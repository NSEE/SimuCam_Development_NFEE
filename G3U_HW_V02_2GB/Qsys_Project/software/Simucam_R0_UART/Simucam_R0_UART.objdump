
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0005305c memsz 0x0006d2d0 flags rwx
    LOAD off    0x00055000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00055000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004b018  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00006014  8114b274  8114b274  0004c274  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81151288  81151288  00052288  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a274  8115307c  8115307c  0005407c  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116d2f0  8116d2f0  00055000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00055000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00055000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001da0  00000000  00000000  00055028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00071f52  00000000  00000000  00056dc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00016c73  00000000  00000000  000c8d1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00022f2d  00000000  00000000  000df98d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009a2c  00000000  00000000  001028bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000cb82  00000000  00000000  0010c2e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026fb3  00000000  00000000  00118e6a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013fe20  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000023b8  00000000  00000000  0013fe60  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  0014e6f9  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0014e6ff  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0014e70b  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0014e70c  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0014e70d  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0014e711  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0014e715  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0014e719  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  0014e724  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0014e72e  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0014e738  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003e  00000000  00000000  0014e749  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  0014e787  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114b274 l    d  .rodata	00000000 .rodata
81151288 l    d  .rwdata	00000000 .rwdata
8115307c l    d  .bss	00000000 .bss
8116d2f0 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
811047e0 l     F .text	00000050 uliCommReadReg
8110478c l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81105020 l     F .text	00000050 uliDpktReadReg
81104fcc l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
811530a0 l     O .bss	00000004 viCh1HoldContext
811530a4 l     O .bss	00000004 viCh2HoldContext
811530a8 l     O .bss	00000004 viCh3HoldContext
811530ac l     O .bss	00000004 viCh4HoldContext
811530b0 l     O .bss	00000004 viCh5HoldContext
811530b4 l     O .bss	00000004 viCh6HoldContext
811530b8 l     O .bss	00000004 viCh7HoldContext
811530bc l     O .bss	00000004 viCh8HoldContext
81106c64 l     F .text	00000054 vFeebWriteReg
81106cb8 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
811530c0 l     O .bss	00000004 viCh1HoldContext
811530c4 l     O .bss	00000004 viCh2HoldContext
811530c8 l     O .bss	00000004 viCh3HoldContext
811530cc l     O .bss	00000004 viCh4HoldContext
811530d0 l     O .bss	00000004 viCh5HoldContext
811530d4 l     O .bss	00000004 viCh6HoldContext
811530d8 l     O .bss	00000004 viCh7HoldContext
811530dc l     O .bss	00000004 viCh8HoldContext
81109ebc l     F .text	00000054 vRmapWriteReg
81109f60 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110a894 l     F .text	00000050 uliSpwcReadReg
8110a840 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
81152fa4 l     O .rwdata	00000001 ucIoValue
8110aa94 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110b384 l     F .text	0000013c msgdma_write_extended_descriptor
8110b4c0 l     F .text	00000164 msgdma_construct_extended_descriptor
8110b624 l     F .text	00000240 msgdma_descriptor_async_transfer
8110b864 l     F .text	00000380 msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110c364 l     F .text	00000054 vRstcWriteReg
8110c3b8 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
811530e4 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
811530ec l     O .bss	00000004 pxNFee.5679
811530f0 l     O .bss	00000004 incrementador.5684
811530f4 l     O .bss	00000004 tCodFeeTask.5682
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
811530fa l     O .bss	00000004 xRAckLocal.5606
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81153100 l     O .bss	00000004 bDmaBack.5647
81153104 l     O .bss	00000001 ucWhoGetDMA.5648
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
81153106 l     O .bss	00000004 xSAckLocal.5591
00000000 l    df *ABS*	00000000 parser_comm_task.c
81153280 l     O .bss	0000004c PreParsedLocal.5644
811532cc l     O .bss	00000054 xTcPusL.5643
00000000 l    df *ABS*	00000000 receiver_uart_task.c
81153320 l     O .bss	0000004c xPreParsedReader.5636
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8115336c l     O .bss	00000054 xPusLocal.5879
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114eb97 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 atoll.c
00000000 l    df *ABS*	00000000 ctype_.c
811506c9 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81151288 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
811229a4 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoll.c
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81150896 l     O .rodata	00000010 zeroes.4389
811508a6 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
811508b6 l     O .rodata	00000010 zeroes.4404
81127920 l     F .text	000000c4 __sbprintf
811508c6 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
811508de l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
81129608 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112b158 l     F .text	00000008 __fp_unlock
8112b16c l     F .text	000001a4 __sinit.part.1
8112b310 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81151ad4 l     O .rwdata	00000020 lc_ctype_charset
81151ab4 l     O .rwdata	00000020 lc_message_charset
81151af4 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8115091c l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8112e180 l     F .text	0000006c sulp
81150a64 l     O .rodata	00000014 fpi.2737
81150a78 l     O .rodata	00000028 tinytens
81150a50 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81150ab0 l     O .rodata	00000010 blanks.4332
81150aa0 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
81131508 l     F .text	00000104 __sprint_r.part.0
81150ad0 l     O .rodata	00000010 blanks.4348
81150ac0 l     O .rodata	00000010 zeroes.4349
81132aa4 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
81132f58 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81136134 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81136278 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
811362ac l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81136530 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
81136628 l       .text	00000000 tx_next_char
81136650 l       .text	00000000 end_tx
81136630 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
8113712c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
811373a8 l     F .text	00000044 alt_get_errno
811373ec l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81137614 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81152fec l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81137bb4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81152ff8 l     O .rwdata	00000004 lockid
811531c8 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81152ffc l     O .rwdata	00000004 lockid
811531d0 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
81139640 l     F .text	00000050 OS_InitMisc
81139690 l     F .text	00000074 OS_InitRdyList
81139814 l     F .text	000000ec OS_InitTCBList
81139558 l     F .text	000000e8 OS_InitEventList
81139704 l     F .text	00000088 OS_InitTaskIdle
8113978c l     F .text	00000088 OS_InitTaskStat
81139aa4 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8113b8bc l     F .text	000000fc OS_FlagTaskRdy
8113b66c l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113d1a8 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81141bd8 l     F .text	00000044 OSTmr_Lock
81141678 l     F .text	00000074 OSTmr_Alloc
81141c1c l     F .text	0000003c OSTmr_Unlock
81141adc l     F .text	000000fc OSTmr_Unlink
811416ec l     F .text	000000a4 OSTmr_Free
8114198c l     F .text	00000150 OSTmr_Link
81141904 l     F .text	00000088 OSTmr_InitTask
81141c58 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81141d68 l     F .text	0000003c alt_dev_reg
81151d70 l     O .rwdata	0000106c jtag_uart_0
81152ddc l     O .rwdata	000000d0 rs232_uart
81152eac l     O .rwdata	00000064 dma_DDR_M1
81152f10 l     O .rwdata	00000064 dma_DDR_M2
81152f74 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
811465f8 l     F .text	000002bc altera_avalon_jtag_uart_irq
811468b4 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
811470b8 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
81147450 l     F .text	000000a4 altera_avalon_uart_irq
811474f4 l     F .text	00000140 altera_avalon_uart_rxirq
81147634 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
8114783c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81147af0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81147d74 l     F .text	00000044 alt_get_errno
81147db8 l     F .text	0000009c alt_msgdma_write_standard_descriptor
81147e54 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81147f88 l     F .text	0000018c alt_msgdma_irq
81148114 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
811481a8 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
81148304 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81148644 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81148d4c l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81148df8 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
81149fc4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
8114a608 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81153278 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8115327c g     O .bss	00000004 alt_instruction_exception_handler
8110718c g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
81153b00 g     O .bss	00001000 vFeeTask0_stk
8111bbf8 g     F .text	0000004c vFailDeleteInitialization
8111a410 g     F .text	00000fd0 vLoadDebugConfs
8115324c g     O .bss	00000004 aux_status_register
81154b00 g     O .bss	00001000 vInAckHandlerTask_stk
81149d80 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811074d4 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110ca04 g     F .text	0000004c vSyncInitIrq
81116be8 g     F .text	00000284 vCheckRetransmission128
8112d804 g     F .text	0000007c _mprec_log10
8110cc0c g     F .text	00000040 bSyncSetMbt
8111d1bc g     F .text	00000054 vFailRequestDMAFromIRQ
8110ac78 g     F .text	00000108 I2C_Read
8115304a g     O .rwdata	00000002 OSTaskNameSize
81153110 g     O .bss	00000004 xWaitSyncQFee
81155b00 g     O .bss	00000260 xBuffer64
8112d8f8 g     F .text	0000008c __any_on
8112c2cc g     F .text	0000005c _isatty_r
81150928 g     O .rodata	00000028 __mprec_tinytens
8110747c g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
8113724c g     F .text	0000015c alt_main
81106520 g     F .text	00000078 bFeebGetRightBufferEmpty
811228c8 g     F .text	000000c8 _puts_r
81105768 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
811531d8 g     O .bss	00000004 OSTmrFreeList
8116d1f0 g     O .bss	00000100 alt_irq
8112c43c g     F .text	00000068 _lseek_r
8111e4a8 g     F .text	00000030 vChangeDefaultAutoResetSync
8113c11c g     F .text	000000d4 OS_MemInit
8111d168 g     F .text	00000054 vFailRequestDMA
81106598 g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
81119708 g     F .text	000009d8 vLoadDefaultETHConf
81112058 g     F .text	0000014c bCheckInAck64
81155d60 g     O .bss	00000150 xPus
81140bb8 g     F .text	00000068 OSTimeSet
81115894 g     F .text	0000008c vPusType250run
8112b510 g     F .text	000000ac __sflags
8111cb3c g     F .text	00000068 vCoudlNotCreateNFee2Task
8111cf28 g     F .text	0000004c vCouldNotGetMutexMebPus
81135dd8 g     F .text	00000088 .hidden __eqdf2
81115f60 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111e394 g     F .text	00000034 vLoadDefaultSyncSource
8111b690 g     F .text	0000004c vFailCreateMutexDMA
81142268 g     F .text	000001ac Check_for_Master_Boot_Record
81166c04 g     O .bss	00000010 OSTmrWheelTbl
81107574 g     F .text	00000050 uliRmapCh3WriteCmdAddress
81148b0c g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
81155eb0 g     O .bss	00000020 xFeeQueueTBL3
811382a4 g     F .text	00000594 OSEventPendMulti
81153114 g     O .bss	00000004 xNfeeSchedule
8116d2f0 g       *ABS*	00000000 __alt_heap_start
8114ac40 g     F .text	0000002c OSTaskCreateHook
811460e0 g     F .text	000001c4 alt_up_sd_card_fclose
81153118 g     O .bss	00000004 xSemCountBuffer64
81104550 g     F .text	0000016c bCommSetGlobalIrqEn
81107978 g     F .text	00000088 bRmapGetIrqControl
8112270c g     F .text	00000044 printf
811530e1 g     O .bss	00000001 SspdConfigControl
8110d028 g     F .text	00000054 bSyncCtrReset
81153022 g     O .rwdata	00000002 OSMboxEn
81110168 g     F .text	00000424 vQCmdFeeRMAPWaitingSync
8111f020 g     F .text	000000a4 aatoh
8113889c g     F .text	00000054 OSIntEnter
81133bc4 g     F .text	000000a4 _wcrtomb_r
81105674 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111bb60 g     F .text	0000004c vFailReceiverCreate
8115311c g     O .bss	00000004 xQMaskDataCtrl
811051c8 g     F .text	00000040 vFeebCh2HandleIrq
81122e30 g     F .text	00000064 __sseek
8112b4c0 g     F .text	00000010 __sinit
8110bca4 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
81129288 g     F .text	00000148 __swbuf_r
811173c0 g     F .text	00000470 bResourcesInitRTOS
8110a3e0 g     F .text	000000f4 bSpwcGetLinkError
81153032 g     O .rwdata	00000002 OSQEn
8110f7f4 g     F .text	00000518 vQCmdFeeRMAPinStandBy
81106eb4 g     F .text	00000040 vRmapCh4HandleIrq
8112c358 g     F .text	00000084 _setlocale_r
81155ed0 g     O .bss	00000020 SyncTBL2
81152fa8 g     O .rwdata	00000004 LedsPainelControl
811533e8 g     O .bss	00000100 cDebugBuffer
8112b318 g     F .text	00000070 __sfmoreglue
811314f0 g     F .text	00000018 ungetc
81105978 g     F .text	000000d4 bFeebCh1SetBufferSize
81137f60 g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114acc0 g     F .text	00000028 OSTaskStatHook
81115dbc g     F .text	00000088 vSendCmdQToNFeeCTRL
8111e404 g     F .text	00000030 vChangeDefaultSyncSource
811531dc g     O .bss	00000001 OSLockNesting
811531e0 g     O .bss	00000004 OSTmrSemSignal
8111d5e8 g     F .text	0000023c vNFeeStructureInit
81153120 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
8112e1ec g     F .text	00001600 _strtod_r
81153124 g     O .bss	00000004 xSemCountSenderACK
8111f1d8 g     F .text	00000448 .hidden __divsf3
81153270 g     O .bss	00000004 current_sector_modified
81153070 g     O .rwdata	00000002 OSDataSize
811531e4 g     O .bss	00000001 OSRunning
8110a6bc g     F .text	00000184 bSpwcInitCh
81136f14 g     F .text	00000064 alt_log_jtag_uart_isr_proc
81155ef0 g     O .bss	00001000 senderTask_stk
8110846c g     F .text	00000094 bRmapGetMemConfigStat
81153128 g     O .bss	00000004 fp
81156ef0 g     O .bss	00000048 xNfeeScheduleTBL
81111f10 g     F .text	00000148 bCheckInAck128
8112c7cc g     F .text	0000015c memmove
8114ad3c g     F .text	0000002c OSInitHookBegin
8110d4c4 g     F .text	00000074 bSyncCtrCh8OutEnable
811106f8 g     F .text	00000098 bEnableDbBuffer
81153068 g     O .rwdata	00000002 OSTmrSize
8112b4a8 g     F .text	00000018 _cleanup
8111e8c4 g     F .text	00000040 siCloseFile
81106ae0 g     F .text	00000184 bFeebInitCh
8112c928 g     F .text	000000b0 _Balloc
8111e434 g     F .text	00000038 vLoadDefaultAutoResetSync
81107a88 g     F .text	000000d8 bRmapSetCodecConfig
81144cbc g     F .text	000000cc alt_up_sd_card_is_Present
81148a4c g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81153084 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
81141f90 g     F .text	00000054 Save_Modified_Sector
811058c8 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
811531e8 g     O .bss	00000004 OSIdleCtr
811531a4 g     O .bss	00000001 alt_log_write_on_flag
8110a8e4 g     F .text	0000003c bEnableIsoDrivers
8111fc48 g     F .text	000000dc .hidden __gtdf2
8114a9d0 g     F .text	0000002c altera_nios2_gen2_irq_init
8114aab8 g       .text	00000000 OSStartTsk
8110cd80 g     F .text	00000070 bSyncSetNCycles
81139e14 g     F .text	000002dc OS_TCBInit
811531a7 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111e01c g     F .text	00000078 vInitSimucamBasicHW
81156f38 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110d3dc g     F .text	00000074 bSyncCtrCh6OutEnable
8110aff4 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81153268 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
811531ec g     O .bss	00000002 OSTmrUsed
8115312c g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
811078d0 g     F .text	000000a8 bRmapSetIrqControl
81105cc8 g     F .text	000000d4 bFeebCh5SetBufferSize
81157f38 g     O .bss	00001000 vDataControlTask_stk
8110528c g     F .text	00000084 vFeebCh4HandleIrq
8115306e g     O .rwdata	00000002 OSTmrWheelTblSize
8111dcc4 g     F .text	0000002c cFeeSpwChannelDisable
8115300e g     O .rwdata	00000002 OSEventSize
811531ee g     O .bss	00000001 OSPrioHighRdy
811218a8 g     F .text	00000064 _fstat_r
8114ac6c g     F .text	0000002c OSTaskDelHook
81153180 g     O .bss	00000004 errno
8110d7b8 g     F .text	0000003c uliSyncGetCtr
81129218 g     F .text	0000001c __svfscanf
81122da4 g     F .text	00000008 __seofread
8114aa98 g       .text	00000000 OSStartHighRdy
8111d548 g     F .text	00000028 vEvtChangeFeeControllerMode
81110944 g     F .text	00000968 vPrintConsoleNFee
81112e50 g     F .text	000000c8 bSendCmdQToNFeeInst
81106f74 g     F .text	00000040 vRmapCh7HandleIrq
8113f5e8 g     F .text	000001ec OSTaskCreateExt
81166bd8 g     O .bss	00000011 alt_log_write_buf
81104a5c g     F .text	0000012c bDpktGetPacketConfig
81107704 g     F .text	00000050 uliRmapCh8WriteCmdAddress
8111bf1c g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
81130034 g     F .text	00001244 ___svfiprintf_internal_r
811149ec g     F .text	00000364 bPreParserV2
8113b19c g     F .text	00000068 OSFlagPendGetFlagsRdy
8115304e g     O .rwdata	00000002 OSTaskStatStkSize
811066d0 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
8113a2e8 g     F .text	00000310 OSFlagAccept
8113d8c4 g     F .text	000000c0 OSQFlush
811538e8 g     O .bss	00000118 xRmap
8113d340 g     F .text	00000148 OSQAccept
811531b8 g     O .bss	00000004 alt_argv
8115afa0 g       *ABS*	00000000 _gp
8111b828 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81137a78 g     F .text	0000013c usleep
81145294 g     F .text	00000384 alt_up_sd_card_fopen
8111e730 g     F .text	00000030 bSDcardIsPresent
81114d50 g     F .text	00000178 vSenderComTask
81144dfc g     F .text	000000d8 alt_up_sd_card_find_first
8113f434 g     F .text	000001b4 OSTaskCreate
8111c0bc g     F .text	00000068 vFailSendNack
8115325c g     O .bss	00000004 command_argument_register
8113ef3c g     F .text	000004f8 OSTaskChangePrio
81115458 g     F .text	000000ac vPusMebInTaskConfigMode
8111c834 g     F .text	00000088 vCouldNotSendTMPusCommand
811531d4 g     O .bss	00000004 alt_heapsem
8111db64 g     F .text	000000b0 vResetMemCCDFEE
8110b28c g     F .text	00000080 bSetBoardLeds
8113a0f0 g     F .text	000001f8 OSDebugInit
8113f7d4 g     F .text	0000034c OSTaskDel
8113c1f0 g     F .text	000001ac OSMutexAccept
81158f38 g     O .bss	000002b8 xSimMeb
8111df00 g     F .text	00000040 vSetTimeCode
811495f4 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
81153130 g     O .bss	00000004 xSemCountPreParsed
81151b54 g     O .rwdata	00000180 alt_fd_list
81105818 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81151cf0 g     O .rwdata	0000001d alt_log_msg_alt_main
81166c14 g     O .bss	00000840 OSFlagTbl
81107214 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8111b990 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
81107614 g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111e2ec g     F .text	0000003c vLoadDefaultRTValue
81139320 g     F .text	000000c0 OS_EventTaskRemove
811591f0 g     O .bss	00001000 vFeeTask5_stk
811531a6 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
81144510 g     F .text	00000134 find_first_empty_record_in_root_directory
8114a0b4 g     F .text	00000098 alt_find_dev
811223f4 g     F .text	00000150 memcpy
81133890 g     F .text	00000264 __hexnan
81104e58 g     F .text	00000174 bDpktInitCh
8115a1f0 g     O .bss	00000160 xBuffer32
81153038 g     O .rwdata	00000002 OSRdyTblSize
81167454 g     O .bss	000001a0 OSTmrTbl
8112b160 g     F .text	0000000c _cleanup_r
81120dc8 g     F .text	000000e4 .hidden __floatsidf
81119330 g     F .text	000001a8 vSendPusTM64
8110cb7c g     F .text	0000004c ucSyncStatusErrorCode
81115ecc g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111ddc0 g     F .text	00000034 cFeeRMAPLogDisable
811132d8 g     F .text	00000df0 vParserCommTask
8114a6d4 g     F .text	00000084 alt_io_redirect
8111dd54 g     F .text	00000034 cFeeRMAPEchoingDisable
81135e60 g     F .text	000000f4 .hidden __ltdf2
8111ce74 g     F .text	0000004c vFailSendPUStoMebTask
81107424 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
81106194 g     F .text	000000d4 bFeebSetIrqControl
8111c62c g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
81153134 g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
8115309c g     O .bss	00000004 EDpktMode
81149a7c g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81149dc4 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110d0d0 g     F .text	00000054 bSyncCtrErrInj
81149d24 g     F .text	0000005c alt_msgdma_register_callback
8111a0e0 g     F .text	00000330 vShowEthConfig
8111e094 g     F .text	00000030 bLogWriteSDCard
8111bcac g     F .text	00000068 vFailSetCountSemaphorexBuffer64
81122990 g     F .text	00000014 puts
8111e944 g     F .text	000002bc bInitSync
8114ade4 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110c8b0 g     F .text	00000128 vSyncHandleIrq
81138034 g     F .text	00000128 OSEventNameGet
811054dc g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8115301c g     O .rwdata	00000002 OSFlagMax
8112c558 g     F .text	000000e0 mbrtowc
81144108 g     F .text	000001b4 find_first_empty_cluster
81115fe8 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110d368 g     F .text	00000074 bSyncCtrCh5OutEnable
811530e8 g     O .bss	00000001 vucN
8112df58 g     F .text	00000074 __fpclassifyd
8110cadc g     F .text	00000054 bSyncStatusExtnIrq
81129234 g     F .text	00000054 _vfscanf_r
8113c870 g     F .text	000005a4 OSMutexPend
8112d758 g     F .text	000000ac __ratio
81144bf8 g     F .text	000000c4 alt_up_sd_card_open_dev
8111c8bc g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
811388f0 g     F .text	00000100 OSIntExit
8110cc4c g     F .text	00000040 bSyncSetBt
81132a88 g     F .text	0000001c __vfiprintf_internal
8111cf74 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
81153056 g     O .rwdata	00000002 OSTCBSize
81105498 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
811531ef g     O .bss	00000001 OSPrioCur
81146b28 g     F .text	000002c4 altera_avalon_jtag_uart_read
811492bc g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
811226d4 g     F .text	00000038 _printf_r
8113497c g     F .text	00000064 .hidden __udivsi3
81136574 g     F .text	000000ac isatty
811530e0 g     O .bss	00000001 LedsBoardControl
81153138 g     O .bss	00000004 xSemCountReceivedACK
8115303c g     O .rwdata	00000002 OSStkWidth
8112c328 g     F .text	00000030 iswspace
81150978 g     O .rodata	000000c8 __mprec_tens
81153030 g     O .rwdata	00000002 OSPtrSize
8111d210 g     F .text	00000054 vFailSendRMAPFromIRQ
8111ccdc g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
8112c3dc g     F .text	0000000c __locale_charset
8110d280 g     F .text	00000074 bSyncCtrCh3OutEnable
81123220 g     F .text	0000001c strtoll
81134b6c g     F .text	000000c8 .hidden __lesf2
81153010 g     O .rwdata	00000002 OSEventTblSize
8111f15c g     F .text	0000007c .hidden __fixunsdfsi
8114a9fc g       .text	00000000 OSCtxSw
8110ad80 g     F .text	00000160 I2C_MultipleRead
811370b8 g     F .text	00000074 alt_log_system_clock
8115318c g     O .bss	00000004 __malloc_top_pad
811531f0 g     O .bss	00000004 OSTCBList
81141638 g     F .text	00000040 OSTmrSignal
8115319c g     O .bss	00000004 alt_fd_list_lock
8112fb60 g     F .text	0000001c strtoul
81152fc0 g     O .rwdata	00000004 __mb_cur_max
8112c40c g     F .text	0000000c _localeconv_r
8112fb7c g     F .text	000002e0 _strtoull_r
8110c2f4 g     F .text	00000070 vRstcHoldDeviceReset
8112cd4c g     F .text	00000044 __i2b
8112bc70 g     F .text	000004c4 __sfvwrite_r
811433e8 g     F .text	000000c0 get_dir_divider_location
811070c0 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
811675f4 g     O .bss	00000c30 OSMemTbl
811531f4 g     O .bss	00000001 OSTickStepState
81136cc8 g     F .text	00000060 alt_log_printf_proc
81104d94 g     F .text	000000c4 bDpktGetPixelDelay
8115a350 g     O .bss	00001800 vReceiverUartTask_stk
81122b9c g     F .text	0000005c _sbrk_r
8115313c g     O .bss	00000004 xSemTimeoutChecker
811430a8 g     F .text	000000cc filename_to_upper_case
811531a8 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
81153034 g     O .rwdata	00000002 OSQMax
81145618 g     F .text	00000090 alt_up_sd_card_set_attributes
8113c56c g     F .text	00000304 OSMutexDel
81168224 g     O .bss	00001000 OSTaskStatStk
8111e760 g     F .text	00000030 bSDcardFAT16Check
8113bd38 g     F .text	000000f8 OSMemNameGet
8111b630 g     F .text	00000060 vFailCreateMutexSResources
81142414 g     F .text	00000284 Read_File_Record_At_Offset
8115bb50 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
81153014 g     O .rwdata	00000002 OSFlagEn
8112d984 g     F .text	00000068 _read_r
8115305a g     O .rwdata	00000002 OSTimeTickHookEn
8113b9b8 g     F .text	000000ac OS_FlagUnlink
8113dd8c g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
81152fdc g     O .rwdata	00000004 alt_max_fd
8111c3d8 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
8113995c g     F .text	00000070 OS_MemCopy
811399cc g     F .text	000000d8 OS_Sched
81143c8c g     F .text	0000047c find_file_in_directory
81132c34 g     F .text	000000f8 _fclose_r
8113bc40 g     F .text	000000f8 OSMemGet
8113fe18 g     F .text	000001bc OSTaskNameSet
8112b128 g     F .text	00000030 fflush
81153188 g     O .bss	00000004 __malloc_max_sbrked_mem
811531f8 g     O .bss	00000004 OSCtxSwCtr
81105d9c g     F .text	000000d4 bFeebCh6SetBufferSize
8114ace8 g     F .text	00000054 OSTimeTickHook
8115bb90 g     O .bss	00001000 vOutAckHandlerTask_stk
811363a8 g     F .text	00000188 alt_irq_register
8115301e g     O .rwdata	00000002 OSFlagNameSize
81120eac g     F .text	00000118 .hidden __extendsfdf2
811393e0 g     F .text	00000108 OS_EventTaskRemoveMulti
8111c9fc g     F .text	00000070 vFailCreateNFEESyncQueue
81144d88 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110ab10 g     F .text	00000088 I2C_TestAdress
81134c34 g     F .text	000008b4 .hidden __adddf3
81166bec g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81134a38 g     F .text	00000078 .hidden __nesf2
8110707c g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
811050fc g     F .text	0000008c usiLineTrDelayCalcPeriodNs
811391c8 g     F .text	00000158 OS_EventTaskWaitMulti
8115cb90 g     O .bss	00000020 SyncTBL4
8112d4f0 g     F .text	00000114 __b2d
81148ff4 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
81153036 g     O .rwdata	00000002 OSQSize
81134344 g     F .text	00000540 .hidden __umoddi3
81137170 g     F .text	000000dc lseek
8113e87c g     F .text	00000214 OSSemPend
8111cec0 g     F .text	00000068 vCouldNotGetCmdQueueMeb
81107bec g     F .text	00000160 bRmapGetCodecStatus
8110a4d4 g     F .text	000000d0 bSpwcGetLinkStatus
811068c0 g     F .text	00000088 bFeebGetWindowing
81152fb0 g     O .rwdata	00000004 _global_impure_ptr
8110c864 g     F .text	0000004c bSSDisplayUpdate
811211f4 g     F .text	0000000c _atoll_r
8114374c g     F .text	00000540 get_home_directory_cluster_for_file
8112d9ec g     F .text	0000056c _realloc_r
81153020 g     O .rwdata	00000002 OSLowestPrio
8116d2f0 g       *ABS*	00000000 __bss_end
8114a510 g     F .text	000000f8 alt_iic_isr_register
8114adb8 g     F .text	0000002c OSTCBInitHook
81153066 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81137968 g     F .text	00000110 alt_tick
81107754 g     F .text	0000017c vRmapInitIrq
8111b928 g     F .text	00000068 vFailGetMutexSenderTask
8110c214 g     F .text	0000006c vRstcSimucamReset
811107fc g     F .text	000000a4 bSendRequestNFeeCtrl
81150ae0 g     O .rodata	00000100 __hexdig
81149b70 g     F .text	000001b4 alt_msgdma_init
81133dc4 g     F .text	00000580 .hidden __udivdi3
811146d4 g     F .text	0000017c setPreAckSenderFreePos
81132eac g     F .text	00000024 _fputwc_r
81153008 g     O .rwdata	00000002 OSEventEn
81150950 g     O .rodata	00000028 __mprec_bigtens
8112cb28 g     F .text	0000010c __s2b
81153062 g     O .rwdata	00000002 OSTmrCfgNameSize
8115cbb0 g     O .bss	00000020 xFeeQueueTBL4
8110cd0c g     F .text	00000074 bSyncSetPolarity
81116e6c g     F .text	0000028c vCheckRetransmission64
81135f54 g     F .text	000000b0 .hidden __floatunsidf
811531ac g     O .bss	00000004 alt_system_clock_in_sec
81136ec0 g     F .text	00000054 alt_log_jtag_uart_startup_info
8111beb4 g     F .text	00000068 vFailFoundBufferRetransmission
8112d228 g     F .text	00000060 __mcmp
81153274 g     O .bss	00000004 current_sector_index
811472e8 g     F .text	00000168 altera_avalon_uart_init
81149e4c g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
811040ec g     F .text	00000464 bSdmaDmaM2Transfer
8111df40 g     F .text	00000034 vResetTimeCode
8111dc98 g     F .text	0000002c cFeeSpwChannelEnable
8112b4e0 g     F .text	00000018 __fp_lock_all
8111d3a4 g     F .text	0000004c vFailSendMsgDataCTRL
8114a4bc g     F .text	00000054 alt_ic_irq_enabled
8110ab98 g     F .text	000000e0 I2C_Write
811072c4 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
811531fc g     O .bss	00000002 OSTmrFree
8113b7d4 g     F .text	000000e8 OS_FlagInit
811378c4 g     F .text	000000a4 alt_alarm_stop
81123204 g     F .text	0000001c strtol
811531a5 g     O .bss	00000001 alt_log_sys_clk_on_flag
81140de4 g     F .text	00000140 OSTmrDel
81142180 g     F .text	000000e8 mark_cluster
81153044 g     O .rwdata	00000002 OSTaskIdleStkSize
811531a0 g     O .bss	00000004 alt_irq_active
8113e49c g     F .text	000000b8 OSSemAccept
81121440 g     F .text	0000044c _fseeko_r
81117d04 g     F .text	00000260 vFillMemmoryPattern
81122f80 g     F .text	00000044 strnlen
8113bf4c g     F .text	000000e0 OSMemPut
8113ba64 g     F .text	000001dc OSMemCreate
81153200 g     O .bss	00000004 OSIdleCtrMax
811194d8 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81136710 g     F .text	000005b8 alt_log_private_printf
81151b2c g     O .rwdata	00000028 alt_dev_null
81148c04 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110cccc g     F .text	00000040 bSyncSetOst
81153058 g     O .rwdata	00000002 OSTicksPerSec
81151cd4 g     O .rwdata	00000019 alt_log_msg_bss
81144644 g     F .text	00000194 convert_filename_to_name_extension
81108500 g     F .text	0000104c bRmapSetRmapMemHKArea
81106738 g     F .text	000000e0 bFeebSetBufferSize
81114ec8 g     F .text	00000434 vSimMebTask
8110aee0 g     F .text	00000094 i2c_start
8114a9fc g       .text	00000000 OSIntCtxSw
8111d264 g     F .text	00000054 vFailSendMsgSync
8110d2f4 g     F .text	00000074 bSyncCtrCh4OutEnable
811499e8 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
81136250 g     F .text	00000028 alt_dcache_flush_all
8112cc34 g     F .text	00000068 __hi0bits
81115920 g     F .text	00000114 vPusType251run
81107664 g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111e328 g     F .text	0000003c vChangeRTValue
81153248 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81116a64 g     F .text	00000184 vCheck
8111d598 g     F .text	00000050 vNFeeNotInUse
81120d48 g     F .text	00000080 .hidden __fixdfsi
81112f18 g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81105f44 g     F .text	000000d4 bFeebCh8SetBufferSize
811069d0 g     F .text	00000088 bFeebStopCh
8110d8e4 g     F .text	00000084 uliPerCalcPeriodMs
81112874 g     F .text	000003ec vNFeeControlTask
8115cbd0 g     O .bss	00001000 vInitialTask_stk
81153140 g     O .bss	00000002 usiIdCMD
8115dbd0 g     O .bss	00000020 SyncTBL3
8110cfd4 g     F .text	00000054 bSyncCtrStart
811442bc g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8112f7ec g     F .text	00000018 strtod
81106a58 g     F .text	00000088 bFeebClrCh
81153204 g     O .bss	00000004 OSTCBFreeList
811073cc g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113ea90 g     F .text	00000174 OSSemPendAbort
8111bac8 g     F .text	0000004c vFailGetMacRTC
811075c4 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111c340 g     F .text	0000004c vFailCreateTimerRetransmisison
8111be4c g     F .text	00000068 vFailGetCountSemaphorexBuffer32
811183a0 g     F .text	000002f0 bSendUART128v2
8111e15c g     F .text	000000ec vSimucamStructureInit
81152fd4 g     O .rwdata	00000008 alt_dev_list
81121370 g     F .text	0000004c _fputc_r
81137bf8 g     F .text	0000010c write
81122750 g     F .text	000000a8 _putc_r
8115326c g     O .bss	00000004 device_pointer
8115305c g     O .rwdata	00000002 OSVersionNbr
81134ab0 g     F .text	000000bc .hidden __gtsf2
8111d488 g     F .text	0000004c vFailFlushMEBQueue
811140c8 g     F .text	00000118 getPreParsedPacket
81110698 g     F .text	00000060 bEnableSPWChannel
811362f0 g     F .text	000000b8 fstat
8111dfa8 g     F .text	00000040 vChangeIdNFEEMaster
81121344 g     F .text	0000002c fprintf
8111dd88 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105870 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111c48c g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111ed00 g     F .text	00000058 _reg_write
8111dfe8 g     F .text	00000034 vChangeDefaultIdNFEEMaster
81135e60 g     F .text	000000f4 .hidden __ledf2
81106ef4 g     F .text	00000040 vRmapCh5HandleIrq
8111058c g     F .text	00000054 bDisableRmapIRQ
8115dbf0 g     O .bss	00001000 vStackMonitor_stk
8111c7cc g     F .text	00000068 vCouldNotSendLog
81141064 g     F .text	000001b8 OSTmrRemainGet
81153004 g     O .rwdata	00000004 OSEndiannessTest
8110c408 g     F .text	00000058 v_spi_start
8112cf90 g     F .text	00000148 __pow5mult
81107524 g     F .text	00000050 uliRmapCh2WriteCmdAddress
81131624 g     F .text	00001464 ___vfiprintf_internal_r
81153198 g     O .bss	00000004 __nlocale_changed
811349e0 g     F .text	00000058 .hidden __umodsi3
8110d124 g     F .text	00000074 bSyncCtrSyncOutEnable
8111e790 g     F .text	000000f8 bInitializeSDCard
8111c25c g     F .text	0000004c vFailParserCommTaskCreate
8111c764 g     F .text	00000068 vCouldNotSendReset
81122c3c g     F .text	00000038 _scanf_r
8111c2f4 g     F .text	0000004c vFailOutAckHandlerTaskCreate
81153016 g     O .rwdata	00000002 OSFlagGrpSize
81115504 g     F .text	0000008c vPusType250conf
8115ebf0 g     O .bss	00000058 xInUseRetrans
8110ca8c g     F .text	00000050 bSyncIrqFlagSync
81149054 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8114121c g     F .text	000000ec OSTmrStateGet
8116d2f0 g       *ABS*	00000000 end
81105394 g     F .text	00000084 vFeebCh6HandleIrq
81117f64 g     F .text	00000260 vPrintMemmoryPattern
8111bfec g     F .text	00000068 vNoContentInPreParsedBuffer
8112188c g     F .text	0000001c fseeko
811141e0 g     F .text	00000168 bSendMessagePUStoMebTask
8111c98c g     F .text	00000070 vFailCreateNFEEQueue
811211dc g     F .text	0000000c _atoi_r
81147b34 g     F .text	00000240 altera_avalon_uart_write
81136654 g     F .text	00000054 alt_log_txchar
81121424 g     F .text	0000001c fseek
81118310 g     F .text	00000090 vCCDChangeValues
81146428 g     F .text	000001d0 altera_avalon_jtag_uart_init
81139c5c g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8111b728 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
8114713c g     F .text	00000084 alt_avalon_timer_sc_init
81106818 g     F .text	000000a8 bFeebSetWindowing
81147228 g     F .text	00000068 altera_avalon_uart_write_fd
8112116c g     F .text	00000064 .hidden __clzsi2
81147290 g     F .text	00000058 altera_avalon_uart_close_fd
8115ec48 g     O .bss	00000020 xMebQTBL
81146dec g     F .text	000002cc altera_avalon_jtag_uart_write
81141790 g     F .text	00000174 OSTmr_Init
8115ec68 g     O .bss	00000348 xBuffer128
8112b4d0 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
8112c6e8 g     F .text	000000e4 memchr
81139900 g     F .text	0000005c OS_MemClr
81125704 g     F .text	00002200 ___vfprintf_internal_r
8114aadc g     F .text	00000164 OSTaskStkInit
81122c74 g     F .text	00000060 _sprintf_r
81108198 g     F .text	000002d4 bRmapGetMemConfigArea
81153142 g     O .bss	00000001 SemCount32
8112b958 g     F .text	00000318 _free_r
8114a758 g     F .text	00000234 alt_printf
811192e0 g     F .text	00000050 vTimeoutCheck
8111edb0 g     F .text	000001fc _print_codec_status
8112c3e8 g     F .text	00000010 __locale_mb_cur_max
81138f10 g     F .text	000001a0 OS_EventTaskRdy
81107a00 g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
8114b030 g     F .text	00000188 __call_exitprocs
81112d28 g     F .text	00000128 vPerformActionNFCRunning
81153208 g     O .bss	00000001 OSCPUUsage
8111cc0c g     F .text	00000068 vCoudlNotCreateNFee4Task
81153194 g     O .bss	00000004 __mlocale_changed
81112c60 g     F .text	000000c8 vPerformActionNFCConfig
8110d07c g     F .text	00000054 bSyncCtrOneShot
81152fb8 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110d7f4 g     F .text	0000003c uliSyncReadStatus
811531c0 g     O .bss	00000004 _alt_tick_rate
8113d984 g     F .text	00000294 OSQPend
8112323c g     F .text	000002e8 _strtoll_r
8115efb0 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
81166b78 g     O .bss	00000044 xDefaults
81140708 g     F .text	0000010c OSTimeDly
811157e8 g     F .text	000000ac vPusMebInTaskRunningMode
8110ca50 g     F .text	0000003c vSyncIrqFlagClrSync
8112d0d8 g     F .text	00000150 __lshift
81112fe0 g     F .text	000002f8 vOutAckHandlerTask
81148aac g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
811531c4 g     O .bss	00000004 _alt_nticks
81137658 g     F .text	00000104 read
81141de4 g     F .text	000000f0 alt_sys_init
8111fa24 g     F .text	0000012c .hidden __floatsisf
81107038 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112fe5c g     F .text	000001d8 __ssprint_r
8112266c g     F .text	00000068 _open_r
8111eca0 g     F .text	00000060 bTestSimucamCriticalHW
8110639c g     F .text	0000010c bFeebGetBuffersStatus
8111b3e0 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
81153209 g     O .bss	00000001 OSTaskCtr
81136620 g       .text	00000000 tx_log_str
811152fc g     F .text	0000015c vPusMebTask
81119290 g     F .text	00000050 siPosStr
81115e44 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
81133af4 g     F .text	000000d0 strncmp
8110d830 g     F .text	0000005c bSyncWriteReg
81107374 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
81140814 g     F .text	00000164 OSTimeDlyHMSM
8112cd90 g     F .text	00000200 __multiply
811469c0 g     F .text	00000070 altera_avalon_jtag_uart_close
8110c5d8 g     F .text	00000058 v_spi_end
8111e904 g     F .text	00000040 cGetNextChar
8114af44 g     F .text	000000ec strncpy
811533c0 g     O .bss	00000028 __malloc_current_mallinfo
8115300a g     O .rwdata	00000002 OSEventMax
81134a38 g     F .text	00000078 .hidden __eqsf2
8112d604 g     F .text	00000154 __d2b
8113ec04 g     F .text	00000118 OSSemPost
81105564 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111e364 g     F .text	00000030 vChangeDefaultRTValue
81105458 g     F .text	00000040 vFeebCh8HandleIrq
81153244 g     O .bss	00000004 initialized
81119140 g     F .text	00000100 vSendLog
81138a84 g     F .text	000000e4 OSSchedUnlock
8110c630 g     F .text	00000164 RTCC_SPI_R_MAC
81152fe8 g     O .rwdata	00000004 alt_log_boot_on_flag
811462a4 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112f90c g     F .text	00000254 _strtoul_r
8115eff0 g     O .bss	00000020 xFeeQueueTBL5
8114a25c g     F .text	000000e4 alt_get_fd
8115320c g     O .bss	00000004 OSMemFreeList
81138be0 g     F .text	000000b8 OSStatInit
8111ec6c g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
8116cc88 g     O .bss	00000014 search_data
8110a1c8 g     F .text	00000134 bSpwcSetLink
81136004 g     F .text	00000130 alt_busy_sleep
8113b5a0 g     F .text	000000cc OSFlagQuery
8110d198 g     F .text	00000074 bSyncCtrCh1OutEnable
81153040 g     O .rwdata	00000002 OSTaskCreateExtEn
8111efac g     F .text	00000074 _split_codec_status
811295ac g     F .text	0000005c _close_r
8111c054 g     F .text	00000068 vCouldNotSendEthConfUART
811122f0 g     F .text	00000584 vInitialTask
81136dc8 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
81148f94 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8114aec8 g     F .text	0000007c memcmp
81138ee8 g     F .text	00000028 OS_Dummy
81146374 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116d2f0 g       *ABS*	00000000 __alt_stack_base
81105e70 g     F .text	000000d4 bFeebCh7SetBufferSize
811463cc g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
811055a8 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8112190c g     F .text	000000d4 _fwrite_r
81116178 g     F .text	000000a4 vReleaseSyncMessages
811490b4 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
811056b8 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
81129450 g     F .text	0000015c __swsetup_r
81169224 g     O .bss	00000300 OSQTbl
8111d044 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
81166bbc g     O .bss	0000001c xConfEth
811354e8 g     F .text	000008f0 .hidden __divdf3
8111e3c8 g     F .text	0000003c vChangeSyncSource
8112b388 g     F .text	00000120 __sfp
8116cc9c g     O .bss	00000054 boot_sector_data
8111cfdc g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
8110a634 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112d880 g     F .text	00000078 __copybits
811516ac g     O .rwdata	00000408 __malloc_av_
8112b4dc g     F .text	00000004 __sinit_lock_release
8115307c g     O .bss	00000004 uliInitialState
8110af74 g     F .text	00000080 i2c_stop
8111f0c4 g     F .text	00000064 Verif_Error
8111f128 g     F .text	00000034 toInt
8111b874 g     F .text	0000004c vFailSendPreAckSenderSemaphore
81153210 g     O .bss	00000004 OSTCBHighRdy
8111fd24 g     F .text	00000720 .hidden __muldf3
81122d48 g     F .text	0000005c __sread
8112b7f0 g     F .text	0000003c fread
81153214 g     O .bss	00000004 OSQFreeList
8114a14c g     F .text	00000110 alt_find_file
8114a008 g     F .text	000000ac alt_dev_llist_insert
81137e38 g     F .text	00000128 __malloc_lock
81121314 g     F .text	00000030 _fprintf_r
811377c8 g     F .text	000000fc sbrk
8111dc14 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111bde4 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
81123524 g     F .text	000021e0 ___svfprintf_internal_r
81119680 g     F .text	00000088 vTMPusTestConnection
81153144 g     O .bss	00000004 xMebQ
8113815c g     F .text	00000148 OSEventNameSet
8112b0c4 g     F .text	00000064 _fflush_r
81132b68 g     F .text	000000cc _calloc_r
81153218 g     O .bss	00000001 OSRdyGrp
8111d358 g     F .text	0000004c vFailSendMsgFeeCTRL
8110cbc8 g     F .text	00000044 ucSyncStatusCycleNumber
81107b60 g     F .text	0000008c bRmapGetCodecConfig
81141308 g     F .text	00000148 OSTmrStart
81105310 g     F .text	00000084 vFeebCh5HandleIrq
811212fc g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8115307c g       *ABS*	00000000 __bss_start
81105bf4 g     F .text	000000d4 bFeebCh4SetBufferSize
81122544 g     F .text	00000128 memset
81114598 g     F .text	0000013c setPreParsedFreePos
8110f3c8 g     F .text	000001fc vQCmdFEEinStandBy
81149b10 g     F .text	00000060 alt_msgdma_open
8111e520 g     F .text	00000210 pattern_createPattern
81117b44 g     F .text	000001c0 main
8111b9f8 g     F .text	00000068 vFailGetMutexReceiverTask
8115f010 g     O .bss	00001000 vNFeeControlTask_stk
811071d0 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111e280 g     F .text	0000003c vChangeEPValue
8110731c g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
811531bc g     O .bss	00000004 alt_envp
8111d3f0 g     F .text	0000004c vFailFlushQueue
81153184 g     O .bss	00000004 __malloc_max_total_mem
811493b4 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111b484 g     F .text	0000005c ucCrc8wInit
8111c38c g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
8114630c g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110b12c g     F .text	00000160 i2c_read
81160010 g     O .bss	00000020 SyncTBL5
811293d0 g     F .text	00000018 __swbuf
81150de0 g     O .rodata	00000100 OSUnMapTbl
81134b6c g     F .text	000000c8 .hidden __ltsf2
811456a8 g     F .text	00000090 alt_up_sd_card_get_attributes
8112b5bc g     F .text	00000234 _fread_r
8111b8c0 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
8110a920 g     F .text	0000003c bDisableIsoDrivers
8115303a g     O .rwdata	00000002 OSSemEn
81141ed4 g     F .text	000000bc Write_Sector_Data
81145ab8 g     F .text	00000628 alt_up_sd_card_write
81153148 g     O .bss	00000004 xFeeQ
81106600 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
8113b204 g     F .text	0000039c OSFlagPost
81122e94 g     F .text	00000008 __sclose
8111c694 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81132d2c g     F .text	00000014 fclose
811390b0 g     F .text	00000118 OS_EventTaskWait
8111c55c g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
81122fc4 g     F .text	00000240 _strtol_r
81120fc4 g     F .text	000001a8 .hidden __truncdfsf2
81160030 g     O .bss	00000020 xFeeQueueTBL2
81139d40 g     F .text	000000d4 OS_TaskStatStkChk
8113fb20 g     F .text	00000158 OSTaskDelReq
81104b88 g     F .text	000000c4 bDpktGetPacketHeader
81106d08 g     F .text	000000c4 vRmapCh1HandleIrq
81129810 g     F .text	00001690 _dtoa_r
811496d0 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81121be0 g     F .text	00000814 _malloc_r
81160050 g     O .bss	00000020 SyncTBL0
81133d30 g     F .text	00000030 __ascii_wctomb
8113c39c g     F .text	000001d0 OSMutexCreate
8111c4f4 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
811121a4 g     F .text	0000014c bCheckInAck32
81152fe0 g     O .rwdata	00000004 alt_errno
811491fc g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81138b68 g     F .text	00000078 OSStart
8110a2fc g     F .text	000000e4 bSpwcGetLink
8110bd2c g     F .text	000004e8 POWER_SPI_RW
81131278 g     F .text	000000dc __submore
81136d28 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81137dd0 g     F .text	00000068 __env_unlock
8111cad4 g     F .text	00000068 vCoudlNotCreateNFee1Task
8112c134 g     F .text	000000cc _fwalk
8113ffd4 g     F .text	000001dc OSTaskResume
8113c02c g     F .text	000000f0 OSMemQuery
8115304c g     O .rwdata	00000002 OSTaskStatEn
8116d2f0 g       *ABS*	00000000 __alt_stack_limit
8115308c g     O .bss	00000004 ECommSpwCh
8111e46c g     F .text	0000003c vChangeAutoResetSync
8112c684 g     F .text	00000064 _mbtowc_r
81111bc0 g     F .text	00000350 vInAckHandlerTaskV2
81153026 g     O .rwdata	00000002 OSMemMax
8113defc g     F .text	00000178 OSQPostFront
811227f8 g     F .text	000000d0 putc
81134884 g     F .text	00000084 .hidden __divsi3
81153219 g     O .bss	00000006 OSRdyTbl
81153000 g     O .rwdata	00000002 OSDebugEn
81151d44 g     O .rwdata	0000002a alt_log_msg_cache
8112b82c g     F .text	0000012c _malloc_trim_r
81109d18 g     F .text	000001a4 bRmapInitCh
81153178 g     O .bss	00000008 xSdHandle
8111f620 g     F .text	00000404 .hidden __mulsf3
81153018 g     O .rwdata	00000002 OSFlagNodeSize
81153080 g     O .bss	00000004 pnt_memory
8111e4d8 g     F .text	00000048 vSyncReset
81111698 g     F .text	00000528 vLoadCtemp
8110cc8c g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
81153250 g     O .bss	00000004 status_register
81153060 g     O .rwdata	00000002 OSTmrCfgMax
8110d620 g     F .text	00000074 bSyncIrqFlagClrError
8111c124 g     F .text	00000068 vFailSetPreAckSenderBuffer
8112e0a4 g     F .text	000000dc strcmp
81153258 g     O .bss	00000004 command_register
8113d488 g     F .text	000001b4 OSQCreate
8113fc78 g     F .text	000001a0 OSTaskNameGet
81160070 g     O .bss	00001000 vFeeTask4_stk
81161070 g     O .bss	00000018 xReceivedACK
8113e074 g     F .text	00000214 OSQPostOpt
81138c98 g     F .text	00000228 OSTimeTick
81153048 g     O .rwdata	00000002 OSTaskMax
8113e554 g     F .text	000000e0 OSSemCreate
8115306c g     O .rwdata	00000002 OSTmrWheelSize
8111c924 g     F .text	00000068 vFailCreateScheduleQueue
8111ed58 g     F .text	00000058 _reg_read
8113d034 g     F .text	00000174 OSMutexQuery
811108a0 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81135dd8 g     F .text	00000088 .hidden __nedf2
81153042 g     O .rwdata	00000002 OSTaskDelEn
8111e248 g     F .text	00000038 vLoadDefaultEPValue
81161088 g     O .bss	00001000 vFeeTask1_stk
8110d450 g     F .text	00000074 bSyncCtrCh7OutEnable
8113ed1c g     F .text	00000118 OSSemQuery
8113d63c g     F .text	00000288 OSQDel
8113dc18 g     F .text	00000174 OSQPendAbort
8115314c g     O .bss	00000004 xMutexPreParsed
81141da4 g     F .text	00000040 alt_irq_init
8113775c g     F .text	0000006c alt_release_fd
811420c4 g     F .text	000000bc get_cluster_flag
8110d694 g     F .text	00000074 bSyncIrqFlagClrBlank
81149e08 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110c9d8 g     F .text	0000002c vSyncClearCounter
811112ac g     F .text	000003ec bPrepareDoubleBuffer
81151d10 g     O .rwdata	00000031 alt_log_msg_stackpointer
81122cd4 g     F .text	00000074 sprintf
811504c8 g     O .rodata	00000100 .hidden __clz_tab
81142698 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
8111ba60 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
81153190 g     O .bss	00000004 _PathLocale
8110d760 g     F .text	00000058 bSyncIrqFlagBlank
8110bbe4 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
81141450 g     F .text	000001e8 OSTmrStop
81109f10 g     F .text	00000050 uliRmapReadReg
81119240 g     F .text	00000050 usiGetIdCMD
8110d88c g     F .text	00000058 uliSyncReadReg
8112f804 g     F .text	00000108 strtof
81105208 g     F .text	00000084 vFeebCh3HandleIrq
81134ab0 g     F .text	000000bc .hidden __gesf2
81122e9c g     F .text	0000004c strcspn
811293e8 g     F .text	00000068 _write_r
8110c280 g     F .text	00000074 vRstcReleaseDeviceReset
8111c2a8 g     F .text	0000004c vFailInAckHandlerTaskCreate
811389f0 g     F .text	00000094 OSSchedLock
8111cba4 g     F .text	00000068 vCoudlNotCreateNFee3Task
8112c418 g     F .text	00000018 setlocale
8114915c g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
81169524 g     O .bss	00000800 OSTmrTaskStk
81122bf8 g     F .text	00000044 scanf
8111ce14 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
8113a5f8 g     F .text	00000110 OSFlagCreate
8114292c g     F .text	00000688 Check_for_DOS_FAT
81116070 g     F .text	00000064 vMebInit
811447d8 g     F .text	000002d0 create_file
8112e09c g     F .text	00000008 nanf
81152fb4 g     O .rwdata	00000004 _impure_ptr
81153254 g     O .bss	00000004 CSD_register_w0
811531b4 g     O .bss	00000004 alt_argc
8111bd7c g     F .text	00000068 vFailGetCountSemaphorexBuffer128
8112aea0 g     F .text	00000224 __sflush_r
8112c4a4 g     F .text	000000b4 _mbrtowc_r
8110a5a4 g     F .text	00000090 bSpwcGetTimecode
8112c404 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
81153090 g     O .bss	00000004 ESdmaBufferSide
81153012 g     O .rwdata	00000002 OSEventMultiEn
81121420 g     F .text	00000004 _fseek_r
81162088 g     O .bss	00001800 vParserCommTask_stk
8111b5c0 g     F .text	00000070 printErrorTask
8111e2bc g     F .text	00000030 vChangeDefaultEPValue
811170f8 g     F .text	000002c8 vCheckRetransmission32
81140c20 g     F .text	000001c4 OSTmrCreate
8111621c g     F .text	000007dc vStackMonitor
811229c0 g     F .text	000001dc __srefill_r
8110a95c g     F .text	0000003c bEnableLvdsBoard
81153150 g     O .bss	00000004 xMutexBuffer32
811530f8 g     O .bss	00000001 ucIterationSide
81106dcc g     F .text	000000a8 vRmapCh2HandleIrq
8113a708 g     F .text	00000250 OSFlagDel
81153220 g     O .bss	00000004 OSEventFreeList
8110a9d4 g     F .text	000000c0 bSetPreEmphasys
8110f204 g     F .text	000001c4 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112c638 g     F .text	0000004c __ascii_mbtowc
8110cf5c g     F .text	00000078 bSyncCtrExtnIrq
81106668 g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112d48c g     F .text	00000064 __ulp
8111ddf4 g     F .text	0000010c vNFeeControlInit
811160d4 g     F .text	000000a4 vSwapMemmory
8113abdc g     F .text	000005c0 OSFlagPend
8115305e g     O .rwdata	00000002 OSTmrEn
8112b4f8 g     F .text	00000018 __fp_unlock_all
81163888 g     O .bss	00000010 xDma
811213bc g     F .text	00000064 fputc
811105e0 g     F .text	00000058 bEnableRmapIRQ
81118988 g     F .text	000002f8 bSendUART32v2
81114850 g     F .text	0000019c setPreAckReceiverFreePos
8110cf1c g     F .text	00000040 bSyncErrInj
81152fcc g     O .rwdata	00000008 alt_fs_list
81163898 g     O .bss	00001000 vSimMebTask_stk
8111cdac g     F .text	00000068 vCoudlNotCreateMebTask
81143174 g     F .text	00000274 check_file_name_for_FAT16_compliance
81164898 g     O .bss	00001000 vFeeTask3_stk
81140f24 g     F .text	00000140 OSTmrNameGet
811534e8 g     O .bss	00000400 xSZData
8110f5c4 g     F .text	00000230 vQCmdFEEinFullPattern
81139b20 g     F .text	0000007c OS_StrCopy
81153260 g     O .bss	00000004 buffer_memory
8111bf84 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
8111e0c4 g     F .text	00000098 vLogWriteNUC
81153028 g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110d5ac g     F .text	00000074 bSyncIrqEnableBlank
8114ad68 g     F .text	00000028 OSInitHookEnd
8111d824 g     F .text	00000340 vUpdateMemMapFEE
8111c1f4 g     F .text	00000068 vFailSetPreAckReceiverBuffer
81105920 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81153054 g     O .rwdata	00000002 OSTCBPrioTblMax
8112c430 g     F .text	0000000c localeconv
8111cd44 g     F .text	00000068 vCoudlNotCreateDataControllerTask
81153154 g     O .bss	00000004 xTimerRetransmission
81114348 g     F .text	00000250 vReceiverUartTask
811531b0 g     O .bss	00000004 alt_log_sys_clk_count
81153050 g     O .rwdata	00000002 OSTaskStatStkChkEn
81136f78 g     F .text	00000140 alt_log_write
81165898 g     O .bss	00001000 vFeeTask2_stk
81153158 g     O .bss	00000004 xMutexBuffer128
81105188 g     F .text	00000040 vFeebCh1HandleIrq
8111ec00 g     F .text	0000003c bStartSync
81105418 g     F .text	00000040 vFeebCh7HandleIrq
8111ec3c g     F .text	00000030 bStopSync
81153094 g     O .bss	00000004 ECommBufferSide
8114a340 g     F .text	00000058 alt_ic_isr_register
81153024 g     O .rwdata	00000002 OSMemEn
81106e74 g     F .text	00000040 vRmapCh3HandleIrq
81152fa0 g     O .rwdata	00000004 alt_stack_limit_value
81115a34 g     F .text	00000388 vPusType252run
8111d30c g     F .text	0000004c vFailSendMsgMasterSyncMeb
811219e0 g     F .text	0000003c fwrite
81153264 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8115302e g     O .rwdata	00000002 OSMutexEn
8111d0ac g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
8115307c g       *ABS*	00000000 _edata
811471c0 g     F .text	00000068 altera_avalon_uart_read_fd
8111df74 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81105070 g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
8116d2f0 g       *ABS*	00000000 _end
8116ccf0 g     O .bss	00000500 active_files
81153224 g     O .bss	00000001 OSIntNesting
8111bb14 g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111dcf0 g     F .text	0000002c cFeeRMAPDump
81105b20 g     F .text	000000d4 bFeebCh3SetBufferSize
8115315c g     O .bss	00000004 xSemCountBuffer32
81132d40 g     F .text	0000016c __fputwc
81153160 g     O .bss	00000004 xQMaskFeeCtrl
8111dc40 g     F .text	0000002c vFeeSpwRMAPChangeConfig
811291a8 g     F .text	00000070 vfscanf
81144aa8 g     F .text	00000150 copy_file_record_name_to_string
81146a30 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81140978 g     F .text	000001dc OSTimeDlyResume
81142fb4 g     F .text	000000f4 Look_for_FAT16
81110638 g     F .text	00000060 bDisableSPWChannel
8113aa88 g     F .text	00000154 OSFlagNameSet
81110790 g     F .text	0000006c bDisAndClrDbBuffer
81153164 g     O .bss	00000004 xMutexBuffer64
81107d4c g     F .text	00000160 bRmapGetCodecError
811401b0 g     F .text	000001c8 OSTaskStkChk
8114a428 g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	0000045c bSdmaDmaM1Transfer
8115302a g     O .rwdata	00000002 OSMemSize
811155e4 g     F .text	00000204 vPusType252conf
8111bc44 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
81122dac g     F .text	00000084 __swrite
81152fbc g     O .rwdata	00000004 __malloc_trim_threshold
8112c3f8 g     F .text	0000000c __locale_msgcharset
81166898 g     O .bss	00000020 xFeeQueueTBL1
81153228 g     O .bss	00000004 OSTCBCur
8111c5c4 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110bce8 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8114ae88 g     F .text	00000040 exit
8113ce14 g     F .text	00000220 OSMutexPost
8110d708 g     F .text	00000058 bSyncIrqFlagError
81144ed4 g     F .text	000003c0 alt_up_sd_card_find_next
8115302c g     O .rwdata	00000002 OSMemTblSize
8112c200 g     F .text	000000cc _fwalk_reent
81149554 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111fb50 g     F .text	000000f8 .hidden __floatunsisf
8112d288 g     F .text	00000204 __mdiff
8111ca6c g     F .text	00000068 vCoudlNotCreateNFee0Task
81106018 g     F .text	0000017c vFeebInitIrq
81104830 g     F .text	0000022c bDpktSetPacketConfig
8111bbac g     F .text	0000004c vFailSenderCreate
81134908 g     F .text	00000074 .hidden __modsi3
8111cc74 g     F .text	00000068 vCoudlNotCreateNFee5Task
8110ce68 g     F .text	0000003c uliSyncGetPer
81106f34 g     F .text	00000040 vRmapCh6HandleIrq
81153168 g     O .bss	00000004 xMutexSenderACK
8111c424 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
81152fac g     O .rwdata	00000004 __ctype_ptr__
8111c18c g     F .text	00000068 vFailSetPreParsedBuffer
81141fe4 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112b4d4 g     F .text	00000004 __sfp_lock_release
81106268 g     F .text	000000ac bFeebGetIrqControl
8111c6fc g     F .text	00000068 vCouldNotSendTurnOff
81138838 g     F .text	00000064 OSInit
8110b30c g     F .text	00000078 bSetPainelLeds
81148c9c g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8115322c g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107eac g     F .text	000002ec bRmapSetMemConfigArea
81140564 g     F .text	0000012c OSTaskQuery
8110d538 g     F .text	00000074 bSyncIrqEnableError
8115316c g     O .bss	00000004 xMutexPus
8113e3ec g     F .text	000000b0 OS_QInit
8112dfcc g     F .text	000000d0 __sccl
811211d0 g     F .text	0000000c atoi
8110da08 g     F .text	00001614 vFeeTask
81139b9c g     F .text	0000005c OS_StrLen
8111d4d4 g     F .text	0000004c vFailFlushNFEEQueue
81105710 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111b4e0 g     F .text	000000e0 vDataControllerInit
8113be30 g     F .text	0000011c OSMemNameSet
811505c8 g     O .rodata	00000101 _ctype_
8110ce2c g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111bd14 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
81153046 g     O .rwdata	00000002 OSTaskProfileEn
8111d520 g     F .text	00000028 vEvtChangeMebMode
81148b6c g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81153170 g     O .bss	00000004 xTxUARTMutex
81153230 g     O .bss	00000004 OSTime
81152fc4 g     O .rwdata	00000004 __mbtowc
811477e0 g     F .text	0000005c altera_avalon_uart_close
8110f01c g     F .text	000001e8 vQCmdFEEinWaitingSync
81153234 g     O .bss	00000004 OSTmrSem
81115590 g     F .text	00000054 vPusType251conf
81169d24 g     O .bss	00001000 OSTaskIdleStk
81121200 g     F .text	000000fc _fopen_r
8115310c g     O .bss	00000004 pdata
8114b1b8 g     F .text	000000bc _exit
811064a8 g     F .text	00000078 bFeebGetLeftBufferEmpty
81149e90 g     F .text	00000134 alt_alarm_start
8113a958 g     F .text	00000130 OSFlagNameGet
81140b54 g     F .text	00000064 OSTimeGet
81153098 g     O .bss	00000004 ESdmaChBufferId
81145738 g     F .text	00000380 alt_up_sd_card_read
81107104 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
81121a1c g     F .text	000001c4 __smakebuf_r
81153174 g     O .bss	00000001 SemCount64
81118690 g     F .text	000002f8 bSendUART64v2
8111d43c g     F .text	0000004c vFailFlushQueueData
811057c0 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81153074 g     O .rwdata	00000008 alt_msgdma_list
81122ee8 g     F .text	00000098 strlen
8110c524 g     F .text	000000b4 uc_spi_get_byte
81107148 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111d114 g     F .text	00000054 vFailSendMsgAccessDMA
8114ac98 g     F .text	00000028 OSTaskSwHook
811374b8 g     F .text	0000015c open
8110954c g     F .text	000007cc bRmapGetRmapMemHKArea
8116ad24 g     O .bss	00000d00 OSEventTbl
8111dc6c g     F .text	0000002c vFeeSpwRMAPChangeDefault
8111fc48 g     F .text	000000dc .hidden __gedf2
8111d2b8 g     F .text	00000054 vFailSendMsgSyncRMAPTRIGGER
811668b8 g     O .bss	00000020 xSenderACK
8114a98c g     F .text	00000044 alt_putchar
811211e8 g     F .text	0000000c atoll
8116ba24 g     O .bss	000011b8 OSTCBTbl
81133058 g     F .text	00000838 __gethex
8113ee34 g     F .text	00000108 OSSemSet
811169f8 g     F .text	0000006c vTimeoutCheckerTaskv2
8111dd1c g     F .text	00000038 cFeeRMAPEchoingEnable
81152fc8 g     O .rwdata	00000004 __wctomb
81117830 g     F .text	00000314 vVariablesInitialization
8113160c g     F .text	00000018 __sprint_r
8110fd0c g     F .text	0000045c vQCmdFeeRMAPinFullPattern
81106314 g     F .text	00000088 bFeebGetIrqFlags
81153088 g     O .bss	00000004 pxDmaM2Dev
8111b6dc g     F .text	0000004c vFailCreateSemaphoreResources
81152fe4 g     O .rwdata	00000004 alt_priority_mask
8110a998 g     F .text	0000003c bDisableLvdsBoard
8113e634 g     F .text	00000248 OSSemDel
81105a4c g     F .text	000000d4 bFeebCh2SetBufferSize
81153238 g     O .bss	00000004 OSFlagFreeList
8110c460 g     F .text	000000c4 v_spi_send_byte
8110c794 g     F .text	000000d0 bSSDisplayConfig
8114a398 g     F .text	00000090 alt_ic_irq_enable
8115300c g     O .rwdata	00000002 OSEventNameSize
81127904 g     F .text	0000001c __vfprintf_internal
8115323c g     O .bss	00000001 OSStatRdy
8110d20c g     F .text	00000074 bSyncCtrCh2OutEnable
8116cbdc g     O .bss	000000ac OSTCBPrioTbl
81147880 g     F .text	00000270 altera_avalon_uart_read
81133d60 g     F .text	00000064 _wctomb_r
81137d04 g     F .text	000000cc __env_lock
81153052 g     O .rwdata	00000002 OSTaskSwHookEn
81153a00 g     O .bss	00000100 cTemp
81105520 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81120444 g     F .text	00000904 .hidden __subdf3
811668d8 g     O .bss	00000260 xPreParsed
8110cea4 g     F .text	0000003c uliSyncGetOst
81153175 g     O .bss	00000001 SemCount128
81106fb4 g     F .text	00000040 vRmapCh8HandleIrq
811055ec g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81118c80 g     F .text	00000290 vSendEthConf
811046bc g     F .text	000000d0 bCommInitCh
8112cc9c g     F .text	000000b0 __lo0bits
811279e4 g     F .text	000017c4 __svfscanf_r
81152ff0 g     O .rwdata	00000008 alt_alarm_list
81131354 g     F .text	0000019c _ungetc_r
8115301a g     O .rwdata	00000002 OSFlagWidth
81106ff4 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
81133c68 g     F .text	000000c8 wcrtomb
81104c4c g     F .text	00000148 bDpktSetPixelDelay
811181c4 g     F .text	0000014c vCCDLoadDefaultValues
81136178 g     F .text	000000d8 close
8110cee0 g     F .text	0000003c uliSyncGetGeneral
8111d570 g     F .text	00000028 vEvtChangeDataControllerMode
811531cc g     O .bss	00000004 alt_envsem
811366a8 g     F .text	00000068 alt_log_repchar
81153240 g     O .bss	00000004 OSIdleCtrRun
81138ec0 g     F .text	00000028 OSVersion
81153064 g     O .rwdata	00000002 OSTmrCfgWheelSize
81140690 g     F .text	00000078 OS_TaskStkClr
8111e888 g     F .text	0000003c siOpenFile
8110d968 g     F .text	000000a0 vDataControlTask
8115303e g     O .rwdata	00000002 OSTaskCreateEn
8110726c g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
811076b4 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81106948 g     F .text	00000088 bFeebStartCh
81118f10 g     F .text	00000118 vSendTurnOff
8111b7dc g     F .text	0000004c vFailSendPreParsedSemaphore
811434a8 g     F .text	000002a4 match_file_record_to_name_ext
811394e8 g     F .text	00000070 OS_EventWaitListInit
81132ed0 g     F .text	00000088 fputwc
81166b38 g     O .bss	00000020 xFeeQueueTBL0
8111b774 g     F .text	00000068 vFailSendxSemCommInit
8114ad90 g     F .text	00000028 OSTaskIdleHook
81119028 g     F .text	00000118 vSendReset
8112b4d8 g     F .text	00000004 __sinit_lock_acquire
8112ca00 g     F .text	00000128 __multadd
81166b58 g     O .bss	00000020 SyncTBL1
81105630 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110cb30 g     F .text	0000004c ucSyncStatusState
81140378 g     F .text	000001ec OSTaskSuspend
8112c9d8 g     F .text	00000028 _Bfree
8110cdf0 g     F .text	0000003c uliSyncGetMbt
81139bf8 g     F .text	00000064 OS_TaskIdle
8115306a g     O .rwdata	00000002 OSTmrTblSize
8113e288 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	113889c0 	call	8113889c <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10b47c04 	addi	r2,r2,-11792
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10b47c04 	addi	r2,r2,-11792
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	11388f00 	call	811388f0 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b717 	ldw	r2,-32036(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b717 	ldw	r2,-32036(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	210bfa04 	addi	r4,r4,12264
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	21075104 	addi	r4,r4,7492
81100274:	11366200 	call	81136620 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	210bfa04 	addi	r4,r4,12264
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	21074404 	addi	r4,r4,7440
81100290:	11366200 	call	81136620 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6abe814 	ori	gp,gp,44960
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	210bfa04 	addi	r4,r4,12264
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	21073504 	addi	r4,r4,7380
811002bc:	11366200 	call	81136620 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	108c1f14 	ori	r2,r2,12412

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18f4bc14 	ori	r3,r3,54000

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	210bfa04 	addi	r4,r4,12264
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	21073c04 	addi	r4,r4,7408
811002fc:	11366200 	call	81136620 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	113724c0 	call	8113724c <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18ccfa04 	addi	r3,r3,13288
81100330:	00a04574 	movhi	r2,33045
81100334:	10ac9d04 	addi	r2,r2,-19852
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06217 	ldw	r2,-32376(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	294cfa04 	addi	r5,r5,13288
8110035c:	1009883a 	mov	r4,r2
81100360:	11213440 	call	81121344 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18ccfa04 	addi	r3,r3,13288
811003cc:	00a04574 	movhi	r2,33045
811003d0:	10aca604 	addi	r2,r2,-19816
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	11223f40 	call	811223f4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a06217 	ldw	r2,-32376(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	294cfa04 	addi	r5,r5,13288
811003f8:	1009883a 	mov	r4,r2
811003fc:	11213440 	call	81121344 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18ccfa04 	addi	r3,r3,13288
81100410:	00a04574 	movhi	r2,33045
81100414:	10acb204 	addi	r2,r2,-19768
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a06217 	ldw	r2,-32376(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	294cfa04 	addi	r5,r5,13288
8110043c:	1009883a 	mov	r4,r2
81100440:	11213440 	call	81121344 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	1137a780 	call	81137a78 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110ac780 	call	8110ac78 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604574 	movhi	r5,33045
811004b0:	296cb804 	addi	r5,r5,-19744
811004b4:	01204574 	movhi	r4,33045
811004b8:	210cfa04 	addi	r4,r4,13288
811004bc:	1122cd40 	call	81122cd4 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a06217 	ldw	r2,-32376(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	294cfa04 	addi	r5,r5,13288
811004cc:	1009883a 	mov	r4,r2
811004d0:	11213440 	call	81121344 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18ccfa04 	addi	r3,r3,13288
811004e0:	00a04574 	movhi	r2,33045
811004e4:	10acbd04 	addi	r2,r2,-19724
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	11223f40 	call	811223f4 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a06217 	ldw	r2,-32376(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	294cfa04 	addi	r5,r5,13288
8110050c:	1009883a 	mov	r4,r2
81100510:	11213440 	call	81121344 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18ccfa04 	addi	r3,r3,13288
81100544:	00a04574 	movhi	r2,33045
81100548:	10acc304 	addi	r2,r2,-19700
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a06217 	ldw	r2,-32376(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	294cfa04 	addi	r5,r5,13288
81100570:	1009883a 	mov	r4,r2
81100574:	11213440 	call	81121344 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18ccfa04 	addi	r3,r3,13288
81100584:	00a04574 	movhi	r2,33045
81100588:	10accc04 	addi	r2,r2,-19664
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a06217 	ldw	r2,-32376(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	294cfa04 	addi	r5,r5,13288
811005b0:	1009883a 	mov	r4,r2
811005b4:	11213440 	call	81121344 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18ccfa04 	addi	r3,r3,13288
811005c0:	00a04574 	movhi	r2,33045
811005c4:	10acd404 	addi	r2,r2,-19632
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a06217 	ldw	r2,-32376(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	294cfa04 	addi	r5,r5,13288
811005ec:	1009883a 	mov	r4,r2
811005f0:	11213440 	call	81121344 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	1137a780 	call	81137a78 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110ab980 	call	8110ab98 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18ccfa04 	addi	r3,r3,13288
81100650:	00a04574 	movhi	r2,33045
81100654:	10acda04 	addi	r2,r2,-19608
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a06217 	ldw	r2,-32376(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	294cfa04 	addi	r5,r5,13288
8110067c:	1009883a 	mov	r4,r2
81100680:	11213440 	call	81121344 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110ac780 	call	8110ac78 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18ccfa04 	addi	r3,r3,13288
811006cc:	00a04574 	movhi	r2,33045
811006d0:	10ace004 	addi	r2,r2,-19584
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	11223f40 	call	811223f4 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a06217 	ldw	r2,-32376(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	294cfa04 	addi	r5,r5,13288
811006f8:	1009883a 	mov	r4,r2
811006fc:	11213440 	call	81121344 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604574 	movhi	r5,33045
81100730:	296ce904 	addi	r5,r5,-19548
81100734:	01204574 	movhi	r4,33045
81100738:	210cfa04 	addi	r4,r4,13288
8110073c:	1122cd40 	call	81122cd4 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a06217 	ldw	r2,-32376(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	294cfa04 	addi	r5,r5,13288
8110074c:	1009883a 	mov	r4,r2
81100750:	11213440 	call	81121344 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18ccfa04 	addi	r3,r3,13288
81100764:	00a04574 	movhi	r2,33045
81100768:	10acf804 	addi	r2,r2,-19488
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a06217 	ldw	r2,-32376(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	294cfa04 	addi	r5,r5,13288
81100790:	1009883a 	mov	r4,r2
81100794:	11213440 	call	81121344 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18ccfa04 	addi	r3,r3,13288
811007a4:	00a04574 	movhi	r2,33045
811007a8:	10ad0104 	addi	r2,r2,-19452
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a06217 	ldw	r2,-32376(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	294cfa04 	addi	r5,r5,13288
811007d0:	1009883a 	mov	r4,r2
811007d4:	11213440 	call	81121344 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	108cfa04 	addi	r2,r2,13288
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a06217 	ldw	r2,-32376(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	294cfa04 	addi	r5,r5,13288
811007f8:	1009883a 	mov	r4,r2
811007fc:	11213440 	call	81121344 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18ccfa04 	addi	r3,r3,13288
81100840:	00a04574 	movhi	r2,33045
81100844:	10ad0904 	addi	r2,r2,-19420
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a06217 	ldw	r2,-32376(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	294cfa04 	addi	r5,r5,13288
8110086c:	1009883a 	mov	r4,r2
81100870:	11213440 	call	81121344 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18ccfa04 	addi	r3,r3,13288
811008dc:	00a04574 	movhi	r2,33045
811008e0:	10ad1204 	addi	r2,r2,-19384
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	11223f40 	call	811223f4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a06217 	ldw	r2,-32376(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	294cfa04 	addi	r5,r5,13288
81100908:	1009883a 	mov	r4,r2
8110090c:	11213440 	call	81121344 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	110ad800 	call	8110ad80 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604574 	movhi	r5,33045
81100984:	296d1e04 	addi	r5,r5,-19336
81100988:	01204574 	movhi	r4,33045
8110098c:	210cfa04 	addi	r4,r4,13288
81100990:	1122cd40 	call	81122cd4 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a06217 	ldw	r2,-32376(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	294cfa04 	addi	r5,r5,13288
811009a0:	1009883a 	mov	r4,r2
811009a4:	11213440 	call	81121344 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18ccfa04 	addi	r3,r3,13288
811009c0:	00a04574 	movhi	r2,33045
811009c4:	10ad2a04 	addi	r2,r2,-19288
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	11223f40 	call	811223f4 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a06217 	ldw	r2,-32376(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	294cfa04 	addi	r5,r5,13288
811009ec:	1009883a 	mov	r4,r2
811009f0:	11213440 	call	81121344 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18ccfa04 	addi	r3,r3,13288
81100a0c:	00a04574 	movhi	r2,33045
81100a10:	10ad3604 	addi	r2,r2,-19240
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a06217 	ldw	r2,-32376(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	294cfa04 	addi	r5,r5,13288
81100a38:	1009883a 	mov	r4,r2
81100a3c:	11213440 	call	81121344 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18ccfa04 	addi	r3,r3,13288
81100a58:	00a04574 	movhi	r2,33045
81100a5c:	10ad3e04 	addi	r2,r2,-19208
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	11223f40 	call	811223f4 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a06217 	ldw	r2,-32376(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	294cfa04 	addi	r5,r5,13288
81100a84:	1009883a 	mov	r4,r2
81100a88:	11213440 	call	81121344 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18ccfa04 	addi	r3,r3,13288
81100aa4:	00a04574 	movhi	r2,33045
81100aa8:	10ad4804 	addi	r2,r2,-19168
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	11223f40 	call	811223f4 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a06217 	ldw	r2,-32376(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	294cfa04 	addi	r5,r5,13288
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	11213440 	call	81121344 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18ccfa04 	addi	r3,r3,13288
81100af0:	00a04574 	movhi	r2,33045
81100af4:	10ad5304 	addi	r2,r2,-19124
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	11223f40 	call	811223f4 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a06217 	ldw	r2,-32376(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	294cfa04 	addi	r5,r5,13288
81100b1c:	1009883a 	mov	r4,r2
81100b20:	11213440 	call	81121344 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18ccfa04 	addi	r3,r3,13288
81100b3c:	00a04574 	movhi	r2,33045
81100b40:	10ad5f04 	addi	r2,r2,-19076
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a06217 	ldw	r2,-32376(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	294cfa04 	addi	r5,r5,13288
81100b68:	1009883a 	mov	r4,r2
81100b6c:	11213440 	call	81121344 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18ccfa04 	addi	r3,r3,13288
81100b88:	00a04574 	movhi	r2,33045
81100b8c:	10ad6504 	addi	r2,r2,-19052
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a06217 	ldw	r2,-32376(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	294cfa04 	addi	r5,r5,13288
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	11213440 	call	81121344 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18ccfa04 	addi	r3,r3,13288
81100bd4:	00a04574 	movhi	r2,33045
81100bd8:	10ad6d04 	addi	r2,r2,-19020
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	11223f40 	call	811223f4 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a06217 	ldw	r2,-32376(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	294cfa04 	addi	r5,r5,13288
81100c00:	1009883a 	mov	r4,r2
81100c04:	11213440 	call	81121344 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18ccfa04 	addi	r3,r3,13288
81100c20:	00a04574 	movhi	r2,33045
81100c24:	10ad7a04 	addi	r2,r2,-18968
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a06217 	ldw	r2,-32376(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	294cfa04 	addi	r5,r5,13288
81100c4c:	1009883a 	mov	r4,r2
81100c50:	11213440 	call	81121344 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18ccfa04 	addi	r3,r3,13288
81100c6c:	00a04574 	movhi	r2,33045
81100c70:	10ad8004 	addi	r2,r2,-18944
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a06217 	ldw	r2,-32376(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	294cfa04 	addi	r5,r5,13288
81100c98:	1009883a 	mov	r4,r2
81100c9c:	11213440 	call	81121344 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18ccfa04 	addi	r3,r3,13288
81100cb8:	00a04574 	movhi	r2,33045
81100cbc:	10ad8504 	addi	r2,r2,-18924
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a06217 	ldw	r2,-32376(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	294cfa04 	addi	r5,r5,13288
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	11213440 	call	81121344 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18ccfa04 	addi	r3,r3,13288
81100d04:	00a04574 	movhi	r2,33045
81100d08:	10ad8c04 	addi	r2,r2,-18896
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	11223f40 	call	811223f4 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a06217 	ldw	r2,-32376(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	294cfa04 	addi	r5,r5,13288
81100d30:	1009883a 	mov	r4,r2
81100d34:	11213440 	call	81121344 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18ccfa04 	addi	r3,r3,13288
81100d50:	00a04574 	movhi	r2,33045
81100d54:	10ad9a04 	addi	r2,r2,-18840
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	11223f40 	call	811223f4 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a06217 	ldw	r2,-32376(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	294cfa04 	addi	r5,r5,13288
81100d7c:	1009883a 	mov	r4,r2
81100d80:	11213440 	call	81121344 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18ccfa04 	addi	r3,r3,13288
81100d9c:	00a04574 	movhi	r2,33045
81100da0:	10adac04 	addi	r2,r2,-18768
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a06217 	ldw	r2,-32376(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	294cfa04 	addi	r5,r5,13288
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	11213440 	call	81121344 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18ccfa04 	addi	r3,r3,13288
81100de8:	00a04574 	movhi	r2,33045
81100dec:	10adb404 	addi	r2,r2,-18736
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	11223f40 	call	811223f4 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a06217 	ldw	r2,-32376(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	294cfa04 	addi	r5,r5,13288
81100e14:	1009883a 	mov	r4,r2
81100e18:	11213440 	call	81121344 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18ccfa04 	addi	r3,r3,13288
81100e34:	00a04574 	movhi	r2,33045
81100e38:	10adbe04 	addi	r2,r2,-18696
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	11223f40 	call	811223f4 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a06217 	ldw	r2,-32376(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	294cfa04 	addi	r5,r5,13288
81100e60:	1009883a 	mov	r4,r2
81100e64:	11213440 	call	81121344 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18ccfa04 	addi	r3,r3,13288
81100e80:	00a04574 	movhi	r2,33045
81100e84:	10adcb04 	addi	r2,r2,-18644
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	11223f40 	call	811223f4 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a06217 	ldw	r2,-32376(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	294cfa04 	addi	r5,r5,13288
81100eac:	1009883a 	mov	r4,r2
81100eb0:	11213440 	call	81121344 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18ccfa04 	addi	r3,r3,13288
81100ecc:	00a04574 	movhi	r2,33045
81100ed0:	10add504 	addi	r2,r2,-18604
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	11223f40 	call	811223f4 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a06217 	ldw	r2,-32376(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	294cfa04 	addi	r5,r5,13288
81100ef8:	1009883a 	mov	r4,r2
81100efc:	11213440 	call	81121344 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18ccfa04 	addi	r3,r3,13288
81100f18:	00a04574 	movhi	r2,33045
81100f1c:	10ade004 	addi	r2,r2,-18560
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	11223f40 	call	811223f4 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a06217 	ldw	r2,-32376(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	294cfa04 	addi	r5,r5,13288
81100f44:	1009883a 	mov	r4,r2
81100f48:	11213440 	call	81121344 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18ccfa04 	addi	r3,r3,13288
81100f64:	00a04574 	movhi	r2,33045
81100f68:	10adf104 	addi	r2,r2,-18492
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	11223f40 	call	811223f4 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a06217 	ldw	r2,-32376(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	294cfa04 	addi	r5,r5,13288
81100f90:	1009883a 	mov	r4,r2
81100f94:	11213440 	call	81121344 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18ccfa04 	addi	r3,r3,13288
81100fb0:	00a04574 	movhi	r2,33045
81100fb4:	10adfc04 	addi	r2,r2,-18448
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	11223f40 	call	811223f4 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a06217 	ldw	r2,-32376(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	294cfa04 	addi	r5,r5,13288
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	11213440 	call	81121344 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18ccfa04 	addi	r3,r3,13288
81100ffc:	00a04574 	movhi	r2,33045
81101000:	10ae0904 	addi	r2,r2,-18396
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	11223f40 	call	811223f4 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a06217 	ldw	r2,-32376(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	294cfa04 	addi	r5,r5,13288
81101028:	1009883a 	mov	r4,r2
8110102c:	11213440 	call	81121344 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18ccfa04 	addi	r3,r3,13288
81101048:	00a04574 	movhi	r2,33045
8110104c:	10ae1704 	addi	r2,r2,-18340
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	11223f40 	call	811223f4 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a06217 	ldw	r2,-32376(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	294cfa04 	addi	r5,r5,13288
81101074:	1009883a 	mov	r4,r2
81101078:	11213440 	call	81121344 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18ccfa04 	addi	r3,r3,13288
81101094:	00a04574 	movhi	r2,33045
81101098:	10ae2404 	addi	r2,r2,-18288
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	11223f40 	call	811223f4 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a06217 	ldw	r2,-32376(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	294cfa04 	addi	r5,r5,13288
811010c0:	1009883a 	mov	r4,r2
811010c4:	11213440 	call	81121344 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18ccfa04 	addi	r3,r3,13288
811010e0:	00a04574 	movhi	r2,33045
811010e4:	10ae3104 	addi	r2,r2,-18236
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a06217 	ldw	r2,-32376(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	294cfa04 	addi	r5,r5,13288
8110110c:	1009883a 	mov	r4,r2
81101110:	11213440 	call	81121344 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	108cfa04 	addi	r2,r2,13288
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a06217 	ldw	r2,-32376(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	294cfa04 	addi	r5,r5,13288
81101194:	1009883a 	mov	r4,r2
81101198:	11213440 	call	81121344 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18ccfa04 	addi	r3,r3,13288
811011b4:	00a04574 	movhi	r2,33045
811011b8:	10ae3504 	addi	r2,r2,-18220
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a06217 	ldw	r2,-32376(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	294cfa04 	addi	r5,r5,13288
811011e0:	1009883a 	mov	r4,r2
811011e4:	11213440 	call	81121344 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18ccfa04 	addi	r3,r3,13288
81101200:	00a04574 	movhi	r2,33045
81101204:	10ae3d04 	addi	r2,r2,-18188
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	11223f40 	call	811223f4 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a06217 	ldw	r2,-32376(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	294cfa04 	addi	r5,r5,13288
8110122c:	1009883a 	mov	r4,r2
81101230:	11213440 	call	81121344 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18ccfa04 	addi	r3,r3,13288
8110124c:	00a04574 	movhi	r2,33045
81101250:	10ae4b04 	addi	r2,r2,-18132
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a06217 	ldw	r2,-32376(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	294cfa04 	addi	r5,r5,13288
81101278:	1009883a 	mov	r4,r2
8110127c:	11213440 	call	81121344 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18ccfa04 	addi	r3,r3,13288
81101298:	00a04574 	movhi	r2,33045
8110129c:	10ae5304 	addi	r2,r2,-18100
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a06217 	ldw	r2,-32376(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	294cfa04 	addi	r5,r5,13288
811012c4:	1009883a 	mov	r4,r2
811012c8:	11213440 	call	81121344 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18ccfa04 	addi	r3,r3,13288
811012e4:	00a04574 	movhi	r2,33045
811012e8:	10ae5b04 	addi	r2,r2,-18068
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	11223f40 	call	811223f4 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a06217 	ldw	r2,-32376(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	294cfa04 	addi	r5,r5,13288
81101310:	1009883a 	mov	r4,r2
81101314:	11213440 	call	81121344 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18ccfa04 	addi	r3,r3,13288
81101330:	00a04574 	movhi	r2,33045
81101334:	10ae6504 	addi	r2,r2,-18028
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a06217 	ldw	r2,-32376(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	294cfa04 	addi	r5,r5,13288
8110135c:	1009883a 	mov	r4,r2
81101360:	11213440 	call	81121344 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18ccfa04 	addi	r3,r3,13288
8110137c:	00a04574 	movhi	r2,33045
81101380:	10ae6c04 	addi	r2,r2,-18000
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	11223f40 	call	811223f4 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a06217 	ldw	r2,-32376(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	294cfa04 	addi	r5,r5,13288
811013a8:	1009883a 	mov	r4,r2
811013ac:	11213440 	call	81121344 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18ccfa04 	addi	r3,r3,13288
811013c8:	00a04574 	movhi	r2,33045
811013cc:	10ae7604 	addi	r2,r2,-17960
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a06217 	ldw	r2,-32376(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	294cfa04 	addi	r5,r5,13288
811013f4:	1009883a 	mov	r4,r2
811013f8:	11213440 	call	81121344 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	108cfa04 	addi	r2,r2,13288
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a06217 	ldw	r2,-32376(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	294cfa04 	addi	r5,r5,13288
81101420:	1009883a 	mov	r4,r2
81101424:	11213440 	call	81121344 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18ccfa04 	addi	r3,r3,13288
81101454:	00a04574 	movhi	r2,33045
81101458:	10ae8004 	addi	r2,r2,-17920
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a06217 	ldw	r2,-32376(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	294cfa04 	addi	r5,r5,13288
81101480:	1009883a 	mov	r4,r2
81101484:	11213440 	call	81121344 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	108cfa04 	addi	r2,r2,13288
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a06217 	ldw	r2,-32376(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	294cfa04 	addi	r5,r5,13288
811014a8:	1009883a 	mov	r4,r2
811014ac:	11213440 	call	81121344 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18ccfa04 	addi	r3,r3,13288
81101538:	00a04574 	movhi	r2,33045
8110153c:	10ae8604 	addi	r2,r2,-17896
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	11223f40 	call	811223f4 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a06217 	ldw	r2,-32376(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	294cfa04 	addi	r5,r5,13288
81101564:	1009883a 	mov	r4,r2
81101568:	11213440 	call	81121344 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18ccfa04 	addi	r3,r3,13288
811015b4:	00a04574 	movhi	r2,33045
811015b8:	10ae9504 	addi	r2,r2,-17836
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a06217 	ldw	r2,-32376(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	294cfa04 	addi	r5,r5,13288
811015e0:	1009883a 	mov	r4,r2
811015e4:	11213440 	call	81121344 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18ccfa04 	addi	r3,r3,13288
81101648:	00a04574 	movhi	r2,33045
8110164c:	10aca604 	addi	r2,r2,-19816
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	11223f40 	call	811223f4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a06217 	ldw	r2,-32376(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	294cfa04 	addi	r5,r5,13288
81101674:	1009883a 	mov	r4,r2
81101678:	11213440 	call	81121344 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604574 	movhi	r5,33045
81101694:	296e9f04 	addi	r5,r5,-17796
81101698:	01204574 	movhi	r4,33045
8110169c:	210cfa04 	addi	r4,r4,13288
811016a0:	1122cd40 	call	81122cd4 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a06217 	ldw	r2,-32376(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	294cfa04 	addi	r5,r5,13288
811016b0:	1009883a 	mov	r4,r2
811016b4:	11213440 	call	81121344 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08917 	ldw	r2,-32220(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	108d3a04 	addi	r2,r2,13544
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	108d3a04 	addi	r2,r2,13544
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	108d3a04 	addi	r2,r2,13544
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	108d3a04 	addi	r2,r2,13544
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	108d3a04 	addi	r2,r2,13544
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	108d3a04 	addi	r2,r2,13544
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	108d3a04 	addi	r2,r2,13544
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18ccfa04 	addi	r3,r3,13288
81101868:	00a04574 	movhi	r2,33045
8110186c:	10aea504 	addi	r2,r2,-17772
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a06217 	ldw	r2,-32376(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	294cfa04 	addi	r5,r5,13288
81101894:	1009883a 	mov	r4,r2
81101898:	11213440 	call	81121344 <fprintf>
8110189c:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	294d3a04 	addi	r5,r5,13544
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	11223f40 	call	811223f4 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604574 	movhi	r5,33045
81101990:	296eaa04 	addi	r5,r5,-17752
81101994:	01204574 	movhi	r4,33045
81101998:	210cfa04 	addi	r4,r4,13288
8110199c:	1122cd40 	call	81122cd4 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a06217 	ldw	r2,-32376(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	294cfa04 	addi	r5,r5,13288
811019ac:	1009883a 	mov	r4,r2
811019b0:	11213440 	call	81121344 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11362500 	call	81136250 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	108cfa04 	addi	r2,r2,13288
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a06217 	ldw	r2,-32376(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	294cfa04 	addi	r5,r5,13288
811019e4:	1009883a 	mov	r4,r2
811019e8:	11213440 	call	81121344 <fprintf>
811019ec:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111fa240 	call	8111fa24 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08817 	ldw	r2,-32224(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111fb500 	call	8111fb50 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111f1d80 	call	8111f1d8 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	1120eac0 	call	81120eac <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604574 	movhi	r5,33045
81101a54:	296eac04 	addi	r5,r5,-17744
81101a58:	01204574 	movhi	r4,33045
81101a5c:	210cfa04 	addi	r4,r4,13288
81101a60:	1122cd40 	call	81122cd4 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a06217 	ldw	r2,-32376(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	294cfa04 	addi	r5,r5,13288
81101a70:	1009883a 	mov	r4,r2
81101a74:	11213440 	call	81121344 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18ccfa04 	addi	r3,r3,13288
81101a84:	00a04574 	movhi	r2,33045
81101a88:	10aeb804 	addi	r2,r2,-17696
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a06217 	ldw	r2,-32376(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	294cfa04 	addi	r5,r5,13288
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	11213440 	call	81121344 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	108cfa04 	addi	r2,r2,13288
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a06217 	ldw	r2,-32376(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	294cfa04 	addi	r5,r5,13288
81101ad8:	1009883a 	mov	r4,r2
81101adc:	11213440 	call	81121344 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18ccfa04 	addi	r3,r3,13288
81101b30:	00a04574 	movhi	r2,33045
81101b34:	10aebe04 	addi	r2,r2,-17672
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a06217 	ldw	r2,-32376(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	294cfa04 	addi	r5,r5,13288
81101b5c:	1009883a 	mov	r4,r2
81101b60:	11213440 	call	81121344 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18ccfa04 	addi	r3,r3,13288
81101bc4:	00a04574 	movhi	r2,33045
81101bc8:	10aca604 	addi	r2,r2,-19816
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	11223f40 	call	811223f4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a06217 	ldw	r2,-32376(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	294cfa04 	addi	r5,r5,13288
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	11213440 	call	81121344 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604574 	movhi	r5,33045
81101c10:	296ec804 	addi	r5,r5,-17632
81101c14:	01204574 	movhi	r4,33045
81101c18:	210cfa04 	addi	r4,r4,13288
81101c1c:	1122cd40 	call	81122cd4 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a06217 	ldw	r2,-32376(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	294cfa04 	addi	r5,r5,13288
81101c2c:	1009883a 	mov	r4,r2
81101c30:	11213440 	call	81121344 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18ccfa04 	addi	r3,r3,13288
81101cd0:	00a04574 	movhi	r2,33045
81101cd4:	10aece04 	addi	r2,r2,-17608
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a06217 	ldw	r2,-32376(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	294cfa04 	addi	r5,r5,13288
81101cfc:	1009883a 	mov	r4,r2
81101d00:	11213440 	call	81121344 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08917 	ldw	r2,-32220(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	108d3a04 	addi	r2,r2,13544
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	108d3a04 	addi	r2,r2,13544
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604574 	movhi	r5,33045
81101df4:	296ed504 	addi	r5,r5,-17580
81101df8:	01204574 	movhi	r4,33045
81101dfc:	210cfa04 	addi	r4,r4,13288
81101e00:	1122cd40 	call	81122cd4 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a06217 	ldw	r2,-32376(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	294cfa04 	addi	r5,r5,13288
81101e10:	1009883a 	mov	r4,r2
81101e14:	11213440 	call	81121344 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604574 	movhi	r5,33045
81101e98:	296eaa04 	addi	r5,r5,-17752
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	210cfa04 	addi	r4,r4,13288
81101ea4:	1122cd40 	call	81122cd4 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a06217 	ldw	r2,-32376(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	294cfa04 	addi	r5,r5,13288
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	11213440 	call	81121344 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	108cfa04 	addi	r2,r2,13288
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a06217 	ldw	r2,-32376(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	294cfa04 	addi	r5,r5,13288
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	11213440 	call	81121344 <fprintf>
81101ef8:	d0e08917 	ldw	r3,-32220(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111fa240 	call	8111fa24 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08817 	ldw	r2,-32224(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111fb500 	call	8111fb50 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111f1d80 	call	8111f1d8 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	1120eac0 	call	81120eac <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604574 	movhi	r5,33045
81101f60:	296ee304 	addi	r5,r5,-17524
81101f64:	01204574 	movhi	r4,33045
81101f68:	210cfa04 	addi	r4,r4,13288
81101f6c:	1122cd40 	call	81122cd4 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a06217 	ldw	r2,-32376(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	294cfa04 	addi	r5,r5,13288
81101f7c:	1009883a 	mov	r4,r2
81101f80:	11213440 	call	81121344 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18ccfa04 	addi	r3,r3,13288
81101f90:	00a04574 	movhi	r2,33045
81101f94:	10aeef04 	addi	r2,r2,-17476
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a06217 	ldw	r2,-32376(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	294cfa04 	addi	r5,r5,13288
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	11213440 	call	81121344 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	108cfa04 	addi	r2,r2,13288
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a06217 	ldw	r2,-32376(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	294cfa04 	addi	r5,r5,13288
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	11213440 	call	81121344 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18ccfa04 	addi	r3,r3,13288
8110204c:	00a04574 	movhi	r2,33045
81102050:	10aef504 	addi	r2,r2,-17452
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a06217 	ldw	r2,-32376(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	294cfa04 	addi	r5,r5,13288
81102078:	1009883a 	mov	r4,r2
8110207c:	11213440 	call	81121344 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18ccfa04 	addi	r3,r3,13288
811020e0:	00a04574 	movhi	r2,33045
811020e4:	10aca604 	addi	r2,r2,-19816
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	11223f40 	call	811223f4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a06217 	ldw	r2,-32376(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	294cfa04 	addi	r5,r5,13288
8110210c:	1009883a 	mov	r4,r2
81102110:	11213440 	call	81121344 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604574 	movhi	r5,33045
8110212c:	296e9f04 	addi	r5,r5,-17796
81102130:	01204574 	movhi	r4,33045
81102134:	210cfa04 	addi	r4,r4,13288
81102138:	1122cd40 	call	81122cd4 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a06217 	ldw	r2,-32376(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	294cfa04 	addi	r5,r5,13288
81102148:	1009883a 	mov	r4,r2
8110214c:	11213440 	call	81121344 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08917 	ldw	r2,-32220(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18ccfa04 	addi	r3,r3,13288
811021ac:	00a04574 	movhi	r2,33045
811021b0:	10af0104 	addi	r2,r2,-17404
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a06217 	ldw	r2,-32376(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	294cfa04 	addi	r5,r5,13288
811021d8:	1009883a 	mov	r4,r2
811021dc:	11213440 	call	81121344 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604574 	movhi	r5,33045
811021f0:	296f0704 	addi	r5,r5,-17380
811021f4:	01204574 	movhi	r4,33045
811021f8:	210cfa04 	addi	r4,r4,13288
811021fc:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a06217 	ldw	r2,-32376(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	294cfa04 	addi	r5,r5,13288
8110220c:	1009883a 	mov	r4,r2
81102210:	11213440 	call	81121344 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604574 	movhi	r5,33045
81102274:	296f0904 	addi	r5,r5,-17372
81102278:	01204574 	movhi	r4,33045
8110227c:	210cfa04 	addi	r4,r4,13288
81102280:	1122cd40 	call	81122cd4 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a06217 	ldw	r2,-32376(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	294cfa04 	addi	r5,r5,13288
81102290:	1009883a 	mov	r4,r2
81102294:	11213440 	call	81121344 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11362500 	call	81136250 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604574 	movhi	r5,33045
811022fc:	296f0c04 	addi	r5,r5,-17360
81102300:	01204574 	movhi	r4,33045
81102304:	210cfa04 	addi	r4,r4,13288
81102308:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a06217 	ldw	r2,-32376(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	294cfa04 	addi	r5,r5,13288
81102318:	1009883a 	mov	r4,r2
8110231c:	11213440 	call	81121344 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111fa240 	call	8111fa24 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08817 	ldw	r2,-32224(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111fb500 	call	8111fb50 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111f1d80 	call	8111f1d8 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	1120eac0 	call	81120eac <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604574 	movhi	r5,33045
81102394:	296f0f04 	addi	r5,r5,-17348
81102398:	01204574 	movhi	r4,33045
8110239c:	210cfa04 	addi	r4,r4,13288
811023a0:	1122cd40 	call	81122cd4 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a06217 	ldw	r2,-32376(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	294cfa04 	addi	r5,r5,13288
811023b0:	1009883a 	mov	r4,r2
811023b4:	11213440 	call	81121344 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604574 	movhi	r5,33045
811023c4:	296f1b04 	addi	r5,r5,-17300
811023c8:	01204574 	movhi	r4,33045
811023cc:	210cfa04 	addi	r4,r4,13288
811023d0:	1122cd40 	call	81122cd4 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a06217 	ldw	r2,-32376(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	294cfa04 	addi	r5,r5,13288
811023e0:	1009883a 	mov	r4,r2
811023e4:	11213440 	call	81121344 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18ccfa04 	addi	r3,r3,13288
811023f4:	00a04574 	movhi	r2,33045
811023f8:	10aeb804 	addi	r2,r2,-17696
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a06217 	ldw	r2,-32376(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	294cfa04 	addi	r5,r5,13288
81102420:	1009883a 	mov	r4,r2
81102424:	11213440 	call	81121344 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	108cfa04 	addi	r2,r2,13288
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a06217 	ldw	r2,-32376(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	294cfa04 	addi	r5,r5,13288
81102448:	1009883a 	mov	r4,r2
8110244c:	11213440 	call	81121344 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18ccfa04 	addi	r3,r3,13288
811024b8:	00a04574 	movhi	r2,33045
811024bc:	10af2504 	addi	r2,r2,-17260
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a06217 	ldw	r2,-32376(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	294cfa04 	addi	r5,r5,13288
811024e4:	1009883a 	mov	r4,r2
811024e8:	11213440 	call	81121344 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18ccfa04 	addi	r3,r3,13288
8110254c:	00a04574 	movhi	r2,33045
81102550:	10aca604 	addi	r2,r2,-19816
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	11223f40 	call	811223f4 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a06217 	ldw	r2,-32376(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	294cfa04 	addi	r5,r5,13288
81102578:	1009883a 	mov	r4,r2
8110257c:	11213440 	call	81121344 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604574 	movhi	r5,33045
81102598:	296e9f04 	addi	r5,r5,-17796
8110259c:	01204574 	movhi	r4,33045
811025a0:	210cfa04 	addi	r4,r4,13288
811025a4:	1122cd40 	call	81122cd4 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a06217 	ldw	r2,-32376(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	294cfa04 	addi	r5,r5,13288
811025b4:	1009883a 	mov	r4,r2
811025b8:	11213440 	call	81121344 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18ccfa04 	addi	r3,r3,13288
81102610:	00a04574 	movhi	r2,33045
81102614:	10af3104 	addi	r2,r2,-17212
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a06217 	ldw	r2,-32376(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	294cfa04 	addi	r5,r5,13288
8110263c:	1009883a 	mov	r4,r2
81102640:	11213440 	call	81121344 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604574 	movhi	r5,33045
81102654:	296f0704 	addi	r5,r5,-17380
81102658:	01204574 	movhi	r4,33045
8110265c:	210cfa04 	addi	r4,r4,13288
81102660:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a06217 	ldw	r2,-32376(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	294cfa04 	addi	r5,r5,13288
81102670:	1009883a 	mov	r4,r2
81102674:	11213440 	call	81121344 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08917 	ldw	r2,-32220(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604574 	movhi	r5,33045
811026c8:	296f3704 	addi	r5,r5,-17188
811026cc:	01204574 	movhi	r4,33045
811026d0:	210cfa04 	addi	r4,r4,13288
811026d4:	1122cd40 	call	81122cd4 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a06217 	ldw	r2,-32376(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	294cfa04 	addi	r5,r5,13288
811026e4:	1009883a 	mov	r4,r2
811026e8:	11213440 	call	81121344 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604574 	movhi	r5,33045
81102710:	296f0904 	addi	r5,r5,-17372
81102714:	01204574 	movhi	r4,33045
81102718:	210cfa04 	addi	r4,r4,13288
8110271c:	1122cd40 	call	81122cd4 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a06217 	ldw	r2,-32376(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	294cfa04 	addi	r5,r5,13288
8110272c:	1009883a 	mov	r4,r2
81102730:	11213440 	call	81121344 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604574 	movhi	r5,33045
81102794:	296f0c04 	addi	r5,r5,-17360
81102798:	01204574 	movhi	r4,33045
8110279c:	210cfa04 	addi	r4,r4,13288
811027a0:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a06217 	ldw	r2,-32376(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	294cfa04 	addi	r5,r5,13288
811027b0:	1009883a 	mov	r4,r2
811027b4:	11213440 	call	81121344 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08917 	ldw	r3,-32220(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111fa240 	call	8111fa24 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08817 	ldw	r2,-32224(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111fb500 	call	8111fb50 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111f1d80 	call	8111f1d8 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	1120eac0 	call	81120eac <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604574 	movhi	r5,33045
8110282c:	296f3f04 	addi	r5,r5,-17156
81102830:	01204574 	movhi	r4,33045
81102834:	210cfa04 	addi	r4,r4,13288
81102838:	1122cd40 	call	81122cd4 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a06217 	ldw	r2,-32376(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	294cfa04 	addi	r5,r5,13288
81102848:	1009883a 	mov	r4,r2
8110284c:	11213440 	call	81121344 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604574 	movhi	r5,33045
8110285c:	296f4b04 	addi	r5,r5,-17108
81102860:	01204574 	movhi	r4,33045
81102864:	210cfa04 	addi	r4,r4,13288
81102868:	1122cd40 	call	81122cd4 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a06217 	ldw	r2,-32376(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	294cfa04 	addi	r5,r5,13288
81102878:	1009883a 	mov	r4,r2
8110287c:	11213440 	call	81121344 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18ccfa04 	addi	r3,r3,13288
8110288c:	00a04574 	movhi	r2,33045
81102890:	10aeef04 	addi	r2,r2,-17476
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	11223f40 	call	811223f4 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a06217 	ldw	r2,-32376(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	294cfa04 	addi	r5,r5,13288
811028b8:	1009883a 	mov	r4,r2
811028bc:	11213440 	call	81121344 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	108cfa04 	addi	r2,r2,13288
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a06217 	ldw	r2,-32376(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	294cfa04 	addi	r5,r5,13288
811028e0:	1009883a 	mov	r4,r2
811028e4:	11213440 	call	81121344 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	1149b100 	call	81149b10 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	1137a780 	call	81137a78 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	1137a780 	call	81137a78 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	1137a780 	call	81137a78 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	1137a780 	call	81137a78 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	1148b0c0 	call	81148b0c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	1149d800 	call	81149d80 <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	1137a780 	call	81137a78 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	1137a780 	call	81137a78 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	1148b0c0 	call	81148b0c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	1149d800 	call	81149d80 <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	1148b0c0 	call	81148b0c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	1149d800 	call	81149d80 <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	1137a780 	call	81137a78 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	1137a780 	call	81137a78 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110bd2c0 	call	8110bd2c <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110bd2c0 	call	8110bd2c <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604574 	movhi	r5,33045
811030d0:	296f5504 	addi	r5,r5,-17068
811030d4:	01204574 	movhi	r4,33045
811030d8:	210cfa04 	addi	r4,r4,13288
811030dc:	1122cd40 	call	81122cd4 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a06217 	ldw	r2,-32376(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	294cfa04 	addi	r5,r5,13288
811030ec:	1009883a 	mov	r4,r2
811030f0:	11213440 	call	81121344 <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604574 	movhi	r5,33045
8110311c:	296f5b04 	addi	r5,r5,-17044
81103120:	01204574 	movhi	r4,33045
81103124:	210cfa04 	addi	r4,r4,13288
81103128:	1122cd40 	call	81122cd4 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a06217 	ldw	r2,-32376(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	294cfa04 	addi	r5,r5,13288
81103138:	1009883a 	mov	r4,r2
8110313c:	11213440 	call	81121344 <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	296f6704 	addi	r5,r5,-16996
81103160:	01204574 	movhi	r4,33045
81103164:	210cfa04 	addi	r4,r4,13288
81103168:	1122cd40 	call	81122cd4 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a06217 	ldw	r2,-32376(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	294cfa04 	addi	r5,r5,13288
81103178:	1009883a 	mov	r4,r2
8110317c:	11213440 	call	81121344 <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18ccfa04 	addi	r3,r3,13288
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10af6d04 	addi	r2,r2,-16972
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	11223f40 	call	811223f4 <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a06217 	ldw	r2,-32376(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	294cfa04 	addi	r5,r5,13288
811031ec:	1009883a 	mov	r4,r2
811031f0:	11213440 	call	81121344 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	110ac780 	call	8110ac78 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	110ac780 	call	8110ac78 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10afa404 	addi	r2,r2,-16752
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	11223f40 	call	811223f4 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111fb500 	call	8111fb50 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111f1d80 	call	8111f1d8 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111f6200 	call	8111f620 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	1120eac0 	call	81120eac <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	296f7204 	addi	r5,r5,-16952
8110365c:	01204574 	movhi	r4,33045
81103660:	210cfa04 	addi	r4,r4,13288
81103664:	1122cd40 	call	81122cd4 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a06217 	ldw	r2,-32376(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	294cfa04 	addi	r5,r5,13288
81103674:	1009883a 	mov	r4,r2
81103678:	11213440 	call	81121344 <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	1120eac0 	call	81120eac <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111fd240 	call	8111fd24 <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	1120eac0 	call	81120eac <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111fd240 	call	8111fd24 <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	1120fc40 	call	81120fc4 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111f1d80 	call	8111f1d8 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111f6200 	call	8111f620 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	1120eac0 	call	81120eac <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	1120eac0 	call	81120eac <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	1120eac0 	call	81120eac <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	296f7b04 	addi	r5,r5,-16916
811037f4:	01204574 	movhi	r4,33045
811037f8:	210cfa04 	addi	r4,r4,13288
811037fc:	1122cd40 	call	81122cd4 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a06217 	ldw	r2,-32376(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	294cfa04 	addi	r5,r5,13288
8110380c:	1009883a 	mov	r4,r2
81103810:	11213440 	call	81121344 <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	1120eac0 	call	81120eac <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111fd240 	call	8111fd24 <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	1120eac0 	call	81120eac <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111fd240 	call	8111fd24 <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	1120fc40 	call	81120fc4 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111f1d80 	call	8111f1d8 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111f6200 	call	8111f620 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	1120eac0 	call	81120eac <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	1120eac0 	call	81120eac <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	1120eac0 	call	81120eac <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	296f8b04 	addi	r5,r5,-16852
8110398c:	01204574 	movhi	r4,33045
81103990:	210cfa04 	addi	r4,r4,13288
81103994:	1122cd40 	call	81122cd4 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a06217 	ldw	r2,-32376(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	294cfa04 	addi	r5,r5,13288
811039a4:	1009883a 	mov	r4,r2
811039a8:	11213440 	call	81121344 <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111f6200 	call	8111f620 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	1120eac0 	call	81120eac <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	296f9b04 	addi	r5,r5,-16788
81103a34:	01204574 	movhi	r4,33045
81103a38:	210cfa04 	addi	r4,r4,13288
81103a3c:	1122cd40 	call	81122cd4 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a06217 	ldw	r2,-32376(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	294cfa04 	addi	r5,r5,13288
81103a4c:	1009883a 	mov	r4,r2
81103a50:	11213440 	call	81121344 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	108cfa04 	addi	r2,r2,13288
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a06217 	ldw	r2,-32376(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	294cfa04 	addi	r5,r5,13288
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	11213440 	call	81121344 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	108cfa04 	addi	r2,r2,13288
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a06217 	ldw	r2,-32376(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	294cfa04 	addi	r5,r5,13288
81103af8:	1009883a 	mov	r4,r2
81103afc:	11213440 	call	81121344 <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	21306404 	addi	r4,r4,-15984
81103b5c:	1149b100 	call	81149b10 <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	1137a780 	call	81137a78 <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204574 	movhi	r4,33045
81103c08:	21306904 	addi	r4,r4,-15964
81103c0c:	1149b100 	call	81149b10 <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	1137a780 	call	81137a78 <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe804 	addi	sp,sp,-96
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01715 	stw	ra,92(sp)
81103ca0:	df001615 	stw	fp,88(sp)
81103ca4:	dc001515 	stw	r16,84(sp)
81103ca8:	df001604 	addi	fp,sp,88
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff315 	stw	r2,-52(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff70d 	sth	zero,-36(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	bool bBufferEmptyFlag = FALSE;
81103cfc:	e03ff615 	stw	zero,-40(fp)

	switch (ucChBufferId) {
81103d00:	e0bffe03 	ldbu	r2,-8(fp)
81103d04:	10c00228 	cmpgeui	r3,r2,8
81103d08:	1800b81e 	bne	r3,zero,81103fec <bSdmaDmaM1Transfer+0x35c>
81103d0c:	100690ba 	slli	r3,r2,2
81103d10:	00a04434 	movhi	r2,33040
81103d14:	108f4904 	addi	r2,r2,15652
81103d18:	1885883a 	add	r2,r3,r2
81103d1c:	10800017 	ldw	r2,0(r2)
81103d20:	1000683a 	jmp	r2
81103d24:	81103d44 	addi	r4,r16,16629
81103d28:	81103d98 	cmpnei	r4,r16,16630
81103d2c:	81103df4 	orhi	r4,r16,16631
81103d30:	81103e48 	cmpgei	r4,r16,16633
81103d34:	81103e9c 	xori	r4,r16,16634
81103d38:	81103ef0 	cmpltui	r4,r16,16635
81103d3c:	81103f44 	addi	r4,r16,16637
81103d40:	81103f98 	cmpnei	r4,r16,16638
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d44:	e0bffd03 	ldbu	r2,-12(fp)
81103d48:	10000826 	beq	r2,zero,81103d6c <bSdmaDmaM1Transfer+0xdc>
81103d4c:	10800060 	cmpeqi	r2,r2,1
81103d50:	10000d26 	beq	r2,zero,81103d88 <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d54:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d58:	00800044 	movi	r2,1
81103d5c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103d60:	11066000 	call	81106600 <bFeebGetCh1RightBufferEmpty>
81103d64:	e0bff615 	stw	r2,-40(fp)
			break;
81103d68:	00000a06 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d6c:	00800074 	movhi	r2,1
81103d70:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d74:	00800044 	movi	r2,1
81103d78:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103d7c:	11065980 	call	81106598 <bFeebGetCh1LeftBufferEmpty>
81103d80:	e0bff615 	stw	r2,-40(fp)
			break;
81103d84:	00000306 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		default:
			bStatus = FALSE;
81103d88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103d8c:	e03ff615 	stw	zero,-40(fp)
			break;
81103d90:	0001883a 	nop
		}
		break;
81103d94:	00009706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d98:	e0bffd03 	ldbu	r2,-12(fp)
81103d9c:	10000926 	beq	r2,zero,81103dc4 <bSdmaDmaM1Transfer+0x134>
81103da0:	10800060 	cmpeqi	r2,r2,1
81103da4:	10000f26 	beq	r2,zero,81103de4 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103da8:	00880004 	movi	r2,8192
81103dac:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103db8:	11066d00 	call	811066d0 <bFeebGetCh2RightBufferEmpty>
81103dbc:	e0bff615 	stw	r2,-40(fp)
			break;
81103dc0:	00000b06 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103dc4:	00800074 	movhi	r2,1
81103dc8:	10880004 	addi	r2,r2,8192
81103dcc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103dd0:	00800044 	movi	r2,1
81103dd4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103dd8:	11066680 	call	81106668 <bFeebGetCh2LeftBufferEmpty>
81103ddc:	e0bff615 	stw	r2,-40(fp)
			break;
81103de0:	00000306 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		default:
			bStatus = FALSE;
81103de4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103de8:	e03ff615 	stw	zero,-40(fp)
			break;
81103dec:	0001883a 	nop
		}
		break;
81103df0:	00008006 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103df4:	e0bffd03 	ldbu	r2,-12(fp)
81103df8:	10000826 	beq	r2,zero,81103e1c <bSdmaDmaM1Transfer+0x18c>
81103dfc:	10800060 	cmpeqi	r2,r2,1
81103e00:	10000d26 	beq	r2,zero,81103e38 <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e04:	00900004 	movi	r2,16384
81103e08:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e0c:	00800044 	movi	r2,1
81103e10:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e14:	e03ff615 	stw	zero,-40(fp)
			break;
81103e18:	00000a06 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e1c:	00800074 	movhi	r2,1
81103e20:	10900004 	addi	r2,r2,16384
81103e24:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e30:	e03ff615 	stw	zero,-40(fp)
			break;
81103e34:	00000306 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bStatus = FALSE;
81103e38:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e3c:	e03ff615 	stw	zero,-40(fp)
			break;
81103e40:	0001883a 	nop
		}
		break;
81103e44:	00006b06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e48:	e0bffd03 	ldbu	r2,-12(fp)
81103e4c:	10000826 	beq	r2,zero,81103e70 <bSdmaDmaM1Transfer+0x1e0>
81103e50:	10800060 	cmpeqi	r2,r2,1
81103e54:	10000d26 	beq	r2,zero,81103e8c <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e58:	00980004 	movi	r2,24576
81103e5c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e60:	00800044 	movi	r2,1
81103e64:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e68:	e03ff615 	stw	zero,-40(fp)
			break;
81103e6c:	00000a06 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e70:	00800074 	movhi	r2,1
81103e74:	10980004 	addi	r2,r2,24576
81103e78:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e7c:	00800044 	movi	r2,1
81103e80:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103e84:	e03ff615 	stw	zero,-40(fp)
			break;
81103e88:	00000306 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		default:
			bStatus = FALSE;
81103e8c:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e90:	e03ff615 	stw	zero,-40(fp)
			break;
81103e94:	0001883a 	nop
		}
		break;
81103e98:	00005606 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e9c:	e0bffd03 	ldbu	r2,-12(fp)
81103ea0:	10000826 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea4:	10800060 	cmpeqi	r2,r2,1
81103ea8:	10000d26 	beq	r2,zero,81103ee0 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103eac:	00a00014 	movui	r2,32768
81103eb0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103eb4:	00800044 	movi	r2,1
81103eb8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ebc:	e03ff615 	stw	zero,-40(fp)
			break;
81103ec0:	00000a06 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a00004 	addi	r2,r2,-32768
81103ecc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103ed8:	e03ff615 	stw	zero,-40(fp)
			break;
81103edc:	00000306 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		default:
			bStatus = FALSE;
81103ee0:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103ee4:	e03ff615 	stw	zero,-40(fp)
			break;
81103ee8:	0001883a 	nop
		}
		break;
81103eec:	00004106 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ef0:	e0bffd03 	ldbu	r2,-12(fp)
81103ef4:	10000826 	beq	r2,zero,81103f18 <bSdmaDmaM1Transfer+0x288>
81103ef8:	10800060 	cmpeqi	r2,r2,1
81103efc:	10000d26 	beq	r2,zero,81103f34 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f00:	00a80014 	movui	r2,40960
81103f04:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f08:	00800044 	movi	r2,1
81103f0c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f10:	e03ff615 	stw	zero,-40(fp)
			break;
81103f14:	00000a06 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f18:	008000b4 	movhi	r2,2
81103f1c:	10a80004 	addi	r2,r2,-24576
81103f20:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f24:	00800044 	movi	r2,1
81103f28:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f2c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f30:	00000306 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bStatus = FALSE;
81103f34:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f38:	e03ff615 	stw	zero,-40(fp)
			break;
81103f3c:	0001883a 	nop
		}
		break;
81103f40:	00002c06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103f44:	e0bffd03 	ldbu	r2,-12(fp)
81103f48:	10000826 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
81103f4c:	10800060 	cmpeqi	r2,r2,1
81103f50:	10000d26 	beq	r2,zero,81103f88 <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f54:	00b00014 	movui	r2,49152
81103f58:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f5c:	00800044 	movi	r2,1
81103f60:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f64:	e03ff615 	stw	zero,-40(fp)
			break;
81103f68:	00000a06 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f6c:	008000b4 	movhi	r2,2
81103f70:	10b00004 	addi	r2,r2,-16384
81103f74:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f78:	00800044 	movi	r2,1
81103f7c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103f80:	e03ff615 	stw	zero,-40(fp)
			break;
81103f84:	00000306 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		default:
			bStatus = FALSE;
81103f88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f8c:	e03ff615 	stw	zero,-40(fp)
			break;
81103f90:	0001883a 	nop
		}
		break;
81103f94:	00001706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f98:	e0bffd03 	ldbu	r2,-12(fp)
81103f9c:	10000826 	beq	r2,zero,81103fc0 <bSdmaDmaM1Transfer+0x330>
81103fa0:	10800060 	cmpeqi	r2,r2,1
81103fa4:	10000d26 	beq	r2,zero,81103fdc <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103fa8:	00b80014 	movui	r2,57344
81103fac:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103fb0:	00800044 	movi	r2,1
81103fb4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fb8:	e03ff615 	stw	zero,-40(fp)
			break;
81103fbc:	00000a06 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103fc0:	008000b4 	movhi	r2,2
81103fc4:	10b80004 	addi	r2,r2,-8192
81103fc8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103fcc:	00800044 	movi	r2,1
81103fd0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81103fd4:	e03ff615 	stw	zero,-40(fp)
			break;
81103fd8:	00000306 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		default:
			bStatus = FALSE;
81103fdc:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103fe0:	e03ff615 	stw	zero,-40(fp)
			break;
81103fe4:	0001883a 	nop
		}
		break;
81103fe8:	00000206 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	default:
		bStatus = FALSE;
81103fec:	e03ff315 	stw	zero,-52(fp)
		break;
81103ff0:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103ff4:	e0bffb17 	ldw	r2,-20(fp)
81103ff8:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103ffc:	e03ff915 	stw	zero,-28(fp)

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
81104000:	e0bff317 	ldw	r2,-52(fp)
81104004:	10003226 	beq	r2,zero,811040d0 <bSdmaDmaM1Transfer+0x440>
81104008:	e0bff617 	ldw	r2,-40(fp)
8110400c:	10003026 	beq	r2,zero,811040d0 <bSdmaDmaM1Transfer+0x440>
81104010:	e0bffc0b 	ldhu	r2,-16(fp)
81104014:	10800468 	cmpgeui	r2,r2,17
81104018:	10002d1e 	bne	r2,zero,811040d0 <bSdmaDmaM1Transfer+0x440>
		if (pxDmaM1Dev == NULL) {
8110401c:	d0a03917 	ldw	r2,-32540(gp)
81104020:	1000041e 	bne	r2,zero,81104034 <bSdmaDmaM1Transfer+0x3a4>
			bStatus = FALSE;
81104024:	e03ff315 	stw	zero,-52(fp)
81104028:	00002906 	br	811040d0 <bSdmaDmaM1Transfer+0x440>
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
8110402c:	01000044 	movi	r4,1
81104030:	11360040 	call	81136004 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81104034:	d0a03917 	ldw	r2,-32540(gp)
81104038:	10800317 	ldw	r2,12(r2)
8110403c:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104040:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81104044:	103ff91e 	bne	r2,zero,8110402c <__reset+0xfb0e402c>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81104048:	d2203917 	ldw	r8,-32540(gp)
8110404c:	e1bff817 	ldw	r6,-32(fp)
81104050:	e1fff417 	ldw	r7,-48(fp)
81104054:	e0bffc0b 	ldhu	r2,-16(fp)
81104058:	10802224 	muli	r2,r2,136
8110405c:	e0fff917 	ldw	r3,-28(fp)
81104060:	e13ff517 	ldw	r4,-44(fp)
81104064:	01400044 	movi	r5,1
81104068:	d9400815 	stw	r5,32(sp)
8110406c:	01400044 	movi	r5,1
81104070:	d9400715 	stw	r5,28(sp)
81104074:	01400044 	movi	r5,1
81104078:	d9400615 	stw	r5,24(sp)
8110407c:	01400044 	movi	r5,1
81104080:	d9400515 	stw	r5,20(sp)
81104084:	01400044 	movi	r5,1
81104088:	d9400415 	stw	r5,16(sp)
8110408c:	d9000315 	stw	r4,12(sp)
81104090:	d8c00215 	stw	r3,8(sp)
81104094:	e0fffa17 	ldw	r3,-24(fp)
81104098:	d8c00115 	stw	r3,4(sp)
8110409c:	d8800015 	stw	r2,0(sp)
811040a0:	800b883a 	mov	r5,r16
811040a4:	4009883a 	mov	r4,r8
811040a8:	110bbe40 	call	8110bbe4 <iMsgdmaConstructExtendedMmToMmDescriptor>
811040ac:	10000226 	beq	r2,zero,811040b8 <bSdmaDmaM1Transfer+0x428>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
811040b0:	e03ff315 	stw	zero,-52(fp)
811040b4:	00000606 	br	811040d0 <bSdmaDmaM1Transfer+0x440>
//					break;
				} else {
					if (iMsgdmaExtendedDescriptorAsyncTransfer(pxDmaM1Dev,
811040b8:	d0a03917 	ldw	r2,-32540(gp)
811040bc:	800b883a 	mov	r5,r16
811040c0:	1009883a 	mov	r4,r2
811040c4:	110bca40 	call	8110bca4 <iMsgdmaExtendedDescriptorAsyncTransfer>
811040c8:	10000126 	beq	r2,zero,811040d0 <bSdmaDmaM1Transfer+0x440>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
811040cc:	e03ff315 	stw	zero,-52(fp)
//					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
//			}
		}
	}
	return bStatus;
811040d0:	e0bff317 	ldw	r2,-52(fp)
}
811040d4:	e6ffff04 	addi	sp,fp,-4
811040d8:	dfc00217 	ldw	ra,8(sp)
811040dc:	df000117 	ldw	fp,4(sp)
811040e0:	dc000017 	ldw	r16,0(sp)
811040e4:	dec00304 	addi	sp,sp,12
811040e8:	f800283a 	ret

811040ec <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
811040ec:	deffe804 	addi	sp,sp,-96
811040f0:	de00012e 	bgeu	sp,et,811040f8 <bSdmaDmaM2Transfer+0xc>
811040f4:	003b68fa 	trap	3
811040f8:	dfc01715 	stw	ra,92(sp)
811040fc:	df001615 	stw	fp,88(sp)
81104100:	dc001515 	stw	r16,84(sp)
81104104:	df001604 	addi	fp,sp,88
81104108:	e13ffb15 	stw	r4,-20(fp)
8110410c:	2809883a 	mov	r4,r5
81104110:	3007883a 	mov	r3,r6
81104114:	3805883a 	mov	r2,r7
81104118:	e13ffc0d 	sth	r4,-16(fp)
8110411c:	e0fffd05 	stb	r3,-12(fp)
81104120:	e0bffe05 	stb	r2,-8(fp)
81104124:	defff004 	addi	sp,sp,-64
81104128:	d8800904 	addi	r2,sp,36
8110412c:	108007c4 	addi	r2,r2,31
81104130:	1004d17a 	srli	r2,r2,5
81104134:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81104138:	00800044 	movi	r2,1
8110413c:	e0bff315 	stw	r2,-52(fp)
	alt_u16 usiCnt = 0;
81104140:	e03ff70d 	sth	zero,-36(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104144:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
81104148:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
8110414c:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104150:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104154:	e03ffa15 	stw	zero,-24(fp)

	bool bBufferEmptyFlag = FALSE;
81104158:	e03ff615 	stw	zero,-40(fp)

	switch (ucChBufferId) {
8110415c:	e0bffe03 	ldbu	r2,-8(fp)
81104160:	10c00228 	cmpgeui	r3,r2,8
81104164:	1800b81e 	bne	r3,zero,81104448 <bSdmaDmaM2Transfer+0x35c>
81104168:	100690ba 	slli	r3,r2,2
8110416c:	00a04434 	movhi	r2,33040
81104170:	10906004 	addi	r2,r2,16768
81104174:	1885883a 	add	r2,r3,r2
81104178:	10800017 	ldw	r2,0(r2)
8110417c:	1000683a 	jmp	r2
81104180:	811041a0 	cmpeqi	r4,r16,16646
81104184:	811041f4 	orhi	r4,r16,16647
81104188:	81104250 	cmplti	r4,r16,16649
8110418c:	811042a4 	muli	r4,r16,16650
81104190:	811042f8 	rdprs	r4,r16,16651
81104194:	8110434c 	andi	r4,r16,16653
81104198:	811043a0 	cmpeqi	r4,r16,16654
8110419c:	811043f4 	orhi	r4,r16,16655
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
811041a0:	e0bffd03 	ldbu	r2,-12(fp)
811041a4:	10000826 	beq	r2,zero,811041c8 <bSdmaDmaM2Transfer+0xdc>
811041a8:	10800060 	cmpeqi	r2,r2,1
811041ac:	10000d26 	beq	r2,zero,811041e4 <bSdmaDmaM2Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
811041b0:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
811041b4:	00800044 	movi	r2,1
811041b8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
811041bc:	11066000 	call	81106600 <bFeebGetCh1RightBufferEmpty>
811041c0:	e0bff615 	stw	r2,-40(fp)
			break;
811041c4:	00000a06 	br	811041f0 <bSdmaDmaM2Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811041c8:	00800074 	movhi	r2,1
811041cc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811041d0:	00800044 	movi	r2,1
811041d4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
811041d8:	11065980 	call	81106598 <bFeebGetCh1LeftBufferEmpty>
811041dc:	e0bff615 	stw	r2,-40(fp)
			break;
811041e0:	00000306 	br	811041f0 <bSdmaDmaM2Transfer+0x104>
		default:
			bStatus = FALSE;
811041e4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811041e8:	e03ff615 	stw	zero,-40(fp)
			break;
811041ec:	0001883a 	nop
		}
		break;
811041f0:	00009706 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
811041f4:	e0bffd03 	ldbu	r2,-12(fp)
811041f8:	10000926 	beq	r2,zero,81104220 <bSdmaDmaM2Transfer+0x134>
811041fc:	10800060 	cmpeqi	r2,r2,1
81104200:	10000f26 	beq	r2,zero,81104240 <bSdmaDmaM2Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81104204:	00880004 	movi	r2,8192
81104208:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
8110420c:	00800044 	movi	r2,1
81104210:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81104214:	11066d00 	call	811066d0 <bFeebGetCh2RightBufferEmpty>
81104218:	e0bff615 	stw	r2,-40(fp)
			break;
8110421c:	00000b06 	br	8110424c <bSdmaDmaM2Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81104220:	00800074 	movhi	r2,1
81104224:	10880004 	addi	r2,r2,8192
81104228:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
8110422c:	00800044 	movi	r2,1
81104230:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81104234:	11066680 	call	81106668 <bFeebGetCh2LeftBufferEmpty>
81104238:	e0bff615 	stw	r2,-40(fp)
			break;
8110423c:	00000306 	br	8110424c <bSdmaDmaM2Transfer+0x160>
		default:
			bStatus = FALSE;
81104240:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104244:	e03ff615 	stw	zero,-40(fp)
			break;
81104248:	0001883a 	nop
		}
		break;
8110424c:	00008006 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81104250:	e0bffd03 	ldbu	r2,-12(fp)
81104254:	10000826 	beq	r2,zero,81104278 <bSdmaDmaM2Transfer+0x18c>
81104258:	10800060 	cmpeqi	r2,r2,1
8110425c:	10000d26 	beq	r2,zero,81104294 <bSdmaDmaM2Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104260:	00900004 	movi	r2,16384
81104264:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104268:	00800044 	movi	r2,1
8110426c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104270:	e03ff615 	stw	zero,-40(fp)
			break;
81104274:	00000a06 	br	811042a0 <bSdmaDmaM2Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104278:	00800074 	movhi	r2,1
8110427c:	10900004 	addi	r2,r2,16384
81104280:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104284:	00800044 	movi	r2,1
81104288:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110428c:	e03ff615 	stw	zero,-40(fp)
			break;
81104290:	00000306 	br	811042a0 <bSdmaDmaM2Transfer+0x1b4>
		default:
			bStatus = FALSE;
81104294:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104298:	e03ff615 	stw	zero,-40(fp)
			break;
8110429c:	0001883a 	nop
		}
		break;
811042a0:	00006b06 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
811042a4:	e0bffd03 	ldbu	r2,-12(fp)
811042a8:	10000826 	beq	r2,zero,811042cc <bSdmaDmaM2Transfer+0x1e0>
811042ac:	10800060 	cmpeqi	r2,r2,1
811042b0:	10000d26 	beq	r2,zero,811042e8 <bSdmaDmaM2Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
811042b4:	00980004 	movi	r2,24576
811042b8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
811042bc:	00800044 	movi	r2,1
811042c0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042c4:	e03ff615 	stw	zero,-40(fp)
			break;
811042c8:	00000a06 	br	811042f4 <bSdmaDmaM2Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
811042cc:	00800074 	movhi	r2,1
811042d0:	10980004 	addi	r2,r2,24576
811042d4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
811042d8:	00800044 	movi	r2,1
811042dc:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811042e0:	e03ff615 	stw	zero,-40(fp)
			break;
811042e4:	00000306 	br	811042f4 <bSdmaDmaM2Transfer+0x208>
		default:
			bStatus = FALSE;
811042e8:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811042ec:	e03ff615 	stw	zero,-40(fp)
			break;
811042f0:	0001883a 	nop
		}
		break;
811042f4:	00005606 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
811042f8:	e0bffd03 	ldbu	r2,-12(fp)
811042fc:	10000826 	beq	r2,zero,81104320 <bSdmaDmaM2Transfer+0x234>
81104300:	10800060 	cmpeqi	r2,r2,1
81104304:	10000d26 	beq	r2,zero,8110433c <bSdmaDmaM2Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104308:	00a00014 	movui	r2,32768
8110430c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81104310:	00800044 	movi	r2,1
81104314:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104318:	e03ff615 	stw	zero,-40(fp)
			break;
8110431c:	00000a06 	br	81104348 <bSdmaDmaM2Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104320:	008000b4 	movhi	r2,2
81104324:	10a00004 	addi	r2,r2,-32768
81104328:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
8110432c:	00800044 	movi	r2,1
81104330:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104334:	e03ff615 	stw	zero,-40(fp)
			break;
81104338:	00000306 	br	81104348 <bSdmaDmaM2Transfer+0x25c>
		default:
			bStatus = FALSE;
8110433c:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104340:	e03ff615 	stw	zero,-40(fp)
			break;
81104344:	0001883a 	nop
		}
		break;
81104348:	00004106 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
8110434c:	e0bffd03 	ldbu	r2,-12(fp)
81104350:	10000826 	beq	r2,zero,81104374 <bSdmaDmaM2Transfer+0x288>
81104354:	10800060 	cmpeqi	r2,r2,1
81104358:	10000d26 	beq	r2,zero,81104390 <bSdmaDmaM2Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
8110435c:	00a80014 	movui	r2,40960
81104360:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81104364:	00800044 	movi	r2,1
81104368:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
8110436c:	e03ff615 	stw	zero,-40(fp)
			break;
81104370:	00000a06 	br	8110439c <bSdmaDmaM2Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81104374:	008000b4 	movhi	r2,2
81104378:	10a80004 	addi	r2,r2,-24576
8110437c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104380:	00800044 	movi	r2,1
81104384:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104388:	e03ff615 	stw	zero,-40(fp)
			break;
8110438c:	00000306 	br	8110439c <bSdmaDmaM2Transfer+0x2b0>
		default:
			bStatus = FALSE;
81104390:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81104394:	e03ff615 	stw	zero,-40(fp)
			break;
81104398:	0001883a 	nop
		}
		break;
8110439c:	00002c06 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811043a0:	e0bffd03 	ldbu	r2,-12(fp)
811043a4:	10000826 	beq	r2,zero,811043c8 <bSdmaDmaM2Transfer+0x2dc>
811043a8:	10800060 	cmpeqi	r2,r2,1
811043ac:	10000d26 	beq	r2,zero,811043e4 <bSdmaDmaM2Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
811043b0:	00b00014 	movui	r2,49152
811043b4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
811043b8:	00800044 	movi	r2,1
811043bc:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043c0:	e03ff615 	stw	zero,-40(fp)
			break;
811043c4:	00000a06 	br	811043f0 <bSdmaDmaM2Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
811043c8:	008000b4 	movhi	r2,2
811043cc:	10b00004 	addi	r2,r2,-16384
811043d0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
811043d4:	00800044 	movi	r2,1
811043d8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
811043dc:	e03ff615 	stw	zero,-40(fp)
			break;
811043e0:	00000306 	br	811043f0 <bSdmaDmaM2Transfer+0x304>
		default:
			bStatus = FALSE;
811043e4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
811043e8:	e03ff615 	stw	zero,-40(fp)
			break;
811043ec:	0001883a 	nop
		}
		break;
811043f0:	00001706 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
811043f4:	e0bffd03 	ldbu	r2,-12(fp)
811043f8:	10000826 	beq	r2,zero,8110441c <bSdmaDmaM2Transfer+0x330>
811043fc:	10800060 	cmpeqi	r2,r2,1
81104400:	10000d26 	beq	r2,zero,81104438 <bSdmaDmaM2Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81104404:	00b80014 	movui	r2,57344
81104408:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
8110440c:	00800044 	movi	r2,1
81104410:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104414:	e03ff615 	stw	zero,-40(fp)
			break;
81104418:	00000a06 	br	81104444 <bSdmaDmaM2Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
8110441c:	008000b4 	movhi	r2,2
81104420:	10b80004 	addi	r2,r2,-8192
81104424:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81104428:	00800044 	movi	r2,1
8110442c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = FALSE;
81104430:	e03ff615 	stw	zero,-40(fp)
			break;
81104434:	00000306 	br	81104444 <bSdmaDmaM2Transfer+0x358>
		default:
			bStatus = FALSE;
81104438:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
8110443c:	e03ff615 	stw	zero,-40(fp)
			break;
81104440:	0001883a 	nop
		}
		break;
81104444:	00000206 	br	81104450 <bSdmaDmaM2Transfer+0x364>
	default:
		bStatus = FALSE;
81104448:	e03ff315 	stw	zero,-52(fp)
		break;
8110444c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
81104450:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104454:	00a00034 	movhi	r2,32768
81104458:	1885883a 	add	r2,r3,r2
8110445c:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104460:	e03ff915 	stw	zero,-28(fp)

	if ((bStatus) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
81104464:	e0bff317 	ldw	r2,-52(fp)
81104468:	10003226 	beq	r2,zero,81104534 <bSdmaDmaM2Transfer+0x448>
8110446c:	e0bff617 	ldw	r2,-40(fp)
81104470:	10003026 	beq	r2,zero,81104534 <bSdmaDmaM2Transfer+0x448>
81104474:	e0bffc0b 	ldhu	r2,-16(fp)
81104478:	10800468 	cmpgeui	r2,r2,17
8110447c:	10002d1e 	bne	r2,zero,81104534 <bSdmaDmaM2Transfer+0x448>
		if (pxDmaM2Dev == NULL) {
81104480:	d0a03a17 	ldw	r2,-32536(gp)
81104484:	1000041e 	bne	r2,zero,81104498 <bSdmaDmaM2Transfer+0x3ac>
			bStatus = FALSE;
81104488:	e03ff315 	stw	zero,-52(fp)
8110448c:	00002906 	br	81104534 <bSdmaDmaM2Transfer+0x448>
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81104490:	01000044 	movi	r4,1
81104494:	11360040 	call	81136004 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81104498:	d0a03a17 	ldw	r2,-32536(gp)
8110449c:	10800317 	ldw	r2,12(r2)
811044a0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811044a4:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
//			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
811044a8:	103ff91e 	bne	r2,zero,81104490 <__reset+0xfb0e4490>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811044ac:	d2203a17 	ldw	r8,-32536(gp)
811044b0:	e1bff817 	ldw	r6,-32(fp)
811044b4:	e1fff417 	ldw	r7,-48(fp)
811044b8:	e0bffc0b 	ldhu	r2,-16(fp)
811044bc:	10802224 	muli	r2,r2,136
811044c0:	e0fff917 	ldw	r3,-28(fp)
811044c4:	e13ff517 	ldw	r4,-44(fp)
811044c8:	01400044 	movi	r5,1
811044cc:	d9400815 	stw	r5,32(sp)
811044d0:	01400044 	movi	r5,1
811044d4:	d9400715 	stw	r5,28(sp)
811044d8:	01400044 	movi	r5,1
811044dc:	d9400615 	stw	r5,24(sp)
811044e0:	01400044 	movi	r5,1
811044e4:	d9400515 	stw	r5,20(sp)
811044e8:	01400044 	movi	r5,1
811044ec:	d9400415 	stw	r5,16(sp)
811044f0:	d9000315 	stw	r4,12(sp)
811044f4:	d8c00215 	stw	r3,8(sp)
811044f8:	e0fffa17 	ldw	r3,-24(fp)
811044fc:	d8c00115 	stw	r3,4(sp)
81104500:	d8800015 	stw	r2,0(sp)
81104504:	800b883a 	mov	r5,r16
81104508:	4009883a 	mov	r4,r8
8110450c:	110bbe40 	call	8110bbe4 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104510:	10000226 	beq	r2,zero,8110451c <bSdmaDmaM2Transfer+0x430>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104514:	e03ff315 	stw	zero,-52(fp)
81104518:	00000606 	br	81104534 <bSdmaDmaM2Transfer+0x448>
//					break;
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
8110451c:	d0a03a17 	ldw	r2,-32536(gp)
81104520:	800b883a 	mov	r5,r16
81104524:	1009883a 	mov	r4,r2
81104528:	110bce80 	call	8110bce8 <iMsgdmaExtendedDescriptorSyncTransfer>
8110452c:	10000126 	beq	r2,zero,81104534 <bSdmaDmaM2Transfer+0x448>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104530:	e03ff315 	stw	zero,-52(fp)
//					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
//			}
		}
	}
	return bStatus;
81104534:	e0bff317 	ldw	r2,-52(fp)
}
81104538:	e6ffff04 	addi	sp,fp,-4
8110453c:	dfc00217 	ldw	ra,8(sp)
81104540:	df000117 	ldw	fp,4(sp)
81104544:	dc000017 	ldw	r16,0(sp)
81104548:	dec00304 	addi	sp,sp,12
8110454c:	f800283a 	ret

81104550 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
81104550:	defff904 	addi	sp,sp,-28
81104554:	de00012e 	bgeu	sp,et,8110455c <bCommSetGlobalIrqEn+0xc>
81104558:	003b68fa 	trap	3
8110455c:	dfc00615 	stw	ra,24(sp)
81104560:	df000515 	stw	fp,20(sp)
81104564:	df000504 	addi	fp,sp,20
81104568:	e13ffe15 	stw	r4,-8(fp)
8110456c:	2805883a 	mov	r2,r5
81104570:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104574:	00800044 	movi	r2,1
81104578:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110457c:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
81104580:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
81104584:	e0bfff03 	ldbu	r2,-4(fp)
81104588:	10c00228 	cmpgeui	r3,r2,8
8110458c:	18002e1e 	bne	r3,zero,81104648 <bCommSetGlobalIrqEn+0xf8>
81104590:	100690ba 	slli	r3,r2,2
81104594:	00a04434 	movhi	r2,33040
81104598:	10916a04 	addi	r2,r2,17832
8110459c:	1885883a 	add	r2,r3,r2
811045a0:	10800017 	ldw	r2,0(r2)
811045a4:	1000683a 	jmp	r2
811045a8:	811045c8 	cmpgei	r4,r16,16663
811045ac:	811045d8 	cmpnei	r4,r16,16663
811045b0:	811045e8 	cmpgeui	r4,r16,16663
811045b4:	811045f8 	rdprs	r4,r16,16663
811045b8:	81104608 	cmpgei	r4,r16,16664
811045bc:	81104618 	cmpnei	r4,r16,16664
811045c0:	81104628 	cmpgeui	r4,r16,16664
811045c4:	81104638 	rdprs	r4,r16,16664
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811045c8:	00a04834 	movhi	r2,33056
811045cc:	108b0004 	addi	r2,r2,11264
811045d0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045d4:	00001e06 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811045d8:	00a04834 	movhi	r2,33056
811045dc:	108a0004 	addi	r2,r2,10240
811045e0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045e4:	00001a06 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811045e8:	00a04834 	movhi	r2,33056
811045ec:	108b0004 	addi	r2,r2,11264
811045f0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045f4:	00001606 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811045f8:	00a04834 	movhi	r2,33056
811045fc:	108a0004 	addi	r2,r2,10240
81104600:	e0bffd15 	stw	r2,-12(fp)
		break;
81104604:	00001206 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104608:	00a04834 	movhi	r2,33056
8110460c:	108b0004 	addi	r2,r2,11264
81104610:	e0bffd15 	stw	r2,-12(fp)
		break;
81104614:	00000e06 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104618:	00a04834 	movhi	r2,33056
8110461c:	108a0004 	addi	r2,r2,10240
81104620:	e0bffd15 	stw	r2,-12(fp)
		break;
81104624:	00000a06 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104628:	00a04834 	movhi	r2,33056
8110462c:	108b0004 	addi	r2,r2,11264
81104630:	e0bffd15 	stw	r2,-12(fp)
		break;
81104634:	00000606 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104638:	00a04834 	movhi	r2,33056
8110463c:	108a0004 	addi	r2,r2,10240
81104640:	e0bffd15 	stw	r2,-12(fp)
		break;
81104644:	00000206 	br	81104650 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
81104648:	e03ffb15 	stw	zero,-20(fp)
		break;
8110464c:	0001883a 	nop
	}

	if (bStatus) {
81104650:	e0bffb17 	ldw	r2,-20(fp)
81104654:	10001326 	beq	r2,zero,811046a4 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
81104658:	01400444 	movi	r5,17
8110465c:	e13ffd17 	ldw	r4,-12(fp)
81104660:	11047e00 	call	811047e0 <uliCommReadReg>
81104664:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
81104668:	e0bffe17 	ldw	r2,-8(fp)
8110466c:	10000426 	beq	r2,zero,81104680 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
81104670:	e0bffc17 	ldw	r2,-16(fp)
81104674:	10800074 	orhi	r2,r2,1
81104678:	e0bffc15 	stw	r2,-16(fp)
8110467c:	00000506 	br	81104694 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
81104680:	e0fffc17 	ldw	r3,-16(fp)
81104684:	00bffff4 	movhi	r2,65535
81104688:	10bfffc4 	addi	r2,r2,-1
8110468c:	1884703a 	and	r2,r3,r2
81104690:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
81104694:	e1bffc17 	ldw	r6,-16(fp)
81104698:	01400444 	movi	r5,17
8110469c:	e13ffd17 	ldw	r4,-12(fp)
811046a0:	110478c0 	call	8110478c <vCommWriteReg>
	}

	return bStatus;
811046a4:	e0bffb17 	ldw	r2,-20(fp)
}
811046a8:	e037883a 	mov	sp,fp
811046ac:	dfc00117 	ldw	ra,4(sp)
811046b0:	df000017 	ldw	fp,0(sp)
811046b4:	dec00204 	addi	sp,sp,8
811046b8:	f800283a 	ret

811046bc <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
811046bc:	defffb04 	addi	sp,sp,-20
811046c0:	de00012e 	bgeu	sp,et,811046c8 <bCommInitCh+0xc>
811046c4:	003b68fa 	trap	3
811046c8:	dfc00415 	stw	ra,16(sp)
811046cc:	df000315 	stw	fp,12(sp)
811046d0:	df000304 	addi	fp,sp,12
811046d4:	e13ffe15 	stw	r4,-8(fp)
811046d8:	2805883a 	mov	r2,r5
811046dc:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811046e0:	00800044 	movi	r2,1
811046e4:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811046e8:	e0bffe17 	ldw	r2,-8(fp)
811046ec:	10805704 	addi	r2,r2,348
811046f0:	e0ffff03 	ldbu	r3,-4(fp)
811046f4:	180b883a 	mov	r5,r3
811046f8:	1009883a 	mov	r4,r2
811046fc:	110a6bc0 	call	8110a6bc <bSpwcInitCh>
81104700:	1000011e 	bne	r2,zero,81104708 <bCommInitCh+0x4c>
		bStatus = FALSE;
81104704:	e03ffd15 	stw	zero,-12(fp)
	}
	//vFeebInitIrq(ucCommCh);

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104708:	e0bffe17 	ldw	r2,-8(fp)
8110470c:	10800904 	addi	r2,r2,36
81104710:	e0ffff03 	ldbu	r3,-4(fp)
81104714:	180b883a 	mov	r5,r3
81104718:	1009883a 	mov	r4,r2
8110471c:	1106ae00 	call	81106ae0 <bFeebInitCh>
81104720:	1000011e 	bne	r2,zero,81104728 <bCommInitCh+0x6c>
		bStatus = FALSE;
81104724:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104728:	e0bffe17 	ldw	r2,-8(fp)
8110472c:	10801104 	addi	r2,r2,68
81104730:	e0ffff03 	ldbu	r3,-4(fp)
81104734:	180b883a 	mov	r5,r3
81104738:	1009883a 	mov	r4,r2
8110473c:	1109d180 	call	81109d18 <bRmapInitCh>
81104740:	1000011e 	bne	r2,zero,81104748 <bCommInitCh+0x8c>
		bStatus = FALSE;
81104744:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104748:	e0bfff03 	ldbu	r2,-4(fp)
8110474c:	1009883a 	mov	r4,r2
81104750:	11077540 	call	81107754 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104754:	e0bffe17 	ldw	r2,-8(fp)
81104758:	10800104 	addi	r2,r2,4
8110475c:	e0ffff03 	ldbu	r3,-4(fp)
81104760:	180b883a 	mov	r5,r3
81104764:	1009883a 	mov	r4,r2
81104768:	1104e580 	call	81104e58 <bDpktInitCh>
8110476c:	1000011e 	bne	r2,zero,81104774 <bCommInitCh+0xb8>
		bStatus = FALSE;
81104770:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
81104774:	e0bffd17 	ldw	r2,-12(fp)
}
81104778:	e037883a 	mov	sp,fp
8110477c:	dfc00117 	ldw	ra,4(sp)
81104780:	df000017 	ldw	fp,0(sp)
81104784:	dec00204 	addi	sp,sp,8
81104788:	f800283a 	ret

8110478c <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110478c:	defffc04 	addi	sp,sp,-16
81104790:	de00012e 	bgeu	sp,et,81104798 <vCommWriteReg+0xc>
81104794:	003b68fa 	trap	3
81104798:	df000315 	stw	fp,12(sp)
8110479c:	df000304 	addi	fp,sp,12
811047a0:	e13ffd15 	stw	r4,-12(fp)
811047a4:	e17ffe15 	stw	r5,-8(fp)
811047a8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811047ac:	e0bffe17 	ldw	r2,-8(fp)
811047b0:	1085883a 	add	r2,r2,r2
811047b4:	1085883a 	add	r2,r2,r2
811047b8:	1007883a 	mov	r3,r2
811047bc:	e0bffd17 	ldw	r2,-12(fp)
811047c0:	10c5883a 	add	r2,r2,r3
811047c4:	e0ffff17 	ldw	r3,-4(fp)
811047c8:	10c00015 	stw	r3,0(r2)
}
811047cc:	0001883a 	nop
811047d0:	e037883a 	mov	sp,fp
811047d4:	df000017 	ldw	fp,0(sp)
811047d8:	dec00104 	addi	sp,sp,4
811047dc:	f800283a 	ret

811047e0 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811047e0:	defffc04 	addi	sp,sp,-16
811047e4:	de00012e 	bgeu	sp,et,811047ec <uliCommReadReg+0xc>
811047e8:	003b68fa 	trap	3
811047ec:	df000315 	stw	fp,12(sp)
811047f0:	df000304 	addi	fp,sp,12
811047f4:	e13ffe15 	stw	r4,-8(fp)
811047f8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811047fc:	e0bfff17 	ldw	r2,-4(fp)
81104800:	1085883a 	add	r2,r2,r2
81104804:	1085883a 	add	r2,r2,r2
81104808:	1007883a 	mov	r3,r2
8110480c:	e0bffe17 	ldw	r2,-8(fp)
81104810:	10c5883a 	add	r2,r2,r3
81104814:	10800017 	ldw	r2,0(r2)
81104818:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110481c:	e0bffd17 	ldw	r2,-12(fp)
}
81104820:	e037883a 	mov	sp,fp
81104824:	df000017 	ldw	fp,0(sp)
81104828:	dec00104 	addi	sp,sp,4
8110482c:	f800283a 	ret

81104830 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
81104830:	defffb04 	addi	sp,sp,-20
81104834:	de00012e 	bgeu	sp,et,8110483c <bDpktSetPacketConfig+0xc>
81104838:	003b68fa 	trap	3
8110483c:	dfc00415 	stw	ra,16(sp)
81104840:	df000315 	stw	fp,12(sp)
81104844:	df000304 	addi	fp,sp,12
81104848:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110484c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104850:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104854:	e0bfff17 	ldw	r2,-4(fp)
81104858:	10007a26 	beq	r2,zero,81104a44 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110485c:	e0bfff17 	ldw	r2,-4(fp)
81104860:	10800017 	ldw	r2,0(r2)
81104864:	01400204 	movi	r5,8
81104868:	1009883a 	mov	r4,r2
8110486c:	11050200 	call	81105020 <uliDpktReadReg>
81104870:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
81104874:	e0bffe17 	ldw	r2,-8(fp)
81104878:	10bfffec 	andhi	r2,r2,65535
8110487c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81104880:	e0bfff17 	ldw	r2,-4(fp)
81104884:	1080010b 	ldhu	r2,4(r2)
81104888:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
8110488c:	e0fffe17 	ldw	r3,-8(fp)
81104890:	1884b03a 	or	r2,r3,r2
81104894:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104898:	e0bffe17 	ldw	r2,-8(fp)
8110489c:	10bfffcc 	andi	r2,r2,65535
811048a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
811048a4:	e0bfff17 	ldw	r2,-4(fp)
811048a8:	1080018b 	ldhu	r2,6(r2)
811048ac:	10bfffcc 	andi	r2,r2,65535
811048b0:	1004943a 	slli	r2,r2,16
811048b4:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
811048b8:	e0bffe17 	ldw	r2,-8(fp)
811048bc:	10c4b03a 	or	r2,r2,r3
811048c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
811048c4:	e0bfff17 	ldw	r2,-4(fp)
811048c8:	10800017 	ldw	r2,0(r2)
811048cc:	e1bffe17 	ldw	r6,-8(fp)
811048d0:	01400204 	movi	r5,8
811048d4:	1009883a 	mov	r4,r2
811048d8:	1104fcc0 	call	81104fcc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048dc:	e0bfff17 	ldw	r2,-4(fp)
811048e0:	10800017 	ldw	r2,0(r2)
811048e4:	01400244 	movi	r5,9
811048e8:	1009883a 	mov	r4,r2
811048ec:	11050200 	call	81105020 <uliDpktReadReg>
811048f0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
811048f4:	e0bffe17 	ldw	r2,-8(fp)
811048f8:	10bfffec 	andhi	r2,r2,65535
811048fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
81104900:	e0bfff17 	ldw	r2,-4(fp)
81104904:	1080020b 	ldhu	r2,8(r2)
81104908:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
8110490c:	e0fffe17 	ldw	r3,-8(fp)
81104910:	1884b03a 	or	r2,r3,r2
81104914:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104918:	e0bffe17 	ldw	r2,-8(fp)
8110491c:	10bfffcc 	andi	r2,r2,65535
81104920:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104924:	e0bfff17 	ldw	r2,-4(fp)
81104928:	1080028b 	ldhu	r2,10(r2)
										<< 16));
8110492c:	10bfffcc 	andi	r2,r2,65535
81104930:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104934:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104938:	e0bffe17 	ldw	r2,-8(fp)
8110493c:	10c4b03a 	or	r2,r2,r3
81104940:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
81104944:	e0bfff17 	ldw	r2,-4(fp)
81104948:	10800017 	ldw	r2,0(r2)
8110494c:	e1bffe17 	ldw	r6,-8(fp)
81104950:	01400244 	movi	r5,9
81104954:	1009883a 	mov	r4,r2
81104958:	1104fcc0 	call	81104fcc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110495c:	e0bfff17 	ldw	r2,-4(fp)
81104960:	10800017 	ldw	r2,0(r2)
81104964:	01400284 	movi	r5,10
81104968:	1009883a 	mov	r4,r2
8110496c:	11050200 	call	81105020 <uliDpktReadReg>
81104970:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
81104974:	e0bffe17 	ldw	r2,-8(fp)
81104978:	10bfffec 	andhi	r2,r2,65535
8110497c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104980:	e0bfff17 	ldw	r2,-4(fp)
81104984:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104988:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
8110498c:	e0fffe17 	ldw	r3,-8(fp)
81104990:	1884b03a 	or	r2,r3,r2
81104994:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104998:	e0bfff17 	ldw	r2,-4(fp)
8110499c:	10800017 	ldw	r2,0(r2)
811049a0:	e1bffe17 	ldw	r6,-8(fp)
811049a4:	01400284 	movi	r5,10
811049a8:	1009883a 	mov	r4,r2
811049ac:	1104fcc0 	call	81104fcc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049b0:	e0bfff17 	ldw	r2,-4(fp)
811049b4:	10800017 	ldw	r2,0(r2)
811049b8:	014002c4 	movi	r5,11
811049bc:	1009883a 	mov	r4,r2
811049c0:	11050200 	call	81105020 <uliDpktReadReg>
811049c4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
811049c8:	e0fffe17 	ldw	r3,-8(fp)
811049cc:	00bfc004 	movi	r2,-256
811049d0:	1884703a 	and	r2,r3,r2
811049d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
811049d8:	e0bfff17 	ldw	r2,-4(fp)
811049dc:	10800383 	ldbu	r2,14(r2)
811049e0:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
811049e4:	e0fffe17 	ldw	r3,-8(fp)
811049e8:	1884b03a 	or	r2,r3,r2
811049ec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
811049f0:	e0fffe17 	ldw	r3,-8(fp)
811049f4:	00bffff4 	movhi	r2,65535
811049f8:	10803fc4 	addi	r2,r2,255
811049fc:	1884703a 	and	r2,r3,r2
81104a00:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104a04:	e0bfff17 	ldw	r2,-4(fp)
81104a08:	108003c3 	ldbu	r2,15(r2)
81104a0c:	10803fcc 	andi	r2,r2,255
81104a10:	1004923a 	slli	r2,r2,8
81104a14:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104a18:	e0fffe17 	ldw	r3,-8(fp)
81104a1c:	1884b03a 	or	r2,r3,r2
81104a20:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104a24:	e0bfff17 	ldw	r2,-4(fp)
81104a28:	10800017 	ldw	r2,0(r2)
81104a2c:	e1bffe17 	ldw	r6,-8(fp)
81104a30:	014002c4 	movi	r5,11
81104a34:	1009883a 	mov	r4,r2
81104a38:	1104fcc0 	call	81104fcc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104a3c:	00800044 	movi	r2,1
81104a40:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104a44:	e0bffd17 	ldw	r2,-12(fp)
}
81104a48:	e037883a 	mov	sp,fp
81104a4c:	dfc00117 	ldw	ra,4(sp)
81104a50:	df000017 	ldw	fp,0(sp)
81104a54:	dec00204 	addi	sp,sp,8
81104a58:	f800283a 	ret

81104a5c <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104a5c:	defffb04 	addi	sp,sp,-20
81104a60:	de00012e 	bgeu	sp,et,81104a68 <bDpktGetPacketConfig+0xc>
81104a64:	003b68fa 	trap	3
81104a68:	dfc00415 	stw	ra,16(sp)
81104a6c:	df000315 	stw	fp,12(sp)
81104a70:	df000304 	addi	fp,sp,12
81104a74:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104a78:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104a7c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104a80:	e0bfff17 	ldw	r2,-4(fp)
81104a84:	10003a26 	beq	r2,zero,81104b70 <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a88:	e0bfff17 	ldw	r2,-4(fp)
81104a8c:	10800017 	ldw	r2,0(r2)
81104a90:	01400204 	movi	r5,8
81104a94:	1009883a 	mov	r4,r2
81104a98:	11050200 	call	81105020 <uliDpktReadReg>
81104a9c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104aa0:	e0bffe17 	ldw	r2,-8(fp)
81104aa4:	1007883a 	mov	r3,r2
81104aa8:	e0bfff17 	ldw	r2,-4(fp)
81104aac:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104ab0:	e0bffe17 	ldw	r2,-8(fp)
81104ab4:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104ab8:	1007883a 	mov	r3,r2
81104abc:	e0bfff17 	ldw	r2,-4(fp)
81104ac0:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ac4:	e0bfff17 	ldw	r2,-4(fp)
81104ac8:	10800017 	ldw	r2,0(r2)
81104acc:	01400244 	movi	r5,9
81104ad0:	1009883a 	mov	r4,r2
81104ad4:	11050200 	call	81105020 <uliDpktReadReg>
81104ad8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104adc:	e0bffe17 	ldw	r2,-8(fp)
81104ae0:	1007883a 	mov	r3,r2
81104ae4:	e0bfff17 	ldw	r2,-4(fp)
81104ae8:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104aec:	e0bffe17 	ldw	r2,-8(fp)
81104af0:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104af4:	1007883a 	mov	r3,r2
81104af8:	e0bfff17 	ldw	r2,-4(fp)
81104afc:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b00:	e0bfff17 	ldw	r2,-4(fp)
81104b04:	10800017 	ldw	r2,0(r2)
81104b08:	01400284 	movi	r5,10
81104b0c:	1009883a 	mov	r4,r2
81104b10:	11050200 	call	81105020 <uliDpktReadReg>
81104b14:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104b18:	e0bffe17 	ldw	r2,-8(fp)
81104b1c:	1007883a 	mov	r3,r2
81104b20:	e0bfff17 	ldw	r2,-4(fp)
81104b24:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b28:	e0bfff17 	ldw	r2,-4(fp)
81104b2c:	10800017 	ldw	r2,0(r2)
81104b30:	014002c4 	movi	r5,11
81104b34:	1009883a 	mov	r4,r2
81104b38:	11050200 	call	81105020 <uliDpktReadReg>
81104b3c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104b40:	e0bffe17 	ldw	r2,-8(fp)
81104b44:	1007883a 	mov	r3,r2
81104b48:	e0bfff17 	ldw	r2,-4(fp)
81104b4c:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104b50:	e0bffe17 	ldw	r2,-8(fp)
81104b54:	10bfc00c 	andi	r2,r2,65280
81104b58:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104b5c:	1007883a 	mov	r3,r2
81104b60:	e0bfff17 	ldw	r2,-4(fp)
81104b64:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104b68:	00800044 	movi	r2,1
81104b6c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b70:	e0bffd17 	ldw	r2,-12(fp)
}
81104b74:	e037883a 	mov	sp,fp
81104b78:	dfc00117 	ldw	ra,4(sp)
81104b7c:	df000017 	ldw	fp,0(sp)
81104b80:	dec00204 	addi	sp,sp,8
81104b84:	f800283a 	ret

81104b88 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104b88:	defffb04 	addi	sp,sp,-20
81104b8c:	de00012e 	bgeu	sp,et,81104b94 <bDpktGetPacketHeader+0xc>
81104b90:	003b68fa 	trap	3
81104b94:	dfc00415 	stw	ra,16(sp)
81104b98:	df000315 	stw	fp,12(sp)
81104b9c:	df000304 	addi	fp,sp,12
81104ba0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104ba4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104ba8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bac:	e0bfff17 	ldw	r2,-4(fp)
81104bb0:	10002026 	beq	r2,zero,81104c34 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bb4:	e0bfff17 	ldw	r2,-4(fp)
81104bb8:	10800017 	ldw	r2,0(r2)
81104bbc:	01400304 	movi	r5,12
81104bc0:	1009883a 	mov	r4,r2
81104bc4:	11050200 	call	81105020 <uliDpktReadReg>
81104bc8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104bcc:	e0bffe17 	ldw	r2,-8(fp)
81104bd0:	1007883a 	mov	r3,r2
81104bd4:	e0bfff17 	ldw	r2,-4(fp)
81104bd8:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104bdc:	e0bffe17 	ldw	r2,-8(fp)
81104be0:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104be4:	1007883a 	mov	r3,r2
81104be8:	e0bfff17 	ldw	r2,-4(fp)
81104bec:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bf0:	e0bfff17 	ldw	r2,-4(fp)
81104bf4:	10800017 	ldw	r2,0(r2)
81104bf8:	01400344 	movi	r5,13
81104bfc:	1009883a 	mov	r4,r2
81104c00:	11050200 	call	81105020 <uliDpktReadReg>
81104c04:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104c08:	e0bffe17 	ldw	r2,-8(fp)
81104c0c:	1007883a 	mov	r3,r2
81104c10:	e0bfff17 	ldw	r2,-4(fp)
81104c14:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104c18:	e0bffe17 	ldw	r2,-8(fp)
81104c1c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104c20:	1007883a 	mov	r3,r2
81104c24:	e0bfff17 	ldw	r2,-4(fp)
81104c28:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104c2c:	00800044 	movi	r2,1
81104c30:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104c34:	e0bffd17 	ldw	r2,-12(fp)
}
81104c38:	e037883a 	mov	sp,fp
81104c3c:	dfc00117 	ldw	ra,4(sp)
81104c40:	df000017 	ldw	fp,0(sp)
81104c44:	dec00204 	addi	sp,sp,8
81104c48:	f800283a 	ret

81104c4c <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104c4c:	defffb04 	addi	sp,sp,-20
81104c50:	de00012e 	bgeu	sp,et,81104c58 <bDpktSetPixelDelay+0xc>
81104c54:	003b68fa 	trap	3
81104c58:	dfc00415 	stw	ra,16(sp)
81104c5c:	df000315 	stw	fp,12(sp)
81104c60:	df000304 	addi	fp,sp,12
81104c64:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104c68:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104c6c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104c70:	e0bfff17 	ldw	r2,-4(fp)
81104c74:	10004126 	beq	r2,zero,81104d7c <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c78:	e0bfff17 	ldw	r2,-4(fp)
81104c7c:	10800017 	ldw	r2,0(r2)
81104c80:	01400384 	movi	r5,14
81104c84:	1009883a 	mov	r4,r2
81104c88:	11050200 	call	81105020 <uliDpktReadReg>
81104c8c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104c90:	e0bffe17 	ldw	r2,-8(fp)
81104c94:	10bfffec 	andhi	r2,r2,65535
81104c98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104c9c:	e0bfff17 	ldw	r2,-4(fp)
81104ca0:	1080060b 	ldhu	r2,24(r2)
81104ca4:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104ca8:	e0fffe17 	ldw	r3,-8(fp)
81104cac:	1884b03a 	or	r2,r3,r2
81104cb0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104cb4:	e0bfff17 	ldw	r2,-4(fp)
81104cb8:	10800017 	ldw	r2,0(r2)
81104cbc:	e1bffe17 	ldw	r6,-8(fp)
81104cc0:	01400384 	movi	r5,14
81104cc4:	1009883a 	mov	r4,r2
81104cc8:	1104fcc0 	call	81104fcc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ccc:	e0bfff17 	ldw	r2,-4(fp)
81104cd0:	10800017 	ldw	r2,0(r2)
81104cd4:	014003c4 	movi	r5,15
81104cd8:	1009883a 	mov	r4,r2
81104cdc:	11050200 	call	81105020 <uliDpktReadReg>
81104ce0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104ce4:	e0bffe17 	ldw	r2,-8(fp)
81104ce8:	10bfffec 	andhi	r2,r2,65535
81104cec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104cf0:	e0bfff17 	ldw	r2,-4(fp)
81104cf4:	1080068b 	ldhu	r2,26(r2)
81104cf8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104cfc:	e0fffe17 	ldw	r3,-8(fp)
81104d00:	1884b03a 	or	r2,r3,r2
81104d04:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104d08:	e0bfff17 	ldw	r2,-4(fp)
81104d0c:	10800017 	ldw	r2,0(r2)
81104d10:	e1bffe17 	ldw	r6,-8(fp)
81104d14:	014003c4 	movi	r5,15
81104d18:	1009883a 	mov	r4,r2
81104d1c:	1104fcc0 	call	81104fcc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d20:	e0bfff17 	ldw	r2,-4(fp)
81104d24:	10800017 	ldw	r2,0(r2)
81104d28:	01400404 	movi	r5,16
81104d2c:	1009883a 	mov	r4,r2
81104d30:	11050200 	call	81105020 <uliDpktReadReg>
81104d34:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104d38:	e0bffe17 	ldw	r2,-8(fp)
81104d3c:	10bfffec 	andhi	r2,r2,65535
81104d40:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104d44:	e0bfff17 	ldw	r2,-4(fp)
81104d48:	1080070b 	ldhu	r2,28(r2)
81104d4c:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104d50:	e0fffe17 	ldw	r3,-8(fp)
81104d54:	1884b03a 	or	r2,r3,r2
81104d58:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104d5c:	e0bfff17 	ldw	r2,-4(fp)
81104d60:	10800017 	ldw	r2,0(r2)
81104d64:	e1bffe17 	ldw	r6,-8(fp)
81104d68:	01400404 	movi	r5,16
81104d6c:	1009883a 	mov	r4,r2
81104d70:	1104fcc0 	call	81104fcc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104d74:	00800044 	movi	r2,1
81104d78:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d7c:	e0bffd17 	ldw	r2,-12(fp)
}
81104d80:	e037883a 	mov	sp,fp
81104d84:	dfc00117 	ldw	ra,4(sp)
81104d88:	df000017 	ldw	fp,0(sp)
81104d8c:	dec00204 	addi	sp,sp,8
81104d90:	f800283a 	ret

81104d94 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104d94:	defffb04 	addi	sp,sp,-20
81104d98:	de00012e 	bgeu	sp,et,81104da0 <bDpktGetPixelDelay+0xc>
81104d9c:	003b68fa 	trap	3
81104da0:	dfc00415 	stw	ra,16(sp)
81104da4:	df000315 	stw	fp,12(sp)
81104da8:	df000304 	addi	fp,sp,12
81104dac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104db0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104db4:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104db8:	e0bfff17 	ldw	r2,-4(fp)
81104dbc:	10002026 	beq	r2,zero,81104e40 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104dc0:	e0bfff17 	ldw	r2,-4(fp)
81104dc4:	10800017 	ldw	r2,0(r2)
81104dc8:	01400384 	movi	r5,14
81104dcc:	1009883a 	mov	r4,r2
81104dd0:	11050200 	call	81105020 <uliDpktReadReg>
81104dd4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104dd8:	e0bffe17 	ldw	r2,-8(fp)
81104ddc:	1007883a 	mov	r3,r2
81104de0:	e0bfff17 	ldw	r2,-4(fp)
81104de4:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104de8:	e0bfff17 	ldw	r2,-4(fp)
81104dec:	10800017 	ldw	r2,0(r2)
81104df0:	014003c4 	movi	r5,15
81104df4:	1009883a 	mov	r4,r2
81104df8:	11050200 	call	81105020 <uliDpktReadReg>
81104dfc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104e00:	e0bffe17 	ldw	r2,-8(fp)
81104e04:	1007883a 	mov	r3,r2
81104e08:	e0bfff17 	ldw	r2,-4(fp)
81104e0c:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104e10:	e0bfff17 	ldw	r2,-4(fp)
81104e14:	10800017 	ldw	r2,0(r2)
81104e18:	01400404 	movi	r5,16
81104e1c:	1009883a 	mov	r4,r2
81104e20:	11050200 	call	81105020 <uliDpktReadReg>
81104e24:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104e28:	e0bffe17 	ldw	r2,-8(fp)
81104e2c:	1007883a 	mov	r3,r2
81104e30:	e0bfff17 	ldw	r2,-4(fp)
81104e34:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104e38:	00800044 	movi	r2,1
81104e3c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e40:	e0bffd17 	ldw	r2,-12(fp)
}
81104e44:	e037883a 	mov	sp,fp
81104e48:	dfc00117 	ldw	ra,4(sp)
81104e4c:	df000017 	ldw	fp,0(sp)
81104e50:	dec00204 	addi	sp,sp,8
81104e54:	f800283a 	ret

81104e58 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104e58:	defffb04 	addi	sp,sp,-20
81104e5c:	de00012e 	bgeu	sp,et,81104e64 <bDpktInitCh+0xc>
81104e60:	003b68fa 	trap	3
81104e64:	dfc00415 	stw	ra,16(sp)
81104e68:	df000315 	stw	fp,12(sp)
81104e6c:	df000304 	addi	fp,sp,12
81104e70:	e13ffe15 	stw	r4,-8(fp)
81104e74:	2805883a 	mov	r2,r5
81104e78:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104e7c:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104e80:	e0bffe17 	ldw	r2,-8(fp)
81104e84:	10004b26 	beq	r2,zero,81104fb4 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104e88:	00800044 	movi	r2,1
81104e8c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104e90:	e0bfff03 	ldbu	r2,-4(fp)
81104e94:	10c00228 	cmpgeui	r3,r2,8
81104e98:	1800361e 	bne	r3,zero,81104f74 <bDpktInitCh+0x11c>
81104e9c:	100690ba 	slli	r3,r2,2
81104ea0:	00a04434 	movhi	r2,33040
81104ea4:	1093ad04 	addi	r2,r2,20148
81104ea8:	1885883a 	add	r2,r3,r2
81104eac:	10800017 	ldw	r2,0(r2)
81104eb0:	1000683a 	jmp	r2
81104eb4:	81104ed4 	ori	r4,r16,16699
81104eb8:	81104ee8 	cmpgeui	r4,r16,16699
81104ebc:	81104efc 	xorhi	r4,r16,16699
81104ec0:	81104f10 	cmplti	r4,r16,16700
81104ec4:	81104f24 	muli	r4,r16,16700
81104ec8:	81104f38 	rdprs	r4,r16,16700
81104ecc:	81104f4c 	andi	r4,r16,16701
81104ed0:	81104f60 	cmpeqi	r4,r16,16701
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104ed4:	e0fffe17 	ldw	r3,-8(fp)
81104ed8:	00a04834 	movhi	r2,33056
81104edc:	108b0004 	addi	r2,r2,11264
81104ee0:	18800015 	stw	r2,0(r3)
			break;
81104ee4:	00002506 	br	81104f7c <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104ee8:	e0fffe17 	ldw	r3,-8(fp)
81104eec:	00a04834 	movhi	r2,33056
81104ef0:	108a0004 	addi	r2,r2,10240
81104ef4:	18800015 	stw	r2,0(r3)
			break;
81104ef8:	00002006 	br	81104f7c <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104efc:	e0fffe17 	ldw	r3,-8(fp)
81104f00:	00a04834 	movhi	r2,33056
81104f04:	108b0004 	addi	r2,r2,11264
81104f08:	18800015 	stw	r2,0(r3)
			break;
81104f0c:	00001b06 	br	81104f7c <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104f10:	e0fffe17 	ldw	r3,-8(fp)
81104f14:	00a04834 	movhi	r2,33056
81104f18:	108a0004 	addi	r2,r2,10240
81104f1c:	18800015 	stw	r2,0(r3)
			break;
81104f20:	00001606 	br	81104f7c <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104f24:	e0fffe17 	ldw	r3,-8(fp)
81104f28:	00a04834 	movhi	r2,33056
81104f2c:	108b0004 	addi	r2,r2,11264
81104f30:	18800015 	stw	r2,0(r3)
			break;
81104f34:	00001106 	br	81104f7c <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104f38:	e0fffe17 	ldw	r3,-8(fp)
81104f3c:	00a04834 	movhi	r2,33056
81104f40:	108a0004 	addi	r2,r2,10240
81104f44:	18800015 	stw	r2,0(r3)
			break;
81104f48:	00000c06 	br	81104f7c <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104f4c:	e0fffe17 	ldw	r3,-8(fp)
81104f50:	00a04834 	movhi	r2,33056
81104f54:	108b0004 	addi	r2,r2,11264
81104f58:	18800015 	stw	r2,0(r3)
			break;
81104f5c:	00000706 	br	81104f7c <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104f60:	e0fffe17 	ldw	r3,-8(fp)
81104f64:	00a04834 	movhi	r2,33056
81104f68:	108a0004 	addi	r2,r2,10240
81104f6c:	18800015 	stw	r2,0(r3)
			break;
81104f70:	00000206 	br	81104f7c <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104f74:	e03ffd15 	stw	zero,-12(fp)
			break;
81104f78:	0001883a 	nop
		}

		if (bStatus) {
81104f7c:	e0bffd17 	ldw	r2,-12(fp)
81104f80:	10000c26 	beq	r2,zero,81104fb4 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104f84:	e13ffe17 	ldw	r4,-8(fp)
81104f88:	1104a5c0 	call	81104a5c <bDpktGetPacketConfig>
81104f8c:	1000011e 	bne	r2,zero,81104f94 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104f90:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104f94:	e13ffe17 	ldw	r4,-8(fp)
81104f98:	1104b880 	call	81104b88 <bDpktGetPacketHeader>
81104f9c:	1000011e 	bne	r2,zero,81104fa4 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104fa0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104fa4:	e13ffe17 	ldw	r4,-8(fp)
81104fa8:	1104d940 	call	81104d94 <bDpktGetPixelDelay>
81104fac:	1000011e 	bne	r2,zero,81104fb4 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104fb0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104fb4:	e0bffd17 	ldw	r2,-12(fp)
}
81104fb8:	e037883a 	mov	sp,fp
81104fbc:	dfc00117 	ldw	ra,4(sp)
81104fc0:	df000017 	ldw	fp,0(sp)
81104fc4:	dec00204 	addi	sp,sp,8
81104fc8:	f800283a 	ret

81104fcc <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104fcc:	defffc04 	addi	sp,sp,-16
81104fd0:	de00012e 	bgeu	sp,et,81104fd8 <vDpktWriteReg+0xc>
81104fd4:	003b68fa 	trap	3
81104fd8:	df000315 	stw	fp,12(sp)
81104fdc:	df000304 	addi	fp,sp,12
81104fe0:	e13ffd15 	stw	r4,-12(fp)
81104fe4:	e17ffe15 	stw	r5,-8(fp)
81104fe8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104fec:	e0bffe17 	ldw	r2,-8(fp)
81104ff0:	1085883a 	add	r2,r2,r2
81104ff4:	1085883a 	add	r2,r2,r2
81104ff8:	1007883a 	mov	r3,r2
81104ffc:	e0bffd17 	ldw	r2,-12(fp)
81105000:	10c5883a 	add	r2,r2,r3
81105004:	e0ffff17 	ldw	r3,-4(fp)
81105008:	10c00015 	stw	r3,0(r2)
}
8110500c:	0001883a 	nop
81105010:	e037883a 	mov	sp,fp
81105014:	df000017 	ldw	fp,0(sp)
81105018:	dec00104 	addi	sp,sp,4
8110501c:	f800283a 	ret

81105020 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105020:	defffc04 	addi	sp,sp,-16
81105024:	de00012e 	bgeu	sp,et,8110502c <uliDpktReadReg+0xc>
81105028:	003b68fa 	trap	3
8110502c:	df000315 	stw	fp,12(sp)
81105030:	df000304 	addi	fp,sp,12
81105034:	e13ffe15 	stw	r4,-8(fp)
81105038:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110503c:	e0bfff17 	ldw	r2,-4(fp)
81105040:	1085883a 	add	r2,r2,r2
81105044:	1085883a 	add	r2,r2,r2
81105048:	1007883a 	mov	r3,r2
8110504c:	e0bffe17 	ldw	r2,-8(fp)
81105050:	10c5883a 	add	r2,r2,r3
81105054:	10800017 	ldw	r2,0(r2)
81105058:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110505c:	e0bffd17 	ldw	r2,-12(fp)
}
81105060:	e037883a 	mov	sp,fp
81105064:	df000017 	ldw	fp,0(sp)
81105068:	dec00104 	addi	sp,sp,4
8110506c:	f800283a 	ret

81105070 <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81105070:	defffc04 	addi	sp,sp,-16
81105074:	de00012e 	bgeu	sp,et,8110507c <usiAdcPxDelayCalcPeriodNs+0xc>
81105078:	003b68fa 	trap	3
8110507c:	dfc00315 	stw	ra,12(sp)
81105080:	df000215 	stw	fp,8(sp)
81105084:	df000204 	addi	fp,sp,8
81105088:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
8110508c:	e13fff17 	ldw	r4,-4(fp)
81105090:	111fb500 	call	8111fb50 <__floatunsisf>
81105094:	1007883a 	mov	r3,r2
81105098:	1809883a 	mov	r4,r3
8110509c:	1120eac0 	call	81120eac <__extendsfdf2>
811050a0:	1011883a 	mov	r8,r2
811050a4:	1813883a 	mov	r9,r3
811050a8:	01a666b4 	movhi	r6,39322
811050ac:	31a66684 	addi	r6,r6,-26214
811050b0:	01cfeeb4 	movhi	r7,16314
811050b4:	39e66644 	addi	r7,r7,-26215
811050b8:	4009883a 	mov	r4,r8
811050bc:	480b883a 	mov	r5,r9
811050c0:	111fd240 	call	8111fd24 <__muldf3>
811050c4:	1009883a 	mov	r4,r2
811050c8:	180b883a 	mov	r5,r3
811050cc:	2005883a 	mov	r2,r4
811050d0:	2807883a 	mov	r3,r5
811050d4:	1009883a 	mov	r4,r2
811050d8:	180b883a 	mov	r5,r3
811050dc:	111f15c0 	call	8111f15c <__fixunsdfsi>
811050e0:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
811050e4:	e0bffe0b 	ldhu	r2,-8(fp)
}
811050e8:	e037883a 	mov	sp,fp
811050ec:	dfc00117 	ldw	ra,4(sp)
811050f0:	df000017 	ldw	fp,0(sp)
811050f4:	dec00204 	addi	sp,sp,8
811050f8:	f800283a 	ret

811050fc <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
811050fc:	defffc04 	addi	sp,sp,-16
81105100:	de00012e 	bgeu	sp,et,81105108 <usiLineTrDelayCalcPeriodNs+0xc>
81105104:	003b68fa 	trap	3
81105108:	dfc00315 	stw	ra,12(sp)
8110510c:	df000215 	stw	fp,8(sp)
81105110:	df000204 	addi	fp,sp,8
81105114:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
81105118:	e13fff17 	ldw	r4,-4(fp)
8110511c:	111fb500 	call	8111fb50 <__floatunsisf>
81105120:	1007883a 	mov	r3,r2
81105124:	1809883a 	mov	r4,r3
81105128:	1120eac0 	call	81120eac <__extendsfdf2>
8110512c:	1011883a 	mov	r8,r2
81105130:	1813883a 	mov	r9,r3
81105134:	0191ebb4 	movhi	r6,18350
81105138:	31851ec4 	addi	r6,r6,5243
8110513c:	01cfe134 	movhi	r7,16260
81105140:	39deb844 	addi	r7,r7,31457
81105144:	4009883a 	mov	r4,r8
81105148:	480b883a 	mov	r5,r9
8110514c:	111fd240 	call	8111fd24 <__muldf3>
81105150:	1009883a 	mov	r4,r2
81105154:	180b883a 	mov	r5,r3
81105158:	2005883a 	mov	r2,r4
8110515c:	2807883a 	mov	r3,r5
81105160:	1009883a 	mov	r4,r2
81105164:	180b883a 	mov	r5,r3
81105168:	111f15c0 	call	8111f15c <__fixunsdfsi>
8110516c:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
81105170:	e0bffe0b 	ldhu	r2,-8(fp)
}
81105174:	e037883a 	mov	sp,fp
81105178:	dfc00117 	ldw	ra,4(sp)
8110517c:	df000017 	ldw	fp,0(sp)
81105180:	dec00204 	addi	sp,sp,8
81105184:	f800283a 	ret

81105188 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105188:	defffb04 	addi	sp,sp,-20
8110518c:	de00012e 	bgeu	sp,et,81105194 <vFeebCh1HandleIrq+0xc>
81105190:	003b68fa 	trap	3
81105194:	dfc00415 	stw	ra,16(sp)
81105198:	df000315 	stw	fp,12(sp)
8110519c:	df000304 	addi	fp,sp,12
811051a0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051a4:	e0bfff17 	ldw	r2,-4(fp)
811051a8:	e0bffd15 	stw	r2,-12(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
811051ac:	11054980 	call	81105498 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
811051b0:	0001883a 	nop
811051b4:	e037883a 	mov	sp,fp
811051b8:	dfc00117 	ldw	ra,4(sp)
811051bc:	df000017 	ldw	fp,0(sp)
811051c0:	dec00204 	addi	sp,sp,8
811051c4:	f800283a 	ret

811051c8 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
811051c8:	defffb04 	addi	sp,sp,-20
811051cc:	de00012e 	bgeu	sp,et,811051d4 <vFeebCh2HandleIrq+0xc>
811051d0:	003b68fa 	trap	3
811051d4:	dfc00415 	stw	ra,16(sp)
811051d8:	df000315 	stw	fp,12(sp)
811051dc:	df000304 	addi	fp,sp,12
811051e0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051e4:	e0bfff17 	ldw	r2,-4(fp)
811051e8:	e0bffd15 	stw	r2,-12(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh2IrqFlagClrBufferEmpty();
811051ec:	11054dc0 	call	811054dc <vFeebCh2IrqFlagClrBufferEmpty>
	if ( error_codel != OS_ERR_NONE ) {
		vFailRequestDMAFromIRQ( 1 );
	}
*/

}
811051f0:	0001883a 	nop
811051f4:	e037883a 	mov	sp,fp
811051f8:	dfc00117 	ldw	ra,4(sp)
811051fc:	df000017 	ldw	fp,0(sp)
81105200:	dec00204 	addi	sp,sp,8
81105204:	f800283a 	ret

81105208 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81105208:	defffa04 	addi	sp,sp,-24
8110520c:	de00012e 	bgeu	sp,et,81105214 <vFeebCh3HandleIrq+0xc>
81105210:	003b68fa 	trap	3
81105214:	dfc00515 	stw	ra,20(sp)
81105218:	df000415 	stw	fp,16(sp)
8110521c:	df000404 	addi	fp,sp,16
81105220:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105224:	e0bfff17 	ldw	r2,-4(fp)
81105228:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110522c:	00800404 	movi	r2,16
81105230:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105234:	00bfe004 	movi	r2,-128
81105238:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
8110523c:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
81105240:	00800084 	movi	r2,2
81105244:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105248:	d0a05d17 	ldw	r2,-32396(gp)
8110524c:	e0fffe17 	ldw	r3,-8(fp)
81105250:	180b883a 	mov	r5,r3
81105254:	1009883a 	mov	r4,r2
81105258:	113dd8c0 	call	8113dd8c <OSQPost>
8110525c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105260:	e0bffd03 	ldbu	r2,-12(fp)
81105264:	10000226 	beq	r2,zero,81105270 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
81105268:	01000084 	movi	r4,2
8110526c:	111d1bc0 	call	8111d1bc <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
81105270:	11055200 	call	81105520 <vFeebCh3IrqFlagClrBufferEmpty>
}
81105274:	0001883a 	nop
81105278:	e037883a 	mov	sp,fp
8110527c:	dfc00117 	ldw	ra,4(sp)
81105280:	df000017 	ldw	fp,0(sp)
81105284:	dec00204 	addi	sp,sp,8
81105288:	f800283a 	ret

8110528c <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
8110528c:	defffa04 	addi	sp,sp,-24
81105290:	de00012e 	bgeu	sp,et,81105298 <vFeebCh4HandleIrq+0xc>
81105294:	003b68fa 	trap	3
81105298:	dfc00515 	stw	ra,20(sp)
8110529c:	df000415 	stw	fp,16(sp)
811052a0:	df000404 	addi	fp,sp,16
811052a4:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811052a8:	e0bfff17 	ldw	r2,-4(fp)
811052ac:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811052b0:	00800404 	movi	r2,16
811052b4:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811052b8:	00bfe004 	movi	r2,-128
811052bc:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811052c0:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
811052c4:	008000c4 	movi	r2,3
811052c8:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811052cc:	d0a05d17 	ldw	r2,-32396(gp)
811052d0:	e0fffe17 	ldw	r3,-8(fp)
811052d4:	180b883a 	mov	r5,r3
811052d8:	1009883a 	mov	r4,r2
811052dc:	113dd8c0 	call	8113dd8c <OSQPost>
811052e0:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811052e4:	e0bffd03 	ldbu	r2,-12(fp)
811052e8:	10000226 	beq	r2,zero,811052f4 <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
811052ec:	010000c4 	movi	r4,3
811052f0:	111d1bc0 	call	8111d1bc <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
811052f4:	11055640 	call	81105564 <vFeebCh4IrqFlagClrBufferEmpty>
}
811052f8:	0001883a 	nop
811052fc:	e037883a 	mov	sp,fp
81105300:	dfc00117 	ldw	ra,4(sp)
81105304:	df000017 	ldw	fp,0(sp)
81105308:	dec00204 	addi	sp,sp,8
8110530c:	f800283a 	ret

81105310 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81105310:	defffa04 	addi	sp,sp,-24
81105314:	de00012e 	bgeu	sp,et,8110531c <vFeebCh5HandleIrq+0xc>
81105318:	003b68fa 	trap	3
8110531c:	dfc00515 	stw	ra,20(sp)
81105320:	df000415 	stw	fp,16(sp)
81105324:	df000404 	addi	fp,sp,16
81105328:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110532c:	e0bfff17 	ldw	r2,-4(fp)
81105330:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105334:	00800404 	movi	r2,16
81105338:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110533c:	00bfe004 	movi	r2,-128
81105340:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105344:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
81105348:	00800104 	movi	r2,4
8110534c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105350:	d0a05d17 	ldw	r2,-32396(gp)
81105354:	e0fffe17 	ldw	r3,-8(fp)
81105358:	180b883a 	mov	r5,r3
8110535c:	1009883a 	mov	r4,r2
81105360:	113dd8c0 	call	8113dd8c <OSQPost>
81105364:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105368:	e0bffd03 	ldbu	r2,-12(fp)
8110536c:	10000226 	beq	r2,zero,81105378 <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
81105370:	01000104 	movi	r4,4
81105374:	111d1bc0 	call	8111d1bc <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
81105378:	11055a80 	call	811055a8 <vFeebCh5IrqFlagClrBufferEmpty>
}
8110537c:	0001883a 	nop
81105380:	e037883a 	mov	sp,fp
81105384:	dfc00117 	ldw	ra,4(sp)
81105388:	df000017 	ldw	fp,0(sp)
8110538c:	dec00204 	addi	sp,sp,8
81105390:	f800283a 	ret

81105394 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81105394:	defffa04 	addi	sp,sp,-24
81105398:	de00012e 	bgeu	sp,et,811053a0 <vFeebCh6HandleIrq+0xc>
8110539c:	003b68fa 	trap	3
811053a0:	dfc00515 	stw	ra,20(sp)
811053a4:	df000415 	stw	fp,16(sp)
811053a8:	df000404 	addi	fp,sp,16
811053ac:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811053b0:	e0bfff17 	ldw	r2,-4(fp)
811053b4:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811053b8:	00800404 	movi	r2,16
811053bc:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811053c0:	00bfe004 	movi	r2,-128
811053c4:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811053c8:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
811053cc:	00800144 	movi	r2,5
811053d0:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811053d4:	d0a05d17 	ldw	r2,-32396(gp)
811053d8:	e0fffe17 	ldw	r3,-8(fp)
811053dc:	180b883a 	mov	r5,r3
811053e0:	1009883a 	mov	r4,r2
811053e4:	113dd8c0 	call	8113dd8c <OSQPost>
811053e8:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811053ec:	e0bffd03 	ldbu	r2,-12(fp)
811053f0:	10000226 	beq	r2,zero,811053fc <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
811053f4:	01000144 	movi	r4,5
811053f8:	111d1bc0 	call	8111d1bc <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
811053fc:	11055ec0 	call	811055ec <vFeebCh6IrqFlagClrBufferEmpty>
}
81105400:	0001883a 	nop
81105404:	e037883a 	mov	sp,fp
81105408:	dfc00117 	ldw	ra,4(sp)
8110540c:	df000017 	ldw	fp,0(sp)
81105410:	dec00204 	addi	sp,sp,8
81105414:	f800283a 	ret

81105418 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81105418:	defffc04 	addi	sp,sp,-16
8110541c:	de00012e 	bgeu	sp,et,81105424 <vFeebCh7HandleIrq+0xc>
81105420:	003b68fa 	trap	3
81105424:	dfc00315 	stw	ra,12(sp)
81105428:	df000215 	stw	fp,8(sp)
8110542c:	df000204 	addi	fp,sp,8
81105430:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105434:	e0bfff17 	ldw	r2,-4(fp)
81105438:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
8110543c:	11056300 	call	81105630 <vFeebCh7IrqFlagClrBufferEmpty>
}
81105440:	0001883a 	nop
81105444:	e037883a 	mov	sp,fp
81105448:	dfc00117 	ldw	ra,4(sp)
8110544c:	df000017 	ldw	fp,0(sp)
81105450:	dec00204 	addi	sp,sp,8
81105454:	f800283a 	ret

81105458 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81105458:	defffc04 	addi	sp,sp,-16
8110545c:	de00012e 	bgeu	sp,et,81105464 <vFeebCh8HandleIrq+0xc>
81105460:	003b68fa 	trap	3
81105464:	dfc00315 	stw	ra,12(sp)
81105468:	df000215 	stw	fp,8(sp)
8110546c:	df000204 	addi	fp,sp,8
81105470:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105474:	e0bfff17 	ldw	r2,-4(fp)
81105478:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
8110547c:	11056740 	call	81105674 <vFeebCh8IrqFlagClrBufferEmpty>
}
81105480:	0001883a 	nop
81105484:	e037883a 	mov	sp,fp
81105488:	dfc00117 	ldw	ra,4(sp)
8110548c:	df000017 	ldw	fp,0(sp)
81105490:	dec00204 	addi	sp,sp,8
81105494:	f800283a 	ret

81105498 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105498:	defffe04 	addi	sp,sp,-8
8110549c:	de00012e 	bgeu	sp,et,811054a4 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
811054a0:	003b68fa 	trap	3
811054a4:	dfc00115 	stw	ra,4(sp)
811054a8:	df000015 	stw	fp,0(sp)
811054ac:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811054b0:	01804004 	movi	r6,256
811054b4:	014004c4 	movi	r5,19
811054b8:	01204834 	movhi	r4,33056
811054bc:	210b0004 	addi	r4,r4,11264
811054c0:	1106c640 	call	81106c64 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054c4:	0001883a 	nop
811054c8:	e037883a 	mov	sp,fp
811054cc:	dfc00117 	ldw	ra,4(sp)
811054d0:	df000017 	ldw	fp,0(sp)
811054d4:	dec00204 	addi	sp,sp,8
811054d8:	f800283a 	ret

811054dc <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
811054dc:	defffe04 	addi	sp,sp,-8
811054e0:	de00012e 	bgeu	sp,et,811054e8 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
811054e4:	003b68fa 	trap	3
811054e8:	dfc00115 	stw	ra,4(sp)
811054ec:	df000015 	stw	fp,0(sp)
811054f0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811054f4:	01804004 	movi	r6,256
811054f8:	014004c4 	movi	r5,19
811054fc:	01204834 	movhi	r4,33056
81105500:	210a0004 	addi	r4,r4,10240
81105504:	1106c640 	call	81106c64 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105508:	0001883a 	nop
8110550c:	e037883a 	mov	sp,fp
81105510:	dfc00117 	ldw	ra,4(sp)
81105514:	df000017 	ldw	fp,0(sp)
81105518:	dec00204 	addi	sp,sp,8
8110551c:	f800283a 	ret

81105520 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
81105520:	defffe04 	addi	sp,sp,-8
81105524:	de00012e 	bgeu	sp,et,8110552c <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81105528:	003b68fa 	trap	3
8110552c:	dfc00115 	stw	ra,4(sp)
81105530:	df000015 	stw	fp,0(sp)
81105534:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105538:	01804004 	movi	r6,256
8110553c:	014004c4 	movi	r5,19
81105540:	01204834 	movhi	r4,33056
81105544:	210b0004 	addi	r4,r4,11264
81105548:	1106c640 	call	81106c64 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110554c:	0001883a 	nop
81105550:	e037883a 	mov	sp,fp
81105554:	dfc00117 	ldw	ra,4(sp)
81105558:	df000017 	ldw	fp,0(sp)
8110555c:	dec00204 	addi	sp,sp,8
81105560:	f800283a 	ret

81105564 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81105564:	defffe04 	addi	sp,sp,-8
81105568:	de00012e 	bgeu	sp,et,81105570 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
8110556c:	003b68fa 	trap	3
81105570:	dfc00115 	stw	ra,4(sp)
81105574:	df000015 	stw	fp,0(sp)
81105578:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110557c:	01804004 	movi	r6,256
81105580:	014004c4 	movi	r5,19
81105584:	01204834 	movhi	r4,33056
81105588:	210a0004 	addi	r4,r4,10240
8110558c:	1106c640 	call	81106c64 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105590:	0001883a 	nop
81105594:	e037883a 	mov	sp,fp
81105598:	dfc00117 	ldw	ra,4(sp)
8110559c:	df000017 	ldw	fp,0(sp)
811055a0:	dec00204 	addi	sp,sp,8
811055a4:	f800283a 	ret

811055a8 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
811055a8:	defffe04 	addi	sp,sp,-8
811055ac:	de00012e 	bgeu	sp,et,811055b4 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
811055b0:	003b68fa 	trap	3
811055b4:	dfc00115 	stw	ra,4(sp)
811055b8:	df000015 	stw	fp,0(sp)
811055bc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811055c0:	01804004 	movi	r6,256
811055c4:	014004c4 	movi	r5,19
811055c8:	01204834 	movhi	r4,33056
811055cc:	210b0004 	addi	r4,r4,11264
811055d0:	1106c640 	call	81106c64 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811055d4:	0001883a 	nop
811055d8:	e037883a 	mov	sp,fp
811055dc:	dfc00117 	ldw	ra,4(sp)
811055e0:	df000017 	ldw	fp,0(sp)
811055e4:	dec00204 	addi	sp,sp,8
811055e8:	f800283a 	ret

811055ec <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
811055ec:	defffe04 	addi	sp,sp,-8
811055f0:	de00012e 	bgeu	sp,et,811055f8 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811055f4:	003b68fa 	trap	3
811055f8:	dfc00115 	stw	ra,4(sp)
811055fc:	df000015 	stw	fp,0(sp)
81105600:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105604:	01804004 	movi	r6,256
81105608:	014004c4 	movi	r5,19
8110560c:	01204834 	movhi	r4,33056
81105610:	210a0004 	addi	r4,r4,10240
81105614:	1106c640 	call	81106c64 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105618:	0001883a 	nop
8110561c:	e037883a 	mov	sp,fp
81105620:	dfc00117 	ldw	ra,4(sp)
81105624:	df000017 	ldw	fp,0(sp)
81105628:	dec00204 	addi	sp,sp,8
8110562c:	f800283a 	ret

81105630 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81105630:	defffe04 	addi	sp,sp,-8
81105634:	de00012e 	bgeu	sp,et,8110563c <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81105638:	003b68fa 	trap	3
8110563c:	dfc00115 	stw	ra,4(sp)
81105640:	df000015 	stw	fp,0(sp)
81105644:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105648:	01804004 	movi	r6,256
8110564c:	014004c4 	movi	r5,19
81105650:	01204834 	movhi	r4,33056
81105654:	210b0004 	addi	r4,r4,11264
81105658:	1106c640 	call	81106c64 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110565c:	0001883a 	nop
81105660:	e037883a 	mov	sp,fp
81105664:	dfc00117 	ldw	ra,4(sp)
81105668:	df000017 	ldw	fp,0(sp)
8110566c:	dec00204 	addi	sp,sp,8
81105670:	f800283a 	ret

81105674 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81105674:	defffe04 	addi	sp,sp,-8
81105678:	de00012e 	bgeu	sp,et,81105680 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
8110567c:	003b68fa 	trap	3
81105680:	dfc00115 	stw	ra,4(sp)
81105684:	df000015 	stw	fp,0(sp)
81105688:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110568c:	01804004 	movi	r6,256
81105690:	014004c4 	movi	r5,19
81105694:	01204834 	movhi	r4,33056
81105698:	210a0004 	addi	r4,r4,10240
8110569c:	1106c640 	call	81106c64 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811056a0:	0001883a 	nop
811056a4:	e037883a 	mov	sp,fp
811056a8:	dfc00117 	ldw	ra,4(sp)
811056ac:	df000017 	ldw	fp,0(sp)
811056b0:	dec00204 	addi	sp,sp,8
811056b4:	f800283a 	ret

811056b8 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
811056b8:	defffd04 	addi	sp,sp,-12
811056bc:	de00012e 	bgeu	sp,et,811056c4 <bFeebCh1IrqFlagBufferEmpty+0xc>
811056c0:	003b68fa 	trap	3
811056c4:	dfc00215 	stw	ra,8(sp)
811056c8:	df000115 	stw	fp,4(sp)
811056cc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811056d0:	01400484 	movi	r5,18
811056d4:	01204834 	movhi	r4,33056
811056d8:	210b0004 	addi	r4,r4,11264
811056dc:	1106cb80 	call	81106cb8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811056e0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811056e4:	10000326 	beq	r2,zero,811056f4 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811056e8:	00800044 	movi	r2,1
811056ec:	e0bfff15 	stw	r2,-4(fp)
811056f0:	00000106 	br	811056f8 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811056f4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811056f8:	e0bfff17 	ldw	r2,-4(fp)
}
811056fc:	e037883a 	mov	sp,fp
81105700:	dfc00117 	ldw	ra,4(sp)
81105704:	df000017 	ldw	fp,0(sp)
81105708:	dec00204 	addi	sp,sp,8
8110570c:	f800283a 	ret

81105710 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
81105710:	defffd04 	addi	sp,sp,-12
81105714:	de00012e 	bgeu	sp,et,8110571c <bFeebCh2IrqFlagBufferEmpty+0xc>
81105718:	003b68fa 	trap	3
8110571c:	dfc00215 	stw	ra,8(sp)
81105720:	df000115 	stw	fp,4(sp)
81105724:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105728:	01400484 	movi	r5,18
8110572c:	01204834 	movhi	r4,33056
81105730:	210a0004 	addi	r4,r4,10240
81105734:	1106cb80 	call	81106cb8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105738:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110573c:	10000326 	beq	r2,zero,8110574c <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105740:	00800044 	movi	r2,1
81105744:	e0bfff15 	stw	r2,-4(fp)
81105748:	00000106 	br	81105750 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110574c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105750:	e0bfff17 	ldw	r2,-4(fp)
}
81105754:	e037883a 	mov	sp,fp
81105758:	dfc00117 	ldw	ra,4(sp)
8110575c:	df000017 	ldw	fp,0(sp)
81105760:	dec00204 	addi	sp,sp,8
81105764:	f800283a 	ret

81105768 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105768:	defffd04 	addi	sp,sp,-12
8110576c:	de00012e 	bgeu	sp,et,81105774 <bFeebCh3IrqFlagBufferEmpty+0xc>
81105770:	003b68fa 	trap	3
81105774:	dfc00215 	stw	ra,8(sp)
81105778:	df000115 	stw	fp,4(sp)
8110577c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105780:	01400484 	movi	r5,18
81105784:	01204834 	movhi	r4,33056
81105788:	210b0004 	addi	r4,r4,11264
8110578c:	1106cb80 	call	81106cb8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105790:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105794:	10000326 	beq	r2,zero,811057a4 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105798:	00800044 	movi	r2,1
8110579c:	e0bfff15 	stw	r2,-4(fp)
811057a0:	00000106 	br	811057a8 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057a4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057a8:	e0bfff17 	ldw	r2,-4(fp)
}
811057ac:	e037883a 	mov	sp,fp
811057b0:	dfc00117 	ldw	ra,4(sp)
811057b4:	df000017 	ldw	fp,0(sp)
811057b8:	dec00204 	addi	sp,sp,8
811057bc:	f800283a 	ret

811057c0 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
811057c0:	defffd04 	addi	sp,sp,-12
811057c4:	de00012e 	bgeu	sp,et,811057cc <bFeebCh4IrqFlagBufferEmpty+0xc>
811057c8:	003b68fa 	trap	3
811057cc:	dfc00215 	stw	ra,8(sp)
811057d0:	df000115 	stw	fp,4(sp)
811057d4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811057d8:	01400484 	movi	r5,18
811057dc:	01204834 	movhi	r4,33056
811057e0:	210a0004 	addi	r4,r4,10240
811057e4:	1106cb80 	call	81106cb8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057e8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811057ec:	10000326 	beq	r2,zero,811057fc <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057f0:	00800044 	movi	r2,1
811057f4:	e0bfff15 	stw	r2,-4(fp)
811057f8:	00000106 	br	81105800 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057fc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105800:	e0bfff17 	ldw	r2,-4(fp)
}
81105804:	e037883a 	mov	sp,fp
81105808:	dfc00117 	ldw	ra,4(sp)
8110580c:	df000017 	ldw	fp,0(sp)
81105810:	dec00204 	addi	sp,sp,8
81105814:	f800283a 	ret

81105818 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81105818:	defffd04 	addi	sp,sp,-12
8110581c:	de00012e 	bgeu	sp,et,81105824 <bFeebCh5IrqFlagBufferEmpty+0xc>
81105820:	003b68fa 	trap	3
81105824:	dfc00215 	stw	ra,8(sp)
81105828:	df000115 	stw	fp,4(sp)
8110582c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105830:	01400484 	movi	r5,18
81105834:	01204834 	movhi	r4,33056
81105838:	210b0004 	addi	r4,r4,11264
8110583c:	1106cb80 	call	81106cb8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105840:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105844:	10000326 	beq	r2,zero,81105854 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105848:	00800044 	movi	r2,1
8110584c:	e0bfff15 	stw	r2,-4(fp)
81105850:	00000106 	br	81105858 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105854:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105858:	e0bfff17 	ldw	r2,-4(fp)
}
8110585c:	e037883a 	mov	sp,fp
81105860:	dfc00117 	ldw	ra,4(sp)
81105864:	df000017 	ldw	fp,0(sp)
81105868:	dec00204 	addi	sp,sp,8
8110586c:	f800283a 	ret

81105870 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105870:	defffd04 	addi	sp,sp,-12
81105874:	de00012e 	bgeu	sp,et,8110587c <bFeebCh6IrqFlagBufferEmpty+0xc>
81105878:	003b68fa 	trap	3
8110587c:	dfc00215 	stw	ra,8(sp)
81105880:	df000115 	stw	fp,4(sp)
81105884:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105888:	01400484 	movi	r5,18
8110588c:	01204834 	movhi	r4,33056
81105890:	210a0004 	addi	r4,r4,10240
81105894:	1106cb80 	call	81106cb8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105898:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110589c:	10000326 	beq	r2,zero,811058ac <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811058a0:	00800044 	movi	r2,1
811058a4:	e0bfff15 	stw	r2,-4(fp)
811058a8:	00000106 	br	811058b0 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811058ac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811058b0:	e0bfff17 	ldw	r2,-4(fp)
}
811058b4:	e037883a 	mov	sp,fp
811058b8:	dfc00117 	ldw	ra,4(sp)
811058bc:	df000017 	ldw	fp,0(sp)
811058c0:	dec00204 	addi	sp,sp,8
811058c4:	f800283a 	ret

811058c8 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
811058c8:	defffd04 	addi	sp,sp,-12
811058cc:	de00012e 	bgeu	sp,et,811058d4 <bFeebCh7IrqFlagBufferEmpty+0xc>
811058d0:	003b68fa 	trap	3
811058d4:	dfc00215 	stw	ra,8(sp)
811058d8:	df000115 	stw	fp,4(sp)
811058dc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811058e0:	01400484 	movi	r5,18
811058e4:	01204834 	movhi	r4,33056
811058e8:	210b0004 	addi	r4,r4,11264
811058ec:	1106cb80 	call	81106cb8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811058f0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811058f4:	10000326 	beq	r2,zero,81105904 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811058f8:	00800044 	movi	r2,1
811058fc:	e0bfff15 	stw	r2,-4(fp)
81105900:	00000106 	br	81105908 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105904:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105908:	e0bfff17 	ldw	r2,-4(fp)
}
8110590c:	e037883a 	mov	sp,fp
81105910:	dfc00117 	ldw	ra,4(sp)
81105914:	df000017 	ldw	fp,0(sp)
81105918:	dec00204 	addi	sp,sp,8
8110591c:	f800283a 	ret

81105920 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81105920:	defffd04 	addi	sp,sp,-12
81105924:	de00012e 	bgeu	sp,et,8110592c <bFeebCh8IrqFlagBufferEmpty+0xc>
81105928:	003b68fa 	trap	3
8110592c:	dfc00215 	stw	ra,8(sp)
81105930:	df000115 	stw	fp,4(sp)
81105934:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105938:	01400484 	movi	r5,18
8110593c:	01204834 	movhi	r4,33056
81105940:	210a0004 	addi	r4,r4,10240
81105944:	1106cb80 	call	81106cb8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105948:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110594c:	10000326 	beq	r2,zero,8110595c <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105950:	00800044 	movi	r2,1
81105954:	e0bfff15 	stw	r2,-4(fp)
81105958:	00000106 	br	81105960 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110595c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105960:	e0bfff17 	ldw	r2,-4(fp)
}
81105964:	e037883a 	mov	sp,fp
81105968:	dfc00117 	ldw	ra,4(sp)
8110596c:	df000017 	ldw	fp,0(sp)
81105970:	dec00204 	addi	sp,sp,8
81105974:	f800283a 	ret

81105978 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105978:	defffa04 	addi	sp,sp,-24
8110597c:	de00012e 	bgeu	sp,et,81105984 <bFeebCh1SetBufferSize+0xc>
81105980:	003b68fa 	trap	3
81105984:	dfc00515 	stw	ra,20(sp)
81105988:	df000415 	stw	fp,16(sp)
8110598c:	df000404 	addi	fp,sp,16
81105990:	2007883a 	mov	r3,r4
81105994:	2805883a 	mov	r2,r5
81105998:	e0fffe05 	stb	r3,-8(fp)
8110599c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811059a0:	00800044 	movi	r2,1
811059a4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
811059a8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
811059ac:	e0bffe03 	ldbu	r2,-8(fp)
811059b0:	10001f26 	beq	r2,zero,81105a30 <bFeebCh1SetBufferSize+0xb8>
811059b4:	e0bffe03 	ldbu	r2,-8(fp)
811059b8:	10800468 	cmpgeui	r2,r2,17
811059bc:	10001c1e 	bne	r2,zero,81105a30 <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
811059c0:	e0bfff03 	ldbu	r2,-4(fp)
811059c4:	10000326 	beq	r2,zero,811059d4 <bFeebCh1SetBufferSize+0x5c>
811059c8:	10800060 	cmpeqi	r2,r2,1
811059cc:	10000b1e 	bne	r2,zero,811059fc <bFeebCh1SetBufferSize+0x84>
811059d0:	00001406 	br	81105a24 <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811059d4:	e0bffe03 	ldbu	r2,-8(fp)
811059d8:	10bfffc4 	addi	r2,r2,-1
811059dc:	108003cc 	andi	r2,r2,15
811059e0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811059e4:	e1bffd17 	ldw	r6,-12(fp)
811059e8:	01400544 	movi	r5,21
811059ec:	01204834 	movhi	r4,33056
811059f0:	210b0004 	addi	r4,r4,11264
811059f4:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811059f8:	00000c06 	br	81105a2c <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811059fc:	e0bffe03 	ldbu	r2,-8(fp)
81105a00:	10bfffc4 	addi	r2,r2,-1
81105a04:	108003cc 	andi	r2,r2,15
81105a08:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105a0c:	e1bffd17 	ldw	r6,-12(fp)
81105a10:	01400504 	movi	r5,20
81105a14:	01204834 	movhi	r4,33056
81105a18:	210b0004 	addi	r4,r4,11264
81105a1c:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a20:	00000206 	br	81105a2c <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105a24:	e03ffc15 	stw	zero,-16(fp)
			break;
81105a28:	0001883a 	nop
		}
	} else {
81105a2c:	00000106 	br	81105a34 <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
81105a30:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105a34:	e0bffc17 	ldw	r2,-16(fp)
}
81105a38:	e037883a 	mov	sp,fp
81105a3c:	dfc00117 	ldw	ra,4(sp)
81105a40:	df000017 	ldw	fp,0(sp)
81105a44:	dec00204 	addi	sp,sp,8
81105a48:	f800283a 	ret

81105a4c <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105a4c:	defffa04 	addi	sp,sp,-24
81105a50:	de00012e 	bgeu	sp,et,81105a58 <bFeebCh2SetBufferSize+0xc>
81105a54:	003b68fa 	trap	3
81105a58:	dfc00515 	stw	ra,20(sp)
81105a5c:	df000415 	stw	fp,16(sp)
81105a60:	df000404 	addi	fp,sp,16
81105a64:	2007883a 	mov	r3,r4
81105a68:	2805883a 	mov	r2,r5
81105a6c:	e0fffe05 	stb	r3,-8(fp)
81105a70:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105a74:	00800044 	movi	r2,1
81105a78:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105a7c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105a80:	e0bffe03 	ldbu	r2,-8(fp)
81105a84:	10001f26 	beq	r2,zero,81105b04 <bFeebCh2SetBufferSize+0xb8>
81105a88:	e0bffe03 	ldbu	r2,-8(fp)
81105a8c:	10800468 	cmpgeui	r2,r2,17
81105a90:	10001c1e 	bne	r2,zero,81105b04 <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105a94:	e0bfff03 	ldbu	r2,-4(fp)
81105a98:	10000326 	beq	r2,zero,81105aa8 <bFeebCh2SetBufferSize+0x5c>
81105a9c:	10800060 	cmpeqi	r2,r2,1
81105aa0:	10000b1e 	bne	r2,zero,81105ad0 <bFeebCh2SetBufferSize+0x84>
81105aa4:	00001406 	br	81105af8 <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105aa8:	e0bffe03 	ldbu	r2,-8(fp)
81105aac:	10bfffc4 	addi	r2,r2,-1
81105ab0:	108003cc 	andi	r2,r2,15
81105ab4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105ab8:	e1bffd17 	ldw	r6,-12(fp)
81105abc:	01400544 	movi	r5,21
81105ac0:	01204834 	movhi	r4,33056
81105ac4:	210a0004 	addi	r4,r4,10240
81105ac8:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105acc:	00000c06 	br	81105b00 <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ad0:	e0bffe03 	ldbu	r2,-8(fp)
81105ad4:	10bfffc4 	addi	r2,r2,-1
81105ad8:	108003cc 	andi	r2,r2,15
81105adc:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105ae0:	e1bffd17 	ldw	r6,-12(fp)
81105ae4:	01400504 	movi	r5,20
81105ae8:	01204834 	movhi	r4,33056
81105aec:	210a0004 	addi	r4,r4,10240
81105af0:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105af4:	00000206 	br	81105b00 <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105af8:	e03ffc15 	stw	zero,-16(fp)
			break;
81105afc:	0001883a 	nop
		}
	} else {
81105b00:	00000106 	br	81105b08 <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
81105b04:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105b08:	e0bffc17 	ldw	r2,-16(fp)
}
81105b0c:	e037883a 	mov	sp,fp
81105b10:	dfc00117 	ldw	ra,4(sp)
81105b14:	df000017 	ldw	fp,0(sp)
81105b18:	dec00204 	addi	sp,sp,8
81105b1c:	f800283a 	ret

81105b20 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105b20:	defffa04 	addi	sp,sp,-24
81105b24:	de00012e 	bgeu	sp,et,81105b2c <bFeebCh3SetBufferSize+0xc>
81105b28:	003b68fa 	trap	3
81105b2c:	dfc00515 	stw	ra,20(sp)
81105b30:	df000415 	stw	fp,16(sp)
81105b34:	df000404 	addi	fp,sp,16
81105b38:	2007883a 	mov	r3,r4
81105b3c:	2805883a 	mov	r2,r5
81105b40:	e0fffe05 	stb	r3,-8(fp)
81105b44:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105b48:	00800044 	movi	r2,1
81105b4c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105b50:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105b54:	e0bffe03 	ldbu	r2,-8(fp)
81105b58:	10001f26 	beq	r2,zero,81105bd8 <bFeebCh3SetBufferSize+0xb8>
81105b5c:	e0bffe03 	ldbu	r2,-8(fp)
81105b60:	10800468 	cmpgeui	r2,r2,17
81105b64:	10001c1e 	bne	r2,zero,81105bd8 <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105b68:	e0bfff03 	ldbu	r2,-4(fp)
81105b6c:	10000326 	beq	r2,zero,81105b7c <bFeebCh3SetBufferSize+0x5c>
81105b70:	10800060 	cmpeqi	r2,r2,1
81105b74:	10000b1e 	bne	r2,zero,81105ba4 <bFeebCh3SetBufferSize+0x84>
81105b78:	00001406 	br	81105bcc <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b7c:	e0bffe03 	ldbu	r2,-8(fp)
81105b80:	10bfffc4 	addi	r2,r2,-1
81105b84:	108003cc 	andi	r2,r2,15
81105b88:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105b8c:	e1bffd17 	ldw	r6,-12(fp)
81105b90:	01400544 	movi	r5,21
81105b94:	01204834 	movhi	r4,33056
81105b98:	210b0004 	addi	r4,r4,11264
81105b9c:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ba0:	00000c06 	br	81105bd4 <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ba4:	e0bffe03 	ldbu	r2,-8(fp)
81105ba8:	10bfffc4 	addi	r2,r2,-1
81105bac:	108003cc 	andi	r2,r2,15
81105bb0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105bb4:	e1bffd17 	ldw	r6,-12(fp)
81105bb8:	01400504 	movi	r5,20
81105bbc:	01204834 	movhi	r4,33056
81105bc0:	210b0004 	addi	r4,r4,11264
81105bc4:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105bc8:	00000206 	br	81105bd4 <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105bcc:	e03ffc15 	stw	zero,-16(fp)
			break;
81105bd0:	0001883a 	nop
		}
	} else {
81105bd4:	00000106 	br	81105bdc <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81105bd8:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105bdc:	e0bffc17 	ldw	r2,-16(fp)
}
81105be0:	e037883a 	mov	sp,fp
81105be4:	dfc00117 	ldw	ra,4(sp)
81105be8:	df000017 	ldw	fp,0(sp)
81105bec:	dec00204 	addi	sp,sp,8
81105bf0:	f800283a 	ret

81105bf4 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105bf4:	defffa04 	addi	sp,sp,-24
81105bf8:	de00012e 	bgeu	sp,et,81105c00 <bFeebCh4SetBufferSize+0xc>
81105bfc:	003b68fa 	trap	3
81105c00:	dfc00515 	stw	ra,20(sp)
81105c04:	df000415 	stw	fp,16(sp)
81105c08:	df000404 	addi	fp,sp,16
81105c0c:	2007883a 	mov	r3,r4
81105c10:	2805883a 	mov	r2,r5
81105c14:	e0fffe05 	stb	r3,-8(fp)
81105c18:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105c1c:	00800044 	movi	r2,1
81105c20:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105c24:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c28:	e0bffe03 	ldbu	r2,-8(fp)
81105c2c:	10001f26 	beq	r2,zero,81105cac <bFeebCh4SetBufferSize+0xb8>
81105c30:	e0bffe03 	ldbu	r2,-8(fp)
81105c34:	10800468 	cmpgeui	r2,r2,17
81105c38:	10001c1e 	bne	r2,zero,81105cac <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105c3c:	e0bfff03 	ldbu	r2,-4(fp)
81105c40:	10000326 	beq	r2,zero,81105c50 <bFeebCh4SetBufferSize+0x5c>
81105c44:	10800060 	cmpeqi	r2,r2,1
81105c48:	10000b1e 	bne	r2,zero,81105c78 <bFeebCh4SetBufferSize+0x84>
81105c4c:	00001406 	br	81105ca0 <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c50:	e0bffe03 	ldbu	r2,-8(fp)
81105c54:	10bfffc4 	addi	r2,r2,-1
81105c58:	108003cc 	andi	r2,r2,15
81105c5c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105c60:	e1bffd17 	ldw	r6,-12(fp)
81105c64:	01400544 	movi	r5,21
81105c68:	01204834 	movhi	r4,33056
81105c6c:	210a0004 	addi	r4,r4,10240
81105c70:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c74:	00000c06 	br	81105ca8 <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c78:	e0bffe03 	ldbu	r2,-8(fp)
81105c7c:	10bfffc4 	addi	r2,r2,-1
81105c80:	108003cc 	andi	r2,r2,15
81105c84:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105c88:	e1bffd17 	ldw	r6,-12(fp)
81105c8c:	01400504 	movi	r5,20
81105c90:	01204834 	movhi	r4,33056
81105c94:	210a0004 	addi	r4,r4,10240
81105c98:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c9c:	00000206 	br	81105ca8 <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ca0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105ca4:	0001883a 	nop
		}
	} else {
81105ca8:	00000106 	br	81105cb0 <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81105cac:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105cb0:	e0bffc17 	ldw	r2,-16(fp)
}
81105cb4:	e037883a 	mov	sp,fp
81105cb8:	dfc00117 	ldw	ra,4(sp)
81105cbc:	df000017 	ldw	fp,0(sp)
81105cc0:	dec00204 	addi	sp,sp,8
81105cc4:	f800283a 	ret

81105cc8 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105cc8:	defffa04 	addi	sp,sp,-24
81105ccc:	de00012e 	bgeu	sp,et,81105cd4 <bFeebCh5SetBufferSize+0xc>
81105cd0:	003b68fa 	trap	3
81105cd4:	dfc00515 	stw	ra,20(sp)
81105cd8:	df000415 	stw	fp,16(sp)
81105cdc:	df000404 	addi	fp,sp,16
81105ce0:	2007883a 	mov	r3,r4
81105ce4:	2805883a 	mov	r2,r5
81105ce8:	e0fffe05 	stb	r3,-8(fp)
81105cec:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105cf0:	00800044 	movi	r2,1
81105cf4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105cf8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105cfc:	e0bffe03 	ldbu	r2,-8(fp)
81105d00:	10001f26 	beq	r2,zero,81105d80 <bFeebCh5SetBufferSize+0xb8>
81105d04:	e0bffe03 	ldbu	r2,-8(fp)
81105d08:	10800468 	cmpgeui	r2,r2,17
81105d0c:	10001c1e 	bne	r2,zero,81105d80 <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105d10:	e0bfff03 	ldbu	r2,-4(fp)
81105d14:	10000326 	beq	r2,zero,81105d24 <bFeebCh5SetBufferSize+0x5c>
81105d18:	10800060 	cmpeqi	r2,r2,1
81105d1c:	10000b1e 	bne	r2,zero,81105d4c <bFeebCh5SetBufferSize+0x84>
81105d20:	00001406 	br	81105d74 <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d24:	e0bffe03 	ldbu	r2,-8(fp)
81105d28:	10bfffc4 	addi	r2,r2,-1
81105d2c:	108003cc 	andi	r2,r2,15
81105d30:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105d34:	e1bffd17 	ldw	r6,-12(fp)
81105d38:	01400544 	movi	r5,21
81105d3c:	01204834 	movhi	r4,33056
81105d40:	210b0004 	addi	r4,r4,11264
81105d44:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d48:	00000c06 	br	81105d7c <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d4c:	e0bffe03 	ldbu	r2,-8(fp)
81105d50:	10bfffc4 	addi	r2,r2,-1
81105d54:	108003cc 	andi	r2,r2,15
81105d58:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105d5c:	e1bffd17 	ldw	r6,-12(fp)
81105d60:	01400504 	movi	r5,20
81105d64:	01204834 	movhi	r4,33056
81105d68:	210b0004 	addi	r4,r4,11264
81105d6c:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d70:	00000206 	br	81105d7c <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105d74:	e03ffc15 	stw	zero,-16(fp)
			break;
81105d78:	0001883a 	nop
		}
	} else {
81105d7c:	00000106 	br	81105d84 <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81105d80:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105d84:	e0bffc17 	ldw	r2,-16(fp)
}
81105d88:	e037883a 	mov	sp,fp
81105d8c:	dfc00117 	ldw	ra,4(sp)
81105d90:	df000017 	ldw	fp,0(sp)
81105d94:	dec00204 	addi	sp,sp,8
81105d98:	f800283a 	ret

81105d9c <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105d9c:	defffa04 	addi	sp,sp,-24
81105da0:	de00012e 	bgeu	sp,et,81105da8 <bFeebCh6SetBufferSize+0xc>
81105da4:	003b68fa 	trap	3
81105da8:	dfc00515 	stw	ra,20(sp)
81105dac:	df000415 	stw	fp,16(sp)
81105db0:	df000404 	addi	fp,sp,16
81105db4:	2007883a 	mov	r3,r4
81105db8:	2805883a 	mov	r2,r5
81105dbc:	e0fffe05 	stb	r3,-8(fp)
81105dc0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105dc4:	00800044 	movi	r2,1
81105dc8:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105dcc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105dd0:	e0bffe03 	ldbu	r2,-8(fp)
81105dd4:	10001f26 	beq	r2,zero,81105e54 <bFeebCh6SetBufferSize+0xb8>
81105dd8:	e0bffe03 	ldbu	r2,-8(fp)
81105ddc:	10800468 	cmpgeui	r2,r2,17
81105de0:	10001c1e 	bne	r2,zero,81105e54 <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105de4:	e0bfff03 	ldbu	r2,-4(fp)
81105de8:	10000326 	beq	r2,zero,81105df8 <bFeebCh6SetBufferSize+0x5c>
81105dec:	10800060 	cmpeqi	r2,r2,1
81105df0:	10000b1e 	bne	r2,zero,81105e20 <bFeebCh6SetBufferSize+0x84>
81105df4:	00001406 	br	81105e48 <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105df8:	e0bffe03 	ldbu	r2,-8(fp)
81105dfc:	10bfffc4 	addi	r2,r2,-1
81105e00:	108003cc 	andi	r2,r2,15
81105e04:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105e08:	e1bffd17 	ldw	r6,-12(fp)
81105e0c:	01400544 	movi	r5,21
81105e10:	01204834 	movhi	r4,33056
81105e14:	210a0004 	addi	r4,r4,10240
81105e18:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e1c:	00000c06 	br	81105e50 <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e20:	e0bffe03 	ldbu	r2,-8(fp)
81105e24:	10bfffc4 	addi	r2,r2,-1
81105e28:	108003cc 	andi	r2,r2,15
81105e2c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105e30:	e1bffd17 	ldw	r6,-12(fp)
81105e34:	01400504 	movi	r5,20
81105e38:	01204834 	movhi	r4,33056
81105e3c:	210a0004 	addi	r4,r4,10240
81105e40:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e44:	00000206 	br	81105e50 <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105e48:	e03ffc15 	stw	zero,-16(fp)
			break;
81105e4c:	0001883a 	nop
		}
	} else {
81105e50:	00000106 	br	81105e58 <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81105e54:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105e58:	e0bffc17 	ldw	r2,-16(fp)
}
81105e5c:	e037883a 	mov	sp,fp
81105e60:	dfc00117 	ldw	ra,4(sp)
81105e64:	df000017 	ldw	fp,0(sp)
81105e68:	dec00204 	addi	sp,sp,8
81105e6c:	f800283a 	ret

81105e70 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105e70:	defffa04 	addi	sp,sp,-24
81105e74:	de00012e 	bgeu	sp,et,81105e7c <bFeebCh7SetBufferSize+0xc>
81105e78:	003b68fa 	trap	3
81105e7c:	dfc00515 	stw	ra,20(sp)
81105e80:	df000415 	stw	fp,16(sp)
81105e84:	df000404 	addi	fp,sp,16
81105e88:	2007883a 	mov	r3,r4
81105e8c:	2805883a 	mov	r2,r5
81105e90:	e0fffe05 	stb	r3,-8(fp)
81105e94:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105e98:	00800044 	movi	r2,1
81105e9c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105ea0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ea4:	e0bffe03 	ldbu	r2,-8(fp)
81105ea8:	10001f26 	beq	r2,zero,81105f28 <bFeebCh7SetBufferSize+0xb8>
81105eac:	e0bffe03 	ldbu	r2,-8(fp)
81105eb0:	10800468 	cmpgeui	r2,r2,17
81105eb4:	10001c1e 	bne	r2,zero,81105f28 <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105eb8:	e0bfff03 	ldbu	r2,-4(fp)
81105ebc:	10000326 	beq	r2,zero,81105ecc <bFeebCh7SetBufferSize+0x5c>
81105ec0:	10800060 	cmpeqi	r2,r2,1
81105ec4:	10000b1e 	bne	r2,zero,81105ef4 <bFeebCh7SetBufferSize+0x84>
81105ec8:	00001406 	br	81105f1c <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ecc:	e0bffe03 	ldbu	r2,-8(fp)
81105ed0:	10bfffc4 	addi	r2,r2,-1
81105ed4:	108003cc 	andi	r2,r2,15
81105ed8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105edc:	e1bffd17 	ldw	r6,-12(fp)
81105ee0:	01400544 	movi	r5,21
81105ee4:	01204834 	movhi	r4,33056
81105ee8:	210b0004 	addi	r4,r4,11264
81105eec:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ef0:	00000c06 	br	81105f24 <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ef4:	e0bffe03 	ldbu	r2,-8(fp)
81105ef8:	10bfffc4 	addi	r2,r2,-1
81105efc:	108003cc 	andi	r2,r2,15
81105f00:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105f04:	e1bffd17 	ldw	r6,-12(fp)
81105f08:	01400504 	movi	r5,20
81105f0c:	01204834 	movhi	r4,33056
81105f10:	210b0004 	addi	r4,r4,11264
81105f14:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105f18:	00000206 	br	81105f24 <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105f1c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105f20:	0001883a 	nop
		}
	} else {
81105f24:	00000106 	br	81105f2c <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
81105f28:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105f2c:	e0bffc17 	ldw	r2,-16(fp)
}
81105f30:	e037883a 	mov	sp,fp
81105f34:	dfc00117 	ldw	ra,4(sp)
81105f38:	df000017 	ldw	fp,0(sp)
81105f3c:	dec00204 	addi	sp,sp,8
81105f40:	f800283a 	ret

81105f44 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105f44:	defffa04 	addi	sp,sp,-24
81105f48:	de00012e 	bgeu	sp,et,81105f50 <bFeebCh8SetBufferSize+0xc>
81105f4c:	003b68fa 	trap	3
81105f50:	dfc00515 	stw	ra,20(sp)
81105f54:	df000415 	stw	fp,16(sp)
81105f58:	df000404 	addi	fp,sp,16
81105f5c:	2007883a 	mov	r3,r4
81105f60:	2805883a 	mov	r2,r5
81105f64:	e0fffe05 	stb	r3,-8(fp)
81105f68:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105f6c:	00800044 	movi	r2,1
81105f70:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105f74:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105f78:	e0bffe03 	ldbu	r2,-8(fp)
81105f7c:	10001f26 	beq	r2,zero,81105ffc <bFeebCh8SetBufferSize+0xb8>
81105f80:	e0bffe03 	ldbu	r2,-8(fp)
81105f84:	10800468 	cmpgeui	r2,r2,17
81105f88:	10001c1e 	bne	r2,zero,81105ffc <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105f8c:	e0bfff03 	ldbu	r2,-4(fp)
81105f90:	10000326 	beq	r2,zero,81105fa0 <bFeebCh8SetBufferSize+0x5c>
81105f94:	10800060 	cmpeqi	r2,r2,1
81105f98:	10000b1e 	bne	r2,zero,81105fc8 <bFeebCh8SetBufferSize+0x84>
81105f9c:	00001406 	br	81105ff0 <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105fa0:	e0bffe03 	ldbu	r2,-8(fp)
81105fa4:	10bfffc4 	addi	r2,r2,-1
81105fa8:	108003cc 	andi	r2,r2,15
81105fac:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105fb0:	e1bffd17 	ldw	r6,-12(fp)
81105fb4:	01400544 	movi	r5,21
81105fb8:	01204834 	movhi	r4,33056
81105fbc:	210a0004 	addi	r4,r4,10240
81105fc0:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105fc4:	00000c06 	br	81105ff8 <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105fc8:	e0bffe03 	ldbu	r2,-8(fp)
81105fcc:	10bfffc4 	addi	r2,r2,-1
81105fd0:	108003cc 	andi	r2,r2,15
81105fd4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105fd8:	e1bffd17 	ldw	r6,-12(fp)
81105fdc:	01400504 	movi	r5,20
81105fe0:	01204834 	movhi	r4,33056
81105fe4:	210a0004 	addi	r4,r4,10240
81105fe8:	1106c640 	call	81106c64 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105fec:	00000206 	br	81105ff8 <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ff0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105ff4:	0001883a 	nop
		}
	} else {
81105ff8:	00000106 	br	81106000 <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
81105ffc:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81106000:	e0bffc17 	ldw	r2,-16(fp)
}
81106004:	e037883a 	mov	sp,fp
81106008:	dfc00117 	ldw	ra,4(sp)
8110600c:	df000017 	ldw	fp,0(sp)
81106010:	dec00204 	addi	sp,sp,8
81106014:	f800283a 	ret

81106018 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81106018:	defffc04 	addi	sp,sp,-16
8110601c:	de00012e 	bgeu	sp,et,81106024 <vFeebInitIrq+0xc>
81106020:	003b68fa 	trap	3
81106024:	dfc00315 	stw	ra,12(sp)
81106028:	df000215 	stw	fp,8(sp)
8110602c:	df000204 	addi	fp,sp,8
81106030:	2005883a 	mov	r2,r4
81106034:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81106038:	e0bfff03 	ldbu	r2,-4(fp)
8110603c:	10c00228 	cmpgeui	r3,r2,8
81106040:	18004e1e 	bne	r3,zero,8110617c <vFeebInitIrq+0x164>
81106044:	100690ba 	slli	r3,r2,2
81106048:	00a04434 	movhi	r2,33040
8110604c:	10981704 	addi	r2,r2,24668
81106050:	1885883a 	add	r2,r3,r2
81106054:	10800017 	ldw	r2,0(r2)
81106058:	1000683a 	jmp	r2
8110605c:	8110607c 	xorhi	r4,r16,16769
81106060:	8110609c 	xori	r4,r16,16770
81106064:	811060bc 	xorhi	r4,r16,16770
81106068:	811060dc 	xori	r4,r16,16771
8110606c:	811060fc 	xorhi	r4,r16,16771
81106070:	8110611c 	xori	r4,r16,16772
81106074:	8110613c 	xorhi	r4,r16,16772
81106078:	8110615c 	xori	r4,r16,16773
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
8110607c:	d0a04004 	addi	r2,gp,-32512
81106080:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81106084:	01a04434 	movhi	r6,33040
81106088:	31946204 	addi	r6,r6,20872
8110608c:	e17ffe17 	ldw	r5,-8(fp)
81106090:	01000584 	movi	r4,22
81106094:	11363a80 	call	811363a8 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81106098:	00003806 	br	8110617c <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
8110609c:	d0a04104 	addi	r2,gp,-32508
811060a0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
811060a4:	01a04434 	movhi	r6,33040
811060a8:	31947204 	addi	r6,r6,20936
811060ac:	e17ffe17 	ldw	r5,-8(fp)
811060b0:	01000504 	movi	r4,20
811060b4:	11363a80 	call	811363a8 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
811060b8:	00003006 	br	8110617c <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811060bc:	d0a04204 	addi	r2,gp,-32504
811060c0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
811060c4:	01a04434 	movhi	r6,33040
811060c8:	31948204 	addi	r6,r6,21000
811060cc:	e17ffe17 	ldw	r5,-8(fp)
811060d0:	01000484 	movi	r4,18
811060d4:	11363a80 	call	811363a8 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
811060d8:	00002806 	br	8110617c <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811060dc:	d0a04304 	addi	r2,gp,-32500
811060e0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
811060e4:	01a04434 	movhi	r6,33040
811060e8:	3194a304 	addi	r6,r6,21132
811060ec:	e17ffe17 	ldw	r5,-8(fp)
811060f0:	01000404 	movi	r4,16
811060f4:	11363a80 	call	811363a8 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
811060f8:	00002006 	br	8110617c <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811060fc:	d0a04404 	addi	r2,gp,-32496
81106100:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81106104:	01a04434 	movhi	r6,33040
81106108:	3194c404 	addi	r6,r6,21264
8110610c:	e17ffe17 	ldw	r5,-8(fp)
81106110:	01000204 	movi	r4,8
81106114:	11363a80 	call	811363a8 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81106118:	00001806 	br	8110617c <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
8110611c:	d0a04504 	addi	r2,gp,-32492
81106120:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81106124:	01a04434 	movhi	r6,33040
81106128:	3194e504 	addi	r6,r6,21396
8110612c:	e17ffe17 	ldw	r5,-8(fp)
81106130:	01000184 	movi	r4,6
81106134:	11363a80 	call	811363a8 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81106138:	00001006 	br	8110617c <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
8110613c:	d0a04604 	addi	r2,gp,-32488
81106140:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81106144:	01a04434 	movhi	r6,33040
81106148:	31950604 	addi	r6,r6,21528
8110614c:	e17ffe17 	ldw	r5,-8(fp)
81106150:	01000144 	movi	r4,5
81106154:	11363a80 	call	811363a8 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81106158:	00000806 	br	8110617c <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
8110615c:	d0a04704 	addi	r2,gp,-32484
81106160:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81106164:	01a04434 	movhi	r6,33040
81106168:	31951604 	addi	r6,r6,21592
8110616c:	e17ffe17 	ldw	r5,-8(fp)
81106170:	01000084 	movi	r4,2
81106174:	11363a80 	call	811363a8 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81106178:	0001883a 	nop
	}
}
8110617c:	0001883a 	nop
81106180:	e037883a 	mov	sp,fp
81106184:	dfc00117 	ldw	ra,4(sp)
81106188:	df000017 	ldw	fp,0(sp)
8110618c:	dec00204 	addi	sp,sp,8
81106190:	f800283a 	ret

81106194 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81106194:	defffb04 	addi	sp,sp,-20
81106198:	de00012e 	bgeu	sp,et,811061a0 <bFeebSetIrqControl+0xc>
8110619c:	003b68fa 	trap	3
811061a0:	dfc00415 	stw	ra,16(sp)
811061a4:	df000315 	stw	fp,12(sp)
811061a8:	df000304 	addi	fp,sp,12
811061ac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811061b0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811061b4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811061b8:	e0bfff17 	ldw	r2,-4(fp)
811061bc:	10002426 	beq	r2,zero,81106250 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811061c0:	e0bfff17 	ldw	r2,-4(fp)
811061c4:	10800017 	ldw	r2,0(r2)
811061c8:	01400444 	movi	r5,17
811061cc:	1009883a 	mov	r4,r2
811061d0:	1106cb80 	call	81106cb8 <uliFeebReadReg>
811061d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
811061d8:	e0bfff17 	ldw	r2,-4(fp)
811061dc:	10800217 	ldw	r2,8(r2)
811061e0:	10000426 	beq	r2,zero,811061f4 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
811061e4:	e0bffe17 	ldw	r2,-8(fp)
811061e8:	10808014 	ori	r2,r2,512
811061ec:	e0bffe15 	stw	r2,-8(fp)
811061f0:	00000406 	br	81106204 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
811061f4:	e0fffe17 	ldw	r3,-8(fp)
811061f8:	00bf7fc4 	movi	r2,-513
811061fc:	1884703a 	and	r2,r3,r2
81106200:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81106204:	e0bfff17 	ldw	r2,-4(fp)
81106208:	10800317 	ldw	r2,12(r2)
8110620c:	10000426 	beq	r2,zero,81106220 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81106210:	e0bffe17 	ldw	r2,-8(fp)
81106214:	10804014 	ori	r2,r2,256
81106218:	e0bffe15 	stw	r2,-8(fp)
8110621c:	00000406 	br	81106230 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81106220:	e0fffe17 	ldw	r3,-8(fp)
81106224:	00bfbfc4 	movi	r2,-257
81106228:	1884703a 	and	r2,r3,r2
8110622c:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106230:	e0bfff17 	ldw	r2,-4(fp)
81106234:	10800017 	ldw	r2,0(r2)
81106238:	e1bffe17 	ldw	r6,-8(fp)
8110623c:	01400444 	movi	r5,17
81106240:	1009883a 	mov	r4,r2
81106244:	1106c640 	call	81106c64 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81106248:	00800044 	movi	r2,1
8110624c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106250:	e0bffd17 	ldw	r2,-12(fp)
}
81106254:	e037883a 	mov	sp,fp
81106258:	dfc00117 	ldw	ra,4(sp)
8110625c:	df000017 	ldw	fp,0(sp)
81106260:	dec00204 	addi	sp,sp,8
81106264:	f800283a 	ret

81106268 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81106268:	defffb04 	addi	sp,sp,-20
8110626c:	de00012e 	bgeu	sp,et,81106274 <bFeebGetIrqControl+0xc>
81106270:	003b68fa 	trap	3
81106274:	dfc00415 	stw	ra,16(sp)
81106278:	df000315 	stw	fp,12(sp)
8110627c:	df000304 	addi	fp,sp,12
81106280:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106284:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106288:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110628c:	e0bfff17 	ldw	r2,-4(fp)
81106290:	10001a26 	beq	r2,zero,811062fc <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106294:	e0bfff17 	ldw	r2,-4(fp)
81106298:	10800017 	ldw	r2,0(r2)
8110629c:	01400444 	movi	r5,17
811062a0:	1009883a 	mov	r4,r2
811062a4:	1106cb80 	call	81106cb8 <uliFeebReadReg>
811062a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
811062ac:	e0bffe17 	ldw	r2,-8(fp)
811062b0:	1080800c 	andi	r2,r2,512
811062b4:	10000426 	beq	r2,zero,811062c8 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
811062b8:	e0bfff17 	ldw	r2,-4(fp)
811062bc:	00c00044 	movi	r3,1
811062c0:	10c00215 	stw	r3,8(r2)
811062c4:	00000206 	br	811062d0 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811062c8:	e0bfff17 	ldw	r2,-4(fp)
811062cc:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
811062d0:	e0bffe17 	ldw	r2,-8(fp)
811062d4:	1080400c 	andi	r2,r2,256
811062d8:	10000426 	beq	r2,zero,811062ec <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
811062dc:	e0bfff17 	ldw	r2,-4(fp)
811062e0:	00c00044 	movi	r3,1
811062e4:	10c00315 	stw	r3,12(r2)
811062e8:	00000206 	br	811062f4 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
811062ec:	e0bfff17 	ldw	r2,-4(fp)
811062f0:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
811062f4:	00800044 	movi	r2,1
811062f8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811062fc:	e0bffd17 	ldw	r2,-12(fp)
}
81106300:	e037883a 	mov	sp,fp
81106304:	dfc00117 	ldw	ra,4(sp)
81106308:	df000017 	ldw	fp,0(sp)
8110630c:	dec00204 	addi	sp,sp,8
81106310:	f800283a 	ret

81106314 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81106314:	defffb04 	addi	sp,sp,-20
81106318:	de00012e 	bgeu	sp,et,81106320 <bFeebGetIrqFlags+0xc>
8110631c:	003b68fa 	trap	3
81106320:	dfc00415 	stw	ra,16(sp)
81106324:	df000315 	stw	fp,12(sp)
81106328:	df000304 	addi	fp,sp,12
8110632c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106330:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106334:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106338:	e0bfff17 	ldw	r2,-4(fp)
8110633c:	10001126 	beq	r2,zero,81106384 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106340:	e0bfff17 	ldw	r2,-4(fp)
81106344:	10800017 	ldw	r2,0(r2)
81106348:	01400484 	movi	r5,18
8110634c:	1009883a 	mov	r4,r2
81106350:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106354:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81106358:	e0bffe17 	ldw	r2,-8(fp)
8110635c:	1080400c 	andi	r2,r2,256
81106360:	10000426 	beq	r2,zero,81106374 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81106364:	e0bfff17 	ldw	r2,-4(fp)
81106368:	00c00044 	movi	r3,1
8110636c:	10c00415 	stw	r3,16(r2)
81106370:	00000206 	br	8110637c <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81106374:	e0bfff17 	ldw	r2,-4(fp)
81106378:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
8110637c:	00800044 	movi	r2,1
81106380:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106384:	e0bffd17 	ldw	r2,-12(fp)
}
81106388:	e037883a 	mov	sp,fp
8110638c:	dfc00117 	ldw	ra,4(sp)
81106390:	df000017 	ldw	fp,0(sp)
81106394:	dec00204 	addi	sp,sp,8
81106398:	f800283a 	ret

8110639c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110639c:	defffb04 	addi	sp,sp,-20
811063a0:	de00012e 	bgeu	sp,et,811063a8 <bFeebGetBuffersStatus+0xc>
811063a4:	003b68fa 	trap	3
811063a8:	dfc00415 	stw	ra,16(sp)
811063ac:	df000315 	stw	fp,12(sp)
811063b0:	df000304 	addi	fp,sp,12
811063b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811063b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811063bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811063c0:	e0bfff17 	ldw	r2,-4(fp)
811063c4:	10003226 	beq	r2,zero,81106490 <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811063c8:	e0bfff17 	ldw	r2,-4(fp)
811063cc:	10800017 	ldw	r2,0(r2)
811063d0:	014000c4 	movi	r5,3
811063d4:	1009883a 	mov	r4,r2
811063d8:	1106cb80 	call	81106cb8 <uliFeebReadReg>
811063dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811063e0:	e0bffe17 	ldw	r2,-8(fp)
811063e4:	1080008c 	andi	r2,r2,2
811063e8:	10000426 	beq	r2,zero,811063fc <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
811063ec:	e0bfff17 	ldw	r2,-4(fp)
811063f0:	00c00044 	movi	r3,1
811063f4:	10c00515 	stw	r3,20(r2)
811063f8:	00000206 	br	81106404 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
811063fc:	e0bfff17 	ldw	r2,-4(fp)
81106400:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106404:	e0bffe17 	ldw	r2,-8(fp)
81106408:	1080004c 	andi	r2,r2,1
8110640c:	10000426 	beq	r2,zero,81106420 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81106410:	e0bfff17 	ldw	r2,-4(fp)
81106414:	00c00044 	movi	r3,1
81106418:	10c00615 	stw	r3,24(r2)
8110641c:	00000206 	br	81106428 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81106420:	e0bfff17 	ldw	r2,-4(fp)
81106424:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106428:	e0bfff17 	ldw	r2,-4(fp)
8110642c:	10800017 	ldw	r2,0(r2)
81106430:	01400504 	movi	r5,20
81106434:	1009883a 	mov	r4,r2
81106438:	1106cb80 	call	81106cb8 <uliFeebReadReg>
8110643c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106440:	e0bffe17 	ldw	r2,-8(fp)
81106444:	108003cc 	andi	r2,r2,15
81106448:	10800044 	addi	r2,r2,1
8110644c:	1007883a 	mov	r3,r2
81106450:	e0bfff17 	ldw	r2,-4(fp)
81106454:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106458:	e0bfff17 	ldw	r2,-4(fp)
8110645c:	10800017 	ldw	r2,0(r2)
81106460:	01400544 	movi	r5,21
81106464:	1009883a 	mov	r4,r2
81106468:	1106cb80 	call	81106cb8 <uliFeebReadReg>
8110646c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106470:	e0bffe17 	ldw	r2,-8(fp)
81106474:	108003cc 	andi	r2,r2,15
81106478:	10800044 	addi	r2,r2,1
8110647c:	1007883a 	mov	r3,r2
81106480:	e0bfff17 	ldw	r2,-4(fp)
81106484:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
81106488:	00800044 	movi	r2,1
8110648c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106490:	e0bffd17 	ldw	r2,-12(fp)
}
81106494:	e037883a 	mov	sp,fp
81106498:	dfc00117 	ldw	ra,4(sp)
8110649c:	df000017 	ldw	fp,0(sp)
811064a0:	dec00204 	addi	sp,sp,8
811064a4:	f800283a 	ret

811064a8 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
811064a8:	defffb04 	addi	sp,sp,-20
811064ac:	de00012e 	bgeu	sp,et,811064b4 <bFeebGetLeftBufferEmpty+0xc>
811064b0:	003b68fa 	trap	3
811064b4:	dfc00415 	stw	ra,16(sp)
811064b8:	df000315 	stw	fp,12(sp)
811064bc:	df000304 	addi	fp,sp,12
811064c0:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
811064c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811064c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811064cc:	e0bfff17 	ldw	r2,-4(fp)
811064d0:	10000d26 	beq	r2,zero,81106508 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811064d4:	e0bfff17 	ldw	r2,-4(fp)
811064d8:	10800017 	ldw	r2,0(r2)
811064dc:	014000c4 	movi	r5,3
811064e0:	1009883a 	mov	r4,r2
811064e4:	1106cb80 	call	81106cb8 <uliFeebReadReg>
811064e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811064ec:	e0bffe17 	ldw	r2,-8(fp)
811064f0:	1080008c 	andi	r2,r2,2
811064f4:	10000326 	beq	r2,zero,81106504 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
811064f8:	00800044 	movi	r2,1
811064fc:	e0bffd15 	stw	r2,-12(fp)
81106500:	00000106 	br	81106508 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
81106504:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106508:	e0bffd17 	ldw	r2,-12(fp)
}
8110650c:	e037883a 	mov	sp,fp
81106510:	dfc00117 	ldw	ra,4(sp)
81106514:	df000017 	ldw	fp,0(sp)
81106518:	dec00204 	addi	sp,sp,8
8110651c:	f800283a 	ret

81106520 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
81106520:	defffb04 	addi	sp,sp,-20
81106524:	de00012e 	bgeu	sp,et,8110652c <bFeebGetRightBufferEmpty+0xc>
81106528:	003b68fa 	trap	3
8110652c:	dfc00415 	stw	ra,16(sp)
81106530:	df000315 	stw	fp,12(sp)
81106534:	df000304 	addi	fp,sp,12
81106538:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
8110653c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106540:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106544:	e0bfff17 	ldw	r2,-4(fp)
81106548:	10000d26 	beq	r2,zero,81106580 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110654c:	e0bfff17 	ldw	r2,-4(fp)
81106550:	10800017 	ldw	r2,0(r2)
81106554:	014000c4 	movi	r5,3
81106558:	1009883a 	mov	r4,r2
8110655c:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106560:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106564:	e0bffe17 	ldw	r2,-8(fp)
81106568:	1080004c 	andi	r2,r2,1
8110656c:	10000326 	beq	r2,zero,8110657c <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
81106570:	00800044 	movi	r2,1
81106574:	e0bffd15 	stw	r2,-12(fp)
81106578:	00000106 	br	81106580 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
8110657c:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106580:	e0bffd17 	ldw	r2,-12(fp)
}
81106584:	e037883a 	mov	sp,fp
81106588:	dfc00117 	ldw	ra,4(sp)
8110658c:	df000017 	ldw	fp,0(sp)
81106590:	dec00204 	addi	sp,sp,8
81106594:	f800283a 	ret

81106598 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
81106598:	defffc04 	addi	sp,sp,-16
8110659c:	de00012e 	bgeu	sp,et,811065a4 <bFeebGetCh1LeftBufferEmpty+0xc>
811065a0:	003b68fa 	trap	3
811065a4:	dfc00315 	stw	ra,12(sp)
811065a8:	df000215 	stw	fp,8(sp)
811065ac:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811065b0:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811065b4:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811065b8:	014000c4 	movi	r5,3
811065bc:	01204834 	movhi	r4,33056
811065c0:	210b0004 	addi	r4,r4,11264
811065c4:	1106cb80 	call	81106cb8 <uliFeebReadReg>
811065c8:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811065cc:	e0bfff17 	ldw	r2,-4(fp)
811065d0:	1080008c 	andi	r2,r2,2
811065d4:	10000326 	beq	r2,zero,811065e4 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
811065d8:	00800044 	movi	r2,1
811065dc:	e0bffe15 	stw	r2,-8(fp)
811065e0:	00000106 	br	811065e8 <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811065e4:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811065e8:	e0bffe17 	ldw	r2,-8(fp)
}
811065ec:	e037883a 	mov	sp,fp
811065f0:	dfc00117 	ldw	ra,4(sp)
811065f4:	df000017 	ldw	fp,0(sp)
811065f8:	dec00204 	addi	sp,sp,8
811065fc:	f800283a 	ret

81106600 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
81106600:	defffc04 	addi	sp,sp,-16
81106604:	de00012e 	bgeu	sp,et,8110660c <bFeebGetCh1RightBufferEmpty+0xc>
81106608:	003b68fa 	trap	3
8110660c:	dfc00315 	stw	ra,12(sp)
81106610:	df000215 	stw	fp,8(sp)
81106614:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106618:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
8110661c:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106620:	014000c4 	movi	r5,3
81106624:	01204834 	movhi	r4,33056
81106628:	210b0004 	addi	r4,r4,11264
8110662c:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106630:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106634:	e0bfff17 	ldw	r2,-4(fp)
81106638:	1080004c 	andi	r2,r2,1
8110663c:	10000326 	beq	r2,zero,8110664c <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106640:	00800044 	movi	r2,1
81106644:	e0bffe15 	stw	r2,-8(fp)
81106648:	00000106 	br	81106650 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
8110664c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106650:	e0bffe17 	ldw	r2,-8(fp)
}
81106654:	e037883a 	mov	sp,fp
81106658:	dfc00117 	ldw	ra,4(sp)
8110665c:	df000017 	ldw	fp,0(sp)
81106660:	dec00204 	addi	sp,sp,8
81106664:	f800283a 	ret

81106668 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
81106668:	defffc04 	addi	sp,sp,-16
8110666c:	de00012e 	bgeu	sp,et,81106674 <bFeebGetCh2LeftBufferEmpty+0xc>
81106670:	003b68fa 	trap	3
81106674:	dfc00315 	stw	ra,12(sp)
81106678:	df000215 	stw	fp,8(sp)
8110667c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106680:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106684:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106688:	014000c4 	movi	r5,3
8110668c:	01204834 	movhi	r4,33056
81106690:	210a0004 	addi	r4,r4,10240
81106694:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106698:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110669c:	e0bfff17 	ldw	r2,-4(fp)
811066a0:	1080008c 	andi	r2,r2,2
811066a4:	10000326 	beq	r2,zero,811066b4 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
811066a8:	00800044 	movi	r2,1
811066ac:	e0bffe15 	stw	r2,-8(fp)
811066b0:	00000106 	br	811066b8 <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811066b4:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811066b8:	e0bffe17 	ldw	r2,-8(fp)
}
811066bc:	e037883a 	mov	sp,fp
811066c0:	dfc00117 	ldw	ra,4(sp)
811066c4:	df000017 	ldw	fp,0(sp)
811066c8:	dec00204 	addi	sp,sp,8
811066cc:	f800283a 	ret

811066d0 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
811066d0:	defffc04 	addi	sp,sp,-16
811066d4:	de00012e 	bgeu	sp,et,811066dc <bFeebGetCh2RightBufferEmpty+0xc>
811066d8:	003b68fa 	trap	3
811066dc:	dfc00315 	stw	ra,12(sp)
811066e0:	df000215 	stw	fp,8(sp)
811066e4:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811066e8:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811066ec:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
811066f0:	014000c4 	movi	r5,3
811066f4:	01204834 	movhi	r4,33056
811066f8:	210a0004 	addi	r4,r4,10240
811066fc:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106700:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106704:	e0bfff17 	ldw	r2,-4(fp)
81106708:	1080004c 	andi	r2,r2,1
8110670c:	10000326 	beq	r2,zero,8110671c <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106710:	00800044 	movi	r2,1
81106714:	e0bffe15 	stw	r2,-8(fp)
81106718:	00000106 	br	81106720 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
8110671c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106720:	e0bffe17 	ldw	r2,-8(fp)
}
81106724:	e037883a 	mov	sp,fp
81106728:	dfc00117 	ldw	ra,4(sp)
8110672c:	df000017 	ldw	fp,0(sp)
81106730:	dec00204 	addi	sp,sp,8
81106734:	f800283a 	ret

81106738 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
81106738:	defff904 	addi	sp,sp,-28
8110673c:	de00012e 	bgeu	sp,et,81106744 <bFeebSetBufferSize+0xc>
81106740:	003b68fa 	trap	3
81106744:	dfc00615 	stw	ra,24(sp)
81106748:	df000515 	stw	fp,20(sp)
8110674c:	df000504 	addi	fp,sp,20
81106750:	e13ffd15 	stw	r4,-12(fp)
81106754:	2807883a 	mov	r3,r5
81106758:	3005883a 	mov	r2,r6
8110675c:	e0fffe05 	stb	r3,-8(fp)
81106760:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106764:	00800044 	movi	r2,1
81106768:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110676c:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106770:	e0bffe03 	ldbu	r2,-8(fp)
81106774:	10002126 	beq	r2,zero,811067fc <bFeebSetBufferSize+0xc4>
81106778:	e0bffe03 	ldbu	r2,-8(fp)
8110677c:	10800468 	cmpgeui	r2,r2,17
81106780:	10001e1e 	bne	r2,zero,811067fc <bFeebSetBufferSize+0xc4>
		switch (ucBufferSide) {
81106784:	e0bfff03 	ldbu	r2,-4(fp)
81106788:	10000326 	beq	r2,zero,81106798 <bFeebSetBufferSize+0x60>
8110678c:	10800060 	cmpeqi	r2,r2,1
81106790:	10000c1e 	bne	r2,zero,811067c4 <bFeebSetBufferSize+0x8c>
81106794:	00001606 	br	811067f0 <bFeebSetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81106798:	e0bffe03 	ldbu	r2,-8(fp)
8110679c:	10bfffc4 	addi	r2,r2,-1
811067a0:	108003cc 	andi	r2,r2,15
811067a4:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
811067a8:	e0bffd17 	ldw	r2,-12(fp)
811067ac:	10800017 	ldw	r2,0(r2)
811067b0:	e1bffc17 	ldw	r6,-16(fp)
811067b4:	01400544 	movi	r5,21
811067b8:	1009883a 	mov	r4,r2
811067bc:	1106c640 	call	81106c64 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811067c0:	00000d06 	br	811067f8 <bFeebSetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811067c4:	e0bffe03 	ldbu	r2,-8(fp)
811067c8:	10bfffc4 	addi	r2,r2,-1
811067cc:	108003cc 	andi	r2,r2,15
811067d0:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
811067d4:	e0bffd17 	ldw	r2,-12(fp)
811067d8:	10800017 	ldw	r2,0(r2)
811067dc:	e1bffc17 	ldw	r6,-16(fp)
811067e0:	01400504 	movi	r5,20
811067e4:	1009883a 	mov	r4,r2
811067e8:	1106c640 	call	81106c64 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811067ec:	00000206 	br	811067f8 <bFeebSetBufferSize+0xc0>
		default:
			bStatus = FALSE;
811067f0:	e03ffb15 	stw	zero,-20(fp)
			break;
811067f4:	0001883a 	nop
		}
	} else {
811067f8:	00000106 	br	81106800 <bFeebSetBufferSize+0xc8>
		bStatus = FALSE;
811067fc:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
81106800:	e0bffb17 	ldw	r2,-20(fp)
}
81106804:	e037883a 	mov	sp,fp
81106808:	dfc00117 	ldw	ra,4(sp)
8110680c:	df000017 	ldw	fp,0(sp)
81106810:	dec00204 	addi	sp,sp,8
81106814:	f800283a 	ret

81106818 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81106818:	defffb04 	addi	sp,sp,-20
8110681c:	de00012e 	bgeu	sp,et,81106824 <bFeebSetWindowing+0xc>
81106820:	003b68fa 	trap	3
81106824:	dfc00415 	stw	ra,16(sp)
81106828:	df000315 	stw	fp,12(sp)
8110682c:	df000304 	addi	fp,sp,12
81106830:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106834:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106838:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110683c:	e0bfff17 	ldw	r2,-4(fp)
81106840:	10001926 	beq	r2,zero,811068a8 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106844:	e0bfff17 	ldw	r2,-4(fp)
81106848:	10800017 	ldw	r2,0(r2)
8110684c:	01400084 	movi	r5,2
81106850:	1009883a 	mov	r4,r2
81106854:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106858:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
8110685c:	e0bfff17 	ldw	r2,-4(fp)
81106860:	10800117 	ldw	r2,4(r2)
81106864:	10000426 	beq	r2,zero,81106878 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81106868:	e0bffe17 	ldw	r2,-8(fp)
8110686c:	10800214 	ori	r2,r2,8
81106870:	e0bffe15 	stw	r2,-8(fp)
81106874:	00000406 	br	81106888 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81106878:	e0fffe17 	ldw	r3,-8(fp)
8110687c:	00bffdc4 	movi	r2,-9
81106880:	1884703a 	and	r2,r3,r2
81106884:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106888:	e0bfff17 	ldw	r2,-4(fp)
8110688c:	10800017 	ldw	r2,0(r2)
81106890:	e1bffe17 	ldw	r6,-8(fp)
81106894:	01400084 	movi	r5,2
81106898:	1009883a 	mov	r4,r2
8110689c:	1106c640 	call	81106c64 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811068a0:	00800044 	movi	r2,1
811068a4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811068a8:	e0bffd17 	ldw	r2,-12(fp)
}
811068ac:	e037883a 	mov	sp,fp
811068b0:	dfc00117 	ldw	ra,4(sp)
811068b4:	df000017 	ldw	fp,0(sp)
811068b8:	dec00204 	addi	sp,sp,8
811068bc:	f800283a 	ret

811068c0 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
811068c0:	defffb04 	addi	sp,sp,-20
811068c4:	de00012e 	bgeu	sp,et,811068cc <bFeebGetWindowing+0xc>
811068c8:	003b68fa 	trap	3
811068cc:	dfc00415 	stw	ra,16(sp)
811068d0:	df000315 	stw	fp,12(sp)
811068d4:	df000304 	addi	fp,sp,12
811068d8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811068dc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811068e0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811068e4:	e0bfff17 	ldw	r2,-4(fp)
811068e8:	10001126 	beq	r2,zero,81106930 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811068ec:	e0bfff17 	ldw	r2,-4(fp)
811068f0:	10800017 	ldw	r2,0(r2)
811068f4:	01400084 	movi	r5,2
811068f8:	1009883a 	mov	r4,r2
811068fc:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106900:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81106904:	e0bffe17 	ldw	r2,-8(fp)
81106908:	1080020c 	andi	r2,r2,8
8110690c:	10000426 	beq	r2,zero,81106920 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81106910:	e0bfff17 	ldw	r2,-4(fp)
81106914:	00c00044 	movi	r3,1
81106918:	10c00115 	stw	r3,4(r2)
8110691c:	00000206 	br	81106928 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81106920:	e0bfff17 	ldw	r2,-4(fp)
81106924:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81106928:	00800044 	movi	r2,1
8110692c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106930:	e0bffd17 	ldw	r2,-12(fp)
}
81106934:	e037883a 	mov	sp,fp
81106938:	dfc00117 	ldw	ra,4(sp)
8110693c:	df000017 	ldw	fp,0(sp)
81106940:	dec00204 	addi	sp,sp,8
81106944:	f800283a 	ret

81106948 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81106948:	defffb04 	addi	sp,sp,-20
8110694c:	de00012e 	bgeu	sp,et,81106954 <bFeebStartCh+0xc>
81106950:	003b68fa 	trap	3
81106954:	dfc00415 	stw	ra,16(sp)
81106958:	df000315 	stw	fp,12(sp)
8110695c:	df000304 	addi	fp,sp,12
81106960:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106964:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106968:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110696c:	e0bfff17 	ldw	r2,-4(fp)
81106970:	10001126 	beq	r2,zero,811069b8 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106974:	e0bfff17 	ldw	r2,-4(fp)
81106978:	10800017 	ldw	r2,0(r2)
8110697c:	01400084 	movi	r5,2
81106980:	1009883a 	mov	r4,r2
81106984:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106988:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
8110698c:	e0bffe17 	ldw	r2,-8(fp)
81106990:	10800114 	ori	r2,r2,4
81106994:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106998:	e0bfff17 	ldw	r2,-4(fp)
8110699c:	10800017 	ldw	r2,0(r2)
811069a0:	e1bffe17 	ldw	r6,-8(fp)
811069a4:	01400084 	movi	r5,2
811069a8:	1009883a 	mov	r4,r2
811069ac:	1106c640 	call	81106c64 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811069b0:	00800044 	movi	r2,1
811069b4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811069b8:	e0bffd17 	ldw	r2,-12(fp)
}
811069bc:	e037883a 	mov	sp,fp
811069c0:	dfc00117 	ldw	ra,4(sp)
811069c4:	df000017 	ldw	fp,0(sp)
811069c8:	dec00204 	addi	sp,sp,8
811069cc:	f800283a 	ret

811069d0 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
811069d0:	defffb04 	addi	sp,sp,-20
811069d4:	de00012e 	bgeu	sp,et,811069dc <bFeebStopCh+0xc>
811069d8:	003b68fa 	trap	3
811069dc:	dfc00415 	stw	ra,16(sp)
811069e0:	df000315 	stw	fp,12(sp)
811069e4:	df000304 	addi	fp,sp,12
811069e8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811069ec:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811069f0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811069f4:	e0bfff17 	ldw	r2,-4(fp)
811069f8:	10001126 	beq	r2,zero,81106a40 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811069fc:	e0bfff17 	ldw	r2,-4(fp)
81106a00:	10800017 	ldw	r2,0(r2)
81106a04:	01400084 	movi	r5,2
81106a08:	1009883a 	mov	r4,r2
81106a0c:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106a10:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81106a14:	e0bffe17 	ldw	r2,-8(fp)
81106a18:	10800094 	ori	r2,r2,2
81106a1c:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106a20:	e0bfff17 	ldw	r2,-4(fp)
81106a24:	10800017 	ldw	r2,0(r2)
81106a28:	e1bffe17 	ldw	r6,-8(fp)
81106a2c:	01400084 	movi	r5,2
81106a30:	1009883a 	mov	r4,r2
81106a34:	1106c640 	call	81106c64 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106a38:	00800044 	movi	r2,1
81106a3c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106a40:	e0bffd17 	ldw	r2,-12(fp)
}
81106a44:	e037883a 	mov	sp,fp
81106a48:	dfc00117 	ldw	ra,4(sp)
81106a4c:	df000017 	ldw	fp,0(sp)
81106a50:	dec00204 	addi	sp,sp,8
81106a54:	f800283a 	ret

81106a58 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81106a58:	defffb04 	addi	sp,sp,-20
81106a5c:	de00012e 	bgeu	sp,et,81106a64 <bFeebClrCh+0xc>
81106a60:	003b68fa 	trap	3
81106a64:	dfc00415 	stw	ra,16(sp)
81106a68:	df000315 	stw	fp,12(sp)
81106a6c:	df000304 	addi	fp,sp,12
81106a70:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106a74:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106a78:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106a7c:	e0bfff17 	ldw	r2,-4(fp)
81106a80:	10001126 	beq	r2,zero,81106ac8 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106a84:	e0bfff17 	ldw	r2,-4(fp)
81106a88:	10800017 	ldw	r2,0(r2)
81106a8c:	01400084 	movi	r5,2
81106a90:	1009883a 	mov	r4,r2
81106a94:	1106cb80 	call	81106cb8 <uliFeebReadReg>
81106a98:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81106a9c:	e0bffe17 	ldw	r2,-8(fp)
81106aa0:	10800054 	ori	r2,r2,1
81106aa4:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106aa8:	e0bfff17 	ldw	r2,-4(fp)
81106aac:	10800017 	ldw	r2,0(r2)
81106ab0:	e1bffe17 	ldw	r6,-8(fp)
81106ab4:	01400084 	movi	r5,2
81106ab8:	1009883a 	mov	r4,r2
81106abc:	1106c640 	call	81106c64 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106ac0:	00800044 	movi	r2,1
81106ac4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106ac8:	e0bffd17 	ldw	r2,-12(fp)
}
81106acc:	e037883a 	mov	sp,fp
81106ad0:	dfc00117 	ldw	ra,4(sp)
81106ad4:	df000017 	ldw	fp,0(sp)
81106ad8:	dec00204 	addi	sp,sp,8
81106adc:	f800283a 	ret

81106ae0 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81106ae0:	defffb04 	addi	sp,sp,-20
81106ae4:	de00012e 	bgeu	sp,et,81106aec <bFeebInitCh+0xc>
81106ae8:	003b68fa 	trap	3
81106aec:	dfc00415 	stw	ra,16(sp)
81106af0:	df000315 	stw	fp,12(sp)
81106af4:	df000304 	addi	fp,sp,12
81106af8:	e13ffe15 	stw	r4,-8(fp)
81106afc:	2805883a 	mov	r2,r5
81106b00:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106b04:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81106b08:	e0bffe17 	ldw	r2,-8(fp)
81106b0c:	10004f26 	beq	r2,zero,81106c4c <bFeebInitCh+0x16c>
		bStatus = TRUE;
81106b10:	00800044 	movi	r2,1
81106b14:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81106b18:	e0bfff03 	ldbu	r2,-4(fp)
81106b1c:	10c00228 	cmpgeui	r3,r2,8
81106b20:	1800361e 	bne	r3,zero,81106bfc <bFeebInitCh+0x11c>
81106b24:	100690ba 	slli	r3,r2,2
81106b28:	00a04434 	movhi	r2,33040
81106b2c:	109acf04 	addi	r2,r2,27452
81106b30:	1885883a 	add	r2,r3,r2
81106b34:	10800017 	ldw	r2,0(r2)
81106b38:	1000683a 	jmp	r2
81106b3c:	81106b5c 	xori	r4,r16,16813
81106b40:	81106b70 	cmpltui	r4,r16,16813
81106b44:	81106b84 	addi	r4,r16,16814
81106b48:	81106b98 	cmpnei	r4,r16,16814
81106b4c:	81106bac 	andhi	r4,r16,16814
81106b50:	81106bc0 	call	881106bc <__reset+0x20f06bc>
81106b54:	81106bd4 	ori	r4,r16,16815
81106b58:	81106be8 	cmpgeui	r4,r16,16815
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106b5c:	e0fffe17 	ldw	r3,-8(fp)
81106b60:	00a04834 	movhi	r2,33056
81106b64:	108b0004 	addi	r2,r2,11264
81106b68:	18800015 	stw	r2,0(r3)
			break;
81106b6c:	00002506 	br	81106c04 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106b70:	e0fffe17 	ldw	r3,-8(fp)
81106b74:	00a04834 	movhi	r2,33056
81106b78:	108a0004 	addi	r2,r2,10240
81106b7c:	18800015 	stw	r2,0(r3)
			break;
81106b80:	00002006 	br	81106c04 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81106b84:	e0fffe17 	ldw	r3,-8(fp)
81106b88:	00a04834 	movhi	r2,33056
81106b8c:	108b0004 	addi	r2,r2,11264
81106b90:	18800015 	stw	r2,0(r3)
			break;
81106b94:	00001b06 	br	81106c04 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106b98:	e0fffe17 	ldw	r3,-8(fp)
81106b9c:	00a04834 	movhi	r2,33056
81106ba0:	108a0004 	addi	r2,r2,10240
81106ba4:	18800015 	stw	r2,0(r3)
			break;
81106ba8:	00001606 	br	81106c04 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106bac:	e0fffe17 	ldw	r3,-8(fp)
81106bb0:	00a04834 	movhi	r2,33056
81106bb4:	108b0004 	addi	r2,r2,11264
81106bb8:	18800015 	stw	r2,0(r3)
			break;
81106bbc:	00001106 	br	81106c04 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106bc0:	e0fffe17 	ldw	r3,-8(fp)
81106bc4:	00a04834 	movhi	r2,33056
81106bc8:	108a0004 	addi	r2,r2,10240
81106bcc:	18800015 	stw	r2,0(r3)
			break;
81106bd0:	00000c06 	br	81106c04 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106bd4:	e0fffe17 	ldw	r3,-8(fp)
81106bd8:	00a04834 	movhi	r2,33056
81106bdc:	108b0004 	addi	r2,r2,11264
81106be0:	18800015 	stw	r2,0(r3)
			break;
81106be4:	00000706 	br	81106c04 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106be8:	e0fffe17 	ldw	r3,-8(fp)
81106bec:	00a04834 	movhi	r2,33056
81106bf0:	108a0004 	addi	r2,r2,10240
81106bf4:	18800015 	stw	r2,0(r3)
			break;
81106bf8:	00000206 	br	81106c04 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106bfc:	e03ffd15 	stw	zero,-12(fp)
			break;
81106c00:	0001883a 	nop
		}

		if (bStatus) {
81106c04:	e0bffd17 	ldw	r2,-12(fp)
81106c08:	10001026 	beq	r2,zero,81106c4c <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106c0c:	e13ffe17 	ldw	r4,-8(fp)
81106c10:	11062680 	call	81106268 <bFeebGetIrqControl>
81106c14:	1000011e 	bne	r2,zero,81106c1c <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106c18:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106c1c:	e13ffe17 	ldw	r4,-8(fp)
81106c20:	11063140 	call	81106314 <bFeebGetIrqFlags>
81106c24:	1000011e 	bne	r2,zero,81106c2c <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106c28:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106c2c:	e13ffe17 	ldw	r4,-8(fp)
81106c30:	110639c0 	call	8110639c <bFeebGetBuffersStatus>
81106c34:	1000011e 	bne	r2,zero,81106c3c <bFeebInitCh+0x15c>
				bStatus = FALSE;
81106c38:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106c3c:	e13ffe17 	ldw	r4,-8(fp)
81106c40:	11068c00 	call	811068c0 <bFeebGetWindowing>
81106c44:	1000011e 	bne	r2,zero,81106c4c <bFeebInitCh+0x16c>
				bStatus = FALSE;
81106c48:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106c4c:	e0bffd17 	ldw	r2,-12(fp)
}
81106c50:	e037883a 	mov	sp,fp
81106c54:	dfc00117 	ldw	ra,4(sp)
81106c58:	df000017 	ldw	fp,0(sp)
81106c5c:	dec00204 	addi	sp,sp,8
81106c60:	f800283a 	ret

81106c64 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81106c64:	defffc04 	addi	sp,sp,-16
81106c68:	de00012e 	bgeu	sp,et,81106c70 <vFeebWriteReg+0xc>
81106c6c:	003b68fa 	trap	3
81106c70:	df000315 	stw	fp,12(sp)
81106c74:	df000304 	addi	fp,sp,12
81106c78:	e13ffd15 	stw	r4,-12(fp)
81106c7c:	e17ffe15 	stw	r5,-8(fp)
81106c80:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81106c84:	e0bffe17 	ldw	r2,-8(fp)
81106c88:	1085883a 	add	r2,r2,r2
81106c8c:	1085883a 	add	r2,r2,r2
81106c90:	1007883a 	mov	r3,r2
81106c94:	e0bffd17 	ldw	r2,-12(fp)
81106c98:	10c5883a 	add	r2,r2,r3
81106c9c:	e0ffff17 	ldw	r3,-4(fp)
81106ca0:	10c00015 	stw	r3,0(r2)
}
81106ca4:	0001883a 	nop
81106ca8:	e037883a 	mov	sp,fp
81106cac:	df000017 	ldw	fp,0(sp)
81106cb0:	dec00104 	addi	sp,sp,4
81106cb4:	f800283a 	ret

81106cb8 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81106cb8:	defffc04 	addi	sp,sp,-16
81106cbc:	de00012e 	bgeu	sp,et,81106cc4 <uliFeebReadReg+0xc>
81106cc0:	003b68fa 	trap	3
81106cc4:	df000315 	stw	fp,12(sp)
81106cc8:	df000304 	addi	fp,sp,12
81106ccc:	e13ffe15 	stw	r4,-8(fp)
81106cd0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81106cd4:	e0bfff17 	ldw	r2,-4(fp)
81106cd8:	1085883a 	add	r2,r2,r2
81106cdc:	1085883a 	add	r2,r2,r2
81106ce0:	1007883a 	mov	r3,r2
81106ce4:	e0bffe17 	ldw	r2,-8(fp)
81106ce8:	10c5883a 	add	r2,r2,r3
81106cec:	10800017 	ldw	r2,0(r2)
81106cf0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81106cf4:	e0bffd17 	ldw	r2,-12(fp)
}
81106cf8:	e037883a 	mov	sp,fp
81106cfc:	df000017 	ldw	fp,0(sp)
81106d00:	dec00104 	addi	sp,sp,4
81106d04:	f800283a 	ret

81106d08 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81106d08:	defffa04 	addi	sp,sp,-24
81106d0c:	de00012e 	bgeu	sp,et,81106d14 <vRmapCh1HandleIrq+0xc>
81106d10:	003b68fa 	trap	3
81106d14:	dfc00515 	stw	ra,20(sp)
81106d18:	df000415 	stw	fp,16(sp)
81106d1c:	df000404 	addi	fp,sp,16
81106d20:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106d24:	e0bfff17 	ldw	r2,-4(fp)
81106d28:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#ifdef DEBUG_ON
	fprintf(fp,"IRQ RMAP.\n");
81106d2c:	d0a06217 	ldw	r2,-32376(gp)
81106d30:	100f883a 	mov	r7,r2
81106d34:	01800284 	movi	r6,10
81106d38:	01400044 	movi	r5,1
81106d3c:	01204574 	movhi	r4,33045
81106d40:	21306e04 	addi	r4,r4,-15944
81106d44:	11219e00 	call	811219e0 <fwrite>
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106d48:	11074d40 	call	811074d4 <uliRmapCh1WriteCmdAddress>
81106d4c:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106d50:	00800444 	movi	r2,17
81106d54:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106d58:	00bffc04 	movi	r2,-16
81106d5c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106d60:	e0bffd03 	ldbu	r2,-12(fp)
81106d64:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106d68:	e03ffe05 	stb	zero,-8(fp)

#ifdef DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106d6c:	d0a06217 	ldw	r2,-32376(gp)
81106d70:	e0fffd03 	ldbu	r3,-12(fp)
81106d74:	180d883a 	mov	r6,r3
81106d78:	01604574 	movhi	r5,33045
81106d7c:	29707104 	addi	r5,r5,-15932
81106d80:	1009883a 	mov	r4,r2
81106d84:	11213440 	call	81121344 <fprintf>
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81106d88:	d0a06a17 	ldw	r2,-32344(gp)
81106d8c:	e0fffe17 	ldw	r3,-8(fp)
81106d90:	180b883a 	mov	r5,r3
81106d94:	1009883a 	mov	r4,r2
81106d98:	113defc0 	call	8113defc <OSQPostFront>
81106d9c:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106da0:	e0bffd43 	ldbu	r2,-11(fp)
81106da4:	10000226 	beq	r2,zero,81106db0 <vRmapCh1HandleIrq+0xa8>
		vFailSendRMAPFromIRQ( 0 );
81106da8:	0009883a 	mov	r4,zero
81106dac:	111d2100 	call	8111d210 <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81106db0:	1106ff40 	call	81106ff4 <vRmapCh1IrqFlagClrWriteCmd>
}
81106db4:	0001883a 	nop
81106db8:	e037883a 	mov	sp,fp
81106dbc:	dfc00117 	ldw	ra,4(sp)
81106dc0:	df000017 	ldw	fp,0(sp)
81106dc4:	dec00204 	addi	sp,sp,8
81106dc8:	f800283a 	ret

81106dcc <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81106dcc:	defffa04 	addi	sp,sp,-24
81106dd0:	de00012e 	bgeu	sp,et,81106dd8 <vRmapCh2HandleIrq+0xc>
81106dd4:	003b68fa 	trap	3
81106dd8:	dfc00515 	stw	ra,20(sp)
81106ddc:	df000415 	stw	fp,16(sp)
81106de0:	df000404 	addi	fp,sp,16
81106de4:	e13fff15 	stw	r4,-4(fp)
	INT8U ucADDRReg;
	INT32U ucValueReg;
	INT32U ucValueMasked;
	INT8U error_codel;

	volatile int* pviHoldContext = (volatile int*) pvContext;
81106de8:	e0bfff17 	ldw	r2,-4(fp)
81106dec:	e0bffc15 	stw	r2,-16(fp)

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
81106df0:	11075240 	call	81107524 <uliRmapCh2WriteCmdAddress>
81106df4:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106df8:	00800444 	movi	r2,17
81106dfc:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106e00:	00bffc04 	movi	r2,-16
81106e04:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106e08:	e0bffd03 	ldbu	r2,-12(fp)
81106e0c:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106e10:	e03ffe05 	stb	zero,-8(fp)

#ifdef DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106e14:	d0a06217 	ldw	r2,-32376(gp)
81106e18:	e0fffd03 	ldbu	r3,-12(fp)
81106e1c:	180d883a 	mov	r6,r3
81106e20:	01604574 	movhi	r5,33045
81106e24:	29707104 	addi	r5,r5,-15932
81106e28:	1009883a 	mov	r4,r2
81106e2c:	11213440 	call	81121344 <fprintf>
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81106e30:	d0a06a17 	ldw	r2,-32344(gp)
81106e34:	e0fffe17 	ldw	r3,-8(fp)
81106e38:	180b883a 	mov	r5,r3
81106e3c:	1009883a 	mov	r4,r2
81106e40:	113defc0 	call	8113defc <OSQPostFront>
81106e44:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106e48:	e0bffd43 	ldbu	r2,-11(fp)
81106e4c:	10000226 	beq	r2,zero,81106e58 <vRmapCh2HandleIrq+0x8c>
		vFailSendRMAPFromIRQ( 0 );
81106e50:	0009883a 	mov	r4,zero
81106e54:	111d2100 	call	8111d210 <vFailSendRMAPFromIRQ>
	}


	vRmapCh2IrqFlagClrWriteCmd();
81106e58:	11070380 	call	81107038 <vRmapCh2IrqFlagClrWriteCmd>
}
81106e5c:	0001883a 	nop
81106e60:	e037883a 	mov	sp,fp
81106e64:	dfc00117 	ldw	ra,4(sp)
81106e68:	df000017 	ldw	fp,0(sp)
81106e6c:	dec00204 	addi	sp,sp,8
81106e70:	f800283a 	ret

81106e74 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81106e74:	defffc04 	addi	sp,sp,-16
81106e78:	de00012e 	bgeu	sp,et,81106e80 <vRmapCh3HandleIrq+0xc>
81106e7c:	003b68fa 	trap	3
81106e80:	dfc00315 	stw	ra,12(sp)
81106e84:	df000215 	stw	fp,8(sp)
81106e88:	df000204 	addi	fp,sp,8
81106e8c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106e90:	e0bfff17 	ldw	r2,-4(fp)
81106e94:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81106e98:	110707c0 	call	8110707c <vRmapCh3IrqFlagClrWriteCmd>
}
81106e9c:	0001883a 	nop
81106ea0:	e037883a 	mov	sp,fp
81106ea4:	dfc00117 	ldw	ra,4(sp)
81106ea8:	df000017 	ldw	fp,0(sp)
81106eac:	dec00204 	addi	sp,sp,8
81106eb0:	f800283a 	ret

81106eb4 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81106eb4:	defffc04 	addi	sp,sp,-16
81106eb8:	de00012e 	bgeu	sp,et,81106ec0 <vRmapCh4HandleIrq+0xc>
81106ebc:	003b68fa 	trap	3
81106ec0:	dfc00315 	stw	ra,12(sp)
81106ec4:	df000215 	stw	fp,8(sp)
81106ec8:	df000204 	addi	fp,sp,8
81106ecc:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106ed0:	e0bfff17 	ldw	r2,-4(fp)
81106ed4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81106ed8:	11070c00 	call	811070c0 <vRmapCh4IrqFlagClrWriteCmd>
}
81106edc:	0001883a 	nop
81106ee0:	e037883a 	mov	sp,fp
81106ee4:	dfc00117 	ldw	ra,4(sp)
81106ee8:	df000017 	ldw	fp,0(sp)
81106eec:	dec00204 	addi	sp,sp,8
81106ef0:	f800283a 	ret

81106ef4 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81106ef4:	defffc04 	addi	sp,sp,-16
81106ef8:	de00012e 	bgeu	sp,et,81106f00 <vRmapCh5HandleIrq+0xc>
81106efc:	003b68fa 	trap	3
81106f00:	dfc00315 	stw	ra,12(sp)
81106f04:	df000215 	stw	fp,8(sp)
81106f08:	df000204 	addi	fp,sp,8
81106f0c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f10:	e0bfff17 	ldw	r2,-4(fp)
81106f14:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106f18:	11071040 	call	81107104 <vRmapCh5IrqFlagClrWriteCmd>
}
81106f1c:	0001883a 	nop
81106f20:	e037883a 	mov	sp,fp
81106f24:	dfc00117 	ldw	ra,4(sp)
81106f28:	df000017 	ldw	fp,0(sp)
81106f2c:	dec00204 	addi	sp,sp,8
81106f30:	f800283a 	ret

81106f34 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81106f34:	defffc04 	addi	sp,sp,-16
81106f38:	de00012e 	bgeu	sp,et,81106f40 <vRmapCh6HandleIrq+0xc>
81106f3c:	003b68fa 	trap	3
81106f40:	dfc00315 	stw	ra,12(sp)
81106f44:	df000215 	stw	fp,8(sp)
81106f48:	df000204 	addi	fp,sp,8
81106f4c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f50:	e0bfff17 	ldw	r2,-4(fp)
81106f54:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81106f58:	11071480 	call	81107148 <vRmapCh6IrqFlagClrWriteCmd>
}
81106f5c:	0001883a 	nop
81106f60:	e037883a 	mov	sp,fp
81106f64:	dfc00117 	ldw	ra,4(sp)
81106f68:	df000017 	ldw	fp,0(sp)
81106f6c:	dec00204 	addi	sp,sp,8
81106f70:	f800283a 	ret

81106f74 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81106f74:	defffc04 	addi	sp,sp,-16
81106f78:	de00012e 	bgeu	sp,et,81106f80 <vRmapCh7HandleIrq+0xc>
81106f7c:	003b68fa 	trap	3
81106f80:	dfc00315 	stw	ra,12(sp)
81106f84:	df000215 	stw	fp,8(sp)
81106f88:	df000204 	addi	fp,sp,8
81106f8c:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f90:	e0bfff17 	ldw	r2,-4(fp)
81106f94:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106f98:	110718c0 	call	8110718c <vRmapCh7IrqFlagClrWriteCmd>
}
81106f9c:	0001883a 	nop
81106fa0:	e037883a 	mov	sp,fp
81106fa4:	dfc00117 	ldw	ra,4(sp)
81106fa8:	df000017 	ldw	fp,0(sp)
81106fac:	dec00204 	addi	sp,sp,8
81106fb0:	f800283a 	ret

81106fb4 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81106fb4:	defffc04 	addi	sp,sp,-16
81106fb8:	de00012e 	bgeu	sp,et,81106fc0 <vRmapCh8HandleIrq+0xc>
81106fbc:	003b68fa 	trap	3
81106fc0:	dfc00315 	stw	ra,12(sp)
81106fc4:	df000215 	stw	fp,8(sp)
81106fc8:	df000204 	addi	fp,sp,8
81106fcc:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106fd0:	e0bfff17 	ldw	r2,-4(fp)
81106fd4:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106fd8:	11071d00 	call	811071d0 <vRmapCh8IrqFlagClrWriteCmd>
}
81106fdc:	0001883a 	nop
81106fe0:	e037883a 	mov	sp,fp
81106fe4:	dfc00117 	ldw	ra,4(sp)
81106fe8:	df000017 	ldw	fp,0(sp)
81106fec:	dec00204 	addi	sp,sp,8
81106ff0:	f800283a 	ret

81106ff4 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81106ff4:	defffe04 	addi	sp,sp,-8
81106ff8:	de00012e 	bgeu	sp,et,81107000 <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106ffc:	003b68fa 	trap	3
81107000:	dfc00115 	stw	ra,4(sp)
81107004:	df000015 	stw	fp,0(sp)
81107008:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110700c:	01800044 	movi	r6,1
81107010:	014004c4 	movi	r5,19
81107014:	01204834 	movhi	r4,33056
81107018:	210b0004 	addi	r4,r4,11264
8110701c:	1109ebc0 	call	81109ebc <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107020:	0001883a 	nop
81107024:	e037883a 	mov	sp,fp
81107028:	dfc00117 	ldw	ra,4(sp)
8110702c:	df000017 	ldw	fp,0(sp)
81107030:	dec00204 	addi	sp,sp,8
81107034:	f800283a 	ret

81107038 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81107038:	defffe04 	addi	sp,sp,-8
8110703c:	de00012e 	bgeu	sp,et,81107044 <vRmapCh2IrqFlagClrWriteCmd+0xc>
81107040:	003b68fa 	trap	3
81107044:	dfc00115 	stw	ra,4(sp)
81107048:	df000015 	stw	fp,0(sp)
8110704c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107050:	01800044 	movi	r6,1
81107054:	014004c4 	movi	r5,19
81107058:	01204834 	movhi	r4,33056
8110705c:	210a0004 	addi	r4,r4,10240
81107060:	1109ebc0 	call	81109ebc <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107064:	0001883a 	nop
81107068:	e037883a 	mov	sp,fp
8110706c:	dfc00117 	ldw	ra,4(sp)
81107070:	df000017 	ldw	fp,0(sp)
81107074:	dec00204 	addi	sp,sp,8
81107078:	f800283a 	ret

8110707c <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
8110707c:	defffe04 	addi	sp,sp,-8
81107080:	de00012e 	bgeu	sp,et,81107088 <vRmapCh3IrqFlagClrWriteCmd+0xc>
81107084:	003b68fa 	trap	3
81107088:	dfc00115 	stw	ra,4(sp)
8110708c:	df000015 	stw	fp,0(sp)
81107090:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81107094:	01800044 	movi	r6,1
81107098:	014004c4 	movi	r5,19
8110709c:	01204834 	movhi	r4,33056
811070a0:	210b0004 	addi	r4,r4,11264
811070a4:	1109ebc0 	call	81109ebc <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070a8:	0001883a 	nop
811070ac:	e037883a 	mov	sp,fp
811070b0:	dfc00117 	ldw	ra,4(sp)
811070b4:	df000017 	ldw	fp,0(sp)
811070b8:	dec00204 	addi	sp,sp,8
811070bc:	f800283a 	ret

811070c0 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
811070c0:	defffe04 	addi	sp,sp,-8
811070c4:	de00012e 	bgeu	sp,et,811070cc <vRmapCh4IrqFlagClrWriteCmd+0xc>
811070c8:	003b68fa 	trap	3
811070cc:	dfc00115 	stw	ra,4(sp)
811070d0:	df000015 	stw	fp,0(sp)
811070d4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811070d8:	01800044 	movi	r6,1
811070dc:	014004c4 	movi	r5,19
811070e0:	01204834 	movhi	r4,33056
811070e4:	210a0004 	addi	r4,r4,10240
811070e8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070ec:	0001883a 	nop
811070f0:	e037883a 	mov	sp,fp
811070f4:	dfc00117 	ldw	ra,4(sp)
811070f8:	df000017 	ldw	fp,0(sp)
811070fc:	dec00204 	addi	sp,sp,8
81107100:	f800283a 	ret

81107104 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
81107104:	defffe04 	addi	sp,sp,-8
81107108:	de00012e 	bgeu	sp,et,81107110 <vRmapCh5IrqFlagClrWriteCmd+0xc>
8110710c:	003b68fa 	trap	3
81107110:	dfc00115 	stw	ra,4(sp)
81107114:	df000015 	stw	fp,0(sp)
81107118:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110711c:	01800044 	movi	r6,1
81107120:	014004c4 	movi	r5,19
81107124:	01204834 	movhi	r4,33056
81107128:	210b0004 	addi	r4,r4,11264
8110712c:	1109ebc0 	call	81109ebc <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107130:	0001883a 	nop
81107134:	e037883a 	mov	sp,fp
81107138:	dfc00117 	ldw	ra,4(sp)
8110713c:	df000017 	ldw	fp,0(sp)
81107140:	dec00204 	addi	sp,sp,8
81107144:	f800283a 	ret

81107148 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81107148:	defffe04 	addi	sp,sp,-8
8110714c:	de00012e 	bgeu	sp,et,81107154 <vRmapCh6IrqFlagClrWriteCmd+0xc>
81107150:	003b68fa 	trap	3
81107154:	dfc00115 	stw	ra,4(sp)
81107158:	df000015 	stw	fp,0(sp)
8110715c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107160:	01800044 	movi	r6,1
81107164:	014004c4 	movi	r5,19
81107168:	01204834 	movhi	r4,33056
8110716c:	210a0004 	addi	r4,r4,10240
81107170:	1109ebc0 	call	81109ebc <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107174:	0001883a 	nop
81107178:	e037883a 	mov	sp,fp
8110717c:	dfc00117 	ldw	ra,4(sp)
81107180:	df000017 	ldw	fp,0(sp)
81107184:	dec00204 	addi	sp,sp,8
81107188:	f800283a 	ret

8110718c <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
8110718c:	defffe04 	addi	sp,sp,-8
81107190:	de00012e 	bgeu	sp,et,81107198 <vRmapCh7IrqFlagClrWriteCmd+0xc>
81107194:	003b68fa 	trap	3
81107198:	dfc00115 	stw	ra,4(sp)
8110719c:	df000015 	stw	fp,0(sp)
811071a0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811071a4:	01800044 	movi	r6,1
811071a8:	014004c4 	movi	r5,19
811071ac:	01204834 	movhi	r4,33056
811071b0:	210b0004 	addi	r4,r4,11264
811071b4:	1109ebc0 	call	81109ebc <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811071b8:	0001883a 	nop
811071bc:	e037883a 	mov	sp,fp
811071c0:	dfc00117 	ldw	ra,4(sp)
811071c4:	df000017 	ldw	fp,0(sp)
811071c8:	dec00204 	addi	sp,sp,8
811071cc:	f800283a 	ret

811071d0 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
811071d0:	defffe04 	addi	sp,sp,-8
811071d4:	de00012e 	bgeu	sp,et,811071dc <vRmapCh8IrqFlagClrWriteCmd+0xc>
811071d8:	003b68fa 	trap	3
811071dc:	dfc00115 	stw	ra,4(sp)
811071e0:	df000015 	stw	fp,0(sp)
811071e4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811071e8:	01800044 	movi	r6,1
811071ec:	014004c4 	movi	r5,19
811071f0:	01204834 	movhi	r4,33056
811071f4:	210a0004 	addi	r4,r4,10240
811071f8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811071fc:	0001883a 	nop
81107200:	e037883a 	mov	sp,fp
81107204:	dfc00117 	ldw	ra,4(sp)
81107208:	df000017 	ldw	fp,0(sp)
8110720c:	dec00204 	addi	sp,sp,8
81107210:	f800283a 	ret

81107214 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
81107214:	defffd04 	addi	sp,sp,-12
81107218:	de00012e 	bgeu	sp,et,81107220 <bRmapCh1IrqFlagWriteCmd+0xc>
8110721c:	003b68fa 	trap	3
81107220:	dfc00215 	stw	ra,8(sp)
81107224:	df000115 	stw	fp,4(sp)
81107228:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
8110722c:	01400484 	movi	r5,18
81107230:	01204834 	movhi	r4,33056
81107234:	210b0004 	addi	r4,r4,11264
81107238:	1109f100 	call	81109f10 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110723c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81107240:	10000326 	beq	r2,zero,81107250 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107244:	00800044 	movi	r2,1
81107248:	e0bfff15 	stw	r2,-4(fp)
8110724c:	00000106 	br	81107254 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107250:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107254:	e0bfff17 	ldw	r2,-4(fp)
}
81107258:	e037883a 	mov	sp,fp
8110725c:	dfc00117 	ldw	ra,4(sp)
81107260:	df000017 	ldw	fp,0(sp)
81107264:	dec00204 	addi	sp,sp,8
81107268:	f800283a 	ret

8110726c <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
8110726c:	defffd04 	addi	sp,sp,-12
81107270:	de00012e 	bgeu	sp,et,81107278 <bRmapCh2IrqFlagWriteCmd+0xc>
81107274:	003b68fa 	trap	3
81107278:	dfc00215 	stw	ra,8(sp)
8110727c:	df000115 	stw	fp,4(sp)
81107280:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107284:	01400484 	movi	r5,18
81107288:	01204834 	movhi	r4,33056
8110728c:	210a0004 	addi	r4,r4,10240
81107290:	1109f100 	call	81109f10 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107294:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107298:	10000326 	beq	r2,zero,811072a8 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110729c:	00800044 	movi	r2,1
811072a0:	e0bfff15 	stw	r2,-4(fp)
811072a4:	00000106 	br	811072ac <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811072a8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811072ac:	e0bfff17 	ldw	r2,-4(fp)
}
811072b0:	e037883a 	mov	sp,fp
811072b4:	dfc00117 	ldw	ra,4(sp)
811072b8:	df000017 	ldw	fp,0(sp)
811072bc:	dec00204 	addi	sp,sp,8
811072c0:	f800283a 	ret

811072c4 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
811072c4:	defffd04 	addi	sp,sp,-12
811072c8:	de00012e 	bgeu	sp,et,811072d0 <bRmapCh3IrqFlagWriteCmd+0xc>
811072cc:	003b68fa 	trap	3
811072d0:	dfc00215 	stw	ra,8(sp)
811072d4:	df000115 	stw	fp,4(sp)
811072d8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811072dc:	01400484 	movi	r5,18
811072e0:	01204834 	movhi	r4,33056
811072e4:	210b0004 	addi	r4,r4,11264
811072e8:	1109f100 	call	81109f10 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811072ec:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811072f0:	10000326 	beq	r2,zero,81107300 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811072f4:	00800044 	movi	r2,1
811072f8:	e0bfff15 	stw	r2,-4(fp)
811072fc:	00000106 	br	81107304 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107300:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107304:	e0bfff17 	ldw	r2,-4(fp)
}
81107308:	e037883a 	mov	sp,fp
8110730c:	dfc00117 	ldw	ra,4(sp)
81107310:	df000017 	ldw	fp,0(sp)
81107314:	dec00204 	addi	sp,sp,8
81107318:	f800283a 	ret

8110731c <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
8110731c:	defffd04 	addi	sp,sp,-12
81107320:	de00012e 	bgeu	sp,et,81107328 <bRmapCh4IrqFlagWriteCmd+0xc>
81107324:	003b68fa 	trap	3
81107328:	dfc00215 	stw	ra,8(sp)
8110732c:	df000115 	stw	fp,4(sp)
81107330:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107334:	01400484 	movi	r5,18
81107338:	01204834 	movhi	r4,33056
8110733c:	210a0004 	addi	r4,r4,10240
81107340:	1109f100 	call	81109f10 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107344:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81107348:	10000326 	beq	r2,zero,81107358 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110734c:	00800044 	movi	r2,1
81107350:	e0bfff15 	stw	r2,-4(fp)
81107354:	00000106 	br	8110735c <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107358:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110735c:	e0bfff17 	ldw	r2,-4(fp)
}
81107360:	e037883a 	mov	sp,fp
81107364:	dfc00117 	ldw	ra,4(sp)
81107368:	df000017 	ldw	fp,0(sp)
8110736c:	dec00204 	addi	sp,sp,8
81107370:	f800283a 	ret

81107374 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81107374:	defffd04 	addi	sp,sp,-12
81107378:	de00012e 	bgeu	sp,et,81107380 <bRmapCh5IrqFlagWriteCmd+0xc>
8110737c:	003b68fa 	trap	3
81107380:	dfc00215 	stw	ra,8(sp)
81107384:	df000115 	stw	fp,4(sp)
81107388:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110738c:	01400484 	movi	r5,18
81107390:	01204834 	movhi	r4,33056
81107394:	210b0004 	addi	r4,r4,11264
81107398:	1109f100 	call	81109f10 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110739c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811073a0:	10000326 	beq	r2,zero,811073b0 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811073a4:	00800044 	movi	r2,1
811073a8:	e0bfff15 	stw	r2,-4(fp)
811073ac:	00000106 	br	811073b4 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811073b0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811073b4:	e0bfff17 	ldw	r2,-4(fp)
}
811073b8:	e037883a 	mov	sp,fp
811073bc:	dfc00117 	ldw	ra,4(sp)
811073c0:	df000017 	ldw	fp,0(sp)
811073c4:	dec00204 	addi	sp,sp,8
811073c8:	f800283a 	ret

811073cc <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
811073cc:	defffd04 	addi	sp,sp,-12
811073d0:	de00012e 	bgeu	sp,et,811073d8 <bRmapCh6IrqFlagWriteCmd+0xc>
811073d4:	003b68fa 	trap	3
811073d8:	dfc00215 	stw	ra,8(sp)
811073dc:	df000115 	stw	fp,4(sp)
811073e0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811073e4:	01400484 	movi	r5,18
811073e8:	01204834 	movhi	r4,33056
811073ec:	210a0004 	addi	r4,r4,10240
811073f0:	1109f100 	call	81109f10 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811073f4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811073f8:	10000326 	beq	r2,zero,81107408 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811073fc:	00800044 	movi	r2,1
81107400:	e0bfff15 	stw	r2,-4(fp)
81107404:	00000106 	br	8110740c <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107408:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110740c:	e0bfff17 	ldw	r2,-4(fp)
}
81107410:	e037883a 	mov	sp,fp
81107414:	dfc00117 	ldw	ra,4(sp)
81107418:	df000017 	ldw	fp,0(sp)
8110741c:	dec00204 	addi	sp,sp,8
81107420:	f800283a 	ret

81107424 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
81107424:	defffd04 	addi	sp,sp,-12
81107428:	de00012e 	bgeu	sp,et,81107430 <bRmapCh7IrqFlagWriteCmd+0xc>
8110742c:	003b68fa 	trap	3
81107430:	dfc00215 	stw	ra,8(sp)
81107434:	df000115 	stw	fp,4(sp)
81107438:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110743c:	01400484 	movi	r5,18
81107440:	01204834 	movhi	r4,33056
81107444:	210b0004 	addi	r4,r4,11264
81107448:	1109f100 	call	81109f10 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110744c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107450:	10000326 	beq	r2,zero,81107460 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107454:	00800044 	movi	r2,1
81107458:	e0bfff15 	stw	r2,-4(fp)
8110745c:	00000106 	br	81107464 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107460:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107464:	e0bfff17 	ldw	r2,-4(fp)
}
81107468:	e037883a 	mov	sp,fp
8110746c:	dfc00117 	ldw	ra,4(sp)
81107470:	df000017 	ldw	fp,0(sp)
81107474:	dec00204 	addi	sp,sp,8
81107478:	f800283a 	ret

8110747c <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
8110747c:	defffd04 	addi	sp,sp,-12
81107480:	de00012e 	bgeu	sp,et,81107488 <bRmapCh8IrqFlagWriteCmd+0xc>
81107484:	003b68fa 	trap	3
81107488:	dfc00215 	stw	ra,8(sp)
8110748c:	df000115 	stw	fp,4(sp)
81107490:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107494:	01400484 	movi	r5,18
81107498:	01204834 	movhi	r4,33056
8110749c:	210a0004 	addi	r4,r4,10240
811074a0:	1109f100 	call	81109f10 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811074a4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811074a8:	10000326 	beq	r2,zero,811074b8 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811074ac:	00800044 	movi	r2,1
811074b0:	e0bfff15 	stw	r2,-4(fp)
811074b4:	00000106 	br	811074bc <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811074b8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811074bc:	e0bfff17 	ldw	r2,-4(fp)
}
811074c0:	e037883a 	mov	sp,fp
811074c4:	dfc00117 	ldw	ra,4(sp)
811074c8:	df000017 	ldw	fp,0(sp)
811074cc:	dec00204 	addi	sp,sp,8
811074d0:	f800283a 	ret

811074d4 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
811074d4:	defffd04 	addi	sp,sp,-12
811074d8:	de00012e 	bgeu	sp,et,811074e0 <uliRmapCh1WriteCmdAddress+0xc>
811074dc:	003b68fa 	trap	3
811074e0:	dfc00215 	stw	ra,8(sp)
811074e4:	df000115 	stw	fp,4(sp)
811074e8:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811074ec:	01400184 	movi	r5,6
811074f0:	01204834 	movhi	r4,33056
811074f4:	210b0004 	addi	r4,r4,11264
811074f8:	1109f100 	call	81109f10 <uliRmapReadReg>
811074fc:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107500:	e13fff17 	ldw	r4,-4(fp)
81107504:	1109f600 	call	81109f60 <uliConvRmapCfgAddr>
81107508:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110750c:	e0bfff17 	ldw	r2,-4(fp)
}
81107510:	e037883a 	mov	sp,fp
81107514:	dfc00117 	ldw	ra,4(sp)
81107518:	df000017 	ldw	fp,0(sp)
8110751c:	dec00204 	addi	sp,sp,8
81107520:	f800283a 	ret

81107524 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
81107524:	defffd04 	addi	sp,sp,-12
81107528:	de00012e 	bgeu	sp,et,81107530 <uliRmapCh2WriteCmdAddress+0xc>
8110752c:	003b68fa 	trap	3
81107530:	dfc00215 	stw	ra,8(sp)
81107534:	df000115 	stw	fp,4(sp)
81107538:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110753c:	01400184 	movi	r5,6
81107540:	01204834 	movhi	r4,33056
81107544:	210a0004 	addi	r4,r4,10240
81107548:	1109f100 	call	81109f10 <uliRmapReadReg>
8110754c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107550:	e13fff17 	ldw	r4,-4(fp)
81107554:	1109f600 	call	81109f60 <uliConvRmapCfgAddr>
81107558:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110755c:	e0bfff17 	ldw	r2,-4(fp)
}
81107560:	e037883a 	mov	sp,fp
81107564:	dfc00117 	ldw	ra,4(sp)
81107568:	df000017 	ldw	fp,0(sp)
8110756c:	dec00204 	addi	sp,sp,8
81107570:	f800283a 	ret

81107574 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107574:	defffd04 	addi	sp,sp,-12
81107578:	de00012e 	bgeu	sp,et,81107580 <uliRmapCh3WriteCmdAddress+0xc>
8110757c:	003b68fa 	trap	3
81107580:	dfc00215 	stw	ra,8(sp)
81107584:	df000115 	stw	fp,4(sp)
81107588:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110758c:	01400184 	movi	r5,6
81107590:	01204834 	movhi	r4,33056
81107594:	210b0004 	addi	r4,r4,11264
81107598:	1109f100 	call	81109f10 <uliRmapReadReg>
8110759c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811075a0:	e13fff17 	ldw	r4,-4(fp)
811075a4:	1109f600 	call	81109f60 <uliConvRmapCfgAddr>
811075a8:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811075ac:	e0bfff17 	ldw	r2,-4(fp)
}
811075b0:	e037883a 	mov	sp,fp
811075b4:	dfc00117 	ldw	ra,4(sp)
811075b8:	df000017 	ldw	fp,0(sp)
811075bc:	dec00204 	addi	sp,sp,8
811075c0:	f800283a 	ret

811075c4 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
811075c4:	defffd04 	addi	sp,sp,-12
811075c8:	de00012e 	bgeu	sp,et,811075d0 <uliRmapCh4WriteCmdAddress+0xc>
811075cc:	003b68fa 	trap	3
811075d0:	dfc00215 	stw	ra,8(sp)
811075d4:	df000115 	stw	fp,4(sp)
811075d8:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811075dc:	01400184 	movi	r5,6
811075e0:	01204834 	movhi	r4,33056
811075e4:	210a0004 	addi	r4,r4,10240
811075e8:	1109f100 	call	81109f10 <uliRmapReadReg>
811075ec:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811075f0:	e13fff17 	ldw	r4,-4(fp)
811075f4:	1109f600 	call	81109f60 <uliConvRmapCfgAddr>
811075f8:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811075fc:	e0bfff17 	ldw	r2,-4(fp)
}
81107600:	e037883a 	mov	sp,fp
81107604:	dfc00117 	ldw	ra,4(sp)
81107608:	df000017 	ldw	fp,0(sp)
8110760c:	dec00204 	addi	sp,sp,8
81107610:	f800283a 	ret

81107614 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
81107614:	defffd04 	addi	sp,sp,-12
81107618:	de00012e 	bgeu	sp,et,81107620 <uliRmapCh5WriteCmdAddress+0xc>
8110761c:	003b68fa 	trap	3
81107620:	dfc00215 	stw	ra,8(sp)
81107624:	df000115 	stw	fp,4(sp)
81107628:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110762c:	01400184 	movi	r5,6
81107630:	01204834 	movhi	r4,33056
81107634:	210b0004 	addi	r4,r4,11264
81107638:	1109f100 	call	81109f10 <uliRmapReadReg>
8110763c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107640:	e13fff17 	ldw	r4,-4(fp)
81107644:	1109f600 	call	81109f60 <uliConvRmapCfgAddr>
81107648:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110764c:	e0bfff17 	ldw	r2,-4(fp)
}
81107650:	e037883a 	mov	sp,fp
81107654:	dfc00117 	ldw	ra,4(sp)
81107658:	df000017 	ldw	fp,0(sp)
8110765c:	dec00204 	addi	sp,sp,8
81107660:	f800283a 	ret

81107664 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107664:	defffd04 	addi	sp,sp,-12
81107668:	de00012e 	bgeu	sp,et,81107670 <uliRmapCh6WriteCmdAddress+0xc>
8110766c:	003b68fa 	trap	3
81107670:	dfc00215 	stw	ra,8(sp)
81107674:	df000115 	stw	fp,4(sp)
81107678:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110767c:	01400184 	movi	r5,6
81107680:	01204834 	movhi	r4,33056
81107684:	210a0004 	addi	r4,r4,10240
81107688:	1109f100 	call	81109f10 <uliRmapReadReg>
8110768c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107690:	e13fff17 	ldw	r4,-4(fp)
81107694:	1109f600 	call	81109f60 <uliConvRmapCfgAddr>
81107698:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110769c:	e0bfff17 	ldw	r2,-4(fp)
}
811076a0:	e037883a 	mov	sp,fp
811076a4:	dfc00117 	ldw	ra,4(sp)
811076a8:	df000017 	ldw	fp,0(sp)
811076ac:	dec00204 	addi	sp,sp,8
811076b0:	f800283a 	ret

811076b4 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
811076b4:	defffd04 	addi	sp,sp,-12
811076b8:	de00012e 	bgeu	sp,et,811076c0 <uliRmapCh7WriteCmdAddress+0xc>
811076bc:	003b68fa 	trap	3
811076c0:	dfc00215 	stw	ra,8(sp)
811076c4:	df000115 	stw	fp,4(sp)
811076c8:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811076cc:	01400184 	movi	r5,6
811076d0:	01204834 	movhi	r4,33056
811076d4:	210b0004 	addi	r4,r4,11264
811076d8:	1109f100 	call	81109f10 <uliRmapReadReg>
811076dc:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811076e0:	e13fff17 	ldw	r4,-4(fp)
811076e4:	1109f600 	call	81109f60 <uliConvRmapCfgAddr>
811076e8:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811076ec:	e0bfff17 	ldw	r2,-4(fp)
}
811076f0:	e037883a 	mov	sp,fp
811076f4:	dfc00117 	ldw	ra,4(sp)
811076f8:	df000017 	ldw	fp,0(sp)
811076fc:	dec00204 	addi	sp,sp,8
81107700:	f800283a 	ret

81107704 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81107704:	defffd04 	addi	sp,sp,-12
81107708:	de00012e 	bgeu	sp,et,81107710 <uliRmapCh8WriteCmdAddress+0xc>
8110770c:	003b68fa 	trap	3
81107710:	dfc00215 	stw	ra,8(sp)
81107714:	df000115 	stw	fp,4(sp)
81107718:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
8110771c:	01400184 	movi	r5,6
81107720:	01204834 	movhi	r4,33056
81107724:	210a0004 	addi	r4,r4,10240
81107728:	1109f100 	call	81109f10 <uliRmapReadReg>
8110772c:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107730:	e13fff17 	ldw	r4,-4(fp)
81107734:	1109f600 	call	81109f60 <uliConvRmapCfgAddr>
81107738:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
8110773c:	e0bfff17 	ldw	r2,-4(fp)
}
81107740:	e037883a 	mov	sp,fp
81107744:	dfc00117 	ldw	ra,4(sp)
81107748:	df000017 	ldw	fp,0(sp)
8110774c:	dec00204 	addi	sp,sp,8
81107750:	f800283a 	ret

81107754 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81107754:	defffc04 	addi	sp,sp,-16
81107758:	de00012e 	bgeu	sp,et,81107760 <vRmapInitIrq+0xc>
8110775c:	003b68fa 	trap	3
81107760:	dfc00315 	stw	ra,12(sp)
81107764:	df000215 	stw	fp,8(sp)
81107768:	df000204 	addi	fp,sp,8
8110776c:	2005883a 	mov	r2,r4
81107770:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107774:	e0bfff03 	ldbu	r2,-4(fp)
81107778:	10c00228 	cmpgeui	r3,r2,8
8110777c:	18004e1e 	bne	r3,zero,811078b8 <vRmapInitIrq+0x164>
81107780:	100690ba 	slli	r3,r2,2
81107784:	00a04434 	movhi	r2,33040
81107788:	109de604 	addi	r2,r2,30616
8110778c:	1885883a 	add	r2,r3,r2
81107790:	10800017 	ldw	r2,0(r2)
81107794:	1000683a 	jmp	r2
81107798:	811077b8 	rdprs	r4,r16,16862
8110779c:	811077d8 	cmpnei	r4,r16,16863
811077a0:	811077f8 	rdprs	r4,r16,16863
811077a4:	81107818 	cmpnei	r4,r16,16864
811077a8:	81107838 	rdprs	r4,r16,16864
811077ac:	81107858 	cmpnei	r4,r16,16865
811077b0:	81107878 	rdprs	r4,r16,16865
811077b4:	81107898 	cmpnei	r4,r16,16866
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811077b8:	d0a04804 	addi	r2,gp,-32480
811077bc:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
811077c0:	01a04434 	movhi	r6,33040
811077c4:	319b4204 	addi	r6,r6,27912
811077c8:	e17ffe17 	ldw	r5,-8(fp)
811077cc:	010005c4 	movi	r4,23
811077d0:	11363a80 	call	811363a8 <alt_irq_register>
		break;
811077d4:	00003806 	br	811078b8 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811077d8:	d0a04904 	addi	r2,gp,-32476
811077dc:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
811077e0:	01a04434 	movhi	r6,33040
811077e4:	319b7304 	addi	r6,r6,28108
811077e8:	e17ffe17 	ldw	r5,-8(fp)
811077ec:	01000544 	movi	r4,21
811077f0:	11363a80 	call	811363a8 <alt_irq_register>
		break;
811077f4:	00003006 	br	811078b8 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811077f8:	d0a04a04 	addi	r2,gp,-32472
811077fc:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
81107800:	01a04434 	movhi	r6,33040
81107804:	319b9d04 	addi	r6,r6,28276
81107808:	e17ffe17 	ldw	r5,-8(fp)
8110780c:	010004c4 	movi	r4,19
81107810:	11363a80 	call	811363a8 <alt_irq_register>
		break;
81107814:	00002806 	br	811078b8 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81107818:	d0a04b04 	addi	r2,gp,-32468
8110781c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81107820:	01a04434 	movhi	r6,33040
81107824:	319bad04 	addi	r6,r6,28340
81107828:	e17ffe17 	ldw	r5,-8(fp)
8110782c:	01000444 	movi	r4,17
81107830:	11363a80 	call	811363a8 <alt_irq_register>
		break;
81107834:	00002006 	br	811078b8 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81107838:	d0a04c04 	addi	r2,gp,-32464
8110783c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81107840:	01a04434 	movhi	r6,33040
81107844:	319bbd04 	addi	r6,r6,28404
81107848:	e17ffe17 	ldw	r5,-8(fp)
8110784c:	01000244 	movi	r4,9
81107850:	11363a80 	call	811363a8 <alt_irq_register>
		break;
81107854:	00001806 	br	811078b8 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81107858:	d0a04d04 	addi	r2,gp,-32460
8110785c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81107860:	01a04434 	movhi	r6,33040
81107864:	319bcd04 	addi	r6,r6,28468
81107868:	e17ffe17 	ldw	r5,-8(fp)
8110786c:	010001c4 	movi	r4,7
81107870:	11363a80 	call	811363a8 <alt_irq_register>
		break;
81107874:	00001006 	br	811078b8 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81107878:	d0a04e04 	addi	r2,gp,-32456
8110787c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81107880:	01a04434 	movhi	r6,33040
81107884:	319bdd04 	addi	r6,r6,28532
81107888:	e17ffe17 	ldw	r5,-8(fp)
8110788c:	01000104 	movi	r4,4
81107890:	11363a80 	call	811363a8 <alt_irq_register>
		break;
81107894:	00000806 	br	811078b8 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81107898:	d0a04f04 	addi	r2,gp,-32452
8110789c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
811078a0:	01a04434 	movhi	r6,33040
811078a4:	319bed04 	addi	r6,r6,28596
811078a8:	e17ffe17 	ldw	r5,-8(fp)
811078ac:	010000c4 	movi	r4,3
811078b0:	11363a80 	call	811363a8 <alt_irq_register>
		break;
811078b4:	0001883a 	nop
	}
}
811078b8:	0001883a 	nop
811078bc:	e037883a 	mov	sp,fp
811078c0:	dfc00117 	ldw	ra,4(sp)
811078c4:	df000017 	ldw	fp,0(sp)
811078c8:	dec00204 	addi	sp,sp,8
811078cc:	f800283a 	ret

811078d0 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
811078d0:	defffb04 	addi	sp,sp,-20
811078d4:	de00012e 	bgeu	sp,et,811078dc <bRmapSetIrqControl+0xc>
811078d8:	003b68fa 	trap	3
811078dc:	dfc00415 	stw	ra,16(sp)
811078e0:	df000315 	stw	fp,12(sp)
811078e4:	df000304 	addi	fp,sp,12
811078e8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811078ec:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811078f0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811078f4:	e0bfff17 	ldw	r2,-4(fp)
811078f8:	10001926 	beq	r2,zero,81107960 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078fc:	e0bfff17 	ldw	r2,-4(fp)
81107900:	10800017 	ldw	r2,0(r2)
81107904:	01400444 	movi	r5,17
81107908:	1009883a 	mov	r4,r2
8110790c:	1109f100 	call	81109f10 <uliRmapReadReg>
81107910:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81107914:	e0bfff17 	ldw	r2,-4(fp)
81107918:	10801017 	ldw	r2,64(r2)
8110791c:	10000426 	beq	r2,zero,81107930 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81107920:	e0bffe17 	ldw	r2,-8(fp)
81107924:	10800054 	ori	r2,r2,1
81107928:	e0bffe15 	stw	r2,-8(fp)
8110792c:	00000406 	br	81107940 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81107930:	e0fffe17 	ldw	r3,-8(fp)
81107934:	00bfff84 	movi	r2,-2
81107938:	1884703a 	and	r2,r3,r2
8110793c:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81107940:	e0bfff17 	ldw	r2,-4(fp)
81107944:	10800017 	ldw	r2,0(r2)
81107948:	e1bffe17 	ldw	r6,-8(fp)
8110794c:	01400444 	movi	r5,17
81107950:	1009883a 	mov	r4,r2
81107954:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81107958:	00800044 	movi	r2,1
8110795c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107960:	e0bffd17 	ldw	r2,-12(fp)
}
81107964:	e037883a 	mov	sp,fp
81107968:	dfc00117 	ldw	ra,4(sp)
8110796c:	df000017 	ldw	fp,0(sp)
81107970:	dec00204 	addi	sp,sp,8
81107974:	f800283a 	ret

81107978 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81107978:	defffb04 	addi	sp,sp,-20
8110797c:	de00012e 	bgeu	sp,et,81107984 <bRmapGetIrqControl+0xc>
81107980:	003b68fa 	trap	3
81107984:	dfc00415 	stw	ra,16(sp)
81107988:	df000315 	stw	fp,12(sp)
8110798c:	df000304 	addi	fp,sp,12
81107990:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107994:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107998:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110799c:	e0bfff17 	ldw	r2,-4(fp)
811079a0:	10001126 	beq	r2,zero,811079e8 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079a4:	e0bfff17 	ldw	r2,-4(fp)
811079a8:	10800017 	ldw	r2,0(r2)
811079ac:	01400444 	movi	r5,17
811079b0:	1009883a 	mov	r4,r2
811079b4:	1109f100 	call	81109f10 <uliRmapReadReg>
811079b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
811079bc:	e0bffe17 	ldw	r2,-8(fp)
811079c0:	1080004c 	andi	r2,r2,1
811079c4:	10000426 	beq	r2,zero,811079d8 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811079c8:	e0bfff17 	ldw	r2,-4(fp)
811079cc:	00c00044 	movi	r3,1
811079d0:	10c01015 	stw	r3,64(r2)
811079d4:	00000206 	br	811079e0 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811079d8:	e0bfff17 	ldw	r2,-4(fp)
811079dc:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
811079e0:	00800044 	movi	r2,1
811079e4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811079e8:	e0bffd17 	ldw	r2,-12(fp)
}
811079ec:	e037883a 	mov	sp,fp
811079f0:	dfc00117 	ldw	ra,4(sp)
811079f4:	df000017 	ldw	fp,0(sp)
811079f8:	dec00204 	addi	sp,sp,8
811079fc:	f800283a 	ret

81107a00 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81107a00:	defffb04 	addi	sp,sp,-20
81107a04:	de00012e 	bgeu	sp,et,81107a0c <bRmapGetIrqFlags+0xc>
81107a08:	003b68fa 	trap	3
81107a0c:	dfc00415 	stw	ra,16(sp)
81107a10:	df000315 	stw	fp,12(sp)
81107a14:	df000304 	addi	fp,sp,12
81107a18:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107a1c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107a20:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107a24:	e0bfff17 	ldw	r2,-4(fp)
81107a28:	10001126 	beq	r2,zero,81107a70 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a2c:	e0bfff17 	ldw	r2,-4(fp)
81107a30:	10800017 	ldw	r2,0(r2)
81107a34:	01400484 	movi	r5,18
81107a38:	1009883a 	mov	r4,r2
81107a3c:	1109f100 	call	81109f10 <uliRmapReadReg>
81107a40:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107a44:	e0bffe17 	ldw	r2,-8(fp)
81107a48:	1080004c 	andi	r2,r2,1
81107a4c:	10000426 	beq	r2,zero,81107a60 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81107a50:	e0bfff17 	ldw	r2,-4(fp)
81107a54:	00c00044 	movi	r3,1
81107a58:	10c01115 	stw	r3,68(r2)
81107a5c:	00000206 	br	81107a68 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81107a60:	e0bfff17 	ldw	r2,-4(fp)
81107a64:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81107a68:	00800044 	movi	r2,1
81107a6c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107a70:	e0bffd17 	ldw	r2,-12(fp)
}
81107a74:	e037883a 	mov	sp,fp
81107a78:	dfc00117 	ldw	ra,4(sp)
81107a7c:	df000017 	ldw	fp,0(sp)
81107a80:	dec00204 	addi	sp,sp,8
81107a84:	f800283a 	ret

81107a88 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81107a88:	defffb04 	addi	sp,sp,-20
81107a8c:	de00012e 	bgeu	sp,et,81107a94 <bRmapSetCodecConfig+0xc>
81107a90:	003b68fa 	trap	3
81107a94:	dfc00415 	stw	ra,16(sp)
81107a98:	df000315 	stw	fp,12(sp)
81107a9c:	df000304 	addi	fp,sp,12
81107aa0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107aa4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107aa8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107aac:	e0bfff17 	ldw	r2,-4(fp)
81107ab0:	10002526 	beq	r2,zero,81107b48 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ab4:	e0bfff17 	ldw	r2,-4(fp)
81107ab8:	10800017 	ldw	r2,0(r2)
81107abc:	01400104 	movi	r5,4
81107ac0:	1009883a 	mov	r4,r2
81107ac4:	1109f100 	call	81109f10 <uliRmapReadReg>
81107ac8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81107acc:	e0fffe17 	ldw	r3,-8(fp)
81107ad0:	00bfc004 	movi	r2,-256
81107ad4:	1884703a 	and	r2,r3,r2
81107ad8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81107adc:	e0bfff17 	ldw	r2,-4(fp)
81107ae0:	10800143 	ldbu	r2,5(r2)
81107ae4:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81107ae8:	e0fffe17 	ldw	r3,-8(fp)
81107aec:	1884b03a 	or	r2,r3,r2
81107af0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81107af4:	e0fffe17 	ldw	r3,-8(fp)
81107af8:	00bffff4 	movhi	r2,65535
81107afc:	10803fc4 	addi	r2,r2,255
81107b00:	1884703a 	and	r2,r3,r2
81107b04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81107b08:	e0bfff17 	ldw	r2,-4(fp)
81107b0c:	10800103 	ldbu	r2,4(r2)
81107b10:	10803fcc 	andi	r2,r2,255
81107b14:	1004923a 	slli	r2,r2,8
81107b18:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81107b1c:	e0fffe17 	ldw	r3,-8(fp)
81107b20:	1884b03a 	or	r2,r3,r2
81107b24:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81107b28:	e0bfff17 	ldw	r2,-4(fp)
81107b2c:	10800017 	ldw	r2,0(r2)
81107b30:	e1bffe17 	ldw	r6,-8(fp)
81107b34:	01400104 	movi	r5,4
81107b38:	1009883a 	mov	r4,r2
81107b3c:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107b40:	00800044 	movi	r2,1
81107b44:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107b48:	e0bffd17 	ldw	r2,-12(fp)
}
81107b4c:	e037883a 	mov	sp,fp
81107b50:	dfc00117 	ldw	ra,4(sp)
81107b54:	df000017 	ldw	fp,0(sp)
81107b58:	dec00204 	addi	sp,sp,8
81107b5c:	f800283a 	ret

81107b60 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107b60:	defffb04 	addi	sp,sp,-20
81107b64:	de00012e 	bgeu	sp,et,81107b6c <bRmapGetCodecConfig+0xc>
81107b68:	003b68fa 	trap	3
81107b6c:	dfc00415 	stw	ra,16(sp)
81107b70:	df000315 	stw	fp,12(sp)
81107b74:	df000304 	addi	fp,sp,12
81107b78:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107b7c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107b80:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107b84:	e0bfff17 	ldw	r2,-4(fp)
81107b88:	10001226 	beq	r2,zero,81107bd4 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b8c:	e0bfff17 	ldw	r2,-4(fp)
81107b90:	10800017 	ldw	r2,0(r2)
81107b94:	01400104 	movi	r5,4
81107b98:	1009883a 	mov	r4,r2
81107b9c:	1109f100 	call	81109f10 <uliRmapReadReg>
81107ba0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81107ba4:	e0bffe17 	ldw	r2,-8(fp)
81107ba8:	1007883a 	mov	r3,r2
81107bac:	e0bfff17 	ldw	r2,-4(fp)
81107bb0:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81107bb4:	e0bffe17 	ldw	r2,-8(fp)
81107bb8:	10bfc00c 	andi	r2,r2,65280
81107bbc:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81107bc0:	1007883a 	mov	r3,r2
81107bc4:	e0bfff17 	ldw	r2,-4(fp)
81107bc8:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81107bcc:	00800044 	movi	r2,1
81107bd0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107bd4:	e0bffd17 	ldw	r2,-12(fp)
}
81107bd8:	e037883a 	mov	sp,fp
81107bdc:	dfc00117 	ldw	ra,4(sp)
81107be0:	df000017 	ldw	fp,0(sp)
81107be4:	dec00204 	addi	sp,sp,8
81107be8:	f800283a 	ret

81107bec <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81107bec:	defffb04 	addi	sp,sp,-20
81107bf0:	de00012e 	bgeu	sp,et,81107bf8 <bRmapGetCodecStatus+0xc>
81107bf4:	003b68fa 	trap	3
81107bf8:	dfc00415 	stw	ra,16(sp)
81107bfc:	df000315 	stw	fp,12(sp)
81107c00:	df000304 	addi	fp,sp,12
81107c04:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107c08:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107c0c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107c10:	e0bfff17 	ldw	r2,-4(fp)
81107c14:	10004726 	beq	r2,zero,81107d34 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c18:	e0bfff17 	ldw	r2,-4(fp)
81107c1c:	10800017 	ldw	r2,0(r2)
81107c20:	01400144 	movi	r5,5
81107c24:	1009883a 	mov	r4,r2
81107c28:	1109f100 	call	81109f10 <uliRmapReadReg>
81107c2c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81107c30:	e0bffe17 	ldw	r2,-8(fp)
81107c34:	1080004c 	andi	r2,r2,1
81107c38:	10000426 	beq	r2,zero,81107c4c <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107c3c:	e0bfff17 	ldw	r2,-4(fp)
81107c40:	00c00044 	movi	r3,1
81107c44:	10c00215 	stw	r3,8(r2)
81107c48:	00000206 	br	81107c54 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107c4c:	e0bfff17 	ldw	r2,-4(fp)
81107c50:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81107c54:	e0bffe17 	ldw	r2,-8(fp)
81107c58:	1080008c 	andi	r2,r2,2
81107c5c:	10000426 	beq	r2,zero,81107c70 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107c60:	e0bfff17 	ldw	r2,-4(fp)
81107c64:	00c00044 	movi	r3,1
81107c68:	10c00315 	stw	r3,12(r2)
81107c6c:	00000206 	br	81107c78 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107c70:	e0bfff17 	ldw	r2,-4(fp)
81107c74:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81107c78:	e0bffe17 	ldw	r2,-8(fp)
81107c7c:	1080010c 	andi	r2,r2,4
81107c80:	10000426 	beq	r2,zero,81107c94 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81107c84:	e0bfff17 	ldw	r2,-4(fp)
81107c88:	00c00044 	movi	r3,1
81107c8c:	10c00415 	stw	r3,16(r2)
81107c90:	00000206 	br	81107c9c <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81107c94:	e0bfff17 	ldw	r2,-4(fp)
81107c98:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81107c9c:	e0bffe17 	ldw	r2,-8(fp)
81107ca0:	1080020c 	andi	r2,r2,8
81107ca4:	10000426 	beq	r2,zero,81107cb8 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107ca8:	e0bfff17 	ldw	r2,-4(fp)
81107cac:	00c00044 	movi	r3,1
81107cb0:	10c00515 	stw	r3,20(r2)
81107cb4:	00000206 	br	81107cc0 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107cb8:	e0bfff17 	ldw	r2,-4(fp)
81107cbc:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107cc0:	e0bffe17 	ldw	r2,-8(fp)
81107cc4:	1080040c 	andi	r2,r2,16
81107cc8:	10000426 	beq	r2,zero,81107cdc <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107ccc:	e0bfff17 	ldw	r2,-4(fp)
81107cd0:	00c00044 	movi	r3,1
81107cd4:	10c00615 	stw	r3,24(r2)
81107cd8:	00000206 	br	81107ce4 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107cdc:	e0bfff17 	ldw	r2,-4(fp)
81107ce0:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81107ce4:	e0bffe17 	ldw	r2,-8(fp)
81107ce8:	1080080c 	andi	r2,r2,32
81107cec:	10000426 	beq	r2,zero,81107d00 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107cf0:	e0bfff17 	ldw	r2,-4(fp)
81107cf4:	00c00044 	movi	r3,1
81107cf8:	10c00715 	stw	r3,28(r2)
81107cfc:	00000206 	br	81107d08 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107d00:	e0bfff17 	ldw	r2,-4(fp)
81107d04:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81107d08:	e0bffe17 	ldw	r2,-8(fp)
81107d0c:	1080100c 	andi	r2,r2,64
81107d10:	10000426 	beq	r2,zero,81107d24 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81107d14:	e0bfff17 	ldw	r2,-4(fp)
81107d18:	00c00044 	movi	r3,1
81107d1c:	10c00815 	stw	r3,32(r2)
81107d20:	00000206 	br	81107d2c <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107d24:	e0bfff17 	ldw	r2,-4(fp)
81107d28:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107d2c:	00800044 	movi	r2,1
81107d30:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107d34:	e0bffd17 	ldw	r2,-12(fp)
}
81107d38:	e037883a 	mov	sp,fp
81107d3c:	dfc00117 	ldw	ra,4(sp)
81107d40:	df000017 	ldw	fp,0(sp)
81107d44:	dec00204 	addi	sp,sp,8
81107d48:	f800283a 	ret

81107d4c <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107d4c:	defffb04 	addi	sp,sp,-20
81107d50:	de00012e 	bgeu	sp,et,81107d58 <bRmapGetCodecError+0xc>
81107d54:	003b68fa 	trap	3
81107d58:	dfc00415 	stw	ra,16(sp)
81107d5c:	df000315 	stw	fp,12(sp)
81107d60:	df000304 	addi	fp,sp,12
81107d64:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107d68:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107d6c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107d70:	e0bfff17 	ldw	r2,-4(fp)
81107d74:	10004726 	beq	r2,zero,81107e94 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d78:	e0bfff17 	ldw	r2,-4(fp)
81107d7c:	10800017 	ldw	r2,0(r2)
81107d80:	01400144 	movi	r5,5
81107d84:	1009883a 	mov	r4,r2
81107d88:	1109f100 	call	81109f10 <uliRmapReadReg>
81107d8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81107d90:	e0bffe17 	ldw	r2,-8(fp)
81107d94:	1080006c 	andhi	r2,r2,1
81107d98:	10000426 	beq	r2,zero,81107dac <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81107d9c:	e0bfff17 	ldw	r2,-4(fp)
81107da0:	00c00044 	movi	r3,1
81107da4:	10c00915 	stw	r3,36(r2)
81107da8:	00000206 	br	81107db4 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107dac:	e0bfff17 	ldw	r2,-4(fp)
81107db0:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81107db4:	e0bffe17 	ldw	r2,-8(fp)
81107db8:	108000ac 	andhi	r2,r2,2
81107dbc:	10000426 	beq	r2,zero,81107dd0 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107dc0:	e0bfff17 	ldw	r2,-4(fp)
81107dc4:	00c00044 	movi	r3,1
81107dc8:	10c00a15 	stw	r3,40(r2)
81107dcc:	00000206 	br	81107dd8 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107dd0:	e0bfff17 	ldw	r2,-4(fp)
81107dd4:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81107dd8:	e0bffe17 	ldw	r2,-8(fp)
81107ddc:	1080012c 	andhi	r2,r2,4
81107de0:	10000426 	beq	r2,zero,81107df4 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81107de4:	e0bfff17 	ldw	r2,-4(fp)
81107de8:	00c00044 	movi	r3,1
81107dec:	10c00b15 	stw	r3,44(r2)
81107df0:	00000206 	br	81107dfc <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81107df4:	e0bfff17 	ldw	r2,-4(fp)
81107df8:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107dfc:	e0bffe17 	ldw	r2,-8(fp)
81107e00:	1080022c 	andhi	r2,r2,8
81107e04:	10000426 	beq	r2,zero,81107e18 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81107e08:	e0bfff17 	ldw	r2,-4(fp)
81107e0c:	00c00044 	movi	r3,1
81107e10:	10c00c15 	stw	r3,48(r2)
81107e14:	00000206 	br	81107e20 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81107e18:	e0bfff17 	ldw	r2,-4(fp)
81107e1c:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107e20:	e0bffe17 	ldw	r2,-8(fp)
81107e24:	1080042c 	andhi	r2,r2,16
81107e28:	10000426 	beq	r2,zero,81107e3c <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107e2c:	e0bfff17 	ldw	r2,-4(fp)
81107e30:	00c00044 	movi	r3,1
81107e34:	10c00d15 	stw	r3,52(r2)
81107e38:	00000206 	br	81107e44 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107e3c:	e0bfff17 	ldw	r2,-4(fp)
81107e40:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81107e44:	e0bffe17 	ldw	r2,-8(fp)
81107e48:	1080082c 	andhi	r2,r2,32
81107e4c:	10000426 	beq	r2,zero,81107e60 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81107e50:	e0bfff17 	ldw	r2,-4(fp)
81107e54:	00c00044 	movi	r3,1
81107e58:	10c00e15 	stw	r3,56(r2)
81107e5c:	00000206 	br	81107e68 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81107e60:	e0bfff17 	ldw	r2,-4(fp)
81107e64:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81107e68:	e0bffe17 	ldw	r2,-8(fp)
81107e6c:	1080102c 	andhi	r2,r2,64
81107e70:	10000426 	beq	r2,zero,81107e84 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81107e74:	e0bfff17 	ldw	r2,-4(fp)
81107e78:	00c00044 	movi	r3,1
81107e7c:	10c00f15 	stw	r3,60(r2)
81107e80:	00000206 	br	81107e8c <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81107e84:	e0bfff17 	ldw	r2,-4(fp)
81107e88:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81107e8c:	00800044 	movi	r2,1
81107e90:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107e94:	e0bffd17 	ldw	r2,-12(fp)
}
81107e98:	e037883a 	mov	sp,fp
81107e9c:	dfc00117 	ldw	ra,4(sp)
81107ea0:	df000017 	ldw	fp,0(sp)
81107ea4:	dec00204 	addi	sp,sp,8
81107ea8:	f800283a 	ret

81107eac <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107eac:	defffb04 	addi	sp,sp,-20
81107eb0:	de00012e 	bgeu	sp,et,81107eb8 <bRmapSetMemConfigArea+0xc>
81107eb4:	003b68fa 	trap	3
81107eb8:	dfc00415 	stw	ra,16(sp)
81107ebc:	df000315 	stw	fp,12(sp)
81107ec0:	df000304 	addi	fp,sp,12
81107ec4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107ec8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107ecc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107ed0:	e0bfff17 	ldw	r2,-4(fp)
81107ed4:	1000aa26 	beq	r2,zero,81108180 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81107ed8:	e0bfff17 	ldw	r2,-4(fp)
81107edc:	10801217 	ldw	r2,72(r2)
81107ee0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107ee4:	e0bfff17 	ldw	r2,-4(fp)
81107ee8:	10800017 	ldw	r2,0(r2)
81107eec:	e1bffe17 	ldw	r6,-8(fp)
81107ef0:	01401004 	movi	r5,64
81107ef4:	1009883a 	mov	r4,r2
81107ef8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107efc:	e0bfff17 	ldw	r2,-4(fp)
81107f00:	10801317 	ldw	r2,76(r2)
81107f04:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f08:	e0bfff17 	ldw	r2,-4(fp)
81107f0c:	10800017 	ldw	r2,0(r2)
81107f10:	e1bffe17 	ldw	r6,-8(fp)
81107f14:	01401044 	movi	r5,65
81107f18:	1009883a 	mov	r4,r2
81107f1c:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81107f20:	e0bfff17 	ldw	r2,-4(fp)
81107f24:	10801417 	ldw	r2,80(r2)
81107f28:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f2c:	e0bfff17 	ldw	r2,-4(fp)
81107f30:	10800017 	ldw	r2,0(r2)
81107f34:	e1bffe17 	ldw	r6,-8(fp)
81107f38:	01401084 	movi	r5,66
81107f3c:	1009883a 	mov	r4,r2
81107f40:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81107f44:	e0bfff17 	ldw	r2,-4(fp)
81107f48:	10801517 	ldw	r2,84(r2)
81107f4c:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f50:	e0bfff17 	ldw	r2,-4(fp)
81107f54:	10800017 	ldw	r2,0(r2)
81107f58:	e1bffe17 	ldw	r6,-8(fp)
81107f5c:	014010c4 	movi	r5,67
81107f60:	1009883a 	mov	r4,r2
81107f64:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107f68:	e0bfff17 	ldw	r2,-4(fp)
81107f6c:	10802217 	ldw	r2,136(r2)
81107f70:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f74:	e0bfff17 	ldw	r2,-4(fp)
81107f78:	10800017 	ldw	r2,0(r2)
81107f7c:	e1bffe17 	ldw	r6,-8(fp)
81107f80:	01401104 	movi	r5,68
81107f84:	1009883a 	mov	r4,r2
81107f88:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81107f8c:	e0bfff17 	ldw	r2,-4(fp)
81107f90:	10801717 	ldw	r2,92(r2)
81107f94:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f98:	e0bfff17 	ldw	r2,-4(fp)
81107f9c:	10800017 	ldw	r2,0(r2)
81107fa0:	e1bffe17 	ldw	r6,-8(fp)
81107fa4:	01401144 	movi	r5,69
81107fa8:	1009883a 	mov	r4,r2
81107fac:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107fb0:	e0bfff17 	ldw	r2,-4(fp)
81107fb4:	10801817 	ldw	r2,96(r2)
81107fb8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fbc:	e0bfff17 	ldw	r2,-4(fp)
81107fc0:	10800017 	ldw	r2,0(r2)
81107fc4:	e1bffe17 	ldw	r6,-8(fp)
81107fc8:	01401184 	movi	r5,70
81107fcc:	1009883a 	mov	r4,r2
81107fd0:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81107fd4:	e0bfff17 	ldw	r2,-4(fp)
81107fd8:	10801917 	ldw	r2,100(r2)
81107fdc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fe0:	e0bfff17 	ldw	r2,-4(fp)
81107fe4:	10800017 	ldw	r2,0(r2)
81107fe8:	e1bffe17 	ldw	r6,-8(fp)
81107fec:	014011c4 	movi	r5,71
81107ff0:	1009883a 	mov	r4,r2
81107ff4:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107ff8:	e0bfff17 	ldw	r2,-4(fp)
81107ffc:	10801a17 	ldw	r2,104(r2)
81108000:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108004:	e0bfff17 	ldw	r2,-4(fp)
81108008:	10800017 	ldw	r2,0(r2)
8110800c:	e1bffe17 	ldw	r6,-8(fp)
81108010:	01401204 	movi	r5,72
81108014:	1009883a 	mov	r4,r2
81108018:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
8110801c:	e0bfff17 	ldw	r2,-4(fp)
81108020:	10801b17 	ldw	r2,108(r2)
81108024:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108028:	e0bfff17 	ldw	r2,-4(fp)
8110802c:	10800017 	ldw	r2,0(r2)
81108030:	e1bffe17 	ldw	r6,-8(fp)
81108034:	01401244 	movi	r5,73
81108038:	1009883a 	mov	r4,r2
8110803c:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108040:	e0bfff17 	ldw	r2,-4(fp)
81108044:	10800017 	ldw	r2,0(r2)
81108048:	01401284 	movi	r5,74
8110804c:	1009883a 	mov	r4,r2
81108050:	1109f100 	call	81109f10 <uliRmapReadReg>
81108054:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81108058:	e0bfff17 	ldw	r2,-4(fp)
8110805c:	10801c17 	ldw	r2,112(r2)
81108060:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108064:	e0bfff17 	ldw	r2,-4(fp)
81108068:	10800017 	ldw	r2,0(r2)
8110806c:	e1bffe17 	ldw	r6,-8(fp)
81108070:	01401284 	movi	r5,74
81108074:	1009883a 	mov	r4,r2
81108078:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
8110807c:	e0bfff17 	ldw	r2,-4(fp)
81108080:	10801d17 	ldw	r2,116(r2)
81108084:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108088:	e0bfff17 	ldw	r2,-4(fp)
8110808c:	10800017 	ldw	r2,0(r2)
81108090:	e1bffe17 	ldw	r6,-8(fp)
81108094:	014012c4 	movi	r5,75
81108098:	1009883a 	mov	r4,r2
8110809c:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
811080a0:	e0bfff17 	ldw	r2,-4(fp)
811080a4:	10801e17 	ldw	r2,120(r2)
811080a8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
811080ac:	e0bfff17 	ldw	r2,-4(fp)
811080b0:	10800017 	ldw	r2,0(r2)
811080b4:	e1bffe17 	ldw	r6,-8(fp)
811080b8:	01401304 	movi	r5,76
811080bc:	1009883a 	mov	r4,r2
811080c0:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
811080c4:	e0bfff17 	ldw	r2,-4(fp)
811080c8:	10801f17 	ldw	r2,124(r2)
811080cc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
811080d0:	e0bfff17 	ldw	r2,-4(fp)
811080d4:	10800017 	ldw	r2,0(r2)
811080d8:	e1bffe17 	ldw	r6,-8(fp)
811080dc:	01401344 	movi	r5,77
811080e0:	1009883a 	mov	r4,r2
811080e4:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
811080e8:	e0bfff17 	ldw	r2,-4(fp)
811080ec:	10802017 	ldw	r2,128(r2)
811080f0:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
811080f4:	e0bfff17 	ldw	r2,-4(fp)
811080f8:	10800017 	ldw	r2,0(r2)
811080fc:	e1bffe17 	ldw	r6,-8(fp)
81108100:	01401384 	movi	r5,78
81108104:	1009883a 	mov	r4,r2
81108108:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
8110810c:	e0bfff17 	ldw	r2,-4(fp)
81108110:	10802217 	ldw	r2,136(r2)
81108114:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	10800017 	ldw	r2,0(r2)
81108120:	e1bffe17 	ldw	r6,-8(fp)
81108124:	014013c4 	movi	r5,79
81108128:	1009883a 	mov	r4,r2
8110812c:	1109ebc0 	call	81109ebc <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81108130:	e0bfff17 	ldw	r2,-4(fp)
81108134:	10802217 	ldw	r2,136(r2)
81108138:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
8110813c:	e0bfff17 	ldw	r2,-4(fp)
81108140:	10800017 	ldw	r2,0(r2)
81108144:	e1bffe17 	ldw	r6,-8(fp)
81108148:	01401404 	movi	r5,80
8110814c:	1009883a 	mov	r4,r2
81108150:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
81108154:	e0bfff17 	ldw	r2,-4(fp)
81108158:	10802317 	ldw	r2,140(r2)
8110815c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
81108160:	e0bfff17 	ldw	r2,-4(fp)
81108164:	10800017 	ldw	r2,0(r2)
81108168:	e1bffe17 	ldw	r6,-8(fp)
8110816c:	01401444 	movi	r5,81
81108170:	1009883a 	mov	r4,r2
81108174:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108178:	00800044 	movi	r2,1
8110817c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108180:	e0bffd17 	ldw	r2,-12(fp)
}
81108184:	e037883a 	mov	sp,fp
81108188:	dfc00117 	ldw	ra,4(sp)
8110818c:	df000017 	ldw	fp,0(sp)
81108190:	dec00204 	addi	sp,sp,8
81108194:	f800283a 	ret

81108198 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81108198:	defffb04 	addi	sp,sp,-20
8110819c:	de00012e 	bgeu	sp,et,811081a4 <bRmapGetMemConfigArea+0xc>
811081a0:	003b68fa 	trap	3
811081a4:	dfc00415 	stw	ra,16(sp)
811081a8:	df000315 	stw	fp,12(sp)
811081ac:	df000304 	addi	fp,sp,12
811081b0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811081b4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811081b8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811081bc:	e0bfff17 	ldw	r2,-4(fp)
811081c0:	1000a426 	beq	r2,zero,81108454 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081c4:	e0bfff17 	ldw	r2,-4(fp)
811081c8:	10800017 	ldw	r2,0(r2)
811081cc:	01401004 	movi	r5,64
811081d0:	1009883a 	mov	r4,r2
811081d4:	1109f100 	call	81109f10 <uliRmapReadReg>
811081d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
811081dc:	e0bfff17 	ldw	r2,-4(fp)
811081e0:	e0fffe17 	ldw	r3,-8(fp)
811081e4:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081e8:	e0bfff17 	ldw	r2,-4(fp)
811081ec:	10800017 	ldw	r2,0(r2)
811081f0:	01401044 	movi	r5,65
811081f4:	1009883a 	mov	r4,r2
811081f8:	1109f100 	call	81109f10 <uliRmapReadReg>
811081fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
81108200:	e0bfff17 	ldw	r2,-4(fp)
81108204:	e0fffe17 	ldw	r3,-8(fp)
81108208:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110820c:	e0bfff17 	ldw	r2,-4(fp)
81108210:	10800017 	ldw	r2,0(r2)
81108214:	01401084 	movi	r5,66
81108218:	1009883a 	mov	r4,r2
8110821c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108220:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
81108224:	e0bfff17 	ldw	r2,-4(fp)
81108228:	e0fffe17 	ldw	r3,-8(fp)
8110822c:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108230:	e0bfff17 	ldw	r2,-4(fp)
81108234:	10800017 	ldw	r2,0(r2)
81108238:	014010c4 	movi	r5,67
8110823c:	1009883a 	mov	r4,r2
81108240:	1109f100 	call	81109f10 <uliRmapReadReg>
81108244:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
81108248:	e0bfff17 	ldw	r2,-4(fp)
8110824c:	e0fffe17 	ldw	r3,-8(fp)
81108250:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108254:	e0bfff17 	ldw	r2,-4(fp)
81108258:	10800017 	ldw	r2,0(r2)
8110825c:	01401104 	movi	r5,68
81108260:	1009883a 	mov	r4,r2
81108264:	1109f100 	call	81109f10 <uliRmapReadReg>
81108268:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
8110826c:	e0bfff17 	ldw	r2,-4(fp)
81108270:	e0fffe17 	ldw	r3,-8(fp)
81108274:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108278:	e0bfff17 	ldw	r2,-4(fp)
8110827c:	10800017 	ldw	r2,0(r2)
81108280:	01401144 	movi	r5,69
81108284:	1009883a 	mov	r4,r2
81108288:	1109f100 	call	81109f10 <uliRmapReadReg>
8110828c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81108290:	e0bfff17 	ldw	r2,-4(fp)
81108294:	e0fffe17 	ldw	r3,-8(fp)
81108298:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110829c:	e0bfff17 	ldw	r2,-4(fp)
811082a0:	10800017 	ldw	r2,0(r2)
811082a4:	01401184 	movi	r5,70
811082a8:	1009883a 	mov	r4,r2
811082ac:	1109f100 	call	81109f10 <uliRmapReadReg>
811082b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
811082b4:	e0bfff17 	ldw	r2,-4(fp)
811082b8:	e0fffe17 	ldw	r3,-8(fp)
811082bc:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082c0:	e0bfff17 	ldw	r2,-4(fp)
811082c4:	10800017 	ldw	r2,0(r2)
811082c8:	014011c4 	movi	r5,71
811082cc:	1009883a 	mov	r4,r2
811082d0:	1109f100 	call	81109f10 <uliRmapReadReg>
811082d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
811082d8:	e0bfff17 	ldw	r2,-4(fp)
811082dc:	e0fffe17 	ldw	r3,-8(fp)
811082e0:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082e4:	e0bfff17 	ldw	r2,-4(fp)
811082e8:	10800017 	ldw	r2,0(r2)
811082ec:	01401204 	movi	r5,72
811082f0:	1009883a 	mov	r4,r2
811082f4:	1109f100 	call	81109f10 <uliRmapReadReg>
811082f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811082fc:	e0bfff17 	ldw	r2,-4(fp)
81108300:	e0fffe17 	ldw	r3,-8(fp)
81108304:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108308:	e0bfff17 	ldw	r2,-4(fp)
8110830c:	10800017 	ldw	r2,0(r2)
81108310:	01401244 	movi	r5,73
81108314:	1009883a 	mov	r4,r2
81108318:	1109f100 	call	81109f10 <uliRmapReadReg>
8110831c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
81108320:	e0bfff17 	ldw	r2,-4(fp)
81108324:	e0fffe17 	ldw	r3,-8(fp)
81108328:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110832c:	e0bfff17 	ldw	r2,-4(fp)
81108330:	10800017 	ldw	r2,0(r2)
81108334:	01401284 	movi	r5,74
81108338:	1009883a 	mov	r4,r2
8110833c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108340:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
81108344:	e0bfff17 	ldw	r2,-4(fp)
81108348:	e0fffe17 	ldw	r3,-8(fp)
8110834c:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108350:	e0bfff17 	ldw	r2,-4(fp)
81108354:	10800017 	ldw	r2,0(r2)
81108358:	014012c4 	movi	r5,75
8110835c:	1009883a 	mov	r4,r2
81108360:	1109f100 	call	81109f10 <uliRmapReadReg>
81108364:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81108368:	e0bfff17 	ldw	r2,-4(fp)
8110836c:	e0fffe17 	ldw	r3,-8(fp)
81108370:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108374:	e0bfff17 	ldw	r2,-4(fp)
81108378:	10800017 	ldw	r2,0(r2)
8110837c:	01401304 	movi	r5,76
81108380:	1009883a 	mov	r4,r2
81108384:	1109f100 	call	81109f10 <uliRmapReadReg>
81108388:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
8110838c:	e0bfff17 	ldw	r2,-4(fp)
81108390:	e0fffe17 	ldw	r3,-8(fp)
81108394:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108398:	e0bfff17 	ldw	r2,-4(fp)
8110839c:	10800017 	ldw	r2,0(r2)
811083a0:	01401344 	movi	r5,77
811083a4:	1009883a 	mov	r4,r2
811083a8:	1109f100 	call	81109f10 <uliRmapReadReg>
811083ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
811083b0:	e0bfff17 	ldw	r2,-4(fp)
811083b4:	e0fffe17 	ldw	r3,-8(fp)
811083b8:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083bc:	e0bfff17 	ldw	r2,-4(fp)
811083c0:	10800017 	ldw	r2,0(r2)
811083c4:	01401384 	movi	r5,78
811083c8:	1009883a 	mov	r4,r2
811083cc:	1109f100 	call	81109f10 <uliRmapReadReg>
811083d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
811083d4:	e0bfff17 	ldw	r2,-4(fp)
811083d8:	e0fffe17 	ldw	r3,-8(fp)
811083dc:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083e0:	e0bfff17 	ldw	r2,-4(fp)
811083e4:	10800017 	ldw	r2,0(r2)
811083e8:	014013c4 	movi	r5,79
811083ec:	1009883a 	mov	r4,r2
811083f0:	1109f100 	call	81109f10 <uliRmapReadReg>
811083f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811083f8:	e0bfff17 	ldw	r2,-4(fp)
811083fc:	e0fffe17 	ldw	r3,-8(fp)
81108400:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108404:	e0bfff17 	ldw	r2,-4(fp)
81108408:	10800017 	ldw	r2,0(r2)
8110840c:	01401404 	movi	r5,80
81108410:	1009883a 	mov	r4,r2
81108414:	1109f100 	call	81109f10 <uliRmapReadReg>
81108418:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
8110841c:	e0bfff17 	ldw	r2,-4(fp)
81108420:	e0fffe17 	ldw	r3,-8(fp)
81108424:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108428:	e0bfff17 	ldw	r2,-4(fp)
8110842c:	10800017 	ldw	r2,0(r2)
81108430:	01401444 	movi	r5,81
81108434:	1009883a 	mov	r4,r2
81108438:	1109f100 	call	81109f10 <uliRmapReadReg>
8110843c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81108440:	e0bfff17 	ldw	r2,-4(fp)
81108444:	e0fffe17 	ldw	r3,-8(fp)
81108448:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
8110844c:	00800044 	movi	r2,1
81108450:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108454:	e0bffd17 	ldw	r2,-12(fp)
}
81108458:	e037883a 	mov	sp,fp
8110845c:	dfc00117 	ldw	ra,4(sp)
81108460:	df000017 	ldw	fp,0(sp)
81108464:	dec00204 	addi	sp,sp,8
81108468:	f800283a 	ret

8110846c <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
8110846c:	defffb04 	addi	sp,sp,-20
81108470:	de00012e 	bgeu	sp,et,81108478 <bRmapGetMemConfigStat+0xc>
81108474:	003b68fa 	trap	3
81108478:	dfc00415 	stw	ra,16(sp)
8110847c:	df000315 	stw	fp,12(sp)
81108480:	df000304 	addi	fp,sp,12
81108484:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108488:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110848c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108490:	e0bfff17 	ldw	r2,-4(fp)
81108494:	10001426 	beq	r2,zero,811084e8 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108498:	e0bfff17 	ldw	r2,-4(fp)
8110849c:	10800017 	ldw	r2,0(r2)
811084a0:	014001c4 	movi	r5,7
811084a4:	1009883a 	mov	r4,r2
811084a8:	1109f100 	call	81109f10 <uliRmapReadReg>
811084ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
811084b0:	e0bfff17 	ldw	r2,-4(fp)
811084b4:	e0fffe17 	ldw	r3,-8(fp)
811084b8:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084bc:	e0bfff17 	ldw	r2,-4(fp)
811084c0:	10800017 	ldw	r2,0(r2)
811084c4:	01400184 	movi	r5,6
811084c8:	1009883a 	mov	r4,r2
811084cc:	1109f100 	call	81109f10 <uliRmapReadReg>
811084d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
811084d4:	e0bfff17 	ldw	r2,-4(fp)
811084d8:	e0fffe17 	ldw	r3,-8(fp)
811084dc:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
811084e0:	00800044 	movi	r2,1
811084e4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811084e8:	e0bffd17 	ldw	r2,-12(fp)
}
811084ec:	e037883a 	mov	sp,fp
811084f0:	dfc00117 	ldw	ra,4(sp)
811084f4:	df000017 	ldw	fp,0(sp)
811084f8:	dec00204 	addi	sp,sp,8
811084fc:	f800283a 	ret

81108500 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81108500:	defffb04 	addi	sp,sp,-20
81108504:	de00012e 	bgeu	sp,et,8110850c <bRmapSetRmapMemHKArea+0xc>
81108508:	003b68fa 	trap	3
8110850c:	dfc00415 	stw	ra,16(sp)
81108510:	df000315 	stw	fp,12(sp)
81108514:	df000304 	addi	fp,sp,12
81108518:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110851c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108520:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108524:	e0bfff17 	ldw	r2,-4(fp)
81108528:	10040226 	beq	r2,zero,81109534 <bRmapSetRmapMemHKArea+0x1034>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110852c:	e0bfff17 	ldw	r2,-4(fp)
81108530:	10800017 	ldw	r2,0(r2)
81108534:	01402804 	movi	r5,160
81108538:	1009883a 	mov	r4,r2
8110853c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108540:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
81108544:	e0bffe17 	ldw	r2,-8(fp)
81108548:	10bfffec 	andhi	r2,r2,65535
8110854c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81108550:	e0bfff17 	ldw	r2,-4(fp)
81108554:	1080260b 	ldhu	r2,152(r2)
81108558:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
8110855c:	e0fffe17 	ldw	r3,-8(fp)
81108560:	1884b03a 	or	r2,r3,r2
81108564:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81108568:	e0bffe17 	ldw	r2,-8(fp)
8110856c:	10bfffcc 	andi	r2,r2,65535
81108570:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
81108574:	e0bfff17 	ldw	r2,-4(fp)
81108578:	1080268b 	ldhu	r2,154(r2)
8110857c:	10bfffcc 	andi	r2,r2,65535
81108580:	1004943a 	slli	r2,r2,16
81108584:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
81108588:	e0bffe17 	ldw	r2,-8(fp)
8110858c:	10c4b03a 	or	r2,r2,r3
81108590:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108594:	e0bfff17 	ldw	r2,-4(fp)
81108598:	10800017 	ldw	r2,0(r2)
8110859c:	e1bffe17 	ldw	r6,-8(fp)
811085a0:	01402804 	movi	r5,160
811085a4:	1009883a 	mov	r4,r2
811085a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085ac:	e0bfff17 	ldw	r2,-4(fp)
811085b0:	10800017 	ldw	r2,0(r2)
811085b4:	01402844 	movi	r5,161
811085b8:	1009883a 	mov	r4,r2
811085bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811085c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
811085c4:	e0bffe17 	ldw	r2,-8(fp)
811085c8:	10bfffec 	andhi	r2,r2,65535
811085cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
811085d0:	e0bfff17 	ldw	r2,-4(fp)
811085d4:	1080270b 	ldhu	r2,156(r2)
811085d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
811085dc:	e0fffe17 	ldw	r3,-8(fp)
811085e0:	1884b03a 	or	r2,r3,r2
811085e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
811085e8:	e0bffe17 	ldw	r2,-8(fp)
811085ec:	10bfffcc 	andi	r2,r2,65535
811085f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
811085f4:	e0bfff17 	ldw	r2,-4(fp)
811085f8:	1080278b 	ldhu	r2,158(r2)
811085fc:	10bfffcc 	andi	r2,r2,65535
81108600:	1004943a 	slli	r2,r2,16
81108604:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
81108608:	e0bffe17 	ldw	r2,-8(fp)
8110860c:	10c4b03a 	or	r2,r2,r3
81108610:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
81108614:	e0bfff17 	ldw	r2,-4(fp)
81108618:	10800017 	ldw	r2,0(r2)
8110861c:	e1bffe17 	ldw	r6,-8(fp)
81108620:	01402844 	movi	r5,161
81108624:	1009883a 	mov	r4,r2
81108628:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110862c:	e0bfff17 	ldw	r2,-4(fp)
81108630:	10800017 	ldw	r2,0(r2)
81108634:	01402884 	movi	r5,162
81108638:	1009883a 	mov	r4,r2
8110863c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108640:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81108644:	e0bffe17 	ldw	r2,-8(fp)
81108648:	10bfffec 	andhi	r2,r2,65535
8110864c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81108650:	e0bfff17 	ldw	r2,-4(fp)
81108654:	1080280b 	ldhu	r2,160(r2)
81108658:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
8110865c:	e0fffe17 	ldw	r3,-8(fp)
81108660:	1884b03a 	or	r2,r3,r2
81108664:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81108668:	e0bffe17 	ldw	r2,-8(fp)
8110866c:	10bfffcc 	andi	r2,r2,65535
81108670:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
81108674:	e0bfff17 	ldw	r2,-4(fp)
81108678:	1080288b 	ldhu	r2,162(r2)
8110867c:	10bfffcc 	andi	r2,r2,65535
81108680:	1004943a 	slli	r2,r2,16
81108684:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
81108688:	e0bffe17 	ldw	r2,-8(fp)
8110868c:	10c4b03a 	or	r2,r2,r3
81108690:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81108694:	e0bfff17 	ldw	r2,-4(fp)
81108698:	10800017 	ldw	r2,0(r2)
8110869c:	e1bffe17 	ldw	r6,-8(fp)
811086a0:	01402884 	movi	r5,162
811086a4:	1009883a 	mov	r4,r2
811086a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086ac:	e0bfff17 	ldw	r2,-4(fp)
811086b0:	10800017 	ldw	r2,0(r2)
811086b4:	014028c4 	movi	r5,163
811086b8:	1009883a 	mov	r4,r2
811086bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811086c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
811086c4:	e0bffe17 	ldw	r2,-8(fp)
811086c8:	10bfffec 	andhi	r2,r2,65535
811086cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
811086d0:	e0bfff17 	ldw	r2,-4(fp)
811086d4:	1080290b 	ldhu	r2,164(r2)
811086d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
811086dc:	e0fffe17 	ldw	r3,-8(fp)
811086e0:	1884b03a 	or	r2,r3,r2
811086e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
811086e8:	e0bffe17 	ldw	r2,-8(fp)
811086ec:	10bfffcc 	andi	r2,r2,65535
811086f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
811086f4:	e0bfff17 	ldw	r2,-4(fp)
811086f8:	1080298b 	ldhu	r2,166(r2)
811086fc:	10bfffcc 	andi	r2,r2,65535
81108700:	1004943a 	slli	r2,r2,16
81108704:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
81108708:	e0bffe17 	ldw	r2,-8(fp)
8110870c:	10c4b03a 	or	r2,r2,r3
81108710:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81108714:	e0bfff17 	ldw	r2,-4(fp)
81108718:	10800017 	ldw	r2,0(r2)
8110871c:	e1bffe17 	ldw	r6,-8(fp)
81108720:	014028c4 	movi	r5,163
81108724:	1009883a 	mov	r4,r2
81108728:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110872c:	e0bfff17 	ldw	r2,-4(fp)
81108730:	10800017 	ldw	r2,0(r2)
81108734:	01402904 	movi	r5,164
81108738:	1009883a 	mov	r4,r2
8110873c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108740:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81108744:	e0bffe17 	ldw	r2,-8(fp)
81108748:	10bfffec 	andhi	r2,r2,65535
8110874c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
81108750:	e0bfff17 	ldw	r2,-4(fp)
81108754:	10802a0b 	ldhu	r2,168(r2)
81108758:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
8110875c:	e0fffe17 	ldw	r3,-8(fp)
81108760:	1884b03a 	or	r2,r3,r2
81108764:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81108768:	e0bffe17 	ldw	r2,-8(fp)
8110876c:	10bfffcc 	andi	r2,r2,65535
81108770:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
81108774:	e0bfff17 	ldw	r2,-4(fp)
81108778:	10802a8b 	ldhu	r2,170(r2)
8110877c:	10bfffcc 	andi	r2,r2,65535
81108780:	1004943a 	slli	r2,r2,16
81108784:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
81108788:	e0bffe17 	ldw	r2,-8(fp)
8110878c:	10c4b03a 	or	r2,r2,r3
81108790:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81108794:	e0bfff17 	ldw	r2,-4(fp)
81108798:	10800017 	ldw	r2,0(r2)
8110879c:	e1bffe17 	ldw	r6,-8(fp)
811087a0:	01402904 	movi	r5,164
811087a4:	1009883a 	mov	r4,r2
811087a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087ac:	e0bfff17 	ldw	r2,-4(fp)
811087b0:	10800017 	ldw	r2,0(r2)
811087b4:	01402944 	movi	r5,165
811087b8:	1009883a 	mov	r4,r2
811087bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811087c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
811087c4:	e0bffe17 	ldw	r2,-8(fp)
811087c8:	10bfffec 	andhi	r2,r2,65535
811087cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
811087d0:	e0bfff17 	ldw	r2,-4(fp)
811087d4:	10802b0b 	ldhu	r2,172(r2)
811087d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
811087dc:	e0fffe17 	ldw	r3,-8(fp)
811087e0:	1884b03a 	or	r2,r3,r2
811087e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
811087e8:	e0bffe17 	ldw	r2,-8(fp)
811087ec:	10bfffcc 	andi	r2,r2,65535
811087f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
811087f4:	e0bfff17 	ldw	r2,-4(fp)
811087f8:	10802b8b 	ldhu	r2,174(r2)
811087fc:	10bfffcc 	andi	r2,r2,65535
81108800:	1004943a 	slli	r2,r2,16
81108804:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
81108808:	e0bffe17 	ldw	r2,-8(fp)
8110880c:	10c4b03a 	or	r2,r2,r3
81108810:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81108814:	e0bfff17 	ldw	r2,-4(fp)
81108818:	10800017 	ldw	r2,0(r2)
8110881c:	e1bffe17 	ldw	r6,-8(fp)
81108820:	01402944 	movi	r5,165
81108824:	1009883a 	mov	r4,r2
81108828:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110882c:	e0bfff17 	ldw	r2,-4(fp)
81108830:	10800017 	ldw	r2,0(r2)
81108834:	01402984 	movi	r5,166
81108838:	1009883a 	mov	r4,r2
8110883c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108840:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81108844:	e0bffe17 	ldw	r2,-8(fp)
81108848:	10bfffec 	andhi	r2,r2,65535
8110884c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81108850:	e0bfff17 	ldw	r2,-4(fp)
81108854:	10802c0b 	ldhu	r2,176(r2)
81108858:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
8110885c:	e0fffe17 	ldw	r3,-8(fp)
81108860:	1884b03a 	or	r2,r3,r2
81108864:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81108868:	e0bffe17 	ldw	r2,-8(fp)
8110886c:	10bfffcc 	andi	r2,r2,65535
81108870:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
81108874:	e0bfff17 	ldw	r2,-4(fp)
81108878:	10802c8b 	ldhu	r2,178(r2)
8110887c:	10bfffcc 	andi	r2,r2,65535
81108880:	1004943a 	slli	r2,r2,16
81108884:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
81108888:	e0bffe17 	ldw	r2,-8(fp)
8110888c:	10c4b03a 	or	r2,r2,r3
81108890:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81108894:	e0bfff17 	ldw	r2,-4(fp)
81108898:	10800017 	ldw	r2,0(r2)
8110889c:	e1bffe17 	ldw	r6,-8(fp)
811088a0:	01402984 	movi	r5,166
811088a4:	1009883a 	mov	r4,r2
811088a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088ac:	e0bfff17 	ldw	r2,-4(fp)
811088b0:	10800017 	ldw	r2,0(r2)
811088b4:	014029c4 	movi	r5,167
811088b8:	1009883a 	mov	r4,r2
811088bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811088c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
811088c4:	e0bffe17 	ldw	r2,-8(fp)
811088c8:	10bfffec 	andhi	r2,r2,65535
811088cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
811088d0:	e0bfff17 	ldw	r2,-4(fp)
811088d4:	10802d0b 	ldhu	r2,180(r2)
811088d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
811088dc:	e0fffe17 	ldw	r3,-8(fp)
811088e0:	1884b03a 	or	r2,r3,r2
811088e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
811088e8:	e0bffe17 	ldw	r2,-8(fp)
811088ec:	10bfffcc 	andi	r2,r2,65535
811088f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
811088f4:	e0bfff17 	ldw	r2,-4(fp)
811088f8:	10802d8b 	ldhu	r2,182(r2)
811088fc:	10bfffcc 	andi	r2,r2,65535
81108900:	1004943a 	slli	r2,r2,16
81108904:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
81108908:	e0bffe17 	ldw	r2,-8(fp)
8110890c:	10c4b03a 	or	r2,r2,r3
81108910:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81108914:	e0bfff17 	ldw	r2,-4(fp)
81108918:	10800017 	ldw	r2,0(r2)
8110891c:	e1bffe17 	ldw	r6,-8(fp)
81108920:	014029c4 	movi	r5,167
81108924:	1009883a 	mov	r4,r2
81108928:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110892c:	e0bfff17 	ldw	r2,-4(fp)
81108930:	10800017 	ldw	r2,0(r2)
81108934:	01402a04 	movi	r5,168
81108938:	1009883a 	mov	r4,r2
8110893c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108940:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81108944:	e0bffe17 	ldw	r2,-8(fp)
81108948:	10bfffec 	andhi	r2,r2,65535
8110894c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81108950:	e0bfff17 	ldw	r2,-4(fp)
81108954:	10802e0b 	ldhu	r2,184(r2)
81108958:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
8110895c:	e0fffe17 	ldw	r3,-8(fp)
81108960:	1884b03a 	or	r2,r3,r2
81108964:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81108968:	e0bffe17 	ldw	r2,-8(fp)
8110896c:	10bfffcc 	andi	r2,r2,65535
81108970:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
81108974:	e0bfff17 	ldw	r2,-4(fp)
81108978:	10802e8b 	ldhu	r2,186(r2)
8110897c:	10bfffcc 	andi	r2,r2,65535
81108980:	1004943a 	slli	r2,r2,16
81108984:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
81108988:	e0bffe17 	ldw	r2,-8(fp)
8110898c:	10c4b03a 	or	r2,r2,r3
81108990:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81108994:	e0bfff17 	ldw	r2,-4(fp)
81108998:	10800017 	ldw	r2,0(r2)
8110899c:	e1bffe17 	ldw	r6,-8(fp)
811089a0:	01402a04 	movi	r5,168
811089a4:	1009883a 	mov	r4,r2
811089a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089ac:	e0bfff17 	ldw	r2,-4(fp)
811089b0:	10800017 	ldw	r2,0(r2)
811089b4:	01402a44 	movi	r5,169
811089b8:	1009883a 	mov	r4,r2
811089bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811089c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
811089c4:	e0bffe17 	ldw	r2,-8(fp)
811089c8:	10bfffec 	andhi	r2,r2,65535
811089cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
811089d0:	e0bfff17 	ldw	r2,-4(fp)
811089d4:	10802f0b 	ldhu	r2,188(r2)
811089d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
811089dc:	e0fffe17 	ldw	r3,-8(fp)
811089e0:	1884b03a 	or	r2,r3,r2
811089e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
811089e8:	e0bffe17 	ldw	r2,-8(fp)
811089ec:	10bfffcc 	andi	r2,r2,65535
811089f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
811089f4:	e0bfff17 	ldw	r2,-4(fp)
811089f8:	10802f8b 	ldhu	r2,190(r2)
811089fc:	10bfffcc 	andi	r2,r2,65535
81108a00:	1004943a 	slli	r2,r2,16
81108a04:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
81108a08:	e0bffe17 	ldw	r2,-8(fp)
81108a0c:	10c4b03a 	or	r2,r2,r3
81108a10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81108a14:	e0bfff17 	ldw	r2,-4(fp)
81108a18:	10800017 	ldw	r2,0(r2)
81108a1c:	e1bffe17 	ldw	r6,-8(fp)
81108a20:	01402a44 	movi	r5,169
81108a24:	1009883a 	mov	r4,r2
81108a28:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a2c:	e0bfff17 	ldw	r2,-4(fp)
81108a30:	10800017 	ldw	r2,0(r2)
81108a34:	01402a84 	movi	r5,170
81108a38:	1009883a 	mov	r4,r2
81108a3c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108a40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81108a44:	e0bffe17 	ldw	r2,-8(fp)
81108a48:	10bfffec 	andhi	r2,r2,65535
81108a4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81108a50:	e0bfff17 	ldw	r2,-4(fp)
81108a54:	1080300b 	ldhu	r2,192(r2)
81108a58:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81108a5c:	e0fffe17 	ldw	r3,-8(fp)
81108a60:	1884b03a 	or	r2,r3,r2
81108a64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81108a68:	e0bffe17 	ldw	r2,-8(fp)
81108a6c:	10bfffcc 	andi	r2,r2,65535
81108a70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81108a74:	e0bfff17 	ldw	r2,-4(fp)
81108a78:	1080308b 	ldhu	r2,194(r2)
81108a7c:	10bfffcc 	andi	r2,r2,65535
81108a80:	1004943a 	slli	r2,r2,16
81108a84:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81108a88:	e0bffe17 	ldw	r2,-8(fp)
81108a8c:	10c4b03a 	or	r2,r2,r3
81108a90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81108a94:	e0bfff17 	ldw	r2,-4(fp)
81108a98:	10800017 	ldw	r2,0(r2)
81108a9c:	e1bffe17 	ldw	r6,-8(fp)
81108aa0:	01402a84 	movi	r5,170
81108aa4:	1009883a 	mov	r4,r2
81108aa8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108aac:	e0bfff17 	ldw	r2,-4(fp)
81108ab0:	10800017 	ldw	r2,0(r2)
81108ab4:	01402ac4 	movi	r5,171
81108ab8:	1009883a 	mov	r4,r2
81108abc:	1109f100 	call	81109f10 <uliRmapReadReg>
81108ac0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81108ac4:	e0bffe17 	ldw	r2,-8(fp)
81108ac8:	10bfffec 	andhi	r2,r2,65535
81108acc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81108ad0:	e0bfff17 	ldw	r2,-4(fp)
81108ad4:	1080310b 	ldhu	r2,196(r2)
81108ad8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81108adc:	e0fffe17 	ldw	r3,-8(fp)
81108ae0:	1884b03a 	or	r2,r3,r2
81108ae4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81108ae8:	e0bffe17 	ldw	r2,-8(fp)
81108aec:	10bfffcc 	andi	r2,r2,65535
81108af0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
81108af4:	e0bfff17 	ldw	r2,-4(fp)
81108af8:	1080318b 	ldhu	r2,198(r2)
81108afc:	10bfffcc 	andi	r2,r2,65535
81108b00:	1004943a 	slli	r2,r2,16
81108b04:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
81108b08:	e0bffe17 	ldw	r2,-8(fp)
81108b0c:	10c4b03a 	or	r2,r2,r3
81108b10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81108b14:	e0bfff17 	ldw	r2,-4(fp)
81108b18:	10800017 	ldw	r2,0(r2)
81108b1c:	e1bffe17 	ldw	r6,-8(fp)
81108b20:	01402ac4 	movi	r5,171
81108b24:	1009883a 	mov	r4,r2
81108b28:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b2c:	e0bfff17 	ldw	r2,-4(fp)
81108b30:	10800017 	ldw	r2,0(r2)
81108b34:	01402b04 	movi	r5,172
81108b38:	1009883a 	mov	r4,r2
81108b3c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108b40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81108b44:	e0bffe17 	ldw	r2,-8(fp)
81108b48:	10bfffec 	andhi	r2,r2,65535
81108b4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81108b50:	e0bfff17 	ldw	r2,-4(fp)
81108b54:	1080320b 	ldhu	r2,200(r2)
81108b58:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81108b5c:	e0fffe17 	ldw	r3,-8(fp)
81108b60:	1884b03a 	or	r2,r3,r2
81108b64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81108b68:	e0bffe17 	ldw	r2,-8(fp)
81108b6c:	10bfffcc 	andi	r2,r2,65535
81108b70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81108b74:	e0bfff17 	ldw	r2,-4(fp)
81108b78:	1080328b 	ldhu	r2,202(r2)
81108b7c:	10bfffcc 	andi	r2,r2,65535
81108b80:	1004943a 	slli	r2,r2,16
81108b84:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
81108b88:	e0bffe17 	ldw	r2,-8(fp)
81108b8c:	10c4b03a 	or	r2,r2,r3
81108b90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81108b94:	e0bfff17 	ldw	r2,-4(fp)
81108b98:	10800017 	ldw	r2,0(r2)
81108b9c:	e1bffe17 	ldw	r6,-8(fp)
81108ba0:	01402b04 	movi	r5,172
81108ba4:	1009883a 	mov	r4,r2
81108ba8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bac:	e0bfff17 	ldw	r2,-4(fp)
81108bb0:	10800017 	ldw	r2,0(r2)
81108bb4:	01402b44 	movi	r5,173
81108bb8:	1009883a 	mov	r4,r2
81108bbc:	1109f100 	call	81109f10 <uliRmapReadReg>
81108bc0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81108bc4:	e0bffe17 	ldw	r2,-8(fp)
81108bc8:	10bfffec 	andhi	r2,r2,65535
81108bcc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81108bd0:	e0bfff17 	ldw	r2,-4(fp)
81108bd4:	1080330b 	ldhu	r2,204(r2)
81108bd8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81108bdc:	e0fffe17 	ldw	r3,-8(fp)
81108be0:	1884b03a 	or	r2,r3,r2
81108be4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81108be8:	e0bffe17 	ldw	r2,-8(fp)
81108bec:	10bfffcc 	andi	r2,r2,65535
81108bf0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
81108bf4:	e0bfff17 	ldw	r2,-4(fp)
81108bf8:	1080338b 	ldhu	r2,206(r2)
81108bfc:	10bfffcc 	andi	r2,r2,65535
81108c00:	1004943a 	slli	r2,r2,16
81108c04:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
81108c08:	e0bffe17 	ldw	r2,-8(fp)
81108c0c:	10c4b03a 	or	r2,r2,r3
81108c10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81108c14:	e0bfff17 	ldw	r2,-4(fp)
81108c18:	10800017 	ldw	r2,0(r2)
81108c1c:	e1bffe17 	ldw	r6,-8(fp)
81108c20:	01402b44 	movi	r5,173
81108c24:	1009883a 	mov	r4,r2
81108c28:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c2c:	e0bfff17 	ldw	r2,-4(fp)
81108c30:	10800017 	ldw	r2,0(r2)
81108c34:	01402b84 	movi	r5,174
81108c38:	1009883a 	mov	r4,r2
81108c3c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108c40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81108c44:	e0bffe17 	ldw	r2,-8(fp)
81108c48:	10bfffec 	andhi	r2,r2,65535
81108c4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81108c50:	e0bfff17 	ldw	r2,-4(fp)
81108c54:	1080340b 	ldhu	r2,208(r2)
81108c58:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81108c5c:	e0fffe17 	ldw	r3,-8(fp)
81108c60:	1884b03a 	or	r2,r3,r2
81108c64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81108c68:	e0bffe17 	ldw	r2,-8(fp)
81108c6c:	10bfffcc 	andi	r2,r2,65535
81108c70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
81108c74:	e0bfff17 	ldw	r2,-4(fp)
81108c78:	1080348b 	ldhu	r2,210(r2)
81108c7c:	10bfffcc 	andi	r2,r2,65535
81108c80:	1004943a 	slli	r2,r2,16
81108c84:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81108c88:	e0bffe17 	ldw	r2,-8(fp)
81108c8c:	10c4b03a 	or	r2,r2,r3
81108c90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81108c94:	e0bfff17 	ldw	r2,-4(fp)
81108c98:	10800017 	ldw	r2,0(r2)
81108c9c:	e1bffe17 	ldw	r6,-8(fp)
81108ca0:	01402b84 	movi	r5,174
81108ca4:	1009883a 	mov	r4,r2
81108ca8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108cac:	e0bfff17 	ldw	r2,-4(fp)
81108cb0:	10800017 	ldw	r2,0(r2)
81108cb4:	01402bc4 	movi	r5,175
81108cb8:	1009883a 	mov	r4,r2
81108cbc:	1109f100 	call	81109f10 <uliRmapReadReg>
81108cc0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81108cc4:	e0bffe17 	ldw	r2,-8(fp)
81108cc8:	10bfffec 	andhi	r2,r2,65535
81108ccc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81108cd0:	e0bfff17 	ldw	r2,-4(fp)
81108cd4:	1080350b 	ldhu	r2,212(r2)
81108cd8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81108cdc:	e0fffe17 	ldw	r3,-8(fp)
81108ce0:	1884b03a 	or	r2,r3,r2
81108ce4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81108ce8:	e0bffe17 	ldw	r2,-8(fp)
81108cec:	10bfffcc 	andi	r2,r2,65535
81108cf0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
81108cf4:	e0bfff17 	ldw	r2,-4(fp)
81108cf8:	1080358b 	ldhu	r2,214(r2)
81108cfc:	10bfffcc 	andi	r2,r2,65535
81108d00:	1004943a 	slli	r2,r2,16
81108d04:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
81108d08:	e0bffe17 	ldw	r2,-8(fp)
81108d0c:	10c4b03a 	or	r2,r2,r3
81108d10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81108d14:	e0bfff17 	ldw	r2,-4(fp)
81108d18:	10800017 	ldw	r2,0(r2)
81108d1c:	e1bffe17 	ldw	r6,-8(fp)
81108d20:	01402bc4 	movi	r5,175
81108d24:	1009883a 	mov	r4,r2
81108d28:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d2c:	e0bfff17 	ldw	r2,-4(fp)
81108d30:	10800017 	ldw	r2,0(r2)
81108d34:	01402c04 	movi	r5,176
81108d38:	1009883a 	mov	r4,r2
81108d3c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108d40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81108d44:	e0bffe17 	ldw	r2,-8(fp)
81108d48:	10bfffec 	andhi	r2,r2,65535
81108d4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81108d50:	e0bfff17 	ldw	r2,-4(fp)
81108d54:	1080360b 	ldhu	r2,216(r2)
81108d58:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81108d5c:	e0fffe17 	ldw	r3,-8(fp)
81108d60:	1884b03a 	or	r2,r3,r2
81108d64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81108d68:	e0bffe17 	ldw	r2,-8(fp)
81108d6c:	10bfffcc 	andi	r2,r2,65535
81108d70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81108d74:	e0bfff17 	ldw	r2,-4(fp)
81108d78:	1080368b 	ldhu	r2,218(r2)
81108d7c:	10bfffcc 	andi	r2,r2,65535
81108d80:	1004943a 	slli	r2,r2,16
81108d84:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
81108d88:	e0bffe17 	ldw	r2,-8(fp)
81108d8c:	10c4b03a 	or	r2,r2,r3
81108d90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81108d94:	e0bfff17 	ldw	r2,-4(fp)
81108d98:	10800017 	ldw	r2,0(r2)
81108d9c:	e1bffe17 	ldw	r6,-8(fp)
81108da0:	01402c04 	movi	r5,176
81108da4:	1009883a 	mov	r4,r2
81108da8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108dac:	e0bfff17 	ldw	r2,-4(fp)
81108db0:	10800017 	ldw	r2,0(r2)
81108db4:	01402c44 	movi	r5,177
81108db8:	1009883a 	mov	r4,r2
81108dbc:	1109f100 	call	81109f10 <uliRmapReadReg>
81108dc0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81108dc4:	e0bffe17 	ldw	r2,-8(fp)
81108dc8:	10bfffec 	andhi	r2,r2,65535
81108dcc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81108dd0:	e0bfff17 	ldw	r2,-4(fp)
81108dd4:	1080370b 	ldhu	r2,220(r2)
81108dd8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81108ddc:	e0fffe17 	ldw	r3,-8(fp)
81108de0:	1884b03a 	or	r2,r3,r2
81108de4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81108de8:	e0bffe17 	ldw	r2,-8(fp)
81108dec:	10bfffcc 	andi	r2,r2,65535
81108df0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
81108df4:	e0bfff17 	ldw	r2,-4(fp)
81108df8:	1080378b 	ldhu	r2,222(r2)
81108dfc:	10bfffcc 	andi	r2,r2,65535
81108e00:	1004943a 	slli	r2,r2,16
81108e04:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
81108e08:	e0bffe17 	ldw	r2,-8(fp)
81108e0c:	10c4b03a 	or	r2,r2,r3
81108e10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81108e14:	e0bfff17 	ldw	r2,-4(fp)
81108e18:	10800017 	ldw	r2,0(r2)
81108e1c:	e1bffe17 	ldw	r6,-8(fp)
81108e20:	01402c44 	movi	r5,177
81108e24:	1009883a 	mov	r4,r2
81108e28:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e2c:	e0bfff17 	ldw	r2,-4(fp)
81108e30:	10800017 	ldw	r2,0(r2)
81108e34:	01402c84 	movi	r5,178
81108e38:	1009883a 	mov	r4,r2
81108e3c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108e40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81108e44:	e0bffe17 	ldw	r2,-8(fp)
81108e48:	10bfffec 	andhi	r2,r2,65535
81108e4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81108e50:	e0bfff17 	ldw	r2,-4(fp)
81108e54:	1080380b 	ldhu	r2,224(r2)
81108e58:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81108e5c:	e0fffe17 	ldw	r3,-8(fp)
81108e60:	1884b03a 	or	r2,r3,r2
81108e64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81108e68:	e0bffe17 	ldw	r2,-8(fp)
81108e6c:	10bfffcc 	andi	r2,r2,65535
81108e70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
81108e74:	e0bfff17 	ldw	r2,-4(fp)
81108e78:	1080388b 	ldhu	r2,226(r2)
81108e7c:	10bfffcc 	andi	r2,r2,65535
81108e80:	1004943a 	slli	r2,r2,16
81108e84:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81108e88:	e0bffe17 	ldw	r2,-8(fp)
81108e8c:	10c4b03a 	or	r2,r2,r3
81108e90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81108e94:	e0bfff17 	ldw	r2,-4(fp)
81108e98:	10800017 	ldw	r2,0(r2)
81108e9c:	e1bffe17 	ldw	r6,-8(fp)
81108ea0:	01402c84 	movi	r5,178
81108ea4:	1009883a 	mov	r4,r2
81108ea8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108eac:	e0bfff17 	ldw	r2,-4(fp)
81108eb0:	10800017 	ldw	r2,0(r2)
81108eb4:	01402cc4 	movi	r5,179
81108eb8:	1009883a 	mov	r4,r2
81108ebc:	1109f100 	call	81109f10 <uliRmapReadReg>
81108ec0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81108ec4:	e0bffe17 	ldw	r2,-8(fp)
81108ec8:	10bfffec 	andhi	r2,r2,65535
81108ecc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81108ed0:	e0bfff17 	ldw	r2,-4(fp)
81108ed4:	1080390b 	ldhu	r2,228(r2)
81108ed8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81108edc:	e0fffe17 	ldw	r3,-8(fp)
81108ee0:	1884b03a 	or	r2,r3,r2
81108ee4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81108ee8:	e0bffe17 	ldw	r2,-8(fp)
81108eec:	10bfffcc 	andi	r2,r2,65535
81108ef0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
81108ef4:	e0bfff17 	ldw	r2,-4(fp)
81108ef8:	1080398b 	ldhu	r2,230(r2)
81108efc:	10bfffcc 	andi	r2,r2,65535
81108f00:	1004943a 	slli	r2,r2,16
81108f04:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
81108f08:	e0bffe17 	ldw	r2,-8(fp)
81108f0c:	10c4b03a 	or	r2,r2,r3
81108f10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81108f14:	e0bfff17 	ldw	r2,-4(fp)
81108f18:	10800017 	ldw	r2,0(r2)
81108f1c:	e1bffe17 	ldw	r6,-8(fp)
81108f20:	01402cc4 	movi	r5,179
81108f24:	1009883a 	mov	r4,r2
81108f28:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f2c:	e0bfff17 	ldw	r2,-4(fp)
81108f30:	10800017 	ldw	r2,0(r2)
81108f34:	01402d04 	movi	r5,180
81108f38:	1009883a 	mov	r4,r2
81108f3c:	1109f100 	call	81109f10 <uliRmapReadReg>
81108f40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81108f44:	e0bffe17 	ldw	r2,-8(fp)
81108f48:	10bfffec 	andhi	r2,r2,65535
81108f4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81108f50:	e0bfff17 	ldw	r2,-4(fp)
81108f54:	10803a0b 	ldhu	r2,232(r2)
81108f58:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81108f5c:	e0fffe17 	ldw	r3,-8(fp)
81108f60:	1884b03a 	or	r2,r3,r2
81108f64:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81108f68:	e0bffe17 	ldw	r2,-8(fp)
81108f6c:	10bfffcc 	andi	r2,r2,65535
81108f70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81108f74:	e0bfff17 	ldw	r2,-4(fp)
81108f78:	10803a8b 	ldhu	r2,234(r2)
81108f7c:	10bfffcc 	andi	r2,r2,65535
81108f80:	1004943a 	slli	r2,r2,16
81108f84:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
81108f88:	e0bffe17 	ldw	r2,-8(fp)
81108f8c:	10c4b03a 	or	r2,r2,r3
81108f90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81108f94:	e0bfff17 	ldw	r2,-4(fp)
81108f98:	10800017 	ldw	r2,0(r2)
81108f9c:	e1bffe17 	ldw	r6,-8(fp)
81108fa0:	01402d04 	movi	r5,180
81108fa4:	1009883a 	mov	r4,r2
81108fa8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108fac:	e0bfff17 	ldw	r2,-4(fp)
81108fb0:	10800017 	ldw	r2,0(r2)
81108fb4:	01402d44 	movi	r5,181
81108fb8:	1009883a 	mov	r4,r2
81108fbc:	1109f100 	call	81109f10 <uliRmapReadReg>
81108fc0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81108fc4:	e0bffe17 	ldw	r2,-8(fp)
81108fc8:	10bfffec 	andhi	r2,r2,65535
81108fcc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81108fd0:	e0bfff17 	ldw	r2,-4(fp)
81108fd4:	10803b0b 	ldhu	r2,236(r2)
81108fd8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108fdc:	e0fffe17 	ldw	r3,-8(fp)
81108fe0:	1884b03a 	or	r2,r3,r2
81108fe4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81108fe8:	e0bffe17 	ldw	r2,-8(fp)
81108fec:	10bfffcc 	andi	r2,r2,65535
81108ff0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
81108ff4:	e0bfff17 	ldw	r2,-4(fp)
81108ff8:	10803b8b 	ldhu	r2,238(r2)
81108ffc:	10bfffcc 	andi	r2,r2,65535
81109000:	1004943a 	slli	r2,r2,16
81109004:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
81109008:	e0bffe17 	ldw	r2,-8(fp)
8110900c:	10c4b03a 	or	r2,r2,r3
81109010:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81109014:	e0bfff17 	ldw	r2,-4(fp)
81109018:	10800017 	ldw	r2,0(r2)
8110901c:	e1bffe17 	ldw	r6,-8(fp)
81109020:	01402d44 	movi	r5,181
81109024:	1009883a 	mov	r4,r2
81109028:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110902c:	e0bfff17 	ldw	r2,-4(fp)
81109030:	10800017 	ldw	r2,0(r2)
81109034:	01402d84 	movi	r5,182
81109038:	1009883a 	mov	r4,r2
8110903c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109040:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81109044:	e0bffe17 	ldw	r2,-8(fp)
81109048:	10bfffec 	andhi	r2,r2,65535
8110904c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81109050:	e0bfff17 	ldw	r2,-4(fp)
81109054:	10803c0b 	ldhu	r2,240(r2)
81109058:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
8110905c:	e0fffe17 	ldw	r3,-8(fp)
81109060:	1884b03a 	or	r2,r3,r2
81109064:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81109068:	e0bffe17 	ldw	r2,-8(fp)
8110906c:	10bfffcc 	andi	r2,r2,65535
81109070:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
81109074:	e0bfff17 	ldw	r2,-4(fp)
81109078:	10803c8b 	ldhu	r2,242(r2)
8110907c:	10bfffcc 	andi	r2,r2,65535
81109080:	1004943a 	slli	r2,r2,16
81109084:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
81109088:	e0bffe17 	ldw	r2,-8(fp)
8110908c:	10c4b03a 	or	r2,r2,r3
81109090:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81109094:	e0bfff17 	ldw	r2,-4(fp)
81109098:	10800017 	ldw	r2,0(r2)
8110909c:	e1bffe17 	ldw	r6,-8(fp)
811090a0:	01402d84 	movi	r5,182
811090a4:	1009883a 	mov	r4,r2
811090a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811090ac:	e0bfff17 	ldw	r2,-4(fp)
811090b0:	10800017 	ldw	r2,0(r2)
811090b4:	01402dc4 	movi	r5,183
811090b8:	1009883a 	mov	r4,r2
811090bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811090c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
811090c4:	e0bffe17 	ldw	r2,-8(fp)
811090c8:	10bfffec 	andhi	r2,r2,65535
811090cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
811090d0:	e0bfff17 	ldw	r2,-4(fp)
811090d4:	10803d0b 	ldhu	r2,244(r2)
811090d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
811090dc:	e0fffe17 	ldw	r3,-8(fp)
811090e0:	1884b03a 	or	r2,r3,r2
811090e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
811090e8:	e0bffe17 	ldw	r2,-8(fp)
811090ec:	10bfffcc 	andi	r2,r2,65535
811090f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
811090f4:	e0bfff17 	ldw	r2,-4(fp)
811090f8:	10803d8b 	ldhu	r2,246(r2)
811090fc:	10bfffcc 	andi	r2,r2,65535
81109100:	1004943a 	slli	r2,r2,16
81109104:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
81109108:	e0bffe17 	ldw	r2,-8(fp)
8110910c:	10c4b03a 	or	r2,r2,r3
81109110:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81109114:	e0bfff17 	ldw	r2,-4(fp)
81109118:	10800017 	ldw	r2,0(r2)
8110911c:	e1bffe17 	ldw	r6,-8(fp)
81109120:	01402dc4 	movi	r5,183
81109124:	1009883a 	mov	r4,r2
81109128:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110912c:	e0bfff17 	ldw	r2,-4(fp)
81109130:	10800017 	ldw	r2,0(r2)
81109134:	01402e04 	movi	r5,184
81109138:	1009883a 	mov	r4,r2
8110913c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109140:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81109144:	e0bffe17 	ldw	r2,-8(fp)
81109148:	10bfffec 	andhi	r2,r2,65535
8110914c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81109150:	e0bfff17 	ldw	r2,-4(fp)
81109154:	10803e0b 	ldhu	r2,248(r2)
81109158:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
8110915c:	e0fffe17 	ldw	r3,-8(fp)
81109160:	1884b03a 	or	r2,r3,r2
81109164:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81109168:	e0bffe17 	ldw	r2,-8(fp)
8110916c:	10bfffcc 	andi	r2,r2,65535
81109170:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
81109174:	e0bfff17 	ldw	r2,-4(fp)
81109178:	10803e8b 	ldhu	r2,250(r2)
8110917c:	10bfffcc 	andi	r2,r2,65535
81109180:	1004943a 	slli	r2,r2,16
81109184:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
81109188:	e0bffe17 	ldw	r2,-8(fp)
8110918c:	10c4b03a 	or	r2,r2,r3
81109190:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81109194:	e0bfff17 	ldw	r2,-4(fp)
81109198:	10800017 	ldw	r2,0(r2)
8110919c:	e1bffe17 	ldw	r6,-8(fp)
811091a0:	01402e04 	movi	r5,184
811091a4:	1009883a 	mov	r4,r2
811091a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811091ac:	e0bfff17 	ldw	r2,-4(fp)
811091b0:	10800017 	ldw	r2,0(r2)
811091b4:	01402e44 	movi	r5,185
811091b8:	1009883a 	mov	r4,r2
811091bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811091c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
811091c4:	e0bffe17 	ldw	r2,-8(fp)
811091c8:	10bfffec 	andhi	r2,r2,65535
811091cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
811091d0:	e0bfff17 	ldw	r2,-4(fp)
811091d4:	10803f0b 	ldhu	r2,252(r2)
811091d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
811091dc:	e0fffe17 	ldw	r3,-8(fp)
811091e0:	1884b03a 	or	r2,r3,r2
811091e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
811091e8:	e0bffe17 	ldw	r2,-8(fp)
811091ec:	10bfffcc 	andi	r2,r2,65535
811091f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
811091f4:	e0bfff17 	ldw	r2,-4(fp)
811091f8:	10803f8b 	ldhu	r2,254(r2)
811091fc:	10bfffcc 	andi	r2,r2,65535
81109200:	1004943a 	slli	r2,r2,16
81109204:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
81109208:	e0bffe17 	ldw	r2,-8(fp)
8110920c:	10c4b03a 	or	r2,r2,r3
81109210:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81109214:	e0bfff17 	ldw	r2,-4(fp)
81109218:	10800017 	ldw	r2,0(r2)
8110921c:	e1bffe17 	ldw	r6,-8(fp)
81109220:	01402e44 	movi	r5,185
81109224:	1009883a 	mov	r4,r2
81109228:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110922c:	e0bfff17 	ldw	r2,-4(fp)
81109230:	10800017 	ldw	r2,0(r2)
81109234:	01402e84 	movi	r5,186
81109238:	1009883a 	mov	r4,r2
8110923c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109240:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81109244:	e0bffe17 	ldw	r2,-8(fp)
81109248:	10bfffec 	andhi	r2,r2,65535
8110924c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81109250:	e0bfff17 	ldw	r2,-4(fp)
81109254:	1080400b 	ldhu	r2,256(r2)
81109258:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
8110925c:	e0fffe17 	ldw	r3,-8(fp)
81109260:	1884b03a 	or	r2,r3,r2
81109264:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81109268:	e0bffe17 	ldw	r2,-8(fp)
8110926c:	10bfffcc 	andi	r2,r2,65535
81109270:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
81109274:	e0bfff17 	ldw	r2,-4(fp)
81109278:	1080408b 	ldhu	r2,258(r2)
8110927c:	10bfffcc 	andi	r2,r2,65535
81109280:	1004943a 	slli	r2,r2,16
81109284:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
81109288:	e0bffe17 	ldw	r2,-8(fp)
8110928c:	10c4b03a 	or	r2,r2,r3
81109290:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81109294:	e0bfff17 	ldw	r2,-4(fp)
81109298:	10800017 	ldw	r2,0(r2)
8110929c:	e1bffe17 	ldw	r6,-8(fp)
811092a0:	01402e84 	movi	r5,186
811092a4:	1009883a 	mov	r4,r2
811092a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092ac:	e0bfff17 	ldw	r2,-4(fp)
811092b0:	10800017 	ldw	r2,0(r2)
811092b4:	01402ec4 	movi	r5,187
811092b8:	1009883a 	mov	r4,r2
811092bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811092c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
811092c4:	e0bffe17 	ldw	r2,-8(fp)
811092c8:	10bfffec 	andhi	r2,r2,65535
811092cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
811092d0:	e0bfff17 	ldw	r2,-4(fp)
811092d4:	1080410b 	ldhu	r2,260(r2)
811092d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
811092dc:	e0fffe17 	ldw	r3,-8(fp)
811092e0:	1884b03a 	or	r2,r3,r2
811092e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
811092e8:	e0bffe17 	ldw	r2,-8(fp)
811092ec:	10bfffcc 	andi	r2,r2,65535
811092f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
811092f4:	e0bfff17 	ldw	r2,-4(fp)
811092f8:	1080418b 	ldhu	r2,262(r2)
811092fc:	10bfffcc 	andi	r2,r2,65535
81109300:	1004943a 	slli	r2,r2,16
81109304:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
81109308:	e0bffe17 	ldw	r2,-8(fp)
8110930c:	10c4b03a 	or	r2,r2,r3
81109310:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81109314:	e0bfff17 	ldw	r2,-4(fp)
81109318:	10800017 	ldw	r2,0(r2)
8110931c:	e1bffe17 	ldw	r6,-8(fp)
81109320:	01402ec4 	movi	r5,187
81109324:	1009883a 	mov	r4,r2
81109328:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110932c:	e0bfff17 	ldw	r2,-4(fp)
81109330:	10800017 	ldw	r2,0(r2)
81109334:	01402f04 	movi	r5,188
81109338:	1009883a 	mov	r4,r2
8110933c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109340:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81109344:	e0bffe17 	ldw	r2,-8(fp)
81109348:	10bfffec 	andhi	r2,r2,65535
8110934c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81109350:	e0bfff17 	ldw	r2,-4(fp)
81109354:	1080420b 	ldhu	r2,264(r2)
81109358:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
8110935c:	e0fffe17 	ldw	r3,-8(fp)
81109360:	1884b03a 	or	r2,r3,r2
81109364:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81109368:	e0bffe17 	ldw	r2,-8(fp)
8110936c:	10bfffcc 	andi	r2,r2,65535
81109370:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
81109374:	e0bfff17 	ldw	r2,-4(fp)
81109378:	1080428b 	ldhu	r2,266(r2)
8110937c:	10bfffcc 	andi	r2,r2,65535
81109380:	1004943a 	slli	r2,r2,16
81109384:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
81109388:	e0bffe17 	ldw	r2,-8(fp)
8110938c:	10c4b03a 	or	r2,r2,r3
81109390:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81109394:	e0bfff17 	ldw	r2,-4(fp)
81109398:	10800017 	ldw	r2,0(r2)
8110939c:	e1bffe17 	ldw	r6,-8(fp)
811093a0:	01402f04 	movi	r5,188
811093a4:	1009883a 	mov	r4,r2
811093a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093ac:	e0bfff17 	ldw	r2,-4(fp)
811093b0:	10800017 	ldw	r2,0(r2)
811093b4:	01402f44 	movi	r5,189
811093b8:	1009883a 	mov	r4,r2
811093bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811093c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
811093c4:	e0bffe17 	ldw	r2,-8(fp)
811093c8:	10bfffec 	andhi	r2,r2,65535
811093cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
811093d0:	e0bfff17 	ldw	r2,-4(fp)
811093d4:	1080430b 	ldhu	r2,268(r2)
811093d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
811093dc:	e0fffe17 	ldw	r3,-8(fp)
811093e0:	1884b03a 	or	r2,r3,r2
811093e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
811093e8:	e0bffe17 	ldw	r2,-8(fp)
811093ec:	10bfffcc 	andi	r2,r2,65535
811093f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
811093f4:	e0bfff17 	ldw	r2,-4(fp)
811093f8:	1080438b 	ldhu	r2,270(r2)
811093fc:	10bfffcc 	andi	r2,r2,65535
81109400:	1004943a 	slli	r2,r2,16
81109404:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
81109408:	e0bffe17 	ldw	r2,-8(fp)
8110940c:	10c4b03a 	or	r2,r2,r3
81109410:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
81109414:	e0bfff17 	ldw	r2,-4(fp)
81109418:	10800017 	ldw	r2,0(r2)
8110941c:	e1bffe17 	ldw	r6,-8(fp)
81109420:	01402f44 	movi	r5,189
81109424:	1009883a 	mov	r4,r2
81109428:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110942c:	e0bfff17 	ldw	r2,-4(fp)
81109430:	10800017 	ldw	r2,0(r2)
81109434:	01402f84 	movi	r5,190
81109438:	1009883a 	mov	r4,r2
8110943c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109440:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
81109444:	e0bffe17 	ldw	r2,-8(fp)
81109448:	10bfffec 	andhi	r2,r2,65535
8110944c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81109450:	e0bfff17 	ldw	r2,-4(fp)
81109454:	1080440b 	ldhu	r2,272(r2)
81109458:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
8110945c:	e0fffe17 	ldw	r3,-8(fp)
81109460:	1884b03a 	or	r2,r3,r2
81109464:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81109468:	e0bffe17 	ldw	r2,-8(fp)
8110946c:	10bfffcc 	andi	r2,r2,65535
81109470:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
81109474:	e0bfff17 	ldw	r2,-4(fp)
81109478:	1080448b 	ldhu	r2,274(r2)
8110947c:	10bfffcc 	andi	r2,r2,65535
81109480:	1004943a 	slli	r2,r2,16
81109484:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
81109488:	e0bffe17 	ldw	r2,-8(fp)
8110948c:	10c4b03a 	or	r2,r2,r3
81109490:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81109494:	e0bfff17 	ldw	r2,-4(fp)
81109498:	10800017 	ldw	r2,0(r2)
8110949c:	e1bffe17 	ldw	r6,-8(fp)
811094a0:	01402f84 	movi	r5,190
811094a4:	1009883a 	mov	r4,r2
811094a8:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094ac:	e0bfff17 	ldw	r2,-4(fp)
811094b0:	10800017 	ldw	r2,0(r2)
811094b4:	01402fc4 	movi	r5,191
811094b8:	1009883a 	mov	r4,r2
811094bc:	1109f100 	call	81109f10 <uliRmapReadReg>
811094c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
811094c4:	e0bffe17 	ldw	r2,-8(fp)
811094c8:	10bfffec 	andhi	r2,r2,65535
811094cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
811094d0:	e0bfff17 	ldw	r2,-4(fp)
811094d4:	1080450b 	ldhu	r2,276(r2)
811094d8:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
811094dc:	e0fffe17 	ldw	r3,-8(fp)
811094e0:	1884b03a 	or	r2,r3,r2
811094e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
811094e8:	e0bffe17 	ldw	r2,-8(fp)
811094ec:	10bfffcc 	andi	r2,r2,65535
811094f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
811094f4:	e0bfff17 	ldw	r2,-4(fp)
811094f8:	1080458b 	ldhu	r2,278(r2)
811094fc:	10bfffcc 	andi	r2,r2,65535
81109500:	1004943a 	slli	r2,r2,16
81109504:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
81109508:	e0bffe17 	ldw	r2,-8(fp)
8110950c:	10c4b03a 	or	r2,r2,r3
81109510:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81109514:	e0bfff17 	ldw	r2,-4(fp)
81109518:	10800017 	ldw	r2,0(r2)
8110951c:	e1bffe17 	ldw	r6,-8(fp)
81109520:	01402fc4 	movi	r5,191
81109524:	1009883a 	mov	r4,r2
81109528:	1109ebc0 	call	81109ebc <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
8110952c:	00800044 	movi	r2,1
81109530:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109534:	e0bffd17 	ldw	r2,-12(fp)
}
81109538:	e037883a 	mov	sp,fp
8110953c:	dfc00117 	ldw	ra,4(sp)
81109540:	df000017 	ldw	fp,0(sp)
81109544:	dec00204 	addi	sp,sp,8
81109548:	f800283a 	ret

8110954c <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
8110954c:	defffb04 	addi	sp,sp,-20
81109550:	de00012e 	bgeu	sp,et,81109558 <bRmapGetRmapMemHKArea+0xc>
81109554:	003b68fa 	trap	3
81109558:	dfc00415 	stw	ra,16(sp)
8110955c:	df000315 	stw	fp,12(sp)
81109560:	df000304 	addi	fp,sp,12
81109564:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109568:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110956c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81109570:	e0bfff17 	ldw	r2,-4(fp)
81109574:	1001e226 	beq	r2,zero,81109d00 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109578:	e0bfff17 	ldw	r2,-4(fp)
8110957c:	10800017 	ldw	r2,0(r2)
81109580:	01402804 	movi	r5,160
81109584:	1009883a 	mov	r4,r2
81109588:	1109f100 	call	81109f10 <uliRmapReadReg>
8110958c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81109590:	e0bffe17 	ldw	r2,-8(fp)
81109594:	1007883a 	mov	r3,r2
81109598:	e0bfff17 	ldw	r2,-4(fp)
8110959c:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
811095a0:	e0bffe17 	ldw	r2,-8(fp)
811095a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
811095a8:	1007883a 	mov	r3,r2
811095ac:	e0bfff17 	ldw	r2,-4(fp)
811095b0:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095b4:	e0bfff17 	ldw	r2,-4(fp)
811095b8:	10800017 	ldw	r2,0(r2)
811095bc:	01402844 	movi	r5,161
811095c0:	1009883a 	mov	r4,r2
811095c4:	1109f100 	call	81109f10 <uliRmapReadReg>
811095c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
811095cc:	e0bffe17 	ldw	r2,-8(fp)
811095d0:	1007883a 	mov	r3,r2
811095d4:	e0bfff17 	ldw	r2,-4(fp)
811095d8:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
811095dc:	e0bffe17 	ldw	r2,-8(fp)
811095e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
811095e4:	1007883a 	mov	r3,r2
811095e8:	e0bfff17 	ldw	r2,-4(fp)
811095ec:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095f0:	e0bfff17 	ldw	r2,-4(fp)
811095f4:	10800017 	ldw	r2,0(r2)
811095f8:	01402884 	movi	r5,162
811095fc:	1009883a 	mov	r4,r2
81109600:	1109f100 	call	81109f10 <uliRmapReadReg>
81109604:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
81109608:	e0bffe17 	ldw	r2,-8(fp)
8110960c:	1007883a 	mov	r3,r2
81109610:	e0bfff17 	ldw	r2,-4(fp)
81109614:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81109618:	e0bffe17 	ldw	r2,-8(fp)
8110961c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
81109620:	1007883a 	mov	r3,r2
81109624:	e0bfff17 	ldw	r2,-4(fp)
81109628:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110962c:	e0bfff17 	ldw	r2,-4(fp)
81109630:	10800017 	ldw	r2,0(r2)
81109634:	014028c4 	movi	r5,163
81109638:	1009883a 	mov	r4,r2
8110963c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109640:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
81109644:	e0bffe17 	ldw	r2,-8(fp)
81109648:	1007883a 	mov	r3,r2
8110964c:	e0bfff17 	ldw	r2,-4(fp)
81109650:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81109654:	e0bffe17 	ldw	r2,-8(fp)
81109658:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
8110965c:	1007883a 	mov	r3,r2
81109660:	e0bfff17 	ldw	r2,-4(fp)
81109664:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109668:	e0bfff17 	ldw	r2,-4(fp)
8110966c:	10800017 	ldw	r2,0(r2)
81109670:	01402904 	movi	r5,164
81109674:	1009883a 	mov	r4,r2
81109678:	1109f100 	call	81109f10 <uliRmapReadReg>
8110967c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81109680:	e0bffe17 	ldw	r2,-8(fp)
81109684:	1007883a 	mov	r3,r2
81109688:	e0bfff17 	ldw	r2,-4(fp)
8110968c:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81109690:	e0bffe17 	ldw	r2,-8(fp)
81109694:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81109698:	1007883a 	mov	r3,r2
8110969c:	e0bfff17 	ldw	r2,-4(fp)
811096a0:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096a4:	e0bfff17 	ldw	r2,-4(fp)
811096a8:	10800017 	ldw	r2,0(r2)
811096ac:	01402944 	movi	r5,165
811096b0:	1009883a 	mov	r4,r2
811096b4:	1109f100 	call	81109f10 <uliRmapReadReg>
811096b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
811096bc:	e0bffe17 	ldw	r2,-8(fp)
811096c0:	1007883a 	mov	r3,r2
811096c4:	e0bfff17 	ldw	r2,-4(fp)
811096c8:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
811096cc:	e0bffe17 	ldw	r2,-8(fp)
811096d0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
811096d4:	1007883a 	mov	r3,r2
811096d8:	e0bfff17 	ldw	r2,-4(fp)
811096dc:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096e0:	e0bfff17 	ldw	r2,-4(fp)
811096e4:	10800017 	ldw	r2,0(r2)
811096e8:	01402984 	movi	r5,166
811096ec:	1009883a 	mov	r4,r2
811096f0:	1109f100 	call	81109f10 <uliRmapReadReg>
811096f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811096f8:	e0bffe17 	ldw	r2,-8(fp)
811096fc:	1007883a 	mov	r3,r2
81109700:	e0bfff17 	ldw	r2,-4(fp)
81109704:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
81109708:	e0bffe17 	ldw	r2,-8(fp)
8110970c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
81109710:	1007883a 	mov	r3,r2
81109714:	e0bfff17 	ldw	r2,-4(fp)
81109718:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110971c:	e0bfff17 	ldw	r2,-4(fp)
81109720:	10800017 	ldw	r2,0(r2)
81109724:	014029c4 	movi	r5,167
81109728:	1009883a 	mov	r4,r2
8110972c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109730:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
81109734:	e0bffe17 	ldw	r2,-8(fp)
81109738:	1007883a 	mov	r3,r2
8110973c:	e0bfff17 	ldw	r2,-4(fp)
81109740:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
81109744:	e0bffe17 	ldw	r2,-8(fp)
81109748:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
8110974c:	1007883a 	mov	r3,r2
81109750:	e0bfff17 	ldw	r2,-4(fp)
81109754:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109758:	e0bfff17 	ldw	r2,-4(fp)
8110975c:	10800017 	ldw	r2,0(r2)
81109760:	01402a04 	movi	r5,168
81109764:	1009883a 	mov	r4,r2
81109768:	1109f100 	call	81109f10 <uliRmapReadReg>
8110976c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81109770:	e0bffe17 	ldw	r2,-8(fp)
81109774:	1007883a 	mov	r3,r2
81109778:	e0bfff17 	ldw	r2,-4(fp)
8110977c:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81109780:	e0bffe17 	ldw	r2,-8(fp)
81109784:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81109788:	1007883a 	mov	r3,r2
8110978c:	e0bfff17 	ldw	r2,-4(fp)
81109790:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109794:	e0bfff17 	ldw	r2,-4(fp)
81109798:	10800017 	ldw	r2,0(r2)
8110979c:	01402a44 	movi	r5,169
811097a0:	1009883a 	mov	r4,r2
811097a4:	1109f100 	call	81109f10 <uliRmapReadReg>
811097a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
811097ac:	e0bffe17 	ldw	r2,-8(fp)
811097b0:	1007883a 	mov	r3,r2
811097b4:	e0bfff17 	ldw	r2,-4(fp)
811097b8:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
811097bc:	e0bffe17 	ldw	r2,-8(fp)
811097c0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
811097c4:	1007883a 	mov	r3,r2
811097c8:	e0bfff17 	ldw	r2,-4(fp)
811097cc:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097d0:	e0bfff17 	ldw	r2,-4(fp)
811097d4:	10800017 	ldw	r2,0(r2)
811097d8:	01402a84 	movi	r5,170
811097dc:	1009883a 	mov	r4,r2
811097e0:	1109f100 	call	81109f10 <uliRmapReadReg>
811097e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
811097e8:	e0bffe17 	ldw	r2,-8(fp)
811097ec:	1007883a 	mov	r3,r2
811097f0:	e0bfff17 	ldw	r2,-4(fp)
811097f4:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811097f8:	e0bffe17 	ldw	r2,-8(fp)
811097fc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
81109800:	1007883a 	mov	r3,r2
81109804:	e0bfff17 	ldw	r2,-4(fp)
81109808:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110980c:	e0bfff17 	ldw	r2,-4(fp)
81109810:	10800017 	ldw	r2,0(r2)
81109814:	01402ac4 	movi	r5,171
81109818:	1009883a 	mov	r4,r2
8110981c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109820:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
81109824:	e0bffe17 	ldw	r2,-8(fp)
81109828:	1007883a 	mov	r3,r2
8110982c:	e0bfff17 	ldw	r2,-4(fp)
81109830:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
81109834:	e0bffe17 	ldw	r2,-8(fp)
81109838:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
8110983c:	1007883a 	mov	r3,r2
81109840:	e0bfff17 	ldw	r2,-4(fp)
81109844:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109848:	e0bfff17 	ldw	r2,-4(fp)
8110984c:	10800017 	ldw	r2,0(r2)
81109850:	01402b04 	movi	r5,172
81109854:	1009883a 	mov	r4,r2
81109858:	1109f100 	call	81109f10 <uliRmapReadReg>
8110985c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81109860:	e0bffe17 	ldw	r2,-8(fp)
81109864:	1007883a 	mov	r3,r2
81109868:	e0bfff17 	ldw	r2,-4(fp)
8110986c:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81109870:	e0bffe17 	ldw	r2,-8(fp)
81109874:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81109878:	1007883a 	mov	r3,r2
8110987c:	e0bfff17 	ldw	r2,-4(fp)
81109880:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109884:	e0bfff17 	ldw	r2,-4(fp)
81109888:	10800017 	ldw	r2,0(r2)
8110988c:	01402b44 	movi	r5,173
81109890:	1009883a 	mov	r4,r2
81109894:	1109f100 	call	81109f10 <uliRmapReadReg>
81109898:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
8110989c:	e0bffe17 	ldw	r2,-8(fp)
811098a0:	1007883a 	mov	r3,r2
811098a4:	e0bfff17 	ldw	r2,-4(fp)
811098a8:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
811098ac:	e0bffe17 	ldw	r2,-8(fp)
811098b0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
811098b4:	1007883a 	mov	r3,r2
811098b8:	e0bfff17 	ldw	r2,-4(fp)
811098bc:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098c0:	e0bfff17 	ldw	r2,-4(fp)
811098c4:	10800017 	ldw	r2,0(r2)
811098c8:	01402b84 	movi	r5,174
811098cc:	1009883a 	mov	r4,r2
811098d0:	1109f100 	call	81109f10 <uliRmapReadReg>
811098d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
811098d8:	e0bffe17 	ldw	r2,-8(fp)
811098dc:	1007883a 	mov	r3,r2
811098e0:	e0bfff17 	ldw	r2,-4(fp)
811098e4:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
811098e8:	e0bffe17 	ldw	r2,-8(fp)
811098ec:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
811098f0:	1007883a 	mov	r3,r2
811098f4:	e0bfff17 	ldw	r2,-4(fp)
811098f8:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098fc:	e0bfff17 	ldw	r2,-4(fp)
81109900:	10800017 	ldw	r2,0(r2)
81109904:	01402bc4 	movi	r5,175
81109908:	1009883a 	mov	r4,r2
8110990c:	1109f100 	call	81109f10 <uliRmapReadReg>
81109910:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81109914:	e0bffe17 	ldw	r2,-8(fp)
81109918:	1007883a 	mov	r3,r2
8110991c:	e0bfff17 	ldw	r2,-4(fp)
81109920:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81109924:	e0bffe17 	ldw	r2,-8(fp)
81109928:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
8110992c:	1007883a 	mov	r3,r2
81109930:	e0bfff17 	ldw	r2,-4(fp)
81109934:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109938:	e0bfff17 	ldw	r2,-4(fp)
8110993c:	10800017 	ldw	r2,0(r2)
81109940:	01402c04 	movi	r5,176
81109944:	1009883a 	mov	r4,r2
81109948:	1109f100 	call	81109f10 <uliRmapReadReg>
8110994c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81109950:	e0bffe17 	ldw	r2,-8(fp)
81109954:	1007883a 	mov	r3,r2
81109958:	e0bfff17 	ldw	r2,-4(fp)
8110995c:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81109960:	e0bffe17 	ldw	r2,-8(fp)
81109964:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81109968:	1007883a 	mov	r3,r2
8110996c:	e0bfff17 	ldw	r2,-4(fp)
81109970:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109974:	e0bfff17 	ldw	r2,-4(fp)
81109978:	10800017 	ldw	r2,0(r2)
8110997c:	01402c44 	movi	r5,177
81109980:	1009883a 	mov	r4,r2
81109984:	1109f100 	call	81109f10 <uliRmapReadReg>
81109988:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
8110998c:	e0bffe17 	ldw	r2,-8(fp)
81109990:	1007883a 	mov	r3,r2
81109994:	e0bfff17 	ldw	r2,-4(fp)
81109998:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
8110999c:	e0bffe17 	ldw	r2,-8(fp)
811099a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
811099a4:	1007883a 	mov	r3,r2
811099a8:	e0bfff17 	ldw	r2,-4(fp)
811099ac:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099b0:	e0bfff17 	ldw	r2,-4(fp)
811099b4:	10800017 	ldw	r2,0(r2)
811099b8:	01402c84 	movi	r5,178
811099bc:	1009883a 	mov	r4,r2
811099c0:	1109f100 	call	81109f10 <uliRmapReadReg>
811099c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
811099c8:	e0bffe17 	ldw	r2,-8(fp)
811099cc:	1007883a 	mov	r3,r2
811099d0:	e0bfff17 	ldw	r2,-4(fp)
811099d4:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
811099d8:	e0bffe17 	ldw	r2,-8(fp)
811099dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
811099e0:	1007883a 	mov	r3,r2
811099e4:	e0bfff17 	ldw	r2,-4(fp)
811099e8:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099ec:	e0bfff17 	ldw	r2,-4(fp)
811099f0:	10800017 	ldw	r2,0(r2)
811099f4:	01402cc4 	movi	r5,179
811099f8:	1009883a 	mov	r4,r2
811099fc:	1109f100 	call	81109f10 <uliRmapReadReg>
81109a00:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81109a04:	e0bffe17 	ldw	r2,-8(fp)
81109a08:	1007883a 	mov	r3,r2
81109a0c:	e0bfff17 	ldw	r2,-4(fp)
81109a10:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81109a14:	e0bffe17 	ldw	r2,-8(fp)
81109a18:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81109a1c:	1007883a 	mov	r3,r2
81109a20:	e0bfff17 	ldw	r2,-4(fp)
81109a24:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a28:	e0bfff17 	ldw	r2,-4(fp)
81109a2c:	10800017 	ldw	r2,0(r2)
81109a30:	01402d04 	movi	r5,180
81109a34:	1009883a 	mov	r4,r2
81109a38:	1109f100 	call	81109f10 <uliRmapReadReg>
81109a3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81109a40:	e0bffe17 	ldw	r2,-8(fp)
81109a44:	1007883a 	mov	r3,r2
81109a48:	e0bfff17 	ldw	r2,-4(fp)
81109a4c:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81109a50:	e0bffe17 	ldw	r2,-8(fp)
81109a54:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81109a58:	1007883a 	mov	r3,r2
81109a5c:	e0bfff17 	ldw	r2,-4(fp)
81109a60:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a64:	e0bfff17 	ldw	r2,-4(fp)
81109a68:	10800017 	ldw	r2,0(r2)
81109a6c:	01402d44 	movi	r5,181
81109a70:	1009883a 	mov	r4,r2
81109a74:	1109f100 	call	81109f10 <uliRmapReadReg>
81109a78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81109a7c:	e0bffe17 	ldw	r2,-8(fp)
81109a80:	1007883a 	mov	r3,r2
81109a84:	e0bfff17 	ldw	r2,-4(fp)
81109a88:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81109a8c:	e0bffe17 	ldw	r2,-8(fp)
81109a90:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81109a94:	1007883a 	mov	r3,r2
81109a98:	e0bfff17 	ldw	r2,-4(fp)
81109a9c:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109aa0:	e0bfff17 	ldw	r2,-4(fp)
81109aa4:	10800017 	ldw	r2,0(r2)
81109aa8:	01402d84 	movi	r5,182
81109aac:	1009883a 	mov	r4,r2
81109ab0:	1109f100 	call	81109f10 <uliRmapReadReg>
81109ab4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81109ab8:	e0bffe17 	ldw	r2,-8(fp)
81109abc:	1007883a 	mov	r3,r2
81109ac0:	e0bfff17 	ldw	r2,-4(fp)
81109ac4:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81109ac8:	e0bffe17 	ldw	r2,-8(fp)
81109acc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
81109ad0:	1007883a 	mov	r3,r2
81109ad4:	e0bfff17 	ldw	r2,-4(fp)
81109ad8:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109adc:	e0bfff17 	ldw	r2,-4(fp)
81109ae0:	10800017 	ldw	r2,0(r2)
81109ae4:	01402dc4 	movi	r5,183
81109ae8:	1009883a 	mov	r4,r2
81109aec:	1109f100 	call	81109f10 <uliRmapReadReg>
81109af0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81109af4:	e0bffe17 	ldw	r2,-8(fp)
81109af8:	1007883a 	mov	r3,r2
81109afc:	e0bfff17 	ldw	r2,-4(fp)
81109b00:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81109b04:	e0bffe17 	ldw	r2,-8(fp)
81109b08:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81109b0c:	1007883a 	mov	r3,r2
81109b10:	e0bfff17 	ldw	r2,-4(fp)
81109b14:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b18:	e0bfff17 	ldw	r2,-4(fp)
81109b1c:	10800017 	ldw	r2,0(r2)
81109b20:	01402e04 	movi	r5,184
81109b24:	1009883a 	mov	r4,r2
81109b28:	1109f100 	call	81109f10 <uliRmapReadReg>
81109b2c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81109b30:	e0bffe17 	ldw	r2,-8(fp)
81109b34:	1007883a 	mov	r3,r2
81109b38:	e0bfff17 	ldw	r2,-4(fp)
81109b3c:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81109b40:	e0bffe17 	ldw	r2,-8(fp)
81109b44:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81109b48:	1007883a 	mov	r3,r2
81109b4c:	e0bfff17 	ldw	r2,-4(fp)
81109b50:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b54:	e0bfff17 	ldw	r2,-4(fp)
81109b58:	10800017 	ldw	r2,0(r2)
81109b5c:	01402e44 	movi	r5,185
81109b60:	1009883a 	mov	r4,r2
81109b64:	1109f100 	call	81109f10 <uliRmapReadReg>
81109b68:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81109b6c:	e0bffe17 	ldw	r2,-8(fp)
81109b70:	1007883a 	mov	r3,r2
81109b74:	e0bfff17 	ldw	r2,-4(fp)
81109b78:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81109b7c:	e0bffe17 	ldw	r2,-8(fp)
81109b80:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81109b84:	1007883a 	mov	r3,r2
81109b88:	e0bfff17 	ldw	r2,-4(fp)
81109b8c:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b90:	e0bfff17 	ldw	r2,-4(fp)
81109b94:	10800017 	ldw	r2,0(r2)
81109b98:	01402e84 	movi	r5,186
81109b9c:	1009883a 	mov	r4,r2
81109ba0:	1109f100 	call	81109f10 <uliRmapReadReg>
81109ba4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81109ba8:	e0bffe17 	ldw	r2,-8(fp)
81109bac:	1007883a 	mov	r3,r2
81109bb0:	e0bfff17 	ldw	r2,-4(fp)
81109bb4:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81109bb8:	e0bffe17 	ldw	r2,-8(fp)
81109bbc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81109bc0:	1007883a 	mov	r3,r2
81109bc4:	e0bfff17 	ldw	r2,-4(fp)
81109bc8:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109bcc:	e0bfff17 	ldw	r2,-4(fp)
81109bd0:	10800017 	ldw	r2,0(r2)
81109bd4:	01402ec4 	movi	r5,187
81109bd8:	1009883a 	mov	r4,r2
81109bdc:	1109f100 	call	81109f10 <uliRmapReadReg>
81109be0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81109be4:	e0bffe17 	ldw	r2,-8(fp)
81109be8:	1007883a 	mov	r3,r2
81109bec:	e0bfff17 	ldw	r2,-4(fp)
81109bf0:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81109bf4:	e0bffe17 	ldw	r2,-8(fp)
81109bf8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81109bfc:	1007883a 	mov	r3,r2
81109c00:	e0bfff17 	ldw	r2,-4(fp)
81109c04:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c08:	e0bfff17 	ldw	r2,-4(fp)
81109c0c:	10800017 	ldw	r2,0(r2)
81109c10:	01402f04 	movi	r5,188
81109c14:	1009883a 	mov	r4,r2
81109c18:	1109f100 	call	81109f10 <uliRmapReadReg>
81109c1c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81109c20:	e0bffe17 	ldw	r2,-8(fp)
81109c24:	1007883a 	mov	r3,r2
81109c28:	e0bfff17 	ldw	r2,-4(fp)
81109c2c:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81109c30:	e0bffe17 	ldw	r2,-8(fp)
81109c34:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81109c38:	1007883a 	mov	r3,r2
81109c3c:	e0bfff17 	ldw	r2,-4(fp)
81109c40:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c44:	e0bfff17 	ldw	r2,-4(fp)
81109c48:	10800017 	ldw	r2,0(r2)
81109c4c:	01402f44 	movi	r5,189
81109c50:	1009883a 	mov	r4,r2
81109c54:	1109f100 	call	81109f10 <uliRmapReadReg>
81109c58:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81109c5c:	e0bffe17 	ldw	r2,-8(fp)
81109c60:	1007883a 	mov	r3,r2
81109c64:	e0bfff17 	ldw	r2,-4(fp)
81109c68:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81109c6c:	e0bffe17 	ldw	r2,-8(fp)
81109c70:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81109c74:	1007883a 	mov	r3,r2
81109c78:	e0bfff17 	ldw	r2,-4(fp)
81109c7c:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c80:	e0bfff17 	ldw	r2,-4(fp)
81109c84:	10800017 	ldw	r2,0(r2)
81109c88:	01402f84 	movi	r5,190
81109c8c:	1009883a 	mov	r4,r2
81109c90:	1109f100 	call	81109f10 <uliRmapReadReg>
81109c94:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81109c98:	e0bffe17 	ldw	r2,-8(fp)
81109c9c:	1007883a 	mov	r3,r2
81109ca0:	e0bfff17 	ldw	r2,-4(fp)
81109ca4:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81109ca8:	e0bffe17 	ldw	r2,-8(fp)
81109cac:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81109cb0:	1007883a 	mov	r3,r2
81109cb4:	e0bfff17 	ldw	r2,-4(fp)
81109cb8:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109cbc:	e0bfff17 	ldw	r2,-4(fp)
81109cc0:	10800017 	ldw	r2,0(r2)
81109cc4:	01402fc4 	movi	r5,191
81109cc8:	1009883a 	mov	r4,r2
81109ccc:	1109f100 	call	81109f10 <uliRmapReadReg>
81109cd0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81109cd4:	e0bffe17 	ldw	r2,-8(fp)
81109cd8:	1007883a 	mov	r3,r2
81109cdc:	e0bfff17 	ldw	r2,-4(fp)
81109ce0:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81109ce4:	e0bffe17 	ldw	r2,-8(fp)
81109ce8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81109cec:	1007883a 	mov	r3,r2
81109cf0:	e0bfff17 	ldw	r2,-4(fp)
81109cf4:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81109cf8:	00800044 	movi	r2,1
81109cfc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109d00:	e0bffd17 	ldw	r2,-12(fp)
}
81109d04:	e037883a 	mov	sp,fp
81109d08:	dfc00117 	ldw	ra,4(sp)
81109d0c:	df000017 	ldw	fp,0(sp)
81109d10:	dec00204 	addi	sp,sp,8
81109d14:	f800283a 	ret

81109d18 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81109d18:	defffb04 	addi	sp,sp,-20
81109d1c:	de00012e 	bgeu	sp,et,81109d24 <bRmapInitCh+0xc>
81109d20:	003b68fa 	trap	3
81109d24:	dfc00415 	stw	ra,16(sp)
81109d28:	df000315 	stw	fp,12(sp)
81109d2c:	df000304 	addi	fp,sp,12
81109d30:	e13ffe15 	stw	r4,-8(fp)
81109d34:	2805883a 	mov	r2,r5
81109d38:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109d3c:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81109d40:	e0bffe17 	ldw	r2,-8(fp)
81109d44:	10005726 	beq	r2,zero,81109ea4 <bRmapInitCh+0x18c>
		bStatus = TRUE;
81109d48:	00800044 	movi	r2,1
81109d4c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109d50:	e0bfff03 	ldbu	r2,-4(fp)
81109d54:	10c00228 	cmpgeui	r3,r2,8
81109d58:	1800361e 	bne	r3,zero,81109e34 <bRmapInitCh+0x11c>
81109d5c:	100690ba 	slli	r3,r2,2
81109d60:	00a04474 	movhi	r2,33041
81109d64:	10a75d04 	addi	r2,r2,-25228
81109d68:	1885883a 	add	r2,r3,r2
81109d6c:	10800017 	ldw	r2,0(r2)
81109d70:	1000683a 	jmp	r2
81109d74:	81109d94 	ori	r4,r16,17014
81109d78:	81109da8 	cmpgeui	r4,r16,17014
81109d7c:	81109dbc 	xorhi	r4,r16,17014
81109d80:	81109dd0 	cmplti	r4,r16,17015
81109d84:	81109de4 	muli	r4,r16,17015
81109d88:	81109df8 	rdprs	r4,r16,17015
81109d8c:	81109e0c 	andi	r4,r16,17016
81109d90:	81109e20 	cmpeqi	r4,r16,17016
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109d94:	e0fffe17 	ldw	r3,-8(fp)
81109d98:	00a04834 	movhi	r2,33056
81109d9c:	108b0004 	addi	r2,r2,11264
81109da0:	18800015 	stw	r2,0(r3)
			break;
81109da4:	00002506 	br	81109e3c <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109da8:	e0fffe17 	ldw	r3,-8(fp)
81109dac:	00a04834 	movhi	r2,33056
81109db0:	108a0004 	addi	r2,r2,10240
81109db4:	18800015 	stw	r2,0(r3)
			break;
81109db8:	00002006 	br	81109e3c <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109dbc:	e0fffe17 	ldw	r3,-8(fp)
81109dc0:	00a04834 	movhi	r2,33056
81109dc4:	108b0004 	addi	r2,r2,11264
81109dc8:	18800015 	stw	r2,0(r3)
			break;
81109dcc:	00001b06 	br	81109e3c <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81109dd0:	e0fffe17 	ldw	r3,-8(fp)
81109dd4:	00a04834 	movhi	r2,33056
81109dd8:	108a0004 	addi	r2,r2,10240
81109ddc:	18800015 	stw	r2,0(r3)
			break;
81109de0:	00001606 	br	81109e3c <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109de4:	e0fffe17 	ldw	r3,-8(fp)
81109de8:	00a04834 	movhi	r2,33056
81109dec:	108b0004 	addi	r2,r2,11264
81109df0:	18800015 	stw	r2,0(r3)
			break;
81109df4:	00001106 	br	81109e3c <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109df8:	e0fffe17 	ldw	r3,-8(fp)
81109dfc:	00a04834 	movhi	r2,33056
81109e00:	108a0004 	addi	r2,r2,10240
81109e04:	18800015 	stw	r2,0(r3)
			break;
81109e08:	00000c06 	br	81109e3c <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109e0c:	e0fffe17 	ldw	r3,-8(fp)
81109e10:	00a04834 	movhi	r2,33056
81109e14:	108b0004 	addi	r2,r2,11264
81109e18:	18800015 	stw	r2,0(r3)
			break;
81109e1c:	00000706 	br	81109e3c <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109e20:	e0fffe17 	ldw	r3,-8(fp)
81109e24:	00a04834 	movhi	r2,33056
81109e28:	108a0004 	addi	r2,r2,10240
81109e2c:	18800015 	stw	r2,0(r3)
			break;
81109e30:	00000206 	br	81109e3c <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81109e34:	e03ffd15 	stw	zero,-12(fp)
			break;
81109e38:	0001883a 	nop
		}

		if (bStatus) {
81109e3c:	e0bffd17 	ldw	r2,-12(fp)
81109e40:	10001826 	beq	r2,zero,81109ea4 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81109e44:	e13ffe17 	ldw	r4,-8(fp)
81109e48:	11079780 	call	81107978 <bRmapGetIrqControl>
81109e4c:	1000011e 	bne	r2,zero,81109e54 <bRmapInitCh+0x13c>
				bStatus = FALSE;
81109e50:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81109e54:	e13ffe17 	ldw	r4,-8(fp)
81109e58:	1107b600 	call	81107b60 <bRmapGetCodecConfig>
81109e5c:	1000011e 	bne	r2,zero,81109e64 <bRmapInitCh+0x14c>
				bStatus = FALSE;
81109e60:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81109e64:	e13ffe17 	ldw	r4,-8(fp)
81109e68:	1107bec0 	call	81107bec <bRmapGetCodecStatus>
81109e6c:	1000011e 	bne	r2,zero,81109e74 <bRmapInitCh+0x15c>
				bStatus = FALSE;
81109e70:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81109e74:	e13ffe17 	ldw	r4,-8(fp)
81109e78:	11081980 	call	81108198 <bRmapGetMemConfigArea>
81109e7c:	1000011e 	bne	r2,zero,81109e84 <bRmapInitCh+0x16c>
				bStatus = FALSE;
81109e80:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81109e84:	e13ffe17 	ldw	r4,-8(fp)
81109e88:	110846c0 	call	8110846c <bRmapGetMemConfigStat>
81109e8c:	1000011e 	bne	r2,zero,81109e94 <bRmapInitCh+0x17c>
				bStatus = FALSE;
81109e90:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81109e94:	e13ffe17 	ldw	r4,-8(fp)
81109e98:	110954c0 	call	8110954c <bRmapGetRmapMemHKArea>
81109e9c:	1000011e 	bne	r2,zero,81109ea4 <bRmapInitCh+0x18c>
				bStatus = FALSE;
81109ea0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109ea4:	e0bffd17 	ldw	r2,-12(fp)
}
81109ea8:	e037883a 	mov	sp,fp
81109eac:	dfc00117 	ldw	ra,4(sp)
81109eb0:	df000017 	ldw	fp,0(sp)
81109eb4:	dec00204 	addi	sp,sp,8
81109eb8:	f800283a 	ret

81109ebc <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109ebc:	defffc04 	addi	sp,sp,-16
81109ec0:	de00012e 	bgeu	sp,et,81109ec8 <vRmapWriteReg+0xc>
81109ec4:	003b68fa 	trap	3
81109ec8:	df000315 	stw	fp,12(sp)
81109ecc:	df000304 	addi	fp,sp,12
81109ed0:	e13ffd15 	stw	r4,-12(fp)
81109ed4:	e17ffe15 	stw	r5,-8(fp)
81109ed8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109edc:	e0bffe17 	ldw	r2,-8(fp)
81109ee0:	1085883a 	add	r2,r2,r2
81109ee4:	1085883a 	add	r2,r2,r2
81109ee8:	1007883a 	mov	r3,r2
81109eec:	e0bffd17 	ldw	r2,-12(fp)
81109ef0:	10c5883a 	add	r2,r2,r3
81109ef4:	e0ffff17 	ldw	r3,-4(fp)
81109ef8:	10c00015 	stw	r3,0(r2)
}
81109efc:	0001883a 	nop
81109f00:	e037883a 	mov	sp,fp
81109f04:	df000017 	ldw	fp,0(sp)
81109f08:	dec00104 	addi	sp,sp,4
81109f0c:	f800283a 	ret

81109f10 <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109f10:	defffc04 	addi	sp,sp,-16
81109f14:	de00012e 	bgeu	sp,et,81109f1c <uliRmapReadReg+0xc>
81109f18:	003b68fa 	trap	3
81109f1c:	df000315 	stw	fp,12(sp)
81109f20:	df000304 	addi	fp,sp,12
81109f24:	e13ffe15 	stw	r4,-8(fp)
81109f28:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109f2c:	e0bfff17 	ldw	r2,-4(fp)
81109f30:	1085883a 	add	r2,r2,r2
81109f34:	1085883a 	add	r2,r2,r2
81109f38:	1007883a 	mov	r3,r2
81109f3c:	e0bffe17 	ldw	r2,-8(fp)
81109f40:	10c5883a 	add	r2,r2,r3
81109f44:	10800017 	ldw	r2,0(r2)
81109f48:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109f4c:	e0bffd17 	ldw	r2,-12(fp)
}
81109f50:	e037883a 	mov	sp,fp
81109f54:	df000017 	ldw	fp,0(sp)
81109f58:	dec00104 	addi	sp,sp,4
81109f5c:	f800283a 	ret

81109f60 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81109f60:	defffd04 	addi	sp,sp,-12
81109f64:	de00012e 	bgeu	sp,et,81109f6c <uliConvRmapCfgAddr+0xc>
81109f68:	003b68fa 	trap	3
81109f6c:	df000215 	stw	fp,8(sp)
81109f70:	df000204 	addi	fp,sp,8
81109f74:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81109f78:	e0bfff17 	ldw	r2,-4(fp)
81109f7c:	10801368 	cmpgeui	r2,r2,77
81109f80:	10008a1e 	bne	r2,zero,8110a1ac <uliConvRmapCfgAddr+0x24c>
81109f84:	e0bfff17 	ldw	r2,-4(fp)
81109f88:	100690ba 	slli	r3,r2,2
81109f8c:	00a04474 	movhi	r2,33041
81109f90:	10a7e804 	addi	r2,r2,-24672
81109f94:	1885883a 	add	r2,r3,r2
81109f98:	10800017 	ldw	r2,0(r2)
81109f9c:	1000683a 	jmp	r2
81109fa0:	8110a0d4 	ori	r4,r16,17027
81109fa4:	8110a1ac 	andhi	r4,r16,17030
81109fa8:	8110a1ac 	andhi	r4,r16,17030
81109fac:	8110a1ac 	andhi	r4,r16,17030
81109fb0:	8110a0e0 	cmpeqi	r4,r16,17027
81109fb4:	8110a1ac 	andhi	r4,r16,17030
81109fb8:	8110a1ac 	andhi	r4,r16,17030
81109fbc:	8110a1ac 	andhi	r4,r16,17030
81109fc0:	8110a0ec 	andhi	r4,r16,17027
81109fc4:	8110a1ac 	andhi	r4,r16,17030
81109fc8:	8110a1ac 	andhi	r4,r16,17030
81109fcc:	8110a1ac 	andhi	r4,r16,17030
81109fd0:	8110a0f8 	rdprs	r4,r16,17027
81109fd4:	8110a1ac 	andhi	r4,r16,17030
81109fd8:	8110a1ac 	andhi	r4,r16,17030
81109fdc:	8110a1ac 	andhi	r4,r16,17030
81109fe0:	8110a104 	addi	r4,r16,17028
81109fe4:	8110a1ac 	andhi	r4,r16,17030
81109fe8:	8110a1ac 	andhi	r4,r16,17030
81109fec:	8110a1ac 	andhi	r4,r16,17030
81109ff0:	8110a110 	cmplti	r4,r16,17028
81109ff4:	8110a1ac 	andhi	r4,r16,17030
81109ff8:	8110a1ac 	andhi	r4,r16,17030
81109ffc:	8110a1ac 	andhi	r4,r16,17030
8110a000:	8110a11c 	xori	r4,r16,17028
8110a004:	8110a1ac 	andhi	r4,r16,17030
8110a008:	8110a1ac 	andhi	r4,r16,17030
8110a00c:	8110a1ac 	andhi	r4,r16,17030
8110a010:	8110a128 	cmpgeui	r4,r16,17028
8110a014:	8110a1ac 	andhi	r4,r16,17030
8110a018:	8110a1ac 	andhi	r4,r16,17030
8110a01c:	8110a1ac 	andhi	r4,r16,17030
8110a020:	8110a134 	orhi	r4,r16,17028
8110a024:	8110a1ac 	andhi	r4,r16,17030
8110a028:	8110a1ac 	andhi	r4,r16,17030
8110a02c:	8110a1ac 	andhi	r4,r16,17030
8110a030:	8110a140 	call	88110a14 <__reset+0x20f0a14>
8110a034:	8110a1ac 	andhi	r4,r16,17030
8110a038:	8110a1ac 	andhi	r4,r16,17030
8110a03c:	8110a1ac 	andhi	r4,r16,17030
8110a040:	8110a14c 	andi	r4,r16,17029
8110a044:	8110a1ac 	andhi	r4,r16,17030
8110a048:	8110a1ac 	andhi	r4,r16,17030
8110a04c:	8110a1ac 	andhi	r4,r16,17030
8110a050:	8110a158 	cmpnei	r4,r16,17029
8110a054:	8110a1ac 	andhi	r4,r16,17030
8110a058:	8110a1ac 	andhi	r4,r16,17030
8110a05c:	8110a1ac 	andhi	r4,r16,17030
8110a060:	8110a1ac 	andhi	r4,r16,17030
8110a064:	8110a1ac 	andhi	r4,r16,17030
8110a068:	8110a1ac 	andhi	r4,r16,17030
8110a06c:	8110a1ac 	andhi	r4,r16,17030
8110a070:	8110a1ac 	andhi	r4,r16,17030
8110a074:	8110a1ac 	andhi	r4,r16,17030
8110a078:	8110a1ac 	andhi	r4,r16,17030
8110a07c:	8110a1ac 	andhi	r4,r16,17030
8110a080:	8110a164 	muli	r4,r16,17029
8110a084:	8110a1ac 	andhi	r4,r16,17030
8110a088:	8110a1ac 	andhi	r4,r16,17030
8110a08c:	8110a1ac 	andhi	r4,r16,17030
8110a090:	8110a170 	cmpltui	r4,r16,17029
8110a094:	8110a1ac 	andhi	r4,r16,17030
8110a098:	8110a1ac 	andhi	r4,r16,17030
8110a09c:	8110a1ac 	andhi	r4,r16,17030
8110a0a0:	8110a17c 	xorhi	r4,r16,17029
8110a0a4:	8110a1ac 	andhi	r4,r16,17030
8110a0a8:	8110a1ac 	andhi	r4,r16,17030
8110a0ac:	8110a1ac 	andhi	r4,r16,17030
8110a0b0:	8110a188 	cmpgei	r4,r16,17030
8110a0b4:	8110a1ac 	andhi	r4,r16,17030
8110a0b8:	8110a1ac 	andhi	r4,r16,17030
8110a0bc:	8110a1ac 	andhi	r4,r16,17030
8110a0c0:	8110a194 	ori	r4,r16,17030
8110a0c4:	8110a1ac 	andhi	r4,r16,17030
8110a0c8:	8110a1ac 	andhi	r4,r16,17030
8110a0cc:	8110a1ac 	andhi	r4,r16,17030
8110a0d0:	8110a1a0 	cmpeqi	r4,r16,17030
	case 0x00000000:
		uliValue = 0x00000040;
8110a0d4:	00801004 	movi	r2,64
8110a0d8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0dc:	00003506 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
8110a0e0:	00801044 	movi	r2,65
8110a0e4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0e8:	00003206 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
8110a0ec:	00801084 	movi	r2,66
8110a0f0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0f4:	00002f06 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
8110a0f8:	008010c4 	movi	r2,67
8110a0fc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a100:	00002c06 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110a104:	00801104 	movi	r2,68
8110a108:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a10c:	00002906 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8110a110:	00801144 	movi	r2,69
8110a114:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a118:	00002606 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8110a11c:	00801184 	movi	r2,70
8110a120:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a124:	00002306 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110a128:	008011c4 	movi	r2,71
8110a12c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a130:	00002006 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110a134:	00801204 	movi	r2,72
8110a138:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a13c:	00001d06 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8110a140:	00801244 	movi	r2,73
8110a144:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a148:	00001a06 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8110a14c:	00801284 	movi	r2,74
8110a150:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a154:	00001706 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110a158:	008012c4 	movi	r2,75
8110a15c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a160:	00001406 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110a164:	00801304 	movi	r2,76
8110a168:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a16c:	00001106 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110a170:	00801344 	movi	r2,77
8110a174:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a178:	00000e06 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8110a17c:	00801384 	movi	r2,78
8110a180:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a184:	00000b06 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8110a188:	008013c4 	movi	r2,79
8110a18c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a190:	00000806 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110a194:	00801404 	movi	r2,80
8110a198:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a19c:	00000506 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110a1a0:	00801444 	movi	r2,81
8110a1a4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a1a8:	00000206 	br	8110a1b4 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8110a1ac:	e03ffe15 	stw	zero,-8(fp)
		break;
8110a1b0:	0001883a 	nop
	}

	return uliValue;
8110a1b4:	e0bffe17 	ldw	r2,-8(fp)
}
8110a1b8:	e037883a 	mov	sp,fp
8110a1bc:	df000017 	ldw	fp,0(sp)
8110a1c0:	dec00104 	addi	sp,sp,4
8110a1c4:	f800283a 	ret

8110a1c8 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110a1c8:	defffb04 	addi	sp,sp,-20
8110a1cc:	de00012e 	bgeu	sp,et,8110a1d4 <bSpwcSetLink+0xc>
8110a1d0:	003b68fa 	trap	3
8110a1d4:	dfc00415 	stw	ra,16(sp)
8110a1d8:	df000315 	stw	fp,12(sp)
8110a1dc:	df000304 	addi	fp,sp,12
8110a1e0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a1e4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a1e8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a1ec:	e0bfff17 	ldw	r2,-4(fp)
8110a1f0:	10003c26 	beq	r2,zero,8110a2e4 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a1f4:	e0bfff17 	ldw	r2,-4(fp)
8110a1f8:	10800017 	ldw	r2,0(r2)
8110a1fc:	000b883a 	mov	r5,zero
8110a200:	1009883a 	mov	r4,r2
8110a204:	110a8940 	call	8110a894 <uliSpwcReadReg>
8110a208:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8110a20c:	e0bfff17 	ldw	r2,-4(fp)
8110a210:	10800117 	ldw	r2,4(r2)
8110a214:	10000426 	beq	r2,zero,8110a228 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110a218:	e0bffe17 	ldw	r2,-8(fp)
8110a21c:	10800114 	ori	r2,r2,4
8110a220:	e0bffe15 	stw	r2,-8(fp)
8110a224:	00000406 	br	8110a238 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110a228:	e0fffe17 	ldw	r3,-8(fp)
8110a22c:	00bffec4 	movi	r2,-5
8110a230:	1884703a 	and	r2,r3,r2
8110a234:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110a238:	e0bfff17 	ldw	r2,-4(fp)
8110a23c:	10800217 	ldw	r2,8(r2)
8110a240:	10000426 	beq	r2,zero,8110a254 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110a244:	e0bffe17 	ldw	r2,-8(fp)
8110a248:	10800094 	ori	r2,r2,2
8110a24c:	e0bffe15 	stw	r2,-8(fp)
8110a250:	00000406 	br	8110a264 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110a254:	e0fffe17 	ldw	r3,-8(fp)
8110a258:	00bfff44 	movi	r2,-3
8110a25c:	1884703a 	and	r2,r3,r2
8110a260:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110a264:	e0bfff17 	ldw	r2,-4(fp)
8110a268:	10800317 	ldw	r2,12(r2)
8110a26c:	10000426 	beq	r2,zero,8110a280 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110a270:	e0bffe17 	ldw	r2,-8(fp)
8110a274:	10800054 	ori	r2,r2,1
8110a278:	e0bffe15 	stw	r2,-8(fp)
8110a27c:	00000406 	br	8110a290 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110a280:	e0fffe17 	ldw	r3,-8(fp)
8110a284:	00bfff84 	movi	r2,-2
8110a288:	1884703a 	and	r2,r3,r2
8110a28c:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110a290:	e0fffe17 	ldw	r3,-8(fp)
8110a294:	00804034 	movhi	r2,256
8110a298:	10bfffc4 	addi	r2,r2,-1
8110a29c:	1884703a 	and	r2,r3,r2
8110a2a0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110a2a4:	e0bfff17 	ldw	r2,-4(fp)
8110a2a8:	10800403 	ldbu	r2,16(r2)
8110a2ac:	10803fcc 	andi	r2,r2,255
8110a2b0:	1004963a 	slli	r2,r2,24
8110a2b4:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8110a2b8:	e0bffe17 	ldw	r2,-8(fp)
8110a2bc:	10c4b03a 	or	r2,r2,r3
8110a2c0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110a2c4:	e0bfff17 	ldw	r2,-4(fp)
8110a2c8:	10800017 	ldw	r2,0(r2)
8110a2cc:	e1bffe17 	ldw	r6,-8(fp)
8110a2d0:	000b883a 	mov	r5,zero
8110a2d4:	1009883a 	mov	r4,r2
8110a2d8:	110a8400 	call	8110a840 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110a2dc:	00800044 	movi	r2,1
8110a2e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a2e4:	e0bffd17 	ldw	r2,-12(fp)
}
8110a2e8:	e037883a 	mov	sp,fp
8110a2ec:	dfc00117 	ldw	ra,4(sp)
8110a2f0:	df000017 	ldw	fp,0(sp)
8110a2f4:	dec00204 	addi	sp,sp,8
8110a2f8:	f800283a 	ret

8110a2fc <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110a2fc:	defffb04 	addi	sp,sp,-20
8110a300:	de00012e 	bgeu	sp,et,8110a308 <bSpwcGetLink+0xc>
8110a304:	003b68fa 	trap	3
8110a308:	dfc00415 	stw	ra,16(sp)
8110a30c:	df000315 	stw	fp,12(sp)
8110a310:	df000304 	addi	fp,sp,12
8110a314:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a318:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a31c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a320:	e0bfff17 	ldw	r2,-4(fp)
8110a324:	10002826 	beq	r2,zero,8110a3c8 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a328:	e0bfff17 	ldw	r2,-4(fp)
8110a32c:	10800017 	ldw	r2,0(r2)
8110a330:	000b883a 	mov	r5,zero
8110a334:	1009883a 	mov	r4,r2
8110a338:	110a8940 	call	8110a894 <uliSpwcReadReg>
8110a33c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8110a340:	e0bffe17 	ldw	r2,-8(fp)
8110a344:	1080010c 	andi	r2,r2,4
8110a348:	10000426 	beq	r2,zero,8110a35c <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110a34c:	e0bfff17 	ldw	r2,-4(fp)
8110a350:	00c00044 	movi	r3,1
8110a354:	10c00115 	stw	r3,4(r2)
8110a358:	00000206 	br	8110a364 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110a35c:	e0bfff17 	ldw	r2,-4(fp)
8110a360:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110a364:	e0bffe17 	ldw	r2,-8(fp)
8110a368:	1080008c 	andi	r2,r2,2
8110a36c:	10000426 	beq	r2,zero,8110a380 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110a370:	e0bfff17 	ldw	r2,-4(fp)
8110a374:	00c00044 	movi	r3,1
8110a378:	10c00215 	stw	r3,8(r2)
8110a37c:	00000206 	br	8110a388 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110a380:	e0bfff17 	ldw	r2,-4(fp)
8110a384:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8110a388:	e0bffe17 	ldw	r2,-8(fp)
8110a38c:	1080004c 	andi	r2,r2,1
8110a390:	10000426 	beq	r2,zero,8110a3a4 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110a394:	e0bfff17 	ldw	r2,-4(fp)
8110a398:	00c00044 	movi	r3,1
8110a39c:	10c00315 	stw	r3,12(r2)
8110a3a0:	00000206 	br	8110a3ac <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110a3a4:	e0bfff17 	ldw	r2,-4(fp)
8110a3a8:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8110a3ac:	e0bffe17 	ldw	r2,-8(fp)
8110a3b0:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110a3b4:	1007883a 	mov	r3,r2
8110a3b8:	e0bfff17 	ldw	r2,-4(fp)
8110a3bc:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110a3c0:	00800044 	movi	r2,1
8110a3c4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a3c8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a3cc:	e037883a 	mov	sp,fp
8110a3d0:	dfc00117 	ldw	ra,4(sp)
8110a3d4:	df000017 	ldw	fp,0(sp)
8110a3d8:	dec00204 	addi	sp,sp,8
8110a3dc:	f800283a 	ret

8110a3e0 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110a3e0:	defffb04 	addi	sp,sp,-20
8110a3e4:	de00012e 	bgeu	sp,et,8110a3ec <bSpwcGetLinkError+0xc>
8110a3e8:	003b68fa 	trap	3
8110a3ec:	dfc00415 	stw	ra,16(sp)
8110a3f0:	df000315 	stw	fp,12(sp)
8110a3f4:	df000304 	addi	fp,sp,12
8110a3f8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a3fc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a400:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a404:	e0bfff17 	ldw	r2,-4(fp)
8110a408:	10002c26 	beq	r2,zero,8110a4bc <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a40c:	e0bfff17 	ldw	r2,-4(fp)
8110a410:	10800017 	ldw	r2,0(r2)
8110a414:	000b883a 	mov	r5,zero
8110a418:	1009883a 	mov	r4,r2
8110a41c:	110a8940 	call	8110a894 <uliSpwcReadReg>
8110a420:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110a424:	e0bffe17 	ldw	r2,-8(fp)
8110a428:	1080006c 	andhi	r2,r2,1
8110a42c:	10000426 	beq	r2,zero,8110a440 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110a430:	e0bfff17 	ldw	r2,-4(fp)
8110a434:	00c00044 	movi	r3,1
8110a438:	10c00515 	stw	r3,20(r2)
8110a43c:	00000206 	br	8110a448 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110a440:	e0bfff17 	ldw	r2,-4(fp)
8110a444:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110a448:	e0bffe17 	ldw	r2,-8(fp)
8110a44c:	108000ac 	andhi	r2,r2,2
8110a450:	10000426 	beq	r2,zero,8110a464 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110a454:	e0bfff17 	ldw	r2,-4(fp)
8110a458:	00c00044 	movi	r3,1
8110a45c:	10c00615 	stw	r3,24(r2)
8110a460:	00000206 	br	8110a46c <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110a464:	e0bfff17 	ldw	r2,-4(fp)
8110a468:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8110a46c:	e0bffe17 	ldw	r2,-8(fp)
8110a470:	1080012c 	andhi	r2,r2,4
8110a474:	10000426 	beq	r2,zero,8110a488 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110a478:	e0bfff17 	ldw	r2,-4(fp)
8110a47c:	00c00044 	movi	r3,1
8110a480:	10c00715 	stw	r3,28(r2)
8110a484:	00000206 	br	8110a490 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110a488:	e0bfff17 	ldw	r2,-4(fp)
8110a48c:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110a490:	e0bffe17 	ldw	r2,-8(fp)
8110a494:	1080022c 	andhi	r2,r2,8
8110a498:	10000426 	beq	r2,zero,8110a4ac <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8110a49c:	e0bfff17 	ldw	r2,-4(fp)
8110a4a0:	00c00044 	movi	r3,1
8110a4a4:	10c00815 	stw	r3,32(r2)
8110a4a8:	00000206 	br	8110a4b4 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8110a4ac:	e0bfff17 	ldw	r2,-4(fp)
8110a4b0:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110a4b4:	00800044 	movi	r2,1
8110a4b8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a4bc:	e0bffd17 	ldw	r2,-12(fp)
}
8110a4c0:	e037883a 	mov	sp,fp
8110a4c4:	dfc00117 	ldw	ra,4(sp)
8110a4c8:	df000017 	ldw	fp,0(sp)
8110a4cc:	dec00204 	addi	sp,sp,8
8110a4d0:	f800283a 	ret

8110a4d4 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110a4d4:	defffb04 	addi	sp,sp,-20
8110a4d8:	de00012e 	bgeu	sp,et,8110a4e0 <bSpwcGetLinkStatus+0xc>
8110a4dc:	003b68fa 	trap	3
8110a4e0:	dfc00415 	stw	ra,16(sp)
8110a4e4:	df000315 	stw	fp,12(sp)
8110a4e8:	df000304 	addi	fp,sp,12
8110a4ec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a4f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a4f4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a4f8:	e0bfff17 	ldw	r2,-4(fp)
8110a4fc:	10002326 	beq	r2,zero,8110a58c <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a500:	e0bfff17 	ldw	r2,-4(fp)
8110a504:	10800017 	ldw	r2,0(r2)
8110a508:	000b883a 	mov	r5,zero
8110a50c:	1009883a 	mov	r4,r2
8110a510:	110a8940 	call	8110a894 <uliSpwcReadReg>
8110a514:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110a518:	e0bffe17 	ldw	r2,-8(fp)
8110a51c:	1081000c 	andi	r2,r2,1024
8110a520:	10000426 	beq	r2,zero,8110a534 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110a524:	e0bfff17 	ldw	r2,-4(fp)
8110a528:	00c00044 	movi	r3,1
8110a52c:	10c00915 	stw	r3,36(r2)
8110a530:	00000206 	br	8110a53c <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110a534:	e0bfff17 	ldw	r2,-4(fp)
8110a538:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8110a53c:	e0bffe17 	ldw	r2,-8(fp)
8110a540:	1080800c 	andi	r2,r2,512
8110a544:	10000426 	beq	r2,zero,8110a558 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110a548:	e0bfff17 	ldw	r2,-4(fp)
8110a54c:	00c00044 	movi	r3,1
8110a550:	10c00a15 	stw	r3,40(r2)
8110a554:	00000206 	br	8110a560 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110a558:	e0bfff17 	ldw	r2,-4(fp)
8110a55c:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110a560:	e0bffe17 	ldw	r2,-8(fp)
8110a564:	1080400c 	andi	r2,r2,256
8110a568:	10000426 	beq	r2,zero,8110a57c <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110a56c:	e0bfff17 	ldw	r2,-4(fp)
8110a570:	00c00044 	movi	r3,1
8110a574:	10c00b15 	stw	r3,44(r2)
8110a578:	00000206 	br	8110a584 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110a57c:	e0bfff17 	ldw	r2,-4(fp)
8110a580:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110a584:	00800044 	movi	r2,1
8110a588:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a58c:	e0bffd17 	ldw	r2,-12(fp)
}
8110a590:	e037883a 	mov	sp,fp
8110a594:	dfc00117 	ldw	ra,4(sp)
8110a598:	df000017 	ldw	fp,0(sp)
8110a59c:	dec00204 	addi	sp,sp,8
8110a5a0:	f800283a 	ret

8110a5a4 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110a5a4:	defffb04 	addi	sp,sp,-20
8110a5a8:	de00012e 	bgeu	sp,et,8110a5b0 <bSpwcGetTimecode+0xc>
8110a5ac:	003b68fa 	trap	3
8110a5b0:	dfc00415 	stw	ra,16(sp)
8110a5b4:	df000315 	stw	fp,12(sp)
8110a5b8:	df000304 	addi	fp,sp,12
8110a5bc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a5c0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a5c4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a5c8:	e0bfff17 	ldw	r2,-4(fp)
8110a5cc:	10001326 	beq	r2,zero,8110a61c <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a5d0:	e0bfff17 	ldw	r2,-4(fp)
8110a5d4:	10800017 	ldw	r2,0(r2)
8110a5d8:	01400044 	movi	r5,1
8110a5dc:	1009883a 	mov	r4,r2
8110a5e0:	110a8940 	call	8110a894 <uliSpwcReadReg>
8110a5e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110a5e8:	e0bffe17 	ldw	r2,-8(fp)
8110a5ec:	1080300c 	andi	r2,r2,192
8110a5f0:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110a5f4:	1007883a 	mov	r3,r2
8110a5f8:	e0bfff17 	ldw	r2,-4(fp)
8110a5fc:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110a600:	e0bffe17 	ldw	r2,-8(fp)
8110a604:	10800fcc 	andi	r2,r2,63
8110a608:	1007883a 	mov	r3,r2
8110a60c:	e0bfff17 	ldw	r2,-4(fp)
8110a610:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110a614:	00800044 	movi	r2,1
8110a618:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a61c:	e0bffd17 	ldw	r2,-12(fp)
}
8110a620:	e037883a 	mov	sp,fp
8110a624:	dfc00117 	ldw	ra,4(sp)
8110a628:	df000017 	ldw	fp,0(sp)
8110a62c:	dec00204 	addi	sp,sp,8
8110a630:	f800283a 	ret

8110a634 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110a634:	defffb04 	addi	sp,sp,-20
8110a638:	de00012e 	bgeu	sp,et,8110a640 <bSpwcClearTimecode+0xc>
8110a63c:	003b68fa 	trap	3
8110a640:	dfc00415 	stw	ra,16(sp)
8110a644:	df000315 	stw	fp,12(sp)
8110a648:	df000304 	addi	fp,sp,12
8110a64c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a650:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a654:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a658:	e0bfff17 	ldw	r2,-4(fp)
8110a65c:	10001126 	beq	r2,zero,8110a6a4 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a660:	e0bfff17 	ldw	r2,-4(fp)
8110a664:	10800017 	ldw	r2,0(r2)
8110a668:	01400044 	movi	r5,1
8110a66c:	1009883a 	mov	r4,r2
8110a670:	110a8940 	call	8110a894 <uliSpwcReadReg>
8110a674:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110a678:	e0bffe17 	ldw	r2,-8(fp)
8110a67c:	10804014 	ori	r2,r2,256
8110a680:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110a684:	e0bfff17 	ldw	r2,-4(fp)
8110a688:	10800017 	ldw	r2,0(r2)
8110a68c:	e1bffe17 	ldw	r6,-8(fp)
8110a690:	01400044 	movi	r5,1
8110a694:	1009883a 	mov	r4,r2
8110a698:	110a8400 	call	8110a840 <vSpwcWriteReg>
		bStatus = TRUE;
8110a69c:	00800044 	movi	r2,1
8110a6a0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a6a4:	e0bffd17 	ldw	r2,-12(fp)
}
8110a6a8:	e037883a 	mov	sp,fp
8110a6ac:	dfc00117 	ldw	ra,4(sp)
8110a6b0:	df000017 	ldw	fp,0(sp)
8110a6b4:	dec00204 	addi	sp,sp,8
8110a6b8:	f800283a 	ret

8110a6bc <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110a6bc:	defffb04 	addi	sp,sp,-20
8110a6c0:	de00012e 	bgeu	sp,et,8110a6c8 <bSpwcInitCh+0xc>
8110a6c4:	003b68fa 	trap	3
8110a6c8:	dfc00415 	stw	ra,16(sp)
8110a6cc:	df000315 	stw	fp,12(sp)
8110a6d0:	df000304 	addi	fp,sp,12
8110a6d4:	e13ffe15 	stw	r4,-8(fp)
8110a6d8:	2805883a 	mov	r2,r5
8110a6dc:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a6e0:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110a6e4:	e0bffe17 	ldw	r2,-8(fp)
8110a6e8:	10004f26 	beq	r2,zero,8110a828 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
8110a6ec:	00800044 	movi	r2,1
8110a6f0:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
8110a6f4:	e0bfff03 	ldbu	r2,-4(fp)
8110a6f8:	10c00228 	cmpgeui	r3,r2,8
8110a6fc:	1800361e 	bne	r3,zero,8110a7d8 <bSpwcInitCh+0x11c>
8110a700:	100690ba 	slli	r3,r2,2
8110a704:	00a04474 	movhi	r2,33041
8110a708:	10a9c604 	addi	r2,r2,-22760
8110a70c:	1885883a 	add	r2,r3,r2
8110a710:	10800017 	ldw	r2,0(r2)
8110a714:	1000683a 	jmp	r2
8110a718:	8110a738 	rdprs	r4,r16,17052
8110a71c:	8110a74c 	andi	r4,r16,17053
8110a720:	8110a760 	cmpeqi	r4,r16,17053
8110a724:	8110a774 	orhi	r4,r16,17053
8110a728:	8110a788 	cmpgei	r4,r16,17054
8110a72c:	8110a79c 	xori	r4,r16,17054
8110a730:	8110a7b0 	cmpltui	r4,r16,17054
8110a734:	8110a7c4 	addi	r4,r16,17055
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a738:	e0fffe17 	ldw	r3,-8(fp)
8110a73c:	00a04834 	movhi	r2,33056
8110a740:	108b0004 	addi	r2,r2,11264
8110a744:	18800015 	stw	r2,0(r3)
			break;
8110a748:	00002506 	br	8110a7e0 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a74c:	e0fffe17 	ldw	r3,-8(fp)
8110a750:	00a04834 	movhi	r2,33056
8110a754:	108a0004 	addi	r2,r2,10240
8110a758:	18800015 	stw	r2,0(r3)
			break;
8110a75c:	00002006 	br	8110a7e0 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a760:	e0fffe17 	ldw	r3,-8(fp)
8110a764:	00a04834 	movhi	r2,33056
8110a768:	108b0004 	addi	r2,r2,11264
8110a76c:	18800015 	stw	r2,0(r3)
			break;
8110a770:	00001b06 	br	8110a7e0 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a774:	e0fffe17 	ldw	r3,-8(fp)
8110a778:	00a04834 	movhi	r2,33056
8110a77c:	108a0004 	addi	r2,r2,10240
8110a780:	18800015 	stw	r2,0(r3)
			break;
8110a784:	00001606 	br	8110a7e0 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a788:	e0fffe17 	ldw	r3,-8(fp)
8110a78c:	00a04834 	movhi	r2,33056
8110a790:	108b0004 	addi	r2,r2,11264
8110a794:	18800015 	stw	r2,0(r3)
			break;
8110a798:	00001106 	br	8110a7e0 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a79c:	e0fffe17 	ldw	r3,-8(fp)
8110a7a0:	00a04834 	movhi	r2,33056
8110a7a4:	108a0004 	addi	r2,r2,10240
8110a7a8:	18800015 	stw	r2,0(r3)
			break;
8110a7ac:	00000c06 	br	8110a7e0 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a7b0:	e0fffe17 	ldw	r3,-8(fp)
8110a7b4:	00a04834 	movhi	r2,33056
8110a7b8:	108b0004 	addi	r2,r2,11264
8110a7bc:	18800015 	stw	r2,0(r3)
			break;
8110a7c0:	00000706 	br	8110a7e0 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a7c4:	e0fffe17 	ldw	r3,-8(fp)
8110a7c8:	00a04834 	movhi	r2,33056
8110a7cc:	108a0004 	addi	r2,r2,10240
8110a7d0:	18800015 	stw	r2,0(r3)
			break;
8110a7d4:	00000206 	br	8110a7e0 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
8110a7d8:	e03ffd15 	stw	zero,-12(fp)
			break;
8110a7dc:	0001883a 	nop
		}

		if (bStatus) {
8110a7e0:	e0bffd17 	ldw	r2,-12(fp)
8110a7e4:	10001026 	beq	r2,zero,8110a828 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110a7e8:	e13ffe17 	ldw	r4,-8(fp)
8110a7ec:	110a2fc0 	call	8110a2fc <bSpwcGetLink>
8110a7f0:	1000011e 	bne	r2,zero,8110a7f8 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
8110a7f4:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110a7f8:	e13ffe17 	ldw	r4,-8(fp)
8110a7fc:	110a3e00 	call	8110a3e0 <bSpwcGetLinkError>
8110a800:	1000011e 	bne	r2,zero,8110a808 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
8110a804:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110a808:	e13ffe17 	ldw	r4,-8(fp)
8110a80c:	110a4d40 	call	8110a4d4 <bSpwcGetLinkStatus>
8110a810:	1000011e 	bne	r2,zero,8110a818 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
8110a814:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110a818:	e13ffe17 	ldw	r4,-8(fp)
8110a81c:	110a5a40 	call	8110a5a4 <bSpwcGetTimecode>
8110a820:	1000011e 	bne	r2,zero,8110a828 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
8110a824:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110a828:	e0bffd17 	ldw	r2,-12(fp)
}
8110a82c:	e037883a 	mov	sp,fp
8110a830:	dfc00117 	ldw	ra,4(sp)
8110a834:	df000017 	ldw	fp,0(sp)
8110a838:	dec00204 	addi	sp,sp,8
8110a83c:	f800283a 	ret

8110a840 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a840:	defffc04 	addi	sp,sp,-16
8110a844:	de00012e 	bgeu	sp,et,8110a84c <vSpwcWriteReg+0xc>
8110a848:	003b68fa 	trap	3
8110a84c:	df000315 	stw	fp,12(sp)
8110a850:	df000304 	addi	fp,sp,12
8110a854:	e13ffd15 	stw	r4,-12(fp)
8110a858:	e17ffe15 	stw	r5,-8(fp)
8110a85c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a860:	e0bffe17 	ldw	r2,-8(fp)
8110a864:	1085883a 	add	r2,r2,r2
8110a868:	1085883a 	add	r2,r2,r2
8110a86c:	1007883a 	mov	r3,r2
8110a870:	e0bffd17 	ldw	r2,-12(fp)
8110a874:	10c5883a 	add	r2,r2,r3
8110a878:	e0ffff17 	ldw	r3,-4(fp)
8110a87c:	10c00015 	stw	r3,0(r2)
}
8110a880:	0001883a 	nop
8110a884:	e037883a 	mov	sp,fp
8110a888:	df000017 	ldw	fp,0(sp)
8110a88c:	dec00104 	addi	sp,sp,4
8110a890:	f800283a 	ret

8110a894 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a894:	defffc04 	addi	sp,sp,-16
8110a898:	de00012e 	bgeu	sp,et,8110a8a0 <uliSpwcReadReg+0xc>
8110a89c:	003b68fa 	trap	3
8110a8a0:	df000315 	stw	fp,12(sp)
8110a8a4:	df000304 	addi	fp,sp,12
8110a8a8:	e13ffe15 	stw	r4,-8(fp)
8110a8ac:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a8b0:	e0bfff17 	ldw	r2,-4(fp)
8110a8b4:	1085883a 	add	r2,r2,r2
8110a8b8:	1085883a 	add	r2,r2,r2
8110a8bc:	1007883a 	mov	r3,r2
8110a8c0:	e0bffe17 	ldw	r2,-8(fp)
8110a8c4:	10c5883a 	add	r2,r2,r3
8110a8c8:	10800017 	ldw	r2,0(r2)
8110a8cc:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a8d0:	e0bffd17 	ldw	r2,-12(fp)
}
8110a8d4:	e037883a 	mov	sp,fp
8110a8d8:	df000017 	ldw	fp,0(sp)
8110a8dc:	dec00104 	addi	sp,sp,4
8110a8e0:	f800283a 	ret

8110a8e4 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110a8e4:	defffe04 	addi	sp,sp,-8
8110a8e8:	de00012e 	bgeu	sp,et,8110a8f0 <bEnableIsoDrivers+0xc>
8110a8ec:	003b68fa 	trap	3
8110a8f0:	dfc00115 	stw	ra,4(sp)
8110a8f4:	df000015 	stw	fp,0(sp)
8110a8f8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110a8fc:	01400204 	movi	r5,8
8110a900:	01000044 	movi	r4,1
8110a904:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a908:	00800044 	movi	r2,1
}
8110a90c:	e037883a 	mov	sp,fp
8110a910:	dfc00117 	ldw	ra,4(sp)
8110a914:	df000017 	ldw	fp,0(sp)
8110a918:	dec00204 	addi	sp,sp,8
8110a91c:	f800283a 	ret

8110a920 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110a920:	defffe04 	addi	sp,sp,-8
8110a924:	de00012e 	bgeu	sp,et,8110a92c <bDisableIsoDrivers+0xc>
8110a928:	003b68fa 	trap	3
8110a92c:	dfc00115 	stw	ra,4(sp)
8110a930:	df000015 	stw	fp,0(sp)
8110a934:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110a938:	01400204 	movi	r5,8
8110a93c:	0009883a 	mov	r4,zero
8110a940:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a944:	00800044 	movi	r2,1
}
8110a948:	e037883a 	mov	sp,fp
8110a94c:	dfc00117 	ldw	ra,4(sp)
8110a950:	df000017 	ldw	fp,0(sp)
8110a954:	dec00204 	addi	sp,sp,8
8110a958:	f800283a 	ret

8110a95c <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110a95c:	defffe04 	addi	sp,sp,-8
8110a960:	de00012e 	bgeu	sp,et,8110a968 <bEnableLvdsBoard+0xc>
8110a964:	003b68fa 	trap	3
8110a968:	dfc00115 	stw	ra,4(sp)
8110a96c:	df000015 	stw	fp,0(sp)
8110a970:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110a974:	01400104 	movi	r5,4
8110a978:	01000044 	movi	r4,1
8110a97c:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a980:	00800044 	movi	r2,1
}
8110a984:	e037883a 	mov	sp,fp
8110a988:	dfc00117 	ldw	ra,4(sp)
8110a98c:	df000017 	ldw	fp,0(sp)
8110a990:	dec00204 	addi	sp,sp,8
8110a994:	f800283a 	ret

8110a998 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110a998:	defffe04 	addi	sp,sp,-8
8110a99c:	de00012e 	bgeu	sp,et,8110a9a4 <bDisableLvdsBoard+0xc>
8110a9a0:	003b68fa 	trap	3
8110a9a4:	dfc00115 	stw	ra,4(sp)
8110a9a8:	df000015 	stw	fp,0(sp)
8110a9ac:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110a9b0:	01400104 	movi	r5,4
8110a9b4:	0009883a 	mov	r4,zero
8110a9b8:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a9bc:	00800044 	movi	r2,1
}
8110a9c0:	e037883a 	mov	sp,fp
8110a9c4:	dfc00117 	ldw	ra,4(sp)
8110a9c8:	df000017 	ldw	fp,0(sp)
8110a9cc:	dec00204 	addi	sp,sp,8
8110a9d0:	f800283a 	ret

8110a9d4 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110a9d4:	defffd04 	addi	sp,sp,-12
8110a9d8:	de00012e 	bgeu	sp,et,8110a9e0 <bSetPreEmphasys+0xc>
8110a9dc:	003b68fa 	trap	3
8110a9e0:	dfc00215 	stw	ra,8(sp)
8110a9e4:	df000115 	stw	fp,4(sp)
8110a9e8:	df000104 	addi	fp,sp,4
8110a9ec:	2005883a 	mov	r2,r4
8110a9f0:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110a9f4:	e0bfff03 	ldbu	r2,-4(fp)
8110a9f8:	10c00060 	cmpeqi	r3,r2,1
8110a9fc:	18000d1e 	bne	r3,zero,8110aa34 <bSetPreEmphasys+0x60>
8110aa00:	10c00088 	cmpgei	r3,r2,2
8110aa04:	1800021e 	bne	r3,zero,8110aa10 <bSetPreEmphasys+0x3c>
8110aa08:	10000626 	beq	r2,zero,8110aa24 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110aa0c:	00001b06 	br	8110aa7c <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110aa10:	10c000a0 	cmpeqi	r3,r2,2
8110aa14:	18000e1e 	bne	r3,zero,8110aa50 <bSetPreEmphasys+0x7c>
8110aa18:	108000e0 	cmpeqi	r2,r2,3
8110aa1c:	1000131e 	bne	r2,zero,8110aa6c <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110aa20:	00001606 	br	8110aa7c <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110aa24:	014000c4 	movi	r5,3
8110aa28:	0009883a 	mov	r4,zero
8110aa2c:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
      break;
8110aa30:	00001206 	br	8110aa7c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110aa34:	01400084 	movi	r5,2
8110aa38:	0009883a 	mov	r4,zero
8110aa3c:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110aa40:	01400044 	movi	r5,1
8110aa44:	01000044 	movi	r4,1
8110aa48:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
      break;
8110aa4c:	00000b06 	br	8110aa7c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110aa50:	01400044 	movi	r5,1
8110aa54:	0009883a 	mov	r4,zero
8110aa58:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110aa5c:	01400084 	movi	r5,2
8110aa60:	01000044 	movi	r4,1
8110aa64:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
      break;
8110aa68:	00000406 	br	8110aa7c <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110aa6c:	014000c4 	movi	r5,3
8110aa70:	01000044 	movi	r4,1
8110aa74:	110aa940 	call	8110aa94 <bCtrlIoLvdsDrive>
      break;
8110aa78:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110aa7c:	00800044 	movi	r2,1
}
8110aa80:	e037883a 	mov	sp,fp
8110aa84:	dfc00117 	ldw	ra,4(sp)
8110aa88:	df000017 	ldw	fp,0(sp)
8110aa8c:	dec00204 	addi	sp,sp,8
8110aa90:	f800283a 	ret

8110aa94 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110aa94:	defffd04 	addi	sp,sp,-12
8110aa98:	de00012e 	bgeu	sp,et,8110aaa0 <bCtrlIoLvdsDrive+0xc>
8110aa9c:	003b68fa 	trap	3
8110aaa0:	df000215 	stw	fp,8(sp)
8110aaa4:	df000204 	addi	fp,sp,8
8110aaa8:	e13ffe15 	stw	r4,-8(fp)
8110aaac:	2805883a 	mov	r2,r5
8110aab0:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110aab4:	e0bffe17 	ldw	r2,-8(fp)
8110aab8:	1000071e 	bne	r2,zero,8110aad8 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110aabc:	e0bfff03 	ldbu	r2,-4(fp)
8110aac0:	0084303a 	nor	r2,zero,r2
8110aac4:	1007883a 	mov	r3,r2
8110aac8:	d0a00103 	ldbu	r2,-32764(gp)
8110aacc:	1884703a 	and	r2,r3,r2
8110aad0:	d0a00105 	stb	r2,-32764(gp)
8110aad4:	00000406 	br	8110aae8 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110aad8:	d0e00103 	ldbu	r3,-32764(gp)
8110aadc:	e0bfff03 	ldbu	r2,-4(fp)
8110aae0:	1884b03a 	or	r2,r3,r2
8110aae4:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110aae8:	d0a00103 	ldbu	r2,-32764(gp)
8110aaec:	10c03fcc 	andi	r3,r2,255
8110aaf0:	00a00034 	movhi	r2,32768
8110aaf4:	10822804 	addi	r2,r2,2208
8110aaf8:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110aafc:	00800044 	movi	r2,1
}
8110ab00:	e037883a 	mov	sp,fp
8110ab04:	df000017 	ldw	fp,0(sp)
8110ab08:	dec00104 	addi	sp,sp,4
8110ab0c:	f800283a 	ret

8110ab10 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110ab10:	defffa04 	addi	sp,sp,-24
8110ab14:	de00012e 	bgeu	sp,et,8110ab1c <I2C_TestAdress+0xc>
8110ab18:	003b68fa 	trap	3
8110ab1c:	dfc00515 	stw	ra,20(sp)
8110ab20:	df000415 	stw	fp,16(sp)
8110ab24:	df000404 	addi	fp,sp,16
8110ab28:	e13ffd15 	stw	r4,-12(fp)
8110ab2c:	e17ffe15 	stw	r5,-8(fp)
8110ab30:	3005883a 	mov	r2,r6
8110ab34:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110ab38:	00800044 	movi	r2,1
8110ab3c:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ab40:	e17ffe17 	ldw	r5,-8(fp)
8110ab44:	e13ffd17 	ldw	r4,-12(fp)
8110ab48:	110aee00 	call	8110aee0 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110ab4c:	e0bfff03 	ldbu	r2,-4(fp)
8110ab50:	10803fcc 	andi	r2,r2,255
8110ab54:	100d883a 	mov	r6,r2
8110ab58:	e17ffe17 	ldw	r5,-8(fp)
8110ab5c:	e13ffd17 	ldw	r4,-12(fp)
8110ab60:	110aff40 	call	8110aff4 <i2c_write>
8110ab64:	1000011e 	bne	r2,zero,8110ab6c <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110ab68:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ab6c:	e17ffe17 	ldw	r5,-8(fp)
8110ab70:	e13ffd17 	ldw	r4,-12(fp)
8110ab74:	110af740 	call	8110af74 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ab78:	0106d604 	movi	r4,7000
8110ab7c:	1137a780 	call	81137a78 <usleep>
    
    return bSuccess;
8110ab80:	e0bffc17 	ldw	r2,-16(fp)

}
8110ab84:	e037883a 	mov	sp,fp
8110ab88:	dfc00117 	ldw	ra,4(sp)
8110ab8c:	df000017 	ldw	fp,0(sp)
8110ab90:	dec00204 	addi	sp,sp,8
8110ab94:	f800283a 	ret

8110ab98 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110ab98:	defff804 	addi	sp,sp,-32
8110ab9c:	de00012e 	bgeu	sp,et,8110aba4 <I2C_Write+0xc>
8110aba0:	003b68fa 	trap	3
8110aba4:	dfc00715 	stw	ra,28(sp)
8110aba8:	df000615 	stw	fp,24(sp)
8110abac:	df000604 	addi	fp,sp,24
8110abb0:	e13ffb15 	stw	r4,-20(fp)
8110abb4:	e17ffc15 	stw	r5,-16(fp)
8110abb8:	3009883a 	mov	r4,r6
8110abbc:	3807883a 	mov	r3,r7
8110abc0:	e0800217 	ldw	r2,8(fp)
8110abc4:	e13ffd05 	stb	r4,-12(fp)
8110abc8:	e0fffe05 	stb	r3,-8(fp)
8110abcc:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110abd0:	00800044 	movi	r2,1
8110abd4:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110abd8:	e17ffc17 	ldw	r5,-16(fp)
8110abdc:	e13ffb17 	ldw	r4,-20(fp)
8110abe0:	110aee00 	call	8110aee0 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110abe4:	e0bffd03 	ldbu	r2,-12(fp)
8110abe8:	10803fcc 	andi	r2,r2,255
8110abec:	100d883a 	mov	r6,r2
8110abf0:	e17ffc17 	ldw	r5,-16(fp)
8110abf4:	e13ffb17 	ldw	r4,-20(fp)
8110abf8:	110aff40 	call	8110aff4 <i2c_write>
8110abfc:	1000011e 	bne	r2,zero,8110ac04 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110ac00:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110ac04:	e0bffa17 	ldw	r2,-24(fp)
8110ac08:	10000726 	beq	r2,zero,8110ac28 <I2C_Write+0x90>
8110ac0c:	e0bffe03 	ldbu	r2,-8(fp)
8110ac10:	100d883a 	mov	r6,r2
8110ac14:	e17ffc17 	ldw	r5,-16(fp)
8110ac18:	e13ffb17 	ldw	r4,-20(fp)
8110ac1c:	110aff40 	call	8110aff4 <i2c_write>
8110ac20:	1000011e 	bne	r2,zero,8110ac28 <I2C_Write+0x90>
        bSuccess = FALSE;
8110ac24:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110ac28:	e0bffa17 	ldw	r2,-24(fp)
8110ac2c:	10000726 	beq	r2,zero,8110ac4c <I2C_Write+0xb4>
8110ac30:	e0bfff03 	ldbu	r2,-4(fp)
8110ac34:	100d883a 	mov	r6,r2
8110ac38:	e17ffc17 	ldw	r5,-16(fp)
8110ac3c:	e13ffb17 	ldw	r4,-20(fp)
8110ac40:	110aff40 	call	8110aff4 <i2c_write>
8110ac44:	1000011e 	bne	r2,zero,8110ac4c <I2C_Write+0xb4>
        bSuccess = FALSE;
8110ac48:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ac4c:	e17ffc17 	ldw	r5,-16(fp)
8110ac50:	e13ffb17 	ldw	r4,-20(fp)
8110ac54:	110af740 	call	8110af74 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ac58:	0106d604 	movi	r4,7000
8110ac5c:	1137a780 	call	81137a78 <usleep>
    
    return bSuccess;
8110ac60:	e0bffa17 	ldw	r2,-24(fp)

}
8110ac64:	e037883a 	mov	sp,fp
8110ac68:	dfc00117 	ldw	ra,4(sp)
8110ac6c:	df000017 	ldw	fp,0(sp)
8110ac70:	dec00204 	addi	sp,sp,8
8110ac74:	f800283a 	ret

8110ac78 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110ac78:	defff904 	addi	sp,sp,-28
8110ac7c:	de00012e 	bgeu	sp,et,8110ac84 <I2C_Read+0xc>
8110ac80:	003b68fa 	trap	3
8110ac84:	dfc00615 	stw	ra,24(sp)
8110ac88:	df000515 	stw	fp,20(sp)
8110ac8c:	df000504 	addi	fp,sp,20
8110ac90:	e13ffc15 	stw	r4,-16(fp)
8110ac94:	e17ffd15 	stw	r5,-12(fp)
8110ac98:	3007883a 	mov	r3,r6
8110ac9c:	3805883a 	mov	r2,r7
8110aca0:	e0fffe05 	stb	r3,-8(fp)
8110aca4:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110aca8:	00800044 	movi	r2,1
8110acac:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110acb0:	e17ffd17 	ldw	r5,-12(fp)
8110acb4:	e13ffc17 	ldw	r4,-16(fp)
8110acb8:	110aee00 	call	8110aee0 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110acbc:	e0bffe03 	ldbu	r2,-8(fp)
8110acc0:	10803fcc 	andi	r2,r2,255
8110acc4:	100d883a 	mov	r6,r2
8110acc8:	e17ffd17 	ldw	r5,-12(fp)
8110accc:	e13ffc17 	ldw	r4,-16(fp)
8110acd0:	110aff40 	call	8110aff4 <i2c_write>
8110acd4:	1000011e 	bne	r2,zero,8110acdc <I2C_Read+0x64>
        bSuccess = FALSE;
8110acd8:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110acdc:	e0bffb17 	ldw	r2,-20(fp)
8110ace0:	10000726 	beq	r2,zero,8110ad00 <I2C_Read+0x88>
8110ace4:	e0bfff03 	ldbu	r2,-4(fp)
8110ace8:	100d883a 	mov	r6,r2
8110acec:	e17ffd17 	ldw	r5,-12(fp)
8110acf0:	e13ffc17 	ldw	r4,-16(fp)
8110acf4:	110aff40 	call	8110aff4 <i2c_write>
8110acf8:	1000011e 	bne	r2,zero,8110ad00 <I2C_Read+0x88>
        bSuccess = FALSE;
8110acfc:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110ad00:	e17ffd17 	ldw	r5,-12(fp)
8110ad04:	e13ffc17 	ldw	r4,-16(fp)
8110ad08:	110aee00 	call	8110aee0 <i2c_start>
    DeviceAddr |= 1; // Read
8110ad0c:	e0bffe03 	ldbu	r2,-8(fp)
8110ad10:	10800054 	ori	r2,r2,1
8110ad14:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110ad18:	e0bffb17 	ldw	r2,-20(fp)
8110ad1c:	10000826 	beq	r2,zero,8110ad40 <I2C_Read+0xc8>
8110ad20:	e0bffe03 	ldbu	r2,-8(fp)
8110ad24:	10803fcc 	andi	r2,r2,255
8110ad28:	100d883a 	mov	r6,r2
8110ad2c:	e17ffd17 	ldw	r5,-12(fp)
8110ad30:	e13ffc17 	ldw	r4,-16(fp)
8110ad34:	110aff40 	call	8110aff4 <i2c_write>
8110ad38:	1000011e 	bne	r2,zero,8110ad40 <I2C_Read+0xc8>
        bSuccess = FALSE;
8110ad3c:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ad40:	e0bffb17 	ldw	r2,-20(fp)
8110ad44:	10000526 	beq	r2,zero,8110ad5c <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110ad48:	000f883a 	mov	r7,zero
8110ad4c:	e1800217 	ldw	r6,8(fp)
8110ad50:	e17ffd17 	ldw	r5,-12(fp)
8110ad54:	e13ffc17 	ldw	r4,-16(fp)
8110ad58:	110b12c0 	call	8110b12c <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110ad5c:	e17ffd17 	ldw	r5,-12(fp)
8110ad60:	e13ffc17 	ldw	r4,-16(fp)
8110ad64:	110af740 	call	8110af74 <i2c_stop>
    
    return bSuccess;
8110ad68:	e0bffb17 	ldw	r2,-20(fp)
}
8110ad6c:	e037883a 	mov	sp,fp
8110ad70:	dfc00117 	ldw	ra,4(sp)
8110ad74:	df000017 	ldw	fp,0(sp)
8110ad78:	dec00204 	addi	sp,sp,8
8110ad7c:	f800283a 	ret

8110ad80 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110ad80:	defff604 	addi	sp,sp,-40
8110ad84:	de00012e 	bgeu	sp,et,8110ad8c <I2C_MultipleRead+0xc>
8110ad88:	003b68fa 	trap	3
8110ad8c:	dfc00915 	stw	ra,36(sp)
8110ad90:	df000815 	stw	fp,32(sp)
8110ad94:	df000804 	addi	fp,sp,32
8110ad98:	e13ffb15 	stw	r4,-20(fp)
8110ad9c:	e17ffc15 	stw	r5,-16(fp)
8110ada0:	3007883a 	mov	r3,r6
8110ada4:	e1fffe15 	stw	r7,-8(fp)
8110ada8:	e0800217 	ldw	r2,8(fp)
8110adac:	e0fffd05 	stb	r3,-12(fp)
8110adb0:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110adb4:	00800044 	movi	r2,1
8110adb8:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110adbc:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110adc0:	e17ffc17 	ldw	r5,-16(fp)
8110adc4:	e13ffb17 	ldw	r4,-20(fp)
8110adc8:	110aee00 	call	8110aee0 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110adcc:	e0bffd03 	ldbu	r2,-12(fp)
8110add0:	10803fcc 	andi	r2,r2,255
8110add4:	100d883a 	mov	r6,r2
8110add8:	e17ffc17 	ldw	r5,-16(fp)
8110addc:	e13ffb17 	ldw	r4,-20(fp)
8110ade0:	110aff40 	call	8110aff4 <i2c_write>
8110ade4:	1000011e 	bne	r2,zero,8110adec <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110ade8:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110adec:	e0bff917 	ldw	r2,-28(fp)
8110adf0:	10000726 	beq	r2,zero,8110ae10 <I2C_MultipleRead+0x90>
8110adf4:	e0bffa03 	ldbu	r2,-24(fp)
8110adf8:	100d883a 	mov	r6,r2
8110adfc:	e17ffc17 	ldw	r5,-16(fp)
8110ae00:	e13ffb17 	ldw	r4,-20(fp)
8110ae04:	110aff40 	call	8110aff4 <i2c_write>
8110ae08:	1000011e 	bne	r2,zero,8110ae10 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110ae0c:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110ae10:	e0bff917 	ldw	r2,-28(fp)
8110ae14:	10000326 	beq	r2,zero,8110ae24 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110ae18:	e17ffc17 	ldw	r5,-16(fp)
8110ae1c:	e13ffb17 	ldw	r4,-20(fp)
8110ae20:	110aee00 	call	8110aee0 <i2c_start>
    DeviceAddr |= 1; // Read
8110ae24:	e0bffd03 	ldbu	r2,-12(fp)
8110ae28:	10800054 	ori	r2,r2,1
8110ae2c:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110ae30:	e0bff917 	ldw	r2,-28(fp)
8110ae34:	10000826 	beq	r2,zero,8110ae58 <I2C_MultipleRead+0xd8>
8110ae38:	e0bffd03 	ldbu	r2,-12(fp)
8110ae3c:	10803fcc 	andi	r2,r2,255
8110ae40:	100d883a 	mov	r6,r2
8110ae44:	e17ffc17 	ldw	r5,-16(fp)
8110ae48:	e13ffb17 	ldw	r4,-20(fp)
8110ae4c:	110aff40 	call	8110aff4 <i2c_write>
8110ae50:	1000011e 	bne	r2,zero,8110ae58 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110ae54:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ae58:	e0bff917 	ldw	r2,-28(fp)
8110ae5c:	10001726 	beq	r2,zero,8110aebc <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110ae60:	e03ff815 	stw	zero,-32(fp)
8110ae64:	00001006 	br	8110aea8 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110ae68:	e0bff817 	ldw	r2,-32(fp)
8110ae6c:	e0fffe17 	ldw	r3,-8(fp)
8110ae70:	1889883a 	add	r4,r3,r2
8110ae74:	e0bfff0b 	ldhu	r2,-4(fp)
8110ae78:	10ffffc4 	addi	r3,r2,-1
8110ae7c:	e0bff817 	ldw	r2,-32(fp)
8110ae80:	1884c03a 	cmpne	r2,r3,r2
8110ae84:	10803fcc 	andi	r2,r2,255
8110ae88:	100f883a 	mov	r7,r2
8110ae8c:	200d883a 	mov	r6,r4
8110ae90:	e17ffc17 	ldw	r5,-16(fp)
8110ae94:	e13ffb17 	ldw	r4,-20(fp)
8110ae98:	110b12c0 	call	8110b12c <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110ae9c:	e0bff817 	ldw	r2,-32(fp)
8110aea0:	10800044 	addi	r2,r2,1
8110aea4:	e0bff815 	stw	r2,-32(fp)
8110aea8:	e0bfff0b 	ldhu	r2,-4(fp)
8110aeac:	e0fff817 	ldw	r3,-32(fp)
8110aeb0:	1880020e 	bge	r3,r2,8110aebc <I2C_MultipleRead+0x13c>
8110aeb4:	e0bff917 	ldw	r2,-28(fp)
8110aeb8:	103feb1e 	bne	r2,zero,8110ae68 <__reset+0xfb0eae68>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110aebc:	e17ffc17 	ldw	r5,-16(fp)
8110aec0:	e13ffb17 	ldw	r4,-20(fp)
8110aec4:	110af740 	call	8110af74 <i2c_stop>
    
    return bSuccess;    
8110aec8:	e0bff917 	ldw	r2,-28(fp)
    
}
8110aecc:	e037883a 	mov	sp,fp
8110aed0:	dfc00117 	ldw	ra,4(sp)
8110aed4:	df000017 	ldw	fp,0(sp)
8110aed8:	dec00204 	addi	sp,sp,8
8110aedc:	f800283a 	ret

8110aee0 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110aee0:	defffc04 	addi	sp,sp,-16
8110aee4:	de00012e 	bgeu	sp,et,8110aeec <i2c_start+0xc>
8110aee8:	003b68fa 	trap	3
8110aeec:	dfc00315 	stw	ra,12(sp)
8110aef0:	df000215 	stw	fp,8(sp)
8110aef4:	df000204 	addi	fp,sp,8
8110aef8:	e13ffe15 	stw	r4,-8(fp)
8110aefc:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110af00:	e0bfff17 	ldw	r2,-4(fp)
8110af04:	10800104 	addi	r2,r2,4
8110af08:	1007883a 	mov	r3,r2
8110af0c:	00800044 	movi	r2,1
8110af10:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110af14:	e0bfff17 	ldw	r2,-4(fp)
8110af18:	00c00044 	movi	r3,1
8110af1c:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110af20:	e0bffe17 	ldw	r2,-8(fp)
8110af24:	00c00044 	movi	r3,1
8110af28:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110af2c:	01000044 	movi	r4,1
8110af30:	1137a780 	call	81137a78 <usleep>
     
    SDA_LOW(data_base); // data low
8110af34:	e0bfff17 	ldw	r2,-4(fp)
8110af38:	0007883a 	mov	r3,zero
8110af3c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110af40:	01000044 	movi	r4,1
8110af44:	1137a780 	call	81137a78 <usleep>
    SCL_LOW(clk_base); // clock low
8110af48:	e0bffe17 	ldw	r2,-8(fp)
8110af4c:	0007883a 	mov	r3,zero
8110af50:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110af54:	01000044 	movi	r4,1
8110af58:	1137a780 	call	81137a78 <usleep>
}
8110af5c:	0001883a 	nop
8110af60:	e037883a 	mov	sp,fp
8110af64:	dfc00117 	ldw	ra,4(sp)
8110af68:	df000017 	ldw	fp,0(sp)
8110af6c:	dec00204 	addi	sp,sp,8
8110af70:	f800283a 	ret

8110af74 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110af74:	defffc04 	addi	sp,sp,-16
8110af78:	de00012e 	bgeu	sp,et,8110af80 <i2c_stop+0xc>
8110af7c:	003b68fa 	trap	3
8110af80:	dfc00315 	stw	ra,12(sp)
8110af84:	df000215 	stw	fp,8(sp)
8110af88:	df000204 	addi	fp,sp,8
8110af8c:	e13ffe15 	stw	r4,-8(fp)
8110af90:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110af94:	e0bfff17 	ldw	r2,-4(fp)
8110af98:	10800104 	addi	r2,r2,4
8110af9c:	1007883a 	mov	r3,r2
8110afa0:	00800044 	movi	r2,1
8110afa4:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110afa8:	e0bfff17 	ldw	r2,-4(fp)
8110afac:	0007883a 	mov	r3,zero
8110afb0:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110afb4:	e0bffe17 	ldw	r2,-8(fp)
8110afb8:	00c00044 	movi	r3,1
8110afbc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110afc0:	01000044 	movi	r4,1
8110afc4:	1137a780 	call	81137a78 <usleep>
    SDA_HIGH(data_base); // data high
8110afc8:	e0bfff17 	ldw	r2,-4(fp)
8110afcc:	00c00044 	movi	r3,1
8110afd0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110afd4:	01000044 	movi	r4,1
8110afd8:	1137a780 	call	81137a78 <usleep>
    

    
}
8110afdc:	0001883a 	nop
8110afe0:	e037883a 	mov	sp,fp
8110afe4:	dfc00117 	ldw	ra,4(sp)
8110afe8:	df000017 	ldw	fp,0(sp)
8110afec:	dec00204 	addi	sp,sp,8
8110aff0:	f800283a 	ret

8110aff4 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110aff4:	defff804 	addi	sp,sp,-32
8110aff8:	de00012e 	bgeu	sp,et,8110b000 <i2c_write+0xc>
8110affc:	003b68fa 	trap	3
8110b000:	dfc00715 	stw	ra,28(sp)
8110b004:	df000615 	stw	fp,24(sp)
8110b008:	df000604 	addi	fp,sp,24
8110b00c:	e13ffd15 	stw	r4,-12(fp)
8110b010:	e17ffe15 	stw	r5,-8(fp)
8110b014:	3005883a 	mov	r2,r6
8110b018:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110b01c:	00bfe004 	movi	r2,-128
8110b020:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110b024:	e0bffe17 	ldw	r2,-8(fp)
8110b028:	10800104 	addi	r2,r2,4
8110b02c:	1007883a 	mov	r3,r2
8110b030:	00800044 	movi	r2,1
8110b034:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110b038:	e03ffb15 	stw	zero,-20(fp)
8110b03c:	00001f06 	br	8110b0bc <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b040:	e0bffd17 	ldw	r2,-12(fp)
8110b044:	0007883a 	mov	r3,zero
8110b048:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110b04c:	e0ffff03 	ldbu	r3,-4(fp)
8110b050:	e0bffa03 	ldbu	r2,-24(fp)
8110b054:	1884703a 	and	r2,r3,r2
8110b058:	10803fcc 	andi	r2,r2,255
8110b05c:	10000426 	beq	r2,zero,8110b070 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110b060:	e0bffe17 	ldw	r2,-8(fp)
8110b064:	00c00044 	movi	r3,1
8110b068:	10c00035 	stwio	r3,0(r2)
8110b06c:	00000306 	br	8110b07c <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110b070:	e0bffe17 	ldw	r2,-8(fp)
8110b074:	0007883a 	mov	r3,zero
8110b078:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110b07c:	e0bffa03 	ldbu	r2,-24(fp)
8110b080:	1004d07a 	srli	r2,r2,1
8110b084:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110b088:	e0bffd17 	ldw	r2,-12(fp)
8110b08c:	00c00044 	movi	r3,1
8110b090:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b094:	01000044 	movi	r4,1
8110b098:	1137a780 	call	81137a78 <usleep>
        SCL_LOW(clk_base);
8110b09c:	e0bffd17 	ldw	r2,-12(fp)
8110b0a0:	0007883a 	mov	r3,zero
8110b0a4:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b0a8:	01000044 	movi	r4,1
8110b0ac:	1137a780 	call	81137a78 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110b0b0:	e0bffb17 	ldw	r2,-20(fp)
8110b0b4:	10800044 	addi	r2,r2,1
8110b0b8:	e0bffb15 	stw	r2,-20(fp)
8110b0bc:	e0bffb17 	ldw	r2,-20(fp)
8110b0c0:	10800210 	cmplti	r2,r2,8
8110b0c4:	103fde1e 	bne	r2,zero,8110b040 <__reset+0xfb0eb040>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110b0c8:	e0bffe17 	ldw	r2,-8(fp)
8110b0cc:	10800104 	addi	r2,r2,4
8110b0d0:	0007883a 	mov	r3,zero
8110b0d4:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110b0d8:	e0bffd17 	ldw	r2,-12(fp)
8110b0dc:	00c00044 	movi	r3,1
8110b0e0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110b0e4:	01000044 	movi	r4,1
8110b0e8:	1137a780 	call	81137a78 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110b0ec:	e0bffe17 	ldw	r2,-8(fp)
8110b0f0:	10800037 	ldwio	r2,0(r2)
8110b0f4:	1005003a 	cmpeq	r2,r2,zero
8110b0f8:	10803fcc 	andi	r2,r2,255
8110b0fc:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110b100:	e0bffd17 	ldw	r2,-12(fp)
8110b104:	0007883a 	mov	r3,zero
8110b108:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b10c:	01000044 	movi	r4,1
8110b110:	1137a780 	call	81137a78 <usleep>
    return bAck;
8110b114:	e0bffc17 	ldw	r2,-16(fp)
}    
8110b118:	e037883a 	mov	sp,fp
8110b11c:	dfc00117 	ldw	ra,4(sp)
8110b120:	df000017 	ldw	fp,0(sp)
8110b124:	dec00204 	addi	sp,sp,8
8110b128:	f800283a 	ret

8110b12c <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110b12c:	defff804 	addi	sp,sp,-32
8110b130:	de00012e 	bgeu	sp,et,8110b138 <i2c_read+0xc>
8110b134:	003b68fa 	trap	3
8110b138:	dfc00715 	stw	ra,28(sp)
8110b13c:	df000615 	stw	fp,24(sp)
8110b140:	df000604 	addi	fp,sp,24
8110b144:	e13ffc15 	stw	r4,-16(fp)
8110b148:	e17ffd15 	stw	r5,-12(fp)
8110b14c:	e1bffe15 	stw	r6,-8(fp)
8110b150:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110b154:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110b158:	e0bffd17 	ldw	r2,-12(fp)
8110b15c:	10800104 	addi	r2,r2,4
8110b160:	0007883a 	mov	r3,zero
8110b164:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110b168:	e0bffc17 	ldw	r2,-16(fp)
8110b16c:	0007883a 	mov	r3,zero
8110b170:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b174:	01000044 	movi	r4,1
8110b178:	1137a780 	call	81137a78 <usleep>

    for(i=0;i<8;i++){
8110b17c:	e03ffb15 	stw	zero,-20(fp)
8110b180:	00001606 	br	8110b1dc <i2c_read+0xb0>
        Data <<= 1;
8110b184:	e0bffa03 	ldbu	r2,-24(fp)
8110b188:	1085883a 	add	r2,r2,r2
8110b18c:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110b190:	e0bffc17 	ldw	r2,-16(fp)
8110b194:	00c00044 	movi	r3,1
8110b198:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b19c:	01000044 	movi	r4,1
8110b1a0:	1137a780 	call	81137a78 <usleep>
        if (SDA_READ(data_base))  // read data   
8110b1a4:	e0bffd17 	ldw	r2,-12(fp)
8110b1a8:	10800037 	ldwio	r2,0(r2)
8110b1ac:	10000326 	beq	r2,zero,8110b1bc <i2c_read+0x90>
            Data |= 0x01;
8110b1b0:	e0bffa03 	ldbu	r2,-24(fp)
8110b1b4:	10800054 	ori	r2,r2,1
8110b1b8:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110b1bc:	e0bffc17 	ldw	r2,-16(fp)
8110b1c0:	0007883a 	mov	r3,zero
8110b1c4:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b1c8:	01000044 	movi	r4,1
8110b1cc:	1137a780 	call	81137a78 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110b1d0:	e0bffb17 	ldw	r2,-20(fp)
8110b1d4:	10800044 	addi	r2,r2,1
8110b1d8:	e0bffb15 	stw	r2,-20(fp)
8110b1dc:	e0bffb17 	ldw	r2,-20(fp)
8110b1e0:	10800210 	cmplti	r2,r2,8
8110b1e4:	103fe71e 	bne	r2,zero,8110b184 <__reset+0xfb0eb184>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b1e8:	e0bffc17 	ldw	r2,-16(fp)
8110b1ec:	0007883a 	mov	r3,zero
8110b1f0:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110b1f4:	e0bffd17 	ldw	r2,-12(fp)
8110b1f8:	10800104 	addi	r2,r2,4
8110b1fc:	1007883a 	mov	r3,r2
8110b200:	00800044 	movi	r2,1
8110b204:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110b208:	e0bfff17 	ldw	r2,-4(fp)
8110b20c:	10000426 	beq	r2,zero,8110b220 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110b210:	e0bffd17 	ldw	r2,-12(fp)
8110b214:	0007883a 	mov	r3,zero
8110b218:	10c00035 	stwio	r3,0(r2)
8110b21c:	00000306 	br	8110b22c <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110b220:	e0bffd17 	ldw	r2,-12(fp)
8110b224:	00c00044 	movi	r3,1
8110b228:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110b22c:	e0bffc17 	ldw	r2,-16(fp)
8110b230:	00c00044 	movi	r3,1
8110b234:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110b238:	01000044 	movi	r4,1
8110b23c:	1137a780 	call	81137a78 <usleep>
    SCL_LOW(clk_base); // clock low
8110b240:	e0bffc17 	ldw	r2,-16(fp)
8110b244:	0007883a 	mov	r3,zero
8110b248:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b24c:	01000044 	movi	r4,1
8110b250:	1137a780 	call	81137a78 <usleep>
    SDA_LOW(data_base);  // data low
8110b254:	e0bffd17 	ldw	r2,-12(fp)
8110b258:	0007883a 	mov	r3,zero
8110b25c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110b260:	01000044 	movi	r4,1
8110b264:	1137a780 	call	81137a78 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110b268:	e0bffe17 	ldw	r2,-8(fp)
8110b26c:	e0fffa03 	ldbu	r3,-24(fp)
8110b270:	10c00005 	stb	r3,0(r2)
}
8110b274:	0001883a 	nop
8110b278:	e037883a 	mov	sp,fp
8110b27c:	dfc00117 	ldw	ra,4(sp)
8110b280:	df000017 	ldw	fp,0(sp)
8110b284:	dec00204 	addi	sp,sp,8
8110b288:	f800283a 	ret

8110b28c <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110b28c:	defffd04 	addi	sp,sp,-12
8110b290:	de00012e 	bgeu	sp,et,8110b298 <bSetBoardLeds+0xc>
8110b294:	003b68fa 	trap	3
8110b298:	df000215 	stw	fp,8(sp)
8110b29c:	df000204 	addi	fp,sp,8
8110b2a0:	e13ffe15 	stw	r4,-8(fp)
8110b2a4:	2805883a 	mov	r2,r5
8110b2a8:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110b2ac:	e0bffe17 	ldw	r2,-8(fp)
8110b2b0:	10800058 	cmpnei	r2,r2,1
8110b2b4:	1000071e 	bne	r2,zero,8110b2d4 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110b2b8:	e0bfff03 	ldbu	r2,-4(fp)
8110b2bc:	0084303a 	nor	r2,zero,r2
8110b2c0:	1007883a 	mov	r3,r2
8110b2c4:	d0a05003 	ldbu	r2,-32448(gp)
8110b2c8:	1884703a 	and	r2,r3,r2
8110b2cc:	d0a05005 	stb	r2,-32448(gp)
8110b2d0:	00000406 	br	8110b2e4 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110b2d4:	d0e05003 	ldbu	r3,-32448(gp)
8110b2d8:	e0bfff03 	ldbu	r2,-4(fp)
8110b2dc:	1884b03a 	or	r2,r3,r2
8110b2e0:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110b2e4:	d0a05003 	ldbu	r2,-32448(gp)
8110b2e8:	10c03fcc 	andi	r3,r2,255
8110b2ec:	00a00034 	movhi	r2,32768
8110b2f0:	10827404 	addi	r2,r2,2512
8110b2f4:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b2f8:	00800044 	movi	r2,1
}
8110b2fc:	e037883a 	mov	sp,fp
8110b300:	df000017 	ldw	fp,0(sp)
8110b304:	dec00104 	addi	sp,sp,4
8110b308:	f800283a 	ret

8110b30c <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110b30c:	defffd04 	addi	sp,sp,-12
8110b310:	de00012e 	bgeu	sp,et,8110b318 <bSetPainelLeds+0xc>
8110b314:	003b68fa 	trap	3
8110b318:	df000215 	stw	fp,8(sp)
8110b31c:	df000204 	addi	fp,sp,8
8110b320:	e13ffe15 	stw	r4,-8(fp)
8110b324:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110b328:	e0bffe17 	ldw	r2,-8(fp)
8110b32c:	10800058 	cmpnei	r2,r2,1
8110b330:	1000051e 	bne	r2,zero,8110b348 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110b334:	d0e00217 	ldw	r3,-32760(gp)
8110b338:	e0bfff17 	ldw	r2,-4(fp)
8110b33c:	1884b03a 	or	r2,r3,r2
8110b340:	d0a00215 	stw	r2,-32760(gp)
8110b344:	00000506 	br	8110b35c <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110b348:	e0bfff17 	ldw	r2,-4(fp)
8110b34c:	0086303a 	nor	r3,zero,r2
8110b350:	d0a00217 	ldw	r2,-32760(gp)
8110b354:	1884703a 	and	r2,r3,r2
8110b358:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110b35c:	d0a00217 	ldw	r2,-32760(gp)
8110b360:	1007883a 	mov	r3,r2
8110b364:	00a00034 	movhi	r2,32768
8110b368:	10824004 	addi	r2,r2,2304
8110b36c:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b370:	00800044 	movi	r2,1
}
8110b374:	e037883a 	mov	sp,fp
8110b378:	df000017 	ldw	fp,0(sp)
8110b37c:	dec00104 	addi	sp,sp,4
8110b380:	f800283a 	ret

8110b384 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110b384:	defffc04 	addi	sp,sp,-16
8110b388:	de00012e 	bgeu	sp,et,8110b390 <msgdma_write_extended_descriptor+0xc>
8110b38c:	003b68fa 	trap	3
8110b390:	df000315 	stw	fp,12(sp)
8110b394:	df000304 	addi	fp,sp,12
8110b398:	e13ffd15 	stw	r4,-12(fp)
8110b39c:	e17ffe15 	stw	r5,-8(fp)
8110b3a0:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110b3a4:	e0bffd17 	ldw	r2,-12(fp)
8110b3a8:	10800037 	ldwio	r2,0(r2)
8110b3ac:	1080010c 	andi	r2,r2,4
8110b3b0:	10000226 	beq	r2,zero,8110b3bc <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110b3b4:	00bff904 	movi	r2,-28
8110b3b8:	00003d06 	br	8110b4b0 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110b3bc:	e0bfff17 	ldw	r2,-4(fp)
8110b3c0:	10800017 	ldw	r2,0(r2)
8110b3c4:	1007883a 	mov	r3,r2
8110b3c8:	e0bffe17 	ldw	r2,-8(fp)
8110b3cc:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110b3d0:	e0bffe17 	ldw	r2,-8(fp)
8110b3d4:	10800104 	addi	r2,r2,4
8110b3d8:	e0ffff17 	ldw	r3,-4(fp)
8110b3dc:	18c00117 	ldw	r3,4(r3)
8110b3e0:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110b3e4:	e0bffe17 	ldw	r2,-8(fp)
8110b3e8:	10800204 	addi	r2,r2,8
8110b3ec:	e0ffff17 	ldw	r3,-4(fp)
8110b3f0:	18c00217 	ldw	r3,8(r3)
8110b3f4:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110b3f8:	e0bffe17 	ldw	r2,-8(fp)
8110b3fc:	10800304 	addi	r2,r2,12
8110b400:	e0ffff17 	ldw	r3,-4(fp)
8110b404:	18c0030b 	ldhu	r3,12(r3)
8110b408:	18ffffcc 	andi	r3,r3,65535
8110b40c:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110b410:	e0bffe17 	ldw	r2,-8(fp)
8110b414:	10800384 	addi	r2,r2,14
8110b418:	e0ffff17 	ldw	r3,-4(fp)
8110b41c:	18c00383 	ldbu	r3,14(r3)
8110b420:	18c03fcc 	andi	r3,r3,255
8110b424:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110b428:	e0bffe17 	ldw	r2,-8(fp)
8110b42c:	108003c4 	addi	r2,r2,15
8110b430:	e0ffff17 	ldw	r3,-4(fp)
8110b434:	18c003c3 	ldbu	r3,15(r3)
8110b438:	18c03fcc 	andi	r3,r3,255
8110b43c:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110b440:	e0bffe17 	ldw	r2,-8(fp)
8110b444:	10800404 	addi	r2,r2,16
8110b448:	e0ffff17 	ldw	r3,-4(fp)
8110b44c:	18c0040b 	ldhu	r3,16(r3)
8110b450:	18ffffcc 	andi	r3,r3,65535
8110b454:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110b458:	e0bffe17 	ldw	r2,-8(fp)
8110b45c:	10800484 	addi	r2,r2,18
8110b460:	e0ffff17 	ldw	r3,-4(fp)
8110b464:	18c0048b 	ldhu	r3,18(r3)
8110b468:	18ffffcc 	andi	r3,r3,65535
8110b46c:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110b470:	e0bffe17 	ldw	r2,-8(fp)
8110b474:	10800504 	addi	r2,r2,20
8110b478:	e0ffff17 	ldw	r3,-4(fp)
8110b47c:	18c00517 	ldw	r3,20(r3)
8110b480:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110b484:	e0bffe17 	ldw	r2,-8(fp)
8110b488:	10800604 	addi	r2,r2,24
8110b48c:	e0ffff17 	ldw	r3,-4(fp)
8110b490:	18c00617 	ldw	r3,24(r3)
8110b494:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110b498:	e0bffe17 	ldw	r2,-8(fp)
8110b49c:	10800704 	addi	r2,r2,28
8110b4a0:	e0ffff17 	ldw	r3,-4(fp)
8110b4a4:	18c00717 	ldw	r3,28(r3)
8110b4a8:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110b4ac:	0005883a 	mov	r2,zero
}
8110b4b0:	e037883a 	mov	sp,fp
8110b4b4:	df000017 	ldw	fp,0(sp)
8110b4b8:	dec00104 	addi	sp,sp,4
8110b4bc:	f800283a 	ret

8110b4c0 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110b4c0:	defff604 	addi	sp,sp,-40
8110b4c4:	de00012e 	bgeu	sp,et,8110b4cc <msgdma_construct_extended_descriptor+0xc>
8110b4c8:	003b68fa 	trap	3
8110b4cc:	df000915 	stw	fp,36(sp)
8110b4d0:	df000904 	addi	fp,sp,36
8110b4d4:	e13ff715 	stw	r4,-36(fp)
8110b4d8:	e17ff815 	stw	r5,-32(fp)
8110b4dc:	e1bff915 	stw	r6,-28(fp)
8110b4e0:	e1fffa15 	stw	r7,-24(fp)
8110b4e4:	e1800517 	ldw	r6,20(fp)
8110b4e8:	e1400617 	ldw	r5,24(fp)
8110b4ec:	e1000717 	ldw	r4,28(fp)
8110b4f0:	e0c00817 	ldw	r3,32(fp)
8110b4f4:	e0800917 	ldw	r2,36(fp)
8110b4f8:	e1bffb0d 	sth	r6,-20(fp)
8110b4fc:	e17ffc05 	stb	r5,-16(fp)
8110b500:	e13ffd05 	stb	r4,-12(fp)
8110b504:	e0fffe0d 	sth	r3,-8(fp)
8110b508:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110b50c:	e0bff717 	ldw	r2,-36(fp)
8110b510:	10c01217 	ldw	r3,72(r2)
8110b514:	e0800117 	ldw	r2,4(fp)
8110b518:	18801936 	bltu	r3,r2,8110b580 <msgdma_construct_extended_descriptor+0xc0>
8110b51c:	e13ff717 	ldw	r4,-36(fp)
8110b520:	20801317 	ldw	r2,76(r4)
8110b524:	20c01417 	ldw	r3,80(r4)
8110b528:	e13ffe0b 	ldhu	r4,-8(fp)
8110b52c:	213fffcc 	andi	r4,r4,65535
8110b530:	2015883a 	mov	r10,r4
8110b534:	0017883a 	mov	r11,zero
8110b538:	1ac01136 	bltu	r3,r11,8110b580 <msgdma_construct_extended_descriptor+0xc0>
8110b53c:	58c0011e 	bne	r11,r3,8110b544 <msgdma_construct_extended_descriptor+0x84>
8110b540:	12800f36 	bltu	r2,r10,8110b580 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110b544:	e13ff717 	ldw	r4,-36(fp)
8110b548:	20801317 	ldw	r2,76(r4)
8110b54c:	20c01417 	ldw	r3,80(r4)
8110b550:	e13fff0b 	ldhu	r4,-4(fp)
8110b554:	213fffcc 	andi	r4,r4,65535
8110b558:	2011883a 	mov	r8,r4
8110b55c:	0013883a 	mov	r9,zero
8110b560:	1a400736 	bltu	r3,r9,8110b580 <msgdma_construct_extended_descriptor+0xc0>
8110b564:	48c0011e 	bne	r9,r3,8110b56c <msgdma_construct_extended_descriptor+0xac>
8110b568:	12000536 	bltu	r2,r8,8110b580 <msgdma_construct_extended_descriptor+0xc0>
8110b56c:	e0bff717 	ldw	r2,-36(fp)
8110b570:	10801703 	ldbu	r2,92(r2)
8110b574:	10803fcc 	andi	r2,r2,255
8110b578:	10800060 	cmpeqi	r2,r2,1
8110b57c:	1000021e 	bne	r2,zero,8110b588 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110b580:	00bffa84 	movi	r2,-22
8110b584:	00002306 	br	8110b614 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110b588:	e0bff817 	ldw	r2,-32(fp)
8110b58c:	e0fff917 	ldw	r3,-28(fp)
8110b590:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110b594:	e0bff817 	ldw	r2,-32(fp)
8110b598:	e0fffa17 	ldw	r3,-24(fp)
8110b59c:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110b5a0:	e0bff817 	ldw	r2,-32(fp)
8110b5a4:	e0c00117 	ldw	r3,4(fp)
8110b5a8:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110b5ac:	e0bff817 	ldw	r2,-32(fp)
8110b5b0:	e0fffb0b 	ldhu	r3,-20(fp)
8110b5b4:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110b5b8:	e0bff817 	ldw	r2,-32(fp)
8110b5bc:	e0fffc03 	ldbu	r3,-16(fp)
8110b5c0:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110b5c4:	e0bff817 	ldw	r2,-32(fp)
8110b5c8:	e0fffd03 	ldbu	r3,-12(fp)
8110b5cc:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110b5d0:	e0bff817 	ldw	r2,-32(fp)
8110b5d4:	e0fffe0b 	ldhu	r3,-8(fp)
8110b5d8:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110b5dc:	e0bff817 	ldw	r2,-32(fp)
8110b5e0:	e0ffff0b 	ldhu	r3,-4(fp)
8110b5e4:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110b5e8:	e0bff817 	ldw	r2,-32(fp)
8110b5ec:	e0c00317 	ldw	r3,12(fp)
8110b5f0:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110b5f4:	e0bff817 	ldw	r2,-32(fp)
8110b5f8:	e0c00417 	ldw	r3,16(fp)
8110b5fc:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110b600:	e0800217 	ldw	r2,8(fp)
8110b604:	10e00034 	orhi	r3,r2,32768
8110b608:	e0bff817 	ldw	r2,-32(fp)
8110b60c:	10c00715 	stw	r3,28(r2)

	return 0;
8110b610:	0005883a 	mov	r2,zero

}
8110b614:	e037883a 	mov	sp,fp
8110b618:	df000017 	ldw	fp,0(sp)
8110b61c:	dec00104 	addi	sp,sp,4
8110b620:	f800283a 	ret

8110b624 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b624:	defff504 	addi	sp,sp,-44
8110b628:	de00012e 	bgeu	sp,et,8110b630 <msgdma_descriptor_async_transfer+0xc>
8110b62c:	003b68fa 	trap	3
8110b630:	dfc00a15 	stw	ra,40(sp)
8110b634:	df000915 	stw	fp,36(sp)
8110b638:	df000904 	addi	fp,sp,36
8110b63c:	e13ffd15 	stw	r4,-12(fp)
8110b640:	e17ffe15 	stw	r5,-8(fp)
8110b644:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b648:	e03ff815 	stw	zero,-32(fp)
	alt_irq_context context = 0;
8110b64c:	e03ff915 	stw	zero,-28(fp)
	alt_u16 counter = 0;
8110b650:	e03ff70d 	sth	zero,-36(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b654:	e0bffd17 	ldw	r2,-12(fp)
8110b658:	10800317 	ldw	r2,12(r2)
8110b65c:	10800204 	addi	r2,r2,8
8110b660:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b664:	10bfffcc 	andi	r2,r2,65535
8110b668:	e0bffa15 	stw	r2,-24(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b66c:	e0bffd17 	ldw	r2,-12(fp)
8110b670:	10800317 	ldw	r2,12(r2)
8110b674:	10800204 	addi	r2,r2,8
8110b678:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b67c:	1004d43a 	srli	r2,r2,16
8110b680:	e0bffb15 	stw	r2,-20(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b684:	e0bffd17 	ldw	r2,-12(fp)
8110b688:	10800917 	ldw	r2,36(r2)
8110b68c:	e0fffb17 	ldw	r3,-20(fp)
8110b690:	1880042e 	bgeu	r3,r2,8110b6a4 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b694:	e0bffd17 	ldw	r2,-12(fp)
8110b698:	10800917 	ldw	r2,36(r2)
8110b69c:	e0fffa17 	ldw	r3,-24(fp)
8110b6a0:	18800236 	bltu	r3,r2,8110b6ac <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110b6a4:	00bff904 	movi	r2,-28
8110b6a8:	00006906 	br	8110b850 <msgdma_descriptor_async_transfer+0x22c>
//	ALT_SEM_PEND(dev->regs_lock, 0);

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110b6ac:	00800804 	movi	r2,32
8110b6b0:	e0bff815 	stw	r2,-32(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b6b4:	0005303a 	rdctl	r2,status
8110b6b8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b6bc:	e0fffc17 	ldw	r3,-16(fp)
8110b6c0:	00bfff84 	movi	r2,-2
8110b6c4:	1884703a 	and	r2,r3,r2
8110b6c8:	1001703a 	wrctl	status,r2
  
  return context;
8110b6cc:	e0bffc17 	ldw	r2,-16(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b6d0:	e0bff915 	stw	r2,-28(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b6d4:	e0bffd17 	ldw	r2,-12(fp)
8110b6d8:	10800317 	ldw	r2,12(r2)
8110b6dc:	10800104 	addi	r2,r2,4
8110b6e0:	e0fff817 	ldw	r3,-32(fp)
8110b6e4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b6e8:	e0bffd17 	ldw	r2,-12(fp)
8110b6ec:	10800317 	ldw	r2,12(r2)
8110b6f0:	e0fffd17 	ldw	r3,-12(fp)
8110b6f4:	18c00317 	ldw	r3,12(r3)
8110b6f8:	18c00037 	ldwio	r3,0(r3)
8110b6fc:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
//	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110b700:	e0bffe17 	ldw	r2,-8(fp)
8110b704:	10000c26 	beq	r2,zero,8110b738 <msgdma_descriptor_async_transfer+0x114>
8110b708:	e0bfff17 	ldw	r2,-4(fp)
8110b70c:	10000a1e 	bne	r2,zero,8110b738 <msgdma_descriptor_async_transfer+0x114>
		counter = 0; /* reset counter */
8110b710:	e03ff70d 	sth	zero,-36(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110b714:	d0a06217 	ldw	r2,-32376(gp)
8110b718:	100f883a 	mov	r7,r2
8110b71c:	01800784 	movi	r6,30
8110b720:	01400044 	movi	r5,1
8110b724:	01204574 	movhi	r4,33045
8110b728:	21307504 	addi	r4,r4,-15916
8110b72c:	11219e00 	call	811219e0 <fwrite>
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
8110b730:	00bff084 	movi	r2,-62
8110b734:	00004606 	br	8110b850 <msgdma_descriptor_async_transfer+0x22c>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b738:	e0bffe17 	ldw	r2,-8(fp)
8110b73c:	10001f1e 	bne	r2,zero,8110b7bc <msgdma_descriptor_async_transfer+0x198>
8110b740:	e0bfff17 	ldw	r2,-4(fp)
8110b744:	10001d26 	beq	r2,zero,8110b7bc <msgdma_descriptor_async_transfer+0x198>
		counter = 0; /* reset counter */
8110b748:	e03ff70d 	sth	zero,-36(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b74c:	00001106 	br	8110b794 <msgdma_descriptor_async_transfer+0x170>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b750:	01000044 	movi	r4,1
8110b754:	11360040 	call	81136004 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b758:	e0bff70b 	ldhu	r2,-36(fp)
8110b75c:	1084e230 	cmpltui	r2,r2,5000
8110b760:	1000091e 	bne	r2,zero,8110b788 <msgdma_descriptor_async_transfer+0x164>
			{
#ifdef DEBUG_ON
				debug(fp,
8110b764:	d0a06217 	ldw	r2,-32376(gp)
8110b768:	100f883a 	mov	r7,r2
8110b76c:	01801544 	movi	r6,85
8110b770:	01400044 	movi	r5,1
8110b774:	01204574 	movhi	r4,33045
8110b778:	21307d04 	addi	r4,r4,-15884
8110b77c:	11219e00 	call	811219e0 <fwrite>
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
//				ALT_SEM_POST(dev->regs_lock);

				return -ETIME;
8110b780:	00bff084 	movi	r2,-62
8110b784:	00003206 	br	8110b850 <msgdma_descriptor_async_transfer+0x22c>
			}
			counter++;
8110b788:	e0bff70b 	ldhu	r2,-36(fp)
8110b78c:	10800044 	addi	r2,r2,1
8110b790:	e0bff70d 	sth	r2,-36(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b794:	e0bffd17 	ldw	r2,-12(fp)
8110b798:	10c00317 	ldw	r3,12(r2)
8110b79c:	e0bffd17 	ldw	r2,-12(fp)
8110b7a0:	10800417 	ldw	r2,16(r2)
8110b7a4:	e1bfff17 	ldw	r6,-4(fp)
8110b7a8:	100b883a 	mov	r5,r2
8110b7ac:	1809883a 	mov	r4,r3
8110b7b0:	110b3840 	call	8110b384 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b7b4:	103fe61e 	bne	r2,zero,8110b750 <__reset+0xfb0eb750>
		 * registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b7b8:	00000206 	br	8110b7c4 <msgdma_descriptor_async_transfer+0x1a0>
		 * semaphore so that other threads can access the registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b7bc:	00bfffc4 	movi	r2,-1
8110b7c0:	00002306 	br	8110b850 <msgdma_descriptor_async_transfer+0x22c>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110b7c4:	e0bffd17 	ldw	r2,-12(fp)
8110b7c8:	10800b17 	ldw	r2,44(r2)
8110b7cc:	10001026 	beq	r2,zero,8110b810 <msgdma_descriptor_async_transfer+0x1ec>

		control |= (dev->control |
8110b7d0:	e0bffd17 	ldw	r2,-12(fp)
8110b7d4:	10c00d17 	ldw	r3,52(r2)
8110b7d8:	e0bff817 	ldw	r2,-32(fp)
8110b7dc:	1884b03a 	or	r2,r3,r2
8110b7e0:	10800514 	ori	r2,r2,20
8110b7e4:	e0bff815 	stw	r2,-32(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110b7e8:	e0fff817 	ldw	r3,-32(fp)
8110b7ec:	00bff7c4 	movi	r2,-33
8110b7f0:	1884703a 	and	r2,r3,r2
8110b7f4:	e0bff815 	stw	r2,-32(fp)
		/* making sure the read-modify-write below can't be pre-empted */
//		context = alt_irq_disable_all();
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b7f8:	e0bffd17 	ldw	r2,-12(fp)
8110b7fc:	10800317 	ldw	r2,12(r2)
8110b800:	10800104 	addi	r2,r2,4
8110b804:	e0fff817 	ldw	r3,-32(fp)
8110b808:	10c00035 	stwio	r3,0(r2)
8110b80c:	00000f06 	br	8110b84c <msgdma_descriptor_async_transfer+0x228>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110b810:	e0bffd17 	ldw	r2,-12(fp)
8110b814:	10c00d17 	ldw	r3,52(r2)
8110b818:	e0bff817 	ldw	r2,-32(fp)
8110b81c:	1884b03a 	or	r2,r3,r2
8110b820:	10800114 	ori	r2,r2,4
8110b824:	e0bff815 	stw	r2,-32(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110b828:	e0fff817 	ldw	r3,-32(fp)
8110b82c:	00bff3c4 	movi	r2,-49
8110b830:	1884703a 	and	r2,r3,r2
8110b834:	e0bff815 	stw	r2,-32(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
//		context = alt_irq_disable_all();
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b838:	e0bffd17 	ldw	r2,-12(fp)
8110b83c:	10800317 	ldw	r2,12(r2)
8110b840:	10800104 	addi	r2,r2,4
8110b844:	e0fff817 	ldw	r3,-32(fp)
8110b848:	10c00035 	stwio	r3,0(r2)
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
//	ALT_SEM_POST(dev->regs_lock);

	return 0;
8110b84c:	0005883a 	mov	r2,zero
}
8110b850:	e037883a 	mov	sp,fp
8110b854:	dfc00117 	ldw	ra,4(sp)
8110b858:	df000017 	ldw	fp,0(sp)
8110b85c:	dec00204 	addi	sp,sp,8
8110b860:	f800283a 	ret

8110b864 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b864:	defff104 	addi	sp,sp,-60
8110b868:	de00012e 	bgeu	sp,et,8110b870 <msgdma_descriptor_sync_transfer+0xc>
8110b86c:	003b68fa 	trap	3
8110b870:	dfc00e15 	stw	ra,56(sp)
8110b874:	df000d15 	stw	fp,52(sp)
8110b878:	df000d04 	addi	fp,sp,52
8110b87c:	e13ffd15 	stw	r4,-12(fp)
8110b880:	e17ffe15 	stw	r5,-8(fp)
8110b884:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b888:	e03ff715 	stw	zero,-36(fp)
	alt_irq_context context = 0;
8110b88c:	e03ff815 	stw	zero,-32(fp)
	alt_u32 csr_status = 0;
8110b890:	e03ff315 	stw	zero,-52(fp)
	alt_u16 counter = 0;
8110b894:	e03ff40d 	sth	zero,-48(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b898:	e0bffd17 	ldw	r2,-12(fp)
8110b89c:	10800317 	ldw	r2,12(r2)
8110b8a0:	10800204 	addi	r2,r2,8
8110b8a4:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b8a8:	10bfffcc 	andi	r2,r2,65535
8110b8ac:	e0bff515 	stw	r2,-44(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b8b0:	e0bffd17 	ldw	r2,-12(fp)
8110b8b4:	10800317 	ldw	r2,12(r2)
8110b8b8:	10800204 	addi	r2,r2,8
8110b8bc:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b8c0:	1004d43a 	srli	r2,r2,16
8110b8c4:	e0bff615 	stw	r2,-40(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110b8c8:	00807804 	movi	r2,480
8110b8cc:	e0bff915 	stw	r2,-28(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b8d0:	00002406 	br	8110b964 <msgdma_descriptor_sync_transfer+0x100>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110b8d4:	01000044 	movi	r4,1
8110b8d8:	11360040 	call	81136004 <alt_busy_sleep>
#ifdef DEBUG_ON
	fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
8110b8dc:	d0a06217 	ldw	r2,-32376(gp)
8110b8e0:	100f883a 	mov	r7,r2
8110b8e4:	01800a04 	movi	r6,40
8110b8e8:	01400044 	movi	r5,1
8110b8ec:	01204574 	movhi	r4,33045
8110b8f0:	21309304 	addi	r4,r4,-15796
8110b8f4:	11219e00 	call	811219e0 <fwrite>
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b8f8:	e0bff40b 	ldhu	r2,-48(fp)
8110b8fc:	1084e230 	cmpltui	r2,r2,5000
8110b900:	1000091e 	bne	r2,zero,8110b928 <msgdma_descriptor_sync_transfer+0xc4>
		{
#ifdef DEBUG_ON
			debug(fp,
8110b904:	d0a06217 	ldw	r2,-32376(gp)
8110b908:	100f883a 	mov	r7,r2
8110b90c:	01801304 	movi	r6,76
8110b910:	01400044 	movi	r5,1
8110b914:	01204574 	movhi	r4,33045
8110b918:	21309e04 	addi	r4,r4,-15752
8110b91c:	11219e00 	call	811219e0 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110b920:	00bff084 	movi	r2,-62
8110b924:	0000aa06 	br	8110bbd0 <msgdma_descriptor_sync_transfer+0x36c>
		}
		counter++;
8110b928:	e0bff40b 	ldhu	r2,-48(fp)
8110b92c:	10800044 	addi	r2,r2,1
8110b930:	e0bff40d 	sth	r2,-48(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b934:	e0bffd17 	ldw	r2,-12(fp)
8110b938:	10800317 	ldw	r2,12(r2)
8110b93c:	10800204 	addi	r2,r2,8
8110b940:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110b944:	10bfffcc 	andi	r2,r2,65535
8110b948:	e0bff515 	stw	r2,-44(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b94c:	e0bffd17 	ldw	r2,-12(fp)
8110b950:	10800317 	ldw	r2,12(r2)
8110b954:	10800204 	addi	r2,r2,8
8110b958:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110b95c:	1004d43a 	srli	r2,r2,16
8110b960:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b964:	e0bffd17 	ldw	r2,-12(fp)
8110b968:	10800917 	ldw	r2,36(r2)
8110b96c:	e0fff617 	ldw	r3,-40(fp)
8110b970:	18bfd82e 	bgeu	r3,r2,8110b8d4 <__reset+0xfb0eb8d4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b974:	e0bffd17 	ldw	r2,-12(fp)
8110b978:	10800917 	ldw	r2,36(r2)
8110b97c:	e0fff517 	ldw	r3,-44(fp)
8110b980:	18bfd42e 	bgeu	r3,r2,8110b8d4 <__reset+0xfb0eb8d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b984:	0005303a 	rdctl	r2,status
8110b988:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b98c:	e0fffc17 	ldw	r3,-16(fp)
8110b990:	00bfff84 	movi	r2,-2
8110b994:	1884703a 	and	r2,r3,r2
8110b998:	1001703a 	wrctl	status,r2
  
  return context;
8110b99c:	e0bffc17 	ldw	r2,-16(fp)
//	ALT_SEM_PEND(dev->regs_lock, 0);

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b9a0:	e0bff815 	stw	r2,-32(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110b9a4:	e0bffd17 	ldw	r2,-12(fp)
8110b9a8:	10800317 	ldw	r2,12(r2)
8110b9ac:	10800104 	addi	r2,r2,4
8110b9b0:	00c00804 	movi	r3,32
8110b9b4:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b9b8:	e0bffd17 	ldw	r2,-12(fp)
8110b9bc:	10800317 	ldw	r2,12(r2)
8110b9c0:	e0fffd17 	ldw	r3,-12(fp)
8110b9c4:	18c00317 	ldw	r3,12(r3)
8110b9c8:	18c00037 	ldwio	r3,0(r3)
8110b9cc:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110b9d0:	e0bffe17 	ldw	r2,-8(fp)
8110b9d4:	10000c26 	beq	r2,zero,8110ba08 <msgdma_descriptor_sync_transfer+0x1a4>
8110b9d8:	e0bfff17 	ldw	r2,-4(fp)
8110b9dc:	10000a1e 	bne	r2,zero,8110ba08 <msgdma_descriptor_sync_transfer+0x1a4>
		counter = 0; /* reset counter */
8110b9e0:	e03ff40d 	sth	zero,-48(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110b9e4:	d0a06217 	ldw	r2,-32376(gp)
8110b9e8:	100f883a 	mov	r7,r2
8110b9ec:	01800784 	movi	r6,30
8110b9f0:	01400044 	movi	r5,1
8110b9f4:	01204574 	movhi	r4,33045
8110b9f8:	21307504 	addi	r4,r4,-15916
8110b9fc:	11219e00 	call	811219e0 <fwrite>
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
8110ba00:	00bff084 	movi	r2,-62
8110ba04:	00007206 	br	8110bbd0 <msgdma_descriptor_sync_transfer+0x36c>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110ba08:	e0bffe17 	ldw	r2,-8(fp)
8110ba0c:	10001f1e 	bne	r2,zero,8110ba8c <msgdma_descriptor_sync_transfer+0x228>
8110ba10:	e0bfff17 	ldw	r2,-4(fp)
8110ba14:	10001d26 	beq	r2,zero,8110ba8c <msgdma_descriptor_sync_transfer+0x228>
		counter = 0; /* reset counter */
8110ba18:	e03ff40d 	sth	zero,-48(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110ba1c:	00001106 	br	8110ba64 <msgdma_descriptor_sync_transfer+0x200>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110ba20:	01000044 	movi	r4,1
8110ba24:	11360040 	call	81136004 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110ba28:	e0bff40b 	ldhu	r2,-48(fp)
8110ba2c:	1084e230 	cmpltui	r2,r2,5000
8110ba30:	1000091e 	bne	r2,zero,8110ba58 <msgdma_descriptor_sync_transfer+0x1f4>
			{
#ifdef DEBUG_ON
				debug(fp,
8110ba34:	d0a06217 	ldw	r2,-32376(gp)
8110ba38:	100f883a 	mov	r7,r2
8110ba3c:	01801004 	movi	r6,64
8110ba40:	01400044 	movi	r5,1
8110ba44:	01204574 	movhi	r4,33045
8110ba48:	2130b204 	addi	r4,r4,-15672
8110ba4c:	11219e00 	call	811219e0 <fwrite>
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
//				ALT_SEM_POST(dev->regs_lock);

				return -ETIME;
8110ba50:	00bff084 	movi	r2,-62
8110ba54:	00005e06 	br	8110bbd0 <msgdma_descriptor_sync_transfer+0x36c>
			}
			counter++;
8110ba58:	e0bff40b 	ldhu	r2,-48(fp)
8110ba5c:	10800044 	addi	r2,r2,1
8110ba60:	e0bff40d 	sth	r2,-48(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110ba64:	e0bffd17 	ldw	r2,-12(fp)
8110ba68:	10c00317 	ldw	r3,12(r2)
8110ba6c:	e0bffd17 	ldw	r2,-12(fp)
8110ba70:	10800417 	ldw	r2,16(r2)
8110ba74:	e1bfff17 	ldw	r6,-4(fp)
8110ba78:	100b883a 	mov	r5,r2
8110ba7c:	1809883a 	mov	r4,r3
8110ba80:	110b3840 	call	8110b384 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110ba84:	103fe61e 	bne	r2,zero,8110ba20 <__reset+0xfb0eba20>
		 * registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110ba88:	00000206 	br	8110ba94 <msgdma_descriptor_sync_transfer+0x230>
		 * semaphore so that other threads can access the registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110ba8c:	00bfffc4 	movi	r2,-1
8110ba90:	00004f06 	br	8110bbd0 <msgdma_descriptor_sync_transfer+0x36c>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110ba94:	e0bffd17 	ldw	r2,-12(fp)
8110ba98:	10800317 	ldw	r2,12(r2)
8110ba9c:	10800104 	addi	r2,r2,4
8110baa0:	e0fffd17 	ldw	r3,-12(fp)
8110baa4:	19000d17 	ldw	r4,52(r3)
8110baa8:	00fff2c4 	movi	r3,-53
8110baac:	20c6703a 	and	r3,r4,r3
8110bab0:	18c00114 	ori	r3,r3,4
8110bab4:	10c00035 	stwio	r3,0(r2)
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

//	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110bab8:	e03ff40d 	sth	zero,-48(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110babc:	e0bffd17 	ldw	r2,-12(fp)
8110bac0:	10800317 	ldw	r2,12(r2)
8110bac4:	10800037 	ldwio	r2,0(r2)
8110bac8:	e0bff315 	stw	r2,-52(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bacc:	00001506 	br	8110bb24 <msgdma_descriptor_sync_transfer+0x2c0>
		alt_busy_sleep(1); /* delay 1us */
8110bad0:	01000044 	movi	r4,1
8110bad4:	11360040 	call	81136004 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bad8:	e0bff40b 	ldhu	r2,-48(fp)
8110badc:	1084e230 	cmpltui	r2,r2,5000
8110bae0:	1000091e 	bne	r2,zero,8110bb08 <msgdma_descriptor_sync_transfer+0x2a4>
		{
#ifdef DEBUG_ON
			debug(fp,
8110bae4:	d0a06217 	ldw	r2,-32376(gp)
8110bae8:	100f883a 	mov	r7,r2
8110baec:	01801184 	movi	r6,70
8110baf0:	01400044 	movi	r5,1
8110baf4:	01204574 	movhi	r4,33045
8110baf8:	2130c304 	addi	r4,r4,-15604
8110bafc:	11219e00 	call	811219e0 <fwrite>
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
//			ALT_SEM_POST(dev->regs_lock);

			return -ETIME;
8110bb00:	00bff084 	movi	r2,-62
8110bb04:	00003206 	br	8110bbd0 <msgdma_descriptor_sync_transfer+0x36c>
		}
		counter++;
8110bb08:	e0bff40b 	ldhu	r2,-48(fp)
8110bb0c:	10800044 	addi	r2,r2,1
8110bb10:	e0bff40d 	sth	r2,-48(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bb14:	e0bffd17 	ldw	r2,-12(fp)
8110bb18:	10800317 	ldw	r2,12(r2)
8110bb1c:	10800037 	ldwio	r2,0(r2)
8110bb20:	e0bff315 	stw	r2,-52(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bb24:	e0fff317 	ldw	r3,-52(fp)
8110bb28:	e0bff917 	ldw	r2,-28(fp)
8110bb2c:	1884703a 	and	r2,r3,r2
8110bb30:	1000031e 	bne	r2,zero,8110bb40 <msgdma_descriptor_sync_transfer+0x2dc>
8110bb34:	e0bff317 	ldw	r2,-52(fp)
8110bb38:	1080004c 	andi	r2,r2,1
8110bb3c:	103fe41e 	bne	r2,zero,8110bad0 <__reset+0xfb0ebad0>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110bb40:	e0fff317 	ldw	r3,-52(fp)
8110bb44:	e0bff917 	ldw	r2,-28(fp)
8110bb48:	1884703a 	and	r2,r3,r2
8110bb4c:	10000226 	beq	r2,zero,8110bb58 <msgdma_descriptor_sync_transfer+0x2f4>
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
//		ALT_SEM_POST(dev->regs_lock);

		return error;
8110bb50:	e0bff917 	ldw	r2,-28(fp)
8110bb54:	00001e06 	br	8110bbd0 <msgdma_descriptor_sync_transfer+0x36c>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110bb58:	e0bffd17 	ldw	r2,-12(fp)
8110bb5c:	10800317 	ldw	r2,12(r2)
8110bb60:	10800104 	addi	r2,r2,4
8110bb64:	10800037 	ldwio	r2,0(r2)
8110bb68:	10800814 	ori	r2,r2,32
8110bb6c:	e0bff715 	stw	r2,-36(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bb70:	0005303a 	rdctl	r2,status
8110bb74:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bb78:	e0fffb17 	ldw	r3,-20(fp)
8110bb7c:	00bfff84 	movi	r2,-2
8110bb80:	1884703a 	and	r2,r3,r2
8110bb84:	1001703a 	wrctl	status,r2
  
  return context;
8110bb88:	e0bffb17 	ldw	r2,-20(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110bb8c:	e0bff815 	stw	r2,-32(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bb90:	e0bffd17 	ldw	r2,-12(fp)
8110bb94:	10800317 	ldw	r2,12(r2)
8110bb98:	10800104 	addi	r2,r2,4
8110bb9c:	e0fff717 	ldw	r3,-36(fp)
8110bba0:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110bba4:	e0bffd17 	ldw	r2,-12(fp)
8110bba8:	10800317 	ldw	r2,12(r2)
8110bbac:	e0fffd17 	ldw	r3,-12(fp)
8110bbb0:	18c00317 	ldw	r3,12(r3)
8110bbb4:	18c00037 	ldwio	r3,0(r3)
8110bbb8:	10c00035 	stwio	r3,0(r2)
8110bbbc:	e0bff817 	ldw	r2,-32(fp)
8110bbc0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bbc4:	e0bffa17 	ldw	r2,-24(fp)
8110bbc8:	1001703a 	wrctl	status,r2
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
//	ALT_SEM_POST(dev->regs_lock);

	return 0;
8110bbcc:	0005883a 	mov	r2,zero

}
8110bbd0:	e037883a 	mov	sp,fp
8110bbd4:	dfc00117 	ldw	ra,4(sp)
8110bbd8:	df000017 	ldw	fp,0(sp)
8110bbdc:	dec00204 	addi	sp,sp,8
8110bbe0:	f800283a 	ret

8110bbe4 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110bbe4:	deffec04 	addi	sp,sp,-80
8110bbe8:	de00012e 	bgeu	sp,et,8110bbf0 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110bbec:	003b68fa 	trap	3
8110bbf0:	dfc01315 	stw	ra,76(sp)
8110bbf4:	df001215 	stw	fp,72(sp)
8110bbf8:	df001204 	addi	fp,sp,72
8110bbfc:	e13ff715 	stw	r4,-36(fp)
8110bc00:	e17ff815 	stw	r5,-32(fp)
8110bc04:	e1bff915 	stw	r6,-28(fp)
8110bc08:	e1fffa15 	stw	r7,-24(fp)
8110bc0c:	e1800617 	ldw	r6,24(fp)
8110bc10:	e1400717 	ldw	r5,28(fp)
8110bc14:	e1000817 	ldw	r4,32(fp)
8110bc18:	e0c00917 	ldw	r3,36(fp)
8110bc1c:	e0800a17 	ldw	r2,40(fp)
8110bc20:	e1bffb0d 	sth	r6,-20(fp)
8110bc24:	e17ffc05 	stb	r5,-16(fp)
8110bc28:	e13ffd05 	stb	r4,-12(fp)
8110bc2c:	e0fffe0d 	sth	r3,-8(fp)
8110bc30:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110bc34:	e0bffb0b 	ldhu	r2,-20(fp)
8110bc38:	e0fffc03 	ldbu	r3,-16(fp)
8110bc3c:	e13ffd03 	ldbu	r4,-12(fp)
8110bc40:	e17ffe0b 	ldhu	r5,-8(fp)
8110bc44:	e1bfff0b 	ldhu	r6,-4(fp)
8110bc48:	d9800815 	stw	r6,32(sp)
8110bc4c:	d9400715 	stw	r5,28(sp)
8110bc50:	d9000615 	stw	r4,24(sp)
8110bc54:	d8c00515 	stw	r3,20(sp)
8110bc58:	d8800415 	stw	r2,16(sp)
8110bc5c:	e0800517 	ldw	r2,20(fp)
8110bc60:	d8800315 	stw	r2,12(sp)
8110bc64:	e0800417 	ldw	r2,16(fp)
8110bc68:	d8800215 	stw	r2,8(sp)
8110bc6c:	e0800317 	ldw	r2,12(fp)
8110bc70:	d8800115 	stw	r2,4(sp)
8110bc74:	e0800217 	ldw	r2,8(fp)
8110bc78:	d8800015 	stw	r2,0(sp)
8110bc7c:	e1fffa17 	ldw	r7,-24(fp)
8110bc80:	e1bff917 	ldw	r6,-28(fp)
8110bc84:	e17ff817 	ldw	r5,-32(fp)
8110bc88:	e13ff717 	ldw	r4,-36(fp)
8110bc8c:	110b4c00 	call	8110b4c0 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110bc90:	e037883a 	mov	sp,fp
8110bc94:	dfc00117 	ldw	ra,4(sp)
8110bc98:	df000017 	ldw	fp,0(sp)
8110bc9c:	dec00204 	addi	sp,sp,8
8110bca0:	f800283a 	ret

8110bca4 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110bca4:	defffc04 	addi	sp,sp,-16
8110bca8:	de00012e 	bgeu	sp,et,8110bcb0 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110bcac:	003b68fa 	trap	3
8110bcb0:	dfc00315 	stw	ra,12(sp)
8110bcb4:	df000215 	stw	fp,8(sp)
8110bcb8:	df000204 	addi	fp,sp,8
8110bcbc:	e13ffe15 	stw	r4,-8(fp)
8110bcc0:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110bcc4:	e1bfff17 	ldw	r6,-4(fp)
8110bcc8:	000b883a 	mov	r5,zero
8110bccc:	e13ffe17 	ldw	r4,-8(fp)
8110bcd0:	110b6240 	call	8110b624 <msgdma_descriptor_async_transfer>
}
8110bcd4:	e037883a 	mov	sp,fp
8110bcd8:	dfc00117 	ldw	ra,4(sp)
8110bcdc:	df000017 	ldw	fp,0(sp)
8110bce0:	dec00204 	addi	sp,sp,8
8110bce4:	f800283a 	ret

8110bce8 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110bce8:	defffc04 	addi	sp,sp,-16
8110bcec:	de00012e 	bgeu	sp,et,8110bcf4 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110bcf0:	003b68fa 	trap	3
8110bcf4:	dfc00315 	stw	ra,12(sp)
8110bcf8:	df000215 	stw	fp,8(sp)
8110bcfc:	df000204 	addi	fp,sp,8
8110bd00:	e13ffe15 	stw	r4,-8(fp)
8110bd04:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110bd08:	e1bfff17 	ldw	r6,-4(fp)
8110bd0c:	000b883a 	mov	r5,zero
8110bd10:	e13ffe17 	ldw	r4,-8(fp)
8110bd14:	110b8640 	call	8110b864 <msgdma_descriptor_sync_transfer>
}
8110bd18:	e037883a 	mov	sp,fp
8110bd1c:	dfc00117 	ldw	ra,4(sp)
8110bd20:	df000017 	ldw	fp,0(sp)
8110bd24:	dec00204 	addi	sp,sp,8
8110bd28:	f800283a 	ret

8110bd2c <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110bd2c:	defff204 	addi	sp,sp,-56
8110bd30:	de00012e 	bgeu	sp,et,8110bd38 <POWER_SPI_RW+0xc>
8110bd34:	003b68fa 	trap	3
8110bd38:	dfc00d15 	stw	ra,52(sp)
8110bd3c:	df000c15 	stw	fp,48(sp)
8110bd40:	df000c04 	addi	fp,sp,48
8110bd44:	2007883a 	mov	r3,r4
8110bd48:	2805883a 	mov	r2,r5
8110bd4c:	e1bffe15 	stw	r6,-8(fp)
8110bd50:	e1ffff15 	stw	r7,-4(fp)
8110bd54:	e0fffc05 	stb	r3,-16(fp)
8110bd58:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110bd5c:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110bd60:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110bd64:	008003f4 	movhi	r2,15
8110bd68:	10909004 	addi	r2,r2,16960
8110bd6c:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110bd70:	00bfe004 	movi	r2,-128
8110bd74:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110bd78:	e0bffe17 	ldw	r2,-8(fp)
8110bd7c:	10000226 	beq	r2,zero,8110bd88 <POWER_SPI_RW+0x5c>
8110bd80:	00800804 	movi	r2,32
8110bd84:	00000106 	br	8110bd8c <POWER_SPI_RW+0x60>
8110bd88:	0005883a 	mov	r2,zero
8110bd8c:	e0fff403 	ldbu	r3,-48(fp)
8110bd90:	10c4b03a 	or	r2,r2,r3
8110bd94:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110bd98:	e0800217 	ldw	r2,8(fp)
8110bd9c:	10000226 	beq	r2,zero,8110bda8 <POWER_SPI_RW+0x7c>
8110bda0:	00800404 	movi	r2,16
8110bda4:	00000106 	br	8110bdac <POWER_SPI_RW+0x80>
8110bda8:	0005883a 	mov	r2,zero
8110bdac:	e0fff403 	ldbu	r3,-48(fp)
8110bdb0:	10c4b03a 	or	r2,r2,r3
8110bdb4:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110bdb8:	e0bfff17 	ldw	r2,-4(fp)
8110bdbc:	10000226 	beq	r2,zero,8110bdc8 <POWER_SPI_RW+0x9c>
8110bdc0:	00800204 	movi	r2,8
8110bdc4:	00000106 	br	8110bdcc <POWER_SPI_RW+0xa0>
8110bdc8:	0005883a 	mov	r2,zero
8110bdcc:	e0fff403 	ldbu	r3,-48(fp)
8110bdd0:	10c4b03a 	or	r2,r2,r3
8110bdd4:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110bdd8:	e0bffd03 	ldbu	r2,-12(fp)
8110bddc:	108001cc 	andi	r2,r2,7
8110bde0:	1007883a 	mov	r3,r2
8110bde4:	e0bff403 	ldbu	r2,-48(fp)
8110bde8:	1884b03a 	or	r2,r3,r2
8110bdec:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110bdf0:	0007883a 	mov	r3,zero
8110bdf4:	00a00034 	movhi	r2,32768
8110bdf8:	10824404 	addi	r2,r2,2320
8110bdfc:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110be00:	0007883a 	mov	r3,zero
8110be04:	00a00034 	movhi	r2,32768
8110be08:	10824c04 	addi	r2,r2,2352
8110be0c:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110be10:	e0bffc03 	ldbu	r2,-16(fp)
8110be14:	1000021e 	bne	r2,zero,8110be20 <POWER_SPI_RW+0xf4>
8110be18:	00c00084 	movi	r3,2
8110be1c:	00000106 	br	8110be24 <POWER_SPI_RW+0xf8>
8110be20:	00c00044 	movi	r3,1
8110be24:	00a00034 	movhi	r2,32768
8110be28:	10824804 	addi	r2,r2,2336
8110be2c:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110be30:	010003c4 	movi	r4,15
8110be34:	1137a780 	call	81137a78 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110be38:	00000306 	br	8110be48 <POWER_SPI_RW+0x11c>
		nWait++;
8110be3c:	e0bff817 	ldw	r2,-32(fp)
8110be40:	10800044 	addi	r2,r2,1
8110be44:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110be48:	00a00034 	movhi	r2,32768
8110be4c:	10825404 	addi	r2,r2,2384
8110be50:	10800037 	ldwio	r2,0(r2)
8110be54:	1080004c 	andi	r2,r2,1
8110be58:	10000326 	beq	r2,zero,8110be68 <POWER_SPI_RW+0x13c>
8110be5c:	e0fff817 	ldw	r3,-32(fp)
8110be60:	e0bffa17 	ldw	r2,-24(fp)
8110be64:	18bff516 	blt	r3,r2,8110be3c <__reset+0xfb0ebe3c>
		nWait++;
	}

	if (SPI_SDO) {
8110be68:	00a00034 	movhi	r2,32768
8110be6c:	10825404 	addi	r2,r2,2384
8110be70:	10800037 	ldwio	r2,0(r2)
8110be74:	1080004c 	andi	r2,r2,1
8110be78:	10000626 	beq	r2,zero,8110be94 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110be7c:	00c000c4 	movi	r3,3
8110be80:	00a00034 	movhi	r2,32768
8110be84:	10824804 	addi	r2,r2,2336
8110be88:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110be8c:	0005883a 	mov	r2,zero
8110be90:	0000db06 	br	8110c200 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110be94:	e03ff715 	stw	zero,-36(fp)
8110be98:	00002406 	br	8110bf2c <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110be9c:	e0bff403 	ldbu	r2,-48(fp)
8110bea0:	10803fcc 	andi	r2,r2,255
8110bea4:	1004d1fa 	srli	r2,r2,7
8110bea8:	10c03fcc 	andi	r3,r2,255
8110beac:	00a00034 	movhi	r2,32768
8110beb0:	10825004 	addi	r2,r2,2368
8110beb4:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110beb8:	e0bff403 	ldbu	r2,-48(fp)
8110bebc:	1085883a 	add	r2,r2,r2
8110bec0:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110bec4:	e0bff517 	ldw	r2,-44(fp)
8110bec8:	1085883a 	add	r2,r2,r2
8110becc:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110bed0:	00a00034 	movhi	r2,32768
8110bed4:	10825404 	addi	r2,r2,2384
8110bed8:	10800037 	ldwio	r2,0(r2)
8110bedc:	1080004c 	andi	r2,r2,1
8110bee0:	1007883a 	mov	r3,r2
8110bee4:	e0bff517 	ldw	r2,-44(fp)
8110bee8:	10c4b03a 	or	r2,r2,r3
8110beec:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110bef0:	00c00044 	movi	r3,1
8110bef4:	00a00034 	movhi	r2,32768
8110bef8:	10824c04 	addi	r2,r2,2352
8110befc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bf00:	010003c4 	movi	r4,15
8110bf04:	1137a780 	call	81137a78 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110bf08:	0007883a 	mov	r3,zero
8110bf0c:	00a00034 	movhi	r2,32768
8110bf10:	10824c04 	addi	r2,r2,2352
8110bf14:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bf18:	010003c4 	movi	r4,15
8110bf1c:	1137a780 	call	81137a78 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110bf20:	e0bff717 	ldw	r2,-36(fp)
8110bf24:	10800044 	addi	r2,r2,1
8110bf28:	e0bff715 	stw	r2,-36(fp)
8110bf2c:	e0bff717 	ldw	r2,-36(fp)
8110bf30:	10800090 	cmplti	r2,r2,2
8110bf34:	103fd91e 	bne	r2,zero,8110be9c <__reset+0xfb0ebe9c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110bf38:	e03ff715 	stw	zero,-36(fp)
8110bf3c:	00002406 	br	8110bfd0 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110bf40:	e0bff403 	ldbu	r2,-48(fp)
8110bf44:	10803fcc 	andi	r2,r2,255
8110bf48:	1004d1fa 	srli	r2,r2,7
8110bf4c:	10c03fcc 	andi	r3,r2,255
8110bf50:	00a00034 	movhi	r2,32768
8110bf54:	10825004 	addi	r2,r2,2368
8110bf58:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110bf5c:	e0bff403 	ldbu	r2,-48(fp)
8110bf60:	1085883a 	add	r2,r2,r2
8110bf64:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110bf68:	e0bff517 	ldw	r2,-44(fp)
8110bf6c:	1085883a 	add	r2,r2,r2
8110bf70:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110bf74:	00a00034 	movhi	r2,32768
8110bf78:	10825404 	addi	r2,r2,2384
8110bf7c:	10800037 	ldwio	r2,0(r2)
8110bf80:	1080004c 	andi	r2,r2,1
8110bf84:	1007883a 	mov	r3,r2
8110bf88:	e0bff517 	ldw	r2,-44(fp)
8110bf8c:	10c4b03a 	or	r2,r2,r3
8110bf90:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110bf94:	00c00044 	movi	r3,1
8110bf98:	00a00034 	movhi	r2,32768
8110bf9c:	10824c04 	addi	r2,r2,2352
8110bfa0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bfa4:	010003c4 	movi	r4,15
8110bfa8:	1137a780 	call	81137a78 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110bfac:	0007883a 	mov	r3,zero
8110bfb0:	00a00034 	movhi	r2,32768
8110bfb4:	10824c04 	addi	r2,r2,2352
8110bfb8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bfbc:	010003c4 	movi	r4,15
8110bfc0:	1137a780 	call	81137a78 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110bfc4:	e0bff717 	ldw	r2,-36(fp)
8110bfc8:	10800044 	addi	r2,r2,1
8110bfcc:	e0bff715 	stw	r2,-36(fp)
8110bfd0:	e0bff717 	ldw	r2,-36(fp)
8110bfd4:	10800210 	cmplti	r2,r2,8
8110bfd8:	103fd91e 	bne	r2,zero,8110bf40 <__reset+0xfb0ebf40>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110bfdc:	e03ff715 	stw	zero,-36(fp)
8110bfe0:	00001a06 	br	8110c04c <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110bfe4:	e0bff517 	ldw	r2,-44(fp)
8110bfe8:	1085883a 	add	r2,r2,r2
8110bfec:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110bff0:	00a00034 	movhi	r2,32768
8110bff4:	10825404 	addi	r2,r2,2384
8110bff8:	10800037 	ldwio	r2,0(r2)
8110bffc:	1080004c 	andi	r2,r2,1
8110c000:	1007883a 	mov	r3,r2
8110c004:	e0bff517 	ldw	r2,-44(fp)
8110c008:	10c4b03a 	or	r2,r2,r3
8110c00c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c010:	00c00044 	movi	r3,1
8110c014:	00a00034 	movhi	r2,32768
8110c018:	10824c04 	addi	r2,r2,2352
8110c01c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c020:	010003c4 	movi	r4,15
8110c024:	1137a780 	call	81137a78 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c028:	0007883a 	mov	r3,zero
8110c02c:	00a00034 	movhi	r2,32768
8110c030:	10824c04 	addi	r2,r2,2352
8110c034:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c038:	010003c4 	movi	r4,15
8110c03c:	1137a780 	call	81137a78 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c040:	e0bff717 	ldw	r2,-36(fp)
8110c044:	10800044 	addi	r2,r2,1
8110c048:	e0bff715 	stw	r2,-36(fp)
8110c04c:	e0bff717 	ldw	r2,-36(fp)
8110c050:	10800210 	cmplti	r2,r2,8
8110c054:	103fe31e 	bne	r2,zero,8110bfe4 <__reset+0xfb0ebfe4>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c058:	e03ff715 	stw	zero,-36(fp)
8110c05c:	00001a06 	br	8110c0c8 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110c060:	e0bff517 	ldw	r2,-44(fp)
8110c064:	1085883a 	add	r2,r2,r2
8110c068:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110c06c:	00a00034 	movhi	r2,32768
8110c070:	10825404 	addi	r2,r2,2384
8110c074:	10800037 	ldwio	r2,0(r2)
8110c078:	1080004c 	andi	r2,r2,1
8110c07c:	1007883a 	mov	r3,r2
8110c080:	e0bff517 	ldw	r2,-44(fp)
8110c084:	10c4b03a 	or	r2,r2,r3
8110c088:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c08c:	00c00044 	movi	r3,1
8110c090:	00a00034 	movhi	r2,32768
8110c094:	10824c04 	addi	r2,r2,2352
8110c098:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c09c:	010003c4 	movi	r4,15
8110c0a0:	1137a780 	call	81137a78 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c0a4:	0007883a 	mov	r3,zero
8110c0a8:	00a00034 	movhi	r2,32768
8110c0ac:	10824c04 	addi	r2,r2,2352
8110c0b0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0b4:	010003c4 	movi	r4,15
8110c0b8:	1137a780 	call	81137a78 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c0bc:	e0bff717 	ldw	r2,-36(fp)
8110c0c0:	10800044 	addi	r2,r2,1
8110c0c4:	e0bff715 	stw	r2,-36(fp)
8110c0c8:	e0bff717 	ldw	r2,-36(fp)
8110c0cc:	10800210 	cmplti	r2,r2,8
8110c0d0:	103fe31e 	bne	r2,zero,8110c060 <__reset+0xfb0ec060>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c0d4:	e03ff715 	stw	zero,-36(fp)
8110c0d8:	00001a06 	br	8110c144 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c0dc:	e0bff517 	ldw	r2,-44(fp)
8110c0e0:	1085883a 	add	r2,r2,r2
8110c0e4:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c0e8:	00a00034 	movhi	r2,32768
8110c0ec:	10825404 	addi	r2,r2,2384
8110c0f0:	10800037 	ldwio	r2,0(r2)
8110c0f4:	1080004c 	andi	r2,r2,1
8110c0f8:	1007883a 	mov	r3,r2
8110c0fc:	e0bff517 	ldw	r2,-44(fp)
8110c100:	10c4b03a 	or	r2,r2,r3
8110c104:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c108:	00c00044 	movi	r3,1
8110c10c:	00a00034 	movhi	r2,32768
8110c110:	10824c04 	addi	r2,r2,2352
8110c114:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c118:	010003c4 	movi	r4,15
8110c11c:	1137a780 	call	81137a78 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c120:	0007883a 	mov	r3,zero
8110c124:	00a00034 	movhi	r2,32768
8110c128:	10824c04 	addi	r2,r2,2352
8110c12c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c130:	010003c4 	movi	r4,15
8110c134:	1137a780 	call	81137a78 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c138:	e0bff717 	ldw	r2,-36(fp)
8110c13c:	10800044 	addi	r2,r2,1
8110c140:	e0bff715 	stw	r2,-36(fp)
8110c144:	e0bff717 	ldw	r2,-36(fp)
8110c148:	10800190 	cmplti	r2,r2,6
8110c14c:	103fe31e 	bne	r2,zero,8110c0dc <__reset+0xfb0ec0dc>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110c150:	00c00044 	movi	r3,1
8110c154:	00a00034 	movhi	r2,32768
8110c158:	10824c04 	addi	r2,r2,2352
8110c15c:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110c160:	010003c4 	movi	r4,15
8110c164:	1137a780 	call	81137a78 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c168:	00c000c4 	movi	r3,3
8110c16c:	00a00034 	movhi	r2,32768
8110c170:	10824804 	addi	r2,r2,2336
8110c174:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110c178:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110c17c:	00800044 	movi	r2,1
8110c180:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110c184:	e03ff715 	stw	zero,-36(fp)
8110c188:	00000d06 	br	8110c1c0 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110c18c:	e0fff517 	ldw	r3,-44(fp)
8110c190:	e0bff617 	ldw	r2,-40(fp)
8110c194:	1884703a 	and	r2,r3,r2
8110c198:	1000031e 	bne	r2,zero,8110c1a8 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110c19c:	e0bff917 	ldw	r2,-28(fp)
8110c1a0:	10800044 	addi	r2,r2,1
8110c1a4:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110c1a8:	e0bff617 	ldw	r2,-40(fp)
8110c1ac:	1085883a 	add	r2,r2,r2
8110c1b0:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110c1b4:	e0bff717 	ldw	r2,-36(fp)
8110c1b8:	10800044 	addi	r2,r2,1
8110c1bc:	e0bff715 	stw	r2,-36(fp)
8110c1c0:	e0bff717 	ldw	r2,-36(fp)
8110c1c4:	10800810 	cmplti	r2,r2,32
8110c1c8:	103ff01e 	bne	r2,zero,8110c18c <__reset+0xfb0ec18c>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110c1cc:	e0bff917 	ldw	r2,-28(fp)
8110c1d0:	1080004c 	andi	r2,r2,1
8110c1d4:	1005003a 	cmpeq	r2,r2,zero
8110c1d8:	10803fcc 	andi	r2,r2,255
8110c1dc:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110c1e0:	e0bffb17 	ldw	r2,-20(fp)
8110c1e4:	1000021e 	bne	r2,zero,8110c1f0 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110c1e8:	0005883a 	mov	r2,zero
8110c1ec:	00000406 	br	8110c200 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110c1f0:	e0800317 	ldw	r2,12(fp)
8110c1f4:	e0fff517 	ldw	r3,-44(fp)
8110c1f8:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110c1fc:	e0bffb17 	ldw	r2,-20(fp)
}
8110c200:	e037883a 	mov	sp,fp
8110c204:	dfc00117 	ldw	ra,4(sp)
8110c208:	df000017 	ldw	fp,0(sp)
8110c20c:	dec00204 	addi	sp,sp,8
8110c210:	f800283a 	ret

8110c214 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110c214:	defffc04 	addi	sp,sp,-16
8110c218:	de00012e 	bgeu	sp,et,8110c220 <vRstcSimucamReset+0xc>
8110c21c:	003b68fa 	trap	3
8110c220:	dfc00315 	stw	ra,12(sp)
8110c224:	df000215 	stw	fp,8(sp)
8110c228:	df000204 	addi	fp,sp,8
8110c22c:	2005883a 	mov	r2,r4
8110c230:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110c234:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110c238:	e0bfff0b 	ldhu	r2,-4(fp)
8110c23c:	e0fffe17 	ldw	r3,-8(fp)
8110c240:	1884b03a 	or	r2,r3,r2
8110c244:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110c248:	e0bffe17 	ldw	r2,-8(fp)
8110c24c:	10800074 	orhi	r2,r2,1
8110c250:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c254:	e1bffe17 	ldw	r6,-8(fp)
8110c258:	000b883a 	mov	r5,zero
8110c25c:	01200034 	movhi	r4,32768
8110c260:	21020004 	addi	r4,r4,2048
8110c264:	110c3640 	call	8110c364 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110c268:	0001883a 	nop
8110c26c:	e037883a 	mov	sp,fp
8110c270:	dfc00117 	ldw	ra,4(sp)
8110c274:	df000017 	ldw	fp,0(sp)
8110c278:	dec00204 	addi	sp,sp,8
8110c27c:	f800283a 	ret

8110c280 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110c280:	defffc04 	addi	sp,sp,-16
8110c284:	de00012e 	bgeu	sp,et,8110c28c <vRstcReleaseDeviceReset+0xc>
8110c288:	003b68fa 	trap	3
8110c28c:	dfc00315 	stw	ra,12(sp)
8110c290:	df000215 	stw	fp,8(sp)
8110c294:	df000204 	addi	fp,sp,8
8110c298:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c29c:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c2a0:	01400044 	movi	r5,1
8110c2a4:	01200034 	movhi	r4,32768
8110c2a8:	21020004 	addi	r4,r4,2048
8110c2ac:	110c3b80 	call	8110c3b8 <uliRstReadReg>
8110c2b0:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110c2b4:	e0bfff17 	ldw	r2,-4(fp)
8110c2b8:	0084303a 	nor	r2,zero,r2
8110c2bc:	e0fffe17 	ldw	r3,-8(fp)
8110c2c0:	1884703a 	and	r2,r3,r2
8110c2c4:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c2c8:	e1bffe17 	ldw	r6,-8(fp)
8110c2cc:	01400044 	movi	r5,1
8110c2d0:	01200034 	movhi	r4,32768
8110c2d4:	21020004 	addi	r4,r4,2048
8110c2d8:	110c3640 	call	8110c364 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c2dc:	0001883a 	nop
8110c2e0:	e037883a 	mov	sp,fp
8110c2e4:	dfc00117 	ldw	ra,4(sp)
8110c2e8:	df000017 	ldw	fp,0(sp)
8110c2ec:	dec00204 	addi	sp,sp,8
8110c2f0:	f800283a 	ret

8110c2f4 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110c2f4:	defffc04 	addi	sp,sp,-16
8110c2f8:	de00012e 	bgeu	sp,et,8110c300 <vRstcHoldDeviceReset+0xc>
8110c2fc:	003b68fa 	trap	3
8110c300:	dfc00315 	stw	ra,12(sp)
8110c304:	df000215 	stw	fp,8(sp)
8110c308:	df000204 	addi	fp,sp,8
8110c30c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c310:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c314:	01400044 	movi	r5,1
8110c318:	01200034 	movhi	r4,32768
8110c31c:	21020004 	addi	r4,r4,2048
8110c320:	110c3b80 	call	8110c3b8 <uliRstReadReg>
8110c324:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110c328:	e0fffe17 	ldw	r3,-8(fp)
8110c32c:	e0bfff17 	ldw	r2,-4(fp)
8110c330:	1884b03a 	or	r2,r3,r2
8110c334:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c338:	e1bffe17 	ldw	r6,-8(fp)
8110c33c:	01400044 	movi	r5,1
8110c340:	01200034 	movhi	r4,32768
8110c344:	21020004 	addi	r4,r4,2048
8110c348:	110c3640 	call	8110c364 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c34c:	0001883a 	nop
8110c350:	e037883a 	mov	sp,fp
8110c354:	dfc00117 	ldw	ra,4(sp)
8110c358:	df000017 	ldw	fp,0(sp)
8110c35c:	dec00204 	addi	sp,sp,8
8110c360:	f800283a 	ret

8110c364 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110c364:	defffc04 	addi	sp,sp,-16
8110c368:	de00012e 	bgeu	sp,et,8110c370 <vRstcWriteReg+0xc>
8110c36c:	003b68fa 	trap	3
8110c370:	df000315 	stw	fp,12(sp)
8110c374:	df000304 	addi	fp,sp,12
8110c378:	e13ffd15 	stw	r4,-12(fp)
8110c37c:	e17ffe15 	stw	r5,-8(fp)
8110c380:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110c384:	e0bffe17 	ldw	r2,-8(fp)
8110c388:	1085883a 	add	r2,r2,r2
8110c38c:	1085883a 	add	r2,r2,r2
8110c390:	1007883a 	mov	r3,r2
8110c394:	e0bffd17 	ldw	r2,-12(fp)
8110c398:	10c5883a 	add	r2,r2,r3
8110c39c:	e0ffff17 	ldw	r3,-4(fp)
8110c3a0:	10c00015 	stw	r3,0(r2)
}
8110c3a4:	0001883a 	nop
8110c3a8:	e037883a 	mov	sp,fp
8110c3ac:	df000017 	ldw	fp,0(sp)
8110c3b0:	dec00104 	addi	sp,sp,4
8110c3b4:	f800283a 	ret

8110c3b8 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110c3b8:	defffc04 	addi	sp,sp,-16
8110c3bc:	de00012e 	bgeu	sp,et,8110c3c4 <uliRstReadReg+0xc>
8110c3c0:	003b68fa 	trap	3
8110c3c4:	df000315 	stw	fp,12(sp)
8110c3c8:	df000304 	addi	fp,sp,12
8110c3cc:	e13ffe15 	stw	r4,-8(fp)
8110c3d0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110c3d4:	e0bfff17 	ldw	r2,-4(fp)
8110c3d8:	1085883a 	add	r2,r2,r2
8110c3dc:	1085883a 	add	r2,r2,r2
8110c3e0:	1007883a 	mov	r3,r2
8110c3e4:	e0bffe17 	ldw	r2,-8(fp)
8110c3e8:	10c5883a 	add	r2,r2,r3
8110c3ec:	10800017 	ldw	r2,0(r2)
8110c3f0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110c3f4:	e0bffd17 	ldw	r2,-12(fp)
}
8110c3f8:	e037883a 	mov	sp,fp
8110c3fc:	df000017 	ldw	fp,0(sp)
8110c400:	dec00104 	addi	sp,sp,4
8110c404:	f800283a 	ret

8110c408 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110c408:	defffe04 	addi	sp,sp,-8
8110c40c:	de00012e 	bgeu	sp,et,8110c414 <v_spi_start+0xc>
8110c410:	003b68fa 	trap	3
8110c414:	dfc00115 	stw	ra,4(sp)
8110c418:	df000015 	stw	fp,0(sp)
8110c41c:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110c420:	0007883a 	mov	r3,zero
8110c424:	00a00034 	movhi	r2,32768
8110c428:	10823004 	addi	r2,r2,2240
8110c42c:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110c430:	0007883a 	mov	r3,zero
8110c434:	00a00034 	movhi	r2,32768
8110c438:	10822c04 	addi	r2,r2,2224
8110c43c:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c440:	01002584 	movi	r4,150
8110c444:	1137a780 	call	81137a78 <usleep>
}
8110c448:	0001883a 	nop
8110c44c:	e037883a 	mov	sp,fp
8110c450:	dfc00117 	ldw	ra,4(sp)
8110c454:	df000017 	ldw	fp,0(sp)
8110c458:	dec00204 	addi	sp,sp,8
8110c45c:	f800283a 	ret

8110c460 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110c460:	defffc04 	addi	sp,sp,-16
8110c464:	de00012e 	bgeu	sp,et,8110c46c <v_spi_send_byte+0xc>
8110c468:	003b68fa 	trap	3
8110c46c:	dfc00315 	stw	ra,12(sp)
8110c470:	df000215 	stw	fp,8(sp)
8110c474:	df000204 	addi	fp,sp,8
8110c478:	2005883a 	mov	r2,r4
8110c47c:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110c480:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110c484:	00bfe004 	movi	r2,-128
8110c488:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110c48c:	e03ffe05 	stb	zero,-8(fp)
8110c490:	00001b06 	br	8110c500 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110c494:	e0ffff03 	ldbu	r3,-4(fp)
8110c498:	e0bffe43 	ldbu	r2,-7(fp)
8110c49c:	1884703a 	and	r2,r3,r2
8110c4a0:	10803fcc 	andi	r2,r2,255
8110c4a4:	1004c03a 	cmpne	r2,r2,zero
8110c4a8:	10c03fcc 	andi	r3,r2,255
8110c4ac:	00a00034 	movhi	r2,32768
8110c4b0:	10823404 	addi	r2,r2,2256
8110c4b4:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110c4b8:	e0bffe43 	ldbu	r2,-7(fp)
8110c4bc:	1004d07a 	srli	r2,r2,1
8110c4c0:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c4c4:	00c00044 	movi	r3,1
8110c4c8:	00a00034 	movhi	r2,32768
8110c4cc:	10823004 	addi	r2,r2,2240
8110c4d0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c4d4:	01002584 	movi	r4,150
8110c4d8:	1137a780 	call	81137a78 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c4dc:	0007883a 	mov	r3,zero
8110c4e0:	00a00034 	movhi	r2,32768
8110c4e4:	10823004 	addi	r2,r2,2240
8110c4e8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c4ec:	01002584 	movi	r4,150
8110c4f0:	1137a780 	call	81137a78 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110c4f4:	e0bffe03 	ldbu	r2,-8(fp)
8110c4f8:	10800044 	addi	r2,r2,1
8110c4fc:	e0bffe05 	stb	r2,-8(fp)
8110c500:	e0bffe03 	ldbu	r2,-8(fp)
8110c504:	10800230 	cmpltui	r2,r2,8
8110c508:	103fe21e 	bne	r2,zero,8110c494 <__reset+0xfb0ec494>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110c50c:	0001883a 	nop
8110c510:	e037883a 	mov	sp,fp
8110c514:	dfc00117 	ldw	ra,4(sp)
8110c518:	df000017 	ldw	fp,0(sp)
8110c51c:	dec00204 	addi	sp,sp,8
8110c520:	f800283a 	ret

8110c524 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110c524:	defffd04 	addi	sp,sp,-12
8110c528:	de00012e 	bgeu	sp,et,8110c530 <uc_spi_get_byte+0xc>
8110c52c:	003b68fa 	trap	3
8110c530:	dfc00215 	stw	ra,8(sp)
8110c534:	df000115 	stw	fp,4(sp)
8110c538:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110c53c:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110c540:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110c544:	e03fff05 	stb	zero,-4(fp)
8110c548:	00001a06 	br	8110c5b4 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110c54c:	e0bfff43 	ldbu	r2,-3(fp)
8110c550:	1085883a 	add	r2,r2,r2
8110c554:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110c558:	00a00034 	movhi	r2,32768
8110c55c:	10823804 	addi	r2,r2,2272
8110c560:	10800037 	ldwio	r2,0(r2)
8110c564:	1080004c 	andi	r2,r2,1
8110c568:	1007883a 	mov	r3,r2
8110c56c:	e0bfff43 	ldbu	r2,-3(fp)
8110c570:	1884b03a 	or	r2,r3,r2
8110c574:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c578:	00c00044 	movi	r3,1
8110c57c:	00a00034 	movhi	r2,32768
8110c580:	10823004 	addi	r2,r2,2240
8110c584:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c588:	01002584 	movi	r4,150
8110c58c:	1137a780 	call	81137a78 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c590:	0007883a 	mov	r3,zero
8110c594:	00a00034 	movhi	r2,32768
8110c598:	10823004 	addi	r2,r2,2240
8110c59c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c5a0:	01002584 	movi	r4,150
8110c5a4:	1137a780 	call	81137a78 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110c5a8:	e0bfff03 	ldbu	r2,-4(fp)
8110c5ac:	10800044 	addi	r2,r2,1
8110c5b0:	e0bfff05 	stb	r2,-4(fp)
8110c5b4:	e0bfff03 	ldbu	r2,-4(fp)
8110c5b8:	10800230 	cmpltui	r2,r2,8
8110c5bc:	103fe31e 	bne	r2,zero,8110c54c <__reset+0xfb0ec54c>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110c5c0:	e0bfff43 	ldbu	r2,-3(fp)
}
8110c5c4:	e037883a 	mov	sp,fp
8110c5c8:	dfc00117 	ldw	ra,4(sp)
8110c5cc:	df000017 	ldw	fp,0(sp)
8110c5d0:	dec00204 	addi	sp,sp,8
8110c5d4:	f800283a 	ret

8110c5d8 <v_spi_end>:

void v_spi_end(void){
8110c5d8:	defffe04 	addi	sp,sp,-8
8110c5dc:	de00012e 	bgeu	sp,et,8110c5e4 <v_spi_end+0xc>
8110c5e0:	003b68fa 	trap	3
8110c5e4:	dfc00115 	stw	ra,4(sp)
8110c5e8:	df000015 	stw	fp,0(sp)
8110c5ec:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110c5f0:	0007883a 	mov	r3,zero
8110c5f4:	00a00034 	movhi	r2,32768
8110c5f8:	10823004 	addi	r2,r2,2240
8110c5fc:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c600:	01002584 	movi	r4,150
8110c604:	1137a780 	call	81137a78 <usleep>
    SPI_CS_N(1);
8110c608:	00c00044 	movi	r3,1
8110c60c:	00a00034 	movhi	r2,32768
8110c610:	10822c04 	addi	r2,r2,2224
8110c614:	10c00035 	stwio	r3,0(r2)
}
8110c618:	0001883a 	nop
8110c61c:	e037883a 	mov	sp,fp
8110c620:	dfc00117 	ldw	ra,4(sp)
8110c624:	df000017 	ldw	fp,0(sp)
8110c628:	dec00204 	addi	sp,sp,8
8110c62c:	f800283a 	ret

8110c630 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110c630:	defff604 	addi	sp,sp,-40
8110c634:	de00012e 	bgeu	sp,et,8110c63c <RTCC_SPI_R_MAC+0xc>
8110c638:	003b68fa 	trap	3
8110c63c:	dfc00915 	stw	ra,36(sp)
8110c640:	df000815 	stw	fp,32(sp)
8110c644:	df000804 	addi	fp,sp,32
8110c648:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c64c:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110c650:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110c654:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110c658:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110c65c:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110c660:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110c664:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110c668:	00800084 	movi	r2,2
8110c66c:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110c670:	00800cc4 	movi	r2,51
8110c674:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110c678:	110c4080 	call	8110c408 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110c67c:	e0bffec3 	ldbu	r2,-5(fp)
8110c680:	1009883a 	mov	r4,r2
8110c684:	110c4600 	call	8110c460 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110c688:	e0bffe83 	ldbu	r2,-6(fp)
8110c68c:	1009883a 	mov	r4,r2
8110c690:	110c4600 	call	8110c460 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110c694:	110c5240 	call	8110c524 <uc_spi_get_byte>
8110c698:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110c69c:	110c5240 	call	8110c524 <uc_spi_get_byte>
8110c6a0:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110c6a4:	110c5240 	call	8110c524 <uc_spi_get_byte>
8110c6a8:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110c6ac:	110c5240 	call	8110c524 <uc_spi_get_byte>
8110c6b0:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110c6b4:	110c5240 	call	8110c524 <uc_spi_get_byte>
8110c6b8:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110c6bc:	110c5240 	call	8110c524 <uc_spi_get_byte>
8110c6c0:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110c6c4:	110c5d80 	call	8110c5d8 <v_spi_end>

    bSuccess = TRUE;
8110c6c8:	00800044 	movi	r2,1
8110c6cc:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110c6d0:	e0bfff17 	ldw	r2,-4(fp)
8110c6d4:	e0fffd03 	ldbu	r3,-12(fp)
8110c6d8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110c6dc:	e0bfff17 	ldw	r2,-4(fp)
8110c6e0:	10800044 	addi	r2,r2,1
8110c6e4:	e0fffd43 	ldbu	r3,-11(fp)
8110c6e8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110c6ec:	e0bfff17 	ldw	r2,-4(fp)
8110c6f0:	10800084 	addi	r2,r2,2
8110c6f4:	e0fffd83 	ldbu	r3,-10(fp)
8110c6f8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110c6fc:	e0bfff17 	ldw	r2,-4(fp)
8110c700:	108000c4 	addi	r2,r2,3
8110c704:	e0fffdc3 	ldbu	r3,-9(fp)
8110c708:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110c70c:	e0bfff17 	ldw	r2,-4(fp)
8110c710:	10800104 	addi	r2,r2,4
8110c714:	e0fffe03 	ldbu	r3,-8(fp)
8110c718:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110c71c:	e0bfff17 	ldw	r2,-4(fp)
8110c720:	10800144 	addi	r2,r2,5
8110c724:	e0fffe43 	ldbu	r3,-7(fp)
8110c728:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110c72c:	e1bffd03 	ldbu	r6,-12(fp)
8110c730:	e1fffd43 	ldbu	r7,-11(fp)
8110c734:	e0bffd83 	ldbu	r2,-10(fp)
8110c738:	e0fffdc3 	ldbu	r3,-9(fp)
8110c73c:	e13ffe03 	ldbu	r4,-8(fp)
8110c740:	e17ffe43 	ldbu	r5,-7(fp)
8110c744:	d9400315 	stw	r5,12(sp)
8110c748:	d9000215 	stw	r4,8(sp)
8110c74c:	d8c00115 	stw	r3,4(sp)
8110c750:	d8800015 	stw	r2,0(sp)
8110c754:	01604574 	movhi	r5,33045
8110c758:	2970d504 	addi	r5,r5,-15532
8110c75c:	01204574 	movhi	r4,33045
8110c760:	210cfa04 	addi	r4,r4,13288
8110c764:	1122cd40 	call	81122cd4 <sprintf>
	debug(fp, cDebugBuffer);
8110c768:	d0a06217 	ldw	r2,-32376(gp)
8110c76c:	01604574 	movhi	r5,33045
8110c770:	294cfa04 	addi	r5,r5,13288
8110c774:	1009883a 	mov	r4,r2
8110c778:	11213440 	call	81121344 <fprintf>
#endif

    return bSuccess;
8110c77c:	e0bffc17 	ldw	r2,-16(fp)
}
8110c780:	e037883a 	mov	sp,fp
8110c784:	dfc00117 	ldw	ra,4(sp)
8110c788:	df000017 	ldw	fp,0(sp)
8110c78c:	dec00204 	addi	sp,sp,8
8110c790:	f800283a 	ret

8110c794 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110c794:	defffd04 	addi	sp,sp,-12
8110c798:	de00012e 	bgeu	sp,et,8110c7a0 <bSSDisplayConfig+0xc>
8110c79c:	003b68fa 	trap	3
8110c7a0:	df000215 	stw	fp,8(sp)
8110c7a4:	df000204 	addi	fp,sp,8
8110c7a8:	2005883a 	mov	r2,r4
8110c7ac:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110c7b0:	e0bfff03 	ldbu	r2,-4(fp)
8110c7b4:	10c00168 	cmpgeui	r3,r2,5
8110c7b8:	18001c1e 	bne	r3,zero,8110c82c <bSSDisplayConfig+0x98>
8110c7bc:	100690ba 	slli	r3,r2,2
8110c7c0:	00a04474 	movhi	r2,33041
8110c7c4:	10b1f504 	addi	r2,r2,-14380
8110c7c8:	1885883a 	add	r2,r3,r2
8110c7cc:	10800017 	ldw	r2,0(r2)
8110c7d0:	1000683a 	jmp	r2
8110c7d4:	8110c7e8 	cmpgeui	r4,r16,17183
8110c7d8:	8110c7f4 	orhi	r4,r16,17183
8110c7dc:	8110c800 	call	88110c80 <__reset+0x20f0c80>
8110c7e0:	8110c814 	ori	r4,r16,17184
8110c7e4:	8110c824 	muli	r4,r16,17184
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110c7e8:	00800cc4 	movi	r2,51
8110c7ec:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c7f0:	00001006 	br	8110c834 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110c7f4:	00801544 	movi	r2,85
8110c7f8:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c7fc:	00000d06 	br	8110c834 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110c800:	d0e05043 	ldbu	r3,-32447(gp)
8110c804:	00bff744 	movi	r2,-35
8110c808:	1884703a 	and	r2,r3,r2
8110c80c:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c810:	00000806 	br	8110c834 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110c814:	d0a05043 	ldbu	r2,-32447(gp)
8110c818:	10800894 	ori	r2,r2,34
8110c81c:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c820:	00000406 	br	8110c834 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110c824:	d0205045 	stb	zero,-32447(gp)
	    break;
8110c828:	00000206 	br	8110c834 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110c82c:	0005883a 	mov	r2,zero
8110c830:	00000806 	br	8110c854 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c834:	00a00034 	movhi	r2,32768
8110c838:	10828404 	addi	r2,r2,2576
8110c83c:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110c840:	d0a05043 	ldbu	r2,-32447(gp)
8110c844:	10c03fcc 	andi	r3,r2,255
8110c848:	e0bffe17 	ldw	r2,-8(fp)
8110c84c:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c850:	00800044 	movi	r2,1
}
8110c854:	e037883a 	mov	sp,fp
8110c858:	df000017 	ldw	fp,0(sp)
8110c85c:	dec00104 	addi	sp,sp,4
8110c860:	f800283a 	ret

8110c864 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110c864:	defffd04 	addi	sp,sp,-12
8110c868:	de00012e 	bgeu	sp,et,8110c870 <bSSDisplayUpdate+0xc>
8110c86c:	003b68fa 	trap	3
8110c870:	df000215 	stw	fp,8(sp)
8110c874:	df000204 	addi	fp,sp,8
8110c878:	2005883a 	mov	r2,r4
8110c87c:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c880:	00a00034 	movhi	r2,32768
8110c884:	10828404 	addi	r2,r2,2576
8110c888:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110c88c:	e0bffe17 	ldw	r2,-8(fp)
8110c890:	10800104 	addi	r2,r2,4
8110c894:	e0ffff03 	ldbu	r3,-4(fp)
8110c898:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c89c:	00800044 	movi	r2,1
}
8110c8a0:	e037883a 	mov	sp,fp
8110c8a4:	df000017 	ldw	fp,0(sp)
8110c8a8:	dec00104 	addi	sp,sp,4
8110c8ac:	f800283a 	ret

8110c8b0 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110c8b0:	defff904 	addi	sp,sp,-28
8110c8b4:	de00012e 	bgeu	sp,et,8110c8bc <vSyncHandleIrq+0xc>
8110c8b8:	003b68fa 	trap	3
8110c8bc:	dfc00615 	stw	ra,24(sp)
8110c8c0:	df000515 	stw	fp,20(sp)
8110c8c4:	df000504 	addi	fp,sp,20
8110c8c8:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110c8cc:	e0bfff17 	ldw	r2,-4(fp)
8110c8d0:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110c8d4:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110c8d8:	d0a05203 	ldbu	r2,-32440(gp)
8110c8dc:	108000cc 	andi	r2,r2,3
8110c8e0:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 )
8110c8e4:	e0bffd03 	ldbu	r2,-12(fp)
8110c8e8:	1000031e 	bne	r2,zero,8110c8f8 <vSyncHandleIrq+0x48>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110c8ec:	00bff804 	movi	r2,-32
8110c8f0:	e0bffe85 	stb	r2,-6(fp)
8110c8f4:	00000206 	br	8110c900 <vSyncHandleIrq+0x50>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110c8f8:	00bff844 	movi	r2,-31
8110c8fc:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110c900:	00800044 	movi	r2,1
8110c904:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110c908:	d0a06917 	ldw	r2,-32348(gp)
8110c90c:	e0fffe17 	ldw	r3,-8(fp)
8110c910:	180b883a 	mov	r5,r3
8110c914:	1009883a 	mov	r4,r2
8110c918:	113defc0 	call	8113defc <OSQPostFront>
8110c91c:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110c920:	e0bffd43 	ldbu	r2,-11(fp)
8110c924:	10000126 	beq	r2,zero,8110c92c <vSyncHandleIrq+0x7c>
		vFailSendMsgMasterSyncMeb( );
8110c928:	111d30c0 	call	8111d30c <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110c92c:	e03ffb05 	stb	zero,-20(fp)
8110c930:	00001606 	br	8110c98c <vSyncHandleIrq+0xdc>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110c934:	e0bffb03 	ldbu	r2,-20(fp)
8110c938:	10800444 	addi	r2,r2,17
8110c93c:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110c940:	e0bffb03 	ldbu	r2,-20(fp)
8110c944:	1085883a 	add	r2,r2,r2
8110c948:	1087883a 	add	r3,r2,r2
8110c94c:	d0a06a04 	addi	r2,gp,-32344
8110c950:	1885883a 	add	r2,r3,r2
8110c954:	10800017 	ldw	r2,0(r2)
8110c958:	e0fffe17 	ldw	r3,-8(fp)
8110c95c:	180b883a 	mov	r5,r3
8110c960:	1009883a 	mov	r4,r2
8110c964:	113defc0 	call	8113defc <OSQPostFront>
8110c968:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110c96c:	e0bffd43 	ldbu	r2,-11(fp)
8110c970:	10000326 	beq	r2,zero,8110c980 <vSyncHandleIrq+0xd0>
			vFailSendMsgSync( ucIL );
8110c974:	e0bffb03 	ldbu	r2,-20(fp)
8110c978:	1009883a 	mov	r4,r2
8110c97c:	111d2640 	call	8111d264 <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110c980:	e0bffb03 	ldbu	r2,-20(fp)
8110c984:	10800044 	addi	r2,r2,1
8110c988:	e0bffb05 	stb	r2,-20(fp)
8110c98c:	e0bffb03 	ldbu	r2,-20(fp)
8110c990:	103fe826 	beq	r2,zero,8110c934 <__reset+0xfb0ec934>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110c994:	d0a05203 	ldbu	r2,-32440(gp)
8110c998:	10800044 	addi	r2,r2,1
8110c99c:	d0a05205 	stb	r2,-32440(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110c9a0:	d0a06217 	ldw	r2,-32376(gp)
8110c9a4:	e0fffd03 	ldbu	r3,-12(fp)
8110c9a8:	180d883a 	mov	r6,r3
8110c9ac:	01604574 	movhi	r5,33045
8110c9b0:	2970e404 	addi	r5,r5,-15472
8110c9b4:	1009883a 	mov	r4,r2
8110c9b8:	11213440 	call	81121344 <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110c9bc:	110ca500 	call	8110ca50 <vSyncIrqFlagClrSync>
}
8110c9c0:	0001883a 	nop
8110c9c4:	e037883a 	mov	sp,fp
8110c9c8:	dfc00117 	ldw	ra,4(sp)
8110c9cc:	df000017 	ldw	fp,0(sp)
8110c9d0:	dec00204 	addi	sp,sp,8
8110c9d4:	f800283a 	ret

8110c9d8 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110c9d8:	deffff04 	addi	sp,sp,-4
8110c9dc:	de00012e 	bgeu	sp,et,8110c9e4 <vSyncClearCounter+0xc>
8110c9e0:	003b68fa 	trap	3
8110c9e4:	df000015 	stw	fp,0(sp)
8110c9e8:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110c9ec:	d0205205 	stb	zero,-32440(gp)
}
8110c9f0:	0001883a 	nop
8110c9f4:	e037883a 	mov	sp,fp
8110c9f8:	df000017 	ldw	fp,0(sp)
8110c9fc:	dec00104 	addi	sp,sp,4
8110ca00:	f800283a 	ret

8110ca04 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110ca04:	defffd04 	addi	sp,sp,-12
8110ca08:	de00012e 	bgeu	sp,et,8110ca10 <vSyncInitIrq+0xc>
8110ca0c:	003b68fa 	trap	3
8110ca10:	dfc00215 	stw	ra,8(sp)
8110ca14:	df000115 	stw	fp,4(sp)
8110ca18:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110ca1c:	d0a05104 	addi	r2,gp,-32444
8110ca20:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110ca24:	01a04474 	movhi	r6,33041
8110ca28:	31b22c04 	addi	r6,r6,-14160
8110ca2c:	e17fff17 	ldw	r5,-4(fp)
8110ca30:	01000284 	movi	r4,10
8110ca34:	11363a80 	call	811363a8 <alt_irq_register>
}
8110ca38:	0001883a 	nop
8110ca3c:	e037883a 	mov	sp,fp
8110ca40:	dfc00117 	ldw	ra,4(sp)
8110ca44:	df000017 	ldw	fp,0(sp)
8110ca48:	dec00204 	addi	sp,sp,8
8110ca4c:	f800283a 	ret

8110ca50 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110ca50:	defffe04 	addi	sp,sp,-8
8110ca54:	de00012e 	bgeu	sp,et,8110ca5c <vSyncIrqFlagClrSync+0xc>
8110ca58:	003b68fa 	trap	3
8110ca5c:	dfc00115 	stw	ra,4(sp)
8110ca60:	df000015 	stw	fp,0(sp)
8110ca64:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110ca68:	01400044 	movi	r5,1
8110ca6c:	010002c4 	movi	r4,11
8110ca70:	110d8300 	call	8110d830 <bSyncWriteReg>
}
8110ca74:	0001883a 	nop
8110ca78:	e037883a 	mov	sp,fp
8110ca7c:	dfc00117 	ldw	ra,4(sp)
8110ca80:	df000017 	ldw	fp,0(sp)
8110ca84:	dec00204 	addi	sp,sp,8
8110ca88:	f800283a 	ret

8110ca8c <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110ca8c:	defffd04 	addi	sp,sp,-12
8110ca90:	de00012e 	bgeu	sp,et,8110ca98 <bSyncIrqFlagSync+0xc>
8110ca94:	003b68fa 	trap	3
8110ca98:	dfc00215 	stw	ra,8(sp)
8110ca9c:	df000115 	stw	fp,4(sp)
8110caa0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110caa4:	01000304 	movi	r4,12
8110caa8:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110caac:	1080004c 	andi	r2,r2,1
8110cab0:	10000326 	beq	r2,zero,8110cac0 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110cab4:	00800044 	movi	r2,1
8110cab8:	e0bfff15 	stw	r2,-4(fp)
8110cabc:	00000106 	br	8110cac4 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110cac0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110cac4:	e0bfff17 	ldw	r2,-4(fp)
}
8110cac8:	e037883a 	mov	sp,fp
8110cacc:	dfc00117 	ldw	ra,4(sp)
8110cad0:	df000017 	ldw	fp,0(sp)
8110cad4:	dec00204 	addi	sp,sp,8
8110cad8:	f800283a 	ret

8110cadc <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110cadc:	defffc04 	addi	sp,sp,-16
8110cae0:	de00012e 	bgeu	sp,et,8110cae8 <bSyncStatusExtnIrq+0xc>
8110cae4:	003b68fa 	trap	3
8110cae8:	dfc00315 	stw	ra,12(sp)
8110caec:	df000215 	stw	fp,8(sp)
8110caf0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110caf4:	0009883a 	mov	r4,zero
8110caf8:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cafc:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110cb00:	e0bfff17 	ldw	r2,-4(fp)
8110cb04:	1000030e 	bge	r2,zero,8110cb14 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110cb08:	00800044 	movi	r2,1
8110cb0c:	e0bffe15 	stw	r2,-8(fp)
8110cb10:	00000106 	br	8110cb18 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110cb14:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110cb18:	e0bffe17 	ldw	r2,-8(fp)
}
8110cb1c:	e037883a 	mov	sp,fp
8110cb20:	dfc00117 	ldw	ra,4(sp)
8110cb24:	df000017 	ldw	fp,0(sp)
8110cb28:	dec00204 	addi	sp,sp,8
8110cb2c:	f800283a 	ret

8110cb30 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110cb30:	defffc04 	addi	sp,sp,-16
8110cb34:	de00012e 	bgeu	sp,et,8110cb3c <ucSyncStatusState+0xc>
8110cb38:	003b68fa 	trap	3
8110cb3c:	dfc00315 	stw	ra,12(sp)
8110cb40:	df000215 	stw	fp,8(sp)
8110cb44:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cb48:	0009883a 	mov	r4,zero
8110cb4c:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cb50:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110cb54:	e0bffe17 	ldw	r2,-8(fp)
8110cb58:	10803fec 	andhi	r2,r2,255
8110cb5c:	1004d43a 	srli	r2,r2,16
8110cb60:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cb64:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cb68:	e037883a 	mov	sp,fp
8110cb6c:	dfc00117 	ldw	ra,4(sp)
8110cb70:	df000017 	ldw	fp,0(sp)
8110cb74:	dec00204 	addi	sp,sp,8
8110cb78:	f800283a 	ret

8110cb7c <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110cb7c:	defffc04 	addi	sp,sp,-16
8110cb80:	de00012e 	bgeu	sp,et,8110cb88 <ucSyncStatusErrorCode+0xc>
8110cb84:	003b68fa 	trap	3
8110cb88:	dfc00315 	stw	ra,12(sp)
8110cb8c:	df000215 	stw	fp,8(sp)
8110cb90:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cb94:	0009883a 	mov	r4,zero
8110cb98:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cb9c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110cba0:	e0bffe17 	ldw	r2,-8(fp)
8110cba4:	10bfc00c 	andi	r2,r2,65280
8110cba8:	1004d23a 	srli	r2,r2,8
8110cbac:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cbb0:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cbb4:	e037883a 	mov	sp,fp
8110cbb8:	dfc00117 	ldw	ra,4(sp)
8110cbbc:	df000017 	ldw	fp,0(sp)
8110cbc0:	dec00204 	addi	sp,sp,8
8110cbc4:	f800283a 	ret

8110cbc8 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110cbc8:	defffc04 	addi	sp,sp,-16
8110cbcc:	de00012e 	bgeu	sp,et,8110cbd4 <ucSyncStatusCycleNumber+0xc>
8110cbd0:	003b68fa 	trap	3
8110cbd4:	dfc00315 	stw	ra,12(sp)
8110cbd8:	df000215 	stw	fp,8(sp)
8110cbdc:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cbe0:	0009883a 	mov	r4,zero
8110cbe4:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cbe8:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110cbec:	e0bffe17 	ldw	r2,-8(fp)
8110cbf0:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cbf4:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cbf8:	e037883a 	mov	sp,fp
8110cbfc:	dfc00117 	ldw	ra,4(sp)
8110cc00:	df000017 	ldw	fp,0(sp)
8110cc04:	dec00204 	addi	sp,sp,8
8110cc08:	f800283a 	ret

8110cc0c <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110cc0c:	defffd04 	addi	sp,sp,-12
8110cc10:	de00012e 	bgeu	sp,et,8110cc18 <bSyncSetMbt+0xc>
8110cc14:	003b68fa 	trap	3
8110cc18:	dfc00215 	stw	ra,8(sp)
8110cc1c:	df000115 	stw	fp,4(sp)
8110cc20:	df000104 	addi	fp,sp,4
8110cc24:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110cc28:	e17fff17 	ldw	r5,-4(fp)
8110cc2c:	01000104 	movi	r4,4
8110cc30:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110cc34:	00800044 	movi	r2,1
}
8110cc38:	e037883a 	mov	sp,fp
8110cc3c:	dfc00117 	ldw	ra,4(sp)
8110cc40:	df000017 	ldw	fp,0(sp)
8110cc44:	dec00204 	addi	sp,sp,8
8110cc48:	f800283a 	ret

8110cc4c <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110cc4c:	defffd04 	addi	sp,sp,-12
8110cc50:	de00012e 	bgeu	sp,et,8110cc58 <bSyncSetBt+0xc>
8110cc54:	003b68fa 	trap	3
8110cc58:	dfc00215 	stw	ra,8(sp)
8110cc5c:	df000115 	stw	fp,4(sp)
8110cc60:	df000104 	addi	fp,sp,4
8110cc64:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110cc68:	e17fff17 	ldw	r5,-4(fp)
8110cc6c:	01000144 	movi	r4,5
8110cc70:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110cc74:	00800044 	movi	r2,1
}
8110cc78:	e037883a 	mov	sp,fp
8110cc7c:	dfc00117 	ldw	ra,4(sp)
8110cc80:	df000017 	ldw	fp,0(sp)
8110cc84:	dec00204 	addi	sp,sp,8
8110cc88:	f800283a 	ret

8110cc8c <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110cc8c:	defffd04 	addi	sp,sp,-12
8110cc90:	de00012e 	bgeu	sp,et,8110cc98 <bSyncSetPer+0xc>
8110cc94:	003b68fa 	trap	3
8110cc98:	dfc00215 	stw	ra,8(sp)
8110cc9c:	df000115 	stw	fp,4(sp)
8110cca0:	df000104 	addi	fp,sp,4
8110cca4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110cca8:	e17fff17 	ldw	r5,-4(fp)
8110ccac:	01000184 	movi	r4,6
8110ccb0:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110ccb4:	00800044 	movi	r2,1
}
8110ccb8:	e037883a 	mov	sp,fp
8110ccbc:	dfc00117 	ldw	ra,4(sp)
8110ccc0:	df000017 	ldw	fp,0(sp)
8110ccc4:	dec00204 	addi	sp,sp,8
8110ccc8:	f800283a 	ret

8110cccc <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110cccc:	defffd04 	addi	sp,sp,-12
8110ccd0:	de00012e 	bgeu	sp,et,8110ccd8 <bSyncSetOst+0xc>
8110ccd4:	003b68fa 	trap	3
8110ccd8:	dfc00215 	stw	ra,8(sp)
8110ccdc:	df000115 	stw	fp,4(sp)
8110cce0:	df000104 	addi	fp,sp,4
8110cce4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110cce8:	e17fff17 	ldw	r5,-4(fp)
8110ccec:	010001c4 	movi	r4,7
8110ccf0:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110ccf4:	00800044 	movi	r2,1
}
8110ccf8:	e037883a 	mov	sp,fp
8110ccfc:	dfc00117 	ldw	ra,4(sp)
8110cd00:	df000017 	ldw	fp,0(sp)
8110cd04:	dec00204 	addi	sp,sp,8
8110cd08:	f800283a 	ret

8110cd0c <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110cd0c:	defffc04 	addi	sp,sp,-16
8110cd10:	de00012e 	bgeu	sp,et,8110cd18 <bSyncSetPolarity+0xc>
8110cd14:	003b68fa 	trap	3
8110cd18:	dfc00315 	stw	ra,12(sp)
8110cd1c:	df000215 	stw	fp,8(sp)
8110cd20:	df000204 	addi	fp,sp,8
8110cd24:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110cd28:	01000204 	movi	r4,8
8110cd2c:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cd30:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cd34:	e0bfff17 	ldw	r2,-4(fp)
8110cd38:	1000051e 	bne	r2,zero,8110cd50 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110cd3c:	e0fffe17 	ldw	r3,-8(fp)
8110cd40:	00bfbfc4 	movi	r2,-257
8110cd44:	1884703a 	and	r2,r3,r2
8110cd48:	e0bffe15 	stw	r2,-8(fp)
8110cd4c:	00000306 	br	8110cd5c <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110cd50:	e0bffe17 	ldw	r2,-8(fp)
8110cd54:	10804014 	ori	r2,r2,256
8110cd58:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110cd5c:	e17ffe17 	ldw	r5,-8(fp)
8110cd60:	01000204 	movi	r4,8
8110cd64:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110cd68:	00800044 	movi	r2,1
}
8110cd6c:	e037883a 	mov	sp,fp
8110cd70:	dfc00117 	ldw	ra,4(sp)
8110cd74:	df000017 	ldw	fp,0(sp)
8110cd78:	dec00204 	addi	sp,sp,8
8110cd7c:	f800283a 	ret

8110cd80 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110cd80:	defffc04 	addi	sp,sp,-16
8110cd84:	de00012e 	bgeu	sp,et,8110cd8c <bSyncSetNCycles+0xc>
8110cd88:	003b68fa 	trap	3
8110cd8c:	dfc00315 	stw	ra,12(sp)
8110cd90:	df000215 	stw	fp,8(sp)
8110cd94:	df000204 	addi	fp,sp,8
8110cd98:	2005883a 	mov	r2,r4
8110cd9c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110cda0:	01000204 	movi	r4,8
8110cda4:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cda8:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110cdac:	e0fffe17 	ldw	r3,-8(fp)
8110cdb0:	00bfc004 	movi	r2,-256
8110cdb4:	1884703a 	and	r2,r3,r2
8110cdb8:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110cdbc:	e0bfff03 	ldbu	r2,-4(fp)
8110cdc0:	e0fffe17 	ldw	r3,-8(fp)
8110cdc4:	1884b03a 	or	r2,r3,r2
8110cdc8:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110cdcc:	e17ffe17 	ldw	r5,-8(fp)
8110cdd0:	01000204 	movi	r4,8
8110cdd4:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110cdd8:	00800044 	movi	r2,1
}
8110cddc:	e037883a 	mov	sp,fp
8110cde0:	dfc00117 	ldw	ra,4(sp)
8110cde4:	df000017 	ldw	fp,0(sp)
8110cde8:	dec00204 	addi	sp,sp,8
8110cdec:	f800283a 	ret

8110cdf0 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110cdf0:	defffd04 	addi	sp,sp,-12
8110cdf4:	de00012e 	bgeu	sp,et,8110cdfc <uliSyncGetMbt+0xc>
8110cdf8:	003b68fa 	trap	3
8110cdfc:	dfc00215 	stw	ra,8(sp)
8110ce00:	df000115 	stw	fp,4(sp)
8110ce04:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110ce08:	01000104 	movi	r4,4
8110ce0c:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110ce10:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110ce14:	e0bfff17 	ldw	r2,-4(fp)
}
8110ce18:	e037883a 	mov	sp,fp
8110ce1c:	dfc00117 	ldw	ra,4(sp)
8110ce20:	df000017 	ldw	fp,0(sp)
8110ce24:	dec00204 	addi	sp,sp,8
8110ce28:	f800283a 	ret

8110ce2c <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110ce2c:	defffd04 	addi	sp,sp,-12
8110ce30:	de00012e 	bgeu	sp,et,8110ce38 <uliSyncGetBt+0xc>
8110ce34:	003b68fa 	trap	3
8110ce38:	dfc00215 	stw	ra,8(sp)
8110ce3c:	df000115 	stw	fp,4(sp)
8110ce40:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110ce44:	01000144 	movi	r4,5
8110ce48:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110ce4c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110ce50:	e0bfff17 	ldw	r2,-4(fp)
}
8110ce54:	e037883a 	mov	sp,fp
8110ce58:	dfc00117 	ldw	ra,4(sp)
8110ce5c:	df000017 	ldw	fp,0(sp)
8110ce60:	dec00204 	addi	sp,sp,8
8110ce64:	f800283a 	ret

8110ce68 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110ce68:	defffd04 	addi	sp,sp,-12
8110ce6c:	de00012e 	bgeu	sp,et,8110ce74 <uliSyncGetPer+0xc>
8110ce70:	003b68fa 	trap	3
8110ce74:	dfc00215 	stw	ra,8(sp)
8110ce78:	df000115 	stw	fp,4(sp)
8110ce7c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110ce80:	01000184 	movi	r4,6
8110ce84:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110ce88:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110ce8c:	e0bfff17 	ldw	r2,-4(fp)
}
8110ce90:	e037883a 	mov	sp,fp
8110ce94:	dfc00117 	ldw	ra,4(sp)
8110ce98:	df000017 	ldw	fp,0(sp)
8110ce9c:	dec00204 	addi	sp,sp,8
8110cea0:	f800283a 	ret

8110cea4 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110cea4:	defffd04 	addi	sp,sp,-12
8110cea8:	de00012e 	bgeu	sp,et,8110ceb0 <uliSyncGetOst+0xc>
8110ceac:	003b68fa 	trap	3
8110ceb0:	dfc00215 	stw	ra,8(sp)
8110ceb4:	df000115 	stw	fp,4(sp)
8110ceb8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110cebc:	010001c4 	movi	r4,7
8110cec0:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cec4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cec8:	e0bfff17 	ldw	r2,-4(fp)
}
8110cecc:	e037883a 	mov	sp,fp
8110ced0:	dfc00117 	ldw	ra,4(sp)
8110ced4:	df000017 	ldw	fp,0(sp)
8110ced8:	dec00204 	addi	sp,sp,8
8110cedc:	f800283a 	ret

8110cee0 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110cee0:	defffd04 	addi	sp,sp,-12
8110cee4:	de00012e 	bgeu	sp,et,8110ceec <uliSyncGetGeneral+0xc>
8110cee8:	003b68fa 	trap	3
8110ceec:	dfc00215 	stw	ra,8(sp)
8110cef0:	df000115 	stw	fp,4(sp)
8110cef4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110cef8:	01000204 	movi	r4,8
8110cefc:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cf00:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf04:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf08:	e037883a 	mov	sp,fp
8110cf0c:	dfc00117 	ldw	ra,4(sp)
8110cf10:	df000017 	ldw	fp,0(sp)
8110cf14:	dec00204 	addi	sp,sp,8
8110cf18:	f800283a 	ret

8110cf1c <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110cf1c:	defffd04 	addi	sp,sp,-12
8110cf20:	de00012e 	bgeu	sp,et,8110cf28 <bSyncErrInj+0xc>
8110cf24:	003b68fa 	trap	3
8110cf28:	dfc00215 	stw	ra,8(sp)
8110cf2c:	df000115 	stw	fp,4(sp)
8110cf30:	df000104 	addi	fp,sp,4
8110cf34:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110cf38:	e17fff17 	ldw	r5,-4(fp)
8110cf3c:	01000244 	movi	r4,9
8110cf40:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110cf44:	00800044 	movi	r2,1
}
8110cf48:	e037883a 	mov	sp,fp
8110cf4c:	dfc00117 	ldw	ra,4(sp)
8110cf50:	df000017 	ldw	fp,0(sp)
8110cf54:	dec00204 	addi	sp,sp,8
8110cf58:	f800283a 	ret

8110cf5c <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110cf5c:	defffc04 	addi	sp,sp,-16
8110cf60:	de00012e 	bgeu	sp,et,8110cf68 <bSyncCtrExtnIrq+0xc>
8110cf64:	003b68fa 	trap	3
8110cf68:	dfc00315 	stw	ra,12(sp)
8110cf6c:	df000215 	stw	fp,8(sp)
8110cf70:	df000204 	addi	fp,sp,8
8110cf74:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cf78:	01000284 	movi	r4,10
8110cf7c:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cf80:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cf84:	e0bfff17 	ldw	r2,-4(fp)
8110cf88:	1000061e 	bne	r2,zero,8110cfa4 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110cf8c:	e0fffe17 	ldw	r3,-8(fp)
8110cf90:	00a00034 	movhi	r2,32768
8110cf94:	10bfffc4 	addi	r2,r2,-1
8110cf98:	1884703a 	and	r2,r3,r2
8110cf9c:	e0bffe15 	stw	r2,-8(fp)
8110cfa0:	00000306 	br	8110cfb0 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110cfa4:	e0bffe17 	ldw	r2,-8(fp)
8110cfa8:	10a00034 	orhi	r2,r2,32768
8110cfac:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cfb0:	e17ffe17 	ldw	r5,-8(fp)
8110cfb4:	01000284 	movi	r4,10
8110cfb8:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110cfbc:	00800044 	movi	r2,1
}
8110cfc0:	e037883a 	mov	sp,fp
8110cfc4:	dfc00117 	ldw	ra,4(sp)
8110cfc8:	df000017 	ldw	fp,0(sp)
8110cfcc:	dec00204 	addi	sp,sp,8
8110cfd0:	f800283a 	ret

8110cfd4 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110cfd4:	defffd04 	addi	sp,sp,-12
8110cfd8:	de00012e 	bgeu	sp,et,8110cfe0 <bSyncCtrStart+0xc>
8110cfdc:	003b68fa 	trap	3
8110cfe0:	dfc00215 	stw	ra,8(sp)
8110cfe4:	df000115 	stw	fp,4(sp)
8110cfe8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cfec:	01000284 	movi	r4,10
8110cff0:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110cff4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110cff8:	e0bfff17 	ldw	r2,-4(fp)
8110cffc:	10800234 	orhi	r2,r2,8
8110d000:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d004:	e17fff17 	ldw	r5,-4(fp)
8110d008:	01000284 	movi	r4,10
8110d00c:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d010:	00800044 	movi	r2,1
}
8110d014:	e037883a 	mov	sp,fp
8110d018:	dfc00117 	ldw	ra,4(sp)
8110d01c:	df000017 	ldw	fp,0(sp)
8110d020:	dec00204 	addi	sp,sp,8
8110d024:	f800283a 	ret

8110d028 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110d028:	defffd04 	addi	sp,sp,-12
8110d02c:	de00012e 	bgeu	sp,et,8110d034 <bSyncCtrReset+0xc>
8110d030:	003b68fa 	trap	3
8110d034:	dfc00215 	stw	ra,8(sp)
8110d038:	df000115 	stw	fp,4(sp)
8110d03c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d040:	01000284 	movi	r4,10
8110d044:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d048:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110d04c:	e0bfff17 	ldw	r2,-4(fp)
8110d050:	10800134 	orhi	r2,r2,4
8110d054:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d058:	e17fff17 	ldw	r5,-4(fp)
8110d05c:	01000284 	movi	r4,10
8110d060:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d064:	00800044 	movi	r2,1
}
8110d068:	e037883a 	mov	sp,fp
8110d06c:	dfc00117 	ldw	ra,4(sp)
8110d070:	df000017 	ldw	fp,0(sp)
8110d074:	dec00204 	addi	sp,sp,8
8110d078:	f800283a 	ret

8110d07c <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110d07c:	defffd04 	addi	sp,sp,-12
8110d080:	de00012e 	bgeu	sp,et,8110d088 <bSyncCtrOneShot+0xc>
8110d084:	003b68fa 	trap	3
8110d088:	dfc00215 	stw	ra,8(sp)
8110d08c:	df000115 	stw	fp,4(sp)
8110d090:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d094:	01000284 	movi	r4,10
8110d098:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d09c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110d0a0:	e0bfff17 	ldw	r2,-4(fp)
8110d0a4:	108000b4 	orhi	r2,r2,2
8110d0a8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d0ac:	e17fff17 	ldw	r5,-4(fp)
8110d0b0:	01000284 	movi	r4,10
8110d0b4:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d0b8:	00800044 	movi	r2,1
}
8110d0bc:	e037883a 	mov	sp,fp
8110d0c0:	dfc00117 	ldw	ra,4(sp)
8110d0c4:	df000017 	ldw	fp,0(sp)
8110d0c8:	dec00204 	addi	sp,sp,8
8110d0cc:	f800283a 	ret

8110d0d0 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110d0d0:	defffd04 	addi	sp,sp,-12
8110d0d4:	de00012e 	bgeu	sp,et,8110d0dc <bSyncCtrErrInj+0xc>
8110d0d8:	003b68fa 	trap	3
8110d0dc:	dfc00215 	stw	ra,8(sp)
8110d0e0:	df000115 	stw	fp,4(sp)
8110d0e4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d0e8:	01000284 	movi	r4,10
8110d0ec:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d0f0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110d0f4:	e0bfff17 	ldw	r2,-4(fp)
8110d0f8:	10800074 	orhi	r2,r2,1
8110d0fc:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d100:	e17fff17 	ldw	r5,-4(fp)
8110d104:	01000284 	movi	r4,10
8110d108:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d10c:	00800044 	movi	r2,1
}
8110d110:	e037883a 	mov	sp,fp
8110d114:	dfc00117 	ldw	ra,4(sp)
8110d118:	df000017 	ldw	fp,0(sp)
8110d11c:	dec00204 	addi	sp,sp,8
8110d120:	f800283a 	ret

8110d124 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110d124:	defffc04 	addi	sp,sp,-16
8110d128:	de00012e 	bgeu	sp,et,8110d130 <bSyncCtrSyncOutEnable+0xc>
8110d12c:	003b68fa 	trap	3
8110d130:	dfc00315 	stw	ra,12(sp)
8110d134:	df000215 	stw	fp,8(sp)
8110d138:	df000204 	addi	fp,sp,8
8110d13c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d140:	01000284 	movi	r4,10
8110d144:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d148:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d14c:	e0bfff17 	ldw	r2,-4(fp)
8110d150:	1000051e 	bne	r2,zero,8110d168 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110d154:	e0fffe17 	ldw	r3,-8(fp)
8110d158:	00bfbfc4 	movi	r2,-257
8110d15c:	1884703a 	and	r2,r3,r2
8110d160:	e0bffe15 	stw	r2,-8(fp)
8110d164:	00000306 	br	8110d174 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110d168:	e0bffe17 	ldw	r2,-8(fp)
8110d16c:	10804014 	ori	r2,r2,256
8110d170:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d174:	e17ffe17 	ldw	r5,-8(fp)
8110d178:	01000284 	movi	r4,10
8110d17c:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d180:	00800044 	movi	r2,1
}
8110d184:	e037883a 	mov	sp,fp
8110d188:	dfc00117 	ldw	ra,4(sp)
8110d18c:	df000017 	ldw	fp,0(sp)
8110d190:	dec00204 	addi	sp,sp,8
8110d194:	f800283a 	ret

8110d198 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110d198:	defffc04 	addi	sp,sp,-16
8110d19c:	de00012e 	bgeu	sp,et,8110d1a4 <bSyncCtrCh1OutEnable+0xc>
8110d1a0:	003b68fa 	trap	3
8110d1a4:	dfc00315 	stw	ra,12(sp)
8110d1a8:	df000215 	stw	fp,8(sp)
8110d1ac:	df000204 	addi	fp,sp,8
8110d1b0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d1b4:	01000284 	movi	r4,10
8110d1b8:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d1bc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d1c0:	e0bfff17 	ldw	r2,-4(fp)
8110d1c4:	1000051e 	bne	r2,zero,8110d1dc <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110d1c8:	e0fffe17 	ldw	r3,-8(fp)
8110d1cc:	00bfff84 	movi	r2,-2
8110d1d0:	1884703a 	and	r2,r3,r2
8110d1d4:	e0bffe15 	stw	r2,-8(fp)
8110d1d8:	00000306 	br	8110d1e8 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110d1dc:	e0bffe17 	ldw	r2,-8(fp)
8110d1e0:	10800054 	ori	r2,r2,1
8110d1e4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d1e8:	e17ffe17 	ldw	r5,-8(fp)
8110d1ec:	01000284 	movi	r4,10
8110d1f0:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d1f4:	00800044 	movi	r2,1
}
8110d1f8:	e037883a 	mov	sp,fp
8110d1fc:	dfc00117 	ldw	ra,4(sp)
8110d200:	df000017 	ldw	fp,0(sp)
8110d204:	dec00204 	addi	sp,sp,8
8110d208:	f800283a 	ret

8110d20c <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110d20c:	defffc04 	addi	sp,sp,-16
8110d210:	de00012e 	bgeu	sp,et,8110d218 <bSyncCtrCh2OutEnable+0xc>
8110d214:	003b68fa 	trap	3
8110d218:	dfc00315 	stw	ra,12(sp)
8110d21c:	df000215 	stw	fp,8(sp)
8110d220:	df000204 	addi	fp,sp,8
8110d224:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d228:	01000284 	movi	r4,10
8110d22c:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d230:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d234:	e0bfff17 	ldw	r2,-4(fp)
8110d238:	1000051e 	bne	r2,zero,8110d250 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110d23c:	e0fffe17 	ldw	r3,-8(fp)
8110d240:	00bfff44 	movi	r2,-3
8110d244:	1884703a 	and	r2,r3,r2
8110d248:	e0bffe15 	stw	r2,-8(fp)
8110d24c:	00000306 	br	8110d25c <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110d250:	e0bffe17 	ldw	r2,-8(fp)
8110d254:	10800094 	ori	r2,r2,2
8110d258:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d25c:	e17ffe17 	ldw	r5,-8(fp)
8110d260:	01000284 	movi	r4,10
8110d264:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d268:	00800044 	movi	r2,1
}
8110d26c:	e037883a 	mov	sp,fp
8110d270:	dfc00117 	ldw	ra,4(sp)
8110d274:	df000017 	ldw	fp,0(sp)
8110d278:	dec00204 	addi	sp,sp,8
8110d27c:	f800283a 	ret

8110d280 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110d280:	defffc04 	addi	sp,sp,-16
8110d284:	de00012e 	bgeu	sp,et,8110d28c <bSyncCtrCh3OutEnable+0xc>
8110d288:	003b68fa 	trap	3
8110d28c:	dfc00315 	stw	ra,12(sp)
8110d290:	df000215 	stw	fp,8(sp)
8110d294:	df000204 	addi	fp,sp,8
8110d298:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d29c:	01000284 	movi	r4,10
8110d2a0:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d2a4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d2a8:	e0bfff17 	ldw	r2,-4(fp)
8110d2ac:	1000051e 	bne	r2,zero,8110d2c4 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110d2b0:	e0fffe17 	ldw	r3,-8(fp)
8110d2b4:	00bffec4 	movi	r2,-5
8110d2b8:	1884703a 	and	r2,r3,r2
8110d2bc:	e0bffe15 	stw	r2,-8(fp)
8110d2c0:	00000306 	br	8110d2d0 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110d2c4:	e0bffe17 	ldw	r2,-8(fp)
8110d2c8:	10800114 	ori	r2,r2,4
8110d2cc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d2d0:	e17ffe17 	ldw	r5,-8(fp)
8110d2d4:	01000284 	movi	r4,10
8110d2d8:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d2dc:	00800044 	movi	r2,1
}
8110d2e0:	e037883a 	mov	sp,fp
8110d2e4:	dfc00117 	ldw	ra,4(sp)
8110d2e8:	df000017 	ldw	fp,0(sp)
8110d2ec:	dec00204 	addi	sp,sp,8
8110d2f0:	f800283a 	ret

8110d2f4 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110d2f4:	defffc04 	addi	sp,sp,-16
8110d2f8:	de00012e 	bgeu	sp,et,8110d300 <bSyncCtrCh4OutEnable+0xc>
8110d2fc:	003b68fa 	trap	3
8110d300:	dfc00315 	stw	ra,12(sp)
8110d304:	df000215 	stw	fp,8(sp)
8110d308:	df000204 	addi	fp,sp,8
8110d30c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d310:	01000284 	movi	r4,10
8110d314:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d318:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d31c:	e0bfff17 	ldw	r2,-4(fp)
8110d320:	1000051e 	bne	r2,zero,8110d338 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110d324:	e0fffe17 	ldw	r3,-8(fp)
8110d328:	00bffdc4 	movi	r2,-9
8110d32c:	1884703a 	and	r2,r3,r2
8110d330:	e0bffe15 	stw	r2,-8(fp)
8110d334:	00000306 	br	8110d344 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110d338:	e0bffe17 	ldw	r2,-8(fp)
8110d33c:	10800214 	ori	r2,r2,8
8110d340:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d344:	e17ffe17 	ldw	r5,-8(fp)
8110d348:	01000284 	movi	r4,10
8110d34c:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d350:	00800044 	movi	r2,1
}
8110d354:	e037883a 	mov	sp,fp
8110d358:	dfc00117 	ldw	ra,4(sp)
8110d35c:	df000017 	ldw	fp,0(sp)
8110d360:	dec00204 	addi	sp,sp,8
8110d364:	f800283a 	ret

8110d368 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110d368:	defffc04 	addi	sp,sp,-16
8110d36c:	de00012e 	bgeu	sp,et,8110d374 <bSyncCtrCh5OutEnable+0xc>
8110d370:	003b68fa 	trap	3
8110d374:	dfc00315 	stw	ra,12(sp)
8110d378:	df000215 	stw	fp,8(sp)
8110d37c:	df000204 	addi	fp,sp,8
8110d380:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d384:	01000284 	movi	r4,10
8110d388:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d38c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d390:	e0bfff17 	ldw	r2,-4(fp)
8110d394:	1000051e 	bne	r2,zero,8110d3ac <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110d398:	e0fffe17 	ldw	r3,-8(fp)
8110d39c:	00bffbc4 	movi	r2,-17
8110d3a0:	1884703a 	and	r2,r3,r2
8110d3a4:	e0bffe15 	stw	r2,-8(fp)
8110d3a8:	00000306 	br	8110d3b8 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110d3ac:	e0bffe17 	ldw	r2,-8(fp)
8110d3b0:	10800414 	ori	r2,r2,16
8110d3b4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d3b8:	e17ffe17 	ldw	r5,-8(fp)
8110d3bc:	01000284 	movi	r4,10
8110d3c0:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d3c4:	00800044 	movi	r2,1
}
8110d3c8:	e037883a 	mov	sp,fp
8110d3cc:	dfc00117 	ldw	ra,4(sp)
8110d3d0:	df000017 	ldw	fp,0(sp)
8110d3d4:	dec00204 	addi	sp,sp,8
8110d3d8:	f800283a 	ret

8110d3dc <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110d3dc:	defffc04 	addi	sp,sp,-16
8110d3e0:	de00012e 	bgeu	sp,et,8110d3e8 <bSyncCtrCh6OutEnable+0xc>
8110d3e4:	003b68fa 	trap	3
8110d3e8:	dfc00315 	stw	ra,12(sp)
8110d3ec:	df000215 	stw	fp,8(sp)
8110d3f0:	df000204 	addi	fp,sp,8
8110d3f4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d3f8:	01000284 	movi	r4,10
8110d3fc:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d400:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d404:	e0bfff17 	ldw	r2,-4(fp)
8110d408:	1000051e 	bne	r2,zero,8110d420 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110d40c:	e0fffe17 	ldw	r3,-8(fp)
8110d410:	00bff7c4 	movi	r2,-33
8110d414:	1884703a 	and	r2,r3,r2
8110d418:	e0bffe15 	stw	r2,-8(fp)
8110d41c:	00000306 	br	8110d42c <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110d420:	e0bffe17 	ldw	r2,-8(fp)
8110d424:	10800814 	ori	r2,r2,32
8110d428:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d42c:	e17ffe17 	ldw	r5,-8(fp)
8110d430:	01000284 	movi	r4,10
8110d434:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d438:	00800044 	movi	r2,1
}
8110d43c:	e037883a 	mov	sp,fp
8110d440:	dfc00117 	ldw	ra,4(sp)
8110d444:	df000017 	ldw	fp,0(sp)
8110d448:	dec00204 	addi	sp,sp,8
8110d44c:	f800283a 	ret

8110d450 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110d450:	defffc04 	addi	sp,sp,-16
8110d454:	de00012e 	bgeu	sp,et,8110d45c <bSyncCtrCh7OutEnable+0xc>
8110d458:	003b68fa 	trap	3
8110d45c:	dfc00315 	stw	ra,12(sp)
8110d460:	df000215 	stw	fp,8(sp)
8110d464:	df000204 	addi	fp,sp,8
8110d468:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d46c:	01000284 	movi	r4,10
8110d470:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d474:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d478:	e0bfff17 	ldw	r2,-4(fp)
8110d47c:	1000051e 	bne	r2,zero,8110d494 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110d480:	e0fffe17 	ldw	r3,-8(fp)
8110d484:	00bfefc4 	movi	r2,-65
8110d488:	1884703a 	and	r2,r3,r2
8110d48c:	e0bffe15 	stw	r2,-8(fp)
8110d490:	00000306 	br	8110d4a0 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110d494:	e0bffe17 	ldw	r2,-8(fp)
8110d498:	10801014 	ori	r2,r2,64
8110d49c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d4a0:	e17ffe17 	ldw	r5,-8(fp)
8110d4a4:	01000284 	movi	r4,10
8110d4a8:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d4ac:	00800044 	movi	r2,1
}
8110d4b0:	e037883a 	mov	sp,fp
8110d4b4:	dfc00117 	ldw	ra,4(sp)
8110d4b8:	df000017 	ldw	fp,0(sp)
8110d4bc:	dec00204 	addi	sp,sp,8
8110d4c0:	f800283a 	ret

8110d4c4 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110d4c4:	defffc04 	addi	sp,sp,-16
8110d4c8:	de00012e 	bgeu	sp,et,8110d4d0 <bSyncCtrCh8OutEnable+0xc>
8110d4cc:	003b68fa 	trap	3
8110d4d0:	dfc00315 	stw	ra,12(sp)
8110d4d4:	df000215 	stw	fp,8(sp)
8110d4d8:	df000204 	addi	fp,sp,8
8110d4dc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d4e0:	01000284 	movi	r4,10
8110d4e4:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d4e8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d4ec:	e0bfff17 	ldw	r2,-4(fp)
8110d4f0:	1000051e 	bne	r2,zero,8110d508 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110d4f4:	e0fffe17 	ldw	r3,-8(fp)
8110d4f8:	00bfdfc4 	movi	r2,-129
8110d4fc:	1884703a 	and	r2,r3,r2
8110d500:	e0bffe15 	stw	r2,-8(fp)
8110d504:	00000306 	br	8110d514 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110d508:	e0bffe17 	ldw	r2,-8(fp)
8110d50c:	10802014 	ori	r2,r2,128
8110d510:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d514:	e17ffe17 	ldw	r5,-8(fp)
8110d518:	01000284 	movi	r4,10
8110d51c:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d520:	00800044 	movi	r2,1
}
8110d524:	e037883a 	mov	sp,fp
8110d528:	dfc00117 	ldw	ra,4(sp)
8110d52c:	df000017 	ldw	fp,0(sp)
8110d530:	dec00204 	addi	sp,sp,8
8110d534:	f800283a 	ret

8110d538 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110d538:	defffc04 	addi	sp,sp,-16
8110d53c:	de00012e 	bgeu	sp,et,8110d544 <bSyncIrqEnableError+0xc>
8110d540:	003b68fa 	trap	3
8110d544:	dfc00315 	stw	ra,12(sp)
8110d548:	df000215 	stw	fp,8(sp)
8110d54c:	df000204 	addi	fp,sp,8
8110d550:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d554:	01000044 	movi	r4,1
8110d558:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d55c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d560:	e0bfff17 	ldw	r2,-4(fp)
8110d564:	1000051e 	bne	r2,zero,8110d57c <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110d568:	e0fffe17 	ldw	r3,-8(fp)
8110d56c:	00bfff44 	movi	r2,-3
8110d570:	1884703a 	and	r2,r3,r2
8110d574:	e0bffe15 	stw	r2,-8(fp)
8110d578:	00000306 	br	8110d588 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110d57c:	e0bffe17 	ldw	r2,-8(fp)
8110d580:	10800094 	ori	r2,r2,2
8110d584:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d588:	e17ffe17 	ldw	r5,-8(fp)
8110d58c:	01000044 	movi	r4,1
8110d590:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d594:	00800044 	movi	r2,1
}
8110d598:	e037883a 	mov	sp,fp
8110d59c:	dfc00117 	ldw	ra,4(sp)
8110d5a0:	df000017 	ldw	fp,0(sp)
8110d5a4:	dec00204 	addi	sp,sp,8
8110d5a8:	f800283a 	ret

8110d5ac <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110d5ac:	defffc04 	addi	sp,sp,-16
8110d5b0:	de00012e 	bgeu	sp,et,8110d5b8 <bSyncIrqEnableBlank+0xc>
8110d5b4:	003b68fa 	trap	3
8110d5b8:	dfc00315 	stw	ra,12(sp)
8110d5bc:	df000215 	stw	fp,8(sp)
8110d5c0:	df000204 	addi	fp,sp,8
8110d5c4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d5c8:	01000044 	movi	r4,1
8110d5cc:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d5d0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d5d4:	e0bfff17 	ldw	r2,-4(fp)
8110d5d8:	1000051e 	bne	r2,zero,8110d5f0 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110d5dc:	e0fffe17 	ldw	r3,-8(fp)
8110d5e0:	00bfff84 	movi	r2,-2
8110d5e4:	1884703a 	and	r2,r3,r2
8110d5e8:	e0bffe15 	stw	r2,-8(fp)
8110d5ec:	00000306 	br	8110d5fc <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110d5f0:	e0bffe17 	ldw	r2,-8(fp)
8110d5f4:	10800054 	ori	r2,r2,1
8110d5f8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d5fc:	e17ffe17 	ldw	r5,-8(fp)
8110d600:	01000044 	movi	r4,1
8110d604:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d608:	00800044 	movi	r2,1
}
8110d60c:	e037883a 	mov	sp,fp
8110d610:	dfc00117 	ldw	ra,4(sp)
8110d614:	df000017 	ldw	fp,0(sp)
8110d618:	dec00204 	addi	sp,sp,8
8110d61c:	f800283a 	ret

8110d620 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110d620:	defffc04 	addi	sp,sp,-16
8110d624:	de00012e 	bgeu	sp,et,8110d62c <bSyncIrqFlagClrError+0xc>
8110d628:	003b68fa 	trap	3
8110d62c:	dfc00315 	stw	ra,12(sp)
8110d630:	df000215 	stw	fp,8(sp)
8110d634:	df000204 	addi	fp,sp,8
8110d638:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d63c:	01000084 	movi	r4,2
8110d640:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d644:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d648:	e0bfff17 	ldw	r2,-4(fp)
8110d64c:	1000051e 	bne	r2,zero,8110d664 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d650:	e0fffe17 	ldw	r3,-8(fp)
8110d654:	00bfff44 	movi	r2,-3
8110d658:	1884703a 	and	r2,r3,r2
8110d65c:	e0bffe15 	stw	r2,-8(fp)
8110d660:	00000306 	br	8110d670 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d664:	e0bffe17 	ldw	r2,-8(fp)
8110d668:	10800094 	ori	r2,r2,2
8110d66c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d670:	e17ffe17 	ldw	r5,-8(fp)
8110d674:	01000084 	movi	r4,2
8110d678:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d67c:	00800044 	movi	r2,1
}
8110d680:	e037883a 	mov	sp,fp
8110d684:	dfc00117 	ldw	ra,4(sp)
8110d688:	df000017 	ldw	fp,0(sp)
8110d68c:	dec00204 	addi	sp,sp,8
8110d690:	f800283a 	ret

8110d694 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110d694:	defffc04 	addi	sp,sp,-16
8110d698:	de00012e 	bgeu	sp,et,8110d6a0 <bSyncIrqFlagClrBlank+0xc>
8110d69c:	003b68fa 	trap	3
8110d6a0:	dfc00315 	stw	ra,12(sp)
8110d6a4:	df000215 	stw	fp,8(sp)
8110d6a8:	df000204 	addi	fp,sp,8
8110d6ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d6b0:	01000084 	movi	r4,2
8110d6b4:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d6b8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d6bc:	e0bfff17 	ldw	r2,-4(fp)
8110d6c0:	1000051e 	bne	r2,zero,8110d6d8 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d6c4:	e0fffe17 	ldw	r3,-8(fp)
8110d6c8:	00bfff84 	movi	r2,-2
8110d6cc:	1884703a 	and	r2,r3,r2
8110d6d0:	e0bffe15 	stw	r2,-8(fp)
8110d6d4:	00000306 	br	8110d6e4 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d6d8:	e0bffe17 	ldw	r2,-8(fp)
8110d6dc:	10800054 	ori	r2,r2,1
8110d6e0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d6e4:	e17ffe17 	ldw	r5,-8(fp)
8110d6e8:	01000084 	movi	r4,2
8110d6ec:	110d8300 	call	8110d830 <bSyncWriteReg>
	return TRUE;
8110d6f0:	00800044 	movi	r2,1
}
8110d6f4:	e037883a 	mov	sp,fp
8110d6f8:	dfc00117 	ldw	ra,4(sp)
8110d6fc:	df000017 	ldw	fp,0(sp)
8110d700:	dec00204 	addi	sp,sp,8
8110d704:	f800283a 	ret

8110d708 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110d708:	defffc04 	addi	sp,sp,-16
8110d70c:	de00012e 	bgeu	sp,et,8110d714 <bSyncIrqFlagError+0xc>
8110d710:	003b68fa 	trap	3
8110d714:	dfc00315 	stw	ra,12(sp)
8110d718:	df000215 	stw	fp,8(sp)
8110d71c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d720:	010000c4 	movi	r4,3
8110d724:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d728:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110d72c:	e0bfff17 	ldw	r2,-4(fp)
8110d730:	1080008c 	andi	r2,r2,2
8110d734:	10000326 	beq	r2,zero,8110d744 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110d738:	00800044 	movi	r2,1
8110d73c:	e0bffe15 	stw	r2,-8(fp)
8110d740:	00000106 	br	8110d748 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110d744:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d748:	e0bffe17 	ldw	r2,-8(fp)
}
8110d74c:	e037883a 	mov	sp,fp
8110d750:	dfc00117 	ldw	ra,4(sp)
8110d754:	df000017 	ldw	fp,0(sp)
8110d758:	dec00204 	addi	sp,sp,8
8110d75c:	f800283a 	ret

8110d760 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110d760:	defffc04 	addi	sp,sp,-16
8110d764:	de00012e 	bgeu	sp,et,8110d76c <bSyncIrqFlagBlank+0xc>
8110d768:	003b68fa 	trap	3
8110d76c:	dfc00315 	stw	ra,12(sp)
8110d770:	df000215 	stw	fp,8(sp)
8110d774:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d778:	010000c4 	movi	r4,3
8110d77c:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d780:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110d784:	e0bfff17 	ldw	r2,-4(fp)
8110d788:	1080004c 	andi	r2,r2,1
8110d78c:	10000326 	beq	r2,zero,8110d79c <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110d790:	00800044 	movi	r2,1
8110d794:	e0bffe15 	stw	r2,-8(fp)
8110d798:	00000106 	br	8110d7a0 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110d79c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d7a0:	e0bffe17 	ldw	r2,-8(fp)
}
8110d7a4:	e037883a 	mov	sp,fp
8110d7a8:	dfc00117 	ldw	ra,4(sp)
8110d7ac:	df000017 	ldw	fp,0(sp)
8110d7b0:	dec00204 	addi	sp,sp,8
8110d7b4:	f800283a 	ret

8110d7b8 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110d7b8:	defffd04 	addi	sp,sp,-12
8110d7bc:	de00012e 	bgeu	sp,et,8110d7c4 <uliSyncGetCtr+0xc>
8110d7c0:	003b68fa 	trap	3
8110d7c4:	dfc00215 	stw	ra,8(sp)
8110d7c8:	df000115 	stw	fp,4(sp)
8110d7cc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d7d0:	01000284 	movi	r4,10
8110d7d4:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d7d8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d7dc:	e0bfff17 	ldw	r2,-4(fp)
}
8110d7e0:	e037883a 	mov	sp,fp
8110d7e4:	dfc00117 	ldw	ra,4(sp)
8110d7e8:	df000017 	ldw	fp,0(sp)
8110d7ec:	dec00204 	addi	sp,sp,8
8110d7f0:	f800283a 	ret

8110d7f4 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110d7f4:	defffd04 	addi	sp,sp,-12
8110d7f8:	de00012e 	bgeu	sp,et,8110d800 <uliSyncReadStatus+0xc>
8110d7fc:	003b68fa 	trap	3
8110d800:	dfc00215 	stw	ra,8(sp)
8110d804:	df000115 	stw	fp,4(sp)
8110d808:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d80c:	0009883a 	mov	r4,zero
8110d810:	110d88c0 	call	8110d88c <uliSyncReadReg>
8110d814:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110d818:	e0bfff17 	ldw	r2,-4(fp)
}
8110d81c:	e037883a 	mov	sp,fp
8110d820:	dfc00117 	ldw	ra,4(sp)
8110d824:	df000017 	ldw	fp,0(sp)
8110d828:	dec00204 	addi	sp,sp,8
8110d82c:	f800283a 	ret

8110d830 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110d830:	defffc04 	addi	sp,sp,-16
8110d834:	de00012e 	bgeu	sp,et,8110d83c <bSyncWriteReg+0xc>
8110d838:	003b68fa 	trap	3
8110d83c:	df000315 	stw	fp,12(sp)
8110d840:	df000304 	addi	fp,sp,12
8110d844:	e13ffe15 	stw	r4,-8(fp)
8110d848:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d84c:	00a00034 	movhi	r2,32768
8110d850:	10810004 	addi	r2,r2,1024
8110d854:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110d858:	e0bffe17 	ldw	r2,-8(fp)
8110d85c:	1085883a 	add	r2,r2,r2
8110d860:	1085883a 	add	r2,r2,r2
8110d864:	1007883a 	mov	r3,r2
8110d868:	e0bffd17 	ldw	r2,-12(fp)
8110d86c:	10c5883a 	add	r2,r2,r3
8110d870:	e0ffff17 	ldw	r3,-4(fp)
8110d874:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110d878:	00800044 	movi	r2,1
}
8110d87c:	e037883a 	mov	sp,fp
8110d880:	df000017 	ldw	fp,0(sp)
8110d884:	dec00104 	addi	sp,sp,4
8110d888:	f800283a 	ret

8110d88c <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110d88c:	defffc04 	addi	sp,sp,-16
8110d890:	de00012e 	bgeu	sp,et,8110d898 <uliSyncReadReg+0xc>
8110d894:	003b68fa 	trap	3
8110d898:	df000315 	stw	fp,12(sp)
8110d89c:	df000304 	addi	fp,sp,12
8110d8a0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d8a4:	00a00034 	movhi	r2,32768
8110d8a8:	10810004 	addi	r2,r2,1024
8110d8ac:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110d8b0:	e0bfff17 	ldw	r2,-4(fp)
8110d8b4:	1085883a 	add	r2,r2,r2
8110d8b8:	1085883a 	add	r2,r2,r2
8110d8bc:	1007883a 	mov	r3,r2
8110d8c0:	e0bffd17 	ldw	r2,-12(fp)
8110d8c4:	10c5883a 	add	r2,r2,r3
8110d8c8:	10800017 	ldw	r2,0(r2)
8110d8cc:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110d8d0:	e0bffe17 	ldw	r2,-8(fp)
}
8110d8d4:	e037883a 	mov	sp,fp
8110d8d8:	df000017 	ldw	fp,0(sp)
8110d8dc:	dec00104 	addi	sp,sp,4
8110d8e0:	f800283a 	ret

8110d8e4 <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110d8e4:	defffc04 	addi	sp,sp,-16
8110d8e8:	de00012e 	bgeu	sp,et,8110d8f0 <uliPerCalcPeriodMs+0xc>
8110d8ec:	003b68fa 	trap	3
8110d8f0:	dfc00315 	stw	ra,12(sp)
8110d8f4:	df000215 	stw	fp,8(sp)
8110d8f8:	df000204 	addi	fp,sp,8
8110d8fc:	2005883a 	mov	r2,r4
8110d900:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110d904:	e0bfff0b 	ldhu	r2,-4(fp)
8110d908:	1009883a 	mov	r4,r2
8110d90c:	1120dc80 	call	81120dc8 <__floatsidf>
8110d910:	1011883a 	mov	r8,r2
8110d914:	1813883a 	mov	r9,r3
8110d918:	000d883a 	mov	r6,zero
8110d91c:	01d03a34 	movhi	r7,16616
8110d920:	39da8004 	addi	r7,r7,27136
8110d924:	4009883a 	mov	r4,r8
8110d928:	480b883a 	mov	r5,r9
8110d92c:	111fd240 	call	8111fd24 <__muldf3>
8110d930:	1009883a 	mov	r4,r2
8110d934:	180b883a 	mov	r5,r3
8110d938:	2005883a 	mov	r2,r4
8110d93c:	2807883a 	mov	r3,r5
8110d940:	1009883a 	mov	r4,r2
8110d944:	180b883a 	mov	r5,r3
8110d948:	111f15c0 	call	8111f15c <__fixunsdfsi>
8110d94c:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110d950:	e0bffe17 	ldw	r2,-8(fp)
}
8110d954:	e037883a 	mov	sp,fp
8110d958:	dfc00117 	ldw	ra,4(sp)
8110d95c:	df000017 	ldw	fp,0(sp)
8110d960:	dec00204 	addi	sp,sp,8
8110d964:	f800283a 	ret

8110d968 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110d968:	defff804 	addi	sp,sp,-32
8110d96c:	de00012e 	bgeu	sp,et,8110d974 <vDataControlTask+0xc>
8110d970:	003b68fa 	trap	3
8110d974:	dfc00715 	stw	ra,28(sp)
8110d978:	df000615 	stw	fp,24(sp)
8110d97c:	df000604 	addi	fp,sp,24
8110d980:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110d984:	e0bffd17 	ldw	r2,-12(fp)
8110d988:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110d98c:	d0a06217 	ldw	r2,-32376(gp)
8110d990:	100f883a 	mov	r7,r2
8110d994:	01800804 	movi	r6,32
8110d998:	01400044 	movi	r5,1
8110d99c:	01204574 	movhi	r4,33045
8110d9a0:	2130e704 	addi	r4,r4,-15460
8110d9a4:	11219e00 	call	811219e0 <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110d9a8:	e0bffa17 	ldw	r2,-24(fp)
8110d9ac:	00c00044 	movi	r3,1
8110d9b0:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110d9b4:	d0a05f17 	ldw	r2,-32388(gp)
8110d9b8:	1009883a 	mov	r4,r2
8110d9bc:	113d8c40 	call	8113d8c4 <OSQFlush>
8110d9c0:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110d9c4:	e0bffc03 	ldbu	r2,-16(fp)
8110d9c8:	10803fcc 	andi	r2,r2,255
8110d9cc:	10000126 	beq	r2,zero,8110d9d4 <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110d9d0:	111d43c0 	call	8111d43c <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskDataCtrl, 0, &error_code); /* Blocking operation */
8110d9d4:	d0a05f17 	ldw	r2,-32388(gp)
8110d9d8:	e0fffc04 	addi	r3,fp,-16
8110d9dc:	180d883a 	mov	r6,r3
8110d9e0:	000b883a 	mov	r5,zero
8110d9e4:	1009883a 	mov	r4,r2
8110d9e8:	113d9840 	call	8113d984 <OSQPend>
8110d9ec:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110d9f0:	000f883a 	mov	r7,zero
8110d9f4:	01800144 	movi	r6,5
8110d9f8:	000b883a 	mov	r5,zero
8110d9fc:	0009883a 	mov	r4,zero
8110da00:	11408140 	call	81140814 <OSTimeDlyHMSM>
	}
8110da04:	003ff306 	br	8110d9d4 <__reset+0xfb0ed9d4>

8110da08 <vFeeTask>:

const char *cTemp[64];
unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8110da08:	deffef04 	addi	sp,sp,-68
8110da0c:	de00012e 	bgeu	sp,et,8110da14 <vFeeTask+0xc>
8110da10:	003b68fa 	trap	3
8110da14:	dfc01015 	stw	ra,64(sp)
8110da18:	df000f15 	stw	fp,60(sp)
8110da1c:	df000f04 	addi	fp,sp,60
8110da20:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110da24:	e03ffb15 	stw	zero,-20(fp)
	alt_u16 *pusiHK;
	alt_u32 *pusiHK32;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110da28:	e0bfff17 	ldw	r2,-4(fp)
8110da2c:	d0a05315 	stw	r2,-32436(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110da30:	d0e06217 	ldw	r3,-32376(gp)
8110da34:	d0a05317 	ldw	r2,-32436(gp)
8110da38:	10800003 	ldbu	r2,0(r2)
8110da3c:	10803fcc 	andi	r2,r2,255
8110da40:	100d883a 	mov	r6,r2
8110da44:	01604574 	movhi	r5,33045
8110da48:	2970f004 	addi	r5,r5,-15424
8110da4c:	1809883a 	mov	r4,r3
8110da50:	11213440 	call	81121344 <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110da54:	d0a05317 	ldw	r2,-32436(gp)
8110da58:	1009883a 	mov	r4,r2
8110da5c:	11109440 	call	81110944 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110da60:	d0a05317 	ldw	r2,-32436(gp)
8110da64:	10802c17 	ldw	r2,176(r2)
8110da68:	10c00368 	cmpgeui	r3,r2,13
8110da6c:	18055c1e 	bne	r3,zero,8110efe0 <vFeeTask+0x15d8>
8110da70:	100690ba 	slli	r3,r2,2
8110da74:	00a04474 	movhi	r2,33041
8110da78:	10b6a204 	addi	r2,r2,-9592
8110da7c:	1885883a 	add	r2,r3,r2
8110da80:	10800017 	ldw	r2,0(r2)
8110da84:	1000683a 	jmp	r2
8110da88:	8110dabc 	xorhi	r4,r16,17258
8110da8c:	8110e23c 	xorhi	r4,r16,17288
8110da90:	8110e2c0 	call	88110e2c <__reset+0x20f0e2c>
8110da94:	8110e420 	cmpeqi	r4,r16,17296
8110da98:	8110eb38 	rdprs	r4,r16,17324
8110da9c:	8110e074 	orhi	r4,r16,17281
8110daa0:	8110e2d0 	cmplti	r4,r16,17291
8110daa4:	8110ea28 	cmpgeui	r4,r16,17320
8110daa8:	8110efe0 	cmpeqi	r4,r16,17343
8110daac:	8110efe0 	cmpeqi	r4,r16,17343
8110dab0:	8110e4a4 	muli	r4,r16,17298
8110dab4:	8110eec4 	addi	r4,r16,17339
8110dab8:	8110ef38 	rdprs	r4,r16,17340
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110dabc:	d0a05317 	ldw	r2,-32436(gp)
8110dac0:	10800003 	ldbu	r2,0(r2)
8110dac4:	10803fcc 	andi	r2,r2,255
8110dac8:	1085883a 	add	r2,r2,r2
8110dacc:	1087883a 	add	r3,r2,r2
8110dad0:	d0a06a04 	addi	r2,gp,-32344
8110dad4:	1885883a 	add	r2,r3,r2
8110dad8:	10800017 	ldw	r2,0(r2)
8110dadc:	1009883a 	mov	r4,r2
8110dae0:	113d8c40 	call	8113d8c4 <OSQFlush>
8110dae4:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dae8:	e0bffd03 	ldbu	r2,-12(fp)
8110daec:	10803fcc 	andi	r2,r2,255
8110daf0:	10000126 	beq	r2,zero,8110daf8 <vFeeTask+0xf0>
					vFailFlushNFEEQueue();
8110daf4:	111d4d40 	call	8111d4d4 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110daf8:	d0a05317 	ldw	r2,-32436(gp)
8110dafc:	10800003 	ldbu	r2,0(r2)
8110db00:	10803fcc 	andi	r2,r2,255
8110db04:	1085883a 	add	r2,r2,r2
8110db08:	1087883a 	add	r3,r2,r2
8110db0c:	d0a05c04 	addi	r2,gp,-32400
8110db10:	1885883a 	add	r2,r3,r2
8110db14:	10800017 	ldw	r2,0(r2)
8110db18:	1009883a 	mov	r4,r2
8110db1c:	113d8c40 	call	8113d8c4 <OSQFlush>
8110db20:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110db24:	e0bffd03 	ldbu	r2,-12(fp)
8110db28:	10803fcc 	andi	r2,r2,255
8110db2c:	10000126 	beq	r2,zero,8110db34 <vFeeTask+0x12c>
					vFailFlushNFEEQueue();
8110db30:	111d4d40 	call	8111d4d4 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110db34:	d0a05317 	ldw	r2,-32436(gp)
8110db38:	10803304 	addi	r2,r2,204
8110db3c:	1009883a 	mov	r4,r2
8110db40:	1104a5c0 	call	81104a5c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8110db44:	d0a05317 	ldw	r2,-32436(gp)
8110db48:	d0e05317 	ldw	r3,-32436(gp)
8110db4c:	1900308b 	ldhu	r4,194(r3)
8110db50:	d0e05317 	ldw	r3,-32436(gp)
8110db54:	18c02f0b 	ldhu	r3,188(r3)
8110db58:	20c7883a 	add	r3,r4,r3
8110db5c:	1809883a 	mov	r4,r3
8110db60:	d0e05317 	ldw	r3,-32436(gp)
8110db64:	18c02f8b 	ldhu	r3,190(r3)
8110db68:	20c7883a 	add	r3,r4,r3
8110db6c:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8110db70:	d0a05317 	ldw	r2,-32436(gp)
8110db74:	d0e05317 	ldw	r3,-32436(gp)
8110db78:	1900310b 	ldhu	r4,196(r3)
8110db7c:	d0e05317 	ldw	r3,-32436(gp)
8110db80:	18c0300b 	ldhu	r3,192(r3)
8110db84:	20c7883a 	add	r3,r4,r3
8110db88:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8110db8c:	d0a05317 	ldw	r2,-32436(gp)
8110db90:	d0e05317 	ldw	r3,-32436(gp)
8110db94:	18c0310b 	ldhu	r3,196(r3)
8110db98:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110db9c:	d0a05317 	ldw	r2,-32436(gp)
8110dba0:	d0e05317 	ldw	r3,-32436(gp)
8110dba4:	18c0300b 	ldhu	r3,192(r3)
8110dba8:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110dbac:	d0a05317 	ldw	r2,-32436(gp)
8110dbb0:	00e00004 	movi	r3,-32768
8110dbb4:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110dbb8:	d0a05317 	ldw	r2,-32436(gp)
8110dbbc:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110dbc0:	d0a05317 	ldw	r2,-32436(gp)
8110dbc4:	00c00044 	movi	r3,1
8110dbc8:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dbcc:	d0a05317 	ldw	r2,-32436(gp)
8110dbd0:	10803304 	addi	r2,r2,204
8110dbd4:	1009883a 	mov	r4,r2
8110dbd8:	11048300 	call	81104830 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110dbdc:	d0a05317 	ldw	r2,-32436(gp)
8110dbe0:	10804304 	addi	r2,r2,268
8110dbe4:	1009883a 	mov	r4,r2
8110dbe8:	110954c0 	call	8110954c <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110dbec:	d0a05317 	ldw	r2,-32436(gp)
8110dbf0:	00ffc004 	movi	r3,-256
8110dbf4:	10c0690d 	sth	r3,420(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110dbf8:	d0a05317 	ldw	r2,-32436(gp)
8110dbfc:	00ffc044 	movi	r3,-255
8110dc00:	10c0698d 	sth	r3,422(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110dc04:	d0a05317 	ldw	r2,-32436(gp)
8110dc08:	00ffc084 	movi	r3,-254
8110dc0c:	10c06a0d 	sth	r3,424(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110dc10:	d0a05317 	ldw	r2,-32436(gp)
8110dc14:	00ffc0c4 	movi	r3,-253
8110dc18:	10c06a8d 	sth	r3,426(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110dc1c:	d0a05317 	ldw	r2,-32436(gp)
8110dc20:	00ffc104 	movi	r3,-252
8110dc24:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110dc28:	d0a05317 	ldw	r2,-32436(gp)
8110dc2c:	00ffc144 	movi	r3,-251
8110dc30:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110dc34:	d0a05317 	ldw	r2,-32436(gp)
8110dc38:	00ffc184 	movi	r3,-250
8110dc3c:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110dc40:	d0a05317 	ldw	r2,-32436(gp)
8110dc44:	00ffc1c4 	movi	r3,-249
8110dc48:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110dc4c:	d0a05317 	ldw	r2,-32436(gp)
8110dc50:	00ffc204 	movi	r3,-248
8110dc54:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110dc58:	d0a05317 	ldw	r2,-32436(gp)
8110dc5c:	00ffc244 	movi	r3,-247
8110dc60:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110dc64:	d0a05317 	ldw	r2,-32436(gp)
8110dc68:	00ffc284 	movi	r3,-246
8110dc6c:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110dc70:	d0a05317 	ldw	r2,-32436(gp)
8110dc74:	00ffc2c4 	movi	r3,-245
8110dc78:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110dc7c:	d0a05317 	ldw	r2,-32436(gp)
8110dc80:	00ffc304 	movi	r3,-244
8110dc84:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110dc88:	d0a05317 	ldw	r2,-32436(gp)
8110dc8c:	00ffc344 	movi	r3,-243
8110dc90:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110dc94:	d0a05317 	ldw	r2,-32436(gp)
8110dc98:	00ffc384 	movi	r3,-242
8110dc9c:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110dca0:	d0a05317 	ldw	r2,-32436(gp)
8110dca4:	00ffc3c4 	movi	r3,-241
8110dca8:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110dcac:	d0a05317 	ldw	r2,-32436(gp)
8110dcb0:	00ffc404 	movi	r3,-240
8110dcb4:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110dcb8:	d0a05317 	ldw	r2,-32436(gp)
8110dcbc:	00ffc444 	movi	r3,-239
8110dcc0:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110dcc4:	d0a05317 	ldw	r2,-32436(gp)
8110dcc8:	00ffc484 	movi	r3,-238
8110dccc:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110dcd0:	d0a05317 	ldw	r2,-32436(gp)
8110dcd4:	00ffc4c4 	movi	r3,-237
8110dcd8:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110dcdc:	d0a05317 	ldw	r2,-32436(gp)
8110dce0:	00ffc504 	movi	r3,-236
8110dce4:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110dce8:	d0a05317 	ldw	r2,-32436(gp)
8110dcec:	00ffc544 	movi	r3,-235
8110dcf0:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110dcf4:	d0a05317 	ldw	r2,-32436(gp)
8110dcf8:	00ffc584 	movi	r3,-234
8110dcfc:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110dd00:	d0a05317 	ldw	r2,-32436(gp)
8110dd04:	00ffc5c4 	movi	r3,-233
8110dd08:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110dd0c:	d0a05317 	ldw	r2,-32436(gp)
8110dd10:	00ffc604 	movi	r3,-232
8110dd14:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110dd18:	d0a05317 	ldw	r2,-32436(gp)
8110dd1c:	00ffc644 	movi	r3,-231
8110dd20:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110dd24:	d0a05317 	ldw	r2,-32436(gp)
8110dd28:	00ffc684 	movi	r3,-230
8110dd2c:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110dd30:	d0a05317 	ldw	r2,-32436(gp)
8110dd34:	00ffc6c4 	movi	r3,-229
8110dd38:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110dd3c:	d0a05317 	ldw	r2,-32436(gp)
8110dd40:	00ffc704 	movi	r3,-228
8110dd44:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110dd48:	d0a05317 	ldw	r2,-32436(gp)
8110dd4c:	00ffc744 	movi	r3,-227
8110dd50:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110dd54:	d0a05317 	ldw	r2,-32436(gp)
8110dd58:	00ffc784 	movi	r3,-226
8110dd5c:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110dd60:	d0a05317 	ldw	r2,-32436(gp)
8110dd64:	00ffc7c4 	movi	r3,-225
8110dd68:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110dd6c:	d0a05317 	ldw	r2,-32436(gp)
8110dd70:	00ffc804 	movi	r3,-224
8110dd74:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110dd78:	d0a05317 	ldw	r2,-32436(gp)
8110dd7c:	00ffc844 	movi	r3,-223
8110dd80:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110dd84:	d0a05317 	ldw	r2,-32436(gp)
8110dd88:	00ffc884 	movi	r3,-222
8110dd8c:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110dd90:	d0a05317 	ldw	r2,-32436(gp)
8110dd94:	00ffc8c4 	movi	r3,-221
8110dd98:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110dd9c:	d0a05317 	ldw	r2,-32436(gp)
8110dda0:	00ffc904 	movi	r3,-220
8110dda4:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110dda8:	d0a05317 	ldw	r2,-32436(gp)
8110ddac:	00ffc944 	movi	r3,-219
8110ddb0:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110ddb4:	d0a05317 	ldw	r2,-32436(gp)
8110ddb8:	00ffc984 	movi	r3,-218
8110ddbc:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110ddc0:	d0a05317 	ldw	r2,-32436(gp)
8110ddc4:	00ffc9c4 	movi	r3,-217
8110ddc8:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110ddcc:	d0a05317 	ldw	r2,-32436(gp)
8110ddd0:	00ffca04 	movi	r3,-216
8110ddd4:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110ddd8:	d0a05317 	ldw	r2,-32436(gp)
8110dddc:	00ffca44 	movi	r3,-215
8110dde0:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110dde4:	d0a05317 	ldw	r2,-32436(gp)
8110dde8:	00ffca84 	movi	r3,-214
8110ddec:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110ddf0:	d0a05317 	ldw	r2,-32436(gp)
8110ddf4:	00ffcac4 	movi	r3,-213
8110ddf8:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110ddfc:	d0a05317 	ldw	r2,-32436(gp)
8110de00:	00ffcb04 	movi	r3,-212
8110de04:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110de08:	d0a05317 	ldw	r2,-32436(gp)
8110de0c:	00ffcb44 	movi	r3,-211
8110de10:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110de14:	d0a05317 	ldw	r2,-32436(gp)
8110de18:	00ffcb84 	movi	r3,-210
8110de1c:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110de20:	d0a05317 	ldw	r2,-32436(gp)
8110de24:	00ffcbc4 	movi	r3,-209
8110de28:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110de2c:	d0a05317 	ldw	r2,-32436(gp)
8110de30:	00ffcc04 	movi	r3,-208
8110de34:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110de38:	d0a05317 	ldw	r2,-32436(gp)
8110de3c:	00ffcc44 	movi	r3,-207
8110de40:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110de44:	d0a05317 	ldw	r2,-32436(gp)
8110de48:	00ffcc84 	movi	r3,-206
8110de4c:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110de50:	d0a05317 	ldw	r2,-32436(gp)
8110de54:	00ffccc4 	movi	r3,-205
8110de58:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110de5c:	d0a05317 	ldw	r2,-32436(gp)
8110de60:	00ffcd04 	movi	r3,-204
8110de64:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110de68:	d0a05317 	ldw	r2,-32436(gp)
8110de6c:	00ffcd44 	movi	r3,-203
8110de70:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110de74:	d0a05317 	ldw	r2,-32436(gp)
8110de78:	00ffcd84 	movi	r3,-202
8110de7c:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110de80:	d0a05317 	ldw	r2,-32436(gp)
8110de84:	00ffcdc4 	movi	r3,-201
8110de88:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110de8c:	d0a05317 	ldw	r2,-32436(gp)
8110de90:	00ffce04 	movi	r3,-200
8110de94:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110de98:	d0a05317 	ldw	r2,-32436(gp)
8110de9c:	00ffce44 	movi	r3,-199
8110dea0:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110dea4:	d0a05317 	ldw	r2,-32436(gp)
8110dea8:	00ffce84 	movi	r3,-198
8110deac:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110deb0:	d0a05317 	ldw	r2,-32436(gp)
8110deb4:	00ffcec4 	movi	r3,-197
8110deb8:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110debc:	d0a05317 	ldw	r2,-32436(gp)
8110dec0:	00ffcf04 	movi	r3,-196
8110dec4:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110dec8:	d0a05317 	ldw	r2,-32436(gp)
8110decc:	00ffcf44 	movi	r3,-195
8110ded0:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110ded4:	d0a05317 	ldw	r2,-32436(gp)
8110ded8:	00ffcf84 	movi	r3,-194
8110dedc:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110dee0:	d0a05317 	ldw	r2,-32436(gp)
8110dee4:	00ffcfc4 	movi	r3,-193
8110dee8:	10c0888d 	sth	r3,546(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110deec:	d0a05317 	ldw	r2,-32436(gp)
8110def0:	10804304 	addi	r2,r2,268
8110def4:	1009883a 	mov	r4,r2
8110def8:	11085000 	call	81108500 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110defc:	11116980 	call	81111698 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110df00:	d0a05317 	ldw	r2,-32436(gp)
8110df04:	10804304 	addi	r2,r2,268
8110df08:	1009883a 	mov	r4,r2
8110df0c:	110954c0 	call	8110954c <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110df10:	d0a05317 	ldw	r2,-32436(gp)
8110df14:	10806904 	addi	r2,r2,420
8110df18:	e0bff915 	stw	r2,-28(fp)

				#ifdef DEBUG_ON
					fprintf(fp,"\n\n================= H  K ==================\n");
8110df1c:	d0a06217 	ldw	r2,-32376(gp)
8110df20:	100f883a 	mov	r7,r2
8110df24:	01800b04 	movi	r6,44
8110df28:	01400044 	movi	r5,1
8110df2c:	01204574 	movhi	r4,33045
8110df30:	2130f704 	addi	r4,r4,-15396
8110df34:	11219e00 	call	811219e0 <fwrite>

					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110df38:	e03ffa05 	stb	zero,-24(fp)
8110df3c:	00001606 	br	8110df98 <vFeeTask+0x590>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
8110df40:	d1206217 	ldw	r4,-32376(gp)
8110df44:	e0fffa03 	ldbu	r3,-24(fp)
8110df48:	00a04574 	movhi	r2,33045
8110df4c:	108e8004 	addi	r2,r2,14848
8110df50:	18c7883a 	add	r3,r3,r3
8110df54:	18c7883a 	add	r3,r3,r3
8110df58:	10c5883a 	add	r2,r2,r3
8110df5c:	10c00017 	ldw	r3,0(r2)
8110df60:	e0bff917 	ldw	r2,-28(fp)
8110df64:	1080000b 	ldhu	r2,0(r2)
8110df68:	10bfffcc 	andi	r2,r2,65535
8110df6c:	100f883a 	mov	r7,r2
8110df70:	180d883a 	mov	r6,r3
8110df74:	01604574 	movhi	r5,33045
8110df78:	29710304 	addi	r5,r5,-15348
8110df7c:	11213440 	call	81121344 <fprintf>
						pusiHK++;
8110df80:	e0bff917 	ldw	r2,-28(fp)
8110df84:	10800084 	addi	r2,r2,2
8110df88:	e0bff915 	stw	r2,-28(fp)
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;

				#ifdef DEBUG_ON
					fprintf(fp,"\n\n================= H  K ==================\n");

					for (ucIL = 0; ucIL < 64; ++ucIL) {
8110df8c:	e0bffa03 	ldbu	r2,-24(fp)
8110df90:	10800044 	addi	r2,r2,1
8110df94:	e0bffa05 	stb	r2,-24(fp)
8110df98:	e0bffa03 	ldbu	r2,-24(fp)
8110df9c:	10801030 	cmpltui	r2,r2,64
8110dfa0:	103fe71e 	bne	r2,zero,8110df40 <__reset+0xfb0edf40>
						fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
						pusiHK++;
					}
					fprintf(fp,"\n================= H  K ==================\n\n");
8110dfa4:	d0a06217 	ldw	r2,-32376(gp)
8110dfa8:	100f883a 	mov	r7,r2
8110dfac:	01800b04 	movi	r6,44
8110dfb0:	01400044 	movi	r5,1
8110dfb4:	01204574 	movhi	r4,33045
8110dfb8:	21310804 	addi	r4,r4,-15328
8110dfbc:	11219e00 	call	811219e0 <fwrite>
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110dfc0:	d0a05317 	ldw	r2,-32436(gp)
8110dfc4:	10804304 	addi	r2,r2,268
8110dfc8:	1009883a 	mov	r4,r2
8110dfcc:	1107b600 	call	81107b60 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110dfd0:	d0e05317 	ldw	r3,-32436(gp)
8110dfd4:	00a045b4 	movhi	r2,33046
8110dfd8:	109ade04 	addi	r2,r2,27512
8110dfdc:	10800c0b 	ldhu	r2,48(r2)
8110dfe0:	18804405 	stb	r2,272(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110dfe4:	d0e05317 	ldw	r3,-32436(gp)
8110dfe8:	00a045b4 	movhi	r2,33046
8110dfec:	109ade04 	addi	r2,r2,27512
8110dff0:	10800c8b 	ldhu	r2,50(r2)
8110dff4:	18804445 	stb	r2,273(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110dff8:	d0a05317 	ldw	r2,-32436(gp)
8110dffc:	10804304 	addi	r2,r2,268
8110e000:	1009883a 	mov	r4,r2
8110e004:	1107a880 	call	81107a88 <bRmapSetCodecConfig>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", xDefaults.ucRmapKey );
8110e008:	d0e06217 	ldw	r3,-32376(gp)
8110e00c:	00a045b4 	movhi	r2,33046
8110e010:	109ade04 	addi	r2,r2,27512
8110e014:	10800c0b 	ldhu	r2,48(r2)
8110e018:	10bfffcc 	andi	r2,r2,65535
8110e01c:	100d883a 	mov	r6,r2
8110e020:	01604574 	movhi	r5,33045
8110e024:	29711404 	addi	r5,r5,-15280
8110e028:	1809883a 	mov	r4,r3
8110e02c:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", xDefaults.ucLogicalAddr);
8110e030:	d0e06217 	ldw	r3,-32376(gp)
8110e034:	00a045b4 	movhi	r2,33046
8110e038:	109ade04 	addi	r2,r2,27512
8110e03c:	10800c8b 	ldhu	r2,50(r2)
8110e040:	10bfffcc 	andi	r2,r2,65535
8110e044:	100d883a 	mov	r6,r2
8110e048:	01604574 	movhi	r5,33045
8110e04c:	29711c04 	addi	r5,r5,-15248
8110e050:	1809883a 	mov	r4,r3
8110e054:	11213440 	call	81121344 <fprintf>
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110e058:	d0a05317 	ldw	r2,-32436(gp)
8110e05c:	00c00144 	movi	r3,5
8110e060:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e064:	d0a05317 	ldw	r2,-32436(gp)
8110e068:	10802e17 	ldw	r2,184(r2)
8110e06c:	d0a05605 	stb	r2,-32424(gp)

				break;
8110e070:	0003e906 	br	8110f018 <vFeeTask+0x1610>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e074:	d0a05317 	ldw	r2,-32436(gp)
8110e078:	10804304 	addi	r2,r2,268
8110e07c:	1009883a 	mov	r4,r2
8110e080:	11081980 	call	81108198 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110e084:	d0a05317 	ldw	r2,-32436(gp)
8110e088:	00c00184 	movi	r3,6
8110e08c:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e090:	d0a05317 	ldw	r2,-32436(gp)
8110e094:	10804304 	addi	r2,r2,268
8110e098:	1009883a 	mov	r4,r2
8110e09c:	1107eac0 	call	81107eac <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e0a0:	d0a05317 	ldw	r2,-32436(gp)
8110e0a4:	10808904 	addi	r2,r2,548
8110e0a8:	1009883a 	mov	r4,r2
8110e0ac:	11106380 	call	81110638 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110e0b0:	d0a05317 	ldw	r2,-32436(gp)
8110e0b4:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
8110e0b8:	d0a05317 	ldw	r2,-32436(gp)
8110e0bc:	10c04304 	addi	r3,r2,268
8110e0c0:	d0a05317 	ldw	r2,-32436(gp)
8110e0c4:	10800043 	ldbu	r2,1(r2)
8110e0c8:	10803fcc 	andi	r2,r2,255
8110e0cc:	100b883a 	mov	r5,r2
8110e0d0:	1809883a 	mov	r4,r3
8110e0d4:	111058c0 	call	8111058c <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e0d8:	d0a05317 	ldw	r2,-32436(gp)
8110e0dc:	10803b04 	addi	r2,r2,236
8110e0e0:	1009883a 	mov	r4,r2
8110e0e4:	11107900 	call	81110790 <bDisAndClrDbBuffer>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110e0e8:	d0e06217 	ldw	r3,-32376(gp)
8110e0ec:	d0a05317 	ldw	r2,-32436(gp)
8110e0f0:	10800003 	ldbu	r2,0(r2)
8110e0f4:	10803fcc 	andi	r2,r2,255
8110e0f8:	100d883a 	mov	r6,r2
8110e0fc:	01604574 	movhi	r5,33045
8110e100:	29712504 	addi	r5,r5,-15212
8110e104:	1809883a 	mov	r4,r3
8110e108:	11213440 	call	81121344 <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110e10c:	d0a05317 	ldw	r2,-32436(gp)
8110e110:	10802217 	ldw	r2,136(r2)
8110e114:	10800058 	cmpnei	r2,r2,1
8110e118:	10000a1e 	bne	r2,zero,8110e144 <vFeeTask+0x73c>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e11c:	e0fff303 	ldbu	r3,-52(fp)
8110e120:	00a045b4 	movhi	r2,33046
8110e124:	108e2204 	addi	r2,r2,14472
8110e128:	180690fa 	slli	r3,r3,3
8110e12c:	10c5883a 	add	r2,r2,r3
8110e130:	10800017 	ldw	r2,0(r2)
8110e134:	1009883a 	mov	r4,r2
8110e138:	113ce140 	call	8113ce14 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110e13c:	d0a05317 	ldw	r2,-32436(gp)
8110e140:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e144:	d0a05317 	ldw	r2,-32436(gp)
8110e148:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e14c:	d0a05317 	ldw	r2,-32436(gp)
8110e150:	10800003 	ldbu	r2,0(r2)
8110e154:	10803fcc 	andi	r2,r2,255
8110e158:	1085883a 	add	r2,r2,r2
8110e15c:	1087883a 	add	r3,r2,r2
8110e160:	d0a05c04 	addi	r2,gp,-32400
8110e164:	1885883a 	add	r2,r3,r2
8110e168:	10800017 	ldw	r2,0(r2)
8110e16c:	1009883a 	mov	r4,r2
8110e170:	113d8c40 	call	8113d8c4 <OSQFlush>
8110e174:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e178:	e0bffd03 	ldbu	r2,-12(fp)
8110e17c:	10803fcc 	andi	r2,r2,255
8110e180:	10000126 	beq	r2,zero,8110e188 <vFeeTask+0x780>
					vFailFlushNFEEQueue();
8110e184:	111d4d40 	call	8111d4d4 <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e188:	d0a05317 	ldw	r2,-32436(gp)
8110e18c:	10800003 	ldbu	r2,0(r2)
8110e190:	10803fcc 	andi	r2,r2,255
8110e194:	100d883a 	mov	r6,r2
8110e198:	000b883a 	mov	r5,zero
8110e19c:	01002044 	movi	r4,129
8110e1a0:	11108a00 	call	811108a0 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110e1a4:	d0a05317 	ldw	r2,-32436(gp)
8110e1a8:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110e1ac:	d0a05317 	ldw	r2,-32436(gp)
8110e1b0:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e1b4:	d0a05317 	ldw	r2,-32436(gp)
8110e1b8:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e1bc:	d0a05317 	ldw	r2,-32436(gp)
8110e1c0:	00c00044 	movi	r3,1
8110e1c4:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110e1c8:	d0a05317 	ldw	r2,-32436(gp)
8110e1cc:	1009883a 	mov	r4,r2
8110e1d0:	111db640 	call	8111db64 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110e1d4:	d0a05317 	ldw	r2,-32436(gp)
8110e1d8:	10800003 	ldbu	r2,0(r2)
8110e1dc:	10803fcc 	andi	r2,r2,255
8110e1e0:	1085883a 	add	r2,r2,r2
8110e1e4:	1087883a 	add	r3,r2,r2
8110e1e8:	d0a06a04 	addi	r2,gp,-32344
8110e1ec:	1885883a 	add	r2,r3,r2
8110e1f0:	10800017 	ldw	r2,0(r2)
8110e1f4:	1009883a 	mov	r4,r2
8110e1f8:	113d8c40 	call	8113d8c4 <OSQFlush>
8110e1fc:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e200:	e0bffd03 	ldbu	r2,-12(fp)
8110e204:	10803fcc 	andi	r2,r2,255
8110e208:	10000126 	beq	r2,zero,8110e210 <vFeeTask+0x808>
					vFailFlushNFEEQueue();
8110e20c:	111d4d40 	call	8111d4d4 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110e210:	d0a05317 	ldw	r2,-32436(gp)
8110e214:	00c00044 	movi	r3,1
8110e218:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110e21c:	d0a05317 	ldw	r2,-32436(gp)
8110e220:	00c00044 	movi	r3,1
8110e224:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e228:	d0a05317 	ldw	r2,-32436(gp)
8110e22c:	10802e17 	ldw	r2,184(r2)
8110e230:	d0a05605 	stb	r2,-32424(gp)
				bFinal = FALSE;
8110e234:	e03ff815 	stw	zero,-32(fp)
				break;
8110e238:	00037706 	br	8110f018 <vFeeTask+0x1610>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e23c:	d0a05317 	ldw	r2,-32436(gp)
8110e240:	10800003 	ldbu	r2,0(r2)
8110e244:	10803fcc 	andi	r2,r2,255
8110e248:	1085883a 	add	r2,r2,r2
8110e24c:	1087883a 	add	r3,r2,r2
8110e250:	d0a06a04 	addi	r2,gp,-32344
8110e254:	1885883a 	add	r2,r3,r2
8110e258:	10800017 	ldw	r2,0(r2)
8110e25c:	e0fffd04 	addi	r3,fp,-12
8110e260:	180d883a 	mov	r6,r3
8110e264:	000b883a 	mov	r5,zero
8110e268:	1009883a 	mov	r4,r2
8110e26c:	113d9840 	call	8113d984 <OSQPend>
8110e270:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e274:	e0bffd03 	ldbu	r2,-12(fp)
8110e278:	10803fcc 	andi	r2,r2,255
8110e27c:	1000061e 	bne	r2,zero,8110e298 <vFeeTask+0x890>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110e280:	d0a05317 	ldw	r2,-32436(gp)
8110e284:	e0fffe17 	ldw	r3,-8(fp)
8110e288:	180b883a 	mov	r5,r3
8110e28c:	1009883a 	mov	r4,r2
8110e290:	110f2040 	call	8110f204 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e294:	00036006 	br	8110f018 <vFeeTask+0x1610>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e298:	d0e06217 	ldw	r3,-32376(gp)
8110e29c:	d0a05317 	ldw	r2,-32436(gp)
8110e2a0:	10800003 	ldbu	r2,0(r2)
8110e2a4:	10803fcc 	andi	r2,r2,255
8110e2a8:	100d883a 	mov	r6,r2
8110e2ac:	01604574 	movhi	r5,33045
8110e2b0:	29712c04 	addi	r5,r5,-15184
8110e2b4:	1809883a 	mov	r4,r3
8110e2b8:	11213440 	call	81121344 <fprintf>
					#endif
				}

				break;
8110e2bc:	00035606 	br	8110f018 <vFeeTask+0x1610>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110e2c0:	d0a05317 	ldw	r2,-32436(gp)
8110e2c4:	00c00184 	movi	r3,6
8110e2c8:	10c02c15 	stw	r3,176(r2)
				break;
8110e2cc:	00035206 	br	8110f018 <vFeeTask+0x1610>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e2d0:	d0a05317 	ldw	r2,-32436(gp)
8110e2d4:	10804304 	addi	r2,r2,268
8110e2d8:	1009883a 	mov	r4,r2
8110e2dc:	11081980 	call	81108198 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110e2e0:	d0a05317 	ldw	r2,-32436(gp)
8110e2e4:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e2e8:	d0a05317 	ldw	r2,-32436(gp)
8110e2ec:	10804304 	addi	r2,r2,268
8110e2f0:	1009883a 	mov	r4,r2
8110e2f4:	1107eac0 	call	81107eac <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e2f8:	d0a05317 	ldw	r2,-32436(gp)
8110e2fc:	10803b04 	addi	r2,r2,236
8110e300:	1009883a 	mov	r4,r2
8110e304:	11107900 	call	81110790 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110e308:	d0a05317 	ldw	r2,-32436(gp)
8110e30c:	10c04304 	addi	r3,r2,268
8110e310:	d0a05317 	ldw	r2,-32436(gp)
8110e314:	10800003 	ldbu	r2,0(r2)
8110e318:	10803fcc 	andi	r2,r2,255
8110e31c:	100b883a 	mov	r5,r2
8110e320:	1809883a 	mov	r4,r3
8110e324:	11105e00 	call	811105e0 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e328:	d0a05317 	ldw	r2,-32436(gp)
8110e32c:	10808904 	addi	r2,r2,548
8110e330:	1009883a 	mov	r4,r2
8110e334:	11106980 	call	81110698 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110e338:	d0a05317 	ldw	r2,-32436(gp)
8110e33c:	00c00044 	movi	r3,1
8110e340:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110e344:	d0a05317 	ldw	r2,-32436(gp)
8110e348:	00c00044 	movi	r3,1
8110e34c:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e350:	d0a05317 	ldw	r2,-32436(gp)
8110e354:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e358:	d0a05317 	ldw	r2,-32436(gp)
8110e35c:	00c00044 	movi	r3,1
8110e360:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e364:	d0a05317 	ldw	r2,-32436(gp)
8110e368:	10800003 	ldbu	r2,0(r2)
8110e36c:	10803fcc 	andi	r2,r2,255
8110e370:	100d883a 	mov	r6,r2
8110e374:	000b883a 	mov	r5,zero
8110e378:	01002044 	movi	r4,129
8110e37c:	11108a00 	call	811108a0 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e380:	d0a05317 	ldw	r2,-32436(gp)
8110e384:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e388:	d0a05317 	ldw	r2,-32436(gp)
8110e38c:	10800003 	ldbu	r2,0(r2)
8110e390:	10803fcc 	andi	r2,r2,255
8110e394:	1085883a 	add	r2,r2,r2
8110e398:	1087883a 	add	r3,r2,r2
8110e39c:	d0a05c04 	addi	r2,gp,-32400
8110e3a0:	1885883a 	add	r2,r3,r2
8110e3a4:	10800017 	ldw	r2,0(r2)
8110e3a8:	1009883a 	mov	r4,r2
8110e3ac:	113d8c40 	call	8113d8c4 <OSQFlush>
8110e3b0:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e3b4:	e0bffd03 	ldbu	r2,-12(fp)
8110e3b8:	10803fcc 	andi	r2,r2,255
8110e3bc:	10000126 	beq	r2,zero,8110e3c4 <vFeeTask+0x9bc>
					vFailFlushNFEEQueue();
8110e3c0:	111d4d40 	call	8111d4d4 <vFailFlushNFEEQueue>
				}

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110e3c4:	d0e06217 	ldw	r3,-32376(gp)
8110e3c8:	d0a05317 	ldw	r2,-32436(gp)
8110e3cc:	10800003 	ldbu	r2,0(r2)
8110e3d0:	10803fcc 	andi	r2,r2,255
8110e3d4:	100d883a 	mov	r6,r2
8110e3d8:	01604574 	movhi	r5,33045
8110e3dc:	29713804 	addi	r5,r5,-15136
8110e3e0:	1809883a 	mov	r4,r3
8110e3e4:	11213440 	call	81121344 <fprintf>
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110e3e8:	d0a05317 	ldw	r2,-32436(gp)
8110e3ec:	1009883a 	mov	r4,r2
8110e3f0:	111db640 	call	8111db64 <vResetMemCCDFEE>

				incrementador = 0;
8110e3f4:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110e3f8:	d0a05317 	ldw	r2,-32436(gp)
8110e3fc:	00c00044 	movi	r3,1
8110e400:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110e404:	d0a05317 	ldw	r2,-32436(gp)
8110e408:	00c000c4 	movi	r3,3
8110e40c:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110e410:	d0a05317 	ldw	r2,-32436(gp)
8110e414:	10802e17 	ldw	r2,184(r2)
8110e418:	d0a05605 	stb	r2,-32424(gp)
				break;
8110e41c:	0002fe06 	br	8110f018 <vFeeTask+0x1610>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e420:	d0a05317 	ldw	r2,-32436(gp)
8110e424:	10800003 	ldbu	r2,0(r2)
8110e428:	10803fcc 	andi	r2,r2,255
8110e42c:	1085883a 	add	r2,r2,r2
8110e430:	1087883a 	add	r3,r2,r2
8110e434:	d0a06a04 	addi	r2,gp,-32344
8110e438:	1885883a 	add	r2,r3,r2
8110e43c:	10800017 	ldw	r2,0(r2)
8110e440:	e0fffd04 	addi	r3,fp,-12
8110e444:	180d883a 	mov	r6,r3
8110e448:	000b883a 	mov	r5,zero
8110e44c:	1009883a 	mov	r4,r2
8110e450:	113d9840 	call	8113d984 <OSQPend>
8110e454:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e458:	e0bffd03 	ldbu	r2,-12(fp)
8110e45c:	10803fcc 	andi	r2,r2,255
8110e460:	1000061e 	bne	r2,zero,8110e47c <vFeeTask+0xa74>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110e464:	d0a05317 	ldw	r2,-32436(gp)
8110e468:	e0fffe17 	ldw	r3,-8(fp)
8110e46c:	180b883a 	mov	r5,r3
8110e470:	1009883a 	mov	r4,r2
8110e474:	110f3c80 	call	8110f3c8 <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e478:	0002e706 	br	8110f018 <vFeeTask+0x1610>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e47c:	d0e06217 	ldw	r3,-32376(gp)
8110e480:	d0a05317 	ldw	r2,-32436(gp)
8110e484:	10800003 	ldbu	r2,0(r2)
8110e488:	10803fcc 	andi	r2,r2,255
8110e48c:	100d883a 	mov	r6,r2
8110e490:	01604574 	movhi	r5,33045
8110e494:	29712c04 	addi	r5,r5,-15184
8110e498:	1809883a 	mov	r4,r3
8110e49c:	11213440 	call	81121344 <fprintf>
					#endif
				}

				break;
8110e4a0:	0002dd06 	br	8110f018 <vFeeTask+0x1610>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e4a4:	d0a05317 	ldw	r2,-32436(gp)
8110e4a8:	10800003 	ldbu	r2,0(r2)
8110e4ac:	10803fcc 	andi	r2,r2,255
8110e4b0:	1085883a 	add	r2,r2,r2
8110e4b4:	1087883a 	add	r3,r2,r2
8110e4b8:	d0a05c04 	addi	r2,gp,-32400
8110e4bc:	1885883a 	add	r2,r3,r2
8110e4c0:	10800017 	ldw	r2,0(r2)
8110e4c4:	1009883a 	mov	r4,r2
8110e4c8:	113d8c40 	call	8113d8c4 <OSQFlush>
8110e4cc:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e4d0:	e0bffd03 	ldbu	r2,-12(fp)
8110e4d4:	10803fcc 	andi	r2,r2,255
8110e4d8:	10000126 	beq	r2,zero,8110e4e0 <vFeeTask+0xad8>
					vFailFlushNFEEQueue();
8110e4dc:	111d4d40 	call	8111d4d4 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110e4e0:	d0a05317 	ldw	r2,-32436(gp)
8110e4e4:	00c00044 	movi	r3,1
8110e4e8:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110e4ec:	d0a05317 	ldw	r2,-32436(gp)
8110e4f0:	00c00044 	movi	r3,1
8110e4f4:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110e4f8:	d0a05317 	ldw	r2,-32436(gp)
8110e4fc:	1009883a 	mov	r4,r2
8110e500:	111db640 	call	8111db64 <vResetMemCCDFEE>

				//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,SDMA_MAX_BLOCKS,0);
				//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,SDMA_MAX_BLOCKS,1);


				while ( (bFeebGetCh1LeftBufferEmpty()== FALSE) || (bFeebGetCh1RightBufferEmpty()== FALSE)  ) {}
8110e504:	0001883a 	nop
8110e508:	11065980 	call	81106598 <bFeebGetCh1LeftBufferEmpty>
8110e50c:	103ffe26 	beq	r2,zero,8110e508 <__reset+0xfb0ee508>
8110e510:	11066000 	call	81106600 <bFeebGetCh1RightBufferEmpty>
8110e514:	103ffc26 	beq	r2,zero,8110e508 <__reset+0xfb0ee508>

				OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay);
8110e518:	00a045b4 	movhi	r2,33046
8110e51c:	109ade04 	addi	r2,r2,27512
8110e520:	1080070b 	ldhu	r2,28(r2)
8110e524:	10bfffcc 	andi	r2,r2,65535
8110e528:	100f883a 	mov	r7,r2
8110e52c:	000d883a 	mov	r6,zero
8110e530:	000b883a 	mov	r5,zero
8110e534:	0009883a 	mov	r4,zero
8110e538:	11408140 	call	81140814 <OSTimeDlyHMSM>

				#ifdef DEBUG_ON
					//fprintf(fp,"\n    i: %u ",incrementador);
					fprintf(fp,"\n\n=========Delay=============\n");
8110e53c:	d0a06217 	ldw	r2,-32376(gp)
8110e540:	100f883a 	mov	r7,r2
8110e544:	01800784 	movi	r6,30
8110e548:	01400044 	movi	r5,1
8110e54c:	01204574 	movhi	r4,33045
8110e550:	21314004 	addi	r4,r4,-15104
8110e554:	11219e00 	call	811219e0 <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", xDefaults.usiDelay);
8110e558:	d0e06217 	ldw	r3,-32376(gp)
8110e55c:	00a045b4 	movhi	r2,33046
8110e560:	109ade04 	addi	r2,r2,27512
8110e564:	1080070b 	ldhu	r2,28(r2)
8110e568:	10bfffcc 	andi	r2,r2,65535
8110e56c:	100d883a 	mov	r6,r2
8110e570:	01604574 	movhi	r5,33045
8110e574:	29714804 	addi	r5,r5,-15072
8110e578:	1809883a 	mov	r4,r3
8110e57c:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110e580:	d0a06217 	ldw	r2,-32376(gp)
8110e584:	100f883a 	mov	r7,r2
8110e588:	01800884 	movi	r6,34
8110e58c:	01400044 	movi	r5,1
8110e590:	01204574 	movhi	r4,33045
8110e594:	21314d04 	addi	r4,r4,-15052
8110e598:	11219e00 	call	811219e0 <fwrite>

				//bFeebCh2SetBufferSize(SDMA_MAX_BLOCKS,0);
				//bFeebCh2SetBufferSize(SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				if (xDefaults.usiLinkNFEE0 == 0) {
8110e59c:	00a045b4 	movhi	r2,33046
8110e5a0:	109ade04 	addi	r2,r2,27512
8110e5a4:	1080100b 	ldhu	r2,64(r2)
8110e5a8:	10bfffcc 	andi	r2,r2,65535
8110e5ac:	1000071e 	bne	r2,zero,8110e5cc <vFeeTask+0xbc4>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110e5b0:	000b883a 	mov	r5,zero
8110e5b4:	01000404 	movi	r4,16
8110e5b8:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110e5bc:	01400044 	movi	r5,1
8110e5c0:	01000404 	movi	r4,16
8110e5c4:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
8110e5c8:	00000606 	br	8110e5e4 <vFeeTask+0xbdc>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110e5cc:	000b883a 	mov	r5,zero
8110e5d0:	01000404 	movi	r4,16
8110e5d4:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110e5d8:	01400044 	movi	r5,1
8110e5dc:	01000404 	movi	r4,16
8110e5e0:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>
				}


				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e5e4:	d0a05317 	ldw	r2,-32436(gp)
8110e5e8:	10803b04 	addi	r2,r2,236
8110e5ec:	1009883a 	mov	r4,r2
8110e5f0:	11106f80 	call	811106f8 <bEnableDbBuffer>


				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110e5f4:	d0a05317 	ldw	r2,-32436(gp)
8110e5f8:	10808904 	addi	r2,r2,548
8110e5fc:	1009883a 	mov	r4,r2
8110e600:	110a5a40 	call	8110a5a4 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110e604:	d0a05317 	ldw	r2,-32436(gp)
8110e608:	10809543 	ldbu	r2,597(r2)
8110e60c:	10803fcc 	andi	r2,r2,255
8110e610:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110e614:	d0a05517 	ldw	r2,-32428(gp)
8110e618:	10800044 	addi	r2,r2,1
8110e61c:	108000cc 	andi	r2,r2,3
8110e620:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110e624:	e0bffc17 	ldw	r2,-16(fp)
8110e628:	10000e1e 	bne	r2,zero,8110e664 <vFeeTask+0xc5c>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110e62c:	d0a05317 	ldw	r2,-32436(gp)
8110e630:	10802917 	ldw	r2,164(r2)
8110e634:	10800003 	ldbu	r2,0(r2)
8110e638:	10803fcc 	andi	r2,r2,255
8110e63c:	10c00044 	addi	r3,r2,1
8110e640:	00a00034 	movhi	r2,32768
8110e644:	10800044 	addi	r2,r2,1
8110e648:	1884703a 	and	r2,r3,r2
8110e64c:	1000040e 	bge	r2,zero,8110e660 <vFeeTask+0xc58>
8110e650:	10bfffc4 	addi	r2,r2,-1
8110e654:	00ffff84 	movi	r3,-2
8110e658:	10c4b03a 	or	r2,r2,r3
8110e65c:	10800044 	addi	r2,r2,1
8110e660:	e0bff305 	stb	r2,-52(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110e664:	d0e05317 	ldw	r3,-32436(gp)
8110e668:	e0bffc17 	ldw	r2,-16(fp)
8110e66c:	1885883a 	add	r2,r3,r2
8110e670:	10802a44 	addi	r2,r2,169
8110e674:	10800003 	ldbu	r2,0(r2)
8110e678:	e0bff505 	stb	r2,-44(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110e67c:	d0a05317 	ldw	r2,-32436(gp)
8110e680:	10802e17 	ldw	r2,184(r2)
8110e684:	1000071e 	bne	r2,zero,8110e6a4 <vFeeTask+0xc9c>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110e688:	d0e05317 	ldw	r3,-32436(gp)
8110e68c:	e0bff503 	ldbu	r2,-44(fp)
8110e690:	10800624 	muli	r2,r2,24
8110e694:	10800904 	addi	r2,r2,36
8110e698:	1885883a 	add	r2,r3,r2
8110e69c:	e0bff415 	stw	r2,-48(fp)
8110e6a0:	00000606 	br	8110e6bc <vFeeTask+0xcb4>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110e6a4:	d0e05317 	ldw	r3,-32436(gp)
8110e6a8:	e0bff503 	ldbu	r2,-44(fp)
8110e6ac:	10800624 	muli	r2,r2,24
8110e6b0:	10800c04 	addi	r2,r2,48
8110e6b4:	1885883a 	add	r2,r3,r2
8110e6b8:	e0bff415 	stw	r2,-48(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8110e6bc:	d0a05317 	ldw	r2,-32436(gp)
8110e6c0:	10802e17 	ldw	r2,184(r2)
8110e6c4:	d0a05605 	stb	r2,-32424(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e6c8:	d0a05317 	ldw	r2,-32436(gp)
8110e6cc:	10803304 	addi	r2,r2,204
8110e6d0:	1009883a 	mov	r4,r2
8110e6d4:	1104a5c0 	call	81104a5c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110e6d8:	d0a05317 	ldw	r2,-32436(gp)
8110e6dc:	e0fff503 	ldbu	r3,-44(fp)
8110e6e0:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110e6e4:	d0a05317 	ldw	r2,-32436(gp)
8110e6e8:	00c00044 	movi	r3,1
8110e6ec:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e6f0:	d0a05317 	ldw	r2,-32436(gp)
8110e6f4:	10803304 	addi	r2,r2,204
8110e6f8:	1009883a 	mov	r4,r2
8110e6fc:	11048300 	call	81104830 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e700:	d0a05317 	ldw	r2,-32436(gp)
8110e704:	10803304 	addi	r2,r2,204
8110e708:	1009883a 	mov	r4,r2
8110e70c:	1104a5c0 	call	81104a5c <bDpktGetPacketConfig>
				#ifdef DEBUG_ON
					//fprintf(fp,"\n    i: %u ",incrementador);
					fprintf(fp,"\n\n=========DATA PACKET=============\n");
8110e710:	d0a06217 	ldw	r2,-32376(gp)
8110e714:	100f883a 	mov	r7,r2
8110e718:	01800904 	movi	r6,36
8110e71c:	01400044 	movi	r5,1
8110e720:	01204574 	movhi	r4,33045
8110e724:	21315604 	addi	r4,r4,-15016
8110e728:	11219e00 	call	811219e0 <fwrite>
					fprintf(fp,"usiCcdXSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize);
8110e72c:	d0e06217 	ldw	r3,-32376(gp)
8110e730:	d0a05317 	ldw	r2,-32436(gp)
8110e734:	1080340b 	ldhu	r2,208(r2)
8110e738:	10bfffcc 	andi	r2,r2,65535
8110e73c:	100d883a 	mov	r6,r2
8110e740:	01604574 	movhi	r5,33045
8110e744:	29714804 	addi	r5,r5,-15072
8110e748:	1809883a 	mov	r4,r3
8110e74c:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"usiCcdYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize);
8110e750:	d0e06217 	ldw	r3,-32376(gp)
8110e754:	d0a05317 	ldw	r2,-32436(gp)
8110e758:	1080348b 	ldhu	r2,210(r2)
8110e75c:	10bfffcc 	andi	r2,r2,65535
8110e760:	100d883a 	mov	r6,r2
8110e764:	01604574 	movhi	r5,33045
8110e768:	29716004 	addi	r5,r5,-14976
8110e76c:	1809883a 	mov	r4,r3
8110e770:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"usiDataYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize);
8110e774:	d0e06217 	ldw	r3,-32376(gp)
8110e778:	d0a05317 	ldw	r2,-32436(gp)
8110e77c:	1080350b 	ldhu	r2,212(r2)
8110e780:	10bfffcc 	andi	r2,r2,65535
8110e784:	100d883a 	mov	r6,r2
8110e788:	01604574 	movhi	r5,33045
8110e78c:	29716504 	addi	r5,r5,-14956
8110e790:	1809883a 	mov	r4,r3
8110e794:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"usiOverscanYSize %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize);
8110e798:	d0e06217 	ldw	r3,-32376(gp)
8110e79c:	d0a05317 	ldw	r2,-32436(gp)
8110e7a0:	1080358b 	ldhu	r2,214(r2)
8110e7a4:	10bfffcc 	andi	r2,r2,65535
8110e7a8:	100d883a 	mov	r6,r2
8110e7ac:	01604574 	movhi	r5,33045
8110e7b0:	29716a04 	addi	r5,r5,-14936
8110e7b4:	1809883a 	mov	r4,r3
8110e7b8:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"usiPacketLength %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength);
8110e7bc:	d0e06217 	ldw	r3,-32376(gp)
8110e7c0:	d0a05317 	ldw	r2,-32436(gp)
8110e7c4:	1080360b 	ldhu	r2,216(r2)
8110e7c8:	10bfffcc 	andi	r2,r2,65535
8110e7cc:	100d883a 	mov	r6,r2
8110e7d0:	01604574 	movhi	r5,33045
8110e7d4:	29717004 	addi	r5,r5,-14912
8110e7d8:	1809883a 	mov	r4,r3
8110e7dc:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"ucCcdNumber %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber);
8110e7e0:	d0e06217 	ldw	r3,-32376(gp)
8110e7e4:	d0a05317 	ldw	r2,-32436(gp)
8110e7e8:	108036c3 	ldbu	r2,219(r2)
8110e7ec:	10803fcc 	andi	r2,r2,255
8110e7f0:	100d883a 	mov	r6,r2
8110e7f4:	01604574 	movhi	r5,33045
8110e7f8:	29717604 	addi	r5,r5,-14888
8110e7fc:	1809883a 	mov	r4,r3
8110e800:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"ucFeeMode %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode);
8110e804:	d0e06217 	ldw	r3,-32376(gp)
8110e808:	d0a05317 	ldw	r2,-32436(gp)
8110e80c:	10803683 	ldbu	r2,218(r2)
8110e810:	10803fcc 	andi	r2,r2,255
8110e814:	100d883a 	mov	r6,r2
8110e818:	01604574 	movhi	r5,33045
8110e81c:	29717b04 	addi	r5,r5,-14868
8110e820:	1809883a 	mov	r4,r3
8110e824:	11213440 	call	81121344 <fprintf>
					fprintf(fp,"=========DATA PACKET=============\n");
8110e828:	d0a06217 	ldw	r2,-32376(gp)
8110e82c:	100f883a 	mov	r7,r2
8110e830:	01800884 	movi	r6,34
8110e834:	01400044 	movi	r5,1
8110e838:	01204574 	movhi	r4,33045
8110e83c:	21314d04 	addi	r4,r4,-15052
8110e840:	11219e00 	call	811219e0 <fwrite>
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110e844:	d0a05317 	ldw	r2,-32436(gp)
8110e848:	10800003 	ldbu	r2,0(r2)
8110e84c:	10803fcc 	andi	r2,r2,255
8110e850:	100d883a 	mov	r6,r2
8110e854:	000b883a 	mov	r5,zero
8110e858:	01002004 	movi	r4,128
8110e85c:	11107fc0 	call	811107fc <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110e860:	e03ff715 	stw	zero,-36(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e864:	d0a05317 	ldw	r2,-32436(gp)
8110e868:	10800003 	ldbu	r2,0(r2)
8110e86c:	10803fcc 	andi	r2,r2,255
8110e870:	1085883a 	add	r2,r2,r2
8110e874:	1087883a 	add	r3,r2,r2
8110e878:	d0a06a04 	addi	r2,gp,-32344
8110e87c:	1885883a 	add	r2,r3,r2
8110e880:	10800017 	ldw	r2,0(r2)
8110e884:	e0fffd04 	addi	r3,fp,-12
8110e888:	180d883a 	mov	r6,r3
8110e88c:	000b883a 	mov	r5,zero
8110e890:	1009883a 	mov	r4,r2
8110e894:	113d9840 	call	8113d984 <OSQPend>
8110e898:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e89c:	e0bffd03 	ldbu	r2,-12(fp)
8110e8a0:	10803fcc 	andi	r2,r2,255
8110e8a4:	1000561e 	bne	r2,zero,8110ea00 <vFeeTask+0xff8>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110e8a8:	e0bffe83 	ldbu	r2,-6(fp)
8110e8ac:	10803fcc 	andi	r2,r2,255
8110e8b0:	108023d8 	cmpnei	r2,r2,143
8110e8b4:	10004c1e 	bne	r2,zero,8110e9e8 <vFeeTask+0xfe0>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110e8b8:	e0fff303 	ldbu	r3,-52(fp)
8110e8bc:	00a045b4 	movhi	r2,33046
8110e8c0:	108e2204 	addi	r2,r2,14472
8110e8c4:	180690fa 	slli	r3,r3,3
8110e8c8:	10c5883a 	add	r2,r2,r3
8110e8cc:	10800017 	ldw	r2,0(r2)
8110e8d0:	e0fffd04 	addi	r3,fp,-12
8110e8d4:	180d883a 	mov	r6,r3
8110e8d8:	000b883a 	mov	r5,zero
8110e8dc:	1009883a 	mov	r4,r2
8110e8e0:	113c8700 	call	8113c870 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110e8e4:	e0bffd03 	ldbu	r2,-12(fp)
8110e8e8:	10803fcc 	andi	r2,r2,255
8110e8ec:	1000181e 	bne	r2,zero,8110e950 <vFeeTask+0xf48>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110e8f0:	d0a05317 	ldw	r2,-32436(gp)
8110e8f4:	00c00044 	movi	r3,1
8110e8f8:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee );
8110e8fc:	e0fff303 	ldbu	r3,-52(fp)
8110e900:	d0a05317 	ldw	r2,-32436(gp)
8110e904:	10800003 	ldbu	r2,0(r2)
8110e908:	10803fcc 	andi	r2,r2,255
8110e90c:	d1205317 	ldw	r4,-32436(gp)
8110e910:	200f883a 	mov	r7,r4
8110e914:	100d883a 	mov	r6,r2
8110e918:	180b883a 	mov	r5,r3
8110e91c:	e13ff417 	ldw	r4,-48(fp)
8110e920:	11112ac0 	call	811112ac <bPrepareDoubleBuffer>
8110e924:	e0bff715 	stw	r2,-36(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e928:	e0fff303 	ldbu	r3,-52(fp)
8110e92c:	00a045b4 	movhi	r2,33046
8110e930:	108e2204 	addi	r2,r2,14472
8110e934:	180690fa 	slli	r3,r3,3
8110e938:	10c5883a 	add	r2,r2,r3
8110e93c:	10800017 	ldw	r2,0(r2)
8110e940:	1009883a 	mov	r4,r2
8110e944:	113ce140 	call	8113ce14 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110e948:	d0a05317 	ldw	r2,-32436(gp)
8110e94c:	10002215 	stw	zero,136(r2)
		
						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110e950:	d0a05317 	ldw	r2,-32436(gp)
8110e954:	10800003 	ldbu	r2,0(r2)
8110e958:	10803fcc 	andi	r2,r2,255
8110e95c:	100d883a 	mov	r6,r2
8110e960:	000b883a 	mov	r5,zero
8110e964:	01002044 	movi	r4,129
8110e968:	11108a00 	call	811108a0 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8110e96c:	e0bff717 	ldw	r2,-36(fp)
8110e970:	10800058 	cmpnei	r2,r2,1
8110e974:	1000141e 	bne	r2,zero,8110e9c8 <vFeeTask+0xfc0>
							if (pxNFee->xControl.bWatingSync==TRUE) {
8110e978:	d0a05317 	ldw	r2,-32436(gp)
8110e97c:	10802817 	ldw	r2,160(r2)
8110e980:	10800058 	cmpnei	r2,r2,1
8110e984:	1000071e 	bne	r2,zero,8110e9a4 <vFeeTask+0xf9c>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110e988:	d0a05317 	ldw	r2,-32436(gp)
8110e98c:	00c001c4 	movi	r3,7
8110e990:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8110e994:	d0a05317 	ldw	r2,-32436(gp)
8110e998:	00c00304 	movi	r3,12
8110e99c:	10c02c15 	stw	r3,176(r2)
8110e9a0:	00000606 	br	8110e9bc <vFeeTask+0xfb4>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110e9a4:	d0a05317 	ldw	r2,-32436(gp)
8110e9a8:	00c001c4 	movi	r3,7
8110e9ac:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8110e9b0:	d0a05317 	ldw	r2,-32436(gp)
8110e9b4:	00c001c4 	movi	r3,7
8110e9b8:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
8110e9bc:	d0a05417 	ldw	r2,-32432(gp)
8110e9c0:	10800044 	addi	r2,r2,1
8110e9c4:	d0a05415 	stw	r2,-32432(gp)
						}


							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
8110e9c8:	d0a06217 	ldw	r2,-32376(gp)
8110e9cc:	100f883a 	mov	r7,r2
8110e9d0:	01800904 	movi	r6,36
8110e9d4:	01400044 	movi	r5,1
8110e9d8:	01204574 	movhi	r4,33045
8110e9dc:	21317f04 	addi	r4,r4,-14852
8110e9e0:	11219e00 	call	811219e0 <fwrite>
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}	
				break;
8110e9e4:	00018c06 	br	8110f018 <vFeeTask+0x1610>
							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
							#endif							
					} else {

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110e9e8:	d0a05317 	ldw	r2,-32436(gp)
8110e9ec:	e0fffe17 	ldw	r3,-8(fp)
8110e9f0:	180b883a 	mov	r5,r3
8110e9f4:	1009883a 	mov	r4,r2
8110e9f8:	110f5c40 	call	8110f5c4 <vQCmdFEEinFullPattern>
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}	
				break;
8110e9fc:	00018606 	br	8110f018 <vFeeTask+0x1610>

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ea00:	d0e06217 	ldw	r3,-32376(gp)
8110ea04:	d0a05317 	ldw	r2,-32436(gp)
8110ea08:	10800003 	ldbu	r2,0(r2)
8110ea0c:	10803fcc 	andi	r2,r2,255
8110ea10:	100d883a 	mov	r6,r2
8110ea14:	01604574 	movhi	r5,33045
8110ea18:	29712c04 	addi	r5,r5,-15184
8110ea1c:	1809883a 	mov	r4,r3
8110ea20:	11213440 	call	81121344 <fprintf>
					#endif
				}	
				break;
8110ea24:	00017c06 	br	8110f018 <vFeeTask+0x1610>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110ea28:	e03ff815 	stw	zero,-32(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ea2c:	d0a05317 	ldw	r2,-32436(gp)
8110ea30:	10804304 	addi	r2,r2,268
8110ea34:	1009883a 	mov	r4,r2
8110ea38:	11081980 	call	81108198 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110ea3c:	d0a05317 	ldw	r2,-32436(gp)
8110ea40:	00c00084 	movi	r3,2
8110ea44:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110ea48:	d0a05317 	ldw	r2,-32436(gp)
8110ea4c:	10804304 	addi	r2,r2,268
8110ea50:	1009883a 	mov	r4,r2
8110ea54:	1107eac0 	call	81107eac <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110ea58:	d0e06217 	ldw	r3,-32376(gp)
8110ea5c:	d0a05317 	ldw	r2,-32436(gp)
8110ea60:	10800003 	ldbu	r2,0(r2)
8110ea64:	10803fcc 	andi	r2,r2,255
8110ea68:	100d883a 	mov	r6,r2
8110ea6c:	01604574 	movhi	r5,33045
8110ea70:	29718904 	addi	r5,r5,-14812
8110ea74:	1809883a 	mov	r4,r3
8110ea78:	11213440 	call	81121344 <fprintf>
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
8110ea7c:	d0a05317 	ldw	r2,-32436(gp)
8110ea80:	10802e17 	ldw	r2,184(r2)
8110ea84:	d0a05605 	stb	r2,-32424(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8110ea88:	d0a05317 	ldw	r2,-32436(gp)
8110ea8c:	00c00044 	movi	r3,1
8110ea90:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110ea94:	d0a05317 	ldw	r2,-32436(gp)
8110ea98:	00c00104 	movi	r3,4
8110ea9c:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110eaa0:	d0a05317 	ldw	r2,-32436(gp)
8110eaa4:	00c00104 	movi	r3,4
8110eaa8:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110eaac:	d0a05317 	ldw	r2,-32436(gp)
8110eab0:	00c00044 	movi	r3,1
8110eab4:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110eab8:	d0a05317 	ldw	r2,-32436(gp)
8110eabc:	00c00044 	movi	r3,1
8110eac0:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110eac4:	d0a05317 	ldw	r2,-32436(gp)
8110eac8:	00c00044 	movi	r3,1
8110eacc:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ead0:	d0a05317 	ldw	r2,-32436(gp)
8110ead4:	10800003 	ldbu	r2,0(r2)
8110ead8:	10803fcc 	andi	r2,r2,255
8110eadc:	100d883a 	mov	r6,r2
8110eae0:	000b883a 	mov	r5,zero
8110eae4:	01002004 	movi	r4,128
8110eae8:	11107fc0 	call	811107fc <bSendRequestNFeeCtrl>



				if (xDefaults.usiLinkNFEE0 == 0) {
8110eaec:	00a045b4 	movhi	r2,33046
8110eaf0:	109ade04 	addi	r2,r2,27512
8110eaf4:	1080100b 	ldhu	r2,64(r2)
8110eaf8:	10bfffcc 	andi	r2,r2,65535
8110eafc:	1000071e 	bne	r2,zero,8110eb1c <vFeeTask+0x1114>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110eb00:	000b883a 	mov	r5,zero
8110eb04:	01000404 	movi	r4,16
8110eb08:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110eb0c:	01400044 	movi	r5,1
8110eb10:	01000404 	movi	r4,16
8110eb14:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
				//bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);


				break;
8110eb18:	00013f06 	br	8110f018 <vFeeTask+0x1610>

				if (xDefaults.usiLinkNFEE0 == 0) {
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110eb1c:	000b883a 	mov	r5,zero
8110eb20:	01000404 	movi	r4,16
8110eb24:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110eb28:	01400044 	movi	r5,1
8110eb2c:	01000404 	movi	r4,16
8110eb30:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>
				//bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);


				break;
8110eb34:	00013806 	br	8110f018 <vFeeTask+0x1610>


			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8110eb38:	e03ff815 	stw	zero,-32(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110eb3c:	d0a05317 	ldw	r2,-32436(gp)
8110eb40:	10800003 	ldbu	r2,0(r2)
8110eb44:	10803fcc 	andi	r2,r2,255
8110eb48:	1085883a 	add	r2,r2,r2
8110eb4c:	1087883a 	add	r3,r2,r2
8110eb50:	d0a06a04 	addi	r2,gp,-32344
8110eb54:	1885883a 	add	r2,r3,r2
8110eb58:	10800017 	ldw	r2,0(r2)
8110eb5c:	e0fffd04 	addi	r3,fp,-12
8110eb60:	180d883a 	mov	r6,r3
8110eb64:	000b883a 	mov	r5,zero
8110eb68:	1009883a 	mov	r4,r2
8110eb6c:	113d9840 	call	8113d984 <OSQPend>
8110eb70:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110eb74:	e0bffd03 	ldbu	r2,-12(fp)
8110eb78:	10803fcc 	andi	r2,r2,255
8110eb7c:	1000c71e 	bne	r2,zero,8110ee9c <vFeeTask+0x1494>

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110eb80:	e0bffe83 	ldbu	r2,-6(fp)
8110eb84:	10803fcc 	andi	r2,r2,255
8110eb88:	108023d8 	cmpnei	r2,r2,143
8110eb8c:	1000b61e 	bne	r2,zero,8110ee68 <vFeeTask+0x1460>

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110eb90:	e0fff303 	ldbu	r3,-52(fp)
8110eb94:	00a045b4 	movhi	r2,33046
8110eb98:	108e2204 	addi	r2,r2,14472
8110eb9c:	180690fa 	slli	r3,r3,3
8110eba0:	10c5883a 	add	r2,r2,r3
8110eba4:	10800017 	ldw	r2,0(r2)
8110eba8:	e0fffd04 	addi	r3,fp,-12
8110ebac:	180d883a 	mov	r6,r3
8110ebb0:	000b883a 	mov	r5,zero
8110ebb4:	1009883a 	mov	r4,r2
8110ebb8:	113c8700 	call	8113c870 <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110ebbc:	e0bffd03 	ldbu	r2,-12(fp)
8110ebc0:	10803fcc 	andi	r2,r2,255
8110ebc4:	1001131e 	bne	r2,zero,8110f014 <vFeeTask+0x160c>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110ebc8:	d0a05317 	ldw	r2,-32436(gp)
8110ebcc:	00c00044 	movi	r3,1
8110ebd0:	10c02215 	stw	r3,136(r2)

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110ebd4:	e0bff417 	ldw	r2,-48(fp)
8110ebd8:	10800117 	ldw	r2,4(r2)
8110ebdc:	10c00404 	addi	r3,r2,16
8110ebe0:	d0a05317 	ldw	r2,-32436(gp)
8110ebe4:	10800417 	ldw	r2,16(r2)
8110ebe8:	18804036 	bltu	r3,r2,8110ecec <vFeeTask+0x12e4>


									#ifdef DEBUG_ON
										//fprintf(fp,"\n    i: %u ",incrementador);
										fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu  -> Time Code Ref. used -> %hu   total = %lu\n", pxNFee->ucId, ucReadout, tCodFeeTask, incrementador);
8110ebec:	d1206217 	ldw	r4,-32376(gp)
8110ebf0:	d0a05317 	ldw	r2,-32436(gp)
8110ebf4:	10800003 	ldbu	r2,0(r2)
8110ebf8:	11403fcc 	andi	r5,r2,255
8110ebfc:	e1bff503 	ldbu	r6,-44(fp)
8110ec00:	d0a05517 	ldw	r2,-32428(gp)
8110ec04:	d0e05417 	ldw	r3,-32432(gp)
8110ec08:	d8c00115 	stw	r3,4(sp)
8110ec0c:	d8800015 	stw	r2,0(sp)
8110ec10:	300f883a 	mov	r7,r6
8110ec14:	280d883a 	mov	r6,r5
8110ec18:	01604574 	movhi	r5,33045
8110ec1c:	29719304 	addi	r5,r5,-14772
8110ec20:	11213440 	call	81121344 <fprintf>
										fprintf(fp,"\nMemory used: %u ", ucMemUsing);
8110ec24:	d0a06217 	ldw	r2,-32376(gp)
8110ec28:	e0fff303 	ldbu	r3,-52(fp)
8110ec2c:	180d883a 	mov	r6,r3
8110ec30:	01604574 	movhi	r5,33045
8110ec34:	2971aa04 	addi	r5,r5,-14680
8110ec38:	1009883a 	mov	r4,r2
8110ec3c:	11213440 	call	81121344 <fprintf>
										fprintf(fp,"\nTotal blocks transmitted: %lu ",xCcdMapLocal->ulBlockI);
8110ec40:	d0e06217 	ldw	r3,-32376(gp)
8110ec44:	e0bff417 	ldw	r2,-48(fp)
8110ec48:	10800117 	ldw	r2,4(r2)
8110ec4c:	100d883a 	mov	r6,r2
8110ec50:	01604574 	movhi	r5,33045
8110ec54:	2971af04 	addi	r5,r5,-14660
8110ec58:	1809883a 	mov	r4,r3
8110ec5c:	11213440 	call	81121344 <fprintf>
									#endif

		                    		/*Define the size of the data in the double buffer (need this to create the interrupt riht)*/

									usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110ec60:	d0a05317 	ldw	r2,-32436(gp)
8110ec64:	10c00417 	ldw	r3,16(r2)
8110ec68:	e0bff417 	ldw	r2,-48(fp)
8110ec6c:	10800117 	ldw	r2,4(r2)
8110ec70:	1885c83a 	sub	r2,r3,r2
8110ec74:	e0bff615 	stw	r2,-40(fp)

		                    		bFinal = TRUE;
8110ec78:	00800044 	movi	r2,1
8110ec7c:	e0bff815 	stw	r2,-32(fp)

		            				if (xDefaults.usiLinkNFEE0 == 0) {
8110ec80:	00a045b4 	movhi	r2,33046
8110ec84:	109ade04 	addi	r2,r2,27512
8110ec88:	1080100b 	ldhu	r2,64(r2)
8110ec8c:	10bfffcc 	andi	r2,r2,65535
8110ec90:	10000b1e 	bne	r2,zero,8110ecc0 <vFeeTask+0x12b8>
		            					bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
8110ec94:	e0bff617 	ldw	r2,-40(fp)
8110ec98:	10803fcc 	andi	r2,r2,255
8110ec9c:	000b883a 	mov	r5,zero
8110eca0:	1009883a 	mov	r4,r2
8110eca4:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
		            					bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
8110eca8:	e0bff617 	ldw	r2,-40(fp)
8110ecac:	10803fcc 	andi	r2,r2,255
8110ecb0:	01400044 	movi	r5,1
8110ecb4:	1009883a 	mov	r4,r2
8110ecb8:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
8110ecbc:	00000e06 	br	8110ecf8 <vFeeTask+0x12f0>
		            				} else {
		            					bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
8110ecc0:	e0bff617 	ldw	r2,-40(fp)
8110ecc4:	10803fcc 	andi	r2,r2,255
8110ecc8:	000b883a 	mov	r5,zero
8110eccc:	1009883a 	mov	r4,r2
8110ecd0:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>
		            					bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
8110ecd4:	e0bff617 	ldw	r2,-40(fp)
8110ecd8:	10803fcc 	andi	r2,r2,255
8110ecdc:	01400044 	movi	r5,1
8110ece0:	1009883a 	mov	r4,r2
8110ece4:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>
8110ece8:	00000306 	br	8110ecf8 <vFeeTask+0x12f0>
									//bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
									//bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
									//bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
		                    	} else {

		                    		bFinal = FALSE;
8110ecec:	e03ff815 	stw	zero,-32(fp)
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110ecf0:	00800404 	movi	r2,16
8110ecf4:	e0bff615 	stw	r2,-40(fp)
		                    	}



		                    	if ( ucMemUsing == 0  ) {
8110ecf8:	e0bff303 	ldbu	r2,-52(fp)
8110ecfc:	1000111e 	bne	r2,zero,8110ed44 <vFeeTask+0x133c>
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110ed00:	e0bff417 	ldw	r2,-48(fp)
8110ed04:	10800217 	ldw	r2,8(r2)
8110ed08:	1011883a 	mov	r8,r2
8110ed0c:	e0bff617 	ldw	r2,-40(fp)
8110ed10:	10ffffcc 	andi	r3,r2,65535
8110ed14:	d0a05603 	ldbu	r2,-32424(gp)
8110ed18:	11003fcc 	andi	r4,r2,255
8110ed1c:	d0a05317 	ldw	r2,-32436(gp)
8110ed20:	10800043 	ldbu	r2,1(r2)
8110ed24:	10803fcc 	andi	r2,r2,255
8110ed28:	100f883a 	mov	r7,r2
8110ed2c:	200d883a 	mov	r6,r4
8110ed30:	180b883a 	mov	r5,r3
8110ed34:	4009883a 	mov	r4,r8
8110ed38:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110ed3c:	e0bff715 	stw	r2,-36(fp)
8110ed40:	00001006 	br	8110ed84 <vFeeTask+0x137c>
		                    	} else {

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110ed44:	e0bff417 	ldw	r2,-48(fp)
8110ed48:	10800217 	ldw	r2,8(r2)
8110ed4c:	1011883a 	mov	r8,r2
8110ed50:	e0bff617 	ldw	r2,-40(fp)
8110ed54:	10ffffcc 	andi	r3,r2,65535
8110ed58:	d0a05603 	ldbu	r2,-32424(gp)
8110ed5c:	11003fcc 	andi	r4,r2,255
8110ed60:	d0a05317 	ldw	r2,-32436(gp)
8110ed64:	10800043 	ldbu	r2,1(r2)
8110ed68:	10803fcc 	andi	r2,r2,255
8110ed6c:	100f883a 	mov	r7,r2
8110ed70:	200d883a 	mov	r6,r4
8110ed74:	180b883a 	mov	r5,r3
8110ed78:	4009883a 	mov	r4,r8
8110ed7c:	11040ec0 	call	811040ec <bSdmaDmaM2Transfer>
8110ed80:	e0bff715 	stw	r2,-36(fp)
		                    	}

		                    	OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110ed84:	e0fff303 	ldbu	r3,-52(fp)
8110ed88:	00a045b4 	movhi	r2,33046
8110ed8c:	108e2204 	addi	r2,r2,14472
8110ed90:	180690fa 	slli	r3,r3,3
8110ed94:	10c5883a 	add	r2,r2,r3
8110ed98:	10800017 	ldw	r2,0(r2)
8110ed9c:	1009883a 	mov	r4,r2
8110eda0:	113ce140 	call	8113ce14 <OSMutexPost>
		                    	pxNFee->xControl.bDMALocked = FALSE;
8110eda4:	d0a05317 	ldw	r2,-32436(gp)
8110eda8:	10002215 	stw	zero,136(r2)

		                    	if ( bDmaReturn == TRUE ) {
8110edac:	e0bff717 	ldw	r2,-36(fp)
8110edb0:	10800058 	cmpnei	r2,r2,1
8110edb4:	10000e1e 	bne	r2,zero,8110edf0 <vFeeTask+0x13e8>

									/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
									xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8110edb8:	e0bff417 	ldw	r2,-48(fp)
8110edbc:	10c00217 	ldw	r3,8(r2)
8110edc0:	e0bff617 	ldw	r2,-40(fp)
8110edc4:	10802224 	muli	r2,r2,136
8110edc8:	1887883a 	add	r3,r3,r2
8110edcc:	e0bff417 	ldw	r2,-48(fp)
8110edd0:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += usiLengthBlocks;
8110edd4:	e0bff417 	ldw	r2,-48(fp)
8110edd8:	10c00117 	ldw	r3,4(r2)
8110eddc:	e0bff617 	ldw	r2,-40(fp)
8110ede0:	1887883a 	add	r3,r3,r2
8110ede4:	e0bff417 	ldw	r2,-48(fp)
8110ede8:	10c00115 	stw	r3,4(r2)
8110edec:	00000806 	br	8110ee10 <vFeeTask+0x1408>
									//bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
		                    	} else {
									#ifdef DEBUG_ON
										fprintf(fp,"\n-- Can't write in the DMA \n ");
8110edf0:	d0a06217 	ldw	r2,-32376(gp)
8110edf4:	100f883a 	mov	r7,r2
8110edf8:	01800744 	movi	r6,29
8110edfc:	01400044 	movi	r5,1
8110ee00:	01204574 	movhi	r4,33045
8110ee04:	2131b704 	addi	r4,r4,-14628
8110ee08:	11219e00 	call	811219e0 <fwrite>
									#endif
									bFinal = FALSE;
8110ee0c:	e03ff815 	stw	zero,-32(fp)
		                    	}


		                        /* Send message telling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110ee10:	d0a05317 	ldw	r2,-32436(gp)
8110ee14:	10800003 	ldbu	r2,0(r2)
8110ee18:	10803fcc 	andi	r2,r2,255
8110ee1c:	100d883a 	mov	r6,r2
8110ee20:	000b883a 	mov	r5,zero
8110ee24:	01002044 	movi	r4,129
8110ee28:	11108a00 	call	811108a0 <bSendGiveBackNFeeCtrl>
										fprintf(fp,"\nblock: %lu ", xCcdMapLocal->ulBlockI);
									#endif
								}
*/

								if ( bFinal == TRUE ) {
8110ee2c:	e0bff817 	ldw	r2,-32(fp)
8110ee30:	10800058 	cmpnei	r2,r2,1
8110ee34:	1000041e 	bne	r2,zero,8110ee48 <vFeeTask+0x1440>
									pxNFee->xControl.eMode = sEndTransmission;
8110ee38:	d0a05317 	ldw	r2,-32436(gp)
8110ee3c:	00c002c4 	movi	r3,11
8110ee40:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ee44:	00007306 	br	8110f014 <vFeeTask+0x160c>
*/

								if ( bFinal == TRUE ) {
									pxNFee->xControl.eMode = sEndTransmission;
								} else {
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ee48:	d0a05317 	ldw	r2,-32436(gp)
8110ee4c:	10800003 	ldbu	r2,0(r2)
8110ee50:	10803fcc 	andi	r2,r2,255
8110ee54:	100d883a 	mov	r6,r2
8110ee58:	000b883a 	mov	r5,zero
8110ee5c:	01002004 	movi	r4,128
8110ee60:	11107fc0 	call	811107fc <bSendRequestNFeeCtrl>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ee64:	00006b06 	br	8110f014 <vFeeTask+0x160c>
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
								}

		                    }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110ee68:	d0a05317 	ldw	r2,-32436(gp)
8110ee6c:	e0fffe17 	ldw	r3,-8(fp)
8110ee70:	180b883a 	mov	r5,r3
8110ee74:	1009883a 	mov	r4,r2
8110ee78:	110f5c40 	call	8110f5c4 <vQCmdFEEinFullPattern>

							if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110ee7c:	d0a05317 	ldw	r2,-32436(gp)
8110ee80:	10802817 	ldw	r2,160(r2)
8110ee84:	1000631e 	bne	r2,zero,8110f014 <vFeeTask+0x160c>
								pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110ee88:	d0a05317 	ldw	r2,-32436(gp)
8110ee8c:	d0e05317 	ldw	r3,-32436(gp)
8110ee90:	18c02d17 	ldw	r3,180(r3)
8110ee94:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ee98:	00005e06 	br	8110f014 <vFeeTask+0x160c>
							}
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110ee9c:	d0e06217 	ldw	r3,-32376(gp)
8110eea0:	d0a05317 	ldw	r2,-32436(gp)
8110eea4:	10800003 	ldbu	r2,0(r2)
8110eea8:	10803fcc 	andi	r2,r2,255
8110eeac:	100d883a 	mov	r6,r2
8110eeb0:	01604574 	movhi	r5,33045
8110eeb4:	29712c04 	addi	r5,r5,-15184
8110eeb8:	1809883a 	mov	r4,r3
8110eebc:	11213440 	call	81121344 <fprintf>
					#endif
				}

				break;
8110eec0:	00005406 	br	8110f014 <vFeeTask+0x160c>

			case sEndTransmission:

				pxNFee->xControl.bWatingSync = TRUE;
8110eec4:	d0a05317 	ldw	r2,-32436(gp)
8110eec8:	00c00044 	movi	r3,1
8110eecc:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110eed0:	d0a05317 	ldw	r2,-32436(gp)
8110eed4:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bDataPacket == TRUE ) {
8110eed8:	00a045b4 	movhi	r2,33046
8110eedc:	109ade04 	addi	r2,r2,27512
8110eee0:	10800817 	ldw	r2,32(r2)
8110eee4:	10800058 	cmpnei	r2,r2,1
8110eee8:	1000111e 	bne	r2,zero,8110ef30 <vFeeTask+0x1528>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110eeec:	d0a05317 	ldw	r2,-32436(gp)
8110eef0:	10802d17 	ldw	r2,180(r2)
8110eef4:	10800198 	cmpnei	r2,r2,6
8110eef8:	1000071e 	bne	r2,zero,8110ef18 <vFeeTask+0x1510>
						pxNFee->xControl.eMode =  sFeeWaitingSync;
8110eefc:	d0a05317 	ldw	r2,-32436(gp)
8110ef00:	00c00304 	movi	r3,12
8110ef04:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110ef08:	d0a05317 	ldw	r2,-32436(gp)
8110ef0c:	00c00184 	movi	r3,6
8110ef10:	10c02d15 	stw	r3,180(r2)
8110ef14:	00000606 	br	8110ef30 <vFeeTask+0x1528>
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8110ef18:	d0a05317 	ldw	r2,-32436(gp)
8110ef1c:	00c00284 	movi	r3,10
8110ef20:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110ef24:	d0a05317 	ldw	r2,-32436(gp)
8110ef28:	00c00304 	movi	r3,12
8110ef2c:	10c02d15 	stw	r3,180(r2)

				//pxNFee->xControl.eMode =  sFeeWaitingSync;
				//pxNFee->xControl.eNextMode =  sToFeeStandBy;


				bFinal = FALSE;
8110ef30:	e03ff815 	stw	zero,-32(fp)
				break;
8110ef34:	00003806 	br	8110f018 <vFeeTask+0x1610>

			case sFeeWaitingSync:

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110ef38:	d0e06217 	ldw	r3,-32376(gp)
8110ef3c:	d0a05317 	ldw	r2,-32436(gp)
8110ef40:	10800003 	ldbu	r2,0(r2)
8110ef44:	10803fcc 	andi	r2,r2,255
8110ef48:	100d883a 	mov	r6,r2
8110ef4c:	01604574 	movhi	r5,33045
8110ef50:	2971bf04 	addi	r5,r5,-14596
8110ef54:	1809883a 	mov	r4,r3
8110ef58:	11213440 	call	81121344 <fprintf>
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ef5c:	d0a05317 	ldw	r2,-32436(gp)
8110ef60:	10800003 	ldbu	r2,0(r2)
8110ef64:	10803fcc 	andi	r2,r2,255
8110ef68:	1085883a 	add	r2,r2,r2
8110ef6c:	1087883a 	add	r3,r2,r2
8110ef70:	d0a06a04 	addi	r2,gp,-32344
8110ef74:	1885883a 	add	r2,r3,r2
8110ef78:	10800017 	ldw	r2,0(r2)
8110ef7c:	e0fffd04 	addi	r3,fp,-12
8110ef80:	180d883a 	mov	r6,r3
8110ef84:	000b883a 	mov	r5,zero
8110ef88:	1009883a 	mov	r4,r2
8110ef8c:	113d9840 	call	8113d984 <OSQPend>
8110ef90:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110ef94:	e0bffd03 	ldbu	r2,-12(fp)
8110ef98:	10803fcc 	andi	r2,r2,255
8110ef9c:	10000a26 	beq	r2,zero,8110efc8 <vFeeTask+0x15c0>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110efa0:	d0e06217 	ldw	r3,-32376(gp)
8110efa4:	d0a05317 	ldw	r2,-32436(gp)
8110efa8:	10800003 	ldbu	r2,0(r2)
8110efac:	10803fcc 	andi	r2,r2,255
8110efb0:	100d883a 	mov	r6,r2
8110efb4:	01604574 	movhi	r5,33045
8110efb8:	2971c804 	addi	r5,r5,-14560
8110efbc:	1809883a 	mov	r4,r3
8110efc0:	11213440 	call	81121344 <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110efc4:	00001406 	br	8110f018 <vFeeTask+0x1610>
				if ( error_code != OS_ERR_NONE ) {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110efc8:	d0a05317 	ldw	r2,-32436(gp)
8110efcc:	e0fffe17 	ldw	r3,-8(fp)
8110efd0:	180b883a 	mov	r5,r3
8110efd4:	1009883a 	mov	r4,r2
8110efd8:	110f01c0 	call	8110f01c <vQCmdFEEinWaitingSync>
				}

				break;
8110efdc:	00000e06 	br	8110f018 <vFeeTask+0x1610>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110efe0:	d0a05317 	ldw	r2,-32436(gp)
8110efe4:	00c00144 	movi	r3,5
8110efe8:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110efec:	d0e06217 	ldw	r3,-32376(gp)
8110eff0:	d0a05317 	ldw	r2,-32436(gp)
8110eff4:	10800003 	ldbu	r2,0(r2)
8110eff8:	10803fcc 	andi	r2,r2,255
8110effc:	100d883a 	mov	r6,r2
8110f000:	01604574 	movhi	r5,33045
8110f004:	2971d904 	addi	r5,r5,-14492
8110f008:	1809883a 	mov	r4,r3
8110f00c:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f010:	00000106 	br	8110f018 <vFeeTask+0x1610>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f014:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110f018:	003a9106 	br	8110da60 <__reset+0xfb0eda60>

8110f01c <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110f01c:	defffb04 	addi	sp,sp,-20
8110f020:	de00012e 	bgeu	sp,et,8110f028 <vQCmdFEEinWaitingSync+0xc>
8110f024:	003b68fa 	trap	3
8110f028:	dfc00415 	stw	ra,16(sp)
8110f02c:	df000315 	stw	fp,12(sp)
8110f030:	df000304 	addi	fp,sp,12
8110f034:	e13ffe15 	stw	r4,-8(fp)
8110f038:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f03c:	e0bfff17 	ldw	r2,-4(fp)
8110f040:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f044:	e0bffdc3 	ldbu	r2,-9(fp)
8110f048:	10c03fcc 	andi	r3,r2,255
8110f04c:	e0bffe17 	ldw	r2,-8(fp)
8110f050:	10800003 	ldbu	r2,0(r2)
8110f054:	10803fcc 	andi	r2,r2,255
8110f058:	10800444 	addi	r2,r2,17
8110f05c:	1880631e 	bne	r3,r2,8110f1ec <vQCmdFEEinWaitingSync+0x1d0>

		switch (uiCmdFEEL.ucByte[2]) {
8110f060:	e0bffd83 	ldbu	r2,-10(fp)
8110f064:	10803fcc 	andi	r2,r2,255
8110f068:	10c02860 	cmpeqi	r3,r2,161
8110f06c:	18001a1e 	bne	r3,zero,8110f0d8 <vQCmdFEEinWaitingSync+0xbc>
8110f070:	10c02888 	cmpgei	r3,r2,162
8110f074:	18000c1e 	bne	r3,zero,8110f0a8 <vQCmdFEEinWaitingSync+0x8c>
8110f078:	10c00120 	cmpeqi	r3,r2,4
8110f07c:	18001f1e 	bne	r3,zero,8110f0fc <vQCmdFEEinWaitingSync+0xe0>
8110f080:	10c00148 	cmpgei	r3,r2,5
8110f084:	1800031e 	bne	r3,zero,8110f094 <vQCmdFEEinWaitingSync+0x78>
8110f088:	10800060 	cmpeqi	r2,r2,1
8110f08c:	1000121e 	bne	r2,zero,8110f0d8 <vQCmdFEEinWaitingSync+0xbc>
8110f090:	00004c06 	br	8110f1c4 <vQCmdFEEinWaitingSync+0x1a8>
8110f094:	10c00220 	cmpeqi	r3,r2,8
8110f098:	1800221e 	bne	r3,zero,8110f124 <vQCmdFEEinWaitingSync+0x108>
8110f09c:	108023e0 	cmpeqi	r2,r2,143
8110f0a0:	10003e1e 	bne	r2,zero,8110f19c <vQCmdFEEinWaitingSync+0x180>
8110f0a4:	00004706 	br	8110f1c4 <vQCmdFEEinWaitingSync+0x1a8>
8110f0a8:	10c03888 	cmpgei	r3,r2,226
8110f0ac:	1800071e 	bne	r3,zero,8110f0cc <vQCmdFEEinWaitingSync+0xb0>
8110f0b0:	10c03808 	cmpgei	r3,r2,224
8110f0b4:	1800321e 	bne	r3,zero,8110f180 <vQCmdFEEinWaitingSync+0x164>
8110f0b8:	10c02920 	cmpeqi	r3,r2,164
8110f0bc:	18000f1e 	bne	r3,zero,8110f0fc <vQCmdFEEinWaitingSync+0xe0>
8110f0c0:	10802a20 	cmpeqi	r2,r2,168
8110f0c4:	1000171e 	bne	r2,zero,8110f124 <vQCmdFEEinWaitingSync+0x108>
8110f0c8:	00003e06 	br	8110f1c4 <vQCmdFEEinWaitingSync+0x1a8>
8110f0cc:	10803c20 	cmpeqi	r2,r2,240
8110f0d0:	10001e1e 	bne	r2,zero,8110f14c <vQCmdFEEinWaitingSync+0x130>
8110f0d4:	00003b06 	br	8110f1c4 <vQCmdFEEinWaitingSync+0x1a8>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f0d8:	e0bffe17 	ldw	r2,-8(fp)
8110f0dc:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f0e0:	e0bffe17 	ldw	r2,-8(fp)
8110f0e4:	00c00144 	movi	r3,5
8110f0e8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f0ec:	e0bffe17 	ldw	r2,-8(fp)
8110f0f0:	00c00144 	movi	r3,5
8110f0f4:	10c02d15 	stw	r3,180(r2)
				break;
8110f0f8:	00003c06 	br	8110f1ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f0fc:	e0bffe17 	ldw	r2,-8(fp)
8110f100:	00c00044 	movi	r3,1
8110f104:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110f108:	e0bffe17 	ldw	r2,-8(fp)
8110f10c:	00c00304 	movi	r3,12
8110f110:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f114:	e0bffe17 	ldw	r2,-8(fp)
8110f118:	00c00184 	movi	r3,6
8110f11c:	10c02d15 	stw	r3,180(r2)
				break;
8110f120:	00003206 	br	8110f1ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f124:	e0bffe17 	ldw	r2,-8(fp)
8110f128:	00c00044 	movi	r3,1
8110f12c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f130:	e0bffe17 	ldw	r2,-8(fp)
8110f134:	00c00284 	movi	r3,10
8110f138:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f13c:	e0bffe17 	ldw	r2,-8(fp)
8110f140:	00c00304 	movi	r3,12
8110f144:	10c02d15 	stw	r3,180(r2)
				break;
8110f148:	00002806 	br	8110f1ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f14c:	d0e06217 	ldw	r3,-32376(gp)
8110f150:	e0bffe17 	ldw	r2,-8(fp)
8110f154:	10800003 	ldbu	r2,0(r2)
8110f158:	10803fcc 	andi	r2,r2,255
8110f15c:	100d883a 	mov	r6,r2
8110f160:	01604574 	movhi	r5,33045
8110f164:	2971e404 	addi	r5,r5,-14448
8110f168:	1809883a 	mov	r4,r3
8110f16c:	11213440 	call	81121344 <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110f170:	e17fff17 	ldw	r5,-4(fp)
8110f174:	e13ffe17 	ldw	r4,-8(fp)
8110f178:	11101680 	call	81110168 <vQCmdFeeRMAPWaitingSync>
				break;
8110f17c:	00001b06 	br	8110f1ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f180:	e0bffe17 	ldw	r2,-8(fp)
8110f184:	10c02d17 	ldw	r3,180(r2)
8110f188:	e0bffe17 	ldw	r2,-8(fp)
8110f18c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f190:	e0bffe17 	ldw	r2,-8(fp)
8110f194:	10002815 	stw	zero,160(r2)

				break;
8110f198:	00001406 	br	8110f1ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f19c:	e0bffe17 	ldw	r2,-8(fp)
8110f1a0:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f1a4:	e0bffe17 	ldw	r2,-8(fp)
8110f1a8:	10800003 	ldbu	r2,0(r2)
8110f1ac:	10803fcc 	andi	r2,r2,255
8110f1b0:	100d883a 	mov	r6,r2
8110f1b4:	000b883a 	mov	r5,zero
8110f1b8:	01002044 	movi	r4,129
8110f1bc:	11108a00 	call	811108a0 <bSendGiveBackNFeeCtrl>
				break;
8110f1c0:	00000a06 	br	8110f1ec <vQCmdFEEinWaitingSync+0x1d0>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f1c4:	d0e06217 	ldw	r3,-32376(gp)
8110f1c8:	e0bffe17 	ldw	r2,-8(fp)
8110f1cc:	10800003 	ldbu	r2,0(r2)
8110f1d0:	10803fcc 	andi	r2,r2,255
8110f1d4:	100d883a 	mov	r6,r2
8110f1d8:	01604574 	movhi	r5,33045
8110f1dc:	2971ee04 	addi	r5,r5,-14408
8110f1e0:	1809883a 	mov	r4,r3
8110f1e4:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f1e8:	0001883a 	nop
		}
	}
}
8110f1ec:	0001883a 	nop
8110f1f0:	e037883a 	mov	sp,fp
8110f1f4:	dfc00117 	ldw	ra,4(sp)
8110f1f8:	df000017 	ldw	fp,0(sp)
8110f1fc:	dec00204 	addi	sp,sp,8
8110f200:	f800283a 	ret

8110f204 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110f204:	defffb04 	addi	sp,sp,-20
8110f208:	de00012e 	bgeu	sp,et,8110f210 <vQCmdFEEinConfig+0xc>
8110f20c:	003b68fa 	trap	3
8110f210:	dfc00415 	stw	ra,16(sp)
8110f214:	df000315 	stw	fp,12(sp)
8110f218:	df000304 	addi	fp,sp,12
8110f21c:	e13ffe15 	stw	r4,-8(fp)
8110f220:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f224:	e0bfff17 	ldw	r2,-4(fp)
8110f228:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f22c:	e0bffdc3 	ldbu	r2,-9(fp)
8110f230:	10c03fcc 	andi	r3,r2,255
8110f234:	e0bffe17 	ldw	r2,-8(fp)
8110f238:	10800003 	ldbu	r2,0(r2)
8110f23c:	10803fcc 	andi	r2,r2,255
8110f240:	10800444 	addi	r2,r2,17
8110f244:	18805a1e 	bne	r3,r2,8110f3b0 <vQCmdFEEinConfig+0x1ac>

		switch (uiCmdFEEL.ucByte[2]) {
8110f248:	e0bffd83 	ldbu	r2,-10(fp)
8110f24c:	10803fcc 	andi	r2,r2,255
8110f250:	10c02860 	cmpeqi	r3,r2,161
8110f254:	18001a1e 	bne	r3,zero,8110f2c0 <vQCmdFEEinConfig+0xbc>
8110f258:	10c02888 	cmpgei	r3,r2,162
8110f25c:	18000c1e 	bne	r3,zero,8110f290 <vQCmdFEEinConfig+0x8c>
8110f260:	10c00120 	cmpeqi	r3,r2,4
8110f264:	1800201e 	bne	r3,zero,8110f2e8 <vQCmdFEEinConfig+0xe4>
8110f268:	10c00148 	cmpgei	r3,r2,5
8110f26c:	1800031e 	bne	r3,zero,8110f27c <vQCmdFEEinConfig+0x78>
8110f270:	10800060 	cmpeqi	r2,r2,1
8110f274:	1000121e 	bne	r2,zero,8110f2c0 <vQCmdFEEinConfig+0xbc>
8110f278:	00004206 	br	8110f384 <vQCmdFEEinConfig+0x180>
8110f27c:	10c00220 	cmpeqi	r3,r2,8
8110f280:	1800221e 	bne	r3,zero,8110f30c <vQCmdFEEinConfig+0x108>
8110f284:	108023e0 	cmpeqi	r2,r2,143
8110f288:	1000341e 	bne	r2,zero,8110f35c <vQCmdFEEinConfig+0x158>
8110f28c:	00003d06 	br	8110f384 <vQCmdFEEinConfig+0x180>
8110f290:	10c03888 	cmpgei	r3,r2,226
8110f294:	1800071e 	bne	r3,zero,8110f2b4 <vQCmdFEEinConfig+0xb0>
8110f298:	10c03808 	cmpgei	r3,r2,224
8110f29c:	1800431e 	bne	r3,zero,8110f3ac <vQCmdFEEinConfig+0x1a8>
8110f2a0:	10c02920 	cmpeqi	r3,r2,164
8110f2a4:	1800101e 	bne	r3,zero,8110f2e8 <vQCmdFEEinConfig+0xe4>
8110f2a8:	10802a20 	cmpeqi	r2,r2,168
8110f2ac:	1000171e 	bne	r2,zero,8110f30c <vQCmdFEEinConfig+0x108>
8110f2b0:	00003406 	br	8110f384 <vQCmdFEEinConfig+0x180>
8110f2b4:	10803c20 	cmpeqi	r2,r2,240
8110f2b8:	10001e1e 	bne	r2,zero,8110f334 <vQCmdFEEinConfig+0x130>
8110f2bc:	00003106 	br	8110f384 <vQCmdFEEinConfig+0x180>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110f2c0:	d0e06217 	ldw	r3,-32376(gp)
8110f2c4:	e0bffe17 	ldw	r2,-8(fp)
8110f2c8:	10800003 	ldbu	r2,0(r2)
8110f2cc:	10803fcc 	andi	r2,r2,255
8110f2d0:	100d883a 	mov	r6,r2
8110f2d4:	01604574 	movhi	r5,33045
8110f2d8:	2971ff04 	addi	r5,r5,-14340
8110f2dc:	1809883a 	mov	r4,r3
8110f2e0:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f2e4:	00003206 	br	8110f3b0 <vQCmdFEEinConfig+0x1ac>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f2e8:	e0bffe17 	ldw	r2,-8(fp)
8110f2ec:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f2f0:	e0bffe17 	ldw	r2,-8(fp)
8110f2f4:	00c00184 	movi	r3,6
8110f2f8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f2fc:	e0bffe17 	ldw	r2,-8(fp)
8110f300:	00c00184 	movi	r3,6
8110f304:	10c02d15 	stw	r3,180(r2)
				break;				
8110f308:	00002906 	br	8110f3b0 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110f30c:	d0e06217 	ldw	r3,-32376(gp)
8110f310:	e0bffe17 	ldw	r2,-8(fp)
8110f314:	10800003 	ldbu	r2,0(r2)
8110f318:	10803fcc 	andi	r2,r2,255
8110f31c:	100d883a 	mov	r6,r2
8110f320:	01604574 	movhi	r5,33045
8110f324:	29720a04 	addi	r5,r5,-14296
8110f328:	1809883a 	mov	r4,r3
8110f32c:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f330:	00001f06 	br	8110f3b0 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
8110f334:	d0e06217 	ldw	r3,-32376(gp)
8110f338:	e0bffe17 	ldw	r2,-8(fp)
8110f33c:	10800003 	ldbu	r2,0(r2)
8110f340:	10803fcc 	andi	r2,r2,255
8110f344:	100d883a 	mov	r6,r2
8110f348:	01604574 	movhi	r5,33045
8110f34c:	29721b04 	addi	r5,r5,-14228
8110f350:	1809883a 	mov	r4,r3
8110f354:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f358:	00001506 	br	8110f3b0 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f35c:	e0bffe17 	ldw	r2,-8(fp)
8110f360:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f364:	e0bffe17 	ldw	r2,-8(fp)
8110f368:	10800003 	ldbu	r2,0(r2)
8110f36c:	10803fcc 	andi	r2,r2,255
8110f370:	100d883a 	mov	r6,r2
8110f374:	000b883a 	mov	r5,zero
8110f378:	01002044 	movi	r4,129
8110f37c:	11108a00 	call	811108a0 <bSendGiveBackNFeeCtrl>
				break;
8110f380:	00000b06 	br	8110f3b0 <vQCmdFEEinConfig+0x1ac>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110f384:	d0e06217 	ldw	r3,-32376(gp)
8110f388:	e0bffe17 	ldw	r2,-8(fp)
8110f38c:	10800003 	ldbu	r2,0(r2)
8110f390:	10803fcc 	andi	r2,r2,255
8110f394:	100d883a 	mov	r6,r2
8110f398:	01604574 	movhi	r5,33045
8110f39c:	29722e04 	addi	r5,r5,-14152
8110f3a0:	1809883a 	mov	r4,r3
8110f3a4:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f3a8:	00000106 	br	8110f3b0 <vQCmdFEEinConfig+0x1ac>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110f3ac:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f3b0:	0001883a 	nop
8110f3b4:	e037883a 	mov	sp,fp
8110f3b8:	dfc00117 	ldw	ra,4(sp)
8110f3bc:	df000017 	ldw	fp,0(sp)
8110f3c0:	dec00204 	addi	sp,sp,8
8110f3c4:	f800283a 	ret

8110f3c8 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110f3c8:	defffb04 	addi	sp,sp,-20
8110f3cc:	de00012e 	bgeu	sp,et,8110f3d4 <vQCmdFEEinStandBy+0xc>
8110f3d0:	003b68fa 	trap	3
8110f3d4:	dfc00415 	stw	ra,16(sp)
8110f3d8:	df000315 	stw	fp,12(sp)
8110f3dc:	df000304 	addi	fp,sp,12
8110f3e0:	e13ffe15 	stw	r4,-8(fp)
8110f3e4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f3e8:	e0bfff17 	ldw	r2,-4(fp)
8110f3ec:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f3f0:	e0bffdc3 	ldbu	r2,-9(fp)
8110f3f4:	10c03fcc 	andi	r3,r2,255
8110f3f8:	e0bffe17 	ldw	r2,-8(fp)
8110f3fc:	10800003 	ldbu	r2,0(r2)
8110f400:	10803fcc 	andi	r2,r2,255
8110f404:	10800444 	addi	r2,r2,17
8110f408:	1880681e 	bne	r3,r2,8110f5ac <vQCmdFEEinStandBy+0x1e4>

		switch (uiCmdFEEL.ucByte[2]) {
8110f40c:	e0bffd83 	ldbu	r2,-10(fp)
8110f410:	10803fcc 	andi	r2,r2,255
8110f414:	10c02860 	cmpeqi	r3,r2,161
8110f418:	18001a1e 	bne	r3,zero,8110f484 <vQCmdFEEinStandBy+0xbc>
8110f41c:	10c02888 	cmpgei	r3,r2,162
8110f420:	18000c1e 	bne	r3,zero,8110f454 <vQCmdFEEinStandBy+0x8c>
8110f424:	10c00120 	cmpeqi	r3,r2,4
8110f428:	18001f1e 	bne	r3,zero,8110f4a8 <vQCmdFEEinStandBy+0xe0>
8110f42c:	10c00148 	cmpgei	r3,r2,5
8110f430:	1800031e 	bne	r3,zero,8110f440 <vQCmdFEEinStandBy+0x78>
8110f434:	10800060 	cmpeqi	r2,r2,1
8110f438:	1000121e 	bne	r2,zero,8110f484 <vQCmdFEEinStandBy+0xbc>
8110f43c:	00005006 	br	8110f580 <vQCmdFEEinStandBy+0x1b8>
8110f440:	10c00220 	cmpeqi	r3,r2,8
8110f444:	1800221e 	bne	r3,zero,8110f4d0 <vQCmdFEEinStandBy+0x108>
8110f448:	108023e0 	cmpeqi	r2,r2,143
8110f44c:	1000421e 	bne	r2,zero,8110f558 <vQCmdFEEinStandBy+0x190>
8110f450:	00004b06 	br	8110f580 <vQCmdFEEinStandBy+0x1b8>
8110f454:	10c03888 	cmpgei	r3,r2,226
8110f458:	1800071e 	bne	r3,zero,8110f478 <vQCmdFEEinStandBy+0xb0>
8110f45c:	10c03808 	cmpgei	r3,r2,224
8110f460:	1800321e 	bne	r3,zero,8110f52c <vQCmdFEEinStandBy+0x164>
8110f464:	10c02920 	cmpeqi	r3,r2,164
8110f468:	18000f1e 	bne	r3,zero,8110f4a8 <vQCmdFEEinStandBy+0xe0>
8110f46c:	10802a20 	cmpeqi	r2,r2,168
8110f470:	1000171e 	bne	r2,zero,8110f4d0 <vQCmdFEEinStandBy+0x108>
8110f474:	00004206 	br	8110f580 <vQCmdFEEinStandBy+0x1b8>
8110f478:	10803c20 	cmpeqi	r2,r2,240
8110f47c:	10001e1e 	bne	r2,zero,8110f4f8 <vQCmdFEEinStandBy+0x130>
8110f480:	00003f06 	br	8110f580 <vQCmdFEEinStandBy+0x1b8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f484:	e0bffe17 	ldw	r2,-8(fp)
8110f488:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f48c:	e0bffe17 	ldw	r2,-8(fp)
8110f490:	00c00144 	movi	r3,5
8110f494:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f498:	e0bffe17 	ldw	r2,-8(fp)
8110f49c:	00c00144 	movi	r3,5
8110f4a0:	10c02d15 	stw	r3,180(r2)
				break;				
8110f4a4:	00004106 	br	8110f5ac <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110f4a8:	d0e06217 	ldw	r3,-32376(gp)
8110f4ac:	e0bffe17 	ldw	r2,-8(fp)
8110f4b0:	10800003 	ldbu	r2,0(r2)
8110f4b4:	10803fcc 	andi	r2,r2,255
8110f4b8:	100d883a 	mov	r6,r2
8110f4bc:	01604574 	movhi	r5,33045
8110f4c0:	29723f04 	addi	r5,r5,-14084
8110f4c4:	1809883a 	mov	r4,r3
8110f4c8:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f4cc:	00003706 	br	8110f5ac <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f4d0:	e0bffe17 	ldw	r2,-8(fp)
8110f4d4:	00c00044 	movi	r3,1
8110f4d8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f4dc:	e0bffe17 	ldw	r2,-8(fp)
8110f4e0:	00c00284 	movi	r3,10
8110f4e4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f4e8:	e0bffe17 	ldw	r2,-8(fp)
8110f4ec:	00c00304 	movi	r3,12
8110f4f0:	10c02d15 	stw	r3,180(r2)
				break;
8110f4f4:	00002d06 	br	8110f5ac <vQCmdFEEinStandBy+0x1e4>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110f4f8:	e17fff17 	ldw	r5,-4(fp)
8110f4fc:	e13ffe17 	ldw	r4,-8(fp)
8110f500:	110f7f40 	call	8110f7f4 <vQCmdFeeRMAPinStandBy>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f504:	d0e06217 	ldw	r3,-32376(gp)
8110f508:	e0bffe17 	ldw	r2,-8(fp)
8110f50c:	10800003 	ldbu	r2,0(r2)
8110f510:	10803fcc 	andi	r2,r2,255
8110f514:	100d883a 	mov	r6,r2
8110f518:	01604574 	movhi	r5,33045
8110f51c:	2971e404 	addi	r5,r5,-14448
8110f520:	1809883a 	mov	r4,r3
8110f524:	11213440 	call	81121344 <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110f528:	00002006 	br	8110f5ac <vQCmdFEEinStandBy+0x1e4>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f52c:	e0bffe17 	ldw	r2,-8(fp)
8110f530:	10802c17 	ldw	r2,176(r2)
8110f534:	10800318 	cmpnei	r2,r2,12
8110f538:	10001b1e 	bne	r2,zero,8110f5a8 <vQCmdFEEinStandBy+0x1e0>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f53c:	e0bffe17 	ldw	r2,-8(fp)
8110f540:	10c02d17 	ldw	r3,180(r2)
8110f544:	e0bffe17 	ldw	r2,-8(fp)
8110f548:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f54c:	e0bffe17 	ldw	r2,-8(fp)
8110f550:	10002815 	stw	zero,160(r2)
				}
				break;
8110f554:	00001406 	br	8110f5a8 <vQCmdFEEinStandBy+0x1e0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f558:	e0bffe17 	ldw	r2,-8(fp)
8110f55c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f560:	e0bffe17 	ldw	r2,-8(fp)
8110f564:	10800003 	ldbu	r2,0(r2)
8110f568:	10803fcc 	andi	r2,r2,255
8110f56c:	100d883a 	mov	r6,r2
8110f570:	000b883a 	mov	r5,zero
8110f574:	01002044 	movi	r4,129
8110f578:	11108a00 	call	811108a0 <bSendGiveBackNFeeCtrl>
				break;
8110f57c:	00000b06 	br	8110f5ac <vQCmdFEEinStandBy+0x1e4>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f580:	d0e06217 	ldw	r3,-32376(gp)
8110f584:	e0bffe17 	ldw	r2,-8(fp)
8110f588:	10800003 	ldbu	r2,0(r2)
8110f58c:	10803fcc 	andi	r2,r2,255
8110f590:	100d883a 	mov	r6,r2
8110f594:	01604574 	movhi	r5,33045
8110f598:	2971ee04 	addi	r5,r5,-14408
8110f59c:	1809883a 	mov	r4,r3
8110f5a0:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f5a4:	00000106 	br	8110f5ac <vQCmdFEEinStandBy+0x1e4>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8110f5a8:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f5ac:	0001883a 	nop
8110f5b0:	e037883a 	mov	sp,fp
8110f5b4:	dfc00117 	ldw	ra,4(sp)
8110f5b8:	df000017 	ldw	fp,0(sp)
8110f5bc:	dec00204 	addi	sp,sp,8
8110f5c0:	f800283a 	ret

8110f5c4 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110f5c4:	defffb04 	addi	sp,sp,-20
8110f5c8:	de00012e 	bgeu	sp,et,8110f5d0 <vQCmdFEEinFullPattern+0xc>
8110f5cc:	003b68fa 	trap	3
8110f5d0:	dfc00415 	stw	ra,16(sp)
8110f5d4:	df000315 	stw	fp,12(sp)
8110f5d8:	df000304 	addi	fp,sp,12
8110f5dc:	e13ffe15 	stw	r4,-8(fp)
8110f5e0:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f5e4:	e0bfff17 	ldw	r2,-4(fp)
8110f5e8:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f5ec:	e0bffdc3 	ldbu	r2,-9(fp)
8110f5f0:	10c03fcc 	andi	r3,r2,255
8110f5f4:	e0bffe17 	ldw	r2,-8(fp)
8110f5f8:	10800003 	ldbu	r2,0(r2)
8110f5fc:	10803fcc 	andi	r2,r2,255
8110f600:	10800444 	addi	r2,r2,17
8110f604:	1880751e 	bne	r3,r2,8110f7dc <vQCmdFEEinFullPattern+0x218>

		switch (uiCmdFEEL.ucByte[2]) {
8110f608:	e0bffd83 	ldbu	r2,-10(fp)
8110f60c:	10803fcc 	andi	r2,r2,255
8110f610:	10c02860 	cmpeqi	r3,r2,161
8110f614:	1800181e 	bne	r3,zero,8110f678 <vQCmdFEEinFullPattern+0xb4>
8110f618:	10c02888 	cmpgei	r3,r2,162
8110f61c:	18000c1e 	bne	r3,zero,8110f650 <vQCmdFEEinFullPattern+0x8c>
8110f620:	10c000a0 	cmpeqi	r3,r2,2
8110f624:	18006a1e 	bne	r3,zero,8110f7d0 <vQCmdFEEinFullPattern+0x20c>
8110f628:	10c000c8 	cmpgei	r3,r2,3
8110f62c:	1800031e 	bne	r3,zero,8110f63c <vQCmdFEEinFullPattern+0x78>
8110f630:	10800060 	cmpeqi	r2,r2,1
8110f634:	1000101e 	bne	r2,zero,8110f678 <vQCmdFEEinFullPattern+0xb4>
8110f638:	00005b06 	br	8110f7a8 <vQCmdFEEinFullPattern+0x1e4>
8110f63c:	10c00120 	cmpeqi	r3,r2,4
8110f640:	1800161e 	bne	r3,zero,8110f69c <vQCmdFEEinFullPattern+0xd8>
8110f644:	10800220 	cmpeqi	r2,r2,8
8110f648:	1000351e 	bne	r2,zero,8110f720 <vQCmdFEEinFullPattern+0x15c>
8110f64c:	00005606 	br	8110f7a8 <vQCmdFEEinFullPattern+0x1e4>
8110f650:	10c03888 	cmpgei	r3,r2,226
8110f654:	1800051e 	bne	r3,zero,8110f66c <vQCmdFEEinFullPattern+0xa8>
8110f658:	10c03808 	cmpgei	r3,r2,224
8110f65c:	1800471e 	bne	r3,zero,8110f77c <vQCmdFEEinFullPattern+0x1b8>
8110f660:	10802920 	cmpeqi	r2,r2,164
8110f664:	1000251e 	bne	r2,zero,8110f6fc <vQCmdFEEinFullPattern+0x138>
8110f668:	00004f06 	br	8110f7a8 <vQCmdFEEinFullPattern+0x1e4>
8110f66c:	10803c20 	cmpeqi	r2,r2,240
8110f670:	1000351e 	bne	r2,zero,8110f748 <vQCmdFEEinFullPattern+0x184>
8110f674:	00004c06 	br	8110f7a8 <vQCmdFEEinFullPattern+0x1e4>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f678:	e0bffe17 	ldw	r2,-8(fp)
8110f67c:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f680:	e0bffe17 	ldw	r2,-8(fp)
8110f684:	00c00144 	movi	r3,5
8110f688:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f68c:	e0bffe17 	ldw	r2,-8(fp)
8110f690:	00c00144 	movi	r3,5
8110f694:	10c02d15 	stw	r3,180(r2)
				break;				
8110f698:	00005006 	br	8110f7dc <vQCmdFEEinFullPattern+0x218>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110f69c:	e0bffe17 	ldw	r2,-8(fp)
8110f6a0:	10802c17 	ldw	r2,176(r2)
8110f6a4:	10800298 	cmpnei	r2,r2,10
8110f6a8:	10000a1e 	bne	r2,zero,8110f6d4 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110f6ac:	e0bffe17 	ldw	r2,-8(fp)
8110f6b0:	00c00044 	movi	r3,1
8110f6b4:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110f6b8:	e0bffe17 	ldw	r2,-8(fp)
8110f6bc:	00c00304 	movi	r3,12
8110f6c0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f6c4:	e0bffe17 	ldw	r2,-8(fp)
8110f6c8:	00c00184 	movi	r3,6
8110f6cc:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110f6d0:	00004206 	br	8110f7dc <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110f6d4:	e0bffe17 	ldw	r2,-8(fp)
8110f6d8:	00c00044 	movi	r3,1
8110f6dc:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110f6e0:	e0bffe17 	ldw	r2,-8(fp)
8110f6e4:	00c00104 	movi	r3,4
8110f6e8:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f6ec:	e0bffe17 	ldw	r2,-8(fp)
8110f6f0:	00c00184 	movi	r3,6
8110f6f4:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110f6f8:	00003806 	br	8110f7dc <vQCmdFEEinFullPattern+0x218>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f6fc:	e0bffe17 	ldw	r2,-8(fp)
8110f700:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f704:	e0bffe17 	ldw	r2,-8(fp)
8110f708:	00c00184 	movi	r3,6
8110f70c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110f710:	e0bffe17 	ldw	r2,-8(fp)
8110f714:	00c00184 	movi	r3,6
8110f718:	10c02d15 	stw	r3,180(r2)
				break;				
8110f71c:	00002f06 	br	8110f7dc <vQCmdFEEinFullPattern+0x218>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110f720:	d0e06217 	ldw	r3,-32376(gp)
8110f724:	e0bffe17 	ldw	r2,-8(fp)
8110f728:	10800003 	ldbu	r2,0(r2)
8110f72c:	10803fcc 	andi	r2,r2,255
8110f730:	100d883a 	mov	r6,r2
8110f734:	01604574 	movhi	r5,33045
8110f738:	29724a04 	addi	r5,r5,-14040
8110f73c:	1809883a 	mov	r4,r3
8110f740:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f744:	00002506 	br	8110f7dc <vQCmdFEEinFullPattern+0x218>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f748:	d0e06217 	ldw	r3,-32376(gp)
8110f74c:	e0bffe17 	ldw	r2,-8(fp)
8110f750:	10800003 	ldbu	r2,0(r2)
8110f754:	10803fcc 	andi	r2,r2,255
8110f758:	100d883a 	mov	r6,r2
8110f75c:	01604574 	movhi	r5,33045
8110f760:	2971e404 	addi	r5,r5,-14448
8110f764:	1809883a 	mov	r4,r3
8110f768:	11213440 	call	81121344 <fprintf>
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110f76c:	e17fff17 	ldw	r5,-4(fp)
8110f770:	e13ffe17 	ldw	r4,-8(fp)
8110f774:	110fd0c0 	call	8110fd0c <vQCmdFeeRMAPinFullPattern>

				break;
8110f778:	00001806 	br	8110f7dc <vQCmdFEEinFullPattern+0x218>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f77c:	e0bffe17 	ldw	r2,-8(fp)
8110f780:	10802c17 	ldw	r2,176(r2)
8110f784:	10800318 	cmpnei	r2,r2,12
8110f788:	1000131e 	bne	r2,zero,8110f7d8 <vQCmdFEEinFullPattern+0x214>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f78c:	e0bffe17 	ldw	r2,-8(fp)
8110f790:	10c02d17 	ldw	r3,180(r2)
8110f794:	e0bffe17 	ldw	r2,-8(fp)
8110f798:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f79c:	e0bffe17 	ldw	r2,-8(fp)
8110f7a0:	10002815 	stw	zero,160(r2)
				}

				break;
8110f7a4:	00000c06 	br	8110f7d8 <vQCmdFEEinFullPattern+0x214>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110f7a8:	d0e06217 	ldw	r3,-32376(gp)
8110f7ac:	e0bffe17 	ldw	r2,-8(fp)
8110f7b0:	10800003 	ldbu	r2,0(r2)
8110f7b4:	10803fcc 	andi	r2,r2,255
8110f7b8:	100d883a 	mov	r6,r2
8110f7bc:	01604574 	movhi	r5,33045
8110f7c0:	29722e04 	addi	r5,r5,-14152
8110f7c4:	1809883a 	mov	r4,r3
8110f7c8:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8110f7cc:	00000306 	br	8110f7dc <vQCmdFEEinFullPattern+0x218>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110f7d0:	0001883a 	nop
8110f7d4:	00000106 	br	8110f7dc <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8110f7d8:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f7dc:	0001883a 	nop
8110f7e0:	e037883a 	mov	sp,fp
8110f7e4:	dfc00117 	ldw	ra,4(sp)
8110f7e8:	df000017 	ldw	fp,0(sp)
8110f7ec:	dec00204 	addi	sp,sp,8
8110f7f0:	f800283a 	ret

8110f7f4 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110f7f4:	defff704 	addi	sp,sp,-36
8110f7f8:	de00012e 	bgeu	sp,et,8110f800 <vQCmdFeeRMAPinStandBy+0xc>
8110f7fc:	003b68fa 	trap	3
8110f800:	dfc00815 	stw	ra,32(sp)
8110f804:	df000715 	stw	fp,28(sp)
8110f808:	df000704 	addi	fp,sp,28
8110f80c:	e13ffe15 	stw	r4,-8(fp)
8110f810:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#ifdef DEBUG_ON
	fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
8110f814:	d0e06217 	ldw	r3,-32376(gp)
8110f818:	e0bffe17 	ldw	r2,-8(fp)
8110f81c:	10800003 	ldbu	r2,0(r2)
8110f820:	10803fcc 	andi	r2,r2,255
8110f824:	100d883a 	mov	r6,r2
8110f828:	01604574 	movhi	r5,33045
8110f82c:	29725804 	addi	r5,r5,-13984
8110f830:	1809883a 	mov	r4,r3
8110f834:	11213440 	call	81121344 <fprintf>
#endif


	uiCmdFEEL.ulWord = cmd;
8110f838:	e0bfff17 	ldw	r2,-4(fp)
8110f83c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110f840:	e0bffd43 	ldbu	r2,-11(fp)
8110f844:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110f848:	e0bffe17 	ldw	r2,-8(fp)
8110f84c:	10804317 	ldw	r2,268(r2)
8110f850:	e0fff903 	ldbu	r3,-28(fp)
8110f854:	180b883a 	mov	r5,r3
8110f858:	1009883a 	mov	r4,r2
8110f85c:	1109f100 	call	81109f10 <uliRmapReadReg>
8110f860:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8110f864:	e0bff903 	ldbu	r2,-28(fp)
8110f868:	10bff004 	addi	r2,r2,-64
8110f86c:	10c003a8 	cmpgeui	r3,r2,14
8110f870:	1801151e 	bne	r3,zero,8110fcc8 <vQCmdFeeRMAPinStandBy+0x4d4>
8110f874:	100690ba 	slli	r3,r2,2
8110f878:	00a04474 	movhi	r2,33041
8110f87c:	10be2304 	addi	r2,r2,-1908
8110f880:	1885883a 	add	r2,r3,r2
8110f884:	10800017 	ldw	r2,0(r2)
8110f888:	1000683a 	jmp	r2
8110f88c:	8110f8c4 	addi	r4,r16,17379
8110f890:	8110fce8 	cmpgeui	r4,r16,17395
8110f894:	8110f9cc 	andi	r4,r16,17383
8110f898:	8110fb64 	muli	r4,r16,17389
8110f89c:	8110fb64 	muli	r4,r16,17389
8110f8a0:	8110fb64 	muli	r4,r16,17389
8110f8a4:	8110fb64 	muli	r4,r16,17389
8110f8a8:	8110fb64 	muli	r4,r16,17389
8110f8ac:	8110fb64 	muli	r4,r16,17389
8110f8b0:	8110fb64 	muli	r4,r16,17389
8110f8b4:	8110fb64 	muli	r4,r16,17389
8110f8b8:	8110fb64 	muli	r4,r16,17389
8110f8bc:	8110fb84 	addi	r4,r16,17390
8110f8c0:	8110fc58 	cmpnei	r4,r16,17393
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110f8c4:	e0fffa17 	ldw	r3,-24(fp)
8110f8c8:	00800434 	movhi	r2,16
8110f8cc:	10bffc04 	addi	r2,r2,-16
8110f8d0:	1884703a 	and	r2,r3,r2
8110f8d4:	1004d13a 	srli	r2,r2,4
8110f8d8:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110f8dc:	e0bffa17 	ldw	r2,-24(fp)
8110f8e0:	1004d53a 	srli	r2,r2,20
8110f8e4:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110f8e8:	e0bffb17 	ldw	r2,-20(fp)
8110f8ec:	1007883a 	mov	r3,r2
8110f8f0:	e0bffe17 	ldw	r2,-8(fp)
8110f8f4:	1080300b 	ldhu	r2,192(r2)
8110f8f8:	1885c83a 	sub	r2,r3,r2
8110f8fc:	1007883a 	mov	r3,r2
8110f900:	e0bffe17 	ldw	r2,-8(fp)
8110f904:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
8110f908:	e0bffc17 	ldw	r2,-16(fp)
8110f90c:	1009883a 	mov	r4,r2
8110f910:	e0bffe17 	ldw	r2,-8(fp)
8110f914:	10c02f8b 	ldhu	r3,190(r2)
8110f918:	e0bffe17 	ldw	r2,-8(fp)
8110f91c:	10802f0b 	ldhu	r2,188(r2)
8110f920:	1885883a 	add	r2,r3,r2
8110f924:	2085c83a 	sub	r2,r4,r2
8110f928:	1007883a 	mov	r3,r2
8110f92c:	e0bffe17 	ldw	r2,-8(fp)
8110f930:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110f934:	e13ffe17 	ldw	r4,-8(fp)
8110f938:	111d8240 	call	8111d824 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f93c:	e0bffe17 	ldw	r2,-8(fp)
8110f940:	10803304 	addi	r2,r2,204
8110f944:	1009883a 	mov	r4,r2
8110f948:	1104a5c0 	call	81104a5c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
8110f94c:	e0bffe17 	ldw	r2,-8(fp)
8110f950:	10c0300b 	ldhu	r3,192(r2)
8110f954:	e0bffe17 	ldw	r2,-8(fp)
8110f958:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
8110f95c:	e0bffc17 	ldw	r2,-16(fp)
8110f960:	1007883a 	mov	r3,r2
8110f964:	e0bffe17 	ldw	r2,-8(fp)
8110f968:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
8110f96c:	e0bffb17 	ldw	r2,-20(fp)
8110f970:	1007883a 	mov	r3,r2
8110f974:	e0bffe17 	ldw	r2,-8(fp)
8110f978:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110f97c:	e0bffb17 	ldw	r2,-20(fp)
8110f980:	1007883a 	mov	r3,r2
8110f984:	e0bffe17 	ldw	r2,-8(fp)
8110f988:	1080300b 	ldhu	r2,192(r2)
8110f98c:	1885c83a 	sub	r2,r3,r2
8110f990:	1007883a 	mov	r3,r2
8110f994:	e0bffe17 	ldw	r2,-8(fp)
8110f998:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f99c:	e0bffe17 	ldw	r2,-8(fp)
8110f9a0:	10803304 	addi	r2,r2,204
8110f9a4:	1009883a 	mov	r4,r2
8110f9a8:	11048300 	call	81104830 <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
8110f9ac:	d0a06217 	ldw	r2,-32376(gp)
8110f9b0:	e1fffc17 	ldw	r7,-16(fp)
8110f9b4:	e1bffb17 	ldw	r6,-20(fp)
8110f9b8:	01604574 	movhi	r5,33045
8110f9bc:	29726404 	addi	r5,r5,-13936
8110f9c0:	1009883a 	mov	r4,r2
8110f9c4:	11213440 	call	81121344 <fprintf>
			#endif

			break;
8110f9c8:	0000ca06 	br	8110fcf4 <vQCmdFeeRMAPinStandBy+0x500>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110f9cc:	e0fffa17 	ldw	r3,-24(fp)
8110f9d0:	00800434 	movhi	r2,16
8110f9d4:	10bffc04 	addi	r2,r2,-16
8110f9d8:	1884703a 	and	r2,r3,r2
8110f9dc:	1004d13a 	srli	r2,r2,4
8110f9e0:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f9e4:	e0bffe17 	ldw	r2,-8(fp)
8110f9e8:	10803304 	addi	r2,r2,204
8110f9ec:	1009883a 	mov	r4,r2
8110f9f0:	1104a5c0 	call	81104a5c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110f9f4:	e0bffb17 	ldw	r2,-20(fp)
8110f9f8:	1007883a 	mov	r3,r2
8110f9fc:	e0bffe17 	ldw	r2,-8(fp)
8110fa00:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110fa04:	e0bffe17 	ldw	r2,-8(fp)
8110fa08:	10803304 	addi	r2,r2,204
8110fa0c:	1009883a 	mov	r4,r2
8110fa10:	11048300 	call	81104830 <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Pckt Length: %u\n", ucValueMasked);
8110fa14:	d0a06217 	ldw	r2,-32376(gp)
8110fa18:	e1bffb17 	ldw	r6,-20(fp)
8110fa1c:	01604574 	movhi	r5,33045
8110fa20:	29726b04 	addi	r5,r5,-13908
8110fa24:	1009883a 	mov	r4,r2
8110fa28:	11213440 	call	81121344 <fprintf>
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110fa2c:	e0bffa17 	ldw	r2,-24(fp)
8110fa30:	1080030c 	andi	r2,r2,12
8110fa34:	1004d0ba 	srli	r2,r2,2
8110fa38:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110fa3c:	e0bffc17 	ldw	r2,-16(fp)
8110fa40:	10c000a0 	cmpeqi	r3,r2,2
8110fa44:	18000e1e 	bne	r3,zero,8110fa80 <vQCmdFeeRMAPinStandBy+0x28c>
8110fa48:	10c000e0 	cmpeqi	r3,r2,3
8110fa4c:	1800171e 	bne	r3,zero,8110faac <vQCmdFeeRMAPinStandBy+0x2b8>
8110fa50:	10800060 	cmpeqi	r2,r2,1
8110fa54:	10001e26 	beq	r2,zero,8110fad0 <vQCmdFeeRMAPinStandBy+0x2dc>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110fa58:	e0bffe17 	ldw	r2,-8(fp)
8110fa5c:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Left side\n");
8110fa60:	d0a06217 	ldw	r2,-32376(gp)
8110fa64:	100f883a 	mov	r7,r2
8110fa68:	01800344 	movi	r6,13
8110fa6c:	01400044 	movi	r5,1
8110fa70:	01204574 	movhi	r4,33045
8110fa74:	21327004 	addi	r4,r4,-13888
8110fa78:	11219e00 	call	811219e0 <fwrite>
					#endif
					break;
8110fa7c:	00002c06 	br	8110fb30 <vQCmdFeeRMAPinStandBy+0x33c>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110fa80:	e0bffe17 	ldw	r2,-8(fp)
8110fa84:	00c00044 	movi	r3,1
8110fa88:	10c02e15 	stw	r3,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Right side\n");
8110fa8c:	d0a06217 	ldw	r2,-32376(gp)
8110fa90:	100f883a 	mov	r7,r2
8110fa94:	01800384 	movi	r6,14
8110fa98:	01400044 	movi	r5,1
8110fa9c:	01204574 	movhi	r4,33045
8110faa0:	21327404 	addi	r4,r4,-13872
8110faa4:	11219e00 	call	811219e0 <fwrite>
					#endif
					break;
8110faa8:	00002106 	br	8110fb30 <vQCmdFeeRMAPinStandBy+0x33c>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110faac:	e0bffe17 	ldw	r2,-8(fp)
8110fab0:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110fab4:	d0a06217 	ldw	r2,-32376(gp)
8110fab8:	100f883a 	mov	r7,r2
8110fabc:	01800f44 	movi	r6,61
8110fac0:	01400044 	movi	r5,1
8110fac4:	01204574 	movhi	r4,33045
8110fac8:	21327804 	addi	r4,r4,-13856
8110facc:	11219e00 	call	811219e0 <fwrite>
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110fad0:	e0bffe17 	ldw	r2,-8(fp)
8110fad4:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fad8:	e0bffe17 	ldw	r2,-8(fp)
8110fadc:	10804304 	addi	r2,r2,268
8110fae0:	1009883a 	mov	r4,r2
8110fae4:	11081980 	call	81108198 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110fae8:	e0bffe17 	ldw	r2,-8(fp)
8110faec:	10c05717 	ldw	r3,348(r2)
8110faf0:	00bffdc4 	movi	r2,-9
8110faf4:	1886703a 	and	r3,r3,r2
8110faf8:	e0bffe17 	ldw	r2,-8(fp)
8110fafc:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fb00:	e0bffe17 	ldw	r2,-8(fp)
8110fb04:	10804304 	addi	r2,r2,268
8110fb08:	1009883a 	mov	r4,r2
8110fb0c:	1107eac0 	call	81107eac <bRmapSetMemConfigArea>
					#ifdef DEBUG_ON
						fprintf(fp," - Switching to Left side\n");
8110fb10:	d0a06217 	ldw	r2,-32376(gp)
8110fb14:	100f883a 	mov	r7,r2
8110fb18:	01800684 	movi	r6,26
8110fb1c:	01400044 	movi	r5,1
8110fb20:	01204574 	movhi	r4,33045
8110fb24:	21328804 	addi	r4,r4,-13792
8110fb28:	11219e00 	call	811219e0 <fwrite>
					#endif
					break;
8110fb2c:	0001883a 	nop
				}
			#ifdef DEBUG_ON
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8110fb30:	d0e06217 	ldw	r3,-32376(gp)
8110fb34:	e0bffe17 	ldw	r2,-8(fp)
8110fb38:	10800003 	ldbu	r2,0(r2)
8110fb3c:	11003fcc 	andi	r4,r2,255
8110fb40:	e0bffe17 	ldw	r2,-8(fp)
8110fb44:	10802e17 	ldw	r2,184(r2)
8110fb48:	100f883a 	mov	r7,r2
8110fb4c:	200d883a 	mov	r6,r4
8110fb50:	01604574 	movhi	r5,33045
8110fb54:	29728f04 	addi	r5,r5,-13764
8110fb58:	1809883a 	mov	r4,r3
8110fb5c:	11213440 	call	81121344 <fprintf>
			#endif
			break;
8110fb60:	00006406 	br	8110fcf4 <vQCmdFeeRMAPinStandBy+0x500>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
8110fb64:	d0a06217 	ldw	r2,-32376(gp)
8110fb68:	e0fff903 	ldbu	r3,-28(fp)
8110fb6c:	180d883a 	mov	r6,r3
8110fb70:	01604574 	movhi	r5,33045
8110fb74:	29729d04 	addi	r5,r5,-13708
8110fb78:	1009883a 	mov	r4,r2
8110fb7c:	11213440 	call	81121344 <fprintf>
			#endif
				break;
8110fb80:	00005c06 	br	8110fcf4 <vQCmdFeeRMAPinStandBy+0x500>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110fb84:	e0bffa17 	ldw	r2,-24(fp)
8110fb88:	10803c0c 	andi	r2,r2,240
8110fb8c:	1004d13a 	srli	r2,r2,4
8110fb90:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8110fb94:	e0bffb17 	ldw	r2,-20(fp)
8110fb98:	10c000a0 	cmpeqi	r3,r2,2
8110fb9c:	18000d1e 	bne	r3,zero,8110fbd4 <vQCmdFeeRMAPinStandBy+0x3e0>
8110fba0:	10c001a0 	cmpeqi	r3,r2,6
8110fba4:	18001c1e 	bne	r3,zero,8110fc18 <vQCmdFeeRMAPinStandBy+0x424>
8110fba8:	1000231e 	bne	r2,zero,8110fc38 <vQCmdFeeRMAPinStandBy+0x444>
				case 0: /* Standby */

				#ifdef DEBUG_ON
					fprintf(fp,"- already in Stand by mode\n", pxNFeeP->ucId);
8110fbac:	d0e06217 	ldw	r3,-32376(gp)
8110fbb0:	e0bffe17 	ldw	r2,-8(fp)
8110fbb4:	10800003 	ldbu	r2,0(r2)
8110fbb8:	10803fcc 	andi	r2,r2,255
8110fbbc:	100d883a 	mov	r6,r2
8110fbc0:	01604574 	movhi	r5,33045
8110fbc4:	2972a604 	addi	r5,r5,-13672
8110fbc8:	1809883a 	mov	r4,r3
8110fbcc:	11213440 	call	81121344 <fprintf>
				#endif

					break;
8110fbd0:	00002006 	br	8110fc54 <vQCmdFeeRMAPinStandBy+0x460>
				case 2: /* PAttern Full image */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
8110fbd4:	d0a06217 	ldw	r2,-32376(gp)
8110fbd8:	100f883a 	mov	r7,r2
8110fbdc:	01800604 	movi	r6,24
8110fbe0:	01400044 	movi	r5,1
8110fbe4:	01204574 	movhi	r4,33045
8110fbe8:	2132ad04 	addi	r4,r4,-13644
8110fbec:	11219e00 	call	811219e0 <fwrite>
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8110fbf0:	e0bffe17 	ldw	r2,-8(fp)
8110fbf4:	00c00044 	movi	r3,1
8110fbf8:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110fbfc:	e0bffe17 	ldw	r2,-8(fp)
8110fc00:	00c00284 	movi	r3,10
8110fc04:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110fc08:	e0bffe17 	ldw	r2,-8(fp)
8110fc0c:	00c00304 	movi	r3,12
8110fc10:	10c02d15 	stw	r3,180(r2)

					break;
8110fc14:	00000f06 	br	8110fc54 <vQCmdFeeRMAPinStandBy+0x460>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp,"- Off-Mode not allowed.\n");
8110fc18:	d0a06217 	ldw	r2,-32376(gp)
8110fc1c:	100f883a 	mov	r7,r2
8110fc20:	01800604 	movi	r6,24
8110fc24:	01400044 	movi	r5,1
8110fc28:	01204574 	movhi	r4,33045
8110fc2c:	2132b404 	addi	r4,r4,-13616
8110fc30:	11219e00 	call	811219e0 <fwrite>
				#endif
					break;
8110fc34:	00000706 	br	8110fc54 <vQCmdFeeRMAPinStandBy+0x460>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp,"- mode not allowed yet ( %hhu )\n", ucValueMasked);
8110fc38:	d0a06217 	ldw	r2,-32376(gp)
8110fc3c:	e1bffb17 	ldw	r6,-20(fp)
8110fc40:	01604574 	movhi	r5,33045
8110fc44:	2972bb04 	addi	r5,r5,-13588
8110fc48:	1009883a 	mov	r4,r2
8110fc4c:	11213440 	call	81121344 <fprintf>
					#endif
					break;
8110fc50:	0001883a 	nop
			}

			break;
8110fc54:	00002706 	br	8110fcf4 <vQCmdFeeRMAPinStandBy+0x500>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110fc58:	e0bffa17 	ldw	r2,-24(fp)
8110fc5c:	1080010c 	andi	r2,r2,4
8110fc60:	1004d0ba 	srli	r2,r2,2
8110fc64:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110fc68:	e0bffb17 	ldw	r2,-20(fp)
8110fc6c:	10002026 	beq	r2,zero,8110fcf0 <vQCmdFeeRMAPinStandBy+0x4fc>
				#ifdef DEBUG_ON
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
8110fc70:	d0a06217 	ldw	r2,-32376(gp)
8110fc74:	100f883a 	mov	r7,r2
8110fc78:	01800a04 	movi	r6,40
8110fc7c:	01400044 	movi	r5,1
8110fc80:	01204574 	movhi	r4,33045
8110fc84:	2132c404 	addi	r4,r4,-13552
8110fc88:	11219e00 	call	811219e0 <fwrite>
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fc8c:	e0bffe17 	ldw	r2,-8(fp)
8110fc90:	10804304 	addi	r2,r2,268
8110fc94:	1009883a 	mov	r4,r2
8110fc98:	11081980 	call	81108198 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110fc9c:	e0bffe17 	ldw	r2,-8(fp)
8110fca0:	10c06217 	ldw	r3,392(r2)
8110fca4:	00bffec4 	movi	r2,-5
8110fca8:	1886703a 	and	r3,r3,r2
8110fcac:	e0bffe17 	ldw	r2,-8(fp)
8110fcb0:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fcb4:	e0bffe17 	ldw	r2,-8(fp)
8110fcb8:	10804304 	addi	r2,r2,268
8110fcbc:	1009883a 	mov	r4,r2
8110fcc0:	1107eac0 	call	81107eac <bRmapSetMemConfigArea>
			}

			break;
8110fcc4:	00000a06 	br	8110fcf0 <vQCmdFeeRMAPinStandBy+0x4fc>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110fcc8:	d0a06217 	ldw	r2,-32376(gp)
8110fccc:	e0fff903 	ldbu	r3,-28(fp)
8110fcd0:	180d883a 	mov	r6,r3
8110fcd4:	01604574 	movhi	r5,33045
8110fcd8:	2972cf04 	addi	r5,r5,-13508
8110fcdc:	1009883a 	mov	r4,r2
8110fce0:	11213440 	call	81121344 <fprintf>
			#endif
			break;
8110fce4:	00000306 	br	8110fcf4 <vQCmdFeeRMAPinStandBy+0x500>
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8110fce8:	0001883a 	nop
8110fcec:	00000106 	br	8110fcf4 <vQCmdFeeRMAPinStandBy+0x500>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110fcf0:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110fcf4:	0001883a 	nop
8110fcf8:	e037883a 	mov	sp,fp
8110fcfc:	dfc00117 	ldw	ra,4(sp)
8110fd00:	df000017 	ldw	fp,0(sp)
8110fd04:	dec00204 	addi	sp,sp,8
8110fd08:	f800283a 	ret

8110fd0c <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
8110fd0c:	defff804 	addi	sp,sp,-32
8110fd10:	de00012e 	bgeu	sp,et,8110fd18 <vQCmdFeeRMAPinFullPattern+0xc>
8110fd14:	003b68fa 	trap	3
8110fd18:	dfc00715 	stw	ra,28(sp)
8110fd1c:	df000615 	stw	fp,24(sp)
8110fd20:	df000604 	addi	fp,sp,24
8110fd24:	e13ffe15 	stw	r4,-8(fp)
8110fd28:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
8110fd2c:	d0e06217 	ldw	r3,-32376(gp)
8110fd30:	e0bffe17 	ldw	r2,-8(fp)
8110fd34:	10800003 	ldbu	r2,0(r2)
8110fd38:	10803fcc 	andi	r2,r2,255
8110fd3c:	100d883a 	mov	r6,r2
8110fd40:	01604574 	movhi	r5,33045
8110fd44:	2972d804 	addi	r5,r5,-13472
8110fd48:	1809883a 	mov	r4,r3
8110fd4c:	11213440 	call	81121344 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110fd50:	e0bfff17 	ldw	r2,-4(fp)
8110fd54:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110fd58:	e0bffd43 	ldbu	r2,-11(fp)
8110fd5c:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110fd60:	e0bffe17 	ldw	r2,-8(fp)
8110fd64:	10804317 	ldw	r2,268(r2)
8110fd68:	e0fffa03 	ldbu	r3,-24(fp)
8110fd6c:	180b883a 	mov	r5,r3
8110fd70:	1009883a 	mov	r4,r2
8110fd74:	1109f100 	call	81109f10 <uliRmapReadReg>
8110fd78:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8110fd7c:	e0bffa03 	ldbu	r2,-24(fp)
8110fd80:	10bff004 	addi	r2,r2,-64
8110fd84:	10c003a8 	cmpgeui	r3,r2,14
8110fd88:	1800e61e 	bne	r3,zero,81110124 <vQCmdFeeRMAPinFullPattern+0x418>
8110fd8c:	100690ba 	slli	r3,r2,2
8110fd90:	00a04474 	movhi	r2,33041
8110fd94:	10bf6904 	addi	r2,r2,-604
8110fd98:	1885883a 	add	r2,r3,r2
8110fd9c:	10800017 	ldw	r2,0(r2)
8110fda0:	1000683a 	jmp	r2
8110fda4:	8110fddc 	xori	r4,r16,17399
8110fda8:	8110fddc 	xori	r4,r16,17399
8110fdac:	8110fddc 	xori	r4,r16,17399
8110fdb0:	8110ff90 	cmplti	r4,r16,17406
8110fdb4:	8110ff90 	cmplti	r4,r16,17406
8110fdb8:	8110ff90 	cmplti	r4,r16,17406
8110fdbc:	8110ff90 	cmplti	r4,r16,17406
8110fdc0:	8110ff90 	cmplti	r4,r16,17406
8110fdc4:	8110ff90 	cmplti	r4,r16,17406
8110fdc8:	8110ff90 	cmplti	r4,r16,17406
8110fdcc:	8110ff90 	cmplti	r4,r16,17406
8110fdd0:	8110ff90 	cmplti	r4,r16,17406
8110fdd4:	8110ffb0 	cmpltui	r4,r16,17406
8110fdd8:	811100bc 	xorhi	r4,r16,17410
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8110fddc:	e0bffe17 	ldw	r2,-8(fp)
8110fde0:	10802d17 	ldw	r2,180(r2)
8110fde4:	108001e0 	cmpeqi	r2,r2,7
8110fde8:	1000041e 	bne	r2,zero,8110fdfc <vQCmdFeeRMAPinFullPattern+0xf0>
8110fdec:	e0bffe17 	ldw	r2,-8(fp)
8110fdf0:	10802d17 	ldw	r2,180(r2)
8110fdf4:	10800318 	cmpnei	r2,r2,12
8110fdf8:	1000541e 	bne	r2,zero,8110ff4c <vQCmdFeeRMAPinFullPattern+0x240>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110fdfc:	e0bffa43 	ldbu	r2,-23(fp)
8110fe00:	1080030c 	andi	r2,r2,12
8110fe04:	1005d0ba 	srai	r2,r2,2
8110fe08:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
8110fe0c:	e0bffb17 	ldw	r2,-20(fp)
8110fe10:	10c000a0 	cmpeqi	r3,r2,2
8110fe14:	18000e1e 	bne	r3,zero,8110fe50 <vQCmdFeeRMAPinFullPattern+0x144>
8110fe18:	10c000e0 	cmpeqi	r3,r2,3
8110fe1c:	1800171e 	bne	r3,zero,8110fe7c <vQCmdFeeRMAPinFullPattern+0x170>
8110fe20:	10800060 	cmpeqi	r2,r2,1
8110fe24:	10001e26 	beq	r2,zero,8110fea0 <vQCmdFeeRMAPinFullPattern+0x194>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
8110fe28:	e0bffe17 	ldw	r2,-8(fp)
8110fe2c:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Left side\n");
8110fe30:	d0a06217 	ldw	r2,-32376(gp)
8110fe34:	100f883a 	mov	r7,r2
8110fe38:	01800344 	movi	r6,13
8110fe3c:	01400044 	movi	r5,1
8110fe40:	01204574 	movhi	r4,33045
8110fe44:	21327004 	addi	r4,r4,-13888
8110fe48:	11219e00 	call	811219e0 <fwrite>
						#endif
						break;
8110fe4c:	00002c06 	br	8110ff00 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
8110fe50:	e0bffe17 	ldw	r2,-8(fp)
8110fe54:	00c00044 	movi	r3,1
8110fe58:	10c02e15 	stw	r3,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Right side\n");
8110fe5c:	d0a06217 	ldw	r2,-32376(gp)
8110fe60:	100f883a 	mov	r7,r2
8110fe64:	01800384 	movi	r6,14
8110fe68:	01400044 	movi	r5,1
8110fe6c:	01204574 	movhi	r4,33045
8110fe70:	21327404 	addi	r4,r4,-13872
8110fe74:	11219e00 	call	811219e0 <fwrite>
						#endif
						break;
8110fe78:	00002106 	br	8110ff00 <vQCmdFeeRMAPinFullPattern+0x1f4>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
8110fe7c:	e0bffe17 	ldw	r2,-8(fp)
8110fe80:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110fe84:	d0a06217 	ldw	r2,-32376(gp)
8110fe88:	100f883a 	mov	r7,r2
8110fe8c:	01800f44 	movi	r6,61
8110fe90:	01400044 	movi	r5,1
8110fe94:	01204574 	movhi	r4,33045
8110fe98:	21327804 	addi	r4,r4,-13856
8110fe9c:	11219e00 	call	811219e0 <fwrite>
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
8110fea0:	e0bffe17 	ldw	r2,-8(fp)
8110fea4:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fea8:	e0bffe17 	ldw	r2,-8(fp)
8110feac:	10804304 	addi	r2,r2,268
8110feb0:	1009883a 	mov	r4,r2
8110feb4:	11081980 	call	81108198 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110feb8:	e0bffe17 	ldw	r2,-8(fp)
8110febc:	10c05717 	ldw	r3,348(r2)
8110fec0:	00bffdc4 	movi	r2,-9
8110fec4:	1886703a 	and	r3,r3,r2
8110fec8:	e0bffe17 	ldw	r2,-8(fp)
8110fecc:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fed0:	e0bffe17 	ldw	r2,-8(fp)
8110fed4:	10804304 	addi	r2,r2,268
8110fed8:	1009883a 	mov	r4,r2
8110fedc:	1107eac0 	call	81107eac <bRmapSetMemConfigArea>
						#ifdef DEBUG_ON
							fprintf(fp," - Switching to Left side\n");
8110fee0:	d0a06217 	ldw	r2,-32376(gp)
8110fee4:	100f883a 	mov	r7,r2
8110fee8:	01800684 	movi	r6,26
8110feec:	01400044 	movi	r5,1
8110fef0:	01204574 	movhi	r4,33045
8110fef4:	21328804 	addi	r4,r4,-13792
8110fef8:	11219e00 	call	811219e0 <fwrite>
						#endif
					break;
8110fefc:	0001883a 	nop
				}
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8110ff00:	d0e06217 	ldw	r3,-32376(gp)
8110ff04:	e0bffe17 	ldw	r2,-8(fp)
8110ff08:	10800003 	ldbu	r2,0(r2)
8110ff0c:	11003fcc 	andi	r4,r2,255
8110ff10:	e0bffe17 	ldw	r2,-8(fp)
8110ff14:	10802e17 	ldw	r2,184(r2)
8110ff18:	100f883a 	mov	r7,r2
8110ff1c:	200d883a 	mov	r6,r4
8110ff20:	01604574 	movhi	r5,33045
8110ff24:	29728f04 	addi	r5,r5,-13764
8110ff28:	1809883a 	mov	r4,r3
8110ff2c:	11213440 	call	81121344 <fprintf>
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
8110ff30:	e0bffe17 	ldw	r2,-8(fp)
8110ff34:	00c00284 	movi	r3,10
8110ff38:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
8110ff3c:	e0bffe17 	ldw	r2,-8(fp)
8110ff40:	00c00304 	movi	r3,12
8110ff44:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
8110ff48:	00007e06 	br	81110144 <vQCmdFeeRMAPinFullPattern+0x438>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
8110ff4c:	e0bffe17 	ldw	r2,-8(fp)
8110ff50:	10802d17 	ldw	r2,180(r2)
8110ff54:	10800118 	cmpnei	r2,r2,4
8110ff58:	10007a1e 	bne	r2,zero,81110144 <vQCmdFeeRMAPinFullPattern+0x438>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8110ff5c:	d0e06217 	ldw	r3,-32376(gp)
8110ff60:	e0bffe17 	ldw	r2,-8(fp)
8110ff64:	10800003 	ldbu	r2,0(r2)
8110ff68:	11003fcc 	andi	r4,r2,255
8110ff6c:	e0bffe17 	ldw	r2,-8(fp)
8110ff70:	10802e17 	ldw	r2,184(r2)
8110ff74:	100f883a 	mov	r7,r2
8110ff78:	200d883a 	mov	r6,r4
8110ff7c:	01604574 	movhi	r5,33045
8110ff80:	2972e504 	addi	r5,r5,-13420
8110ff84:	1809883a 	mov	r4,r3
8110ff88:	11213440 	call	81121344 <fprintf>
				}
			}



			break;
8110ff8c:	00006d06 	br	81110144 <vQCmdFeeRMAPinFullPattern+0x438>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110ff90:	d0a06217 	ldw	r2,-32376(gp)
8110ff94:	e0fffa03 	ldbu	r3,-24(fp)
8110ff98:	180d883a 	mov	r6,r3
8110ff9c:	01604574 	movhi	r5,33045
8110ffa0:	2972cf04 	addi	r5,r5,-13508
8110ffa4:	1009883a 	mov	r4,r2
8110ffa8:	11213440 	call	81121344 <fprintf>
			#endif
				break;
8110ffac:	00006806 	br	81110150 <vQCmdFeeRMAPinFullPattern+0x444>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110ffb0:	e0bffa43 	ldbu	r2,-23(fp)
8110ffb4:	1004d13a 	srli	r2,r2,4
8110ffb8:	10803fcc 	andi	r2,r2,255
8110ffbc:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
8110ffc0:	e0bffc17 	ldw	r2,-16(fp)
8110ffc4:	10c000a0 	cmpeqi	r3,r2,2
8110ffc8:	1800221e 	bne	r3,zero,81110054 <vQCmdFeeRMAPinFullPattern+0x348>
8110ffcc:	10c001a0 	cmpeqi	r3,r2,6
8110ffd0:	18002a1e 	bne	r3,zero,8111007c <vQCmdFeeRMAPinFullPattern+0x370>
8110ffd4:	1000311e 	bne	r2,zero,8111009c <vQCmdFeeRMAPinFullPattern+0x390>
				case 0: /* Standby */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
8110ffd8:	d0a06217 	ldw	r2,-32376(gp)
8110ffdc:	100f883a 	mov	r7,r2
8110ffe0:	01800384 	movi	r6,14
8110ffe4:	01400044 	movi	r5,1
8110ffe8:	01204574 	movhi	r4,33045
8110ffec:	2132fc04 	addi	r4,r4,-13328
8110fff0:	11219e00 	call	811219e0 <fwrite>
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110fff4:	e0bffe17 	ldw	r2,-8(fp)
8110fff8:	10802c17 	ldw	r2,176(r2)
8110fffc:	10800298 	cmpnei	r2,r2,10
81110000:	10000a1e 	bne	r2,zero,8111002c <vQCmdFeeRMAPinFullPattern+0x320>
						pxNFeeP->xControl.bWatingSync = TRUE;
81110004:	e0bffe17 	ldw	r2,-8(fp)
81110008:	00c00044 	movi	r3,1
8111000c:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110010:	e0bffe17 	ldw	r2,-8(fp)
81110014:	00c00304 	movi	r3,12
81110018:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8111001c:	e0bffe17 	ldw	r2,-8(fp)
81110020:	00c00184 	movi	r3,6
81110024:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
81110028:	00002306 	br	811100b8 <vQCmdFeeRMAPinFullPattern+0x3ac>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
8111002c:	e0bffe17 	ldw	r2,-8(fp)
81110030:	00c00044 	movi	r3,1
81110034:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
81110038:	e0bffe17 	ldw	r2,-8(fp)
8111003c:	00c00104 	movi	r3,4
81110040:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110044:	e0bffe17 	ldw	r2,-8(fp)
81110048:	00c00184 	movi	r3,6
8111004c:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
81110050:	00001906 	br	811100b8 <vQCmdFeeRMAPinFullPattern+0x3ac>
				case 2: /* PAttern Full image */
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110054:	d0e06217 	ldw	r3,-32376(gp)
81110058:	e0bffe17 	ldw	r2,-8(fp)
8111005c:	10800003 	ldbu	r2,0(r2)
81110060:	10803fcc 	andi	r2,r2,255
81110064:	100d883a 	mov	r6,r2
81110068:	01604574 	movhi	r5,33045
8111006c:	29724a04 	addi	r5,r5,-14040
81110070:	1809883a 	mov	r4,r3
81110074:	11213440 	call	81121344 <fprintf>
					#endif

					break;
81110078:	00000f06 	br	811100b8 <vQCmdFeeRMAPinFullPattern+0x3ac>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
8111007c:	d0a06217 	ldw	r2,-32376(gp)
81110080:	100f883a 	mov	r7,r2
81110084:	018005c4 	movi	r6,23
81110088:	01400044 	movi	r5,1
8111008c:	01204574 	movhi	r4,33045
81110090:	21330004 	addi	r4,r4,-13312
81110094:	11219e00 	call	811219e0 <fwrite>
				#endif
					break;
81110098:	00000706 	br	811100b8 <vQCmdFeeRMAPinFullPattern+0x3ac>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
8111009c:	d0a06217 	ldw	r2,-32376(gp)
811100a0:	e1bffc17 	ldw	r6,-16(fp)
811100a4:	01604574 	movhi	r5,33045
811100a8:	29730604 	addi	r5,r5,-13288
811100ac:	1009883a 	mov	r4,r2
811100b0:	11213440 	call	81121344 <fprintf>
					#endif
					break;
811100b4:	0001883a 	nop
			}

			break;
811100b8:	00002506 	br	81110150 <vQCmdFeeRMAPinFullPattern+0x444>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
811100bc:	e0bffa43 	ldbu	r2,-23(fp)
811100c0:	1080010c 	andi	r2,r2,4
811100c4:	10803fcc 	andi	r2,r2,255
811100c8:	1004d0ba 	srli	r2,r2,2
811100cc:	10803fcc 	andi	r2,r2,255
811100d0:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
811100d4:	e0bffc17 	ldw	r2,-16(fp)
811100d8:	10001c26 	beq	r2,zero,8111014c <vQCmdFeeRMAPinFullPattern+0x440>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
811100dc:	e0bffe17 	ldw	r2,-8(fp)
811100e0:	10802d17 	ldw	r2,180(r2)
811100e4:	10800198 	cmpnei	r2,r2,6
811100e8:	1000181e 	bne	r2,zero,8111014c <vQCmdFeeRMAPinFullPattern+0x440>
					pxNFeeP->xControl.bWatingSync = FALSE;
811100ec:	e0bffe17 	ldw	r2,-8(fp)
811100f0:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
811100f4:	e0bffe17 	ldw	r2,-8(fp)
811100f8:	10c02d17 	ldw	r3,180(r2)
811100fc:	e0bffe17 	ldw	r2,-8(fp)
81110100:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
81110104:	d0a06217 	ldw	r2,-32376(gp)
81110108:	100f883a 	mov	r7,r2
8111010c:	01800404 	movi	r6,16
81110110:	01400044 	movi	r5,1
81110114:	01204574 	movhi	r4,33045
81110118:	21330e04 	addi	r4,r4,-13256
8111011c:	11219e00 	call	811219e0 <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
81110120:	00000a06 	br	8111014c <vQCmdFeeRMAPinFullPattern+0x440>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110124:	d0a06217 	ldw	r2,-32376(gp)
81110128:	e0fffa03 	ldbu	r3,-24(fp)
8111012c:	180d883a 	mov	r6,r3
81110130:	01604574 	movhi	r5,33045
81110134:	2972cf04 	addi	r5,r5,-13508
81110138:	1009883a 	mov	r4,r2
8111013c:	11213440 	call	81121344 <fprintf>
			#endif
			break;
81110140:	00000306 	br	81110150 <vQCmdFeeRMAPinFullPattern+0x444>
				}
			}



			break;
81110144:	0001883a 	nop
81110148:	00000106 	br	81110150 <vQCmdFeeRMAPinFullPattern+0x444>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8111014c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
81110150:	0001883a 	nop
81110154:	e037883a 	mov	sp,fp
81110158:	dfc00117 	ldw	ra,4(sp)
8111015c:	df000017 	ldw	fp,0(sp)
81110160:	dec00204 	addi	sp,sp,8
81110164:	f800283a 	ret

81110168 <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
81110168:	defff804 	addi	sp,sp,-32
8111016c:	de00012e 	bgeu	sp,et,81110174 <vQCmdFeeRMAPWaitingSync+0xc>
81110170:	003b68fa 	trap	3
81110174:	dfc00715 	stw	ra,28(sp)
81110178:	df000615 	stw	fp,24(sp)
8111017c:	df000604 	addi	fp,sp,24
81110180:	e13ffe15 	stw	r4,-8(fp)
81110184:	e17fff15 	stw	r5,-4(fp)
	INT8U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
81110188:	d0e06217 	ldw	r3,-32376(gp)
8111018c:	e0bffe17 	ldw	r2,-8(fp)
81110190:	10800003 	ldbu	r2,0(r2)
81110194:	10803fcc 	andi	r2,r2,255
81110198:	100d883a 	mov	r6,r2
8111019c:	01604574 	movhi	r5,33045
811101a0:	29731304 	addi	r5,r5,-13236
811101a4:	1809883a 	mov	r4,r3
811101a8:	11213440 	call	81121344 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
811101ac:	e0bfff17 	ldw	r2,-4(fp)
811101b0:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
811101b4:	e0bffd43 	ldbu	r2,-11(fp)
811101b8:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
811101bc:	e0bffe17 	ldw	r2,-8(fp)
811101c0:	10804317 	ldw	r2,268(r2)
811101c4:	e0fffa03 	ldbu	r3,-24(fp)
811101c8:	180b883a 	mov	r5,r3
811101cc:	1009883a 	mov	r4,r2
811101d0:	1109f100 	call	81109f10 <uliRmapReadReg>
811101d4:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
811101d8:	e0bffa03 	ldbu	r2,-24(fp)
811101dc:	10c010c8 	cmpgei	r3,r2,67
811101e0:	1800051e 	bne	r3,zero,811101f8 <vQCmdFeeRMAPWaitingSync+0x90>
811101e4:	10c01008 	cmpgei	r3,r2,64
811101e8:	1800081e 	bne	r3,zero,8111020c <vQCmdFeeRMAPWaitingSync+0xa4>
811101ec:	108000a0 	cmpeqi	r2,r2,2
811101f0:	1000a81e 	bne	r2,zero,81110494 <vQCmdFeeRMAPWaitingSync+0x32c>
811101f4:	0000d406 	br	81110548 <vQCmdFeeRMAPWaitingSync+0x3e0>
811101f8:	10c01350 	cmplti	r3,r2,77
811101fc:	1800701e 	bne	r3,zero,811103c0 <vQCmdFeeRMAPWaitingSync+0x258>
81110200:	10801360 	cmpeqi	r2,r2,77
81110204:	1000b61e 	bne	r2,zero,811104e0 <vQCmdFeeRMAPWaitingSync+0x378>
81110208:	0000cf06 	br	81110548 <vQCmdFeeRMAPWaitingSync+0x3e0>
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8111020c:	e0bffe17 	ldw	r2,-8(fp)
81110210:	10802d17 	ldw	r2,180(r2)
81110214:	108001e0 	cmpeqi	r2,r2,7
81110218:	1000041e 	bne	r2,zero,8111022c <vQCmdFeeRMAPWaitingSync+0xc4>
8111021c:	e0bffe17 	ldw	r2,-8(fp)
81110220:	10802d17 	ldw	r2,180(r2)
81110224:	10800318 	cmpnei	r2,r2,12
81110228:	1000541e 	bne	r2,zero,8111037c <vQCmdFeeRMAPWaitingSync+0x214>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8111022c:	e0bffa43 	ldbu	r2,-23(fp)
81110230:	1080030c 	andi	r2,r2,12
81110234:	1005d0ba 	srai	r2,r2,2
81110238:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
8111023c:	e0bffb17 	ldw	r2,-20(fp)
81110240:	10c000a0 	cmpeqi	r3,r2,2
81110244:	18000e1e 	bne	r3,zero,81110280 <vQCmdFeeRMAPWaitingSync+0x118>
81110248:	10c000e0 	cmpeqi	r3,r2,3
8111024c:	1800171e 	bne	r3,zero,811102ac <vQCmdFeeRMAPWaitingSync+0x144>
81110250:	10800060 	cmpeqi	r2,r2,1
81110254:	10001e26 	beq	r2,zero,811102d0 <vQCmdFeeRMAPWaitingSync+0x168>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
81110258:	e0bffe17 	ldw	r2,-8(fp)
8111025c:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Left side\n");
81110260:	d0a06217 	ldw	r2,-32376(gp)
81110264:	100f883a 	mov	r7,r2
81110268:	01800344 	movi	r6,13
8111026c:	01400044 	movi	r5,1
81110270:	01204574 	movhi	r4,33045
81110274:	21327004 	addi	r4,r4,-13888
81110278:	11219e00 	call	811219e0 <fwrite>
						#endif
						break;
8111027c:	00002c06 	br	81110330 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
81110280:	e0bffe17 	ldw	r2,-8(fp)
81110284:	00c00044 	movi	r3,1
81110288:	10c02e15 	stw	r3,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Right side\n");
8111028c:	d0a06217 	ldw	r2,-32376(gp)
81110290:	100f883a 	mov	r7,r2
81110294:	01800384 	movi	r6,14
81110298:	01400044 	movi	r5,1
8111029c:	01204574 	movhi	r4,33045
811102a0:	21327404 	addi	r4,r4,-13872
811102a4:	11219e00 	call	811219e0 <fwrite>
						#endif
						break;
811102a8:	00002106 	br	81110330 <vQCmdFeeRMAPWaitingSync+0x1c8>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
811102ac:	e0bffe17 	ldw	r2,-8(fp)
811102b0:	10002e15 	stw	zero,184(r2)
						#ifdef DEBUG_ON
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
811102b4:	d0a06217 	ldw	r2,-32376(gp)
811102b8:	100f883a 	mov	r7,r2
811102bc:	01800f44 	movi	r6,61
811102c0:	01400044 	movi	r5,1
811102c4:	01204574 	movhi	r4,33045
811102c8:	21327804 	addi	r4,r4,-13856
811102cc:	11219e00 	call	811219e0 <fwrite>
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
811102d0:	e0bffe17 	ldw	r2,-8(fp)
811102d4:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
811102d8:	e0bffe17 	ldw	r2,-8(fp)
811102dc:	10804304 	addi	r2,r2,268
811102e0:	1009883a 	mov	r4,r2
811102e4:	11081980 	call	81108198 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
811102e8:	e0bffe17 	ldw	r2,-8(fp)
811102ec:	10c05717 	ldw	r3,348(r2)
811102f0:	00bffdc4 	movi	r2,-9
811102f4:	1886703a 	and	r3,r3,r2
811102f8:	e0bffe17 	ldw	r2,-8(fp)
811102fc:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
81110300:	e0bffe17 	ldw	r2,-8(fp)
81110304:	10804304 	addi	r2,r2,268
81110308:	1009883a 	mov	r4,r2
8111030c:	1107eac0 	call	81107eac <bRmapSetMemConfigArea>
						#ifdef DEBUG_ON
							fprintf(fp," - Switching to Left side\n");
81110310:	d0a06217 	ldw	r2,-32376(gp)
81110314:	100f883a 	mov	r7,r2
81110318:	01800684 	movi	r6,26
8111031c:	01400044 	movi	r5,1
81110320:	01204574 	movhi	r4,33045
81110324:	21328804 	addi	r4,r4,-13792
81110328:	11219e00 	call	811219e0 <fwrite>
						#endif
					break;
8111032c:	0001883a 	nop
				}
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
81110330:	d0e06217 	ldw	r3,-32376(gp)
81110334:	e0bffe17 	ldw	r2,-8(fp)
81110338:	10800003 	ldbu	r2,0(r2)
8111033c:	11003fcc 	andi	r4,r2,255
81110340:	e0bffe17 	ldw	r2,-8(fp)
81110344:	10802e17 	ldw	r2,184(r2)
81110348:	100f883a 	mov	r7,r2
8111034c:	200d883a 	mov	r6,r4
81110350:	01604574 	movhi	r5,33045
81110354:	29728f04 	addi	r5,r5,-13764
81110358:	1809883a 	mov	r4,r3
8111035c:	11213440 	call	81121344 <fprintf>
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
81110360:	e0bffe17 	ldw	r2,-8(fp)
81110364:	00c00284 	movi	r3,10
81110368:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
8111036c:	e0bffe17 	ldw	r2,-8(fp)
81110370:	00c00304 	movi	r3,12
81110374:	10c02d15 	stw	r3,180(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					#endif
				}
			}
			break;
81110378:	00007b06 	br	81110568 <vQCmdFeeRMAPWaitingSync+0x400>


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
			} else {
				if (pxNFeeP->xControl.eNextMode == sFeeTestFullPattern) {
8111037c:	e0bffe17 	ldw	r2,-8(fp)
81110380:	10802d17 	ldw	r2,180(r2)
81110384:	10800118 	cmpnei	r2,r2,4
81110388:	1000771e 	bne	r2,zero,81110568 <vQCmdFeeRMAPWaitingSync+0x400>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
8111038c:	d0e06217 	ldw	r3,-32376(gp)
81110390:	e0bffe17 	ldw	r2,-8(fp)
81110394:	10800003 	ldbu	r2,0(r2)
81110398:	11003fcc 	andi	r4,r2,255
8111039c:	e0bffe17 	ldw	r2,-8(fp)
811103a0:	10802e17 	ldw	r2,184(r2)
811103a4:	100f883a 	mov	r7,r2
811103a8:	200d883a 	mov	r6,r4
811103ac:	01604574 	movhi	r5,33045
811103b0:	2972e504 	addi	r5,r5,-13420
811103b4:	1809883a 	mov	r4,r3
811103b8:	11213440 	call	81121344 <fprintf>
					#endif
				}
			}
			break;
811103bc:	00006a06 	br	81110568 <vQCmdFeeRMAPWaitingSync+0x400>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
811103c0:	e0bffa43 	ldbu	r2,-23(fp)
811103c4:	1004d13a 	srli	r2,r2,4
811103c8:	10803fcc 	andi	r2,r2,255
811103cc:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
811103d0:	e0bffc17 	ldw	r2,-16(fp)
811103d4:	10c000a0 	cmpeqi	r3,r2,2
811103d8:	1800141e 	bne	r3,zero,8111042c <vQCmdFeeRMAPWaitingSync+0x2c4>
811103dc:	10c001a0 	cmpeqi	r3,r2,6
811103e0:	18001c1e 	bne	r3,zero,81110454 <vQCmdFeeRMAPWaitingSync+0x2ec>
811103e4:	1000231e 	bne	r2,zero,81110474 <vQCmdFeeRMAPWaitingSync+0x30c>
			case 0: /* Standby */
			#ifdef DEBUG_ON
				fprintf(fp,"- to Stand-By\n");
811103e8:	d0a06217 	ldw	r2,-32376(gp)
811103ec:	100f883a 	mov	r7,r2
811103f0:	01800384 	movi	r6,14
811103f4:	01400044 	movi	r5,1
811103f8:	01204574 	movhi	r4,33045
811103fc:	2132fc04 	addi	r4,r4,-13328
81110400:	11219e00 	call	811219e0 <fwrite>
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
81110404:	e0bffe17 	ldw	r2,-8(fp)
81110408:	00c00044 	movi	r3,1
8111040c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110410:	e0bffe17 	ldw	r2,-8(fp)
81110414:	00c00304 	movi	r3,12
81110418:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8111041c:	e0bffe17 	ldw	r2,-8(fp)
81110420:	00c00184 	movi	r3,6
81110424:	10c02d15 	stw	r3,180(r2)


				break;
81110428:	00001906 	br	81110490 <vQCmdFeeRMAPWaitingSync+0x328>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
8111042c:	e0bffe17 	ldw	r2,-8(fp)
81110430:	00c00044 	movi	r3,1
81110434:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
81110438:	e0bffe17 	ldw	r2,-8(fp)
8111043c:	00c00304 	movi	r3,12
81110440:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
81110444:	e0bffe17 	ldw	r2,-8(fp)
81110448:	00c00284 	movi	r3,10
8111044c:	10c02d15 	stw	r3,180(r2)

				break;
81110450:	00000f06 	br	81110490 <vQCmdFeeRMAPWaitingSync+0x328>
			case 6:
			#ifdef DEBUG_ON
				fprintf(fp," Off-Mode not allowed.\n");
81110454:	d0a06217 	ldw	r2,-32376(gp)
81110458:	100f883a 	mov	r7,r2
8111045c:	018005c4 	movi	r6,23
81110460:	01400044 	movi	r5,1
81110464:	01204574 	movhi	r4,33045
81110468:	21330004 	addi	r4,r4,-13312
8111046c:	11219e00 	call	811219e0 <fwrite>
			#endif
				break;
81110470:	00000706 	br	81110490 <vQCmdFeeRMAPWaitingSync+0x328>
			case 3:
			case 4:
			case 5:
			default:
				#ifdef DEBUG_ON
					fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
81110474:	d0a06217 	ldw	r2,-32376(gp)
81110478:	e1bffc17 	ldw	r6,-16(fp)
8111047c:	01604574 	movhi	r5,33045
81110480:	29730604 	addi	r5,r5,-13288
81110484:	1009883a 	mov	r4,r2
81110488:	11213440 	call	81121344 <fprintf>
				#endif
				break;
8111048c:	0001883a 	nop
		}

			break;
81110490:	00003806 	br	81110574 <vQCmdFeeRMAPWaitingSync+0x40c>
		case 2: /* PAttern Full image */
			#ifdef DEBUG_ON
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
81110494:	d0e06217 	ldw	r3,-32376(gp)
81110498:	e0bffe17 	ldw	r2,-8(fp)
8111049c:	10800003 	ldbu	r2,0(r2)
811104a0:	10803fcc 	andi	r2,r2,255
811104a4:	100d883a 	mov	r6,r2
811104a8:	01604574 	movhi	r5,33045
811104ac:	29724a04 	addi	r5,r5,-14040
811104b0:	1809883a 	mov	r4,r3
811104b4:	11213440 	call	81121344 <fprintf>
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
811104b8:	e0bffe17 	ldw	r2,-8(fp)
811104bc:	00c00044 	movi	r3,1
811104c0:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
811104c4:	e0bffe17 	ldw	r2,-8(fp)
811104c8:	00c00284 	movi	r3,10
811104cc:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
811104d0:	e0bffe17 	ldw	r2,-8(fp)
811104d4:	00c00304 	movi	r3,12
811104d8:	10c02d15 	stw	r3,180(r2)

			break;
811104dc:	00002506 	br	81110574 <vQCmdFeeRMAPWaitingSync+0x40c>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
811104e0:	e0bffa43 	ldbu	r2,-23(fp)
811104e4:	1080010c 	andi	r2,r2,4
811104e8:	10803fcc 	andi	r2,r2,255
811104ec:	1004d0ba 	srli	r2,r2,2
811104f0:	10803fcc 	andi	r2,r2,255
811104f4:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
811104f8:	e0bffc17 	ldw	r2,-16(fp)
811104fc:	10001c26 	beq	r2,zero,81110570 <vQCmdFeeRMAPWaitingSync+0x408>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81110500:	e0bffe17 	ldw	r2,-8(fp)
81110504:	10802d17 	ldw	r2,180(r2)
81110508:	10800198 	cmpnei	r2,r2,6
8111050c:	1000181e 	bne	r2,zero,81110570 <vQCmdFeeRMAPWaitingSync+0x408>
					pxNFeeP->xControl.bWatingSync = FALSE;
81110510:	e0bffe17 	ldw	r2,-8(fp)
81110514:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
81110518:	e0bffe17 	ldw	r2,-8(fp)
8111051c:	10c02d17 	ldw	r3,180(r2)
81110520:	e0bffe17 	ldw	r2,-8(fp)
81110524:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
81110528:	d0a06217 	ldw	r2,-32376(gp)
8111052c:	100f883a 	mov	r7,r2
81110530:	01800404 	movi	r6,16
81110534:	01400044 	movi	r5,1
81110538:	01204574 	movhi	r4,33045
8111053c:	21330e04 	addi	r4,r4,-13256
81110540:	11219e00 	call	811219e0 <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110544:	00000a06 	br	81110570 <vQCmdFeeRMAPWaitingSync+0x408>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
81110548:	d0a06217 	ldw	r2,-32376(gp)
8111054c:	e0fffa03 	ldbu	r3,-24(fp)
81110550:	180d883a 	mov	r6,r3
81110554:	01604574 	movhi	r5,33045
81110558:	2972cf04 	addi	r5,r5,-13508
8111055c:	1009883a 	mov	r4,r2
81110560:	11213440 	call	81121344 <fprintf>
			#endif
			break;
81110564:	00000306 	br	81110574 <vQCmdFeeRMAPWaitingSync+0x40c>
					#ifdef DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					#endif
				}
			}
			break;
81110568:	0001883a 	nop
8111056c:	00000106 	br	81110574 <vQCmdFeeRMAPWaitingSync+0x40c>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110570:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
81110574:	0001883a 	nop
81110578:	e037883a 	mov	sp,fp
8111057c:	dfc00117 	ldw	ra,4(sp)
81110580:	df000017 	ldw	fp,0(sp)
81110584:	dec00204 	addi	sp,sp,8
81110588:	f800283a 	ret

8111058c <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
8111058c:	defffc04 	addi	sp,sp,-16
81110590:	de00012e 	bgeu	sp,et,81110598 <bDisableRmapIRQ+0xc>
81110594:	003b68fa 	trap	3
81110598:	dfc00315 	stw	ra,12(sp)
8111059c:	df000215 	stw	fp,8(sp)
811105a0:	df000204 	addi	fp,sp,8
811105a4:	e13ffe15 	stw	r4,-8(fp)
811105a8:	2805883a 	mov	r2,r5
811105ac:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
811105b0:	e13ffe17 	ldw	r4,-8(fp)
811105b4:	11079780 	call	81107978 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811105b8:	e0bffe17 	ldw	r2,-8(fp)
811105bc:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
811105c0:	e13ffe17 	ldw	r4,-8(fp)
811105c4:	11078d00 	call	811078d0 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
811105c8:	00800044 	movi	r2,1
}
811105cc:	e037883a 	mov	sp,fp
811105d0:	dfc00117 	ldw	ra,4(sp)
811105d4:	df000017 	ldw	fp,0(sp)
811105d8:	dec00204 	addi	sp,sp,8
811105dc:	f800283a 	ret

811105e0 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
811105e0:	defffc04 	addi	sp,sp,-16
811105e4:	de00012e 	bgeu	sp,et,811105ec <bEnableRmapIRQ+0xc>
811105e8:	003b68fa 	trap	3
811105ec:	dfc00315 	stw	ra,12(sp)
811105f0:	df000215 	stw	fp,8(sp)
811105f4:	df000204 	addi	fp,sp,8
811105f8:	e13ffe15 	stw	r4,-8(fp)
811105fc:	2805883a 	mov	r2,r5
81110600:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
81110604:	e13ffe17 	ldw	r4,-8(fp)
81110608:	11079780 	call	81107978 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8111060c:	e0bffe17 	ldw	r2,-8(fp)
81110610:	00c00044 	movi	r3,1
81110614:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81110618:	e13ffe17 	ldw	r4,-8(fp)
8111061c:	11078d00 	call	811078d0 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110620:	00800044 	movi	r2,1
}
81110624:	e037883a 	mov	sp,fp
81110628:	dfc00117 	ldw	ra,4(sp)
8111062c:	df000017 	ldw	fp,0(sp)
81110630:	dec00204 	addi	sp,sp,8
81110634:	f800283a 	ret

81110638 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
81110638:	defffd04 	addi	sp,sp,-12
8111063c:	de00012e 	bgeu	sp,et,81110644 <bDisableSPWChannel+0xc>
81110640:	003b68fa 	trap	3
81110644:	dfc00215 	stw	ra,8(sp)
81110648:	df000115 	stw	fp,4(sp)
8111064c:	df000104 	addi	fp,sp,4
81110650:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
81110654:	e13fff17 	ldw	r4,-4(fp)
81110658:	110a2fc0 	call	8110a2fc <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8111065c:	e0bfff17 	ldw	r2,-4(fp)
81110660:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
81110664:	e0bfff17 	ldw	r2,-4(fp)
81110668:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8111066c:	e0bfff17 	ldw	r2,-4(fp)
81110670:	00c00044 	movi	r3,1
81110674:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
81110678:	e13fff17 	ldw	r4,-4(fp)
8111067c:	110a1c80 	call	8110a1c8 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
81110680:	00800044 	movi	r2,1
}
81110684:	e037883a 	mov	sp,fp
81110688:	dfc00117 	ldw	ra,4(sp)
8111068c:	df000017 	ldw	fp,0(sp)
81110690:	dec00204 	addi	sp,sp,8
81110694:	f800283a 	ret

81110698 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
81110698:	defffd04 	addi	sp,sp,-12
8111069c:	de00012e 	bgeu	sp,et,811106a4 <bEnableSPWChannel+0xc>
811106a0:	003b68fa 	trap	3
811106a4:	dfc00215 	stw	ra,8(sp)
811106a8:	df000115 	stw	fp,4(sp)
811106ac:	df000104 	addi	fp,sp,4
811106b0:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
811106b4:	e13fff17 	ldw	r4,-4(fp)
811106b8:	110a2fc0 	call	8110a2fc <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
811106bc:	e0bfff17 	ldw	r2,-4(fp)
811106c0:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
811106c4:	e0bfff17 	ldw	r2,-4(fp)
811106c8:	00c00044 	movi	r3,1
811106cc:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
811106d0:	e0bfff17 	ldw	r2,-4(fp)
811106d4:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
811106d8:	e13fff17 	ldw	r4,-4(fp)
811106dc:	110a1c80 	call	8110a1c8 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
811106e0:	00800044 	movi	r2,1
}
811106e4:	e037883a 	mov	sp,fp
811106e8:	dfc00117 	ldw	ra,4(sp)
811106ec:	df000017 	ldw	fp,0(sp)
811106f0:	dec00204 	addi	sp,sp,8
811106f4:	f800283a 	ret

811106f8 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
811106f8:	defffd04 	addi	sp,sp,-12
811106fc:	de00012e 	bgeu	sp,et,81110704 <bEnableDbBuffer+0xc>
81110700:	003b68fa 	trap	3
81110704:	dfc00215 	stw	ra,8(sp)
81110708:	df000115 	stw	fp,4(sp)
8111070c:	df000104 	addi	fp,sp,4
81110710:	e13fff15 	stw	r4,-4(fp)
	// TODO: mudar [rfranca]
	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
81110714:	e13fff17 	ldw	r4,-4(fp)
81110718:	11069d00 	call	811069d0 <bFeebStopCh>
	// TODO: mudar [rfranca]
	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8111071c:	e13fff17 	ldw	r4,-4(fp)
81110720:	1106a580 	call	81106a58 <bFeebClrCh>
	// TODO: mudar [rfranca]
	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
81110724:	e13fff17 	ldw	r4,-4(fp)
81110728:	11069480 	call	81106948 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
8111072c:	e13fff17 	ldw	r4,-4(fp)
81110730:	11068c00 	call	811068c0 <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
81110734:	00a045b4 	movhi	r2,33046
81110738:	109ade04 	addi	r2,r2,27512
8111073c:	10c00817 	ldw	r3,32(r2)
81110740:	e0bfff17 	ldw	r2,-4(fp)
81110744:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
81110748:	e13fff17 	ldw	r4,-4(fp)
8111074c:	11068180 	call	81106818 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
81110750:	e13fff17 	ldw	r4,-4(fp)
81110754:	11062680 	call	81106268 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81110758:	e0bfff17 	ldw	r2,-4(fp)
8111075c:	00c00044 	movi	r3,1
81110760:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81110764:	e0bfff17 	ldw	r2,-4(fp)
81110768:	00c00044 	movi	r3,1
8111076c:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
81110770:	e13fff17 	ldw	r4,-4(fp)
81110774:	11061940 	call	81106194 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110778:	00800044 	movi	r2,1
}
8111077c:	e037883a 	mov	sp,fp
81110780:	dfc00117 	ldw	ra,4(sp)
81110784:	df000017 	ldw	fp,0(sp)
81110788:	dec00204 	addi	sp,sp,8
8111078c:	f800283a 	ret

81110790 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
81110790:	defffd04 	addi	sp,sp,-12
81110794:	de00012e 	bgeu	sp,et,8111079c <bDisAndClrDbBuffer+0xc>
81110798:	003b68fa 	trap	3
8111079c:	dfc00215 	stw	ra,8(sp)
811107a0:	df000115 	stw	fp,4(sp)
811107a4:	df000104 	addi	fp,sp,4
811107a8:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
811107ac:	e13fff17 	ldw	r4,-4(fp)
811107b0:	11062680 	call	81106268 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811107b4:	e0bfff17 	ldw	r2,-4(fp)
811107b8:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
811107bc:	e0bfff17 	ldw	r2,-4(fp)
811107c0:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
811107c4:	e13fff17 	ldw	r4,-4(fp)
811107c8:	11061940 	call	81106194 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
811107cc:	e13fff17 	ldw	r4,-4(fp)
811107d0:	11069d00 	call	811069d0 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
811107d4:	e13fff17 	ldw	r4,-4(fp)
811107d8:	1106a580 	call	81106a58 <bFeebClrCh>
	// TODO: remover [rfranca]
	bFeebStartCh(pxFeebCh);
811107dc:	e13fff17 	ldw	r4,-4(fp)
811107e0:	11069480 	call	81106948 <bFeebStartCh>

	/*todo: No treatment for now  */
	return TRUE;
811107e4:	00800044 	movi	r2,1
}
811107e8:	e037883a 	mov	sp,fp
811107ec:	dfc00117 	ldw	ra,4(sp)
811107f0:	df000017 	ldw	fp,0(sp)
811107f4:	dec00204 	addi	sp,sp,8
811107f8:	f800283a 	ret

811107fc <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811107fc:	defff804 	addi	sp,sp,-32
81110800:	de00012e 	bgeu	sp,et,81110808 <bSendRequestNFeeCtrl+0xc>
81110804:	003b68fa 	trap	3
81110808:	dfc00715 	stw	ra,28(sp)
8111080c:	df000615 	stw	fp,24(sp)
81110810:	df000604 	addi	fp,sp,24
81110814:	2807883a 	mov	r3,r5
81110818:	3005883a 	mov	r2,r6
8111081c:	e13ffd05 	stb	r4,-12(fp)
81110820:	e0fffe05 	stb	r3,-8(fp)
81110824:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81110828:	00800404 	movi	r2,16
8111082c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81110830:	e0bffd03 	ldbu	r2,-12(fp)
81110834:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81110838:	e0bffe03 	ldbu	r2,-8(fp)
8111083c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81110840:	e0bfff03 	ldbu	r2,-4(fp)
81110844:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81110848:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8111084c:	d0a05d17 	ldw	r2,-32396(gp)
81110850:	e0fffc17 	ldw	r3,-16(fp)
81110854:	180b883a 	mov	r5,r3
81110858:	1009883a 	mov	r4,r2
8111085c:	113dd8c0 	call	8113dd8c <OSQPost>
81110860:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81110864:	e0bffb03 	ldbu	r2,-20(fp)
81110868:	10000526 	beq	r2,zero,81110880 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8111086c:	e0bfff03 	ldbu	r2,-4(fp)
81110870:	1009883a 	mov	r4,r2
81110874:	111d1680 	call	8111d168 <vFailRequestDMA>
		bSuccesL = FALSE;
81110878:	e03ffa15 	stw	zero,-24(fp)
8111087c:	00000206 	br	81110888 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81110880:	00800044 	movi	r2,1
81110884:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81110888:	e0bffa17 	ldw	r2,-24(fp)
}
8111088c:	e037883a 	mov	sp,fp
81110890:	dfc00117 	ldw	ra,4(sp)
81110894:	df000017 	ldw	fp,0(sp)
81110898:	dec00204 	addi	sp,sp,8
8111089c:	f800283a 	ret

811108a0 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811108a0:	defff804 	addi	sp,sp,-32
811108a4:	de00012e 	bgeu	sp,et,811108ac <bSendGiveBackNFeeCtrl+0xc>
811108a8:	003b68fa 	trap	3
811108ac:	dfc00715 	stw	ra,28(sp)
811108b0:	df000615 	stw	fp,24(sp)
811108b4:	df000604 	addi	fp,sp,24
811108b8:	2807883a 	mov	r3,r5
811108bc:	3005883a 	mov	r2,r6
811108c0:	e13ffd05 	stb	r4,-12(fp)
811108c4:	e0fffe05 	stb	r3,-8(fp)
811108c8:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811108cc:	00800404 	movi	r2,16
811108d0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811108d4:	e0bffd03 	ldbu	r2,-12(fp)
811108d8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811108dc:	e0bffe03 	ldbu	r2,-8(fp)
811108e0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811108e4:	e0bfff03 	ldbu	r2,-4(fp)
811108e8:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811108ec:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811108f0:	d0a07017 	ldw	r2,-32320(gp)
811108f4:	e0fffc17 	ldw	r3,-16(fp)
811108f8:	180b883a 	mov	r5,r3
811108fc:	1009883a 	mov	r4,r2
81110900:	113dd8c0 	call	8113dd8c <OSQPost>
81110904:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81110908:	e0bffb03 	ldbu	r2,-20(fp)
8111090c:	10000526 	beq	r2,zero,81110924 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81110910:	e0bfff03 	ldbu	r2,-4(fp)
81110914:	1009883a 	mov	r4,r2
81110918:	111d1680 	call	8111d168 <vFailRequestDMA>
		bSuccesL = FALSE;
8111091c:	e03ffa15 	stw	zero,-24(fp)
81110920:	00000206 	br	8111092c <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81110924:	00800044 	movi	r2,1
81110928:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8111092c:	e0bffa17 	ldw	r2,-24(fp)
}
81110930:	e037883a 	mov	sp,fp
81110934:	dfc00117 	ldw	ra,4(sp)
81110938:	df000017 	ldw	fp,0(sp)
8111093c:	dec00204 	addi	sp,sp,8
81110940:	f800283a 	ret

81110944 <vPrintConsoleNFee>:




#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
81110944:	defffa04 	addi	sp,sp,-24
81110948:	de00012e 	bgeu	sp,et,81110950 <vPrintConsoleNFee+0xc>
8111094c:	003b68fa 	trap	3
81110950:	dfc00515 	stw	ra,20(sp)
81110954:	df000415 	stw	fp,16(sp)
81110958:	df000404 	addi	fp,sp,16
8111095c:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
81110960:	e0bfff17 	ldw	r2,-4(fp)
81110964:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
81110968:	d0e06217 	ldw	r3,-32376(gp)
8111096c:	e0bffe17 	ldw	r2,-8(fp)
81110970:	10800003 	ldbu	r2,0(r2)
81110974:	10803fcc 	andi	r2,r2,255
81110978:	100d883a 	mov	r6,r2
8111097c:	01604574 	movhi	r5,33045
81110980:	29732004 	addi	r5,r5,-13184
81110984:	1809883a 	mov	r4,r3
81110988:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"\n");
8111098c:	d0a06217 	ldw	r2,-32376(gp)
81110990:	100b883a 	mov	r5,r2
81110994:	01000284 	movi	r4,10
81110998:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
8111099c:	d0e06217 	ldw	r3,-32376(gp)
811109a0:	e0bffe17 	ldw	r2,-8(fp)
811109a4:	10800003 	ldbu	r2,0(r2)
811109a8:	10803fcc 	andi	r2,r2,255
811109ac:	100d883a 	mov	r6,r2
811109b0:	01604574 	movhi	r5,33045
811109b4:	29733504 	addi	r5,r5,-13100
811109b8:	1809883a 	mov	r4,r3
811109bc:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
811109c0:	d0e06217 	ldw	r3,-32376(gp)
811109c4:	e0bffe17 	ldw	r2,-8(fp)
811109c8:	10802f0b 	ldhu	r2,188(r2)
811109cc:	10bfffcc 	andi	r2,r2,65535
811109d0:	100d883a 	mov	r6,r2
811109d4:	01604574 	movhi	r5,33045
811109d8:	29733b04 	addi	r5,r5,-13076
811109dc:	1809883a 	mov	r4,r3
811109e0:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
811109e4:	d0e06217 	ldw	r3,-32376(gp)
811109e8:	e0bffe17 	ldw	r2,-8(fp)
811109ec:	10802f8b 	ldhu	r2,190(r2)
811109f0:	10bfffcc 	andi	r2,r2,65535
811109f4:	100d883a 	mov	r6,r2
811109f8:	01604574 	movhi	r5,33045
811109fc:	29734004 	addi	r5,r5,-13056
81110a00:	1809883a 	mov	r4,r3
81110a04:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
81110a08:	d0e06217 	ldw	r3,-32376(gp)
81110a0c:	e0bffe17 	ldw	r2,-8(fp)
81110a10:	1080300b 	ldhu	r2,192(r2)
81110a14:	10bfffcc 	andi	r2,r2,65535
81110a18:	100d883a 	mov	r6,r2
81110a1c:	01604574 	movhi	r5,33045
81110a20:	29734604 	addi	r5,r5,-13032
81110a24:	1809883a 	mov	r4,r3
81110a28:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
81110a2c:	d0e06217 	ldw	r3,-32376(gp)
81110a30:	e0bffe17 	ldw	r2,-8(fp)
81110a34:	1080308b 	ldhu	r2,194(r2)
81110a38:	10bfffcc 	andi	r2,r2,65535
81110a3c:	100d883a 	mov	r6,r2
81110a40:	01604574 	movhi	r5,33045
81110a44:	29734a04 	addi	r5,r5,-13016
81110a48:	1809883a 	mov	r4,r3
81110a4c:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81110a50:	d0e06217 	ldw	r3,-32376(gp)
81110a54:	e0bffe17 	ldw	r2,-8(fp)
81110a58:	1080310b 	ldhu	r2,196(r2)
81110a5c:	10bfffcc 	andi	r2,r2,65535
81110a60:	100d883a 	mov	r6,r2
81110a64:	01604574 	movhi	r5,33045
81110a68:	29735004 	addi	r5,r5,-12992
81110a6c:	1809883a 	mov	r4,r3
81110a70:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"\n");
81110a74:	d0a06217 	ldw	r2,-32376(gp)
81110a78:	100b883a 	mov	r5,r2
81110a7c:	01000284 	movi	r4,10
81110a80:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
81110a84:	d0e06217 	ldw	r3,-32376(gp)
81110a88:	e0bffe17 	ldw	r2,-8(fp)
81110a8c:	10800003 	ldbu	r2,0(r2)
81110a90:	10803fcc 	andi	r2,r2,255
81110a94:	100d883a 	mov	r6,r2
81110a98:	01604574 	movhi	r5,33045
81110a9c:	29735504 	addi	r5,r5,-12972
81110aa0:	1809883a 	mov	r4,r3
81110aa4:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
81110aa8:	d0e06217 	ldw	r3,-32376(gp)
81110aac:	e0bffe17 	ldw	r2,-8(fp)
81110ab0:	10802c17 	ldw	r2,176(r2)
81110ab4:	100d883a 	mov	r6,r2
81110ab8:	01604574 	movhi	r5,33045
81110abc:	29735b04 	addi	r5,r5,-12948
81110ac0:	1809883a 	mov	r4,r3
81110ac4:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
81110ac8:	d0e06217 	ldw	r3,-32376(gp)
81110acc:	e0bffe17 	ldw	r2,-8(fp)
81110ad0:	10802117 	ldw	r2,132(r2)
81110ad4:	100d883a 	mov	r6,r2
81110ad8:	01604574 	movhi	r5,33045
81110adc:	29736104 	addi	r5,r5,-12924
81110ae0:	1809883a 	mov	r4,r3
81110ae4:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
81110ae8:	d0e06217 	ldw	r3,-32376(gp)
81110aec:	e0bffe17 	ldw	r2,-8(fp)
81110af0:	10802317 	ldw	r2,140(r2)
81110af4:	100d883a 	mov	r6,r2
81110af8:	01604574 	movhi	r5,33045
81110afc:	29736804 	addi	r5,r5,-12896
81110b00:	1809883a 	mov	r4,r3
81110b04:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
81110b08:	d0e06217 	ldw	r3,-32376(gp)
81110b0c:	e0bffe17 	ldw	r2,-8(fp)
81110b10:	10802417 	ldw	r2,144(r2)
81110b14:	100d883a 	mov	r6,r2
81110b18:	01604574 	movhi	r5,33045
81110b1c:	29736f04 	addi	r5,r5,-12868
81110b20:	1809883a 	mov	r4,r3
81110b24:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
81110b28:	d0e06217 	ldw	r3,-32376(gp)
81110b2c:	e0bffe17 	ldw	r2,-8(fp)
81110b30:	10802517 	ldw	r2,148(r2)
81110b34:	100d883a 	mov	r6,r2
81110b38:	01604574 	movhi	r5,33045
81110b3c:	29737604 	addi	r5,r5,-12840
81110b40:	1809883a 	mov	r4,r3
81110b44:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
81110b48:	d0e06217 	ldw	r3,-32376(gp)
81110b4c:	e0bffe17 	ldw	r2,-8(fp)
81110b50:	10802617 	ldw	r2,152(r2)
81110b54:	100d883a 	mov	r6,r2
81110b58:	01604574 	movhi	r5,33045
81110b5c:	29737d04 	addi	r5,r5,-12812
81110b60:	1809883a 	mov	r4,r3
81110b64:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
81110b68:	d1206217 	ldw	r4,-32376(gp)
81110b6c:	e0bffe17 	ldw	r2,-8(fp)
81110b70:	10802a43 	ldbu	r2,169(r2)
81110b74:	11403fcc 	andi	r5,r2,255
81110b78:	e0bffe17 	ldw	r2,-8(fp)
81110b7c:	10802a83 	ldbu	r2,170(r2)
81110b80:	11803fcc 	andi	r6,r2,255
81110b84:	e0bffe17 	ldw	r2,-8(fp)
81110b88:	10802ac3 	ldbu	r2,171(r2)
81110b8c:	10803fcc 	andi	r2,r2,255
81110b90:	e0fffe17 	ldw	r3,-8(fp)
81110b94:	18c02b03 	ldbu	r3,172(r3)
81110b98:	18c03fcc 	andi	r3,r3,255
81110b9c:	d8c00115 	stw	r3,4(sp)
81110ba0:	d8800015 	stw	r2,0(sp)
81110ba4:	300f883a 	mov	r7,r6
81110ba8:	280d883a 	mov	r6,r5
81110bac:	01604574 	movhi	r5,33045
81110bb0:	29738404 	addi	r5,r5,-12784
81110bb4:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
81110bb8:	d0e06217 	ldw	r3,-32376(gp)
81110bbc:	e0bffe17 	ldw	r2,-8(fp)
81110bc0:	10802e17 	ldw	r2,184(r2)
81110bc4:	100d883a 	mov	r6,r2
81110bc8:	01604574 	movhi	r5,33045
81110bcc:	29739104 	addi	r5,r5,-12732
81110bd0:	1809883a 	mov	r4,r3
81110bd4:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"\n\n");
81110bd8:	d0a06217 	ldw	r2,-32376(gp)
81110bdc:	100f883a 	mov	r7,r2
81110be0:	01800084 	movi	r6,2
81110be4:	01400044 	movi	r5,1
81110be8:	01204574 	movhi	r4,33045
81110bec:	21339704 	addi	r4,r4,-12708
81110bf0:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
81110bf4:	d0e06217 	ldw	r3,-32376(gp)
81110bf8:	e0bffe17 	ldw	r2,-8(fp)
81110bfc:	10800003 	ldbu	r2,0(r2)
81110c00:	10803fcc 	andi	r2,r2,255
81110c04:	100d883a 	mov	r6,r2
81110c08:	01604574 	movhi	r5,33045
81110c0c:	29739804 	addi	r5,r5,-12704
81110c10:	1809883a 	mov	r4,r3
81110c14:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    General Info: \n");
81110c18:	d0a06217 	ldw	r2,-32376(gp)
81110c1c:	100f883a 	mov	r7,r2
81110c20:	018004c4 	movi	r6,19
81110c24:	01400044 	movi	r5,1
81110c28:	01204574 	movhi	r4,33045
81110c2c:	21339e04 	addi	r4,r4,-12680
81110c30:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81110c34:	d0e06217 	ldw	r3,-32376(gp)
81110c38:	e0bffe17 	ldw	r2,-8(fp)
81110c3c:	10800117 	ldw	r2,4(r2)
81110c40:	100d883a 	mov	r6,r2
81110c44:	01604574 	movhi	r5,33045
81110c48:	2973a304 	addi	r5,r5,-12660
81110c4c:	1809883a 	mov	r4,r3
81110c50:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
81110c54:	d0e06217 	ldw	r3,-32376(gp)
81110c58:	e0bffe17 	ldw	r2,-8(fp)
81110c5c:	10800217 	ldw	r2,8(r2)
81110c60:	100d883a 	mov	r6,r2
81110c64:	01604574 	movhi	r5,33045
81110c68:	2973ab04 	addi	r5,r5,-12628
81110c6c:	1809883a 	mov	r4,r3
81110c70:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
81110c74:	d0e06217 	ldw	r3,-32376(gp)
81110c78:	e0bffe17 	ldw	r2,-8(fp)
81110c7c:	10800317 	ldw	r2,12(r2)
81110c80:	100d883a 	mov	r6,r2
81110c84:	01604574 	movhi	r5,33045
81110c88:	2973b304 	addi	r5,r5,-12596
81110c8c:	1809883a 	mov	r4,r3
81110c90:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
81110c94:	d0a06217 	ldw	r2,-32376(gp)
81110c98:	100f883a 	mov	r7,r2
81110c9c:	01800644 	movi	r6,25
81110ca0:	01400044 	movi	r5,1
81110ca4:	01204574 	movhi	r4,33045
81110ca8:	2133ba04 	addi	r4,r4,-12568
81110cac:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
81110cb0:	d0e06217 	ldw	r3,-32376(gp)
81110cb4:	e0bffe17 	ldw	r2,-8(fp)
81110cb8:	10800517 	ldw	r2,20(r2)
81110cbc:	100d883a 	mov	r6,r2
81110cc0:	01604574 	movhi	r5,33045
81110cc4:	2973c104 	addi	r5,r5,-12540
81110cc8:	1809883a 	mov	r4,r3
81110ccc:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
81110cd0:	d0e06217 	ldw	r3,-32376(gp)
81110cd4:	e0bffe17 	ldw	r2,-8(fp)
81110cd8:	10800417 	ldw	r2,16(r2)
81110cdc:	100d883a 	mov	r6,r2
81110ce0:	01604574 	movhi	r5,33045
81110ce4:	2973c904 	addi	r5,r5,-12508
81110ce8:	1809883a 	mov	r4,r3
81110cec:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
81110cf0:	d0e06217 	ldw	r3,-32376(gp)
81110cf4:	e0bffe17 	ldw	r2,-8(fp)
81110cf8:	10800603 	ldbu	r2,24(r2)
81110cfc:	10803fcc 	andi	r2,r2,255
81110d00:	100d883a 	mov	r6,r2
81110d04:	01604574 	movhi	r5,33045
81110d08:	2973d104 	addi	r5,r5,-12476
81110d0c:	1809883a 	mov	r4,r3
81110d10:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81110d14:	d2206217 	ldw	r8,-32376(gp)
81110d18:	e13ffe17 	ldw	r4,-8(fp)
81110d1c:	20800717 	ldw	r2,28(r4)
81110d20:	20c00817 	ldw	r3,32(r4)
81110d24:	100d883a 	mov	r6,r2
81110d28:	180f883a 	mov	r7,r3
81110d2c:	01604574 	movhi	r5,33045
81110d30:	2973d904 	addi	r5,r5,-12444
81110d34:	4009883a 	mov	r4,r8
81110d38:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"\n");
81110d3c:	d0a06217 	ldw	r2,-32376(gp)
81110d40:	100b883a 	mov	r5,r2
81110d44:	01000284 	movi	r4,10
81110d48:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
81110d4c:	d0e06217 	ldw	r3,-32376(gp)
81110d50:	e0bffe17 	ldw	r2,-8(fp)
81110d54:	10800003 	ldbu	r2,0(r2)
81110d58:	10803fcc 	andi	r2,r2,255
81110d5c:	100f883a 	mov	r7,r2
81110d60:	000d883a 	mov	r6,zero
81110d64:	01604574 	movhi	r5,33045
81110d68:	2973e104 	addi	r5,r5,-12412
81110d6c:	1809883a 	mov	r4,r3
81110d70:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Left side \n");
81110d74:	d0a06217 	ldw	r2,-32376(gp)
81110d78:	100f883a 	mov	r7,r2
81110d7c:	018004c4 	movi	r6,19
81110d80:	01400044 	movi	r5,1
81110d84:	01204574 	movhi	r4,33045
81110d88:	2133eb04 	addi	r4,r4,-12372
81110d8c:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
81110d90:	d0e06217 	ldw	r3,-32376(gp)
81110d94:	e0bffe17 	ldw	r2,-8(fp)
81110d98:	10800917 	ldw	r2,36(r2)
81110d9c:	100d883a 	mov	r6,r2
81110da0:	01604574 	movhi	r5,33045
81110da4:	2973f004 	addi	r5,r5,-12352
81110da8:	1809883a 	mov	r4,r3
81110dac:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
81110db0:	d0e06217 	ldw	r3,-32376(gp)
81110db4:	e0bffe17 	ldw	r2,-8(fp)
81110db8:	10800a17 	ldw	r2,40(r2)
81110dbc:	100d883a 	mov	r6,r2
81110dc0:	01604574 	movhi	r5,33045
81110dc4:	2973f904 	addi	r5,r5,-12316
81110dc8:	1809883a 	mov	r4,r3
81110dcc:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81110dd0:	d0e06217 	ldw	r3,-32376(gp)
81110dd4:	e0bffe17 	ldw	r2,-8(fp)
81110dd8:	10800b17 	ldw	r2,44(r2)
81110ddc:	100d883a 	mov	r6,r2
81110de0:	01604574 	movhi	r5,33045
81110de4:	29740404 	addi	r5,r5,-12272
81110de8:	1809883a 	mov	r4,r3
81110dec:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Right side \n");
81110df0:	d0a06217 	ldw	r2,-32376(gp)
81110df4:	100f883a 	mov	r7,r2
81110df8:	01800504 	movi	r6,20
81110dfc:	01400044 	movi	r5,1
81110e00:	01204574 	movhi	r4,33045
81110e04:	21341004 	addi	r4,r4,-12224
81110e08:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
81110e0c:	d0e06217 	ldw	r3,-32376(gp)
81110e10:	e0bffe17 	ldw	r2,-8(fp)
81110e14:	10800c17 	ldw	r2,48(r2)
81110e18:	100d883a 	mov	r6,r2
81110e1c:	01604574 	movhi	r5,33045
81110e20:	2973f004 	addi	r5,r5,-12352
81110e24:	1809883a 	mov	r4,r3
81110e28:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
81110e2c:	d0e06217 	ldw	r3,-32376(gp)
81110e30:	e0bffe17 	ldw	r2,-8(fp)
81110e34:	10800d17 	ldw	r2,52(r2)
81110e38:	100d883a 	mov	r6,r2
81110e3c:	01604574 	movhi	r5,33045
81110e40:	2973f904 	addi	r5,r5,-12316
81110e44:	1809883a 	mov	r4,r3
81110e48:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
81110e4c:	d0e06217 	ldw	r3,-32376(gp)
81110e50:	e0bffe17 	ldw	r2,-8(fp)
81110e54:	10800e17 	ldw	r2,56(r2)
81110e58:	100d883a 	mov	r6,r2
81110e5c:	01604574 	movhi	r5,33045
81110e60:	29740404 	addi	r5,r5,-12272
81110e64:	1809883a 	mov	r4,r3
81110e68:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"\n");
81110e6c:	d0a06217 	ldw	r2,-32376(gp)
81110e70:	100b883a 	mov	r5,r2
81110e74:	01000284 	movi	r4,10
81110e78:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
81110e7c:	d0e06217 	ldw	r3,-32376(gp)
81110e80:	e0bffe17 	ldw	r2,-8(fp)
81110e84:	10800003 	ldbu	r2,0(r2)
81110e88:	10803fcc 	andi	r2,r2,255
81110e8c:	100f883a 	mov	r7,r2
81110e90:	01800044 	movi	r6,1
81110e94:	01604574 	movhi	r5,33045
81110e98:	2973e104 	addi	r5,r5,-12412
81110e9c:	1809883a 	mov	r4,r3
81110ea0:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Left side \n");
81110ea4:	d0a06217 	ldw	r2,-32376(gp)
81110ea8:	100f883a 	mov	r7,r2
81110eac:	018004c4 	movi	r6,19
81110eb0:	01400044 	movi	r5,1
81110eb4:	01204574 	movhi	r4,33045
81110eb8:	2133eb04 	addi	r4,r4,-12372
81110ebc:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81110ec0:	d0e06217 	ldw	r3,-32376(gp)
81110ec4:	e0bffe17 	ldw	r2,-8(fp)
81110ec8:	10800f17 	ldw	r2,60(r2)
81110ecc:	100d883a 	mov	r6,r2
81110ed0:	01604574 	movhi	r5,33045
81110ed4:	2973f004 	addi	r5,r5,-12352
81110ed8:	1809883a 	mov	r4,r3
81110edc:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81110ee0:	d0e06217 	ldw	r3,-32376(gp)
81110ee4:	e0bffe17 	ldw	r2,-8(fp)
81110ee8:	10801017 	ldw	r2,64(r2)
81110eec:	100d883a 	mov	r6,r2
81110ef0:	01604574 	movhi	r5,33045
81110ef4:	2973f904 	addi	r5,r5,-12316
81110ef8:	1809883a 	mov	r4,r3
81110efc:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81110f00:	d0e06217 	ldw	r3,-32376(gp)
81110f04:	e0bffe17 	ldw	r2,-8(fp)
81110f08:	10801117 	ldw	r2,68(r2)
81110f0c:	100d883a 	mov	r6,r2
81110f10:	01604574 	movhi	r5,33045
81110f14:	29740404 	addi	r5,r5,-12272
81110f18:	1809883a 	mov	r4,r3
81110f1c:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Right side \n");
81110f20:	d0a06217 	ldw	r2,-32376(gp)
81110f24:	100f883a 	mov	r7,r2
81110f28:	01800504 	movi	r6,20
81110f2c:	01400044 	movi	r5,1
81110f30:	01204574 	movhi	r4,33045
81110f34:	21341004 	addi	r4,r4,-12224
81110f38:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
81110f3c:	d0e06217 	ldw	r3,-32376(gp)
81110f40:	e0bffe17 	ldw	r2,-8(fp)
81110f44:	10801217 	ldw	r2,72(r2)
81110f48:	100d883a 	mov	r6,r2
81110f4c:	01604574 	movhi	r5,33045
81110f50:	2973f004 	addi	r5,r5,-12352
81110f54:	1809883a 	mov	r4,r3
81110f58:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
81110f5c:	d0e06217 	ldw	r3,-32376(gp)
81110f60:	e0bffe17 	ldw	r2,-8(fp)
81110f64:	10801317 	ldw	r2,76(r2)
81110f68:	100d883a 	mov	r6,r2
81110f6c:	01604574 	movhi	r5,33045
81110f70:	2973f904 	addi	r5,r5,-12316
81110f74:	1809883a 	mov	r4,r3
81110f78:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
81110f7c:	d0e06217 	ldw	r3,-32376(gp)
81110f80:	e0bffe17 	ldw	r2,-8(fp)
81110f84:	10801417 	ldw	r2,80(r2)
81110f88:	100d883a 	mov	r6,r2
81110f8c:	01604574 	movhi	r5,33045
81110f90:	29740404 	addi	r5,r5,-12272
81110f94:	1809883a 	mov	r4,r3
81110f98:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"\n");
81110f9c:	d0a06217 	ldw	r2,-32376(gp)
81110fa0:	100b883a 	mov	r5,r2
81110fa4:	01000284 	movi	r4,10
81110fa8:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
81110fac:	d0e06217 	ldw	r3,-32376(gp)
81110fb0:	e0bffe17 	ldw	r2,-8(fp)
81110fb4:	10800003 	ldbu	r2,0(r2)
81110fb8:	10803fcc 	andi	r2,r2,255
81110fbc:	100f883a 	mov	r7,r2
81110fc0:	01800084 	movi	r6,2
81110fc4:	01604574 	movhi	r5,33045
81110fc8:	2973e104 	addi	r5,r5,-12412
81110fcc:	1809883a 	mov	r4,r3
81110fd0:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Left side \n");
81110fd4:	d0a06217 	ldw	r2,-32376(gp)
81110fd8:	100f883a 	mov	r7,r2
81110fdc:	018004c4 	movi	r6,19
81110fe0:	01400044 	movi	r5,1
81110fe4:	01204574 	movhi	r4,33045
81110fe8:	2133eb04 	addi	r4,r4,-12372
81110fec:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81110ff0:	d0e06217 	ldw	r3,-32376(gp)
81110ff4:	e0bffe17 	ldw	r2,-8(fp)
81110ff8:	10801517 	ldw	r2,84(r2)
81110ffc:	100d883a 	mov	r6,r2
81111000:	01604574 	movhi	r5,33045
81111004:	2973f004 	addi	r5,r5,-12352
81111008:	1809883a 	mov	r4,r3
8111100c:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81111010:	d0e06217 	ldw	r3,-32376(gp)
81111014:	e0bffe17 	ldw	r2,-8(fp)
81111018:	10801617 	ldw	r2,88(r2)
8111101c:	100d883a 	mov	r6,r2
81111020:	01604574 	movhi	r5,33045
81111024:	2973f904 	addi	r5,r5,-12316
81111028:	1809883a 	mov	r4,r3
8111102c:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81111030:	d0e06217 	ldw	r3,-32376(gp)
81111034:	e0bffe17 	ldw	r2,-8(fp)
81111038:	10801717 	ldw	r2,92(r2)
8111103c:	100d883a 	mov	r6,r2
81111040:	01604574 	movhi	r5,33045
81111044:	29740404 	addi	r5,r5,-12272
81111048:	1809883a 	mov	r4,r3
8111104c:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Right side \n");
81111050:	d0a06217 	ldw	r2,-32376(gp)
81111054:	100f883a 	mov	r7,r2
81111058:	01800504 	movi	r6,20
8111105c:	01400044 	movi	r5,1
81111060:	01204574 	movhi	r4,33045
81111064:	21341004 	addi	r4,r4,-12224
81111068:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
8111106c:	d0e06217 	ldw	r3,-32376(gp)
81111070:	e0bffe17 	ldw	r2,-8(fp)
81111074:	10801817 	ldw	r2,96(r2)
81111078:	100d883a 	mov	r6,r2
8111107c:	01604574 	movhi	r5,33045
81111080:	2973f004 	addi	r5,r5,-12352
81111084:	1809883a 	mov	r4,r3
81111088:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
8111108c:	d0e06217 	ldw	r3,-32376(gp)
81111090:	e0bffe17 	ldw	r2,-8(fp)
81111094:	10801917 	ldw	r2,100(r2)
81111098:	100d883a 	mov	r6,r2
8111109c:	01604574 	movhi	r5,33045
811110a0:	2973f904 	addi	r5,r5,-12316
811110a4:	1809883a 	mov	r4,r3
811110a8:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
811110ac:	d0e06217 	ldw	r3,-32376(gp)
811110b0:	e0bffe17 	ldw	r2,-8(fp)
811110b4:	10801a17 	ldw	r2,104(r2)
811110b8:	100d883a 	mov	r6,r2
811110bc:	01604574 	movhi	r5,33045
811110c0:	29740404 	addi	r5,r5,-12272
811110c4:	1809883a 	mov	r4,r3
811110c8:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"\n");
811110cc:	d0a06217 	ldw	r2,-32376(gp)
811110d0:	100b883a 	mov	r5,r2
811110d4:	01000284 	movi	r4,10
811110d8:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
811110dc:	d0e06217 	ldw	r3,-32376(gp)
811110e0:	e0bffe17 	ldw	r2,-8(fp)
811110e4:	10800003 	ldbu	r2,0(r2)
811110e8:	10803fcc 	andi	r2,r2,255
811110ec:	100f883a 	mov	r7,r2
811110f0:	018000c4 	movi	r6,3
811110f4:	01604574 	movhi	r5,33045
811110f8:	2973e104 	addi	r5,r5,-12412
811110fc:	1809883a 	mov	r4,r3
81111100:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Left side \n");
81111104:	d0a06217 	ldw	r2,-32376(gp)
81111108:	100f883a 	mov	r7,r2
8111110c:	018004c4 	movi	r6,19
81111110:	01400044 	movi	r5,1
81111114:	01204574 	movhi	r4,33045
81111118:	2133eb04 	addi	r4,r4,-12372
8111111c:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
81111120:	d0e06217 	ldw	r3,-32376(gp)
81111124:	e0bffe17 	ldw	r2,-8(fp)
81111128:	10801b17 	ldw	r2,108(r2)
8111112c:	100d883a 	mov	r6,r2
81111130:	01604574 	movhi	r5,33045
81111134:	2973f004 	addi	r5,r5,-12352
81111138:	1809883a 	mov	r4,r3
8111113c:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
81111140:	d0e06217 	ldw	r3,-32376(gp)
81111144:	e0bffe17 	ldw	r2,-8(fp)
81111148:	10801c17 	ldw	r2,112(r2)
8111114c:	100d883a 	mov	r6,r2
81111150:	01604574 	movhi	r5,33045
81111154:	2973f904 	addi	r5,r5,-12316
81111158:	1809883a 	mov	r4,r3
8111115c:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
81111160:	d0e06217 	ldw	r3,-32376(gp)
81111164:	e0bffe17 	ldw	r2,-8(fp)
81111168:	10801d17 	ldw	r2,116(r2)
8111116c:	100d883a 	mov	r6,r2
81111170:	01604574 	movhi	r5,33045
81111174:	29740404 	addi	r5,r5,-12272
81111178:	1809883a 	mov	r4,r3
8111117c:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"        Right side \n");
81111180:	d0a06217 	ldw	r2,-32376(gp)
81111184:	100f883a 	mov	r7,r2
81111188:	01800504 	movi	r6,20
8111118c:	01400044 	movi	r5,1
81111190:	01204574 	movhi	r4,33045
81111194:	21341004 	addi	r4,r4,-12224
81111198:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
8111119c:	d0e06217 	ldw	r3,-32376(gp)
811111a0:	e0bffe17 	ldw	r2,-8(fp)
811111a4:	10801e17 	ldw	r2,120(r2)
811111a8:	100d883a 	mov	r6,r2
811111ac:	01604574 	movhi	r5,33045
811111b0:	2973f004 	addi	r5,r5,-12352
811111b4:	1809883a 	mov	r4,r3
811111b8:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
811111bc:	d0e06217 	ldw	r3,-32376(gp)
811111c0:	e0bffe17 	ldw	r2,-8(fp)
811111c4:	10801f17 	ldw	r2,124(r2)
811111c8:	100d883a 	mov	r6,r2
811111cc:	01604574 	movhi	r5,33045
811111d0:	2973f904 	addi	r5,r5,-12316
811111d4:	1809883a 	mov	r4,r3
811111d8:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
811111dc:	d0e06217 	ldw	r3,-32376(gp)
811111e0:	e0bffe17 	ldw	r2,-8(fp)
811111e4:	10802017 	ldw	r2,128(r2)
811111e8:	100d883a 	mov	r6,r2
811111ec:	01604574 	movhi	r5,33045
811111f0:	29740404 	addi	r5,r5,-12272
811111f4:	1809883a 	mov	r4,r3
811111f8:	11213440 	call	81121344 <fprintf>
		fprintf(fp,"\n");
811111fc:	d0a06217 	ldw	r2,-32376(gp)
81111200:	100b883a 	mov	r5,r2
81111204:	01000284 	movi	r4,10
81111208:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"==============================================================================\n");
8111120c:	d0a06217 	ldw	r2,-32376(gp)
81111210:	100f883a 	mov	r7,r2
81111214:	018013c4 	movi	r6,79
81111218:	01400044 	movi	r5,1
8111121c:	01204574 	movhi	r4,33045
81111220:	21341604 	addi	r4,r4,-12200
81111224:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"==============================================================================\n");
81111228:	d0a06217 	ldw	r2,-32376(gp)
8111122c:	100f883a 	mov	r7,r2
81111230:	018013c4 	movi	r6,79
81111234:	01400044 	movi	r5,1
81111238:	01204574 	movhi	r4,33045
8111123c:	21341604 	addi	r4,r4,-12200
81111240:	11219e00 	call	811219e0 <fwrite>
		fprintf(fp,"\n");
81111244:	d0a06217 	ldw	r2,-32376(gp)
81111248:	100b883a 	mov	r5,r2
8111124c:	01000284 	movi	r4,10
81111250:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"\n");
81111254:	d0a06217 	ldw	r2,-32376(gp)
81111258:	100b883a 	mov	r5,r2
8111125c:	01000284 	movi	r4,10
81111260:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"\n");
81111264:	d0a06217 	ldw	r2,-32376(gp)
81111268:	100b883a 	mov	r5,r2
8111126c:	01000284 	movi	r4,10
81111270:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"\n");
81111274:	d0a06217 	ldw	r2,-32376(gp)
81111278:	100b883a 	mov	r5,r2
8111127c:	01000284 	movi	r4,10
81111280:	11213bc0 	call	811213bc <fputc>
		fprintf(fp,"\n");
81111284:	d0a06217 	ldw	r2,-32376(gp)
81111288:	100b883a 	mov	r5,r2
8111128c:	01000284 	movi	r4,10
81111290:	11213bc0 	call	811213bc <fputc>
	}
81111294:	0001883a 	nop
81111298:	e037883a 	mov	sp,fp
8111129c:	dfc00117 	ldw	ra,4(sp)
811112a0:	df000017 	ldw	fp,0(sp)
811112a4:	dec00204 	addi	sp,sp,8
811112a8:	f800283a 	ret

811112ac <bPrepareDoubleBuffer>:

*/



bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID, TNFee *pxNFee ) {
811112ac:	defff804 	addi	sp,sp,-32
811112b0:	de00012e 	bgeu	sp,et,811112b8 <bPrepareDoubleBuffer+0xc>
811112b4:	003b68fa 	trap	3
811112b8:	dfc00715 	stw	ra,28(sp)
811112bc:	df000615 	stw	fp,24(sp)
811112c0:	df000604 	addi	fp,sp,24
811112c4:	e13ffc15 	stw	r4,-16(fp)
811112c8:	2807883a 	mov	r3,r5
811112cc:	3005883a 	mov	r2,r6
811112d0:	e1ffff15 	stw	r7,-4(fp)
811112d4:	e0fffd05 	stb	r3,-12(fp)
811112d8:	e0bffe05 	stb	r2,-8(fp)
	bool  bDmaReturn;
	unsigned long ulLengthBlocks;

	bDmaReturn = FALSE;
811112dc:	e03ffa15 	stw	zero,-24(fp)
	xCcdMapLocal->ulBlockI = 0;
811112e0:	e0bffc17 	ldw	r2,-16(fp)
811112e4:	10000115 	stw	zero,4(r2)
	xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
811112e8:	e0bffc17 	ldw	r2,-16(fp)
811112ec:	10c00017 	ldw	r3,0(r2)
811112f0:	e0bffc17 	ldw	r2,-16(fp)
811112f4:	10c00215 	stw	r3,8(r2)


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
811112f8:	e0bffc17 	ldw	r2,-16(fp)
811112fc:	10800117 	ldw	r2,4(r2)
81111300:	10c00404 	addi	r3,r2,16
81111304:	e0bfff17 	ldw	r2,-4(fp)
81111308:	10800417 	ldw	r2,16(r2)
8111130c:	18800736 	bltu	r3,r2,8111132c <bPrepareDoubleBuffer+0x80>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
81111310:	e0bfff17 	ldw	r2,-4(fp)
81111314:	10c00417 	ldw	r3,16(r2)
81111318:	e0bffc17 	ldw	r2,-16(fp)
8111131c:	10800117 	ldw	r2,4(r2)
81111320:	1885c83a 	sub	r2,r3,r2
81111324:	e0bffb15 	stw	r2,-20(fp)
81111328:	00000206 	br	81111334 <bPrepareDoubleBuffer+0x88>

	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
8111132c:	00800404 	movi	r2,16
81111330:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
81111334:	00a045b4 	movhi	r2,33046
81111338:	109ade04 	addi	r2,r2,27512
8111133c:	1080100b 	ldhu	r2,64(r2)
81111340:	10bfffcc 	andi	r2,r2,65535
81111344:	10000b1e 	bne	r2,zero,81111374 <bPrepareDoubleBuffer+0xc8>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
81111348:	e0bffb17 	ldw	r2,-20(fp)
8111134c:	10803fcc 	andi	r2,r2,255
81111350:	000b883a 	mov	r5,zero
81111354:	1009883a 	mov	r4,r2
81111358:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
8111135c:	e0bffb17 	ldw	r2,-20(fp)
81111360:	10803fcc 	andi	r2,r2,255
81111364:	01400044 	movi	r5,1
81111368:	1009883a 	mov	r4,r2
8111136c:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
81111370:	00000a06 	br	8111139c <bPrepareDoubleBuffer+0xf0>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
81111374:	e0bffb17 	ldw	r2,-20(fp)
81111378:	10803fcc 	andi	r2,r2,255
8111137c:	000b883a 	mov	r5,zero
81111380:	1009883a 	mov	r4,r2
81111384:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
81111388:	e0bffb17 	ldw	r2,-20(fp)
8111138c:	10803fcc 	andi	r2,r2,255
81111390:	01400044 	movi	r5,1
81111394:	1009883a 	mov	r4,r2
81111398:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>


	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,0);
	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,1);

	if (  ucMem == 0  ) {
8111139c:	e0bffd03 	ldbu	r2,-12(fp)
811113a0:	1000231e 	bne	r2,zero,81111430 <bPrepareDoubleBuffer+0x184>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
811113a4:	e0bffc17 	ldw	r2,-16(fp)
811113a8:	10800217 	ldw	r2,8(r2)
811113ac:	1011883a 	mov	r8,r2
811113b0:	e0bffb17 	ldw	r2,-20(fp)
811113b4:	10ffffcc 	andi	r3,r2,65535
811113b8:	d0a05603 	ldbu	r2,-32424(gp)
811113bc:	11003fcc 	andi	r4,r2,255
811113c0:	e0bfff17 	ldw	r2,-4(fp)
811113c4:	10800043 	ldbu	r2,1(r2)
811113c8:	10803fcc 	andi	r2,r2,255
811113cc:	100f883a 	mov	r7,r2
811113d0:	200d883a 	mov	r6,r4
811113d4:	180b883a 	mov	r5,r3
811113d8:	4009883a 	mov	r4,r8
811113dc:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
811113e0:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
811113e4:	e0bffa17 	ldw	r2,-24(fp)
811113e8:	10800058 	cmpnei	r2,r2,1
811113ec:	10000e1e 	bne	r2,zero,81111428 <bPrepareDoubleBuffer+0x17c>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
811113f0:	e0bffc17 	ldw	r2,-16(fp)
811113f4:	10c00217 	ldw	r3,8(r2)
811113f8:	e0bffb17 	ldw	r2,-20(fp)
811113fc:	10802224 	muli	r2,r2,136
81111400:	1887883a 	add	r3,r3,r2
81111404:	e0bffc17 	ldw	r2,-16(fp)
81111408:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
8111140c:	e0bffc17 	ldw	r2,-16(fp)
81111410:	10c00117 	ldw	r3,4(r2)
81111414:	e0bffb17 	ldw	r2,-20(fp)
81111418:	1887883a 	add	r3,r3,r2
8111141c:	e0bffc17 	ldw	r2,-16(fp)
81111420:	10c00115 	stw	r3,4(r2)
81111424:	00002506 	br	811114bc <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
81111428:	e0bffa17 	ldw	r2,-24(fp)
8111142c:	00009506 	br	81111684 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111430:	e0bffc17 	ldw	r2,-16(fp)
81111434:	10800217 	ldw	r2,8(r2)
81111438:	1011883a 	mov	r8,r2
8111143c:	e0bffb17 	ldw	r2,-20(fp)
81111440:	10ffffcc 	andi	r3,r2,65535
81111444:	d0a05603 	ldbu	r2,-32424(gp)
81111448:	11003fcc 	andi	r4,r2,255
8111144c:	e0bfff17 	ldw	r2,-4(fp)
81111450:	10800043 	ldbu	r2,1(r2)
81111454:	10803fcc 	andi	r2,r2,255
81111458:	100f883a 	mov	r7,r2
8111145c:	200d883a 	mov	r6,r4
81111460:	180b883a 	mov	r5,r3
81111464:	4009883a 	mov	r4,r8
81111468:	11040ec0 	call	811040ec <bSdmaDmaM2Transfer>
8111146c:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111470:	e0bffa17 	ldw	r2,-24(fp)
81111474:	10800058 	cmpnei	r2,r2,1
81111478:	10000e1e 	bne	r2,zero,811114b4 <bPrepareDoubleBuffer+0x208>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
8111147c:	e0bffc17 	ldw	r2,-16(fp)
81111480:	10c00217 	ldw	r3,8(r2)
81111484:	e0bffb17 	ldw	r2,-20(fp)
81111488:	10802224 	muli	r2,r2,136
8111148c:	1887883a 	add	r3,r3,r2
81111490:	e0bffc17 	ldw	r2,-16(fp)
81111494:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
81111498:	e0bffc17 	ldw	r2,-16(fp)
8111149c:	10c00117 	ldw	r3,4(r2)
811114a0:	e0bffb17 	ldw	r2,-20(fp)
811114a4:	1887883a 	add	r3,r3,r2
811114a8:	e0bffc17 	ldw	r2,-16(fp)
811114ac:	10c00115 	stw	r3,4(r2)
811114b0:	00000206 	br	811114bc <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
811114b4:	e0bffa17 	ldw	r2,-24(fp)
811114b8:	00007206 	br	81111684 <bPrepareDoubleBuffer+0x3d8>
	}


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
811114bc:	e0bffc17 	ldw	r2,-16(fp)
811114c0:	10800117 	ldw	r2,4(r2)
811114c4:	10c00404 	addi	r3,r2,16
811114c8:	e0bfff17 	ldw	r2,-4(fp)
811114cc:	10800417 	ldw	r2,16(r2)
811114d0:	18800736 	bltu	r3,r2,811114f0 <bPrepareDoubleBuffer+0x244>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
811114d4:	e0bfff17 	ldw	r2,-4(fp)
811114d8:	10c00417 	ldw	r3,16(r2)
811114dc:	e0bffc17 	ldw	r2,-16(fp)
811114e0:	10800117 	ldw	r2,4(r2)
811114e4:	1885c83a 	sub	r2,r3,r2
811114e8:	e0bffb15 	stw	r2,-20(fp)
811114ec:	00000206 	br	811114f8 <bPrepareDoubleBuffer+0x24c>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
811114f0:	00800404 	movi	r2,16
811114f4:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
811114f8:	00a045b4 	movhi	r2,33046
811114fc:	109ade04 	addi	r2,r2,27512
81111500:	1080100b 	ldhu	r2,64(r2)
81111504:	10bfffcc 	andi	r2,r2,65535
81111508:	10000b1e 	bne	r2,zero,81111538 <bPrepareDoubleBuffer+0x28c>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
8111150c:	e0bffb17 	ldw	r2,-20(fp)
81111510:	10803fcc 	andi	r2,r2,255
81111514:	000b883a 	mov	r5,zero
81111518:	1009883a 	mov	r4,r2
8111151c:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
81111520:	e0bffb17 	ldw	r2,-20(fp)
81111524:	10803fcc 	andi	r2,r2,255
81111528:	01400044 	movi	r5,1
8111152c:	1009883a 	mov	r4,r2
81111530:	11059780 	call	81105978 <bFeebCh1SetBufferSize>
81111534:	00000a06 	br	81111560 <bPrepareDoubleBuffer+0x2b4>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
81111538:	e0bffb17 	ldw	r2,-20(fp)
8111153c:	10803fcc 	andi	r2,r2,255
81111540:	000b883a 	mov	r5,zero
81111544:	1009883a 	mov	r4,r2
81111548:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
8111154c:	e0bffb17 	ldw	r2,-20(fp)
81111550:	10803fcc 	andi	r2,r2,255
81111554:	01400044 	movi	r5,1
81111558:	1009883a 	mov	r4,r2
8111155c:	1105a4c0 	call	81105a4c <bFeebCh2SetBufferSize>

	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,0);
	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,1);


	if (  ucMem == 0  ) {
81111560:	e0bffd03 	ldbu	r2,-12(fp)
81111564:	1000231e 	bne	r2,zero,811115f4 <bPrepareDoubleBuffer+0x348>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
81111568:	e0bffc17 	ldw	r2,-16(fp)
8111156c:	10800217 	ldw	r2,8(r2)
81111570:	1011883a 	mov	r8,r2
81111574:	e0bffb17 	ldw	r2,-20(fp)
81111578:	10ffffcc 	andi	r3,r2,65535
8111157c:	d0a05603 	ldbu	r2,-32424(gp)
81111580:	11003fcc 	andi	r4,r2,255
81111584:	e0bfff17 	ldw	r2,-4(fp)
81111588:	10800043 	ldbu	r2,1(r2)
8111158c:	10803fcc 	andi	r2,r2,255
81111590:	100f883a 	mov	r7,r2
81111594:	200d883a 	mov	r6,r4
81111598:	180b883a 	mov	r5,r3
8111159c:	4009883a 	mov	r4,r8
811115a0:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
811115a4:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
811115a8:	e0bffa17 	ldw	r2,-24(fp)
811115ac:	10800058 	cmpnei	r2,r2,1
811115b0:	10000e1e 	bne	r2,zero,811115ec <bPrepareDoubleBuffer+0x340>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
811115b4:	e0bffc17 	ldw	r2,-16(fp)
811115b8:	10c00217 	ldw	r3,8(r2)
811115bc:	e0bffb17 	ldw	r2,-20(fp)
811115c0:	10802224 	muli	r2,r2,136
811115c4:	1887883a 	add	r3,r3,r2
811115c8:	e0bffc17 	ldw	r2,-16(fp)
811115cc:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
811115d0:	e0bffc17 	ldw	r2,-16(fp)
811115d4:	10c00117 	ldw	r3,4(r2)
811115d8:	e0bffb17 	ldw	r2,-20(fp)
811115dc:	1887883a 	add	r3,r3,r2
811115e0:	e0bffc17 	ldw	r2,-16(fp)
811115e4:	10c00115 	stw	r3,4(r2)
811115e8:	00002506 	br	81111680 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
811115ec:	e0bffa17 	ldw	r2,-24(fp)
811115f0:	00002406 	br	81111684 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
811115f4:	e0bffc17 	ldw	r2,-16(fp)
811115f8:	10800217 	ldw	r2,8(r2)
811115fc:	1011883a 	mov	r8,r2
81111600:	e0bffb17 	ldw	r2,-20(fp)
81111604:	10ffffcc 	andi	r3,r2,65535
81111608:	d0a05603 	ldbu	r2,-32424(gp)
8111160c:	11003fcc 	andi	r4,r2,255
81111610:	e0bfff17 	ldw	r2,-4(fp)
81111614:	10800043 	ldbu	r2,1(r2)
81111618:	10803fcc 	andi	r2,r2,255
8111161c:	100f883a 	mov	r7,r2
81111620:	200d883a 	mov	r6,r4
81111624:	180b883a 	mov	r5,r3
81111628:	4009883a 	mov	r4,r8
8111162c:	11040ec0 	call	811040ec <bSdmaDmaM2Transfer>
81111630:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
81111634:	e0bffa17 	ldw	r2,-24(fp)
81111638:	10800058 	cmpnei	r2,r2,1
8111163c:	10000e1e 	bne	r2,zero,81111678 <bPrepareDoubleBuffer+0x3cc>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
81111640:	e0bffc17 	ldw	r2,-16(fp)
81111644:	10c00217 	ldw	r3,8(r2)
81111648:	e0bffb17 	ldw	r2,-20(fp)
8111164c:	10802224 	muli	r2,r2,136
81111650:	1887883a 	add	r3,r3,r2
81111654:	e0bffc17 	ldw	r2,-16(fp)
81111658:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
8111165c:	e0bffc17 	ldw	r2,-16(fp)
81111660:	10c00117 	ldw	r3,4(r2)
81111664:	e0bffb17 	ldw	r2,-20(fp)
81111668:	1887883a 	add	r3,r3,r2
8111166c:	e0bffc17 	ldw	r2,-16(fp)
81111670:	10c00115 	stw	r3,4(r2)
81111674:	00000206 	br	81111680 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
81111678:	e0bffa17 	ldw	r2,-24(fp)
8111167c:	00000106 	br	81111684 <bPrepareDoubleBuffer+0x3d8>
	}

	return bDmaReturn;
81111680:	e0bffa17 	ldw	r2,-24(fp)

}
81111684:	e037883a 	mov	sp,fp
81111688:	dfc00117 	ldw	ra,4(sp)
8111168c:	df000017 	ldw	fp,0(sp)
81111690:	dec00204 	addi	sp,sp,8
81111694:	f800283a 	ret

81111698 <vLoadCtemp>:


void vLoadCtemp(void) {
81111698:	deffff04 	addi	sp,sp,-4
8111169c:	de00012e 	bgeu	sp,et,811116a4 <vLoadCtemp+0xc>
811116a0:	003b68fa 	trap	3
811116a4:	df000015 	stw	fp,0(sp)
811116a8:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
811116ac:	00a04574 	movhi	r2,33045
811116b0:	108e8004 	addi	r2,r2,14848
811116b4:	00e04574 	movhi	r3,33045
811116b8:	18f42a04 	addi	r3,r3,-12120
811116bc:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
811116c0:	00a04574 	movhi	r2,33045
811116c4:	108e8004 	addi	r2,r2,14848
811116c8:	00e04574 	movhi	r3,33045
811116cc:	18f42e04 	addi	r3,r3,-12104
811116d0:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
811116d4:	00a04574 	movhi	r2,33045
811116d8:	108e8004 	addi	r2,r2,14848
811116dc:	00e04574 	movhi	r3,33045
811116e0:	18f43204 	addi	r3,r3,-12088
811116e4:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
811116e8:	00a04574 	movhi	r2,33045
811116ec:	108e8004 	addi	r2,r2,14848
811116f0:	00e04574 	movhi	r3,33045
811116f4:	18f43604 	addi	r3,r3,-12072
811116f8:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
811116fc:	00a04574 	movhi	r2,33045
81111700:	108e8004 	addi	r2,r2,14848
81111704:	00e04574 	movhi	r3,33045
81111708:	18f43a04 	addi	r3,r3,-12056
8111170c:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
81111710:	00a04574 	movhi	r2,33045
81111714:	108e8004 	addi	r2,r2,14848
81111718:	00e04574 	movhi	r3,33045
8111171c:	18f43e04 	addi	r3,r3,-12040
81111720:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
81111724:	00a04574 	movhi	r2,33045
81111728:	108e8004 	addi	r2,r2,14848
8111172c:	00e04574 	movhi	r3,33045
81111730:	18f44204 	addi	r3,r3,-12024
81111734:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
81111738:	00a04574 	movhi	r2,33045
8111173c:	108e8004 	addi	r2,r2,14848
81111740:	00e04574 	movhi	r3,33045
81111744:	18f44604 	addi	r3,r3,-12008
81111748:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
8111174c:	00a04574 	movhi	r2,33045
81111750:	108e8004 	addi	r2,r2,14848
81111754:	00e04574 	movhi	r3,33045
81111758:	18f44a04 	addi	r3,r3,-11992
8111175c:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
81111760:	00a04574 	movhi	r2,33045
81111764:	108e8004 	addi	r2,r2,14848
81111768:	00e04574 	movhi	r3,33045
8111176c:	18f44e04 	addi	r3,r3,-11976
81111770:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
81111774:	00a04574 	movhi	r2,33045
81111778:	108e8004 	addi	r2,r2,14848
8111177c:	00e04574 	movhi	r3,33045
81111780:	18f45204 	addi	r3,r3,-11960
81111784:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
81111788:	00a04574 	movhi	r2,33045
8111178c:	108e8004 	addi	r2,r2,14848
81111790:	00e04574 	movhi	r3,33045
81111794:	18f45604 	addi	r3,r3,-11944
81111798:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
8111179c:	00a04574 	movhi	r2,33045
811117a0:	108e8004 	addi	r2,r2,14848
811117a4:	00e04574 	movhi	r3,33045
811117a8:	18f45a04 	addi	r3,r3,-11928
811117ac:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
811117b0:	00a04574 	movhi	r2,33045
811117b4:	108e8004 	addi	r2,r2,14848
811117b8:	00e04574 	movhi	r3,33045
811117bc:	18f45d04 	addi	r3,r3,-11916
811117c0:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
811117c4:	00a04574 	movhi	r2,33045
811117c8:	108e8004 	addi	r2,r2,14848
811117cc:	00e04574 	movhi	r3,33045
811117d0:	18f46004 	addi	r3,r3,-11904
811117d4:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
811117d8:	00a04574 	movhi	r2,33045
811117dc:	108e8004 	addi	r2,r2,14848
811117e0:	00e04574 	movhi	r3,33045
811117e4:	18f46304 	addi	r3,r3,-11892
811117e8:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
811117ec:	00a04574 	movhi	r2,33045
811117f0:	108e8004 	addi	r2,r2,14848
811117f4:	00e04574 	movhi	r3,33045
811117f8:	18f46704 	addi	r3,r3,-11876
811117fc:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
81111800:	00a04574 	movhi	r2,33045
81111804:	108e8004 	addi	r2,r2,14848
81111808:	00e04574 	movhi	r3,33045
8111180c:	18f46a04 	addi	r3,r3,-11864
81111810:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
81111814:	00a04574 	movhi	r2,33045
81111818:	108e8004 	addi	r2,r2,14848
8111181c:	00e04574 	movhi	r3,33045
81111820:	18f46d04 	addi	r3,r3,-11852
81111824:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
81111828:	00a04574 	movhi	r2,33045
8111182c:	108e8004 	addi	r2,r2,14848
81111830:	00e04574 	movhi	r3,33045
81111834:	18f47104 	addi	r3,r3,-11836
81111838:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
8111183c:	00a04574 	movhi	r2,33045
81111840:	108e8004 	addi	r2,r2,14848
81111844:	00e04574 	movhi	r3,33045
81111848:	18f47504 	addi	r3,r3,-11820
8111184c:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
81111850:	00a04574 	movhi	r2,33045
81111854:	108e8004 	addi	r2,r2,14848
81111858:	00e04574 	movhi	r3,33045
8111185c:	18f47904 	addi	r3,r3,-11804
81111860:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
81111864:	00a04574 	movhi	r2,33045
81111868:	108e8004 	addi	r2,r2,14848
8111186c:	00e04574 	movhi	r3,33045
81111870:	18f47d04 	addi	r3,r3,-11788
81111874:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
81111878:	00a04574 	movhi	r2,33045
8111187c:	108e8004 	addi	r2,r2,14848
81111880:	00e04574 	movhi	r3,33045
81111884:	18f48104 	addi	r3,r3,-11772
81111888:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
8111188c:	00a04574 	movhi	r2,33045
81111890:	108e8004 	addi	r2,r2,14848
81111894:	00e04574 	movhi	r3,33045
81111898:	18f48404 	addi	r3,r3,-11760
8111189c:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
811118a0:	00a04574 	movhi	r2,33045
811118a4:	108e8004 	addi	r2,r2,14848
811118a8:	00e04574 	movhi	r3,33045
811118ac:	18f48804 	addi	r3,r3,-11744
811118b0:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
811118b4:	00a04574 	movhi	r2,33045
811118b8:	108e8004 	addi	r2,r2,14848
811118bc:	00e04574 	movhi	r3,33045
811118c0:	18f48c04 	addi	r3,r3,-11728
811118c4:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
811118c8:	00a04574 	movhi	r2,33045
811118cc:	108e8004 	addi	r2,r2,14848
811118d0:	00e04574 	movhi	r3,33045
811118d4:	18f49004 	addi	r3,r3,-11712
811118d8:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
811118dc:	00a04574 	movhi	r2,33045
811118e0:	108e8004 	addi	r2,r2,14848
811118e4:	00e04574 	movhi	r3,33045
811118e8:	18f49404 	addi	r3,r3,-11696
811118ec:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
811118f0:	00a04574 	movhi	r2,33045
811118f4:	108e8004 	addi	r2,r2,14848
811118f8:	00e04574 	movhi	r3,33045
811118fc:	18f49804 	addi	r3,r3,-11680
81111900:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
81111904:	00a04574 	movhi	r2,33045
81111908:	108e8004 	addi	r2,r2,14848
8111190c:	00e04574 	movhi	r3,33045
81111910:	18f49d04 	addi	r3,r3,-11660
81111914:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
81111918:	00a04574 	movhi	r2,33045
8111191c:	108e8004 	addi	r2,r2,14848
81111920:	00e04574 	movhi	r3,33045
81111924:	18f4a104 	addi	r3,r3,-11644
81111928:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
8111192c:	00a04574 	movhi	r2,33045
81111930:	108e8004 	addi	r2,r2,14848
81111934:	00e04574 	movhi	r3,33045
81111938:	18f4a504 	addi	r3,r3,-11628
8111193c:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
81111940:	00a04574 	movhi	r2,33045
81111944:	108e8004 	addi	r2,r2,14848
81111948:	00e04574 	movhi	r3,33045
8111194c:	18f4a904 	addi	r3,r3,-11612
81111950:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
81111954:	00a04574 	movhi	r2,33045
81111958:	108e8004 	addi	r2,r2,14848
8111195c:	00e04574 	movhi	r3,33045
81111960:	18f4ad04 	addi	r3,r3,-11596
81111964:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
81111968:	00a04574 	movhi	r2,33045
8111196c:	108e8004 	addi	r2,r2,14848
81111970:	00e04574 	movhi	r3,33045
81111974:	18f4b104 	addi	r3,r3,-11580
81111978:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
8111197c:	00a04574 	movhi	r2,33045
81111980:	108e8004 	addi	r2,r2,14848
81111984:	00e04574 	movhi	r3,33045
81111988:	18f4b504 	addi	r3,r3,-11564
8111198c:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
81111990:	00a04574 	movhi	r2,33045
81111994:	108e8004 	addi	r2,r2,14848
81111998:	00e04574 	movhi	r3,33045
8111199c:	18f4b904 	addi	r3,r3,-11548
811119a0:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
811119a4:	00a04574 	movhi	r2,33045
811119a8:	108e8004 	addi	r2,r2,14848
811119ac:	00e04574 	movhi	r3,33045
811119b0:	18f4bd04 	addi	r3,r3,-11532
811119b4:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
811119b8:	00a04574 	movhi	r2,33045
811119bc:	108e8004 	addi	r2,r2,14848
811119c0:	00e04574 	movhi	r3,33045
811119c4:	18f4c104 	addi	r3,r3,-11516
811119c8:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
811119cc:	00a04574 	movhi	r2,33045
811119d0:	108e8004 	addi	r2,r2,14848
811119d4:	00e04574 	movhi	r3,33045
811119d8:	18f4c504 	addi	r3,r3,-11500
811119dc:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
811119e0:	00a04574 	movhi	r2,33045
811119e4:	108e8004 	addi	r2,r2,14848
811119e8:	00e04574 	movhi	r3,33045
811119ec:	18f4c904 	addi	r3,r3,-11484
811119f0:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
811119f4:	00a04574 	movhi	r2,33045
811119f8:	108e8004 	addi	r2,r2,14848
811119fc:	00e04574 	movhi	r3,33045
81111a00:	18f4cd04 	addi	r3,r3,-11468
81111a04:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
81111a08:	00a04574 	movhi	r2,33045
81111a0c:	108e8004 	addi	r2,r2,14848
81111a10:	00e04574 	movhi	r3,33045
81111a14:	18f4d104 	addi	r3,r3,-11452
81111a18:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
81111a1c:	00a04574 	movhi	r2,33045
81111a20:	108e8004 	addi	r2,r2,14848
81111a24:	00e04574 	movhi	r3,33045
81111a28:	18f4d504 	addi	r3,r3,-11436
81111a2c:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
81111a30:	00a04574 	movhi	r2,33045
81111a34:	108e8004 	addi	r2,r2,14848
81111a38:	00e04574 	movhi	r3,33045
81111a3c:	18f4d904 	addi	r3,r3,-11420
81111a40:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
81111a44:	00a04574 	movhi	r2,33045
81111a48:	108e8004 	addi	r2,r2,14848
81111a4c:	00e04574 	movhi	r3,33045
81111a50:	18f4dd04 	addi	r3,r3,-11404
81111a54:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
81111a58:	00a04574 	movhi	r2,33045
81111a5c:	108e8004 	addi	r2,r2,14848
81111a60:	00e04574 	movhi	r3,33045
81111a64:	18f4e104 	addi	r3,r3,-11388
81111a68:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
81111a6c:	00a04574 	movhi	r2,33045
81111a70:	108e8004 	addi	r2,r2,14848
81111a74:	00e04574 	movhi	r3,33045
81111a78:	18f4e504 	addi	r3,r3,-11372
81111a7c:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
81111a80:	00a04574 	movhi	r2,33045
81111a84:	108e8004 	addi	r2,r2,14848
81111a88:	00e04574 	movhi	r3,33045
81111a8c:	18f4e904 	addi	r3,r3,-11356
81111a90:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
81111a94:	00a04574 	movhi	r2,33045
81111a98:	108e8004 	addi	r2,r2,14848
81111a9c:	00e04574 	movhi	r3,33045
81111aa0:	18f4ed04 	addi	r3,r3,-11340
81111aa4:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
81111aa8:	00a04574 	movhi	r2,33045
81111aac:	108e8004 	addi	r2,r2,14848
81111ab0:	00e04574 	movhi	r3,33045
81111ab4:	18f4f104 	addi	r3,r3,-11324
81111ab8:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
81111abc:	00a04574 	movhi	r2,33045
81111ac0:	108e8004 	addi	r2,r2,14848
81111ac4:	00e04574 	movhi	r3,33045
81111ac8:	18f4f504 	addi	r3,r3,-11308
81111acc:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
81111ad0:	00a04574 	movhi	r2,33045
81111ad4:	108e8004 	addi	r2,r2,14848
81111ad8:	00e04574 	movhi	r3,33045
81111adc:	18f4f904 	addi	r3,r3,-11292
81111ae0:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
81111ae4:	00a04574 	movhi	r2,33045
81111ae8:	108e8004 	addi	r2,r2,14848
81111aec:	00e04574 	movhi	r3,33045
81111af0:	18f4fd04 	addi	r3,r3,-11276
81111af4:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
81111af8:	00a04574 	movhi	r2,33045
81111afc:	108e8004 	addi	r2,r2,14848
81111b00:	00e04574 	movhi	r3,33045
81111b04:	18f50104 	addi	r3,r3,-11260
81111b08:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
81111b0c:	00a04574 	movhi	r2,33045
81111b10:	108e8004 	addi	r2,r2,14848
81111b14:	00e04574 	movhi	r3,33045
81111b18:	18f50504 	addi	r3,r3,-11244
81111b1c:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
81111b20:	00a04574 	movhi	r2,33045
81111b24:	108e8004 	addi	r2,r2,14848
81111b28:	00e04574 	movhi	r3,33045
81111b2c:	18f50904 	addi	r3,r3,-11228
81111b30:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
81111b34:	00a04574 	movhi	r2,33045
81111b38:	108e8004 	addi	r2,r2,14848
81111b3c:	00e04574 	movhi	r3,33045
81111b40:	18f50d04 	addi	r3,r3,-11212
81111b44:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
81111b48:	00a04574 	movhi	r2,33045
81111b4c:	108e8004 	addi	r2,r2,14848
81111b50:	00e04574 	movhi	r3,33045
81111b54:	18f51104 	addi	r3,r3,-11196
81111b58:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
81111b5c:	00a04574 	movhi	r2,33045
81111b60:	108e8004 	addi	r2,r2,14848
81111b64:	00e04574 	movhi	r3,33045
81111b68:	18f51504 	addi	r3,r3,-11180
81111b6c:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
81111b70:	00a04574 	movhi	r2,33045
81111b74:	108e8004 	addi	r2,r2,14848
81111b78:	00e04574 	movhi	r3,33045
81111b7c:	18f51904 	addi	r3,r3,-11164
81111b80:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
81111b84:	00a04574 	movhi	r2,33045
81111b88:	108e8004 	addi	r2,r2,14848
81111b8c:	00e04574 	movhi	r3,33045
81111b90:	18f51d04 	addi	r3,r3,-11148
81111b94:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
81111b98:	00a04574 	movhi	r2,33045
81111b9c:	108e8004 	addi	r2,r2,14848
81111ba0:	00e04574 	movhi	r3,33045
81111ba4:	18f52104 	addi	r3,r3,-11132
81111ba8:	10c03f15 	stw	r3,252(r2)
}
81111bac:	0001883a 	nop
81111bb0:	e037883a 	mov	sp,fp
81111bb4:	df000017 	ldw	fp,0(sp)
81111bb8:	dec00104 	addi	sp,sp,4
81111bbc:	f800283a 	ret

81111bc0 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
81111bc0:	defff604 	addi	sp,sp,-40
81111bc4:	de00012e 	bgeu	sp,et,81111bcc <vInAckHandlerTaskV2+0xc>
81111bc8:	003b68fa 	trap	3
81111bcc:	dfc00915 	stw	ra,36(sp)
81111bd0:	df000815 	stw	fp,32(sp)
81111bd4:	df000804 	addi	fp,sp,32
81111bd8:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
81111bdc:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
81111be0:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81111be4:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81111be8:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
81111bec:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
81111bf0:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
81111bf4:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
81111bf8:	d0a06217 	ldw	r2,-32376(gp)
81111bfc:	100f883a 	mov	r7,r2
81111c00:	018007c4 	movi	r6,31
81111c04:	01400044 	movi	r5,1
81111c08:	01204574 	movhi	r4,33045
81111c0c:	21352504 	addi	r4,r4,-11116
81111c10:	11219e00 	call	811219e0 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
81111c14:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81111c18:	e0bff917 	ldw	r2,-28(fp)
81111c1c:	10c00060 	cmpeqi	r3,r2,1
81111c20:	1800071e 	bne	r3,zero,81111c40 <vInAckHandlerTaskV2+0x80>
81111c24:	0080032e 	bgeu	zero,r2,81111c34 <vInAckHandlerTaskV2+0x74>
81111c28:	108000a0 	cmpeqi	r2,r2,2
81111c2c:	10004a1e 	bne	r2,zero,81111d58 <vInAckHandlerTaskV2+0x198>
81111c30:	0000ac06 	br	81111ee4 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
81111c34:	00800044 	movi	r2,1
81111c38:	e0bff915 	stw	r2,-28(fp)
				break;
81111c3c:	0000b306 	br	81111f0c <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81111c40:	00800044 	movi	r2,1
81111c44:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
81111c48:	d0a06617 	ldw	r2,-32360(gp)
81111c4c:	e0fffe04 	addi	r3,fp,-8
81111c50:	180d883a 	mov	r6,r3
81111c54:	000b883a 	mov	r5,zero
81111c58:	1009883a 	mov	r4,r2
81111c5c:	113e87c0 	call	8113e87c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81111c60:	e0bffe03 	ldbu	r2,-8(fp)
81111c64:	10803fcc 	andi	r2,r2,255
81111c68:	1000391e 	bne	r2,zero,81111d50 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81111c6c:	d0a06517 	ldw	r2,-32364(gp)
81111c70:	e0fffe04 	addi	r3,fp,-8
81111c74:	180d883a 	mov	r6,r3
81111c78:	000b883a 	mov	r5,zero
81111c7c:	1009883a 	mov	r4,r2
81111c80:	113c8700 	call	8113c870 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81111c84:	e0bffe03 	ldbu	r2,-8(fp)
81111c88:	10803fcc 	andi	r2,r2,255
81111c8c:	10002b1e 	bne	r2,zero,81111d3c <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81111c90:	e03ffa45 	stb	zero,-23(fp)
81111c94:	00002206 	br	81111d20 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
81111c98:	e0fffa43 	ldbu	r3,-23(fp)
81111c9c:	00a045b4 	movhi	r2,33046
81111ca0:	10841c04 	addi	r2,r2,4208
81111ca4:	18c7883a 	add	r3,r3,r3
81111ca8:	18c7883a 	add	r3,r3,r3
81111cac:	10c5883a 	add	r2,r2,r3
81111cb0:	10800003 	ldbu	r2,0(r2)
81111cb4:	10803fcc 	andi	r2,r2,255
81111cb8:	1080201c 	xori	r2,r2,128
81111cbc:	10bfe004 	addi	r2,r2,-128
81111cc0:	10001426 	beq	r2,zero,81111d14 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
81111cc4:	e0fffa43 	ldbu	r3,-23(fp)
81111cc8:	00a045b4 	movhi	r2,33046
81111ccc:	10841c04 	addi	r2,r2,4208
81111cd0:	18c7883a 	add	r3,r3,r3
81111cd4:	18c7883a 	add	r3,r3,r3
81111cd8:	10c5883a 	add	r2,r2,r3
81111cdc:	10c0000b 	ldhu	r3,0(r2)
81111ce0:	d0e0568d 	sth	r3,-32422(gp)
81111ce4:	1080008b 	ldhu	r2,2(r2)
81111ce8:	d0a0570d 	sth	r2,-32420(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81111cec:	e0fffa43 	ldbu	r3,-23(fp)
81111cf0:	00a045b4 	movhi	r2,33046
81111cf4:	10841c04 	addi	r2,r2,4208
81111cf8:	18c7883a 	add	r3,r3,r3
81111cfc:	18c7883a 	add	r3,r3,r3
81111d00:	10c5883a 	add	r2,r2,r3
81111d04:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81111d08:	00800084 	movi	r2,2
81111d0c:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81111d10:	00000606 	br	81111d2c <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81111d14:	e0bffa43 	ldbu	r2,-23(fp)
81111d18:	10800044 	addi	r2,r2,1
81111d1c:	e0bffa45 	stb	r2,-23(fp)
81111d20:	e0bffa43 	ldbu	r2,-23(fp)
81111d24:	108001b0 	cmpltui	r2,r2,6
81111d28:	103fdb1e 	bne	r2,zero,81111c98 <__reset+0xfb0f1c98>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
81111d2c:	d0a06517 	ldw	r2,-32364(gp)
81111d30:	1009883a 	mov	r4,r2
81111d34:	113ce140 	call	8113ce14 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81111d38:	00007406 	br	81111f0c <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
81111d3c:	d0a06617 	ldw	r2,-32360(gp)
81111d40:	1009883a 	mov	r4,r2
81111d44:	113ec040 	call	8113ec04 <OSSemPost>
                    	vFailGetMutexReceiverTask();
81111d48:	111b9f80 	call	8111b9f8 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81111d4c:	00006f06 	br	81111f0c <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
81111d50:	111b9900 	call	8111b990 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
81111d54:	00006d06 	br	81111f0c <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
81111d58:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81111d5c:	d0a06883 	ldbu	r2,-32350(gp)
81111d60:	10803fcc 	andi	r2,r2,255
81111d64:	10800218 	cmpnei	r2,r2,8
81111d68:	1000021e 	bne	r2,zero,81111d74 <vInAckHandlerTaskV2+0x1b4>
81111d6c:	00c00104 	movi	r3,4
81111d70:	00000106 	br	81111d78 <vInAckHandlerTaskV2+0x1b8>
81111d74:	0007883a 	mov	r3,zero
81111d78:	d0a07503 	ldbu	r2,-32300(gp)
81111d7c:	10803fcc 	andi	r2,r2,255
81111d80:	10800218 	cmpnei	r2,r2,8
81111d84:	1000021e 	bne	r2,zero,81111d90 <vInAckHandlerTaskV2+0x1d0>
81111d88:	00800084 	movi	r2,2
81111d8c:	00000106 	br	81111d94 <vInAckHandlerTaskV2+0x1d4>
81111d90:	0005883a 	mov	r2,zero
81111d94:	1884b03a 	or	r2,r3,r2
81111d98:	1007883a 	mov	r3,r2
81111d9c:	d0a07543 	ldbu	r2,-32299(gp)
81111da0:	10803fcc 	andi	r2,r2,255
81111da4:	108001a0 	cmpeqi	r2,r2,6
81111da8:	1884b03a 	or	r2,r3,r2
81111dac:	1007883a 	mov	r3,r2
81111db0:	e0bffa83 	ldbu	r2,-22(fp)
81111db4:	1884b03a 	or	r2,r3,r2
81111db8:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81111dbc:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
81111dc0:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
81111dc4:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81111dc8:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81111dcc:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
81111dd0:	e0bffa03 	ldbu	r2,-24(fp)
81111dd4:	10800044 	addi	r2,r2,1
81111dd8:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81111ddc:	e0bffa83 	ldbu	r2,-22(fp)
81111de0:	1080004c 	andi	r2,r2,1
81111de4:	10803fcc 	andi	r2,r2,255
81111de8:	1000061e 	bne	r2,zero,81111e04 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81111dec:	e0bffd04 	addi	r2,fp,-12
81111df0:	100b883a 	mov	r5,r2
81111df4:	d1205684 	addi	r4,gp,-32422
81111df8:	1111f100 	call	81111f10 <bCheckInAck128>
81111dfc:	e0bff815 	stw	r2,-32(fp)
81111e00:	00000206 	br	81111e0c <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
81111e04:	00800044 	movi	r2,1
81111e08:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81111e0c:	e0bffa83 	ldbu	r2,-22(fp)
81111e10:	1080008c 	andi	r2,r2,2
81111e14:	10803fcc 	andi	r2,r2,255
81111e18:	1000081e 	bne	r2,zero,81111e3c <vInAckHandlerTaskV2+0x27c>
81111e1c:	e0bff817 	ldw	r2,-32(fp)
81111e20:	1000061e 	bne	r2,zero,81111e3c <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
81111e24:	e0bffc04 	addi	r2,fp,-16
81111e28:	100b883a 	mov	r5,r2
81111e2c:	d1205684 	addi	r4,gp,-32422
81111e30:	11120580 	call	81112058 <bCheckInAck64>
81111e34:	e0bff815 	stw	r2,-32(fp)
81111e38:	00000206 	br	81111e44 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
81111e3c:	00800044 	movi	r2,1
81111e40:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
81111e44:	e0bffa83 	ldbu	r2,-22(fp)
81111e48:	1080010c 	andi	r2,r2,4
81111e4c:	10803fcc 	andi	r2,r2,255
81111e50:	1000081e 	bne	r2,zero,81111e74 <vInAckHandlerTaskV2+0x2b4>
81111e54:	e0bff817 	ldw	r2,-32(fp)
81111e58:	1000061e 	bne	r2,zero,81111e74 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81111e5c:	e0bffb04 	addi	r2,fp,-20
81111e60:	100b883a 	mov	r5,r2
81111e64:	d1205684 	addi	r4,gp,-32422
81111e68:	11121a40 	call	811121a4 <bCheckInAck32>
81111e6c:	e0bff815 	stw	r2,-32(fp)
81111e70:	00000206 	br	81111e7c <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
81111e74:	00800044 	movi	r2,1
81111e78:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
81111e7c:	e0bffa03 	ldbu	r2,-24(fp)
81111e80:	10c00044 	addi	r3,r2,1
81111e84:	e0fffa05 	stb	r3,-24(fp)
81111e88:	10803fcc 	andi	r2,r2,255
81111e8c:	10800ca8 	cmpgeui	r2,r2,50
81111e90:	10000e1e 	bne	r2,zero,81111ecc <vInAckHandlerTaskV2+0x30c>
81111e94:	e0bff817 	ldw	r2,-32(fp)
81111e98:	10000c1e 	bne	r2,zero,81111ecc <vInAckHandlerTaskV2+0x30c>
81111e9c:	e0bffb17 	ldw	r2,-20(fp)
81111ea0:	1005003a 	cmpeq	r2,r2,zero
81111ea4:	1007883a 	mov	r3,r2
81111ea8:	e0bffc17 	ldw	r2,-16(fp)
81111eac:	1005003a 	cmpeq	r2,r2,zero
81111eb0:	1884b03a 	or	r2,r3,r2
81111eb4:	10c03fcc 	andi	r3,r2,255
81111eb8:	e0bffd17 	ldw	r2,-12(fp)
81111ebc:	1005003a 	cmpeq	r2,r2,zero
81111ec0:	10803fcc 	andi	r2,r2,255
81111ec4:	1884b03a 	or	r2,r3,r2
81111ec8:	103fc11e 	bne	r2,zero,81111dd0 <__reset+0xfb0f1dd0>
                
                if (bFound == FALSE) {
81111ecc:	e0bff817 	ldw	r2,-32(fp)
81111ed0:	1000011e 	bne	r2,zero,81111ed8 <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
81111ed4:	111beb40 	call	8111beb4 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81111ed8:	00800044 	movi	r2,1
81111edc:	e0bff915 	stw	r2,-28(fp)
				break;
81111ee0:	00000a06 	br	81111f0c <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81111ee4:	d0a06217 	ldw	r2,-32376(gp)
81111ee8:	100f883a 	mov	r7,r2
81111eec:	01801144 	movi	r6,69
81111ef0:	01400044 	movi	r5,1
81111ef4:	01204574 	movhi	r4,33045
81111ef8:	21352d04 	addi	r4,r4,-11084
81111efc:	11219e00 	call	811219e0 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
81111f00:	00800044 	movi	r2,1
81111f04:	e0bff915 	stw	r2,-28(fp)
				break;
81111f08:	0001883a 	nop
		}
	}
81111f0c:	003f4206 	br	81111c18 <__reset+0xfb0f1c18>

81111f10 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81111f10:	defffa04 	addi	sp,sp,-24
81111f14:	de00012e 	bgeu	sp,et,81111f1c <bCheckInAck128+0xc>
81111f18:	003b68fa 	trap	3
81111f1c:	dfc00515 	stw	ra,20(sp)
81111f20:	df000415 	stw	fp,16(sp)
81111f24:	df000404 	addi	fp,sp,16
81111f28:	e13ffe15 	stw	r4,-8(fp)
81111f2c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81111f30:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81111f34:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81111f38:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81111f3c:	e0bfff17 	ldw	r2,-4(fp)
81111f40:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
81111f44:	d0a06e17 	ldw	r2,-32328(gp)
81111f48:	e0fffd44 	addi	r3,fp,-11
81111f4c:	180d883a 	mov	r6,r3
81111f50:	01400144 	movi	r5,5
81111f54:	1009883a 	mov	r4,r2
81111f58:	113c8700 	call	8113c870 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81111f5c:	e0bffd43 	ldbu	r2,-11(fp)
81111f60:	10803fcc 	andi	r2,r2,255
81111f64:	10000226 	beq	r2,zero,81111f70 <bCheckInAck128+0x60>
        return bFound;
81111f68:	e0bffc17 	ldw	r2,-16(fp)
81111f6c:	00003506 	br	81112044 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81111f70:	e03ffd05 	stb	zero,-12(fp)
81111f74:	00002706 	br	81112014 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
81111f78:	e0fffd03 	ldbu	r3,-12(fp)
81111f7c:	00a045b4 	movhi	r2,33046
81111f80:	10bb1a04 	addi	r2,r2,-5016
81111f84:	18c02324 	muli	r3,r3,140
81111f88:	10c5883a 	add	r2,r2,r3
81111f8c:	10802104 	addi	r2,r2,132
81111f90:	10c0000b 	ldhu	r3,0(r2)
81111f94:	e0bffe17 	ldw	r2,-8(fp)
81111f98:	1080008b 	ldhu	r2,2(r2)
81111f9c:	18ffffcc 	andi	r3,r3,65535
81111fa0:	10bfffcc 	andi	r2,r2,65535
81111fa4:	1880181e 	bne	r3,r2,81112008 <bCheckInAck128+0xf8>
            bFound = TRUE;
81111fa8:	00800044 	movi	r2,1
81111fac:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
81111fb0:	e0fffd03 	ldbu	r3,-12(fp)
81111fb4:	00a045b4 	movhi	r2,33046
81111fb8:	10bafc04 	addi	r2,r2,-5136
81111fbc:	18c7883a 	add	r3,r3,r3
81111fc0:	18c7883a 	add	r3,r3,r3
81111fc4:	10c5883a 	add	r2,r2,r3
81111fc8:	10000015 	stw	zero,0(r2)
            SemCount128++;
81111fcc:	d0a07543 	ldbu	r2,-32299(gp)
81111fd0:	10800044 	addi	r2,r2,1
81111fd4:	d0a07545 	stb	r2,-32299(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81111fd8:	d0a06317 	ldw	r2,-32372(gp)
81111fdc:	1009883a 	mov	r4,r2
81111fe0:	113ec040 	call	8113ec04 <OSSemPost>
81111fe4:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81111fe8:	e0bffd43 	ldbu	r2,-11(fp)
81111fec:	10803fcc 	andi	r2,r2,255
81111ff0:	10000c26 	beq	r2,zero,81112024 <bCheckInAck128+0x114>
                SemCount128--;
81111ff4:	d0a07543 	ldbu	r2,-32299(gp)
81111ff8:	10bfffc4 	addi	r2,r2,-1
81111ffc:	d0a07545 	stb	r2,-32299(gp)
                vFailSetCountSemaphorexBuffer128();
81112000:	111bd140 	call	8111bd14 <vFailSetCountSemaphorexBuffer128>
            }
            break;
81112004:	00000706 	br	81112024 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81112008:	e0bffd03 	ldbu	r2,-12(fp)
8111200c:	10800044 	addi	r2,r2,1
81112010:	e0bffd05 	stb	r2,-12(fp)
81112014:	e0bffd03 	ldbu	r2,-12(fp)
81112018:	108001b0 	cmpltui	r2,r2,6
8111201c:	103fd61e 	bne	r2,zero,81111f78 <__reset+0xfb0f1f78>
81112020:	00000106 	br	81112028 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
81112024:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81112028:	d0a06e17 	ldw	r2,-32328(gp)
8111202c:	1009883a 	mov	r4,r2
81112030:	113ce140 	call	8113ce14 <OSMutexPost>
    (*bFinished) = TRUE;
81112034:	e0bfff17 	ldw	r2,-4(fp)
81112038:	00c00044 	movi	r3,1
8111203c:	10c00015 	stw	r3,0(r2)

    return bFound;
81112040:	e0bffc17 	ldw	r2,-16(fp)
}
81112044:	e037883a 	mov	sp,fp
81112048:	dfc00117 	ldw	ra,4(sp)
8111204c:	df000017 	ldw	fp,0(sp)
81112050:	dec00204 	addi	sp,sp,8
81112054:	f800283a 	ret

81112058 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
81112058:	defffa04 	addi	sp,sp,-24
8111205c:	de00012e 	bgeu	sp,et,81112064 <bCheckInAck64+0xc>
81112060:	003b68fa 	trap	3
81112064:	dfc00515 	stw	ra,20(sp)
81112068:	df000415 	stw	fp,16(sp)
8111206c:	df000404 	addi	fp,sp,16
81112070:	e13ffe15 	stw	r4,-8(fp)
81112074:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81112078:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8111207c:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81112080:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81112084:	e0bfff17 	ldw	r2,-4(fp)
81112088:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8111208c:	d0a07117 	ldw	r2,-32316(gp)
81112090:	e0fffd44 	addi	r3,fp,-11
81112094:	180d883a 	mov	r6,r3
81112098:	01400044 	movi	r5,1
8111209c:	1009883a 	mov	r4,r2
811120a0:	113c8700 	call	8113c870 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811120a4:	e0bffd43 	ldbu	r2,-11(fp)
811120a8:	10803fcc 	andi	r2,r2,255
811120ac:	10000226 	beq	r2,zero,811120b8 <bCheckInAck64+0x60>
        return bFound;
811120b0:	e0bffc17 	ldw	r2,-16(fp)
811120b4:	00003606 	br	81112190 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
811120b8:	e03ffd05 	stb	zero,-12(fp)
811120bc:	00002806 	br	81112160 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
811120c0:	e0fffd03 	ldbu	r3,-12(fp)
811120c4:	00a04574 	movhi	r2,33045
811120c8:	1096c004 	addi	r2,r2,23296
811120cc:	18c01324 	muli	r3,r3,76
811120d0:	10c5883a 	add	r2,r2,r3
811120d4:	10801104 	addi	r2,r2,68
811120d8:	10c0000b 	ldhu	r3,0(r2)
811120dc:	e0bffe17 	ldw	r2,-8(fp)
811120e0:	1080008b 	ldhu	r2,2(r2)
811120e4:	18ffffcc 	andi	r3,r3,65535
811120e8:	10bfffcc 	andi	r2,r2,65535
811120ec:	1880191e 	bne	r3,r2,81112154 <bCheckInAck64+0xfc>
            bFound = TRUE;
811120f0:	00800044 	movi	r2,1
811120f4:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
811120f8:	e0fffd03 	ldbu	r3,-12(fp)
811120fc:	00a045b4 	movhi	r2,33046
81112100:	10bafc04 	addi	r2,r2,-5136
81112104:	18c00184 	addi	r3,r3,6
81112108:	18c7883a 	add	r3,r3,r3
8111210c:	18c7883a 	add	r3,r3,r3
81112110:	10c5883a 	add	r2,r2,r3
81112114:	10000015 	stw	zero,0(r2)
            SemCount64++;
81112118:	d0a07503 	ldbu	r2,-32300(gp)
8111211c:	10800044 	addi	r2,r2,1
81112120:	d0a07505 	stb	r2,-32300(gp)
            error_code = OSSemPost(xSemCountBuffer64);
81112124:	d0a05e17 	ldw	r2,-32392(gp)
81112128:	1009883a 	mov	r4,r2
8111212c:	113ec040 	call	8113ec04 <OSSemPost>
81112130:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112134:	e0bffd43 	ldbu	r2,-11(fp)
81112138:	10803fcc 	andi	r2,r2,255
8111213c:	10000c26 	beq	r2,zero,81112170 <bCheckInAck64+0x118>
                SemCount64--;
81112140:	d0a07503 	ldbu	r2,-32300(gp)
81112144:	10bfffc4 	addi	r2,r2,-1
81112148:	d0a07505 	stb	r2,-32300(gp)
                vFailSetCountSemaphorexBuffer64();
8111214c:	111bcac0 	call	8111bcac <vFailSetCountSemaphorexBuffer64>
            }
            break;
81112150:	00000706 	br	81112170 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81112154:	e0bffd03 	ldbu	r2,-12(fp)
81112158:	10800044 	addi	r2,r2,1
8111215c:	e0bffd05 	stb	r2,-12(fp)
81112160:	e0bffd03 	ldbu	r2,-12(fp)
81112164:	10800230 	cmpltui	r2,r2,8
81112168:	103fd51e 	bne	r2,zero,811120c0 <__reset+0xfb0f20c0>
8111216c:	00000106 	br	81112174 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81112170:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
81112174:	d0a07117 	ldw	r2,-32316(gp)
81112178:	1009883a 	mov	r4,r2
8111217c:	113ce140 	call	8113ce14 <OSMutexPost>
    (*bFinished) = TRUE;
81112180:	e0bfff17 	ldw	r2,-4(fp)
81112184:	00c00044 	movi	r3,1
81112188:	10c00015 	stw	r3,0(r2)

    return bFound;
8111218c:	e0bffc17 	ldw	r2,-16(fp)
}
81112190:	e037883a 	mov	sp,fp
81112194:	dfc00117 	ldw	ra,4(sp)
81112198:	df000017 	ldw	fp,0(sp)
8111219c:	dec00204 	addi	sp,sp,8
811121a0:	f800283a 	ret

811121a4 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
811121a4:	defffa04 	addi	sp,sp,-24
811121a8:	de00012e 	bgeu	sp,et,811121b0 <bCheckInAck32+0xc>
811121ac:	003b68fa 	trap	3
811121b0:	dfc00515 	stw	ra,20(sp)
811121b4:	df000415 	stw	fp,16(sp)
811121b8:	df000404 	addi	fp,sp,16
811121bc:	e13ffe15 	stw	r4,-8(fp)
811121c0:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811121c4:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811121c8:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811121cc:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811121d0:	e0bfff17 	ldw	r2,-4(fp)
811121d4:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811121d8:	d0a06c17 	ldw	r2,-32336(gp)
811121dc:	e0fffd44 	addi	r3,fp,-11
811121e0:	180d883a 	mov	r6,r3
811121e4:	01400044 	movi	r5,1
811121e8:	1009883a 	mov	r4,r2
811121ec:	113c8700 	call	8113c870 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811121f0:	e0bffd43 	ldbu	r2,-11(fp)
811121f4:	10803fcc 	andi	r2,r2,255
811121f8:	10000226 	beq	r2,zero,81112204 <bCheckInAck32+0x60>
        return bFound;
811121fc:	e0bffc17 	ldw	r2,-16(fp)
81112200:	00003606 	br	811122dc <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81112204:	e03ffd05 	stb	zero,-12(fp)
81112208:	00002806 	br	811122ac <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8111220c:	e0fffd03 	ldbu	r3,-12(fp)
81112210:	00a045b4 	movhi	r2,33046
81112214:	10a87c04 	addi	r2,r2,-24080
81112218:	18c00b24 	muli	r3,r3,44
8111221c:	10c5883a 	add	r2,r2,r3
81112220:	10800904 	addi	r2,r2,36
81112224:	10c0000b 	ldhu	r3,0(r2)
81112228:	e0bffe17 	ldw	r2,-8(fp)
8111222c:	1080008b 	ldhu	r2,2(r2)
81112230:	18ffffcc 	andi	r3,r3,65535
81112234:	10bfffcc 	andi	r2,r2,65535
81112238:	1880191e 	bne	r3,r2,811122a0 <bCheckInAck32+0xfc>
            bFound = TRUE;
8111223c:	00800044 	movi	r2,1
81112240:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81112244:	e0fffd03 	ldbu	r3,-12(fp)
81112248:	00a045b4 	movhi	r2,33046
8111224c:	10bafc04 	addi	r2,r2,-5136
81112250:	18c00384 	addi	r3,r3,14
81112254:	18c7883a 	add	r3,r3,r3
81112258:	18c7883a 	add	r3,r3,r3
8111225c:	10c5883a 	add	r2,r2,r3
81112260:	10000015 	stw	zero,0(r2)
            SemCount32++;
81112264:	d0a06883 	ldbu	r2,-32350(gp)
81112268:	10800044 	addi	r2,r2,1
8111226c:	d0a06885 	stb	r2,-32350(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81112270:	d0a06f17 	ldw	r2,-32324(gp)
81112274:	1009883a 	mov	r4,r2
81112278:	113ec040 	call	8113ec04 <OSSemPost>
8111227c:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81112280:	e0bffd43 	ldbu	r2,-11(fp)
81112284:	10803fcc 	andi	r2,r2,255
81112288:	10000c26 	beq	r2,zero,811122bc <bCheckInAck32+0x118>
                SemCount32--;
8111228c:	d0a06883 	ldbu	r2,-32350(gp)
81112290:	10bfffc4 	addi	r2,r2,-1
81112294:	d0a06885 	stb	r2,-32350(gp)
                vFailSetCountSemaphorexBuffer32();
81112298:	111bc440 	call	8111bc44 <vFailSetCountSemaphorexBuffer32>
            }
            break;
8111229c:	00000706 	br	811122bc <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
811122a0:	e0bffd03 	ldbu	r2,-12(fp)
811122a4:	10800044 	addi	r2,r2,1
811122a8:	e0bffd05 	stb	r2,-12(fp)
811122ac:	e0bffd03 	ldbu	r2,-12(fp)
811122b0:	10800230 	cmpltui	r2,r2,8
811122b4:	103fd51e 	bne	r2,zero,8111220c <__reset+0xfb0f220c>
811122b8:	00000106 	br	811122c0 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
811122bc:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
811122c0:	d0a06c17 	ldw	r2,-32336(gp)
811122c4:	1009883a 	mov	r4,r2
811122c8:	113ce140 	call	8113ce14 <OSMutexPost>
    (*bFinished) = TRUE;
811122cc:	e0bfff17 	ldw	r2,-4(fp)
811122d0:	00c00044 	movi	r3,1
811122d4:	10c00015 	stw	r3,0(r2)

    return bFound;
811122d8:	e0bffc17 	ldw	r2,-16(fp)
}
811122dc:	e037883a 	mov	sp,fp
811122e0:	dfc00117 	ldw	ra,4(sp)
811122e4:	df000017 	ldw	fp,0(sp)
811122e8:	dec00204 	addi	sp,sp,8
811122ec:	f800283a 	ret

811122f0 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
811122f0:	defff704 	addi	sp,sp,-36
811122f4:	de00012e 	bgeu	sp,et,811122fc <vInitialTask+0xc>
811122f8:	003b68fa 	trap	3
811122fc:	dfc00815 	stw	ra,32(sp)
81112300:	df000715 	stw	fp,28(sp)
81112304:	df000704 	addi	fp,sp,28
81112308:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8111230c:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81112310:	d8000415 	stw	zero,16(sp)
81112314:	d8000315 	stw	zero,12(sp)
81112318:	00810004 	movi	r2,1024
8111231c:	d8800215 	stw	r2,8(sp)
81112320:	00a04574 	movhi	r2,33045
81112324:	108ec004 	addi	r2,r2,15104
81112328:	d8800115 	stw	r2,4(sp)
8111232c:	008002c4 	movi	r2,11
81112330:	d8800015 	stw	r2,0(sp)
81112334:	01c002c4 	movi	r7,11
81112338:	01a04574 	movhi	r6,33045
8111233c:	3192bf04 	addi	r6,r6,19196
81112340:	016045b4 	movhi	r5,33046
81112344:	2963e004 	addi	r5,r5,-28800
81112348:	01204474 	movhi	r4,33041
8111234c:	21368204 	addi	r4,r4,-9720
81112350:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
81112354:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112358:	e0bffe03 	ldbu	r2,-8(fp)
8111235c:	10803fcc 	andi	r2,r2,255
81112360:	10000526 	beq	r2,zero,81112378 <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112364:	e0bffe03 	ldbu	r2,-8(fp)
81112368:	10803fcc 	andi	r2,r2,255
8111236c:	1009883a 	mov	r4,r2
81112370:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
81112374:	111ca6c0 	call	8111ca6c <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112378:	01c17704 	movi	r7,1500
8111237c:	000d883a 	mov	r6,zero
81112380:	000b883a 	mov	r5,zero
81112384:	0009883a 	mov	r4,zero
81112388:	11408140 	call	81140814 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8111238c:	d8000415 	stw	zero,16(sp)
81112390:	d8000315 	stw	zero,12(sp)
81112394:	00810004 	movi	r2,1024
81112398:	d8800215 	stw	r2,8(sp)
8111239c:	00a04574 	movhi	r2,33045
811123a0:	109fce04 	addi	r2,r2,32568
811123a4:	d8800115 	stw	r2,4(sp)
811123a8:	00800284 	movi	r2,10
811123ac:	d8800015 	stw	r2,0(sp)
811123b0:	01c00284 	movi	r7,10
811123b4:	01a045b4 	movhi	r6,33046
811123b8:	31a3cd04 	addi	r6,r6,-28876
811123bc:	016045b4 	movhi	r5,33046
811123c0:	2963d804 	addi	r5,r5,-28832
811123c4:	01204474 	movhi	r4,33041
811123c8:	21365a04 	addi	r4,r4,-9880
811123cc:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
811123d0:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811123d4:	e0bffe03 	ldbu	r2,-8(fp)
811123d8:	10803fcc 	andi	r2,r2,255
811123dc:	10000526 	beq	r2,zero,811123f4 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811123e0:	e0bffe03 	ldbu	r2,-8(fp)
811123e4:	10803fcc 	andi	r2,r2,255
811123e8:	1009883a 	mov	r4,r2
811123ec:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
811123f0:	111cd440 	call	8111cd44 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811123f4:	01c17704 	movi	r7,1500
811123f8:	000d883a 	mov	r6,zero
811123fc:	000b883a 	mov	r5,zero
81112400:	0009883a 	mov	r4,zero
81112404:	11408140 	call	81140814 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
81112408:	d8000415 	stw	zero,16(sp)
8111240c:	d8000315 	stw	zero,12(sp)
81112410:	00810004 	movi	r2,1024
81112414:	d8800215 	stw	r2,8(sp)
81112418:	00a045b4 	movhi	r2,33046
8111241c:	10bc0404 	addi	r2,r2,-4080
81112420:	d8800115 	stw	r2,4(sp)
81112424:	00800244 	movi	r2,9
81112428:	d8800015 	stw	r2,0(sp)
8111242c:	01c00244 	movi	r7,9
81112430:	01a045b4 	movhi	r6,33046
81112434:	31800304 	addi	r6,r6,12
81112438:	016045b4 	movhi	r5,33046
8111243c:	2963e004 	addi	r5,r5,-28800
81112440:	01204474 	movhi	r4,33041
81112444:	210a1d04 	addi	r4,r4,10356
81112448:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
8111244c:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112450:	e0bffe03 	ldbu	r2,-8(fp)
81112454:	10803fcc 	andi	r2,r2,255
81112458:	10000526 	beq	r2,zero,81112470 <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8111245c:	e0bffe03 	ldbu	r2,-8(fp)
81112460:	10803fcc 	andi	r2,r2,255
81112464:	1009883a 	mov	r4,r2
81112468:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
8111246c:	111ccdc0 	call	8111ccdc <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81112470:	01c17704 	movi	r7,1500
81112474:	000d883a 	mov	r6,zero
81112478:	000b883a 	mov	r5,zero
8111247c:	0009883a 	mov	r4,zero
81112480:	11408140 	call	81140814 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
81112484:	d8000415 	stw	zero,16(sp)
81112488:	d8000315 	stw	zero,12(sp)
8111248c:	00810004 	movi	r2,1024
81112490:	d8800215 	stw	r2,8(sp)
81112494:	00a045b4 	movhi	r2,33046
81112498:	108e2604 	addi	r2,r2,14488
8111249c:	d8800115 	stw	r2,4(sp)
811124a0:	00800204 	movi	r2,8
811124a4:	d8800015 	stw	r2,0(sp)
811124a8:	01c00204 	movi	r7,8
811124ac:	01a045b4 	movhi	r6,33046
811124b0:	31922504 	addi	r6,r6,18580
811124b4:	016045b4 	movhi	r5,33046
811124b8:	2963ce04 	addi	r5,r5,-28872
811124bc:	01204474 	movhi	r4,33041
811124c0:	2113b204 	addi	r4,r4,20168
811124c4:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
811124c8:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811124cc:	e0bffe03 	ldbu	r2,-8(fp)
811124d0:	10803fcc 	andi	r2,r2,255
811124d4:	10000526 	beq	r2,zero,811124ec <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811124d8:	e0bffe03 	ldbu	r2,-8(fp)
811124dc:	10803fcc 	andi	r2,r2,255
811124e0:	1009883a 	mov	r4,r2
811124e4:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
811124e8:	111cdac0 	call	8111cdac <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
811124ec:	01c17704 	movi	r7,1500
811124f0:	000d883a 	mov	r6,zero
811124f4:	000b883a 	mov	r5,zero
811124f8:	0009883a 	mov	r4,zero
811124fc:	11408140 	call	81140814 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81112500:	d8000415 	stw	zero,16(sp)
81112504:	d8000315 	stw	zero,12(sp)
81112508:	00810004 	movi	r2,1024
8111250c:	d8800215 	stw	r2,8(sp)
81112510:	00a04574 	movhi	r2,33045
81112514:	109bce04 	addi	r2,r2,28472
81112518:	d8800115 	stw	r2,4(sp)
8111251c:	00800784 	movi	r2,30
81112520:	d8800015 	stw	r2,0(sp)
81112524:	01c00784 	movi	r7,30
81112528:	01a04574 	movhi	r6,33045
8111252c:	319fcd04 	addi	r6,r6,32564
81112530:	000b883a 	mov	r5,zero
81112534:	01204474 	movhi	r4,33041
81112538:	211a7e04 	addi	r4,r4,27128
8111253c:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
81112540:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112544:	e0bffe03 	ldbu	r2,-8(fp)
81112548:	10803fcc 	andi	r2,r2,255
8111254c:	10000526 	beq	r2,zero,81112564 <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112550:	e0bffe03 	ldbu	r2,-8(fp)
81112554:	10803fcc 	andi	r2,r2,255
81112558:	1009883a 	mov	r4,r2
8111255c:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
81112560:	111c3d80 	call	8111c3d8 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112564:	01c03204 	movi	r7,200
81112568:	000d883a 	mov	r6,zero
8111256c:	000b883a 	mov	r5,zero
81112570:	0009883a 	mov	r4,zero
81112574:	11408140 	call	81140814 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81112578:	d8000415 	stw	zero,16(sp)
8111257c:	d8000315 	stw	zero,12(sp)
81112580:	00810004 	movi	r2,1024
81112584:	d8800215 	stw	r2,8(sp)
81112588:	00a045b4 	movhi	r2,33046
8111258c:	10aee404 	addi	r2,r2,-17520
81112590:	d8800115 	stw	r2,4(sp)
81112594:	008006c4 	movi	r2,27
81112598:	d8800015 	stw	r2,0(sp)
8111259c:	01c006c4 	movi	r7,27
811125a0:	01a045b4 	movhi	r6,33046
811125a4:	31b2e304 	addi	r6,r6,-13428
811125a8:	000b883a 	mov	r5,zero
811125ac:	01204474 	movhi	r4,33041
811125b0:	210bf804 	addi	r4,r4,12256
811125b4:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
811125b8:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811125bc:	e0bffe03 	ldbu	r2,-8(fp)
811125c0:	10803fcc 	andi	r2,r2,255
811125c4:	10000526 	beq	r2,zero,811125dc <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811125c8:	e0bffe03 	ldbu	r2,-8(fp)
811125cc:	10803fcc 	andi	r2,r2,255
811125d0:	1009883a 	mov	r4,r2
811125d4:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
811125d8:	111c2f40 	call	8111c2f4 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811125dc:	01c03204 	movi	r7,200
811125e0:	000d883a 	mov	r6,zero
811125e4:	000b883a 	mov	r5,zero
811125e8:	0009883a 	mov	r4,zero
811125ec:	11408140 	call	81140814 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
811125f0:	d8000415 	stw	zero,16(sp)
811125f4:	d8000315 	stw	zero,12(sp)
811125f8:	00810004 	movi	r2,1024
811125fc:	d8800215 	stw	r2,8(sp)
81112600:	00a04574 	movhi	r2,33045
81112604:	1092c004 	addi	r2,r2,19200
81112608:	d8800115 	stw	r2,4(sp)
8111260c:	00800644 	movi	r2,25
81112610:	d8800015 	stw	r2,0(sp)
81112614:	01c00644 	movi	r7,25
81112618:	01a04574 	movhi	r6,33045
8111261c:	3196bf04 	addi	r6,r6,23292
81112620:	000b883a 	mov	r5,zero
81112624:	01204474 	movhi	r4,33041
81112628:	2106f004 	addi	r4,r4,7104
8111262c:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
81112630:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112634:	e0bffe03 	ldbu	r2,-8(fp)
81112638:	10803fcc 	andi	r2,r2,255
8111263c:	10000526 	beq	r2,zero,81112654 <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81112640:	e0bffe03 	ldbu	r2,-8(fp)
81112644:	10803fcc 	andi	r2,r2,255
81112648:	1009883a 	mov	r4,r2
8111264c:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
81112650:	111c2a80 	call	8111c2a8 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112654:	01c03204 	movi	r7,200
81112658:	000d883a 	mov	r6,zero
8111265c:	000b883a 	mov	r5,zero
81112660:	0009883a 	mov	r4,zero
81112664:	11408140 	call	81140814 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81112668:	d8000415 	stw	zero,16(sp)
8111266c:	d8000315 	stw	zero,12(sp)
81112670:	00818004 	movi	r2,1536
81112674:	d8800215 	stw	r2,8(sp)
81112678:	00a045b4 	movhi	r2,33046
8111267c:	10882204 	addi	r2,r2,8328
81112680:	d8800115 	stw	r2,4(sp)
81112684:	00800704 	movi	r2,28
81112688:	d8800015 	stw	r2,0(sp)
8111268c:	01c00704 	movi	r7,28
81112690:	01a045b4 	movhi	r6,33046
81112694:	318e2104 	addi	r6,r6,14468
81112698:	000b883a 	mov	r5,zero
8111269c:	01204474 	movhi	r4,33041
811126a0:	210cb604 	addi	r4,r4,13016
811126a4:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
811126a8:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811126ac:	e0bffe03 	ldbu	r2,-8(fp)
811126b0:	10803fcc 	andi	r2,r2,255
811126b4:	10000526 	beq	r2,zero,811126cc <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
811126b8:	e0bffe03 	ldbu	r2,-8(fp)
811126bc:	10803fcc 	andi	r2,r2,255
811126c0:	1009883a 	mov	r4,r2
811126c4:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
811126c8:	111c25c0 	call	8111c25c <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811126cc:	01c03204 	movi	r7,200
811126d0:	000d883a 	mov	r6,zero
811126d4:	000b883a 	mov	r5,zero
811126d8:	0009883a 	mov	r4,zero
811126dc:	11408140 	call	81140814 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
811126e0:	d8000415 	stw	zero,16(sp)
811126e4:	d8000315 	stw	zero,12(sp)
811126e8:	00818004 	movi	r2,1536
811126ec:	d8800215 	stw	r2,8(sp)
811126f0:	00a045b4 	movhi	r2,33046
811126f4:	10a8d404 	addi	r2,r2,-23728
811126f8:	d8800115 	stw	r2,4(sp)
811126fc:	00800804 	movi	r2,32
81112700:	d8800015 	stw	r2,0(sp)
81112704:	01c00804 	movi	r7,32
81112708:	01a045b4 	movhi	r6,33046
8111270c:	31aed304 	addi	r6,r6,-17588
81112710:	000b883a 	mov	r5,zero
81112714:	01204474 	movhi	r4,33041
81112718:	2110d204 	addi	r4,r4,17224
8111271c:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
81112720:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81112724:	e0bffe03 	ldbu	r2,-8(fp)
81112728:	10803fcc 	andi	r2,r2,255
8111272c:	10000526 	beq	r2,zero,81112744 <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81112730:	e0bffe03 	ldbu	r2,-8(fp)
81112734:	10803fcc 	andi	r2,r2,255
81112738:	1009883a 	mov	r4,r2
8111273c:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
		vFailReceiverCreate();
81112740:	111bb600 	call	8111bb60 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81112744:	01c03204 	movi	r7,200
81112748:	000d883a 	mov	r6,zero
8111274c:	000b883a 	mov	r5,zero
81112750:	0009883a 	mov	r4,zero
81112754:	11408140 	call	81140814 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
81112758:	d8000415 	stw	zero,16(sp)
8111275c:	d8000315 	stw	zero,12(sp)
81112760:	00810004 	movi	r2,1024
81112764:	d8800215 	stw	r2,8(sp)
81112768:	00a04574 	movhi	r2,33045
8111276c:	1097bc04 	addi	r2,r2,24304
81112770:	d8800115 	stw	r2,4(sp)
81112774:	00800684 	movi	r2,26
81112778:	d8800015 	stw	r2,0(sp)
8111277c:	01c00684 	movi	r7,26
81112780:	01a04574 	movhi	r6,33045
81112784:	319bbb04 	addi	r6,r6,28396
81112788:	000b883a 	mov	r5,zero
8111278c:	01204474 	movhi	r4,33041
81112790:	21135404 	addi	r4,r4,19792
81112794:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
81112798:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8111279c:	01c03204 	movi	r7,200
811127a0:	000d883a 	mov	r6,zero
811127a4:	000b883a 	mov	r5,zero
811127a8:	0009883a 	mov	r4,zero
811127ac:	11408140 	call	81140814 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
811127b0:	e0bffe03 	ldbu	r2,-8(fp)
811127b4:	10803fcc 	andi	r2,r2,255
811127b8:	10000526 	beq	r2,zero,811127d0 <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
811127bc:	e0bffe03 	ldbu	r2,-8(fp)
811127c0:	10803fcc 	andi	r2,r2,255
811127c4:	1009883a 	mov	r4,r2
811127c8:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
		vFailSenderCreate();
811127cc:	111bbac0 	call	8111bbac <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
811127d0:	d0a06d17 	ldw	r2,-32332(gp)
811127d4:	e17ffe04 	addi	r5,fp,-8
811127d8:	1009883a 	mov	r4,r2
811127dc:	11413080 	call	81141308 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
811127e0:	e0bffe03 	ldbu	r2,-8(fp)
811127e4:	10803fcc 	andi	r2,r2,255
811127e8:	10000126 	beq	r2,zero,811127f0 <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
811127ec:	111c6940 	call	8111c694 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
811127f0:	01c00084 	movi	r7,2
811127f4:	01800784 	movi	r6,30
811127f8:	000b883a 	mov	r5,zero
811127fc:	0009883a 	mov	r4,zero
81112800:	11408140 	call	81140814 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
81112804:	01003fc4 	movi	r4,255
81112808:	113f7d40 	call	8113f7d4 <OSTaskDel>
8111280c:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
81112810:	e0bffe03 	ldbu	r2,-8(fp)
81112814:	10803fcc 	andi	r2,r2,255
81112818:	10001026 	beq	r2,zero,8111285c <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8111281c:	e0bffe03 	ldbu	r2,-8(fp)
81112820:	10803fcc 	andi	r2,r2,255
81112824:	1009883a 	mov	r4,r2
81112828:	111b5c00 	call	8111b5c0 <printErrorTask>
		#endif
		vFailDeleteInitialization();
8111282c:	111bbf80 	call	8111bbf8 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
81112830:	014009c4 	movi	r5,39
81112834:	01000044 	movi	r4,1
81112838:	113ef3c0 	call	8113ef3c <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8111283c:	01003fc4 	movi	r4,255
81112840:	113f7d40 	call	8113f7d4 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
81112844:	000f883a 	mov	r7,zero
81112848:	01800284 	movi	r6,10
8111284c:	000b883a 	mov	r5,zero
81112850:	0009883a 	mov	r4,zero
81112854:	11408140 	call	81140814 <OSTimeDlyHMSM>
		}
81112858:	003ff806 	br	8111283c <__reset+0xfb0f283c>
	}

}
8111285c:	0001883a 	nop
81112860:	e037883a 	mov	sp,fp
81112864:	dfc00117 	ldw	ra,4(sp)
81112868:	df000017 	ldw	fp,0(sp)
8111286c:	dec00204 	addi	sp,sp,8
81112870:	f800283a 	ret

81112874 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
81112874:	defff804 	addi	sp,sp,-32
81112878:	de00012e 	bgeu	sp,et,81112880 <vNFeeControlTask+0xc>
8111287c:	003b68fa 	trap	3
81112880:	dfc00715 	stw	ra,28(sp)
81112884:	df000615 	stw	fp,24(sp)
81112888:	df000604 	addi	fp,sp,24
8111288c:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
81112890:	e0bfff17 	ldw	r2,-4(fp)
81112894:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
81112898:	d0a06217 	ldw	r2,-32376(gp)
8111289c:	100f883a 	mov	r7,r2
811128a0:	01800804 	movi	r6,32
811128a4:	01400044 	movi	r5,1
811128a8:	01204574 	movhi	r4,33045
811128ac:	21353f04 	addi	r4,r4,-11012
811128b0:	11219e00 	call	811219e0 <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
811128b4:	e0bffb17 	ldw	r2,-20(fp)
811128b8:	10809a17 	ldw	r2,616(r2)
811128bc:	10c00168 	cmpgeui	r3,r2,5
811128c0:	1800da1e 	bne	r3,zero,81112c2c <vNFeeControlTask+0x3b8>
811128c4:	100690ba 	slli	r3,r2,2
811128c8:	00a04474 	movhi	r2,33041
811128cc:	108a3704 	addi	r2,r2,10460
811128d0:	1885883a 	add	r2,r3,r2
811128d4:	10800017 	ldw	r2,0(r2)
811128d8:	1000683a 	jmp	r2
811128dc:	811128f0 	cmpltui	r4,r16,17571
811128e0:	81112920 	cmpeqi	r4,r16,17572
811128e4:	81112980 	call	88111298 <__reset+0x20f1298>
811128e8:	81112a34 	orhi	r4,r16,17576
811128ec:	81112a94 	ori	r4,r16,17578
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
811128f0:	d0a07017 	ldw	r2,-32320(gp)
811128f4:	1009883a 	mov	r4,r2
811128f8:	113d8c40 	call	8113d8c4 <OSQFlush>
811128fc:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81112900:	e0bffe03 	ldbu	r2,-8(fp)
81112904:	10803fcc 	andi	r2,r2,255
81112908:	10000126 	beq	r2,zero,81112910 <vNFeeControlTask+0x9c>
					vFailFlushQueue();
8111290c:	111d3f00 	call	8111d3f0 <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
81112910:	e0bffb17 	ldw	r2,-20(fp)
81112914:	00c00044 	movi	r3,1
81112918:	10c09a15 	stw	r3,616(r2)
				break;
8111291c:	0000cf06 	br	81112c5c <vNFeeControlTask+0x3e8>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
81112920:	d0a06217 	ldw	r2,-32376(gp)
81112924:	100f883a 	mov	r7,r2
81112928:	018008c4 	movi	r6,35
8111292c:	01400044 	movi	r5,1
81112930:	01204574 	movhi	r4,33045
81112934:	21354804 	addi	r4,r4,-10976
81112938:	11219e00 	call	811219e0 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8111293c:	d0a05d17 	ldw	r2,-32396(gp)
81112940:	1009883a 	mov	r4,r2
81112944:	113d8c40 	call	8113d8c4 <OSQFlush>
81112948:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8111294c:	e0bffe03 	ldbu	r2,-8(fp)
81112950:	10803fcc 	andi	r2,r2,255
81112954:	10000126 	beq	r2,zero,8111295c <vNFeeControlTask+0xe8>
					vFailFlushQueue();
81112958:	111d3f00 	call	8111d3f0 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
8111295c:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
81112960:	00800044 	movi	r2,1
81112964:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81112968:	00bfffc4 	movi	r2,-1
8111296c:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebConfig;
81112970:	e0bffb17 	ldw	r2,-20(fp)
81112974:	00c000c4 	movi	r3,3
81112978:	10c09a15 	stw	r3,616(r2)
				break;
8111297c:	0000b706 	br	81112c5c <vNFeeControlTask+0x3e8>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
81112980:	111d5480 	call	8111d548 <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
81112984:	d0a06217 	ldw	r2,-32376(gp)
81112988:	100f883a 	mov	r7,r2
8111298c:	01800804 	movi	r6,32
81112990:	01400044 	movi	r5,1
81112994:	01204574 	movhi	r4,33045
81112998:	21355104 	addi	r4,r4,-10940
8111299c:	11219e00 	call	811219e0 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
811129a0:	d0a05d17 	ldw	r2,-32396(gp)
811129a4:	1009883a 	mov	r4,r2
811129a8:	113d8c40 	call	8113d8c4 <OSQFlush>
811129ac:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
811129b0:	e0bffe03 	ldbu	r2,-8(fp)
811129b4:	10803fcc 	andi	r2,r2,255
811129b8:	10000126 	beq	r2,zero,811129c0 <vNFeeControlTask+0x14c>
					vFailFlushQueue();
811129bc:	111d3f00 	call	8111d3f0 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
811129c0:	e03ffa45 	stb	zero,-23(fp)
811129c4:	00001006 	br	81112a08 <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
811129c8:	e0bffa43 	ldbu	r2,-23(fp)
811129cc:	1085883a 	add	r2,r2,r2
811129d0:	1087883a 	add	r3,r2,r2
811129d4:	d0a06a04 	addi	r2,gp,-32344
811129d8:	1885883a 	add	r2,r3,r2
811129dc:	10800017 	ldw	r2,0(r2)
811129e0:	1009883a 	mov	r4,r2
811129e4:	113d8c40 	call	8113d8c4 <OSQFlush>
811129e8:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
811129ec:	e0bffe03 	ldbu	r2,-8(fp)
811129f0:	10803fcc 	andi	r2,r2,255
811129f4:	10000126 	beq	r2,zero,811129fc <vNFeeControlTask+0x188>
						vFailFlushQueue();
811129f8:	111d3f00 	call	8111d3f0 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
811129fc:	e0bffa43 	ldbu	r2,-23(fp)
81112a00:	10800044 	addi	r2,r2,1
81112a04:	e0bffa45 	stb	r2,-23(fp)
81112a08:	e0bffa43 	ldbu	r2,-23(fp)
81112a0c:	103fee26 	beq	r2,zero,811129c8 <__reset+0xfb0f29c8>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
81112a10:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
81112a14:	00800044 	movi	r2,1
81112a18:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
81112a1c:	00bfffc4 	movi	r2,-1
81112a20:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebRun;
81112a24:	e0bffb17 	ldw	r2,-20(fp)
81112a28:	00c00104 	movi	r3,4
81112a2c:	10c09a15 	stw	r3,616(r2)
				break;
81112a30:	00008a06 	br	81112c5c <vNFeeControlTask+0x3e8>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
81112a34:	d0a07017 	ldw	r2,-32320(gp)
81112a38:	e0fffe04 	addi	r3,fp,-8
81112a3c:	180d883a 	mov	r6,r3
81112a40:	000b883a 	mov	r5,zero
81112a44:	1009883a 	mov	r4,r2
81112a48:	113d9840 	call	8113d984 <OSQPend>
81112a4c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81112a50:	e0bffe03 	ldbu	r2,-8(fp)
81112a54:	10803fcc 	andi	r2,r2,255
81112a58:	10000c1e 	bne	r2,zero,81112a8c <vNFeeControlTask+0x218>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81112a5c:	e0bffdc3 	ldbu	r2,-9(fp)
81112a60:	10803fcc 	andi	r2,r2,255
81112a64:	10800418 	cmpnei	r2,r2,16
81112a68:	1000041e 	bne	r2,zero,81112a7c <vNFeeControlTask+0x208>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
81112a6c:	e0bffd17 	ldw	r2,-12(fp)
81112a70:	e17ffb17 	ldw	r5,-20(fp)
81112a74:	1009883a 	mov	r4,r2
81112a78:	1112c600 	call	81112c60 <vPerformActionNFCConfig>

					};
					bCmdSent = FALSE;
81112a7c:	e03ffc15 	stw	zero,-16(fp)
					bDmaBack = TRUE;
81112a80:	00800044 	movi	r2,1
81112a84:	d0a05815 	stw	r2,-32416(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81112a88:	00007406 	br	81112c5c <vNFeeControlTask+0x3e8>
					};
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81112a8c:	111d0440 	call	8111d044 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81112a90:	00007206 	br	81112c5c <vNFeeControlTask+0x3e8>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81112a94:	d0a05817 	ldw	r2,-32416(gp)
81112a98:	10800058 	cmpnei	r2,r2,1
81112a9c:	1000221e 	bne	r2,zero,81112b28 <vNFeeControlTask+0x2b4>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81112aa0:	d0a05d17 	ldw	r2,-32396(gp)
81112aa4:	e0fffe04 	addi	r3,fp,-8
81112aa8:	180d883a 	mov	r6,r3
81112aac:	01400104 	movi	r5,4
81112ab0:	1009883a 	mov	r4,r2
81112ab4:	113d9840 	call	8113d984 <OSQPend>
81112ab8:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
81112abc:	e0bffe03 	ldbu	r2,-8(fp)
81112ac0:	10803fcc 	andi	r2,r2,255
81112ac4:	1000181e 	bne	r2,zero,81112b28 <vNFeeControlTask+0x2b4>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81112ac8:	e0bffd03 	ldbu	r2,-12(fp)
81112acc:	e0bffa05 	stb	r2,-24(fp)


						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
81112ad0:	e0bffa03 	ldbu	r2,-24(fp)
81112ad4:	e0fffb17 	ldw	r3,-20(fp)
81112ad8:	10809624 	muli	r2,r2,600
81112adc:	1885883a 	add	r2,r3,r2
81112ae0:	10802304 	addi	r2,r2,140
81112ae4:	10800017 	ldw	r2,0(r2)
81112ae8:	10800058 	cmpnei	r2,r2,1
81112aec:	10000e1e 	bne	r2,zero,81112b28 <vNFeeControlTask+0x2b4>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
81112af0:	e0bffa03 	ldbu	r2,-24(fp)
81112af4:	e0fffa03 	ldbu	r3,-24(fp)
81112af8:	180f883a 	mov	r7,r3
81112afc:	000d883a 	mov	r6,zero
81112b00:	014023c4 	movi	r5,143
81112b04:	1009883a 	mov	r4,r2
81112b08:	1112e500 	call	81112e50 <bSendCmdQToNFeeInst>
81112b0c:	e0bffc15 	stw	r2,-16(fp)
							if ( bCmdSent == TRUE ) {
81112b10:	e0bffc17 	ldw	r2,-16(fp)
81112b14:	10800058 	cmpnei	r2,r2,1
81112b18:	1000031e 	bne	r2,zero,81112b28 <vNFeeControlTask+0x2b4>
								bDmaBack = FALSE;
81112b1c:	d0205815 	stw	zero,-32416(gp)
								ucWhoGetDMA = ucFeeInstL;
81112b20:	e0bffa03 	ldbu	r2,-24(fp)
81112b24:	d0a05905 	stb	r2,-32412(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
81112b28:	d0a05817 	ldw	r2,-32416(gp)
81112b2c:	1000081e 	bne	r2,zero,81112b50 <vNFeeControlTask+0x2dc>

					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
81112b30:	d0a07017 	ldw	r2,-32320(gp)
81112b34:	e0fffe04 	addi	r3,fp,-8
81112b38:	180d883a 	mov	r6,r3
81112b3c:	000b883a 	mov	r5,zero
81112b40:	1009883a 	mov	r4,r2
81112b44:	113d9840 	call	8113d984 <OSQPend>
81112b48:	e0bffd15 	stw	r2,-12(fp)
81112b4c:	00000706 	br	81112b6c <vNFeeControlTask+0x2f8>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81112b50:	d0a07017 	ldw	r2,-32320(gp)
81112b54:	e0fffe04 	addi	r3,fp,-8
81112b58:	180d883a 	mov	r6,r3
81112b5c:	01400104 	movi	r5,4
81112b60:	1009883a 	mov	r4,r2
81112b64:	113d9840 	call	8113d984 <OSQPend>
81112b68:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
81112b6c:	e0bffe03 	ldbu	r2,-8(fp)
81112b70:	10803fcc 	andi	r2,r2,255
81112b74:	1000381e 	bne	r2,zero,81112c58 <vNFeeControlTask+0x3e4>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81112b78:	e0bffd83 	ldbu	r2,-10(fp)
81112b7c:	10803fcc 	andi	r2,r2,255
81112b80:	10802058 	cmpnei	r2,r2,129
81112b84:	1000091e 	bne	r2,zero,81112bac <vNFeeControlTask+0x338>
						if ( uiCmdNFC.ucByte[0] == ucFeeInstL ){
81112b88:	e0bffd03 	ldbu	r2,-12(fp)
81112b8c:	10c03fcc 	andi	r3,r2,255
81112b90:	e0bffa03 	ldbu	r2,-24(fp)
81112b94:	1880301e 	bne	r3,r2,81112c58 <vNFeeControlTask+0x3e4>
							bDmaBack = TRUE;
81112b98:	00800044 	movi	r2,1
81112b9c:	d0a05815 	stw	r2,-32416(gp)
							ucFeeInstL = 255;
81112ba0:	00bfffc4 	movi	r2,-1
81112ba4:	e0bffa05 	stb	r2,-24(fp)
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
81112ba8:	00002b06 	br	81112c58 <vNFeeControlTask+0x3e4>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81112bac:	e0bffdc3 	ldbu	r2,-9(fp)
81112bb0:	10803fcc 	andi	r2,r2,255
81112bb4:	10800418 	cmpnei	r2,r2,16
81112bb8:	1000051e 	bne	r2,zero,81112bd0 <vNFeeControlTask+0x35c>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81112bbc:	e0bffd17 	ldw	r2,-12(fp)
81112bc0:	e17ffb17 	ldw	r5,-20(fp)
81112bc4:	1009883a 	mov	r4,r2
81112bc8:	1112d280 	call	81112d28 <vPerformActionNFCRunning>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
81112bcc:	00002206 	br	81112c58 <vNFeeControlTask+0x3e4>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
81112bd0:	e0bffdc3 	ldbu	r2,-9(fp)
81112bd4:	10803fcc 	andi	r2,r2,255
81112bd8:	10800470 	cmpltui	r2,r2,17
81112bdc:	10001e1e 	bne	r2,zero,81112c58 <vNFeeControlTask+0x3e4>
81112be0:	e0bffdc3 	ldbu	r2,-9(fp)
81112be4:	10803fcc 	andi	r2,r2,255
81112be8:	108004e8 	cmpgeui	r2,r2,19
81112bec:	10001a1e 	bne	r2,zero,81112c58 <vNFeeControlTask+0x3e4>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
81112bf0:	e0bffdc3 	ldbu	r2,-9(fp)
81112bf4:	10bffbc4 	addi	r2,r2,-17
81112bf8:	10803fcc 	andi	r2,r2,255
81112bfc:	e0fffd83 	ldbu	r3,-10(fp)
81112c00:	18c03fcc 	andi	r3,r3,255
81112c04:	e13ffd43 	ldbu	r4,-11(fp)
81112c08:	21003fcc 	andi	r4,r4,255
81112c0c:	e17ffd03 	ldbu	r5,-12(fp)
81112c10:	29403fcc 	andi	r5,r5,255
81112c14:	280f883a 	mov	r7,r5
81112c18:	200d883a 	mov	r6,r4
81112c1c:	180b883a 	mov	r5,r3
81112c20:	1009883a 	mov	r4,r2
81112c24:	1112e500 	call	81112e50 <bSendCmdQToNFeeInst>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
81112c28:	00000b06 	br	81112c58 <vNFeeControlTask+0x3e4>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81112c2c:	d0a06217 	ldw	r2,-32376(gp)
81112c30:	100f883a 	mov	r7,r2
81112c34:	01800f44 	movi	r6,61
81112c38:	01400044 	movi	r5,1
81112c3c:	01204574 	movhi	r4,33045
81112c40:	21355a04 	addi	r4,r4,-10904
81112c44:	11219e00 	call	811219e0 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
81112c48:	e0bffb17 	ldw	r2,-20(fp)
81112c4c:	00c000c4 	movi	r3,3
81112c50:	10c09a15 	stw	r3,616(r2)
				break;
81112c54:	00000106 	br	81112c5c <vNFeeControlTask+0x3e8>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
81112c58:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
81112c5c:	003f1506 	br	811128b4 <__reset+0xfb0f28b4>

81112c60 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81112c60:	defffb04 	addi	sp,sp,-20
81112c64:	de00012e 	bgeu	sp,et,81112c6c <vPerformActionNFCConfig+0xc>
81112c68:	003b68fa 	trap	3
81112c6c:	dfc00415 	stw	ra,16(sp)
81112c70:	df000315 	stw	fp,12(sp)
81112c74:	df000304 	addi	fp,sp,12
81112c78:	e13ffe15 	stw	r4,-8(fp)
81112c7c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81112c80:	e0bffe17 	ldw	r2,-8(fp)
81112c84:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81112c88:	e0bffd83 	ldbu	r2,-10(fp)
81112c8c:	10803fcc 	andi	r2,r2,255
81112c90:	10c000a0 	cmpeqi	r3,r2,2
81112c94:	1800121e 	bne	r3,zero,81112ce0 <vPerformActionNFCConfig+0x80>
81112c98:	10c000c8 	cmpgei	r3,r2,3
81112c9c:	1800031e 	bne	r3,zero,81112cac <vPerformActionNFCConfig+0x4c>
81112ca0:	10800060 	cmpeqi	r2,r2,1
81112ca4:	1000061e 	bne	r2,zero,81112cc0 <vPerformActionNFCConfig+0x60>
81112ca8:	00001106 	br	81112cf0 <vPerformActionNFCConfig+0x90>
81112cac:	10c02860 	cmpeqi	r3,r2,161
81112cb0:	1800031e 	bne	r3,zero,81112cc0 <vPerformActionNFCConfig+0x60>
81112cb4:	108028a0 	cmpeqi	r2,r2,162
81112cb8:	1000091e 	bne	r2,zero,81112ce0 <vPerformActionNFCConfig+0x80>
81112cbc:	00000c06 	br	81112cf0 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
81112cc0:	d0a06217 	ldw	r2,-32376(gp)
81112cc4:	100f883a 	mov	r7,r2
81112cc8:	01800d44 	movi	r6,53
81112ccc:	01400044 	movi	r5,1
81112cd0:	01204574 	movhi	r4,33045
81112cd4:	21356a04 	addi	r4,r4,-10840
81112cd8:	11219e00 	call	811219e0 <fwrite>
			#endif
			/* Do nothing for now */
			break;
81112cdc:	00000c06 	br	81112d10 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
81112ce0:	e0bfff17 	ldw	r2,-4(fp)
81112ce4:	00c00084 	movi	r3,2
81112ce8:	10c09a15 	stw	r3,616(r2)
			break;
81112cec:	00000806 	br	81112d10 <vPerformActionNFCConfig+0xb0>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81112cf0:	d0a06217 	ldw	r2,-32376(gp)
81112cf4:	100f883a 	mov	r7,r2
81112cf8:	018009c4 	movi	r6,39
81112cfc:	01400044 	movi	r5,1
81112d00:	01204574 	movhi	r4,33045
81112d04:	21357804 	addi	r4,r4,-10784
81112d08:	11219e00 	call	811219e0 <fwrite>
			#endif	
			break;
81112d0c:	0001883a 	nop
	}

}
81112d10:	0001883a 	nop
81112d14:	e037883a 	mov	sp,fp
81112d18:	dfc00117 	ldw	ra,4(sp)
81112d1c:	df000017 	ldw	fp,0(sp)
81112d20:	dec00204 	addi	sp,sp,8
81112d24:	f800283a 	ret

81112d28 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81112d28:	defffa04 	addi	sp,sp,-24
81112d2c:	de00012e 	bgeu	sp,et,81112d34 <vPerformActionNFCRunning+0xc>
81112d30:	003b68fa 	trap	3
81112d34:	dfc00515 	stw	ra,20(sp)
81112d38:	df000415 	stw	fp,16(sp)
81112d3c:	df000404 	addi	fp,sp,16
81112d40:	e13ffe15 	stw	r4,-8(fp)
81112d44:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81112d48:	e0bffe17 	ldw	r2,-8(fp)
81112d4c:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81112d50:	e0bffd83 	ldbu	r2,-10(fp)
81112d54:	10803fcc 	andi	r2,r2,255
81112d58:	10c02088 	cmpgei	r3,r2,130
81112d5c:	1800071e 	bne	r3,zero,81112d7c <vPerformActionNFCRunning+0x54>
81112d60:	10c02008 	cmpgei	r3,r2,128
81112d64:	1800331e 	bne	r3,zero,81112e34 <vPerformActionNFCRunning+0x10c>
81112d68:	10c00060 	cmpeqi	r3,r2,1
81112d6c:	1800051e 	bne	r3,zero,81112d84 <vPerformActionNFCRunning+0x5c>
81112d70:	108000a0 	cmpeqi	r2,r2,2
81112d74:	10001f1e 	bne	r2,zero,81112df4 <vPerformActionNFCRunning+0xcc>
81112d78:	00002606 	br	81112e14 <vPerformActionNFCRunning+0xec>
81112d7c:	10802860 	cmpeqi	r2,r2,161
81112d80:	10002426 	beq	r2,zero,81112e14 <vPerformActionNFCRunning+0xec>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
81112d84:	e0bfff17 	ldw	r2,-4(fp)
81112d88:	00c00044 	movi	r3,1
81112d8c:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81112d90:	e03ffc05 	stb	zero,-16(fp)
81112d94:	00001406 	br	81112de8 <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
81112d98:	e0bffc03 	ldbu	r2,-16(fp)
81112d9c:	e0ffff17 	ldw	r3,-4(fp)
81112da0:	108025c4 	addi	r2,r2,151
81112da4:	1085883a 	add	r2,r2,r2
81112da8:	1085883a 	add	r2,r2,r2
81112dac:	1885883a 	add	r2,r3,r2
81112db0:	10800017 	ldw	r2,0(r2)
81112db4:	10800017 	ldw	r2,0(r2)
81112db8:	10800058 	cmpnei	r2,r2,1
81112dbc:	1000071e 	bne	r2,zero,81112ddc <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
81112dc0:	e0bffc03 	ldbu	r2,-16(fp)
81112dc4:	e0fffc03 	ldbu	r3,-16(fp)
81112dc8:	180f883a 	mov	r7,r3
81112dcc:	000d883a 	mov	r6,zero
81112dd0:	01402844 	movi	r5,161
81112dd4:	1009883a 	mov	r4,r2
81112dd8:	1112f180 	call	81112f18 <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81112ddc:	e0bffc03 	ldbu	r2,-16(fp)
81112de0:	10800044 	addi	r2,r2,1
81112de4:	e0bffc05 	stb	r2,-16(fp)
81112de8:	e0bffc03 	ldbu	r2,-16(fp)
81112dec:	103fea26 	beq	r2,zero,81112d98 <__reset+0xfb0f2d98>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81112df0:	00001106 	br	81112e38 <vPerformActionNFCRunning+0x110>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81112df4:	d0a06217 	ldw	r2,-32376(gp)
81112df8:	100f883a 	mov	r7,r2
81112dfc:	01800d84 	movi	r6,54
81112e00:	01400044 	movi	r5,1
81112e04:	01204574 	movhi	r4,33045
81112e08:	21358204 	addi	r4,r4,-10744
81112e0c:	11219e00 	call	811219e0 <fwrite>
			#endif		
			/* Do nothing for now */

			break;
81112e10:	00000906 	br	81112e38 <vPerformActionNFCRunning+0x110>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81112e14:	d0a06217 	ldw	r2,-32376(gp)
81112e18:	100f883a 	mov	r7,r2
81112e1c:	018009c4 	movi	r6,39
81112e20:	01400044 	movi	r5,1
81112e24:	01204574 	movhi	r4,33045
81112e28:	21357804 	addi	r4,r4,-10784
81112e2c:	11219e00 	call	811219e0 <fwrite>
			#endif	
			break;
81112e30:	00000106 	br	81112e38 <vPerformActionNFCRunning+0x110>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
81112e34:	0001883a 	nop
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
	}
}
81112e38:	0001883a 	nop
81112e3c:	e037883a 	mov	sp,fp
81112e40:	dfc00117 	ldw	ra,4(sp)
81112e44:	df000017 	ldw	fp,0(sp)
81112e48:	dec00204 	addi	sp,sp,8
81112e4c:	f800283a 	ret

81112e50 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112e50:	defff704 	addi	sp,sp,-36
81112e54:	de00012e 	bgeu	sp,et,81112e5c <bSendCmdQToNFeeInst+0xc>
81112e58:	003b68fa 	trap	3
81112e5c:	dfc00815 	stw	ra,32(sp)
81112e60:	df000715 	stw	fp,28(sp)
81112e64:	df000704 	addi	fp,sp,28
81112e68:	2011883a 	mov	r8,r4
81112e6c:	2809883a 	mov	r4,r5
81112e70:	3007883a 	mov	r3,r6
81112e74:	3805883a 	mov	r2,r7
81112e78:	e23ffc05 	stb	r8,-16(fp)
81112e7c:	e13ffd05 	stb	r4,-12(fp)
81112e80:	e0fffe05 	stb	r3,-8(fp)
81112e84:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81112e88:	e0bffc03 	ldbu	r2,-16(fp)
81112e8c:	10800444 	addi	r2,r2,17
81112e90:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112e94:	e0bffd03 	ldbu	r2,-12(fp)
81112e98:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112e9c:	e0bffe03 	ldbu	r2,-8(fp)
81112ea0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112ea4:	e0bfff03 	ldbu	r2,-4(fp)
81112ea8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81112eac:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81112eb0:	e0bffc03 	ldbu	r2,-16(fp)
81112eb4:	1085883a 	add	r2,r2,r2
81112eb8:	1087883a 	add	r3,r2,r2
81112ebc:	d0a06a04 	addi	r2,gp,-32344
81112ec0:	1885883a 	add	r2,r3,r2
81112ec4:	10800017 	ldw	r2,0(r2)
81112ec8:	e0fffb17 	ldw	r3,-20(fp)
81112ecc:	180b883a 	mov	r5,r3
81112ed0:	1009883a 	mov	r4,r2
81112ed4:	113dd8c0 	call	8113dd8c <OSQPost>
81112ed8:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112edc:	e0bffa03 	ldbu	r2,-24(fp)
81112ee0:	10000526 	beq	r2,zero,81112ef8 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81112ee4:	e0bffc03 	ldbu	r2,-16(fp)
81112ee8:	1009883a 	mov	r4,r2
81112eec:	111d1140 	call	8111d114 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81112ef0:	e03ff915 	stw	zero,-28(fp)
81112ef4:	00000206 	br	81112f00 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81112ef8:	00800044 	movi	r2,1
81112efc:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81112f00:	e0bff917 	ldw	r2,-28(fp)
}
81112f04:	e037883a 	mov	sp,fp
81112f08:	dfc00117 	ldw	ra,4(sp)
81112f0c:	df000017 	ldw	fp,0(sp)
81112f10:	dec00204 	addi	sp,sp,8
81112f14:	f800283a 	ret

81112f18 <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112f18:	defff704 	addi	sp,sp,-36
81112f1c:	de00012e 	bgeu	sp,et,81112f24 <bSendCmdQToNFeeInst_Prio+0xc>
81112f20:	003b68fa 	trap	3
81112f24:	dfc00815 	stw	ra,32(sp)
81112f28:	df000715 	stw	fp,28(sp)
81112f2c:	df000704 	addi	fp,sp,28
81112f30:	2011883a 	mov	r8,r4
81112f34:	2809883a 	mov	r4,r5
81112f38:	3007883a 	mov	r3,r6
81112f3c:	3805883a 	mov	r2,r7
81112f40:	e23ffc05 	stb	r8,-16(fp)
81112f44:	e13ffd05 	stb	r4,-12(fp)
81112f48:	e0fffe05 	stb	r3,-8(fp)
81112f4c:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81112f50:	e0bffc03 	ldbu	r2,-16(fp)
81112f54:	10800444 	addi	r2,r2,17
81112f58:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112f5c:	e0bffd03 	ldbu	r2,-12(fp)
81112f60:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112f64:	e0bffe03 	ldbu	r2,-8(fp)
81112f68:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112f6c:	e0bfff03 	ldbu	r2,-4(fp)
81112f70:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81112f74:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81112f78:	e0bffc03 	ldbu	r2,-16(fp)
81112f7c:	1085883a 	add	r2,r2,r2
81112f80:	1087883a 	add	r3,r2,r2
81112f84:	d0a06a04 	addi	r2,gp,-32344
81112f88:	1885883a 	add	r2,r3,r2
81112f8c:	10800017 	ldw	r2,0(r2)
81112f90:	e0fffb17 	ldw	r3,-20(fp)
81112f94:	180b883a 	mov	r5,r3
81112f98:	1009883a 	mov	r4,r2
81112f9c:	113defc0 	call	8113defc <OSQPostFront>
81112fa0:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112fa4:	e0bffa03 	ldbu	r2,-24(fp)
81112fa8:	10000526 	beq	r2,zero,81112fc0 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81112fac:	e0bffc03 	ldbu	r2,-16(fp)
81112fb0:	1009883a 	mov	r4,r2
81112fb4:	111d1140 	call	8111d114 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81112fb8:	e03ff915 	stw	zero,-28(fp)
81112fbc:	00000206 	br	81112fc8 <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
81112fc0:	00800044 	movi	r2,1
81112fc4:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81112fc8:	e0bff917 	ldw	r2,-28(fp)
}
81112fcc:	e037883a 	mov	sp,fp
81112fd0:	dfc00117 	ldw	ra,4(sp)
81112fd4:	df000017 	ldw	fp,0(sp)
81112fd8:	dec00204 	addi	sp,sp,8
81112fdc:	f800283a 	ret

81112fe0 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81112fe0:	defff704 	addi	sp,sp,-36
81112fe4:	de00012e 	bgeu	sp,et,81112fec <vOutAckHandlerTask+0xc>
81112fe8:	003b68fa 	trap	3
81112fec:	dfc00815 	stw	ra,32(sp)
81112ff0:	df000715 	stw	fp,28(sp)
81112ff4:	df000704 	addi	fp,sp,28
81112ff8:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
81112ffc:	e03ffac5 	stb	zero,-21(fp)
81113000:	e03ffb05 	stb	zero,-20(fp)
81113004:	e03ffb45 	stb	zero,-19(fp)
81113008:	e03ffb85 	stb	zero,-18(fp)
8111300c:	e03ffbc5 	stb	zero,-17(fp)
81113010:	e03ffc05 	stb	zero,-16(fp)
81113014:	e03ffc45 	stb	zero,-15(fp)
81113018:	e03ffc85 	stb	zero,-14(fp)
8111301c:	e03ffcc5 	stb	zero,-13(fp)
81113020:	e03ffd05 	stb	zero,-12(fp)
81113024:	e03ffd45 	stb	zero,-11(fp)
81113028:	e03ffd85 	stb	zero,-10(fp)
8111302c:	e03ffdc5 	stb	zero,-9(fp)
81113030:	e03ffe05 	stb	zero,-8(fp)
81113034:	e03ffe45 	stb	zero,-7(fp)
81113038:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8111303c:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81113040:	d0a06217 	ldw	r2,-32376(gp)
81113044:	100f883a 	mov	r7,r2
81113048:	01800804 	movi	r6,32
8111304c:	01400044 	movi	r5,1
81113050:	01204574 	movhi	r4,33045
81113054:	21359004 	addi	r4,r4,-10688
81113058:	11219e00 	call	811219e0 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
8111305c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
81113060:	e0bff917 	ldw	r2,-28(fp)
81113064:	10c00060 	cmpeqi	r3,r2,1
81113068:	1800071e 	bne	r3,zero,81113088 <vOutAckHandlerTask+0xa8>
8111306c:	0080032e 	bgeu	zero,r2,8111307c <vOutAckHandlerTask+0x9c>
81113070:	108000a0 	cmpeqi	r2,r2,2
81113074:	1000471e 	bne	r2,zero,81113194 <vOutAckHandlerTask+0x1b4>
81113078:	00008c06 	br	811132ac <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8111307c:	00800044 	movi	r2,1
81113080:	e0bff915 	stw	r2,-28(fp)
				break;
81113084:	00009306 	br	811132d4 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
81113088:	00800044 	movi	r2,1
8111308c:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81113090:	d0a06117 	ldw	r2,-32380(gp)
81113094:	e0fffa84 	addi	r3,fp,-22
81113098:	180d883a 	mov	r6,r3
8111309c:	000b883a 	mov	r5,zero
811130a0:	1009883a 	mov	r4,r2
811130a4:	113e87c0 	call	8113e87c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
811130a8:	e0bffa83 	ldbu	r2,-22(fp)
811130ac:	10803fcc 	andi	r2,r2,255
811130b0:	1000361e 	bne	r2,zero,8111318c <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
811130b4:	d0a07217 	ldw	r2,-32312(gp)
811130b8:	e0fffa84 	addi	r3,fp,-22
811130bc:	180d883a 	mov	r6,r3
811130c0:	000b883a 	mov	r5,zero
811130c4:	1009883a 	mov	r4,r2
811130c8:	113c8700 	call	8113c870 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
811130cc:	e0bffa83 	ldbu	r2,-22(fp)
811130d0:	10803fcc 	andi	r2,r2,255
811130d4:	10002b1e 	bne	r2,zero,81113184 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
811130d8:	e03ffa05 	stb	zero,-24(fp)
811130dc:	00002206 	br	81113168 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
811130e0:	e0fffa03 	ldbu	r3,-24(fp)
811130e4:	00a045b4 	movhi	r2,33046
811130e8:	109a2e04 	addi	r2,r2,26808
811130ec:	18c7883a 	add	r3,r3,r3
811130f0:	18c7883a 	add	r3,r3,r3
811130f4:	10c5883a 	add	r2,r2,r3
811130f8:	10800003 	ldbu	r2,0(r2)
811130fc:	10803fcc 	andi	r2,r2,255
81113100:	1080201c 	xori	r2,r2,128
81113104:	10bfe004 	addi	r2,r2,-128
81113108:	10001426 	beq	r2,zero,8111315c <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8111310c:	e0fffa03 	ldbu	r3,-24(fp)
81113110:	00a045b4 	movhi	r2,33046
81113114:	109a2e04 	addi	r2,r2,26808
81113118:	18c7883a 	add	r3,r3,r3
8111311c:	18c7883a 	add	r3,r3,r3
81113120:	10c5883a 	add	r2,r2,r3
81113124:	10c0000b 	ldhu	r3,0(r2)
81113128:	d0e0598d 	sth	r3,-32410(gp)
8111312c:	1080008b 	ldhu	r2,2(r2)
81113130:	d0a05a0d 	sth	r2,-32408(gp)
                                eSenderAckState = sSASending;
81113134:	00800084 	movi	r2,2
81113138:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8111313c:	e0fffa03 	ldbu	r3,-24(fp)
81113140:	00a045b4 	movhi	r2,33046
81113144:	109a2e04 	addi	r2,r2,26808
81113148:	18c7883a 	add	r3,r3,r3
8111314c:	18c7883a 	add	r3,r3,r3
81113150:	10c5883a 	add	r2,r2,r3
81113154:	10000005 	stb	zero,0(r2)
                                break;
81113158:	00000606 	br	81113174 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8111315c:	e0bffa03 	ldbu	r2,-24(fp)
81113160:	10800044 	addi	r2,r2,1
81113164:	e0bffa05 	stb	r2,-24(fp)
81113168:	e0bffa03 	ldbu	r2,-24(fp)
8111316c:	10800230 	cmpltui	r2,r2,8
81113170:	103fdb1e 	bne	r2,zero,811130e0 <__reset+0xfb0f30e0>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
81113174:	d0a07217 	ldw	r2,-32312(gp)
81113178:	1009883a 	mov	r4,r2
8111317c:	113ce140 	call	8113ce14 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113180:	00005406 	br	811132d4 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
81113184:	111b9280 	call	8111b928 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81113188:	00005206 	br	811132d4 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8111318c:	111b8c00 	call	8111b8c0 <vFailGetCountSemaphoreSenderTask>
                }

                break;
81113190:	00005006 	br	811132d4 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
81113194:	d0a05983 	ldbu	r2,-32410(gp)
81113198:	10803fcc 	andi	r2,r2,255
8111319c:	1080201c 	xori	r2,r2,128
811131a0:	10bfe004 	addi	r2,r2,-128
811131a4:	108008e0 	cmpeqi	r2,r2,35
811131a8:	1000201e 	bne	r2,zero,8111322c <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
811131ac:	d0a059c3 	ldbu	r2,-32409(gp)
811131b0:	10c03fcc 	andi	r3,r2,255
811131b4:	18c0201c 	xori	r3,r3,128
811131b8:	18ffe004 	addi	r3,r3,-128
811131bc:	d0a05a0b 	ldhu	r2,-32408(gp)
811131c0:	113fffcc 	andi	r4,r2,65535
811131c4:	e0bffac4 	addi	r2,fp,-21
811131c8:	200f883a 	mov	r7,r4
811131cc:	180d883a 	mov	r6,r3
811131d0:	01604574 	movhi	r5,33045
811131d4:	29759904 	addi	r5,r5,-10652
811131d8:	1009883a 	mov	r4,r2
811131dc:	1122cd40 	call	81122cd4 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
811131e0:	e0bffac4 	addi	r2,fp,-21
811131e4:	1009883a 	mov	r4,r2
811131e8:	1122ee80 	call	81122ee8 <strlen>
811131ec:	1007883a 	mov	r3,r2
811131f0:	e0bffac4 	addi	r2,fp,-21
811131f4:	180b883a 	mov	r5,r3
811131f8:	1009883a 	mov	r4,r2
811131fc:	111b4840 	call	8111b484 <ucCrc8wInit>
81113200:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81113204:	e13ffa43 	ldbu	r4,-23(fp)
81113208:	e0fffac4 	addi	r3,fp,-21
8111320c:	e0bffac4 	addi	r2,fp,-21
81113210:	200f883a 	mov	r7,r4
81113214:	180d883a 	mov	r6,r3
81113218:	01604574 	movhi	r5,33045
8111321c:	29759b04 	addi	r5,r5,-10644
81113220:	1009883a 	mov	r4,r2
81113224:	1122cd40 	call	81122cd4 <sprintf>
81113228:	00000c06 	br	8111325c <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
8111322c:	e0bffac4 	addi	r2,fp,-21
81113230:	00c008c4 	movi	r3,35
81113234:	10c00005 	stb	r3,0(r2)
81113238:	00c01f04 	movi	r3,124
8111323c:	10c00045 	stb	r3,1(r2)
81113240:	00c00d44 	movi	r3,53
81113244:	10c00085 	stb	r3,2(r2)
81113248:	00c00d04 	movi	r3,52
8111324c:	10c000c5 	stb	r3,3(r2)
81113250:	00c00ec4 	movi	r3,59
81113254:	10c00105 	stb	r3,4(r2)
81113258:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
8111325c:	d0a07417 	ldw	r2,-32304(gp)
81113260:	e0fffa84 	addi	r3,fp,-22
81113264:	180d883a 	mov	r6,r3
81113268:	01401904 	movi	r5,100
8111326c:	1009883a 	mov	r4,r2
81113270:	113c8700 	call	8113c870 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
81113274:	e0bffa83 	ldbu	r2,-22(fp)
81113278:	10803fcc 	andi	r2,r2,255
8111327c:	1000071e 	bne	r2,zero,8111329c <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
81113280:	e0bffac4 	addi	r2,fp,-21
81113284:	1009883a 	mov	r4,r2
81113288:	11229900 	call	81122990 <puts>
                    OSMutexPost(xTxUARTMutex);
8111328c:	d0a07417 	ldw	r2,-32304(gp)
81113290:	1009883a 	mov	r4,r2
81113294:	113ce140 	call	8113ce14 <OSMutexPost>
81113298:	00000106 	br	811132a0 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8111329c:	111ba600 	call	8111ba60 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
811132a0:	00800044 	movi	r2,1
811132a4:	e0bff915 	stw	r2,-28(fp)
                
				break;
811132a8:	00000a06 	br	811132d4 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
811132ac:	d0a06217 	ldw	r2,-32376(gp)
811132b0:	100f883a 	mov	r7,r2
811132b4:	01801104 	movi	r6,68
811132b8:	01400044 	movi	r5,1
811132bc:	01204574 	movhi	r4,33045
811132c0:	21359e04 	addi	r4,r4,-10632
811132c4:	11219e00 	call	811219e0 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
811132c8:	00800044 	movi	r2,1
811132cc:	e0bff915 	stw	r2,-28(fp)
				break;
811132d0:	0001883a 	nop
		}
	}
811132d4:	003f6206 	br	81113060 <__reset+0xfb0f3060>

811132d8 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
811132d8:	deffd704 	addi	sp,sp,-164
811132dc:	de00012e 	bgeu	sp,et,811132e4 <vParserCommTask+0xc>
811132e0:	003b68fa 	trap	3
811132e4:	dfc02815 	stw	ra,160(sp)
811132e8:	df002715 	stw	fp,156(sp)
811132ec:	df002704 	addi	fp,sp,156
811132f0:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
811132f4:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
811132f8:	d0a06217 	ldw	r2,-32376(gp)
811132fc:	100f883a 	mov	r7,r2
81113300:	01800704 	movi	r6,28
81113304:	01400044 	movi	r5,1
81113308:	01204574 	movhi	r4,33045
8111330c:	2135b004 	addi	r4,r4,-10560
81113310:	11219e00 	call	811219e0 <fwrite>
    #endif

	eParserMode = sConfiguring;
81113314:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
81113318:	e0bfdc17 	ldw	r2,-144(fp)
8111331c:	10800168 	cmpgeui	r2,r2,5
81113320:	1003651e 	bne	r2,zero,811140b8 <vParserCommTask+0xde0>
81113324:	e0bfdc17 	ldw	r2,-144(fp)
81113328:	100690ba 	slli	r3,r2,2
8111332c:	00a04474 	movhi	r2,33041
81113330:	108cd004 	addi	r2,r2,13120
81113334:	1885883a 	add	r2,r3,r2
81113338:	10800017 	ldw	r2,0(r2)
8111333c:	1000683a 	jmp	r2
81113340:	81113354 	ori	r4,r16,17613
81113344:	81113360 	cmpeqi	r4,r16,17613
81113348:	811133f4 	orhi	r4,r16,17615
8111334c:	81113558 	cmpnei	r4,r16,17621
81113350:	8111359c 	xori	r4,r16,17622
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
81113354:	00800044 	movi	r2,1
81113358:	e0bfdc15 	stw	r2,-144(fp)
				break;
8111335c:	00035906 	br	811140c4 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
81113360:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
81113364:	00800044 	movi	r2,1
81113368:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
8111336c:	d0a06417 	ldw	r2,-32368(gp)
81113370:	e0ffde84 	addi	r3,fp,-134
81113374:	180d883a 	mov	r6,r3
81113378:	000b883a 	mov	r5,zero
8111337c:	1009883a 	mov	r4,r2
81113380:	113e87c0 	call	8113e87c <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81113384:	e0bfde83 	ldbu	r2,-134(fp)
81113388:	10803fcc 	andi	r2,r2,255
8111338c:	1000171e 	bne	r2,zero,811133ec <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81113390:	01204574 	movhi	r4,33045
81113394:	210ca004 	addi	r4,r4,12928
81113398:	11140c80 	call	811140c8 <getPreParsedPacket>
8111339c:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
811133a0:	e0bfdd17 	ldw	r2,-140(fp)
811133a4:	10800058 	cmpnei	r2,r2,1
811133a8:	10000e1e 	bne	r2,zero,811133e4 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
811133ac:	00a04574 	movhi	r2,33045
811133b0:	108ca004 	addi	r2,r2,12928
811133b4:	10800103 	ldbu	r2,4(r2)
811133b8:	10803fcc 	andi	r2,r2,255
811133bc:	1080201c 	xori	r2,r2,128
811133c0:	10bfe004 	addi	r2,r2,-128
811133c4:	10800858 	cmpnei	r2,r2,33
811133c8:	1000031e 	bne	r2,zero,811133d8 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
811133cc:	008000c4 	movi	r2,3
811133d0:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811133d4:	00033b06 	br	811140c4 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
811133d8:	00800084 	movi	r2,2
811133dc:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811133e0:	00033806 	br	811140c4 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
811133e4:	111bfec0 	call	8111bfec <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811133e8:	00033606 	br	811140c4 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
811133ec:	111bf1c0 	call	8111bf1c <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
811133f0:	00033406 	br	811140c4 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
811133f4:	00a04574 	movhi	r2,33045
811133f8:	108ca004 	addi	r2,r2,12928
811133fc:	10800143 	ldbu	r2,5(r2)
81113400:	10803fcc 	andi	r2,r2,255
81113404:	1080201c 	xori	r2,r2,128
81113408:	10bfe004 	addi	r2,r2,-128
8111340c:	10c010e0 	cmpeqi	r3,r2,67
81113410:	1800031e 	bne	r3,zero,81113420 <vParserCommTask+0x148>
81113414:	10801420 	cmpeqi	r2,r2,80
81113418:	1000051e 	bne	r2,zero,81113430 <vParserCommTask+0x158>
8111341c:	00004a06 	br	81113548 <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81113420:	1118c800 	call	81118c80 <vSendEthConf>
						eParserMode = sWaitingMessage;
81113424:	00800044 	movi	r2,1
81113428:	e0bfdc15 	stw	r2,-144(fp)
						break;
8111342c:	00004906 	br	81113554 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
81113430:	e0bfdec4 	addi	r2,fp,-133
81113434:	01802004 	movi	r6,128
81113438:	000b883a 	mov	r5,zero
8111343c:	1009883a 	mov	r4,r2
81113440:	11225440 	call	81122544 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81113444:	00a04574 	movhi	r2,33045
81113448:	108ca004 	addi	r2,r2,12928
8111344c:	1080028b 	ldhu	r2,10(r2)
81113450:	117fffcc 	andi	r5,r2,65535
81113454:	00a04574 	movhi	r2,33045
81113458:	108ca004 	addi	r2,r2,12928
8111345c:	1080030b 	ldhu	r2,12(r2)
81113460:	11bfffcc 	andi	r6,r2,65535
81113464:	00a04574 	movhi	r2,33045
81113468:	108ca004 	addi	r2,r2,12928
8111346c:	1080038b 	ldhu	r2,14(r2)
81113470:	10ffffcc 	andi	r3,r2,65535
81113474:	00a04574 	movhi	r2,33045
81113478:	108ca004 	addi	r2,r2,12928
8111347c:	1080040b 	ldhu	r2,16(r2)
81113480:	113fffcc 	andi	r4,r2,65535
81113484:	00a04574 	movhi	r2,33045
81113488:	108ca004 	addi	r2,r2,12928
8111348c:	1080048b 	ldhu	r2,18(r2)
81113490:	10bfffcc 	andi	r2,r2,65535
81113494:	e23fdec4 	addi	r8,fp,-133
81113498:	d8800215 	stw	r2,8(sp)
8111349c:	d9000115 	stw	r4,4(sp)
811134a0:	d8c00015 	stw	r3,0(sp)
811134a4:	300f883a 	mov	r7,r6
811134a8:	280d883a 	mov	r6,r5
811134ac:	01604574 	movhi	r5,33045
811134b0:	2975b804 	addi	r5,r5,-10528
811134b4:	4009883a 	mov	r4,r8
811134b8:	1122cd40 	call	81122cd4 <sprintf>
							debug(fp, cPUSDebug );
811134bc:	d0a06217 	ldw	r2,-32376(gp)
811134c0:	e0ffdec4 	addi	r3,fp,-133
811134c4:	180b883a 	mov	r5,r3
811134c8:	1009883a 	mov	r4,r2
811134cc:	11213440 	call	81121344 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
811134d0:	00a04574 	movhi	r2,33045
811134d4:	108ca004 	addi	r2,r2,12928
811134d8:	10c0030b 	ldhu	r3,12(r2)
811134dc:	00a04574 	movhi	r2,33045
811134e0:	108cb304 	addi	r2,r2,13004
811134e4:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
811134e8:	00a04574 	movhi	r2,33045
811134ec:	108ca004 	addi	r2,r2,12928
811134f0:	10c0038b 	ldhu	r3,14(r2)
811134f4:	00a04574 	movhi	r2,33045
811134f8:	108cb304 	addi	r2,r2,13004
811134fc:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81113500:	00a04574 	movhi	r2,33045
81113504:	108ca004 	addi	r2,r2,12928
81113508:	10c0040b 	ldhu	r3,16(r2)
8111350c:	00a04574 	movhi	r2,33045
81113510:	108cb304 	addi	r2,r2,13004
81113514:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81113518:	00a04574 	movhi	r2,33045
8111351c:	108ca004 	addi	r2,r2,12928
81113520:	10c0048b 	ldhu	r3,18(r2)
81113524:	00a04574 	movhi	r2,33045
81113528:	108cb304 	addi	r2,r2,13004
8111352c:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81113530:	00a04574 	movhi	r2,33045
81113534:	108cb304 	addi	r2,r2,13004
81113538:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
8111353c:	00800104 	movi	r2,4
81113540:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
81113544:	00000306 	br	81113554 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
81113548:	00800044 	movi	r2,1
8111354c:	e0bfdc15 	stw	r2,-144(fp)
						break;
81113550:	0001883a 	nop
				}
				break;
81113554:	0002db06 	br	811140c4 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81113558:	00800044 	movi	r2,1
8111355c:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81113560:	00a04574 	movhi	r2,33045
81113564:	108cb304 	addi	r2,r2,13004
81113568:	1080030b 	ldhu	r2,12(r2)
8111356c:	10bfffcc 	andi	r2,r2,65535
81113570:	10c01220 	cmpeqi	r3,r2,72
81113574:	1800051e 	bne	r3,zero,8111358c <vParserCommTask+0x2b4>
81113578:	108014e0 	cmpeqi	r2,r2,83
8111357c:	1000051e 	bne	r2,zero,81113594 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81113580:	00800044 	movi	r2,1
81113584:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81113588:	00000306 	br	81113598 <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
8111358c:	0001883a 	nop
81113590:	0002cc06 	br	811140c4 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81113594:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81113598:	0002ca06 	br	811140c4 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8111359c:	00800044 	movi	r2,1
811135a0:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
811135a4:	00a04574 	movhi	r2,33045
811135a8:	108cb304 	addi	r2,r2,13004
811135ac:	1080030b 	ldhu	r2,12(r2)
811135b0:	10bfffcc 	andi	r2,r2,65535
811135b4:	10c03ea0 	cmpeqi	r3,r2,250
811135b8:	1800401e 	bne	r3,zero,811136bc <vParserCommTask+0x3e4>
811135bc:	10c03ec8 	cmpgei	r3,r2,251
811135c0:	1800031e 	bne	r3,zero,811135d0 <vParserCommTask+0x2f8>
811135c4:	10800460 	cmpeqi	r2,r2,17
811135c8:	1000061e 	bne	r2,zero,811135e4 <vParserCommTask+0x30c>
811135cc:	0002b606 	br	811140a8 <vParserCommTask+0xdd0>
811135d0:	10c03ee0 	cmpeqi	r3,r2,251
811135d4:	18009d1e 	bne	r3,zero,8111384c <vParserCommTask+0x574>
811135d8:	10803f20 	cmpeqi	r2,r2,252
811135dc:	1001321e 	bne	r2,zero,81113aa8 <vParserCommTask+0x7d0>
811135e0:	0002b106 	br	811140a8 <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
811135e4:	00a04574 	movhi	r2,33045
811135e8:	108cb304 	addi	r2,r2,13004
811135ec:	1080038b 	ldhu	r2,14(r2)
811135f0:	10bfffcc 	andi	r2,r2,65535
811135f4:	10800060 	cmpeqi	r2,r2,1
811135f8:	10000e26 	beq	r2,zero,81113634 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
811135fc:	d0a06217 	ldw	r2,-32376(gp)
81113600:	100f883a 	mov	r7,r2
81113604:	01800944 	movi	r6,37
81113608:	01400044 	movi	r5,1
8111360c:	01204574 	movhi	r4,33045
81113610:	2135ce04 	addi	r4,r4,-10440
81113614:	11219e00 	call	811219e0 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
81113618:	00a04574 	movhi	r2,33045
8111361c:	108cb304 	addi	r2,r2,13004
81113620:	1080040b 	ldhu	r2,16(r2)
81113624:	10bfffcc 	andi	r2,r2,65535
81113628:	1009883a 	mov	r4,r2
8111362c:	11196800 	call	81119680 <vTMPusTestConnection>

								break;
81113630:	00002106 	br	811136b8 <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113634:	e0bfdec4 	addi	r2,fp,-133
81113638:	01802004 	movi	r6,128
8111363c:	000b883a 	mov	r5,zero
81113640:	1009883a 	mov	r4,r2
81113644:	11225440 	call	81122544 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81113648:	00a04574 	movhi	r2,33045
8111364c:	108cb304 	addi	r2,r2,13004
81113650:	1080030b 	ldhu	r2,12(r2)
81113654:	113fffcc 	andi	r4,r2,65535
81113658:	00a04574 	movhi	r2,33045
8111365c:	108cb304 	addi	r2,r2,13004
81113660:	1080038b 	ldhu	r2,14(r2)
81113664:	117fffcc 	andi	r5,r2,65535
81113668:	00a04574 	movhi	r2,33045
8111366c:	108cb304 	addi	r2,r2,13004
81113670:	1080040b 	ldhu	r2,16(r2)
81113674:	10bfffcc 	andi	r2,r2,65535
81113678:	e0ffdec4 	addi	r3,fp,-133
8111367c:	d8800015 	stw	r2,0(sp)
81113680:	280f883a 	mov	r7,r5
81113684:	200d883a 	mov	r6,r4
81113688:	01604574 	movhi	r5,33045
8111368c:	2975d804 	addi	r5,r5,-10400
81113690:	1809883a 	mov	r4,r3
81113694:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113698:	d0a06217 	ldw	r2,-32376(gp)
8111369c:	e0ffdec4 	addi	r3,fp,-133
811136a0:	180b883a 	mov	r5,r3
811136a4:	1009883a 	mov	r4,r2
811136a8:	11213440 	call	81121344 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
811136ac:	00800044 	movi	r2,1
811136b0:	e0bfdc15 	stw	r2,-144(fp)
								break;
811136b4:	0001883a 	nop
						}
                        break;
811136b8:	00027e06 	br	811140b4 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
811136bc:	00a04574 	movhi	r2,33045
811136c0:	108cb304 	addi	r2,r2,13004
811136c4:	1080038b 	ldhu	r2,14(r2)
811136c8:	10bfffcc 	andi	r2,r2,65535
811136cc:	10c00f20 	cmpeqi	r3,r2,60
811136d0:	18001a1e 	bne	r3,zero,8111373c <vParserCommTask+0x464>
811136d4:	10c00f48 	cmpgei	r3,r2,61
811136d8:	1800031e 	bne	r3,zero,811136e8 <vParserCommTask+0x410>
811136dc:	10800ee0 	cmpeqi	r2,r2,59
811136e0:	1000061e 	bne	r2,zero,811136fc <vParserCommTask+0x424>
811136e4:	00003706 	br	811137c4 <vParserCommTask+0x4ec>
811136e8:	10c00f60 	cmpeqi	r3,r2,61
811136ec:	18001e1e 	bne	r3,zero,81113768 <vParserCommTask+0x490>
811136f0:	10800fa0 	cmpeqi	r2,r2,62
811136f4:	1000271e 	bne	r2,zero,81113794 <vParserCommTask+0x4bc>
811136f8:	00003206 	br	811137c4 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
811136fc:	d0a06217 	ldw	r2,-32376(gp)
81113700:	100f883a 	mov	r7,r2
81113704:	018006c4 	movi	r6,27
81113708:	01400044 	movi	r5,1
8111370c:	01204574 	movhi	r4,33045
81113710:	2135eb04 	addi	r4,r4,-10324
81113714:	11219e00 	call	811219e0 <fwrite>
								#endif
								vSendReset();
81113718:	11190280 	call	81119028 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
8111371c:	000f883a 	mov	r7,zero
81113720:	018000c4 	movi	r6,3
81113724:	000b883a 	mov	r5,zero
81113728:	0009883a 	mov	r4,zero
8111372c:	11408140 	call	81140814 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81113730:	0104e204 	movi	r4,5000
81113734:	110c2140 	call	8110c214 <vRstcSimucamReset>

								break;
81113738:	00004306 	br	81113848 <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
8111373c:	d0a06217 	ldw	r2,-32376(gp)
81113740:	100f883a 	mov	r7,r2
81113744:	01800704 	movi	r6,28
81113748:	01400044 	movi	r5,1
8111374c:	01204574 	movhi	r4,33045
81113750:	2135f204 	addi	r4,r4,-10296
81113754:	11219e00 	call	811219e0 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113758:	01204574 	movhi	r4,33045
8111375c:	210cb304 	addi	r4,r4,13004
81113760:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

								break;
81113764:	00003806 	br	81113848 <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
81113768:	d0a06217 	ldw	r2,-32376(gp)
8111376c:	100f883a 	mov	r7,r2
81113770:	01800644 	movi	r6,25
81113774:	01400044 	movi	r5,1
81113778:	01204574 	movhi	r4,33045
8111377c:	2135fa04 	addi	r4,r4,-10264
81113780:	11219e00 	call	811219e0 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113784:	01204574 	movhi	r4,33045
81113788:	210cb304 	addi	r4,r4,13004
8111378c:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

								break;
81113790:	00002d06 	br	81113848 <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81113794:	d0a06217 	ldw	r2,-32376(gp)
81113798:	100f883a 	mov	r7,r2
8111379c:	01800744 	movi	r6,29
811137a0:	01400044 	movi	r5,1
811137a4:	01204574 	movhi	r4,33045
811137a8:	21360104 	addi	r4,r4,-10236
811137ac:	11219e00 	call	811219e0 <fwrite>
								#endif
								vSendTurnOff();
811137b0:	1118f100 	call	81118f10 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
811137b4:	01204574 	movhi	r4,33045
811137b8:	210cb304 	addi	r4,r4,13004
811137bc:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

								break;
811137c0:	00002106 	br	81113848 <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811137c4:	e0bfdec4 	addi	r2,fp,-133
811137c8:	01802004 	movi	r6,128
811137cc:	000b883a 	mov	r5,zero
811137d0:	1009883a 	mov	r4,r2
811137d4:	11225440 	call	81122544 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811137d8:	00a04574 	movhi	r2,33045
811137dc:	108cb304 	addi	r2,r2,13004
811137e0:	1080030b 	ldhu	r2,12(r2)
811137e4:	113fffcc 	andi	r4,r2,65535
811137e8:	00a04574 	movhi	r2,33045
811137ec:	108cb304 	addi	r2,r2,13004
811137f0:	1080038b 	ldhu	r2,14(r2)
811137f4:	117fffcc 	andi	r5,r2,65535
811137f8:	00a04574 	movhi	r2,33045
811137fc:	108cb304 	addi	r2,r2,13004
81113800:	1080040b 	ldhu	r2,16(r2)
81113804:	10bfffcc 	andi	r2,r2,65535
81113808:	e0ffdec4 	addi	r3,fp,-133
8111380c:	d8800015 	stw	r2,0(sp)
81113810:	280f883a 	mov	r7,r5
81113814:	200d883a 	mov	r6,r4
81113818:	01604574 	movhi	r5,33045
8111381c:	2975d804 	addi	r5,r5,-10400
81113820:	1809883a 	mov	r4,r3
81113824:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113828:	d0a06217 	ldw	r2,-32376(gp)
8111382c:	e0ffdec4 	addi	r3,fp,-133
81113830:	180b883a 	mov	r5,r3
81113834:	1009883a 	mov	r4,r2
81113838:	11213440 	call	81121344 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8111383c:	00800044 	movi	r2,1
81113840:	e0bfdc15 	stw	r2,-144(fp)
								break;
81113844:	0001883a 	nop
						}
                        break;
81113848:	00021a06 	br	811140b4 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8111384c:	00a04574 	movhi	r2,33045
81113850:	108ca004 	addi	r2,r2,12928
81113854:	1080050b 	ldhu	r2,20(r2)
81113858:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
8111385c:	e0bfde0b 	ldhu	r2,-136(fp)
81113860:	108000b0 	cmpltui	r2,r2,2
81113864:	1000121e 	bne	r2,zero,811138b0 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
81113868:	e0bfdec4 	addi	r2,fp,-133
8111386c:	01802004 	movi	r6,128
81113870:	000b883a 	mov	r5,zero
81113874:	1009883a 	mov	r4,r2
81113878:	11225440 	call	81122544 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
8111387c:	e0ffde0b 	ldhu	r3,-136(fp)
81113880:	e0bfdec4 	addi	r2,fp,-133
81113884:	180d883a 	mov	r6,r3
81113888:	01604574 	movhi	r5,33045
8111388c:	29760904 	addi	r5,r5,-10204
81113890:	1009883a 	mov	r4,r2
81113894:	1122cd40 	call	81122cd4 <sprintf>
								debug(fp, cPUSDebug );
81113898:	d0a06217 	ldw	r2,-32376(gp)
8111389c:	e0ffdec4 	addi	r3,fp,-133
811138a0:	180b883a 	mov	r5,r3
811138a4:	1009883a 	mov	r4,r2
811138a8:	11213440 	call	81121344 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
811138ac:	00020106 	br	811140b4 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
811138b0:	00a04574 	movhi	r2,33045
811138b4:	108cb304 	addi	r2,r2,13004
811138b8:	10800483 	ldbu	r2,18(r2)
811138bc:	10c03fcc 	andi	r3,r2,255
811138c0:	00a04574 	movhi	r2,33045
811138c4:	108cb304 	addi	r2,r2,13004
811138c8:	18c00284 	addi	r3,r3,10
811138cc:	18c7883a 	add	r3,r3,r3
811138d0:	10c5883a 	add	r2,r2,r3
811138d4:	e0ffde0b 	ldhu	r3,-136(fp)
811138d8:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
811138dc:	00a04574 	movhi	r2,33045
811138e0:	108cb304 	addi	r2,r2,13004
811138e4:	10800483 	ldbu	r2,18(r2)
811138e8:	10800044 	addi	r2,r2,1
811138ec:	1007883a 	mov	r3,r2
811138f0:	00a04574 	movhi	r2,33045
811138f4:	108cb304 	addi	r2,r2,13004
811138f8:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
811138fc:	00a04574 	movhi	r2,33045
81113900:	108cb304 	addi	r2,r2,13004
81113904:	1080038b 	ldhu	r2,14(r2)
81113908:	10bfffcc 	andi	r2,r2,65535
8111390c:	10c000a0 	cmpeqi	r3,r2,2
81113910:	1800191e 	bne	r3,zero,81113978 <vParserCommTask+0x6a0>
81113914:	10c00160 	cmpeqi	r3,r2,5
81113918:	18002c1e 	bne	r3,zero,811139cc <vParserCommTask+0x6f4>
8111391c:	10800060 	cmpeqi	r2,r2,1
81113920:	10003f26 	beq	r2,zero,81113a20 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113924:	e0bfdec4 	addi	r2,fp,-133
81113928:	01802004 	movi	r6,128
8111392c:	000b883a 	mov	r5,zero
81113930:	1009883a 	mov	r4,r2
81113934:	11225440 	call	81122544 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113938:	e0ffde0b 	ldhu	r3,-136(fp)
8111393c:	e0bfdec4 	addi	r2,fp,-133
81113940:	180d883a 	mov	r6,r3
81113944:	01604574 	movhi	r5,33045
81113948:	29761804 	addi	r5,r5,-10144
8111394c:	1009883a 	mov	r4,r2
81113950:	1122cd40 	call	81122cd4 <sprintf>
										debug(fp, cPUSDebug );
81113954:	d0a06217 	ldw	r2,-32376(gp)
81113958:	e0ffdec4 	addi	r3,fp,-133
8111395c:	180b883a 	mov	r5,r3
81113960:	1009883a 	mov	r4,r2
81113964:	11213440 	call	81121344 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
81113968:	01204574 	movhi	r4,33045
8111396c:	210cb304 	addi	r4,r4,13004
81113970:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

									break;
81113974:	00004b06 	br	81113aa4 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113978:	e0bfdec4 	addi	r2,fp,-133
8111397c:	01802004 	movi	r6,128
81113980:	000b883a 	mov	r5,zero
81113984:	1009883a 	mov	r4,r2
81113988:	11225440 	call	81122544 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8111398c:	e0ffde0b 	ldhu	r3,-136(fp)
81113990:	e0bfdec4 	addi	r2,fp,-133
81113994:	180d883a 	mov	r6,r3
81113998:	01604574 	movhi	r5,33045
8111399c:	29762804 	addi	r5,r5,-10080
811139a0:	1009883a 	mov	r4,r2
811139a4:	1122cd40 	call	81122cd4 <sprintf>
										debug(fp, cPUSDebug );
811139a8:	d0a06217 	ldw	r2,-32376(gp)
811139ac:	e0ffdec4 	addi	r3,fp,-133
811139b0:	180b883a 	mov	r5,r3
811139b4:	1009883a 	mov	r4,r2
811139b8:	11213440 	call	81121344 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811139bc:	01204574 	movhi	r4,33045
811139c0:	210cb304 	addi	r4,r4,13004
811139c4:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

									break;
811139c8:	00003606 	br	81113aa4 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
811139cc:	e0bfdec4 	addi	r2,fp,-133
811139d0:	01802004 	movi	r6,128
811139d4:	000b883a 	mov	r5,zero
811139d8:	1009883a 	mov	r4,r2
811139dc:	11225440 	call	81122544 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811139e0:	e0ffde0b 	ldhu	r3,-136(fp)
811139e4:	e0bfdec4 	addi	r2,fp,-133
811139e8:	180d883a 	mov	r6,r3
811139ec:	01604574 	movhi	r5,33045
811139f0:	29763804 	addi	r5,r5,-10016
811139f4:	1009883a 	mov	r4,r2
811139f8:	1122cd40 	call	81122cd4 <sprintf>
										debug(fp, cPUSDebug );
811139fc:	d0a06217 	ldw	r2,-32376(gp)
81113a00:	e0ffdec4 	addi	r3,fp,-133
81113a04:	180b883a 	mov	r5,r3
81113a08:	1009883a 	mov	r4,r2
81113a0c:	11213440 	call	81121344 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81113a10:	01204574 	movhi	r4,33045
81113a14:	210cb304 	addi	r4,r4,13004
81113a18:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

									break;
81113a1c:	00002106 	br	81113aa4 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113a20:	e0bfdec4 	addi	r2,fp,-133
81113a24:	01802004 	movi	r6,128
81113a28:	000b883a 	mov	r5,zero
81113a2c:	1009883a 	mov	r4,r2
81113a30:	11225440 	call	81122544 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81113a34:	00a04574 	movhi	r2,33045
81113a38:	108cb304 	addi	r2,r2,13004
81113a3c:	1080030b 	ldhu	r2,12(r2)
81113a40:	113fffcc 	andi	r4,r2,65535
81113a44:	00a04574 	movhi	r2,33045
81113a48:	108cb304 	addi	r2,r2,13004
81113a4c:	1080038b 	ldhu	r2,14(r2)
81113a50:	117fffcc 	andi	r5,r2,65535
81113a54:	00a04574 	movhi	r2,33045
81113a58:	108cb304 	addi	r2,r2,13004
81113a5c:	1080040b 	ldhu	r2,16(r2)
81113a60:	10bfffcc 	andi	r2,r2,65535
81113a64:	e0ffdec4 	addi	r3,fp,-133
81113a68:	d8800015 	stw	r2,0(sp)
81113a6c:	280f883a 	mov	r7,r5
81113a70:	200d883a 	mov	r6,r4
81113a74:	01604574 	movhi	r5,33045
81113a78:	2975d804 	addi	r5,r5,-10400
81113a7c:	1809883a 	mov	r4,r3
81113a80:	1122cd40 	call	81122cd4 <sprintf>
										debug(fp, cPUSDebug );
81113a84:	d0a06217 	ldw	r2,-32376(gp)
81113a88:	e0ffdec4 	addi	r3,fp,-133
81113a8c:	180b883a 	mov	r5,r3
81113a90:	1009883a 	mov	r4,r2
81113a94:	11213440 	call	81121344 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
81113a98:	00800044 	movi	r2,1
81113a9c:	e0bfdc15 	stw	r2,-144(fp)
									break;
81113aa0:	0001883a 	nop
							}
						}
                        break;
81113aa4:	00018306 	br	811140b4 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81113aa8:	00a04574 	movhi	r2,33045
81113aac:	108ca004 	addi	r2,r2,12928
81113ab0:	1080050b 	ldhu	r2,20(r2)
81113ab4:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81113ab8:	00a04574 	movhi	r2,33045
81113abc:	108cb304 	addi	r2,r2,13004
81113ac0:	10800483 	ldbu	r2,18(r2)
81113ac4:	10c03fcc 	andi	r3,r2,255
81113ac8:	00a04574 	movhi	r2,33045
81113acc:	108cb304 	addi	r2,r2,13004
81113ad0:	18c00284 	addi	r3,r3,10
81113ad4:	18c7883a 	add	r3,r3,r3
81113ad8:	10c5883a 	add	r2,r2,r3
81113adc:	e0ffde0b 	ldhu	r3,-136(fp)
81113ae0:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
81113ae4:	00a04574 	movhi	r2,33045
81113ae8:	108cb304 	addi	r2,r2,13004
81113aec:	10800483 	ldbu	r2,18(r2)
81113af0:	10800044 	addi	r2,r2,1
81113af4:	1007883a 	mov	r3,r2
81113af8:	00a04574 	movhi	r2,33045
81113afc:	108cb304 	addi	r2,r2,13004
81113b00:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
81113b04:	00a04574 	movhi	r2,33045
81113b08:	108cb304 	addi	r2,r2,13004
81113b0c:	1080038b 	ldhu	r2,14(r2)
81113b10:	10bfffcc 	andi	r2,r2,65535
81113b14:	10c000e0 	cmpeqi	r3,r2,3
81113b18:	18000a1e 	bne	r3,zero,81113b44 <vParserCommTask+0x86c>
81113b1c:	10c00108 	cmpgei	r3,r2,4
81113b20:	1800031e 	bne	r3,zero,81113b30 <vParserCommTask+0x858>
81113b24:	108000a0 	cmpeqi	r2,r2,2
81113b28:	1000451e 	bne	r2,zero,81113c40 <vParserCommTask+0x968>
81113b2c:	00013c06 	br	81114020 <vParserCommTask+0xd48>
81113b30:	10c00120 	cmpeqi	r3,r2,4
81113b34:	1800181e 	bne	r3,zero,81113b98 <vParserCommTask+0x8c0>
81113b38:	10800160 	cmpeqi	r2,r2,5
81113b3c:	10002b1e 	bne	r2,zero,81113bec <vParserCommTask+0x914>
81113b40:	00013706 	br	81114020 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113b44:	e0bfdec4 	addi	r2,fp,-133
81113b48:	01802004 	movi	r6,128
81113b4c:	000b883a 	mov	r5,zero
81113b50:	1009883a 	mov	r4,r2
81113b54:	11225440 	call	81122544 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113b58:	e0ffde0b 	ldhu	r3,-136(fp)
81113b5c:	e0bfdec4 	addi	r2,fp,-133
81113b60:	180d883a 	mov	r6,r3
81113b64:	01604574 	movhi	r5,33045
81113b68:	29764a04 	addi	r5,r5,-9944
81113b6c:	1009883a 	mov	r4,r2
81113b70:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113b74:	d0a06217 	ldw	r2,-32376(gp)
81113b78:	e0ffdec4 	addi	r3,fp,-133
81113b7c:	180b883a 	mov	r5,r3
81113b80:	1009883a 	mov	r4,r2
81113b84:	11213440 	call	81121344 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113b88:	01204574 	movhi	r4,33045
81113b8c:	210cb304 	addi	r4,r4,13004
81113b90:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

								break;
81113b94:	00014306 	br	811140a4 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113b98:	e0bfdec4 	addi	r2,fp,-133
81113b9c:	01802004 	movi	r6,128
81113ba0:	000b883a 	mov	r5,zero
81113ba4:	1009883a 	mov	r4,r2
81113ba8:	11225440 	call	81122544 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113bac:	e0ffde0b 	ldhu	r3,-136(fp)
81113bb0:	e0bfdec4 	addi	r2,fp,-133
81113bb4:	180d883a 	mov	r6,r3
81113bb8:	01604574 	movhi	r5,33045
81113bbc:	29765a04 	addi	r5,r5,-9880
81113bc0:	1009883a 	mov	r4,r2
81113bc4:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113bc8:	d0a06217 	ldw	r2,-32376(gp)
81113bcc:	e0ffdec4 	addi	r3,fp,-133
81113bd0:	180b883a 	mov	r5,r3
81113bd4:	1009883a 	mov	r4,r2
81113bd8:	11213440 	call	81121344 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113bdc:	01204574 	movhi	r4,33045
81113be0:	210cb304 	addi	r4,r4,13004
81113be4:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

								break;
81113be8:	00012e06 	br	811140a4 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113bec:	e0bfdec4 	addi	r2,fp,-133
81113bf0:	01802004 	movi	r6,128
81113bf4:	000b883a 	mov	r5,zero
81113bf8:	1009883a 	mov	r4,r2
81113bfc:	11225440 	call	81122544 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113c00:	e0ffde0b 	ldhu	r3,-136(fp)
81113c04:	e0bfdec4 	addi	r2,fp,-133
81113c08:	180d883a 	mov	r6,r3
81113c0c:	01604574 	movhi	r5,33045
81113c10:	29766a04 	addi	r5,r5,-9816
81113c14:	1009883a 	mov	r4,r2
81113c18:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113c1c:	d0a06217 	ldw	r2,-32376(gp)
81113c20:	e0ffdec4 	addi	r3,fp,-133
81113c24:	180b883a 	mov	r5,r3
81113c28:	1009883a 	mov	r4,r2
81113c2c:	11213440 	call	81121344 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113c30:	01204574 	movhi	r4,33045
81113c34:	210cb304 	addi	r4,r4,13004
81113c38:	11141e00 	call	811141e0 <bSendMessagePUStoMebTask>

								break;
81113c3c:	00011906 	br	811140a4 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81113c40:	00a04574 	movhi	r2,33045
81113c44:	108cb304 	addi	r2,r2,13004
81113c48:	10800483 	ldbu	r2,18(r2)
81113c4c:	10c03fcc 	andi	r3,r2,255
81113c50:	00a04574 	movhi	r2,33045
81113c54:	108ca004 	addi	r2,r2,12928
81113c58:	1100058b 	ldhu	r4,22(r2)
81113c5c:	00a04574 	movhi	r2,33045
81113c60:	108cb304 	addi	r2,r2,13004
81113c64:	18c00284 	addi	r3,r3,10
81113c68:	18c7883a 	add	r3,r3,r3
81113c6c:	10c5883a 	add	r2,r2,r3
81113c70:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113c74:	00a04574 	movhi	r2,33045
81113c78:	108cb304 	addi	r2,r2,13004
81113c7c:	10800483 	ldbu	r2,18(r2)
81113c80:	10800044 	addi	r2,r2,1
81113c84:	1007883a 	mov	r3,r2
81113c88:	00a04574 	movhi	r2,33045
81113c8c:	108cb304 	addi	r2,r2,13004
81113c90:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
81113c94:	00a04574 	movhi	r2,33045
81113c98:	108cb304 	addi	r2,r2,13004
81113c9c:	10800483 	ldbu	r2,18(r2)
81113ca0:	10c03fcc 	andi	r3,r2,255
81113ca4:	00a04574 	movhi	r2,33045
81113ca8:	108ca004 	addi	r2,r2,12928
81113cac:	1100060b 	ldhu	r4,24(r2)
81113cb0:	00a04574 	movhi	r2,33045
81113cb4:	108cb304 	addi	r2,r2,13004
81113cb8:	18c00284 	addi	r3,r3,10
81113cbc:	18c7883a 	add	r3,r3,r3
81113cc0:	10c5883a 	add	r2,r2,r3
81113cc4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113cc8:	00a04574 	movhi	r2,33045
81113ccc:	108cb304 	addi	r2,r2,13004
81113cd0:	10800483 	ldbu	r2,18(r2)
81113cd4:	10800044 	addi	r2,r2,1
81113cd8:	1007883a 	mov	r3,r2
81113cdc:	00a04574 	movhi	r2,33045
81113ce0:	108cb304 	addi	r2,r2,13004
81113ce4:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81113ce8:	00a04574 	movhi	r2,33045
81113cec:	108cb304 	addi	r2,r2,13004
81113cf0:	10800483 	ldbu	r2,18(r2)
81113cf4:	10c03fcc 	andi	r3,r2,255
81113cf8:	00a04574 	movhi	r2,33045
81113cfc:	108ca004 	addi	r2,r2,12928
81113d00:	1100068b 	ldhu	r4,26(r2)
81113d04:	00a04574 	movhi	r2,33045
81113d08:	108cb304 	addi	r2,r2,13004
81113d0c:	18c00284 	addi	r3,r3,10
81113d10:	18c7883a 	add	r3,r3,r3
81113d14:	10c5883a 	add	r2,r2,r3
81113d18:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113d1c:	00a04574 	movhi	r2,33045
81113d20:	108cb304 	addi	r2,r2,13004
81113d24:	10800483 	ldbu	r2,18(r2)
81113d28:	10800044 	addi	r2,r2,1
81113d2c:	1007883a 	mov	r3,r2
81113d30:	00a04574 	movhi	r2,33045
81113d34:	108cb304 	addi	r2,r2,13004
81113d38:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
81113d3c:	00a04574 	movhi	r2,33045
81113d40:	108cb304 	addi	r2,r2,13004
81113d44:	10800483 	ldbu	r2,18(r2)
81113d48:	10c03fcc 	andi	r3,r2,255
81113d4c:	00a04574 	movhi	r2,33045
81113d50:	108ca004 	addi	r2,r2,12928
81113d54:	1100070b 	ldhu	r4,28(r2)
81113d58:	00a04574 	movhi	r2,33045
81113d5c:	108cb304 	addi	r2,r2,13004
81113d60:	18c00284 	addi	r3,r3,10
81113d64:	18c7883a 	add	r3,r3,r3
81113d68:	10c5883a 	add	r2,r2,r3
81113d6c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113d70:	00a04574 	movhi	r2,33045
81113d74:	108cb304 	addi	r2,r2,13004
81113d78:	10800483 	ldbu	r2,18(r2)
81113d7c:	10800044 	addi	r2,r2,1
81113d80:	1007883a 	mov	r3,r2
81113d84:	00a04574 	movhi	r2,33045
81113d88:	108cb304 	addi	r2,r2,13004
81113d8c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81113d90:	00a04574 	movhi	r2,33045
81113d94:	108cb304 	addi	r2,r2,13004
81113d98:	10800483 	ldbu	r2,18(r2)
81113d9c:	10c03fcc 	andi	r3,r2,255
81113da0:	00a04574 	movhi	r2,33045
81113da4:	108ca004 	addi	r2,r2,12928
81113da8:	1100078b 	ldhu	r4,30(r2)
81113dac:	00a04574 	movhi	r2,33045
81113db0:	108cb304 	addi	r2,r2,13004
81113db4:	18c00284 	addi	r3,r3,10
81113db8:	18c7883a 	add	r3,r3,r3
81113dbc:	10c5883a 	add	r2,r2,r3
81113dc0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113dc4:	00a04574 	movhi	r2,33045
81113dc8:	108cb304 	addi	r2,r2,13004
81113dcc:	10800483 	ldbu	r2,18(r2)
81113dd0:	10800044 	addi	r2,r2,1
81113dd4:	1007883a 	mov	r3,r2
81113dd8:	00a04574 	movhi	r2,33045
81113ddc:	108cb304 	addi	r2,r2,13004
81113de0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81113de4:	00a04574 	movhi	r2,33045
81113de8:	108cb304 	addi	r2,r2,13004
81113dec:	10800483 	ldbu	r2,18(r2)
81113df0:	10c03fcc 	andi	r3,r2,255
81113df4:	00a04574 	movhi	r2,33045
81113df8:	108ca004 	addi	r2,r2,12928
81113dfc:	1100080b 	ldhu	r4,32(r2)
81113e00:	00a04574 	movhi	r2,33045
81113e04:	108cb304 	addi	r2,r2,13004
81113e08:	18c00284 	addi	r3,r3,10
81113e0c:	18c7883a 	add	r3,r3,r3
81113e10:	10c5883a 	add	r2,r2,r3
81113e14:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113e18:	00a04574 	movhi	r2,33045
81113e1c:	108cb304 	addi	r2,r2,13004
81113e20:	10800483 	ldbu	r2,18(r2)
81113e24:	10800044 	addi	r2,r2,1
81113e28:	1007883a 	mov	r3,r2
81113e2c:	00a04574 	movhi	r2,33045
81113e30:	108cb304 	addi	r2,r2,13004
81113e34:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113e38:	e0bfdec4 	addi	r2,fp,-133
81113e3c:	01802004 	movi	r6,128
81113e40:	000b883a 	mov	r5,zero
81113e44:	1009883a 	mov	r4,r2
81113e48:	11225440 	call	81122544 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81113e4c:	e0ffdec4 	addi	r3,fp,-133
81113e50:	00a04574 	movhi	r2,33045
81113e54:	10b67904 	addi	r2,r2,-9756
81113e58:	1009883a 	mov	r4,r2
81113e5c:	00800b84 	movi	r2,46
81113e60:	100d883a 	mov	r6,r2
81113e64:	200b883a 	mov	r5,r4
81113e68:	1809883a 	mov	r4,r3
81113e6c:	11223f40 	call	811223f4 <memcpy>
									debug(fp, cPUSDebug );
81113e70:	d0a06217 	ldw	r2,-32376(gp)
81113e74:	e0ffdec4 	addi	r3,fp,-133
81113e78:	180b883a 	mov	r5,r3
81113e7c:	1009883a 	mov	r4,r2
81113e80:	11213440 	call	81121344 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81113e84:	e0ffde0b 	ldhu	r3,-136(fp)
81113e88:	e0bfdec4 	addi	r2,fp,-133
81113e8c:	180d883a 	mov	r6,r3
81113e90:	01604574 	movhi	r5,33045
81113e94:	29768504 	addi	r5,r5,-9708
81113e98:	1009883a 	mov	r4,r2
81113e9c:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113ea0:	d0a06217 	ldw	r2,-32376(gp)
81113ea4:	e0ffdec4 	addi	r3,fp,-133
81113ea8:	180b883a 	mov	r5,r3
81113eac:	1009883a 	mov	r4,r2
81113eb0:	11213440 	call	81121344 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81113eb4:	00a04574 	movhi	r2,33045
81113eb8:	108ca004 	addi	r2,r2,12928
81113ebc:	1080058b 	ldhu	r2,22(r2)
81113ec0:	10ffffcc 	andi	r3,r2,65535
81113ec4:	e0bfdec4 	addi	r2,fp,-133
81113ec8:	180d883a 	mov	r6,r3
81113ecc:	01604574 	movhi	r5,33045
81113ed0:	29768c04 	addi	r5,r5,-9680
81113ed4:	1009883a 	mov	r4,r2
81113ed8:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113edc:	d0a06217 	ldw	r2,-32376(gp)
81113ee0:	e0ffdec4 	addi	r3,fp,-133
81113ee4:	180b883a 	mov	r5,r3
81113ee8:	1009883a 	mov	r4,r2
81113eec:	11213440 	call	81121344 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81113ef0:	00a04574 	movhi	r2,33045
81113ef4:	108ca004 	addi	r2,r2,12928
81113ef8:	1080060b 	ldhu	r2,24(r2)
81113efc:	10ffffcc 	andi	r3,r2,65535
81113f00:	e0bfdec4 	addi	r2,fp,-133
81113f04:	180d883a 	mov	r6,r3
81113f08:	01604574 	movhi	r5,33045
81113f0c:	29769004 	addi	r5,r5,-9664
81113f10:	1009883a 	mov	r4,r2
81113f14:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113f18:	d0a06217 	ldw	r2,-32376(gp)
81113f1c:	e0ffdec4 	addi	r3,fp,-133
81113f20:	180b883a 	mov	r5,r3
81113f24:	1009883a 	mov	r4,r2
81113f28:	11213440 	call	81121344 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81113f2c:	00a04574 	movhi	r2,33045
81113f30:	108ca004 	addi	r2,r2,12928
81113f34:	1080068b 	ldhu	r2,26(r2)
81113f38:	10ffffcc 	andi	r3,r2,65535
81113f3c:	e0bfdec4 	addi	r2,fp,-133
81113f40:	180d883a 	mov	r6,r3
81113f44:	01604574 	movhi	r5,33045
81113f48:	29769504 	addi	r5,r5,-9644
81113f4c:	1009883a 	mov	r4,r2
81113f50:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113f54:	d0a06217 	ldw	r2,-32376(gp)
81113f58:	e0ffdec4 	addi	r3,fp,-133
81113f5c:	180b883a 	mov	r5,r3
81113f60:	1009883a 	mov	r4,r2
81113f64:	11213440 	call	81121344 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81113f68:	00a04574 	movhi	r2,33045
81113f6c:	108ca004 	addi	r2,r2,12928
81113f70:	1080070b 	ldhu	r2,28(r2)
81113f74:	10ffffcc 	andi	r3,r2,65535
81113f78:	e0bfdec4 	addi	r2,fp,-133
81113f7c:	180d883a 	mov	r6,r3
81113f80:	01604574 	movhi	r5,33045
81113f84:	29769c04 	addi	r5,r5,-9616
81113f88:	1009883a 	mov	r4,r2
81113f8c:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113f90:	d0a06217 	ldw	r2,-32376(gp)
81113f94:	e0ffdec4 	addi	r3,fp,-133
81113f98:	180b883a 	mov	r5,r3
81113f9c:	1009883a 	mov	r4,r2
81113fa0:	11213440 	call	81121344 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81113fa4:	00a04574 	movhi	r2,33045
81113fa8:	108ca004 	addi	r2,r2,12928
81113fac:	1080078b 	ldhu	r2,30(r2)
81113fb0:	10ffffcc 	andi	r3,r2,65535
81113fb4:	e0bfdec4 	addi	r2,fp,-133
81113fb8:	180d883a 	mov	r6,r3
81113fbc:	01604574 	movhi	r5,33045
81113fc0:	2976a304 	addi	r5,r5,-9588
81113fc4:	1009883a 	mov	r4,r2
81113fc8:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81113fcc:	d0a06217 	ldw	r2,-32376(gp)
81113fd0:	e0ffdec4 	addi	r3,fp,-133
81113fd4:	180b883a 	mov	r5,r3
81113fd8:	1009883a 	mov	r4,r2
81113fdc:	11213440 	call	81121344 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81113fe0:	00a04574 	movhi	r2,33045
81113fe4:	108ca004 	addi	r2,r2,12928
81113fe8:	1080080b 	ldhu	r2,32(r2)
81113fec:	10ffffcc 	andi	r3,r2,65535
81113ff0:	e0bfdec4 	addi	r2,fp,-133
81113ff4:	180d883a 	mov	r6,r3
81113ff8:	01604574 	movhi	r5,33045
81113ffc:	2976a904 	addi	r5,r5,-9564
81114000:	1009883a 	mov	r4,r2
81114004:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81114008:	d0a06217 	ldw	r2,-32376(gp)
8111400c:	e0ffdec4 	addi	r3,fp,-133
81114010:	180b883a 	mov	r5,r3
81114014:	1009883a 	mov	r4,r2
81114018:	11213440 	call	81121344 <fprintf>
								#endif

								break;
8111401c:	00002106 	br	811140a4 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81114020:	e0bfdec4 	addi	r2,fp,-133
81114024:	01802004 	movi	r6,128
81114028:	000b883a 	mov	r5,zero
8111402c:	1009883a 	mov	r4,r2
81114030:	11225440 	call	81122544 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81114034:	00a04574 	movhi	r2,33045
81114038:	108cb304 	addi	r2,r2,13004
8111403c:	1080030b 	ldhu	r2,12(r2)
81114040:	113fffcc 	andi	r4,r2,65535
81114044:	00a04574 	movhi	r2,33045
81114048:	108cb304 	addi	r2,r2,13004
8111404c:	1080038b 	ldhu	r2,14(r2)
81114050:	117fffcc 	andi	r5,r2,65535
81114054:	00a04574 	movhi	r2,33045
81114058:	108cb304 	addi	r2,r2,13004
8111405c:	1080040b 	ldhu	r2,16(r2)
81114060:	10bfffcc 	andi	r2,r2,65535
81114064:	e0ffdec4 	addi	r3,fp,-133
81114068:	d8800015 	stw	r2,0(sp)
8111406c:	280f883a 	mov	r7,r5
81114070:	200d883a 	mov	r6,r4
81114074:	01604574 	movhi	r5,33045
81114078:	2975d804 	addi	r5,r5,-10400
8111407c:	1809883a 	mov	r4,r3
81114080:	1122cd40 	call	81122cd4 <sprintf>
									debug(fp, cPUSDebug );
81114084:	d0a06217 	ldw	r2,-32376(gp)
81114088:	e0ffdec4 	addi	r3,fp,-133
8111408c:	180b883a 	mov	r5,r3
81114090:	1009883a 	mov	r4,r2
81114094:	11213440 	call	81121344 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81114098:	00800044 	movi	r2,1
8111409c:	e0bfdc15 	stw	r2,-144(fp)
								break;
811140a0:	0001883a 	nop
						}
                        break;
811140a4:	00000306 	br	811140b4 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
811140a8:	00800044 	movi	r2,1
811140ac:	e0bfdc15 	stw	r2,-144(fp)
                        break;
811140b0:	0001883a 	nop
                }
				break;				
811140b4:	00000306 	br	811140c4 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
811140b8:	00800044 	movi	r2,1
811140bc:	e0bfdc15 	stw	r2,-144(fp)
				break;
811140c0:	0001883a 	nop
		}
	}
811140c4:	003c9406 	br	81113318 <__reset+0xfb0f3318>

811140c8 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
811140c8:	defffb04 	addi	sp,sp,-20
811140cc:	de00012e 	bgeu	sp,et,811140d4 <getPreParsedPacket+0xc>
811140d0:	003b68fa 	trap	3
811140d4:	dfc00415 	stw	ra,16(sp)
811140d8:	df000315 	stw	fp,12(sp)
811140dc:	df000304 	addi	fp,sp,12
811140e0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811140e4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
811140e8:	d0a06b17 	ldw	r2,-32340(gp)
811140ec:	e0fffe44 	addi	r3,fp,-7
811140f0:	180d883a 	mov	r6,r3
811140f4:	000b883a 	mov	r5,zero
811140f8:	1009883a 	mov	r4,r2
811140fc:	113c8700 	call	8113c870 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81114100:	e0bffe43 	ldbu	r2,-7(fp)
81114104:	10803fcc 	andi	r2,r2,255
81114108:	10002e1e 	bne	r2,zero,811141c4 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8111410c:	e03ffe05 	stb	zero,-8(fp)
81114110:	00002506 	br	811141a8 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
81114114:	e0fffe03 	ldbu	r3,-8(fp)
81114118:	00a045b4 	movhi	r2,33046
8111411c:	109a3604 	addi	r2,r2,26840
81114120:	18c01324 	muli	r3,r3,76
81114124:	10c5883a 	add	r2,r2,r3
81114128:	10800104 	addi	r2,r2,4
8111412c:	10800003 	ldbu	r2,0(r2)
81114130:	10803fcc 	andi	r2,r2,255
81114134:	1080201c 	xori	r2,r2,128
81114138:	10bfe004 	addi	r2,r2,-128
8111413c:	10001726 	beq	r2,zero,8111419c <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81114140:	e0fffe03 	ldbu	r3,-8(fp)
81114144:	e13fff17 	ldw	r4,-4(fp)
81114148:	00a045b4 	movhi	r2,33046
8111414c:	109a3604 	addi	r2,r2,26840
81114150:	18c01324 	muli	r3,r3,76
81114154:	10c5883a 	add	r2,r2,r3
81114158:	2007883a 	mov	r3,r4
8111415c:	1009883a 	mov	r4,r2
81114160:	00801304 	movi	r2,76
81114164:	100d883a 	mov	r6,r2
81114168:	200b883a 	mov	r5,r4
8111416c:	1809883a 	mov	r4,r3
81114170:	11223f40 	call	811223f4 <memcpy>
                bSuccess = TRUE;
81114174:	00800044 	movi	r2,1
81114178:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
8111417c:	e0fffe03 	ldbu	r3,-8(fp)
81114180:	00a045b4 	movhi	r2,33046
81114184:	109a3604 	addi	r2,r2,26840
81114188:	18c01324 	muli	r3,r3,76
8111418c:	10c5883a 	add	r2,r2,r3
81114190:	10800104 	addi	r2,r2,4
81114194:	10000005 	stb	zero,0(r2)
                break;
81114198:	00000606 	br	811141b4 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8111419c:	e0bffe03 	ldbu	r2,-8(fp)
811141a0:	10800044 	addi	r2,r2,1
811141a4:	e0bffe05 	stb	r2,-8(fp)
811141a8:	e0bffe03 	ldbu	r2,-8(fp)
811141ac:	10800230 	cmpltui	r2,r2,8
811141b0:	103fd81e 	bne	r2,zero,81114114 <__reset+0xfb0f4114>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
811141b4:	d0a06b17 	ldw	r2,-32340(gp)
811141b8:	1009883a 	mov	r4,r2
811141bc:	113ce140 	call	8113ce14 <OSMutexPost>
811141c0:	00000106 	br	811141c8 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
811141c4:	111bf840 	call	8111bf84 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
811141c8:	e0bffd17 	ldw	r2,-12(fp)
}
811141cc:	e037883a 	mov	sp,fp
811141d0:	dfc00117 	ldw	ra,4(sp)
811141d4:	df000017 	ldw	fp,0(sp)
811141d8:	dec00204 	addi	sp,sp,8
811141dc:	f800283a 	ret

811141e0 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
811141e0:	defffa04 	addi	sp,sp,-24
811141e4:	de00012e 	bgeu	sp,et,811141ec <bSendMessagePUStoMebTask+0xc>
811141e8:	003b68fa 	trap	3
811141ec:	dfc00515 	stw	ra,20(sp)
811141f0:	df000415 	stw	fp,16(sp)
811141f4:	df000404 	addi	fp,sp,16
811141f8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811141fc:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81114200:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
81114204:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
81114208:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
8111420c:	d0a07317 	ldw	r2,-32308(gp)
81114210:	e0fffd44 	addi	r3,fp,-11
81114214:	180d883a 	mov	r6,r3
81114218:	01400284 	movi	r5,10
8111421c:	1009883a 	mov	r4,r2
81114220:	113c8700 	call	8113c870 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114224:	e0bffd43 	ldbu	r2,-11(fp)
81114228:	10803fcc 	andi	r2,r2,255
8111422c:	1000401e 	bne	r2,zero,81114330 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81114230:	e03ffd05 	stb	zero,-12(fp)
81114234:	00003806 	br	81114318 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
81114238:	e0fffd03 	ldbu	r3,-12(fp)
8111423c:	00a04574 	movhi	r2,33045
81114240:	10975804 	addi	r2,r2,23904
81114244:	18c01524 	muli	r3,r3,84
81114248:	10c5883a 	add	r2,r2,r3
8111424c:	10800104 	addi	r2,r2,4
81114250:	10800017 	ldw	r2,0(r2)
81114254:	10002d1e 	bne	r2,zero,8111430c <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
81114258:	e0fffd03 	ldbu	r3,-12(fp)
8111425c:	00a04574 	movhi	r2,33045
81114260:	10975804 	addi	r2,r2,23904
81114264:	18c01524 	muli	r3,r3,84
81114268:	10c7883a 	add	r3,r2,r3
8111426c:	e0bfff17 	ldw	r2,-4(fp)
81114270:	1009883a 	mov	r4,r2
81114274:	00801504 	movi	r2,84
81114278:	100d883a 	mov	r6,r2
8111427c:	200b883a 	mov	r5,r4
81114280:	1809883a 	mov	r4,r3
81114284:	11223f40 	call	811223f4 <memcpy>
            	xPus[i].bInUse = TRUE;
81114288:	e0fffd03 	ldbu	r3,-12(fp)
8111428c:	00a04574 	movhi	r2,33045
81114290:	10975804 	addi	r2,r2,23904
81114294:	18c01524 	muli	r3,r3,84
81114298:	10c5883a 	add	r2,r2,r3
8111429c:	10800104 	addi	r2,r2,4
811142a0:	00c00044 	movi	r3,1
811142a4:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
811142a8:	00800044 	movi	r2,1
811142ac:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
811142b0:	00800044 	movi	r2,1
811142b4:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
811142b8:	d0a06917 	ldw	r2,-32348(gp)
811142bc:	e0fffe17 	ldw	r3,-8(fp)
811142c0:	180b883a 	mov	r5,r3
811142c4:	1009883a 	mov	r4,r2
811142c8:	113dd8c0 	call	8113dd8c <OSQPost>
811142cc:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
811142d0:	e0bffd43 	ldbu	r2,-11(fp)
811142d4:	10803fcc 	andi	r2,r2,255
811142d8:	10000926 	beq	r2,zero,81114300 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
811142dc:	111ce740 	call	8111ce74 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
811142e0:	e0fffd03 	ldbu	r3,-12(fp)
811142e4:	00a04574 	movhi	r2,33045
811142e8:	10975804 	addi	r2,r2,23904
811142ec:	18c01524 	muli	r3,r3,84
811142f0:	10c5883a 	add	r2,r2,r3
811142f4:	10800104 	addi	r2,r2,4
811142f8:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
811142fc:	00000906 	br	81114324 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81114300:	00800044 	movi	r2,1
81114304:	e0bffc15 	stw	r2,-16(fp)
                break;
81114308:	00000606 	br	81114324 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
8111430c:	e0bffd03 	ldbu	r2,-12(fp)
81114310:	10800044 	addi	r2,r2,1
81114314:	e0bffd05 	stb	r2,-12(fp)
81114318:	e0bffd03 	ldbu	r2,-12(fp)
8111431c:	10800130 	cmpltui	r2,r2,4
81114320:	103fc51e 	bne	r2,zero,81114238 <__reset+0xfb0f4238>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81114324:	d0a07317 	ldw	r2,-32308(gp)
81114328:	1009883a 	mov	r4,r2
8111432c:	113ce140 	call	8113ce14 <OSMutexPost>
    }

    return bSuccess;
81114330:	e0bffc17 	ldw	r2,-16(fp)
}
81114334:	e037883a 	mov	sp,fp
81114338:	dfc00117 	ldw	ra,4(sp)
8111433c:	df000017 	ldw	fp,0(sp)
81114340:	dec00204 	addi	sp,sp,8
81114344:	f800283a 	ret

81114348 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
81114348:	deffab04 	addi	sp,sp,-340
8111434c:	de00012e 	bgeu	sp,et,81114354 <vReceiverUartTask+0xc>
81114350:	003b68fa 	trap	3
81114354:	dfc05415 	stw	ra,336(sp)
81114358:	df005315 	stw	fp,332(sp)
8111435c:	df005304 	addi	fp,sp,332
81114360:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81114364:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
81114368:	d0a06217 	ldw	r2,-32376(gp)
8111436c:	100f883a 	mov	r7,r2
81114370:	01800784 	movi	r6,30
81114374:	01400044 	movi	r5,1
81114378:	01204574 	movhi	r4,33045
8111437c:	2136af04 	addi	r4,r4,-9540
81114380:	11219e00 	call	811219e0 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
81114384:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81114388:	e0bfad17 	ldw	r2,-332(fp)
8111438c:	10c00060 	cmpeqi	r3,r2,1
81114390:	1800091e 	bne	r3,zero,811143b8 <vReceiverUartTask+0x70>
81114394:	0080052e 	bgeu	zero,r2,811143ac <vReceiverUartTask+0x64>
81114398:	10c000a0 	cmpeqi	r3,r2,2
8111439c:	18005d1e 	bne	r3,zero,81114514 <vReceiverUartTask+0x1cc>
811143a0:	108000e0 	cmpeqi	r2,r2,3
811143a4:	10006e1e 	bne	r2,zero,81114560 <vReceiverUartTask+0x218>
811143a8:	00007706 	br	81114588 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
811143ac:	00800044 	movi	r2,1
811143b0:	e0bfad15 	stw	r2,-332(fp)
                break;
811143b4:	00007706 	br	81114594 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
811143b8:	e0bfaf04 	addi	r2,fp,-324
811143bc:	01802004 	movi	r6,128
811143c0:	000b883a 	mov	r5,zero
811143c4:	1009883a 	mov	r4,r2
811143c8:	11225440 	call	81122544 <memset>
                scanf("%s", cReceive);
811143cc:	e0bfcf04 	addi	r2,fp,-196
811143d0:	100b883a 	mov	r5,r2
811143d4:	01204574 	movhi	r4,33045
811143d8:	2136b704 	addi	r4,r4,-9508
811143dc:	1122bf80 	call	81122bf8 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
811143e0:	e0ffcf04 	addi	r3,fp,-196
811143e4:	e0bfaf04 	addi	r2,fp,-324
811143e8:	01801fc4 	movi	r6,127
811143ec:	180b883a 	mov	r5,r3
811143f0:	1009883a 	mov	r4,r2
811143f4:	11223f40 	call	811223f4 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
811143f8:	e0bfaf04 	addi	r2,fp,-324
811143fc:	01604574 	movhi	r5,33045
81114400:	294cc804 	addi	r5,r5,13088
81114404:	1009883a 	mov	r4,r2
81114408:	11149ec0 	call	811149ec <bPreParserV2>
8111440c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
81114410:	e0bfae17 	ldw	r2,-328(fp)
81114414:	10800058 	cmpnei	r2,r2,1
81114418:	1000281e 	bne	r2,zero,811144bc <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
8111441c:	00a04574 	movhi	r2,33045
81114420:	108cc804 	addi	r2,r2,13088
81114424:	10800103 	ldbu	r2,4(r2)
81114428:	10803fcc 	andi	r2,r2,255
8111442c:	1080201c 	xori	r2,r2,128
81114430:	10bfe004 	addi	r2,r2,-128
81114434:	10800fe0 	cmpeqi	r2,r2,63
81114438:	1000081e 	bne	r2,zero,8111445c <vReceiverUartTask+0x114>
8111443c:	00a04574 	movhi	r2,33045
81114440:	108cc804 	addi	r2,r2,13088
81114444:	10800103 	ldbu	r2,4(r2)
81114448:	10803fcc 	andi	r2,r2,255
8111444c:	1080201c 	xori	r2,r2,128
81114450:	10bfe004 	addi	r2,r2,-128
81114454:	10800858 	cmpnei	r2,r2,33
81114458:	1000031e 	bne	r2,zero,81114468 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
8111445c:	00800084 	movi	r2,2
81114460:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81114464:	00004b06 	br	81114594 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81114468:	00a04574 	movhi	r2,33045
8111446c:	108cc804 	addi	r2,r2,13088
81114470:	10800103 	ldbu	r2,4(r2)
81114474:	10803fcc 	andi	r2,r2,255
81114478:	1080201c 	xori	r2,r2,128
8111447c:	10bfe004 	addi	r2,r2,-128
81114480:	108008d8 	cmpnei	r2,r2,35
81114484:	10000a1e 	bne	r2,zero,811144b0 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
81114488:	00800044 	movi	r2,1
8111448c:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81114490:	d0a06217 	ldw	r2,-32376(gp)
81114494:	100f883a 	mov	r7,r2
81114498:	018006c4 	movi	r6,27
8111449c:	01400044 	movi	r5,1
811144a0:	01204574 	movhi	r4,33045
811144a4:	2136b804 	addi	r4,r4,-9504
811144a8:	11219e00 	call	811219e0 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811144ac:	00003906 	br	81114594 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
811144b0:	008000c4 	movi	r2,3
811144b4:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
811144b8:	00003606 	br	81114594 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
811144bc:	00a04574 	movhi	r2,33045
811144c0:	108cc804 	addi	r2,r2,13088
811144c4:	00c008c4 	movi	r3,35
811144c8:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
811144cc:	00a04574 	movhi	r2,33045
811144d0:	108cc804 	addi	r2,r2,13088
811144d4:	00c00b84 	movi	r3,46
811144d8:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
811144dc:	00a04574 	movhi	r2,33045
811144e0:	108cc804 	addi	r2,r2,13088
811144e4:	00c00044 	movi	r3,1
811144e8:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
811144ec:	01204574 	movhi	r4,33045
811144f0:	210cc804 	addi	r4,r4,13088
811144f4:	11146d40 	call	811146d4 <setPreAckSenderFreePos>
811144f8:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811144fc:	e0bfae17 	ldw	r2,-328(fp)
81114500:	1000011e 	bne	r2,zero,81114508 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81114504:	111c0bc0 	call	8111c0bc <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81114508:	00800044 	movi	r2,1
8111450c:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81114510:	00002006 	br	81114594 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81114514:	01204574 	movhi	r4,33045
81114518:	210cc804 	addi	r4,r4,13088
8111451c:	11146d40 	call	811146d4 <setPreAckSenderFreePos>
81114520:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81114524:	e0bfae17 	ldw	r2,-328(fp)
81114528:	10800058 	cmpnei	r2,r2,1
8111452c:	1000081e 	bne	r2,zero,81114550 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81114530:	01204574 	movhi	r4,33045
81114534:	210cc804 	addi	r4,r4,13088
81114538:	11145980 	call	81114598 <setPreParsedFreePos>
8111453c:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81114540:	e0bfae17 	ldw	r2,-328(fp)
81114544:	1000031e 	bne	r2,zero,81114554 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
81114548:	111c18c0 	call	8111c18c <vFailSetPreParsedBuffer>
8111454c:	00000106 	br	81114554 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81114550:	111c1240 	call	8111c124 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81114554:	00800044 	movi	r2,1
81114558:	e0bfad15 	stw	r2,-332(fp)
                break;
8111455c:	00000d06 	br	81114594 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81114560:	01204574 	movhi	r4,33045
81114564:	210cc804 	addi	r4,r4,13088
81114568:	11148500 	call	81114850 <setPreAckReceiverFreePos>
8111456c:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81114570:	e0bfae17 	ldw	r2,-328(fp)
81114574:	1000011e 	bne	r2,zero,8111457c <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81114578:	111c1f40 	call	8111c1f4 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
8111457c:	00800044 	movi	r2,1
81114580:	e0bfad15 	stw	r2,-332(fp)
                break;
81114584:	00000306 	br	81114594 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81114588:	00800044 	movi	r2,1
8111458c:	e0bfad15 	stw	r2,-332(fp)
                break;
81114590:	0001883a 	nop
        }

    }
81114594:	003f7c06 	br	81114388 <__reset+0xfb0f4388>

81114598 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81114598:	defffb04 	addi	sp,sp,-20
8111459c:	de00012e 	bgeu	sp,et,811145a4 <setPreParsedFreePos+0xc>
811145a0:	003b68fa 	trap	3
811145a4:	dfc00415 	stw	ra,16(sp)
811145a8:	df000315 	stw	fp,12(sp)
811145ac:	df000304 	addi	fp,sp,12
811145b0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811145b4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811145b8:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811145bc:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
811145c0:	d0a06b17 	ldw	r2,-32340(gp)
811145c4:	e0fffe44 	addi	r3,fp,-7
811145c8:	180d883a 	mov	r6,r3
811145cc:	01400284 	movi	r5,10
811145d0:	1009883a 	mov	r4,r2
811145d4:	113c8700 	call	8113c870 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811145d8:	e0bffe43 	ldbu	r2,-7(fp)
811145dc:	10803fcc 	andi	r2,r2,255
811145e0:	1000361e 	bne	r2,zero,811146bc <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
811145e4:	e03ffe05 	stb	zero,-8(fp)
811145e8:	00002e06 	br	811146a4 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
811145ec:	e0fffe03 	ldbu	r3,-8(fp)
811145f0:	00a045b4 	movhi	r2,33046
811145f4:	109a3604 	addi	r2,r2,26840
811145f8:	18c01324 	muli	r3,r3,76
811145fc:	10c5883a 	add	r2,r2,r3
81114600:	10800104 	addi	r2,r2,4
81114604:	10800003 	ldbu	r2,0(r2)
81114608:	10803fcc 	andi	r2,r2,255
8111460c:	1080201c 	xori	r2,r2,128
81114610:	10bfe004 	addi	r2,r2,-128
81114614:	1000201e 	bne	r2,zero,81114698 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81114618:	e0fffe03 	ldbu	r3,-8(fp)
8111461c:	00a045b4 	movhi	r2,33046
81114620:	109a3604 	addi	r2,r2,26840
81114624:	18c01324 	muli	r3,r3,76
81114628:	10c7883a 	add	r3,r2,r3
8111462c:	e0bfff17 	ldw	r2,-4(fp)
81114630:	1009883a 	mov	r4,r2
81114634:	00801304 	movi	r2,76
81114638:	100d883a 	mov	r6,r2
8111463c:	200b883a 	mov	r5,r4
81114640:	1809883a 	mov	r4,r3
81114644:	11223f40 	call	811223f4 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
81114648:	d0a06417 	ldw	r2,-32368(gp)
8111464c:	1009883a 	mov	r4,r2
81114650:	113ec040 	call	8113ec04 <OSSemPost>
81114654:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81114658:	e0bffe43 	ldbu	r2,-7(fp)
8111465c:	10803fcc 	andi	r2,r2,255
81114660:	1000031e 	bne	r2,zero,81114670 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81114664:	00800044 	movi	r2,1
81114668:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
8111466c:	00001006 	br	811146b0 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81114670:	111b7dc0 	call	8111b7dc <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81114674:	e0fffe03 	ldbu	r3,-8(fp)
81114678:	00a045b4 	movhi	r2,33046
8111467c:	109a3604 	addi	r2,r2,26840
81114680:	18c01324 	muli	r3,r3,76
81114684:	10c5883a 	add	r2,r2,r3
81114688:	10800104 	addi	r2,r2,4
8111468c:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81114690:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81114694:	00000606 	br	811146b0 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81114698:	e0bffe03 	ldbu	r2,-8(fp)
8111469c:	10800044 	addi	r2,r2,1
811146a0:	e0bffe05 	stb	r2,-8(fp)
811146a4:	e0bffe03 	ldbu	r2,-8(fp)
811146a8:	10800230 	cmpltui	r2,r2,8
811146ac:	103fcf1e 	bne	r2,zero,811145ec <__reset+0xfb0f45ec>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
811146b0:	d0a06b17 	ldw	r2,-32340(gp)
811146b4:	1009883a 	mov	r4,r2
811146b8:	113ce140 	call	8113ce14 <OSMutexPost>
    }
    return bSuccess;
811146bc:	e0bffd17 	ldw	r2,-12(fp)
}
811146c0:	e037883a 	mov	sp,fp
811146c4:	dfc00117 	ldw	ra,4(sp)
811146c8:	df000017 	ldw	fp,0(sp)
811146cc:	dec00204 	addi	sp,sp,8
811146d0:	f800283a 	ret

811146d4 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
811146d4:	defffb04 	addi	sp,sp,-20
811146d8:	de00012e 	bgeu	sp,et,811146e0 <setPreAckSenderFreePos+0xc>
811146dc:	003b68fa 	trap	3
811146e0:	dfc00415 	stw	ra,16(sp)
811146e4:	df000315 	stw	fp,12(sp)
811146e8:	df000304 	addi	fp,sp,12
811146ec:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811146f0:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811146f4:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811146f8:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
811146fc:	d0a07217 	ldw	r2,-32312(gp)
81114700:	e0fffe44 	addi	r3,fp,-7
81114704:	180d883a 	mov	r6,r3
81114708:	01400284 	movi	r5,10
8111470c:	1009883a 	mov	r4,r2
81114710:	113c8700 	call	8113c870 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114714:	e0bffe43 	ldbu	r2,-7(fp)
81114718:	10803fcc 	andi	r2,r2,255
8111471c:	1000461e 	bne	r2,zero,81114838 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81114720:	e03ffe05 	stb	zero,-8(fp)
81114724:	00003e06 	br	81114820 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81114728:	e0fffe03 	ldbu	r3,-8(fp)
8111472c:	00a045b4 	movhi	r2,33046
81114730:	109a2e04 	addi	r2,r2,26808
81114734:	18c7883a 	add	r3,r3,r3
81114738:	18c7883a 	add	r3,r3,r3
8111473c:	10c5883a 	add	r2,r2,r3
81114740:	10800003 	ldbu	r2,0(r2)
81114744:	10803fcc 	andi	r2,r2,255
81114748:	1080201c 	xori	r2,r2,128
8111474c:	10bfe004 	addi	r2,r2,-128
81114750:	1000301e 	bne	r2,zero,81114814 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81114754:	e0fffe03 	ldbu	r3,-8(fp)
81114758:	e0bfff17 	ldw	r2,-4(fp)
8111475c:	11000103 	ldbu	r4,4(r2)
81114760:	00a045b4 	movhi	r2,33046
81114764:	109a2e04 	addi	r2,r2,26808
81114768:	18c7883a 	add	r3,r3,r3
8111476c:	18c7883a 	add	r3,r3,r3
81114770:	10c5883a 	add	r2,r2,r3
81114774:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81114778:	e0fffe03 	ldbu	r3,-8(fp)
8111477c:	e0bfff17 	ldw	r2,-4(fp)
81114780:	11000143 	ldbu	r4,5(r2)
81114784:	00a045b4 	movhi	r2,33046
81114788:	109a2e04 	addi	r2,r2,26808
8111478c:	18c7883a 	add	r3,r3,r3
81114790:	18c7883a 	add	r3,r3,r3
81114794:	10c5883a 	add	r2,r2,r3
81114798:	10800044 	addi	r2,r2,1
8111479c:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
811147a0:	e0fffe03 	ldbu	r3,-8(fp)
811147a4:	e0bfff17 	ldw	r2,-4(fp)
811147a8:	1100020b 	ldhu	r4,8(r2)
811147ac:	00a045b4 	movhi	r2,33046
811147b0:	109a2e04 	addi	r2,r2,26808
811147b4:	18c7883a 	add	r3,r3,r3
811147b8:	18c7883a 	add	r3,r3,r3
811147bc:	10c5883a 	add	r2,r2,r3
811147c0:	10800084 	addi	r2,r2,2
811147c4:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
811147c8:	d0a06117 	ldw	r2,-32380(gp)
811147cc:	1009883a 	mov	r4,r2
811147d0:	113ec040 	call	8113ec04 <OSSemPost>
811147d4:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
811147d8:	e0bffe43 	ldbu	r2,-7(fp)
811147dc:	10803fcc 	andi	r2,r2,255
811147e0:	10000926 	beq	r2,zero,81114808 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
811147e4:	111b8740 	call	8111b874 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
811147e8:	e0fffe03 	ldbu	r3,-8(fp)
811147ec:	00a045b4 	movhi	r2,33046
811147f0:	109a2e04 	addi	r2,r2,26808
811147f4:	18c7883a 	add	r3,r3,r3
811147f8:	18c7883a 	add	r3,r3,r3
811147fc:	10c5883a 	add	r2,r2,r3
81114800:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81114804:	00000906 	br	8111482c <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81114808:	00800044 	movi	r2,1
8111480c:	e0bffd15 	stw	r2,-12(fp)
                break;
81114810:	00000606 	br	8111482c <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81114814:	e0bffe03 	ldbu	r2,-8(fp)
81114818:	10800044 	addi	r2,r2,1
8111481c:	e0bffe05 	stb	r2,-8(fp)
81114820:	e0bffe03 	ldbu	r2,-8(fp)
81114824:	10800230 	cmpltui	r2,r2,8
81114828:	103fbf1e 	bne	r2,zero,81114728 <__reset+0xfb0f4728>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
8111482c:	d0a07217 	ldw	r2,-32312(gp)
81114830:	1009883a 	mov	r4,r2
81114834:	113ce140 	call	8113ce14 <OSMutexPost>
    }

    return bSuccess;
81114838:	e0bffd17 	ldw	r2,-12(fp)
}
8111483c:	e037883a 	mov	sp,fp
81114840:	dfc00117 	ldw	ra,4(sp)
81114844:	df000017 	ldw	fp,0(sp)
81114848:	dec00204 	addi	sp,sp,8
8111484c:	f800283a 	ret

81114850 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81114850:	defffb04 	addi	sp,sp,-20
81114854:	de00012e 	bgeu	sp,et,8111485c <setPreAckReceiverFreePos+0xc>
81114858:	003b68fa 	trap	3
8111485c:	dfc00415 	stw	ra,16(sp)
81114860:	df000315 	stw	fp,12(sp)
81114864:	df000304 	addi	fp,sp,12
81114868:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111486c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81114870:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81114874:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81114878:	d0a06517 	ldw	r2,-32364(gp)
8111487c:	e0fffe44 	addi	r3,fp,-7
81114880:	180d883a 	mov	r6,r3
81114884:	01400504 	movi	r5,20
81114888:	1009883a 	mov	r4,r2
8111488c:	113c8700 	call	8113c870 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81114890:	e0bffe43 	ldbu	r2,-7(fp)
81114894:	10803fcc 	andi	r2,r2,255
81114898:	1000471e 	bne	r2,zero,811149b8 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8111489c:	e03ffe05 	stb	zero,-8(fp)
811148a0:	00003e06 	br	8111499c <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
811148a4:	e0fffe03 	ldbu	r3,-8(fp)
811148a8:	00a045b4 	movhi	r2,33046
811148ac:	10841c04 	addi	r2,r2,4208
811148b0:	18c7883a 	add	r3,r3,r3
811148b4:	18c7883a 	add	r3,r3,r3
811148b8:	10c5883a 	add	r2,r2,r3
811148bc:	10800003 	ldbu	r2,0(r2)
811148c0:	10803fcc 	andi	r2,r2,255
811148c4:	1080201c 	xori	r2,r2,128
811148c8:	10bfe004 	addi	r2,r2,-128
811148cc:	1000301e 	bne	r2,zero,81114990 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
811148d0:	e0fffe03 	ldbu	r3,-8(fp)
811148d4:	e0bfff17 	ldw	r2,-4(fp)
811148d8:	11000103 	ldbu	r4,4(r2)
811148dc:	00a045b4 	movhi	r2,33046
811148e0:	10841c04 	addi	r2,r2,4208
811148e4:	18c7883a 	add	r3,r3,r3
811148e8:	18c7883a 	add	r3,r3,r3
811148ec:	10c5883a 	add	r2,r2,r3
811148f0:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
811148f4:	e0fffe03 	ldbu	r3,-8(fp)
811148f8:	e0bfff17 	ldw	r2,-4(fp)
811148fc:	11000143 	ldbu	r4,5(r2)
81114900:	00a045b4 	movhi	r2,33046
81114904:	10841c04 	addi	r2,r2,4208
81114908:	18c7883a 	add	r3,r3,r3
8111490c:	18c7883a 	add	r3,r3,r3
81114910:	10c5883a 	add	r2,r2,r3
81114914:	10800044 	addi	r2,r2,1
81114918:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
8111491c:	e0fffe03 	ldbu	r3,-8(fp)
81114920:	e0bfff17 	ldw	r2,-4(fp)
81114924:	1100020b 	ldhu	r4,8(r2)
81114928:	00a045b4 	movhi	r2,33046
8111492c:	10841c04 	addi	r2,r2,4208
81114930:	18c7883a 	add	r3,r3,r3
81114934:	18c7883a 	add	r3,r3,r3
81114938:	10c5883a 	add	r2,r2,r3
8111493c:	10800084 	addi	r2,r2,2
81114940:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81114944:	d0a06617 	ldw	r2,-32360(gp)
81114948:	1009883a 	mov	r4,r2
8111494c:	113ec040 	call	8113ec04 <OSSemPost>
81114950:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81114954:	e0bffe43 	ldbu	r2,-7(fp)
81114958:	10803fcc 	andi	r2,r2,255
8111495c:	1000031e 	bne	r2,zero,8111496c <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81114960:	00800044 	movi	r2,1
81114964:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81114968:	00000f06 	br	811149a8 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
8111496c:	111b8280 	call	8111b828 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81114970:	e0fffe03 	ldbu	r3,-8(fp)
81114974:	00a045b4 	movhi	r2,33046
81114978:	10841c04 	addi	r2,r2,4208
8111497c:	18c7883a 	add	r3,r3,r3
81114980:	18c7883a 	add	r3,r3,r3
81114984:	10c5883a 	add	r2,r2,r3
81114988:	10000005 	stb	zero,0(r2)
                }
                break;
8111498c:	00000606 	br	811149a8 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81114990:	e0bffe03 	ldbu	r2,-8(fp)
81114994:	10800044 	addi	r2,r2,1
81114998:	e0bffe05 	stb	r2,-8(fp)
8111499c:	e0bffe03 	ldbu	r2,-8(fp)
811149a0:	108001b0 	cmpltui	r2,r2,6
811149a4:	103fbf1e 	bne	r2,zero,811148a4 <__reset+0xfb0f48a4>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
811149a8:	d0a06517 	ldw	r2,-32364(gp)
811149ac:	1009883a 	mov	r4,r2
811149b0:	113ce140 	call	8113ce14 <OSMutexPost>
811149b4:	00000706 	br	811149d4 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
811149b8:	d0a06217 	ldw	r2,-32376(gp)
811149bc:	100f883a 	mov	r7,r2
811149c0:	01801404 	movi	r6,80
811149c4:	01400044 	movi	r5,1
811149c8:	01204574 	movhi	r4,33045
811149cc:	2136bf04 	addi	r4,r4,-9476
811149d0:	11219e00 	call	811219e0 <fwrite>
        #endif
    }

    return bSuccess;
811149d4:	e0bffd17 	ldw	r2,-12(fp)
}
811149d8:	e037883a 	mov	sp,fp
811149dc:	dfc00117 	ldw	ra,4(sp)
811149e0:	df000017 	ldw	fp,0(sp)
811149e4:	dec00204 	addi	sp,sp,8
811149e8:	f800283a 	ret

811149ec <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
811149ec:	defff404 	addi	sp,sp,-48
811149f0:	de00012e 	bgeu	sp,et,811149f8 <bPreParserV2+0xc>
811149f4:	003b68fa 	trap	3
811149f8:	dfc00b15 	stw	ra,44(sp)
811149fc:	df000a15 	stw	fp,40(sp)
81114a00:	dc000915 	stw	r16,36(sp)
81114a04:	df000a04 	addi	fp,sp,40
81114a08:	e13ffd15 	stw	r4,-12(fp)
81114a0c:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81114a10:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81114a14:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81114a18:	01402004 	movi	r5,128
81114a1c:	e13ffd17 	ldw	r4,-12(fp)
81114a20:	1122f800 	call	81122f80 <strnlen>
81114a24:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81114a28:	01400ec4 	movi	r5,59
81114a2c:	e13ffd17 	ldw	r4,-12(fp)
81114a30:	11192900 	call	81119290 <siPosStr>
81114a34:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81114a38:	e0fff98f 	ldh	r3,-26(fp)
81114a3c:	e0bff90f 	ldh	r2,-28(fp)
81114a40:	10bfffc4 	addi	r2,r2,-1
81114a44:	18800226 	beq	r3,r2,81114a50 <bPreParserV2+0x64>
        return bSuccess;
81114a48:	e0bff617 	ldw	r2,-40(fp)
81114a4c:	0000ba06 	br	81114d38 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81114a50:	01401f04 	movi	r5,124
81114a54:	e13ffd17 	ldw	r4,-12(fp)
81114a58:	11192900 	call	81119290 <siPosStr>
81114a5c:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81114a60:	e0bffa0f 	ldh	r2,-24(fp)
81114a64:	e0fff98f 	ldh	r3,-26(fp)
81114a68:	1880020e 	bge	r3,r2,81114a74 <bPreParserV2+0x88>
        return bSuccess;
81114a6c:	e0bff617 	ldw	r2,-40(fp)
81114a70:	0000b106 	br	81114d38 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81114a74:	01604574 	movhi	r5,33045
81114a78:	2976d404 	addi	r5,r5,-9392
81114a7c:	e13ffd17 	ldw	r4,-12(fp)
81114a80:	1122e9c0 	call	81122e9c <strcspn>
81114a84:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81114a88:	e0bffa8f 	ldh	r2,-22(fp)
81114a8c:	e0fffa0f 	ldh	r3,-24(fp)
81114a90:	1880020e 	bge	r3,r2,81114a9c <bPreParserV2+0xb0>
        return bSuccess;
81114a94:	e0bff617 	ldw	r2,-40(fp)
81114a98:	0000a706 	br	81114d38 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81114a9c:	e0bffa8f 	ldh	r2,-22(fp)
81114aa0:	e0fffd17 	ldw	r3,-12(fp)
81114aa4:	1885883a 	add	r2,r3,r2
81114aa8:	10c00003 	ldbu	r3,0(r2)
81114aac:	e0bffe17 	ldw	r2,-8(fp)
81114ab0:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81114ab4:	e0bffe17 	ldw	r2,-8(fp)
81114ab8:	10800103 	ldbu	r2,4(r2)
81114abc:	10803fcc 	andi	r2,r2,255
81114ac0:	1080201c 	xori	r2,r2,128
81114ac4:	10bfe004 	addi	r2,r2,-128
81114ac8:	108008d8 	cmpnei	r2,r2,35
81114acc:	1000041e 	bne	r2,zero,81114ae0 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81114ad0:	00800044 	movi	r2,1
81114ad4:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81114ad8:	e0bff617 	ldw	r2,-40(fp)
81114adc:	00009606 	br	81114d38 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81114ae0:	e0bffa8f 	ldh	r2,-22(fp)
81114ae4:	e0fffd17 	ldw	r3,-12(fp)
81114ae8:	1889883a 	add	r4,r3,r2
81114aec:	e0fffa0f 	ldh	r3,-24(fp)
81114af0:	e0bffa8f 	ldh	r2,-22(fp)
81114af4:	1885c83a 	sub	r2,r3,r2
81114af8:	100b883a 	mov	r5,r2
81114afc:	111b4840 	call	8111b484 <ucCrc8wInit>
81114b00:	1007883a 	mov	r3,r2
81114b04:	e0bffe17 	ldw	r2,-8(fp)
81114b08:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
81114b0c:	e0bffa8f 	ldh	r2,-22(fp)
81114b10:	10800044 	addi	r2,r2,1
81114b14:	e0fffd17 	ldw	r3,-12(fp)
81114b18:	1885883a 	add	r2,r3,r2
81114b1c:	10c00003 	ldbu	r3,0(r2)
81114b20:	e0bffe17 	ldw	r2,-8(fp)
81114b24:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81114b28:	e0bffe17 	ldw	r2,-8(fp)
81114b2c:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81114b30:	e0bffe17 	ldw	r2,-8(fp)
81114b34:	10800204 	addi	r2,r2,8
81114b38:	01801004 	movi	r6,64
81114b3c:	000b883a 	mov	r5,zero
81114b40:	1009883a 	mov	r4,r2
81114b44:	11225440 	call	81122544 <memset>

    i = siIni + 3; /* "?C:i..." */
81114b48:	e0bffa8b 	ldhu	r2,-22(fp)
81114b4c:	108000c4 	addi	r2,r2,3
81114b50:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81114b54:	e0bffb44 	addi	r2,fp,-19
81114b58:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81114b5c:	e0bffb44 	addi	r2,fp,-19
81114b60:	01800184 	movi	r6,6
81114b64:	000b883a 	mov	r5,zero
81114b68:	1009883a 	mov	r4,r2
81114b6c:	11225440 	call	81122544 <memset>
        do {
            c = buffer[i];
81114b70:	e0bff703 	ldbu	r2,-36(fp)
81114b74:	e0fffd17 	ldw	r3,-12(fp)
81114b78:	1885883a 	add	r2,r3,r2
81114b7c:	10800003 	ldbu	r2,0(r2)
81114b80:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81114b84:	d0e00317 	ldw	r3,-32756(gp)
81114b88:	e0bffb07 	ldb	r2,-20(fp)
81114b8c:	10800044 	addi	r2,r2,1
81114b90:	1885883a 	add	r2,r3,r2
81114b94:	10800003 	ldbu	r2,0(r2)
81114b98:	10803fcc 	andi	r2,r2,255
81114b9c:	1080010c 	andi	r2,r2,4
81114ba0:	10000626 	beq	r2,zero,81114bbc <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81114ba4:	e0bff817 	ldw	r2,-32(fp)
81114ba8:	e0fffb03 	ldbu	r3,-20(fp)
81114bac:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81114bb0:	e0bff817 	ldw	r2,-32(fp)
81114bb4:	10800044 	addi	r2,r2,1
81114bb8:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81114bbc:	e0bff703 	ldbu	r2,-36(fp)
81114bc0:	10800044 	addi	r2,r2,1
81114bc4:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81114bc8:	e0bff90f 	ldh	r2,-28(fp)
81114bcc:	e0fff703 	ldbu	r3,-36(fp)
81114bd0:	1880090e 	bge	r3,r2,81114bf8 <bPreParserV2+0x20c>
81114bd4:	e0bffb07 	ldb	r2,-20(fp)
81114bd8:	10800ea0 	cmpeqi	r2,r2,58
81114bdc:	1000061e 	bne	r2,zero,81114bf8 <bPreParserV2+0x20c>
81114be0:	e0bffb07 	ldb	r2,-20(fp)
81114be4:	10800ee0 	cmpeqi	r2,r2,59
81114be8:	1000031e 	bne	r2,zero,81114bf8 <bPreParserV2+0x20c>
81114bec:	e0bffb07 	ldb	r2,-20(fp)
81114bf0:	10801f18 	cmpnei	r2,r2,124
81114bf4:	103fde1e 	bne	r2,zero,81114b70 <__reset+0xfb0f4b70>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81114bf8:	e0bff817 	ldw	r2,-32(fp)
81114bfc:	00c00284 	movi	r3,10
81114c00:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81114c04:	e0bffb07 	ldb	r2,-20(fp)
81114c08:	10800ea0 	cmpeqi	r2,r2,58
81114c0c:	1000031e 	bne	r2,zero,81114c1c <bPreParserV2+0x230>
81114c10:	e0bffb07 	ldb	r2,-20(fp)
81114c14:	10801f18 	cmpnei	r2,r2,124
81114c18:	10001a1e 	bne	r2,zero,81114c84 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
81114c1c:	e0bffe17 	ldw	r2,-8(fp)
81114c20:	10800183 	ldbu	r2,6(r2)
81114c24:	10803fcc 	andi	r2,r2,255
81114c28:	10800828 	cmpgeui	r2,r2,32
81114c2c:	1000041e 	bne	r2,zero,81114c40 <bPreParserV2+0x254>
81114c30:	e0bffe17 	ldw	r2,-8(fp)
81114c34:	10800183 	ldbu	r2,6(r2)
81114c38:	14003fcc 	andi	r16,r2,255
81114c3c:	00000106 	br	81114c44 <bPreParserV2+0x258>
81114c40:	04000804 	movi	r16,32
81114c44:	e0bffb44 	addi	r2,fp,-19
81114c48:	1009883a 	mov	r4,r2
81114c4c:	11211d00 	call	811211d0 <atoi>
81114c50:	1009883a 	mov	r4,r2
81114c54:	e0fffe17 	ldw	r3,-8(fp)
81114c58:	80800104 	addi	r2,r16,4
81114c5c:	1085883a 	add	r2,r2,r2
81114c60:	1885883a 	add	r2,r3,r2
81114c64:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
81114c68:	e0bffe17 	ldw	r2,-8(fp)
81114c6c:	10800183 	ldbu	r2,6(r2)
81114c70:	10800044 	addi	r2,r2,1
81114c74:	1007883a 	mov	r3,r2
81114c78:	e0bffe17 	ldw	r2,-8(fp)
81114c7c:	10c00185 	stb	r3,6(r2)
81114c80:	00000906 	br	81114ca8 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81114c84:	e0bffb07 	ldb	r2,-20(fp)
81114c88:	10800ed8 	cmpnei	r2,r2,59
81114c8c:	1000061e 	bne	r2,zero,81114ca8 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81114c90:	e0bffb44 	addi	r2,fp,-19
81114c94:	1009883a 	mov	r4,r2
81114c98:	11211d00 	call	811211d0 <atoi>
81114c9c:	1007883a 	mov	r3,r2
81114ca0:	e0bffe17 	ldw	r2,-8(fp)
81114ca4:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
81114ca8:	e0bffb07 	ldb	r2,-20(fp)
81114cac:	10800ee0 	cmpeqi	r2,r2,59
81114cb0:	1000031e 	bne	r2,zero,81114cc0 <bPreParserV2+0x2d4>
81114cb4:	e0bff90f 	ldh	r2,-28(fp)
81114cb8:	e0fff703 	ldbu	r3,-36(fp)
81114cbc:	18bfa516 	blt	r3,r2,81114b54 <__reset+0xfb0f4b54>


    if ( c == FINAL_CHAR )
81114cc0:	e0bffb07 	ldb	r2,-20(fp)
81114cc4:	10800ed8 	cmpnei	r2,r2,59
81114cc8:	1000191e 	bne	r2,zero,81114d30 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81114ccc:	e0bffe17 	ldw	r2,-8(fp)
81114cd0:	10c01243 	ldbu	r3,73(r2)
81114cd4:	e0bffe17 	ldw	r2,-8(fp)
81114cd8:	10801203 	ldbu	r2,72(r2)
81114cdc:	18c03fcc 	andi	r3,r3,255
81114ce0:	10803fcc 	andi	r2,r2,255
81114ce4:	1880031e 	bne	r3,r2,81114cf4 <bPreParserV2+0x308>
            bSuccess = TRUE;
81114ce8:	00800044 	movi	r2,1
81114cec:	e0bff615 	stw	r2,-40(fp)
81114cf0:	00001006 	br	81114d34 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81114cf4:	d0e06217 	ldw	r3,-32376(gp)
81114cf8:	e0bffe17 	ldw	r2,-8(fp)
81114cfc:	10801203 	ldbu	r2,72(r2)
81114d00:	11003fcc 	andi	r4,r2,255
81114d04:	e0bffe17 	ldw	r2,-8(fp)
81114d08:	10801243 	ldbu	r2,73(r2)
81114d0c:	10803fcc 	andi	r2,r2,255
81114d10:	100f883a 	mov	r7,r2
81114d14:	200d883a 	mov	r6,r4
81114d18:	01604574 	movhi	r5,33045
81114d1c:	2976d604 	addi	r5,r5,-9384
81114d20:	1809883a 	mov	r4,r3
81114d24:	11213440 	call	81121344 <fprintf>
            #endif
            bSuccess = FALSE;
81114d28:	e03ff615 	stw	zero,-40(fp)
81114d2c:	00000106 	br	81114d34 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81114d30:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81114d34:	e0bff617 	ldw	r2,-40(fp)
}
81114d38:	e6ffff04 	addi	sp,fp,-4
81114d3c:	dfc00217 	ldw	ra,8(sp)
81114d40:	df000117 	ldw	fp,4(sp)
81114d44:	dc000017 	ldw	r16,0(sp)
81114d48:	dec00304 	addi	sp,sp,12
81114d4c:	f800283a 	ret

81114d50 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81114d50:	defffb04 	addi	sp,sp,-20
81114d54:	de00012e 	bgeu	sp,et,81114d5c <vSenderComTask+0xc>
81114d58:	003b68fa 	trap	3
81114d5c:	dfc00415 	stw	ra,16(sp)
81114d60:	df000315 	stw	fp,12(sp)
81114d64:	df000304 	addi	fp,sp,12
81114d68:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81114d6c:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81114d70:	d0a06217 	ldw	r2,-32376(gp)
81114d74:	100f883a 	mov	r7,r2
81114d78:	01800704 	movi	r6,28
81114d7c:	01400044 	movi	r5,1
81114d80:	01204574 	movhi	r4,33045
81114d84:	2136e204 	addi	r4,r4,-9336
81114d88:	11219e00 	call	811219e0 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
81114d8c:	e0bffd17 	ldw	r2,-12(fp)
81114d90:	10c00060 	cmpeqi	r3,r2,1
81114d94:	1800091e 	bne	r3,zero,81114dbc <vSenderComTask+0x6c>
81114d98:	0080052e 	bgeu	zero,r2,81114db0 <vSenderComTask+0x60>
81114d9c:	10c000a0 	cmpeqi	r3,r2,2
81114da0:	1800471e 	bne	r3,zero,81114ec0 <vSenderComTask+0x170>
81114da4:	10800160 	cmpeqi	r2,r2,5
81114da8:	10002c1e 	bne	r2,zero,81114e5c <vSenderComTask+0x10c>
81114dac:	00003a06 	br	81114e98 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81114db0:	00800044 	movi	r2,1
81114db4:	e0bffd15 	stw	r2,-12(fp)
                break;
81114db8:	00004206 	br	81114ec4 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
81114dbc:	d0a06217 	ldw	r2,-32376(gp)
81114dc0:	100f883a 	mov	r7,r2
81114dc4:	01800784 	movi	r6,30
81114dc8:	01400044 	movi	r5,1
81114dcc:	01204574 	movhi	r4,33045
81114dd0:	2136ea04 	addi	r4,r4,-9304
81114dd4:	11219e00 	call	811219e0 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81114dd8:	01400044 	movi	r5,1
81114ddc:	01204574 	movhi	r4,33045
81114de0:	2136f204 	addi	r4,r4,-9272
81114de4:	11189880 	call	81118988 <bSendUART32v2>
81114de8:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
81114dec:	e0bffe17 	ldw	r2,-8(fp)
81114df0:	10800058 	cmpnei	r2,r2,1
81114df4:	10000a1e 	bne	r2,zero,81114e20 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81114df8:	00800144 	movi	r2,5
81114dfc:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81114e00:	d0a06217 	ldw	r2,-32376(gp)
81114e04:	100f883a 	mov	r7,r2
81114e08:	01800d44 	movi	r6,53
81114e0c:	01400044 	movi	r5,1
81114e10:	01204574 	movhi	r4,33045
81114e14:	2136f504 	addi	r4,r4,-9260
81114e18:	11219e00 	call	811219e0 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81114e1c:	00002906 	br	81114ec4 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
81114e20:	d0a06217 	ldw	r2,-32376(gp)
81114e24:	100f883a 	mov	r7,r2
81114e28:	01800784 	movi	r6,30
81114e2c:	01400044 	movi	r5,1
81114e30:	01204574 	movhi	r4,33045
81114e34:	21370304 	addi	r4,r4,-9204
81114e38:	11219e00 	call	811219e0 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
81114e3c:	00800044 	movi	r2,1
81114e40:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81114e44:	000f883a 	mov	r7,zero
81114e48:	01800144 	movi	r6,5
81114e4c:	000b883a 	mov	r5,zero
81114e50:	0009883a 	mov	r4,zero
81114e54:	11408140 	call	81140814 <OSTimeDlyHMSM>
                }
                break;
81114e58:	00001a06 	br	81114ec4 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81114e5c:	00800144 	movi	r2,5
81114e60:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
81114e64:	d0a06217 	ldw	r2,-32376(gp)
81114e68:	100f883a 	mov	r7,r2
81114e6c:	018002c4 	movi	r6,11
81114e70:	01400044 	movi	r5,1
81114e74:	01204574 	movhi	r4,33045
81114e78:	21370b04 	addi	r4,r4,-9172
81114e7c:	11219e00 	call	811219e0 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81114e80:	000f883a 	mov	r7,zero
81114e84:	01800644 	movi	r6,25
81114e88:	000b883a 	mov	r5,zero
81114e8c:	0009883a 	mov	r4,zero
81114e90:	11408140 	call	81140814 <OSTimeDlyHMSM>

                break;
81114e94:	00000b06 	br	81114ec4 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
81114e98:	d0a06217 	ldw	r2,-32376(gp)
81114e9c:	100f883a 	mov	r7,r2
81114ea0:	018003c4 	movi	r6,15
81114ea4:	01400044 	movi	r5,1
81114ea8:	01204574 	movhi	r4,33045
81114eac:	21370e04 	addi	r4,r4,-9160
81114eb0:	11219e00 	call	811219e0 <fwrite>
                #endif
                eSenderMode = sDummySender;
81114eb4:	00800144 	movi	r2,5
81114eb8:	e0bffd15 	stw	r2,-12(fp)
                break;
81114ebc:	00000106 	br	81114ec4 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81114ec0:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81114ec4:	003fb106 	br	81114d8c <__reset+0xfb0f4d8c>

81114ec8 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81114ec8:	defff804 	addi	sp,sp,-32
81114ecc:	de00012e 	bgeu	sp,et,81114ed4 <vSimMebTask+0xc>
81114ed0:	003b68fa 	trap	3
81114ed4:	dfc00715 	stw	ra,28(sp)
81114ed8:	df000615 	stw	fp,24(sp)
81114edc:	df000604 	addi	fp,sp,24
81114ee0:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
81114ee4:	e0bfff17 	ldw	r2,-4(fp)
81114ee8:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
81114eec:	d0a06217 	ldw	r2,-32376(gp)
81114ef0:	100f883a 	mov	r7,r2
81114ef4:	018008c4 	movi	r6,35
81114ef8:	01400044 	movi	r5,1
81114efc:	01204574 	movhi	r4,33045
81114f00:	21371204 	addi	r4,r4,-9144
81114f04:	11219e00 	call	811219e0 <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
81114f08:	e0bffb17 	ldw	r2,-20(fp)
81114f0c:	10800117 	ldw	r2,4(r2)
81114f10:	10c00168 	cmpgeui	r3,r2,5
81114f14:	1800ed1e 	bne	r3,zero,811152cc <vSimMebTask+0x404>
81114f18:	100690ba 	slli	r3,r2,2
81114f1c:	00a04474 	movhi	r2,33041
81114f20:	1093cc04 	addi	r2,r2,20272
81114f24:	1885883a 	add	r2,r3,r2
81114f28:	10800017 	ldw	r2,0(r2)
81114f2c:	1000683a 	jmp	r2
81114f30:	81114f44 	addi	r4,r16,17725
81114f34:	81114f5c 	xori	r4,r16,17725
81114f38:	81114fdc 	xori	r4,r16,17727
81114f3c:	811150a8 	cmpgeui	r4,r16,17730
81114f40:	81115180 	call	88111518 <__reset+0x20f1518>
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81114f44:	e13ffb17 	ldw	r4,-20(fp)
81114f48:	11160700 	call	81116070 <vMebInit>
				pxMebC->eMode = sMebToConfig;
81114f4c:	e0bffb17 	ldw	r2,-20(fp)
81114f50:	00c00044 	movi	r3,1
81114f54:	10c00115 	stw	r3,4(r2)
				break;
81114f58:	0000e706 	br	811152f8 <vSimMebTask+0x430>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
81114f5c:	d0a06217 	ldw	r2,-32376(gp)
81114f60:	100f883a 	mov	r7,r2
81114f64:	01800584 	movi	r6,22
81114f68:	01400044 	movi	r5,1
81114f6c:	01204574 	movhi	r4,33045
81114f70:	21371b04 	addi	r4,r4,-9108
81114f74:	11219e00 	call	811219e0 <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81114f78:	111ec3c0 	call	8111ec3c <bStopSync>
				vSyncClearCounter();
81114f7c:	110c9d80 	call	8110c9d8 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81114f80:	11161780 	call	81116178 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81114f84:	01c00284 	movi	r7,10
81114f88:	000d883a 	mov	r6,zero
81114f8c:	000b883a 	mov	r5,zero
81114f90:	0009883a 	mov	r4,zero
81114f94:	11408140 	call	81140814 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81114f98:	000d883a 	mov	r6,zero
81114f9c:	000b883a 	mov	r5,zero
81114fa0:	01002844 	movi	r4,161
81114fa4:	1115e440 	call	81115e44 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81114fa8:	000d883a 	mov	r6,zero
81114fac:	000b883a 	mov	r5,zero
81114fb0:	01002844 	movi	r4,161
81114fb4:	1115fe80 	call	81115fe8 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81114fb8:	01c03e84 	movi	r7,250
81114fbc:	000d883a 	mov	r6,zero
81114fc0:	000b883a 	mov	r5,zero
81114fc4:	0009883a 	mov	r4,zero
81114fc8:	11408140 	call	81140814 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81114fcc:	e0bffb17 	ldw	r2,-20(fp)
81114fd0:	00c000c4 	movi	r3,3
81114fd4:	10c00115 	stw	r3,4(r2)
				break;
81114fd8:	0000c706 	br	811152f8 <vSimMebTask+0x430>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
81114fdc:	d0a06217 	ldw	r2,-32376(gp)
81114fe0:	100f883a 	mov	r7,r2
81114fe4:	018004c4 	movi	r6,19
81114fe8:	01400044 	movi	r5,1
81114fec:	01204574 	movhi	r4,33045
81114ff0:	21372104 	addi	r4,r4,-9084
81114ff4:	11219e00 	call	811219e0 <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81114ff8:	000d883a 	mov	r6,zero
81114ffc:	000b883a 	mov	r5,zero
81115000:	01002884 	movi	r4,162
81115004:	1115e440 	call	81115e44 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
81115008:	000d883a 	mov	r6,zero
8111500c:	000b883a 	mov	r5,zero
81115010:	01002884 	movi	r4,162
81115014:	1115fe80 	call	81115fe8 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
81115018:	e0bffb17 	ldw	r2,-20(fp)
8111501c:	1080050b 	ldhu	r2,20(r2)
81115020:	10bfffcc 	andi	r2,r2,65535
81115024:	100f883a 	mov	r7,r2
81115028:	000d883a 	mov	r6,zero
8111502c:	000b883a 	mov	r5,zero
81115030:	0009883a 	mov	r4,zero
81115034:	11408140 	call	81140814 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81115038:	e03ffa05 	stb	zero,-24(fp)
8111503c:	00001006 	br	81115080 <vSimMebTask+0x1b8>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
81115040:	e0bffa03 	ldbu	r2,-24(fp)
81115044:	10809624 	muli	r2,r2,600
81115048:	10809b04 	addi	r2,r2,620
8111504c:	e0fffb17 	ldw	r3,-20(fp)
81115050:	1885883a 	add	r2,r3,r2
81115054:	1009883a 	mov	r4,r2
81115058:	110a6340 	call	8110a634 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
8111505c:	e0bffa03 	ldbu	r2,-24(fp)
81115060:	e0fffb17 	ldw	r3,-20(fp)
81115064:	10809624 	muli	r2,r2,600
81115068:	1885883a 	add	r2,r3,r2
8111506c:	10803c04 	addi	r2,r2,240
81115070:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81115074:	e0bffa03 	ldbu	r2,-24(fp)
81115078:	10800044 	addi	r2,r2,1
8111507c:	e0bffa05 	stb	r2,-24(fp)
81115080:	e0bffa03 	ldbu	r2,-24(fp)
81115084:	103fee26 	beq	r2,zero,81115040 <__reset+0xfb0f5040>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
81115088:	110d0280 	call	8110d028 <bSyncCtrReset>
				vSyncClearCounter();
8111508c:	110c9d80 	call	8110c9d8 <vSyncClearCounter>
				bStartSync();
81115090:	111ec000 	call	8111ec00 <bStartSync>

				vEvtChangeMebMode();
81115094:	111d5200 	call	8111d520 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81115098:	e0bffb17 	ldw	r2,-20(fp)
8111509c:	00c00104 	movi	r3,4
811150a0:	10c00115 	stw	r3,4(r2)
				break;
811150a4:	00009406 	br	811152f8 <vSimMebTask+0x430>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811150a8:	d0a06917 	ldw	r2,-32348(gp)
811150ac:	e0fffe04 	addi	r3,fp,-8
811150b0:	180d883a 	mov	r6,r3
811150b4:	000b883a 	mov	r5,zero
811150b8:	1009883a 	mov	r4,r2
811150bc:	113d9840 	call	8113d984 <OSQPend>
811150c0:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
811150c4:	e0bffe03 	ldbu	r2,-8(fp)
811150c8:	10803fcc 	andi	r2,r2,255
811150cc:	1000291e 	bne	r2,zero,81115174 <vSimMebTask+0x2ac>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
811150d0:	e0bffdc3 	ldbu	r2,-9(fp)
811150d4:	10803fcc 	andi	r2,r2,255
811150d8:	10800058 	cmpnei	r2,r2,1
811150dc:	10001c1e 	bne	r2,zero,81115150 <vSimMebTask+0x288>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
811150e0:	e0bffd83 	ldbu	r2,-10(fp)
811150e4:	10803fcc 	andi	r2,r2,255
811150e8:	10c00060 	cmpeqi	r3,r2,1
811150ec:	1800031e 	bne	r3,zero,811150fc <vSimMebTask+0x234>
811150f0:	10803820 	cmpeqi	r2,r2,224
811150f4:	1000041e 	bne	r2,zero,81115108 <vSimMebTask+0x240>
811150f8:	00000b06 	br	81115128 <vSimMebTask+0x260>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
811150fc:	e13ffb17 	ldw	r4,-20(fp)
81115100:	11152fc0 	call	811152fc <vPusMebTask>
								break;
81115104:	00001d06 	br	8111517c <vSimMebTask+0x2b4>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81115108:	d0a06217 	ldw	r2,-32376(gp)
8111510c:	100f883a 	mov	r7,r2
81115110:	018012c4 	movi	r6,75
81115114:	01400044 	movi	r5,1
81115118:	01204574 	movhi	r4,33045
8111511c:	21372604 	addi	r4,r4,-9064
81115120:	11219e00 	call	811219e0 <fwrite>
								#endif
								break;
81115124:	00001506 	br	8111517c <vSimMebTask+0x2b4>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81115128:	d0a06217 	ldw	r2,-32376(gp)
8111512c:	e0fffd83 	ldbu	r3,-10(fp)
81115130:	18c03fcc 	andi	r3,r3,255
81115134:	180d883a 	mov	r6,r3
81115138:	01604574 	movhi	r5,33045
8111513c:	29773904 	addi	r5,r5,-8988
81115140:	1009883a 	mov	r4,r2
81115144:	11213440 	call	81121344 <fprintf>
								#endif
								break;
81115148:	0001883a 	nop
8111514c:	00000b06 	br	8111517c <vSimMebTask+0x2b4>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81115150:	d0a06217 	ldw	r2,-32376(gp)
81115154:	e0fffdc3 	ldbu	r3,-9(fp)
81115158:	18c03fcc 	andi	r3,r3,255
8111515c:	180d883a 	mov	r6,r3
81115160:	01604574 	movhi	r5,33045
81115164:	29774b04 	addi	r5,r5,-8916
81115168:	1009883a 	mov	r4,r2
8111516c:	11213440 	call	81121344 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81115170:	00006106 	br	811152f8 <vSimMebTask+0x430>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81115174:	111cec00 	call	8111cec0 <vCouldNotGetCmdQueueMeb>
				}

				break;
81115178:	00005f06 	br	811152f8 <vSimMebTask+0x430>
8111517c:	00005e06 	br	811152f8 <vSimMebTask+0x430>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81115180:	d0a06917 	ldw	r2,-32348(gp)
81115184:	e0fffe04 	addi	r3,fp,-8
81115188:	180d883a 	mov	r6,r3
8111518c:	000b883a 	mov	r5,zero
81115190:	1009883a 	mov	r4,r2
81115194:	113d9840 	call	8113d984 <OSQPend>
81115198:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8111519c:	e0bffe03 	ldbu	r2,-8(fp)
811151a0:	10803fcc 	andi	r2,r2,255
811151a4:	1000461e 	bne	r2,zero,811152c0 <vSimMebTask+0x3f8>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
811151a8:	e0bffdc3 	ldbu	r2,-9(fp)
811151ac:	10803fcc 	andi	r2,r2,255
811151b0:	10800058 	cmpnei	r2,r2,1
811151b4:	1000391e 	bne	r2,zero,8111529c <vSimMebTask+0x3d4>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
811151b8:	e0bffd83 	ldbu	r2,-10(fp)
811151bc:	10803fcc 	andi	r2,r2,255
811151c0:	10c03820 	cmpeqi	r3,r2,224
811151c4:	1800071e 	bne	r3,zero,811151e4 <vSimMebTask+0x31c>
811151c8:	10c03860 	cmpeqi	r3,r2,225
811151cc:	1800071e 	bne	r3,zero,811151ec <vSimMebTask+0x324>
811151d0:	10800060 	cmpeqi	r2,r2,1
811151d4:	10002726 	beq	r2,zero,81115274 <vSimMebTask+0x3ac>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
811151d8:	e13ffb17 	ldw	r4,-20(fp)
811151dc:	11152fc0 	call	811152fc <vPusMebTask>
								break;
811151e0:	00003906 	br	811152c8 <vSimMebTask+0x400>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
811151e4:	e13ffb17 	ldw	r4,-20(fp)
811151e8:	11160d40 	call	811160d4 <vSwapMemmory>
							case M_SYNC:
								#ifdef DEBUG_ON
									bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
811151ec:	e0bffb17 	ldw	r2,-20(fp)
811151f0:	10809b04 	addi	r2,r2,620
811151f4:	1009883a 	mov	r4,r2
811151f8:	110a5a40 	call	8110a5a4 <bSpwcGetTimecode>
									tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
811151fc:	e0bffb17 	ldw	r2,-20(fp)
81115200:	1080a743 	ldbu	r2,669(r2)
81115204:	e0bffc05 	stb	r2,-16(fp)
									tCodeNext = ( tCode ) % 4;
81115208:	e0bffc03 	ldbu	r2,-16(fp)
8111520c:	108000cc 	andi	r2,r2,3
81115210:	e0bffc45 	stb	r2,-15(fp)

									fprintf(fp,"\n\nMEB TASK:  TC: %hhu ( %hhu )\n ", tCode, tCodeNext);
81115214:	d0a06217 	ldw	r2,-32376(gp)
81115218:	e0fffc03 	ldbu	r3,-16(fp)
8111521c:	e13ffc43 	ldbu	r4,-15(fp)
81115220:	200f883a 	mov	r7,r4
81115224:	180d883a 	mov	r6,r3
81115228:	01604574 	movhi	r5,33045
8111522c:	29775904 	addi	r5,r5,-8860
81115230:	1009883a 	mov	r4,r2
81115234:	11213440 	call	81121344 <fprintf>


									bRmapGetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);
81115238:	e0bffb17 	ldw	r2,-20(fp)
8111523c:	10805504 	addi	r2,r2,340
81115240:	1009883a 	mov	r4,r2
81115244:	11081980 	call	81108198 <bRmapGetMemConfigArea>
									ucFrameNumber = pxMebC->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliFrameNumber;
81115248:	e0bffb17 	ldw	r2,-20(fp)
8111524c:	10807717 	ldw	r2,476(r2)
81115250:	e0bffc85 	stb	r2,-14(fp)

									//bRmapSetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);

									fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
81115254:	d0a06217 	ldw	r2,-32376(gp)
81115258:	e0fffc83 	ldbu	r3,-14(fp)
8111525c:	180d883a 	mov	r6,r3
81115260:	01604574 	movhi	r5,33045
81115264:	29776204 	addi	r5,r5,-8824
81115268:	1009883a 	mov	r4,r2
8111526c:	11213440 	call	81121344 <fprintf>

								#endif

								break;
81115270:	00001506 	br	811152c8 <vSimMebTask+0x400>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
81115274:	d0a06217 	ldw	r2,-32376(gp)
81115278:	e0fffd83 	ldbu	r3,-10(fp)
8111527c:	18c03fcc 	andi	r3,r3,255
81115280:	180d883a 	mov	r6,r3
81115284:	01604574 	movhi	r5,33045
81115288:	29776b04 	addi	r5,r5,-8788
8111528c:	1009883a 	mov	r4,r2
81115290:	11213440 	call	81121344 <fprintf>
								#endif
								break;
81115294:	0001883a 	nop
81115298:	00000b06 	br	811152c8 <vSimMebTask+0x400>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
8111529c:	d0a06217 	ldw	r2,-32376(gp)
811152a0:	e0fffdc3 	ldbu	r3,-9(fp)
811152a4:	18c03fcc 	andi	r3,r3,255
811152a8:	180d883a 	mov	r6,r3
811152ac:	01604574 	movhi	r5,33045
811152b0:	29774b04 	addi	r5,r5,-8916
811152b4:	1009883a 	mov	r4,r2
811152b8:	11213440 	call	81121344 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
811152bc:	00000e06 	br	811152f8 <vSimMebTask+0x430>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811152c0:	111cec00 	call	8111cec0 <vCouldNotGetCmdQueueMeb>
				}			
				break;
811152c4:	00000c06 	br	811152f8 <vSimMebTask+0x430>
811152c8:	00000b06 	br	811152f8 <vSimMebTask+0x430>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
811152cc:	d0a06217 	ldw	r2,-32376(gp)
811152d0:	100f883a 	mov	r7,r2
811152d4:	01800bc4 	movi	r6,47
811152d8:	01400044 	movi	r5,1
811152dc:	01204574 	movhi	r4,33045
811152e0:	21377404 	addi	r4,r4,-8752
811152e4:	11219e00 	call	811219e0 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
811152e8:	e0bffb17 	ldw	r2,-20(fp)
811152ec:	00c00044 	movi	r3,1
811152f0:	10c00115 	stw	r3,4(r2)
				break;
811152f4:	0001883a 	nop
		}
	}
811152f8:	003f0306 	br	81114f08 <__reset+0xfb0f4f08>

811152fc <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
811152fc:	defffb04 	addi	sp,sp,-20
81115300:	de00012e 	bgeu	sp,et,81115308 <vPusMebTask+0xc>
81115304:	003b68fa 	trap	3
81115308:	dfc00415 	stw	ra,16(sp)
8111530c:	df000315 	stw	fp,12(sp)
81115310:	df000304 	addi	fp,sp,12
81115314:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
81115318:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
8111531c:	d0a07317 	ldw	r2,-32308(gp)
81115320:	e0fffe44 	addi	r3,fp,-7
81115324:	180d883a 	mov	r6,r3
81115328:	01400084 	movi	r5,2
8111532c:	1009883a 	mov	r4,r2
81115330:	113c8700 	call	8113c870 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81115334:	e0bffe43 	ldbu	r2,-7(fp)
81115338:	10803fcc 	andi	r2,r2,255
8111533c:	10002c1e 	bne	r2,zero,811153f0 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81115340:	e03ffe05 	stb	zero,-8(fp)
81115344:	00002306 	br	811153d4 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81115348:	e0fffe03 	ldbu	r3,-8(fp)
8111534c:	00a04574 	movhi	r2,33045
81115350:	10975804 	addi	r2,r2,23904
81115354:	18c01524 	muli	r3,r3,84
81115358:	10c5883a 	add	r2,r2,r3
8111535c:	10800104 	addi	r2,r2,4
81115360:	10800017 	ldw	r2,0(r2)
81115364:	10800058 	cmpnei	r2,r2,1
81115368:	1000171e 	bne	r2,zero,811153c8 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
8111536c:	e13ffe03 	ldbu	r4,-8(fp)
81115370:	00e04574 	movhi	r3,33045
81115374:	18ccdb04 	addi	r3,r3,13164
81115378:	00a04574 	movhi	r2,33045
8111537c:	10975804 	addi	r2,r2,23904
81115380:	21001524 	muli	r4,r4,84
81115384:	1105883a 	add	r2,r2,r4
81115388:	1009883a 	mov	r4,r2
8111538c:	00801504 	movi	r2,84
81115390:	100d883a 	mov	r6,r2
81115394:	200b883a 	mov	r5,r4
81115398:	1809883a 	mov	r4,r3
8111539c:	11223f40 	call	811223f4 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
811153a0:	e0fffe03 	ldbu	r3,-8(fp)
811153a4:	00a04574 	movhi	r2,33045
811153a8:	10975804 	addi	r2,r2,23904
811153ac:	18c01524 	muli	r3,r3,84
811153b0:	10c5883a 	add	r2,r2,r3
811153b4:	10800104 	addi	r2,r2,4
811153b8:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
811153bc:	00800044 	movi	r2,1
811153c0:	e0bffd15 	stw	r2,-12(fp)
                break;
811153c4:	00000606 	br	811153e0 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811153c8:	e0bffe03 	ldbu	r2,-8(fp)
811153cc:	10800044 	addi	r2,r2,1
811153d0:	e0bffe05 	stb	r2,-8(fp)
811153d4:	e0bffe03 	ldbu	r2,-8(fp)
811153d8:	10800130 	cmpltui	r2,r2,4
811153dc:	103fda1e 	bne	r2,zero,81115348 <__reset+0xfb0f5348>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
811153e0:	d0a07317 	ldw	r2,-32308(gp)
811153e4:	1009883a 	mov	r4,r2
811153e8:	113ce140 	call	8113ce14 <OSMutexPost>
811153ec:	00000106 	br	811153f4 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
811153f0:	111cf280 	call	8111cf28 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
811153f4:	e0bffd17 	ldw	r2,-12(fp)
811153f8:	10001126 	beq	r2,zero,81115440 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
811153fc:	e0bfff17 	ldw	r2,-4(fp)
81115400:	10800117 	ldw	r2,4(r2)
81115404:	10c000e0 	cmpeqi	r3,r2,3
81115408:	1800031e 	bne	r3,zero,81115418 <vPusMebTask+0x11c>
8111540c:	10800120 	cmpeqi	r2,r2,4
81115410:	1000061e 	bne	r2,zero,8111542c <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81115414:	00000a06 	br	81115440 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81115418:	01604574 	movhi	r5,33045
8111541c:	294cdb04 	addi	r5,r5,13164
81115420:	e13fff17 	ldw	r4,-4(fp)
81115424:	11154580 	call	81115458 <vPusMebInTaskConfigMode>
				break;
81115428:	00000506 	br	81115440 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
8111542c:	01604574 	movhi	r5,33045
81115430:	294cdb04 	addi	r5,r5,13164
81115434:	e13fff17 	ldw	r4,-4(fp)
81115438:	11157e80 	call	811157e8 <vPusMebInTaskRunningMode>
				break;
8111543c:	0001883a 	nop
			default:
				break;
		}
	}
}
81115440:	0001883a 	nop
81115444:	e037883a 	mov	sp,fp
81115448:	dfc00117 	ldw	ra,4(sp)
8111544c:	df000017 	ldw	fp,0(sp)
81115450:	dec00204 	addi	sp,sp,8
81115454:	f800283a 	ret

81115458 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115458:	defffc04 	addi	sp,sp,-16
8111545c:	de00012e 	bgeu	sp,et,81115464 <vPusMebInTaskConfigMode+0xc>
81115460:	003b68fa 	trap	3
81115464:	dfc00315 	stw	ra,12(sp)
81115468:	df000215 	stw	fp,8(sp)
8111546c:	df000204 	addi	fp,sp,8
81115470:	e13ffe15 	stw	r4,-8(fp)
81115474:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81115478:	e0bfff17 	ldw	r2,-4(fp)
8111547c:	1080030b 	ldhu	r2,12(r2)
81115480:	10bfffcc 	andi	r2,r2,65535
81115484:	10c03ee0 	cmpeqi	r3,r2,251
81115488:	1800081e 	bne	r3,zero,811154ac <vPusMebInTaskConfigMode+0x54>
8111548c:	10c03f20 	cmpeqi	r3,r2,252
81115490:	18000a1e 	bne	r3,zero,811154bc <vPusMebInTaskConfigMode+0x64>
81115494:	10803ea0 	cmpeqi	r2,r2,250
81115498:	10000c26 	beq	r2,zero,811154cc <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
8111549c:	e17fff17 	ldw	r5,-4(fp)
811154a0:	e13ffe17 	ldw	r4,-8(fp)
811154a4:	11155040 	call	81115504 <vPusType250conf>
			break;
811154a8:	00001006 	br	811154ec <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
811154ac:	e17fff17 	ldw	r5,-4(fp)
811154b0:	e13ffe17 	ldw	r4,-8(fp)
811154b4:	11155900 	call	81115590 <vPusType251conf>
			break;
811154b8:	00000c06 	br	811154ec <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
811154bc:	e17fff17 	ldw	r5,-4(fp)
811154c0:	e13ffe17 	ldw	r4,-8(fp)
811154c4:	11155e40 	call	811155e4 <vPusType252conf>
			break;
811154c8:	00000806 	br	811154ec <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
811154cc:	d0a06217 	ldw	r2,-32376(gp)
811154d0:	100f883a 	mov	r7,r2
811154d4:	01800d84 	movi	r6,54
811154d8:	01400044 	movi	r5,1
811154dc:	01204574 	movhi	r4,33045
811154e0:	21378004 	addi	r4,r4,-8704
811154e4:	11219e00 	call	811219e0 <fwrite>
			#endif
			break;
811154e8:	0001883a 	nop
	}
}
811154ec:	0001883a 	nop
811154f0:	e037883a 	mov	sp,fp
811154f4:	dfc00117 	ldw	ra,4(sp)
811154f8:	df000017 	ldw	fp,0(sp)
811154fc:	dec00204 	addi	sp,sp,8
81115500:	f800283a 	ret

81115504 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115504:	defffc04 	addi	sp,sp,-16
81115508:	de00012e 	bgeu	sp,et,81115510 <vPusType250conf+0xc>
8111550c:	003b68fa 	trap	3
81115510:	dfc00315 	stw	ra,12(sp)
81115514:	df000215 	stw	fp,8(sp)
81115518:	df000204 	addi	fp,sp,8
8111551c:	e13ffe15 	stw	r4,-8(fp)
81115520:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81115524:	e0bfff17 	ldw	r2,-4(fp)
81115528:	1080038b 	ldhu	r2,14(r2)
8111552c:	10bfffcc 	andi	r2,r2,65535
81115530:	10c00f60 	cmpeqi	r3,r2,61
81115534:	1800031e 	bne	r3,zero,81115544 <vPusType250conf+0x40>
81115538:	10800fa0 	cmpeqi	r2,r2,62
8111553c:	10000d1e 	bne	r2,zero,81115574 <vPusType250conf+0x70>
81115540:	00000406 	br	81115554 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81115544:	e0bffe17 	ldw	r2,-8(fp)
81115548:	00c00084 	movi	r3,2
8111554c:	10c00115 	stw	r3,4(r2)
			break;
81115550:	00000906 	br	81115578 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81115554:	d0a06217 	ldw	r2,-32376(gp)
81115558:	100f883a 	mov	r7,r2
8111555c:	01800b04 	movi	r6,44
81115560:	01400044 	movi	r5,1
81115564:	01204574 	movhi	r4,33045
81115568:	21378e04 	addi	r4,r4,-8648
8111556c:	11219e00 	call	811219e0 <fwrite>
			#endif
			break;
81115570:	00000106 	br	81115578 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81115574:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81115578:	0001883a 	nop
8111557c:	e037883a 	mov	sp,fp
81115580:	dfc00117 	ldw	ra,4(sp)
81115584:	df000017 	ldw	fp,0(sp)
81115588:	dec00204 	addi	sp,sp,8
8111558c:	f800283a 	ret

81115590 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115590:	defffc04 	addi	sp,sp,-16
81115594:	de00012e 	bgeu	sp,et,8111559c <vPusType251conf+0xc>
81115598:	003b68fa 	trap	3
8111559c:	dfc00315 	stw	ra,12(sp)
811155a0:	df000215 	stw	fp,8(sp)
811155a4:	df000204 	addi	fp,sp,8
811155a8:	e13ffe15 	stw	r4,-8(fp)
811155ac:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
811155b0:	d0a06217 	ldw	r2,-32376(gp)
811155b4:	100f883a 	mov	r7,r2
811155b8:	01801184 	movi	r6,70
811155bc:	01400044 	movi	r5,1
811155c0:	01204574 	movhi	r4,33045
811155c4:	21379a04 	addi	r4,r4,-8600
811155c8:	11219e00 	call	811219e0 <fwrite>
	#endif
}
811155cc:	0001883a 	nop
811155d0:	e037883a 	mov	sp,fp
811155d4:	dfc00117 	ldw	ra,4(sp)
811155d8:	df000017 	ldw	fp,0(sp)
811155dc:	dec00204 	addi	sp,sp,8
811155e0:	f800283a 	ret

811155e4 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811155e4:	defffb04 	addi	sp,sp,-20
811155e8:	de00012e 	bgeu	sp,et,811155f0 <vPusType252conf+0xc>
811155ec:	003b68fa 	trap	3
811155f0:	dfc00415 	stw	ra,16(sp)
811155f4:	df000315 	stw	fp,12(sp)
811155f8:	df000304 	addi	fp,sp,12
811155fc:	e13ffe15 	stw	r4,-8(fp)
81115600:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115604:	e0bfff17 	ldw	r2,-4(fp)
81115608:	1080050b 	ldhu	r2,20(r2)
8111560c:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81115610:	e0bfff17 	ldw	r2,-4(fp)
81115614:	1080038b 	ldhu	r2,14(r2)
81115618:	10bfffcc 	andi	r2,r2,65535
8111561c:	10c000a0 	cmpeqi	r3,r2,2
81115620:	18000c1e 	bne	r3,zero,81115654 <vPusType252conf+0x70>
81115624:	10c00090 	cmplti	r3,r2,2
81115628:	1800611e 	bne	r3,zero,811157b0 <vPusType252conf+0x1cc>
8111562c:	10800188 	cmpgei	r2,r2,6
81115630:	10005f1e 	bne	r2,zero,811157b0 <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81115634:	d0a06217 	ldw	r2,-32376(gp)
81115638:	100f883a 	mov	r7,r2
8111563c:	01801384 	movi	r6,78
81115640:	01400044 	movi	r5,1
81115644:	01204574 	movhi	r4,33045
81115648:	2137ac04 	addi	r4,r4,-8528
8111564c:	11219e00 	call	811219e0 <fwrite>
			#endif
			break;
81115650:	00005f06 	br	811157d0 <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115654:	e0bffd0b 	ldhu	r2,-12(fp)
81115658:	10809624 	muli	r2,r2,600
8111565c:	10805504 	addi	r2,r2,340
81115660:	e0fffe17 	ldw	r3,-8(fp)
81115664:	1885883a 	add	r2,r3,r2
81115668:	1009883a 	mov	r4,r2
8111566c:	11079780 	call	81107978 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81115670:	e0bffd0b 	ldhu	r2,-12(fp)
81115674:	e0fffe17 	ldw	r3,-8(fp)
81115678:	10809624 	muli	r2,r2,600
8111567c:	1885883a 	add	r2,r3,r2
81115680:	10806504 	addi	r2,r2,404
81115684:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115688:	e0bffd0b 	ldhu	r2,-12(fp)
8111568c:	10809624 	muli	r2,r2,600
81115690:	10805504 	addi	r2,r2,340
81115694:	e0fffe17 	ldw	r3,-8(fp)
81115698:	1885883a 	add	r2,r3,r2
8111569c:	1009883a 	mov	r4,r2
811156a0:	11078d00 	call	811078d0 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811156a4:	e0bffd0b 	ldhu	r2,-12(fp)
811156a8:	10809624 	muli	r2,r2,600
811156ac:	10805504 	addi	r2,r2,340
811156b0:	e0fffe17 	ldw	r3,-8(fp)
811156b4:	1885883a 	add	r2,r3,r2
811156b8:	1009883a 	mov	r4,r2
811156bc:	1107b600 	call	81107b60 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811156c0:	e0bffd0b 	ldhu	r2,-12(fp)
811156c4:	e0ffff17 	ldw	r3,-4(fp)
811156c8:	18c00b0b 	ldhu	r3,44(r3)
811156cc:	1809883a 	mov	r4,r3
811156d0:	e0fffe17 	ldw	r3,-8(fp)
811156d4:	10809624 	muli	r2,r2,600
811156d8:	1885883a 	add	r2,r3,r2
811156dc:	10805604 	addi	r2,r2,344
811156e0:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
811156e4:	e0bffd0b 	ldhu	r2,-12(fp)
811156e8:	e0ffff17 	ldw	r3,-4(fp)
811156ec:	18c0098b 	ldhu	r3,38(r3)
811156f0:	1809883a 	mov	r4,r3
811156f4:	e0fffe17 	ldw	r3,-8(fp)
811156f8:	10809624 	muli	r2,r2,600
811156fc:	1885883a 	add	r2,r3,r2
81115700:	10805644 	addi	r2,r2,345
81115704:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81115708:	e0bffd0b 	ldhu	r2,-12(fp)
8111570c:	10809624 	muli	r2,r2,600
81115710:	10805504 	addi	r2,r2,340
81115714:	e0fffe17 	ldw	r3,-8(fp)
81115718:	1885883a 	add	r2,r3,r2
8111571c:	1009883a 	mov	r4,r2
81115720:	1107a880 	call	81107a88 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115724:	e0bffd0b 	ldhu	r2,-12(fp)
81115728:	10809624 	muli	r2,r2,600
8111572c:	10805504 	addi	r2,r2,340
81115730:	e0fffe17 	ldw	r3,-8(fp)
81115734:	1885883a 	add	r2,r3,r2
81115738:	1009883a 	mov	r4,r2
8111573c:	11079780 	call	81107978 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81115740:	e0bffd0b 	ldhu	r2,-12(fp)
81115744:	e0fffe17 	ldw	r3,-8(fp)
81115748:	10809624 	muli	r2,r2,600
8111574c:	1885883a 	add	r2,r3,r2
81115750:	10806504 	addi	r2,r2,404
81115754:	00c00044 	movi	r3,1
81115758:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111575c:	e0bffd0b 	ldhu	r2,-12(fp)
81115760:	10809624 	muli	r2,r2,600
81115764:	10805504 	addi	r2,r2,340
81115768:	e0fffe17 	ldw	r3,-8(fp)
8111576c:	1885883a 	add	r2,r3,r2
81115770:	1009883a 	mov	r4,r2
81115774:	11078d00 	call	811078d0 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81115778:	d0e06217 	ldw	r3,-32376(gp)
8111577c:	e0bfff17 	ldw	r2,-4(fp)
81115780:	10800b0b 	ldhu	r2,44(r2)
81115784:	113fffcc 	andi	r4,r2,65535
81115788:	e0bfff17 	ldw	r2,-4(fp)
8111578c:	1080098b 	ldhu	r2,38(r2)
81115790:	10bfffcc 	andi	r2,r2,65535
81115794:	100f883a 	mov	r7,r2
81115798:	200d883a 	mov	r6,r4
8111579c:	01604574 	movhi	r5,33045
811157a0:	2977c004 	addi	r5,r5,-8448
811157a4:	1809883a 	mov	r4,r3
811157a8:	11213440 	call	81121344 <fprintf>
			#endif

			break;
811157ac:	00000806 	br	811157d0 <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
811157b0:	d0a06217 	ldw	r2,-32376(gp)
811157b4:	100f883a 	mov	r7,r2
811157b8:	01800b04 	movi	r6,44
811157bc:	01400044 	movi	r5,1
811157c0:	01204574 	movhi	r4,33045
811157c4:	21378e04 	addi	r4,r4,-8648
811157c8:	11219e00 	call	811219e0 <fwrite>
			#endif
			break;
811157cc:	0001883a 	nop
	}
}
811157d0:	0001883a 	nop
811157d4:	e037883a 	mov	sp,fp
811157d8:	dfc00117 	ldw	ra,4(sp)
811157dc:	df000017 	ldw	fp,0(sp)
811157e0:	dec00204 	addi	sp,sp,8
811157e4:	f800283a 	ret

811157e8 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811157e8:	defffc04 	addi	sp,sp,-16
811157ec:	de00012e 	bgeu	sp,et,811157f4 <vPusMebInTaskRunningMode+0xc>
811157f0:	003b68fa 	trap	3
811157f4:	dfc00315 	stw	ra,12(sp)
811157f8:	df000215 	stw	fp,8(sp)
811157fc:	df000204 	addi	fp,sp,8
81115800:	e13ffe15 	stw	r4,-8(fp)
81115804:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81115808:	e0bfff17 	ldw	r2,-4(fp)
8111580c:	1080030b 	ldhu	r2,12(r2)
81115810:	10bfffcc 	andi	r2,r2,65535
81115814:	10c03ee0 	cmpeqi	r3,r2,251
81115818:	1800081e 	bne	r3,zero,8111583c <vPusMebInTaskRunningMode+0x54>
8111581c:	10c03f20 	cmpeqi	r3,r2,252
81115820:	18000a1e 	bne	r3,zero,8111584c <vPusMebInTaskRunningMode+0x64>
81115824:	10803ea0 	cmpeqi	r2,r2,250
81115828:	10000c26 	beq	r2,zero,8111585c <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
8111582c:	e17fff17 	ldw	r5,-4(fp)
81115830:	e13ffe17 	ldw	r4,-8(fp)
81115834:	11158940 	call	81115894 <vPusType250run>
			break;
81115838:	00001006 	br	8111587c <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
8111583c:	e17fff17 	ldw	r5,-4(fp)
81115840:	e13ffe17 	ldw	r4,-8(fp)
81115844:	11159200 	call	81115920 <vPusType251run>
			break;
81115848:	00000c06 	br	8111587c <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
8111584c:	e17fff17 	ldw	r5,-4(fp)
81115850:	e13ffe17 	ldw	r4,-8(fp)
81115854:	1115a340 	call	81115a34 <vPusType252run>
			break;
81115858:	00000806 	br	8111587c <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
8111585c:	d0a06217 	ldw	r2,-32376(gp)
81115860:	100f883a 	mov	r7,r2
81115864:	01800cc4 	movi	r6,51
81115868:	01400044 	movi	r5,1
8111586c:	01204574 	movhi	r4,33045
81115870:	2137d004 	addi	r4,r4,-8384
81115874:	11219e00 	call	811219e0 <fwrite>
			#endif
			break;
81115878:	0001883a 	nop
	}
}
8111587c:	0001883a 	nop
81115880:	e037883a 	mov	sp,fp
81115884:	dfc00117 	ldw	ra,4(sp)
81115888:	df000017 	ldw	fp,0(sp)
8111588c:	dec00204 	addi	sp,sp,8
81115890:	f800283a 	ret

81115894 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115894:	defffc04 	addi	sp,sp,-16
81115898:	de00012e 	bgeu	sp,et,811158a0 <vPusType250run+0xc>
8111589c:	003b68fa 	trap	3
811158a0:	dfc00315 	stw	ra,12(sp)
811158a4:	df000215 	stw	fp,8(sp)
811158a8:	df000204 	addi	fp,sp,8
811158ac:	e13ffe15 	stw	r4,-8(fp)
811158b0:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811158b4:	e0bfff17 	ldw	r2,-4(fp)
811158b8:	1080038b 	ldhu	r2,14(r2)
811158bc:	10bfffcc 	andi	r2,r2,65535
811158c0:	10c00f20 	cmpeqi	r3,r2,60
811158c4:	1800031e 	bne	r3,zero,811158d4 <vPusType250run+0x40>
811158c8:	10800fa0 	cmpeqi	r2,r2,62
811158cc:	10000d1e 	bne	r2,zero,81115904 <vPusType250run+0x70>
811158d0:	00000406 	br	811158e4 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
811158d4:	e0bffe17 	ldw	r2,-8(fp)
811158d8:	00c00044 	movi	r3,1
811158dc:	10c00115 	stw	r3,4(r2)
			break;
811158e0:	00000906 	br	81115908 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
811158e4:	d0a06217 	ldw	r2,-32376(gp)
811158e8:	100f883a 	mov	r7,r2
811158ec:	01800c84 	movi	r6,50
811158f0:	01400044 	movi	r5,1
811158f4:	01204574 	movhi	r4,33045
811158f8:	2137dd04 	addi	r4,r4,-8332
811158fc:	11219e00 	call	811219e0 <fwrite>
			#endif
			break;
81115900:	00000106 	br	81115908 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81115904:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81115908:	0001883a 	nop
8111590c:	e037883a 	mov	sp,fp
81115910:	dfc00117 	ldw	ra,4(sp)
81115914:	df000017 	ldw	fp,0(sp)
81115918:	dec00204 	addi	sp,sp,8
8111591c:	f800283a 	ret

81115920 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115920:	defffb04 	addi	sp,sp,-20
81115924:	de00012e 	bgeu	sp,et,8111592c <vPusType251run+0xc>
81115928:	003b68fa 	trap	3
8111592c:	dfc00415 	stw	ra,16(sp)
81115930:	df000315 	stw	fp,12(sp)
81115934:	df000304 	addi	fp,sp,12
81115938:	e13ffe15 	stw	r4,-8(fp)
8111593c:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115940:	e0bfff17 	ldw	r2,-4(fp)
81115944:	1080050b 	ldhu	r2,20(r2)
81115948:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
8111594c:	e0bfff17 	ldw	r2,-4(fp)
81115950:	1080038b 	ldhu	r2,14(r2)
81115954:	10bfffcc 	andi	r2,r2,65535
81115958:	10c000a0 	cmpeqi	r3,r2,2
8111595c:	18000f1e 	bne	r3,zero,8111599c <vPusType251run+0x7c>
81115960:	10c00160 	cmpeqi	r3,r2,5
81115964:	1800181e 	bne	r3,zero,811159c8 <vPusType251run+0xa8>
81115968:	10800060 	cmpeqi	r2,r2,1
8111596c:	10002126 	beq	r2,zero,811159f4 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81115970:	e0bffd0b 	ldhu	r2,-12(fp)
81115974:	10800444 	addi	r2,r2,17
81115978:	10803fcc 	andi	r2,r2,255
8111597c:	e0fffd0b 	ldhu	r3,-12(fp)
81115980:	18c03fcc 	andi	r3,r3,255
81115984:	180f883a 	mov	r7,r3
81115988:	000d883a 	mov	r6,zero
8111598c:	01400044 	movi	r5,1
81115990:	1009883a 	mov	r4,r2
81115994:	1115ecc0 	call	81115ecc <vSendCmdQToNFeeCTRL_GEN>
			break;
81115998:	00002006 	br	81115a1c <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
8111599c:	e0bffd0b 	ldhu	r2,-12(fp)
811159a0:	10800444 	addi	r2,r2,17
811159a4:	10803fcc 	andi	r2,r2,255
811159a8:	e0fffd0b 	ldhu	r3,-12(fp)
811159ac:	18c03fcc 	andi	r3,r3,255
811159b0:	180f883a 	mov	r7,r3
811159b4:	000d883a 	mov	r6,zero
811159b8:	01400104 	movi	r5,4
811159bc:	1009883a 	mov	r4,r2
811159c0:	1115ecc0 	call	81115ecc <vSendCmdQToNFeeCTRL_GEN>
			break;
811159c4:	00001506 	br	81115a1c <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
811159c8:	e0bffd0b 	ldhu	r2,-12(fp)
811159cc:	10800444 	addi	r2,r2,17
811159d0:	10803fcc 	andi	r2,r2,255
811159d4:	e0fffd0b 	ldhu	r3,-12(fp)
811159d8:	18c03fcc 	andi	r3,r3,255
811159dc:	180f883a 	mov	r7,r3
811159e0:	000d883a 	mov	r6,zero
811159e4:	01400204 	movi	r5,8
811159e8:	1009883a 	mov	r4,r2
811159ec:	1115ecc0 	call	81115ecc <vSendCmdQToNFeeCTRL_GEN>
			break;
811159f0:	00000a06 	br	81115a1c <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
811159f4:	d0e06217 	ldw	r3,-32376(gp)
811159f8:	e0bfff17 	ldw	r2,-4(fp)
811159fc:	1080038b 	ldhu	r2,14(r2)
81115a00:	10bfffcc 	andi	r2,r2,65535
81115a04:	100d883a 	mov	r6,r2
81115a08:	01604574 	movhi	r5,33045
81115a0c:	2977ea04 	addi	r5,r5,-8280
81115a10:	1809883a 	mov	r4,r3
81115a14:	11213440 	call	81121344 <fprintf>
			#endif
			break;
81115a18:	0001883a 	nop
	}
}
81115a1c:	0001883a 	nop
81115a20:	e037883a 	mov	sp,fp
81115a24:	dfc00117 	ldw	ra,4(sp)
81115a28:	df000017 	ldw	fp,0(sp)
81115a2c:	dec00204 	addi	sp,sp,8
81115a30:	f800283a 	ret

81115a34 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115a34:	defffb04 	addi	sp,sp,-20
81115a38:	de00012e 	bgeu	sp,et,81115a40 <vPusType252run+0xc>
81115a3c:	003b68fa 	trap	3
81115a40:	dfc00415 	stw	ra,16(sp)
81115a44:	df000315 	stw	fp,12(sp)
81115a48:	df000304 	addi	fp,sp,12
81115a4c:	e13ffe15 	stw	r4,-8(fp)
81115a50:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115a54:	e0bfff17 	ldw	r2,-4(fp)
81115a58:	1080050b 	ldhu	r2,20(r2)
81115a5c:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81115a60:	e0bfff17 	ldw	r2,-4(fp)
81115a64:	1080038b 	ldhu	r2,14(r2)
81115a68:	10bfffcc 	andi	r2,r2,65535
81115a6c:	10c000e0 	cmpeqi	r3,r2,3
81115a70:	18000a1e 	bne	r3,zero,81115a9c <vPusType252run+0x68>
81115a74:	10c00108 	cmpgei	r3,r2,4
81115a78:	1800031e 	bne	r3,zero,81115a88 <vPusType252run+0x54>
81115a7c:	108000a0 	cmpeqi	r2,r2,2
81115a80:	1000581e 	bne	r2,zero,81115be4 <vPusType252run+0x1b0>
81115a84:	0000be06 	br	81115d80 <vPusType252run+0x34c>
81115a88:	10c00120 	cmpeqi	r3,r2,4
81115a8c:	18002c1e 	bne	r3,zero,81115b40 <vPusType252run+0x10c>
81115a90:	10800160 	cmpeqi	r2,r2,5
81115a94:	1000c21e 	bne	r2,zero,81115da0 <vPusType252run+0x36c>
81115a98:	0000b906 	br	81115d80 <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115a9c:	e0bffd0b 	ldhu	r2,-12(fp)
81115aa0:	10809624 	muli	r2,r2,600
81115aa4:	10809b04 	addi	r2,r2,620
81115aa8:	e0fffe17 	ldw	r3,-8(fp)
81115aac:	1885883a 	add	r2,r3,r2
81115ab0:	1009883a 	mov	r4,r2
81115ab4:	110a2fc0 	call	8110a2fc <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81115ab8:	e0bffd0b 	ldhu	r2,-12(fp)
81115abc:	e0fffe17 	ldw	r3,-8(fp)
81115ac0:	10809624 	muli	r2,r2,600
81115ac4:	1885883a 	add	r2,r3,r2
81115ac8:	10809d04 	addi	r2,r2,628
81115acc:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81115ad0:	e0bffd0b 	ldhu	r2,-12(fp)
81115ad4:	e0fffe17 	ldw	r3,-8(fp)
81115ad8:	10809624 	muli	r2,r2,600
81115adc:	1885883a 	add	r2,r3,r2
81115ae0:	10809c04 	addi	r2,r2,624
81115ae4:	00c00044 	movi	r3,1
81115ae8:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81115aec:	e0bffd0b 	ldhu	r2,-12(fp)
81115af0:	e0fffe17 	ldw	r3,-8(fp)
81115af4:	10809624 	muli	r2,r2,600
81115af8:	1885883a 	add	r2,r3,r2
81115afc:	10809e04 	addi	r2,r2,632
81115b00:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115b04:	e0bffd0b 	ldhu	r2,-12(fp)
81115b08:	10809624 	muli	r2,r2,600
81115b0c:	10809b04 	addi	r2,r2,620
81115b10:	e0fffe17 	ldw	r3,-8(fp)
81115b14:	1885883a 	add	r2,r3,r2
81115b18:	1009883a 	mov	r4,r2
81115b1c:	110a1c80 	call	8110a1c8 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81115b20:	d0a06217 	ldw	r2,-32376(gp)
81115b24:	e0fffd0b 	ldhu	r3,-12(fp)
81115b28:	180d883a 	mov	r6,r3
81115b2c:	01604574 	movhi	r5,33045
81115b30:	2977f804 	addi	r5,r5,-8224
81115b34:	1009883a 	mov	r4,r2
81115b38:	11213440 	call	81121344 <fprintf>
			#endif

			break;
81115b3c:	00009906 	br	81115da4 <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115b40:	e0bffd0b 	ldhu	r2,-12(fp)
81115b44:	10809624 	muli	r2,r2,600
81115b48:	10809b04 	addi	r2,r2,620
81115b4c:	e0fffe17 	ldw	r3,-8(fp)
81115b50:	1885883a 	add	r2,r3,r2
81115b54:	1009883a 	mov	r4,r2
81115b58:	110a2fc0 	call	8110a2fc <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81115b5c:	e0bffd0b 	ldhu	r2,-12(fp)
81115b60:	e0fffe17 	ldw	r3,-8(fp)
81115b64:	10809624 	muli	r2,r2,600
81115b68:	1885883a 	add	r2,r3,r2
81115b6c:	10809d04 	addi	r2,r2,628
81115b70:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81115b74:	e0bffd0b 	ldhu	r2,-12(fp)
81115b78:	e0fffe17 	ldw	r3,-8(fp)
81115b7c:	10809624 	muli	r2,r2,600
81115b80:	1885883a 	add	r2,r3,r2
81115b84:	10809c04 	addi	r2,r2,624
81115b88:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81115b8c:	e0bffd0b 	ldhu	r2,-12(fp)
81115b90:	e0fffe17 	ldw	r3,-8(fp)
81115b94:	10809624 	muli	r2,r2,600
81115b98:	1885883a 	add	r2,r3,r2
81115b9c:	10809e04 	addi	r2,r2,632
81115ba0:	00c00044 	movi	r3,1
81115ba4:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115ba8:	e0bffd0b 	ldhu	r2,-12(fp)
81115bac:	10809624 	muli	r2,r2,600
81115bb0:	10809b04 	addi	r2,r2,620
81115bb4:	e0fffe17 	ldw	r3,-8(fp)
81115bb8:	1885883a 	add	r2,r3,r2
81115bbc:	1009883a 	mov	r4,r2
81115bc0:	110a1c80 	call	8110a1c8 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81115bc4:	d0a06217 	ldw	r2,-32376(gp)
81115bc8:	e0fffd0b 	ldhu	r3,-12(fp)
81115bcc:	180d883a 	mov	r6,r3
81115bd0:	01604574 	movhi	r5,33045
81115bd4:	29780104 	addi	r5,r5,-8188
81115bd8:	1009883a 	mov	r4,r2
81115bdc:	11213440 	call	81121344 <fprintf>
			#endif

			break;
81115be0:	00007006 	br	81115da4 <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81115be4:	e0bffd0b 	ldhu	r2,-12(fp)
81115be8:	e0fffe17 	ldw	r3,-8(fp)
81115bec:	10809624 	muli	r2,r2,600
81115bf0:	1885883a 	add	r2,r3,r2
81115bf4:	10803e04 	addi	r2,r2,248
81115bf8:	10800017 	ldw	r2,0(r2)
81115bfc:	10800058 	cmpnei	r2,r2,1
81115c00:	10004a1e 	bne	r2,zero,81115d2c <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115c04:	e0bffd0b 	ldhu	r2,-12(fp)
81115c08:	10809624 	muli	r2,r2,600
81115c0c:	10805504 	addi	r2,r2,340
81115c10:	e0fffe17 	ldw	r3,-8(fp)
81115c14:	1885883a 	add	r2,r3,r2
81115c18:	1009883a 	mov	r4,r2
81115c1c:	11079780 	call	81107978 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81115c20:	e0bffd0b 	ldhu	r2,-12(fp)
81115c24:	e0fffe17 	ldw	r3,-8(fp)
81115c28:	10809624 	muli	r2,r2,600
81115c2c:	1885883a 	add	r2,r3,r2
81115c30:	10806504 	addi	r2,r2,404
81115c34:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115c38:	e0bffd0b 	ldhu	r2,-12(fp)
81115c3c:	10809624 	muli	r2,r2,600
81115c40:	10805504 	addi	r2,r2,340
81115c44:	e0fffe17 	ldw	r3,-8(fp)
81115c48:	1885883a 	add	r2,r3,r2
81115c4c:	1009883a 	mov	r4,r2
81115c50:	11078d00 	call	811078d0 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81115c54:	e0bffd0b 	ldhu	r2,-12(fp)
81115c58:	10809624 	muli	r2,r2,600
81115c5c:	10805504 	addi	r2,r2,340
81115c60:	e0fffe17 	ldw	r3,-8(fp)
81115c64:	1885883a 	add	r2,r3,r2
81115c68:	1009883a 	mov	r4,r2
81115c6c:	1107b600 	call	81107b60 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81115c70:	e0bffd0b 	ldhu	r2,-12(fp)
81115c74:	e0ffff17 	ldw	r3,-4(fp)
81115c78:	18c00b0b 	ldhu	r3,44(r3)
81115c7c:	1809883a 	mov	r4,r3
81115c80:	e0fffe17 	ldw	r3,-8(fp)
81115c84:	10809624 	muli	r2,r2,600
81115c88:	1885883a 	add	r2,r3,r2
81115c8c:	10805604 	addi	r2,r2,344
81115c90:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81115c94:	e0bffd0b 	ldhu	r2,-12(fp)
81115c98:	e0ffff17 	ldw	r3,-4(fp)
81115c9c:	18c0098b 	ldhu	r3,38(r3)
81115ca0:	1809883a 	mov	r4,r3
81115ca4:	e0fffe17 	ldw	r3,-8(fp)
81115ca8:	10809624 	muli	r2,r2,600
81115cac:	1885883a 	add	r2,r3,r2
81115cb0:	10805644 	addi	r2,r2,345
81115cb4:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81115cb8:	e0bffd0b 	ldhu	r2,-12(fp)
81115cbc:	10809624 	muli	r2,r2,600
81115cc0:	10805504 	addi	r2,r2,340
81115cc4:	e0fffe17 	ldw	r3,-8(fp)
81115cc8:	1885883a 	add	r2,r3,r2
81115ccc:	1009883a 	mov	r4,r2
81115cd0:	1107a880 	call	81107a88 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115cd4:	e0bffd0b 	ldhu	r2,-12(fp)
81115cd8:	10809624 	muli	r2,r2,600
81115cdc:	10805504 	addi	r2,r2,340
81115ce0:	e0fffe17 	ldw	r3,-8(fp)
81115ce4:	1885883a 	add	r2,r3,r2
81115ce8:	1009883a 	mov	r4,r2
81115cec:	11079780 	call	81107978 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81115cf0:	e0bffd0b 	ldhu	r2,-12(fp)
81115cf4:	e0fffe17 	ldw	r3,-8(fp)
81115cf8:	10809624 	muli	r2,r2,600
81115cfc:	1885883a 	add	r2,r3,r2
81115d00:	10806504 	addi	r2,r2,404
81115d04:	00c00044 	movi	r3,1
81115d08:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115d0c:	e0bffd0b 	ldhu	r2,-12(fp)
81115d10:	10809624 	muli	r2,r2,600
81115d14:	10805504 	addi	r2,r2,340
81115d18:	e0fffe17 	ldw	r3,-8(fp)
81115d1c:	1885883a 	add	r2,r3,r2
81115d20:	1009883a 	mov	r4,r2
81115d24:	11078d00 	call	811078d0 <bRmapSetIrqControl>
81115d28:	00000706 	br	81115d48 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
81115d2c:	d0a06217 	ldw	r2,-32376(gp)
81115d30:	e0fffd0b 	ldhu	r3,-12(fp)
81115d34:	180d883a 	mov	r6,r3
81115d38:	01604574 	movhi	r5,33045
81115d3c:	29780a04 	addi	r5,r5,-8152
81115d40:	1009883a 	mov	r4,r2
81115d44:	11213440 	call	81121344 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81115d48:	d0e06217 	ldw	r3,-32376(gp)
81115d4c:	e0bfff17 	ldw	r2,-4(fp)
81115d50:	10800b0b 	ldhu	r2,44(r2)
81115d54:	113fffcc 	andi	r4,r2,65535
81115d58:	e0bfff17 	ldw	r2,-4(fp)
81115d5c:	1080098b 	ldhu	r2,38(r2)
81115d60:	10bfffcc 	andi	r2,r2,65535
81115d64:	100f883a 	mov	r7,r2
81115d68:	200d883a 	mov	r6,r4
81115d6c:	01604574 	movhi	r5,33045
81115d70:	2977c004 	addi	r5,r5,-8448
81115d74:	1809883a 	mov	r4,r3
81115d78:	11213440 	call	81121344 <fprintf>
			#endif
			break;
81115d7c:	00000906 	br	81115da4 <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81115d80:	d0a06217 	ldw	r2,-32376(gp)
81115d84:	100f883a 	mov	r7,r2
81115d88:	01800c84 	movi	r6,50
81115d8c:	01400044 	movi	r5,1
81115d90:	01204574 	movhi	r4,33045
81115d94:	2137dd04 	addi	r4,r4,-8332
81115d98:	11219e00 	call	811219e0 <fwrite>
			#endif
			break;
81115d9c:	00000106 	br	81115da4 <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81115da0:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81115da4:	0001883a 	nop
81115da8:	e037883a 	mov	sp,fp
81115dac:	dfc00117 	ldw	ra,4(sp)
81115db0:	df000017 	ldw	fp,0(sp)
81115db4:	dec00204 	addi	sp,sp,8
81115db8:	f800283a 	ret

81115dbc <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115dbc:	defff904 	addi	sp,sp,-28
81115dc0:	de00012e 	bgeu	sp,et,81115dc8 <vSendCmdQToNFeeCTRL+0xc>
81115dc4:	003b68fa 	trap	3
81115dc8:	dfc00615 	stw	ra,24(sp)
81115dcc:	df000515 	stw	fp,20(sp)
81115dd0:	df000504 	addi	fp,sp,20
81115dd4:	2807883a 	mov	r3,r5
81115dd8:	3005883a 	mov	r2,r6
81115ddc:	e13ffd05 	stb	r4,-12(fp)
81115de0:	e0fffe05 	stb	r3,-8(fp)
81115de4:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81115de8:	00800404 	movi	r2,16
81115dec:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115df0:	e0bffd03 	ldbu	r2,-12(fp)
81115df4:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115df8:	e0bffe03 	ldbu	r2,-8(fp)
81115dfc:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115e00:	e0bfff03 	ldbu	r2,-4(fp)
81115e04:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81115e08:	d0a07017 	ldw	r2,-32320(gp)
81115e0c:	e0fffc17 	ldw	r3,-16(fp)
81115e10:	180b883a 	mov	r5,r3
81115e14:	1009883a 	mov	r4,r2
81115e18:	113dd8c0 	call	8113dd8c <OSQPost>
81115e1c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115e20:	e0bffb03 	ldbu	r2,-20(fp)
81115e24:	10000126 	beq	r2,zero,81115e2c <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81115e28:	111d3580 	call	8111d358 <vFailSendMsgFeeCTRL>
	}
}
81115e2c:	0001883a 	nop
81115e30:	e037883a 	mov	sp,fp
81115e34:	dfc00117 	ldw	ra,4(sp)
81115e38:	df000017 	ldw	fp,0(sp)
81115e3c:	dec00204 	addi	sp,sp,8
81115e40:	f800283a 	ret

81115e44 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115e44:	defff904 	addi	sp,sp,-28
81115e48:	de00012e 	bgeu	sp,et,81115e50 <vSendCmdQToNFeeCTRL_PRIO+0xc>
81115e4c:	003b68fa 	trap	3
81115e50:	dfc00615 	stw	ra,24(sp)
81115e54:	df000515 	stw	fp,20(sp)
81115e58:	df000504 	addi	fp,sp,20
81115e5c:	2807883a 	mov	r3,r5
81115e60:	3005883a 	mov	r2,r6
81115e64:	e13ffd05 	stb	r4,-12(fp)
81115e68:	e0fffe05 	stb	r3,-8(fp)
81115e6c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81115e70:	00800404 	movi	r2,16
81115e74:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115e78:	e0bffd03 	ldbu	r2,-12(fp)
81115e7c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115e80:	e0bffe03 	ldbu	r2,-8(fp)
81115e84:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115e88:	e0bfff03 	ldbu	r2,-4(fp)
81115e8c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81115e90:	d0a07017 	ldw	r2,-32320(gp)
81115e94:	e0fffc17 	ldw	r3,-16(fp)
81115e98:	180b883a 	mov	r5,r3
81115e9c:	1009883a 	mov	r4,r2
81115ea0:	113defc0 	call	8113defc <OSQPostFront>
81115ea4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115ea8:	e0bffb03 	ldbu	r2,-20(fp)
81115eac:	10000126 	beq	r2,zero,81115eb4 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81115eb0:	111d3580 	call	8111d358 <vFailSendMsgFeeCTRL>
	}
}
81115eb4:	0001883a 	nop
81115eb8:	e037883a 	mov	sp,fp
81115ebc:	dfc00117 	ldw	ra,4(sp)
81115ec0:	df000017 	ldw	fp,0(sp)
81115ec4:	dec00204 	addi	sp,sp,8
81115ec8:	f800283a 	ret

81115ecc <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115ecc:	defff804 	addi	sp,sp,-32
81115ed0:	de00012e 	bgeu	sp,et,81115ed8 <vSendCmdQToNFeeCTRL_GEN+0xc>
81115ed4:	003b68fa 	trap	3
81115ed8:	dfc00715 	stw	ra,28(sp)
81115edc:	df000615 	stw	fp,24(sp)
81115ee0:	df000604 	addi	fp,sp,24
81115ee4:	2011883a 	mov	r8,r4
81115ee8:	2809883a 	mov	r4,r5
81115eec:	3007883a 	mov	r3,r6
81115ef0:	3805883a 	mov	r2,r7
81115ef4:	e23ffc05 	stb	r8,-16(fp)
81115ef8:	e13ffd05 	stb	r4,-12(fp)
81115efc:	e0fffe05 	stb	r3,-8(fp)
81115f00:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81115f04:	e0bffc03 	ldbu	r2,-16(fp)
81115f08:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115f0c:	e0bffd03 	ldbu	r2,-12(fp)
81115f10:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115f14:	e0bffe03 	ldbu	r2,-8(fp)
81115f18:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115f1c:	e0bfff03 	ldbu	r2,-4(fp)
81115f20:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81115f24:	d0a07017 	ldw	r2,-32320(gp)
81115f28:	e0fffb17 	ldw	r3,-20(fp)
81115f2c:	180b883a 	mov	r5,r3
81115f30:	1009883a 	mov	r4,r2
81115f34:	113dd8c0 	call	8113dd8c <OSQPost>
81115f38:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115f3c:	e0bffa03 	ldbu	r2,-24(fp)
81115f40:	10000126 	beq	r2,zero,81115f48 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81115f44:	111d3580 	call	8111d358 <vFailSendMsgFeeCTRL>
	}
}
81115f48:	0001883a 	nop
81115f4c:	e037883a 	mov	sp,fp
81115f50:	dfc00117 	ldw	ra,4(sp)
81115f54:	df000017 	ldw	fp,0(sp)
81115f58:	dec00204 	addi	sp,sp,8
81115f5c:	f800283a 	ret

81115f60 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115f60:	defff904 	addi	sp,sp,-28
81115f64:	de00012e 	bgeu	sp,et,81115f6c <vSendCmdQToDataCTRL+0xc>
81115f68:	003b68fa 	trap	3
81115f6c:	dfc00615 	stw	ra,24(sp)
81115f70:	df000515 	stw	fp,20(sp)
81115f74:	df000504 	addi	fp,sp,20
81115f78:	2807883a 	mov	r3,r5
81115f7c:	3005883a 	mov	r2,r6
81115f80:	e13ffd05 	stb	r4,-12(fp)
81115f84:	e0fffe05 	stb	r3,-8(fp)
81115f88:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81115f8c:	00800804 	movi	r2,32
81115f90:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115f94:	e0bffd03 	ldbu	r2,-12(fp)
81115f98:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115f9c:	e0bffe03 	ldbu	r2,-8(fp)
81115fa0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115fa4:	e0bfff03 	ldbu	r2,-4(fp)
81115fa8:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81115fac:	d0a05f17 	ldw	r2,-32388(gp)
81115fb0:	e0fffc17 	ldw	r3,-16(fp)
81115fb4:	180b883a 	mov	r5,r3
81115fb8:	1009883a 	mov	r4,r2
81115fbc:	113dd8c0 	call	8113dd8c <OSQPost>
81115fc0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115fc4:	e0bffb03 	ldbu	r2,-20(fp)
81115fc8:	10000126 	beq	r2,zero,81115fd0 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81115fcc:	111d3a40 	call	8111d3a4 <vFailSendMsgDataCTRL>
	}
}
81115fd0:	0001883a 	nop
81115fd4:	e037883a 	mov	sp,fp
81115fd8:	dfc00117 	ldw	ra,4(sp)
81115fdc:	df000017 	ldw	fp,0(sp)
81115fe0:	dec00204 	addi	sp,sp,8
81115fe4:	f800283a 	ret

81115fe8 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115fe8:	defff904 	addi	sp,sp,-28
81115fec:	de00012e 	bgeu	sp,et,81115ff4 <vSendCmdQToDataCTRL_PRIO+0xc>
81115ff0:	003b68fa 	trap	3
81115ff4:	dfc00615 	stw	ra,24(sp)
81115ff8:	df000515 	stw	fp,20(sp)
81115ffc:	df000504 	addi	fp,sp,20
81116000:	2807883a 	mov	r3,r5
81116004:	3005883a 	mov	r2,r6
81116008:	e13ffd05 	stb	r4,-12(fp)
8111600c:	e0fffe05 	stb	r3,-8(fp)
81116010:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81116014:	00800404 	movi	r2,16
81116018:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111601c:	e0bffd03 	ldbu	r2,-12(fp)
81116020:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81116024:	e0bffe03 	ldbu	r2,-8(fp)
81116028:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111602c:	e0bfff03 	ldbu	r2,-4(fp)
81116030:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81116034:	d0a05f17 	ldw	r2,-32388(gp)
81116038:	e0fffc17 	ldw	r3,-16(fp)
8111603c:	180b883a 	mov	r5,r3
81116040:	1009883a 	mov	r4,r2
81116044:	113defc0 	call	8113defc <OSQPostFront>
81116048:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111604c:	e0bffb03 	ldbu	r2,-20(fp)
81116050:	10000126 	beq	r2,zero,81116058 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81116054:	111d3580 	call	8111d358 <vFailSendMsgFeeCTRL>
	}
}
81116058:	0001883a 	nop
8111605c:	e037883a 	mov	sp,fp
81116060:	dfc00117 	ldw	ra,4(sp)
81116064:	df000017 	ldw	fp,0(sp)
81116068:	dec00204 	addi	sp,sp,8
8111606c:	f800283a 	ret

81116070 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81116070:	defffc04 	addi	sp,sp,-16
81116074:	de00012e 	bgeu	sp,et,8111607c <vMebInit+0xc>
81116078:	003b68fa 	trap	3
8111607c:	dfc00315 	stw	ra,12(sp)
81116080:	df000215 	stw	fp,8(sp)
81116084:	df000204 	addi	fp,sp,8
81116088:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
8111608c:	e0bfff17 	ldw	r2,-4(fp)
81116090:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
81116094:	e0bfff17 	ldw	r2,-4(fp)
81116098:	00c00044 	movi	r3,1
8111609c:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
811160a0:	d0a06917 	ldw	r2,-32348(gp)
811160a4:	1009883a 	mov	r4,r2
811160a8:	113d8c40 	call	8113d8c4 <OSQFlush>
811160ac:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
811160b0:	e0bffe03 	ldbu	r2,-8(fp)
811160b4:	10000126 	beq	r2,zero,811160bc <vMebInit+0x4c>
		vFailFlushMEBQueue();
811160b8:	111d4880 	call	8111d488 <vFailFlushMEBQueue>
	}
}
811160bc:	0001883a 	nop
811160c0:	e037883a 	mov	sp,fp
811160c4:	dfc00117 	ldw	ra,4(sp)
811160c8:	df000017 	ldw	fp,0(sp)
811160cc:	dec00204 	addi	sp,sp,8
811160d0:	f800283a 	ret

811160d4 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
811160d4:	defffe04 	addi	sp,sp,-8
811160d8:	de00012e 	bgeu	sp,et,811160e0 <vSwapMemmory+0xc>
811160dc:	003b68fa 	trap	3
811160e0:	df000115 	stw	fp,4(sp)
811160e4:	df000104 	addi	fp,sp,4
811160e8:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
811160ec:	e0bfff17 	ldw	r2,-4(fp)
811160f0:	10800203 	ldbu	r2,8(r2)
811160f4:	10803fcc 	andi	r2,r2,255
811160f8:	10c00044 	addi	r3,r2,1
811160fc:	00a00034 	movhi	r2,32768
81116100:	10800044 	addi	r2,r2,1
81116104:	1884703a 	and	r2,r3,r2
81116108:	1000040e 	bge	r2,zero,8111611c <vSwapMemmory+0x48>
8111610c:	10bfffc4 	addi	r2,r2,-1
81116110:	00ffff84 	movi	r3,-2
81116114:	10c4b03a 	or	r2,r2,r3
81116118:	10800044 	addi	r2,r2,1
8111611c:	1007883a 	mov	r3,r2
81116120:	e0bfff17 	ldw	r2,-4(fp)
81116124:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81116128:	e0bfff17 	ldw	r2,-4(fp)
8111612c:	10800243 	ldbu	r2,9(r2)
81116130:	10803fcc 	andi	r2,r2,255
81116134:	10c00044 	addi	r3,r2,1
81116138:	00a00034 	movhi	r2,32768
8111613c:	10800044 	addi	r2,r2,1
81116140:	1884703a 	and	r2,r3,r2
81116144:	1000040e 	bge	r2,zero,81116158 <vSwapMemmory+0x84>
81116148:	10bfffc4 	addi	r2,r2,-1
8111614c:	00ffff84 	movi	r3,-2
81116150:	10c4b03a 	or	r2,r2,r3
81116154:	10800044 	addi	r2,r2,1
81116158:	1007883a 	mov	r3,r2
8111615c:	e0bfff17 	ldw	r2,-4(fp)
81116160:	10c00245 	stb	r3,9(r2)

}
81116164:	0001883a 	nop
81116168:	e037883a 	mov	sp,fp
8111616c:	df000017 	ldw	fp,0(sp)
81116170:	dec00104 	addi	sp,sp,4
81116174:	f800283a 	ret

81116178 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81116178:	defffc04 	addi	sp,sp,-16
8111617c:	de00012e 	bgeu	sp,et,81116184 <vReleaseSyncMessages+0xc>
81116180:	003b68fa 	trap	3
81116184:	dfc00315 	stw	ra,12(sp)
81116188:	df000215 	stw	fp,8(sp)
8111618c:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81116190:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
81116194:	00bff844 	movi	r2,-31
81116198:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8111619c:	e03ffe05 	stb	zero,-8(fp)
811161a0:	00001606 	br	811161fc <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
811161a4:	e0bffe03 	ldbu	r2,-8(fp)
811161a8:	10800444 	addi	r2,r2,17
811161ac:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
811161b0:	e0bffe03 	ldbu	r2,-8(fp)
811161b4:	1085883a 	add	r2,r2,r2
811161b8:	1087883a 	add	r3,r2,r2
811161bc:	d0a05c04 	addi	r2,gp,-32400
811161c0:	1885883a 	add	r2,r3,r2
811161c4:	10800017 	ldw	r2,0(r2)
811161c8:	e0ffff17 	ldw	r3,-4(fp)
811161cc:	180b883a 	mov	r5,r3
811161d0:	1009883a 	mov	r4,r2
811161d4:	113dd8c0 	call	8113dd8c <OSQPost>
811161d8:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
811161dc:	e0bffe43 	ldbu	r2,-7(fp)
811161e0:	10000326 	beq	r2,zero,811161f0 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
811161e4:	e0bffe03 	ldbu	r2,-8(fp)
811161e8:	1009883a 	mov	r4,r2
811161ec:	111d2640 	call	8111d264 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811161f0:	e0bffe03 	ldbu	r2,-8(fp)
811161f4:	10800044 	addi	r2,r2,1
811161f8:	e0bffe05 	stb	r2,-8(fp)
811161fc:	e0bffe03 	ldbu	r2,-8(fp)
81116200:	103fe826 	beq	r2,zero,811161a4 <__reset+0xfb0f61a4>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81116204:	0001883a 	nop
81116208:	e037883a 	mov	sp,fp
8111620c:	dfc00117 	ldw	ra,4(sp)
81116210:	df000017 	ldw	fp,0(sp)
81116214:	dec00204 	addi	sp,sp,8
81116218:	f800283a 	ret

8111621c <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
8111621c:	defff804 	addi	sp,sp,-32
81116220:	de00012e 	bgeu	sp,et,81116228 <vStackMonitor+0xc>
81116224:	003b68fa 	trap	3
81116228:	dfc00715 	stw	ra,28(sp)
8111622c:	df000615 	stw	fp,24(sp)
81116230:	df000604 	addi	fp,sp,24
81116234:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81116238:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
8111623c:	d0a06217 	ldw	r2,-32376(gp)
81116240:	100f883a 	mov	r7,r2
81116244:	018006c4 	movi	r6,27
81116248:	01400044 	movi	r5,1
8111624c:	01204574 	movhi	r4,33045
81116250:	21381d04 	addi	r4,r4,-8076
81116254:	11219e00 	call	811219e0 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81116258:	d0a06217 	ldw	r2,-32376(gp)
8111625c:	100f883a 	mov	r7,r2
81116260:	01800b04 	movi	r6,44
81116264:	01400044 	movi	r5,1
81116268:	01204574 	movhi	r4,33045
8111626c:	21382404 	addi	r4,r4,-8048
81116270:	11219e00 	call	811219e0 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81116274:	d0a06217 	ldw	r2,-32376(gp)
81116278:	100f883a 	mov	r7,r2
8111627c:	01800f84 	movi	r6,62
81116280:	01400044 	movi	r5,1
81116284:	01204574 	movhi	r4,33045
81116288:	21383004 	addi	r4,r4,-8000
8111628c:	11219e00 	call	811219e0 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81116290:	e0bffd04 	addi	r2,fp,-12
81116294:	100b883a 	mov	r5,r2
81116298:	01000804 	movi	r4,32
8111629c:	11401b00 	call	811401b0 <OSTaskStkChk>
811162a0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
811162a4:	e0bffc03 	ldbu	r2,-16(fp)
811162a8:	10000f1e 	bne	r2,zero,811162e8 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811162ac:	d1206217 	ldw	r4,-32376(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
811162b0:	e0fffd17 	ldw	r3,-12(fp)
811162b4:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811162b8:	188b883a 	add	r5,r3,r2
811162bc:	e0bffd17 	ldw	r2,-12(fp)
811162c0:	e0fffe17 	ldw	r3,-8(fp)
811162c4:	d8c00115 	stw	r3,4(sp)
811162c8:	d8800015 	stw	r2,0(sp)
811162cc:	280f883a 	mov	r7,r5
811162d0:	01a04574 	movhi	r6,33045
811162d4:	31b84004 	addi	r6,r6,-7936
811162d8:	01604574 	movhi	r5,33045
811162dc:	29784404 	addi	r5,r5,-7920
811162e0:	11213440 	call	81121344 <fprintf>
811162e4:	00000706 	br	81116304 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
811162e8:	d0a06217 	ldw	r2,-32376(gp)
811162ec:	100f883a 	mov	r7,r2
811162f0:	01800904 	movi	r6,36
811162f4:	01400044 	movi	r5,1
811162f8:	01204574 	movhi	r4,33045
811162fc:	21385304 	addi	r4,r4,-7860
81116300:	11219e00 	call	811219e0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81116304:	e0bffd04 	addi	r2,fp,-12
81116308:	100b883a 	mov	r5,r2
8111630c:	01000784 	movi	r4,30
81116310:	11401b00 	call	811401b0 <OSTaskStkChk>
81116314:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116318:	e0bffc03 	ldbu	r2,-16(fp)
8111631c:	10000f1e 	bne	r2,zero,8111635c <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116320:	d1206217 	ldw	r4,-32376(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81116324:	e0fffd17 	ldw	r3,-12(fp)
81116328:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111632c:	188b883a 	add	r5,r3,r2
81116330:	e0bffd17 	ldw	r2,-12(fp)
81116334:	e0fffe17 	ldw	r3,-8(fp)
81116338:	d8c00115 	stw	r3,4(sp)
8111633c:	d8800015 	stw	r2,0(sp)
81116340:	280f883a 	mov	r7,r5
81116344:	01a04574 	movhi	r6,33045
81116348:	31b85d04 	addi	r6,r6,-7820
8111634c:	01604574 	movhi	r5,33045
81116350:	29784404 	addi	r5,r5,-7920
81116354:	11213440 	call	81121344 <fprintf>
81116358:	00000706 	br	81116378 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
8111635c:	d0a06217 	ldw	r2,-32376(gp)
81116360:	100f883a 	mov	r7,r2
81116364:	01800984 	movi	r6,38
81116368:	01400044 	movi	r5,1
8111636c:	01204574 	movhi	r4,33045
81116370:	21386104 	addi	r4,r4,-7804
81116374:	11219e00 	call	811219e0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81116378:	e0bffd04 	addi	r2,fp,-12
8111637c:	100b883a 	mov	r5,r2
81116380:	01000704 	movi	r4,28
81116384:	11401b00 	call	811401b0 <OSTaskStkChk>
81116388:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111638c:	e0bffc03 	ldbu	r2,-16(fp)
81116390:	10000f1e 	bne	r2,zero,811163d0 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116394:	d1206217 	ldw	r4,-32376(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81116398:	e0fffd17 	ldw	r3,-12(fp)
8111639c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811163a0:	188b883a 	add	r5,r3,r2
811163a4:	e0bffd17 	ldw	r2,-12(fp)
811163a8:	e0fffe17 	ldw	r3,-8(fp)
811163ac:	d8c00115 	stw	r3,4(sp)
811163b0:	d8800015 	stw	r2,0(sp)
811163b4:	280f883a 	mov	r7,r5
811163b8:	01a04574 	movhi	r6,33045
811163bc:	31b86b04 	addi	r6,r6,-7764
811163c0:	01604574 	movhi	r5,33045
811163c4:	29784404 	addi	r5,r5,-7920
811163c8:	11213440 	call	81121344 <fprintf>
811163cc:	00000706 	br	811163ec <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
811163d0:	d0a06217 	ldw	r2,-32376(gp)
811163d4:	100f883a 	mov	r7,r2
811163d8:	01800884 	movi	r6,34
811163dc:	01400044 	movi	r5,1
811163e0:	01204574 	movhi	r4,33045
811163e4:	21386e04 	addi	r4,r4,-7752
811163e8:	11219e00 	call	811219e0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
811163ec:	e0bffd04 	addi	r2,fp,-12
811163f0:	100b883a 	mov	r5,r2
811163f4:	010006c4 	movi	r4,27
811163f8:	11401b00 	call	811401b0 <OSTaskStkChk>
811163fc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116400:	e0bffc03 	ldbu	r2,-16(fp)
81116404:	10000f1e 	bne	r2,zero,81116444 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116408:	d1206217 	ldw	r4,-32376(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
8111640c:	e0fffd17 	ldw	r3,-12(fp)
81116410:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116414:	188b883a 	add	r5,r3,r2
81116418:	e0bffd17 	ldw	r2,-12(fp)
8111641c:	e0fffe17 	ldw	r3,-8(fp)
81116420:	d8c00115 	stw	r3,4(sp)
81116424:	d8800015 	stw	r2,0(sp)
81116428:	280f883a 	mov	r7,r5
8111642c:	01a04574 	movhi	r6,33045
81116430:	31b87704 	addi	r6,r6,-7716
81116434:	01604574 	movhi	r5,33045
81116438:	29784404 	addi	r5,r5,-7920
8111643c:	11213440 	call	81121344 <fprintf>
81116440:	00000706 	br	81116460 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81116444:	d0a06217 	ldw	r2,-32376(gp)
81116448:	100f883a 	mov	r7,r2
8111644c:	018008c4 	movi	r6,35
81116450:	01400044 	movi	r5,1
81116454:	01204574 	movhi	r4,33045
81116458:	21387b04 	addi	r4,r4,-7700
8111645c:	11219e00 	call	811219e0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81116460:	e0bffd04 	addi	r2,fp,-12
81116464:	100b883a 	mov	r5,r2
81116468:	01000684 	movi	r4,26
8111646c:	11401b00 	call	811401b0 <OSTaskStkChk>
81116470:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116474:	e0bffc03 	ldbu	r2,-16(fp)
81116478:	10000f1e 	bne	r2,zero,811164b8 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111647c:	d1206217 	ldw	r4,-32376(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81116480:	e0fffd17 	ldw	r3,-12(fp)
81116484:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116488:	188b883a 	add	r5,r3,r2
8111648c:	e0bffd17 	ldw	r2,-12(fp)
81116490:	e0fffe17 	ldw	r3,-8(fp)
81116494:	d8c00115 	stw	r3,4(sp)
81116498:	d8800015 	stw	r2,0(sp)
8111649c:	280f883a 	mov	r7,r5
811164a0:	01a04574 	movhi	r6,33045
811164a4:	31b88404 	addi	r6,r6,-7664
811164a8:	01604574 	movhi	r5,33045
811164ac:	29784404 	addi	r5,r5,-7920
811164b0:	11213440 	call	81121344 <fprintf>
811164b4:	00000706 	br	811164d4 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
811164b8:	d0a06217 	ldw	r2,-32376(gp)
811164bc:	100f883a 	mov	r7,r2
811164c0:	01800884 	movi	r6,34
811164c4:	01400044 	movi	r5,1
811164c8:	01204574 	movhi	r4,33045
811164cc:	21388704 	addi	r4,r4,-7652
811164d0:	11219e00 	call	811219e0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
811164d4:	e0bffd04 	addi	r2,fp,-12
811164d8:	100b883a 	mov	r5,r2
811164dc:	01000644 	movi	r4,25
811164e0:	11401b00 	call	811401b0 <OSTaskStkChk>
811164e4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811164e8:	e0bffc03 	ldbu	r2,-16(fp)
811164ec:	10000f1e 	bne	r2,zero,8111652c <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811164f0:	d1206217 	ldw	r4,-32376(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
811164f4:	e0fffd17 	ldw	r3,-12(fp)
811164f8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811164fc:	188b883a 	add	r5,r3,r2
81116500:	e0bffd17 	ldw	r2,-12(fp)
81116504:	e0fffe17 	ldw	r3,-8(fp)
81116508:	d8c00115 	stw	r3,4(sp)
8111650c:	d8800015 	stw	r2,0(sp)
81116510:	280f883a 	mov	r7,r5
81116514:	01a04574 	movhi	r6,33045
81116518:	31b89004 	addi	r6,r6,-7616
8111651c:	01604574 	movhi	r5,33045
81116520:	29784404 	addi	r5,r5,-7920
81116524:	11213440 	call	81121344 <fprintf>
81116528:	00000706 	br	81116548 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
8111652c:	d0a06217 	ldw	r2,-32376(gp)
81116530:	100f883a 	mov	r7,r2
81116534:	01800884 	movi	r6,34
81116538:	01400044 	movi	r5,1
8111653c:	01204574 	movhi	r4,33045
81116540:	21389304 	addi	r4,r4,-7604
81116544:	11219e00 	call	811219e0 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81116548:	e0bffd04 	addi	r2,fp,-12
8111654c:	100b883a 	mov	r5,r2
81116550:	01000044 	movi	r4,1
81116554:	11401b00 	call	811401b0 <OSTaskStkChk>
81116558:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111655c:	e0bffc03 	ldbu	r2,-16(fp)
81116560:	10000f1e 	bne	r2,zero,811165a0 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116564:	d1206217 	ldw	r4,-32376(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81116568:	e0fffd17 	ldw	r3,-12(fp)
8111656c:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116570:	188b883a 	add	r5,r3,r2
81116574:	e0bffd17 	ldw	r2,-12(fp)
81116578:	e0fffe17 	ldw	r3,-8(fp)
8111657c:	d8c00115 	stw	r3,4(sp)
81116580:	d8800015 	stw	r2,0(sp)
81116584:	280f883a 	mov	r7,r5
81116588:	01a04574 	movhi	r6,33045
8111658c:	31b89c04 	addi	r6,r6,-7568
81116590:	01604574 	movhi	r5,33045
81116594:	29784404 	addi	r5,r5,-7920
81116598:	11213440 	call	81121344 <fprintf>
8111659c:	00000706 	br	811165bc <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
811165a0:	d0a06217 	ldw	r2,-32376(gp)
811165a4:	100f883a 	mov	r7,r2
811165a8:	01800804 	movi	r6,32
811165ac:	01400044 	movi	r5,1
811165b0:	01204574 	movhi	r4,33045
811165b4:	21389f04 	addi	r4,r4,-7556
811165b8:	11219e00 	call	811219e0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
811165bc:	e0bffd04 	addi	r2,fp,-12
811165c0:	100b883a 	mov	r5,r2
811165c4:	010002c4 	movi	r4,11
811165c8:	11401b00 	call	811401b0 <OSTaskStkChk>
811165cc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811165d0:	e0bffc03 	ldbu	r2,-16(fp)
811165d4:	10000f1e 	bne	r2,zero,81116614 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811165d8:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
811165dc:	e0fffd17 	ldw	r3,-12(fp)
811165e0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811165e4:	188b883a 	add	r5,r3,r2
811165e8:	e0bffd17 	ldw	r2,-12(fp)
811165ec:	e0fffe17 	ldw	r3,-8(fp)
811165f0:	d8c00115 	stw	r3,4(sp)
811165f4:	d8800015 	stw	r2,0(sp)
811165f8:	280f883a 	mov	r7,r5
811165fc:	01a04574 	movhi	r6,33045
81116600:	31b8a804 	addi	r6,r6,-7520
81116604:	01604574 	movhi	r5,33045
81116608:	29784404 	addi	r5,r5,-7920
8111660c:	11213440 	call	81121344 <fprintf>
81116610:	00000706 	br	81116630 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81116614:	d0a06217 	ldw	r2,-32376(gp)
81116618:	100f883a 	mov	r7,r2
8111661c:	018008c4 	movi	r6,35
81116620:	01400044 	movi	r5,1
81116624:	01204574 	movhi	r4,33045
81116628:	2138ab04 	addi	r4,r4,-7508
8111662c:	11219e00 	call	811219e0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81116630:	e0bffd04 	addi	r2,fp,-12
81116634:	100b883a 	mov	r5,r2
81116638:	01000304 	movi	r4,12
8111663c:	11401b00 	call	811401b0 <OSTaskStkChk>
81116640:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116644:	e0bffc03 	ldbu	r2,-16(fp)
81116648:	10000f1e 	bne	r2,zero,81116688 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111664c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81116650:	e0fffd17 	ldw	r3,-12(fp)
81116654:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116658:	188b883a 	add	r5,r3,r2
8111665c:	e0bffd17 	ldw	r2,-12(fp)
81116660:	e0fffe17 	ldw	r3,-8(fp)
81116664:	d8c00115 	stw	r3,4(sp)
81116668:	d8800015 	stw	r2,0(sp)
8111666c:	280f883a 	mov	r7,r5
81116670:	01a04574 	movhi	r6,33045
81116674:	31b8b404 	addi	r6,r6,-7472
81116678:	01604574 	movhi	r5,33045
8111667c:	29784404 	addi	r5,r5,-7920
81116680:	11213440 	call	81121344 <fprintf>
81116684:	00000706 	br	811166a4 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81116688:	d0a06217 	ldw	r2,-32376(gp)
8111668c:	100f883a 	mov	r7,r2
81116690:	018008c4 	movi	r6,35
81116694:	01400044 	movi	r5,1
81116698:	01204574 	movhi	r4,33045
8111669c:	2138b704 	addi	r4,r4,-7460
811166a0:	11219e00 	call	811219e0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
811166a4:	e0bffd04 	addi	r2,fp,-12
811166a8:	100b883a 	mov	r5,r2
811166ac:	01000344 	movi	r4,13
811166b0:	11401b00 	call	811401b0 <OSTaskStkChk>
811166b4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811166b8:	e0bffc03 	ldbu	r2,-16(fp)
811166bc:	10000f1e 	bne	r2,zero,811166fc <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811166c0:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
811166c4:	e0fffd17 	ldw	r3,-12(fp)
811166c8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811166cc:	188b883a 	add	r5,r3,r2
811166d0:	e0bffd17 	ldw	r2,-12(fp)
811166d4:	e0fffe17 	ldw	r3,-8(fp)
811166d8:	d8c00115 	stw	r3,4(sp)
811166dc:	d8800015 	stw	r2,0(sp)
811166e0:	280f883a 	mov	r7,r5
811166e4:	01a04574 	movhi	r6,33045
811166e8:	31b8c004 	addi	r6,r6,-7424
811166ec:	01604574 	movhi	r5,33045
811166f0:	29784404 	addi	r5,r5,-7920
811166f4:	11213440 	call	81121344 <fprintf>
811166f8:	00000706 	br	81116718 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
811166fc:	d0a06217 	ldw	r2,-32376(gp)
81116700:	100f883a 	mov	r7,r2
81116704:	018008c4 	movi	r6,35
81116708:	01400044 	movi	r5,1
8111670c:	01204574 	movhi	r4,33045
81116710:	2138c304 	addi	r4,r4,-7412
81116714:	11219e00 	call	811219e0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81116718:	e0bffd04 	addi	r2,fp,-12
8111671c:	100b883a 	mov	r5,r2
81116720:	01000384 	movi	r4,14
81116724:	11401b00 	call	811401b0 <OSTaskStkChk>
81116728:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111672c:	e0bffc03 	ldbu	r2,-16(fp)
81116730:	10000f1e 	bne	r2,zero,81116770 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116734:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81116738:	e0fffd17 	ldw	r3,-12(fp)
8111673c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116740:	188b883a 	add	r5,r3,r2
81116744:	e0bffd17 	ldw	r2,-12(fp)
81116748:	e0fffe17 	ldw	r3,-8(fp)
8111674c:	d8c00115 	stw	r3,4(sp)
81116750:	d8800015 	stw	r2,0(sp)
81116754:	280f883a 	mov	r7,r5
81116758:	01a04574 	movhi	r6,33045
8111675c:	31b8cc04 	addi	r6,r6,-7376
81116760:	01604574 	movhi	r5,33045
81116764:	29784404 	addi	r5,r5,-7920
81116768:	11213440 	call	81121344 <fprintf>
8111676c:	00000706 	br	8111678c <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81116770:	d0a06217 	ldw	r2,-32376(gp)
81116774:	100f883a 	mov	r7,r2
81116778:	018008c4 	movi	r6,35
8111677c:	01400044 	movi	r5,1
81116780:	01204574 	movhi	r4,33045
81116784:	2138cf04 	addi	r4,r4,-7364
81116788:	11219e00 	call	811219e0 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
8111678c:	e0bffd04 	addi	r2,fp,-12
81116790:	100b883a 	mov	r5,r2
81116794:	010003c4 	movi	r4,15
81116798:	11401b00 	call	811401b0 <OSTaskStkChk>
8111679c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811167a0:	e0bffc03 	ldbu	r2,-16(fp)
811167a4:	10000f1e 	bne	r2,zero,811167e4 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811167a8:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
811167ac:	e0fffd17 	ldw	r3,-12(fp)
811167b0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811167b4:	188b883a 	add	r5,r3,r2
811167b8:	e0bffd17 	ldw	r2,-12(fp)
811167bc:	e0fffe17 	ldw	r3,-8(fp)
811167c0:	d8c00115 	stw	r3,4(sp)
811167c4:	d8800015 	stw	r2,0(sp)
811167c8:	280f883a 	mov	r7,r5
811167cc:	01a04574 	movhi	r6,33045
811167d0:	31b8d804 	addi	r6,r6,-7328
811167d4:	01604574 	movhi	r5,33045
811167d8:	29784404 	addi	r5,r5,-7920
811167dc:	11213440 	call	81121344 <fprintf>
811167e0:	00000706 	br	81116800 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
811167e4:	d0a06217 	ldw	r2,-32376(gp)
811167e8:	100f883a 	mov	r7,r2
811167ec:	018008c4 	movi	r6,35
811167f0:	01400044 	movi	r5,1
811167f4:	01204574 	movhi	r4,33045
811167f8:	2138db04 	addi	r4,r4,-7316
811167fc:	11219e00 	call	811219e0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81116800:	e0bffd04 	addi	r2,fp,-12
81116804:	100b883a 	mov	r5,r2
81116808:	01000404 	movi	r4,16
8111680c:	11401b00 	call	811401b0 <OSTaskStkChk>
81116810:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116814:	e0bffc03 	ldbu	r2,-16(fp)
81116818:	10000f1e 	bne	r2,zero,81116858 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111681c:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81116820:	e0fffd17 	ldw	r3,-12(fp)
81116824:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116828:	188b883a 	add	r5,r3,r2
8111682c:	e0bffd17 	ldw	r2,-12(fp)
81116830:	e0fffe17 	ldw	r3,-8(fp)
81116834:	d8c00115 	stw	r3,4(sp)
81116838:	d8800015 	stw	r2,0(sp)
8111683c:	280f883a 	mov	r7,r5
81116840:	01a04574 	movhi	r6,33045
81116844:	31b8e404 	addi	r6,r6,-7280
81116848:	01604574 	movhi	r5,33045
8111684c:	29784404 	addi	r5,r5,-7920
81116850:	11213440 	call	81121344 <fprintf>
81116854:	00000706 	br	81116874 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81116858:	d0a06217 	ldw	r2,-32376(gp)
8111685c:	100f883a 	mov	r7,r2
81116860:	018008c4 	movi	r6,35
81116864:	01400044 	movi	r5,1
81116868:	01204574 	movhi	r4,33045
8111686c:	2138e704 	addi	r4,r4,-7268
81116870:	11219e00 	call	811219e0 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
81116874:	e0bffd04 	addi	r2,fp,-12
81116878:	100b883a 	mov	r5,r2
8111687c:	01000284 	movi	r4,10
81116880:	11401b00 	call	811401b0 <OSTaskStkChk>
81116884:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116888:	e0bffc03 	ldbu	r2,-16(fp)
8111688c:	10000f1e 	bne	r2,zero,811168cc <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116890:	d1206217 	ldw	r4,-32376(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
81116894:	e0fffd17 	ldw	r3,-12(fp)
81116898:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111689c:	188b883a 	add	r5,r3,r2
811168a0:	e0bffd17 	ldw	r2,-12(fp)
811168a4:	e0fffe17 	ldw	r3,-8(fp)
811168a8:	d8c00115 	stw	r3,4(sp)
811168ac:	d8800015 	stw	r2,0(sp)
811168b0:	280f883a 	mov	r7,r5
811168b4:	01a04574 	movhi	r6,33045
811168b8:	31b8f004 	addi	r6,r6,-7232
811168bc:	01604574 	movhi	r5,33045
811168c0:	29784404 	addi	r5,r5,-7920
811168c4:	11213440 	call	81121344 <fprintf>
811168c8:	00000706 	br	811168e8 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
811168cc:	d0a06217 	ldw	r2,-32376(gp)
811168d0:	100f883a 	mov	r7,r2
811168d4:	01800884 	movi	r6,34
811168d8:	01400044 	movi	r5,1
811168dc:	01204574 	movhi	r4,33045
811168e0:	2138f304 	addi	r4,r4,-7220
811168e4:	11219e00 	call	811219e0 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
811168e8:	e0bffd04 	addi	r2,fp,-12
811168ec:	100b883a 	mov	r5,r2
811168f0:	01000244 	movi	r4,9
811168f4:	11401b00 	call	811401b0 <OSTaskStkChk>
811168f8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811168fc:	e0bffc03 	ldbu	r2,-16(fp)
81116900:	10000f1e 	bne	r2,zero,81116940 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116904:	d1206217 	ldw	r4,-32376(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81116908:	e0fffd17 	ldw	r3,-12(fp)
8111690c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116910:	188b883a 	add	r5,r3,r2
81116914:	e0bffd17 	ldw	r2,-12(fp)
81116918:	e0fffe17 	ldw	r3,-8(fp)
8111691c:	d8c00115 	stw	r3,4(sp)
81116920:	d8800015 	stw	r2,0(sp)
81116924:	280f883a 	mov	r7,r5
81116928:	01a04574 	movhi	r6,33045
8111692c:	31b8fc04 	addi	r6,r6,-7184
81116930:	01604574 	movhi	r5,33045
81116934:	29784404 	addi	r5,r5,-7920
81116938:	11213440 	call	81121344 <fprintf>
8111693c:	00000706 	br	8111695c <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81116940:	d0a06217 	ldw	r2,-32376(gp)
81116944:	100f883a 	mov	r7,r2
81116948:	01800844 	movi	r6,33
8111694c:	01400044 	movi	r5,1
81116950:	01204574 	movhi	r4,33045
81116954:	2138ff04 	addi	r4,r4,-7172
81116958:	11219e00 	call	811219e0 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
8111695c:	e0bffd04 	addi	r2,fp,-12
81116960:	100b883a 	mov	r5,r2
81116964:	01000204 	movi	r4,8
81116968:	11401b00 	call	811401b0 <OSTaskStkChk>
8111696c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116970:	e0bffc03 	ldbu	r2,-16(fp)
81116974:	10000f1e 	bne	r2,zero,811169b4 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116978:	d1206217 	ldw	r4,-32376(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
8111697c:	e0fffd17 	ldw	r3,-12(fp)
81116980:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116984:	188b883a 	add	r5,r3,r2
81116988:	e0bffd17 	ldw	r2,-12(fp)
8111698c:	e0fffe17 	ldw	r3,-8(fp)
81116990:	d8c00115 	stw	r3,4(sp)
81116994:	d8800015 	stw	r2,0(sp)
81116998:	280f883a 	mov	r7,r5
8111699c:	01a04574 	movhi	r6,33045
811169a0:	31b90804 	addi	r6,r6,-7136
811169a4:	01604574 	movhi	r5,33045
811169a8:	29784404 	addi	r5,r5,-7920
811169ac:	11213440 	call	81121344 <fprintf>
811169b0:	00000706 	br	811169d0 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
811169b4:	d0a06217 	ldw	r2,-32376(gp)
811169b8:	100f883a 	mov	r7,r2
811169bc:	018007c4 	movi	r6,31
811169c0:	01400044 	movi	r5,1
811169c4:	01204574 	movhi	r4,33045
811169c8:	21390b04 	addi	r4,r4,-7124
811169cc:	11219e00 	call	811219e0 <fwrite>
    	}		


    	fprintf(fp, "\n" );
811169d0:	d0a06217 	ldw	r2,-32376(gp)
811169d4:	100b883a 	mov	r5,r2
811169d8:	01000284 	movi	r4,10
811169dc:	11213bc0 	call	811213bc <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
811169e0:	000f883a 	mov	r7,zero
811169e4:	01800284 	movi	r6,10
811169e8:	000b883a 	mov	r5,zero
811169ec:	0009883a 	mov	r4,zero
811169f0:	11408140 	call	81140814 <OSTimeDlyHMSM>
    }
811169f4:	003e1806 	br	81116258 <__reset+0xfb0f6258>

811169f8 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
811169f8:	defffc04 	addi	sp,sp,-16
811169fc:	de00012e 	bgeu	sp,et,81116a04 <vTimeoutCheckerTaskv2+0xc>
81116a00:	003b68fa 	trap	3
81116a04:	dfc00315 	stw	ra,12(sp)
81116a08:	df000215 	stw	fp,8(sp)
81116a0c:	df000204 	addi	fp,sp,8
81116a10:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81116a14:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81116a18:	d0a06217 	ldw	r2,-32376(gp)
81116a1c:	100f883a 	mov	r7,r2
81116a20:	01800844 	movi	r6,33
81116a24:	01400044 	movi	r5,1
81116a28:	01204574 	movhi	r4,33045
81116a2c:	21391304 	addi	r4,r4,-7092
81116a30:	11219e00 	call	811219e0 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81116a34:	d0a06717 	ldw	r2,-32356(gp)
81116a38:	e1bffe04 	addi	r6,fp,-8
81116a3c:	000b883a 	mov	r5,zero
81116a40:	1009883a 	mov	r4,r2
81116a44:	113e87c0 	call	8113e87c <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81116a48:	e0bffe03 	ldbu	r2,-8(fp)
81116a4c:	10803fcc 	andi	r2,r2,255
81116a50:	1000021e 	bne	r2,zero,81116a5c <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81116a54:	1116a640 	call	81116a64 <vCheck>
81116a58:	003ff606 	br	81116a34 <__reset+0xfb0f6a34>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81116a5c:	111c4240 	call	8111c424 <vFailGetBlockingSemTimeoutTask>
        }
    }
81116a60:	003ff406 	br	81116a34 <__reset+0xfb0f6a34>

81116a64 <vCheck>:
}


void vCheck( void ) {
81116a64:	defffd04 	addi	sp,sp,-12
81116a68:	de00012e 	bgeu	sp,et,81116a70 <vCheck+0xc>
81116a6c:	003b68fa 	trap	3
81116a70:	dfc00215 	stw	ra,8(sp)
81116a74:	df000115 	stw	fp,4(sp)
81116a78:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81116a7c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81116a80:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81116a84:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81116a88:	d0a06883 	ldbu	r2,-32350(gp)
81116a8c:	10803fcc 	andi	r2,r2,255
81116a90:	10800218 	cmpnei	r2,r2,8
81116a94:	1000021e 	bne	r2,zero,81116aa0 <vCheck+0x3c>
81116a98:	00c00104 	movi	r3,4
81116a9c:	00000106 	br	81116aa4 <vCheck+0x40>
81116aa0:	0007883a 	mov	r3,zero
81116aa4:	d0a07503 	ldbu	r2,-32300(gp)
81116aa8:	10803fcc 	andi	r2,r2,255
81116aac:	10800218 	cmpnei	r2,r2,8
81116ab0:	1000021e 	bne	r2,zero,81116abc <vCheck+0x58>
81116ab4:	00800084 	movi	r2,2
81116ab8:	00000106 	br	81116ac0 <vCheck+0x5c>
81116abc:	0005883a 	mov	r2,zero
81116ac0:	1884b03a 	or	r2,r3,r2
81116ac4:	1007883a 	mov	r3,r2
81116ac8:	d0a07543 	ldbu	r2,-32299(gp)
81116acc:	10803fcc 	andi	r2,r2,255
81116ad0:	108001a0 	cmpeqi	r2,r2,6
81116ad4:	1884b03a 	or	r2,r3,r2
81116ad8:	1007883a 	mov	r3,r2
81116adc:	e0bfff03 	ldbu	r2,-4(fp)
81116ae0:	1884b03a 	or	r2,r3,r2
81116ae4:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81116ae8:	e0bfff03 	ldbu	r2,-4(fp)
81116aec:	108001d8 	cmpnei	r2,r2,7
81116af0:	10003726 	beq	r2,zero,81116bd0 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81116af4:	d0a07417 	ldw	r2,-32304(gp)
81116af8:	e0ffff44 	addi	r3,fp,-3
81116afc:	180d883a 	mov	r6,r3
81116b00:	000b883a 	mov	r5,zero
81116b04:	1009883a 	mov	r4,r2
81116b08:	113c8700 	call	8113c870 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81116b0c:	e0bfff43 	ldbu	r2,-3(fp)
81116b10:	10803fcc 	andi	r2,r2,255
81116b14:	10000826 	beq	r2,zero,81116b38 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81116b18:	d0a06217 	ldw	r2,-32376(gp)
81116b1c:	100f883a 	mov	r7,r2
81116b20:	01800f04 	movi	r6,60
81116b24:	01400044 	movi	r5,1
81116b28:	01204574 	movhi	r4,33045
81116b2c:	21391c04 	addi	r4,r4,-7056
81116b30:	11219e00 	call	811219e0 <fwrite>
		#endif
        return;
81116b34:	00002706 	br	81116bd4 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81116b38:	e0bfff03 	ldbu	r2,-4(fp)
81116b3c:	1080004c 	andi	r2,r2,1
81116b40:	10803fcc 	andi	r2,r2,255
81116b44:	1000021e 	bne	r2,zero,81116b50 <vCheck+0xec>
        vCheckRetransmission128();
81116b48:	1116be80 	call	81116be8 <vCheckRetransmission128>
81116b4c:	00000506 	br	81116b64 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81116b50:	01800604 	movi	r6,24
81116b54:	000b883a 	mov	r5,zero
81116b58:	012045b4 	movhi	r4,33046
81116b5c:	213afc04 	addi	r4,r4,-5136
81116b60:	11225440 	call	81122544 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81116b64:	e0bfff03 	ldbu	r2,-4(fp)
81116b68:	1080008c 	andi	r2,r2,2
81116b6c:	10803fcc 	andi	r2,r2,255
81116b70:	1000021e 	bne	r2,zero,81116b7c <vCheck+0x118>
        vCheckRetransmission64();
81116b74:	1116e6c0 	call	81116e6c <vCheckRetransmission64>
81116b78:	00000506 	br	81116b90 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81116b7c:	01800804 	movi	r6,32
81116b80:	000b883a 	mov	r5,zero
81116b84:	012045b4 	movhi	r4,33046
81116b88:	213b0204 	addi	r4,r4,-5112
81116b8c:	11225440 	call	81122544 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81116b90:	e0bfff03 	ldbu	r2,-4(fp)
81116b94:	1080010c 	andi	r2,r2,4
81116b98:	10803fcc 	andi	r2,r2,255
81116b9c:	1000021e 	bne	r2,zero,81116ba8 <vCheck+0x144>
        vCheckRetransmission32();
81116ba0:	11170f80 	call	811170f8 <vCheckRetransmission32>
81116ba4:	00000506 	br	81116bbc <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81116ba8:	01800804 	movi	r6,32
81116bac:	000b883a 	mov	r5,zero
81116bb0:	012045b4 	movhi	r4,33046
81116bb4:	213b0a04 	addi	r4,r4,-5080
81116bb8:	11225440 	call	81122544 <memset>


    OSMutexPost(xTxUARTMutex);
81116bbc:	d0a07417 	ldw	r2,-32304(gp)
81116bc0:	1009883a 	mov	r4,r2
81116bc4:	113ce140 	call	8113ce14 <OSMutexPost>

    return;
81116bc8:	0001883a 	nop
81116bcc:	00000106 	br	81116bd4 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81116bd0:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81116bd4:	e037883a 	mov	sp,fp
81116bd8:	dfc00117 	ldw	ra,4(sp)
81116bdc:	df000017 	ldw	fp,0(sp)
81116be0:	dec00204 	addi	sp,sp,8
81116be4:	f800283a 	ret

81116be8 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81116be8:	defffd04 	addi	sp,sp,-12
81116bec:	de00012e 	bgeu	sp,et,81116bf4 <vCheckRetransmission128+0xc>
81116bf0:	003b68fa 	trap	3
81116bf4:	dfc00215 	stw	ra,8(sp)
81116bf8:	df000115 	stw	fp,4(sp)
81116bfc:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81116c00:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81116c04:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81116c08:	d0a06e17 	ldw	r2,-32328(gp)
81116c0c:	e0ffff44 	addi	r3,fp,-3
81116c10:	180b883a 	mov	r5,r3
81116c14:	1009883a 	mov	r4,r2
81116c18:	113c1f00 	call	8113c1f0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81116c1c:	e0bfff43 	ldbu	r2,-3(fp)
81116c20:	10803fcc 	andi	r2,r2,255
81116c24:	10008b1e 	bne	r2,zero,81116e54 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81116c28:	e03fff05 	stb	zero,-4(fp)
81116c2c:	00008106 	br	81116e34 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81116c30:	e0ffff03 	ldbu	r3,-4(fp)
81116c34:	00a045b4 	movhi	r2,33046
81116c38:	10bafc04 	addi	r2,r2,-5136
81116c3c:	18c7883a 	add	r3,r3,r3
81116c40:	18c7883a 	add	r3,r3,r3
81116c44:	10c5883a 	add	r2,r2,r3
81116c48:	10800017 	ldw	r2,0(r2)
81116c4c:	10800058 	cmpnei	r2,r2,1
81116c50:	1000751e 	bne	r2,zero,81116e28 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81116c54:	e0ffff03 	ldbu	r3,-4(fp)
81116c58:	00a045b4 	movhi	r2,33046
81116c5c:	10bb1a04 	addi	r2,r2,-5016
81116c60:	18c02324 	muli	r3,r3,140
81116c64:	10c5883a 	add	r2,r2,r3
81116c68:	10802004 	addi	r2,r2,128
81116c6c:	10800017 	ldw	r2,0(r2)
81116c70:	10800058 	cmpnei	r2,r2,1
81116c74:	1000211e 	bne	r2,zero,81116cfc <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81116c78:	e0ffff03 	ldbu	r3,-4(fp)
81116c7c:	00a045b4 	movhi	r2,33046
81116c80:	10bb1a04 	addi	r2,r2,-5016
81116c84:	19002324 	muli	r4,r3,140
81116c88:	1105883a 	add	r2,r2,r4
81116c8c:	10802184 	addi	r2,r2,134
81116c90:	1080000b 	ldhu	r2,0(r2)
81116c94:	10800044 	addi	r2,r2,1
81116c98:	100b883a 	mov	r5,r2
81116c9c:	00a045b4 	movhi	r2,33046
81116ca0:	10bb1a04 	addi	r2,r2,-5016
81116ca4:	19002324 	muli	r4,r3,140
81116ca8:	1105883a 	add	r2,r2,r4
81116cac:	10802184 	addi	r2,r2,134
81116cb0:	1140000d 	sth	r5,0(r2)
81116cb4:	00a045b4 	movhi	r2,33046
81116cb8:	10bb1a04 	addi	r2,r2,-5016
81116cbc:	18c02324 	muli	r3,r3,140
81116cc0:	10c5883a 	add	r2,r2,r3
81116cc4:	10802184 	addi	r2,r2,134
81116cc8:	1080000b 	ldhu	r2,0(r2)
81116ccc:	10bfffcc 	andi	r2,r2,65535
81116cd0:	10a0001c 	xori	r2,r2,32768
81116cd4:	10a00004 	addi	r2,r2,-32768
81116cd8:	10800090 	cmplti	r2,r2,2
81116cdc:	1000071e 	bne	r2,zero,81116cfc <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81116ce0:	e0ffff03 	ldbu	r3,-4(fp)
81116ce4:	00a045b4 	movhi	r2,33046
81116ce8:	10bb1a04 	addi	r2,r2,-5016
81116cec:	18c02324 	muli	r3,r3,140
81116cf0:	10c5883a 	add	r2,r2,r3
81116cf4:	10802004 	addi	r2,r2,128
81116cf8:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81116cfc:	e0ffff03 	ldbu	r3,-4(fp)
81116d00:	00a045b4 	movhi	r2,33046
81116d04:	10bb1a04 	addi	r2,r2,-5016
81116d08:	18c02324 	muli	r3,r3,140
81116d0c:	10c5883a 	add	r2,r2,r3
81116d10:	10802004 	addi	r2,r2,128
81116d14:	10800017 	ldw	r2,0(r2)
81116d18:	1000431e 	bne	r2,zero,81116e28 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81116d1c:	e0bfff03 	ldbu	r2,-4(fp)
81116d20:	10c02324 	muli	r3,r2,140
81116d24:	00a045b4 	movhi	r2,33046
81116d28:	10bb1a04 	addi	r2,r2,-5016
81116d2c:	1885883a 	add	r2,r3,r2
81116d30:	1009883a 	mov	r4,r2
81116d34:	11229900 	call	81122990 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81116d38:	e0ffff03 	ldbu	r3,-4(fp)
81116d3c:	00a045b4 	movhi	r2,33046
81116d40:	10bb1a04 	addi	r2,r2,-5016
81116d44:	18c02324 	muli	r3,r3,140
81116d48:	10c5883a 	add	r2,r2,r3
81116d4c:	10802004 	addi	r2,r2,128
81116d50:	00c00044 	movi	r3,1
81116d54:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81116d58:	e0ffff03 	ldbu	r3,-4(fp)
81116d5c:	00a045b4 	movhi	r2,33046
81116d60:	10bb1a04 	addi	r2,r2,-5016
81116d64:	18c02324 	muli	r3,r3,140
81116d68:	10c5883a 	add	r2,r2,r3
81116d6c:	10802184 	addi	r2,r2,134
81116d70:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81116d74:	e0ffff03 	ldbu	r3,-4(fp)
81116d78:	00a045b4 	movhi	r2,33046
81116d7c:	10bb1a04 	addi	r2,r2,-5016
81116d80:	19002324 	muli	r4,r3,140
81116d84:	1105883a 	add	r2,r2,r4
81116d88:	10802204 	addi	r2,r2,136
81116d8c:	10800003 	ldbu	r2,0(r2)
81116d90:	10800044 	addi	r2,r2,1
81116d94:	100b883a 	mov	r5,r2
81116d98:	00a045b4 	movhi	r2,33046
81116d9c:	10bb1a04 	addi	r2,r2,-5016
81116da0:	19002324 	muli	r4,r3,140
81116da4:	1105883a 	add	r2,r2,r4
81116da8:	10802204 	addi	r2,r2,136
81116dac:	11400005 	stb	r5,0(r2)
81116db0:	00a045b4 	movhi	r2,33046
81116db4:	10bb1a04 	addi	r2,r2,-5016
81116db8:	18c02324 	muli	r3,r3,140
81116dbc:	10c5883a 	add	r2,r2,r3
81116dc0:	10802204 	addi	r2,r2,136
81116dc4:	10800003 	ldbu	r2,0(r2)
81116dc8:	10803fcc 	andi	r2,r2,255
81116dcc:	108000b0 	cmpltui	r2,r2,2
81116dd0:	1000151e 	bne	r2,zero,81116e28 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81116dd4:	e0ffff03 	ldbu	r3,-4(fp)
81116dd8:	00a045b4 	movhi	r2,33046
81116ddc:	10bafc04 	addi	r2,r2,-5136
81116de0:	18c7883a 	add	r3,r3,r3
81116de4:	18c7883a 	add	r3,r3,r3
81116de8:	10c5883a 	add	r2,r2,r3
81116dec:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81116df0:	d0a07543 	ldbu	r2,-32299(gp)
81116df4:	10800044 	addi	r2,r2,1
81116df8:	d0a07545 	stb	r2,-32299(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81116dfc:	d0a06317 	ldw	r2,-32372(gp)
81116e00:	1009883a 	mov	r4,r2
81116e04:	113ec040 	call	8113ec04 <OSSemPost>
81116e08:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81116e0c:	e0bfff43 	ldbu	r2,-3(fp)
81116e10:	10803fcc 	andi	r2,r2,255
81116e14:	10000426 	beq	r2,zero,81116e28 <vCheckRetransmission128+0x240>
                        SemCount128--;
81116e18:	d0a07543 	ldbu	r2,-32299(gp)
81116e1c:	10bfffc4 	addi	r2,r2,-1
81116e20:	d0a07545 	stb	r2,-32299(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81116e24:	111bd140 	call	8111bd14 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81116e28:	e0bfff03 	ldbu	r2,-4(fp)
81116e2c:	10800044 	addi	r2,r2,1
81116e30:	e0bfff05 	stb	r2,-4(fp)
81116e34:	e0bfff03 	ldbu	r2,-4(fp)
81116e38:	108001b0 	cmpltui	r2,r2,6
81116e3c:	103f7c1e 	bne	r2,zero,81116c30 <__reset+0xfb0f6c30>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81116e40:	d0a06e17 	ldw	r2,-32328(gp)
81116e44:	1009883a 	mov	r4,r2
81116e48:	113ce140 	call	8113ce14 <OSMutexPost>

    return;
81116e4c:	0001883a 	nop
81116e50:	00000106 	br	81116e58 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81116e54:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81116e58:	e037883a 	mov	sp,fp
81116e5c:	dfc00117 	ldw	ra,4(sp)
81116e60:	df000017 	ldw	fp,0(sp)
81116e64:	dec00204 	addi	sp,sp,8
81116e68:	f800283a 	ret

81116e6c <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81116e6c:	defffd04 	addi	sp,sp,-12
81116e70:	de00012e 	bgeu	sp,et,81116e78 <vCheckRetransmission64+0xc>
81116e74:	003b68fa 	trap	3
81116e78:	dfc00215 	stw	ra,8(sp)
81116e7c:	df000115 	stw	fp,4(sp)
81116e80:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81116e84:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81116e88:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81116e8c:	d0a07117 	ldw	r2,-32316(gp)
81116e90:	e0ffff44 	addi	r3,fp,-3
81116e94:	180b883a 	mov	r5,r3
81116e98:	1009883a 	mov	r4,r2
81116e9c:	113c1f00 	call	8113c1f0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81116ea0:	e0bfff43 	ldbu	r2,-3(fp)
81116ea4:	10803fcc 	andi	r2,r2,255
81116ea8:	10008d1e 	bne	r2,zero,811170e0 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81116eac:	e03fff05 	stb	zero,-4(fp)
81116eb0:	00008306 	br	811170c0 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81116eb4:	e0ffff03 	ldbu	r3,-4(fp)
81116eb8:	00a045b4 	movhi	r2,33046
81116ebc:	10bafc04 	addi	r2,r2,-5136
81116ec0:	18c00184 	addi	r3,r3,6
81116ec4:	18c7883a 	add	r3,r3,r3
81116ec8:	18c7883a 	add	r3,r3,r3
81116ecc:	10c5883a 	add	r2,r2,r3
81116ed0:	10800017 	ldw	r2,0(r2)
81116ed4:	10800058 	cmpnei	r2,r2,1
81116ed8:	1000761e 	bne	r2,zero,811170b4 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81116edc:	e0ffff03 	ldbu	r3,-4(fp)
81116ee0:	00a04574 	movhi	r2,33045
81116ee4:	1096c004 	addi	r2,r2,23296
81116ee8:	18c01324 	muli	r3,r3,76
81116eec:	10c5883a 	add	r2,r2,r3
81116ef0:	10801004 	addi	r2,r2,64
81116ef4:	10800017 	ldw	r2,0(r2)
81116ef8:	10800058 	cmpnei	r2,r2,1
81116efc:	1000211e 	bne	r2,zero,81116f84 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81116f00:	e0ffff03 	ldbu	r3,-4(fp)
81116f04:	00a04574 	movhi	r2,33045
81116f08:	1096c004 	addi	r2,r2,23296
81116f0c:	19001324 	muli	r4,r3,76
81116f10:	1105883a 	add	r2,r2,r4
81116f14:	10801184 	addi	r2,r2,70
81116f18:	1080000b 	ldhu	r2,0(r2)
81116f1c:	10800044 	addi	r2,r2,1
81116f20:	100b883a 	mov	r5,r2
81116f24:	00a04574 	movhi	r2,33045
81116f28:	1096c004 	addi	r2,r2,23296
81116f2c:	19001324 	muli	r4,r3,76
81116f30:	1105883a 	add	r2,r2,r4
81116f34:	10801184 	addi	r2,r2,70
81116f38:	1140000d 	sth	r5,0(r2)
81116f3c:	00a04574 	movhi	r2,33045
81116f40:	1096c004 	addi	r2,r2,23296
81116f44:	18c01324 	muli	r3,r3,76
81116f48:	10c5883a 	add	r2,r2,r3
81116f4c:	10801184 	addi	r2,r2,70
81116f50:	1080000b 	ldhu	r2,0(r2)
81116f54:	10bfffcc 	andi	r2,r2,65535
81116f58:	10a0001c 	xori	r2,r2,32768
81116f5c:	10a00004 	addi	r2,r2,-32768
81116f60:	10800090 	cmplti	r2,r2,2
81116f64:	1000071e 	bne	r2,zero,81116f84 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81116f68:	e0ffff03 	ldbu	r3,-4(fp)
81116f6c:	00a04574 	movhi	r2,33045
81116f70:	1096c004 	addi	r2,r2,23296
81116f74:	18c01324 	muli	r3,r3,76
81116f78:	10c5883a 	add	r2,r2,r3
81116f7c:	10801004 	addi	r2,r2,64
81116f80:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81116f84:	e0ffff03 	ldbu	r3,-4(fp)
81116f88:	00a04574 	movhi	r2,33045
81116f8c:	1096c004 	addi	r2,r2,23296
81116f90:	18c01324 	muli	r3,r3,76
81116f94:	10c5883a 	add	r2,r2,r3
81116f98:	10801004 	addi	r2,r2,64
81116f9c:	10800017 	ldw	r2,0(r2)
81116fa0:	1000441e 	bne	r2,zero,811170b4 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
81116fa4:	e0bfff03 	ldbu	r2,-4(fp)
81116fa8:	10c01324 	muli	r3,r2,76
81116fac:	00a04574 	movhi	r2,33045
81116fb0:	1096c004 	addi	r2,r2,23296
81116fb4:	1885883a 	add	r2,r3,r2
81116fb8:	1009883a 	mov	r4,r2
81116fbc:	11229900 	call	81122990 <puts>
                xBuffer64[ucIL].bSent = TRUE;
81116fc0:	e0ffff03 	ldbu	r3,-4(fp)
81116fc4:	00a04574 	movhi	r2,33045
81116fc8:	1096c004 	addi	r2,r2,23296
81116fcc:	18c01324 	muli	r3,r3,76
81116fd0:	10c5883a 	add	r2,r2,r3
81116fd4:	10801004 	addi	r2,r2,64
81116fd8:	00c00044 	movi	r3,1
81116fdc:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81116fe0:	e0ffff03 	ldbu	r3,-4(fp)
81116fe4:	00a04574 	movhi	r2,33045
81116fe8:	1096c004 	addi	r2,r2,23296
81116fec:	18c01324 	muli	r3,r3,76
81116ff0:	10c5883a 	add	r2,r2,r3
81116ff4:	10801184 	addi	r2,r2,70
81116ff8:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81116ffc:	e0ffff03 	ldbu	r3,-4(fp)
81117000:	00a04574 	movhi	r2,33045
81117004:	1096c004 	addi	r2,r2,23296
81117008:	19001324 	muli	r4,r3,76
8111700c:	1105883a 	add	r2,r2,r4
81117010:	10801204 	addi	r2,r2,72
81117014:	10800003 	ldbu	r2,0(r2)
81117018:	10800044 	addi	r2,r2,1
8111701c:	100b883a 	mov	r5,r2
81117020:	00a04574 	movhi	r2,33045
81117024:	1096c004 	addi	r2,r2,23296
81117028:	19001324 	muli	r4,r3,76
8111702c:	1105883a 	add	r2,r2,r4
81117030:	10801204 	addi	r2,r2,72
81117034:	11400005 	stb	r5,0(r2)
81117038:	00a04574 	movhi	r2,33045
8111703c:	1096c004 	addi	r2,r2,23296
81117040:	18c01324 	muli	r3,r3,76
81117044:	10c5883a 	add	r2,r2,r3
81117048:	10801204 	addi	r2,r2,72
8111704c:	10800003 	ldbu	r2,0(r2)
81117050:	10803fcc 	andi	r2,r2,255
81117054:	108000b0 	cmpltui	r2,r2,2
81117058:	1000161e 	bne	r2,zero,811170b4 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
8111705c:	e0ffff03 	ldbu	r3,-4(fp)
81117060:	00a045b4 	movhi	r2,33046
81117064:	10bafc04 	addi	r2,r2,-5136
81117068:	18c00184 	addi	r3,r3,6
8111706c:	18c7883a 	add	r3,r3,r3
81117070:	18c7883a 	add	r3,r3,r3
81117074:	10c5883a 	add	r2,r2,r3
81117078:	10000015 	stw	zero,0(r2)
                    SemCount64++;
8111707c:	d0a07503 	ldbu	r2,-32300(gp)
81117080:	10800044 	addi	r2,r2,1
81117084:	d0a07505 	stb	r2,-32300(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81117088:	d0a05e17 	ldw	r2,-32392(gp)
8111708c:	1009883a 	mov	r4,r2
81117090:	113ec040 	call	8113ec04 <OSSemPost>
81117094:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81117098:	e0bfff43 	ldbu	r2,-3(fp)
8111709c:	10803fcc 	andi	r2,r2,255
811170a0:	10000426 	beq	r2,zero,811170b4 <vCheckRetransmission64+0x248>
                        SemCount64--;
811170a4:	d0a07503 	ldbu	r2,-32300(gp)
811170a8:	10bfffc4 	addi	r2,r2,-1
811170ac:	d0a07505 	stb	r2,-32300(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811170b0:	111bcac0 	call	8111bcac <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
811170b4:	e0bfff03 	ldbu	r2,-4(fp)
811170b8:	10800044 	addi	r2,r2,1
811170bc:	e0bfff05 	stb	r2,-4(fp)
811170c0:	e0bfff03 	ldbu	r2,-4(fp)
811170c4:	10800230 	cmpltui	r2,r2,8
811170c8:	103f7a1e 	bne	r2,zero,81116eb4 <__reset+0xfb0f6eb4>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
811170cc:	d0a07117 	ldw	r2,-32316(gp)
811170d0:	1009883a 	mov	r4,r2
811170d4:	113ce140 	call	8113ce14 <OSMutexPost>

    return;
811170d8:	0001883a 	nop
811170dc:	00000106 	br	811170e4 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811170e0:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
811170e4:	e037883a 	mov	sp,fp
811170e8:	dfc00117 	ldw	ra,4(sp)
811170ec:	df000017 	ldw	fp,0(sp)
811170f0:	dec00204 	addi	sp,sp,8
811170f4:	f800283a 	ret

811170f8 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
811170f8:	defffd04 	addi	sp,sp,-12
811170fc:	de00012e 	bgeu	sp,et,81117104 <vCheckRetransmission32+0xc>
81117100:	003b68fa 	trap	3
81117104:	dfc00215 	stw	ra,8(sp)
81117108:	df000115 	stw	fp,4(sp)
8111710c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81117110:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
81117114:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81117118:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8111711c:	d0a06c17 	ldw	r2,-32336(gp)
81117120:	e0ffff84 	addi	r3,fp,-2
81117124:	180b883a 	mov	r5,r3
81117128:	1009883a 	mov	r4,r2
8111712c:	113c1f00 	call	8113c1f0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81117130:	e0bfff83 	ldbu	r2,-2(fp)
81117134:	10803fcc 	andi	r2,r2,255
81117138:	10009b1e 	bne	r2,zero,811173a8 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
8111713c:	e03fff05 	stb	zero,-4(fp)
81117140:	00009106 	br	81117388 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
81117144:	e0ffff03 	ldbu	r3,-4(fp)
81117148:	00a045b4 	movhi	r2,33046
8111714c:	10bafc04 	addi	r2,r2,-5136
81117150:	18c00384 	addi	r3,r3,14
81117154:	18c7883a 	add	r3,r3,r3
81117158:	18c7883a 	add	r3,r3,r3
8111715c:	10c5883a 	add	r2,r2,r3
81117160:	10800017 	ldw	r2,0(r2)
81117164:	10800058 	cmpnei	r2,r2,1
81117168:	1000841e 	bne	r2,zero,8111737c <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
8111716c:	e0ffff03 	ldbu	r3,-4(fp)
81117170:	00a045b4 	movhi	r2,33046
81117174:	10a87c04 	addi	r2,r2,-24080
81117178:	18c00b24 	muli	r3,r3,44
8111717c:	10c5883a 	add	r2,r2,r3
81117180:	10800804 	addi	r2,r2,32
81117184:	10800017 	ldw	r2,0(r2)
81117188:	10800058 	cmpnei	r2,r2,1
8111718c:	1000211e 	bne	r2,zero,81117214 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81117190:	e0ffff03 	ldbu	r3,-4(fp)
81117194:	00a045b4 	movhi	r2,33046
81117198:	10a87c04 	addi	r2,r2,-24080
8111719c:	19000b24 	muli	r4,r3,44
811171a0:	1105883a 	add	r2,r2,r4
811171a4:	10800984 	addi	r2,r2,38
811171a8:	1080000b 	ldhu	r2,0(r2)
811171ac:	10800044 	addi	r2,r2,1
811171b0:	100b883a 	mov	r5,r2
811171b4:	00a045b4 	movhi	r2,33046
811171b8:	10a87c04 	addi	r2,r2,-24080
811171bc:	19000b24 	muli	r4,r3,44
811171c0:	1105883a 	add	r2,r2,r4
811171c4:	10800984 	addi	r2,r2,38
811171c8:	1140000d 	sth	r5,0(r2)
811171cc:	00a045b4 	movhi	r2,33046
811171d0:	10a87c04 	addi	r2,r2,-24080
811171d4:	18c00b24 	muli	r3,r3,44
811171d8:	10c5883a 	add	r2,r2,r3
811171dc:	10800984 	addi	r2,r2,38
811171e0:	1080000b 	ldhu	r2,0(r2)
811171e4:	10bfffcc 	andi	r2,r2,65535
811171e8:	10a0001c 	xori	r2,r2,32768
811171ec:	10a00004 	addi	r2,r2,-32768
811171f0:	10800090 	cmplti	r2,r2,2
811171f4:	1000071e 	bne	r2,zero,81117214 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
811171f8:	e0ffff03 	ldbu	r3,-4(fp)
811171fc:	00a045b4 	movhi	r2,33046
81117200:	10a87c04 	addi	r2,r2,-24080
81117204:	18c00b24 	muli	r3,r3,44
81117208:	10c5883a 	add	r2,r2,r3
8111720c:	10800804 	addi	r2,r2,32
81117210:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81117214:	e0ffff03 	ldbu	r3,-4(fp)
81117218:	00a045b4 	movhi	r2,33046
8111721c:	10a87c04 	addi	r2,r2,-24080
81117220:	18c00b24 	muli	r3,r3,44
81117224:	10c5883a 	add	r2,r2,r3
81117228:	10800804 	addi	r2,r2,32
8111722c:	10800017 	ldw	r2,0(r2)
81117230:	1000521e 	bne	r2,zero,8111737c <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81117234:	e0bfff03 	ldbu	r2,-4(fp)
81117238:	10c00b24 	muli	r3,r2,44
8111723c:	00a045b4 	movhi	r2,33046
81117240:	10a87c04 	addi	r2,r2,-24080
81117244:	1885883a 	add	r2,r3,r2
81117248:	1009883a 	mov	r4,r2
8111724c:	11229900 	call	81122990 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81117250:	e0ffff03 	ldbu	r3,-4(fp)
81117254:	00a045b4 	movhi	r2,33046
81117258:	10a87c04 	addi	r2,r2,-24080
8111725c:	18c00b24 	muli	r3,r3,44
81117260:	10c5883a 	add	r2,r2,r3
81117264:	10800804 	addi	r2,r2,32
81117268:	00c00044 	movi	r3,1
8111726c:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81117270:	e0ffff03 	ldbu	r3,-4(fp)
81117274:	00a045b4 	movhi	r2,33046
81117278:	10a87c04 	addi	r2,r2,-24080
8111727c:	18c00b24 	muli	r3,r3,44
81117280:	10c5883a 	add	r2,r2,r3
81117284:	10800984 	addi	r2,r2,38
81117288:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
8111728c:	e0ffff03 	ldbu	r3,-4(fp)
81117290:	00a045b4 	movhi	r2,33046
81117294:	10a87c04 	addi	r2,r2,-24080
81117298:	18c00b24 	muli	r3,r3,44
8111729c:	10c5883a 	add	r2,r2,r3
811172a0:	10800904 	addi	r2,r2,36
811172a4:	1080000b 	ldhu	r2,0(r2)
811172a8:	10bfffcc 	andi	r2,r2,65535
811172ac:	10800058 	cmpnei	r2,r2,1
811172b0:	1000021e 	bne	r2,zero,811172bc <vCheckRetransmission32+0x1c4>
811172b4:	00bffe84 	movi	r2,-6
811172b8:	00000106 	br	811172c0 <vCheckRetransmission32+0x1c8>
811172bc:	00800044 	movi	r2,1
811172c0:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
811172c4:	e0ffff03 	ldbu	r3,-4(fp)
811172c8:	00a045b4 	movhi	r2,33046
811172cc:	10a87c04 	addi	r2,r2,-24080
811172d0:	19000b24 	muli	r4,r3,44
811172d4:	1105883a 	add	r2,r2,r4
811172d8:	10800a04 	addi	r2,r2,40
811172dc:	10800003 	ldbu	r2,0(r2)
811172e0:	10800044 	addi	r2,r2,1
811172e4:	100b883a 	mov	r5,r2
811172e8:	00a045b4 	movhi	r2,33046
811172ec:	10a87c04 	addi	r2,r2,-24080
811172f0:	19000b24 	muli	r4,r3,44
811172f4:	1105883a 	add	r2,r2,r4
811172f8:	10800a04 	addi	r2,r2,40
811172fc:	11400005 	stb	r5,0(r2)
81117300:	00a045b4 	movhi	r2,33046
81117304:	10a87c04 	addi	r2,r2,-24080
81117308:	18c00b24 	muli	r3,r3,44
8111730c:	10c5883a 	add	r2,r2,r3
81117310:	10800a04 	addi	r2,r2,40
81117314:	10800003 	ldbu	r2,0(r2)
81117318:	10803fcc 	andi	r2,r2,255
8111731c:	e0ffff43 	ldbu	r3,-3(fp)
81117320:	1880162e 	bgeu	r3,r2,8111737c <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81117324:	e0ffff03 	ldbu	r3,-4(fp)
81117328:	00a045b4 	movhi	r2,33046
8111732c:	10bafc04 	addi	r2,r2,-5136
81117330:	18c00384 	addi	r3,r3,14
81117334:	18c7883a 	add	r3,r3,r3
81117338:	18c7883a 	add	r3,r3,r3
8111733c:	10c5883a 	add	r2,r2,r3
81117340:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81117344:	d0a06883 	ldbu	r2,-32350(gp)
81117348:	10800044 	addi	r2,r2,1
8111734c:	d0a06885 	stb	r2,-32350(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81117350:	d0a06f17 	ldw	r2,-32324(gp)
81117354:	1009883a 	mov	r4,r2
81117358:	113ec040 	call	8113ec04 <OSSemPost>
8111735c:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81117360:	e0bfff83 	ldbu	r2,-2(fp)
81117364:	10803fcc 	andi	r2,r2,255
81117368:	10000426 	beq	r2,zero,8111737c <vCheckRetransmission32+0x284>
                        SemCount32--;
8111736c:	d0a06883 	ldbu	r2,-32350(gp)
81117370:	10bfffc4 	addi	r2,r2,-1
81117374:	d0a06885 	stb	r2,-32350(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81117378:	111bc440 	call	8111bc44 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
8111737c:	e0bfff03 	ldbu	r2,-4(fp)
81117380:	10800044 	addi	r2,r2,1
81117384:	e0bfff05 	stb	r2,-4(fp)
81117388:	e0bfff03 	ldbu	r2,-4(fp)
8111738c:	10800230 	cmpltui	r2,r2,8
81117390:	103f6c1e 	bne	r2,zero,81117144 <__reset+0xfb0f7144>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81117394:	d0a06c17 	ldw	r2,-32336(gp)
81117398:	1009883a 	mov	r4,r2
8111739c:	113ce140 	call	8113ce14 <OSMutexPost>

    return;
811173a0:	0001883a 	nop
811173a4:	00000106 	br	811173ac <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811173a8:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
811173ac:	e037883a 	mov	sp,fp
811173b0:	dfc00117 	ldw	ra,4(sp)
811173b4:	df000017 	ldw	fp,0(sp)
811173b8:	dec00204 	addi	sp,sp,8
811173bc:	f800283a 	ret

811173c0 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
811173c0:	defff904 	addi	sp,sp,-28
811173c4:	de00012e 	bgeu	sp,et,811173cc <bResourcesInitRTOS+0xc>
811173c8:	003b68fa 	trap	3
811173cc:	dfc00615 	stw	ra,24(sp)
811173d0:	df000515 	stw	fp,20(sp)
811173d4:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
811173d8:	00800044 	movi	r2,1
811173dc:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
811173e0:	0009883a 	mov	r4,zero
811173e4:	113e5540 	call	8113e554 <OSSemCreate>
811173e8:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCommInit) {
811173ec:	d0a06017 	ldw	r2,-32384(gp)
811173f0:	1000021e 	bne	r2,zero,811173fc <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
811173f4:	111b6dc0 	call	8111b6dc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811173f8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
811173fc:	e0bfff04 	addi	r2,fp,-4
81117400:	100b883a 	mov	r5,r2
81117404:	01000444 	movi	r4,17
81117408:	113c39c0 	call	8113c39c <OSMutexCreate>
8111740c:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
81117410:	e0bfff03 	ldbu	r2,-4(fp)
81117414:	10803fcc 	andi	r2,r2,255
81117418:	10000526 	beq	r2,zero,81117430 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
8111741c:	e0bfff03 	ldbu	r2,-4(fp)
81117420:	10803fcc 	andi	r2,r2,255
81117424:	1009883a 	mov	r4,r2
81117428:	111b6300 	call	8111b630 <vFailCreateMutexSResources>
		bSuccess = FALSE;
8111742c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81117430:	e0bfff04 	addi	r2,fp,-4
81117434:	100b883a 	mov	r5,r2
81117438:	01000504 	movi	r4,20
8111743c:	113c39c0 	call	8113c39c <OSMutexCreate>
81117440:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
81117444:	e0bfff03 	ldbu	r2,-4(fp)
81117448:	10803fcc 	andi	r2,r2,255
8111744c:	10000526 	beq	r2,zero,81117464 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81117450:	e0bfff03 	ldbu	r2,-4(fp)
81117454:	10803fcc 	andi	r2,r2,255
81117458:	1009883a 	mov	r4,r2
8111745c:	111b6300 	call	8111b630 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117460:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81117464:	e0bfff04 	addi	r2,fp,-4
81117468:	100b883a 	mov	r5,r2
8111746c:	01000544 	movi	r4,21
81117470:	113c39c0 	call	8113c39c <OSMutexCreate>
81117474:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81117478:	e0bfff03 	ldbu	r2,-4(fp)
8111747c:	10803fcc 	andi	r2,r2,255
81117480:	10000526 	beq	r2,zero,81117498 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81117484:	e0bfff03 	ldbu	r2,-4(fp)
81117488:	10803fcc 	andi	r2,r2,255
8111748c:	1009883a 	mov	r4,r2
81117490:	111b6300 	call	8111b630 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117494:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81117498:	e0bfff04 	addi	r2,fp,-4
8111749c:	100b883a 	mov	r5,r2
811174a0:	01000584 	movi	r4,22
811174a4:	113c39c0 	call	8113c39c <OSMutexCreate>
811174a8:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
811174ac:	e0bfff03 	ldbu	r2,-4(fp)
811174b0:	10803fcc 	andi	r2,r2,255
811174b4:	10000526 	beq	r2,zero,811174cc <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
811174b8:	e0bfff03 	ldbu	r2,-4(fp)
811174bc:	10803fcc 	andi	r2,r2,255
811174c0:	1009883a 	mov	r4,r2
811174c4:	111b6300 	call	8111b630 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811174c8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
811174cc:	00800184 	movi	r2,6
811174d0:	d0a07545 	stb	r2,-32299(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
811174d4:	01000184 	movi	r4,6
811174d8:	113e5540 	call	8113e554 <OSSemCreate>
811174dc:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountBuffer128) {
811174e0:	d0a06317 	ldw	r2,-32372(gp)
811174e4:	1000031e 	bne	r2,zero,811174f4 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
811174e8:	d0207545 	stb	zero,-32299(gp)
		vFailCreateSemaphoreResources();
811174ec:	111b6dc0 	call	8111b6dc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811174f0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
811174f4:	00800204 	movi	r2,8
811174f8:	d0a07505 	stb	r2,-32300(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
811174fc:	01000204 	movi	r4,8
81117500:	113e5540 	call	8113e554 <OSSemCreate>
81117504:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer64) {
81117508:	d0a05e17 	ldw	r2,-32392(gp)
8111750c:	1000031e 	bne	r2,zero,8111751c <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81117510:	d0207505 	stb	zero,-32300(gp)
		vFailCreateSemaphoreResources();
81117514:	111b6dc0 	call	8111b6dc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117518:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
8111751c:	00800204 	movi	r2,8
81117520:	d0a06885 	stb	r2,-32350(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81117524:	01000204 	movi	r4,8
81117528:	113e5540 	call	8113e554 <OSSemCreate>
8111752c:	d0a06f15 	stw	r2,-32324(gp)
	if (!xSemCountBuffer32) {
81117530:	d0a06f17 	ldw	r2,-32324(gp)
81117534:	1000031e 	bne	r2,zero,81117544 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
81117538:	d0206885 	stb	zero,-32350(gp)
		vFailCreateSemaphoreResources();
8111753c:	111b6dc0 	call	8111b6dc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81117540:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81117544:	e0bfff04 	addi	r2,fp,-4
81117548:	100b883a 	mov	r5,r2
8111754c:	010004c4 	movi	r4,19
81117550:	113c39c0 	call	8113c39c <OSMutexCreate>
81117554:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
81117558:	e0bfff03 	ldbu	r2,-4(fp)
8111755c:	10803fcc 	andi	r2,r2,255
81117560:	10000526 	beq	r2,zero,81117578 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81117564:	e0bfff03 	ldbu	r2,-4(fp)
81117568:	10803fcc 	andi	r2,r2,255
8111756c:	1009883a 	mov	r4,r2
81117570:	111b6300 	call	8111b630 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117574:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81117578:	e0bfff04 	addi	r2,fp,-4
8111757c:	100b883a 	mov	r5,r2
81117580:	010005c4 	movi	r4,23
81117584:	113c39c0 	call	8113c39c <OSMutexCreate>
81117588:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
8111758c:	e0bfff03 	ldbu	r2,-4(fp)
81117590:	10803fcc 	andi	r2,r2,255
81117594:	10000526 	beq	r2,zero,811175ac <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81117598:	e0bfff03 	ldbu	r2,-4(fp)
8111759c:	10803fcc 	andi	r2,r2,255
811175a0:	1009883a 	mov	r4,r2
811175a4:	111b6300 	call	8111b630 <vFailCreateMutexSResources>
		bSuccess = FALSE;
811175a8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
811175ac:	0009883a 	mov	r4,zero
811175b0:	113e5540 	call	8113e554 <OSSemCreate>
811175b4:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemCountReceivedACK) {
811175b8:	d0a06617 	ldw	r2,-32360(gp)
811175bc:	1000021e 	bne	r2,zero,811175c8 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
811175c0:	111b6dc0 	call	8111b6dc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811175c4:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
811175c8:	0009883a 	mov	r4,zero
811175cc:	113e5540 	call	8113e554 <OSSemCreate>
811175d0:	d0a06415 	stw	r2,-32368(gp)
	if (!xSemCountPreParsed) {
811175d4:	d0a06417 	ldw	r2,-32368(gp)
811175d8:	1000021e 	bne	r2,zero,811175e4 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
811175dc:	111b6dc0 	call	8111b6dc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811175e0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
811175e4:	0009883a 	mov	r4,zero
811175e8:	113e5540 	call	8113e554 <OSSemCreate>
811175ec:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountSenderACK) {
811175f0:	d0a06117 	ldw	r2,-32380(gp)
811175f4:	1000021e 	bne	r2,zero,81117600 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
811175f8:	111b6dc0 	call	8111b6dc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
811175fc:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81117600:	e0bfff04 	addi	r2,fp,-4
81117604:	100b883a 	mov	r5,r2
81117608:	01000484 	movi	r4,18
8111760c:	113c39c0 	call	8113c39c <OSMutexCreate>
81117610:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
81117614:	e0bfff03 	ldbu	r2,-4(fp)
81117618:	10803fcc 	andi	r2,r2,255
8111761c:	10000526 	beq	r2,zero,81117634 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81117620:	e0bfff03 	ldbu	r2,-4(fp)
81117624:	10803fcc 	andi	r2,r2,255
81117628:	1009883a 	mov	r4,r2
8111762c:	111b6300 	call	8111b630 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81117630:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81117634:	0009883a 	mov	r4,zero
81117638:	113e5540 	call	8113e554 <OSSemCreate>
8111763c:	d0a06715 	stw	r2,-32356(gp)
	if (!xSemTimeoutChecker) {
81117640:	d0a06717 	ldw	r2,-32356(gp)
81117644:	1000021e 	bne	r2,zero,81117650 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
81117648:	111b6dc0 	call	8111b6dc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
8111764c:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81117650:	e0bfff04 	addi	r2,fp,-4
81117654:	d8800215 	stw	r2,8(sp)
81117658:	00a04574 	movhi	r2,33045
8111765c:	10b92c04 	addi	r2,r2,-6992
81117660:	d8800115 	stw	r2,4(sp)
81117664:	d8000015 	stw	zero,0(sp)
81117668:	01e044b4 	movhi	r7,33042
8111766c:	39e4b804 	addi	r7,r7,-27936
81117670:	01800084 	movi	r6,2
81117674:	01400104 	movi	r5,4
81117678:	01000284 	movi	r4,10
8111767c:	1140c200 	call	81140c20 <OSTmrCreate>
81117680:	d0a06d15 	stw	r2,-32332(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81117684:	e0bfff03 	ldbu	r2,-4(fp)
81117688:	10803fcc 	andi	r2,r2,255
8111768c:	10000226 	beq	r2,zero,81117698 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81117690:	111c3400 	call	8111c340 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81117694:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81117698:	01400484 	movi	r5,18
8111769c:	01204574 	movhi	r4,33045
811176a0:	211bbc04 	addi	r4,r4,28400
811176a4:	113d4880 	call	8113d488 <OSQCreate>
811176a8:	d0a05d15 	stw	r2,-32396(gp)
	if ( xNfeeSchedule == NULL ) {
811176ac:	d0a05d17 	ldw	r2,-32396(gp)
811176b0:	1000021e 	bne	r2,zero,811176bc <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
811176b4:	111c9240 	call	8111c924 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
811176b8:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
811176bc:	01400204 	movi	r5,8
811176c0:	012045b4 	movhi	r4,33046
811176c4:	211ace04 	addi	r4,r4,27448
811176c8:	113d4880 	call	8113d488 <OSQCreate>
811176cc:	d0a06a15 	stw	r2,-32344(gp)
	if ( xFeeQ[0] == NULL ) {
811176d0:	d0a06a17 	ldw	r2,-32344(gp)
811176d4:	1000031e 	bne	r2,zero,811176e4 <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
811176d8:	0009883a 	mov	r4,zero
811176dc:	111c98c0 	call	8111c98c <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811176e0:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
811176e4:	01400204 	movi	r5,8
811176e8:	012045b4 	movhi	r4,33046
811176ec:	21001404 	addi	r4,r4,80
811176f0:	113d4880 	call	8113d488 <OSQCreate>
811176f4:	d0a05c15 	stw	r2,-32400(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
811176f8:	d0a05c17 	ldw	r2,-32400(gp)
811176fc:	1000031e 	bne	r2,zero,8111770c <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81117700:	0009883a 	mov	r4,zero
81117704:	111c9fc0 	call	8111c9fc <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81117708:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
8111770c:	01400204 	movi	r5,8
81117710:	012045b4 	movhi	r4,33046
81117714:	213b1204 	addi	r4,r4,-5048
81117718:	113d4880 	call	8113d488 <OSQCreate>
8111771c:	d0a06915 	stw	r2,-32348(gp)
	if ( xMebQ == NULL ) {
81117720:	d0a06917 	ldw	r2,-32348(gp)
81117724:	1000031e 	bne	r2,zero,81117734 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
81117728:	01000144 	movi	r4,5
8111772c:	111c98c0 	call	8111c98c <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81117730:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81117734:	e0bfff04 	addi	r2,fp,-4
81117738:	100b883a 	mov	r5,r2
8111773c:	010001c4 	movi	r4,7
81117740:	113c39c0 	call	8113c39c <OSMutexCreate>
81117744:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
81117748:	e0bfff03 	ldbu	r2,-4(fp)
8111774c:	10803fcc 	andi	r2,r2,255
81117750:	10000526 	beq	r2,zero,81117768 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81117754:	e0bfff03 	ldbu	r2,-4(fp)
81117758:	10803fcc 	andi	r2,r2,255
8111775c:	1009883a 	mov	r4,r2
81117760:	111ce140 	call	8111ce14 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81117764:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81117768:	01400404 	movi	r5,16
8111776c:	012045b4 	movhi	r4,33046
81117770:	213bec04 	addi	r4,r4,-4176
81117774:	113d4880 	call	8113d488 <OSQCreate>
81117778:	d0a07015 	stw	r2,-32320(gp)
	if ( xQMaskFeeCtrl == NULL ) {
8111777c:	d0a07017 	ldw	r2,-32320(gp)
81117780:	1000021e 	bne	r2,zero,8111778c <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81117784:	111cf740 	call	8111cf74 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81117788:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
8111778c:	01400404 	movi	r5,16
81117790:	012045b4 	movhi	r4,33046
81117794:	212ed404 	addi	r4,r4,-17584
81117798:	113d4880 	call	8113d488 <OSQCreate>
8111779c:	d0a05f15 	stw	r2,-32388(gp)
	if ( xQMaskDataCtrl == NULL ) {
811177a0:	d0a05f17 	ldw	r2,-32388(gp)
811177a4:	1000021e 	bne	r2,zero,811177b0 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
811177a8:	111cfdc0 	call	8111cfdc <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
811177ac:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
811177b0:	e0bfff04 	addi	r2,fp,-4
811177b4:	100b883a 	mov	r5,r2
811177b8:	01000104 	movi	r4,4
811177bc:	113c39c0 	call	8113c39c <OSMutexCreate>
811177c0:	1007883a 	mov	r3,r2
811177c4:	00a045b4 	movhi	r2,33046
811177c8:	108e2204 	addi	r2,r2,14472
811177cc:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
811177d0:	e0bfff03 	ldbu	r2,-4(fp)
811177d4:	10803fcc 	andi	r2,r2,255
811177d8:	10000226 	beq	r2,zero,811177e4 <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
811177dc:	111b6900 	call	8111b690 <vFailCreateMutexDMA>
		bSuccess = FALSE;
811177e0:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
811177e4:	e0bfff04 	addi	r2,fp,-4
811177e8:	100b883a 	mov	r5,r2
811177ec:	01000184 	movi	r4,6
811177f0:	113c39c0 	call	8113c39c <OSMutexCreate>
811177f4:	1007883a 	mov	r3,r2
811177f8:	00a045b4 	movhi	r2,33046
811177fc:	108e2204 	addi	r2,r2,14472
81117800:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81117804:	e0bfff03 	ldbu	r2,-4(fp)
81117808:	10803fcc 	andi	r2,r2,255
8111780c:	10000226 	beq	r2,zero,81117818 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81117810:	111b6900 	call	8111b690 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81117814:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81117818:	e0bffe17 	ldw	r2,-8(fp)
}
8111781c:	e037883a 	mov	sp,fp
81117820:	dfc00117 	ldw	ra,4(sp)
81117824:	df000017 	ldw	fp,0(sp)
81117828:	dec00204 	addi	sp,sp,8
8111782c:	f800283a 	ret

81117830 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81117830:	defffd04 	addi	sp,sp,-12
81117834:	de00012e 	bgeu	sp,et,8111783c <vVariablesInitialization+0xc>
81117838:	003b68fa 	trap	3
8111783c:	dfc00215 	stw	ra,8(sp)
81117840:	df000115 	stw	fp,4(sp)
81117844:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81117848:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
8111784c:	00800084 	movi	r2,2
81117850:	d0a0680d 	sth	r2,-32352(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81117854:	01800604 	movi	r6,24
81117858:	000b883a 	mov	r5,zero
8111785c:	012045b4 	movhi	r4,33046
81117860:	213afc04 	addi	r4,r4,-5136
81117864:	11225440 	call	81122544 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81117868:	01800804 	movi	r6,32
8111786c:	000b883a 	mov	r5,zero
81117870:	012045b4 	movhi	r4,33046
81117874:	213b0204 	addi	r4,r4,-5112
81117878:	11225440 	call	81122544 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
8111787c:	01800804 	movi	r6,32
81117880:	000b883a 	mov	r5,zero
81117884:	012045b4 	movhi	r4,33046
81117888:	213b0a04 	addi	r4,r4,-5080
8111788c:	11225440 	call	81122544 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81117890:	e03fff05 	stb	zero,-4(fp)
81117894:	00002806 	br	81117938 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81117898:	e0bfff03 	ldbu	r2,-4(fp)
8111789c:	10c02324 	muli	r3,r2,140
811178a0:	00a045b4 	movhi	r2,33046
811178a4:	10bb1a04 	addi	r2,r2,-5016
811178a8:	1885883a 	add	r2,r3,r2
811178ac:	01802004 	movi	r6,128
811178b0:	000b883a 	mov	r5,zero
811178b4:	1009883a 	mov	r4,r2
811178b8:	11225440 	call	81122544 <memset>
		xBuffer128[ucIL].bSent = FALSE;
811178bc:	e0ffff03 	ldbu	r3,-4(fp)
811178c0:	00a045b4 	movhi	r2,33046
811178c4:	10bb1a04 	addi	r2,r2,-5016
811178c8:	18c02324 	muli	r3,r3,140
811178cc:	10c5883a 	add	r2,r2,r3
811178d0:	10802004 	addi	r2,r2,128
811178d4:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
811178d8:	e0ffff03 	ldbu	r3,-4(fp)
811178dc:	00a045b4 	movhi	r2,33046
811178e0:	10bb1a04 	addi	r2,r2,-5016
811178e4:	18c02324 	muli	r3,r3,140
811178e8:	10c5883a 	add	r2,r2,r3
811178ec:	10802104 	addi	r2,r2,132
811178f0:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
811178f4:	e0ffff03 	ldbu	r3,-4(fp)
811178f8:	00a045b4 	movhi	r2,33046
811178fc:	10bb1a04 	addi	r2,r2,-5016
81117900:	18c02324 	muli	r3,r3,140
81117904:	10c5883a 	add	r2,r2,r3
81117908:	10802184 	addi	r2,r2,134
8111790c:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81117910:	e0ffff03 	ldbu	r3,-4(fp)
81117914:	00a045b4 	movhi	r2,33046
81117918:	10bb1a04 	addi	r2,r2,-5016
8111791c:	18c02324 	muli	r3,r3,140
81117920:	10c5883a 	add	r2,r2,r3
81117924:	10802204 	addi	r2,r2,136
81117928:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111792c:	e0bfff03 	ldbu	r2,-4(fp)
81117930:	10800044 	addi	r2,r2,1
81117934:	e0bfff05 	stb	r2,-4(fp)
81117938:	e0bfff03 	ldbu	r2,-4(fp)
8111793c:	108001b0 	cmpltui	r2,r2,6
81117940:	103fd51e 	bne	r2,zero,81117898 <__reset+0xfb0f7898>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81117944:	e03fff05 	stb	zero,-4(fp)
81117948:	00002806 	br	811179ec <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
8111794c:	e0bfff03 	ldbu	r2,-4(fp)
81117950:	10c01324 	muli	r3,r2,76
81117954:	00a04574 	movhi	r2,33045
81117958:	1096c004 	addi	r2,r2,23296
8111795c:	1885883a 	add	r2,r3,r2
81117960:	01801004 	movi	r6,64
81117964:	000b883a 	mov	r5,zero
81117968:	1009883a 	mov	r4,r2
8111796c:	11225440 	call	81122544 <memset>
		xBuffer64[ucIL].bSent = FALSE;
81117970:	e0ffff03 	ldbu	r3,-4(fp)
81117974:	00a04574 	movhi	r2,33045
81117978:	1096c004 	addi	r2,r2,23296
8111797c:	18c01324 	muli	r3,r3,76
81117980:	10c5883a 	add	r2,r2,r3
81117984:	10801004 	addi	r2,r2,64
81117988:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
8111798c:	e0ffff03 	ldbu	r3,-4(fp)
81117990:	00a04574 	movhi	r2,33045
81117994:	1096c004 	addi	r2,r2,23296
81117998:	18c01324 	muli	r3,r3,76
8111799c:	10c5883a 	add	r2,r2,r3
811179a0:	10801104 	addi	r2,r2,68
811179a4:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
811179a8:	e0ffff03 	ldbu	r3,-4(fp)
811179ac:	00a04574 	movhi	r2,33045
811179b0:	1096c004 	addi	r2,r2,23296
811179b4:	18c01324 	muli	r3,r3,76
811179b8:	10c5883a 	add	r2,r2,r3
811179bc:	10801184 	addi	r2,r2,70
811179c0:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
811179c4:	e0ffff03 	ldbu	r3,-4(fp)
811179c8:	00a04574 	movhi	r2,33045
811179cc:	1096c004 	addi	r2,r2,23296
811179d0:	18c01324 	muli	r3,r3,76
811179d4:	10c5883a 	add	r2,r2,r3
811179d8:	10801204 	addi	r2,r2,72
811179dc:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811179e0:	e0bfff03 	ldbu	r2,-4(fp)
811179e4:	10800044 	addi	r2,r2,1
811179e8:	e0bfff05 	stb	r2,-4(fp)
811179ec:	e0bfff03 	ldbu	r2,-4(fp)
811179f0:	10800230 	cmpltui	r2,r2,8
811179f4:	103fd51e 	bne	r2,zero,8111794c <__reset+0xfb0f794c>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811179f8:	e03fff05 	stb	zero,-4(fp)
811179fc:	00002806 	br	81117aa0 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81117a00:	e0bfff03 	ldbu	r2,-4(fp)
81117a04:	10c00b24 	muli	r3,r2,44
81117a08:	00a045b4 	movhi	r2,33046
81117a0c:	10a87c04 	addi	r2,r2,-24080
81117a10:	1885883a 	add	r2,r3,r2
81117a14:	01800804 	movi	r6,32
81117a18:	000b883a 	mov	r5,zero
81117a1c:	1009883a 	mov	r4,r2
81117a20:	11225440 	call	81122544 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81117a24:	e0ffff03 	ldbu	r3,-4(fp)
81117a28:	00a045b4 	movhi	r2,33046
81117a2c:	10a87c04 	addi	r2,r2,-24080
81117a30:	18c00b24 	muli	r3,r3,44
81117a34:	10c5883a 	add	r2,r2,r3
81117a38:	10800804 	addi	r2,r2,32
81117a3c:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81117a40:	e0ffff03 	ldbu	r3,-4(fp)
81117a44:	00a045b4 	movhi	r2,33046
81117a48:	10a87c04 	addi	r2,r2,-24080
81117a4c:	18c00b24 	muli	r3,r3,44
81117a50:	10c5883a 	add	r2,r2,r3
81117a54:	10800904 	addi	r2,r2,36
81117a58:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81117a5c:	e0ffff03 	ldbu	r3,-4(fp)
81117a60:	00a045b4 	movhi	r2,33046
81117a64:	10a87c04 	addi	r2,r2,-24080
81117a68:	18c00b24 	muli	r3,r3,44
81117a6c:	10c5883a 	add	r2,r2,r3
81117a70:	10800984 	addi	r2,r2,38
81117a74:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81117a78:	e0ffff03 	ldbu	r3,-4(fp)
81117a7c:	00a045b4 	movhi	r2,33046
81117a80:	10a87c04 	addi	r2,r2,-24080
81117a84:	18c00b24 	muli	r3,r3,44
81117a88:	10c5883a 	add	r2,r2,r3
81117a8c:	10800a04 	addi	r2,r2,40
81117a90:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81117a94:	e0bfff03 	ldbu	r2,-4(fp)
81117a98:	10800044 	addi	r2,r2,1
81117a9c:	e0bfff05 	stb	r2,-4(fp)
81117aa0:	e0bfff03 	ldbu	r2,-4(fp)
81117aa4:	10800230 	cmpltui	r2,r2,8
81117aa8:	103fd51e 	bne	r2,zero,81117a00 <__reset+0xfb0f7a00>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81117aac:	e03fff05 	stb	zero,-4(fp)
81117ab0:	00001b06 	br	81117b20 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81117ab4:	e0ffff03 	ldbu	r3,-4(fp)
81117ab8:	00a04574 	movhi	r2,33045
81117abc:	10975804 	addi	r2,r2,23904
81117ac0:	18c01524 	muli	r3,r3,84
81117ac4:	10c5883a 	add	r2,r2,r3
81117ac8:	10800104 	addi	r2,r2,4
81117acc:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81117ad0:	e0ffff03 	ldbu	r3,-4(fp)
81117ad4:	00a04574 	movhi	r2,33045
81117ad8:	10975804 	addi	r2,r2,23904
81117adc:	18c01524 	muli	r3,r3,84
81117ae0:	10c5883a 	add	r2,r2,r3
81117ae4:	10800484 	addi	r2,r2,18
81117ae8:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81117aec:	e0bfff03 	ldbu	r2,-4(fp)
81117af0:	10801524 	muli	r2,r2,84
81117af4:	10c00504 	addi	r3,r2,20
81117af8:	00a04574 	movhi	r2,33045
81117afc:	10975804 	addi	r2,r2,23904
81117b00:	1885883a 	add	r2,r3,r2
81117b04:	01801004 	movi	r6,64
81117b08:	000b883a 	mov	r5,zero
81117b0c:	1009883a 	mov	r4,r2
81117b10:	11225440 	call	81122544 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81117b14:	e0bfff03 	ldbu	r2,-4(fp)
81117b18:	10800044 	addi	r2,r2,1
81117b1c:	e0bfff05 	stb	r2,-4(fp)
81117b20:	e0bfff03 	ldbu	r2,-4(fp)
81117b24:	10800130 	cmpltui	r2,r2,4
81117b28:	103fe21e 	bne	r2,zero,81117ab4 <__reset+0xfb0f7ab4>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81117b2c:	0001883a 	nop
81117b30:	e037883a 	mov	sp,fp
81117b34:	dfc00117 	ldw	ra,4(sp)
81117b38:	df000017 	ldw	fp,0(sp)
81117b3c:	dec00204 	addi	sp,sp,8
81117b40:	f800283a 	ret

81117b44 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81117b44:	defff704 	addi	sp,sp,-36
81117b48:	de00012e 	bgeu	sp,et,81117b50 <main+0xc>
81117b4c:	003b68fa 	trap	3
81117b50:	dfc00815 	stw	ra,32(sp)
81117b54:	df000715 	stw	fp,28(sp)
81117b58:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81117b5c:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81117b60:	11388380 	call	81138838 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81117b64:	01604574 	movhi	r5,33045
81117b68:	29793004 	addi	r5,r5,-6976
81117b6c:	01204574 	movhi	r4,33045
81117b70:	21393104 	addi	r4,r4,-6972
81117b74:	11212fc0 	call	811212fc <fopen>
81117b78:	d0a06215 	stw	r2,-32376(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
81117b7c:	d0a06217 	ldw	r2,-32376(gp)
81117b80:	100f883a 	mov	r7,r2
81117b84:	01800484 	movi	r6,18
81117b88:	01400044 	movi	r5,1
81117b8c:	01204574 	movhi	r4,33045
81117b90:	21393604 	addi	r4,r4,-6952
81117b94:	11219e00 	call	811219e0 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81117b98:	111e01c0 	call	8111e01c <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81117b9c:	111eca00 	call	8111eca0 <bTestSimucamCriticalHW>
81117ba0:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117ba4:	e0bffe17 	ldw	r2,-8(fp)
81117ba8:	1000031e 	bne	r2,zero,81117bb8 <main+0x74>
		vFailTestCriticasParts();
81117bac:	111b7280 	call	8111b728 <vFailTestCriticasParts>
		return -1;
81117bb0:	00bfffc4 	movi	r2,-1
81117bb4:	00004e06 	br	81117cf0 <main+0x1ac>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81117bb8:	111e7900 	call	8111e790 <bInitializeSDCard>
81117bbc:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117bc0:	e0bffe17 	ldw	r2,-8(fp)
81117bc4:	1000031e 	bne	r2,zero,81117bd4 <main+0x90>
		vFailTestCriticasParts();
81117bc8:	111b7280 	call	8111b728 <vFailTestCriticasParts>
		return -1;
81117bcc:	00bfffc4 	movi	r2,-1
81117bd0:	00004706 	br	81117cf0 <main+0x1ac>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81117bd4:	11197080 	call	81119708 <vLoadDefaultETHConf>
81117bd8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117bdc:	e0bffe17 	ldw	r2,-8(fp)
81117be0:	1000091e 	bne	r2,zero,81117c08 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
81117be4:	d0a06217 	ldw	r2,-32376(gp)
81117be8:	100f883a 	mov	r7,r2
81117bec:	01801484 	movi	r6,82
81117bf0:	01400044 	movi	r5,1
81117bf4:	01204574 	movhi	r4,33045
81117bf8:	21393b04 	addi	r4,r4,-6932
81117bfc:	11219e00 	call	811219e0 <fwrite>
		#endif
		return -1;
81117c00:	00bfffc4 	movi	r2,-1
81117c04:	00003a06 	br	81117cf0 <main+0x1ac>
	}

	bIniSimucamStatus = vLoadDebugConfs();
81117c08:	111a4100 	call	8111a410 <vLoadDebugConfs>
81117c0c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117c10:	e0bffe17 	ldw	r2,-8(fp)
81117c14:	1000091e 	bne	r2,zero,81117c3c <main+0xf8>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
81117c18:	d0a06217 	ldw	r2,-32376(gp)
81117c1c:	100f883a 	mov	r7,r2
81117c20:	01801504 	movi	r6,84
81117c24:	01400044 	movi	r5,1
81117c28:	01204574 	movhi	r4,33045
81117c2c:	21395004 	addi	r4,r4,-6848
81117c30:	11219e00 	call	811219e0 <fwrite>
		#endif
		return -1;
81117c34:	00bfffc4 	movi	r2,-1
81117c38:	00002d06 	br	81117cf0 <main+0x1ac>



	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
81117c3c:	111a0e00 	call	8111a0e0 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81117c40:	11173c00 	call	811173c0 <bResourcesInitRTOS>
81117c44:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117c48:	e0bffe17 	ldw	r2,-8(fp)
81117c4c:	1000091e 	bne	r2,zero,81117c74 <main+0x130>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81117c50:	d0a06217 	ldw	r2,-32376(gp)
81117c54:	100f883a 	mov	r7,r2
81117c58:	01800ac4 	movi	r6,43
81117c5c:	01400044 	movi	r5,1
81117c60:	01204574 	movhi	r4,33045
81117c64:	21396604 	addi	r4,r4,-6760
81117c68:	11219e00 	call	811219e0 <fwrite>
		return -1;
81117c6c:	00bfffc4 	movi	r2,-1
81117c70:	00001f06 	br	81117cf0 <main+0x1ac>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81117c74:	012045b4 	movhi	r4,33046
81117c78:	2123ce04 	addi	r4,r4,-28872
81117c7c:	111e15c0 	call	8111e15c <vSimucamStructureInit>

	vVariablesInitialization();
81117c80:	11178300 	call	81117830 <vVariablesInitialization>

	bInitSync();
81117c84:	111e9440 	call	8111e944 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81117c88:	012045b4 	movhi	r4,33046
81117c8c:	2123ce04 	addi	r4,r4,-28872
81117c90:	1117d040 	call	81117d04 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81117c94:	d8000415 	stw	zero,16(sp)
81117c98:	d8000315 	stw	zero,12(sp)
81117c9c:	00810004 	movi	r2,1024
81117ca0:	d8800215 	stw	r2,8(sp)
81117ca4:	00a045b4 	movhi	r2,33046
81117ca8:	10b2f404 	addi	r2,r2,-13360
81117cac:	d8800115 	stw	r2,4(sp)
81117cb0:	00800044 	movi	r2,1
81117cb4:	d8800015 	stw	r2,0(sp)
81117cb8:	01c00044 	movi	r7,1
81117cbc:	01a045b4 	movhi	r6,33046
81117cc0:	31b6f304 	addi	r6,r6,-9268
81117cc4:	000b883a 	mov	r5,zero
81117cc8:	01204474 	movhi	r4,33041
81117ccc:	2108bc04 	addi	r4,r4,8944
81117cd0:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
81117cd4:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81117cd8:	e0bfff03 	ldbu	r2,-4(fp)
81117cdc:	1000021e 	bne	r2,zero,81117ce8 <main+0x1a4>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81117ce0:	1138b680 	call	81138b68 <OSStart>
81117ce4:	00000106 	br	81117cec <main+0x1a8>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81117ce8:	111bb140 	call	8111bb14 <vFailInitialization>
	}
  
	return 0;
81117cec:	0005883a 	mov	r2,zero
}
81117cf0:	e037883a 	mov	sp,fp
81117cf4:	dfc00117 	ldw	ra,4(sp)
81117cf8:	df000017 	ldw	fp,0(sp)
81117cfc:	dec00204 	addi	sp,sp,8
81117d00:	f800283a 	ret

81117d04 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81117d04:	defff604 	addi	sp,sp,-40
81117d08:	de00012e 	bgeu	sp,et,81117d10 <vFillMemmoryPattern+0xc>
81117d0c:	003b68fa 	trap	3
81117d10:	dfc00915 	stw	ra,36(sp)
81117d14:	df000815 	stw	fp,32(sp)
81117d18:	df000804 	addi	fp,sp,32
81117d1c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81117d20:	00800044 	movi	r2,1
81117d24:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81117d28:	d0a06217 	ldw	r2,-32376(gp)
81117d2c:	100f883a 	mov	r7,r2
81117d30:	018009c4 	movi	r6,39
81117d34:	01400044 	movi	r5,1
81117d38:	01204574 	movhi	r4,33045
81117d3c:	21397104 	addi	r4,r4,-6716
81117d40:	11219e00 	call	811219e0 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81117d44:	e03ffa05 	stb	zero,-24(fp)
81117d48:	00007606 	br	81117f24 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117d4c:	e03ffc85 	stb	zero,-14(fp)
81117d50:	00006706 	br	81117ef0 <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81117d54:	e0bffc83 	ldbu	r2,-14(fp)
81117d58:	e0ffff17 	ldw	r3,-4(fp)
81117d5c:	10809624 	muli	r2,r2,600
81117d60:	1885883a 	add	r2,r3,r2
81117d64:	10804304 	addi	r2,r2,268
81117d68:	1080000b 	ldhu	r2,0(r2)
81117d6c:	10ffffcc 	andi	r3,r2,65535
81117d70:	e0bffc83 	ldbu	r2,-14(fp)
81117d74:	e13fff17 	ldw	r4,-4(fp)
81117d78:	10809624 	muli	r2,r2,600
81117d7c:	2085883a 	add	r2,r4,r2
81117d80:	10804204 	addi	r2,r2,264
81117d84:	1080000b 	ldhu	r2,0(r2)
81117d88:	10bfffcc 	andi	r2,r2,65535
81117d8c:	1885883a 	add	r2,r3,r2
81117d90:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81117d94:	e0bffc83 	ldbu	r2,-14(fp)
81117d98:	e0ffff17 	ldw	r3,-4(fp)
81117d9c:	10809624 	muli	r2,r2,600
81117da0:	1885883a 	add	r2,r3,r2
81117da4:	10804284 	addi	r2,r2,266
81117da8:	1080000b 	ldhu	r2,0(r2)
81117dac:	10ffffcc 	andi	r3,r2,65535
81117db0:	e0bffc83 	ldbu	r2,-14(fp)
81117db4:	e13fff17 	ldw	r4,-4(fp)
81117db8:	10809624 	muli	r2,r2,600
81117dbc:	2085883a 	add	r2,r4,r2
81117dc0:	10804184 	addi	r2,r2,262
81117dc4:	1080000b 	ldhu	r2,0(r2)
81117dc8:	10bfffcc 	andi	r2,r2,65535
81117dcc:	1887883a 	add	r3,r3,r2
81117dd0:	e0bffc83 	ldbu	r2,-14(fp)
81117dd4:	e13fff17 	ldw	r4,-4(fp)
81117dd8:	10809624 	muli	r2,r2,600
81117ddc:	2085883a 	add	r2,r4,r2
81117de0:	10804104 	addi	r2,r2,260
81117de4:	1080000b 	ldhu	r2,0(r2)
81117de8:	10bfffcc 	andi	r2,r2,65535
81117dec:	1885883a 	add	r2,r3,r2
81117df0:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81117df4:	e03ffc05 	stb	zero,-16(fp)
81117df8:	00003706 	br	81117ed8 <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81117dfc:	e03ffc45 	stb	zero,-15(fp)
81117e00:	00002606 	br	81117e9c <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
81117e04:	e0bffc43 	ldbu	r2,-15(fp)
81117e08:	10000b1e 	bne	r2,zero,81117e38 <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81117e0c:	e0bffc83 	ldbu	r2,-14(fp)
81117e10:	e13ffc03 	ldbu	r4,-16(fp)
81117e14:	e0ffff17 	ldw	r3,-4(fp)
81117e18:	21000624 	muli	r4,r4,24
81117e1c:	10809624 	muli	r2,r2,600
81117e20:	2085883a 	add	r2,r4,r2
81117e24:	1885883a 	add	r2,r3,r2
81117e28:	10801b04 	addi	r2,r2,108
81117e2c:	10800017 	ldw	r2,0(r2)
81117e30:	e0bffb15 	stw	r2,-20(fp)
81117e34:	00000a06 	br	81117e60 <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81117e38:	e0bffc83 	ldbu	r2,-14(fp)
81117e3c:	e13ffc03 	ldbu	r4,-16(fp)
81117e40:	e0ffff17 	ldw	r3,-4(fp)
81117e44:	21000624 	muli	r4,r4,24
81117e48:	10809624 	muli	r2,r2,600
81117e4c:	2085883a 	add	r2,r4,r2
81117e50:	1885883a 	add	r2,r3,r2
81117e54:	10801e04 	addi	r2,r2,120
81117e58:	10800017 	ldw	r2,0(r2)
81117e5c:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81117e60:	e0fffa03 	ldbu	r3,-24(fp)
81117e64:	e13ffc03 	ldbu	r4,-16(fp)
81117e68:	e17ffc43 	ldbu	r5,-15(fp)
81117e6c:	e0bffd17 	ldw	r2,-12(fp)
81117e70:	d8800115 	stw	r2,4(sp)
81117e74:	e0bffe17 	ldw	r2,-8(fp)
81117e78:	d8800015 	stw	r2,0(sp)
81117e7c:	280f883a 	mov	r7,r5
81117e80:	200d883a 	mov	r6,r4
81117e84:	e17ffb17 	ldw	r5,-20(fp)
81117e88:	1809883a 	mov	r4,r3
81117e8c:	111e5200 	call	8111e520 <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81117e90:	e0bffc43 	ldbu	r2,-15(fp)
81117e94:	10800044 	addi	r2,r2,1
81117e98:	e0bffc45 	stb	r2,-15(fp)
81117e9c:	e0bffc43 	ldbu	r2,-15(fp)
81117ea0:	108000b0 	cmpltui	r2,r2,2
81117ea4:	103fd71e 	bne	r2,zero,81117e04 <__reset+0xfb0f7e04>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81117ea8:	d0a06217 	ldw	r2,-32376(gp)
81117eac:	e0fffc83 	ldbu	r3,-14(fp)
81117eb0:	e13ffc03 	ldbu	r4,-16(fp)
81117eb4:	200f883a 	mov	r7,r4
81117eb8:	180d883a 	mov	r6,r3
81117ebc:	01604574 	movhi	r5,33045
81117ec0:	29797b04 	addi	r5,r5,-6676
81117ec4:	1009883a 	mov	r4,r2
81117ec8:	11213440 	call	81121344 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81117ecc:	e0bffc03 	ldbu	r2,-16(fp)
81117ed0:	10800044 	addi	r2,r2,1
81117ed4:	e0bffc05 	stb	r2,-16(fp)
81117ed8:	e0bffc03 	ldbu	r2,-16(fp)
81117edc:	10800130 	cmpltui	r2,r2,4
81117ee0:	103fc61e 	bne	r2,zero,81117dfc <__reset+0xfb0f7dfc>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117ee4:	e0bffc83 	ldbu	r2,-14(fp)
81117ee8:	10800044 	addi	r2,r2,1
81117eec:	e0bffc85 	stb	r2,-14(fp)
81117ef0:	e0fffc83 	ldbu	r3,-14(fp)
81117ef4:	e0bffcc3 	ldbu	r2,-13(fp)
81117ef8:	18bf9636 	bltu	r3,r2,81117d54 <__reset+0xfb0f7d54>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81117efc:	d0a06217 	ldw	r2,-32376(gp)
81117f00:	e0fffa03 	ldbu	r3,-24(fp)
81117f04:	180d883a 	mov	r6,r3
81117f08:	01604574 	movhi	r5,33045
81117f0c:	29798004 	addi	r5,r5,-6656
81117f10:	1009883a 	mov	r4,r2
81117f14:	11213440 	call	81121344 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81117f18:	e0bffa03 	ldbu	r2,-24(fp)
81117f1c:	10800044 	addi	r2,r2,1
81117f20:	e0bffa05 	stb	r2,-24(fp)
81117f24:	e0bffa03 	ldbu	r2,-24(fp)
81117f28:	108000b0 	cmpltui	r2,r2,2
81117f2c:	103f871e 	bne	r2,zero,81117d4c <__reset+0xfb0f7d4c>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81117f30:	d0a06217 	ldw	r2,-32376(gp)
81117f34:	100f883a 	mov	r7,r2
81117f38:	01800404 	movi	r6,16
81117f3c:	01400044 	movi	r5,1
81117f40:	01204574 	movhi	r4,33045
81117f44:	21398404 	addi	r4,r4,-6640
81117f48:	11219e00 	call	811219e0 <fwrite>
#endif


}
81117f4c:	0001883a 	nop
81117f50:	e037883a 	mov	sp,fp
81117f54:	dfc00117 	ldw	ra,4(sp)
81117f58:	df000017 	ldw	fp,0(sp)
81117f5c:	dec00204 	addi	sp,sp,8
81117f60:	f800283a 	ret

81117f64 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81117f64:	defff604 	addi	sp,sp,-40
81117f68:	de00012e 	bgeu	sp,et,81117f70 <vPrintMemmoryPattern+0xc>
81117f6c:	003b68fa 	trap	3
81117f70:	dfc00915 	stw	ra,36(sp)
81117f74:	df000815 	stw	fp,32(sp)
81117f78:	df000804 	addi	fp,sp,32
81117f7c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81117f80:	00800044 	movi	r2,1
81117f84:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81117f88:	d0a06217 	ldw	r2,-32376(gp)
81117f8c:	100f883a 	mov	r7,r2
81117f90:	018009c4 	movi	r6,39
81117f94:	01400044 	movi	r5,1
81117f98:	01204574 	movhi	r4,33045
81117f9c:	21397104 	addi	r4,r4,-6716
81117fa0:	11219e00 	call	811219e0 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81117fa4:	e03ffa05 	stb	zero,-24(fp)
81117fa8:	00007606 	br	81118184 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117fac:	e03ffc85 	stb	zero,-14(fp)
81117fb0:	00006706 	br	81118150 <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81117fb4:	e0bffc83 	ldbu	r2,-14(fp)
81117fb8:	e0ffff17 	ldw	r3,-4(fp)
81117fbc:	10809624 	muli	r2,r2,600
81117fc0:	1885883a 	add	r2,r3,r2
81117fc4:	10804304 	addi	r2,r2,268
81117fc8:	1080000b 	ldhu	r2,0(r2)
81117fcc:	10ffffcc 	andi	r3,r2,65535
81117fd0:	e0bffc83 	ldbu	r2,-14(fp)
81117fd4:	e13fff17 	ldw	r4,-4(fp)
81117fd8:	10809624 	muli	r2,r2,600
81117fdc:	2085883a 	add	r2,r4,r2
81117fe0:	10804204 	addi	r2,r2,264
81117fe4:	1080000b 	ldhu	r2,0(r2)
81117fe8:	10bfffcc 	andi	r2,r2,65535
81117fec:	1885883a 	add	r2,r3,r2
81117ff0:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81117ff4:	e0bffc83 	ldbu	r2,-14(fp)
81117ff8:	e0ffff17 	ldw	r3,-4(fp)
81117ffc:	10809624 	muli	r2,r2,600
81118000:	1885883a 	add	r2,r3,r2
81118004:	10804284 	addi	r2,r2,266
81118008:	1080000b 	ldhu	r2,0(r2)
8111800c:	10ffffcc 	andi	r3,r2,65535
81118010:	e0bffc83 	ldbu	r2,-14(fp)
81118014:	e13fff17 	ldw	r4,-4(fp)
81118018:	10809624 	muli	r2,r2,600
8111801c:	2085883a 	add	r2,r4,r2
81118020:	10804184 	addi	r2,r2,262
81118024:	1080000b 	ldhu	r2,0(r2)
81118028:	10bfffcc 	andi	r2,r2,65535
8111802c:	1887883a 	add	r3,r3,r2
81118030:	e0bffc83 	ldbu	r2,-14(fp)
81118034:	e13fff17 	ldw	r4,-4(fp)
81118038:	10809624 	muli	r2,r2,600
8111803c:	2085883a 	add	r2,r4,r2
81118040:	10804104 	addi	r2,r2,260
81118044:	1080000b 	ldhu	r2,0(r2)
81118048:	10bfffcc 	andi	r2,r2,65535
8111804c:	1885883a 	add	r2,r3,r2
81118050:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81118054:	e03ffc05 	stb	zero,-16(fp)
81118058:	00003706 	br	81118138 <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111805c:	e03ffc45 	stb	zero,-15(fp)
81118060:	00002606 	br	811180fc <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
81118064:	e0bffc43 	ldbu	r2,-15(fp)
81118068:	10000b1e 	bne	r2,zero,81118098 <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
8111806c:	e0bffc83 	ldbu	r2,-14(fp)
81118070:	e13ffc03 	ldbu	r4,-16(fp)
81118074:	e0ffff17 	ldw	r3,-4(fp)
81118078:	21000624 	muli	r4,r4,24
8111807c:	10809624 	muli	r2,r2,600
81118080:	2085883a 	add	r2,r4,r2
81118084:	1885883a 	add	r2,r3,r2
81118088:	10801b04 	addi	r2,r2,108
8111808c:	10800017 	ldw	r2,0(r2)
81118090:	e0bffb15 	stw	r2,-20(fp)
81118094:	00000a06 	br	811180c0 <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81118098:	e0bffc83 	ldbu	r2,-14(fp)
8111809c:	e13ffc03 	ldbu	r4,-16(fp)
811180a0:	e0ffff17 	ldw	r3,-4(fp)
811180a4:	21000624 	muli	r4,r4,24
811180a8:	10809624 	muli	r2,r2,600
811180ac:	2085883a 	add	r2,r4,r2
811180b0:	1885883a 	add	r2,r3,r2
811180b4:	10801e04 	addi	r2,r2,120
811180b8:	10800017 	ldw	r2,0(r2)
811180bc:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811180c0:	e0fffa03 	ldbu	r3,-24(fp)
811180c4:	e13ffc03 	ldbu	r4,-16(fp)
811180c8:	e17ffc43 	ldbu	r5,-15(fp)
811180cc:	e0bffe17 	ldw	r2,-8(fp)
811180d0:	d8800115 	stw	r2,4(sp)
811180d4:	e0bffd17 	ldw	r2,-12(fp)
811180d8:	d8800015 	stw	r2,0(sp)
811180dc:	280f883a 	mov	r7,r5
811180e0:	200d883a 	mov	r6,r4
811180e4:	e17ffb17 	ldw	r5,-20(fp)
811180e8:	1809883a 	mov	r4,r3
811180ec:	111e5200 	call	8111e520 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811180f0:	e0bffc43 	ldbu	r2,-15(fp)
811180f4:	10800044 	addi	r2,r2,1
811180f8:	e0bffc45 	stb	r2,-15(fp)
811180fc:	e0bffc43 	ldbu	r2,-15(fp)
81118100:	108000b0 	cmpltui	r2,r2,2
81118104:	103fd71e 	bne	r2,zero,81118064 <__reset+0xfb0f8064>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81118108:	d0a06217 	ldw	r2,-32376(gp)
8111810c:	e0fffc83 	ldbu	r3,-14(fp)
81118110:	e13ffc03 	ldbu	r4,-16(fp)
81118114:	200f883a 	mov	r7,r4
81118118:	180d883a 	mov	r6,r3
8111811c:	01604574 	movhi	r5,33045
81118120:	29797b04 	addi	r5,r5,-6676
81118124:	1009883a 	mov	r4,r2
81118128:	11213440 	call	81121344 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
8111812c:	e0bffc03 	ldbu	r2,-16(fp)
81118130:	10800044 	addi	r2,r2,1
81118134:	e0bffc05 	stb	r2,-16(fp)
81118138:	e0bffc03 	ldbu	r2,-16(fp)
8111813c:	10800130 	cmpltui	r2,r2,4
81118140:	103fc61e 	bne	r2,zero,8111805c <__reset+0xfb0f805c>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81118144:	e0bffc83 	ldbu	r2,-14(fp)
81118148:	10800044 	addi	r2,r2,1
8111814c:	e0bffc85 	stb	r2,-14(fp)
81118150:	e0fffc83 	ldbu	r3,-14(fp)
81118154:	e0bffcc3 	ldbu	r2,-13(fp)
81118158:	18bf9636 	bltu	r3,r2,81117fb4 <__reset+0xfb0f7fb4>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
8111815c:	d0a06217 	ldw	r2,-32376(gp)
81118160:	e0fffa03 	ldbu	r3,-24(fp)
81118164:	180d883a 	mov	r6,r3
81118168:	01604574 	movhi	r5,33045
8111816c:	29798004 	addi	r5,r5,-6656
81118170:	1009883a 	mov	r4,r2
81118174:	11213440 	call	81121344 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81118178:	e0bffa03 	ldbu	r2,-24(fp)
8111817c:	10800044 	addi	r2,r2,1
81118180:	e0bffa05 	stb	r2,-24(fp)
81118184:	e0bffa03 	ldbu	r2,-24(fp)
81118188:	108000b0 	cmpltui	r2,r2,2
8111818c:	103f871e 	bne	r2,zero,81117fac <__reset+0xfb0f7fac>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81118190:	d0a06217 	ldw	r2,-32376(gp)
81118194:	100f883a 	mov	r7,r2
81118198:	01800404 	movi	r6,16
8111819c:	01400044 	movi	r5,1
811181a0:	01204574 	movhi	r4,33045
811181a4:	21398404 	addi	r4,r4,-6640
811181a8:	11219e00 	call	811219e0 <fwrite>
#endif


}
811181ac:	0001883a 	nop
811181b0:	e037883a 	mov	sp,fp
811181b4:	dfc00117 	ldw	ra,4(sp)
811181b8:	df000017 	ldw	fp,0(sp)
811181bc:	dec00204 	addi	sp,sp,8
811181c0:	f800283a 	ret

811181c4 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
811181c4:	defffd04 	addi	sp,sp,-12
811181c8:	de00012e 	bgeu	sp,et,811181d0 <vCCDLoadDefaultValues+0xc>
811181cc:	003b68fa 	trap	3
811181d0:	dfc00215 	stw	ra,8(sp)
811181d4:	df000115 	stw	fp,4(sp)
811181d8:	df000104 	addi	fp,sp,4
811181dc:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
811181e0:	00a045b4 	movhi	r2,33046
811181e4:	109ade04 	addi	r2,r2,27512
811181e8:	10c0060b 	ldhu	r3,24(r2)
811181ec:	e0bfff17 	ldw	r2,-4(fp)
811181f0:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
811181f4:	00a045b4 	movhi	r2,33046
811181f8:	109ade04 	addi	r2,r2,27512
811181fc:	10c0050b 	ldhu	r3,20(r2)
81118200:	e0bfff17 	ldw	r2,-4(fp)
81118204:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
81118208:	00a045b4 	movhi	r2,33046
8111820c:	109ade04 	addi	r2,r2,27512
81118210:	10c0058b 	ldhu	r3,22(r2)
81118214:	e0bfff17 	ldw	r2,-4(fp)
81118218:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
8111821c:	00a045b4 	movhi	r2,33046
81118220:	109ade04 	addi	r2,r2,27512
81118224:	10c0040b 	ldhu	r3,16(r2)
81118228:	e0bfff17 	ldw	r2,-4(fp)
8111822c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
81118230:	00a045b4 	movhi	r2,33046
81118234:	109ade04 	addi	r2,r2,27512
81118238:	10c0048b 	ldhu	r3,18(r2)
8111823c:	e0bfff17 	ldw	r2,-4(fp)
81118240:	10c0000d 	sth	r3,0(r2)

#ifdef DEBUG_ON
	//fprintf(fp,"\n    i: %u ",incrementador);
	fprintf(fp,"\nusiHeight %hu\n", ccdDef->usiHeight);
81118244:	d0e06217 	ldw	r3,-32376(gp)
81118248:	e0bfff17 	ldw	r2,-4(fp)
8111824c:	1080020b 	ldhu	r2,8(r2)
81118250:	10bfffcc 	andi	r2,r2,65535
81118254:	100d883a 	mov	r6,r2
81118258:	01604574 	movhi	r5,33045
8111825c:	29798904 	addi	r5,r5,-6620
81118260:	1809883a 	mov	r4,r3
81118264:	11213440 	call	81121344 <fprintf>
	fprintf(fp,"usiOLN %hu\n", ccdDef->usiOLN);
81118268:	d0e06217 	ldw	r3,-32376(gp)
8111826c:	e0bfff17 	ldw	r2,-4(fp)
81118270:	1080010b 	ldhu	r2,4(r2)
81118274:	10bfffcc 	andi	r2,r2,65535
81118278:	100d883a 	mov	r6,r2
8111827c:	01604574 	movhi	r5,33045
81118280:	29798d04 	addi	r5,r5,-6604
81118284:	1809883a 	mov	r4,r3
81118288:	11213440 	call	81121344 <fprintf>
	fprintf(fp,"usiHalfWidth %hu\n", ccdDef->usiHalfWidth);
8111828c:	d0e06217 	ldw	r3,-32376(gp)
81118290:	e0bfff17 	ldw	r2,-4(fp)
81118294:	1080018b 	ldhu	r2,6(r2)
81118298:	10bfffcc 	andi	r2,r2,65535
8111829c:	100d883a 	mov	r6,r2
811182a0:	01604574 	movhi	r5,33045
811182a4:	29799004 	addi	r5,r5,-6592
811182a8:	1809883a 	mov	r4,r3
811182ac:	11213440 	call	81121344 <fprintf>
	fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
811182b0:	d0e06217 	ldw	r3,-32376(gp)
811182b4:	e0bfff17 	ldw	r2,-4(fp)
811182b8:	1080008b 	ldhu	r2,2(r2)
811182bc:	10bfffcc 	andi	r2,r2,65535
811182c0:	100d883a 	mov	r6,r2
811182c4:	01604574 	movhi	r5,33045
811182c8:	29799504 	addi	r5,r5,-6572
811182cc:	1809883a 	mov	r4,r3
811182d0:	11213440 	call	81121344 <fprintf>
	fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
811182d4:	d0e06217 	ldw	r3,-32376(gp)
811182d8:	e0bfff17 	ldw	r2,-4(fp)
811182dc:	1080000b 	ldhu	r2,0(r2)
811182e0:	10bfffcc 	andi	r2,r2,65535
811182e4:	100d883a 	mov	r6,r2
811182e8:	01604574 	movhi	r5,33045
811182ec:	29799a04 	addi	r5,r5,-6552
811182f0:	1809883a 	mov	r4,r3
811182f4:	11213440 	call	81121344 <fprintf>
#endif

}
811182f8:	0001883a 	nop
811182fc:	e037883a 	mov	sp,fp
81118300:	dfc00117 	ldw	ra,4(sp)
81118304:	df000017 	ldw	fp,0(sp)
81118308:	dec00204 	addi	sp,sp,8
8111830c:	f800283a 	ret

81118310 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81118310:	defff904 	addi	sp,sp,-28
81118314:	de00012e 	bgeu	sp,et,8111831c <vCCDChangeValues+0xc>
81118318:	003b68fa 	trap	3
8111831c:	df000615 	stw	fp,24(sp)
81118320:	df000604 	addi	fp,sp,24
81118324:	e13ffa15 	stw	r4,-24(fp)
81118328:	2811883a 	mov	r8,r5
8111832c:	300b883a 	mov	r5,r6
81118330:	3809883a 	mov	r4,r7
81118334:	e0c00117 	ldw	r3,4(fp)
81118338:	e0800217 	ldw	r2,8(fp)
8111833c:	e23ffb0d 	sth	r8,-20(fp)
81118340:	e17ffc0d 	sth	r5,-16(fp)
81118344:	e13ffd0d 	sth	r4,-12(fp)
81118348:	e0fffe0d 	sth	r3,-8(fp)
8111834c:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81118350:	e0bffa17 	ldw	r2,-24(fp)
81118354:	e0fffb0b 	ldhu	r3,-20(fp)
81118358:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
8111835c:	e0bffa17 	ldw	r2,-24(fp)
81118360:	e0fffc0b 	ldhu	r3,-16(fp)
81118364:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81118368:	e0bffa17 	ldw	r2,-24(fp)
8111836c:	e0fffd0b 	ldhu	r3,-12(fp)
81118370:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81118374:	e0bffa17 	ldw	r2,-24(fp)
81118378:	e0fffe0b 	ldhu	r3,-8(fp)
8111837c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81118380:	e0bffa17 	ldw	r2,-24(fp)
81118384:	e0ffff0b 	ldhu	r3,-4(fp)
81118388:	10c0000d 	sth	r3,0(r2)
}
8111838c:	0001883a 	nop
81118390:	e037883a 	mov	sp,fp
81118394:	df000017 	ldw	fp,0(sp)
81118398:	dec00104 	addi	sp,sp,4
8111839c:	f800283a 	ret

811183a0 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
811183a0:	defff904 	addi	sp,sp,-28
811183a4:	de00012e 	bgeu	sp,et,811183ac <bSendUART128v2+0xc>
811183a8:	003b68fa 	trap	3
811183ac:	dfc00615 	stw	ra,24(sp)
811183b0:	df000515 	stw	fp,20(sp)
811183b4:	df000504 	addi	fp,sp,20
811183b8:	e13ffe15 	stw	r4,-8(fp)
811183bc:	2805883a 	mov	r2,r5
811183c0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
811183c4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811183c8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811183cc:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811183d0:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811183d4:	d0a06317 	ldw	r2,-32372(gp)
811183d8:	e0fffd04 	addi	r3,fp,-12
811183dc:	180d883a 	mov	r6,r3
811183e0:	01400504 	movi	r5,20
811183e4:	1009883a 	mov	r4,r2
811183e8:	113e87c0 	call	8113e87c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811183ec:	e0bffd03 	ldbu	r2,-12(fp)
811183f0:	10803fcc 	andi	r2,r2,255
811183f4:	10000326 	beq	r2,zero,81118404 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811183f8:	111bd7c0 	call	8111bd7c <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
811183fc:	e0bffc17 	ldw	r2,-16(fp)
81118400:	00009e06 	br	8111867c <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81118404:	d0a06e17 	ldw	r2,-32328(gp)
81118408:	e0fffd04 	addi	r3,fp,-12
8111840c:	180d883a 	mov	r6,r3
81118410:	01400104 	movi	r5,4
81118414:	1009883a 	mov	r4,r2
81118418:	113c8700 	call	8113c870 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111841c:	e0bffd03 	ldbu	r2,-12(fp)
81118420:	10803fcc 	andi	r2,r2,255
81118424:	10001126 	beq	r2,zero,8111846c <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81118428:	d0a06217 	ldw	r2,-32376(gp)
8111842c:	100f883a 	mov	r7,r2
81118430:	01801484 	movi	r6,82
81118434:	01400044 	movi	r5,1
81118438:	01204574 	movhi	r4,33045
8111843c:	21399f04 	addi	r4,r4,-6532
81118440:	11219e00 	call	811219e0 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81118444:	d0a06317 	ldw	r2,-32372(gp)
81118448:	1009883a 	mov	r4,r2
8111844c:	113ec040 	call	8113ec04 <OSSemPost>
81118450:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81118454:	e0bffd03 	ldbu	r2,-12(fp)
81118458:	10803fcc 	andi	r2,r2,255
8111845c:	10000126 	beq	r2,zero,81118464 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81118460:	111bd140 	call	8111bd14 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81118464:	e0bffc17 	ldw	r2,-16(fp)
81118468:	00008406 	br	8111867c <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111846c:	e03ffb05 	stb	zero,-20(fp)
81118470:	00004306 	br	81118580 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81118474:	e0fffb03 	ldbu	r3,-20(fp)
81118478:	00a045b4 	movhi	r2,33046
8111847c:	10bafc04 	addi	r2,r2,-5136
81118480:	18c7883a 	add	r3,r3,r3
81118484:	18c7883a 	add	r3,r3,r3
81118488:	10c5883a 	add	r2,r2,r3
8111848c:	10800017 	ldw	r2,0(r2)
81118490:	1000381e 	bne	r2,zero,81118574 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81118494:	e0bffb03 	ldbu	r2,-20(fp)
81118498:	10c02324 	muli	r3,r2,140
8111849c:	00a045b4 	movhi	r2,33046
811184a0:	10bb1a04 	addi	r2,r2,-5016
811184a4:	1885883a 	add	r2,r3,r2
811184a8:	01802004 	movi	r6,128
811184ac:	000b883a 	mov	r5,zero
811184b0:	1009883a 	mov	r4,r2
811184b4:	11225440 	call	81122544 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
811184b8:	e0bffb03 	ldbu	r2,-20(fp)
811184bc:	10c02324 	muli	r3,r2,140
811184c0:	00a045b4 	movhi	r2,33046
811184c4:	10bb1a04 	addi	r2,r2,-5016
811184c8:	1885883a 	add	r2,r3,r2
811184cc:	01801fc4 	movi	r6,127
811184d0:	e17ffe17 	ldw	r5,-8(fp)
811184d4:	1009883a 	mov	r4,r2
811184d8:	11223f40 	call	811223f4 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
811184dc:	e13ffb03 	ldbu	r4,-20(fp)
811184e0:	e0ffff0b 	ldhu	r3,-4(fp)
811184e4:	00a045b4 	movhi	r2,33046
811184e8:	10bb1a04 	addi	r2,r2,-5016
811184ec:	21002324 	muli	r4,r4,140
811184f0:	1105883a 	add	r2,r2,r4
811184f4:	10802104 	addi	r2,r2,132
811184f8:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
811184fc:	e0fffb03 	ldbu	r3,-20(fp)
81118500:	00a045b4 	movhi	r2,33046
81118504:	10bb1a04 	addi	r2,r2,-5016
81118508:	18c02324 	muli	r3,r3,140
8111850c:	10c5883a 	add	r2,r2,r3
81118510:	10802204 	addi	r2,r2,136
81118514:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81118518:	e0fffb03 	ldbu	r3,-20(fp)
8111851c:	00a045b4 	movhi	r2,33046
81118520:	10bb1a04 	addi	r2,r2,-5016
81118524:	18c02324 	muli	r3,r3,140
81118528:	10c5883a 	add	r2,r2,r3
8111852c:	10802184 	addi	r2,r2,134
81118530:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81118534:	e0fffb03 	ldbu	r3,-20(fp)
81118538:	00a045b4 	movhi	r2,33046
8111853c:	10bb1a04 	addi	r2,r2,-5016
81118540:	18c02324 	muli	r3,r3,140
81118544:	10c5883a 	add	r2,r2,r3
81118548:	10802004 	addi	r2,r2,128
8111854c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81118550:	e0fffb03 	ldbu	r3,-20(fp)
81118554:	00a045b4 	movhi	r2,33046
81118558:	10bafc04 	addi	r2,r2,-5136
8111855c:	18c7883a 	add	r3,r3,r3
81118560:	18c7883a 	add	r3,r3,r3
81118564:	10c5883a 	add	r2,r2,r3
81118568:	00c00044 	movi	r3,1
8111856c:	10c00015 	stw	r3,0(r2)
			break;
81118570:	00000606 	br	8111858c <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81118574:	e0bffb03 	ldbu	r2,-20(fp)
81118578:	10800044 	addi	r2,r2,1
8111857c:	e0bffb05 	stb	r2,-20(fp)
81118580:	e0bffb03 	ldbu	r2,-20(fp)
81118584:	108001b0 	cmpltui	r2,r2,6
81118588:	103fba1e 	bne	r2,zero,81118474 <__reset+0xfb0f8474>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
8111858c:	e0bffb03 	ldbu	r2,-20(fp)
81118590:	108001b0 	cmpltui	r2,r2,6
81118594:	1000091e 	bne	r2,zero,811185bc <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81118598:	d0a06317 	ldw	r2,-32372(gp)
8111859c:	1009883a 	mov	r4,r2
811185a0:	113ec040 	call	8113ec04 <OSSemPost>
811185a4:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
811185a8:	d0a06e17 	ldw	r2,-32328(gp)
811185ac:	1009883a 	mov	r4,r2
811185b0:	113ce140 	call	8113ce14 <OSMutexPost>
		return bSuccessL;
811185b4:	e0bffc17 	ldw	r2,-16(fp)
811185b8:	00003006 	br	8111867c <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
811185bc:	00800044 	movi	r2,1
811185c0:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
811185c4:	d0a07543 	ldbu	r2,-32299(gp)
811185c8:	10bfffc4 	addi	r2,r2,-1
811185cc:	d0a07545 	stb	r2,-32299(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811185d0:	d0a07417 	ldw	r2,-32304(gp)
811185d4:	e0fffd04 	addi	r3,fp,-12
811185d8:	180d883a 	mov	r6,r3
811185dc:	01400084 	movi	r5,2
811185e0:	1009883a 	mov	r4,r2
811185e4:	113c8700 	call	8113c870 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811185e8:	e0bffd03 	ldbu	r2,-12(fp)
811185ec:	10803fcc 	andi	r2,r2,255
811185f0:	10000c26 	beq	r2,zero,81118624 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
811185f4:	d0a06217 	ldw	r2,-32376(gp)
811185f8:	100f883a 	mov	r7,r2
811185fc:	01801c04 	movi	r6,112
81118600:	01400044 	movi	r5,1
81118604:	01204574 	movhi	r4,33045
81118608:	2139b404 	addi	r4,r4,-6448
8111860c:	11219e00 	call	811219e0 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81118610:	d0a06e17 	ldw	r2,-32328(gp)
81118614:	1009883a 	mov	r4,r2
81118618:	113ce140 	call	8113ce14 <OSMutexPost>
		return bSuccessL;
8111861c:	e0bffc17 	ldw	r2,-16(fp)
81118620:	00001606 	br	8111867c <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81118624:	e0bffb03 	ldbu	r2,-20(fp)
81118628:	10c02324 	muli	r3,r2,140
8111862c:	00a045b4 	movhi	r2,33046
81118630:	10bb1a04 	addi	r2,r2,-5016
81118634:	1885883a 	add	r2,r3,r2
81118638:	1009883a 	mov	r4,r2
8111863c:	11229900 	call	81122990 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81118640:	e0fffb03 	ldbu	r3,-20(fp)
81118644:	00a045b4 	movhi	r2,33046
81118648:	10bb1a04 	addi	r2,r2,-5016
8111864c:	18c02324 	muli	r3,r3,140
81118650:	10c5883a 	add	r2,r2,r3
81118654:	10802004 	addi	r2,r2,128
81118658:	00c00044 	movi	r3,1
8111865c:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81118660:	d0a07417 	ldw	r2,-32304(gp)
81118664:	1009883a 	mov	r4,r2
81118668:	113ce140 	call	8113ce14 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
8111866c:	d0a06e17 	ldw	r2,-32328(gp)
81118670:	1009883a 	mov	r4,r2
81118674:	113ce140 	call	8113ce14 <OSMutexPost>

	return bSuccessL;
81118678:	e0bffc17 	ldw	r2,-16(fp)
}
8111867c:	e037883a 	mov	sp,fp
81118680:	dfc00117 	ldw	ra,4(sp)
81118684:	df000017 	ldw	fp,0(sp)
81118688:	dec00204 	addi	sp,sp,8
8111868c:	f800283a 	ret

81118690 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81118690:	defff904 	addi	sp,sp,-28
81118694:	de00012e 	bgeu	sp,et,8111869c <bSendUART64v2+0xc>
81118698:	003b68fa 	trap	3
8111869c:	dfc00615 	stw	ra,24(sp)
811186a0:	df000515 	stw	fp,20(sp)
811186a4:	df000504 	addi	fp,sp,20
811186a8:	e13ffe15 	stw	r4,-8(fp)
811186ac:	2805883a 	mov	r2,r5
811186b0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
811186b4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811186b8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811186bc:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811186c0:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811186c4:	d0a05e17 	ldw	r2,-32392(gp)
811186c8:	e0fffd04 	addi	r3,fp,-12
811186cc:	180d883a 	mov	r6,r3
811186d0:	01400504 	movi	r5,20
811186d4:	1009883a 	mov	r4,r2
811186d8:	113e87c0 	call	8113e87c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811186dc:	e0bffd03 	ldbu	r2,-12(fp)
811186e0:	10803fcc 	andi	r2,r2,255
811186e4:	10000326 	beq	r2,zero,811186f4 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811186e8:	111bde40 	call	8111bde4 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
811186ec:	e0bffc17 	ldw	r2,-16(fp)
811186f0:	0000a006 	br	81118974 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811186f4:	d0a07117 	ldw	r2,-32316(gp)
811186f8:	e0fffd04 	addi	r3,fp,-12
811186fc:	180d883a 	mov	r6,r3
81118700:	01400104 	movi	r5,4
81118704:	1009883a 	mov	r4,r2
81118708:	113c8700 	call	8113c870 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111870c:	e0bffd03 	ldbu	r2,-12(fp)
81118710:	10803fcc 	andi	r2,r2,255
81118714:	10001126 	beq	r2,zero,8111875c <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81118718:	d0a06217 	ldw	r2,-32376(gp)
8111871c:	100f883a 	mov	r7,r2
81118720:	018013c4 	movi	r6,79
81118724:	01400044 	movi	r5,1
81118728:	01204574 	movhi	r4,33045
8111872c:	2139d104 	addi	r4,r4,-6332
81118730:	11219e00 	call	811219e0 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81118734:	d0a05e17 	ldw	r2,-32392(gp)
81118738:	1009883a 	mov	r4,r2
8111873c:	113ec040 	call	8113ec04 <OSSemPost>
81118740:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81118744:	e0bffd03 	ldbu	r2,-12(fp)
81118748:	10803fcc 	andi	r2,r2,255
8111874c:	10000126 	beq	r2,zero,81118754 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81118750:	111bcac0 	call	8111bcac <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81118754:	e0bffc17 	ldw	r2,-16(fp)
81118758:	00008606 	br	81118974 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8111875c:	e03ffb05 	stb	zero,-20(fp)
81118760:	00004506 	br	81118878 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81118764:	e0fffb03 	ldbu	r3,-20(fp)
81118768:	00a045b4 	movhi	r2,33046
8111876c:	10bafc04 	addi	r2,r2,-5136
81118770:	18c00184 	addi	r3,r3,6
81118774:	18c7883a 	add	r3,r3,r3
81118778:	18c7883a 	add	r3,r3,r3
8111877c:	10c5883a 	add	r2,r2,r3
81118780:	10800017 	ldw	r2,0(r2)
81118784:	1000391e 	bne	r2,zero,8111886c <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81118788:	e0bffb03 	ldbu	r2,-20(fp)
8111878c:	10c01324 	muli	r3,r2,76
81118790:	00a04574 	movhi	r2,33045
81118794:	1096c004 	addi	r2,r2,23296
81118798:	1885883a 	add	r2,r3,r2
8111879c:	01801004 	movi	r6,64
811187a0:	000b883a 	mov	r5,zero
811187a4:	1009883a 	mov	r4,r2
811187a8:	11225440 	call	81122544 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
811187ac:	e0bffb03 	ldbu	r2,-20(fp)
811187b0:	10c01324 	muli	r3,r2,76
811187b4:	00a04574 	movhi	r2,33045
811187b8:	1096c004 	addi	r2,r2,23296
811187bc:	1885883a 	add	r2,r3,r2
811187c0:	01800fc4 	movi	r6,63
811187c4:	e17ffe17 	ldw	r5,-8(fp)
811187c8:	1009883a 	mov	r4,r2
811187cc:	11223f40 	call	811223f4 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
811187d0:	e13ffb03 	ldbu	r4,-20(fp)
811187d4:	e0ffff0b 	ldhu	r3,-4(fp)
811187d8:	00a04574 	movhi	r2,33045
811187dc:	1096c004 	addi	r2,r2,23296
811187e0:	21001324 	muli	r4,r4,76
811187e4:	1105883a 	add	r2,r2,r4
811187e8:	10801104 	addi	r2,r2,68
811187ec:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
811187f0:	e0fffb03 	ldbu	r3,-20(fp)
811187f4:	00a04574 	movhi	r2,33045
811187f8:	1096c004 	addi	r2,r2,23296
811187fc:	18c01324 	muli	r3,r3,76
81118800:	10c5883a 	add	r2,r2,r3
81118804:	10801204 	addi	r2,r2,72
81118808:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
8111880c:	e0fffb03 	ldbu	r3,-20(fp)
81118810:	00a04574 	movhi	r2,33045
81118814:	1096c004 	addi	r2,r2,23296
81118818:	18c01324 	muli	r3,r3,76
8111881c:	10c5883a 	add	r2,r2,r3
81118820:	10801184 	addi	r2,r2,70
81118824:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81118828:	e0fffb03 	ldbu	r3,-20(fp)
8111882c:	00a04574 	movhi	r2,33045
81118830:	1096c004 	addi	r2,r2,23296
81118834:	18c01324 	muli	r3,r3,76
81118838:	10c5883a 	add	r2,r2,r3
8111883c:	10801004 	addi	r2,r2,64
81118840:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81118844:	e0fffb03 	ldbu	r3,-20(fp)
81118848:	00a045b4 	movhi	r2,33046
8111884c:	10bafc04 	addi	r2,r2,-5136
81118850:	18c00184 	addi	r3,r3,6
81118854:	18c7883a 	add	r3,r3,r3
81118858:	18c7883a 	add	r3,r3,r3
8111885c:	10c5883a 	add	r2,r2,r3
81118860:	00c00044 	movi	r3,1
81118864:	10c00015 	stw	r3,0(r2)
			break;
81118868:	00000606 	br	81118884 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8111886c:	e0bffb03 	ldbu	r2,-20(fp)
81118870:	10800044 	addi	r2,r2,1
81118874:	e0bffb05 	stb	r2,-20(fp)
81118878:	e0bffb03 	ldbu	r2,-20(fp)
8111887c:	10800230 	cmpltui	r2,r2,8
81118880:	103fb81e 	bne	r2,zero,81118764 <__reset+0xfb0f8764>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81118884:	e0bffb03 	ldbu	r2,-20(fp)
81118888:	10800230 	cmpltui	r2,r2,8
8111888c:	1000091e 	bne	r2,zero,811188b4 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81118890:	d0a05e17 	ldw	r2,-32392(gp)
81118894:	1009883a 	mov	r4,r2
81118898:	113ec040 	call	8113ec04 <OSSemPost>
8111889c:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
811188a0:	d0a07117 	ldw	r2,-32316(gp)
811188a4:	1009883a 	mov	r4,r2
811188a8:	113ce140 	call	8113ce14 <OSMutexPost>
		return bSuccessL;
811188ac:	e0bffc17 	ldw	r2,-16(fp)
811188b0:	00003006 	br	81118974 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
811188b4:	00800044 	movi	r2,1
811188b8:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
811188bc:	d0a07503 	ldbu	r2,-32300(gp)
811188c0:	10bfffc4 	addi	r2,r2,-1
811188c4:	d0a07505 	stb	r2,-32300(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811188c8:	d0a07417 	ldw	r2,-32304(gp)
811188cc:	e0fffd04 	addi	r3,fp,-12
811188d0:	180d883a 	mov	r6,r3
811188d4:	01400084 	movi	r5,2
811188d8:	1009883a 	mov	r4,r2
811188dc:	113c8700 	call	8113c870 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811188e0:	e0bffd03 	ldbu	r2,-12(fp)
811188e4:	10803fcc 	andi	r2,r2,255
811188e8:	10000c26 	beq	r2,zero,8111891c <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
811188ec:	d0a06217 	ldw	r2,-32376(gp)
811188f0:	100f883a 	mov	r7,r2
811188f4:	01801bc4 	movi	r6,111
811188f8:	01400044 	movi	r5,1
811188fc:	01204574 	movhi	r4,33045
81118900:	2139e504 	addi	r4,r4,-6252
81118904:	11219e00 	call	811219e0 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81118908:	d0a07117 	ldw	r2,-32316(gp)
8111890c:	1009883a 	mov	r4,r2
81118910:	113ce140 	call	8113ce14 <OSMutexPost>
		return bSuccessL;
81118914:	e0bffc17 	ldw	r2,-16(fp)
81118918:	00001606 	br	81118974 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
8111891c:	e0bffb03 	ldbu	r2,-20(fp)
81118920:	10c01324 	muli	r3,r2,76
81118924:	00a04574 	movhi	r2,33045
81118928:	1096c004 	addi	r2,r2,23296
8111892c:	1885883a 	add	r2,r3,r2
81118930:	1009883a 	mov	r4,r2
81118934:	11229900 	call	81122990 <puts>
	xBuffer64[ucIL].bSent = TRUE;
81118938:	e0fffb03 	ldbu	r3,-20(fp)
8111893c:	00a04574 	movhi	r2,33045
81118940:	1096c004 	addi	r2,r2,23296
81118944:	18c01324 	muli	r3,r3,76
81118948:	10c5883a 	add	r2,r2,r3
8111894c:	10801004 	addi	r2,r2,64
81118950:	00c00044 	movi	r3,1
81118954:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81118958:	d0a07417 	ldw	r2,-32304(gp)
8111895c:	1009883a 	mov	r4,r2
81118960:	113ce140 	call	8113ce14 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81118964:	d0a07117 	ldw	r2,-32316(gp)
81118968:	1009883a 	mov	r4,r2
8111896c:	113ce140 	call	8113ce14 <OSMutexPost>

	return bSuccessL;
81118970:	e0bffc17 	ldw	r2,-16(fp)
}
81118974:	e037883a 	mov	sp,fp
81118978:	dfc00117 	ldw	ra,4(sp)
8111897c:	df000017 	ldw	fp,0(sp)
81118980:	dec00204 	addi	sp,sp,8
81118984:	f800283a 	ret

81118988 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81118988:	defff904 	addi	sp,sp,-28
8111898c:	de00012e 	bgeu	sp,et,81118994 <bSendUART32v2+0xc>
81118990:	003b68fa 	trap	3
81118994:	dfc00615 	stw	ra,24(sp)
81118998:	df000515 	stw	fp,20(sp)
8111899c:	df000504 	addi	fp,sp,20
811189a0:	e13ffe15 	stw	r4,-8(fp)
811189a4:	2805883a 	mov	r2,r5
811189a8:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
811189ac:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811189b0:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811189b4:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811189b8:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811189bc:	d0a06f17 	ldw	r2,-32324(gp)
811189c0:	e0fffd04 	addi	r3,fp,-12
811189c4:	180d883a 	mov	r6,r3
811189c8:	01400504 	movi	r5,20
811189cc:	1009883a 	mov	r4,r2
811189d0:	113e87c0 	call	8113e87c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811189d4:	e0bffd03 	ldbu	r2,-12(fp)
811189d8:	10803fcc 	andi	r2,r2,255
811189dc:	10000326 	beq	r2,zero,811189ec <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811189e0:	111be4c0 	call	8111be4c <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
811189e4:	e0bffc17 	ldw	r2,-16(fp)
811189e8:	0000a006 	br	81118c6c <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811189ec:	d0a06c17 	ldw	r2,-32336(gp)
811189f0:	e0fffd04 	addi	r3,fp,-12
811189f4:	180d883a 	mov	r6,r3
811189f8:	01400104 	movi	r5,4
811189fc:	1009883a 	mov	r4,r2
81118a00:	113c8700 	call	8113c870 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118a04:	e0bffd03 	ldbu	r2,-12(fp)
81118a08:	10803fcc 	andi	r2,r2,255
81118a0c:	10001126 	beq	r2,zero,81118a54 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81118a10:	d0a06217 	ldw	r2,-32376(gp)
81118a14:	100f883a 	mov	r7,r2
81118a18:	018013c4 	movi	r6,79
81118a1c:	01400044 	movi	r5,1
81118a20:	01204574 	movhi	r4,33045
81118a24:	213a0104 	addi	r4,r4,-6140
81118a28:	11219e00 	call	811219e0 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81118a2c:	d0a06f17 	ldw	r2,-32324(gp)
81118a30:	1009883a 	mov	r4,r2
81118a34:	113ec040 	call	8113ec04 <OSSemPost>
81118a38:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81118a3c:	e0bffd03 	ldbu	r2,-12(fp)
81118a40:	10803fcc 	andi	r2,r2,255
81118a44:	10000126 	beq	r2,zero,81118a4c <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81118a48:	111bc440 	call	8111bc44 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81118a4c:	e0bffc17 	ldw	r2,-16(fp)
81118a50:	00008606 	br	81118c6c <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81118a54:	e03ffb05 	stb	zero,-20(fp)
81118a58:	00004506 	br	81118b70 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81118a5c:	e0fffb03 	ldbu	r3,-20(fp)
81118a60:	00a045b4 	movhi	r2,33046
81118a64:	10bafc04 	addi	r2,r2,-5136
81118a68:	18c00384 	addi	r3,r3,14
81118a6c:	18c7883a 	add	r3,r3,r3
81118a70:	18c7883a 	add	r3,r3,r3
81118a74:	10c5883a 	add	r2,r2,r3
81118a78:	10800017 	ldw	r2,0(r2)
81118a7c:	1000391e 	bne	r2,zero,81118b64 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81118a80:	e0bffb03 	ldbu	r2,-20(fp)
81118a84:	10c00b24 	muli	r3,r2,44
81118a88:	00a045b4 	movhi	r2,33046
81118a8c:	10a87c04 	addi	r2,r2,-24080
81118a90:	1885883a 	add	r2,r3,r2
81118a94:	01800804 	movi	r6,32
81118a98:	000b883a 	mov	r5,zero
81118a9c:	1009883a 	mov	r4,r2
81118aa0:	11225440 	call	81122544 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81118aa4:	e0bffb03 	ldbu	r2,-20(fp)
81118aa8:	10c00b24 	muli	r3,r2,44
81118aac:	00a045b4 	movhi	r2,33046
81118ab0:	10a87c04 	addi	r2,r2,-24080
81118ab4:	1885883a 	add	r2,r3,r2
81118ab8:	018007c4 	movi	r6,31
81118abc:	e17ffe17 	ldw	r5,-8(fp)
81118ac0:	1009883a 	mov	r4,r2
81118ac4:	11223f40 	call	811223f4 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81118ac8:	e13ffb03 	ldbu	r4,-20(fp)
81118acc:	e0ffff0b 	ldhu	r3,-4(fp)
81118ad0:	00a045b4 	movhi	r2,33046
81118ad4:	10a87c04 	addi	r2,r2,-24080
81118ad8:	21000b24 	muli	r4,r4,44
81118adc:	1105883a 	add	r2,r2,r4
81118ae0:	10800904 	addi	r2,r2,36
81118ae4:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81118ae8:	e0fffb03 	ldbu	r3,-20(fp)
81118aec:	00a045b4 	movhi	r2,33046
81118af0:	10a87c04 	addi	r2,r2,-24080
81118af4:	18c00b24 	muli	r3,r3,44
81118af8:	10c5883a 	add	r2,r2,r3
81118afc:	10800a04 	addi	r2,r2,40
81118b00:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81118b04:	e0fffb03 	ldbu	r3,-20(fp)
81118b08:	00a045b4 	movhi	r2,33046
81118b0c:	10a87c04 	addi	r2,r2,-24080
81118b10:	18c00b24 	muli	r3,r3,44
81118b14:	10c5883a 	add	r2,r2,r3
81118b18:	10800984 	addi	r2,r2,38
81118b1c:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81118b20:	e0fffb03 	ldbu	r3,-20(fp)
81118b24:	00a045b4 	movhi	r2,33046
81118b28:	10a87c04 	addi	r2,r2,-24080
81118b2c:	18c00b24 	muli	r3,r3,44
81118b30:	10c5883a 	add	r2,r2,r3
81118b34:	10800804 	addi	r2,r2,32
81118b38:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81118b3c:	e0fffb03 	ldbu	r3,-20(fp)
81118b40:	00a045b4 	movhi	r2,33046
81118b44:	10bafc04 	addi	r2,r2,-5136
81118b48:	18c00384 	addi	r3,r3,14
81118b4c:	18c7883a 	add	r3,r3,r3
81118b50:	18c7883a 	add	r3,r3,r3
81118b54:	10c5883a 	add	r2,r2,r3
81118b58:	00c00044 	movi	r3,1
81118b5c:	10c00015 	stw	r3,0(r2)
			break;
81118b60:	00000606 	br	81118b7c <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81118b64:	e0bffb03 	ldbu	r2,-20(fp)
81118b68:	10800044 	addi	r2,r2,1
81118b6c:	e0bffb05 	stb	r2,-20(fp)
81118b70:	e0bffb03 	ldbu	r2,-20(fp)
81118b74:	10800230 	cmpltui	r2,r2,8
81118b78:	103fb81e 	bne	r2,zero,81118a5c <__reset+0xfb0f8a5c>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81118b7c:	e0bffb03 	ldbu	r2,-20(fp)
81118b80:	10800230 	cmpltui	r2,r2,8
81118b84:	1000091e 	bne	r2,zero,81118bac <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81118b88:	d0a06f17 	ldw	r2,-32324(gp)
81118b8c:	1009883a 	mov	r4,r2
81118b90:	113ec040 	call	8113ec04 <OSSemPost>
81118b94:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81118b98:	d0a06c17 	ldw	r2,-32336(gp)
81118b9c:	1009883a 	mov	r4,r2
81118ba0:	113ce140 	call	8113ce14 <OSMutexPost>
		return bSuccessL;
81118ba4:	e0bffc17 	ldw	r2,-16(fp)
81118ba8:	00003006 	br	81118c6c <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81118bac:	00800044 	movi	r2,1
81118bb0:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81118bb4:	d0a06883 	ldbu	r2,-32350(gp)
81118bb8:	10bfffc4 	addi	r2,r2,-1
81118bbc:	d0a06885 	stb	r2,-32350(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81118bc0:	d0a07417 	ldw	r2,-32304(gp)
81118bc4:	e0fffd04 	addi	r3,fp,-12
81118bc8:	180d883a 	mov	r6,r3
81118bcc:	01400084 	movi	r5,2
81118bd0:	1009883a 	mov	r4,r2
81118bd4:	113c8700 	call	8113c870 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118bd8:	e0bffd03 	ldbu	r2,-12(fp)
81118bdc:	10803fcc 	andi	r2,r2,255
81118be0:	10000c26 	beq	r2,zero,81118c14 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81118be4:	d0a06217 	ldw	r2,-32376(gp)
81118be8:	100f883a 	mov	r7,r2
81118bec:	01801bc4 	movi	r6,111
81118bf0:	01400044 	movi	r5,1
81118bf4:	01204574 	movhi	r4,33045
81118bf8:	213a1504 	addi	r4,r4,-6060
81118bfc:	11219e00 	call	811219e0 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81118c00:	d0a06c17 	ldw	r2,-32336(gp)
81118c04:	1009883a 	mov	r4,r2
81118c08:	113ce140 	call	8113ce14 <OSMutexPost>
		return bSuccessL;
81118c0c:	e0bffc17 	ldw	r2,-16(fp)
81118c10:	00001606 	br	81118c6c <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81118c14:	e0bffb03 	ldbu	r2,-20(fp)
81118c18:	10c00b24 	muli	r3,r2,44
81118c1c:	00a045b4 	movhi	r2,33046
81118c20:	10a87c04 	addi	r2,r2,-24080
81118c24:	1885883a 	add	r2,r3,r2
81118c28:	1009883a 	mov	r4,r2
81118c2c:	11229900 	call	81122990 <puts>
	xBuffer32[ucIL].bSent = TRUE;
81118c30:	e0fffb03 	ldbu	r3,-20(fp)
81118c34:	00a045b4 	movhi	r2,33046
81118c38:	10a87c04 	addi	r2,r2,-24080
81118c3c:	18c00b24 	muli	r3,r3,44
81118c40:	10c5883a 	add	r2,r2,r3
81118c44:	10800804 	addi	r2,r2,32
81118c48:	00c00044 	movi	r3,1
81118c4c:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81118c50:	d0a07417 	ldw	r2,-32304(gp)
81118c54:	1009883a 	mov	r4,r2
81118c58:	113ce140 	call	8113ce14 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81118c5c:	d0a06c17 	ldw	r2,-32336(gp)
81118c60:	1009883a 	mov	r4,r2
81118c64:	113ce140 	call	8113ce14 <OSMutexPost>

	return bSuccessL;
81118c68:	e0bffc17 	ldw	r2,-16(fp)
}
81118c6c:	e037883a 	mov	sp,fp
81118c70:	dfc00117 	ldw	ra,4(sp)
81118c74:	df000017 	ldw	fp,0(sp)
81118c78:	dec00204 	addi	sp,sp,8
81118c7c:	f800283a 	ret

81118c80 <vSendEthConf>:


void vSendEthConf ( void ) {
81118c80:	deffc304 	addi	sp,sp,-244
81118c84:	de00012e 	bgeu	sp,et,81118c8c <vSendEthConf+0xc>
81118c88:	003b68fa 	trap	3
81118c8c:	dfc03c15 	stw	ra,240(sp)
81118c90:	df003b15 	stw	fp,236(sp)
81118c94:	dd403a15 	stw	r21,232(sp)
81118c98:	dd003915 	stw	r20,228(sp)
81118c9c:	dcc03815 	stw	r19,224(sp)
81118ca0:	dc803715 	stw	r18,220(sp)
81118ca4:	dc403615 	stw	r17,216(sp)
81118ca8:	dc003515 	stw	r16,212(sp)
81118cac:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
81118cb0:	e03fd98d 	sth	zero,-154(fp)
81118cb4:	e03fda0d 	sth	zero,-152(fp)
81118cb8:	e0bfda84 	addi	r2,fp,-150
81118cbc:	00c01f04 	movi	r3,124
81118cc0:	180d883a 	mov	r6,r3
81118cc4:	000b883a 	mov	r5,zero
81118cc8:	1009883a 	mov	r4,r2
81118ccc:	11225440 	call	81122544 <memset>
    unsigned char crc = 0;
81118cd0:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81118cd4:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118cd8:	11192400 	call	81119240 <usiGetIdCMD>
81118cdc:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118ce0:	e57fd90b 	ldhu	r21,-156(fp)
81118ce4:	00a045b4 	movhi	r2,33046
81118ce8:	109aef04 	addi	r2,r2,27580
81118cec:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118cf0:	00a045b4 	movhi	r2,33046
81118cf4:	109aef04 	addi	r2,r2,27580
81118cf8:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118cfc:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118d00:	00a045b4 	movhi	r2,33046
81118d04:	109aef04 	addi	r2,r2,27580
81118d08:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d0c:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118d10:	00a045b4 	movhi	r2,33046
81118d14:	109aef04 	addi	r2,r2,27580
81118d18:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d1c:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118d20:	00a045b4 	movhi	r2,33046
81118d24:	109aef04 	addi	r2,r2,27580
81118d28:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d2c:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118d30:	00a045b4 	movhi	r2,33046
81118d34:	109aef04 	addi	r2,r2,27580
81118d38:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d3c:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118d40:	00a045b4 	movhi	r2,33046
81118d44:	109aef04 	addi	r2,r2,27580
81118d48:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d4c:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118d50:	00a045b4 	movhi	r2,33046
81118d54:	109aef04 	addi	r2,r2,27580
81118d58:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d5c:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81118d60:	00a045b4 	movhi	r2,33046
81118d64:	109aef04 	addi	r2,r2,27580
81118d68:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d6c:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118d70:	00a045b4 	movhi	r2,33046
81118d74:	109aef04 	addi	r2,r2,27580
81118d78:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d7c:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118d80:	00a045b4 	movhi	r2,33046
81118d84:	109aef04 	addi	r2,r2,27580
81118d88:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d8c:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118d90:	00a045b4 	movhi	r2,33046
81118d94:	109aef04 	addi	r2,r2,27580
81118d98:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118d9c:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118da0:	00a045b4 	movhi	r2,33046
81118da4:	109aef04 	addi	r2,r2,27580
81118da8:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118dac:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118db0:	00a045b4 	movhi	r2,33046
81118db4:	109aef04 	addi	r2,r2,27580
81118db8:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118dbc:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118dc0:	00a045b4 	movhi	r2,33046
81118dc4:	109aef04 	addi	r2,r2,27580
81118dc8:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118dcc:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118dd0:	00a045b4 	movhi	r2,33046
81118dd4:	109aef04 	addi	r2,r2,27580
81118dd8:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118ddc:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118de0:	00a045b4 	movhi	r2,33046
81118de4:	109aef04 	addi	r2,r2,27580
81118de8:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118dec:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81118df0:	00a045b4 	movhi	r2,33046
81118df4:	109aef04 	addi	r2,r2,27580
81118df8:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118dfc:	10bfffcc 	andi	r2,r2,65535
81118e00:	e53fd984 	addi	r20,fp,-154
81118e04:	d8801115 	stw	r2,68(sp)
81118e08:	dcc01015 	stw	r19,64(sp)
81118e0c:	dc800f15 	stw	r18,60(sp)
81118e10:	dc400e15 	stw	r17,56(sp)
81118e14:	dc000d15 	stw	r16,52(sp)
81118e18:	dbc00c15 	stw	r15,48(sp)
81118e1c:	db800b15 	stw	r14,44(sp)
81118e20:	db400a15 	stw	r13,40(sp)
81118e24:	db000915 	stw	r12,36(sp)
81118e28:	dac00815 	stw	r11,32(sp)
81118e2c:	da800715 	stw	r10,28(sp)
81118e30:	da400615 	stw	r9,24(sp)
81118e34:	da000515 	stw	r8,20(sp)
81118e38:	d9c00415 	stw	r7,16(sp)
81118e3c:	d9800315 	stw	r6,12(sp)
81118e40:	d9400215 	stw	r5,8(sp)
81118e44:	d9000115 	stw	r4,4(sp)
81118e48:	d8c00015 	stw	r3,0(sp)
81118e4c:	a80f883a 	mov	r7,r21
81118e50:	018010c4 	movi	r6,67
81118e54:	01604574 	movhi	r5,33045
81118e58:	297a3104 	addi	r5,r5,-5948
81118e5c:	a009883a 	mov	r4,r20
81118e60:	1122cd40 	call	81122cd4 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81118e64:	e0bfd984 	addi	r2,fp,-154
81118e68:	1009883a 	mov	r4,r2
81118e6c:	1122ee80 	call	81122ee8 <strlen>
81118e70:	1007883a 	mov	r3,r2
81118e74:	e0bfd984 	addi	r2,fp,-154
81118e78:	180b883a 	mov	r5,r3
81118e7c:	1009883a 	mov	r4,r2
81118e80:	111b4840 	call	8111b484 <ucCrc8wInit>
81118e84:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81118e88:	e13fd703 	ldbu	r4,-164(fp)
81118e8c:	e0ffd984 	addi	r3,fp,-154
81118e90:	e0bfd984 	addi	r2,fp,-154
81118e94:	200f883a 	mov	r7,r4
81118e98:	180d883a 	mov	r6,r3
81118e9c:	01604574 	movhi	r5,33045
81118ea0:	297a4904 	addi	r5,r5,-5852
81118ea4:	1009883a 	mov	r4,r2
81118ea8:	1122cd40 	call	81122cd4 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81118eac:	e0bfd90b 	ldhu	r2,-156(fp)
81118eb0:	10ffffcc 	andi	r3,r2,65535
81118eb4:	18e0001c 	xori	r3,r3,32768
81118eb8:	18e00004 	addi	r3,r3,-32768
81118ebc:	e0bfd984 	addi	r2,fp,-154
81118ec0:	180b883a 	mov	r5,r3
81118ec4:	1009883a 	mov	r4,r2
81118ec8:	11183a00 	call	811183a0 <bSendUART128v2>
81118ecc:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81118ed0:	e0bfd817 	ldw	r2,-160(fp)
81118ed4:	10800060 	cmpeqi	r2,r2,1
81118ed8:	1000011e 	bne	r2,zero,81118ee0 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81118edc:	111c0540 	call	8111c054 <vCouldNotSendEthConfUART>
	}
}
81118ee0:	0001883a 	nop
81118ee4:	e6fffa04 	addi	sp,fp,-24
81118ee8:	dfc00717 	ldw	ra,28(sp)
81118eec:	df000617 	ldw	fp,24(sp)
81118ef0:	dd400517 	ldw	r21,20(sp)
81118ef4:	dd000417 	ldw	r20,16(sp)
81118ef8:	dcc00317 	ldw	r19,12(sp)
81118efc:	dc800217 	ldw	r18,8(sp)
81118f00:	dc400117 	ldw	r17,4(sp)
81118f04:	dc000017 	ldw	r16,0(sp)
81118f08:	dec00804 	addi	sp,sp,32
81118f0c:	f800283a 	ret

81118f10 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81118f10:	defff304 	addi	sp,sp,-52
81118f14:	de00012e 	bgeu	sp,et,81118f1c <vSendTurnOff+0xc>
81118f18:	003b68fa 	trap	3
81118f1c:	dfc00c15 	stw	ra,48(sp)
81118f20:	df000b15 	stw	fp,44(sp)
81118f24:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81118f28:	e03ff78d 	sth	zero,-34(fp)
81118f2c:	e03ff80d 	sth	zero,-32(fp)
81118f30:	e03ff88d 	sth	zero,-30(fp)
81118f34:	e03ff90d 	sth	zero,-28(fp)
81118f38:	e03ff98d 	sth	zero,-26(fp)
81118f3c:	e03ffa0d 	sth	zero,-24(fp)
81118f40:	e03ffa8d 	sth	zero,-22(fp)
81118f44:	e03ffb0d 	sth	zero,-20(fp)
81118f48:	e03ffb8d 	sth	zero,-18(fp)
81118f4c:	e03ffc0d 	sth	zero,-16(fp)
81118f50:	e03ffc8d 	sth	zero,-14(fp)
81118f54:	e03ffd0d 	sth	zero,-12(fp)
81118f58:	e03ffd8d 	sth	zero,-10(fp)
81118f5c:	e03ffe0d 	sth	zero,-8(fp)
81118f60:	e03ffe8d 	sth	zero,-6(fp)
81118f64:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81118f68:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81118f6c:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118f70:	11192400 	call	81119240 <usiGetIdCMD>
81118f74:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81118f78:	e0fff70b 	ldhu	r3,-36(fp)
81118f7c:	e0bff784 	addi	r2,fp,-34
81118f80:	180d883a 	mov	r6,r3
81118f84:	01604574 	movhi	r5,33045
81118f88:	297a4c04 	addi	r5,r5,-5840
81118f8c:	1009883a 	mov	r4,r2
81118f90:	1122cd40 	call	81122cd4 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81118f94:	e0bff784 	addi	r2,fp,-34
81118f98:	1009883a 	mov	r4,r2
81118f9c:	1122ee80 	call	81122ee8 <strlen>
81118fa0:	1007883a 	mov	r3,r2
81118fa4:	e0bff784 	addi	r2,fp,-34
81118fa8:	180b883a 	mov	r5,r3
81118fac:	1009883a 	mov	r4,r2
81118fb0:	111b4840 	call	8111b484 <ucCrc8wInit>
81118fb4:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81118fb8:	e13ff503 	ldbu	r4,-44(fp)
81118fbc:	e0fff784 	addi	r3,fp,-34
81118fc0:	e0bff784 	addi	r2,fp,-34
81118fc4:	200f883a 	mov	r7,r4
81118fc8:	180d883a 	mov	r6,r3
81118fcc:	01604574 	movhi	r5,33045
81118fd0:	297a4904 	addi	r5,r5,-5852
81118fd4:	1009883a 	mov	r4,r2
81118fd8:	1122cd40 	call	81122cd4 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81118fdc:	e0bff70b 	ldhu	r2,-36(fp)
81118fe0:	10ffffcc 	andi	r3,r2,65535
81118fe4:	18e0001c 	xori	r3,r3,32768
81118fe8:	18e00004 	addi	r3,r3,-32768
81118fec:	e0bff784 	addi	r2,fp,-34
81118ff0:	180b883a 	mov	r5,r3
81118ff4:	1009883a 	mov	r4,r2
81118ff8:	11189880 	call	81118988 <bSendUART32v2>
81118ffc:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81119000:	e0bff617 	ldw	r2,-40(fp)
81119004:	10800060 	cmpeqi	r2,r2,1
81119008:	1000011e 	bne	r2,zero,81119010 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111900c:	111c6fc0 	call	8111c6fc <vCouldNotSendTurnOff>
	}
}
81119010:	0001883a 	nop
81119014:	e037883a 	mov	sp,fp
81119018:	dfc00117 	ldw	ra,4(sp)
8111901c:	df000017 	ldw	fp,0(sp)
81119020:	dec00204 	addi	sp,sp,8
81119024:	f800283a 	ret

81119028 <vSendReset>:

void vSendReset ( void ) {
81119028:	defff304 	addi	sp,sp,-52
8111902c:	de00012e 	bgeu	sp,et,81119034 <vSendReset+0xc>
81119030:	003b68fa 	trap	3
81119034:	dfc00c15 	stw	ra,48(sp)
81119038:	df000b15 	stw	fp,44(sp)
8111903c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81119040:	e03ff78d 	sth	zero,-34(fp)
81119044:	e03ff80d 	sth	zero,-32(fp)
81119048:	e03ff88d 	sth	zero,-30(fp)
8111904c:	e03ff90d 	sth	zero,-28(fp)
81119050:	e03ff98d 	sth	zero,-26(fp)
81119054:	e03ffa0d 	sth	zero,-24(fp)
81119058:	e03ffa8d 	sth	zero,-22(fp)
8111905c:	e03ffb0d 	sth	zero,-20(fp)
81119060:	e03ffb8d 	sth	zero,-18(fp)
81119064:	e03ffc0d 	sth	zero,-16(fp)
81119068:	e03ffc8d 	sth	zero,-14(fp)
8111906c:	e03ffd0d 	sth	zero,-12(fp)
81119070:	e03ffd8d 	sth	zero,-10(fp)
81119074:	e03ffe0d 	sth	zero,-8(fp)
81119078:	e03ffe8d 	sth	zero,-6(fp)
8111907c:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81119080:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119084:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119088:	11192400 	call	81119240 <usiGetIdCMD>
8111908c:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81119090:	e0fff70b 	ldhu	r3,-36(fp)
81119094:	e0bff784 	addi	r2,fp,-34
81119098:	180d883a 	mov	r6,r3
8111909c:	01604574 	movhi	r5,33045
811190a0:	297a4e04 	addi	r5,r5,-5832
811190a4:	1009883a 	mov	r4,r2
811190a8:	1122cd40 	call	81122cd4 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
811190ac:	e0bff784 	addi	r2,fp,-34
811190b0:	1009883a 	mov	r4,r2
811190b4:	1122ee80 	call	81122ee8 <strlen>
811190b8:	1007883a 	mov	r3,r2
811190bc:	e0bff784 	addi	r2,fp,-34
811190c0:	180b883a 	mov	r5,r3
811190c4:	1009883a 	mov	r4,r2
811190c8:	111b4840 	call	8111b484 <ucCrc8wInit>
811190cc:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811190d0:	e13ff503 	ldbu	r4,-44(fp)
811190d4:	e0fff784 	addi	r3,fp,-34
811190d8:	e0bff784 	addi	r2,fp,-34
811190dc:	200f883a 	mov	r7,r4
811190e0:	180d883a 	mov	r6,r3
811190e4:	01604574 	movhi	r5,33045
811190e8:	297a4904 	addi	r5,r5,-5852
811190ec:	1009883a 	mov	r4,r2
811190f0:	1122cd40 	call	81122cd4 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811190f4:	e0bff70b 	ldhu	r2,-36(fp)
811190f8:	10ffffcc 	andi	r3,r2,65535
811190fc:	18e0001c 	xori	r3,r3,32768
81119100:	18e00004 	addi	r3,r3,-32768
81119104:	e0bff784 	addi	r2,fp,-34
81119108:	180b883a 	mov	r5,r3
8111910c:	1009883a 	mov	r4,r2
81119110:	11189880 	call	81118988 <bSendUART32v2>
81119114:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81119118:	e0bff617 	ldw	r2,-40(fp)
8111911c:	10800060 	cmpeqi	r2,r2,1
81119120:	1000011e 	bne	r2,zero,81119128 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81119124:	111c6fc0 	call	8111c6fc <vCouldNotSendTurnOff>
	}
}
81119128:	0001883a 	nop
8111912c:	e037883a 	mov	sp,fp
81119130:	dfc00117 	ldw	ra,4(sp)
81119134:	df000017 	ldw	fp,0(sp)
81119138:	dec00204 	addi	sp,sp,8
8111913c:	f800283a 	ret

81119140 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81119140:	deffda04 	addi	sp,sp,-152
81119144:	de00012e 	bgeu	sp,et,8111914c <vSendLog+0xc>
81119148:	003b68fa 	trap	3
8111914c:	dfc02515 	stw	ra,148(sp)
81119150:	df002415 	stw	fp,144(sp)
81119154:	df002404 	addi	fp,sp,144
81119158:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8111915c:	e03fde8d 	sth	zero,-134(fp)
81119160:	e03fdf0d 	sth	zero,-132(fp)
81119164:	e0bfdf84 	addi	r2,fp,-130
81119168:	00c01f04 	movi	r3,124
8111916c:	180d883a 	mov	r6,r3
81119170:	000b883a 	mov	r5,zero
81119174:	1009883a 	mov	r4,r2
81119178:	11225440 	call	81122544 <memset>
    unsigned char crc = 0;
8111917c:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119180:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119184:	11192400 	call	81119240 <usiGetIdCMD>
81119188:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8111918c:	e0ffde0b 	ldhu	r3,-136(fp)
81119190:	e0bfde84 	addi	r2,fp,-134
81119194:	e1ffff17 	ldw	r7,-4(fp)
81119198:	180d883a 	mov	r6,r3
8111919c:	01604574 	movhi	r5,33045
811191a0:	297a5004 	addi	r5,r5,-5824
811191a4:	1009883a 	mov	r4,r2
811191a8:	1122cd40 	call	81122cd4 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
811191ac:	e0bfde84 	addi	r2,fp,-134
811191b0:	1009883a 	mov	r4,r2
811191b4:	1122ee80 	call	81122ee8 <strlen>
811191b8:	1007883a 	mov	r3,r2
811191bc:	e0bfde84 	addi	r2,fp,-134
811191c0:	180b883a 	mov	r5,r3
811191c4:	1009883a 	mov	r4,r2
811191c8:	111b4840 	call	8111b484 <ucCrc8wInit>
811191cc:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
811191d0:	e13fdc03 	ldbu	r4,-144(fp)
811191d4:	e0ffde84 	addi	r3,fp,-134
811191d8:	e0bfde84 	addi	r2,fp,-134
811191dc:	200f883a 	mov	r7,r4
811191e0:	180d883a 	mov	r6,r3
811191e4:	01604574 	movhi	r5,33045
811191e8:	297a4904 	addi	r5,r5,-5852
811191ec:	1009883a 	mov	r4,r2
811191f0:	1122cd40 	call	81122cd4 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
811191f4:	e0bfde0b 	ldhu	r2,-136(fp)
811191f8:	10ffffcc 	andi	r3,r2,65535
811191fc:	18e0001c 	xori	r3,r3,32768
81119200:	18e00004 	addi	r3,r3,-32768
81119204:	e0bfde84 	addi	r2,fp,-134
81119208:	180b883a 	mov	r5,r3
8111920c:	1009883a 	mov	r4,r2
81119210:	11183a00 	call	811183a0 <bSendUART128v2>
81119214:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81119218:	e0bfdd17 	ldw	r2,-140(fp)
8111921c:	10800060 	cmpeqi	r2,r2,1
81119220:	1000011e 	bne	r2,zero,81119228 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
81119224:	111c7cc0 	call	8111c7cc <vCouldNotSendLog>
	}
}
81119228:	0001883a 	nop
8111922c:	e037883a 	mov	sp,fp
81119230:	dfc00117 	ldw	ra,4(sp)
81119234:	df000017 	ldw	fp,0(sp)
81119238:	dec00204 	addi	sp,sp,8
8111923c:	f800283a 	ret

81119240 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81119240:	deffff04 	addi	sp,sp,-4
81119244:	de00012e 	bgeu	sp,et,8111924c <usiGetIdCMD+0xc>
81119248:	003b68fa 	trap	3
8111924c:	df000015 	stw	fp,0(sp)
81119250:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
81119254:	d0a0680b 	ldhu	r2,-32352(gp)
81119258:	10ffffcc 	andi	r3,r2,65535
8111925c:	00bfffd4 	movui	r2,65535
81119260:	1880031e 	bne	r3,r2,81119270 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
81119264:	00800084 	movi	r2,2
81119268:	d0a0680d 	sth	r2,-32352(gp)
8111926c:	00000306 	br	8111927c <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81119270:	d0a0680b 	ldhu	r2,-32352(gp)
81119274:	10800044 	addi	r2,r2,1
81119278:	d0a0680d 	sth	r2,-32352(gp)

    return usiIdCMD;
8111927c:	d0a0680b 	ldhu	r2,-32352(gp)
}
81119280:	e037883a 	mov	sp,fp
81119284:	df000017 	ldw	fp,0(sp)
81119288:	dec00104 	addi	sp,sp,4
8111928c:	f800283a 	ret

81119290 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
81119290:	defffb04 	addi	sp,sp,-20
81119294:	de00012e 	bgeu	sp,et,8111929c <siPosStr+0xc>
81119298:	003b68fa 	trap	3
8111929c:	dfc00415 	stw	ra,16(sp)
811192a0:	df000315 	stw	fp,12(sp)
811192a4:	df000304 	addi	fp,sp,12
811192a8:	e13ffe15 	stw	r4,-8(fp)
811192ac:	2805883a 	mov	r2,r5
811192b0:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
811192b4:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
811192b8:	e0bfff03 	ldbu	r2,-4(fp)
811192bc:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
811192c0:	e17ffd04 	addi	r5,fp,-12
811192c4:	e13ffe17 	ldw	r4,-8(fp)
811192c8:	1122e9c0 	call	81122e9c <strcspn>
}
811192cc:	e037883a 	mov	sp,fp
811192d0:	dfc00117 	ldw	ra,4(sp)
811192d4:	df000017 	ldw	fp,0(sp)
811192d8:	dec00204 	addi	sp,sp,8
811192dc:	f800283a 	ret

811192e0 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
811192e0:	defffc04 	addi	sp,sp,-16
811192e4:	de00012e 	bgeu	sp,et,811192ec <vTimeoutCheck+0xc>
811192e8:	003b68fa 	trap	3
811192ec:	dfc00315 	stw	ra,12(sp)
811192f0:	df000215 	stw	fp,8(sp)
811192f4:	df000204 	addi	fp,sp,8
811192f8:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
811192fc:	d0a06717 	ldw	r2,-32356(gp)
81119300:	1009883a 	mov	r4,r2
81119304:	113ec040 	call	8113ec04 <OSSemPost>
81119308:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8111930c:	e0bffe03 	ldbu	r2,-8(fp)
81119310:	10000126 	beq	r2,zero,81119318 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
81119314:	111c48c0 	call	8111c48c <vFailPostBlockingSemTimeoutTask>
	}
}
81119318:	0001883a 	nop
8111931c:	e037883a 	mov	sp,fp
81119320:	dfc00117 	ldw	ra,4(sp)
81119324:	df000017 	ldw	fp,0(sp)
81119328:	dec00204 	addi	sp,sp,8
8111932c:	f800283a 	ret

81119330 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81119330:	deffe304 	addi	sp,sp,-116
81119334:	de00012e 	bgeu	sp,et,8111933c <vSendPusTM64+0xc>
81119338:	003b68fa 	trap	3
8111933c:	dfc01815 	stw	ra,96(sp)
81119340:	df001715 	stw	fp,92(sp)
81119344:	df001704 	addi	fp,sp,92
81119348:	e1000215 	stw	r4,8(fp)
8111934c:	e1400315 	stw	r5,12(fp)
81119350:	e1800415 	stw	r6,16(fp)
81119354:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81119358:	e03fef8d 	sth	zero,-66(fp)
8111935c:	e03ff00d 	sth	zero,-64(fp)
81119360:	e0bff084 	addi	r2,fp,-62
81119364:	00c00f04 	movi	r3,60
81119368:	180d883a 	mov	r6,r3
8111936c:	000b883a 	mov	r5,zero
81119370:	1009883a 	mov	r4,r2
81119374:	11225440 	call	81122544 <memset>
    unsigned char crc = 0;
81119378:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8111937c:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81119380:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81119384:	11192400 	call	81119240 <usiGetIdCMD>
81119388:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111938c:	e1bfef0b 	ldhu	r6,-68(fp)
81119390:	e080040b 	ldhu	r2,16(fp)
81119394:	11ffffcc 	andi	r7,r2,65535
81119398:	e080048b 	ldhu	r2,18(fp)
8111939c:	10bfffcc 	andi	r2,r2,65535
811193a0:	e0c0050b 	ldhu	r3,20(fp)
811193a4:	18ffffcc 	andi	r3,r3,65535
811193a8:	e100058b 	ldhu	r4,22(fp)
811193ac:	213fffcc 	andi	r4,r4,65535
811193b0:	e140060b 	ldhu	r5,24(fp)
811193b4:	297fffcc 	andi	r5,r5,65535
811193b8:	e23fef84 	addi	r8,fp,-66
811193bc:	d9400315 	stw	r5,12(sp)
811193c0:	d9000215 	stw	r4,8(sp)
811193c4:	d8c00115 	stw	r3,4(sp)
811193c8:	d8800015 	stw	r2,0(sp)
811193cc:	01604574 	movhi	r5,33045
811193d0:	297a5304 	addi	r5,r5,-5812
811193d4:	4009883a 	mov	r4,r8
811193d8:	1122cd40 	call	81122cd4 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811193dc:	e03fed05 	stb	zero,-76(fp)
811193e0:	00001206 	br	8111942c <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
811193e4:	e0bfed03 	ldbu	r2,-76(fp)
811193e8:	10800284 	addi	r2,r2,10
811193ec:	1085883a 	add	r2,r2,r2
811193f0:	e0c00204 	addi	r3,fp,8
811193f4:	1885883a 	add	r2,r3,r2
811193f8:	1080000b 	ldhu	r2,0(r2)
811193fc:	113fffcc 	andi	r4,r2,65535
81119400:	e0ffef84 	addi	r3,fp,-66
81119404:	e0bfef84 	addi	r2,fp,-66
81119408:	200f883a 	mov	r7,r4
8111940c:	180d883a 	mov	r6,r3
81119410:	01604574 	movhi	r5,33045
81119414:	297a5a04 	addi	r5,r5,-5784
81119418:	1009883a 	mov	r4,r2
8111941c:	1122cd40 	call	81122cd4 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81119420:	e0bfed03 	ldbu	r2,-76(fp)
81119424:	10800044 	addi	r2,r2,1
81119428:	e0bfed05 	stb	r2,-76(fp)
8111942c:	e0800683 	ldbu	r2,26(fp)
81119430:	10803fcc 	andi	r2,r2,255
81119434:	e0ffed03 	ldbu	r3,-76(fp)
81119438:	18bfea36 	bltu	r3,r2,811193e4 <__reset+0xfb0f93e4>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111943c:	e0bfef84 	addi	r2,fp,-66
81119440:	1009883a 	mov	r4,r2
81119444:	1122ee80 	call	81122ee8 <strlen>
81119448:	1007883a 	mov	r3,r2
8111944c:	e0bfef84 	addi	r2,fp,-66
81119450:	180b883a 	mov	r5,r3
81119454:	1009883a 	mov	r4,r2
81119458:	111b4840 	call	8111b484 <ucCrc8wInit>
8111945c:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81119460:	e13fed43 	ldbu	r4,-75(fp)
81119464:	e0ffef84 	addi	r3,fp,-66
81119468:	e0bfef84 	addi	r2,fp,-66
8111946c:	200f883a 	mov	r7,r4
81119470:	180d883a 	mov	r6,r3
81119474:	01604574 	movhi	r5,33045
81119478:	297a4904 	addi	r5,r5,-5852
8111947c:	1009883a 	mov	r4,r2
81119480:	1122cd40 	call	81122cd4 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81119484:	e0bfef0b 	ldhu	r2,-68(fp)
81119488:	10ffffcc 	andi	r3,r2,65535
8111948c:	18e0001c 	xori	r3,r3,32768
81119490:	18e00004 	addi	r3,r3,-32768
81119494:	e0bfef84 	addi	r2,fp,-66
81119498:	180b883a 	mov	r5,r3
8111949c:	1009883a 	mov	r4,r2
811194a0:	11186900 	call	81118690 <bSendUART64v2>
811194a4:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
811194a8:	e0bfee17 	ldw	r2,-72(fp)
811194ac:	10800060 	cmpeqi	r2,r2,1
811194b0:	1000031e 	bne	r2,zero,811194c0 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
811194b4:	e0bfef84 	addi	r2,fp,-66
811194b8:	1009883a 	mov	r4,r2
811194bc:	111c8340 	call	8111c834 <vCouldNotSendTMPusCommand>
	}
}
811194c0:	0001883a 	nop
811194c4:	e037883a 	mov	sp,fp
811194c8:	dfc00117 	ldw	ra,4(sp)
811194cc:	df000017 	ldw	fp,0(sp)
811194d0:	dec00604 	addi	sp,sp,24
811194d4:	f800283a 	ret

811194d8 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
811194d8:	deffd304 	addi	sp,sp,-180
811194dc:	de00012e 	bgeu	sp,et,811194e4 <vSendPusTM128+0xc>
811194e0:	003b68fa 	trap	3
811194e4:	dfc02815 	stw	ra,160(sp)
811194e8:	df002715 	stw	fp,156(sp)
811194ec:	df002704 	addi	fp,sp,156
811194f0:	e1000215 	stw	r4,8(fp)
811194f4:	e1400315 	stw	r5,12(fp)
811194f8:	e1800415 	stw	r6,16(fp)
811194fc:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81119500:	e03fdf8d 	sth	zero,-130(fp)
81119504:	e03fe00d 	sth	zero,-128(fp)
81119508:	e0bfe084 	addi	r2,fp,-126
8111950c:	00c01f04 	movi	r3,124
81119510:	180d883a 	mov	r6,r3
81119514:	000b883a 	mov	r5,zero
81119518:	1009883a 	mov	r4,r2
8111951c:	11225440 	call	81122544 <memset>
    unsigned char crc = 0;
81119520:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81119524:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81119528:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111952c:	11192400 	call	81119240 <usiGetIdCMD>
81119530:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81119534:	e1bfdf0b 	ldhu	r6,-132(fp)
81119538:	e080040b 	ldhu	r2,16(fp)
8111953c:	11ffffcc 	andi	r7,r2,65535
81119540:	e080048b 	ldhu	r2,18(fp)
81119544:	10bfffcc 	andi	r2,r2,65535
81119548:	e0c0050b 	ldhu	r3,20(fp)
8111954c:	18ffffcc 	andi	r3,r3,65535
81119550:	e100058b 	ldhu	r4,22(fp)
81119554:	213fffcc 	andi	r4,r4,65535
81119558:	e140060b 	ldhu	r5,24(fp)
8111955c:	297fffcc 	andi	r5,r5,65535
81119560:	e23fdf84 	addi	r8,fp,-130
81119564:	d9400315 	stw	r5,12(sp)
81119568:	d9000215 	stw	r4,8(sp)
8111956c:	d8c00115 	stw	r3,4(sp)
81119570:	d8800015 	stw	r2,0(sp)
81119574:	01604574 	movhi	r5,33045
81119578:	297a5304 	addi	r5,r5,-5812
8111957c:	4009883a 	mov	r4,r8
81119580:	1122cd40 	call	81122cd4 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81119584:	e03fdd05 	stb	zero,-140(fp)
81119588:	00001206 	br	811195d4 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111958c:	e0bfdd03 	ldbu	r2,-140(fp)
81119590:	10800284 	addi	r2,r2,10
81119594:	1085883a 	add	r2,r2,r2
81119598:	e0c00204 	addi	r3,fp,8
8111959c:	1885883a 	add	r2,r3,r2
811195a0:	1080000b 	ldhu	r2,0(r2)
811195a4:	113fffcc 	andi	r4,r2,65535
811195a8:	e0ffdf84 	addi	r3,fp,-130
811195ac:	e0bfdf84 	addi	r2,fp,-130
811195b0:	200f883a 	mov	r7,r4
811195b4:	180d883a 	mov	r6,r3
811195b8:	01604574 	movhi	r5,33045
811195bc:	297a5a04 	addi	r5,r5,-5784
811195c0:	1009883a 	mov	r4,r2
811195c4:	1122cd40 	call	81122cd4 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811195c8:	e0bfdd03 	ldbu	r2,-140(fp)
811195cc:	10800044 	addi	r2,r2,1
811195d0:	e0bfdd05 	stb	r2,-140(fp)
811195d4:	e0800683 	ldbu	r2,26(fp)
811195d8:	10803fcc 	andi	r2,r2,255
811195dc:	e0ffdd03 	ldbu	r3,-140(fp)
811195e0:	18bfea36 	bltu	r3,r2,8111958c <__reset+0xfb0f958c>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
811195e4:	e0bfdf84 	addi	r2,fp,-130
811195e8:	1009883a 	mov	r4,r2
811195ec:	1122ee80 	call	81122ee8 <strlen>
811195f0:	1007883a 	mov	r3,r2
811195f4:	e0bfdf84 	addi	r2,fp,-130
811195f8:	180b883a 	mov	r5,r3
811195fc:	1009883a 	mov	r4,r2
81119600:	111b4840 	call	8111b484 <ucCrc8wInit>
81119604:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81119608:	e13fdd43 	ldbu	r4,-139(fp)
8111960c:	e0ffdf84 	addi	r3,fp,-130
81119610:	e0bfdf84 	addi	r2,fp,-130
81119614:	200f883a 	mov	r7,r4
81119618:	180d883a 	mov	r6,r3
8111961c:	01604574 	movhi	r5,33045
81119620:	297a4904 	addi	r5,r5,-5852
81119624:	1009883a 	mov	r4,r2
81119628:	1122cd40 	call	81122cd4 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8111962c:	e0bfdf0b 	ldhu	r2,-132(fp)
81119630:	10ffffcc 	andi	r3,r2,65535
81119634:	18e0001c 	xori	r3,r3,32768
81119638:	18e00004 	addi	r3,r3,-32768
8111963c:	e0bfdf84 	addi	r2,fp,-130
81119640:	180b883a 	mov	r5,r3
81119644:	1009883a 	mov	r4,r2
81119648:	11183a00 	call	811183a0 <bSendUART128v2>
8111964c:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81119650:	e0bfde17 	ldw	r2,-136(fp)
81119654:	10800060 	cmpeqi	r2,r2,1
81119658:	1000031e 	bne	r2,zero,81119668 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8111965c:	e0bfdf84 	addi	r2,fp,-130
81119660:	1009883a 	mov	r4,r2
81119664:	111c8340 	call	8111c834 <vCouldNotSendTMPusCommand>
	}
}
81119668:	0001883a 	nop
8111966c:	e037883a 	mov	sp,fp
81119670:	dfc00117 	ldw	ra,4(sp)
81119674:	df000017 	ldw	fp,0(sp)
81119678:	dec00604 	addi	sp,sp,24
8111967c:	f800283a 	ret

81119680 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81119680:	deffd704 	addi	sp,sp,-164
81119684:	de00012e 	bgeu	sp,et,8111968c <vTMPusTestConnection+0xc>
81119688:	003b68fa 	trap	3
8111968c:	dfc02815 	stw	ra,160(sp)
81119690:	df002715 	stw	fp,156(sp)
81119694:	df002704 	addi	fp,sp,156
81119698:	2005883a 	mov	r2,r4
8111969c:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
811196a0:	e0bfff0b 	ldhu	r2,-4(fp)
811196a4:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
811196a8:	00801c04 	movi	r2,112
811196ac:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
811196b0:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
811196b4:	00800444 	movi	r2,17
811196b8:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
811196bc:	00800084 	movi	r2,2
811196c0:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
811196c4:	d809883a 	mov	r4,sp
811196c8:	e0bfee04 	addi	r2,fp,-72
811196cc:	00c01104 	movi	r3,68
811196d0:	180d883a 	mov	r6,r3
811196d4:	100b883a 	mov	r5,r2
811196d8:	11223f40 	call	811223f4 <memcpy>
811196dc:	e13fea17 	ldw	r4,-88(fp)
811196e0:	e17feb17 	ldw	r5,-84(fp)
811196e4:	e1bfec17 	ldw	r6,-80(fp)
811196e8:	e1ffed17 	ldw	r7,-76(fp)
811196ec:	11193300 	call	81119330 <vSendPusTM64>
}
811196f0:	0001883a 	nop
811196f4:	e037883a 	mov	sp,fp
811196f8:	dfc00117 	ldw	ra,4(sp)
811196fc:	df000017 	ldw	fp,0(sp)
81119700:	dec00204 	addi	sp,sp,8
81119704:	f800283a 	ret

81119708 <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
81119708:	defff504 	addi	sp,sp,-44
8111970c:	de00012e 	bgeu	sp,et,81119714 <vLoadDefaultETHConf+0xc>
81119710:	003b68fa 	trap	3
81119714:	dfc00a15 	stw	ra,40(sp)
81119718:	df000915 	stw	fp,36(sp)
8111971c:	dc000815 	stw	r16,32(sp)
81119720:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81119724:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81119728:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111972c:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81119730:	d0a07617 	ldw	r2,-32296(gp)
81119734:	10800058 	cmpnei	r2,r2,1
81119738:	1002051e 	bne	r2,zero,81119f50 <vLoadDefaultETHConf+0x848>
8111973c:	111e7300 	call	8111e730 <bSDcardIsPresent>
81119740:	10020326 	beq	r2,zero,81119f50 <vLoadDefaultETHConf+0x848>
81119744:	111e7600 	call	8111e760 <bSDcardFAT16Check>
81119748:	10020126 	beq	r2,zero,81119f50 <vLoadDefaultETHConf+0x848>

		siFile = siOpenFile( ETH_FILE_NAME );
8111974c:	01204574 	movhi	r4,33045
81119750:	213a5c04 	addi	r4,r4,-5776
81119754:	111e8880 	call	8111e888 <siOpenFile>
81119758:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111975c:	e0bffc0f 	ldh	r2,-16(fp)
81119760:	1001f316 	blt	r2,zero,81119f30 <vLoadDefaultETHConf+0x828>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81119764:	e0bffd04 	addi	r2,fp,-12
81119768:	01800204 	movi	r6,8
8111976c:	01400284 	movi	r5,10
81119770:	1009883a 	mov	r4,r2
81119774:	11225440 	call	81122544 <memset>
			p_inteiro = inteiro;
81119778:	e0bffd04 	addi	r2,fp,-12
8111977c:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81119780:	e0bffc0f 	ldh	r2,-16(fp)
81119784:	1009883a 	mov	r4,r2
81119788:	111e9040 	call	8111e904 <cGetNextChar>
8111978c:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81119790:	e0bff947 	ldb	r2,-27(fp)
81119794:	10800084 	addi	r2,r2,2
81119798:	10c015a8 	cmpgeui	r3,r2,86
8111979c:	1801d81e 	bne	r3,zero,81119f00 <vLoadDefaultETHConf+0x7f8>
811197a0:	100690ba 	slli	r3,r2,2
811197a4:	00a044b4 	movhi	r2,33042
811197a8:	10a5ee04 	addi	r2,r2,-26696
811197ac:	1885883a 	add	r2,r3,r2
811197b0:	10800017 	ldw	r2,0(r2)
811197b4:	1000683a 	jmp	r2
811197b8:	81119950 	cmplti	r4,r16,18021
811197bc:	81119944 	addi	r4,r16,18021
811197c0:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197c4:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197c8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197cc:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197d0:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197d4:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197d8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197dc:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197e0:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197e4:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197e8:	81119f20 	cmpeqi	r4,r16,18044
811197ec:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197f0:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197f4:	81119f20 	cmpeqi	r4,r16,18044
811197f8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811197fc:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119800:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119804:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119808:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111980c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119810:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119814:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119818:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111981c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119820:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119824:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119828:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111982c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119830:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119834:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119838:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111983c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119840:	81119f20 	cmpeqi	r4,r16,18044
81119844:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119848:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111984c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119850:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119854:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119858:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111985c:	81119910 	cmplti	r4,r16,18020
81119860:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119864:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119868:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111986c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119870:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119874:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119878:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111987c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119880:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119884:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119888:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111988c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119890:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119894:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119898:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111989c:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198a0:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198a4:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198a8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198ac:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198b0:	81119eb8 	rdprs	r4,r16,18042
811198b4:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198b8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198bc:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198c0:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198c4:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198c8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198cc:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198d0:	81119de8 	cmpgeui	r4,r16,18039
811198d4:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198d8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198dc:	81119b14 	ori	r4,r16,18028
811198e0:	81119c70 	cmpltui	r4,r16,18033
811198e4:	81119a48 	cmpgei	r4,r16,18025
811198e8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198ec:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198f0:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198f4:	81119978 	rdprs	r4,r16,18021
811198f8:	81119f00 	call	881119f0 <__reset+0x20f19f0>
811198fc:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119900:	81119be4 	muli	r4,r16,18031
81119904:	81119f00 	call	881119f0 <__reset+0x20f19f0>
81119908:	81119f00 	call	881119f0 <__reset+0x20f19f0>
8111990c:	81119d18 	cmpnei	r4,r16,18036
					case 39:// single quote '
						c = cGetNextChar(siFile);
81119910:	e0bffc0f 	ldh	r2,-16(fp)
81119914:	1009883a 	mov	r4,r2
81119918:	111e9040 	call	8111e904 <cGetNextChar>
8111991c:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81119920:	00000406 	br	81119934 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
81119924:	e0bffc0f 	ldh	r2,-16(fp)
81119928:	1009883a 	mov	r4,r2
8111992c:	111e9040 	call	8111e904 <cGetNextChar>
81119930:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81119934:	e0bff947 	ldb	r2,-27(fp)
81119938:	108009d8 	cmpnei	r2,r2,39
8111993c:	103ff91e 	bne	r2,zero,81119924 <__reset+0xfb0f9924>
							c = cGetNextChar(siFile);
						}
						break;
81119940:	00017806 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case -1: 	//EOF
						bEOF = TRUE;
81119944:	00800044 	movi	r2,1
81119948:	e0bff815 	stw	r2,-32(fp)
						break;
8111994c:	00017506 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81119950:	d0a06217 	ldw	r2,-32376(gp)
81119954:	100f883a 	mov	r7,r2
81119958:	018006c4 	movi	r6,27
8111995c:	01400044 	movi	r5,1
81119960:	01204574 	movhi	r4,33045
81119964:	213a5e04 	addi	r4,r4,-5768
81119968:	11219e00 	call	811219e0 <fwrite>
						#endif
						bEOF = TRUE;
8111996c:	00800044 	movi	r2,1
81119970:	e0bff815 	stw	r2,-32(fp)
						break;
81119974:	00016b06 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81119978:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111997c:	e0bffc0f 	ldh	r2,-16(fp)
81119980:	1009883a 	mov	r4,r2
81119984:	111e9040 	call	8111e904 <cGetNextChar>
81119988:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111998c:	d0e00317 	ldw	r3,-32756(gp)
81119990:	e0bff947 	ldb	r2,-27(fp)
81119994:	10800044 	addi	r2,r2,1
81119998:	1885883a 	add	r2,r3,r2
8111999c:	10800003 	ldbu	r2,0(r2)
811199a0:	10803fcc 	andi	r2,r2,255
811199a4:	1080010c 	andi	r2,r2,4
811199a8:	10000626 	beq	r2,zero,811199c4 <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
811199ac:	e0bffa17 	ldw	r2,-24(fp)
811199b0:	e0fff943 	ldbu	r3,-27(fp)
811199b4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811199b8:	e0bffa17 	ldw	r2,-24(fp)
811199bc:	10800044 	addi	r2,r2,1
811199c0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
811199c4:	e0bff947 	ldb	r2,-27(fp)
811199c8:	10800ea0 	cmpeqi	r2,r2,58
811199cc:	1000031e 	bne	r2,zero,811199dc <vLoadDefaultETHConf+0x2d4>
811199d0:	e0bff947 	ldb	r2,-27(fp)
811199d4:	10800ed8 	cmpnei	r2,r2,59
811199d8:	103fe81e 	bne	r2,zero,8111997c <__reset+0xfb0f997c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811199dc:	e0bffa17 	ldw	r2,-24(fp)
811199e0:	00c00284 	movi	r3,10
811199e4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
811199e8:	e0bff903 	ldbu	r2,-28(fp)
811199ec:	10800168 	cmpgeui	r2,r2,5
811199f0:	1000021e 	bne	r2,zero,811199fc <vLoadDefaultETHConf+0x2f4>
811199f4:	e43ff903 	ldbu	r16,-28(fp)
811199f8:	00000106 	br	81119a00 <vLoadDefaultETHConf+0x2f8>
811199fc:	04000144 	movi	r16,5
81119a00:	e0bffd04 	addi	r2,fp,-12
81119a04:	1009883a 	mov	r4,r2
81119a08:	11211d00 	call	811211d0 <atoi>
81119a0c:	1007883a 	mov	r3,r2
81119a10:	00a045b4 	movhi	r2,33046
81119a14:	109aef04 	addi	r2,r2,27580
81119a18:	1405883a 	add	r2,r2,r16
81119a1c:	10800404 	addi	r2,r2,16
81119a20:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119a24:	e0bffd04 	addi	r2,fp,-12
81119a28:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119a2c:	e0bff903 	ldbu	r2,-28(fp)
81119a30:	10800044 	addi	r2,r2,1
81119a34:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119a38:	e0bff947 	ldb	r2,-27(fp)
81119a3c:	10800ed8 	cmpnei	r2,r2,59
81119a40:	103fce1e 	bne	r2,zero,8111997c <__reset+0xfb0f997c>

						break;
81119a44:	00013706 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case 'I':

						ucParser = 0;
81119a48:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119a4c:	e0bffc0f 	ldh	r2,-16(fp)
81119a50:	1009883a 	mov	r4,r2
81119a54:	111e9040 	call	8111e904 <cGetNextChar>
81119a58:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119a5c:	d0e00317 	ldw	r3,-32756(gp)
81119a60:	e0bff947 	ldb	r2,-27(fp)
81119a64:	10800044 	addi	r2,r2,1
81119a68:	1885883a 	add	r2,r3,r2
81119a6c:	10800003 	ldbu	r2,0(r2)
81119a70:	10803fcc 	andi	r2,r2,255
81119a74:	1080010c 	andi	r2,r2,4
81119a78:	10000626 	beq	r2,zero,81119a94 <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
81119a7c:	e0bffa17 	ldw	r2,-24(fp)
81119a80:	e0fff943 	ldbu	r3,-27(fp)
81119a84:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119a88:	e0bffa17 	ldw	r2,-24(fp)
81119a8c:	10800044 	addi	r2,r2,1
81119a90:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119a94:	e0bff947 	ldb	r2,-27(fp)
81119a98:	10800ba0 	cmpeqi	r2,r2,46
81119a9c:	1000031e 	bne	r2,zero,81119aac <vLoadDefaultETHConf+0x3a4>
81119aa0:	e0bff947 	ldb	r2,-27(fp)
81119aa4:	10800ed8 	cmpnei	r2,r2,59
81119aa8:	103fe81e 	bne	r2,zero,81119a4c <__reset+0xfb0f9a4c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119aac:	e0bffa17 	ldw	r2,-24(fp)
81119ab0:	00c00284 	movi	r3,10
81119ab4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81119ab8:	e0bff903 	ldbu	r2,-28(fp)
81119abc:	108000e8 	cmpgeui	r2,r2,3
81119ac0:	1000021e 	bne	r2,zero,81119acc <vLoadDefaultETHConf+0x3c4>
81119ac4:	e43ff903 	ldbu	r16,-28(fp)
81119ac8:	00000106 	br	81119ad0 <vLoadDefaultETHConf+0x3c8>
81119acc:	040000c4 	movi	r16,3
81119ad0:	e0bffd04 	addi	r2,fp,-12
81119ad4:	1009883a 	mov	r4,r2
81119ad8:	11211d00 	call	811211d0 <atoi>
81119adc:	1007883a 	mov	r3,r2
81119ae0:	00a045b4 	movhi	r2,33046
81119ae4:	109aef04 	addi	r2,r2,27580
81119ae8:	1405883a 	add	r2,r2,r16
81119aec:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119af0:	e0bffd04 	addi	r2,fp,-12
81119af4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119af8:	e0bff903 	ldbu	r2,-28(fp)
81119afc:	10800044 	addi	r2,r2,1
81119b00:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119b04:	e0bff947 	ldb	r2,-27(fp)
81119b08:	10800ed8 	cmpnei	r2,r2,59
81119b0c:	103fcf1e 	bne	r2,zero,81119a4c <__reset+0xfb0f9a4c>

						break;
81119b10:	00010406 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case 'G':

						ucParser = 0;
81119b14:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119b18:	e0bffc0f 	ldh	r2,-16(fp)
81119b1c:	1009883a 	mov	r4,r2
81119b20:	111e9040 	call	8111e904 <cGetNextChar>
81119b24:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119b28:	d0e00317 	ldw	r3,-32756(gp)
81119b2c:	e0bff947 	ldb	r2,-27(fp)
81119b30:	10800044 	addi	r2,r2,1
81119b34:	1885883a 	add	r2,r3,r2
81119b38:	10800003 	ldbu	r2,0(r2)
81119b3c:	10803fcc 	andi	r2,r2,255
81119b40:	1080010c 	andi	r2,r2,4
81119b44:	10000626 	beq	r2,zero,81119b60 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81119b48:	e0bffa17 	ldw	r2,-24(fp)
81119b4c:	e0fff943 	ldbu	r3,-27(fp)
81119b50:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119b54:	e0bffa17 	ldw	r2,-24(fp)
81119b58:	10800044 	addi	r2,r2,1
81119b5c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119b60:	e0bff947 	ldb	r2,-27(fp)
81119b64:	10800ba0 	cmpeqi	r2,r2,46
81119b68:	1000031e 	bne	r2,zero,81119b78 <vLoadDefaultETHConf+0x470>
81119b6c:	e0bff947 	ldb	r2,-27(fp)
81119b70:	10800ed8 	cmpnei	r2,r2,59
81119b74:	103fe81e 	bne	r2,zero,81119b18 <__reset+0xfb0f9b18>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119b78:	e0bffa17 	ldw	r2,-24(fp)
81119b7c:	00c00284 	movi	r3,10
81119b80:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81119b84:	e0bff903 	ldbu	r2,-28(fp)
81119b88:	108000e8 	cmpgeui	r2,r2,3
81119b8c:	1000021e 	bne	r2,zero,81119b98 <vLoadDefaultETHConf+0x490>
81119b90:	e43ff903 	ldbu	r16,-28(fp)
81119b94:	00000106 	br	81119b9c <vLoadDefaultETHConf+0x494>
81119b98:	040000c4 	movi	r16,3
81119b9c:	e0bffd04 	addi	r2,fp,-12
81119ba0:	1009883a 	mov	r4,r2
81119ba4:	11211d00 	call	811211d0 <atoi>
81119ba8:	1007883a 	mov	r3,r2
81119bac:	00a045b4 	movhi	r2,33046
81119bb0:	109aef04 	addi	r2,r2,27580
81119bb4:	1405883a 	add	r2,r2,r16
81119bb8:	10800104 	addi	r2,r2,4
81119bbc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119bc0:	e0bffd04 	addi	r2,fp,-12
81119bc4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119bc8:	e0bff903 	ldbu	r2,-28(fp)
81119bcc:	10800044 	addi	r2,r2,1
81119bd0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119bd4:	e0bff947 	ldb	r2,-27(fp)
81119bd8:	10800ed8 	cmpnei	r2,r2,59
81119bdc:	103fce1e 	bne	r2,zero,81119b18 <__reset+0xfb0f9b18>

						break;
81119be0:	0000d006 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case 'P':
						ucParser = 0;
81119be4:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
81119be8:	e0bffc0f 	ldh	r2,-16(fp)
81119bec:	1009883a 	mov	r4,r2
81119bf0:	111e9040 	call	8111e904 <cGetNextChar>
81119bf4:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119bf8:	d0e00317 	ldw	r3,-32756(gp)
81119bfc:	e0bff947 	ldb	r2,-27(fp)
81119c00:	10800044 	addi	r2,r2,1
81119c04:	1885883a 	add	r2,r3,r2
81119c08:	10800003 	ldbu	r2,0(r2)
81119c0c:	10803fcc 	andi	r2,r2,255
81119c10:	1080010c 	andi	r2,r2,4
81119c14:	10000626 	beq	r2,zero,81119c30 <vLoadDefaultETHConf+0x528>
								(*p_inteiro) = c;
81119c18:	e0bffa17 	ldw	r2,-24(fp)
81119c1c:	e0fff943 	ldbu	r3,-27(fp)
81119c20:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119c24:	e0bffa17 	ldw	r2,-24(fp)
81119c28:	10800044 	addi	r2,r2,1
81119c2c:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81119c30:	e0bff947 	ldb	r2,-27(fp)
81119c34:	10800ed8 	cmpnei	r2,r2,59
81119c38:	103feb1e 	bne	r2,zero,81119be8 <__reset+0xfb0f9be8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119c3c:	e0bffa17 	ldw	r2,-24(fp)
81119c40:	00c00284 	movi	r3,10
81119c44:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81119c48:	e0bffd04 	addi	r2,fp,-12
81119c4c:	1009883a 	mov	r4,r2
81119c50:	11211d00 	call	811211d0 <atoi>
81119c54:	1007883a 	mov	r3,r2
81119c58:	00a045b4 	movhi	r2,33046
81119c5c:	109aef04 	addi	r2,r2,27580
81119c60:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119c64:	e0bffd04 	addi	r2,fp,-12
81119c68:	e0bffa15 	stw	r2,-24(fp)

						break;
81119c6c:	0000ad06 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case 'H':

						do {
							c = cGetNextChar(siFile);
81119c70:	e0bffc0f 	ldh	r2,-16(fp)
81119c74:	1009883a 	mov	r4,r2
81119c78:	111e9040 	call	8111e904 <cGetNextChar>
81119c7c:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119c80:	d0e00317 	ldw	r3,-32756(gp)
81119c84:	e0bff947 	ldb	r2,-27(fp)
81119c88:	10800044 	addi	r2,r2,1
81119c8c:	1885883a 	add	r2,r3,r2
81119c90:	10800003 	ldbu	r2,0(r2)
81119c94:	10803fcc 	andi	r2,r2,255
81119c98:	1080010c 	andi	r2,r2,4
81119c9c:	10000626 	beq	r2,zero,81119cb8 <vLoadDefaultETHConf+0x5b0>
								(*p_inteiro) = c;
81119ca0:	e0bffa17 	ldw	r2,-24(fp)
81119ca4:	e0fff943 	ldbu	r3,-27(fp)
81119ca8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119cac:	e0bffa17 	ldw	r2,-24(fp)
81119cb0:	10800044 	addi	r2,r2,1
81119cb4:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81119cb8:	e0bff947 	ldb	r2,-27(fp)
81119cbc:	10800ed8 	cmpnei	r2,r2,59
81119cc0:	103feb1e 	bne	r2,zero,81119c70 <__reset+0xfb0f9c70>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119cc4:	e0bffa17 	ldw	r2,-24(fp)
81119cc8:	00c00284 	movi	r3,10
81119ccc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81119cd0:	e0bffd04 	addi	r2,fp,-12
81119cd4:	1009883a 	mov	r4,r2
81119cd8:	11211d00 	call	811211d0 <atoi>
81119cdc:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81119ce0:	e0bffc8f 	ldh	r2,-14(fp)
81119ce4:	10800058 	cmpnei	r2,r2,1
81119ce8:	1000051e 	bne	r2,zero,81119d00 <vLoadDefaultETHConf+0x5f8>
							xConfEth.bDHCP = TRUE;
81119cec:	00a045b4 	movhi	r2,33046
81119cf0:	109aef04 	addi	r2,r2,27580
81119cf4:	00c00044 	movi	r3,1
81119cf8:	10c00615 	stw	r3,24(r2)
81119cfc:	00000306 	br	81119d0c <vLoadDefaultETHConf+0x604>
						else
							xConfEth.bDHCP = FALSE;
81119d00:	00a045b4 	movhi	r2,33046
81119d04:	109aef04 	addi	r2,r2,27580
81119d08:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119d0c:	e0bffd04 	addi	r2,fp,-12
81119d10:	e0bffa15 	stw	r2,-24(fp)

						break;
81119d14:	00008306 	br	81119f24 <vLoadDefaultETHConf+0x81c>

					case 'S':

						ucParser = 0;
81119d18:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119d1c:	e0bffc0f 	ldh	r2,-16(fp)
81119d20:	1009883a 	mov	r4,r2
81119d24:	111e9040 	call	8111e904 <cGetNextChar>
81119d28:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119d2c:	d0e00317 	ldw	r3,-32756(gp)
81119d30:	e0bff947 	ldb	r2,-27(fp)
81119d34:	10800044 	addi	r2,r2,1
81119d38:	1885883a 	add	r2,r3,r2
81119d3c:	10800003 	ldbu	r2,0(r2)
81119d40:	10803fcc 	andi	r2,r2,255
81119d44:	1080010c 	andi	r2,r2,4
81119d48:	10000626 	beq	r2,zero,81119d64 <vLoadDefaultETHConf+0x65c>
									(*p_inteiro) = c;
81119d4c:	e0bffa17 	ldw	r2,-24(fp)
81119d50:	e0fff943 	ldbu	r3,-27(fp)
81119d54:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119d58:	e0bffa17 	ldw	r2,-24(fp)
81119d5c:	10800044 	addi	r2,r2,1
81119d60:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119d64:	e0bff947 	ldb	r2,-27(fp)
81119d68:	10800ba0 	cmpeqi	r2,r2,46
81119d6c:	1000031e 	bne	r2,zero,81119d7c <vLoadDefaultETHConf+0x674>
81119d70:	e0bff947 	ldb	r2,-27(fp)
81119d74:	10800ed8 	cmpnei	r2,r2,59
81119d78:	103fe81e 	bne	r2,zero,81119d1c <__reset+0xfb0f9d1c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119d7c:	e0bffa17 	ldw	r2,-24(fp)
81119d80:	00c00284 	movi	r3,10
81119d84:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81119d88:	e0bff903 	ldbu	r2,-28(fp)
81119d8c:	108000e8 	cmpgeui	r2,r2,3
81119d90:	1000021e 	bne	r2,zero,81119d9c <vLoadDefaultETHConf+0x694>
81119d94:	e43ff903 	ldbu	r16,-28(fp)
81119d98:	00000106 	br	81119da0 <vLoadDefaultETHConf+0x698>
81119d9c:	040000c4 	movi	r16,3
81119da0:	e0bffd04 	addi	r2,fp,-12
81119da4:	1009883a 	mov	r4,r2
81119da8:	11211d00 	call	811211d0 <atoi>
81119dac:	1007883a 	mov	r3,r2
81119db0:	00a045b4 	movhi	r2,33046
81119db4:	109aef04 	addi	r2,r2,27580
81119db8:	1405883a 	add	r2,r2,r16
81119dbc:	10800204 	addi	r2,r2,8
81119dc0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119dc4:	e0bffd04 	addi	r2,fp,-12
81119dc8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119dcc:	e0bff903 	ldbu	r2,-28(fp)
81119dd0:	10800044 	addi	r2,r2,1
81119dd4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119dd8:	e0bff947 	ldb	r2,-27(fp)
81119ddc:	10800ed8 	cmpnei	r2,r2,59
81119de0:	103fce1e 	bne	r2,zero,81119d1c <__reset+0xfb0f9d1c>

						break;
81119de4:	00004f06 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case 'D':

						ucParser = 0;
81119de8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119dec:	e0bffc0f 	ldh	r2,-16(fp)
81119df0:	1009883a 	mov	r4,r2
81119df4:	111e9040 	call	8111e904 <cGetNextChar>
81119df8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119dfc:	d0e00317 	ldw	r3,-32756(gp)
81119e00:	e0bff947 	ldb	r2,-27(fp)
81119e04:	10800044 	addi	r2,r2,1
81119e08:	1885883a 	add	r2,r3,r2
81119e0c:	10800003 	ldbu	r2,0(r2)
81119e10:	10803fcc 	andi	r2,r2,255
81119e14:	1080010c 	andi	r2,r2,4
81119e18:	10000626 	beq	r2,zero,81119e34 <vLoadDefaultETHConf+0x72c>
									(*p_inteiro) = c;
81119e1c:	e0bffa17 	ldw	r2,-24(fp)
81119e20:	e0fff943 	ldbu	r3,-27(fp)
81119e24:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119e28:	e0bffa17 	ldw	r2,-24(fp)
81119e2c:	10800044 	addi	r2,r2,1
81119e30:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119e34:	e0bff947 	ldb	r2,-27(fp)
81119e38:	10800ba0 	cmpeqi	r2,r2,46
81119e3c:	1000031e 	bne	r2,zero,81119e4c <vLoadDefaultETHConf+0x744>
81119e40:	e0bff947 	ldb	r2,-27(fp)
81119e44:	10800ed8 	cmpnei	r2,r2,59
81119e48:	103fe81e 	bne	r2,zero,81119dec <__reset+0xfb0f9dec>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119e4c:	e0bffa17 	ldw	r2,-24(fp)
81119e50:	00c00284 	movi	r3,10
81119e54:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
81119e58:	e0bff903 	ldbu	r2,-28(fp)
81119e5c:	108000e8 	cmpgeui	r2,r2,3
81119e60:	1000021e 	bne	r2,zero,81119e6c <vLoadDefaultETHConf+0x764>
81119e64:	e43ff903 	ldbu	r16,-28(fp)
81119e68:	00000106 	br	81119e70 <vLoadDefaultETHConf+0x768>
81119e6c:	040000c4 	movi	r16,3
81119e70:	e0bffd04 	addi	r2,fp,-12
81119e74:	1009883a 	mov	r4,r2
81119e78:	11211d00 	call	811211d0 <atoi>
81119e7c:	1007883a 	mov	r3,r2
81119e80:	00a045b4 	movhi	r2,33046
81119e84:	109aef04 	addi	r2,r2,27580
81119e88:	1405883a 	add	r2,r2,r16
81119e8c:	10800304 	addi	r2,r2,12
81119e90:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119e94:	e0bffd04 	addi	r2,fp,-12
81119e98:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119e9c:	e0bff903 	ldbu	r2,-28(fp)
81119ea0:	10800044 	addi	r2,r2,1
81119ea4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119ea8:	e0bff947 	ldb	r2,-27(fp)
81119eac:	10800ed8 	cmpnei	r2,r2,59
81119eb0:	103fce1e 	bne	r2,zero,81119dec <__reset+0xfb0f9dec>

						break;						
81119eb4:	00001b06 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81119eb8:	e0bffc0f 	ldh	r2,-16(fp)
81119ebc:	1009883a 	mov	r4,r2
81119ec0:	111e8c40 	call	8111e8c4 <siCloseFile>
81119ec4:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81119ec8:	e0bffb17 	ldw	r2,-20(fp)
81119ecc:	1000071e 	bne	r2,zero,81119eec <vLoadDefaultETHConf+0x7e4>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81119ed0:	d0a06217 	ldw	r2,-32376(gp)
81119ed4:	100f883a 	mov	r7,r2
81119ed8:	01800784 	movi	r6,30
81119edc:	01400044 	movi	r5,1
81119ee0:	01204574 	movhi	r4,33045
81119ee4:	213a6504 	addi	r4,r4,-5740
81119ee8:	11219e00 	call	811219e0 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81119eec:	00800044 	movi	r2,1
81119ef0:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81119ef4:	00800044 	movi	r2,1
81119ef8:	e0bff715 	stw	r2,-36(fp)
						break;
81119efc:	00000906 	br	81119f24 <vLoadDefaultETHConf+0x81c>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
81119f00:	d0a06217 	ldw	r2,-32376(gp)
81119f04:	100f883a 	mov	r7,r2
81119f08:	01800844 	movi	r6,33
81119f0c:	01400044 	movi	r5,1
81119f10:	01204574 	movhi	r4,33045
81119f14:	213a6d04 	addi	r4,r4,-5708
81119f18:	11219e00 	call	811219e0 <fwrite>
						#endif
						break;
81119f1c:	00000106 	br	81119f24 <vLoadDefaultETHConf+0x81c>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81119f20:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81119f24:	e0bff817 	ldw	r2,-32(fp)
81119f28:	103e1526 	beq	r2,zero,81119780 <__reset+0xfb0f9780>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81119f2c:	00000f06 	br	81119f6c <vLoadDefaultETHConf+0x864>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
81119f30:	d0a06217 	ldw	r2,-32376(gp)
81119f34:	100f883a 	mov	r7,r2
81119f38:	01800604 	movi	r6,24
81119f3c:	01400044 	movi	r5,1
81119f40:	01204574 	movhi	r4,33045
81119f44:	213a7604 	addi	r4,r4,-5672
81119f48:	11219e00 	call	811219e0 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81119f4c:	00000706 	br	81119f6c <vLoadDefaultETHConf+0x864>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
81119f50:	d0a06217 	ldw	r2,-32376(gp)
81119f54:	100f883a 	mov	r7,r2
81119f58:	018004c4 	movi	r6,19
81119f5c:	01400044 	movi	r5,1
81119f60:	01204574 	movhi	r4,33045
81119f64:	213a7d04 	addi	r4,r4,-5644
81119f68:	11219e00 	call	811219e0 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81119f6c:	e0bff717 	ldw	r2,-36(fp)
81119f70:	1000541e 	bne	r2,zero,8111a0c4 <vLoadDefaultETHConf+0x9bc>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81119f74:	01204574 	movhi	r4,33045
81119f78:	213a8204 	addi	r4,r4,-5624
81119f7c:	11229900 	call	81122990 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81119f80:	01604574 	movhi	r5,33045
81119f84:	297a5c04 	addi	r5,r5,-5776
81119f88:	01204574 	movhi	r4,33045
81119f8c:	213a9604 	addi	r4,r4,-5544
81119f90:	112270c0 	call	8112270c <printf>


		xConfEth.siPortPUS = 17000;
81119f94:	00a045b4 	movhi	r2,33046
81119f98:	109aef04 	addi	r2,r2,27580
81119f9c:	00d09a04 	movi	r3,17000
81119fa0:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
81119fa4:	00a045b4 	movhi	r2,33046
81119fa8:	109aef04 	addi	r2,r2,27580
81119fac:	00fff004 	movi	r3,-64
81119fb0:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
81119fb4:	00a045b4 	movhi	r2,33046
81119fb8:	109aef04 	addi	r2,r2,27580
81119fbc:	00ffea04 	movi	r3,-88
81119fc0:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
81119fc4:	00a045b4 	movhi	r2,33046
81119fc8:	109aef04 	addi	r2,r2,27580
81119fcc:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81119fd0:	00a045b4 	movhi	r2,33046
81119fd4:	109aef04 	addi	r2,r2,27580
81119fd8:	00c00144 	movi	r3,5
81119fdc:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81119fe0:	00a045b4 	movhi	r2,33046
81119fe4:	109aef04 	addi	r2,r2,27580
81119fe8:	00fff004 	movi	r3,-64
81119fec:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81119ff0:	00a045b4 	movhi	r2,33046
81119ff4:	109aef04 	addi	r2,r2,27580
81119ff8:	00ffea04 	movi	r3,-88
81119ffc:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8111a000:	00a045b4 	movhi	r2,33046
8111a004:	109aef04 	addi	r2,r2,27580
8111a008:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8111a00c:	00a045b4 	movhi	r2,33046
8111a010:	109aef04 	addi	r2,r2,27580
8111a014:	00c00044 	movi	r3,1
8111a018:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8111a01c:	00a045b4 	movhi	r2,33046
8111a020:	109aef04 	addi	r2,r2,27580
8111a024:	00ffffc4 	movi	r3,-1
8111a028:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8111a02c:	00a045b4 	movhi	r2,33046
8111a030:	109aef04 	addi	r2,r2,27580
8111a034:	00ffffc4 	movi	r3,-1
8111a038:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8111a03c:	00a045b4 	movhi	r2,33046
8111a040:	109aef04 	addi	r2,r2,27580
8111a044:	00ffffc4 	movi	r3,-1
8111a048:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8111a04c:	00a045b4 	movhi	r2,33046
8111a050:	109aef04 	addi	r2,r2,27580
8111a054:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8111a058:	00a045b4 	movhi	r2,33046
8111a05c:	109aef04 	addi	r2,r2,27580
8111a060:	00ffff04 	movi	r3,-4
8111a064:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111a068:	00a045b4 	movhi	r2,33046
8111a06c:	109aef04 	addi	r2,r2,27580
8111a070:	00fffdc4 	movi	r3,-9
8111a074:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111a078:	00a045b4 	movhi	r2,33046
8111a07c:	109aef04 	addi	r2,r2,27580
8111a080:	00c018c4 	movi	r3,99
8111a084:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111a088:	00a045b4 	movhi	r2,33046
8111a08c:	109aef04 	addi	r2,r2,27580
8111a090:	00c01344 	movi	r3,77
8111a094:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111a098:	00a045b4 	movhi	r2,33046
8111a09c:	109aef04 	addi	r2,r2,27580
8111a0a0:	00c007c4 	movi	r3,31
8111a0a4:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111a0a8:	00a045b4 	movhi	r2,33046
8111a0ac:	109aef04 	addi	r2,r2,27580
8111a0b0:	00c01084 	movi	r3,66
8111a0b4:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111a0b8:	00a045b4 	movhi	r2,33046
8111a0bc:	109aef04 	addi	r2,r2,27580
8111a0c0:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111a0c4:	e0bff717 	ldw	r2,-36(fp)
}
8111a0c8:	e6ffff04 	addi	sp,fp,-4
8111a0cc:	dfc00217 	ldw	ra,8(sp)
8111a0d0:	df000117 	ldw	fp,4(sp)
8111a0d4:	dc000017 	ldw	r16,0(sp)
8111a0d8:	dec00304 	addi	sp,sp,12
8111a0dc:	f800283a 	ret

8111a0e0 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
8111a0e0:	defff004 	addi	sp,sp,-64
8111a0e4:	de00012e 	bgeu	sp,et,8111a0ec <vShowEthConfig+0xc>
8111a0e8:	003b68fa 	trap	3
8111a0ec:	dfc00f15 	stw	ra,60(sp)
8111a0f0:	df000e15 	stw	fp,56(sp)
8111a0f4:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111a0f8:	d0a06217 	ldw	r2,-32376(gp)
8111a0fc:	100f883a 	mov	r7,r2
8111a100:	018007c4 	movi	r6,31
8111a104:	01400044 	movi	r5,1
8111a108:	01204574 	movhi	r4,33045
8111a10c:	213a9c04 	addi	r4,r4,-5520
8111a110:	11219e00 	call	811219e0 <fwrite>

		memset(buffer,0,40);
8111a114:	01800a04 	movi	r6,40
8111a118:	000b883a 	mov	r5,zero
8111a11c:	e13ff604 	addi	r4,fp,-40
8111a120:	11225440 	call	81122544 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8111a124:	00a045b4 	movhi	r2,33046
8111a128:	109aef04 	addi	r2,r2,27580
8111a12c:	10800403 	ldbu	r2,16(r2)
8111a130:	11803fcc 	andi	r6,r2,255
8111a134:	00a045b4 	movhi	r2,33046
8111a138:	109aef04 	addi	r2,r2,27580
8111a13c:	10800443 	ldbu	r2,17(r2)
8111a140:	11c03fcc 	andi	r7,r2,255
8111a144:	00a045b4 	movhi	r2,33046
8111a148:	109aef04 	addi	r2,r2,27580
8111a14c:	10800483 	ldbu	r2,18(r2)
8111a150:	10c03fcc 	andi	r3,r2,255
8111a154:	00a045b4 	movhi	r2,33046
8111a158:	109aef04 	addi	r2,r2,27580
8111a15c:	108004c3 	ldbu	r2,19(r2)
8111a160:	11003fcc 	andi	r4,r2,255
8111a164:	00a045b4 	movhi	r2,33046
8111a168:	109aef04 	addi	r2,r2,27580
8111a16c:	10800503 	ldbu	r2,20(r2)
8111a170:	11403fcc 	andi	r5,r2,255
8111a174:	00a045b4 	movhi	r2,33046
8111a178:	109aef04 	addi	r2,r2,27580
8111a17c:	10800543 	ldbu	r2,21(r2)
8111a180:	10803fcc 	andi	r2,r2,255
8111a184:	d8800315 	stw	r2,12(sp)
8111a188:	d9400215 	stw	r5,8(sp)
8111a18c:	d9000115 	stw	r4,4(sp)
8111a190:	d8c00015 	stw	r3,0(sp)
8111a194:	01604574 	movhi	r5,33045
8111a198:	297aa404 	addi	r5,r5,-5488
8111a19c:	e13ff604 	addi	r4,fp,-40
8111a1a0:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, buffer );
8111a1a4:	d0a06217 	ldw	r2,-32376(gp)
8111a1a8:	e17ff604 	addi	r5,fp,-40
8111a1ac:	1009883a 	mov	r4,r2
8111a1b0:	11213440 	call	81121344 <fprintf>

		memset(buffer,0,40);
8111a1b4:	01800a04 	movi	r6,40
8111a1b8:	000b883a 	mov	r5,zero
8111a1bc:	e13ff604 	addi	r4,fp,-40
8111a1c0:	11225440 	call	81122544 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111a1c4:	00a045b4 	movhi	r2,33046
8111a1c8:	109aef04 	addi	r2,r2,27580
8111a1cc:	10800003 	ldbu	r2,0(r2)
8111a1d0:	11003fcc 	andi	r4,r2,255
8111a1d4:	00a045b4 	movhi	r2,33046
8111a1d8:	109aef04 	addi	r2,r2,27580
8111a1dc:	10800043 	ldbu	r2,1(r2)
8111a1e0:	11403fcc 	andi	r5,r2,255
8111a1e4:	00a045b4 	movhi	r2,33046
8111a1e8:	109aef04 	addi	r2,r2,27580
8111a1ec:	10800083 	ldbu	r2,2(r2)
8111a1f0:	10c03fcc 	andi	r3,r2,255
8111a1f4:	00a045b4 	movhi	r2,33046
8111a1f8:	109aef04 	addi	r2,r2,27580
8111a1fc:	108000c3 	ldbu	r2,3(r2)
8111a200:	10803fcc 	andi	r2,r2,255
8111a204:	d8800115 	stw	r2,4(sp)
8111a208:	d8c00015 	stw	r3,0(sp)
8111a20c:	280f883a 	mov	r7,r5
8111a210:	200d883a 	mov	r6,r4
8111a214:	01604574 	movhi	r5,33045
8111a218:	297aad04 	addi	r5,r5,-5452
8111a21c:	e13ff604 	addi	r4,fp,-40
8111a220:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, buffer );
8111a224:	d0a06217 	ldw	r2,-32376(gp)
8111a228:	e17ff604 	addi	r5,fp,-40
8111a22c:	1009883a 	mov	r4,r2
8111a230:	11213440 	call	81121344 <fprintf>

		memset(buffer,0,40);
8111a234:	01800a04 	movi	r6,40
8111a238:	000b883a 	mov	r5,zero
8111a23c:	e13ff604 	addi	r4,fp,-40
8111a240:	11225440 	call	81122544 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
8111a244:	00a045b4 	movhi	r2,33046
8111a248:	109aef04 	addi	r2,r2,27580
8111a24c:	10800103 	ldbu	r2,4(r2)
8111a250:	11003fcc 	andi	r4,r2,255
8111a254:	00a045b4 	movhi	r2,33046
8111a258:	109aef04 	addi	r2,r2,27580
8111a25c:	10800143 	ldbu	r2,5(r2)
8111a260:	11403fcc 	andi	r5,r2,255
8111a264:	00a045b4 	movhi	r2,33046
8111a268:	109aef04 	addi	r2,r2,27580
8111a26c:	10800183 	ldbu	r2,6(r2)
8111a270:	10c03fcc 	andi	r3,r2,255
8111a274:	00a045b4 	movhi	r2,33046
8111a278:	109aef04 	addi	r2,r2,27580
8111a27c:	108001c3 	ldbu	r2,7(r2)
8111a280:	10803fcc 	andi	r2,r2,255
8111a284:	d8800115 	stw	r2,4(sp)
8111a288:	d8c00015 	stw	r3,0(sp)
8111a28c:	280f883a 	mov	r7,r5
8111a290:	200d883a 	mov	r6,r4
8111a294:	01604574 	movhi	r5,33045
8111a298:	297ab304 	addi	r5,r5,-5428
8111a29c:	e13ff604 	addi	r4,fp,-40
8111a2a0:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, buffer );
8111a2a4:	d0a06217 	ldw	r2,-32376(gp)
8111a2a8:	e17ff604 	addi	r5,fp,-40
8111a2ac:	1009883a 	mov	r4,r2
8111a2b0:	11213440 	call	81121344 <fprintf>

		memset(buffer,0,40);
8111a2b4:	01800a04 	movi	r6,40
8111a2b8:	000b883a 	mov	r5,zero
8111a2bc:	e13ff604 	addi	r4,fp,-40
8111a2c0:	11225440 	call	81122544 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8111a2c4:	00a045b4 	movhi	r2,33046
8111a2c8:	109aef04 	addi	r2,r2,27580
8111a2cc:	10800203 	ldbu	r2,8(r2)
8111a2d0:	11003fcc 	andi	r4,r2,255
8111a2d4:	00a045b4 	movhi	r2,33046
8111a2d8:	109aef04 	addi	r2,r2,27580
8111a2dc:	10800243 	ldbu	r2,9(r2)
8111a2e0:	11403fcc 	andi	r5,r2,255
8111a2e4:	00a045b4 	movhi	r2,33046
8111a2e8:	109aef04 	addi	r2,r2,27580
8111a2ec:	10800283 	ldbu	r2,10(r2)
8111a2f0:	10c03fcc 	andi	r3,r2,255
8111a2f4:	00a045b4 	movhi	r2,33046
8111a2f8:	109aef04 	addi	r2,r2,27580
8111a2fc:	108002c3 	ldbu	r2,11(r2)
8111a300:	10803fcc 	andi	r2,r2,255
8111a304:	d8800115 	stw	r2,4(sp)
8111a308:	d8c00015 	stw	r3,0(sp)
8111a30c:	280f883a 	mov	r7,r5
8111a310:	200d883a 	mov	r6,r4
8111a314:	01604574 	movhi	r5,33045
8111a318:	297aba04 	addi	r5,r5,-5400
8111a31c:	e13ff604 	addi	r4,fp,-40
8111a320:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, buffer );
8111a324:	d0a06217 	ldw	r2,-32376(gp)
8111a328:	e17ff604 	addi	r5,fp,-40
8111a32c:	1009883a 	mov	r4,r2
8111a330:	11213440 	call	81121344 <fprintf>

		memset(buffer,0,40);
8111a334:	01800a04 	movi	r6,40
8111a338:	000b883a 	mov	r5,zero
8111a33c:	e13ff604 	addi	r4,fp,-40
8111a340:	11225440 	call	81122544 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
8111a344:	00a045b4 	movhi	r2,33046
8111a348:	109aef04 	addi	r2,r2,27580
8111a34c:	10800303 	ldbu	r2,12(r2)
8111a350:	11003fcc 	andi	r4,r2,255
8111a354:	00a045b4 	movhi	r2,33046
8111a358:	109aef04 	addi	r2,r2,27580
8111a35c:	10800343 	ldbu	r2,13(r2)
8111a360:	11403fcc 	andi	r5,r2,255
8111a364:	00a045b4 	movhi	r2,33046
8111a368:	109aef04 	addi	r2,r2,27580
8111a36c:	10800383 	ldbu	r2,14(r2)
8111a370:	10c03fcc 	andi	r3,r2,255
8111a374:	00a045b4 	movhi	r2,33046
8111a378:	109aef04 	addi	r2,r2,27580
8111a37c:	108003c3 	ldbu	r2,15(r2)
8111a380:	10803fcc 	andi	r2,r2,255
8111a384:	d8800115 	stw	r2,4(sp)
8111a388:	d8c00015 	stw	r3,0(sp)
8111a38c:	280f883a 	mov	r7,r5
8111a390:	200d883a 	mov	r6,r4
8111a394:	01604574 	movhi	r5,33045
8111a398:	297ac104 	addi	r5,r5,-5372
8111a39c:	e13ff604 	addi	r4,fp,-40
8111a3a0:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, buffer );
8111a3a4:	d0a06217 	ldw	r2,-32376(gp)
8111a3a8:	e17ff604 	addi	r5,fp,-40
8111a3ac:	1009883a 	mov	r4,r2
8111a3b0:	11213440 	call	81121344 <fprintf>

		memset(buffer,0,40);
8111a3b4:	01800a04 	movi	r6,40
8111a3b8:	000b883a 	mov	r5,zero
8111a3bc:	e13ff604 	addi	r4,fp,-40
8111a3c0:	11225440 	call	81122544 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8111a3c4:	00a045b4 	movhi	r2,33046
8111a3c8:	109aef04 	addi	r2,r2,27580
8111a3cc:	1080058b 	ldhu	r2,22(r2)
8111a3d0:	10bfffcc 	andi	r2,r2,65535
8111a3d4:	100d883a 	mov	r6,r2
8111a3d8:	01604574 	movhi	r5,33045
8111a3dc:	297ac804 	addi	r5,r5,-5344
8111a3e0:	e13ff604 	addi	r4,fp,-40
8111a3e4:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, buffer );
8111a3e8:	d0a06217 	ldw	r2,-32376(gp)
8111a3ec:	e17ff604 	addi	r5,fp,-40
8111a3f0:	1009883a 	mov	r4,r2
8111a3f4:	11213440 	call	81121344 <fprintf>

	}
8111a3f8:	0001883a 	nop
8111a3fc:	e037883a 	mov	sp,fp
8111a400:	dfc00117 	ldw	ra,4(sp)
8111a404:	df000017 	ldw	fp,0(sp)
8111a408:	dec00204 	addi	sp,sp,8
8111a40c:	f800283a 	ret

8111a410 <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
8111a410:	deffef04 	addi	sp,sp,-68
8111a414:	de00012e 	bgeu	sp,et,8111a41c <vLoadDebugConfs+0xc>
8111a418:	003b68fa 	trap	3
8111a41c:	dfc01015 	stw	ra,64(sp)
8111a420:	df000f15 	stw	fp,60(sp)
8111a424:	dc000e15 	stw	r16,56(sp)
8111a428:	df000f04 	addi	fp,sp,60
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8111a42c:	e03ff115 	stw	zero,-60(fp)
	bool bEOF = FALSE;
8111a430:	e03ff215 	stw	zero,-56(fp)
	bool close = FALSE;
8111a434:	e03ff515 	stw	zero,-44(fp)
	char c, *p_inteiro;
	char inteiro[8];
	char inteiroll[24];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8111a438:	d0a07617 	ldw	r2,-32296(gp)
8111a43c:	10800058 	cmpnei	r2,r2,1
8111a440:	10039e1e 	bne	r2,zero,8111b2bc <vLoadDebugConfs+0xeac>
8111a444:	111e7300 	call	8111e730 <bSDcardIsPresent>
8111a448:	10039c26 	beq	r2,zero,8111b2bc <vLoadDebugConfs+0xeac>
8111a44c:	111e7600 	call	8111e760 <bSDcardFAT16Check>
8111a450:	10039a26 	beq	r2,zero,8111b2bc <vLoadDebugConfs+0xeac>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8111a454:	01204574 	movhi	r4,33045
8111a458:	213acc04 	addi	r4,r4,-5328
8111a45c:	111e8880 	call	8111e888 <siOpenFile>
8111a460:	e0bff60d 	sth	r2,-40(fp)

		if ( siFile >= 0 ){
8111a464:	e0bff60f 	ldh	r2,-40(fp)
8111a468:	10038c16 	blt	r2,zero,8111b29c <vLoadDebugConfs+0xe8c>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8111a46c:	e0bff704 	addi	r2,fp,-36
8111a470:	01800204 	movi	r6,8
8111a474:	01400284 	movi	r5,10
8111a478:	1009883a 	mov	r4,r2
8111a47c:	11225440 	call	81122544 <memset>
			memset( &(inteiroll) , 10 , sizeof( inteiroll ) );
8111a480:	e0bff904 	addi	r2,fp,-28
8111a484:	01800604 	movi	r6,24
8111a488:	01400284 	movi	r5,10
8111a48c:	1009883a 	mov	r4,r2
8111a490:	11225440 	call	81122544 <memset>
			p_inteiro = inteiro;
8111a494:	e0bff704 	addi	r2,fp,-36
8111a498:	e0bff415 	stw	r2,-48(fp)

			do {
				c = cGetNextChar(siFile);
8111a49c:	e0bff60f 	ldh	r2,-40(fp)
8111a4a0:	1009883a 	mov	r4,r2
8111a4a4:	111e9040 	call	8111e904 <cGetNextChar>
8111a4a8:	e0bff345 	stb	r2,-51(fp)
				//printf("%c \n", c);
				switch (c) {
8111a4ac:	e0bff347 	ldb	r2,-51(fp)
8111a4b0:	10800084 	addi	r2,r2,2
8111a4b4:	10c01768 	cmpgeui	r3,r2,93
8111a4b8:	18036c1e 	bne	r3,zero,8111b26c <vLoadDebugConfs+0xe5c>
8111a4bc:	100690ba 	slli	r3,r2,2
8111a4c0:	00a044b4 	movhi	r2,33042
8111a4c4:	10a93504 	addi	r2,r2,-23340
8111a4c8:	1885883a 	add	r2,r3,r2
8111a4cc:	10800017 	ldw	r2,0(r2)
8111a4d0:	1000683a 	jmp	r2
8111a4d4:	8111a688 	cmpgei	r4,r16,18074
8111a4d8:	8111a67c 	xorhi	r4,r16,18073
8111a4dc:	8111b26c 	andhi	r4,r16,18121
8111a4e0:	8111b26c 	andhi	r4,r16,18121
8111a4e4:	8111b26c 	andhi	r4,r16,18121
8111a4e8:	8111b26c 	andhi	r4,r16,18121
8111a4ec:	8111b26c 	andhi	r4,r16,18121
8111a4f0:	8111b26c 	andhi	r4,r16,18121
8111a4f4:	8111b26c 	andhi	r4,r16,18121
8111a4f8:	8111b26c 	andhi	r4,r16,18121
8111a4fc:	8111b26c 	andhi	r4,r16,18121
8111a500:	8111b26c 	andhi	r4,r16,18121
8111a504:	8111b28c 	andi	r4,r16,18122
8111a508:	8111b26c 	andhi	r4,r16,18121
8111a50c:	8111b26c 	andhi	r4,r16,18121
8111a510:	8111b28c 	andi	r4,r16,18122
8111a514:	8111b26c 	andhi	r4,r16,18121
8111a518:	8111b26c 	andhi	r4,r16,18121
8111a51c:	8111b26c 	andhi	r4,r16,18121
8111a520:	8111b26c 	andhi	r4,r16,18121
8111a524:	8111b26c 	andhi	r4,r16,18121
8111a528:	8111b26c 	andhi	r4,r16,18121
8111a52c:	8111b26c 	andhi	r4,r16,18121
8111a530:	8111b26c 	andhi	r4,r16,18121
8111a534:	8111b26c 	andhi	r4,r16,18121
8111a538:	8111b26c 	andhi	r4,r16,18121
8111a53c:	8111b26c 	andhi	r4,r16,18121
8111a540:	8111b26c 	andhi	r4,r16,18121
8111a544:	8111b26c 	andhi	r4,r16,18121
8111a548:	8111b26c 	andhi	r4,r16,18121
8111a54c:	8111b26c 	andhi	r4,r16,18121
8111a550:	8111b26c 	andhi	r4,r16,18121
8111a554:	8111b26c 	andhi	r4,r16,18121
8111a558:	8111b26c 	andhi	r4,r16,18121
8111a55c:	8111b28c 	andi	r4,r16,18122
8111a560:	8111b26c 	andhi	r4,r16,18121
8111a564:	8111b26c 	andhi	r4,r16,18121
8111a568:	8111b26c 	andhi	r4,r16,18121
8111a56c:	8111b26c 	andhi	r4,r16,18121
8111a570:	8111b26c 	andhi	r4,r16,18121
8111a574:	8111b26c 	andhi	r4,r16,18121
8111a578:	8111a648 	cmpgei	r4,r16,18073
8111a57c:	8111b26c 	andhi	r4,r16,18121
8111a580:	8111b26c 	andhi	r4,r16,18121
8111a584:	8111b26c 	andhi	r4,r16,18121
8111a588:	8111b26c 	andhi	r4,r16,18121
8111a58c:	8111b26c 	andhi	r4,r16,18121
8111a590:	8111b26c 	andhi	r4,r16,18121
8111a594:	8111b26c 	andhi	r4,r16,18121
8111a598:	8111b26c 	andhi	r4,r16,18121
8111a59c:	8111b26c 	andhi	r4,r16,18121
8111a5a0:	8111b26c 	andhi	r4,r16,18121
8111a5a4:	8111b26c 	andhi	r4,r16,18121
8111a5a8:	8111b26c 	andhi	r4,r16,18121
8111a5ac:	8111b26c 	andhi	r4,r16,18121
8111a5b0:	8111b26c 	andhi	r4,r16,18121
8111a5b4:	8111b26c 	andhi	r4,r16,18121
8111a5b8:	8111b26c 	andhi	r4,r16,18121
8111a5bc:	8111b26c 	andhi	r4,r16,18121
8111a5c0:	8111b26c 	andhi	r4,r16,18121
8111a5c4:	8111b26c 	andhi	r4,r16,18121
8111a5c8:	8111b26c 	andhi	r4,r16,18121
8111a5cc:	8111b224 	muli	r4,r16,18120
8111a5d0:	8111b26c 	andhi	r4,r16,18121
8111a5d4:	8111b26c 	andhi	r4,r16,18121
8111a5d8:	8111b26c 	andhi	r4,r16,18121
8111a5dc:	8111b26c 	andhi	r4,r16,18121
8111a5e0:	8111a970 	cmpltui	r4,r16,18085
8111a5e4:	8111af1c 	xori	r4,r16,18108
8111a5e8:	8111ab80 	call	88111ab8 <__reset+0x20f1ab8>
8111a5ec:	8111acfc 	xorhi	r4,r16,18099
8111a5f0:	8111b26c 	andhi	r4,r16,18121
8111a5f4:	8111b26c 	andhi	r4,r16,18121
8111a5f8:	8111b26c 	andhi	r4,r16,18121
8111a5fc:	8111ac30 	cmpltui	r4,r16,18096
8111a600:	8111b26c 	andhi	r4,r16,18121
8111a604:	8111ae94 	ori	r4,r16,18106
8111a608:	8111ad84 	addi	r4,r16,18102
8111a60c:	8111aa20 	cmpeqi	r4,r16,18088
8111a610:	8111ae0c 	andi	r4,r16,18104
8111a614:	8111a810 	cmplti	r4,r16,18080
8111a618:	8111aad0 	cmplti	r4,r16,18091
8111a61c:	8111a760 	cmpeqi	r4,r16,18077
8111a620:	8111b26c 	andhi	r4,r16,18121
8111a624:	8111a8c0 	call	88111a8c <__reset+0x20f1a8c>
8111a628:	8111a6b0 	cmpltui	r4,r16,18074
8111a62c:	8111b0d4 	ori	r4,r16,18115
8111a630:	8111b03c 	xorhi	r4,r16,18112
8111a634:	8111b26c 	andhi	r4,r16,18121
8111a638:	8111afa4 	muli	r4,r16,18110
8111a63c:	8111b26c 	andhi	r4,r16,18121
8111a640:	8111b26c 	andhi	r4,r16,18121
8111a644:	8111b17c 	xorhi	r4,r16,18117
					case 39:// single quote '
						c = cGetNextChar(siFile);
8111a648:	e0bff60f 	ldh	r2,-40(fp)
8111a64c:	1009883a 	mov	r4,r2
8111a650:	111e9040 	call	8111e904 <cGetNextChar>
8111a654:	e0bff345 	stb	r2,-51(fp)
						while ( c != 39 ){
8111a658:	00000406 	br	8111a66c <vLoadDebugConfs+0x25c>
							c = cGetNextChar(siFile);
8111a65c:	e0bff60f 	ldh	r2,-40(fp)
8111a660:	1009883a 	mov	r4,r2
8111a664:	111e9040 	call	8111e904 <cGetNextChar>
8111a668:	e0bff345 	stb	r2,-51(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111a66c:	e0bff347 	ldb	r2,-51(fp)
8111a670:	108009d8 	cmpnei	r2,r2,39
8111a674:	103ff91e 	bne	r2,zero,8111a65c <__reset+0xfb0fa65c>
							c = cGetNextChar(siFile);
						}
						break;
8111a678:	00030506 	br	8111b290 <vLoadDebugConfs+0xe80>
					case -1: 	//EOF
						bEOF = TRUE;
8111a67c:	00800044 	movi	r2,1
8111a680:	e0bff215 	stw	r2,-56(fp)
						break;
8111a684:	00030206 	br	8111b290 <vLoadDebugConfs+0xe80>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
8111a688:	d0a06217 	ldw	r2,-32376(gp)
8111a68c:	100f883a 	mov	r7,r2
8111a690:	018006c4 	movi	r6,27
8111a694:	01400044 	movi	r5,1
8111a698:	01204574 	movhi	r4,33045
8111a69c:	213a5e04 	addi	r4,r4,-5768
8111a6a0:	11219e00 	call	811219e0 <fwrite>
						#endif
						bEOF = TRUE;
8111a6a4:	00800044 	movi	r2,1
8111a6a8:	e0bff215 	stw	r2,-56(fp)
						break;
8111a6ac:	0002f806 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
8111a6b0:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a6b4:	e0bff60f 	ldh	r2,-40(fp)
8111a6b8:	1009883a 	mov	r4,r2
8111a6bc:	111e9040 	call	8111e904 <cGetNextChar>
8111a6c0:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111a6c4:	d0e00317 	ldw	r3,-32756(gp)
8111a6c8:	e0bff347 	ldb	r2,-51(fp)
8111a6cc:	10800044 	addi	r2,r2,1
8111a6d0:	1885883a 	add	r2,r3,r2
8111a6d4:	10800003 	ldbu	r2,0(r2)
8111a6d8:	10803fcc 	andi	r2,r2,255
8111a6dc:	1080010c 	andi	r2,r2,4
8111a6e0:	10000626 	beq	r2,zero,8111a6fc <vLoadDebugConfs+0x2ec>
									(*p_inteiro) = c;
8111a6e4:	e0bff417 	ldw	r2,-48(fp)
8111a6e8:	e0fff343 	ldbu	r3,-51(fp)
8111a6ec:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a6f0:	e0bff417 	ldw	r2,-48(fp)
8111a6f4:	10800044 	addi	r2,r2,1
8111a6f8:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a6fc:	e0bff347 	ldb	r2,-51(fp)
8111a700:	10800ba0 	cmpeqi	r2,r2,46
8111a704:	1000031e 	bne	r2,zero,8111a714 <vLoadDebugConfs+0x304>
8111a708:	e0bff347 	ldb	r2,-51(fp)
8111a70c:	10800ed8 	cmpnei	r2,r2,59
8111a710:	103fe81e 	bne	r2,zero,8111a6b4 <__reset+0xfb0fa6b4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a714:	e0bff417 	ldw	r2,-48(fp)
8111a718:	00c00284 	movi	r3,10
8111a71c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = atoi( inteiro );
8111a720:	e0bff704 	addi	r2,fp,-36
8111a724:	1009883a 	mov	r4,r2
8111a728:	11211d00 	call	811211d0 <atoi>
8111a72c:	1007883a 	mov	r3,r2
8111a730:	00a045b4 	movhi	r2,33046
8111a734:	109ade04 	addi	r2,r2,27512
8111a738:	10c0068d 	sth	r3,26(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a73c:	e0bff704 	addi	r2,fp,-36
8111a740:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111a744:	e0bff303 	ldbu	r2,-52(fp)
8111a748:	10800044 	addi	r2,r2,1
8111a74c:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111a750:	e0bff347 	ldb	r2,-51(fp)
8111a754:	10800ed8 	cmpnei	r2,r2,59
8111a758:	103fd61e 	bne	r2,zero,8111a6b4 <__reset+0xfb0fa6b4>

						break;
8111a75c:	0002cc06 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'P':
						ucParser = 0;
8111a760:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a764:	e0bff60f 	ldh	r2,-40(fp)
8111a768:	1009883a 	mov	r4,r2
8111a76c:	111e9040 	call	8111e904 <cGetNextChar>
8111a770:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111a774:	d0e00317 	ldw	r3,-32756(gp)
8111a778:	e0bff347 	ldb	r2,-51(fp)
8111a77c:	10800044 	addi	r2,r2,1
8111a780:	1885883a 	add	r2,r3,r2
8111a784:	10800003 	ldbu	r2,0(r2)
8111a788:	10803fcc 	andi	r2,r2,255
8111a78c:	1080010c 	andi	r2,r2,4
8111a790:	10000626 	beq	r2,zero,8111a7ac <vLoadDebugConfs+0x39c>
									(*p_inteiro) = c;
8111a794:	e0bff417 	ldw	r2,-48(fp)
8111a798:	e0fff343 	ldbu	r3,-51(fp)
8111a79c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a7a0:	e0bff417 	ldw	r2,-48(fp)
8111a7a4:	10800044 	addi	r2,r2,1
8111a7a8:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a7ac:	e0bff347 	ldb	r2,-51(fp)
8111a7b0:	10800ba0 	cmpeqi	r2,r2,46
8111a7b4:	1000031e 	bne	r2,zero,8111a7c4 <vLoadDebugConfs+0x3b4>
8111a7b8:	e0bff347 	ldb	r2,-51(fp)
8111a7bc:	10800ed8 	cmpnei	r2,r2,59
8111a7c0:	103fe81e 	bne	r2,zero,8111a764 <__reset+0xfb0fa764>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a7c4:	e0bff417 	ldw	r2,-48(fp)
8111a7c8:	00c00284 	movi	r3,10
8111a7cc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = atoi( inteiro );
8111a7d0:	e0bff704 	addi	r2,fp,-36
8111a7d4:	1009883a 	mov	r4,r2
8111a7d8:	11211d00 	call	811211d0 <atoi>
8111a7dc:	1007883a 	mov	r3,r2
8111a7e0:	00a045b4 	movhi	r2,33046
8111a7e4:	109ade04 	addi	r2,r2,27512
8111a7e8:	10c0048d 	sth	r3,18(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a7ec:	e0bff704 	addi	r2,fp,-36
8111a7f0:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111a7f4:	e0bff303 	ldbu	r2,-52(fp)
8111a7f8:	10800044 	addi	r2,r2,1
8111a7fc:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111a800:	e0bff347 	ldb	r2,-51(fp)
8111a804:	10800ed8 	cmpnei	r2,r2,59
8111a808:	103fd61e 	bne	r2,zero,8111a764 <__reset+0xfb0fa764>

						break;
8111a80c:	0002a006 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'N':
						ucParser = 0;
8111a810:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a814:	e0bff60f 	ldh	r2,-40(fp)
8111a818:	1009883a 	mov	r4,r2
8111a81c:	111e9040 	call	8111e904 <cGetNextChar>
8111a820:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111a824:	d0e00317 	ldw	r3,-32756(gp)
8111a828:	e0bff347 	ldb	r2,-51(fp)
8111a82c:	10800044 	addi	r2,r2,1
8111a830:	1885883a 	add	r2,r3,r2
8111a834:	10800003 	ldbu	r2,0(r2)
8111a838:	10803fcc 	andi	r2,r2,255
8111a83c:	1080010c 	andi	r2,r2,4
8111a840:	10000626 	beq	r2,zero,8111a85c <vLoadDebugConfs+0x44c>
									(*p_inteiro) = c;
8111a844:	e0bff417 	ldw	r2,-48(fp)
8111a848:	e0fff343 	ldbu	r3,-51(fp)
8111a84c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a850:	e0bff417 	ldw	r2,-48(fp)
8111a854:	10800044 	addi	r2,r2,1
8111a858:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a85c:	e0bff347 	ldb	r2,-51(fp)
8111a860:	10800ba0 	cmpeqi	r2,r2,46
8111a864:	1000031e 	bne	r2,zero,8111a874 <vLoadDebugConfs+0x464>
8111a868:	e0bff347 	ldb	r2,-51(fp)
8111a86c:	10800ed8 	cmpnei	r2,r2,59
8111a870:	103fe81e 	bne	r2,zero,8111a814 <__reset+0xfb0fa814>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a874:	e0bff417 	ldw	r2,-48(fp)
8111a878:	00c00284 	movi	r3,10
8111a87c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = atoi( inteiro );
8111a880:	e0bff704 	addi	r2,fp,-36
8111a884:	1009883a 	mov	r4,r2
8111a888:	11211d00 	call	811211d0 <atoi>
8111a88c:	1007883a 	mov	r3,r2
8111a890:	00a045b4 	movhi	r2,33046
8111a894:	109ade04 	addi	r2,r2,27512
8111a898:	10c0040d 	sth	r3,16(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a89c:	e0bff704 	addi	r2,fp,-36
8111a8a0:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111a8a4:	e0bff303 	ldbu	r2,-52(fp)
8111a8a8:	10800044 	addi	r2,r2,1
8111a8ac:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111a8b0:	e0bff347 	ldb	r2,-51(fp)
8111a8b4:	10800ed8 	cmpnei	r2,r2,59
8111a8b8:	103fd61e 	bne	r2,zero,8111a814 <__reset+0xfb0fa814>

						break;
8111a8bc:	00027406 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'R':
						ucParser = 0;
8111a8c0:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a8c4:	e0bff60f 	ldh	r2,-40(fp)
8111a8c8:	1009883a 	mov	r4,r2
8111a8cc:	111e9040 	call	8111e904 <cGetNextChar>
8111a8d0:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111a8d4:	d0e00317 	ldw	r3,-32756(gp)
8111a8d8:	e0bff347 	ldb	r2,-51(fp)
8111a8dc:	10800044 	addi	r2,r2,1
8111a8e0:	1885883a 	add	r2,r3,r2
8111a8e4:	10800003 	ldbu	r2,0(r2)
8111a8e8:	10803fcc 	andi	r2,r2,255
8111a8ec:	1080010c 	andi	r2,r2,4
8111a8f0:	10000626 	beq	r2,zero,8111a90c <vLoadDebugConfs+0x4fc>
									(*p_inteiro) = c;
8111a8f4:	e0bff417 	ldw	r2,-48(fp)
8111a8f8:	e0fff343 	ldbu	r3,-51(fp)
8111a8fc:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a900:	e0bff417 	ldw	r2,-48(fp)
8111a904:	10800044 	addi	r2,r2,1
8111a908:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a90c:	e0bff347 	ldb	r2,-51(fp)
8111a910:	10800ba0 	cmpeqi	r2,r2,46
8111a914:	1000031e 	bne	r2,zero,8111a924 <vLoadDebugConfs+0x514>
8111a918:	e0bff347 	ldb	r2,-51(fp)
8111a91c:	10800ed8 	cmpnei	r2,r2,59
8111a920:	103fe81e 	bne	r2,zero,8111a8c4 <__reset+0xfb0fa8c4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a924:	e0bff417 	ldw	r2,-48(fp)
8111a928:	00c00284 	movi	r3,10
8111a92c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = atoi( inteiro );
8111a930:	e0bff704 	addi	r2,fp,-36
8111a934:	1009883a 	mov	r4,r2
8111a938:	11211d00 	call	811211d0 <atoi>
8111a93c:	1007883a 	mov	r3,r2
8111a940:	00a045b4 	movhi	r2,33046
8111a944:	109ade04 	addi	r2,r2,27512
8111a948:	10c00c0d 	sth	r3,48(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a94c:	e0bff704 	addi	r2,fp,-36
8111a950:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111a954:	e0bff303 	ldbu	r2,-52(fp)
8111a958:	10800044 	addi	r2,r2,1
8111a95c:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111a960:	e0bff347 	ldb	r2,-51(fp)
8111a964:	10800ed8 	cmpnei	r2,r2,59
8111a968:	103fd61e 	bne	r2,zero,8111a8c4 <__reset+0xfb0fa8c4>

						break;
8111a96c:	00024806 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'A':
						ucParser = 0;
8111a970:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a974:	e0bff60f 	ldh	r2,-40(fp)
8111a978:	1009883a 	mov	r4,r2
8111a97c:	111e9040 	call	8111e904 <cGetNextChar>
8111a980:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111a984:	d0e00317 	ldw	r3,-32756(gp)
8111a988:	e0bff347 	ldb	r2,-51(fp)
8111a98c:	10800044 	addi	r2,r2,1
8111a990:	1885883a 	add	r2,r3,r2
8111a994:	10800003 	ldbu	r2,0(r2)
8111a998:	10803fcc 	andi	r2,r2,255
8111a99c:	1080010c 	andi	r2,r2,4
8111a9a0:	10000626 	beq	r2,zero,8111a9bc <vLoadDebugConfs+0x5ac>
									(*p_inteiro) = c;
8111a9a4:	e0bff417 	ldw	r2,-48(fp)
8111a9a8:	e0fff343 	ldbu	r3,-51(fp)
8111a9ac:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a9b0:	e0bff417 	ldw	r2,-48(fp)
8111a9b4:	10800044 	addi	r2,r2,1
8111a9b8:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a9bc:	e0bff347 	ldb	r2,-51(fp)
8111a9c0:	10800ba0 	cmpeqi	r2,r2,46
8111a9c4:	1000031e 	bne	r2,zero,8111a9d4 <vLoadDebugConfs+0x5c4>
8111a9c8:	e0bff347 	ldb	r2,-51(fp)
8111a9cc:	10800ed8 	cmpnei	r2,r2,59
8111a9d0:	103fe81e 	bne	r2,zero,8111a974 <__reset+0xfb0fa974>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a9d4:	e0bff417 	ldw	r2,-48(fp)
8111a9d8:	00c00284 	movi	r3,10
8111a9dc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = atoi( inteiro );
8111a9e0:	e0bff704 	addi	r2,fp,-36
8111a9e4:	1009883a 	mov	r4,r2
8111a9e8:	11211d00 	call	811211d0 <atoi>
8111a9ec:	1007883a 	mov	r3,r2
8111a9f0:	00a045b4 	movhi	r2,33046
8111a9f4:	109ade04 	addi	r2,r2,27512
8111a9f8:	10c00c8d 	sth	r3,50(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a9fc:	e0bff704 	addi	r2,fp,-36
8111aa00:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111aa04:	e0bff303 	ldbu	r2,-52(fp)
8111aa08:	10800044 	addi	r2,r2,1
8111aa0c:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111aa10:	e0bff347 	ldb	r2,-51(fp)
8111aa14:	10800ed8 	cmpnei	r2,r2,59
8111aa18:	103fd61e 	bne	r2,zero,8111a974 <__reset+0xfb0fa974>

						break;
8111aa1c:	00021c06 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'L':
						ucParser = 0;
8111aa20:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111aa24:	e0bff60f 	ldh	r2,-40(fp)
8111aa28:	1009883a 	mov	r4,r2
8111aa2c:	111e9040 	call	8111e904 <cGetNextChar>
8111aa30:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111aa34:	d0e00317 	ldw	r3,-32756(gp)
8111aa38:	e0bff347 	ldb	r2,-51(fp)
8111aa3c:	10800044 	addi	r2,r2,1
8111aa40:	1885883a 	add	r2,r3,r2
8111aa44:	10800003 	ldbu	r2,0(r2)
8111aa48:	10803fcc 	andi	r2,r2,255
8111aa4c:	1080010c 	andi	r2,r2,4
8111aa50:	10000626 	beq	r2,zero,8111aa6c <vLoadDebugConfs+0x65c>
									(*p_inteiro) = c;
8111aa54:	e0bff417 	ldw	r2,-48(fp)
8111aa58:	e0fff343 	ldbu	r3,-51(fp)
8111aa5c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111aa60:	e0bff417 	ldw	r2,-48(fp)
8111aa64:	10800044 	addi	r2,r2,1
8111aa68:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111aa6c:	e0bff347 	ldb	r2,-51(fp)
8111aa70:	10800ba0 	cmpeqi	r2,r2,46
8111aa74:	1000031e 	bne	r2,zero,8111aa84 <vLoadDebugConfs+0x674>
8111aa78:	e0bff347 	ldb	r2,-51(fp)
8111aa7c:	10800ed8 	cmpnei	r2,r2,59
8111aa80:	103fe81e 	bne	r2,zero,8111aa24 <__reset+0xfb0faa24>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111aa84:	e0bff417 	ldw	r2,-48(fp)
8111aa88:	00c00284 	movi	r3,10
8111aa8c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = atoi( inteiro );
8111aa90:	e0bff704 	addi	r2,fp,-36
8111aa94:	1009883a 	mov	r4,r2
8111aa98:	11211d00 	call	811211d0 <atoi>
8111aa9c:	1007883a 	mov	r3,r2
8111aaa0:	00a045b4 	movhi	r2,33046
8111aaa4:	109ade04 	addi	r2,r2,27512
8111aaa8:	10c0060d 	sth	r3,24(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111aaac:	e0bff704 	addi	r2,fp,-36
8111aab0:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111aab4:	e0bff303 	ldbu	r2,-52(fp)
8111aab8:	10800044 	addi	r2,r2,1
8111aabc:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111aac0:	e0bff347 	ldb	r2,-51(fp)
8111aac4:	10800ed8 	cmpnei	r2,r2,59
8111aac8:	103fd61e 	bne	r2,zero,8111aa24 <__reset+0xfb0faa24>

						break;
8111aacc:	0001f006 	br	8111b290 <vLoadDebugConfs+0xe80>

					case 'O':
						ucParser = 0;
8111aad0:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111aad4:	e0bff60f 	ldh	r2,-40(fp)
8111aad8:	1009883a 	mov	r4,r2
8111aadc:	111e9040 	call	8111e904 <cGetNextChar>
8111aae0:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111aae4:	d0e00317 	ldw	r3,-32756(gp)
8111aae8:	e0bff347 	ldb	r2,-51(fp)
8111aaec:	10800044 	addi	r2,r2,1
8111aaf0:	1885883a 	add	r2,r3,r2
8111aaf4:	10800003 	ldbu	r2,0(r2)
8111aaf8:	10803fcc 	andi	r2,r2,255
8111aafc:	1080010c 	andi	r2,r2,4
8111ab00:	10000626 	beq	r2,zero,8111ab1c <vLoadDebugConfs+0x70c>
									(*p_inteiro) = c;
8111ab04:	e0bff417 	ldw	r2,-48(fp)
8111ab08:	e0fff343 	ldbu	r3,-51(fp)
8111ab0c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ab10:	e0bff417 	ldw	r2,-48(fp)
8111ab14:	10800044 	addi	r2,r2,1
8111ab18:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ab1c:	e0bff347 	ldb	r2,-51(fp)
8111ab20:	10800ba0 	cmpeqi	r2,r2,46
8111ab24:	1000031e 	bne	r2,zero,8111ab34 <vLoadDebugConfs+0x724>
8111ab28:	e0bff347 	ldb	r2,-51(fp)
8111ab2c:	10800ed8 	cmpnei	r2,r2,59
8111ab30:	103fe81e 	bne	r2,zero,8111aad4 <__reset+0xfb0faad4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ab34:	e0bff417 	ldw	r2,-48(fp)
8111ab38:	00c00284 	movi	r3,10
8111ab3c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = atoi( inteiro );
8111ab40:	e0bff704 	addi	r2,fp,-36
8111ab44:	1009883a 	mov	r4,r2
8111ab48:	11211d00 	call	811211d0 <atoi>
8111ab4c:	1007883a 	mov	r3,r2
8111ab50:	00a045b4 	movhi	r2,33046
8111ab54:	109ade04 	addi	r2,r2,27512
8111ab58:	10c0050d 	sth	r3,20(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ab5c:	e0bff704 	addi	r2,fp,-36
8111ab60:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111ab64:	e0bff303 	ldbu	r2,-52(fp)
8111ab68:	10800044 	addi	r2,r2,1
8111ab6c:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111ab70:	e0bff347 	ldb	r2,-51(fp)
8111ab74:	10800ed8 	cmpnei	r2,r2,59
8111ab78:	103fd61e 	bne	r2,zero,8111aad4 <__reset+0xfb0faad4>

						break;
8111ab7c:	0001c406 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'C':
						ucParser = 0;
8111ab80:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ab84:	e0bff60f 	ldh	r2,-40(fp)
8111ab88:	1009883a 	mov	r4,r2
8111ab8c:	111e9040 	call	8111e904 <cGetNextChar>
8111ab90:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111ab94:	d0e00317 	ldw	r3,-32756(gp)
8111ab98:	e0bff347 	ldb	r2,-51(fp)
8111ab9c:	10800044 	addi	r2,r2,1
8111aba0:	1885883a 	add	r2,r3,r2
8111aba4:	10800003 	ldbu	r2,0(r2)
8111aba8:	10803fcc 	andi	r2,r2,255
8111abac:	1080010c 	andi	r2,r2,4
8111abb0:	10000626 	beq	r2,zero,8111abcc <vLoadDebugConfs+0x7bc>
									(*p_inteiro) = c;
8111abb4:	e0bff417 	ldw	r2,-48(fp)
8111abb8:	e0fff343 	ldbu	r3,-51(fp)
8111abbc:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111abc0:	e0bff417 	ldw	r2,-48(fp)
8111abc4:	10800044 	addi	r2,r2,1
8111abc8:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111abcc:	e0bff347 	ldb	r2,-51(fp)
8111abd0:	10800ba0 	cmpeqi	r2,r2,46
8111abd4:	1000031e 	bne	r2,zero,8111abe4 <vLoadDebugConfs+0x7d4>
8111abd8:	e0bff347 	ldb	r2,-51(fp)
8111abdc:	10800ed8 	cmpnei	r2,r2,59
8111abe0:	103fe81e 	bne	r2,zero,8111ab84 <__reset+0xfb0fab84>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111abe4:	e0bff417 	ldw	r2,-48(fp)
8111abe8:	00c00284 	movi	r3,10
8111abec:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = atoi( inteiro );
8111abf0:	e0bff704 	addi	r2,fp,-36
8111abf4:	1009883a 	mov	r4,r2
8111abf8:	11211d00 	call	811211d0 <atoi>
8111abfc:	1007883a 	mov	r3,r2
8111ac00:	00a045b4 	movhi	r2,33046
8111ac04:	109ade04 	addi	r2,r2,27512
8111ac08:	10c0058d 	sth	r3,22(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111ac0c:	e0bff704 	addi	r2,fp,-36
8111ac10:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111ac14:	e0bff303 	ldbu	r2,-52(fp)
8111ac18:	10800044 	addi	r2,r2,1
8111ac1c:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111ac20:	e0bff347 	ldb	r2,-51(fp)
8111ac24:	10800ed8 	cmpnei	r2,r2,59
8111ac28:	103fd61e 	bne	r2,zero,8111ab84 <__reset+0xfb0fab84>

						break;
8111ac2c:	00019806 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'H':

						ucParser = 0;
8111ac30:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111ac34:	e0bff60f 	ldh	r2,-40(fp)
8111ac38:	1009883a 	mov	r4,r2
8111ac3c:	111e9040 	call	8111e904 <cGetNextChar>
8111ac40:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
8111ac44:	d0e00317 	ldw	r3,-32756(gp)
8111ac48:	e0bff347 	ldb	r2,-51(fp)
8111ac4c:	10800044 	addi	r2,r2,1
8111ac50:	1885883a 	add	r2,r3,r2
8111ac54:	10800003 	ldbu	r2,0(r2)
8111ac58:	10803fcc 	andi	r2,r2,255
8111ac5c:	1080010c 	andi	r2,r2,4
8111ac60:	10000626 	beq	r2,zero,8111ac7c <vLoadDebugConfs+0x86c>
									(*p_inteiro) = c;
8111ac64:	e0bff417 	ldw	r2,-48(fp)
8111ac68:	e0fff343 	ldbu	r3,-51(fp)
8111ac6c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111ac70:	e0bff417 	ldw	r2,-48(fp)
8111ac74:	10800044 	addi	r2,r2,1
8111ac78:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111ac7c:	e0bff347 	ldb	r2,-51(fp)
8111ac80:	10800ba0 	cmpeqi	r2,r2,46
8111ac84:	1000031e 	bne	r2,zero,8111ac94 <vLoadDebugConfs+0x884>
8111ac88:	e0bff347 	ldb	r2,-51(fp)
8111ac8c:	10800ed8 	cmpnei	r2,r2,59
8111ac90:	103fe81e 	bne	r2,zero,8111ac34 <__reset+0xfb0fac34>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ac94:	e0bff417 	ldw	r2,-48(fp)
8111ac98:	00c00284 	movi	r3,10
8111ac9c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.HK[min_sim(ucParser,15)] = atoi( inteiro );
8111aca0:	e0bff303 	ldbu	r2,-52(fp)
8111aca4:	108003e8 	cmpgeui	r2,r2,15
8111aca8:	1000021e 	bne	r2,zero,8111acb4 <vLoadDebugConfs+0x8a4>
8111acac:	e43ff303 	ldbu	r16,-52(fp)
8111acb0:	00000106 	br	8111acb8 <vLoadDebugConfs+0x8a8>
8111acb4:	040003c4 	movi	r16,15
8111acb8:	e0bff704 	addi	r2,fp,-36
8111acbc:	1009883a 	mov	r4,r2
8111acc0:	11211d00 	call	811211d0 <atoi>
8111acc4:	1007883a 	mov	r3,r2
8111acc8:	00a045b4 	movhi	r2,33046
8111accc:	109ade04 	addi	r2,r2,27512
8111acd0:	1405883a 	add	r2,r2,r16
8111acd4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111acd8:	e0bff704 	addi	r2,fp,-36
8111acdc:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
8111ace0:	e0bff303 	ldbu	r2,-52(fp)
8111ace4:	10800044 	addi	r2,r2,1
8111ace8:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111acec:	e0bff347 	ldb	r2,-51(fp)
8111acf0:	10800ed8 	cmpnei	r2,r2,59
8111acf4:	103fcf1e 	bne	r2,zero,8111ac34 <__reset+0xfb0fac34>

						break;
8111acf8:	00016506 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'D':

						do {
							c = cGetNextChar(siFile);
8111acfc:	e0bff60f 	ldh	r2,-40(fp)
8111ad00:	1009883a 	mov	r4,r2
8111ad04:	111e9040 	call	8111e904 <cGetNextChar>
8111ad08:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111ad0c:	d0e00317 	ldw	r3,-32756(gp)
8111ad10:	e0bff347 	ldb	r2,-51(fp)
8111ad14:	10800044 	addi	r2,r2,1
8111ad18:	1885883a 	add	r2,r3,r2
8111ad1c:	10800003 	ldbu	r2,0(r2)
8111ad20:	10803fcc 	andi	r2,r2,255
8111ad24:	1080010c 	andi	r2,r2,4
8111ad28:	10000626 	beq	r2,zero,8111ad44 <vLoadDebugConfs+0x934>
								(*p_inteiro) = c;
8111ad2c:	e0bff417 	ldw	r2,-48(fp)
8111ad30:	e0fff343 	ldbu	r3,-51(fp)
8111ad34:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ad38:	e0bff417 	ldw	r2,-48(fp)
8111ad3c:	10800044 	addi	r2,r2,1
8111ad40:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ad44:	e0bff347 	ldb	r2,-51(fp)
8111ad48:	10800ed8 	cmpnei	r2,r2,59
8111ad4c:	103feb1e 	bne	r2,zero,8111acfc <__reset+0xfb0facfc>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ad50:	e0bff417 	ldw	r2,-48(fp)
8111ad54:	00c00284 	movi	r3,10
8111ad58:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDelay = atoi( inteiro );
8111ad5c:	e0bff704 	addi	r2,fp,-36
8111ad60:	1009883a 	mov	r4,r2
8111ad64:	11211d00 	call	811211d0 <atoi>
8111ad68:	1007883a 	mov	r3,r2
8111ad6c:	00a045b4 	movhi	r2,33046
8111ad70:	109ade04 	addi	r2,r2,27512
8111ad74:	10c0070d 	sth	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ad78:	e0bff704 	addi	r2,fp,-36
8111ad7c:	e0bff415 	stw	r2,-48(fp)

						break;
8111ad80:	00014306 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111ad84:	e0bff60f 	ldh	r2,-40(fp)
8111ad88:	1009883a 	mov	r4,r2
8111ad8c:	111e9040 	call	8111e904 <cGetNextChar>
8111ad90:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111ad94:	d0e00317 	ldw	r3,-32756(gp)
8111ad98:	e0bff347 	ldb	r2,-51(fp)
8111ad9c:	10800044 	addi	r2,r2,1
8111ada0:	1885883a 	add	r2,r3,r2
8111ada4:	10800003 	ldbu	r2,0(r2)
8111ada8:	10803fcc 	andi	r2,r2,255
8111adac:	1080010c 	andi	r2,r2,4
8111adb0:	10000626 	beq	r2,zero,8111adcc <vLoadDebugConfs+0x9bc>
								(*p_inteiro) = c;
8111adb4:	e0bff417 	ldw	r2,-48(fp)
8111adb8:	e0fff343 	ldbu	r3,-51(fp)
8111adbc:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111adc0:	e0bff417 	ldw	r2,-48(fp)
8111adc4:	10800044 	addi	r2,r2,1
8111adc8:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111adcc:	e0bff347 	ldb	r2,-51(fp)
8111add0:	10800ed8 	cmpnei	r2,r2,59
8111add4:	103feb1e 	bne	r2,zero,8111ad84 <__reset+0xfb0fad84>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111add8:	e0bff417 	ldw	r2,-48(fp)
8111addc:	00c00284 	movi	r3,10
8111ade0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = atoi( inteiro );
8111ade4:	e0bff704 	addi	r2,fp,-36
8111ade8:	1009883a 	mov	r4,r2
8111adec:	11211d00 	call	811211d0 <atoi>
8111adf0:	1007883a 	mov	r3,r2
8111adf4:	00a045b4 	movhi	r2,33046
8111adf8:	109ade04 	addi	r2,r2,27512
8111adfc:	10c00a15 	stw	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ae00:	e0bff704 	addi	r2,fp,-36
8111ae04:	e0bff415 	stw	r2,-48(fp)

						break;
8111ae08:	00012106 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8111ae0c:	e0bff60f 	ldh	r2,-40(fp)
8111ae10:	1009883a 	mov	r4,r2
8111ae14:	111e9040 	call	8111e904 <cGetNextChar>
8111ae18:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111ae1c:	d0e00317 	ldw	r3,-32756(gp)
8111ae20:	e0bff347 	ldb	r2,-51(fp)
8111ae24:	10800044 	addi	r2,r2,1
8111ae28:	1885883a 	add	r2,r3,r2
8111ae2c:	10800003 	ldbu	r2,0(r2)
8111ae30:	10803fcc 	andi	r2,r2,255
8111ae34:	1080010c 	andi	r2,r2,4
8111ae38:	10000626 	beq	r2,zero,8111ae54 <vLoadDebugConfs+0xa44>
								(*p_inteiro) = c;
8111ae3c:	e0bff417 	ldw	r2,-48(fp)
8111ae40:	e0fff343 	ldbu	r3,-51(fp)
8111ae44:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111ae48:	e0bff417 	ldw	r2,-48(fp)
8111ae4c:	10800044 	addi	r2,r2,1
8111ae50:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111ae54:	e0bff347 	ldb	r2,-51(fp)
8111ae58:	10800ed8 	cmpnei	r2,r2,59
8111ae5c:	103feb1e 	bne	r2,zero,8111ae0c <__reset+0xfb0fae0c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111ae60:	e0bff417 	ldw	r2,-48(fp)
8111ae64:	00c00284 	movi	r3,10
8111ae68:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = atoi( inteiro );
8111ae6c:	e0bff704 	addi	r2,fp,-36
8111ae70:	1009883a 	mov	r4,r2
8111ae74:	11211d00 	call	811211d0 <atoi>
8111ae78:	1007883a 	mov	r3,r2
8111ae7c:	00a045b4 	movhi	r2,33046
8111ae80:	109ade04 	addi	r2,r2,27512
8111ae84:	10c00b15 	stw	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111ae88:	e0bff704 	addi	r2,fp,-36
8111ae8c:	e0bff415 	stw	r2,-48(fp)

						break;
8111ae90:	0000ff06 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8111ae94:	e0bff60f 	ldh	r2,-40(fp)
8111ae98:	1009883a 	mov	r4,r2
8111ae9c:	111e9040 	call	8111e904 <cGetNextChar>
8111aea0:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111aea4:	d0e00317 	ldw	r3,-32756(gp)
8111aea8:	e0bff347 	ldb	r2,-51(fp)
8111aeac:	10800044 	addi	r2,r2,1
8111aeb0:	1885883a 	add	r2,r3,r2
8111aeb4:	10800003 	ldbu	r2,0(r2)
8111aeb8:	10803fcc 	andi	r2,r2,255
8111aebc:	1080010c 	andi	r2,r2,4
8111aec0:	10000626 	beq	r2,zero,8111aedc <vLoadDebugConfs+0xacc>
								(*p_inteiro) = c;
8111aec4:	e0bff417 	ldw	r2,-48(fp)
8111aec8:	e0fff343 	ldbu	r3,-51(fp)
8111aecc:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111aed0:	e0bff417 	ldw	r2,-48(fp)
8111aed4:	10800044 	addi	r2,r2,1
8111aed8:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111aedc:	e0bff347 	ldb	r2,-51(fp)
8111aee0:	10800ed8 	cmpnei	r2,r2,59
8111aee4:	103feb1e 	bne	r2,zero,8111ae94 <__reset+0xfb0fae94>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111aee8:	e0bff417 	ldw	r2,-48(fp)
8111aeec:	00c00284 	movi	r3,10
8111aef0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = atoi( inteiro );
8111aef4:	e0bff704 	addi	r2,fp,-36
8111aef8:	1009883a 	mov	r4,r2
8111aefc:	11211d00 	call	811211d0 <atoi>
8111af00:	1007883a 	mov	r3,r2
8111af04:	00a045b4 	movhi	r2,33046
8111af08:	109ade04 	addi	r2,r2,27512
8111af0c:	10c00915 	stw	r3,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111af10:	e0bff704 	addi	r2,fp,-36
8111af14:	e0bff415 	stw	r2,-48(fp)

						break;
8111af18:	0000dd06 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'B':

						do {
							c = cGetNextChar(siFile);
8111af1c:	e0bff60f 	ldh	r2,-40(fp)
8111af20:	1009883a 	mov	r4,r2
8111af24:	111e9040 	call	8111e904 <cGetNextChar>
8111af28:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111af2c:	d0e00317 	ldw	r3,-32756(gp)
8111af30:	e0bff347 	ldb	r2,-51(fp)
8111af34:	10800044 	addi	r2,r2,1
8111af38:	1885883a 	add	r2,r3,r2
8111af3c:	10800003 	ldbu	r2,0(r2)
8111af40:	10803fcc 	andi	r2,r2,255
8111af44:	1080010c 	andi	r2,r2,4
8111af48:	10000626 	beq	r2,zero,8111af64 <vLoadDebugConfs+0xb54>
								(*p_inteiro) = c;
8111af4c:	e0bff417 	ldw	r2,-48(fp)
8111af50:	e0fff343 	ldbu	r3,-51(fp)
8111af54:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111af58:	e0bff417 	ldw	r2,-48(fp)
8111af5c:	10800044 	addi	r2,r2,1
8111af60:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111af64:	e0bff347 	ldb	r2,-51(fp)
8111af68:	10800ed8 	cmpnei	r2,r2,59
8111af6c:	103feb1e 	bne	r2,zero,8111af1c <__reset+0xfb0faf1c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111af70:	e0bff417 	ldw	r2,-48(fp)
8111af74:	00c00284 	movi	r3,10
8111af78:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiLinkNFEE0 = atoi( inteiro );
8111af7c:	e0bff704 	addi	r2,fp,-36
8111af80:	1009883a 	mov	r4,r2
8111af84:	11211d00 	call	811211d0 <atoi>
8111af88:	1007883a 	mov	r3,r2
8111af8c:	00a045b4 	movhi	r2,33046
8111af90:	109ade04 	addi	r2,r2,27512
8111af94:	10c0100d 	sth	r3,64(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111af98:	e0bff704 	addi	r2,fp,-36
8111af9c:	e0bff415 	stw	r2,-48(fp)

						break;
8111afa0:	0000bb06 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'W':

						p_inteiro = inteiroll;
8111afa4:	e0bff904 	addi	r2,fp,-28
8111afa8:	e0bff415 	stw	r2,-48(fp)
						do {
							c = cGetNextChar(siFile);
8111afac:	e0bff60f 	ldh	r2,-40(fp)
8111afb0:	1009883a 	mov	r4,r2
8111afb4:	111e9040 	call	8111e904 <cGetNextChar>
8111afb8:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111afbc:	d0e00317 	ldw	r3,-32756(gp)
8111afc0:	e0bff347 	ldb	r2,-51(fp)
8111afc4:	10800044 	addi	r2,r2,1
8111afc8:	1885883a 	add	r2,r3,r2
8111afcc:	10800003 	ldbu	r2,0(r2)
8111afd0:	10803fcc 	andi	r2,r2,255
8111afd4:	1080010c 	andi	r2,r2,4
8111afd8:	10000626 	beq	r2,zero,8111aff4 <vLoadDebugConfs+0xbe4>
								(*p_inteiro) = c;
8111afdc:	e0bff417 	ldw	r2,-48(fp)
8111afe0:	e0fff343 	ldbu	r3,-51(fp)
8111afe4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111afe8:	e0bff417 	ldw	r2,-48(fp)
8111afec:	10800044 	addi	r2,r2,1
8111aff0:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111aff4:	e0bff347 	ldb	r2,-51(fp)
8111aff8:	10800ed8 	cmpnei	r2,r2,59
8111affc:	103feb1e 	bne	r2,zero,8111afac <__reset+0xfb0fafac>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b000:	e0bff417 	ldw	r2,-48(fp)
8111b004:	00c00284 	movi	r3,10
8111b008:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ullMaskMSB = (unsigned long)atoll( inteiroll );
8111b00c:	e0bff904 	addi	r2,fp,-28
8111b010:	1009883a 	mov	r4,r2
8111b014:	11211e80 	call	811211e8 <atoll>
8111b018:	1009883a 	mov	r4,r2
8111b01c:	180b883a 	mov	r5,r3
8111b020:	2007883a 	mov	r3,r4
8111b024:	00a045b4 	movhi	r2,33046
8111b028:	109ade04 	addi	r2,r2,27512
8111b02c:	10c00e15 	stw	r3,56(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b030:	e0bff704 	addi	r2,fp,-36
8111b034:	e0bff415 	stw	r2,-48(fp)

						break;
8111b038:	00009506 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'U':

						p_inteiro = inteiroll;
8111b03c:	e0bff904 	addi	r2,fp,-28
8111b040:	e0bff415 	stw	r2,-48(fp)
						do {
							c = cGetNextChar(siFile);
8111b044:	e0bff60f 	ldh	r2,-40(fp)
8111b048:	1009883a 	mov	r4,r2
8111b04c:	111e9040 	call	8111e904 <cGetNextChar>
8111b050:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b054:	d0e00317 	ldw	r3,-32756(gp)
8111b058:	e0bff347 	ldb	r2,-51(fp)
8111b05c:	10800044 	addi	r2,r2,1
8111b060:	1885883a 	add	r2,r3,r2
8111b064:	10800003 	ldbu	r2,0(r2)
8111b068:	10803fcc 	andi	r2,r2,255
8111b06c:	1080010c 	andi	r2,r2,4
8111b070:	10000626 	beq	r2,zero,8111b08c <vLoadDebugConfs+0xc7c>
								(*p_inteiro) = c;
8111b074:	e0bff417 	ldw	r2,-48(fp)
8111b078:	e0fff343 	ldbu	r3,-51(fp)
8111b07c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b080:	e0bff417 	ldw	r2,-48(fp)
8111b084:	10800044 	addi	r2,r2,1
8111b088:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b08c:	e0bff347 	ldb	r2,-51(fp)
8111b090:	10800ed8 	cmpnei	r2,r2,59
8111b094:	103feb1e 	bne	r2,zero,8111b044 <__reset+0xfb0fb044>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b098:	e0bff417 	ldw	r2,-48(fp)
8111b09c:	00c00284 	movi	r3,10
8111b0a0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ullMaskLSB = (unsigned long)atoll( inteiroll );
8111b0a4:	e0bff904 	addi	r2,fp,-28
8111b0a8:	1009883a 	mov	r4,r2
8111b0ac:	11211e80 	call	811211e8 <atoll>
8111b0b0:	1009883a 	mov	r4,r2
8111b0b4:	180b883a 	mov	r5,r3
8111b0b8:	2007883a 	mov	r3,r4
8111b0bc:	00a045b4 	movhi	r2,33046
8111b0c0:	109ade04 	addi	r2,r2,27512
8111b0c4:	10c00d15 	stw	r3,52(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b0c8:	e0bff704 	addi	r2,fp,-36
8111b0cc:	e0bff415 	stw	r2,-48(fp)

						break;
8111b0d0:	00006f06 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8111b0d4:	e0bff60f 	ldh	r2,-40(fp)
8111b0d8:	1009883a 	mov	r4,r2
8111b0dc:	111e9040 	call	8111e904 <cGetNextChar>
8111b0e0:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b0e4:	d0e00317 	ldw	r3,-32756(gp)
8111b0e8:	e0bff347 	ldb	r2,-51(fp)
8111b0ec:	10800044 	addi	r2,r2,1
8111b0f0:	1885883a 	add	r2,r3,r2
8111b0f4:	10800003 	ldbu	r2,0(r2)
8111b0f8:	10803fcc 	andi	r2,r2,255
8111b0fc:	1080010c 	andi	r2,r2,4
8111b100:	10000626 	beq	r2,zero,8111b11c <vLoadDebugConfs+0xd0c>
								(*p_inteiro) = c;
8111b104:	e0bff417 	ldw	r2,-48(fp)
8111b108:	e0fff343 	ldbu	r3,-51(fp)
8111b10c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b110:	e0bff417 	ldw	r2,-48(fp)
8111b114:	10800044 	addi	r2,r2,1
8111b118:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b11c:	e0bff347 	ldb	r2,-51(fp)
8111b120:	10800ed8 	cmpnei	r2,r2,59
8111b124:	103feb1e 	bne	r2,zero,8111b0d4 <__reset+0xfb0fb0d4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b128:	e0bff417 	ldw	r2,-48(fp)
8111b12c:	00c00284 	movi	r3,10
8111b130:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111b134:	e0bff704 	addi	r2,fp,-36
8111b138:	1009883a 	mov	r4,r2
8111b13c:	11211d00 	call	811211d0 <atoi>
8111b140:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8111b144:	e0bff68f 	ldh	r2,-38(fp)
8111b148:	10800058 	cmpnei	r2,r2,1
8111b14c:	1000051e 	bne	r2,zero,8111b164 <vLoadDebugConfs+0xd54>
							xDefaults.bDataPacket = TRUE;
8111b150:	00a045b4 	movhi	r2,33046
8111b154:	109ade04 	addi	r2,r2,27512
8111b158:	00c00044 	movi	r3,1
8111b15c:	10c00815 	stw	r3,32(r2)
8111b160:	00000306 	br	8111b170 <vLoadDebugConfs+0xd60>
						else
							xDefaults.bDataPacket = FALSE;
8111b164:	00a045b4 	movhi	r2,33046
8111b168:	109ade04 	addi	r2,r2,27512
8111b16c:	10000815 	stw	zero,32(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b170:	e0bff704 	addi	r2,fp,-36
8111b174:	e0bff415 	stw	r2,-48(fp)

						break;
8111b178:	00004506 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 'Z':

						do {
							c = cGetNextChar(siFile);
8111b17c:	e0bff60f 	ldh	r2,-40(fp)
8111b180:	1009883a 	mov	r4,r2
8111b184:	111e9040 	call	8111e904 <cGetNextChar>
8111b188:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
8111b18c:	d0e00317 	ldw	r3,-32756(gp)
8111b190:	e0bff347 	ldb	r2,-51(fp)
8111b194:	10800044 	addi	r2,r2,1
8111b198:	1885883a 	add	r2,r3,r2
8111b19c:	10800003 	ldbu	r2,0(r2)
8111b1a0:	10803fcc 	andi	r2,r2,255
8111b1a4:	1080010c 	andi	r2,r2,4
8111b1a8:	10000626 	beq	r2,zero,8111b1c4 <vLoadDebugConfs+0xdb4>
								(*p_inteiro) = c;
8111b1ac:	e0bff417 	ldw	r2,-48(fp)
8111b1b0:	e0fff343 	ldbu	r3,-51(fp)
8111b1b4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111b1b8:	e0bff417 	ldw	r2,-48(fp)
8111b1bc:	10800044 	addi	r2,r2,1
8111b1c0:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111b1c4:	e0bff347 	ldb	r2,-51(fp)
8111b1c8:	10800ed8 	cmpnei	r2,r2,59
8111b1cc:	103feb1e 	bne	r2,zero,8111b17c <__reset+0xfb0fb17c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111b1d0:	e0bff417 	ldw	r2,-48(fp)
8111b1d4:	00c00284 	movi	r3,10
8111b1d8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111b1dc:	e0bff704 	addi	r2,fp,-36
8111b1e0:	1009883a 	mov	r4,r2
8111b1e4:	11211d00 	call	811211d0 <atoi>
8111b1e8:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8111b1ec:	e0bff68f 	ldh	r2,-38(fp)
8111b1f0:	10800058 	cmpnei	r2,r2,1
8111b1f4:	1000051e 	bne	r2,zero,8111b20c <vLoadDebugConfs+0xdfc>
							xDefaults.bMaskSD = TRUE;
8111b1f8:	00a045b4 	movhi	r2,33046
8111b1fc:	109ade04 	addi	r2,r2,27512
8111b200:	00c00044 	movi	r3,1
8111b204:	10c00f15 	stw	r3,60(r2)
8111b208:	00000306 	br	8111b218 <vLoadDebugConfs+0xe08>
						else
							xDefaults.bMaskSD = FALSE;
8111b20c:	00a045b4 	movhi	r2,33046
8111b210:	109ade04 	addi	r2,r2,27512
8111b214:	10000f15 	stw	zero,60(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111b218:	e0bff704 	addi	r2,fp,-36
8111b21c:	e0bff415 	stw	r2,-48(fp)

						break;
8111b220:	00001b06 	br	8111b290 <vLoadDebugConfs+0xe80>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111b224:	e0bff60f 	ldh	r2,-40(fp)
8111b228:	1009883a 	mov	r4,r2
8111b22c:	111e8c40 	call	8111e8c4 <siCloseFile>
8111b230:	e0bff515 	stw	r2,-44(fp)
						if (close == FALSE){
8111b234:	e0bff517 	ldw	r2,-44(fp)
8111b238:	1000071e 	bne	r2,zero,8111b258 <vLoadDebugConfs+0xe48>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111b23c:	d0a06217 	ldw	r2,-32376(gp)
8111b240:	100f883a 	mov	r7,r2
8111b244:	01800784 	movi	r6,30
8111b248:	01400044 	movi	r5,1
8111b24c:	01204574 	movhi	r4,33045
8111b250:	213a6504 	addi	r4,r4,-5740
8111b254:	11219e00 	call	811219e0 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111b258:	00800044 	movi	r2,1
8111b25c:	e0bff215 	stw	r2,-56(fp)
						bSuccess = TRUE; //pensar melhor
8111b260:	00800044 	movi	r2,1
8111b264:	e0bff115 	stw	r2,-60(fp)
						break;
8111b268:	00000906 	br	8111b290 <vLoadDebugConfs+0xe80>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111b26c:	d0a06217 	ldw	r2,-32376(gp)
8111b270:	100f883a 	mov	r7,r2
8111b274:	01800844 	movi	r6,33
8111b278:	01400044 	movi	r5,1
8111b27c:	01204574 	movhi	r4,33045
8111b280:	213a6d04 	addi	r4,r4,-5708
8111b284:	11219e00 	call	811219e0 <fwrite>
						#endif
						break;
8111b288:	00000106 	br	8111b290 <vLoadDebugConfs+0xe80>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111b28c:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111b290:	e0bff217 	ldw	r2,-56(fp)
8111b294:	103c8126 	beq	r2,zero,8111a49c <__reset+0xfb0fa49c>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111b298:	00000f06 	br	8111b2d8 <vLoadDebugConfs+0xec8>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111b29c:	d0a06217 	ldw	r2,-32376(gp)
8111b2a0:	100f883a 	mov	r7,r2
8111b2a4:	01800604 	movi	r6,24
8111b2a8:	01400044 	movi	r5,1
8111b2ac:	01204574 	movhi	r4,33045
8111b2b0:	213a7604 	addi	r4,r4,-5672
8111b2b4:	11219e00 	call	811219e0 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111b2b8:	00000706 	br	8111b2d8 <vLoadDebugConfs+0xec8>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111b2bc:	d0a06217 	ldw	r2,-32376(gp)
8111b2c0:	100f883a 	mov	r7,r2
8111b2c4:	018004c4 	movi	r6,19
8111b2c8:	01400044 	movi	r5,1
8111b2cc:	01204574 	movhi	r4,33045
8111b2d0:	213a7d04 	addi	r4,r4,-5644
8111b2d4:	11219e00 	call	811219e0 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111b2d8:	e0bff117 	ldw	r2,-60(fp)
8111b2dc:	1000391e 	bne	r2,zero,8111b3c4 <vLoadDebugConfs+0xfb4>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Debug Configs: Could not load the default values from SDCard\n");
8111b2e0:	01204574 	movhi	r4,33045
8111b2e4:	213acf04 	addi	r4,r4,-5316
8111b2e8:	11229900 	call	81122990 <puts>
		printf("Can't find the file:'%s'.\n", ETH_FILE_NAME);
8111b2ec:	01604574 	movhi	r5,33045
8111b2f0:	297a5c04 	addi	r5,r5,-5776
8111b2f4:	01204574 	movhi	r4,33045
8111b2f8:	213adf04 	addi	r4,r4,-5252
8111b2fc:	112270c0 	call	8112270c <printf>



		xDefaults.usiRows = 4510;
8111b300:	00a045b4 	movhi	r2,33046
8111b304:	109ade04 	addi	r2,r2,27512
8111b308:	00c46784 	movi	r3,4510
8111b30c:	10c0060d 	sth	r3,24(r2)
		xDefaults.usiCols = 2255;
8111b310:	00a045b4 	movhi	r2,33046
8111b314:	109ade04 	addi	r2,r2,27512
8111b318:	00c233c4 	movi	r3,2255
8111b31c:	10c0058d 	sth	r3,22(r2)
		xDefaults.usiOLN = 30;
8111b320:	00a045b4 	movhi	r2,33046
8111b324:	109ade04 	addi	r2,r2,27512
8111b328:	00c00784 	movi	r3,30
8111b32c:	10c0050d 	sth	r3,20(r2)
		xDefaults.usiPreScanSerial = 25;
8111b330:	00a045b4 	movhi	r2,33046
8111b334:	109ade04 	addi	r2,r2,27512
8111b338:	00c00644 	movi	r3,25
8111b33c:	10c0048d 	sth	r3,18(r2)
		xDefaults.usiOverScanSerial = 15;
8111b340:	00a045b4 	movhi	r2,33046
8111b344:	109ade04 	addi	r2,r2,27512
8111b348:	00c003c4 	movi	r3,15
8111b34c:	10c0040d 	sth	r3,16(r2)
		xDefaults.usiSyncPeriod = 6250;
8111b350:	00a045b4 	movhi	r2,33046
8111b354:	109ade04 	addi	r2,r2,27512
8111b358:	00c61a84 	movi	r3,6250
8111b35c:	10c0068d 	sth	r3,26(r2)
		xDefaults.usiDelay = 20;
8111b360:	00a045b4 	movhi	r2,33046
8111b364:	109ade04 	addi	r2,r2,27512
8111b368:	00c00504 	movi	r3,20
8111b36c:	10c0070d 	sth	r3,28(r2)
		xDefaults.bDataPacket = TRUE;
8111b370:	00a045b4 	movhi	r2,33046
8111b374:	109ade04 	addi	r2,r2,27512
8111b378:	00c00044 	movi	r3,1
8111b37c:	10c00815 	stw	r3,32(r2)
		xDefaults.ulLineDelay = 0;
8111b380:	00a045b4 	movhi	r2,33046
8111b384:	109ade04 	addi	r2,r2,27512
8111b388:	10000915 	stw	zero,36(r2)
		xDefaults.ulColDelay = 0;
8111b38c:	00a045b4 	movhi	r2,33046
8111b390:	109ade04 	addi	r2,r2,27512
8111b394:	10000a15 	stw	zero,40(r2)
		xDefaults.ulADCPixelDelay = 0;
8111b398:	00a045b4 	movhi	r2,33046
8111b39c:	109ade04 	addi	r2,r2,27512
8111b3a0:	10000b15 	stw	zero,44(r2)
		xDefaults.ucLogicalAddr = 0x51;
8111b3a4:	00a045b4 	movhi	r2,33046
8111b3a8:	109ade04 	addi	r2,r2,27512
8111b3ac:	00c01444 	movi	r3,81
8111b3b0:	10c00c8d 	sth	r3,50(r2)
		xDefaults.ucRmapKey = 0xD1;
8111b3b4:	00a045b4 	movhi	r2,33046
8111b3b8:	109ade04 	addi	r2,r2,27512
8111b3bc:	00c03444 	movi	r3,209
8111b3c0:	10c00c0d 	sth	r3,48(r2)

	}

	return bSuccess;
8111b3c4:	e0bff117 	ldw	r2,-60(fp)
}
8111b3c8:	e6ffff04 	addi	sp,fp,-4
8111b3cc:	dfc00217 	ldw	ra,8(sp)
8111b3d0:	df000117 	ldw	fp,4(sp)
8111b3d4:	dc000017 	ldw	r16,0(sp)
8111b3d8:	dec00304 	addi	sp,sp,12
8111b3dc:	f800283a 	ret

8111b3e0 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111b3e0:	defffb04 	addi	sp,sp,-20
8111b3e4:	de00012e 	bgeu	sp,et,8111b3ec <ucCrc8+0xc>
8111b3e8:	003b68fa 	trap	3
8111b3ec:	df000415 	stw	fp,16(sp)
8111b3f0:	df000404 	addi	fp,sp,16
8111b3f4:	e13ffd15 	stw	r4,-12(fp)
8111b3f8:	e17ffe15 	stw	r5,-8(fp)
8111b3fc:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111b400:	e0bffe17 	ldw	r2,-8(fp)
8111b404:	1000021e 	bne	r2,zero,8111b410 <ucCrc8+0x30>
        return 0;
8111b408:	0005883a 	mov	r2,zero
8111b40c:	00001906 	br	8111b474 <ucCrc8+0x94>
    crc &= 0xff;
8111b410:	e0bffd17 	ldw	r2,-12(fp)
8111b414:	10803fcc 	andi	r2,r2,255
8111b418:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8111b41c:	e0fffe17 	ldw	r3,-8(fp)
8111b420:	e0bfff17 	ldw	r2,-4(fp)
8111b424:	1885883a 	add	r2,r3,r2
8111b428:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8111b42c:	00000d06 	br	8111b464 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111b430:	e0bffe17 	ldw	r2,-8(fp)
8111b434:	10c00044 	addi	r3,r2,1
8111b438:	e0fffe15 	stw	r3,-8(fp)
8111b43c:	10800003 	ldbu	r2,0(r2)
8111b440:	10c03fcc 	andi	r3,r2,255
8111b444:	e0bffd17 	ldw	r2,-12(fp)
8111b448:	1886f03a 	xor	r3,r3,r2
8111b44c:	00a04574 	movhi	r2,33045
8111b450:	10bae5c4 	addi	r2,r2,-5225
8111b454:	10c5883a 	add	r2,r2,r3
8111b458:	10800003 	ldbu	r2,0(r2)
8111b45c:	10803fcc 	andi	r2,r2,255
8111b460:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111b464:	e0fffe17 	ldw	r3,-8(fp)
8111b468:	e0bffc17 	ldw	r2,-16(fp)
8111b46c:	18bff036 	bltu	r3,r2,8111b430 <__reset+0xfb0fb430>
        crc = crc8_table[crc ^ *data++];
    return crc;
8111b470:	e0bffd17 	ldw	r2,-12(fp)
}
8111b474:	e037883a 	mov	sp,fp
8111b478:	df000017 	ldw	fp,0(sp)
8111b47c:	dec00104 	addi	sp,sp,4
8111b480:	f800283a 	ret

8111b484 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111b484:	defffb04 	addi	sp,sp,-20
8111b488:	de00012e 	bgeu	sp,et,8111b490 <ucCrc8wInit+0xc>
8111b48c:	003b68fa 	trap	3
8111b490:	dfc00415 	stw	ra,16(sp)
8111b494:	df000315 	stw	fp,12(sp)
8111b498:	df000304 	addi	fp,sp,12
8111b49c:	e13ffe15 	stw	r4,-8(fp)
8111b4a0:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111b4a4:	000d883a 	mov	r6,zero
8111b4a8:	000b883a 	mov	r5,zero
8111b4ac:	0009883a 	mov	r4,zero
8111b4b0:	111b3e00 	call	8111b3e0 <ucCrc8>
8111b4b4:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111b4b8:	e0bffd03 	ldbu	r2,-12(fp)
8111b4bc:	e1bfff17 	ldw	r6,-4(fp)
8111b4c0:	e17ffe17 	ldw	r5,-8(fp)
8111b4c4:	1009883a 	mov	r4,r2
8111b4c8:	111b3e00 	call	8111b3e0 <ucCrc8>
}
8111b4cc:	e037883a 	mov	sp,fp
8111b4d0:	dfc00117 	ldw	ra,4(sp)
8111b4d4:	df000017 	ldw	fp,0(sp)
8111b4d8:	dec00204 	addi	sp,sp,8
8111b4dc:	f800283a 	ret

8111b4e0 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111b4e0:	defffc04 	addi	sp,sp,-16
8111b4e4:	de00012e 	bgeu	sp,et,8111b4ec <vDataControllerInit+0xc>
8111b4e8:	003b68fa 	trap	3
8111b4ec:	df000315 	stw	fp,12(sp)
8111b4f0:	df000304 	addi	fp,sp,12
8111b4f4:	e13ffe15 	stw	r4,-8(fp)
8111b4f8:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8111b4fc:	e0bffe17 	ldw	r2,-8(fp)
8111b500:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111b504:	e03ffd05 	stb	zero,-12(fp)
8111b508:	00001c06 	br	8111b57c <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8111b50c:	e0bffd03 	ldbu	r2,-12(fp)
8111b510:	e0fffd03 	ldbu	r3,-12(fp)
8111b514:	18c09624 	muli	r3,r3,600
8111b518:	e13fff17 	ldw	r4,-4(fp)
8111b51c:	20c7883a 	add	r3,r4,r3
8111b520:	e13ffe17 	ldw	r4,-8(fp)
8111b524:	10800084 	addi	r2,r2,2
8111b528:	1085883a 	add	r2,r2,r2
8111b52c:	1085883a 	add	r2,r2,r2
8111b530:	2085883a 	add	r2,r4,r2
8111b534:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111b538:	e17ffd03 	ldbu	r5,-12(fp)
8111b53c:	e0bffd03 	ldbu	r2,-12(fp)
8111b540:	e0ffff17 	ldw	r3,-4(fp)
8111b544:	108025c4 	addi	r2,r2,151
8111b548:	1085883a 	add	r2,r2,r2
8111b54c:	1085883a 	add	r2,r2,r2
8111b550:	1885883a 	add	r2,r3,r2
8111b554:	10c00017 	ldw	r3,0(r2)
8111b558:	e13ffe17 	ldw	r4,-8(fp)
8111b55c:	288000c4 	addi	r2,r5,3
8111b560:	1085883a 	add	r2,r2,r2
8111b564:	1085883a 	add	r2,r2,r2
8111b568:	2085883a 	add	r2,r4,r2
8111b56c:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111b570:	e0bffd03 	ldbu	r2,-12(fp)
8111b574:	10800044 	addi	r2,r2,1
8111b578:	e0bffd05 	stb	r2,-12(fp)
8111b57c:	e0bffd03 	ldbu	r2,-12(fp)
8111b580:	103fe226 	beq	r2,zero,8111b50c <__reset+0xfb0fb50c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111b584:	e0bfff17 	ldw	r2,-4(fp)
8111b588:	10c09904 	addi	r3,r2,612
8111b58c:	e0bffe17 	ldw	r2,-8(fp)
8111b590:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111b594:	e0bffe17 	ldw	r2,-8(fp)
8111b598:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8111b59c:	e0bffe17 	ldw	r2,-8(fp)
8111b5a0:	10c00504 	addi	r3,r2,20
8111b5a4:	e0bfff17 	ldw	r2,-4(fp)
8111b5a8:	10c09b15 	stw	r3,620(r2)
}
8111b5ac:	0001883a 	nop
8111b5b0:	e037883a 	mov	sp,fp
8111b5b4:	df000017 	ldw	fp,0(sp)
8111b5b8:	dec00104 	addi	sp,sp,4
8111b5bc:	f800283a 	ret

8111b5c0 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8111b5c0:	defff904 	addi	sp,sp,-28
8111b5c4:	de00012e 	bgeu	sp,et,8111b5cc <printErrorTask+0xc>
8111b5c8:	003b68fa 	trap	3
8111b5cc:	dfc00615 	stw	ra,24(sp)
8111b5d0:	df000515 	stw	fp,20(sp)
8111b5d4:	df000504 	addi	fp,sp,20
8111b5d8:	2005883a 	mov	r2,r4
8111b5dc:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8111b5e0:	e03ffb15 	stw	zero,-20(fp)
8111b5e4:	e03ffc15 	stw	zero,-16(fp)
8111b5e8:	e03ffd15 	stw	zero,-12(fp)
8111b5ec:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8111b5f0:	e0bfff03 	ldbu	r2,-4(fp)
8111b5f4:	100d883a 	mov	r6,r2
8111b5f8:	01604574 	movhi	r5,33045
8111b5fc:	297b2604 	addi	r5,r5,-4968
8111b600:	e13ffb04 	addi	r4,fp,-20
8111b604:	1122cd40 	call	81122cd4 <sprintf>
		debug(fp, buffer);
8111b608:	d0a06217 	ldw	r2,-32376(gp)
8111b60c:	e17ffb04 	addi	r5,fp,-20
8111b610:	1009883a 	mov	r4,r2
8111b614:	11213440 	call	81121344 <fprintf>
	}
8111b618:	0001883a 	nop
8111b61c:	e037883a 	mov	sp,fp
8111b620:	dfc00117 	ldw	ra,4(sp)
8111b624:	df000017 	ldw	fp,0(sp)
8111b628:	dec00204 	addi	sp,sp,8
8111b62c:	f800283a 	ret

8111b630 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8111b630:	defffd04 	addi	sp,sp,-12
8111b634:	de00012e 	bgeu	sp,et,8111b63c <vFailCreateMutexSResources+0xc>
8111b638:	003b68fa 	trap	3
8111b63c:	dfc00215 	stw	ra,8(sp)
8111b640:	df000115 	stw	fp,4(sp)
8111b644:	df000104 	addi	fp,sp,4
8111b648:	2005883a 	mov	r2,r4
8111b64c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8111b650:	d0a06217 	ldw	r2,-32376(gp)
8111b654:	100f883a 	mov	r7,r2
8111b658:	018008c4 	movi	r6,35
8111b65c:	01400044 	movi	r5,1
8111b660:	01204574 	movhi	r4,33045
8111b664:	213b2904 	addi	r4,r4,-4956
8111b668:	11219e00 	call	811219e0 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111b66c:	e0bfff03 	ldbu	r2,-4(fp)
8111b670:	1009883a 	mov	r4,r2
8111b674:	111b5c00 	call	8111b5c0 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b678:	0001883a 	nop
8111b67c:	e037883a 	mov	sp,fp
8111b680:	dfc00117 	ldw	ra,4(sp)
8111b684:	df000017 	ldw	fp,0(sp)
8111b688:	dec00204 	addi	sp,sp,8
8111b68c:	f800283a 	ret

8111b690 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8111b690:	defffe04 	addi	sp,sp,-8
8111b694:	de00012e 	bgeu	sp,et,8111b69c <vFailCreateMutexDMA+0xc>
8111b698:	003b68fa 	trap	3
8111b69c:	dfc00115 	stw	ra,4(sp)
8111b6a0:	df000015 	stw	fp,0(sp)
8111b6a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111b6a8:	d0a06217 	ldw	r2,-32376(gp)
8111b6ac:	100f883a 	mov	r7,r2
8111b6b0:	018009c4 	movi	r6,39
8111b6b4:	01400044 	movi	r5,1
8111b6b8:	01204574 	movhi	r4,33045
8111b6bc:	213b3204 	addi	r4,r4,-4920
8111b6c0:	11219e00 	call	811219e0 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b6c4:	0001883a 	nop
8111b6c8:	e037883a 	mov	sp,fp
8111b6cc:	dfc00117 	ldw	ra,4(sp)
8111b6d0:	df000017 	ldw	fp,0(sp)
8111b6d4:	dec00204 	addi	sp,sp,8
8111b6d8:	f800283a 	ret

8111b6dc <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8111b6dc:	defffe04 	addi	sp,sp,-8
8111b6e0:	de00012e 	bgeu	sp,et,8111b6e8 <vFailCreateSemaphoreResources+0xc>
8111b6e4:	003b68fa 	trap	3
8111b6e8:	dfc00115 	stw	ra,4(sp)
8111b6ec:	df000015 	stw	fp,0(sp)
8111b6f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8111b6f4:	d0a06217 	ldw	r2,-32376(gp)
8111b6f8:	100f883a 	mov	r7,r2
8111b6fc:	01800984 	movi	r6,38
8111b700:	01400044 	movi	r5,1
8111b704:	01204574 	movhi	r4,33045
8111b708:	213b3c04 	addi	r4,r4,-4880
8111b70c:	11219e00 	call	811219e0 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b710:	0001883a 	nop
8111b714:	e037883a 	mov	sp,fp
8111b718:	dfc00117 	ldw	ra,4(sp)
8111b71c:	df000017 	ldw	fp,0(sp)
8111b720:	dec00204 	addi	sp,sp,8
8111b724:	f800283a 	ret

8111b728 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8111b728:	defffe04 	addi	sp,sp,-8
8111b72c:	de00012e 	bgeu	sp,et,8111b734 <vFailTestCriticasParts+0xc>
8111b730:	003b68fa 	trap	3
8111b734:	dfc00115 	stw	ra,4(sp)
8111b738:	df000015 	stw	fp,0(sp)
8111b73c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111b740:	d0a06217 	ldw	r2,-32376(gp)
8111b744:	100f883a 	mov	r7,r2
8111b748:	018007c4 	movi	r6,31
8111b74c:	01400044 	movi	r5,1
8111b750:	01204574 	movhi	r4,33045
8111b754:	213b4604 	addi	r4,r4,-4840
8111b758:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b75c:	0001883a 	nop
8111b760:	e037883a 	mov	sp,fp
8111b764:	dfc00117 	ldw	ra,4(sp)
8111b768:	df000017 	ldw	fp,0(sp)
8111b76c:	dec00204 	addi	sp,sp,8
8111b770:	f800283a 	ret

8111b774 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111b774:	defffe04 	addi	sp,sp,-8
8111b778:	de00012e 	bgeu	sp,et,8111b780 <vFailSendxSemCommInit+0xc>
8111b77c:	003b68fa 	trap	3
8111b780:	dfc00115 	stw	ra,4(sp)
8111b784:	df000015 	stw	fp,0(sp)
8111b788:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
8111b78c:	d0a06217 	ldw	r2,-32376(gp)
8111b790:	100f883a 	mov	r7,r2
8111b794:	01800744 	movi	r6,29
8111b798:	01400044 	movi	r5,1
8111b79c:	01204574 	movhi	r4,33045
8111b7a0:	213b4e04 	addi	r4,r4,-4808
8111b7a4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111b7a8:	d0a06217 	ldw	r2,-32376(gp)
8111b7ac:	100f883a 	mov	r7,r2
8111b7b0:	01800a44 	movi	r6,41
8111b7b4:	01400044 	movi	r5,1
8111b7b8:	01204574 	movhi	r4,33045
8111b7bc:	213b5604 	addi	r4,r4,-4776
8111b7c0:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b7c4:	0001883a 	nop
8111b7c8:	e037883a 	mov	sp,fp
8111b7cc:	dfc00117 	ldw	ra,4(sp)
8111b7d0:	df000017 	ldw	fp,0(sp)
8111b7d4:	dec00204 	addi	sp,sp,8
8111b7d8:	f800283a 	ret

8111b7dc <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8111b7dc:	defffe04 	addi	sp,sp,-8
8111b7e0:	de00012e 	bgeu	sp,et,8111b7e8 <vFailSendPreParsedSemaphore+0xc>
8111b7e4:	003b68fa 	trap	3
8111b7e8:	dfc00115 	stw	ra,4(sp)
8111b7ec:	df000015 	stw	fp,0(sp)
8111b7f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8111b7f4:	d0a06217 	ldw	r2,-32376(gp)
8111b7f8:	100f883a 	mov	r7,r2
8111b7fc:	01800904 	movi	r6,36
8111b800:	01400044 	movi	r5,1
8111b804:	01204574 	movhi	r4,33045
8111b808:	213b6104 	addi	r4,r4,-4732
8111b80c:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b810:	0001883a 	nop
8111b814:	e037883a 	mov	sp,fp
8111b818:	dfc00117 	ldw	ra,4(sp)
8111b81c:	df000017 	ldw	fp,0(sp)
8111b820:	dec00204 	addi	sp,sp,8
8111b824:	f800283a 	ret

8111b828 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8111b828:	defffe04 	addi	sp,sp,-8
8111b82c:	de00012e 	bgeu	sp,et,8111b834 <vFailSendPreAckReceiverSemaphore+0xc>
8111b830:	003b68fa 	trap	3
8111b834:	dfc00115 	stw	ra,4(sp)
8111b838:	df000015 	stw	fp,0(sp)
8111b83c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111b840:	d0a06217 	ldw	r2,-32376(gp)
8111b844:	100f883a 	mov	r7,r2
8111b848:	01800a44 	movi	r6,41
8111b84c:	01400044 	movi	r5,1
8111b850:	01204574 	movhi	r4,33045
8111b854:	213b6b04 	addi	r4,r4,-4692
8111b858:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b85c:	0001883a 	nop
8111b860:	e037883a 	mov	sp,fp
8111b864:	dfc00117 	ldw	ra,4(sp)
8111b868:	df000017 	ldw	fp,0(sp)
8111b86c:	dec00204 	addi	sp,sp,8
8111b870:	f800283a 	ret

8111b874 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111b874:	defffe04 	addi	sp,sp,-8
8111b878:	de00012e 	bgeu	sp,et,8111b880 <vFailSendPreAckSenderSemaphore+0xc>
8111b87c:	003b68fa 	trap	3
8111b880:	dfc00115 	stw	ra,4(sp)
8111b884:	df000015 	stw	fp,0(sp)
8111b888:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8111b88c:	d0a06217 	ldw	r2,-32376(gp)
8111b890:	100f883a 	mov	r7,r2
8111b894:	018009c4 	movi	r6,39
8111b898:	01400044 	movi	r5,1
8111b89c:	01204574 	movhi	r4,33045
8111b8a0:	213b7604 	addi	r4,r4,-4648
8111b8a4:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b8a8:	0001883a 	nop
8111b8ac:	e037883a 	mov	sp,fp
8111b8b0:	dfc00117 	ldw	ra,4(sp)
8111b8b4:	df000017 	ldw	fp,0(sp)
8111b8b8:	dec00204 	addi	sp,sp,8
8111b8bc:	f800283a 	ret

8111b8c0 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8111b8c0:	defffe04 	addi	sp,sp,-8
8111b8c4:	de00012e 	bgeu	sp,et,8111b8cc <vFailGetCountSemaphoreSenderTask+0xc>
8111b8c8:	003b68fa 	trap	3
8111b8cc:	dfc00115 	stw	ra,4(sp)
8111b8d0:	df000015 	stw	fp,0(sp)
8111b8d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111b8d8:	d0a06217 	ldw	r2,-32376(gp)
8111b8dc:	100f883a 	mov	r7,r2
8111b8e0:	01800a44 	movi	r6,41
8111b8e4:	01400044 	movi	r5,1
8111b8e8:	01204574 	movhi	r4,33045
8111b8ec:	213b8004 	addi	r4,r4,-4608
8111b8f0:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8111b8f4:	d0a06217 	ldw	r2,-32376(gp)
8111b8f8:	100f883a 	mov	r7,r2
8111b8fc:	01801104 	movi	r6,68
8111b900:	01400044 	movi	r5,1
8111b904:	01204574 	movhi	r4,33045
8111b908:	213b8b04 	addi	r4,r4,-4564
8111b90c:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b910:	0001883a 	nop
8111b914:	e037883a 	mov	sp,fp
8111b918:	dfc00117 	ldw	ra,4(sp)
8111b91c:	df000017 	ldw	fp,0(sp)
8111b920:	dec00204 	addi	sp,sp,8
8111b924:	f800283a 	ret

8111b928 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8111b928:	defffe04 	addi	sp,sp,-8
8111b92c:	de00012e 	bgeu	sp,et,8111b934 <vFailGetMutexSenderTask+0xc>
8111b930:	003b68fa 	trap	3
8111b934:	dfc00115 	stw	ra,4(sp)
8111b938:	df000015 	stw	fp,0(sp)
8111b93c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111b940:	d0a06217 	ldw	r2,-32376(gp)
8111b944:	100f883a 	mov	r7,r2
8111b948:	01800804 	movi	r6,32
8111b94c:	01400044 	movi	r5,1
8111b950:	01204574 	movhi	r4,33045
8111b954:	213b9d04 	addi	r4,r4,-4492
8111b958:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111b95c:	d0a06217 	ldw	r2,-32376(gp)
8111b960:	100f883a 	mov	r7,r2
8111b964:	01801084 	movi	r6,66
8111b968:	01400044 	movi	r5,1
8111b96c:	01204574 	movhi	r4,33045
8111b970:	213ba604 	addi	r4,r4,-4456
8111b974:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b978:	0001883a 	nop
8111b97c:	e037883a 	mov	sp,fp
8111b980:	dfc00117 	ldw	ra,4(sp)
8111b984:	df000017 	ldw	fp,0(sp)
8111b988:	dec00204 	addi	sp,sp,8
8111b98c:	f800283a 	ret

8111b990 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111b990:	defffe04 	addi	sp,sp,-8
8111b994:	de00012e 	bgeu	sp,et,8111b99c <vFailGetCountSemaphoreReceiverTask+0xc>
8111b998:	003b68fa 	trap	3
8111b99c:	dfc00115 	stw	ra,4(sp)
8111b9a0:	df000015 	stw	fp,0(sp)
8111b9a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111b9a8:	d0a06217 	ldw	r2,-32376(gp)
8111b9ac:	100f883a 	mov	r7,r2
8111b9b0:	01800ac4 	movi	r6,43
8111b9b4:	01400044 	movi	r5,1
8111b9b8:	01204574 	movhi	r4,33045
8111b9bc:	213bb704 	addi	r4,r4,-4388
8111b9c0:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8111b9c4:	d0a06217 	ldw	r2,-32376(gp)
8111b9c8:	100f883a 	mov	r7,r2
8111b9cc:	01801184 	movi	r6,70
8111b9d0:	01400044 	movi	r5,1
8111b9d4:	01204574 	movhi	r4,33045
8111b9d8:	213bc204 	addi	r4,r4,-4344
8111b9dc:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b9e0:	0001883a 	nop
8111b9e4:	e037883a 	mov	sp,fp
8111b9e8:	dfc00117 	ldw	ra,4(sp)
8111b9ec:	df000017 	ldw	fp,0(sp)
8111b9f0:	dec00204 	addi	sp,sp,8
8111b9f4:	f800283a 	ret

8111b9f8 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111b9f8:	defffe04 	addi	sp,sp,-8
8111b9fc:	de00012e 	bgeu	sp,et,8111ba04 <vFailGetMutexReceiverTask+0xc>
8111ba00:	003b68fa 	trap	3
8111ba04:	dfc00115 	stw	ra,4(sp)
8111ba08:	df000015 	stw	fp,0(sp)
8111ba0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111ba10:	d0a06217 	ldw	r2,-32376(gp)
8111ba14:	100f883a 	mov	r7,r2
8111ba18:	01800884 	movi	r6,34
8111ba1c:	01400044 	movi	r5,1
8111ba20:	01204574 	movhi	r4,33045
8111ba24:	213bd404 	addi	r4,r4,-4272
8111ba28:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8111ba2c:	d0a06217 	ldw	r2,-32376(gp)
8111ba30:	100f883a 	mov	r7,r2
8111ba34:	01801104 	movi	r6,68
8111ba38:	01400044 	movi	r5,1
8111ba3c:	01204574 	movhi	r4,33045
8111ba40:	213bdd04 	addi	r4,r4,-4236
8111ba44:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ba48:	0001883a 	nop
8111ba4c:	e037883a 	mov	sp,fp
8111ba50:	dfc00117 	ldw	ra,4(sp)
8111ba54:	df000017 	ldw	fp,0(sp)
8111ba58:	dec00204 	addi	sp,sp,8
8111ba5c:	f800283a 	ret

8111ba60 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111ba60:	defffe04 	addi	sp,sp,-8
8111ba64:	de00012e 	bgeu	sp,et,8111ba6c <vFailGetMutexTxUARTSenderTask+0xc>
8111ba68:	003b68fa 	trap	3
8111ba6c:	dfc00115 	stw	ra,4(sp)
8111ba70:	df000015 	stw	fp,0(sp)
8111ba74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8111ba78:	d0a06217 	ldw	r2,-32376(gp)
8111ba7c:	100f883a 	mov	r7,r2
8111ba80:	01800984 	movi	r6,38
8111ba84:	01400044 	movi	r5,1
8111ba88:	01204574 	movhi	r4,33045
8111ba8c:	213bef04 	addi	r4,r4,-4164
8111ba90:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111ba94:	d0a06217 	ldw	r2,-32376(gp)
8111ba98:	100f883a 	mov	r7,r2
8111ba9c:	01801044 	movi	r6,65
8111baa0:	01400044 	movi	r5,1
8111baa4:	01204574 	movhi	r4,33045
8111baa8:	213bf904 	addi	r4,r4,-4124
8111baac:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bab0:	0001883a 	nop
8111bab4:	e037883a 	mov	sp,fp
8111bab8:	dfc00117 	ldw	ra,4(sp)
8111babc:	df000017 	ldw	fp,0(sp)
8111bac0:	dec00204 	addi	sp,sp,8
8111bac4:	f800283a 	ret

8111bac8 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8111bac8:	defffe04 	addi	sp,sp,-8
8111bacc:	de00012e 	bgeu	sp,et,8111bad4 <vFailGetMacRTC+0xc>
8111bad0:	003b68fa 	trap	3
8111bad4:	dfc00115 	stw	ra,4(sp)
8111bad8:	df000015 	stw	fp,0(sp)
8111badc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
8111bae0:	d0a06217 	ldw	r2,-32376(gp)
8111bae4:	100f883a 	mov	r7,r2
8111bae8:	018003c4 	movi	r6,15
8111baec:	01400044 	movi	r5,1
8111baf0:	01204574 	movhi	r4,33045
8111baf4:	213c0a04 	addi	r4,r4,-4056
8111baf8:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bafc:	0001883a 	nop
8111bb00:	e037883a 	mov	sp,fp
8111bb04:	dfc00117 	ldw	ra,4(sp)
8111bb08:	df000017 	ldw	fp,0(sp)
8111bb0c:	dec00204 	addi	sp,sp,8
8111bb10:	f800283a 	ret

8111bb14 <vFailInitialization>:


void vFailInitialization( void )
{
8111bb14:	defffe04 	addi	sp,sp,-8
8111bb18:	de00012e 	bgeu	sp,et,8111bb20 <vFailInitialization+0xc>
8111bb1c:	003b68fa 	trap	3
8111bb20:	dfc00115 	stw	ra,4(sp)
8111bb24:	df000015 	stw	fp,0(sp)
8111bb28:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
8111bb2c:	d0a06217 	ldw	r2,-32376(gp)
8111bb30:	100f883a 	mov	r7,r2
8111bb34:	01800504 	movi	r6,20
8111bb38:	01400044 	movi	r5,1
8111bb3c:	01204574 	movhi	r4,33045
8111bb40:	213c0e04 	addi	r4,r4,-4040
8111bb44:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bb48:	0001883a 	nop
8111bb4c:	e037883a 	mov	sp,fp
8111bb50:	dfc00117 	ldw	ra,4(sp)
8111bb54:	df000017 	ldw	fp,0(sp)
8111bb58:	dec00204 	addi	sp,sp,8
8111bb5c:	f800283a 	ret

8111bb60 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111bb60:	defffe04 	addi	sp,sp,-8
8111bb64:	de00012e 	bgeu	sp,et,8111bb6c <vFailReceiverCreate+0xc>
8111bb68:	003b68fa 	trap	3
8111bb6c:	dfc00115 	stw	ra,4(sp)
8111bb70:	df000015 	stw	fp,0(sp)
8111bb74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
8111bb78:	d0a06217 	ldw	r2,-32376(gp)
8111bb7c:	100f883a 	mov	r7,r2
8111bb80:	01800484 	movi	r6,18
8111bb84:	01400044 	movi	r5,1
8111bb88:	01204574 	movhi	r4,33045
8111bb8c:	213c1404 	addi	r4,r4,-4016
8111bb90:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bb94:	0001883a 	nop
8111bb98:	e037883a 	mov	sp,fp
8111bb9c:	dfc00117 	ldw	ra,4(sp)
8111bba0:	df000017 	ldw	fp,0(sp)
8111bba4:	dec00204 	addi	sp,sp,8
8111bba8:	f800283a 	ret

8111bbac <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111bbac:	defffe04 	addi	sp,sp,-8
8111bbb0:	de00012e 	bgeu	sp,et,8111bbb8 <vFailSenderCreate+0xc>
8111bbb4:	003b68fa 	trap	3
8111bbb8:	dfc00115 	stw	ra,4(sp)
8111bbbc:	df000015 	stw	fp,0(sp)
8111bbc0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
8111bbc4:	d0a06217 	ldw	r2,-32376(gp)
8111bbc8:	100f883a 	mov	r7,r2
8111bbcc:	01800484 	movi	r6,18
8111bbd0:	01400044 	movi	r5,1
8111bbd4:	01204574 	movhi	r4,33045
8111bbd8:	213c1904 	addi	r4,r4,-3996
8111bbdc:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bbe0:	0001883a 	nop
8111bbe4:	e037883a 	mov	sp,fp
8111bbe8:	dfc00117 	ldw	ra,4(sp)
8111bbec:	df000017 	ldw	fp,0(sp)
8111bbf0:	dec00204 	addi	sp,sp,8
8111bbf4:	f800283a 	ret

8111bbf8 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8111bbf8:	defffe04 	addi	sp,sp,-8
8111bbfc:	de00012e 	bgeu	sp,et,8111bc04 <vFailDeleteInitialization+0xc>
8111bc00:	003b68fa 	trap	3
8111bc04:	dfc00115 	stw	ra,4(sp)
8111bc08:	df000015 	stw	fp,0(sp)
8111bc0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
8111bc10:	d0a06217 	ldw	r2,-32376(gp)
8111bc14:	100f883a 	mov	r7,r2
8111bc18:	01800684 	movi	r6,26
8111bc1c:	01400044 	movi	r5,1
8111bc20:	01204574 	movhi	r4,33045
8111bc24:	213c1e04 	addi	r4,r4,-3976
8111bc28:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bc2c:	0001883a 	nop
8111bc30:	e037883a 	mov	sp,fp
8111bc34:	dfc00117 	ldw	ra,4(sp)
8111bc38:	df000017 	ldw	fp,0(sp)
8111bc3c:	dec00204 	addi	sp,sp,8
8111bc40:	f800283a 	ret

8111bc44 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111bc44:	defffe04 	addi	sp,sp,-8
8111bc48:	de00012e 	bgeu	sp,et,8111bc50 <vFailSetCountSemaphorexBuffer32+0xc>
8111bc4c:	003b68fa 	trap	3
8111bc50:	dfc00115 	stw	ra,4(sp)
8111bc54:	df000015 	stw	fp,0(sp)
8111bc58:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111bc5c:	d0a06217 	ldw	r2,-32376(gp)
8111bc60:	100f883a 	mov	r7,r2
8111bc64:	01800a04 	movi	r6,40
8111bc68:	01400044 	movi	r5,1
8111bc6c:	01204574 	movhi	r4,33045
8111bc70:	213c2504 	addi	r4,r4,-3948
8111bc74:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111bc78:	d0a06217 	ldw	r2,-32376(gp)
8111bc7c:	100f883a 	mov	r7,r2
8111bc80:	018008c4 	movi	r6,35
8111bc84:	01400044 	movi	r5,1
8111bc88:	01204574 	movhi	r4,33045
8111bc8c:	213c3004 	addi	r4,r4,-3904
8111bc90:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bc94:	0001883a 	nop
8111bc98:	e037883a 	mov	sp,fp
8111bc9c:	dfc00117 	ldw	ra,4(sp)
8111bca0:	df000017 	ldw	fp,0(sp)
8111bca4:	dec00204 	addi	sp,sp,8
8111bca8:	f800283a 	ret

8111bcac <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111bcac:	defffe04 	addi	sp,sp,-8
8111bcb0:	de00012e 	bgeu	sp,et,8111bcb8 <vFailSetCountSemaphorexBuffer64+0xc>
8111bcb4:	003b68fa 	trap	3
8111bcb8:	dfc00115 	stw	ra,4(sp)
8111bcbc:	df000015 	stw	fp,0(sp)
8111bcc0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111bcc4:	d0a06217 	ldw	r2,-32376(gp)
8111bcc8:	100f883a 	mov	r7,r2
8111bccc:	01800a04 	movi	r6,40
8111bcd0:	01400044 	movi	r5,1
8111bcd4:	01204574 	movhi	r4,33045
8111bcd8:	213c3904 	addi	r4,r4,-3868
8111bcdc:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111bce0:	d0a06217 	ldw	r2,-32376(gp)
8111bce4:	100f883a 	mov	r7,r2
8111bce8:	018008c4 	movi	r6,35
8111bcec:	01400044 	movi	r5,1
8111bcf0:	01204574 	movhi	r4,33045
8111bcf4:	213c3004 	addi	r4,r4,-3904
8111bcf8:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bcfc:	0001883a 	nop
8111bd00:	e037883a 	mov	sp,fp
8111bd04:	dfc00117 	ldw	ra,4(sp)
8111bd08:	df000017 	ldw	fp,0(sp)
8111bd0c:	dec00204 	addi	sp,sp,8
8111bd10:	f800283a 	ret

8111bd14 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111bd14:	defffe04 	addi	sp,sp,-8
8111bd18:	de00012e 	bgeu	sp,et,8111bd20 <vFailSetCountSemaphorexBuffer128+0xc>
8111bd1c:	003b68fa 	trap	3
8111bd20:	dfc00115 	stw	ra,4(sp)
8111bd24:	df000015 	stw	fp,0(sp)
8111bd28:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111bd2c:	d0a06217 	ldw	r2,-32376(gp)
8111bd30:	100f883a 	mov	r7,r2
8111bd34:	01800a44 	movi	r6,41
8111bd38:	01400044 	movi	r5,1
8111bd3c:	01204574 	movhi	r4,33045
8111bd40:	213c4404 	addi	r4,r4,-3824
8111bd44:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111bd48:	d0a06217 	ldw	r2,-32376(gp)
8111bd4c:	100f883a 	mov	r7,r2
8111bd50:	018008c4 	movi	r6,35
8111bd54:	01400044 	movi	r5,1
8111bd58:	01204574 	movhi	r4,33045
8111bd5c:	213c3004 	addi	r4,r4,-3904
8111bd60:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bd64:	0001883a 	nop
8111bd68:	e037883a 	mov	sp,fp
8111bd6c:	dfc00117 	ldw	ra,4(sp)
8111bd70:	df000017 	ldw	fp,0(sp)
8111bd74:	dec00204 	addi	sp,sp,8
8111bd78:	f800283a 	ret

8111bd7c <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111bd7c:	defffe04 	addi	sp,sp,-8
8111bd80:	de00012e 	bgeu	sp,et,8111bd88 <vFailGetCountSemaphorexBuffer128+0xc>
8111bd84:	003b68fa 	trap	3
8111bd88:	dfc00115 	stw	ra,4(sp)
8111bd8c:	df000015 	stw	fp,0(sp)
8111bd90:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111bd94:	d0a06217 	ldw	r2,-32376(gp)
8111bd98:	100f883a 	mov	r7,r2
8111bd9c:	01800a44 	movi	r6,41
8111bda0:	01400044 	movi	r5,1
8111bda4:	01204574 	movhi	r4,33045
8111bda8:	213c4f04 	addi	r4,r4,-3780
8111bdac:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111bdb0:	d0a06217 	ldw	r2,-32376(gp)
8111bdb4:	100f883a 	mov	r7,r2
8111bdb8:	01800884 	movi	r6,34
8111bdbc:	01400044 	movi	r5,1
8111bdc0:	01204574 	movhi	r4,33045
8111bdc4:	213c5a04 	addi	r4,r4,-3736
8111bdc8:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bdcc:	0001883a 	nop
8111bdd0:	e037883a 	mov	sp,fp
8111bdd4:	dfc00117 	ldw	ra,4(sp)
8111bdd8:	df000017 	ldw	fp,0(sp)
8111bddc:	dec00204 	addi	sp,sp,8
8111bde0:	f800283a 	ret

8111bde4 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111bde4:	defffe04 	addi	sp,sp,-8
8111bde8:	de00012e 	bgeu	sp,et,8111bdf0 <vFailGetCountSemaphorexBuffer64+0xc>
8111bdec:	003b68fa 	trap	3
8111bdf0:	dfc00115 	stw	ra,4(sp)
8111bdf4:	df000015 	stw	fp,0(sp)
8111bdf8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111bdfc:	d0a06217 	ldw	r2,-32376(gp)
8111be00:	100f883a 	mov	r7,r2
8111be04:	01800a04 	movi	r6,40
8111be08:	01400044 	movi	r5,1
8111be0c:	01204574 	movhi	r4,33045
8111be10:	213c6304 	addi	r4,r4,-3700
8111be14:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111be18:	d0a06217 	ldw	r2,-32376(gp)
8111be1c:	100f883a 	mov	r7,r2
8111be20:	01800884 	movi	r6,34
8111be24:	01400044 	movi	r5,1
8111be28:	01204574 	movhi	r4,33045
8111be2c:	213c5a04 	addi	r4,r4,-3736
8111be30:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111be34:	0001883a 	nop
8111be38:	e037883a 	mov	sp,fp
8111be3c:	dfc00117 	ldw	ra,4(sp)
8111be40:	df000017 	ldw	fp,0(sp)
8111be44:	dec00204 	addi	sp,sp,8
8111be48:	f800283a 	ret

8111be4c <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111be4c:	defffe04 	addi	sp,sp,-8
8111be50:	de00012e 	bgeu	sp,et,8111be58 <vFailGetCountSemaphorexBuffer32+0xc>
8111be54:	003b68fa 	trap	3
8111be58:	dfc00115 	stw	ra,4(sp)
8111be5c:	df000015 	stw	fp,0(sp)
8111be60:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111be64:	d0a06217 	ldw	r2,-32376(gp)
8111be68:	100f883a 	mov	r7,r2
8111be6c:	01800a04 	movi	r6,40
8111be70:	01400044 	movi	r5,1
8111be74:	01204574 	movhi	r4,33045
8111be78:	213c6e04 	addi	r4,r4,-3656
8111be7c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111be80:	d0a06217 	ldw	r2,-32376(gp)
8111be84:	100f883a 	mov	r7,r2
8111be88:	01800884 	movi	r6,34
8111be8c:	01400044 	movi	r5,1
8111be90:	01204574 	movhi	r4,33045
8111be94:	213c5a04 	addi	r4,r4,-3736
8111be98:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111be9c:	0001883a 	nop
8111bea0:	e037883a 	mov	sp,fp
8111bea4:	dfc00117 	ldw	ra,4(sp)
8111bea8:	df000017 	ldw	fp,0(sp)
8111beac:	dec00204 	addi	sp,sp,8
8111beb0:	f800283a 	ret

8111beb4 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111beb4:	defffe04 	addi	sp,sp,-8
8111beb8:	de00012e 	bgeu	sp,et,8111bec0 <vFailFoundBufferRetransmission+0xc>
8111bebc:	003b68fa 	trap	3
8111bec0:	dfc00115 	stw	ra,4(sp)
8111bec4:	df000015 	stw	fp,0(sp)
8111bec8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111becc:	d0a06217 	ldw	r2,-32376(gp)
8111bed0:	100f883a 	mov	r7,r2
8111bed4:	01800a84 	movi	r6,42
8111bed8:	01400044 	movi	r5,1
8111bedc:	01204574 	movhi	r4,33045
8111bee0:	213c7904 	addi	r4,r4,-3612
8111bee4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111bee8:	d0a06217 	ldw	r2,-32376(gp)
8111beec:	100f883a 	mov	r7,r2
8111bef0:	01801204 	movi	r6,72
8111bef4:	01400044 	movi	r5,1
8111bef8:	01204574 	movhi	r4,33045
8111befc:	213c8404 	addi	r4,r4,-3568
8111bf00:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bf04:	0001883a 	nop
8111bf08:	e037883a 	mov	sp,fp
8111bf0c:	dfc00117 	ldw	ra,4(sp)
8111bf10:	df000017 	ldw	fp,0(sp)
8111bf14:	dec00204 	addi	sp,sp,8
8111bf18:	f800283a 	ret

8111bf1c <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111bf1c:	defffe04 	addi	sp,sp,-8
8111bf20:	de00012e 	bgeu	sp,et,8111bf28 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111bf24:	003b68fa 	trap	3
8111bf28:	dfc00115 	stw	ra,4(sp)
8111bf2c:	df000015 	stw	fp,0(sp)
8111bf30:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111bf34:	d0a06217 	ldw	r2,-32376(gp)
8111bf38:	100f883a 	mov	r7,r2
8111bf3c:	01800b84 	movi	r6,46
8111bf40:	01400044 	movi	r5,1
8111bf44:	01204574 	movhi	r4,33045
8111bf48:	213c9704 	addi	r4,r4,-3492
8111bf4c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111bf50:	d0a06217 	ldw	r2,-32376(gp)
8111bf54:	100f883a 	mov	r7,r2
8111bf58:	018010c4 	movi	r6,67
8111bf5c:	01400044 	movi	r5,1
8111bf60:	01204574 	movhi	r4,33045
8111bf64:	213ca304 	addi	r4,r4,-3444
8111bf68:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bf6c:	0001883a 	nop
8111bf70:	e037883a 	mov	sp,fp
8111bf74:	dfc00117 	ldw	ra,4(sp)
8111bf78:	df000017 	ldw	fp,0(sp)
8111bf7c:	dec00204 	addi	sp,sp,8
8111bf80:	f800283a 	ret

8111bf84 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111bf84:	defffe04 	addi	sp,sp,-8
8111bf88:	de00012e 	bgeu	sp,et,8111bf90 <vFailGetxMutexPreParsedParserRxTask+0xc>
8111bf8c:	003b68fa 	trap	3
8111bf90:	dfc00115 	stw	ra,4(sp)
8111bf94:	df000015 	stw	fp,0(sp)
8111bf98:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111bf9c:	d0a06217 	ldw	r2,-32376(gp)
8111bfa0:	100f883a 	mov	r7,r2
8111bfa4:	01800b04 	movi	r6,44
8111bfa8:	01400044 	movi	r5,1
8111bfac:	01204574 	movhi	r4,33045
8111bfb0:	213cb404 	addi	r4,r4,-3376
8111bfb4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111bfb8:	d0a06217 	ldw	r2,-32376(gp)
8111bfbc:	100f883a 	mov	r7,r2
8111bfc0:	01800fc4 	movi	r6,63
8111bfc4:	01400044 	movi	r5,1
8111bfc8:	01204574 	movhi	r4,33045
8111bfcc:	213cc004 	addi	r4,r4,-3328
8111bfd0:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bfd4:	0001883a 	nop
8111bfd8:	e037883a 	mov	sp,fp
8111bfdc:	dfc00117 	ldw	ra,4(sp)
8111bfe0:	df000017 	ldw	fp,0(sp)
8111bfe4:	dec00204 	addi	sp,sp,8
8111bfe8:	f800283a 	ret

8111bfec <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111bfec:	defffe04 	addi	sp,sp,-8
8111bff0:	de00012e 	bgeu	sp,et,8111bff8 <vNoContentInPreParsedBuffer+0xc>
8111bff4:	003b68fa 	trap	3
8111bff8:	dfc00115 	stw	ra,4(sp)
8111bffc:	df000015 	stw	fp,0(sp)
8111c000:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111c004:	d0a06217 	ldw	r2,-32376(gp)
8111c008:	100f883a 	mov	r7,r2
8111c00c:	01800904 	movi	r6,36
8111c010:	01400044 	movi	r5,1
8111c014:	01204574 	movhi	r4,33045
8111c018:	213cd004 	addi	r4,r4,-3264
8111c01c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111c020:	d0a06217 	ldw	r2,-32376(gp)
8111c024:	100f883a 	mov	r7,r2
8111c028:	01801684 	movi	r6,90
8111c02c:	01400044 	movi	r5,1
8111c030:	01204574 	movhi	r4,33045
8111c034:	213cda04 	addi	r4,r4,-3224
8111c038:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c03c:	0001883a 	nop
8111c040:	e037883a 	mov	sp,fp
8111c044:	dfc00117 	ldw	ra,4(sp)
8111c048:	df000017 	ldw	fp,0(sp)
8111c04c:	dec00204 	addi	sp,sp,8
8111c050:	f800283a 	ret

8111c054 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111c054:	defffe04 	addi	sp,sp,-8
8111c058:	de00012e 	bgeu	sp,et,8111c060 <vCouldNotSendEthConfUART+0xc>
8111c05c:	003b68fa 	trap	3
8111c060:	dfc00115 	stw	ra,4(sp)
8111c064:	df000015 	stw	fp,0(sp)
8111c068:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111c06c:	d0a06217 	ldw	r2,-32376(gp)
8111c070:	100f883a 	mov	r7,r2
8111c074:	01800844 	movi	r6,33
8111c078:	01400044 	movi	r5,1
8111c07c:	01204574 	movhi	r4,33045
8111c080:	213cf104 	addi	r4,r4,-3132
8111c084:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111c088:	d0a06217 	ldw	r2,-32376(gp)
8111c08c:	100f883a 	mov	r7,r2
8111c090:	01801784 	movi	r6,94
8111c094:	01400044 	movi	r5,1
8111c098:	01204574 	movhi	r4,33045
8111c09c:	213cfa04 	addi	r4,r4,-3096
8111c0a0:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c0a4:	0001883a 	nop
8111c0a8:	e037883a 	mov	sp,fp
8111c0ac:	dfc00117 	ldw	ra,4(sp)
8111c0b0:	df000017 	ldw	fp,0(sp)
8111c0b4:	dec00204 	addi	sp,sp,8
8111c0b8:	f800283a 	ret

8111c0bc <vFailSendNack>:

void vFailSendNack( void )
{
8111c0bc:	defffe04 	addi	sp,sp,-8
8111c0c0:	de00012e 	bgeu	sp,et,8111c0c8 <vFailSendNack+0xc>
8111c0c4:	003b68fa 	trap	3
8111c0c8:	dfc00115 	stw	ra,4(sp)
8111c0cc:	df000015 	stw	fp,0(sp)
8111c0d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
8111c0d4:	d0a06217 	ldw	r2,-32376(gp)
8111c0d8:	100f883a 	mov	r7,r2
8111c0dc:	01800584 	movi	r6,22
8111c0e0:	01400044 	movi	r5,1
8111c0e4:	01204574 	movhi	r4,33045
8111c0e8:	213d1204 	addi	r4,r4,-3000
8111c0ec:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111c0f0:	d0a06217 	ldw	r2,-32376(gp)
8111c0f4:	100f883a 	mov	r7,r2
8111c0f8:	01800a84 	movi	r6,42
8111c0fc:	01400044 	movi	r5,1
8111c100:	01204574 	movhi	r4,33045
8111c104:	213d1804 	addi	r4,r4,-2976
8111c108:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c10c:	0001883a 	nop
8111c110:	e037883a 	mov	sp,fp
8111c114:	dfc00117 	ldw	ra,4(sp)
8111c118:	df000017 	ldw	fp,0(sp)
8111c11c:	dec00204 	addi	sp,sp,8
8111c120:	f800283a 	ret

8111c124 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111c124:	defffe04 	addi	sp,sp,-8
8111c128:	de00012e 	bgeu	sp,et,8111c130 <vFailSetPreAckSenderBuffer+0xc>
8111c12c:	003b68fa 	trap	3
8111c130:	dfc00115 	stw	ra,4(sp)
8111c134:	df000015 	stw	fp,0(sp)
8111c138:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111c13c:	d0a06217 	ldw	r2,-32376(gp)
8111c140:	100f883a 	mov	r7,r2
8111c144:	018008c4 	movi	r6,35
8111c148:	01400044 	movi	r5,1
8111c14c:	01204574 	movhi	r4,33045
8111c150:	213d2304 	addi	r4,r4,-2932
8111c154:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111c158:	d0a06217 	ldw	r2,-32376(gp)
8111c15c:	100f883a 	mov	r7,r2
8111c160:	01801584 	movi	r6,86
8111c164:	01400044 	movi	r5,1
8111c168:	01204574 	movhi	r4,33045
8111c16c:	213d2c04 	addi	r4,r4,-2896
8111c170:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c174:	0001883a 	nop
8111c178:	e037883a 	mov	sp,fp
8111c17c:	dfc00117 	ldw	ra,4(sp)
8111c180:	df000017 	ldw	fp,0(sp)
8111c184:	dec00204 	addi	sp,sp,8
8111c188:	f800283a 	ret

8111c18c <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111c18c:	defffe04 	addi	sp,sp,-8
8111c190:	de00012e 	bgeu	sp,et,8111c198 <vFailSetPreParsedBuffer+0xc>
8111c194:	003b68fa 	trap	3
8111c198:	dfc00115 	stw	ra,4(sp)
8111c19c:	df000015 	stw	fp,0(sp)
8111c1a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111c1a4:	d0a06217 	ldw	r2,-32376(gp)
8111c1a8:	100f883a 	mov	r7,r2
8111c1ac:	01800804 	movi	r6,32
8111c1b0:	01400044 	movi	r5,1
8111c1b4:	01204574 	movhi	r4,33045
8111c1b8:	213d4204 	addi	r4,r4,-2808
8111c1bc:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111c1c0:	d0a06217 	ldw	r2,-32376(gp)
8111c1c4:	100f883a 	mov	r7,r2
8111c1c8:	018013c4 	movi	r6,79
8111c1cc:	01400044 	movi	r5,1
8111c1d0:	01204574 	movhi	r4,33045
8111c1d4:	213d4b04 	addi	r4,r4,-2772
8111c1d8:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c1dc:	0001883a 	nop
8111c1e0:	e037883a 	mov	sp,fp
8111c1e4:	dfc00117 	ldw	ra,4(sp)
8111c1e8:	df000017 	ldw	fp,0(sp)
8111c1ec:	dec00204 	addi	sp,sp,8
8111c1f0:	f800283a 	ret

8111c1f4 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111c1f4:	defffe04 	addi	sp,sp,-8
8111c1f8:	de00012e 	bgeu	sp,et,8111c200 <vFailSetPreAckReceiverBuffer+0xc>
8111c1fc:	003b68fa 	trap	3
8111c200:	dfc00115 	stw	ra,4(sp)
8111c204:	df000015 	stw	fp,0(sp)
8111c208:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111c20c:	d0a06217 	ldw	r2,-32376(gp)
8111c210:	100f883a 	mov	r7,r2
8111c214:	01800944 	movi	r6,37
8111c218:	01400044 	movi	r5,1
8111c21c:	01204574 	movhi	r4,33045
8111c220:	213d5f04 	addi	r4,r4,-2692
8111c224:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111c228:	d0a06217 	ldw	r2,-32376(gp)
8111c22c:	100f883a 	mov	r7,r2
8111c230:	018015c4 	movi	r6,87
8111c234:	01400044 	movi	r5,1
8111c238:	01204574 	movhi	r4,33045
8111c23c:	213d6904 	addi	r4,r4,-2652
8111c240:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c244:	0001883a 	nop
8111c248:	e037883a 	mov	sp,fp
8111c24c:	dfc00117 	ldw	ra,4(sp)
8111c250:	df000017 	ldw	fp,0(sp)
8111c254:	dec00204 	addi	sp,sp,8
8111c258:	f800283a 	ret

8111c25c <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111c25c:	defffe04 	addi	sp,sp,-8
8111c260:	de00012e 	bgeu	sp,et,8111c268 <vFailParserCommTaskCreate+0xc>
8111c264:	003b68fa 	trap	3
8111c268:	dfc00115 	stw	ra,4(sp)
8111c26c:	df000015 	stw	fp,0(sp)
8111c270:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
8111c274:	d0a06217 	ldw	r2,-32376(gp)
8111c278:	100f883a 	mov	r7,r2
8111c27c:	01800684 	movi	r6,26
8111c280:	01400044 	movi	r5,1
8111c284:	01204574 	movhi	r4,33045
8111c288:	213d7f04 	addi	r4,r4,-2564
8111c28c:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c290:	0001883a 	nop
8111c294:	e037883a 	mov	sp,fp
8111c298:	dfc00117 	ldw	ra,4(sp)
8111c29c:	df000017 	ldw	fp,0(sp)
8111c2a0:	dec00204 	addi	sp,sp,8
8111c2a4:	f800283a 	ret

8111c2a8 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111c2a8:	defffe04 	addi	sp,sp,-8
8111c2ac:	de00012e 	bgeu	sp,et,8111c2b4 <vFailInAckHandlerTaskCreate+0xc>
8111c2b0:	003b68fa 	trap	3
8111c2b4:	dfc00115 	stw	ra,4(sp)
8111c2b8:	df000015 	stw	fp,0(sp)
8111c2bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111c2c0:	d0a06217 	ldw	r2,-32376(gp)
8111c2c4:	100f883a 	mov	r7,r2
8111c2c8:	01800704 	movi	r6,28
8111c2cc:	01400044 	movi	r5,1
8111c2d0:	01204574 	movhi	r4,33045
8111c2d4:	213d8604 	addi	r4,r4,-2536
8111c2d8:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c2dc:	0001883a 	nop
8111c2e0:	e037883a 	mov	sp,fp
8111c2e4:	dfc00117 	ldw	ra,4(sp)
8111c2e8:	df000017 	ldw	fp,0(sp)
8111c2ec:	dec00204 	addi	sp,sp,8
8111c2f0:	f800283a 	ret

8111c2f4 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111c2f4:	defffe04 	addi	sp,sp,-8
8111c2f8:	de00012e 	bgeu	sp,et,8111c300 <vFailOutAckHandlerTaskCreate+0xc>
8111c2fc:	003b68fa 	trap	3
8111c300:	dfc00115 	stw	ra,4(sp)
8111c304:	df000015 	stw	fp,0(sp)
8111c308:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111c30c:	d0a06217 	ldw	r2,-32376(gp)
8111c310:	100f883a 	mov	r7,r2
8111c314:	01800704 	movi	r6,28
8111c318:	01400044 	movi	r5,1
8111c31c:	01204574 	movhi	r4,33045
8111c320:	213d8604 	addi	r4,r4,-2536
8111c324:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c328:	0001883a 	nop
8111c32c:	e037883a 	mov	sp,fp
8111c330:	dfc00117 	ldw	ra,4(sp)
8111c334:	df000017 	ldw	fp,0(sp)
8111c338:	dec00204 	addi	sp,sp,8
8111c33c:	f800283a 	ret

8111c340 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111c340:	defffe04 	addi	sp,sp,-8
8111c344:	de00012e 	bgeu	sp,et,8111c34c <vFailCreateTimerRetransmisison+0xc>
8111c348:	003b68fa 	trap	3
8111c34c:	dfc00115 	stw	ra,4(sp)
8111c350:	df000015 	stw	fp,0(sp)
8111c354:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111c358:	d0a06217 	ldw	r2,-32376(gp)
8111c35c:	100f883a 	mov	r7,r2
8111c360:	018007c4 	movi	r6,31
8111c364:	01400044 	movi	r5,1
8111c368:	01204574 	movhi	r4,33045
8111c36c:	213d8e04 	addi	r4,r4,-2504
8111c370:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c374:	0001883a 	nop
8111c378:	e037883a 	mov	sp,fp
8111c37c:	dfc00117 	ldw	ra,4(sp)
8111c380:	df000017 	ldw	fp,0(sp)
8111c384:	dec00204 	addi	sp,sp,8
8111c388:	f800283a 	ret

8111c38c <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111c38c:	defffe04 	addi	sp,sp,-8
8111c390:	de00012e 	bgeu	sp,et,8111c398 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111c394:	003b68fa 	trap	3
8111c398:	dfc00115 	stw	ra,4(sp)
8111c39c:	df000015 	stw	fp,0(sp)
8111c3a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111c3a4:	d0a06217 	ldw	r2,-32376(gp)
8111c3a8:	100f883a 	mov	r7,r2
8111c3ac:	01800904 	movi	r6,36
8111c3b0:	01400044 	movi	r5,1
8111c3b4:	01204574 	movhi	r4,33045
8111c3b8:	213d9604 	addi	r4,r4,-2472
8111c3bc:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c3c0:	0001883a 	nop
8111c3c4:	e037883a 	mov	sp,fp
8111c3c8:	dfc00117 	ldw	ra,4(sp)
8111c3cc:	df000017 	ldw	fp,0(sp)
8111c3d0:	dec00204 	addi	sp,sp,8
8111c3d4:	f800283a 	ret

8111c3d8 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111c3d8:	defffe04 	addi	sp,sp,-8
8111c3dc:	de00012e 	bgeu	sp,et,8111c3e4 <vFailTimeoutCheckerTaskCreate+0xc>
8111c3e0:	003b68fa 	trap	3
8111c3e4:	dfc00115 	stw	ra,4(sp)
8111c3e8:	df000015 	stw	fp,0(sp)
8111c3ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111c3f0:	d0a06217 	ldw	r2,-32376(gp)
8111c3f4:	100f883a 	mov	r7,r2
8111c3f8:	01800a04 	movi	r6,40
8111c3fc:	01400044 	movi	r5,1
8111c400:	01204574 	movhi	r4,33045
8111c404:	213da004 	addi	r4,r4,-2432
8111c408:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c40c:	0001883a 	nop
8111c410:	e037883a 	mov	sp,fp
8111c414:	dfc00117 	ldw	ra,4(sp)
8111c418:	df000017 	ldw	fp,0(sp)
8111c41c:	dec00204 	addi	sp,sp,8
8111c420:	f800283a 	ret

8111c424 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111c424:	defffe04 	addi	sp,sp,-8
8111c428:	de00012e 	bgeu	sp,et,8111c430 <vFailGetBlockingSemTimeoutTask+0xc>
8111c42c:	003b68fa 	trap	3
8111c430:	dfc00115 	stw	ra,4(sp)
8111c434:	df000015 	stw	fp,0(sp)
8111c438:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111c43c:	d0a06217 	ldw	r2,-32376(gp)
8111c440:	100f883a 	mov	r7,r2
8111c444:	018009c4 	movi	r6,39
8111c448:	01400044 	movi	r5,1
8111c44c:	01204574 	movhi	r4,33045
8111c450:	213dab04 	addi	r4,r4,-2388
8111c454:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111c458:	d0a06217 	ldw	r2,-32376(gp)
8111c45c:	100f883a 	mov	r7,r2
8111c460:	01800cc4 	movi	r6,51
8111c464:	01400044 	movi	r5,1
8111c468:	01204574 	movhi	r4,33045
8111c46c:	213db504 	addi	r4,r4,-2348
8111c470:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c474:	0001883a 	nop
8111c478:	e037883a 	mov	sp,fp
8111c47c:	dfc00117 	ldw	ra,4(sp)
8111c480:	df000017 	ldw	fp,0(sp)
8111c484:	dec00204 	addi	sp,sp,8
8111c488:	f800283a 	ret

8111c48c <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111c48c:	defffe04 	addi	sp,sp,-8
8111c490:	de00012e 	bgeu	sp,et,8111c498 <vFailPostBlockingSemTimeoutTask+0xc>
8111c494:	003b68fa 	trap	3
8111c498:	dfc00115 	stw	ra,4(sp)
8111c49c:	df000015 	stw	fp,0(sp)
8111c4a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111c4a4:	d0a06217 	ldw	r2,-32376(gp)
8111c4a8:	100f883a 	mov	r7,r2
8111c4ac:	01800a04 	movi	r6,40
8111c4b0:	01400044 	movi	r5,1
8111c4b4:	01204574 	movhi	r4,33045
8111c4b8:	213dc204 	addi	r4,r4,-2296
8111c4bc:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111c4c0:	d0a06217 	ldw	r2,-32376(gp)
8111c4c4:	100f883a 	mov	r7,r2
8111c4c8:	01800c84 	movi	r6,50
8111c4cc:	01400044 	movi	r5,1
8111c4d0:	01204574 	movhi	r4,33045
8111c4d4:	213dcd04 	addi	r4,r4,-2252
8111c4d8:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c4dc:	0001883a 	nop
8111c4e0:	e037883a 	mov	sp,fp
8111c4e4:	dfc00117 	ldw	ra,4(sp)
8111c4e8:	df000017 	ldw	fp,0(sp)
8111c4ec:	dec00204 	addi	sp,sp,8
8111c4f0:	f800283a 	ret

8111c4f4 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111c4f4:	defffe04 	addi	sp,sp,-8
8111c4f8:	de00012e 	bgeu	sp,et,8111c500 <vFailCouldNotRetransmitTimeoutTask+0xc>
8111c4fc:	003b68fa 	trap	3
8111c500:	dfc00115 	stw	ra,4(sp)
8111c504:	df000015 	stw	fp,0(sp)
8111c508:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111c50c:	d0a06217 	ldw	r2,-32376(gp)
8111c510:	100f883a 	mov	r7,r2
8111c514:	01800ac4 	movi	r6,43
8111c518:	01400044 	movi	r5,1
8111c51c:	01204574 	movhi	r4,33045
8111c520:	213dda04 	addi	r4,r4,-2200
8111c524:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111c528:	d0a06217 	ldw	r2,-32376(gp)
8111c52c:	100f883a 	mov	r7,r2
8111c530:	01801644 	movi	r6,89
8111c534:	01400044 	movi	r5,1
8111c538:	01204574 	movhi	r4,33045
8111c53c:	213de504 	addi	r4,r4,-2156
8111c540:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c544:	0001883a 	nop
8111c548:	e037883a 	mov	sp,fp
8111c54c:	dfc00117 	ldw	ra,4(sp)
8111c550:	df000017 	ldw	fp,0(sp)
8111c554:	dec00204 	addi	sp,sp,8
8111c558:	f800283a 	ret

8111c55c <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111c55c:	defffe04 	addi	sp,sp,-8
8111c560:	de00012e 	bgeu	sp,et,8111c568 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111c564:	003b68fa 	trap	3
8111c568:	dfc00115 	stw	ra,4(sp)
8111c56c:	df000015 	stw	fp,0(sp)
8111c570:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111c574:	d0a06217 	ldw	r2,-32376(gp)
8111c578:	100f883a 	mov	r7,r2
8111c57c:	01800a84 	movi	r6,42
8111c580:	01400044 	movi	r5,1
8111c584:	01204574 	movhi	r4,33045
8111c588:	213dfc04 	addi	r4,r4,-2064
8111c58c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111c590:	d0a06217 	ldw	r2,-32376(gp)
8111c594:	100f883a 	mov	r7,r2
8111c598:	01801444 	movi	r6,81
8111c59c:	01400044 	movi	r5,1
8111c5a0:	01204574 	movhi	r4,33045
8111c5a4:	213e0704 	addi	r4,r4,-2020
8111c5a8:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c5ac:	0001883a 	nop
8111c5b0:	e037883a 	mov	sp,fp
8111c5b4:	dfc00117 	ldw	ra,4(sp)
8111c5b8:	df000017 	ldw	fp,0(sp)
8111c5bc:	dec00204 	addi	sp,sp,8
8111c5c0:	f800283a 	ret

8111c5c4 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111c5c4:	defffe04 	addi	sp,sp,-8
8111c5c8:	de00012e 	bgeu	sp,et,8111c5d0 <vCouldNotRetransmitB64TimeoutTask+0xc>
8111c5cc:	003b68fa 	trap	3
8111c5d0:	dfc00115 	stw	ra,4(sp)
8111c5d4:	df000015 	stw	fp,0(sp)
8111c5d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111c5dc:	d0a06217 	ldw	r2,-32376(gp)
8111c5e0:	100f883a 	mov	r7,r2
8111c5e4:	01800a84 	movi	r6,42
8111c5e8:	01400044 	movi	r5,1
8111c5ec:	01204574 	movhi	r4,33045
8111c5f0:	213e1c04 	addi	r4,r4,-1936
8111c5f4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111c5f8:	d0a06217 	ldw	r2,-32376(gp)
8111c5fc:	100f883a 	mov	r7,r2
8111c600:	01801444 	movi	r6,81
8111c604:	01400044 	movi	r5,1
8111c608:	01204574 	movhi	r4,33045
8111c60c:	213e2704 	addi	r4,r4,-1892
8111c610:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c614:	0001883a 	nop
8111c618:	e037883a 	mov	sp,fp
8111c61c:	dfc00117 	ldw	ra,4(sp)
8111c620:	df000017 	ldw	fp,0(sp)
8111c624:	dec00204 	addi	sp,sp,8
8111c628:	f800283a 	ret

8111c62c <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111c62c:	defffe04 	addi	sp,sp,-8
8111c630:	de00012e 	bgeu	sp,et,8111c638 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111c634:	003b68fa 	trap	3
8111c638:	dfc00115 	stw	ra,4(sp)
8111c63c:	df000015 	stw	fp,0(sp)
8111c640:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111c644:	d0a06217 	ldw	r2,-32376(gp)
8111c648:	100f883a 	mov	r7,r2
8111c64c:	01800ac4 	movi	r6,43
8111c650:	01400044 	movi	r5,1
8111c654:	01204574 	movhi	r4,33045
8111c658:	213e3c04 	addi	r4,r4,-1808
8111c65c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111c660:	d0a06217 	ldw	r2,-32376(gp)
8111c664:	100f883a 	mov	r7,r2
8111c668:	01801484 	movi	r6,82
8111c66c:	01400044 	movi	r5,1
8111c670:	01204574 	movhi	r4,33045
8111c674:	213e4704 	addi	r4,r4,-1764
8111c678:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c67c:	0001883a 	nop
8111c680:	e037883a 	mov	sp,fp
8111c684:	dfc00117 	ldw	ra,4(sp)
8111c688:	df000017 	ldw	fp,0(sp)
8111c68c:	dec00204 	addi	sp,sp,8
8111c690:	f800283a 	ret

8111c694 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111c694:	defffe04 	addi	sp,sp,-8
8111c698:	de00012e 	bgeu	sp,et,8111c6a0 <vFailStartTimerRetransmission+0xc>
8111c69c:	003b68fa 	trap	3
8111c6a0:	dfc00115 	stw	ra,4(sp)
8111c6a4:	df000015 	stw	fp,0(sp)
8111c6a8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111c6ac:	d0a06217 	ldw	r2,-32376(gp)
8111c6b0:	100f883a 	mov	r7,r2
8111c6b4:	01800984 	movi	r6,38
8111c6b8:	01400044 	movi	r5,1
8111c6bc:	01204574 	movhi	r4,33045
8111c6c0:	213e5c04 	addi	r4,r4,-1680
8111c6c4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111c6c8:	d0a06217 	ldw	r2,-32376(gp)
8111c6cc:	100f883a 	mov	r7,r2
8111c6d0:	01800d44 	movi	r6,53
8111c6d4:	01400044 	movi	r5,1
8111c6d8:	01204574 	movhi	r4,33045
8111c6dc:	213e6604 	addi	r4,r4,-1640
8111c6e0:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c6e4:	0001883a 	nop
8111c6e8:	e037883a 	mov	sp,fp
8111c6ec:	dfc00117 	ldw	ra,4(sp)
8111c6f0:	df000017 	ldw	fp,0(sp)
8111c6f4:	dec00204 	addi	sp,sp,8
8111c6f8:	f800283a 	ret

8111c6fc <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111c6fc:	defffe04 	addi	sp,sp,-8
8111c700:	de00012e 	bgeu	sp,et,8111c708 <vCouldNotSendTurnOff+0xc>
8111c704:	003b68fa 	trap	3
8111c708:	dfc00115 	stw	ra,4(sp)
8111c70c:	df000015 	stw	fp,0(sp)
8111c710:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111c714:	d0a06217 	ldw	r2,-32376(gp)
8111c718:	100f883a 	mov	r7,r2
8111c71c:	01800744 	movi	r6,29
8111c720:	01400044 	movi	r5,1
8111c724:	01204574 	movhi	r4,33045
8111c728:	213e7404 	addi	r4,r4,-1584
8111c72c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
8111c730:	d0a06217 	ldw	r2,-32376(gp)
8111c734:	100f883a 	mov	r7,r2
8111c738:	01800984 	movi	r6,38
8111c73c:	01400044 	movi	r5,1
8111c740:	01204574 	movhi	r4,33045
8111c744:	213e7c04 	addi	r4,r4,-1552
8111c748:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c74c:	0001883a 	nop
8111c750:	e037883a 	mov	sp,fp
8111c754:	dfc00117 	ldw	ra,4(sp)
8111c758:	df000017 	ldw	fp,0(sp)
8111c75c:	dec00204 	addi	sp,sp,8
8111c760:	f800283a 	ret

8111c764 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111c764:	defffe04 	addi	sp,sp,-8
8111c768:	de00012e 	bgeu	sp,et,8111c770 <vCouldNotSendReset+0xc>
8111c76c:	003b68fa 	trap	3
8111c770:	dfc00115 	stw	ra,4(sp)
8111c774:	df000015 	stw	fp,0(sp)
8111c778:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111c77c:	d0a06217 	ldw	r2,-32376(gp)
8111c780:	100f883a 	mov	r7,r2
8111c784:	018006c4 	movi	r6,27
8111c788:	01400044 	movi	r5,1
8111c78c:	01204574 	movhi	r4,33045
8111c790:	213e8604 	addi	r4,r4,-1512
8111c794:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
8111c798:	d0a06217 	ldw	r2,-32376(gp)
8111c79c:	100f883a 	mov	r7,r2
8111c7a0:	018008c4 	movi	r6,35
8111c7a4:	01400044 	movi	r5,1
8111c7a8:	01204574 	movhi	r4,33045
8111c7ac:	213e8d04 	addi	r4,r4,-1484
8111c7b0:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c7b4:	0001883a 	nop
8111c7b8:	e037883a 	mov	sp,fp
8111c7bc:	dfc00117 	ldw	ra,4(sp)
8111c7c0:	df000017 	ldw	fp,0(sp)
8111c7c4:	dec00204 	addi	sp,sp,8
8111c7c8:	f800283a 	ret

8111c7cc <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111c7cc:	defffe04 	addi	sp,sp,-8
8111c7d0:	de00012e 	bgeu	sp,et,8111c7d8 <vCouldNotSendLog+0xc>
8111c7d4:	003b68fa 	trap	3
8111c7d8:	dfc00115 	stw	ra,4(sp)
8111c7dc:	df000015 	stw	fp,0(sp)
8111c7e0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111c7e4:	d0a06217 	ldw	r2,-32376(gp)
8111c7e8:	100f883a 	mov	r7,r2
8111c7ec:	01800644 	movi	r6,25
8111c7f0:	01400044 	movi	r5,1
8111c7f4:	01204574 	movhi	r4,33045
8111c7f8:	213e9604 	addi	r4,r4,-1448
8111c7fc:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
8111c800:	d0a06217 	ldw	r2,-32376(gp)
8111c804:	100f883a 	mov	r7,r2
8111c808:	018008c4 	movi	r6,35
8111c80c:	01400044 	movi	r5,1
8111c810:	01204574 	movhi	r4,33045
8111c814:	213e9d04 	addi	r4,r4,-1420
8111c818:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c81c:	0001883a 	nop
8111c820:	e037883a 	mov	sp,fp
8111c824:	dfc00117 	ldw	ra,4(sp)
8111c828:	df000017 	ldw	fp,0(sp)
8111c82c:	dec00204 	addi	sp,sp,8
8111c830:	f800283a 	ret

8111c834 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111c834:	defffd04 	addi	sp,sp,-12
8111c838:	de00012e 	bgeu	sp,et,8111c840 <vCouldNotSendTMPusCommand+0xc>
8111c83c:	003b68fa 	trap	3
8111c840:	dfc00215 	stw	ra,8(sp)
8111c844:	df000115 	stw	fp,4(sp)
8111c848:	df000104 	addi	fp,sp,4
8111c84c:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111c850:	d0a06217 	ldw	r2,-32376(gp)
8111c854:	100f883a 	mov	r7,r2
8111c858:	01800884 	movi	r6,34
8111c85c:	01400044 	movi	r5,1
8111c860:	01204574 	movhi	r4,33045
8111c864:	213ea604 	addi	r4,r4,-1384
8111c868:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111c86c:	d0a06217 	ldw	r2,-32376(gp)
8111c870:	100f883a 	mov	r7,r2
8111c874:	01800ac4 	movi	r6,43
8111c878:	01400044 	movi	r5,1
8111c87c:	01204574 	movhi	r4,33045
8111c880:	213eaf04 	addi	r4,r4,-1348
8111c884:	11219e00 	call	811219e0 <fwrite>
		debug(fp,"cData");
8111c888:	d0a06217 	ldw	r2,-32376(gp)
8111c88c:	100f883a 	mov	r7,r2
8111c890:	01800144 	movi	r6,5
8111c894:	01400044 	movi	r5,1
8111c898:	01204574 	movhi	r4,33045
8111c89c:	213eba04 	addi	r4,r4,-1304
8111c8a0:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c8a4:	0001883a 	nop
8111c8a8:	e037883a 	mov	sp,fp
8111c8ac:	dfc00117 	ldw	ra,4(sp)
8111c8b0:	df000017 	ldw	fp,0(sp)
8111c8b4:	dec00204 	addi	sp,sp,8
8111c8b8:	f800283a 	ret

8111c8bc <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111c8bc:	defffe04 	addi	sp,sp,-8
8111c8c0:	de00012e 	bgeu	sp,et,8111c8c8 <vWarnCouldNotgetMutexRetrans128+0xc>
8111c8c4:	003b68fa 	trap	3
8111c8c8:	dfc00115 	stw	ra,4(sp)
8111c8cc:	df000015 	stw	fp,0(sp)
8111c8d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111c8d4:	d0a06217 	ldw	r2,-32376(gp)
8111c8d8:	100f883a 	mov	r7,r2
8111c8dc:	01800a04 	movi	r6,40
8111c8e0:	01400044 	movi	r5,1
8111c8e4:	01204574 	movhi	r4,33045
8111c8e8:	213ebc04 	addi	r4,r4,-1296
8111c8ec:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111c8f0:	d0a06217 	ldw	r2,-32376(gp)
8111c8f4:	100f883a 	mov	r7,r2
8111c8f8:	018014c4 	movi	r6,83
8111c8fc:	01400044 	movi	r5,1
8111c900:	01204574 	movhi	r4,33045
8111c904:	213ec704 	addi	r4,r4,-1252
8111c908:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c90c:	0001883a 	nop
8111c910:	e037883a 	mov	sp,fp
8111c914:	dfc00117 	ldw	ra,4(sp)
8111c918:	df000017 	ldw	fp,0(sp)
8111c91c:	dec00204 	addi	sp,sp,8
8111c920:	f800283a 	ret

8111c924 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111c924:	defffe04 	addi	sp,sp,-8
8111c928:	de00012e 	bgeu	sp,et,8111c930 <vFailCreateScheduleQueue+0xc>
8111c92c:	003b68fa 	trap	3
8111c930:	dfc00115 	stw	ra,4(sp)
8111c934:	df000015 	stw	fp,0(sp)
8111c938:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111c93c:	d0a06217 	ldw	r2,-32376(gp)
8111c940:	100f883a 	mov	r7,r2
8111c944:	01800844 	movi	r6,33
8111c948:	01400044 	movi	r5,1
8111c94c:	01204574 	movhi	r4,33045
8111c950:	213edc04 	addi	r4,r4,-1168
8111c954:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111c958:	d0a06217 	ldw	r2,-32376(gp)
8111c95c:	100f883a 	mov	r7,r2
8111c960:	01801204 	movi	r6,72
8111c964:	01400044 	movi	r5,1
8111c968:	01204574 	movhi	r4,33045
8111c96c:	213ee504 	addi	r4,r4,-1132
8111c970:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c974:	0001883a 	nop
8111c978:	e037883a 	mov	sp,fp
8111c97c:	dfc00117 	ldw	ra,4(sp)
8111c980:	df000017 	ldw	fp,0(sp)
8111c984:	dec00204 	addi	sp,sp,8
8111c988:	f800283a 	ret

8111c98c <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111c98c:	defffd04 	addi	sp,sp,-12
8111c990:	de00012e 	bgeu	sp,et,8111c998 <vFailCreateNFEEQueue+0xc>
8111c994:	003b68fa 	trap	3
8111c998:	dfc00215 	stw	ra,8(sp)
8111c99c:	df000115 	stw	fp,4(sp)
8111c9a0:	df000104 	addi	fp,sp,4
8111c9a4:	2005883a 	mov	r2,r4
8111c9a8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111c9ac:	d0a06217 	ldw	r2,-32376(gp)
8111c9b0:	100f883a 	mov	r7,r2
8111c9b4:	01800744 	movi	r6,29
8111c9b8:	01400044 	movi	r5,1
8111c9bc:	01204574 	movhi	r4,33045
8111c9c0:	213ef804 	addi	r4,r4,-1056
8111c9c4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		fprintf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111c9c8:	d0a06217 	ldw	r2,-32376(gp)
8111c9cc:	e0ffff03 	ldbu	r3,-4(fp)
8111c9d0:	180d883a 	mov	r6,r3
8111c9d4:	01604574 	movhi	r5,33045
8111c9d8:	297f0004 	addi	r5,r5,-1024
8111c9dc:	1009883a 	mov	r4,r2
8111c9e0:	11213440 	call	81121344 <fprintf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c9e4:	0001883a 	nop
8111c9e8:	e037883a 	mov	sp,fp
8111c9ec:	dfc00117 	ldw	ra,4(sp)
8111c9f0:	df000017 	ldw	fp,0(sp)
8111c9f4:	dec00204 	addi	sp,sp,8
8111c9f8:	f800283a 	ret

8111c9fc <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111c9fc:	defffd04 	addi	sp,sp,-12
8111ca00:	de00012e 	bgeu	sp,et,8111ca08 <vFailCreateNFEESyncQueue+0xc>
8111ca04:	003b68fa 	trap	3
8111ca08:	dfc00215 	stw	ra,8(sp)
8111ca0c:	df000115 	stw	fp,4(sp)
8111ca10:	df000104 	addi	fp,sp,4
8111ca14:	2005883a 	mov	r2,r4
8111ca18:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111ca1c:	d0a06217 	ldw	r2,-32376(gp)
8111ca20:	100f883a 	mov	r7,r2
8111ca24:	01800844 	movi	r6,33
8111ca28:	01400044 	movi	r5,1
8111ca2c:	01204574 	movhi	r4,33045
8111ca30:	213f0e04 	addi	r4,r4,-968
8111ca34:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		fprintf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111ca38:	d0a06217 	ldw	r2,-32376(gp)
8111ca3c:	e0ffff03 	ldbu	r3,-4(fp)
8111ca40:	180d883a 	mov	r6,r3
8111ca44:	01604574 	movhi	r5,33045
8111ca48:	297f1704 	addi	r5,r5,-932
8111ca4c:	1009883a 	mov	r4,r2
8111ca50:	11213440 	call	81121344 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ca54:	0001883a 	nop
8111ca58:	e037883a 	mov	sp,fp
8111ca5c:	dfc00117 	ldw	ra,4(sp)
8111ca60:	df000017 	ldw	fp,0(sp)
8111ca64:	dec00204 	addi	sp,sp,8
8111ca68:	f800283a 	ret

8111ca6c <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111ca6c:	defffe04 	addi	sp,sp,-8
8111ca70:	de00012e 	bgeu	sp,et,8111ca78 <vCoudlNotCreateNFee0Task+0xc>
8111ca74:	003b68fa 	trap	3
8111ca78:	dfc00115 	stw	ra,4(sp)
8111ca7c:	df000015 	stw	fp,0(sp)
8111ca80:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111ca84:	d0a06217 	ldw	r2,-32376(gp)
8111ca88:	100f883a 	mov	r7,r2
8111ca8c:	01800844 	movi	r6,33
8111ca90:	01400044 	movi	r5,1
8111ca94:	01204574 	movhi	r4,33045
8111ca98:	213f2504 	addi	r4,r4,-876
8111ca9c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
8111caa0:	d0a06217 	ldw	r2,-32376(gp)
8111caa4:	100f883a 	mov	r7,r2
8111caa8:	01800784 	movi	r6,30
8111caac:	01400044 	movi	r5,1
8111cab0:	01204574 	movhi	r4,33045
8111cab4:	213f2e04 	addi	r4,r4,-840
8111cab8:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cabc:	0001883a 	nop
8111cac0:	e037883a 	mov	sp,fp
8111cac4:	dfc00117 	ldw	ra,4(sp)
8111cac8:	df000017 	ldw	fp,0(sp)
8111cacc:	dec00204 	addi	sp,sp,8
8111cad0:	f800283a 	ret

8111cad4 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111cad4:	defffe04 	addi	sp,sp,-8
8111cad8:	de00012e 	bgeu	sp,et,8111cae0 <vCoudlNotCreateNFee1Task+0xc>
8111cadc:	003b68fa 	trap	3
8111cae0:	dfc00115 	stw	ra,4(sp)
8111cae4:	df000015 	stw	fp,0(sp)
8111cae8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111caec:	d0a06217 	ldw	r2,-32376(gp)
8111caf0:	100f883a 	mov	r7,r2
8111caf4:	01800844 	movi	r6,33
8111caf8:	01400044 	movi	r5,1
8111cafc:	01204574 	movhi	r4,33045
8111cb00:	213f3604 	addi	r4,r4,-808
8111cb04:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
8111cb08:	d0a06217 	ldw	r2,-32376(gp)
8111cb0c:	100f883a 	mov	r7,r2
8111cb10:	01800784 	movi	r6,30
8111cb14:	01400044 	movi	r5,1
8111cb18:	01204574 	movhi	r4,33045
8111cb1c:	213f3f04 	addi	r4,r4,-772
8111cb20:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cb24:	0001883a 	nop
8111cb28:	e037883a 	mov	sp,fp
8111cb2c:	dfc00117 	ldw	ra,4(sp)
8111cb30:	df000017 	ldw	fp,0(sp)
8111cb34:	dec00204 	addi	sp,sp,8
8111cb38:	f800283a 	ret

8111cb3c <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111cb3c:	defffe04 	addi	sp,sp,-8
8111cb40:	de00012e 	bgeu	sp,et,8111cb48 <vCoudlNotCreateNFee2Task+0xc>
8111cb44:	003b68fa 	trap	3
8111cb48:	dfc00115 	stw	ra,4(sp)
8111cb4c:	df000015 	stw	fp,0(sp)
8111cb50:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111cb54:	d0a06217 	ldw	r2,-32376(gp)
8111cb58:	100f883a 	mov	r7,r2
8111cb5c:	01800844 	movi	r6,33
8111cb60:	01400044 	movi	r5,1
8111cb64:	01204574 	movhi	r4,33045
8111cb68:	213f4704 	addi	r4,r4,-740
8111cb6c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
8111cb70:	d0a06217 	ldw	r2,-32376(gp)
8111cb74:	100f883a 	mov	r7,r2
8111cb78:	01800784 	movi	r6,30
8111cb7c:	01400044 	movi	r5,1
8111cb80:	01204574 	movhi	r4,33045
8111cb84:	213f5004 	addi	r4,r4,-704
8111cb88:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cb8c:	0001883a 	nop
8111cb90:	e037883a 	mov	sp,fp
8111cb94:	dfc00117 	ldw	ra,4(sp)
8111cb98:	df000017 	ldw	fp,0(sp)
8111cb9c:	dec00204 	addi	sp,sp,8
8111cba0:	f800283a 	ret

8111cba4 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111cba4:	defffe04 	addi	sp,sp,-8
8111cba8:	de00012e 	bgeu	sp,et,8111cbb0 <vCoudlNotCreateNFee3Task+0xc>
8111cbac:	003b68fa 	trap	3
8111cbb0:	dfc00115 	stw	ra,4(sp)
8111cbb4:	df000015 	stw	fp,0(sp)
8111cbb8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111cbbc:	d0a06217 	ldw	r2,-32376(gp)
8111cbc0:	100f883a 	mov	r7,r2
8111cbc4:	01800844 	movi	r6,33
8111cbc8:	01400044 	movi	r5,1
8111cbcc:	01204574 	movhi	r4,33045
8111cbd0:	213f5804 	addi	r4,r4,-672
8111cbd4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
8111cbd8:	d0a06217 	ldw	r2,-32376(gp)
8111cbdc:	100f883a 	mov	r7,r2
8111cbe0:	01800784 	movi	r6,30
8111cbe4:	01400044 	movi	r5,1
8111cbe8:	01204574 	movhi	r4,33045
8111cbec:	213f6104 	addi	r4,r4,-636
8111cbf0:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cbf4:	0001883a 	nop
8111cbf8:	e037883a 	mov	sp,fp
8111cbfc:	dfc00117 	ldw	ra,4(sp)
8111cc00:	df000017 	ldw	fp,0(sp)
8111cc04:	dec00204 	addi	sp,sp,8
8111cc08:	f800283a 	ret

8111cc0c <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111cc0c:	defffe04 	addi	sp,sp,-8
8111cc10:	de00012e 	bgeu	sp,et,8111cc18 <vCoudlNotCreateNFee4Task+0xc>
8111cc14:	003b68fa 	trap	3
8111cc18:	dfc00115 	stw	ra,4(sp)
8111cc1c:	df000015 	stw	fp,0(sp)
8111cc20:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111cc24:	d0a06217 	ldw	r2,-32376(gp)
8111cc28:	100f883a 	mov	r7,r2
8111cc2c:	01800844 	movi	r6,33
8111cc30:	01400044 	movi	r5,1
8111cc34:	01204574 	movhi	r4,33045
8111cc38:	213f6904 	addi	r4,r4,-604
8111cc3c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
8111cc40:	d0a06217 	ldw	r2,-32376(gp)
8111cc44:	100f883a 	mov	r7,r2
8111cc48:	01800784 	movi	r6,30
8111cc4c:	01400044 	movi	r5,1
8111cc50:	01204574 	movhi	r4,33045
8111cc54:	213f7204 	addi	r4,r4,-568
8111cc58:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cc5c:	0001883a 	nop
8111cc60:	e037883a 	mov	sp,fp
8111cc64:	dfc00117 	ldw	ra,4(sp)
8111cc68:	df000017 	ldw	fp,0(sp)
8111cc6c:	dec00204 	addi	sp,sp,8
8111cc70:	f800283a 	ret

8111cc74 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111cc74:	defffe04 	addi	sp,sp,-8
8111cc78:	de00012e 	bgeu	sp,et,8111cc80 <vCoudlNotCreateNFee5Task+0xc>
8111cc7c:	003b68fa 	trap	3
8111cc80:	dfc00115 	stw	ra,4(sp)
8111cc84:	df000015 	stw	fp,0(sp)
8111cc88:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111cc8c:	d0a06217 	ldw	r2,-32376(gp)
8111cc90:	100f883a 	mov	r7,r2
8111cc94:	01800844 	movi	r6,33
8111cc98:	01400044 	movi	r5,1
8111cc9c:	01204574 	movhi	r4,33045
8111cca0:	213f7a04 	addi	r4,r4,-536
8111cca4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
8111cca8:	d0a06217 	ldw	r2,-32376(gp)
8111ccac:	100f883a 	mov	r7,r2
8111ccb0:	01800784 	movi	r6,30
8111ccb4:	01400044 	movi	r5,1
8111ccb8:	01204574 	movhi	r4,33045
8111ccbc:	213f8304 	addi	r4,r4,-500
8111ccc0:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ccc4:	0001883a 	nop
8111ccc8:	e037883a 	mov	sp,fp
8111cccc:	dfc00117 	ldw	ra,4(sp)
8111ccd0:	df000017 	ldw	fp,0(sp)
8111ccd4:	dec00204 	addi	sp,sp,8
8111ccd8:	f800283a 	ret

8111ccdc <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111ccdc:	defffe04 	addi	sp,sp,-8
8111cce0:	de00012e 	bgeu	sp,et,8111cce8 <vCoudlNotCreateNFeeControllerTask+0xc>
8111cce4:	003b68fa 	trap	3
8111cce8:	dfc00115 	stw	ra,4(sp)
8111ccec:	df000015 	stw	fp,0(sp)
8111ccf0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111ccf4:	d0a06217 	ldw	r2,-32376(gp)
8111ccf8:	100f883a 	mov	r7,r2
8111ccfc:	01800a84 	movi	r6,42
8111cd00:	01400044 	movi	r5,1
8111cd04:	01204574 	movhi	r4,33045
8111cd08:	213f8b04 	addi	r4,r4,-468
8111cd0c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
8111cd10:	d0a06217 	ldw	r2,-32376(gp)
8111cd14:	100f883a 	mov	r7,r2
8111cd18:	018009c4 	movi	r6,39
8111cd1c:	01400044 	movi	r5,1
8111cd20:	01204574 	movhi	r4,33045
8111cd24:	213f9604 	addi	r4,r4,-424
8111cd28:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cd2c:	0001883a 	nop
8111cd30:	e037883a 	mov	sp,fp
8111cd34:	dfc00117 	ldw	ra,4(sp)
8111cd38:	df000017 	ldw	fp,0(sp)
8111cd3c:	dec00204 	addi	sp,sp,8
8111cd40:	f800283a 	ret

8111cd44 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111cd44:	defffe04 	addi	sp,sp,-8
8111cd48:	de00012e 	bgeu	sp,et,8111cd50 <vCoudlNotCreateDataControllerTask+0xc>
8111cd4c:	003b68fa 	trap	3
8111cd50:	dfc00115 	stw	ra,4(sp)
8111cd54:	df000015 	stw	fp,0(sp)
8111cd58:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111cd5c:	d0a06217 	ldw	r2,-32376(gp)
8111cd60:	100f883a 	mov	r7,r2
8111cd64:	01800a84 	movi	r6,42
8111cd68:	01400044 	movi	r5,1
8111cd6c:	01204574 	movhi	r4,33045
8111cd70:	213fa004 	addi	r4,r4,-384
8111cd74:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
8111cd78:	d0a06217 	ldw	r2,-32376(gp)
8111cd7c:	100f883a 	mov	r7,r2
8111cd80:	018009c4 	movi	r6,39
8111cd84:	01400044 	movi	r5,1
8111cd88:	01204574 	movhi	r4,33045
8111cd8c:	213fab04 	addi	r4,r4,-340
8111cd90:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cd94:	0001883a 	nop
8111cd98:	e037883a 	mov	sp,fp
8111cd9c:	dfc00117 	ldw	ra,4(sp)
8111cda0:	df000017 	ldw	fp,0(sp)
8111cda4:	dec00204 	addi	sp,sp,8
8111cda8:	f800283a 	ret

8111cdac <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111cdac:	defffe04 	addi	sp,sp,-8
8111cdb0:	de00012e 	bgeu	sp,et,8111cdb8 <vCoudlNotCreateMebTask+0xc>
8111cdb4:	003b68fa 	trap	3
8111cdb8:	dfc00115 	stw	ra,4(sp)
8111cdbc:	df000015 	stw	fp,0(sp)
8111cdc0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111cdc4:	d0a06217 	ldw	r2,-32376(gp)
8111cdc8:	100f883a 	mov	r7,r2
8111cdcc:	018007c4 	movi	r6,31
8111cdd0:	01400044 	movi	r5,1
8111cdd4:	01204574 	movhi	r4,33045
8111cdd8:	213fb504 	addi	r4,r4,-300
8111cddc:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
8111cde0:	d0a06217 	ldw	r2,-32376(gp)
8111cde4:	100f883a 	mov	r7,r2
8111cde8:	018006c4 	movi	r6,27
8111cdec:	01400044 	movi	r5,1
8111cdf0:	01204574 	movhi	r4,33045
8111cdf4:	213fbd04 	addi	r4,r4,-268
8111cdf8:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cdfc:	0001883a 	nop
8111ce00:	e037883a 	mov	sp,fp
8111ce04:	dfc00117 	ldw	ra,4(sp)
8111ce08:	df000017 	ldw	fp,0(sp)
8111ce0c:	dec00204 	addi	sp,sp,8
8111ce10:	f800283a 	ret

8111ce14 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111ce14:	defffd04 	addi	sp,sp,-12
8111ce18:	de00012e 	bgeu	sp,et,8111ce20 <vFailCreateMutexSPUSQueueMeb+0xc>
8111ce1c:	003b68fa 	trap	3
8111ce20:	dfc00215 	stw	ra,8(sp)
8111ce24:	df000115 	stw	fp,4(sp)
8111ce28:	df000104 	addi	fp,sp,4
8111ce2c:	2005883a 	mov	r2,r4
8111ce30:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111ce34:	d0a06217 	ldw	r2,-32376(gp)
8111ce38:	100f883a 	mov	r7,r2
8111ce3c:	01800944 	movi	r6,37
8111ce40:	01400044 	movi	r5,1
8111ce44:	01204574 	movhi	r4,33045
8111ce48:	213fc404 	addi	r4,r4,-240
8111ce4c:	11219e00 	call	811219e0 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111ce50:	e0bfff03 	ldbu	r2,-4(fp)
8111ce54:	1009883a 	mov	r4,r2
8111ce58:	111b5c00 	call	8111b5c0 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ce5c:	0001883a 	nop
8111ce60:	e037883a 	mov	sp,fp
8111ce64:	dfc00117 	ldw	ra,4(sp)
8111ce68:	df000017 	ldw	fp,0(sp)
8111ce6c:	dec00204 	addi	sp,sp,8
8111ce70:	f800283a 	ret

8111ce74 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111ce74:	defffe04 	addi	sp,sp,-8
8111ce78:	de00012e 	bgeu	sp,et,8111ce80 <vFailSendPUStoMebTask+0xc>
8111ce7c:	003b68fa 	trap	3
8111ce80:	dfc00115 	stw	ra,4(sp)
8111ce84:	df000015 	stw	fp,0(sp)
8111ce88:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111ce8c:	d0a06217 	ldw	r2,-32376(gp)
8111ce90:	100f883a 	mov	r7,r2
8111ce94:	01800784 	movi	r6,30
8111ce98:	01400044 	movi	r5,1
8111ce9c:	01204574 	movhi	r4,33045
8111cea0:	213fce04 	addi	r4,r4,-200
8111cea4:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cea8:	0001883a 	nop
8111ceac:	e037883a 	mov	sp,fp
8111ceb0:	dfc00117 	ldw	ra,4(sp)
8111ceb4:	df000017 	ldw	fp,0(sp)
8111ceb8:	dec00204 	addi	sp,sp,8
8111cebc:	f800283a 	ret

8111cec0 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111cec0:	defffe04 	addi	sp,sp,-8
8111cec4:	de00012e 	bgeu	sp,et,8111cecc <vCouldNotGetCmdQueueMeb+0xc>
8111cec8:	003b68fa 	trap	3
8111cecc:	dfc00115 	stw	ra,4(sp)
8111ced0:	df000015 	stw	fp,0(sp)
8111ced4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111ced8:	d0a06217 	ldw	r2,-32376(gp)
8111cedc:	100f883a 	mov	r7,r2
8111cee0:	01800a84 	movi	r6,42
8111cee4:	01400044 	movi	r5,1
8111cee8:	01204574 	movhi	r4,33045
8111ceec:	213fd604 	addi	r4,r4,-168
8111cef0:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111cef4:	d0a06217 	ldw	r2,-32376(gp)
8111cef8:	100f883a 	mov	r7,r2
8111cefc:	01800cc4 	movi	r6,51
8111cf00:	01400044 	movi	r5,1
8111cf04:	01204574 	movhi	r4,33045
8111cf08:	213fe104 	addi	r4,r4,-124
8111cf0c:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf10:	0001883a 	nop
8111cf14:	e037883a 	mov	sp,fp
8111cf18:	dfc00117 	ldw	ra,4(sp)
8111cf1c:	df000017 	ldw	fp,0(sp)
8111cf20:	dec00204 	addi	sp,sp,8
8111cf24:	f800283a 	ret

8111cf28 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111cf28:	defffe04 	addi	sp,sp,-8
8111cf2c:	de00012e 	bgeu	sp,et,8111cf34 <vCouldNotGetMutexMebPus+0xc>
8111cf30:	003b68fa 	trap	3
8111cf34:	dfc00115 	stw	ra,4(sp)
8111cf38:	df000015 	stw	fp,0(sp)
8111cf3c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111cf40:	d0a06217 	ldw	r2,-32376(gp)
8111cf44:	100f883a 	mov	r7,r2
8111cf48:	01800804 	movi	r6,32
8111cf4c:	01400044 	movi	r5,1
8111cf50:	01204574 	movhi	r4,33045
8111cf54:	213fee04 	addi	r4,r4,-72
8111cf58:	11219e00 	call	811219e0 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cf5c:	0001883a 	nop
8111cf60:	e037883a 	mov	sp,fp
8111cf64:	dfc00117 	ldw	ra,4(sp)
8111cf68:	df000017 	ldw	fp,0(sp)
8111cf6c:	dec00204 	addi	sp,sp,8
8111cf70:	f800283a 	ret

8111cf74 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111cf74:	defffe04 	addi	sp,sp,-8
8111cf78:	de00012e 	bgeu	sp,et,8111cf80 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111cf7c:	003b68fa 	trap	3
8111cf80:	dfc00115 	stw	ra,4(sp)
8111cf84:	df000015 	stw	fp,0(sp)
8111cf88:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111cf8c:	d0a06217 	ldw	r2,-32376(gp)
8111cf90:	100f883a 	mov	r7,r2
8111cf94:	01800a44 	movi	r6,41
8111cf98:	01400044 	movi	r5,1
8111cf9c:	01204574 	movhi	r4,33045
8111cfa0:	213ff704 	addi	r4,r4,-36
8111cfa4:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111cfa8:	d0a06217 	ldw	r2,-32376(gp)
8111cfac:	100f883a 	mov	r7,r2
8111cfb0:	01800c84 	movi	r6,50
8111cfb4:	01400044 	movi	r5,1
8111cfb8:	01204574 	movhi	r4,33045
8111cfbc:	21000204 	addi	r4,r4,8
8111cfc0:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111cfc4:	0001883a 	nop
8111cfc8:	e037883a 	mov	sp,fp
8111cfcc:	dfc00117 	ldw	ra,4(sp)
8111cfd0:	df000017 	ldw	fp,0(sp)
8111cfd4:	dec00204 	addi	sp,sp,8
8111cfd8:	f800283a 	ret

8111cfdc <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111cfdc:	defffe04 	addi	sp,sp,-8
8111cfe0:	de00012e 	bgeu	sp,et,8111cfe8 <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111cfe4:	003b68fa 	trap	3
8111cfe8:	dfc00115 	stw	ra,4(sp)
8111cfec:	df000015 	stw	fp,0(sp)
8111cff0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111cff4:	d0a06217 	ldw	r2,-32376(gp)
8111cff8:	100f883a 	mov	r7,r2
8111cffc:	01800a44 	movi	r6,41
8111d000:	01400044 	movi	r5,1
8111d004:	01204574 	movhi	r4,33045
8111d008:	21000f04 	addi	r4,r4,60
8111d00c:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111d010:	d0a06217 	ldw	r2,-32376(gp)
8111d014:	100f883a 	mov	r7,r2
8111d018:	01800c84 	movi	r6,50
8111d01c:	01400044 	movi	r5,1
8111d020:	01204574 	movhi	r4,33045
8111d024:	21001a04 	addi	r4,r4,104
8111d028:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d02c:	0001883a 	nop
8111d030:	e037883a 	mov	sp,fp
8111d034:	dfc00117 	ldw	ra,4(sp)
8111d038:	df000017 	ldw	fp,0(sp)
8111d03c:	dec00204 	addi	sp,sp,8
8111d040:	f800283a 	ret

8111d044 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111d044:	defffe04 	addi	sp,sp,-8
8111d048:	de00012e 	bgeu	sp,et,8111d050 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111d04c:	003b68fa 	trap	3
8111d050:	dfc00115 	stw	ra,4(sp)
8111d054:	df000015 	stw	fp,0(sp)
8111d058:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111d05c:	d0a06217 	ldw	r2,-32376(gp)
8111d060:	100f883a 	mov	r7,r2
8111d064:	01800984 	movi	r6,38
8111d068:	01400044 	movi	r5,1
8111d06c:	01204574 	movhi	r4,33045
8111d070:	21002704 	addi	r4,r4,156
8111d074:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111d078:	d0a06217 	ldw	r2,-32376(gp)
8111d07c:	100f883a 	mov	r7,r2
8111d080:	01800bc4 	movi	r6,47
8111d084:	01400044 	movi	r5,1
8111d088:	01204574 	movhi	r4,33045
8111d08c:	21003104 	addi	r4,r4,196
8111d090:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d094:	0001883a 	nop
8111d098:	e037883a 	mov	sp,fp
8111d09c:	dfc00117 	ldw	ra,4(sp)
8111d0a0:	df000017 	ldw	fp,0(sp)
8111d0a4:	dec00204 	addi	sp,sp,8
8111d0a8:	f800283a 	ret

8111d0ac <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111d0ac:	defffe04 	addi	sp,sp,-8
8111d0b0:	de00012e 	bgeu	sp,et,8111d0b8 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111d0b4:	003b68fa 	trap	3
8111d0b8:	dfc00115 	stw	ra,4(sp)
8111d0bc:	df000015 	stw	fp,0(sp)
8111d0c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111d0c4:	d0a06217 	ldw	r2,-32376(gp)
8111d0c8:	100f883a 	mov	r7,r2
8111d0cc:	01800984 	movi	r6,38
8111d0d0:	01400044 	movi	r5,1
8111d0d4:	01204574 	movhi	r4,33045
8111d0d8:	21003d04 	addi	r4,r4,244
8111d0dc:	11219e00 	call	811219e0 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111d0e0:	d0a06217 	ldw	r2,-32376(gp)
8111d0e4:	100f883a 	mov	r7,r2
8111d0e8:	01800bc4 	movi	r6,47
8111d0ec:	01400044 	movi	r5,1
8111d0f0:	01204574 	movhi	r4,33045
8111d0f4:	21004704 	addi	r4,r4,284
8111d0f8:	11219e00 	call	811219e0 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d0fc:	0001883a 	nop
8111d100:	e037883a 	mov	sp,fp
8111d104:	dfc00117 	ldw	ra,4(sp)
8111d108:	df000017 	ldw	fp,0(sp)
8111d10c:	dec00204 	addi	sp,sp,8
8111d110:	f800283a 	ret

8111d114 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111d114:	defffd04 	addi	sp,sp,-12
8111d118:	de00012e 	bgeu	sp,et,8111d120 <vFailSendMsgAccessDMA+0xc>
8111d11c:	003b68fa 	trap	3
8111d120:	dfc00215 	stw	ra,8(sp)
8111d124:	df000115 	stw	fp,4(sp)
8111d128:	df000104 	addi	fp,sp,4
8111d12c:	2005883a 	mov	r2,r4
8111d130:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
8111d134:	d0a06217 	ldw	r2,-32376(gp)
8111d138:	e0ffff03 	ldbu	r3,-4(fp)
8111d13c:	180d883a 	mov	r6,r3
8111d140:	01604574 	movhi	r5,33045
8111d144:	29405304 	addi	r5,r5,332
8111d148:	1009883a 	mov	r4,r2
8111d14c:	11213440 	call	81121344 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d150:	0001883a 	nop
8111d154:	e037883a 	mov	sp,fp
8111d158:	dfc00117 	ldw	ra,4(sp)
8111d15c:	df000017 	ldw	fp,0(sp)
8111d160:	dec00204 	addi	sp,sp,8
8111d164:	f800283a 	ret

8111d168 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111d168:	defffd04 	addi	sp,sp,-12
8111d16c:	de00012e 	bgeu	sp,et,8111d174 <vFailRequestDMA+0xc>
8111d170:	003b68fa 	trap	3
8111d174:	dfc00215 	stw	ra,8(sp)
8111d178:	df000115 	stw	fp,4(sp)
8111d17c:	df000104 	addi	fp,sp,4
8111d180:	2005883a 	mov	r2,r4
8111d184:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111d188:	d0a06217 	ldw	r2,-32376(gp)
8111d18c:	e0ffff03 	ldbu	r3,-4(fp)
8111d190:	180d883a 	mov	r6,r3
8111d194:	01604574 	movhi	r5,33045
8111d198:	29405b04 	addi	r5,r5,364
8111d19c:	1009883a 	mov	r4,r2
8111d1a0:	11213440 	call	81121344 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d1a4:	0001883a 	nop
8111d1a8:	e037883a 	mov	sp,fp
8111d1ac:	dfc00117 	ldw	ra,4(sp)
8111d1b0:	df000017 	ldw	fp,0(sp)
8111d1b4:	dec00204 	addi	sp,sp,8
8111d1b8:	f800283a 	ret

8111d1bc <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111d1bc:	defffd04 	addi	sp,sp,-12
8111d1c0:	de00012e 	bgeu	sp,et,8111d1c8 <vFailRequestDMAFromIRQ+0xc>
8111d1c4:	003b68fa 	trap	3
8111d1c8:	dfc00215 	stw	ra,8(sp)
8111d1cc:	df000115 	stw	fp,4(sp)
8111d1d0:	df000104 	addi	fp,sp,4
8111d1d4:	2005883a 	mov	r2,r4
8111d1d8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111d1dc:	d0a06217 	ldw	r2,-32376(gp)
8111d1e0:	e0ffff03 	ldbu	r3,-4(fp)
8111d1e4:	180d883a 	mov	r6,r3
8111d1e8:	01604574 	movhi	r5,33045
8111d1ec:	29405b04 	addi	r5,r5,364
8111d1f0:	1009883a 	mov	r4,r2
8111d1f4:	11213440 	call	81121344 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d1f8:	0001883a 	nop
8111d1fc:	e037883a 	mov	sp,fp
8111d200:	dfc00117 	ldw	ra,4(sp)
8111d204:	df000017 	ldw	fp,0(sp)
8111d208:	dec00204 	addi	sp,sp,8
8111d20c:	f800283a 	ret

8111d210 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111d210:	defffd04 	addi	sp,sp,-12
8111d214:	de00012e 	bgeu	sp,et,8111d21c <vFailSendRMAPFromIRQ+0xc>
8111d218:	003b68fa 	trap	3
8111d21c:	dfc00215 	stw	ra,8(sp)
8111d220:	df000115 	stw	fp,4(sp)
8111d224:	df000104 	addi	fp,sp,4
8111d228:	2005883a 	mov	r2,r4
8111d22c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n: \n", ucTemp);
8111d230:	d0a06217 	ldw	r2,-32376(gp)
8111d234:	e0ffff03 	ldbu	r3,-4(fp)
8111d238:	180d883a 	mov	r6,r3
8111d23c:	01604574 	movhi	r5,33045
8111d240:	29406204 	addi	r5,r5,392
8111d244:	1009883a 	mov	r4,r2
8111d248:	11213440 	call	81121344 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d24c:	0001883a 	nop
8111d250:	e037883a 	mov	sp,fp
8111d254:	dfc00117 	ldw	ra,4(sp)
8111d258:	df000017 	ldw	fp,0(sp)
8111d25c:	dec00204 	addi	sp,sp,8
8111d260:	f800283a 	ret

8111d264 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111d264:	defffd04 	addi	sp,sp,-12
8111d268:	de00012e 	bgeu	sp,et,8111d270 <vFailSendMsgSync+0xc>
8111d26c:	003b68fa 	trap	3
8111d270:	dfc00215 	stw	ra,8(sp)
8111d274:	df000115 	stw	fp,4(sp)
8111d278:	df000104 	addi	fp,sp,4
8111d27c:	2005883a 	mov	r2,r4
8111d280:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
8111d284:	d0a06217 	ldw	r2,-32376(gp)
8111d288:	e0ffff03 	ldbu	r3,-4(fp)
8111d28c:	180d883a 	mov	r6,r3
8111d290:	01604574 	movhi	r5,33045
8111d294:	29406a04 	addi	r5,r5,424
8111d298:	1009883a 	mov	r4,r2
8111d29c:	11213440 	call	81121344 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d2a0:	0001883a 	nop
8111d2a4:	e037883a 	mov	sp,fp
8111d2a8:	dfc00117 	ldw	ra,4(sp)
8111d2ac:	df000017 	ldw	fp,0(sp)
8111d2b0:	dec00204 	addi	sp,sp,8
8111d2b4:	f800283a 	ret

8111d2b8 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111d2b8:	defffd04 	addi	sp,sp,-12
8111d2bc:	de00012e 	bgeu	sp,et,8111d2c4 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111d2c0:	003b68fa 	trap	3
8111d2c4:	dfc00215 	stw	ra,8(sp)
8111d2c8:	df000115 	stw	fp,4(sp)
8111d2cc:	df000104 	addi	fp,sp,4
8111d2d0:	2005883a 	mov	r2,r4
8111d2d4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n: \n", ucTemp);
8111d2d8:	d0a06217 	ldw	r2,-32376(gp)
8111d2dc:	e0ffff03 	ldbu	r3,-4(fp)
8111d2e0:	180d883a 	mov	r6,r3
8111d2e4:	01604574 	movhi	r5,33045
8111d2e8:	29407104 	addi	r5,r5,452
8111d2ec:	1009883a 	mov	r4,r2
8111d2f0:	11213440 	call	81121344 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d2f4:	0001883a 	nop
8111d2f8:	e037883a 	mov	sp,fp
8111d2fc:	dfc00117 	ldw	ra,4(sp)
8111d300:	df000017 	ldw	fp,0(sp)
8111d304:	dec00204 	addi	sp,sp,8
8111d308:	f800283a 	ret

8111d30c <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111d30c:	defffe04 	addi	sp,sp,-8
8111d310:	de00012e 	bgeu	sp,et,8111d318 <vFailSendMsgMasterSyncMeb+0xc>
8111d314:	003b68fa 	trap	3
8111d318:	dfc00115 	stw	ra,4(sp)
8111d31c:	df000015 	stw	fp,0(sp)
8111d320:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111d324:	d0a06217 	ldw	r2,-32376(gp)
8111d328:	100f883a 	mov	r7,r2
8111d32c:	018006c4 	movi	r6,27
8111d330:	01400044 	movi	r5,1
8111d334:	01204574 	movhi	r4,33045
8111d338:	21007e04 	addi	r4,r4,504
8111d33c:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d340:	0001883a 	nop
8111d344:	e037883a 	mov	sp,fp
8111d348:	dfc00117 	ldw	ra,4(sp)
8111d34c:	df000017 	ldw	fp,0(sp)
8111d350:	dec00204 	addi	sp,sp,8
8111d354:	f800283a 	ret

8111d358 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111d358:	defffe04 	addi	sp,sp,-8
8111d35c:	de00012e 	bgeu	sp,et,8111d364 <vFailSendMsgFeeCTRL+0xc>
8111d360:	003b68fa 	trap	3
8111d364:	dfc00115 	stw	ra,4(sp)
8111d368:	df000015 	stw	fp,0(sp)
8111d36c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111d370:	d0a06217 	ldw	r2,-32376(gp)
8111d374:	100f883a 	mov	r7,r2
8111d378:	018005c4 	movi	r6,23
8111d37c:	01400044 	movi	r5,1
8111d380:	01204574 	movhi	r4,33045
8111d384:	21008504 	addi	r4,r4,532
8111d388:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d38c:	0001883a 	nop
8111d390:	e037883a 	mov	sp,fp
8111d394:	dfc00117 	ldw	ra,4(sp)
8111d398:	df000017 	ldw	fp,0(sp)
8111d39c:	dec00204 	addi	sp,sp,8
8111d3a0:	f800283a 	ret

8111d3a4 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111d3a4:	defffe04 	addi	sp,sp,-8
8111d3a8:	de00012e 	bgeu	sp,et,8111d3b0 <vFailSendMsgDataCTRL+0xc>
8111d3ac:	003b68fa 	trap	3
8111d3b0:	dfc00115 	stw	ra,4(sp)
8111d3b4:	df000015 	stw	fp,0(sp)
8111d3b8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111d3bc:	d0a06217 	ldw	r2,-32376(gp)
8111d3c0:	100f883a 	mov	r7,r2
8111d3c4:	01800604 	movi	r6,24
8111d3c8:	01400044 	movi	r5,1
8111d3cc:	01204574 	movhi	r4,33045
8111d3d0:	21008b04 	addi	r4,r4,556
8111d3d4:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d3d8:	0001883a 	nop
8111d3dc:	e037883a 	mov	sp,fp
8111d3e0:	dfc00117 	ldw	ra,4(sp)
8111d3e4:	df000017 	ldw	fp,0(sp)
8111d3e8:	dec00204 	addi	sp,sp,8
8111d3ec:	f800283a 	ret

8111d3f0 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111d3f0:	defffe04 	addi	sp,sp,-8
8111d3f4:	de00012e 	bgeu	sp,et,8111d3fc <vFailFlushQueue+0xc>
8111d3f8:	003b68fa 	trap	3
8111d3fc:	dfc00115 	stw	ra,4(sp)
8111d400:	df000015 	stw	fp,0(sp)
8111d404:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111d408:	d0a06217 	ldw	r2,-32376(gp)
8111d40c:	100f883a 	mov	r7,r2
8111d410:	01800744 	movi	r6,29
8111d414:	01400044 	movi	r5,1
8111d418:	01204574 	movhi	r4,33045
8111d41c:	21009204 	addi	r4,r4,584
8111d420:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d424:	0001883a 	nop
8111d428:	e037883a 	mov	sp,fp
8111d42c:	dfc00117 	ldw	ra,4(sp)
8111d430:	df000017 	ldw	fp,0(sp)
8111d434:	dec00204 	addi	sp,sp,8
8111d438:	f800283a 	ret

8111d43c <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111d43c:	defffe04 	addi	sp,sp,-8
8111d440:	de00012e 	bgeu	sp,et,8111d448 <vFailFlushQueueData+0xc>
8111d444:	003b68fa 	trap	3
8111d448:	dfc00115 	stw	ra,4(sp)
8111d44c:	df000015 	stw	fp,0(sp)
8111d450:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111d454:	d0a06217 	ldw	r2,-32376(gp)
8111d458:	100f883a 	mov	r7,r2
8111d45c:	01800844 	movi	r6,33
8111d460:	01400044 	movi	r5,1
8111d464:	01204574 	movhi	r4,33045
8111d468:	21009a04 	addi	r4,r4,616
8111d46c:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d470:	0001883a 	nop
8111d474:	e037883a 	mov	sp,fp
8111d478:	dfc00117 	ldw	ra,4(sp)
8111d47c:	df000017 	ldw	fp,0(sp)
8111d480:	dec00204 	addi	sp,sp,8
8111d484:	f800283a 	ret

8111d488 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111d488:	defffe04 	addi	sp,sp,-8
8111d48c:	de00012e 	bgeu	sp,et,8111d494 <vFailFlushMEBQueue+0xc>
8111d490:	003b68fa 	trap	3
8111d494:	dfc00115 	stw	ra,4(sp)
8111d498:	df000015 	stw	fp,0(sp)
8111d49c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111d4a0:	d0a06217 	ldw	r2,-32376(gp)
8111d4a4:	100f883a 	mov	r7,r2
8111d4a8:	01800804 	movi	r6,32
8111d4ac:	01400044 	movi	r5,1
8111d4b0:	01204574 	movhi	r4,33045
8111d4b4:	2100a304 	addi	r4,r4,652
8111d4b8:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d4bc:	0001883a 	nop
8111d4c0:	e037883a 	mov	sp,fp
8111d4c4:	dfc00117 	ldw	ra,4(sp)
8111d4c8:	df000017 	ldw	fp,0(sp)
8111d4cc:	dec00204 	addi	sp,sp,8
8111d4d0:	f800283a 	ret

8111d4d4 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111d4d4:	defffe04 	addi	sp,sp,-8
8111d4d8:	de00012e 	bgeu	sp,et,8111d4e0 <vFailFlushNFEEQueue+0xc>
8111d4dc:	003b68fa 	trap	3
8111d4e0:	dfc00115 	stw	ra,4(sp)
8111d4e4:	df000015 	stw	fp,0(sp)
8111d4e8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111d4ec:	d0a06217 	ldw	r2,-32376(gp)
8111d4f0:	100f883a 	mov	r7,r2
8111d4f4:	01800844 	movi	r6,33
8111d4f8:	01400044 	movi	r5,1
8111d4fc:	01204574 	movhi	r4,33045
8111d500:	2100ac04 	addi	r4,r4,688
8111d504:	11219e00 	call	811219e0 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111d508:	0001883a 	nop
8111d50c:	e037883a 	mov	sp,fp
8111d510:	dfc00117 	ldw	ra,4(sp)
8111d514:	df000017 	ldw	fp,0(sp)
8111d518:	dec00204 	addi	sp,sp,8
8111d51c:	f800283a 	ret

8111d520 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111d520:	deffff04 	addi	sp,sp,-4
8111d524:	de00012e 	bgeu	sp,et,8111d52c <vEvtChangeMebMode+0xc>
8111d528:	003b68fa 	trap	3
8111d52c:	df000015 	stw	fp,0(sp)
8111d530:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d534:	0001883a 	nop
8111d538:	e037883a 	mov	sp,fp
8111d53c:	df000017 	ldw	fp,0(sp)
8111d540:	dec00104 	addi	sp,sp,4
8111d544:	f800283a 	ret

8111d548 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111d548:	deffff04 	addi	sp,sp,-4
8111d54c:	de00012e 	bgeu	sp,et,8111d554 <vEvtChangeFeeControllerMode+0xc>
8111d550:	003b68fa 	trap	3
8111d554:	df000015 	stw	fp,0(sp)
8111d558:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d55c:	0001883a 	nop
8111d560:	e037883a 	mov	sp,fp
8111d564:	df000017 	ldw	fp,0(sp)
8111d568:	dec00104 	addi	sp,sp,4
8111d56c:	f800283a 	ret

8111d570 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111d570:	deffff04 	addi	sp,sp,-4
8111d574:	de00012e 	bgeu	sp,et,8111d57c <vEvtChangeDataControllerMode+0xc>
8111d578:	003b68fa 	trap	3
8111d57c:	df000015 	stw	fp,0(sp)
8111d580:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111d584:	0001883a 	nop
8111d588:	e037883a 	mov	sp,fp
8111d58c:	df000017 	ldw	fp,0(sp)
8111d590:	dec00104 	addi	sp,sp,4
8111d594:	f800283a 	ret

8111d598 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111d598:	defffd04 	addi	sp,sp,-12
8111d59c:	de00012e 	bgeu	sp,et,8111d5a4 <vNFeeNotInUse+0xc>
8111d5a0:	003b68fa 	trap	3
8111d5a4:	df000215 	stw	fp,8(sp)
8111d5a8:	df000204 	addi	fp,sp,8
8111d5ac:	e13ffe15 	stw	r4,-8(fp)
8111d5b0:	2805883a 	mov	r2,r5
8111d5b4:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111d5b8:	e0bffe17 	ldw	r2,-8(fp)
8111d5bc:	e0ffff03 	ldbu	r3,-4(fp)
8111d5c0:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111d5c4:	e0bffe17 	ldw	r2,-8(fp)
8111d5c8:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111d5cc:	e0bffe17 	ldw	r2,-8(fp)
8111d5d0:	10002315 	stw	zero,140(r2)
}
8111d5d4:	0001883a 	nop
8111d5d8:	e037883a 	mov	sp,fp
8111d5dc:	df000017 	ldw	fp,0(sp)
8111d5e0:	dec00104 	addi	sp,sp,4
8111d5e4:	f800283a 	ret

8111d5e8 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111d5e8:	defffb04 	addi	sp,sp,-20
8111d5ec:	de00012e 	bgeu	sp,et,8111d5f4 <vNFeeStructureInit+0xc>
8111d5f0:	003b68fa 	trap	3
8111d5f4:	dfc00415 	stw	ra,16(sp)
8111d5f8:	df000315 	stw	fp,12(sp)
8111d5fc:	df000304 	addi	fp,sp,12
8111d600:	e13ffe15 	stw	r4,-8(fp)
8111d604:	2805883a 	mov	r2,r5
8111d608:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111d60c:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111d610:	e0bffe17 	ldw	r2,-8(fp)
8111d614:	e0ffff03 	ldbu	r3,-4(fp)
8111d618:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111d61c:	e0bffe17 	ldw	r2,-8(fp)
8111d620:	10802f04 	addi	r2,r2,188
8111d624:	1009883a 	mov	r4,r2
8111d628:	11181c40 	call	811181c4 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111d62c:	e13ffe17 	ldw	r4,-8(fp)
8111d630:	111d8240 	call	8111d824 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111d634:	e0bffe17 	ldw	r2,-8(fp)
8111d638:	00c00044 	movi	r3,1
8111d63c:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111d640:	e0bffe17 	ldw	r2,-8(fp)
8111d644:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111d648:	e0bffe17 	ldw	r2,-8(fp)
8111d64c:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111d650:	e0bffe17 	ldw	r2,-8(fp)
8111d654:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111d658:	e0bffe17 	ldw	r2,-8(fp)
8111d65c:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111d660:	e0bffe17 	ldw	r2,-8(fp)
8111d664:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111d668:	e0bffe17 	ldw	r2,-8(fp)
8111d66c:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111d670:	e0bffe17 	ldw	r2,-8(fp)
8111d674:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111d678:	e0bffe17 	ldw	r2,-8(fp)
8111d67c:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111d680:	e0bffe17 	ldw	r2,-8(fp)
8111d684:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111d688:	e0bffe17 	ldw	r2,-8(fp)
8111d68c:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111d690:	e0bffe17 	ldw	r2,-8(fp)
8111d694:	10002d15 	stw	zero,180(r2)

    switch (ucIdNFEE) {
8111d698:	e0bfff03 	ldbu	r2,-4(fp)
8111d69c:	1000071e 	bne	r2,zero,8111d6bc <vNFeeStructureInit+0xd4>
		case 0:
			pxNfeeL->ucSPWId = (unsigned char)xDefaults.usiLinkNFEE0;
8111d6a0:	00a045b4 	movhi	r2,33046
8111d6a4:	109ade04 	addi	r2,r2,27512
8111d6a8:	1080100b 	ldhu	r2,64(r2)
8111d6ac:	1007883a 	mov	r3,r2
8111d6b0:	e0bffe17 	ldw	r2,-8(fp)
8111d6b4:	10c00045 	stb	r3,1(r2)
			break;
8111d6b8:	00000a06 	br	8111d6e4 <vNFeeStructureInit+0xfc>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "\n CRITICAL! Can't bind the SPQ channel with the NFEE %i \n", pxNfeeL->ucId);
8111d6bc:	d0e06217 	ldw	r3,-32376(gp)
8111d6c0:	e0bffe17 	ldw	r2,-8(fp)
8111d6c4:	10800003 	ldbu	r2,0(r2)
8111d6c8:	10803fcc 	andi	r2,r2,255
8111d6cc:	100d883a 	mov	r6,r2
8111d6d0:	01604574 	movhi	r5,33045
8111d6d4:	2940b504 	addi	r5,r5,724
8111d6d8:	1809883a 	mov	r4,r3
8111d6dc:	11213440 	call	81121344 <fprintf>
			#endif
			break;
8111d6e0:	0001883a 	nop

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111d6e4:	e03ffd05 	stb	zero,-12(fp)
8111d6e8:	00000906 	br	8111d710 <vNFeeStructureInit+0x128>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111d6ec:	e0bffd03 	ldbu	r2,-12(fp)
8111d6f0:	e0fffe17 	ldw	r3,-8(fp)
8111d6f4:	1885883a 	add	r2,r3,r2
8111d6f8:	10802a44 	addi	r2,r2,169
8111d6fc:	e0fffd03 	ldbu	r3,-12(fp)
8111d700:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111d704:	e0bffd03 	ldbu	r2,-12(fp)
8111d708:	10800044 	addi	r2,r2,1
8111d70c:	e0bffd05 	stb	r2,-12(fp)
8111d710:	e0bffd03 	ldbu	r2,-12(fp)
8111d714:	10800130 	cmpltui	r2,r2,4
8111d718:	103ff41e 	bne	r2,zero,8111d6ec <__reset+0xfb0fd6ec>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, pxNfeeL->ucSPWId ) == FALSE ) {
8111d71c:	e0bffe17 	ldw	r2,-8(fp)
8111d720:	10c03204 	addi	r3,r2,200
8111d724:	e0bffe17 	ldw	r2,-8(fp)
8111d728:	10800043 	ldbu	r2,1(r2)
8111d72c:	10803fcc 	andi	r2,r2,255
8111d730:	100b883a 	mov	r5,r2
8111d734:	1809883a 	mov	r4,r3
8111d738:	11046bc0 	call	811046bc <bCommInitCh>
8111d73c:	1000091e 	bne	r2,zero,8111d764 <vNFeeStructureInit+0x17c>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111d740:	d0e06217 	ldw	r3,-32376(gp)
8111d744:	e0bffe17 	ldw	r2,-8(fp)
8111d748:	10800003 	ldbu	r2,0(r2)
8111d74c:	10803fcc 	andi	r2,r2,255
8111d750:	100d883a 	mov	r6,r2
8111d754:	01604574 	movhi	r5,33045
8111d758:	2940c404 	addi	r5,r5,784
8111d75c:	1809883a 	mov	r4,r3
8111d760:	11213440 	call	81121344 <fprintf>
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, pxNfeeL->ucSPWId ) == FALSE ) {
8111d764:	e0bffe17 	ldw	r2,-8(fp)
8111d768:	10800043 	ldbu	r2,1(r2)
8111d76c:	10803fcc 	andi	r2,r2,255
8111d770:	100b883a 	mov	r5,r2
8111d774:	01000044 	movi	r4,1
8111d778:	11045500 	call	81104550 <bCommSetGlobalIrqEn>
8111d77c:	1000091e 	bne	r2,zero,8111d7a4 <vNFeeStructureInit+0x1bc>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111d780:	d0e06217 	ldw	r3,-32376(gp)
8111d784:	e0bffe17 	ldw	r2,-8(fp)
8111d788:	10800003 	ldbu	r2,0(r2)
8111d78c:	10803fcc 	andi	r2,r2,255
8111d790:	100d883a 	mov	r6,r2
8111d794:	01604574 	movhi	r5,33045
8111d798:	2940d004 	addi	r5,r5,832
8111d79c:	1809883a 	mov	r4,r3
8111d7a0:	11213440 	call	81121344 <fprintf>
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111d7a4:	e0bffe17 	ldw	r2,-8(fp)
8111d7a8:	10803304 	addi	r2,r2,204
8111d7ac:	1009883a 	mov	r4,r2
8111d7b0:	1104d940 	call	81104d94 <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8111d7b4:	00a045b4 	movhi	r2,33046
8111d7b8:	109ade04 	addi	r2,r2,27512
8111d7bc:	10800b17 	ldw	r2,44(r2)
8111d7c0:	1009883a 	mov	r4,r2
8111d7c4:	11050700 	call	81105070 <usiAdcPxDelayCalcPeriodNs>
8111d7c8:	1007883a 	mov	r3,r2
8111d7cc:	e0bffe17 	ldw	r2,-8(fp)
8111d7d0:	10c03a0d 	sth	r3,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111d7d4:	e0bffe17 	ldw	r2,-8(fp)
8111d7d8:	1000398d 	sth	zero,230(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8111d7dc:	00a045b4 	movhi	r2,33046
8111d7e0:	109ade04 	addi	r2,r2,27512
8111d7e4:	10800917 	ldw	r2,36(r2)
8111d7e8:	1009883a 	mov	r4,r2
8111d7ec:	11050fc0 	call	811050fc <usiLineTrDelayCalcPeriodNs>
8111d7f0:	1007883a 	mov	r3,r2
8111d7f4:	e0bffe17 	ldw	r2,-8(fp)
8111d7f8:	10c0390d 	sth	r3,228(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111d7fc:	e0bffe17 	ldw	r2,-8(fp)
8111d800:	10803304 	addi	r2,r2,204
8111d804:	1009883a 	mov	r4,r2
8111d808:	1104c4c0 	call	81104c4c <bDpktSetPixelDelay>


}
8111d80c:	0001883a 	nop
8111d810:	e037883a 	mov	sp,fp
8111d814:	dfc00117 	ldw	ra,4(sp)
8111d818:	df000017 	ldw	fp,0(sp)
8111d81c:	dec00204 	addi	sp,sp,8
8111d820:	f800283a 	ret

8111d824 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111d824:	defff404 	addi	sp,sp,-48
8111d828:	de00012e 	bgeu	sp,et,8111d830 <vUpdateMemMapFEE+0xc>
8111d82c:	003b68fa 	trap	3
8111d830:	df000b15 	stw	fp,44(sp)
8111d834:	df000b04 	addi	fp,sp,44
8111d838:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111d83c:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111d840:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111d844:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111d848:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111d84c:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111d850:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111d854:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111d858:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111d85c:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111d860:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111d864:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111d868:	e17fff17 	ldw	r5,-4(fp)
8111d86c:	01035a34 	movhi	r4,3432
8111d870:	21348c04 	addi	r4,r4,-11728
8111d874:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111d878:	e13fff17 	ldw	r4,-4(fp)
8111d87c:	21000003 	ldbu	r4,0(r4)
8111d880:	21403fcc 	andi	r5,r4,255
8111d884:	01035a34 	movhi	r4,3432
8111d888:	21348c04 	addi	r4,r4,-11728
8111d88c:	2909383a 	mul	r4,r5,r4
8111d890:	200b883a 	mov	r5,r4
8111d894:	e13fff17 	ldw	r4,-4(fp)
8111d898:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111d89c:	e13fff17 	ldw	r4,-4(fp)
8111d8a0:	21400117 	ldw	r5,4(r4)
8111d8a4:	01033234 	movhi	r4,3272
8111d8a8:	21348c04 	addi	r4,r4,-11728
8111d8ac:	290b883a 	add	r5,r5,r4
8111d8b0:	e13fff17 	ldw	r4,-4(fp)
8111d8b4:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111d8b8:	e13fff17 	ldw	r4,-4(fp)
8111d8bc:	2100310b 	ldhu	r4,196(r4)
8111d8c0:	217fffcc 	andi	r5,r4,65535
8111d8c4:	e13fff17 	ldw	r4,-4(fp)
8111d8c8:	2100300b 	ldhu	r4,192(r4)
8111d8cc:	213fffcc 	andi	r4,r4,65535
8111d8d0:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111d8d4:	e13fff17 	ldw	r4,-4(fp)
8111d8d8:	2100308b 	ldhu	r4,194(r4)
8111d8dc:	21bfffcc 	andi	r6,r4,65535
8111d8e0:	e13fff17 	ldw	r4,-4(fp)
8111d8e4:	21002f8b 	ldhu	r4,190(r4)
8111d8e8:	213fffcc 	andi	r4,r4,65535
8111d8ec:	310d883a 	add	r6,r6,r4
8111d8f0:	e13fff17 	ldw	r4,-4(fp)
8111d8f4:	21002f0b 	ldhu	r4,188(r4)
8111d8f8:	213fffcc 	andi	r4,r4,65535
8111d8fc:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111d900:	2909383a 	mul	r4,r5,r4
8111d904:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111d908:	e13ffa17 	ldw	r4,-24(fp)
8111d90c:	2109883a 	add	r4,r4,r4
8111d910:	200b883a 	mov	r5,r4
8111d914:	e13fff17 	ldw	r4,-4(fp)
8111d918:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111d91c:	e13fff17 	ldw	r4,-4(fp)
8111d920:	21000517 	ldw	r4,20(r4)
8111d924:	2008d0fa 	srli	r4,r4,3
8111d928:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111d92c:	e13fff17 	ldw	r4,-4(fp)
8111d930:	21000517 	ldw	r4,20(r4)
8111d934:	210001cc 	andi	r4,r4,7
8111d938:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111d93c:	e13ffb17 	ldw	r4,-20(fp)
8111d940:	20001226 	beq	r4,zero,8111d98c <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111d944:	e13ff517 	ldw	r4,-44(fp)
8111d948:	21000044 	addi	r4,r4,1
8111d94c:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111d950:	e13fff17 	ldw	r4,-4(fp)
8111d954:	21400517 	ldw	r5,20(r4)
8111d958:	e13ffb17 	ldw	r4,-20(fp)
8111d95c:	2909c83a 	sub	r4,r5,r4
8111d960:	21400204 	addi	r5,r4,8
8111d964:	e13fff17 	ldw	r4,-4(fp)
8111d968:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111d96c:	e13ffb17 	ldw	r4,-20(fp)
8111d970:	200b883a 	mov	r5,r4
8111d974:	01000204 	movi	r4,8
8111d978:	2149c83a 	sub	r4,r4,r5
8111d97c:	200b883a 	mov	r5,r4
8111d980:	e13fff17 	ldw	r4,-4(fp)
8111d984:	21400605 	stb	r5,24(r4)
8111d988:	00000206 	br	8111d994 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111d98c:	e13fff17 	ldw	r4,-4(fp)
8111d990:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111d994:	e13ff517 	ldw	r4,-44(fp)
8111d998:	2008d13a 	srli	r4,r4,4
8111d99c:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111d9a0:	e13ff517 	ldw	r4,-44(fp)
8111d9a4:	210003cc 	andi	r4,r4,15
8111d9a8:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111d9ac:	e13ffc17 	ldw	r4,-16(fp)
8111d9b0:	20000b26 	beq	r4,zero,8111d9e0 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111d9b4:	e13ff717 	ldw	r4,-36(fp)
8111d9b8:	21000044 	addi	r4,r4,1
8111d9bc:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111d9c0:	e17ff517 	ldw	r5,-44(fp)
8111d9c4:	e13ffc17 	ldw	r4,-16(fp)
8111d9c8:	290bc83a 	sub	r5,r5,r4
8111d9cc:	e13ff717 	ldw	r4,-36(fp)
8111d9d0:	2909883a 	add	r4,r5,r4
8111d9d4:	21000404 	addi	r4,r4,16
8111d9d8:	e13ff615 	stw	r4,-40(fp)
8111d9dc:	00000406 	br	8111d9f0 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111d9e0:	e17ff517 	ldw	r5,-44(fp)
8111d9e4:	e13ff717 	ldw	r4,-36(fp)
8111d9e8:	2909883a 	add	r4,r5,r4
8111d9ec:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111d9f0:	e13ff617 	ldw	r4,-40(fp)
8111d9f4:	200a90fa 	slli	r5,r4,3
8111d9f8:	e13fff17 	ldw	r4,-4(fp)
8111d9fc:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111da00:	e13ffb17 	ldw	r4,-20(fp)
8111da04:	20000926 	beq	r4,zero,8111da2c <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111da08:	e13ffc17 	ldw	r4,-16(fp)
8111da0c:	2109883a 	add	r4,r4,r4
8111da10:	2109883a 	add	r4,r4,r4
8111da14:	200b883a 	mov	r5,r4
8111da18:	e13ffb17 	ldw	r4,-20(fp)
8111da1c:	2008d07a 	srli	r4,r4,1
8111da20:	2909883a 	add	r4,r5,r4
8111da24:	e13ff805 	stb	r4,-32(fp)
8111da28:	00000406 	br	8111da3c <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111da2c:	e13ffc17 	ldw	r4,-16(fp)
8111da30:	2109883a 	add	r4,r4,r4
8111da34:	2109883a 	add	r4,r4,r4
8111da38:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111da3c:	e13ff803 	ldbu	r4,-32(fp)
8111da40:	01401004 	movi	r5,64
8111da44:	2909c83a 	sub	r4,r5,r4
8111da48:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);
8111da4c:	e13ffd03 	ldbu	r4,-12(fp)
8111da50:	217ff804 	addi	r5,r4,-32
8111da54:	28000416 	blt	r5,zero,8111da68 <vUpdateMemMapFEE+0x244>
8111da58:	013fffc4 	movi	r4,-1
8111da5c:	2146983a 	sll	r3,r4,r5
8111da60:	0005883a 	mov	r2,zero
8111da64:	00000a06 	br	8111da90 <vUpdateMemMapFEE+0x26c>
8111da68:	017fffc4 	movi	r5,-1
8111da6c:	280cd07a 	srli	r6,r5,1
8111da70:	014007c4 	movi	r5,31
8111da74:	290bc83a 	sub	r5,r5,r4
8111da78:	314ad83a 	srl	r5,r6,r5
8111da7c:	01bfffc4 	movi	r6,-1
8111da80:	3106983a 	sll	r3,r6,r4
8111da84:	28c6b03a 	or	r3,r5,r3
8111da88:	017fffc4 	movi	r5,-1
8111da8c:	2904983a 	sll	r2,r5,r4
8111da90:	e13fff17 	ldw	r4,-4(fp)
8111da94:	20800715 	stw	r2,28(r4)
8111da98:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF);


    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111da9c:	e0bfff17 	ldw	r2,-4(fp)
8111daa0:	e0fff717 	ldw	r3,-36(fp)
8111daa4:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111daa8:	e0bfff17 	ldw	r2,-4(fp)
8111daac:	10c00117 	ldw	r3,4(r2)
8111dab0:	008004b4 	movhi	r2,18
8111dab4:	10a40004 	addi	r2,r2,-28672
8111dab8:	1885883a 	add	r2,r3,r2
8111dabc:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111dac0:	e0bfff17 	ldw	r2,-4(fp)
8111dac4:	10c00517 	ldw	r3,20(r2)
8111dac8:	008000b4 	movhi	r2,2
8111dacc:	10a40004 	addi	r2,r2,-28672
8111dad0:	1885883a 	add	r2,r3,r2
8111dad4:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111dad8:	e03ff845 	stb	zero,-31(fp)
8111dadc:	00001906 	br	8111db44 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111dae0:	e0bff843 	ldbu	r2,-31(fp)
8111dae4:	e0ffff17 	ldw	r3,-4(fp)
8111dae8:	10800624 	muli	r2,r2,24
8111daec:	1885883a 	add	r2,r3,r2
8111daf0:	10800904 	addi	r2,r2,36
8111daf4:	e0fff917 	ldw	r3,-28(fp)
8111daf8:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111dafc:	e0fff917 	ldw	r3,-28(fp)
8111db00:	e0bffe17 	ldw	r2,-8(fp)
8111db04:	1885883a 	add	r2,r3,r2
8111db08:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111db0c:	e0bff843 	ldbu	r2,-31(fp)
8111db10:	e0ffff17 	ldw	r3,-4(fp)
8111db14:	10800624 	muli	r2,r2,24
8111db18:	1885883a 	add	r2,r3,r2
8111db1c:	10800c04 	addi	r2,r2,48
8111db20:	e0fff917 	ldw	r3,-28(fp)
8111db24:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111db28:	e0fff917 	ldw	r3,-28(fp)
8111db2c:	e0bffe17 	ldw	r2,-8(fp)
8111db30:	1885883a 	add	r2,r3,r2
8111db34:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111db38:	e0bff843 	ldbu	r2,-31(fp)
8111db3c:	10800044 	addi	r2,r2,1
8111db40:	e0bff845 	stb	r2,-31(fp)
8111db44:	e0bff843 	ldbu	r2,-31(fp)
8111db48:	10800130 	cmpltui	r2,r2,4
8111db4c:	103fe41e 	bne	r2,zero,8111dae0 <__reset+0xfb0fdae0>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
8111db50:	0001883a 	nop
8111db54:	e037883a 	mov	sp,fp
8111db58:	df000017 	ldw	fp,0(sp)
8111db5c:	dec00104 	addi	sp,sp,4
8111db60:	f800283a 	ret

8111db64 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111db64:	defffd04 	addi	sp,sp,-12
8111db68:	de00012e 	bgeu	sp,et,8111db70 <vResetMemCCDFEE+0xc>
8111db6c:	003b68fa 	trap	3
8111db70:	df000215 	stw	fp,8(sp)
8111db74:	df000204 	addi	fp,sp,8
8111db78:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111db7c:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111db80:	e03ffe05 	stb	zero,-8(fp)
8111db84:	00001b06 	br	8111dbf4 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111db88:	e0bffe03 	ldbu	r2,-8(fp)
8111db8c:	e0ffff17 	ldw	r3,-4(fp)
8111db90:	10800624 	muli	r2,r2,24
8111db94:	1885883a 	add	r2,r3,r2
8111db98:	10800b04 	addi	r2,r2,44
8111db9c:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111dba0:	e0bffe03 	ldbu	r2,-8(fp)
8111dba4:	e0ffff17 	ldw	r3,-4(fp)
8111dba8:	10800624 	muli	r2,r2,24
8111dbac:	1885883a 	add	r2,r3,r2
8111dbb0:	10800a04 	addi	r2,r2,40
8111dbb4:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111dbb8:	e0bffe03 	ldbu	r2,-8(fp)
8111dbbc:	e0ffff17 	ldw	r3,-4(fp)
8111dbc0:	10800624 	muli	r2,r2,24
8111dbc4:	1885883a 	add	r2,r3,r2
8111dbc8:	10800e04 	addi	r2,r2,56
8111dbcc:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111dbd0:	e0bffe03 	ldbu	r2,-8(fp)
8111dbd4:	e0ffff17 	ldw	r3,-4(fp)
8111dbd8:	10800624 	muli	r2,r2,24
8111dbdc:	1885883a 	add	r2,r3,r2
8111dbe0:	10800d04 	addi	r2,r2,52
8111dbe4:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111dbe8:	e0bffe03 	ldbu	r2,-8(fp)
8111dbec:	10800044 	addi	r2,r2,1
8111dbf0:	e0bffe05 	stb	r2,-8(fp)
8111dbf4:	e0bffe03 	ldbu	r2,-8(fp)
8111dbf8:	10800130 	cmpltui	r2,r2,4
8111dbfc:	103fe21e 	bne	r2,zero,8111db88 <__reset+0xfb0fdb88>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111dc00:	0001883a 	nop
8111dc04:	e037883a 	mov	sp,fp
8111dc08:	df000017 	ldw	fp,0(sp)
8111dc0c:	dec00104 	addi	sp,sp,4
8111dc10:	f800283a 	ret

8111dc14 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111dc14:	defffe04 	addi	sp,sp,-8
8111dc18:	de00012e 	bgeu	sp,et,8111dc20 <vFeeSpwRMAPLoadDefault+0xc>
8111dc1c:	003b68fa 	trap	3
8111dc20:	df000115 	stw	fp,4(sp)
8111dc24:	df000104 	addi	fp,sp,4
8111dc28:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111dc2c:	0001883a 	nop
8111dc30:	e037883a 	mov	sp,fp
8111dc34:	df000017 	ldw	fp,0(sp)
8111dc38:	dec00104 	addi	sp,sp,4
8111dc3c:	f800283a 	ret

8111dc40 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111dc40:	defffe04 	addi	sp,sp,-8
8111dc44:	de00012e 	bgeu	sp,et,8111dc4c <vFeeSpwRMAPChangeConfig+0xc>
8111dc48:	003b68fa 	trap	3
8111dc4c:	df000115 	stw	fp,4(sp)
8111dc50:	df000104 	addi	fp,sp,4
8111dc54:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111dc58:	0001883a 	nop
8111dc5c:	e037883a 	mov	sp,fp
8111dc60:	df000017 	ldw	fp,0(sp)
8111dc64:	dec00104 	addi	sp,sp,4
8111dc68:	f800283a 	ret

8111dc6c <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111dc6c:	defffe04 	addi	sp,sp,-8
8111dc70:	de00012e 	bgeu	sp,et,8111dc78 <vFeeSpwRMAPChangeDefault+0xc>
8111dc74:	003b68fa 	trap	3
8111dc78:	df000115 	stw	fp,4(sp)
8111dc7c:	df000104 	addi	fp,sp,4
8111dc80:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111dc84:	0001883a 	nop
8111dc88:	e037883a 	mov	sp,fp
8111dc8c:	df000017 	ldw	fp,0(sp)
8111dc90:	dec00104 	addi	sp,sp,4
8111dc94:	f800283a 	ret

8111dc98 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111dc98:	defffe04 	addi	sp,sp,-8
8111dc9c:	de00012e 	bgeu	sp,et,8111dca4 <cFeeSpwChannelEnable+0xc>
8111dca0:	003b68fa 	trap	3
8111dca4:	df000115 	stw	fp,4(sp)
8111dca8:	df000104 	addi	fp,sp,4
8111dcac:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111dcb0:	0001883a 	nop
8111dcb4:	e037883a 	mov	sp,fp
8111dcb8:	df000017 	ldw	fp,0(sp)
8111dcbc:	dec00104 	addi	sp,sp,4
8111dcc0:	f800283a 	ret

8111dcc4 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111dcc4:	defffe04 	addi	sp,sp,-8
8111dcc8:	de00012e 	bgeu	sp,et,8111dcd0 <cFeeSpwChannelDisable+0xc>
8111dccc:	003b68fa 	trap	3
8111dcd0:	df000115 	stw	fp,4(sp)
8111dcd4:	df000104 	addi	fp,sp,4
8111dcd8:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111dcdc:	0001883a 	nop
8111dce0:	e037883a 	mov	sp,fp
8111dce4:	df000017 	ldw	fp,0(sp)
8111dce8:	dec00104 	addi	sp,sp,4
8111dcec:	f800283a 	ret

8111dcf0 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111dcf0:	defffe04 	addi	sp,sp,-8
8111dcf4:	de00012e 	bgeu	sp,et,8111dcfc <cFeeRMAPDump+0xc>
8111dcf8:	003b68fa 	trap	3
8111dcfc:	df000115 	stw	fp,4(sp)
8111dd00:	df000104 	addi	fp,sp,4
8111dd04:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111dd08:	0001883a 	nop
8111dd0c:	e037883a 	mov	sp,fp
8111dd10:	df000017 	ldw	fp,0(sp)
8111dd14:	dec00104 	addi	sp,sp,4
8111dd18:	f800283a 	ret

8111dd1c <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111dd1c:	defffe04 	addi	sp,sp,-8
8111dd20:	de00012e 	bgeu	sp,et,8111dd28 <cFeeRMAPEchoingEnable+0xc>
8111dd24:	003b68fa 	trap	3
8111dd28:	df000115 	stw	fp,4(sp)
8111dd2c:	df000104 	addi	fp,sp,4
8111dd30:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111dd34:	e0bfff17 	ldw	r2,-4(fp)
8111dd38:	00c00044 	movi	r3,1
8111dd3c:	10c02515 	stw	r3,148(r2)
}
8111dd40:	0001883a 	nop
8111dd44:	e037883a 	mov	sp,fp
8111dd48:	df000017 	ldw	fp,0(sp)
8111dd4c:	dec00104 	addi	sp,sp,4
8111dd50:	f800283a 	ret

8111dd54 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111dd54:	defffe04 	addi	sp,sp,-8
8111dd58:	de00012e 	bgeu	sp,et,8111dd60 <cFeeRMAPEchoingDisable+0xc>
8111dd5c:	003b68fa 	trap	3
8111dd60:	df000115 	stw	fp,4(sp)
8111dd64:	df000104 	addi	fp,sp,4
8111dd68:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111dd6c:	e0bfff17 	ldw	r2,-4(fp)
8111dd70:	10002515 	stw	zero,148(r2)
}
8111dd74:	0001883a 	nop
8111dd78:	e037883a 	mov	sp,fp
8111dd7c:	df000017 	ldw	fp,0(sp)
8111dd80:	dec00104 	addi	sp,sp,4
8111dd84:	f800283a 	ret

8111dd88 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111dd88:	defffe04 	addi	sp,sp,-8
8111dd8c:	de00012e 	bgeu	sp,et,8111dd94 <cFeeRMAPLogEnable+0xc>
8111dd90:	003b68fa 	trap	3
8111dd94:	df000115 	stw	fp,4(sp)
8111dd98:	df000104 	addi	fp,sp,4
8111dd9c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111dda0:	e0bfff17 	ldw	r2,-4(fp)
8111dda4:	00c00044 	movi	r3,1
8111dda8:	10c02415 	stw	r3,144(r2)
}
8111ddac:	0001883a 	nop
8111ddb0:	e037883a 	mov	sp,fp
8111ddb4:	df000017 	ldw	fp,0(sp)
8111ddb8:	dec00104 	addi	sp,sp,4
8111ddbc:	f800283a 	ret

8111ddc0 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111ddc0:	defffe04 	addi	sp,sp,-8
8111ddc4:	de00012e 	bgeu	sp,et,8111ddcc <cFeeRMAPLogDisable+0xc>
8111ddc8:	003b68fa 	trap	3
8111ddcc:	df000115 	stw	fp,4(sp)
8111ddd0:	df000104 	addi	fp,sp,4
8111ddd4:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111ddd8:	e0bfff17 	ldw	r2,-4(fp)
8111dddc:	10002415 	stw	zero,144(r2)
}
8111dde0:	0001883a 	nop
8111dde4:	e037883a 	mov	sp,fp
8111dde8:	df000017 	ldw	fp,0(sp)
8111ddec:	dec00104 	addi	sp,sp,4
8111ddf0:	f800283a 	ret

8111ddf4 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111ddf4:	defffc04 	addi	sp,sp,-16
8111ddf8:	de00012e 	bgeu	sp,et,8111de00 <vNFeeControlInit+0xc>
8111ddfc:	003b68fa 	trap	3
8111de00:	dfc00315 	stw	ra,12(sp)
8111de04:	df000215 	stw	fp,8(sp)
8111de08:	df000204 	addi	fp,sp,8
8111de0c:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111de10:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111de14:	e13fff17 	ldw	r4,-4(fp)
8111de18:	111df400 	call	8111df40 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111de1c:	e13fff17 	ldw	r4,-4(fp)
8111de20:	111df740 	call	8111df74 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111de24:	e0bfff17 	ldw	r2,-4(fp)
8111de28:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111de2c:	e03ffe05 	stb	zero,-8(fp)
8111de30:	00002b06 	br	8111dee0 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111de34:	e0bffe03 	ldbu	r2,-8(fp)
8111de38:	10809624 	muli	r2,r2,600
8111de3c:	e0ffff17 	ldw	r3,-4(fp)
8111de40:	1885883a 	add	r2,r3,r2
8111de44:	e0fffe03 	ldbu	r3,-8(fp)
8111de48:	180b883a 	mov	r5,r3
8111de4c:	1009883a 	mov	r4,r2
8111de50:	111d5e80 	call	8111d5e8 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111de54:	e0bffe03 	ldbu	r2,-8(fp)
8111de58:	e0fffe03 	ldbu	r3,-8(fp)
8111de5c:	18c09624 	muli	r3,r3,600
8111de60:	18c02104 	addi	r3,r3,132
8111de64:	e13fff17 	ldw	r4,-4(fp)
8111de68:	20c7883a 	add	r3,r4,r3
8111de6c:	e13fff17 	ldw	r4,-4(fp)
8111de70:	108025c4 	addi	r2,r2,151
8111de74:	1085883a 	add	r2,r2,r2
8111de78:	1085883a 	add	r2,r2,r2
8111de7c:	2085883a 	add	r2,r4,r2
8111de80:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111de84:	e0bffe03 	ldbu	r2,-8(fp)
8111de88:	e0fffe03 	ldbu	r3,-8(fp)
8111de8c:	18c09624 	muli	r3,r3,600
8111de90:	18c02704 	addi	r3,r3,156
8111de94:	e13fff17 	ldw	r4,-4(fp)
8111de98:	20c7883a 	add	r3,r4,r3
8111de9c:	e13fff17 	ldw	r4,-4(fp)
8111dea0:	10802604 	addi	r2,r2,152
8111dea4:	1085883a 	add	r2,r2,r2
8111dea8:	1085883a 	add	r2,r2,r2
8111deac:	2085883a 	add	r2,r4,r2
8111deb0:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111deb4:	e0bffe03 	ldbu	r2,-8(fp)
8111deb8:	e0ffff17 	ldw	r3,-4(fp)
8111debc:	18c09617 	ldw	r3,600(r3)
8111dec0:	e13fff17 	ldw	r4,-4(fp)
8111dec4:	10809624 	muli	r2,r2,600
8111dec8:	2085883a 	add	r2,r4,r2
8111decc:	10802904 	addi	r2,r2,164
8111ded0:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111ded4:	e0bffe03 	ldbu	r2,-8(fp)
8111ded8:	10800044 	addi	r2,r2,1
8111dedc:	e0bffe05 	stb	r2,-8(fp)
8111dee0:	e0bffe03 	ldbu	r2,-8(fp)
8111dee4:	103fd326 	beq	r2,zero,8111de34 <__reset+0xfb0fde34>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111dee8:	0001883a 	nop
8111deec:	e037883a 	mov	sp,fp
8111def0:	dfc00117 	ldw	ra,4(sp)
8111def4:	df000017 	ldw	fp,0(sp)
8111def8:	dec00204 	addi	sp,sp,8
8111defc:	f800283a 	ret

8111df00 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111df00:	defffd04 	addi	sp,sp,-12
8111df04:	de00012e 	bgeu	sp,et,8111df0c <vSetTimeCode+0xc>
8111df08:	003b68fa 	trap	3
8111df0c:	df000215 	stw	fp,8(sp)
8111df10:	df000204 	addi	fp,sp,8
8111df14:	e13ffe15 	stw	r4,-8(fp)
8111df18:	2805883a 	mov	r2,r5
8111df1c:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111df20:	e0bffe17 	ldw	r2,-8(fp)
8111df24:	e0ffff03 	ldbu	r3,-4(fp)
8111df28:	10c09905 	stb	r3,612(r2)
}
8111df2c:	0001883a 	nop
8111df30:	e037883a 	mov	sp,fp
8111df34:	df000017 	ldw	fp,0(sp)
8111df38:	dec00104 	addi	sp,sp,4
8111df3c:	f800283a 	ret

8111df40 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111df40:	defffe04 	addi	sp,sp,-8
8111df44:	de00012e 	bgeu	sp,et,8111df4c <vResetTimeCode+0xc>
8111df48:	003b68fa 	trap	3
8111df4c:	df000115 	stw	fp,4(sp)
8111df50:	df000104 	addi	fp,sp,4
8111df54:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111df58:	e0bfff17 	ldw	r2,-4(fp)
8111df5c:	10009905 	stb	zero,612(r2)
}
8111df60:	0001883a 	nop
8111df64:	e037883a 	mov	sp,fp
8111df68:	df000017 	ldw	fp,0(sp)
8111df6c:	dec00104 	addi	sp,sp,4
8111df70:	f800283a 	ret

8111df74 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111df74:	defffe04 	addi	sp,sp,-8
8111df78:	de00012e 	bgeu	sp,et,8111df80 <vLoadDefaultIdNFEEMaster+0xc>
8111df7c:	003b68fa 	trap	3
8111df80:	df000115 	stw	fp,4(sp)
8111df84:	df000104 	addi	fp,sp,4
8111df88:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111df8c:	e0bfff17 	ldw	r2,-4(fp)
8111df90:	10009945 	stb	zero,613(r2)
}
8111df94:	0001883a 	nop
8111df98:	e037883a 	mov	sp,fp
8111df9c:	df000017 	ldw	fp,0(sp)
8111dfa0:	dec00104 	addi	sp,sp,4
8111dfa4:	f800283a 	ret

8111dfa8 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111dfa8:	defffd04 	addi	sp,sp,-12
8111dfac:	de00012e 	bgeu	sp,et,8111dfb4 <vChangeIdNFEEMaster+0xc>
8111dfb0:	003b68fa 	trap	3
8111dfb4:	df000215 	stw	fp,8(sp)
8111dfb8:	df000204 	addi	fp,sp,8
8111dfbc:	e13ffe15 	stw	r4,-8(fp)
8111dfc0:	2805883a 	mov	r2,r5
8111dfc4:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111dfc8:	e0bffe17 	ldw	r2,-8(fp)
8111dfcc:	e0ffff03 	ldbu	r3,-4(fp)
8111dfd0:	10c09945 	stb	r3,613(r2)
}
8111dfd4:	0001883a 	nop
8111dfd8:	e037883a 	mov	sp,fp
8111dfdc:	df000017 	ldw	fp,0(sp)
8111dfe0:	dec00104 	addi	sp,sp,4
8111dfe4:	f800283a 	ret

8111dfe8 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111dfe8:	defffd04 	addi	sp,sp,-12
8111dfec:	de00012e 	bgeu	sp,et,8111dff4 <vChangeDefaultIdNFEEMaster+0xc>
8111dff0:	003b68fa 	trap	3
8111dff4:	df000215 	stw	fp,8(sp)
8111dff8:	df000204 	addi	fp,sp,8
8111dffc:	e13ffe15 	stw	r4,-8(fp)
8111e000:	2805883a 	mov	r2,r5
8111e004:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111e008:	0001883a 	nop
8111e00c:	e037883a 	mov	sp,fp
8111e010:	df000017 	ldw	fp,0(sp)
8111e014:	dec00104 	addi	sp,sp,4
8111e018:	f800283a 	ret

8111e01c <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111e01c:	defffe04 	addi	sp,sp,-8
8111e020:	de00012e 	bgeu	sp,et,8111e028 <vInitSimucamBasicHW+0xc>
8111e024:	003b68fa 	trap	3
8111e028:	dfc00115 	stw	ra,4(sp)
8111e02c:	df000015 	stw	fp,0(sp)
8111e030:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111e034:	01403fc4 	movi	r5,255
8111e038:	0009883a 	mov	r4,zero
8111e03c:	110b28c0 	call	8110b28c <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111e040:	01400834 	movhi	r5,32
8111e044:	297fffc4 	addi	r5,r5,-1
8111e048:	0009883a 	mov	r4,zero
8111e04c:	110b30c0 	call	8110b30c <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111e050:	01400074 	movhi	r5,1
8111e054:	01000044 	movi	r4,1
8111e058:	110b30c0 	call	8110b30c <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111e05c:	0009883a 	mov	r4,zero
8111e060:	110c7940 	call	8110c794 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111e064:	0009883a 	mov	r4,zero
8111e068:	110c8640 	call	8110c864 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111e06c:	01008004 	movi	r4,512
8111e070:	110c2f40 	call	8110c2f4 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111e074:	01008004 	movi	r4,512
8111e078:	110c2800 	call	8110c280 <vRstcReleaseDeviceReset>

}
8111e07c:	0001883a 	nop
8111e080:	e037883a 	mov	sp,fp
8111e084:	dfc00117 	ldw	ra,4(sp)
8111e088:	df000017 	ldw	fp,0(sp)
8111e08c:	dec00204 	addi	sp,sp,8
8111e090:	f800283a 	ret

8111e094 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111e094:	defffd04 	addi	sp,sp,-12
8111e098:	de00012e 	bgeu	sp,et,8111e0a0 <bLogWriteSDCard+0xc>
8111e09c:	003b68fa 	trap	3
8111e0a0:	df000215 	stw	fp,8(sp)
8111e0a4:	df000204 	addi	fp,sp,8
8111e0a8:	e13ffe15 	stw	r4,-8(fp)
8111e0ac:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111e0b0:	00800044 	movi	r2,1
}
8111e0b4:	e037883a 	mov	sp,fp
8111e0b8:	df000017 	ldw	fp,0(sp)
8111e0bc:	dec00104 	addi	sp,sp,4
8111e0c0:	f800283a 	ret

8111e0c4 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111e0c4:	deffe004 	addi	sp,sp,-128
8111e0c8:	de00012e 	bgeu	sp,et,8111e0d0 <vLogWriteNUC+0xc>
8111e0cc:	003b68fa 	trap	3
8111e0d0:	dfc01f15 	stw	ra,124(sp)
8111e0d4:	df001e15 	stw	fp,120(sp)
8111e0d8:	df001e04 	addi	fp,sp,120
8111e0dc:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111e0e0:	e03fe215 	stw	zero,-120(fp)
8111e0e4:	e0bfe304 	addi	r2,fp,-116
8111e0e8:	00c01b84 	movi	r3,110
8111e0ec:	180d883a 	mov	r6,r3
8111e0f0:	000b883a 	mov	r5,zero
8111e0f4:	1009883a 	mov	r4,r2
8111e0f8:	11225440 	call	81122544 <memset>
	memset(cTemp,0,114);
8111e0fc:	01801c84 	movi	r6,114
8111e100:	000b883a 	mov	r5,zero
8111e104:	e13fe204 	addi	r4,fp,-120
8111e108:	11225440 	call	81122544 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111e10c:	e13fff17 	ldw	r4,-4(fp)
8111e110:	1122ee80 	call	81122ee8 <strlen>
8111e114:	10801c68 	cmpgeui	r2,r2,113
8111e118:	1000031e 	bne	r2,zero,8111e128 <vLogWriteNUC+0x64>
8111e11c:	e13fff17 	ldw	r4,-4(fp)
8111e120:	1122ee80 	call	81122ee8 <strlen>
8111e124:	00000106 	br	8111e12c <vLogWriteNUC+0x68>
8111e128:	00801c44 	movi	r2,113
8111e12c:	100d883a 	mov	r6,r2
8111e130:	e17fff17 	ldw	r5,-4(fp)
8111e134:	e13fe204 	addi	r4,fp,-120
8111e138:	11223f40 	call	811223f4 <memcpy>
	vSendLog ( cDataIn );
8111e13c:	e13fff17 	ldw	r4,-4(fp)
8111e140:	11191400 	call	81119140 <vSendLog>
}
8111e144:	0001883a 	nop
8111e148:	e037883a 	mov	sp,fp
8111e14c:	dfc00117 	ldw	ra,4(sp)
8111e150:	df000017 	ldw	fp,0(sp)
8111e154:	dec00204 	addi	sp,sp,8
8111e158:	f800283a 	ret

8111e15c <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111e15c:	defffd04 	addi	sp,sp,-12
8111e160:	de00012e 	bgeu	sp,et,8111e168 <vSimucamStructureInit+0xc>
8111e164:	003b68fa 	trap	3
8111e168:	dfc00215 	stw	ra,8(sp)
8111e16c:	df000115 	stw	fp,4(sp)
8111e170:	df000104 	addi	fp,sp,4
8111e174:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111e178:	e0bfff17 	ldw	r2,-4(fp)
8111e17c:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111e180:	e0bfff17 	ldw	r2,-4(fp)
8111e184:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111e188:	e13fff17 	ldw	r4,-4(fp)
8111e18c:	111e2480 	call	8111e248 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111e190:	e13fff17 	ldw	r4,-4(fp)
8111e194:	111e2ec0 	call	8111e2ec <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111e198:	e13fff17 	ldw	r4,-4(fp)
8111e19c:	111e3940 	call	8111e394 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111e1a0:	e13fff17 	ldw	r4,-4(fp)
8111e1a4:	111e4340 	call	8111e434 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111e1a8:	e0bfff17 	ldw	r2,-4(fp)
8111e1ac:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111e1b0:	e0bfff17 	ldw	r2,-4(fp)
8111e1b4:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111e1b8:	e0bfff17 	ldw	r2,-4(fp)
8111e1bc:	00c07d04 	movi	r3,500
8111e1c0:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111e1c4:	e0bfff17 	ldw	r2,-4(fp)
8111e1c8:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111e1cc:	e0bfff17 	ldw	r2,-4(fp)
8111e1d0:	00c00044 	movi	r3,1
8111e1d4:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111e1d8:	e0bfff17 	ldw	r2,-4(fp)
8111e1dc:	10c00204 	addi	r3,r2,8
8111e1e0:	e0bfff17 	ldw	r2,-4(fp)
8111e1e4:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111e1e8:	e0bfff17 	ldw	r2,-4(fp)
8111e1ec:	10c00244 	addi	r3,r2,9
8111e1f0:	e0bfff17 	ldw	r2,-4(fp)
8111e1f4:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111e1f8:	e0bfff17 	ldw	r2,-4(fp)
8111e1fc:	10800017 	ldw	r2,0(r2)
8111e200:	10000b1e 	bne	r2,zero,8111e230 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111e204:	e0bfff17 	ldw	r2,-4(fp)
8111e208:	10801204 	addi	r2,r2,72
8111e20c:	1009883a 	mov	r4,r2
8111e210:	111ddf40 	call	8111ddf4 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111e214:	e0bfff17 	ldw	r2,-4(fp)
8111e218:	10c00a04 	addi	r3,r2,40
8111e21c:	e0bfff17 	ldw	r2,-4(fp)
8111e220:	10801204 	addi	r2,r2,72
8111e224:	100b883a 	mov	r5,r2
8111e228:	1809883a 	mov	r4,r3
8111e22c:	111b4e00 	call	8111b4e0 <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
8111e230:	0001883a 	nop
8111e234:	e037883a 	mov	sp,fp
8111e238:	dfc00117 	ldw	ra,4(sp)
8111e23c:	df000017 	ldw	fp,0(sp)
8111e240:	dec00204 	addi	sp,sp,8
8111e244:	f800283a 	ret

8111e248 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111e248:	defffe04 	addi	sp,sp,-8
8111e24c:	de00012e 	bgeu	sp,et,8111e254 <vLoadDefaultEPValue+0xc>
8111e250:	003b68fa 	trap	3
8111e254:	df000115 	stw	fp,4(sp)
8111e258:	df000104 	addi	fp,sp,4
8111e25c:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111e260:	e0bfff17 	ldw	r2,-4(fp)
8111e264:	00d07234 	movhi	r3,16840
8111e268:	10c00315 	stw	r3,12(r2)
}
8111e26c:	0001883a 	nop
8111e270:	e037883a 	mov	sp,fp
8111e274:	df000017 	ldw	fp,0(sp)
8111e278:	dec00104 	addi	sp,sp,4
8111e27c:	f800283a 	ret

8111e280 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e280:	defffd04 	addi	sp,sp,-12
8111e284:	de00012e 	bgeu	sp,et,8111e28c <vChangeEPValue+0xc>
8111e288:	003b68fa 	trap	3
8111e28c:	df000215 	stw	fp,8(sp)
8111e290:	df000204 	addi	fp,sp,8
8111e294:	e13ffe15 	stw	r4,-8(fp)
8111e298:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111e29c:	e0bffe17 	ldw	r2,-8(fp)
8111e2a0:	e0ffff17 	ldw	r3,-4(fp)
8111e2a4:	10c00315 	stw	r3,12(r2)
}
8111e2a8:	0001883a 	nop
8111e2ac:	e037883a 	mov	sp,fp
8111e2b0:	df000017 	ldw	fp,0(sp)
8111e2b4:	dec00104 	addi	sp,sp,4
8111e2b8:	f800283a 	ret

8111e2bc <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e2bc:	defffd04 	addi	sp,sp,-12
8111e2c0:	de00012e 	bgeu	sp,et,8111e2c8 <vChangeDefaultEPValue+0xc>
8111e2c4:	003b68fa 	trap	3
8111e2c8:	df000215 	stw	fp,8(sp)
8111e2cc:	df000204 	addi	fp,sp,8
8111e2d0:	e13ffe15 	stw	r4,-8(fp)
8111e2d4:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111e2d8:	0001883a 	nop
8111e2dc:	e037883a 	mov	sp,fp
8111e2e0:	df000017 	ldw	fp,0(sp)
8111e2e4:	dec00104 	addi	sp,sp,4
8111e2e8:	f800283a 	ret

8111e2ec <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111e2ec:	defffe04 	addi	sp,sp,-8
8111e2f0:	de00012e 	bgeu	sp,et,8111e2f8 <vLoadDefaultRTValue+0xc>
8111e2f4:	003b68fa 	trap	3
8111e2f8:	df000115 	stw	fp,4(sp)
8111e2fc:	df000104 	addi	fp,sp,4
8111e300:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111e304:	e0ffff17 	ldw	r3,-4(fp)
8111e308:	00901eb4 	movhi	r2,16506
8111e30c:	10a66684 	addi	r2,r2,-26214
8111e310:	18800415 	stw	r2,16(r3)
}
8111e314:	0001883a 	nop
8111e318:	e037883a 	mov	sp,fp
8111e31c:	df000017 	ldw	fp,0(sp)
8111e320:	dec00104 	addi	sp,sp,4
8111e324:	f800283a 	ret

8111e328 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e328:	defffd04 	addi	sp,sp,-12
8111e32c:	de00012e 	bgeu	sp,et,8111e334 <vChangeRTValue+0xc>
8111e330:	003b68fa 	trap	3
8111e334:	df000215 	stw	fp,8(sp)
8111e338:	df000204 	addi	fp,sp,8
8111e33c:	e13ffe15 	stw	r4,-8(fp)
8111e340:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111e344:	e0bffe17 	ldw	r2,-8(fp)
8111e348:	e0ffff17 	ldw	r3,-4(fp)
8111e34c:	10c00415 	stw	r3,16(r2)
}
8111e350:	0001883a 	nop
8111e354:	e037883a 	mov	sp,fp
8111e358:	df000017 	ldw	fp,0(sp)
8111e35c:	dec00104 	addi	sp,sp,4
8111e360:	f800283a 	ret

8111e364 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111e364:	defffd04 	addi	sp,sp,-12
8111e368:	de00012e 	bgeu	sp,et,8111e370 <vChangeDefaultRTValue+0xc>
8111e36c:	003b68fa 	trap	3
8111e370:	df000215 	stw	fp,8(sp)
8111e374:	df000204 	addi	fp,sp,8
8111e378:	e13ffe15 	stw	r4,-8(fp)
8111e37c:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111e380:	0001883a 	nop
8111e384:	e037883a 	mov	sp,fp
8111e388:	df000017 	ldw	fp,0(sp)
8111e38c:	dec00104 	addi	sp,sp,4
8111e390:	f800283a 	ret

8111e394 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111e394:	defffe04 	addi	sp,sp,-8
8111e398:	de00012e 	bgeu	sp,et,8111e3a0 <vLoadDefaultSyncSource+0xc>
8111e39c:	003b68fa 	trap	3
8111e3a0:	df000115 	stw	fp,4(sp)
8111e3a4:	df000104 	addi	fp,sp,4
8111e3a8:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111e3ac:	e0bfff17 	ldw	r2,-4(fp)
8111e3b0:	10000815 	stw	zero,32(r2)
}
8111e3b4:	0001883a 	nop
8111e3b8:	e037883a 	mov	sp,fp
8111e3bc:	df000017 	ldw	fp,0(sp)
8111e3c0:	dec00104 	addi	sp,sp,4
8111e3c4:	f800283a 	ret

8111e3c8 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111e3c8:	defffd04 	addi	sp,sp,-12
8111e3cc:	de00012e 	bgeu	sp,et,8111e3d4 <vChangeSyncSource+0xc>
8111e3d0:	003b68fa 	trap	3
8111e3d4:	df000215 	stw	fp,8(sp)
8111e3d8:	df000204 	addi	fp,sp,8
8111e3dc:	e13ffe15 	stw	r4,-8(fp)
8111e3e0:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111e3e4:	e0bffe17 	ldw	r2,-8(fp)
8111e3e8:	e0ffff17 	ldw	r3,-4(fp)
8111e3ec:	10c00815 	stw	r3,32(r2)
}
8111e3f0:	0001883a 	nop
8111e3f4:	e037883a 	mov	sp,fp
8111e3f8:	df000017 	ldw	fp,0(sp)
8111e3fc:	dec00104 	addi	sp,sp,4
8111e400:	f800283a 	ret

8111e404 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111e404:	defffd04 	addi	sp,sp,-12
8111e408:	de00012e 	bgeu	sp,et,8111e410 <vChangeDefaultSyncSource+0xc>
8111e40c:	003b68fa 	trap	3
8111e410:	df000215 	stw	fp,8(sp)
8111e414:	df000204 	addi	fp,sp,8
8111e418:	e13ffe15 	stw	r4,-8(fp)
8111e41c:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111e420:	0001883a 	nop
8111e424:	e037883a 	mov	sp,fp
8111e428:	df000017 	ldw	fp,0(sp)
8111e42c:	dec00104 	addi	sp,sp,4
8111e430:	f800283a 	ret

8111e434 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111e434:	defffe04 	addi	sp,sp,-8
8111e438:	de00012e 	bgeu	sp,et,8111e440 <vLoadDefaultAutoResetSync+0xc>
8111e43c:	003b68fa 	trap	3
8111e440:	df000115 	stw	fp,4(sp)
8111e444:	df000104 	addi	fp,sp,4
8111e448:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111e44c:	e0bfff17 	ldw	r2,-4(fp)
8111e450:	00c00044 	movi	r3,1
8111e454:	10c00915 	stw	r3,36(r2)
}
8111e458:	0001883a 	nop
8111e45c:	e037883a 	mov	sp,fp
8111e460:	df000017 	ldw	fp,0(sp)
8111e464:	dec00104 	addi	sp,sp,4
8111e468:	f800283a 	ret

8111e46c <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111e46c:	defffd04 	addi	sp,sp,-12
8111e470:	de00012e 	bgeu	sp,et,8111e478 <vChangeAutoResetSync+0xc>
8111e474:	003b68fa 	trap	3
8111e478:	df000215 	stw	fp,8(sp)
8111e47c:	df000204 	addi	fp,sp,8
8111e480:	e13ffe15 	stw	r4,-8(fp)
8111e484:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111e488:	e0bffe17 	ldw	r2,-8(fp)
8111e48c:	e0ffff17 	ldw	r3,-4(fp)
8111e490:	10c00915 	stw	r3,36(r2)
}
8111e494:	0001883a 	nop
8111e498:	e037883a 	mov	sp,fp
8111e49c:	df000017 	ldw	fp,0(sp)
8111e4a0:	dec00104 	addi	sp,sp,4
8111e4a4:	f800283a 	ret

8111e4a8 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111e4a8:	defffd04 	addi	sp,sp,-12
8111e4ac:	de00012e 	bgeu	sp,et,8111e4b4 <vChangeDefaultAutoResetSync+0xc>
8111e4b0:	003b68fa 	trap	3
8111e4b4:	df000215 	stw	fp,8(sp)
8111e4b8:	df000204 	addi	fp,sp,8
8111e4bc:	e13ffe15 	stw	r4,-8(fp)
8111e4c0:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111e4c4:	0001883a 	nop
8111e4c8:	e037883a 	mov	sp,fp
8111e4cc:	df000017 	ldw	fp,0(sp)
8111e4d0:	dec00104 	addi	sp,sp,4
8111e4d4:	f800283a 	ret

8111e4d8 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111e4d8:	defffc04 	addi	sp,sp,-16
8111e4dc:	de00012e 	bgeu	sp,et,8111e4e4 <vSyncReset+0xc>
8111e4e0:	003b68fa 	trap	3
8111e4e4:	dfc00315 	stw	ra,12(sp)
8111e4e8:	df000215 	stw	fp,8(sp)
8111e4ec:	df000204 	addi	fp,sp,8
8111e4f0:	e13ffe15 	stw	r4,-8(fp)
8111e4f4:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111e4f8:	e0bffe17 	ldw	r2,-8(fp)
8111e4fc:	10801204 	addi	r2,r2,72
8111e500:	1009883a 	mov	r4,r2
8111e504:	111df400 	call	8111df40 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111e508:	0001883a 	nop
8111e50c:	e037883a 	mov	sp,fp
8111e510:	dfc00117 	ldw	ra,4(sp)
8111e514:	df000017 	ldw	fp,0(sp)
8111e518:	dec00204 	addi	sp,sp,8
8111e51c:	f800283a 	ret

8111e520 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111e520:	defff004 	addi	sp,sp,-64
8111e524:	de00012e 	bgeu	sp,et,8111e52c <pattern_createPattern+0xc>
8111e528:	003b68fa 	trap	3
8111e52c:	dfc00f15 	stw	ra,60(sp)
8111e530:	df000e15 	stw	fp,56(sp)
8111e534:	dcc00d15 	stw	r19,52(sp)
8111e538:	dc800c15 	stw	r18,48(sp)
8111e53c:	dc400b15 	stw	r17,44(sp)
8111e540:	dc000a15 	stw	r16,40(sp)
8111e544:	df000e04 	addi	fp,sp,56
8111e548:	e17ff915 	stw	r5,-28(fp)
8111e54c:	3007883a 	mov	r3,r6
8111e550:	3805883a 	mov	r2,r7
8111e554:	e13ff805 	stb	r4,-32(fp)
8111e558:	e0fffa05 	stb	r3,-24(fp)
8111e55c:	e0bffb05 	stb	r2,-20(fp)
	unsigned long long a0;
	unsigned long long a1;

	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111e560:	e0bff803 	ldbu	r2,-32(fp)
8111e564:	1009883a 	mov	r4,r2
8111e568:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111e56c:	e0bff917 	ldw	r2,-28(fp)
8111e570:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111e574:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111e578:	e0bff217 	ldw	r2,-56(fp)
8111e57c:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111e580:	e03ff515 	stw	zero,-44(fp)
8111e584:	00003606 	br	8111e660 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111e588:	e03ff615 	stw	zero,-40(fp)
8111e58c:	00002e06 	br	8111e648 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111e590:	e0bff303 	ldbu	r2,-52(fp)
8111e594:	10801018 	cmpnei	r2,r2,64
8111e598:	10000b1e 	bne	r2,zero,8111e5c8 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111e59c:	e0bff417 	ldw	r2,-48(fp)
8111e5a0:	00ffffc4 	movi	r3,-1
8111e5a4:	10c02015 	stw	r3,128(r2)
8111e5a8:	00ffffc4 	movi	r3,-1
8111e5ac:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111e5b0:	e0bff217 	ldw	r2,-56(fp)
8111e5b4:	10802204 	addi	r2,r2,136
8111e5b8:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111e5bc:	e0bff217 	ldw	r2,-56(fp)
8111e5c0:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111e5c4:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111e5c8:	e0bff303 	ldbu	r2,-52(fp)
8111e5cc:	10c00044 	addi	r3,r2,1
8111e5d0:	e0fff305 	stb	r3,-52(fp)
8111e5d4:	10803fcc 	andi	r2,r2,255
8111e5d8:	e0fffa03 	ldbu	r3,-24(fp)
8111e5dc:	18c000cc 	andi	r3,r3,3
8111e5e0:	180692fa 	slli	r3,r3,11
8111e5e4:	1809883a 	mov	r4,r3
8111e5e8:	00f80004 	movi	r3,-8192
8111e5ec:	20c6b03a 	or	r3,r4,r3
8111e5f0:	1809883a 	mov	r4,r3
8111e5f4:	e0fffb03 	ldbu	r3,-20(fp)
8111e5f8:	18c0004c 	andi	r3,r3,1
8111e5fc:	180692ba 	slli	r3,r3,10
8111e600:	20c6b03a 	or	r3,r4,r3
8111e604:	1809883a 	mov	r4,r3
8111e608:	e0fff517 	ldw	r3,-44(fp)
8111e60c:	18c007cc 	andi	r3,r3,31
8111e610:	1806917a 	slli	r3,r3,5
8111e614:	20c6b03a 	or	r3,r4,r3
8111e618:	1809883a 	mov	r4,r3
8111e61c:	e0fff617 	ldw	r3,-40(fp)
8111e620:	18c007cc 	andi	r3,r3,31
8111e624:	20c6b03a 	or	r3,r4,r3
8111e628:	1809883a 	mov	r4,r3
8111e62c:	e0fff417 	ldw	r3,-48(fp)
8111e630:	1085883a 	add	r2,r2,r2
8111e634:	1885883a 	add	r2,r3,r2
8111e638:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111e63c:	e0bff617 	ldw	r2,-40(fp)
8111e640:	10800044 	addi	r2,r2,1
8111e644:	e0bff615 	stw	r2,-40(fp)
8111e648:	e0fff617 	ldw	r3,-40(fp)
8111e64c:	e0800217 	ldw	r2,8(fp)
8111e650:	18bfcf36 	bltu	r3,r2,8111e590 <__reset+0xfb0fe590>

	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111e654:	e0bff517 	ldw	r2,-44(fp)
8111e658:	10800044 	addi	r2,r2,1
8111e65c:	e0bff515 	stw	r2,-44(fp)
8111e660:	e0fff517 	ldw	r3,-44(fp)
8111e664:	e0800317 	ldw	r2,12(fp)
8111e668:	18bfc736 	bltu	r3,r2,8111e588 <__reset+0xfb0fe588>
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
8111e66c:	e0bff417 	ldw	r2,-48(fp)
8111e670:	10002015 	stw	zero,128(r2)
8111e674:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111e678:	e03ff705 	stb	zero,-36(fp)
8111e67c:	00001c06 	br	8111e6f0 <pattern_createPattern+0x1d0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
8111e680:	e13ff417 	ldw	r4,-48(fp)
8111e684:	20802017 	ldw	r2,128(r4)
8111e688:	20c02117 	ldw	r3,132(r4)
8111e68c:	e13ff703 	ldbu	r4,-36(fp)
8111e690:	217ff804 	addi	r5,r4,-32
8111e694:	28000416 	blt	r5,zero,8111e6a8 <pattern_createPattern+0x188>
8111e698:	01200034 	movhi	r4,32768
8111e69c:	2160d83a 	srl	r16,r4,r5
8111e6a0:	0023883a 	mov	r17,zero
8111e6a4:	00000a06 	br	8111e6d0 <pattern_createPattern+0x1b0>
8111e6a8:	01600034 	movhi	r5,32768
8111e6ac:	280c907a 	slli	r6,r5,1
8111e6b0:	014007c4 	movi	r5,31
8111e6b4:	290bc83a 	sub	r5,r5,r4
8111e6b8:	314a983a 	sll	r5,r6,r5
8111e6bc:	000d883a 	mov	r6,zero
8111e6c0:	3120d83a 	srl	r16,r6,r4
8111e6c4:	2c20b03a 	or	r16,r5,r16
8111e6c8:	01600034 	movhi	r5,32768
8111e6cc:	2922d83a 	srl	r17,r5,r4
8111e6d0:	1424b03a 	or	r18,r2,r16
8111e6d4:	1c66b03a 	or	r19,r3,r17
8111e6d8:	e0bff417 	ldw	r2,-48(fp)
8111e6dc:	14802015 	stw	r18,128(r2)
8111e6e0:	14c02115 	stw	r19,132(r2)
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111e6e4:	e0bff703 	ldbu	r2,-36(fp)
8111e6e8:	10800044 	addi	r2,r2,1
8111e6ec:	e0bff705 	stb	r2,-36(fp)
8111e6f0:	e0fff703 	ldbu	r3,-36(fp)
8111e6f4:	e0bff303 	ldbu	r2,-52(fp)
8111e6f8:	18bfe136 	bltu	r3,r2,8111e680 <__reset+0xfb0fe680>
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
	}



	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111e6fc:	e0bff217 	ldw	r2,-56(fp)
8111e700:	10802204 	addi	r2,r2,136
8111e704:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111e708:	e0bff217 	ldw	r2,-56(fp)
}
8111e70c:	e6fffc04 	addi	sp,fp,-16
8111e710:	dfc00517 	ldw	ra,20(sp)
8111e714:	df000417 	ldw	fp,16(sp)
8111e718:	dcc00317 	ldw	r19,12(sp)
8111e71c:	dc800217 	ldw	r18,8(sp)
8111e720:	dc400117 	ldw	r17,4(sp)
8111e724:	dc000017 	ldw	r16,0(sp)
8111e728:	dec00604 	addi	sp,sp,24
8111e72c:	f800283a 	ret

8111e730 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111e730:	defffe04 	addi	sp,sp,-8
8111e734:	de00012e 	bgeu	sp,et,8111e73c <bSDcardIsPresent+0xc>
8111e738:	003b68fa 	trap	3
8111e73c:	dfc00115 	stw	ra,4(sp)
8111e740:	df000015 	stw	fp,0(sp)
8111e744:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111e748:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
}
8111e74c:	e037883a 	mov	sp,fp
8111e750:	dfc00117 	ldw	ra,4(sp)
8111e754:	df000017 	ldw	fp,0(sp)
8111e758:	dec00204 	addi	sp,sp,8
8111e75c:	f800283a 	ret

8111e760 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111e760:	defffe04 	addi	sp,sp,-8
8111e764:	de00012e 	bgeu	sp,et,8111e76c <bSDcardFAT16Check+0xc>
8111e768:	003b68fa 	trap	3
8111e76c:	dfc00115 	stw	ra,4(sp)
8111e770:	df000015 	stw	fp,0(sp)
8111e774:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111e778:	1144d880 	call	81144d88 <alt_up_sd_card_is_FAT16>
}
8111e77c:	e037883a 	mov	sp,fp
8111e780:	dfc00117 	ldw	ra,4(sp)
8111e784:	df000017 	ldw	fp,0(sp)
8111e788:	dec00204 	addi	sp,sp,8
8111e78c:	f800283a 	ret

8111e790 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111e790:	defffd04 	addi	sp,sp,-12
8111e794:	de00012e 	bgeu	sp,et,8111e79c <bInitializeSDCard+0xc>
8111e798:	003b68fa 	trap	3
8111e79c:	dfc00215 	stw	ra,8(sp)
8111e7a0:	df000115 	stw	fp,4(sp)
8111e7a4:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111e7a8:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111e7ac:	d0207715 	stw	zero,-32292(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111e7b0:	01204574 	movhi	r4,33045
8111e7b4:	2100e004 	addi	r4,r4,896
8111e7b8:	1144bf80 	call	81144bf8 <alt_up_sd_card_open_dev>
8111e7bc:	d0a07715 	stw	r2,-32292(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111e7c0:	d0a07717 	ldw	r2,-32292(gp)
8111e7c4:	10002226 	beq	r2,zero,8111e850 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111e7c8:	111e7300 	call	8111e730 <bSDcardIsPresent>
8111e7cc:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111e7d0:	e0bfff17 	ldw	r2,-4(fp)
8111e7d4:	10001626 	beq	r2,zero,8111e830 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111e7d8:	111e7600 	call	8111e760 <bSDcardFAT16Check>
8111e7dc:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111e7e0:	e0bfff17 	ldw	r2,-4(fp)
8111e7e4:	10000a26 	beq	r2,zero,8111e810 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111e7e8:	00800044 	movi	r2,1
8111e7ec:	d0a07615 	stw	r2,-32296(gp)
				debug(fp, "SD is up.\r\n");
8111e7f0:	d0a06217 	ldw	r2,-32376(gp)
8111e7f4:	100f883a 	mov	r7,r2
8111e7f8:	018002c4 	movi	r6,11
8111e7fc:	01400044 	movi	r5,1
8111e800:	01204574 	movhi	r4,33045
8111e804:	2100eb04 	addi	r4,r4,940
8111e808:	11219e00 	call	811219e0 <fwrite>
8111e80c:	00001806 	br	8111e870 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
8111e810:	d0a06217 	ldw	r2,-32376(gp)
8111e814:	100f883a 	mov	r7,r2
8111e818:	01800984 	movi	r6,38
8111e81c:	01400044 	movi	r5,1
8111e820:	01204574 	movhi	r4,33045
8111e824:	2100ee04 	addi	r4,r4,952
8111e828:	11219e00 	call	811219e0 <fwrite>
8111e82c:	00001006 	br	8111e870 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
8111e830:	d0a06217 	ldw	r2,-32376(gp)
8111e834:	100f883a 	mov	r7,r2
8111e838:	01800744 	movi	r6,29
8111e83c:	01400044 	movi	r5,1
8111e840:	01204574 	movhi	r4,33045
8111e844:	2100f804 	addi	r4,r4,992
8111e848:	11219e00 	call	811219e0 <fwrite>
8111e84c:	00000806 	br	8111e870 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111e850:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
8111e854:	d0a06217 	ldw	r2,-32376(gp)
8111e858:	100f883a 	mov	r7,r2
8111e85c:	018008c4 	movi	r6,35
8111e860:	01400044 	movi	r5,1
8111e864:	01204574 	movhi	r4,33045
8111e868:	21010004 	addi	r4,r4,1024
8111e86c:	11219e00 	call	811219e0 <fwrite>
	}

	return bSucess;
8111e870:	e0bfff17 	ldw	r2,-4(fp)
}
8111e874:	e037883a 	mov	sp,fp
8111e878:	dfc00117 	ldw	ra,4(sp)
8111e87c:	df000017 	ldw	fp,0(sp)
8111e880:	dec00204 	addi	sp,sp,8
8111e884:	f800283a 	ret

8111e888 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111e888:	defffd04 	addi	sp,sp,-12
8111e88c:	de00012e 	bgeu	sp,et,8111e894 <siOpenFile+0xc>
8111e890:	003b68fa 	trap	3
8111e894:	dfc00215 	stw	ra,8(sp)
8111e898:	df000115 	stw	fp,4(sp)
8111e89c:	df000104 	addi	fp,sp,4
8111e8a0:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111e8a4:	000b883a 	mov	r5,zero
8111e8a8:	e13fff17 	ldw	r4,-4(fp)
8111e8ac:	11452940 	call	81145294 <alt_up_sd_card_fopen>
}
8111e8b0:	e037883a 	mov	sp,fp
8111e8b4:	dfc00117 	ldw	ra,4(sp)
8111e8b8:	df000017 	ldw	fp,0(sp)
8111e8bc:	dec00204 	addi	sp,sp,8
8111e8c0:	f800283a 	ret

8111e8c4 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111e8c4:	defffd04 	addi	sp,sp,-12
8111e8c8:	de00012e 	bgeu	sp,et,8111e8d0 <siCloseFile+0xc>
8111e8cc:	003b68fa 	trap	3
8111e8d0:	dfc00215 	stw	ra,8(sp)
8111e8d4:	df000115 	stw	fp,4(sp)
8111e8d8:	df000104 	addi	fp,sp,4
8111e8dc:	2005883a 	mov	r2,r4
8111e8e0:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111e8e4:	e0bfff0f 	ldh	r2,-4(fp)
8111e8e8:	1009883a 	mov	r4,r2
8111e8ec:	11460e00 	call	811460e0 <alt_up_sd_card_fclose>
}
8111e8f0:	e037883a 	mov	sp,fp
8111e8f4:	dfc00117 	ldw	ra,4(sp)
8111e8f8:	df000017 	ldw	fp,0(sp)
8111e8fc:	dec00204 	addi	sp,sp,8
8111e900:	f800283a 	ret

8111e904 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111e904:	defffd04 	addi	sp,sp,-12
8111e908:	de00012e 	bgeu	sp,et,8111e910 <cGetNextChar+0xc>
8111e90c:	003b68fa 	trap	3
8111e910:	dfc00215 	stw	ra,8(sp)
8111e914:	df000115 	stw	fp,4(sp)
8111e918:	df000104 	addi	fp,sp,4
8111e91c:	2005883a 	mov	r2,r4
8111e920:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111e924:	e0bfff0f 	ldh	r2,-4(fp)
8111e928:	1009883a 	mov	r4,r2
8111e92c:	11457380 	call	81145738 <alt_up_sd_card_read>
}
8111e930:	e037883a 	mov	sp,fp
8111e934:	dfc00117 	ldw	ra,4(sp)
8111e938:	df000017 	ldw	fp,0(sp)
8111e93c:	dec00204 	addi	sp,sp,8
8111e940:	f800283a 	ret

8111e944 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8111e944:	defffc04 	addi	sp,sp,-16
8111e948:	de00012e 	bgeu	sp,et,8111e950 <bInitSync+0xc>
8111e94c:	003b68fa 	trap	3
8111e950:	dfc00315 	stw	ra,12(sp)
8111e954:	df000215 	stw	fp,8(sp)
8111e958:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111e95c:	110ca040 	call	8110ca04 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
8111e960:	d0a06217 	ldw	r2,-32376(gp)
8111e964:	100f883a 	mov	r7,r2
8111e968:	01800684 	movi	r6,26
8111e96c:	01400044 	movi	r5,1
8111e970:	01204574 	movhi	r4,33045
8111e974:	21010904 	addi	r4,r4,1060
8111e978:	11219e00 	call	811219e0 <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8111e97c:	01004c74 	movhi	r4,305
8111e980:	210b4004 	addi	r4,r4,11520
8111e984:	110cc0c0 	call	8110cc0c <bSyncSetMbt>
8111e988:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e98c:	e0bffe17 	ldw	r2,-8(fp)
8111e990:	1000091e 	bne	r2,zero,8111e9b8 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e994:	d0a06217 	ldw	r2,-32376(gp)
8111e998:	100f883a 	mov	r7,r2
8111e99c:	018005c4 	movi	r6,23
8111e9a0:	01400044 	movi	r5,1
8111e9a4:	01204574 	movhi	r4,33045
8111e9a8:	21011004 	addi	r4,r4,1088
8111e9ac:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111e9b0:	e0bffe17 	ldw	r2,-8(fp)
8111e9b4:	00008d06 	br	8111ebec <bInitSync+0x2a8>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111e9b8:	01002674 	movhi	r4,153
8111e9bc:	2125a004 	addi	r4,r4,-27008
8111e9c0:	110cc4c0 	call	8110cc4c <bSyncSetBt>
8111e9c4:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e9c8:	e0bffe17 	ldw	r2,-8(fp)
8111e9cc:	1000091e 	bne	r2,zero,8111e9f4 <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e9d0:	d0a06217 	ldw	r2,-32376(gp)
8111e9d4:	100f883a 	mov	r7,r2
8111e9d8:	018005c4 	movi	r6,23
8111e9dc:	01400044 	movi	r5,1
8111e9e0:	01204574 	movhi	r4,33045
8111e9e4:	21011004 	addi	r4,r4,1088
8111e9e8:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111e9ec:	e0bffe17 	ldw	r2,-8(fp)
8111e9f0:	00007e06 	br	8111ebec <bInitSync+0x2a8>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
8111e9f4:	00a045b4 	movhi	r2,33046
8111e9f8:	109ade04 	addi	r2,r2,27512
8111e9fc:	1080068b 	ldhu	r2,26(r2)
8111ea00:	10bfffcc 	andi	r2,r2,65535
8111ea04:	1009883a 	mov	r4,r2
8111ea08:	110d8e40 	call	8110d8e4 <uliPerCalcPeriodMs>
8111ea0c:	1009883a 	mov	r4,r2
8111ea10:	110cc8c0 	call	8110cc8c <bSyncSetPer>
8111ea14:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ea18:	e0bffe17 	ldw	r2,-8(fp)
8111ea1c:	1000091e 	bne	r2,zero,8111ea44 <bInitSync+0x100>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ea20:	d0a06217 	ldw	r2,-32376(gp)
8111ea24:	100f883a 	mov	r7,r2
8111ea28:	018005c4 	movi	r6,23
8111ea2c:	01400044 	movi	r5,1
8111ea30:	01204574 	movhi	r4,33045
8111ea34:	21011004 	addi	r4,r4,1088
8111ea38:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111ea3c:	e0bffe17 	ldw	r2,-8(fp)
8111ea40:	00006a06 	br	8111ebec <bInitSync+0x2a8>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8111ea44:	01005f74 	movhi	r4,381
8111ea48:	211e1004 	addi	r4,r4,30784
8111ea4c:	110cccc0 	call	8110cccc <bSyncSetOst>
8111ea50:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ea54:	e0bffe17 	ldw	r2,-8(fp)
8111ea58:	1000091e 	bne	r2,zero,8111ea80 <bInitSync+0x13c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ea5c:	d0a06217 	ldw	r2,-32376(gp)
8111ea60:	100f883a 	mov	r7,r2
8111ea64:	018005c4 	movi	r6,23
8111ea68:	01400044 	movi	r5,1
8111ea6c:	01204574 	movhi	r4,33045
8111ea70:	21011004 	addi	r4,r4,1088
8111ea74:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111ea78:	e0bffe17 	ldw	r2,-8(fp)
8111ea7c:	00005b06 	br	8111ebec <bInitSync+0x2a8>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8111ea80:	0009883a 	mov	r4,zero
8111ea84:	110cd0c0 	call	8110cd0c <bSyncSetPolarity>
8111ea88:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ea8c:	e0bffe17 	ldw	r2,-8(fp)
8111ea90:	1000091e 	bne	r2,zero,8111eab8 <bInitSync+0x174>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ea94:	d0a06217 	ldw	r2,-32376(gp)
8111ea98:	100f883a 	mov	r7,r2
8111ea9c:	018005c4 	movi	r6,23
8111eaa0:	01400044 	movi	r5,1
8111eaa4:	01204574 	movhi	r4,33045
8111eaa8:	21011004 	addi	r4,r4,1088
8111eaac:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111eab0:	e0bffe17 	ldw	r2,-8(fp)
8111eab4:	00004d06 	br	8111ebec <bInitSync+0x2a8>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8111eab8:	01000104 	movi	r4,4
8111eabc:	110cd800 	call	8110cd80 <bSyncSetNCycles>
8111eac0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111eac4:	e0bffe17 	ldw	r2,-8(fp)
8111eac8:	1000091e 	bne	r2,zero,8111eaf0 <bInitSync+0x1ac>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111eacc:	d0a06217 	ldw	r2,-32376(gp)
8111ead0:	100f883a 	mov	r7,r2
8111ead4:	018005c4 	movi	r6,23
8111ead8:	01400044 	movi	r5,1
8111eadc:	01204574 	movhi	r4,33045
8111eae0:	21011004 	addi	r4,r4,1088
8111eae4:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111eae8:	e0bffe17 	ldw	r2,-8(fp)
8111eaec:	00003f06 	br	8111ebec <bInitSync+0x2a8>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8111eaf0:	01000044 	movi	r4,1
8111eaf4:	110cf5c0 	call	8110cf5c <bSyncCtrExtnIrq>
8111eaf8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111eafc:	e0bffe17 	ldw	r2,-8(fp)
8111eb00:	1000091e 	bne	r2,zero,8111eb28 <bInitSync+0x1e4>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111eb04:	d0a06217 	ldw	r2,-32376(gp)
8111eb08:	100f883a 	mov	r7,r2
8111eb0c:	018005c4 	movi	r6,23
8111eb10:	01400044 	movi	r5,1
8111eb14:	01204574 	movhi	r4,33045
8111eb18:	21011004 	addi	r4,r4,1088
8111eb1c:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111eb20:	e0bffe17 	ldw	r2,-8(fp)
8111eb24:	00003106 	br	8111ebec <bInitSync+0x2a8>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8111eb28:	01000044 	movi	r4,1
8111eb2c:	110d1240 	call	8110d124 <bSyncCtrSyncOutEnable>
8111eb30:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111eb34:	e0bffe17 	ldw	r2,-8(fp)
8111eb38:	1000091e 	bne	r2,zero,8111eb60 <bInitSync+0x21c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111eb3c:	d0a06217 	ldw	r2,-32376(gp)
8111eb40:	100f883a 	mov	r7,r2
8111eb44:	018005c4 	movi	r6,23
8111eb48:	01400044 	movi	r5,1
8111eb4c:	01204574 	movhi	r4,33045
8111eb50:	21011004 	addi	r4,r4,1088
8111eb54:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111eb58:	e0bffe17 	ldw	r2,-8(fp)
8111eb5c:	00002306 	br	8111ebec <bInitSync+0x2a8>
	}


	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8111eb60:	01000044 	movi	r4,1
8111eb64:	110d1980 	call	8110d198 <bSyncCtrCh1OutEnable>
8111eb68:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111eb6c:	e0bffe17 	ldw	r2,-8(fp)
8111eb70:	1000091e 	bne	r2,zero,8111eb98 <bInitSync+0x254>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111eb74:	d0a06217 	ldw	r2,-32376(gp)
8111eb78:	100f883a 	mov	r7,r2
8111eb7c:	018005c4 	movi	r6,23
8111eb80:	01400044 	movi	r5,1
8111eb84:	01204574 	movhi	r4,33045
8111eb88:	21011004 	addi	r4,r4,1088
8111eb8c:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111eb90:	e0bffe17 	ldw	r2,-8(fp)
8111eb94:	00001506 	br	8111ebec <bInitSync+0x2a8>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh2OutEnable(TRUE);
8111eb98:	01000044 	movi	r4,1
8111eb9c:	110d20c0 	call	8110d20c <bSyncCtrCh2OutEnable>
8111eba0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111eba4:	e0bffe17 	ldw	r2,-8(fp)
8111eba8:	1000091e 	bne	r2,zero,8111ebd0 <bInitSync+0x28c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ebac:	d0a06217 	ldw	r2,-32376(gp)
8111ebb0:	100f883a 	mov	r7,r2
8111ebb4:	018005c4 	movi	r6,23
8111ebb8:	01400044 	movi	r5,1
8111ebbc:	01204574 	movhi	r4,33045
8111ebc0:	21011004 	addi	r4,r4,1088
8111ebc4:	11219e00 	call	811219e0 <fwrite>
		#endif
		return bSuccess;
8111ebc8:	e0bffe17 	ldw	r2,-8(fp)
8111ebcc:	00000706 	br	8111ebec <bInitSync+0x2a8>
	}

	bSuccess = bSyncCtrStart();
8111ebd0:	110cfd40 	call	8110cfd4 <bSyncCtrStart>
8111ebd4:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
8111ebd8:	110d0280 	call	8110d028 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111ebdc:	01000044 	movi	r4,1
8111ebe0:	110d5ac0 	call	8110d5ac <bSyncIrqEnableBlank>
8111ebe4:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
8111ebe8:	e0bffe17 	ldw	r2,-8(fp)
}
8111ebec:	e037883a 	mov	sp,fp
8111ebf0:	dfc00117 	ldw	ra,4(sp)
8111ebf4:	df000017 	ldw	fp,0(sp)
8111ebf8:	dec00204 	addi	sp,sp,8
8111ebfc:	f800283a 	ret

8111ec00 <bStartSync>:


bool bStartSync(void) {
8111ec00:	defffd04 	addi	sp,sp,-12
8111ec04:	de00012e 	bgeu	sp,et,8111ec0c <bStartSync+0xc>
8111ec08:	003b68fa 	trap	3
8111ec0c:	dfc00215 	stw	ra,8(sp)
8111ec10:	df000115 	stw	fp,4(sp)
8111ec14:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
8111ec18:	110d0280 	call	8110d028 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
8111ec1c:	110cfd40 	call	8110cfd4 <bSyncCtrStart>
8111ec20:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8111ec24:	e0bfff17 	ldw	r2,-4(fp)
}
8111ec28:	e037883a 	mov	sp,fp
8111ec2c:	dfc00117 	ldw	ra,4(sp)
8111ec30:	df000017 	ldw	fp,0(sp)
8111ec34:	dec00204 	addi	sp,sp,8
8111ec38:	f800283a 	ret

8111ec3c <bStopSync>:

bool bStopSync(void) {
8111ec3c:	defffe04 	addi	sp,sp,-8
8111ec40:	de00012e 	bgeu	sp,et,8111ec48 <bStopSync+0xc>
8111ec44:	003b68fa 	trap	3
8111ec48:	dfc00115 	stw	ra,4(sp)
8111ec4c:	df000015 	stw	fp,0(sp)
8111ec50:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8111ec54:	110d0280 	call	8110d028 <bSyncCtrReset>
}
8111ec58:	e037883a 	mov	sp,fp
8111ec5c:	dfc00117 	ldw	ra,4(sp)
8111ec60:	df000017 	ldw	fp,0(sp)
8111ec64:	dec00204 	addi	sp,sp,8
8111ec68:	f800283a 	ret

8111ec6c <bClearCounterSync>:

void bClearCounterSync(void) {
8111ec6c:	defffe04 	addi	sp,sp,-8
8111ec70:	de00012e 	bgeu	sp,et,8111ec78 <bClearCounterSync+0xc>
8111ec74:	003b68fa 	trap	3
8111ec78:	dfc00115 	stw	ra,4(sp)
8111ec7c:	df000015 	stw	fp,0(sp)
8111ec80:	d839883a 	mov	fp,sp

	vSyncClearCounter();
8111ec84:	110c9d80 	call	8110c9d8 <vSyncClearCounter>
}
8111ec88:	0001883a 	nop
8111ec8c:	e037883a 	mov	sp,fp
8111ec90:	dfc00117 	ldw	ra,4(sp)
8111ec94:	df000017 	ldw	fp,0(sp)
8111ec98:	dec00204 	addi	sp,sp,8
8111ec9c:	f800283a 	ret

8111eca0 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111eca0:	defffd04 	addi	sp,sp,-12
8111eca4:	de00012e 	bgeu	sp,et,8111ecac <bTestSimucamCriticalHW+0xc>
8111eca8:	003b68fa 	trap	3
8111ecac:	dfc00215 	stw	ra,8(sp)
8111ecb0:	df000115 	stw	fp,4(sp)
8111ecb4:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8111ecb8:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8111ecbc:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111ecc0:	e0bfff17 	ldw	r2,-4(fp)
8111ecc4:	1000021e 	bne	r2,zero,8111ecd0 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8111ecc8:	e0bfff17 	ldw	r2,-4(fp)
8111eccc:	00000706 	br	8111ecec <bTestSimucamCriticalHW+0x4c>
	}

	bSuccess = bSdmaInitM2Dma();
8111ecd0:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
8111ecd4:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111ecd8:	e0bfff17 	ldw	r2,-4(fp)
8111ecdc:	1000021e 	bne	r2,zero,8111ece8 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111ece0:	e0bfff17 	ldw	r2,-4(fp)
8111ece4:	00000106 	br	8111ecec <bTestSimucamCriticalHW+0x4c>

	//xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
	//xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;


	return TRUE;
8111ece8:	00800044 	movi	r2,1
}
8111ecec:	e037883a 	mov	sp,fp
8111ecf0:	dfc00117 	ldw	ra,4(sp)
8111ecf4:	df000017 	ldw	fp,0(sp)
8111ecf8:	dec00204 	addi	sp,sp,8
8111ecfc:	f800283a 	ret

8111ed00 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111ed00:	defffc04 	addi	sp,sp,-16
8111ed04:	de00012e 	bgeu	sp,et,8111ed0c <_reg_write+0xc>
8111ed08:	003b68fa 	trap	3
8111ed0c:	df000315 	stw	fp,12(sp)
8111ed10:	df000304 	addi	fp,sp,12
8111ed14:	e13ffd15 	stw	r4,-12(fp)
8111ed18:	e17ffe15 	stw	r5,-8(fp)
8111ed1c:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111ed20:	e0bffe17 	ldw	r2,-8(fp)
8111ed24:	1085883a 	add	r2,r2,r2
8111ed28:	1085883a 	add	r2,r2,r2
8111ed2c:	1007883a 	mov	r3,r2
8111ed30:	e0bffd17 	ldw	r2,-12(fp)
8111ed34:	1885883a 	add	r2,r3,r2
8111ed38:	1007883a 	mov	r3,r2
8111ed3c:	e0bfff17 	ldw	r2,-4(fp)
8111ed40:	18800035 	stwio	r2,0(r3)
	return 1;
8111ed44:	00800044 	movi	r2,1

}
8111ed48:	e037883a 	mov	sp,fp
8111ed4c:	df000017 	ldw	fp,0(sp)
8111ed50:	dec00104 	addi	sp,sp,4
8111ed54:	f800283a 	ret

8111ed58 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111ed58:	defffc04 	addi	sp,sp,-16
8111ed5c:	de00012e 	bgeu	sp,et,8111ed64 <_reg_read+0xc>
8111ed60:	003b68fa 	trap	3
8111ed64:	df000315 	stw	fp,12(sp)
8111ed68:	df000304 	addi	fp,sp,12
8111ed6c:	e13ffd15 	stw	r4,-12(fp)
8111ed70:	e17ffe15 	stw	r5,-8(fp)
8111ed74:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111ed78:	e0bffe17 	ldw	r2,-8(fp)
8111ed7c:	1085883a 	add	r2,r2,r2
8111ed80:	1085883a 	add	r2,r2,r2
8111ed84:	1007883a 	mov	r3,r2
8111ed88:	e0bffd17 	ldw	r2,-12(fp)
8111ed8c:	1885883a 	add	r2,r3,r2
8111ed90:	10c00037 	ldwio	r3,0(r2)
8111ed94:	e0bfff17 	ldw	r2,-4(fp)
8111ed98:	10c00015 	stw	r3,0(r2)
	return 1;
8111ed9c:	00800044 	movi	r2,1

}
8111eda0:	e037883a 	mov	sp,fp
8111eda4:	df000017 	ldw	fp,0(sp)
8111eda8:	dec00104 	addi	sp,sp,4
8111edac:	f800283a 	ret

8111edb0 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111edb0:	defffa04 	addi	sp,sp,-24
8111edb4:	de00012e 	bgeu	sp,et,8111edbc <_print_codec_status+0xc>
8111edb8:	003b68fa 	trap	3
8111edbc:	dfc00515 	stw	ra,20(sp)
8111edc0:	df000415 	stw	fp,16(sp)
8111edc4:	df000404 	addi	fp,sp,16
8111edc8:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111edcc:	e0bfff17 	ldw	r2,-4(fp)
8111edd0:	1005d1ba 	srai	r2,r2,6
8111edd4:	1080004c 	andi	r2,r2,1
8111edd8:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111eddc:	e0bfff17 	ldw	r2,-4(fp)
8111ede0:	1005d17a 	srai	r2,r2,5
8111ede4:	1080004c 	andi	r2,r2,1
8111ede8:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111edec:	e0bfff17 	ldw	r2,-4(fp)
8111edf0:	1005d13a 	srai	r2,r2,4
8111edf4:	1080004c 	andi	r2,r2,1
8111edf8:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111edfc:	00e04574 	movhi	r3,33045
8111ee00:	18ccfa04 	addi	r3,r3,13288
8111ee04:	00a04574 	movhi	r2,33045
8111ee08:	10811604 	addi	r2,r2,1112
8111ee0c:	1009883a 	mov	r4,r2
8111ee10:	008005c4 	movi	r2,23
8111ee14:	100d883a 	mov	r6,r2
8111ee18:	200b883a 	mov	r5,r4
8111ee1c:	1809883a 	mov	r4,r3
8111ee20:	11223f40 	call	811223f4 <memcpy>
	debug(fp, cDebugBuffer);
8111ee24:	d0a06217 	ldw	r2,-32376(gp)
8111ee28:	01604574 	movhi	r5,33045
8111ee2c:	294cfa04 	addi	r5,r5,13288
8111ee30:	1009883a 	mov	r4,r2
8111ee34:	11213440 	call	81121344 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111ee38:	e0bffc17 	ldw	r2,-16(fp)
8111ee3c:	10800058 	cmpnei	r2,r2,1
8111ee40:	1000031e 	bne	r2,zero,8111ee50 <_print_codec_status+0xa0>
8111ee44:	00a04574 	movhi	r2,33045
8111ee48:	10811c04 	addi	r2,r2,1136
8111ee4c:	00000206 	br	8111ee58 <_print_codec_status+0xa8>
8111ee50:	00a04574 	movhi	r2,33045
8111ee54:	10811d04 	addi	r2,r2,1140
8111ee58:	100d883a 	mov	r6,r2
8111ee5c:	01604574 	movhi	r5,33045
8111ee60:	29411e04 	addi	r5,r5,1144
8111ee64:	01204574 	movhi	r4,33045
8111ee68:	210cfa04 	addi	r4,r4,13288
8111ee6c:	1122cd40 	call	81122cd4 <sprintf>
	debug(fp, cDebugBuffer);
8111ee70:	d0a06217 	ldw	r2,-32376(gp)
8111ee74:	01604574 	movhi	r5,33045
8111ee78:	294cfa04 	addi	r5,r5,13288
8111ee7c:	1009883a 	mov	r4,r2
8111ee80:	11213440 	call	81121344 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111ee84:	e0bffd17 	ldw	r2,-12(fp)
8111ee88:	10800058 	cmpnei	r2,r2,1
8111ee8c:	1000031e 	bne	r2,zero,8111ee9c <_print_codec_status+0xec>
8111ee90:	00a04574 	movhi	r2,33045
8111ee94:	10811c04 	addi	r2,r2,1136
8111ee98:	00000206 	br	8111eea4 <_print_codec_status+0xf4>
8111ee9c:	00a04574 	movhi	r2,33045
8111eea0:	10811d04 	addi	r2,r2,1140
8111eea4:	100d883a 	mov	r6,r2
8111eea8:	01604574 	movhi	r5,33045
8111eeac:	29412404 	addi	r5,r5,1168
8111eeb0:	01204574 	movhi	r4,33045
8111eeb4:	210cfa04 	addi	r4,r4,13288
8111eeb8:	1122cd40 	call	81122cd4 <sprintf>
	debug(fp, cDebugBuffer);
8111eebc:	d0a06217 	ldw	r2,-32376(gp)
8111eec0:	01604574 	movhi	r5,33045
8111eec4:	294cfa04 	addi	r5,r5,13288
8111eec8:	1009883a 	mov	r4,r2
8111eecc:	11213440 	call	81121344 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111eed0:	e0bffe17 	ldw	r2,-8(fp)
8111eed4:	10800058 	cmpnei	r2,r2,1
8111eed8:	1000031e 	bne	r2,zero,8111eee8 <_print_codec_status+0x138>
8111eedc:	00a04574 	movhi	r2,33045
8111eee0:	10811c04 	addi	r2,r2,1136
8111eee4:	00000206 	br	8111eef0 <_print_codec_status+0x140>
8111eee8:	00a04574 	movhi	r2,33045
8111eeec:	10811d04 	addi	r2,r2,1140
8111eef0:	100d883a 	mov	r6,r2
8111eef4:	01604574 	movhi	r5,33045
8111eef8:	29412a04 	addi	r5,r5,1192
8111eefc:	01204574 	movhi	r4,33045
8111ef00:	210cfa04 	addi	r4,r4,13288
8111ef04:	1122cd40 	call	81122cd4 <sprintf>
	debug(fp, cDebugBuffer);
8111ef08:	d0a06217 	ldw	r2,-32376(gp)
8111ef0c:	01604574 	movhi	r5,33045
8111ef10:	294cfa04 	addi	r5,r5,13288
8111ef14:	1009883a 	mov	r4,r2
8111ef18:	11213440 	call	81121344 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111ef1c:	00a04574 	movhi	r2,33045
8111ef20:	108cfa04 	addi	r2,r2,13288
8111ef24:	00c00b44 	movi	r3,45
8111ef28:	10c00005 	stb	r3,0(r2)
8111ef2c:	00c00b44 	movi	r3,45
8111ef30:	10c00045 	stb	r3,1(r2)
8111ef34:	00c00b44 	movi	r3,45
8111ef38:	10c00085 	stb	r3,2(r2)
8111ef3c:	00c00b44 	movi	r3,45
8111ef40:	10c000c5 	stb	r3,3(r2)
8111ef44:	00c00b44 	movi	r3,45
8111ef48:	10c00105 	stb	r3,4(r2)
8111ef4c:	00c00b44 	movi	r3,45
8111ef50:	10c00145 	stb	r3,5(r2)
8111ef54:	00c00b44 	movi	r3,45
8111ef58:	10c00185 	stb	r3,6(r2)
8111ef5c:	00c00b44 	movi	r3,45
8111ef60:	10c001c5 	stb	r3,7(r2)
8111ef64:	00c00804 	movi	r3,32
8111ef68:	10c00205 	stb	r3,8(r2)
8111ef6c:	00c00804 	movi	r3,32
8111ef70:	10c00245 	stb	r3,9(r2)
8111ef74:	00c00284 	movi	r3,10
8111ef78:	10c00285 	stb	r3,10(r2)
8111ef7c:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111ef80:	d0a06217 	ldw	r2,-32376(gp)
8111ef84:	01604574 	movhi	r5,33045
8111ef88:	294cfa04 	addi	r5,r5,13288
8111ef8c:	1009883a 	mov	r4,r2
8111ef90:	11213440 	call	81121344 <fprintf>
#endif
}
8111ef94:	0001883a 	nop
8111ef98:	e037883a 	mov	sp,fp
8111ef9c:	dfc00117 	ldw	ra,4(sp)
8111efa0:	df000017 	ldw	fp,0(sp)
8111efa4:	dec00204 	addi	sp,sp,8
8111efa8:	f800283a 	ret

8111efac <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111efac:	defffb04 	addi	sp,sp,-20
8111efb0:	de00012e 	bgeu	sp,et,8111efb8 <_split_codec_status+0xc>
8111efb4:	003b68fa 	trap	3
8111efb8:	df000415 	stw	fp,16(sp)
8111efbc:	df000404 	addi	fp,sp,16
8111efc0:	e13ffc15 	stw	r4,-16(fp)
8111efc4:	e17ffd15 	stw	r5,-12(fp)
8111efc8:	e1bffe15 	stw	r6,-8(fp)
8111efcc:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111efd0:	e0bffc17 	ldw	r2,-16(fp)
8111efd4:	1005d1ba 	srai	r2,r2,6
8111efd8:	10c0004c 	andi	r3,r2,1
8111efdc:	e0bffd17 	ldw	r2,-12(fp)
8111efe0:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111efe4:	e0bffc17 	ldw	r2,-16(fp)
8111efe8:	1005d17a 	srai	r2,r2,5
8111efec:	10c0004c 	andi	r3,r2,1
8111eff0:	e0bffe17 	ldw	r2,-8(fp)
8111eff4:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111eff8:	e0bffc17 	ldw	r2,-16(fp)
8111effc:	1005d13a 	srai	r2,r2,4
8111f000:	10c0004c 	andi	r3,r2,1
8111f004:	e0bfff17 	ldw	r2,-4(fp)
8111f008:	10c00015 	stw	r3,0(r2)
}
8111f00c:	0001883a 	nop
8111f010:	e037883a 	mov	sp,fp
8111f014:	df000017 	ldw	fp,0(sp)
8111f018:	dec00104 	addi	sp,sp,4
8111f01c:	f800283a 	ret

8111f020 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111f020:	defffc04 	addi	sp,sp,-16
8111f024:	de00012e 	bgeu	sp,et,8111f02c <aatoh+0xc>
8111f028:	003b68fa 	trap	3
8111f02c:	df000315 	stw	fp,12(sp)
8111f030:	df000304 	addi	fp,sp,12
8111f034:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111f038:	e0bfff17 	ldw	r2,-4(fp)
8111f03c:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111f040:	e0bffd17 	ldw	r2,-12(fp)
8111f044:	10c00003 	ldbu	r3,0(r2)
8111f048:	e0bffd17 	ldw	r2,-12(fp)
8111f04c:	10800003 	ldbu	r2,0(r2)
8111f050:	10803fcc 	andi	r2,r2,255
8111f054:	10800eb0 	cmpltui	r2,r2,58
8111f058:	1000021e 	bne	r2,zero,8111f064 <aatoh+0x44>
8111f05c:	00800dc4 	movi	r2,55
8111f060:	00000106 	br	8111f068 <aatoh+0x48>
8111f064:	00800c04 	movi	r2,48
8111f068:	1885c83a 	sub	r2,r3,r2
8111f06c:	1004913a 	slli	r2,r2,4
8111f070:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111f074:	e0bffd17 	ldw	r2,-12(fp)
8111f078:	10800044 	addi	r2,r2,1
8111f07c:	10c00003 	ldbu	r3,0(r2)
8111f080:	e0bffd17 	ldw	r2,-12(fp)
8111f084:	10800044 	addi	r2,r2,1
8111f088:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111f08c:	10803fcc 	andi	r2,r2,255
8111f090:	10800eb0 	cmpltui	r2,r2,58
8111f094:	1000021e 	bne	r2,zero,8111f0a0 <aatoh+0x80>
8111f098:	00800dc4 	movi	r2,55
8111f09c:	00000106 	br	8111f0a4 <aatoh+0x84>
8111f0a0:	00800c04 	movi	r2,48
8111f0a4:	1885c83a 	sub	r2,r3,r2
8111f0a8:	2085883a 	add	r2,r4,r2
8111f0ac:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111f0b0:	e0bffe03 	ldbu	r2,-8(fp)
}
8111f0b4:	e037883a 	mov	sp,fp
8111f0b8:	df000017 	ldw	fp,0(sp)
8111f0bc:	dec00104 	addi	sp,sp,4
8111f0c0:	f800283a 	ret

8111f0c4 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111f0c4:	defffd04 	addi	sp,sp,-12
8111f0c8:	de00012e 	bgeu	sp,et,8111f0d0 <Verif_Error+0xc>
8111f0cc:	003b68fa 	trap	3
8111f0d0:	dfc00215 	stw	ra,8(sp)
8111f0d4:	df000115 	stw	fp,4(sp)
8111f0d8:	df000104 	addi	fp,sp,4
8111f0dc:	2005883a 	mov	r2,r4
8111f0e0:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111f0e4:	e0bfff03 	ldbu	r2,-4(fp)
8111f0e8:	1000091e 	bne	r2,zero,8111f110 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111f0ec:	d0a06217 	ldw	r2,-32376(gp)
8111f0f0:	100f883a 	mov	r7,r2
8111f0f4:	018001c4 	movi	r6,7
8111f0f8:	01400044 	movi	r5,1
8111f0fc:	01204574 	movhi	r4,33045
8111f100:	21013004 	addi	r4,r4,1216
8111f104:	11219e00 	call	811219e0 <fwrite>
#endif
		return 0;
8111f108:	0005883a 	mov	r2,zero
8111f10c:	00000106 	br	8111f114 <Verif_Error+0x50>
	} else
		return 1;
8111f110:	00800044 	movi	r2,1
}
8111f114:	e037883a 	mov	sp,fp
8111f118:	dfc00117 	ldw	ra,4(sp)
8111f11c:	df000017 	ldw	fp,0(sp)
8111f120:	dec00204 	addi	sp,sp,8
8111f124:	f800283a 	ret

8111f128 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111f128:	defffe04 	addi	sp,sp,-8
8111f12c:	de00012e 	bgeu	sp,et,8111f134 <toInt+0xc>
8111f130:	003b68fa 	trap	3
8111f134:	df000115 	stw	fp,4(sp)
8111f138:	df000104 	addi	fp,sp,4
8111f13c:	2005883a 	mov	r2,r4
8111f140:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111f144:	e0bfff03 	ldbu	r2,-4(fp)
8111f148:	10bff404 	addi	r2,r2,-48
}
8111f14c:	e037883a 	mov	sp,fp
8111f150:	df000017 	ldw	fp,0(sp)
8111f154:	dec00104 	addi	sp,sp,4
8111f158:	f800283a 	ret

8111f15c <__fixunsdfsi>:
8111f15c:	defffd04 	addi	sp,sp,-12
8111f160:	000d883a 	mov	r6,zero
8111f164:	01d07834 	movhi	r7,16864
8111f168:	de00012e 	bgeu	sp,et,8111f170 <__fixunsdfsi+0x14>
8111f16c:	003b68fa 	trap	3
8111f170:	dc400115 	stw	r17,4(sp)
8111f174:	dc000015 	stw	r16,0(sp)
8111f178:	dfc00215 	stw	ra,8(sp)
8111f17c:	2023883a 	mov	r17,r4
8111f180:	2821883a 	mov	r16,r5
8111f184:	111fc480 	call	8111fc48 <__gedf2>
8111f188:	1000080e 	bge	r2,zero,8111f1ac <__fixunsdfsi+0x50>
8111f18c:	8809883a 	mov	r4,r17
8111f190:	800b883a 	mov	r5,r16
8111f194:	1120d480 	call	81120d48 <__fixdfsi>
8111f198:	dfc00217 	ldw	ra,8(sp)
8111f19c:	dc400117 	ldw	r17,4(sp)
8111f1a0:	dc000017 	ldw	r16,0(sp)
8111f1a4:	dec00304 	addi	sp,sp,12
8111f1a8:	f800283a 	ret
8111f1ac:	000d883a 	mov	r6,zero
8111f1b0:	01d07834 	movhi	r7,16864
8111f1b4:	8809883a 	mov	r4,r17
8111f1b8:	800b883a 	mov	r5,r16
8111f1bc:	11204440 	call	81120444 <__subdf3>
8111f1c0:	180b883a 	mov	r5,r3
8111f1c4:	1009883a 	mov	r4,r2
8111f1c8:	1120d480 	call	81120d48 <__fixdfsi>
8111f1cc:	00e00034 	movhi	r3,32768
8111f1d0:	10c5883a 	add	r2,r2,r3
8111f1d4:	003ff006 	br	8111f198 <__reset+0xfb0ff198>

8111f1d8 <__divsf3>:
8111f1d8:	defff504 	addi	sp,sp,-44
8111f1dc:	200cd5fa 	srli	r6,r4,23
8111f1e0:	de00012e 	bgeu	sp,et,8111f1e8 <__divsf3+0x10>
8111f1e4:	003b68fa 	trap	3
8111f1e8:	dcc00415 	stw	r19,16(sp)
8111f1ec:	2026d7fa 	srli	r19,r4,31
8111f1f0:	00c02034 	movhi	r3,128
8111f1f4:	dd800715 	stw	r22,28(sp)
8111f1f8:	dd000515 	stw	r20,20(sp)
8111f1fc:	dc800315 	stw	r18,12(sp)
8111f200:	18ffffc4 	addi	r3,r3,-1
8111f204:	dfc00a15 	stw	ra,40(sp)
8111f208:	df000915 	stw	fp,36(sp)
8111f20c:	ddc00815 	stw	r23,32(sp)
8111f210:	dd400615 	stw	r21,24(sp)
8111f214:	dc400215 	stw	r17,8(sp)
8111f218:	dc000115 	stw	r16,4(sp)
8111f21c:	35003fcc 	andi	r20,r6,255
8111f220:	1924703a 	and	r18,r3,r4
8111f224:	9d803fcc 	andi	r22,r19,255
8111f228:	a0005226 	beq	r20,zero,8111f374 <__divsf3+0x19c>
8111f22c:	00803fc4 	movi	r2,255
8111f230:	a0802e26 	beq	r20,r2,8111f2ec <__divsf3+0x114>
8111f234:	91002034 	orhi	r4,r18,128
8111f238:	202490fa 	slli	r18,r4,3
8111f23c:	a53fe044 	addi	r20,r20,-127
8111f240:	0021883a 	mov	r16,zero
8111f244:	002f883a 	mov	r23,zero
8111f248:	280cd5fa 	srli	r6,r5,23
8111f24c:	282ad7fa 	srli	r21,r5,31
8111f250:	00c02034 	movhi	r3,128
8111f254:	18ffffc4 	addi	r3,r3,-1
8111f258:	31803fcc 	andi	r6,r6,255
8111f25c:	1962703a 	and	r17,r3,r5
8111f260:	af003fcc 	andi	fp,r21,255
8111f264:	30004a26 	beq	r6,zero,8111f390 <__divsf3+0x1b8>
8111f268:	00803fc4 	movi	r2,255
8111f26c:	30804526 	beq	r6,r2,8111f384 <__divsf3+0x1ac>
8111f270:	89402034 	orhi	r5,r17,128
8111f274:	282290fa 	slli	r17,r5,3
8111f278:	31bfe044 	addi	r6,r6,-127
8111f27c:	000b883a 	mov	r5,zero
8111f280:	2c20b03a 	or	r16,r5,r16
8111f284:	802090ba 	slli	r16,r16,2
8111f288:	00a044b4 	movhi	r2,33042
8111f28c:	10bcab04 	addi	r2,r2,-3412
8111f290:	80a1883a 	add	r16,r16,r2
8111f294:	81000017 	ldw	r4,0(r16)
8111f298:	9d46f03a 	xor	r3,r19,r21
8111f29c:	180f883a 	mov	r7,r3
8111f2a0:	18803fcc 	andi	r2,r3,255
8111f2a4:	a18dc83a 	sub	r6,r20,r6
8111f2a8:	2000683a 	jmp	r4
8111f2ac:	8111f490 	cmplti	r4,r16,18386
8111f2b0:	8111f314 	ori	r4,r16,18380
8111f2b4:	8111f484 	addi	r4,r16,18386
8111f2b8:	8111f300 	call	88111f30 <__reset+0x20f1f30>
8111f2bc:	8111f484 	addi	r4,r16,18386
8111f2c0:	8111f45c 	xori	r4,r16,18385
8111f2c4:	8111f484 	addi	r4,r16,18386
8111f2c8:	8111f300 	call	88111f30 <__reset+0x20f1f30>
8111f2cc:	8111f314 	ori	r4,r16,18380
8111f2d0:	8111f314 	ori	r4,r16,18380
8111f2d4:	8111f45c 	xori	r4,r16,18385
8111f2d8:	8111f300 	call	88111f30 <__reset+0x20f1f30>
8111f2dc:	8111f570 	cmpltui	r4,r16,18389
8111f2e0:	8111f570 	cmpltui	r4,r16,18389
8111f2e4:	8111f570 	cmpltui	r4,r16,18389
8111f2e8:	8111f524 	muli	r4,r16,18388
8111f2ec:	9000581e 	bne	r18,zero,8111f450 <__divsf3+0x278>
8111f2f0:	04000204 	movi	r16,8
8111f2f4:	05c00084 	movi	r23,2
8111f2f8:	003fd306 	br	8111f248 <__reset+0xfb0ff248>
8111f2fc:	0023883a 	mov	r17,zero
8111f300:	e02d883a 	mov	r22,fp
8111f304:	282f883a 	mov	r23,r5
8111f308:	00800084 	movi	r2,2
8111f30c:	b8808f1e 	bne	r23,r2,8111f54c <__divsf3+0x374>
8111f310:	b005883a 	mov	r2,r22
8111f314:	11c0004c 	andi	r7,r2,1
8111f318:	013fffc4 	movi	r4,-1
8111f31c:	000d883a 	mov	r6,zero
8111f320:	21003fcc 	andi	r4,r4,255
8111f324:	200895fa 	slli	r4,r4,23
8111f328:	38803fcc 	andi	r2,r7,255
8111f32c:	00c02034 	movhi	r3,128
8111f330:	100497fa 	slli	r2,r2,31
8111f334:	18ffffc4 	addi	r3,r3,-1
8111f338:	30c6703a 	and	r3,r6,r3
8111f33c:	1906b03a 	or	r3,r3,r4
8111f340:	1884b03a 	or	r2,r3,r2
8111f344:	dfc00a17 	ldw	ra,40(sp)
8111f348:	df000917 	ldw	fp,36(sp)
8111f34c:	ddc00817 	ldw	r23,32(sp)
8111f350:	dd800717 	ldw	r22,28(sp)
8111f354:	dd400617 	ldw	r21,24(sp)
8111f358:	dd000517 	ldw	r20,20(sp)
8111f35c:	dcc00417 	ldw	r19,16(sp)
8111f360:	dc800317 	ldw	r18,12(sp)
8111f364:	dc400217 	ldw	r17,8(sp)
8111f368:	dc000117 	ldw	r16,4(sp)
8111f36c:	dec00b04 	addi	sp,sp,44
8111f370:	f800283a 	ret
8111f374:	90002b1e 	bne	r18,zero,8111f424 <__divsf3+0x24c>
8111f378:	04000104 	movi	r16,4
8111f37c:	05c00044 	movi	r23,1
8111f380:	003fb106 	br	8111f248 <__reset+0xfb0ff248>
8111f384:	8800251e 	bne	r17,zero,8111f41c <__divsf3+0x244>
8111f388:	01400084 	movi	r5,2
8111f38c:	00000206 	br	8111f398 <__divsf3+0x1c0>
8111f390:	88001a1e 	bne	r17,zero,8111f3fc <__divsf3+0x224>
8111f394:	01400044 	movi	r5,1
8111f398:	8160b03a 	or	r16,r16,r5
8111f39c:	802090ba 	slli	r16,r16,2
8111f3a0:	00e044b4 	movhi	r3,33042
8111f3a4:	18fcef04 	addi	r3,r3,-3140
8111f3a8:	80e1883a 	add	r16,r16,r3
8111f3ac:	80c00017 	ldw	r3,0(r16)
8111f3b0:	9d44f03a 	xor	r2,r19,r21
8111f3b4:	a18dc83a 	sub	r6,r20,r6
8111f3b8:	1800683a 	jmp	r3
8111f3bc:	8111f314 	ori	r4,r16,18380
8111f3c0:	8111f314 	ori	r4,r16,18380
8111f3c4:	8111f560 	cmpeqi	r4,r16,18389
8111f3c8:	8111f2fc 	xorhi	r4,r16,18379
8111f3cc:	8111f560 	cmpeqi	r4,r16,18389
8111f3d0:	8111f45c 	xori	r4,r16,18385
8111f3d4:	8111f560 	cmpeqi	r4,r16,18389
8111f3d8:	8111f2fc 	xorhi	r4,r16,18379
8111f3dc:	8111f314 	ori	r4,r16,18380
8111f3e0:	8111f314 	ori	r4,r16,18380
8111f3e4:	8111f45c 	xori	r4,r16,18385
8111f3e8:	8111f2fc 	xorhi	r4,r16,18379
8111f3ec:	8111f570 	cmpltui	r4,r16,18389
8111f3f0:	8111f570 	cmpltui	r4,r16,18389
8111f3f4:	8111f570 	cmpltui	r4,r16,18389
8111f3f8:	8111f588 	cmpgei	r4,r16,18390
8111f3fc:	8809883a 	mov	r4,r17
8111f400:	112116c0 	call	8112116c <__clzsi2>
8111f404:	10fffec4 	addi	r3,r2,-5
8111f408:	10801d84 	addi	r2,r2,118
8111f40c:	88e2983a 	sll	r17,r17,r3
8111f410:	008dc83a 	sub	r6,zero,r2
8111f414:	000b883a 	mov	r5,zero
8111f418:	003f9906 	br	8111f280 <__reset+0xfb0ff280>
8111f41c:	014000c4 	movi	r5,3
8111f420:	003f9706 	br	8111f280 <__reset+0xfb0ff280>
8111f424:	9009883a 	mov	r4,r18
8111f428:	d9400015 	stw	r5,0(sp)
8111f42c:	112116c0 	call	8112116c <__clzsi2>
8111f430:	10fffec4 	addi	r3,r2,-5
8111f434:	11801d84 	addi	r6,r2,118
8111f438:	90e4983a 	sll	r18,r18,r3
8111f43c:	01a9c83a 	sub	r20,zero,r6
8111f440:	0021883a 	mov	r16,zero
8111f444:	002f883a 	mov	r23,zero
8111f448:	d9400017 	ldw	r5,0(sp)
8111f44c:	003f7e06 	br	8111f248 <__reset+0xfb0ff248>
8111f450:	04000304 	movi	r16,12
8111f454:	05c000c4 	movi	r23,3
8111f458:	003f7b06 	br	8111f248 <__reset+0xfb0ff248>
8111f45c:	01802034 	movhi	r6,128
8111f460:	000f883a 	mov	r7,zero
8111f464:	31bfffc4 	addi	r6,r6,-1
8111f468:	013fffc4 	movi	r4,-1
8111f46c:	003fac06 	br	8111f320 <__reset+0xfb0ff320>
8111f470:	01400044 	movi	r5,1
8111f474:	2909c83a 	sub	r4,r5,r4
8111f478:	00c006c4 	movi	r3,27
8111f47c:	19004b0e 	bge	r3,r4,8111f5ac <__divsf3+0x3d4>
8111f480:	114e703a 	and	r7,r2,r5
8111f484:	0009883a 	mov	r4,zero
8111f488:	000d883a 	mov	r6,zero
8111f48c:	003fa406 	br	8111f320 <__reset+0xfb0ff320>
8111f490:	9006917a 	slli	r3,r18,5
8111f494:	8822917a 	slli	r17,r17,5
8111f498:	1c40372e 	bgeu	r3,r17,8111f578 <__divsf3+0x3a0>
8111f49c:	31bfffc4 	addi	r6,r6,-1
8111f4a0:	010006c4 	movi	r4,27
8111f4a4:	000b883a 	mov	r5,zero
8111f4a8:	180f883a 	mov	r7,r3
8111f4ac:	294b883a 	add	r5,r5,r5
8111f4b0:	18c7883a 	add	r3,r3,r3
8111f4b4:	38000116 	blt	r7,zero,8111f4bc <__divsf3+0x2e4>
8111f4b8:	1c400236 	bltu	r3,r17,8111f4c4 <__divsf3+0x2ec>
8111f4bc:	1c47c83a 	sub	r3,r3,r17
8111f4c0:	29400054 	ori	r5,r5,1
8111f4c4:	213fffc4 	addi	r4,r4,-1
8111f4c8:	203ff71e 	bne	r4,zero,8111f4a8 <__reset+0xfb0ff4a8>
8111f4cc:	1806c03a 	cmpne	r3,r3,zero
8111f4d0:	1962b03a 	or	r17,r3,r5
8111f4d4:	31001fc4 	addi	r4,r6,127
8111f4d8:	013fe50e 	bge	zero,r4,8111f470 <__reset+0xfb0ff470>
8111f4dc:	88c001cc 	andi	r3,r17,7
8111f4e0:	18000426 	beq	r3,zero,8111f4f4 <__divsf3+0x31c>
8111f4e4:	88c003cc 	andi	r3,r17,15
8111f4e8:	01400104 	movi	r5,4
8111f4ec:	19400126 	beq	r3,r5,8111f4f4 <__divsf3+0x31c>
8111f4f0:	8963883a 	add	r17,r17,r5
8111f4f4:	88c2002c 	andhi	r3,r17,2048
8111f4f8:	18000426 	beq	r3,zero,8111f50c <__divsf3+0x334>
8111f4fc:	00fe0034 	movhi	r3,63488
8111f500:	18ffffc4 	addi	r3,r3,-1
8111f504:	31002004 	addi	r4,r6,128
8111f508:	88e2703a 	and	r17,r17,r3
8111f50c:	00c03f84 	movi	r3,254
8111f510:	193f8016 	blt	r3,r4,8111f314 <__reset+0xfb0ff314>
8111f514:	880c91ba 	slli	r6,r17,6
8111f518:	11c0004c 	andi	r7,r2,1
8111f51c:	300cd27a 	srli	r6,r6,9
8111f520:	003f7f06 	br	8111f320 <__reset+0xfb0ff320>
8111f524:	9080102c 	andhi	r2,r18,64
8111f528:	10000226 	beq	r2,zero,8111f534 <__divsf3+0x35c>
8111f52c:	8880102c 	andhi	r2,r17,64
8111f530:	10001826 	beq	r2,zero,8111f594 <__divsf3+0x3bc>
8111f534:	00802034 	movhi	r2,128
8111f538:	91801034 	orhi	r6,r18,64
8111f53c:	10bfffc4 	addi	r2,r2,-1
8111f540:	980f883a 	mov	r7,r19
8111f544:	308c703a 	and	r6,r6,r2
8111f548:	003fc706 	br	8111f468 <__reset+0xfb0ff468>
8111f54c:	008000c4 	movi	r2,3
8111f550:	b8802d26 	beq	r23,r2,8111f608 <__divsf3+0x430>
8111f554:	00c00044 	movi	r3,1
8111f558:	b005883a 	mov	r2,r22
8111f55c:	b8ffdd1e 	bne	r23,r3,8111f4d4 <__reset+0xfb0ff4d4>
8111f560:	11c0004c 	andi	r7,r2,1
8111f564:	0009883a 	mov	r4,zero
8111f568:	000d883a 	mov	r6,zero
8111f56c:	003f6c06 	br	8111f320 <__reset+0xfb0ff320>
8111f570:	9023883a 	mov	r17,r18
8111f574:	003f6406 	br	8111f308 <__reset+0xfb0ff308>
8111f578:	1c47c83a 	sub	r3,r3,r17
8111f57c:	01000684 	movi	r4,26
8111f580:	01400044 	movi	r5,1
8111f584:	003fc806 	br	8111f4a8 <__reset+0xfb0ff4a8>
8111f588:	9080102c 	andhi	r2,r18,64
8111f58c:	103fe926 	beq	r2,zero,8111f534 <__reset+0xfb0ff534>
8111f590:	0023883a 	mov	r17,zero
8111f594:	00802034 	movhi	r2,128
8111f598:	89801034 	orhi	r6,r17,64
8111f59c:	10bfffc4 	addi	r2,r2,-1
8111f5a0:	a80f883a 	mov	r7,r21
8111f5a4:	308c703a 	and	r6,r6,r2
8111f5a8:	003faf06 	br	8111f468 <__reset+0xfb0ff468>
8111f5ac:	01c00804 	movi	r7,32
8111f5b0:	390fc83a 	sub	r7,r7,r4
8111f5b4:	89ce983a 	sll	r7,r17,r7
8111f5b8:	890ad83a 	srl	r5,r17,r4
8111f5bc:	380ec03a 	cmpne	r7,r7,zero
8111f5c0:	29cab03a 	or	r5,r5,r7
8111f5c4:	28c001cc 	andi	r3,r5,7
8111f5c8:	18000426 	beq	r3,zero,8111f5dc <__divsf3+0x404>
8111f5cc:	28c003cc 	andi	r3,r5,15
8111f5d0:	01000104 	movi	r4,4
8111f5d4:	19000126 	beq	r3,r4,8111f5dc <__divsf3+0x404>
8111f5d8:	290b883a 	add	r5,r5,r4
8111f5dc:	28c1002c 	andhi	r3,r5,1024
8111f5e0:	18000426 	beq	r3,zero,8111f5f4 <__divsf3+0x41c>
8111f5e4:	11c0004c 	andi	r7,r2,1
8111f5e8:	01000044 	movi	r4,1
8111f5ec:	000d883a 	mov	r6,zero
8111f5f0:	003f4b06 	br	8111f320 <__reset+0xfb0ff320>
8111f5f4:	280a91ba 	slli	r5,r5,6
8111f5f8:	11c0004c 	andi	r7,r2,1
8111f5fc:	0009883a 	mov	r4,zero
8111f600:	280cd27a 	srli	r6,r5,9
8111f604:	003f4606 	br	8111f320 <__reset+0xfb0ff320>
8111f608:	00802034 	movhi	r2,128
8111f60c:	89801034 	orhi	r6,r17,64
8111f610:	10bfffc4 	addi	r2,r2,-1
8111f614:	b00f883a 	mov	r7,r22
8111f618:	308c703a 	and	r6,r6,r2
8111f61c:	003f9206 	br	8111f468 <__reset+0xfb0ff468>

8111f620 <__mulsf3>:
8111f620:	defff504 	addi	sp,sp,-44
8111f624:	de00012e 	bgeu	sp,et,8111f62c <__mulsf3+0xc>
8111f628:	003b68fa 	trap	3
8111f62c:	dc000115 	stw	r16,4(sp)
8111f630:	2020d5fa 	srli	r16,r4,23
8111f634:	dd400615 	stw	r21,24(sp)
8111f638:	202ad7fa 	srli	r21,r4,31
8111f63c:	dc800315 	stw	r18,12(sp)
8111f640:	04802034 	movhi	r18,128
8111f644:	df000915 	stw	fp,36(sp)
8111f648:	dd000515 	stw	r20,20(sp)
8111f64c:	94bfffc4 	addi	r18,r18,-1
8111f650:	dfc00a15 	stw	ra,40(sp)
8111f654:	ddc00815 	stw	r23,32(sp)
8111f658:	dd800715 	stw	r22,28(sp)
8111f65c:	dcc00415 	stw	r19,16(sp)
8111f660:	dc400215 	stw	r17,8(sp)
8111f664:	84003fcc 	andi	r16,r16,255
8111f668:	9124703a 	and	r18,r18,r4
8111f66c:	a829883a 	mov	r20,r21
8111f670:	af003fcc 	andi	fp,r21,255
8111f674:	80005426 	beq	r16,zero,8111f7c8 <__mulsf3+0x1a8>
8111f678:	00803fc4 	movi	r2,255
8111f67c:	80802f26 	beq	r16,r2,8111f73c <__mulsf3+0x11c>
8111f680:	91002034 	orhi	r4,r18,128
8111f684:	202490fa 	slli	r18,r4,3
8111f688:	843fe044 	addi	r16,r16,-127
8111f68c:	0023883a 	mov	r17,zero
8111f690:	002f883a 	mov	r23,zero
8111f694:	2804d5fa 	srli	r2,r5,23
8111f698:	282cd7fa 	srli	r22,r5,31
8111f69c:	01002034 	movhi	r4,128
8111f6a0:	213fffc4 	addi	r4,r4,-1
8111f6a4:	10803fcc 	andi	r2,r2,255
8111f6a8:	2166703a 	and	r19,r4,r5
8111f6ac:	b1803fcc 	andi	r6,r22,255
8111f6b0:	10004c26 	beq	r2,zero,8111f7e4 <__mulsf3+0x1c4>
8111f6b4:	00c03fc4 	movi	r3,255
8111f6b8:	10c04726 	beq	r2,r3,8111f7d8 <__mulsf3+0x1b8>
8111f6bc:	99002034 	orhi	r4,r19,128
8111f6c0:	202690fa 	slli	r19,r4,3
8111f6c4:	10bfe044 	addi	r2,r2,-127
8111f6c8:	0007883a 	mov	r3,zero
8111f6cc:	80a1883a 	add	r16,r16,r2
8111f6d0:	010003c4 	movi	r4,15
8111f6d4:	1c44b03a 	or	r2,r3,r17
8111f6d8:	b56af03a 	xor	r21,r22,r21
8111f6dc:	81c00044 	addi	r7,r16,1
8111f6e0:	20806b36 	bltu	r4,r2,8111f890 <__mulsf3+0x270>
8111f6e4:	100490ba 	slli	r2,r2,2
8111f6e8:	012044b4 	movhi	r4,33042
8111f6ec:	213dbf04 	addi	r4,r4,-2308
8111f6f0:	1105883a 	add	r2,r2,r4
8111f6f4:	10800017 	ldw	r2,0(r2)
8111f6f8:	1000683a 	jmp	r2
8111f6fc:	8111f890 	cmplti	r4,r16,18402
8111f700:	8111f750 	cmplti	r4,r16,18397
8111f704:	8111f750 	cmplti	r4,r16,18397
8111f708:	8111f74c 	andi	r4,r16,18397
8111f70c:	8111f874 	orhi	r4,r16,18401
8111f710:	8111f874 	orhi	r4,r16,18401
8111f714:	8111f860 	cmpeqi	r4,r16,18401
8111f718:	8111f74c 	andi	r4,r16,18397
8111f71c:	8111f874 	orhi	r4,r16,18401
8111f720:	8111f860 	cmpeqi	r4,r16,18401
8111f724:	8111f874 	orhi	r4,r16,18401
8111f728:	8111f74c 	andi	r4,r16,18397
8111f72c:	8111f880 	call	88111f88 <__reset+0x20f1f88>
8111f730:	8111f880 	call	88111f88 <__reset+0x20f1f88>
8111f734:	8111f880 	call	88111f88 <__reset+0x20f1f88>
8111f738:	8111f95c 	xori	r4,r16,18405
8111f73c:	90003b1e 	bne	r18,zero,8111f82c <__mulsf3+0x20c>
8111f740:	04400204 	movi	r17,8
8111f744:	05c00084 	movi	r23,2
8111f748:	003fd206 	br	8111f694 <__reset+0xfb0ff694>
8111f74c:	302b883a 	mov	r21,r6
8111f750:	00800084 	movi	r2,2
8111f754:	18802626 	beq	r3,r2,8111f7f0 <__mulsf3+0x1d0>
8111f758:	008000c4 	movi	r2,3
8111f75c:	1880ab26 	beq	r3,r2,8111fa0c <__mulsf3+0x3ec>
8111f760:	00800044 	movi	r2,1
8111f764:	1880a21e 	bne	r3,r2,8111f9f0 <__mulsf3+0x3d0>
8111f768:	a829883a 	mov	r20,r21
8111f76c:	0007883a 	mov	r3,zero
8111f770:	0009883a 	mov	r4,zero
8111f774:	18803fcc 	andi	r2,r3,255
8111f778:	100695fa 	slli	r3,r2,23
8111f77c:	a0803fcc 	andi	r2,r20,255
8111f780:	100a97fa 	slli	r5,r2,31
8111f784:	00802034 	movhi	r2,128
8111f788:	10bfffc4 	addi	r2,r2,-1
8111f78c:	2084703a 	and	r2,r4,r2
8111f790:	10c4b03a 	or	r2,r2,r3
8111f794:	1144b03a 	or	r2,r2,r5
8111f798:	dfc00a17 	ldw	ra,40(sp)
8111f79c:	df000917 	ldw	fp,36(sp)
8111f7a0:	ddc00817 	ldw	r23,32(sp)
8111f7a4:	dd800717 	ldw	r22,28(sp)
8111f7a8:	dd400617 	ldw	r21,24(sp)
8111f7ac:	dd000517 	ldw	r20,20(sp)
8111f7b0:	dcc00417 	ldw	r19,16(sp)
8111f7b4:	dc800317 	ldw	r18,12(sp)
8111f7b8:	dc400217 	ldw	r17,8(sp)
8111f7bc:	dc000117 	ldw	r16,4(sp)
8111f7c0:	dec00b04 	addi	sp,sp,44
8111f7c4:	f800283a 	ret
8111f7c8:	90000d1e 	bne	r18,zero,8111f800 <__mulsf3+0x1e0>
8111f7cc:	04400104 	movi	r17,4
8111f7d0:	05c00044 	movi	r23,1
8111f7d4:	003faf06 	br	8111f694 <__reset+0xfb0ff694>
8111f7d8:	9806c03a 	cmpne	r3,r19,zero
8111f7dc:	18c00084 	addi	r3,r3,2
8111f7e0:	003fba06 	br	8111f6cc <__reset+0xfb0ff6cc>
8111f7e4:	9800141e 	bne	r19,zero,8111f838 <__mulsf3+0x218>
8111f7e8:	00c00044 	movi	r3,1
8111f7ec:	003fb706 	br	8111f6cc <__reset+0xfb0ff6cc>
8111f7f0:	a829883a 	mov	r20,r21
8111f7f4:	00ffffc4 	movi	r3,-1
8111f7f8:	0009883a 	mov	r4,zero
8111f7fc:	003fdd06 	br	8111f774 <__reset+0xfb0ff774>
8111f800:	9009883a 	mov	r4,r18
8111f804:	d9400015 	stw	r5,0(sp)
8111f808:	112116c0 	call	8112116c <__clzsi2>
8111f80c:	10fffec4 	addi	r3,r2,-5
8111f810:	10801d84 	addi	r2,r2,118
8111f814:	90e4983a 	sll	r18,r18,r3
8111f818:	00a1c83a 	sub	r16,zero,r2
8111f81c:	0023883a 	mov	r17,zero
8111f820:	002f883a 	mov	r23,zero
8111f824:	d9400017 	ldw	r5,0(sp)
8111f828:	003f9a06 	br	8111f694 <__reset+0xfb0ff694>
8111f82c:	04400304 	movi	r17,12
8111f830:	05c000c4 	movi	r23,3
8111f834:	003f9706 	br	8111f694 <__reset+0xfb0ff694>
8111f838:	9809883a 	mov	r4,r19
8111f83c:	d9800015 	stw	r6,0(sp)
8111f840:	112116c0 	call	8112116c <__clzsi2>
8111f844:	10fffec4 	addi	r3,r2,-5
8111f848:	10801d84 	addi	r2,r2,118
8111f84c:	98e6983a 	sll	r19,r19,r3
8111f850:	0085c83a 	sub	r2,zero,r2
8111f854:	0007883a 	mov	r3,zero
8111f858:	d9800017 	ldw	r6,0(sp)
8111f85c:	003f9b06 	br	8111f6cc <__reset+0xfb0ff6cc>
8111f860:	01002034 	movhi	r4,128
8111f864:	0029883a 	mov	r20,zero
8111f868:	213fffc4 	addi	r4,r4,-1
8111f86c:	00ffffc4 	movi	r3,-1
8111f870:	003fc006 	br	8111f774 <__reset+0xfb0ff774>
8111f874:	9027883a 	mov	r19,r18
8111f878:	b807883a 	mov	r3,r23
8111f87c:	003fb406 	br	8111f750 <__reset+0xfb0ff750>
8111f880:	9027883a 	mov	r19,r18
8111f884:	e02b883a 	mov	r21,fp
8111f888:	b807883a 	mov	r3,r23
8111f88c:	003fb006 	br	8111f750 <__reset+0xfb0ff750>
8111f890:	9004d43a 	srli	r2,r18,16
8111f894:	9810d43a 	srli	r8,r19,16
8111f898:	94bfffcc 	andi	r18,r18,65535
8111f89c:	993fffcc 	andi	r4,r19,65535
8111f8a0:	910d383a 	mul	r6,r18,r4
8111f8a4:	20a7383a 	mul	r19,r4,r2
8111f8a8:	9225383a 	mul	r18,r18,r8
8111f8ac:	3006d43a 	srli	r3,r6,16
8111f8b0:	1211383a 	mul	r8,r2,r8
8111f8b4:	94e5883a 	add	r18,r18,r19
8111f8b8:	1c87883a 	add	r3,r3,r18
8111f8bc:	1cc0022e 	bgeu	r3,r19,8111f8c8 <__mulsf3+0x2a8>
8111f8c0:	00800074 	movhi	r2,1
8111f8c4:	4091883a 	add	r8,r8,r2
8111f8c8:	1804943a 	slli	r2,r3,16
8111f8cc:	31bfffcc 	andi	r6,r6,65535
8111f8d0:	1806d43a 	srli	r3,r3,16
8111f8d4:	1185883a 	add	r2,r2,r6
8111f8d8:	102691ba 	slli	r19,r2,6
8111f8dc:	1a07883a 	add	r3,r3,r8
8111f8e0:	1004d6ba 	srli	r2,r2,26
8111f8e4:	180891ba 	slli	r4,r3,6
8111f8e8:	9826c03a 	cmpne	r19,r19,zero
8111f8ec:	9884b03a 	or	r2,r19,r2
8111f8f0:	1126b03a 	or	r19,r2,r4
8111f8f4:	9882002c 	andhi	r2,r19,2048
8111f8f8:	10000426 	beq	r2,zero,8111f90c <__mulsf3+0x2ec>
8111f8fc:	9804d07a 	srli	r2,r19,1
8111f900:	9900004c 	andi	r4,r19,1
8111f904:	3821883a 	mov	r16,r7
8111f908:	1126b03a 	or	r19,r2,r4
8111f90c:	80c01fc4 	addi	r3,r16,127
8111f910:	00c0210e 	bge	zero,r3,8111f998 <__mulsf3+0x378>
8111f914:	988001cc 	andi	r2,r19,7
8111f918:	10000426 	beq	r2,zero,8111f92c <__mulsf3+0x30c>
8111f91c:	988003cc 	andi	r2,r19,15
8111f920:	01000104 	movi	r4,4
8111f924:	11000126 	beq	r2,r4,8111f92c <__mulsf3+0x30c>
8111f928:	9927883a 	add	r19,r19,r4
8111f92c:	9882002c 	andhi	r2,r19,2048
8111f930:	10000426 	beq	r2,zero,8111f944 <__mulsf3+0x324>
8111f934:	00be0034 	movhi	r2,63488
8111f938:	10bfffc4 	addi	r2,r2,-1
8111f93c:	80c02004 	addi	r3,r16,128
8111f940:	98a6703a 	and	r19,r19,r2
8111f944:	00803f84 	movi	r2,254
8111f948:	10ffa916 	blt	r2,r3,8111f7f0 <__reset+0xfb0ff7f0>
8111f94c:	980891ba 	slli	r4,r19,6
8111f950:	a829883a 	mov	r20,r21
8111f954:	2008d27a 	srli	r4,r4,9
8111f958:	003f8606 	br	8111f774 <__reset+0xfb0ff774>
8111f95c:	9080102c 	andhi	r2,r18,64
8111f960:	10000826 	beq	r2,zero,8111f984 <__mulsf3+0x364>
8111f964:	9880102c 	andhi	r2,r19,64
8111f968:	1000061e 	bne	r2,zero,8111f984 <__mulsf3+0x364>
8111f96c:	00802034 	movhi	r2,128
8111f970:	99001034 	orhi	r4,r19,64
8111f974:	10bfffc4 	addi	r2,r2,-1
8111f978:	b029883a 	mov	r20,r22
8111f97c:	2088703a 	and	r4,r4,r2
8111f980:	003fba06 	br	8111f86c <__reset+0xfb0ff86c>
8111f984:	00802034 	movhi	r2,128
8111f988:	91001034 	orhi	r4,r18,64
8111f98c:	10bfffc4 	addi	r2,r2,-1
8111f990:	2088703a 	and	r4,r4,r2
8111f994:	003fb506 	br	8111f86c <__reset+0xfb0ff86c>
8111f998:	00800044 	movi	r2,1
8111f99c:	10c7c83a 	sub	r3,r2,r3
8111f9a0:	008006c4 	movi	r2,27
8111f9a4:	10ff7016 	blt	r2,r3,8111f768 <__reset+0xfb0ff768>
8111f9a8:	00800804 	movi	r2,32
8111f9ac:	10c5c83a 	sub	r2,r2,r3
8111f9b0:	9884983a 	sll	r2,r19,r2
8111f9b4:	98c6d83a 	srl	r3,r19,r3
8111f9b8:	1004c03a 	cmpne	r2,r2,zero
8111f9bc:	1884b03a 	or	r2,r3,r2
8111f9c0:	10c001cc 	andi	r3,r2,7
8111f9c4:	18000426 	beq	r3,zero,8111f9d8 <__mulsf3+0x3b8>
8111f9c8:	10c003cc 	andi	r3,r2,15
8111f9cc:	01000104 	movi	r4,4
8111f9d0:	19000126 	beq	r3,r4,8111f9d8 <__mulsf3+0x3b8>
8111f9d4:	1105883a 	add	r2,r2,r4
8111f9d8:	10c1002c 	andhi	r3,r2,1024
8111f9dc:	18000626 	beq	r3,zero,8111f9f8 <__mulsf3+0x3d8>
8111f9e0:	a829883a 	mov	r20,r21
8111f9e4:	00c00044 	movi	r3,1
8111f9e8:	0009883a 	mov	r4,zero
8111f9ec:	003f6106 	br	8111f774 <__reset+0xfb0ff774>
8111f9f0:	3821883a 	mov	r16,r7
8111f9f4:	003fc506 	br	8111f90c <__reset+0xfb0ff90c>
8111f9f8:	100491ba 	slli	r2,r2,6
8111f9fc:	a829883a 	mov	r20,r21
8111fa00:	0007883a 	mov	r3,zero
8111fa04:	1008d27a 	srli	r4,r2,9
8111fa08:	003f5a06 	br	8111f774 <__reset+0xfb0ff774>
8111fa0c:	00802034 	movhi	r2,128
8111fa10:	99001034 	orhi	r4,r19,64
8111fa14:	10bfffc4 	addi	r2,r2,-1
8111fa18:	a829883a 	mov	r20,r21
8111fa1c:	2088703a 	and	r4,r4,r2
8111fa20:	003f9206 	br	8111f86c <__reset+0xfb0ff86c>

8111fa24 <__floatsisf>:
8111fa24:	defffd04 	addi	sp,sp,-12
8111fa28:	de00012e 	bgeu	sp,et,8111fa30 <__floatsisf+0xc>
8111fa2c:	003b68fa 	trap	3
8111fa30:	dfc00215 	stw	ra,8(sp)
8111fa34:	dc400115 	stw	r17,4(sp)
8111fa38:	dc000015 	stw	r16,0(sp)
8111fa3c:	20003526 	beq	r4,zero,8111fb14 <__floatsisf+0xf0>
8111fa40:	2021883a 	mov	r16,r4
8111fa44:	2022d7fa 	srli	r17,r4,31
8111fa48:	20003616 	blt	r4,zero,8111fb24 <__floatsisf+0x100>
8111fa4c:	8009883a 	mov	r4,r16
8111fa50:	112116c0 	call	8112116c <__clzsi2>
8111fa54:	00c02784 	movi	r3,158
8111fa58:	1887c83a 	sub	r3,r3,r2
8111fa5c:	01002584 	movi	r4,150
8111fa60:	20c01416 	blt	r4,r3,8111fab4 <__floatsisf+0x90>
8111fa64:	20c9c83a 	sub	r4,r4,r3
8111fa68:	8120983a 	sll	r16,r16,r4
8111fa6c:	00802034 	movhi	r2,128
8111fa70:	10bfffc4 	addi	r2,r2,-1
8111fa74:	8809883a 	mov	r4,r17
8111fa78:	80a0703a 	and	r16,r16,r2
8111fa7c:	18803fcc 	andi	r2,r3,255
8111fa80:	100695fa 	slli	r3,r2,23
8111fa84:	20803fcc 	andi	r2,r4,255
8111fa88:	100897fa 	slli	r4,r2,31
8111fa8c:	00802034 	movhi	r2,128
8111fa90:	10bfffc4 	addi	r2,r2,-1
8111fa94:	8084703a 	and	r2,r16,r2
8111fa98:	10c4b03a 	or	r2,r2,r3
8111fa9c:	1104b03a 	or	r2,r2,r4
8111faa0:	dfc00217 	ldw	ra,8(sp)
8111faa4:	dc400117 	ldw	r17,4(sp)
8111faa8:	dc000017 	ldw	r16,0(sp)
8111faac:	dec00304 	addi	sp,sp,12
8111fab0:	f800283a 	ret
8111fab4:	01002644 	movi	r4,153
8111fab8:	20c01c16 	blt	r4,r3,8111fb2c <__floatsisf+0x108>
8111fabc:	20c9c83a 	sub	r4,r4,r3
8111fac0:	8120983a 	sll	r16,r16,r4
8111fac4:	013f0034 	movhi	r4,64512
8111fac8:	213fffc4 	addi	r4,r4,-1
8111facc:	814001cc 	andi	r5,r16,7
8111fad0:	8108703a 	and	r4,r16,r4
8111fad4:	28000426 	beq	r5,zero,8111fae8 <__floatsisf+0xc4>
8111fad8:	840003cc 	andi	r16,r16,15
8111fadc:	01400104 	movi	r5,4
8111fae0:	81400126 	beq	r16,r5,8111fae8 <__floatsisf+0xc4>
8111fae4:	2149883a 	add	r4,r4,r5
8111fae8:	2141002c 	andhi	r5,r4,1024
8111faec:	28000526 	beq	r5,zero,8111fb04 <__floatsisf+0xe0>
8111faf0:	00c027c4 	movi	r3,159
8111faf4:	1887c83a 	sub	r3,r3,r2
8111faf8:	00bf0034 	movhi	r2,64512
8111fafc:	10bfffc4 	addi	r2,r2,-1
8111fb00:	2088703a 	and	r4,r4,r2
8111fb04:	202091ba 	slli	r16,r4,6
8111fb08:	8809883a 	mov	r4,r17
8111fb0c:	8020d27a 	srli	r16,r16,9
8111fb10:	003fda06 	br	8111fa7c <__reset+0xfb0ffa7c>
8111fb14:	0009883a 	mov	r4,zero
8111fb18:	0007883a 	mov	r3,zero
8111fb1c:	0021883a 	mov	r16,zero
8111fb20:	003fd606 	br	8111fa7c <__reset+0xfb0ffa7c>
8111fb24:	0121c83a 	sub	r16,zero,r4
8111fb28:	003fc806 	br	8111fa4c <__reset+0xfb0ffa4c>
8111fb2c:	01002e44 	movi	r4,185
8111fb30:	20c9c83a 	sub	r4,r4,r3
8111fb34:	01400144 	movi	r5,5
8111fb38:	8108983a 	sll	r4,r16,r4
8111fb3c:	288bc83a 	sub	r5,r5,r2
8111fb40:	8160d83a 	srl	r16,r16,r5
8111fb44:	2008c03a 	cmpne	r4,r4,zero
8111fb48:	8120b03a 	or	r16,r16,r4
8111fb4c:	003fdd06 	br	8111fac4 <__reset+0xfb0ffac4>

8111fb50 <__floatunsisf>:
8111fb50:	defffe04 	addi	sp,sp,-8
8111fb54:	de00012e 	bgeu	sp,et,8111fb5c <__floatunsisf+0xc>
8111fb58:	003b68fa 	trap	3
8111fb5c:	dfc00115 	stw	ra,4(sp)
8111fb60:	dc000015 	stw	r16,0(sp)
8111fb64:	20002c26 	beq	r4,zero,8111fc18 <__floatunsisf+0xc8>
8111fb68:	2021883a 	mov	r16,r4
8111fb6c:	112116c0 	call	8112116c <__clzsi2>
8111fb70:	00c02784 	movi	r3,158
8111fb74:	1887c83a 	sub	r3,r3,r2
8111fb78:	01002584 	movi	r4,150
8111fb7c:	20c00f16 	blt	r4,r3,8111fbbc <__floatunsisf+0x6c>
8111fb80:	20c9c83a 	sub	r4,r4,r3
8111fb84:	8108983a 	sll	r4,r16,r4
8111fb88:	00802034 	movhi	r2,128
8111fb8c:	10bfffc4 	addi	r2,r2,-1
8111fb90:	2088703a 	and	r4,r4,r2
8111fb94:	18803fcc 	andi	r2,r3,255
8111fb98:	100695fa 	slli	r3,r2,23
8111fb9c:	00802034 	movhi	r2,128
8111fba0:	10bfffc4 	addi	r2,r2,-1
8111fba4:	2084703a 	and	r2,r4,r2
8111fba8:	10c4b03a 	or	r2,r2,r3
8111fbac:	dfc00117 	ldw	ra,4(sp)
8111fbb0:	dc000017 	ldw	r16,0(sp)
8111fbb4:	dec00204 	addi	sp,sp,8
8111fbb8:	f800283a 	ret
8111fbbc:	01002644 	movi	r4,153
8111fbc0:	20c01816 	blt	r4,r3,8111fc24 <__floatunsisf+0xd4>
8111fbc4:	20c9c83a 	sub	r4,r4,r3
8111fbc8:	8108983a 	sll	r4,r16,r4
8111fbcc:	017f0034 	movhi	r5,64512
8111fbd0:	297fffc4 	addi	r5,r5,-1
8111fbd4:	218001cc 	andi	r6,r4,7
8111fbd8:	214a703a 	and	r5,r4,r5
8111fbdc:	30000426 	beq	r6,zero,8111fbf0 <__floatunsisf+0xa0>
8111fbe0:	210003cc 	andi	r4,r4,15
8111fbe4:	01800104 	movi	r6,4
8111fbe8:	21800126 	beq	r4,r6,8111fbf0 <__floatunsisf+0xa0>
8111fbec:	298b883a 	add	r5,r5,r6
8111fbf0:	2901002c 	andhi	r4,r5,1024
8111fbf4:	20000526 	beq	r4,zero,8111fc0c <__floatunsisf+0xbc>
8111fbf8:	00c027c4 	movi	r3,159
8111fbfc:	1887c83a 	sub	r3,r3,r2
8111fc00:	00bf0034 	movhi	r2,64512
8111fc04:	10bfffc4 	addi	r2,r2,-1
8111fc08:	288a703a 	and	r5,r5,r2
8111fc0c:	280891ba 	slli	r4,r5,6
8111fc10:	2008d27a 	srli	r4,r4,9
8111fc14:	003fdf06 	br	8111fb94 <__reset+0xfb0ffb94>
8111fc18:	0007883a 	mov	r3,zero
8111fc1c:	0009883a 	mov	r4,zero
8111fc20:	003fdc06 	br	8111fb94 <__reset+0xfb0ffb94>
8111fc24:	01402e44 	movi	r5,185
8111fc28:	28cbc83a 	sub	r5,r5,r3
8111fc2c:	01000144 	movi	r4,5
8111fc30:	2089c83a 	sub	r4,r4,r2
8111fc34:	814a983a 	sll	r5,r16,r5
8111fc38:	8108d83a 	srl	r4,r16,r4
8111fc3c:	2820c03a 	cmpne	r16,r5,zero
8111fc40:	2408b03a 	or	r4,r4,r16
8111fc44:	003fe106 	br	8111fbcc <__reset+0xfb0ffbcc>

8111fc48 <__gedf2>:
8111fc48:	2804d53a 	srli	r2,r5,20
8111fc4c:	3806d53a 	srli	r3,r7,20
8111fc50:	02000434 	movhi	r8,16
8111fc54:	423fffc4 	addi	r8,r8,-1
8111fc58:	1081ffcc 	andi	r2,r2,2047
8111fc5c:	0241ffc4 	movi	r9,2047
8111fc60:	2a14703a 	and	r10,r5,r8
8111fc64:	18c1ffcc 	andi	r3,r3,2047
8111fc68:	3a10703a 	and	r8,r7,r8
8111fc6c:	280ad7fa 	srli	r5,r5,31
8111fc70:	380ed7fa 	srli	r7,r7,31
8111fc74:	12401d26 	beq	r2,r9,8111fcec <__gedf2+0xa4>
8111fc78:	0241ffc4 	movi	r9,2047
8111fc7c:	1a401226 	beq	r3,r9,8111fcc8 <__gedf2+0x80>
8111fc80:	1000081e 	bne	r2,zero,8111fca4 <__gedf2+0x5c>
8111fc84:	2296b03a 	or	r11,r4,r10
8111fc88:	5813003a 	cmpeq	r9,r11,zero
8111fc8c:	1800091e 	bne	r3,zero,8111fcb4 <__gedf2+0x6c>
8111fc90:	3218b03a 	or	r12,r6,r8
8111fc94:	6000071e 	bne	r12,zero,8111fcb4 <__gedf2+0x6c>
8111fc98:	0005883a 	mov	r2,zero
8111fc9c:	5800101e 	bne	r11,zero,8111fce0 <__gedf2+0x98>
8111fca0:	f800283a 	ret
8111fca4:	18000c1e 	bne	r3,zero,8111fcd8 <__gedf2+0x90>
8111fca8:	3212b03a 	or	r9,r6,r8
8111fcac:	48000c26 	beq	r9,zero,8111fce0 <__gedf2+0x98>
8111fcb0:	0013883a 	mov	r9,zero
8111fcb4:	39c03fcc 	andi	r7,r7,255
8111fcb8:	48000826 	beq	r9,zero,8111fcdc <__gedf2+0x94>
8111fcbc:	38000926 	beq	r7,zero,8111fce4 <__gedf2+0x9c>
8111fcc0:	00800044 	movi	r2,1
8111fcc4:	f800283a 	ret
8111fcc8:	3212b03a 	or	r9,r6,r8
8111fccc:	483fec26 	beq	r9,zero,8111fc80 <__reset+0xfb0ffc80>
8111fcd0:	00bfff84 	movi	r2,-2
8111fcd4:	f800283a 	ret
8111fcd8:	39c03fcc 	andi	r7,r7,255
8111fcdc:	29c00626 	beq	r5,r7,8111fcf8 <__gedf2+0xb0>
8111fce0:	283ff726 	beq	r5,zero,8111fcc0 <__reset+0xfb0ffcc0>
8111fce4:	00bfffc4 	movi	r2,-1
8111fce8:	f800283a 	ret
8111fcec:	2292b03a 	or	r9,r4,r10
8111fcf0:	483fe126 	beq	r9,zero,8111fc78 <__reset+0xfb0ffc78>
8111fcf4:	003ff606 	br	8111fcd0 <__reset+0xfb0ffcd0>
8111fcf8:	18bff916 	blt	r3,r2,8111fce0 <__reset+0xfb0ffce0>
8111fcfc:	10c00316 	blt	r2,r3,8111fd0c <__gedf2+0xc4>
8111fd00:	42bff736 	bltu	r8,r10,8111fce0 <__reset+0xfb0ffce0>
8111fd04:	52000326 	beq	r10,r8,8111fd14 <__gedf2+0xcc>
8111fd08:	5200042e 	bgeu	r10,r8,8111fd1c <__gedf2+0xd4>
8111fd0c:	283fec1e 	bne	r5,zero,8111fcc0 <__reset+0xfb0ffcc0>
8111fd10:	003ff406 	br	8111fce4 <__reset+0xfb0ffce4>
8111fd14:	313ff236 	bltu	r6,r4,8111fce0 <__reset+0xfb0ffce0>
8111fd18:	21bffc36 	bltu	r4,r6,8111fd0c <__reset+0xfb0ffd0c>
8111fd1c:	0005883a 	mov	r2,zero
8111fd20:	f800283a 	ret

8111fd24 <__muldf3>:
8111fd24:	defff304 	addi	sp,sp,-52
8111fd28:	2804d53a 	srli	r2,r5,20
8111fd2c:	de00012e 	bgeu	sp,et,8111fd34 <__muldf3+0x10>
8111fd30:	003b68fa 	trap	3
8111fd34:	dd800915 	stw	r22,36(sp)
8111fd38:	282cd7fa 	srli	r22,r5,31
8111fd3c:	dc000315 	stw	r16,12(sp)
8111fd40:	04000434 	movhi	r16,16
8111fd44:	dd400815 	stw	r21,32(sp)
8111fd48:	dc800515 	stw	r18,20(sp)
8111fd4c:	843fffc4 	addi	r16,r16,-1
8111fd50:	dfc00c15 	stw	ra,48(sp)
8111fd54:	df000b15 	stw	fp,44(sp)
8111fd58:	ddc00a15 	stw	r23,40(sp)
8111fd5c:	dd000715 	stw	r20,28(sp)
8111fd60:	dcc00615 	stw	r19,24(sp)
8111fd64:	dc400415 	stw	r17,16(sp)
8111fd68:	1481ffcc 	andi	r18,r2,2047
8111fd6c:	2c20703a 	and	r16,r5,r16
8111fd70:	b02b883a 	mov	r21,r22
8111fd74:	b2403fcc 	andi	r9,r22,255
8111fd78:	90006026 	beq	r18,zero,8111fefc <__muldf3+0x1d8>
8111fd7c:	0081ffc4 	movi	r2,2047
8111fd80:	2029883a 	mov	r20,r4
8111fd84:	90803626 	beq	r18,r2,8111fe60 <__muldf3+0x13c>
8111fd88:	80800434 	orhi	r2,r16,16
8111fd8c:	100490fa 	slli	r2,r2,3
8111fd90:	2020d77a 	srli	r16,r4,29
8111fd94:	202890fa 	slli	r20,r4,3
8111fd98:	94bf0044 	addi	r18,r18,-1023
8111fd9c:	80a0b03a 	or	r16,r16,r2
8111fda0:	0027883a 	mov	r19,zero
8111fda4:	0039883a 	mov	fp,zero
8111fda8:	3804d53a 	srli	r2,r7,20
8111fdac:	382ed7fa 	srli	r23,r7,31
8111fdb0:	04400434 	movhi	r17,16
8111fdb4:	8c7fffc4 	addi	r17,r17,-1
8111fdb8:	1081ffcc 	andi	r2,r2,2047
8111fdbc:	3011883a 	mov	r8,r6
8111fdc0:	3c62703a 	and	r17,r7,r17
8111fdc4:	ba803fcc 	andi	r10,r23,255
8111fdc8:	10006d26 	beq	r2,zero,8111ff80 <__muldf3+0x25c>
8111fdcc:	00c1ffc4 	movi	r3,2047
8111fdd0:	10c06526 	beq	r2,r3,8111ff68 <__muldf3+0x244>
8111fdd4:	88c00434 	orhi	r3,r17,16
8111fdd8:	180690fa 	slli	r3,r3,3
8111fddc:	3022d77a 	srli	r17,r6,29
8111fde0:	301090fa 	slli	r8,r6,3
8111fde4:	10bf0044 	addi	r2,r2,-1023
8111fde8:	88e2b03a 	or	r17,r17,r3
8111fdec:	000b883a 	mov	r5,zero
8111fdf0:	9085883a 	add	r2,r18,r2
8111fdf4:	2cc8b03a 	or	r4,r5,r19
8111fdf8:	00c003c4 	movi	r3,15
8111fdfc:	bdacf03a 	xor	r22,r23,r22
8111fe00:	12c00044 	addi	r11,r2,1
8111fe04:	19009936 	bltu	r3,r4,8112006c <__muldf3+0x348>
8111fe08:	200890ba 	slli	r4,r4,2
8111fe0c:	00e044b4 	movhi	r3,33042
8111fe10:	18ff8804 	addi	r3,r3,-480
8111fe14:	20c9883a 	add	r4,r4,r3
8111fe18:	20c00017 	ldw	r3,0(r4)
8111fe1c:	1800683a 	jmp	r3
8111fe20:	8112006c 	andhi	r4,r16,18433
8111fe24:	8111fe80 	call	88111fe8 <__reset+0x20f1fe8>
8111fe28:	8111fe80 	call	88111fe8 <__reset+0x20f1fe8>
8111fe2c:	8111fe7c 	xorhi	r4,r16,18425
8111fe30:	81120048 	cmpgei	r4,r16,18433
8111fe34:	81120048 	cmpgei	r4,r16,18433
8111fe38:	81120030 	cmpltui	r4,r16,18432
8111fe3c:	8111fe7c 	xorhi	r4,r16,18425
8111fe40:	81120048 	cmpgei	r4,r16,18433
8111fe44:	81120030 	cmpltui	r4,r16,18432
8111fe48:	81120048 	cmpgei	r4,r16,18433
8111fe4c:	8111fe7c 	xorhi	r4,r16,18425
8111fe50:	81120058 	cmpnei	r4,r16,18433
8111fe54:	81120058 	cmpnei	r4,r16,18433
8111fe58:	81120058 	cmpnei	r4,r16,18433
8111fe5c:	81120274 	orhi	r4,r16,18441
8111fe60:	2404b03a 	or	r2,r4,r16
8111fe64:	10006f1e 	bne	r2,zero,81120024 <__muldf3+0x300>
8111fe68:	04c00204 	movi	r19,8
8111fe6c:	0021883a 	mov	r16,zero
8111fe70:	0029883a 	mov	r20,zero
8111fe74:	07000084 	movi	fp,2
8111fe78:	003fcb06 	br	8111fda8 <__reset+0xfb0ffda8>
8111fe7c:	502d883a 	mov	r22,r10
8111fe80:	00800084 	movi	r2,2
8111fe84:	28805726 	beq	r5,r2,8111ffe4 <__muldf3+0x2c0>
8111fe88:	008000c4 	movi	r2,3
8111fe8c:	28816626 	beq	r5,r2,81120428 <__muldf3+0x704>
8111fe90:	00800044 	movi	r2,1
8111fe94:	2881411e 	bne	r5,r2,8112039c <__muldf3+0x678>
8111fe98:	b02b883a 	mov	r21,r22
8111fe9c:	0005883a 	mov	r2,zero
8111fea0:	000b883a 	mov	r5,zero
8111fea4:	0029883a 	mov	r20,zero
8111fea8:	1004953a 	slli	r2,r2,20
8111feac:	a8c03fcc 	andi	r3,r21,255
8111feb0:	04400434 	movhi	r17,16
8111feb4:	8c7fffc4 	addi	r17,r17,-1
8111feb8:	180697fa 	slli	r3,r3,31
8111febc:	2c4a703a 	and	r5,r5,r17
8111fec0:	288ab03a 	or	r5,r5,r2
8111fec4:	28c6b03a 	or	r3,r5,r3
8111fec8:	a005883a 	mov	r2,r20
8111fecc:	dfc00c17 	ldw	ra,48(sp)
8111fed0:	df000b17 	ldw	fp,44(sp)
8111fed4:	ddc00a17 	ldw	r23,40(sp)
8111fed8:	dd800917 	ldw	r22,36(sp)
8111fedc:	dd400817 	ldw	r21,32(sp)
8111fee0:	dd000717 	ldw	r20,28(sp)
8111fee4:	dcc00617 	ldw	r19,24(sp)
8111fee8:	dc800517 	ldw	r18,20(sp)
8111feec:	dc400417 	ldw	r17,16(sp)
8111fef0:	dc000317 	ldw	r16,12(sp)
8111fef4:	dec00d04 	addi	sp,sp,52
8111fef8:	f800283a 	ret
8111fefc:	2404b03a 	or	r2,r4,r16
8111ff00:	2027883a 	mov	r19,r4
8111ff04:	10004226 	beq	r2,zero,81120010 <__muldf3+0x2ec>
8111ff08:	8000fc26 	beq	r16,zero,811202fc <__muldf3+0x5d8>
8111ff0c:	8009883a 	mov	r4,r16
8111ff10:	d9800215 	stw	r6,8(sp)
8111ff14:	d9c00015 	stw	r7,0(sp)
8111ff18:	da400115 	stw	r9,4(sp)
8111ff1c:	112116c0 	call	8112116c <__clzsi2>
8111ff20:	d9800217 	ldw	r6,8(sp)
8111ff24:	d9c00017 	ldw	r7,0(sp)
8111ff28:	da400117 	ldw	r9,4(sp)
8111ff2c:	113ffd44 	addi	r4,r2,-11
8111ff30:	00c00704 	movi	r3,28
8111ff34:	1900ed16 	blt	r3,r4,811202ec <__muldf3+0x5c8>
8111ff38:	00c00744 	movi	r3,29
8111ff3c:	147ffe04 	addi	r17,r2,-8
8111ff40:	1907c83a 	sub	r3,r3,r4
8111ff44:	8460983a 	sll	r16,r16,r17
8111ff48:	98c6d83a 	srl	r3,r19,r3
8111ff4c:	9c68983a 	sll	r20,r19,r17
8111ff50:	1c20b03a 	or	r16,r3,r16
8111ff54:	1080fcc4 	addi	r2,r2,1011
8111ff58:	00a5c83a 	sub	r18,zero,r2
8111ff5c:	0027883a 	mov	r19,zero
8111ff60:	0039883a 	mov	fp,zero
8111ff64:	003f9006 	br	8111fda8 <__reset+0xfb0ffda8>
8111ff68:	3446b03a 	or	r3,r6,r17
8111ff6c:	1800261e 	bne	r3,zero,81120008 <__muldf3+0x2e4>
8111ff70:	0023883a 	mov	r17,zero
8111ff74:	0011883a 	mov	r8,zero
8111ff78:	01400084 	movi	r5,2
8111ff7c:	003f9c06 	br	8111fdf0 <__reset+0xfb0ffdf0>
8111ff80:	3446b03a 	or	r3,r6,r17
8111ff84:	18001c26 	beq	r3,zero,8111fff8 <__muldf3+0x2d4>
8111ff88:	8800ce26 	beq	r17,zero,811202c4 <__muldf3+0x5a0>
8111ff8c:	8809883a 	mov	r4,r17
8111ff90:	d9800215 	stw	r6,8(sp)
8111ff94:	da400115 	stw	r9,4(sp)
8111ff98:	da800015 	stw	r10,0(sp)
8111ff9c:	112116c0 	call	8112116c <__clzsi2>
8111ffa0:	d9800217 	ldw	r6,8(sp)
8111ffa4:	da400117 	ldw	r9,4(sp)
8111ffa8:	da800017 	ldw	r10,0(sp)
8111ffac:	113ffd44 	addi	r4,r2,-11
8111ffb0:	00c00704 	movi	r3,28
8111ffb4:	1900bf16 	blt	r3,r4,811202b4 <__muldf3+0x590>
8111ffb8:	00c00744 	movi	r3,29
8111ffbc:	123ffe04 	addi	r8,r2,-8
8111ffc0:	1907c83a 	sub	r3,r3,r4
8111ffc4:	8a22983a 	sll	r17,r17,r8
8111ffc8:	30c6d83a 	srl	r3,r6,r3
8111ffcc:	3210983a 	sll	r8,r6,r8
8111ffd0:	1c62b03a 	or	r17,r3,r17
8111ffd4:	1080fcc4 	addi	r2,r2,1011
8111ffd8:	0085c83a 	sub	r2,zero,r2
8111ffdc:	000b883a 	mov	r5,zero
8111ffe0:	003f8306 	br	8111fdf0 <__reset+0xfb0ffdf0>
8111ffe4:	b02b883a 	mov	r21,r22
8111ffe8:	0081ffc4 	movi	r2,2047
8111ffec:	000b883a 	mov	r5,zero
8111fff0:	0029883a 	mov	r20,zero
8111fff4:	003fac06 	br	8111fea8 <__reset+0xfb0ffea8>
8111fff8:	0023883a 	mov	r17,zero
8111fffc:	0011883a 	mov	r8,zero
81120000:	01400044 	movi	r5,1
81120004:	003f7a06 	br	8111fdf0 <__reset+0xfb0ffdf0>
81120008:	014000c4 	movi	r5,3
8112000c:	003f7806 	br	8111fdf0 <__reset+0xfb0ffdf0>
81120010:	04c00104 	movi	r19,4
81120014:	0021883a 	mov	r16,zero
81120018:	0029883a 	mov	r20,zero
8112001c:	07000044 	movi	fp,1
81120020:	003f6106 	br	8111fda8 <__reset+0xfb0ffda8>
81120024:	04c00304 	movi	r19,12
81120028:	070000c4 	movi	fp,3
8112002c:	003f5e06 	br	8111fda8 <__reset+0xfb0ffda8>
81120030:	01400434 	movhi	r5,16
81120034:	002b883a 	mov	r21,zero
81120038:	297fffc4 	addi	r5,r5,-1
8112003c:	053fffc4 	movi	r20,-1
81120040:	0081ffc4 	movi	r2,2047
81120044:	003f9806 	br	8111fea8 <__reset+0xfb0ffea8>
81120048:	8023883a 	mov	r17,r16
8112004c:	a011883a 	mov	r8,r20
81120050:	e00b883a 	mov	r5,fp
81120054:	003f8a06 	br	8111fe80 <__reset+0xfb0ffe80>
81120058:	8023883a 	mov	r17,r16
8112005c:	a011883a 	mov	r8,r20
81120060:	482d883a 	mov	r22,r9
81120064:	e00b883a 	mov	r5,fp
81120068:	003f8506 	br	8111fe80 <__reset+0xfb0ffe80>
8112006c:	a00ad43a 	srli	r5,r20,16
81120070:	401ad43a 	srli	r13,r8,16
81120074:	a53fffcc 	andi	r20,r20,65535
81120078:	423fffcc 	andi	r8,r8,65535
8112007c:	4519383a 	mul	r12,r8,r20
81120080:	4147383a 	mul	r3,r8,r5
81120084:	6d09383a 	mul	r4,r13,r20
81120088:	600cd43a 	srli	r6,r12,16
8112008c:	2b5d383a 	mul	r14,r5,r13
81120090:	20c9883a 	add	r4,r4,r3
81120094:	310d883a 	add	r6,r6,r4
81120098:	30c0022e 	bgeu	r6,r3,811200a4 <__muldf3+0x380>
8112009c:	00c00074 	movhi	r3,1
811200a0:	70dd883a 	add	r14,r14,r3
811200a4:	8826d43a 	srli	r19,r17,16
811200a8:	8bffffcc 	andi	r15,r17,65535
811200ac:	7d23383a 	mul	r17,r15,r20
811200b0:	7949383a 	mul	r4,r15,r5
811200b4:	9d29383a 	mul	r20,r19,r20
811200b8:	8814d43a 	srli	r10,r17,16
811200bc:	3012943a 	slli	r9,r6,16
811200c0:	a129883a 	add	r20,r20,r4
811200c4:	633fffcc 	andi	r12,r12,65535
811200c8:	5515883a 	add	r10,r10,r20
811200cc:	3006d43a 	srli	r3,r6,16
811200d0:	4b13883a 	add	r9,r9,r12
811200d4:	2ccb383a 	mul	r5,r5,r19
811200d8:	5100022e 	bgeu	r10,r4,811200e4 <__muldf3+0x3c0>
811200dc:	01000074 	movhi	r4,1
811200e0:	290b883a 	add	r5,r5,r4
811200e4:	802ad43a 	srli	r21,r16,16
811200e8:	843fffcc 	andi	r16,r16,65535
811200ec:	440d383a 	mul	r6,r8,r16
811200f0:	4565383a 	mul	r18,r8,r21
811200f4:	8349383a 	mul	r4,r16,r13
811200f8:	500e943a 	slli	r7,r10,16
811200fc:	3010d43a 	srli	r8,r6,16
81120100:	5028d43a 	srli	r20,r10,16
81120104:	2489883a 	add	r4,r4,r18
81120108:	8abfffcc 	andi	r10,r17,65535
8112010c:	3a95883a 	add	r10,r7,r10
81120110:	4119883a 	add	r12,r8,r4
81120114:	a169883a 	add	r20,r20,r5
81120118:	1a87883a 	add	r3,r3,r10
8112011c:	6d5b383a 	mul	r13,r13,r21
81120120:	6480022e 	bgeu	r12,r18,8112012c <__muldf3+0x408>
81120124:	01000074 	movhi	r4,1
81120128:	691b883a 	add	r13,r13,r4
8112012c:	7c25383a 	mul	r18,r15,r16
81120130:	7d4b383a 	mul	r5,r15,r21
81120134:	84cf383a 	mul	r7,r16,r19
81120138:	901ed43a 	srli	r15,r18,16
8112013c:	6008d43a 	srli	r4,r12,16
81120140:	6010943a 	slli	r8,r12,16
81120144:	394f883a 	add	r7,r7,r5
81120148:	333fffcc 	andi	r12,r6,65535
8112014c:	79df883a 	add	r15,r15,r7
81120150:	235b883a 	add	r13,r4,r13
81120154:	9d63383a 	mul	r17,r19,r21
81120158:	4309883a 	add	r4,r8,r12
8112015c:	7940022e 	bgeu	r15,r5,81120168 <__muldf3+0x444>
81120160:	01400074 	movhi	r5,1
81120164:	8963883a 	add	r17,r17,r5
81120168:	780a943a 	slli	r5,r15,16
8112016c:	91bfffcc 	andi	r6,r18,65535
81120170:	70c7883a 	add	r3,r14,r3
81120174:	298d883a 	add	r6,r5,r6
81120178:	1a8f803a 	cmpltu	r7,r3,r10
8112017c:	350b883a 	add	r5,r6,r20
81120180:	20c7883a 	add	r3,r4,r3
81120184:	3955883a 	add	r10,r7,r5
81120188:	1909803a 	cmpltu	r4,r3,r4
8112018c:	6a91883a 	add	r8,r13,r10
81120190:	780cd43a 	srli	r6,r15,16
81120194:	2219883a 	add	r12,r4,r8
81120198:	2d0b803a 	cmpltu	r5,r5,r20
8112019c:	51cf803a 	cmpltu	r7,r10,r7
811201a0:	29ceb03a 	or	r7,r5,r7
811201a4:	4351803a 	cmpltu	r8,r8,r13
811201a8:	610b803a 	cmpltu	r5,r12,r4
811201ac:	4148b03a 	or	r4,r8,r5
811201b0:	398f883a 	add	r7,r7,r6
811201b4:	3909883a 	add	r4,r7,r4
811201b8:	1810927a 	slli	r8,r3,9
811201bc:	2449883a 	add	r4,r4,r17
811201c0:	2008927a 	slli	r4,r4,9
811201c4:	6022d5fa 	srli	r17,r12,23
811201c8:	1806d5fa 	srli	r3,r3,23
811201cc:	4252b03a 	or	r9,r8,r9
811201d0:	600a927a 	slli	r5,r12,9
811201d4:	4810c03a 	cmpne	r8,r9,zero
811201d8:	2462b03a 	or	r17,r4,r17
811201dc:	40c6b03a 	or	r3,r8,r3
811201e0:	8900402c 	andhi	r4,r17,256
811201e4:	1950b03a 	or	r8,r3,r5
811201e8:	20000726 	beq	r4,zero,81120208 <__muldf3+0x4e4>
811201ec:	4006d07a 	srli	r3,r8,1
811201f0:	880497fa 	slli	r2,r17,31
811201f4:	4200004c 	andi	r8,r8,1
811201f8:	8822d07a 	srli	r17,r17,1
811201fc:	1a10b03a 	or	r8,r3,r8
81120200:	1210b03a 	or	r8,r2,r8
81120204:	5805883a 	mov	r2,r11
81120208:	1140ffc4 	addi	r5,r2,1023
8112020c:	0140440e 	bge	zero,r5,81120320 <__muldf3+0x5fc>
81120210:	40c001cc 	andi	r3,r8,7
81120214:	18000726 	beq	r3,zero,81120234 <__muldf3+0x510>
81120218:	40c003cc 	andi	r3,r8,15
8112021c:	01000104 	movi	r4,4
81120220:	19000426 	beq	r3,r4,81120234 <__muldf3+0x510>
81120224:	4107883a 	add	r3,r8,r4
81120228:	1a11803a 	cmpltu	r8,r3,r8
8112022c:	8a23883a 	add	r17,r17,r8
81120230:	1811883a 	mov	r8,r3
81120234:	88c0402c 	andhi	r3,r17,256
81120238:	18000426 	beq	r3,zero,8112024c <__muldf3+0x528>
8112023c:	11410004 	addi	r5,r2,1024
81120240:	00bfc034 	movhi	r2,65280
81120244:	10bfffc4 	addi	r2,r2,-1
81120248:	88a2703a 	and	r17,r17,r2
8112024c:	0081ff84 	movi	r2,2046
81120250:	117f6416 	blt	r2,r5,8111ffe4 <__reset+0xfb0fffe4>
81120254:	8828977a 	slli	r20,r17,29
81120258:	4010d0fa 	srli	r8,r8,3
8112025c:	8822927a 	slli	r17,r17,9
81120260:	2881ffcc 	andi	r2,r5,2047
81120264:	a228b03a 	or	r20,r20,r8
81120268:	880ad33a 	srli	r5,r17,12
8112026c:	b02b883a 	mov	r21,r22
81120270:	003f0d06 	br	8111fea8 <__reset+0xfb0ffea8>
81120274:	8080022c 	andhi	r2,r16,8
81120278:	10000926 	beq	r2,zero,811202a0 <__muldf3+0x57c>
8112027c:	8880022c 	andhi	r2,r17,8
81120280:	1000071e 	bne	r2,zero,811202a0 <__muldf3+0x57c>
81120284:	00800434 	movhi	r2,16
81120288:	89400234 	orhi	r5,r17,8
8112028c:	10bfffc4 	addi	r2,r2,-1
81120290:	b82b883a 	mov	r21,r23
81120294:	288a703a 	and	r5,r5,r2
81120298:	4029883a 	mov	r20,r8
8112029c:	003f6806 	br	81120040 <__reset+0xfb100040>
811202a0:	00800434 	movhi	r2,16
811202a4:	81400234 	orhi	r5,r16,8
811202a8:	10bfffc4 	addi	r2,r2,-1
811202ac:	288a703a 	and	r5,r5,r2
811202b0:	003f6306 	br	81120040 <__reset+0xfb100040>
811202b4:	147ff604 	addi	r17,r2,-40
811202b8:	3462983a 	sll	r17,r6,r17
811202bc:	0011883a 	mov	r8,zero
811202c0:	003f4406 	br	8111ffd4 <__reset+0xfb0fffd4>
811202c4:	3009883a 	mov	r4,r6
811202c8:	d9800215 	stw	r6,8(sp)
811202cc:	da400115 	stw	r9,4(sp)
811202d0:	da800015 	stw	r10,0(sp)
811202d4:	112116c0 	call	8112116c <__clzsi2>
811202d8:	10800804 	addi	r2,r2,32
811202dc:	da800017 	ldw	r10,0(sp)
811202e0:	da400117 	ldw	r9,4(sp)
811202e4:	d9800217 	ldw	r6,8(sp)
811202e8:	003f3006 	br	8111ffac <__reset+0xfb0fffac>
811202ec:	143ff604 	addi	r16,r2,-40
811202f0:	9c20983a 	sll	r16,r19,r16
811202f4:	0029883a 	mov	r20,zero
811202f8:	003f1606 	br	8111ff54 <__reset+0xfb0fff54>
811202fc:	d9800215 	stw	r6,8(sp)
81120300:	d9c00015 	stw	r7,0(sp)
81120304:	da400115 	stw	r9,4(sp)
81120308:	112116c0 	call	8112116c <__clzsi2>
8112030c:	10800804 	addi	r2,r2,32
81120310:	da400117 	ldw	r9,4(sp)
81120314:	d9c00017 	ldw	r7,0(sp)
81120318:	d9800217 	ldw	r6,8(sp)
8112031c:	003f0306 	br	8111ff2c <__reset+0xfb0fff2c>
81120320:	00c00044 	movi	r3,1
81120324:	1947c83a 	sub	r3,r3,r5
81120328:	00800e04 	movi	r2,56
8112032c:	10feda16 	blt	r2,r3,8111fe98 <__reset+0xfb0ffe98>
81120330:	008007c4 	movi	r2,31
81120334:	10c01b16 	blt	r2,r3,811203a4 <__muldf3+0x680>
81120338:	00800804 	movi	r2,32
8112033c:	10c5c83a 	sub	r2,r2,r3
81120340:	888a983a 	sll	r5,r17,r2
81120344:	40c8d83a 	srl	r4,r8,r3
81120348:	4084983a 	sll	r2,r8,r2
8112034c:	88e2d83a 	srl	r17,r17,r3
81120350:	2906b03a 	or	r3,r5,r4
81120354:	1004c03a 	cmpne	r2,r2,zero
81120358:	1886b03a 	or	r3,r3,r2
8112035c:	188001cc 	andi	r2,r3,7
81120360:	10000726 	beq	r2,zero,81120380 <__muldf3+0x65c>
81120364:	188003cc 	andi	r2,r3,15
81120368:	01000104 	movi	r4,4
8112036c:	11000426 	beq	r2,r4,81120380 <__muldf3+0x65c>
81120370:	1805883a 	mov	r2,r3
81120374:	10c00104 	addi	r3,r2,4
81120378:	1885803a 	cmpltu	r2,r3,r2
8112037c:	88a3883a 	add	r17,r17,r2
81120380:	8880202c 	andhi	r2,r17,128
81120384:	10001c26 	beq	r2,zero,811203f8 <__muldf3+0x6d4>
81120388:	b02b883a 	mov	r21,r22
8112038c:	00800044 	movi	r2,1
81120390:	000b883a 	mov	r5,zero
81120394:	0029883a 	mov	r20,zero
81120398:	003ec306 	br	8111fea8 <__reset+0xfb0ffea8>
8112039c:	5805883a 	mov	r2,r11
811203a0:	003f9906 	br	81120208 <__reset+0xfb100208>
811203a4:	00bff844 	movi	r2,-31
811203a8:	1145c83a 	sub	r2,r2,r5
811203ac:	8888d83a 	srl	r4,r17,r2
811203b0:	00800804 	movi	r2,32
811203b4:	18801a26 	beq	r3,r2,81120420 <__muldf3+0x6fc>
811203b8:	00801004 	movi	r2,64
811203bc:	10c5c83a 	sub	r2,r2,r3
811203c0:	8884983a 	sll	r2,r17,r2
811203c4:	1204b03a 	or	r2,r2,r8
811203c8:	1004c03a 	cmpne	r2,r2,zero
811203cc:	2084b03a 	or	r2,r4,r2
811203d0:	144001cc 	andi	r17,r2,7
811203d4:	88000d1e 	bne	r17,zero,8112040c <__muldf3+0x6e8>
811203d8:	000b883a 	mov	r5,zero
811203dc:	1028d0fa 	srli	r20,r2,3
811203e0:	b02b883a 	mov	r21,r22
811203e4:	0005883a 	mov	r2,zero
811203e8:	a468b03a 	or	r20,r20,r17
811203ec:	003eae06 	br	8111fea8 <__reset+0xfb0ffea8>
811203f0:	1007883a 	mov	r3,r2
811203f4:	0023883a 	mov	r17,zero
811203f8:	880a927a 	slli	r5,r17,9
811203fc:	1805883a 	mov	r2,r3
81120400:	8822977a 	slli	r17,r17,29
81120404:	280ad33a 	srli	r5,r5,12
81120408:	003ff406 	br	811203dc <__reset+0xfb1003dc>
8112040c:	10c003cc 	andi	r3,r2,15
81120410:	01000104 	movi	r4,4
81120414:	193ff626 	beq	r3,r4,811203f0 <__reset+0xfb1003f0>
81120418:	0023883a 	mov	r17,zero
8112041c:	003fd506 	br	81120374 <__reset+0xfb100374>
81120420:	0005883a 	mov	r2,zero
81120424:	003fe706 	br	811203c4 <__reset+0xfb1003c4>
81120428:	00800434 	movhi	r2,16
8112042c:	89400234 	orhi	r5,r17,8
81120430:	10bfffc4 	addi	r2,r2,-1
81120434:	b02b883a 	mov	r21,r22
81120438:	288a703a 	and	r5,r5,r2
8112043c:	4029883a 	mov	r20,r8
81120440:	003eff06 	br	81120040 <__reset+0xfb100040>

81120444 <__subdf3>:
81120444:	02000434 	movhi	r8,16
81120448:	423fffc4 	addi	r8,r8,-1
8112044c:	defffb04 	addi	sp,sp,-20
81120450:	2a14703a 	and	r10,r5,r8
81120454:	3812d53a 	srli	r9,r7,20
81120458:	3a10703a 	and	r8,r7,r8
8112045c:	de00012e 	bgeu	sp,et,81120464 <__subdf3+0x20>
81120460:	003b68fa 	trap	3
81120464:	2006d77a 	srli	r3,r4,29
81120468:	3004d77a 	srli	r2,r6,29
8112046c:	dc000015 	stw	r16,0(sp)
81120470:	501490fa 	slli	r10,r10,3
81120474:	2820d53a 	srli	r16,r5,20
81120478:	401090fa 	slli	r8,r8,3
8112047c:	dc800215 	stw	r18,8(sp)
81120480:	dc400115 	stw	r17,4(sp)
81120484:	dfc00415 	stw	ra,16(sp)
81120488:	202290fa 	slli	r17,r4,3
8112048c:	dcc00315 	stw	r19,12(sp)
81120490:	4a41ffcc 	andi	r9,r9,2047
81120494:	0101ffc4 	movi	r4,2047
81120498:	2824d7fa 	srli	r18,r5,31
8112049c:	8401ffcc 	andi	r16,r16,2047
811204a0:	50c6b03a 	or	r3,r10,r3
811204a4:	380ed7fa 	srli	r7,r7,31
811204a8:	408ab03a 	or	r5,r8,r2
811204ac:	300c90fa 	slli	r6,r6,3
811204b0:	49009626 	beq	r9,r4,8112070c <__subdf3+0x2c8>
811204b4:	39c0005c 	xori	r7,r7,1
811204b8:	8245c83a 	sub	r2,r16,r9
811204bc:	3c807426 	beq	r7,r18,81120690 <__subdf3+0x24c>
811204c0:	0080af0e 	bge	zero,r2,81120780 <__subdf3+0x33c>
811204c4:	48002a1e 	bne	r9,zero,81120570 <__subdf3+0x12c>
811204c8:	2988b03a 	or	r4,r5,r6
811204cc:	20009a1e 	bne	r4,zero,81120738 <__subdf3+0x2f4>
811204d0:	888001cc 	andi	r2,r17,7
811204d4:	10000726 	beq	r2,zero,811204f4 <__subdf3+0xb0>
811204d8:	888003cc 	andi	r2,r17,15
811204dc:	01000104 	movi	r4,4
811204e0:	11000426 	beq	r2,r4,811204f4 <__subdf3+0xb0>
811204e4:	890b883a 	add	r5,r17,r4
811204e8:	2c63803a 	cmpltu	r17,r5,r17
811204ec:	1c47883a 	add	r3,r3,r17
811204f0:	2823883a 	mov	r17,r5
811204f4:	1880202c 	andhi	r2,r3,128
811204f8:	10005926 	beq	r2,zero,81120660 <__subdf3+0x21c>
811204fc:	84000044 	addi	r16,r16,1
81120500:	0081ffc4 	movi	r2,2047
81120504:	8080be26 	beq	r16,r2,81120800 <__subdf3+0x3bc>
81120508:	017fe034 	movhi	r5,65408
8112050c:	297fffc4 	addi	r5,r5,-1
81120510:	1946703a 	and	r3,r3,r5
81120514:	1804977a 	slli	r2,r3,29
81120518:	1806927a 	slli	r3,r3,9
8112051c:	8822d0fa 	srli	r17,r17,3
81120520:	8401ffcc 	andi	r16,r16,2047
81120524:	180ad33a 	srli	r5,r3,12
81120528:	9100004c 	andi	r4,r18,1
8112052c:	1444b03a 	or	r2,r2,r17
81120530:	80c1ffcc 	andi	r3,r16,2047
81120534:	1820953a 	slli	r16,r3,20
81120538:	20c03fcc 	andi	r3,r4,255
8112053c:	180897fa 	slli	r4,r3,31
81120540:	00c00434 	movhi	r3,16
81120544:	18ffffc4 	addi	r3,r3,-1
81120548:	28c6703a 	and	r3,r5,r3
8112054c:	1c06b03a 	or	r3,r3,r16
81120550:	1906b03a 	or	r3,r3,r4
81120554:	dfc00417 	ldw	ra,16(sp)
81120558:	dcc00317 	ldw	r19,12(sp)
8112055c:	dc800217 	ldw	r18,8(sp)
81120560:	dc400117 	ldw	r17,4(sp)
81120564:	dc000017 	ldw	r16,0(sp)
81120568:	dec00504 	addi	sp,sp,20
8112056c:	f800283a 	ret
81120570:	0101ffc4 	movi	r4,2047
81120574:	813fd626 	beq	r16,r4,811204d0 <__reset+0xfb1004d0>
81120578:	29402034 	orhi	r5,r5,128
8112057c:	01000e04 	movi	r4,56
81120580:	2080a316 	blt	r4,r2,81120810 <__subdf3+0x3cc>
81120584:	010007c4 	movi	r4,31
81120588:	2080c616 	blt	r4,r2,811208a4 <__subdf3+0x460>
8112058c:	01000804 	movi	r4,32
81120590:	2089c83a 	sub	r4,r4,r2
81120594:	2910983a 	sll	r8,r5,r4
81120598:	308ed83a 	srl	r7,r6,r2
8112059c:	3108983a 	sll	r4,r6,r4
811205a0:	2884d83a 	srl	r2,r5,r2
811205a4:	41ccb03a 	or	r6,r8,r7
811205a8:	2008c03a 	cmpne	r4,r4,zero
811205ac:	310cb03a 	or	r6,r6,r4
811205b0:	898dc83a 	sub	r6,r17,r6
811205b4:	89a3803a 	cmpltu	r17,r17,r6
811205b8:	1887c83a 	sub	r3,r3,r2
811205bc:	1c47c83a 	sub	r3,r3,r17
811205c0:	3023883a 	mov	r17,r6
811205c4:	1880202c 	andhi	r2,r3,128
811205c8:	10002326 	beq	r2,zero,81120658 <__subdf3+0x214>
811205cc:	04c02034 	movhi	r19,128
811205d0:	9cffffc4 	addi	r19,r19,-1
811205d4:	1ce6703a 	and	r19,r3,r19
811205d8:	98007a26 	beq	r19,zero,811207c4 <__subdf3+0x380>
811205dc:	9809883a 	mov	r4,r19
811205e0:	112116c0 	call	8112116c <__clzsi2>
811205e4:	113ffe04 	addi	r4,r2,-8
811205e8:	00c007c4 	movi	r3,31
811205ec:	19007b16 	blt	r3,r4,811207dc <__subdf3+0x398>
811205f0:	00800804 	movi	r2,32
811205f4:	1105c83a 	sub	r2,r2,r4
811205f8:	8884d83a 	srl	r2,r17,r2
811205fc:	9906983a 	sll	r3,r19,r4
81120600:	8922983a 	sll	r17,r17,r4
81120604:	10c4b03a 	or	r2,r2,r3
81120608:	24007816 	blt	r4,r16,811207ec <__subdf3+0x3a8>
8112060c:	2421c83a 	sub	r16,r4,r16
81120610:	80c00044 	addi	r3,r16,1
81120614:	010007c4 	movi	r4,31
81120618:	20c09516 	blt	r4,r3,81120870 <__subdf3+0x42c>
8112061c:	01400804 	movi	r5,32
81120620:	28cbc83a 	sub	r5,r5,r3
81120624:	88c8d83a 	srl	r4,r17,r3
81120628:	8962983a 	sll	r17,r17,r5
8112062c:	114a983a 	sll	r5,r2,r5
81120630:	10c6d83a 	srl	r3,r2,r3
81120634:	8804c03a 	cmpne	r2,r17,zero
81120638:	290ab03a 	or	r5,r5,r4
8112063c:	28a2b03a 	or	r17,r5,r2
81120640:	0021883a 	mov	r16,zero
81120644:	003fa206 	br	811204d0 <__reset+0xfb1004d0>
81120648:	2090b03a 	or	r8,r4,r2
8112064c:	40018e26 	beq	r8,zero,81120c88 <__subdf3+0x844>
81120650:	1007883a 	mov	r3,r2
81120654:	2023883a 	mov	r17,r4
81120658:	888001cc 	andi	r2,r17,7
8112065c:	103f9e1e 	bne	r2,zero,811204d8 <__reset+0xfb1004d8>
81120660:	1804977a 	slli	r2,r3,29
81120664:	8822d0fa 	srli	r17,r17,3
81120668:	1810d0fa 	srli	r8,r3,3
8112066c:	9100004c 	andi	r4,r18,1
81120670:	1444b03a 	or	r2,r2,r17
81120674:	00c1ffc4 	movi	r3,2047
81120678:	80c02826 	beq	r16,r3,8112071c <__subdf3+0x2d8>
8112067c:	01400434 	movhi	r5,16
81120680:	297fffc4 	addi	r5,r5,-1
81120684:	80e0703a 	and	r16,r16,r3
81120688:	414a703a 	and	r5,r8,r5
8112068c:	003fa806 	br	81120530 <__reset+0xfb100530>
81120690:	0080630e 	bge	zero,r2,81120820 <__subdf3+0x3dc>
81120694:	48003026 	beq	r9,zero,81120758 <__subdf3+0x314>
81120698:	0101ffc4 	movi	r4,2047
8112069c:	813f8c26 	beq	r16,r4,811204d0 <__reset+0xfb1004d0>
811206a0:	29402034 	orhi	r5,r5,128
811206a4:	01000e04 	movi	r4,56
811206a8:	2080a90e 	bge	r4,r2,81120950 <__subdf3+0x50c>
811206ac:	298cb03a 	or	r6,r5,r6
811206b0:	3012c03a 	cmpne	r9,r6,zero
811206b4:	0005883a 	mov	r2,zero
811206b8:	4c53883a 	add	r9,r9,r17
811206bc:	4c63803a 	cmpltu	r17,r9,r17
811206c0:	10c7883a 	add	r3,r2,r3
811206c4:	88c7883a 	add	r3,r17,r3
811206c8:	4823883a 	mov	r17,r9
811206cc:	1880202c 	andhi	r2,r3,128
811206d0:	1000d026 	beq	r2,zero,81120a14 <__subdf3+0x5d0>
811206d4:	84000044 	addi	r16,r16,1
811206d8:	0081ffc4 	movi	r2,2047
811206dc:	8080fe26 	beq	r16,r2,81120ad8 <__subdf3+0x694>
811206e0:	00bfe034 	movhi	r2,65408
811206e4:	10bfffc4 	addi	r2,r2,-1
811206e8:	1886703a 	and	r3,r3,r2
811206ec:	880ad07a 	srli	r5,r17,1
811206f0:	180497fa 	slli	r2,r3,31
811206f4:	8900004c 	andi	r4,r17,1
811206f8:	2922b03a 	or	r17,r5,r4
811206fc:	1806d07a 	srli	r3,r3,1
81120700:	1462b03a 	or	r17,r2,r17
81120704:	3825883a 	mov	r18,r7
81120708:	003f7106 	br	811204d0 <__reset+0xfb1004d0>
8112070c:	2984b03a 	or	r2,r5,r6
81120710:	103f6826 	beq	r2,zero,811204b4 <__reset+0xfb1004b4>
81120714:	39c03fcc 	andi	r7,r7,255
81120718:	003f6706 	br	811204b8 <__reset+0xfb1004b8>
8112071c:	4086b03a 	or	r3,r8,r2
81120720:	18015226 	beq	r3,zero,81120c6c <__subdf3+0x828>
81120724:	00c00434 	movhi	r3,16
81120728:	41400234 	orhi	r5,r8,8
8112072c:	18ffffc4 	addi	r3,r3,-1
81120730:	28ca703a 	and	r5,r5,r3
81120734:	003f7e06 	br	81120530 <__reset+0xfb100530>
81120738:	10bfffc4 	addi	r2,r2,-1
8112073c:	1000491e 	bne	r2,zero,81120864 <__subdf3+0x420>
81120740:	898fc83a 	sub	r7,r17,r6
81120744:	89e3803a 	cmpltu	r17,r17,r7
81120748:	1947c83a 	sub	r3,r3,r5
8112074c:	1c47c83a 	sub	r3,r3,r17
81120750:	3823883a 	mov	r17,r7
81120754:	003f9b06 	br	811205c4 <__reset+0xfb1005c4>
81120758:	2988b03a 	or	r4,r5,r6
8112075c:	203f5c26 	beq	r4,zero,811204d0 <__reset+0xfb1004d0>
81120760:	10bfffc4 	addi	r2,r2,-1
81120764:	1000931e 	bne	r2,zero,811209b4 <__subdf3+0x570>
81120768:	898d883a 	add	r6,r17,r6
8112076c:	3463803a 	cmpltu	r17,r6,r17
81120770:	1947883a 	add	r3,r3,r5
81120774:	88c7883a 	add	r3,r17,r3
81120778:	3023883a 	mov	r17,r6
8112077c:	003fd306 	br	811206cc <__reset+0xfb1006cc>
81120780:	1000541e 	bne	r2,zero,811208d4 <__subdf3+0x490>
81120784:	80800044 	addi	r2,r16,1
81120788:	1081ffcc 	andi	r2,r2,2047
8112078c:	01000044 	movi	r4,1
81120790:	2080a20e 	bge	r4,r2,81120a1c <__subdf3+0x5d8>
81120794:	8989c83a 	sub	r4,r17,r6
81120798:	8905803a 	cmpltu	r2,r17,r4
8112079c:	1967c83a 	sub	r19,r3,r5
811207a0:	98a7c83a 	sub	r19,r19,r2
811207a4:	9880202c 	andhi	r2,r19,128
811207a8:	10006326 	beq	r2,zero,81120938 <__subdf3+0x4f4>
811207ac:	3463c83a 	sub	r17,r6,r17
811207b0:	28c7c83a 	sub	r3,r5,r3
811207b4:	344d803a 	cmpltu	r6,r6,r17
811207b8:	19a7c83a 	sub	r19,r3,r6
811207bc:	3825883a 	mov	r18,r7
811207c0:	983f861e 	bne	r19,zero,811205dc <__reset+0xfb1005dc>
811207c4:	8809883a 	mov	r4,r17
811207c8:	112116c0 	call	8112116c <__clzsi2>
811207cc:	10800804 	addi	r2,r2,32
811207d0:	113ffe04 	addi	r4,r2,-8
811207d4:	00c007c4 	movi	r3,31
811207d8:	193f850e 	bge	r3,r4,811205f0 <__reset+0xfb1005f0>
811207dc:	10bff604 	addi	r2,r2,-40
811207e0:	8884983a 	sll	r2,r17,r2
811207e4:	0023883a 	mov	r17,zero
811207e8:	243f880e 	bge	r4,r16,8112060c <__reset+0xfb10060c>
811207ec:	00ffe034 	movhi	r3,65408
811207f0:	18ffffc4 	addi	r3,r3,-1
811207f4:	8121c83a 	sub	r16,r16,r4
811207f8:	10c6703a 	and	r3,r2,r3
811207fc:	003f3406 	br	811204d0 <__reset+0xfb1004d0>
81120800:	9100004c 	andi	r4,r18,1
81120804:	000b883a 	mov	r5,zero
81120808:	0005883a 	mov	r2,zero
8112080c:	003f4806 	br	81120530 <__reset+0xfb100530>
81120810:	298cb03a 	or	r6,r5,r6
81120814:	300cc03a 	cmpne	r6,r6,zero
81120818:	0005883a 	mov	r2,zero
8112081c:	003f6406 	br	811205b0 <__reset+0xfb1005b0>
81120820:	10009a1e 	bne	r2,zero,81120a8c <__subdf3+0x648>
81120824:	82400044 	addi	r9,r16,1
81120828:	4881ffcc 	andi	r2,r9,2047
8112082c:	02800044 	movi	r10,1
81120830:	5080670e 	bge	r10,r2,811209d0 <__subdf3+0x58c>
81120834:	0081ffc4 	movi	r2,2047
81120838:	4880af26 	beq	r9,r2,81120af8 <__subdf3+0x6b4>
8112083c:	898d883a 	add	r6,r17,r6
81120840:	1945883a 	add	r2,r3,r5
81120844:	3447803a 	cmpltu	r3,r6,r17
81120848:	1887883a 	add	r3,r3,r2
8112084c:	182297fa 	slli	r17,r3,31
81120850:	300cd07a 	srli	r6,r6,1
81120854:	1806d07a 	srli	r3,r3,1
81120858:	4821883a 	mov	r16,r9
8112085c:	89a2b03a 	or	r17,r17,r6
81120860:	003f1b06 	br	811204d0 <__reset+0xfb1004d0>
81120864:	0101ffc4 	movi	r4,2047
81120868:	813f441e 	bne	r16,r4,8112057c <__reset+0xfb10057c>
8112086c:	003f1806 	br	811204d0 <__reset+0xfb1004d0>
81120870:	843ff844 	addi	r16,r16,-31
81120874:	01400804 	movi	r5,32
81120878:	1408d83a 	srl	r4,r2,r16
8112087c:	19405026 	beq	r3,r5,811209c0 <__subdf3+0x57c>
81120880:	01401004 	movi	r5,64
81120884:	28c7c83a 	sub	r3,r5,r3
81120888:	10c4983a 	sll	r2,r2,r3
8112088c:	88a2b03a 	or	r17,r17,r2
81120890:	8822c03a 	cmpne	r17,r17,zero
81120894:	2462b03a 	or	r17,r4,r17
81120898:	0007883a 	mov	r3,zero
8112089c:	0021883a 	mov	r16,zero
811208a0:	003f6d06 	br	81120658 <__reset+0xfb100658>
811208a4:	11fff804 	addi	r7,r2,-32
811208a8:	01000804 	movi	r4,32
811208ac:	29ced83a 	srl	r7,r5,r7
811208b0:	11004526 	beq	r2,r4,811209c8 <__subdf3+0x584>
811208b4:	01001004 	movi	r4,64
811208b8:	2089c83a 	sub	r4,r4,r2
811208bc:	2904983a 	sll	r2,r5,r4
811208c0:	118cb03a 	or	r6,r2,r6
811208c4:	300cc03a 	cmpne	r6,r6,zero
811208c8:	398cb03a 	or	r6,r7,r6
811208cc:	0005883a 	mov	r2,zero
811208d0:	003f3706 	br	811205b0 <__reset+0xfb1005b0>
811208d4:	80002a26 	beq	r16,zero,81120980 <__subdf3+0x53c>
811208d8:	0101ffc4 	movi	r4,2047
811208dc:	49006626 	beq	r9,r4,81120a78 <__subdf3+0x634>
811208e0:	0085c83a 	sub	r2,zero,r2
811208e4:	18c02034 	orhi	r3,r3,128
811208e8:	01000e04 	movi	r4,56
811208ec:	20807e16 	blt	r4,r2,81120ae8 <__subdf3+0x6a4>
811208f0:	010007c4 	movi	r4,31
811208f4:	2080e716 	blt	r4,r2,81120c94 <__subdf3+0x850>
811208f8:	01000804 	movi	r4,32
811208fc:	2089c83a 	sub	r4,r4,r2
81120900:	1914983a 	sll	r10,r3,r4
81120904:	8890d83a 	srl	r8,r17,r2
81120908:	8908983a 	sll	r4,r17,r4
8112090c:	1884d83a 	srl	r2,r3,r2
81120910:	5222b03a 	or	r17,r10,r8
81120914:	2006c03a 	cmpne	r3,r4,zero
81120918:	88e2b03a 	or	r17,r17,r3
8112091c:	3463c83a 	sub	r17,r6,r17
81120920:	2885c83a 	sub	r2,r5,r2
81120924:	344d803a 	cmpltu	r6,r6,r17
81120928:	1187c83a 	sub	r3,r2,r6
8112092c:	4821883a 	mov	r16,r9
81120930:	3825883a 	mov	r18,r7
81120934:	003f2306 	br	811205c4 <__reset+0xfb1005c4>
81120938:	24d0b03a 	or	r8,r4,r19
8112093c:	40001b1e 	bne	r8,zero,811209ac <__subdf3+0x568>
81120940:	0005883a 	mov	r2,zero
81120944:	0009883a 	mov	r4,zero
81120948:	0021883a 	mov	r16,zero
8112094c:	003f4906 	br	81120674 <__reset+0xfb100674>
81120950:	010007c4 	movi	r4,31
81120954:	20803a16 	blt	r4,r2,81120a40 <__subdf3+0x5fc>
81120958:	01000804 	movi	r4,32
8112095c:	2089c83a 	sub	r4,r4,r2
81120960:	2912983a 	sll	r9,r5,r4
81120964:	3090d83a 	srl	r8,r6,r2
81120968:	3108983a 	sll	r4,r6,r4
8112096c:	2884d83a 	srl	r2,r5,r2
81120970:	4a12b03a 	or	r9,r9,r8
81120974:	2008c03a 	cmpne	r4,r4,zero
81120978:	4912b03a 	or	r9,r9,r4
8112097c:	003f4e06 	br	811206b8 <__reset+0xfb1006b8>
81120980:	1c48b03a 	or	r4,r3,r17
81120984:	20003c26 	beq	r4,zero,81120a78 <__subdf3+0x634>
81120988:	0084303a 	nor	r2,zero,r2
8112098c:	1000381e 	bne	r2,zero,81120a70 <__subdf3+0x62c>
81120990:	3463c83a 	sub	r17,r6,r17
81120994:	28c5c83a 	sub	r2,r5,r3
81120998:	344d803a 	cmpltu	r6,r6,r17
8112099c:	1187c83a 	sub	r3,r2,r6
811209a0:	4821883a 	mov	r16,r9
811209a4:	3825883a 	mov	r18,r7
811209a8:	003f0606 	br	811205c4 <__reset+0xfb1005c4>
811209ac:	2023883a 	mov	r17,r4
811209b0:	003f0906 	br	811205d8 <__reset+0xfb1005d8>
811209b4:	0101ffc4 	movi	r4,2047
811209b8:	813f3a1e 	bne	r16,r4,811206a4 <__reset+0xfb1006a4>
811209bc:	003ec406 	br	811204d0 <__reset+0xfb1004d0>
811209c0:	0005883a 	mov	r2,zero
811209c4:	003fb106 	br	8112088c <__reset+0xfb10088c>
811209c8:	0005883a 	mov	r2,zero
811209cc:	003fbc06 	br	811208c0 <__reset+0xfb1008c0>
811209d0:	1c44b03a 	or	r2,r3,r17
811209d4:	80008e1e 	bne	r16,zero,81120c10 <__subdf3+0x7cc>
811209d8:	1000c826 	beq	r2,zero,81120cfc <__subdf3+0x8b8>
811209dc:	2984b03a 	or	r2,r5,r6
811209e0:	103ebb26 	beq	r2,zero,811204d0 <__reset+0xfb1004d0>
811209e4:	8989883a 	add	r4,r17,r6
811209e8:	1945883a 	add	r2,r3,r5
811209ec:	2447803a 	cmpltu	r3,r4,r17
811209f0:	1887883a 	add	r3,r3,r2
811209f4:	1880202c 	andhi	r2,r3,128
811209f8:	2023883a 	mov	r17,r4
811209fc:	103f1626 	beq	r2,zero,81120658 <__reset+0xfb100658>
81120a00:	00bfe034 	movhi	r2,65408
81120a04:	10bfffc4 	addi	r2,r2,-1
81120a08:	5021883a 	mov	r16,r10
81120a0c:	1886703a 	and	r3,r3,r2
81120a10:	003eaf06 	br	811204d0 <__reset+0xfb1004d0>
81120a14:	3825883a 	mov	r18,r7
81120a18:	003f0f06 	br	81120658 <__reset+0xfb100658>
81120a1c:	1c44b03a 	or	r2,r3,r17
81120a20:	8000251e 	bne	r16,zero,81120ab8 <__subdf3+0x674>
81120a24:	1000661e 	bne	r2,zero,81120bc0 <__subdf3+0x77c>
81120a28:	2990b03a 	or	r8,r5,r6
81120a2c:	40009626 	beq	r8,zero,81120c88 <__subdf3+0x844>
81120a30:	2807883a 	mov	r3,r5
81120a34:	3023883a 	mov	r17,r6
81120a38:	3825883a 	mov	r18,r7
81120a3c:	003ea406 	br	811204d0 <__reset+0xfb1004d0>
81120a40:	127ff804 	addi	r9,r2,-32
81120a44:	01000804 	movi	r4,32
81120a48:	2a52d83a 	srl	r9,r5,r9
81120a4c:	11008c26 	beq	r2,r4,81120c80 <__subdf3+0x83c>
81120a50:	01001004 	movi	r4,64
81120a54:	2085c83a 	sub	r2,r4,r2
81120a58:	2884983a 	sll	r2,r5,r2
81120a5c:	118cb03a 	or	r6,r2,r6
81120a60:	300cc03a 	cmpne	r6,r6,zero
81120a64:	4992b03a 	or	r9,r9,r6
81120a68:	0005883a 	mov	r2,zero
81120a6c:	003f1206 	br	811206b8 <__reset+0xfb1006b8>
81120a70:	0101ffc4 	movi	r4,2047
81120a74:	493f9c1e 	bne	r9,r4,811208e8 <__reset+0xfb1008e8>
81120a78:	2807883a 	mov	r3,r5
81120a7c:	3023883a 	mov	r17,r6
81120a80:	4821883a 	mov	r16,r9
81120a84:	3825883a 	mov	r18,r7
81120a88:	003e9106 	br	811204d0 <__reset+0xfb1004d0>
81120a8c:	80001f1e 	bne	r16,zero,81120b0c <__subdf3+0x6c8>
81120a90:	1c48b03a 	or	r4,r3,r17
81120a94:	20005a26 	beq	r4,zero,81120c00 <__subdf3+0x7bc>
81120a98:	0084303a 	nor	r2,zero,r2
81120a9c:	1000561e 	bne	r2,zero,81120bf8 <__subdf3+0x7b4>
81120aa0:	89a3883a 	add	r17,r17,r6
81120aa4:	1945883a 	add	r2,r3,r5
81120aa8:	898d803a 	cmpltu	r6,r17,r6
81120aac:	3087883a 	add	r3,r6,r2
81120ab0:	4821883a 	mov	r16,r9
81120ab4:	003f0506 	br	811206cc <__reset+0xfb1006cc>
81120ab8:	10002b1e 	bne	r2,zero,81120b68 <__subdf3+0x724>
81120abc:	2984b03a 	or	r2,r5,r6
81120ac0:	10008026 	beq	r2,zero,81120cc4 <__subdf3+0x880>
81120ac4:	2807883a 	mov	r3,r5
81120ac8:	3023883a 	mov	r17,r6
81120acc:	3825883a 	mov	r18,r7
81120ad0:	0401ffc4 	movi	r16,2047
81120ad4:	003e7e06 	br	811204d0 <__reset+0xfb1004d0>
81120ad8:	3809883a 	mov	r4,r7
81120adc:	0011883a 	mov	r8,zero
81120ae0:	0005883a 	mov	r2,zero
81120ae4:	003ee306 	br	81120674 <__reset+0xfb100674>
81120ae8:	1c62b03a 	or	r17,r3,r17
81120aec:	8822c03a 	cmpne	r17,r17,zero
81120af0:	0005883a 	mov	r2,zero
81120af4:	003f8906 	br	8112091c <__reset+0xfb10091c>
81120af8:	3809883a 	mov	r4,r7
81120afc:	4821883a 	mov	r16,r9
81120b00:	0011883a 	mov	r8,zero
81120b04:	0005883a 	mov	r2,zero
81120b08:	003eda06 	br	81120674 <__reset+0xfb100674>
81120b0c:	0101ffc4 	movi	r4,2047
81120b10:	49003b26 	beq	r9,r4,81120c00 <__subdf3+0x7bc>
81120b14:	0085c83a 	sub	r2,zero,r2
81120b18:	18c02034 	orhi	r3,r3,128
81120b1c:	01000e04 	movi	r4,56
81120b20:	20806e16 	blt	r4,r2,81120cdc <__subdf3+0x898>
81120b24:	010007c4 	movi	r4,31
81120b28:	20807716 	blt	r4,r2,81120d08 <__subdf3+0x8c4>
81120b2c:	01000804 	movi	r4,32
81120b30:	2089c83a 	sub	r4,r4,r2
81120b34:	1914983a 	sll	r10,r3,r4
81120b38:	8890d83a 	srl	r8,r17,r2
81120b3c:	8908983a 	sll	r4,r17,r4
81120b40:	1884d83a 	srl	r2,r3,r2
81120b44:	5222b03a 	or	r17,r10,r8
81120b48:	2006c03a 	cmpne	r3,r4,zero
81120b4c:	88e2b03a 	or	r17,r17,r3
81120b50:	89a3883a 	add	r17,r17,r6
81120b54:	1145883a 	add	r2,r2,r5
81120b58:	898d803a 	cmpltu	r6,r17,r6
81120b5c:	3087883a 	add	r3,r6,r2
81120b60:	4821883a 	mov	r16,r9
81120b64:	003ed906 	br	811206cc <__reset+0xfb1006cc>
81120b68:	2984b03a 	or	r2,r5,r6
81120b6c:	10004226 	beq	r2,zero,81120c78 <__subdf3+0x834>
81120b70:	1808d0fa 	srli	r4,r3,3
81120b74:	8822d0fa 	srli	r17,r17,3
81120b78:	1806977a 	slli	r3,r3,29
81120b7c:	2080022c 	andhi	r2,r4,8
81120b80:	1c62b03a 	or	r17,r3,r17
81120b84:	10000826 	beq	r2,zero,81120ba8 <__subdf3+0x764>
81120b88:	2812d0fa 	srli	r9,r5,3
81120b8c:	4880022c 	andhi	r2,r9,8
81120b90:	1000051e 	bne	r2,zero,81120ba8 <__subdf3+0x764>
81120b94:	300cd0fa 	srli	r6,r6,3
81120b98:	2804977a 	slli	r2,r5,29
81120b9c:	4809883a 	mov	r4,r9
81120ba0:	3825883a 	mov	r18,r7
81120ba4:	11a2b03a 	or	r17,r2,r6
81120ba8:	8806d77a 	srli	r3,r17,29
81120bac:	200890fa 	slli	r4,r4,3
81120bb0:	882290fa 	slli	r17,r17,3
81120bb4:	0401ffc4 	movi	r16,2047
81120bb8:	1906b03a 	or	r3,r3,r4
81120bbc:	003e4406 	br	811204d0 <__reset+0xfb1004d0>
81120bc0:	2984b03a 	or	r2,r5,r6
81120bc4:	103e4226 	beq	r2,zero,811204d0 <__reset+0xfb1004d0>
81120bc8:	8989c83a 	sub	r4,r17,r6
81120bcc:	8911803a 	cmpltu	r8,r17,r4
81120bd0:	1945c83a 	sub	r2,r3,r5
81120bd4:	1205c83a 	sub	r2,r2,r8
81120bd8:	1200202c 	andhi	r8,r2,128
81120bdc:	403e9a26 	beq	r8,zero,81120648 <__reset+0xfb100648>
81120be0:	3463c83a 	sub	r17,r6,r17
81120be4:	28c5c83a 	sub	r2,r5,r3
81120be8:	344d803a 	cmpltu	r6,r6,r17
81120bec:	1187c83a 	sub	r3,r2,r6
81120bf0:	3825883a 	mov	r18,r7
81120bf4:	003e3606 	br	811204d0 <__reset+0xfb1004d0>
81120bf8:	0101ffc4 	movi	r4,2047
81120bfc:	493fc71e 	bne	r9,r4,81120b1c <__reset+0xfb100b1c>
81120c00:	2807883a 	mov	r3,r5
81120c04:	3023883a 	mov	r17,r6
81120c08:	4821883a 	mov	r16,r9
81120c0c:	003e3006 	br	811204d0 <__reset+0xfb1004d0>
81120c10:	10003626 	beq	r2,zero,81120cec <__subdf3+0x8a8>
81120c14:	2984b03a 	or	r2,r5,r6
81120c18:	10001726 	beq	r2,zero,81120c78 <__subdf3+0x834>
81120c1c:	1808d0fa 	srli	r4,r3,3
81120c20:	8822d0fa 	srli	r17,r17,3
81120c24:	1806977a 	slli	r3,r3,29
81120c28:	2080022c 	andhi	r2,r4,8
81120c2c:	1c62b03a 	or	r17,r3,r17
81120c30:	10000726 	beq	r2,zero,81120c50 <__subdf3+0x80c>
81120c34:	2812d0fa 	srli	r9,r5,3
81120c38:	4880022c 	andhi	r2,r9,8
81120c3c:	1000041e 	bne	r2,zero,81120c50 <__subdf3+0x80c>
81120c40:	300cd0fa 	srli	r6,r6,3
81120c44:	2804977a 	slli	r2,r5,29
81120c48:	4809883a 	mov	r4,r9
81120c4c:	11a2b03a 	or	r17,r2,r6
81120c50:	8806d77a 	srli	r3,r17,29
81120c54:	200890fa 	slli	r4,r4,3
81120c58:	882290fa 	slli	r17,r17,3
81120c5c:	3825883a 	mov	r18,r7
81120c60:	1906b03a 	or	r3,r3,r4
81120c64:	0401ffc4 	movi	r16,2047
81120c68:	003e1906 	br	811204d0 <__reset+0xfb1004d0>
81120c6c:	000b883a 	mov	r5,zero
81120c70:	0005883a 	mov	r2,zero
81120c74:	003e2e06 	br	81120530 <__reset+0xfb100530>
81120c78:	0401ffc4 	movi	r16,2047
81120c7c:	003e1406 	br	811204d0 <__reset+0xfb1004d0>
81120c80:	0005883a 	mov	r2,zero
81120c84:	003f7506 	br	81120a5c <__reset+0xfb100a5c>
81120c88:	0005883a 	mov	r2,zero
81120c8c:	0009883a 	mov	r4,zero
81120c90:	003e7806 	br	81120674 <__reset+0xfb100674>
81120c94:	123ff804 	addi	r8,r2,-32
81120c98:	01000804 	movi	r4,32
81120c9c:	1a10d83a 	srl	r8,r3,r8
81120ca0:	11002526 	beq	r2,r4,81120d38 <__subdf3+0x8f4>
81120ca4:	01001004 	movi	r4,64
81120ca8:	2085c83a 	sub	r2,r4,r2
81120cac:	1884983a 	sll	r2,r3,r2
81120cb0:	1444b03a 	or	r2,r2,r17
81120cb4:	1004c03a 	cmpne	r2,r2,zero
81120cb8:	40a2b03a 	or	r17,r8,r2
81120cbc:	0005883a 	mov	r2,zero
81120cc0:	003f1606 	br	8112091c <__reset+0xfb10091c>
81120cc4:	02000434 	movhi	r8,16
81120cc8:	0009883a 	mov	r4,zero
81120ccc:	423fffc4 	addi	r8,r8,-1
81120cd0:	00bfffc4 	movi	r2,-1
81120cd4:	0401ffc4 	movi	r16,2047
81120cd8:	003e6606 	br	81120674 <__reset+0xfb100674>
81120cdc:	1c62b03a 	or	r17,r3,r17
81120ce0:	8822c03a 	cmpne	r17,r17,zero
81120ce4:	0005883a 	mov	r2,zero
81120ce8:	003f9906 	br	81120b50 <__reset+0xfb100b50>
81120cec:	2807883a 	mov	r3,r5
81120cf0:	3023883a 	mov	r17,r6
81120cf4:	0401ffc4 	movi	r16,2047
81120cf8:	003df506 	br	811204d0 <__reset+0xfb1004d0>
81120cfc:	2807883a 	mov	r3,r5
81120d00:	3023883a 	mov	r17,r6
81120d04:	003df206 	br	811204d0 <__reset+0xfb1004d0>
81120d08:	123ff804 	addi	r8,r2,-32
81120d0c:	01000804 	movi	r4,32
81120d10:	1a10d83a 	srl	r8,r3,r8
81120d14:	11000a26 	beq	r2,r4,81120d40 <__subdf3+0x8fc>
81120d18:	01001004 	movi	r4,64
81120d1c:	2085c83a 	sub	r2,r4,r2
81120d20:	1884983a 	sll	r2,r3,r2
81120d24:	1444b03a 	or	r2,r2,r17
81120d28:	1004c03a 	cmpne	r2,r2,zero
81120d2c:	40a2b03a 	or	r17,r8,r2
81120d30:	0005883a 	mov	r2,zero
81120d34:	003f8606 	br	81120b50 <__reset+0xfb100b50>
81120d38:	0005883a 	mov	r2,zero
81120d3c:	003fdc06 	br	81120cb0 <__reset+0xfb100cb0>
81120d40:	0005883a 	mov	r2,zero
81120d44:	003ff706 	br	81120d24 <__reset+0xfb100d24>

81120d48 <__fixdfsi>:
81120d48:	280cd53a 	srli	r6,r5,20
81120d4c:	00c00434 	movhi	r3,16
81120d50:	18ffffc4 	addi	r3,r3,-1
81120d54:	3181ffcc 	andi	r6,r6,2047
81120d58:	01c0ff84 	movi	r7,1022
81120d5c:	28c6703a 	and	r3,r5,r3
81120d60:	280ad7fa 	srli	r5,r5,31
81120d64:	3980120e 	bge	r7,r6,81120db0 <__fixdfsi+0x68>
81120d68:	00810744 	movi	r2,1053
81120d6c:	11800c16 	blt	r2,r6,81120da0 <__fixdfsi+0x58>
81120d70:	00810cc4 	movi	r2,1075
81120d74:	1185c83a 	sub	r2,r2,r6
81120d78:	01c007c4 	movi	r7,31
81120d7c:	18c00434 	orhi	r3,r3,16
81120d80:	38800d16 	blt	r7,r2,81120db8 <__fixdfsi+0x70>
81120d84:	31befb44 	addi	r6,r6,-1043
81120d88:	2084d83a 	srl	r2,r4,r2
81120d8c:	1986983a 	sll	r3,r3,r6
81120d90:	1884b03a 	or	r2,r3,r2
81120d94:	28000726 	beq	r5,zero,81120db4 <__fixdfsi+0x6c>
81120d98:	0085c83a 	sub	r2,zero,r2
81120d9c:	f800283a 	ret
81120da0:	00a00034 	movhi	r2,32768
81120da4:	10bfffc4 	addi	r2,r2,-1
81120da8:	2885883a 	add	r2,r5,r2
81120dac:	f800283a 	ret
81120db0:	0005883a 	mov	r2,zero
81120db4:	f800283a 	ret
81120db8:	008104c4 	movi	r2,1043
81120dbc:	1185c83a 	sub	r2,r2,r6
81120dc0:	1884d83a 	srl	r2,r3,r2
81120dc4:	003ff306 	br	81120d94 <__reset+0xfb100d94>

81120dc8 <__floatsidf>:
81120dc8:	defffd04 	addi	sp,sp,-12
81120dcc:	de00012e 	bgeu	sp,et,81120dd4 <__floatsidf+0xc>
81120dd0:	003b68fa 	trap	3
81120dd4:	dfc00215 	stw	ra,8(sp)
81120dd8:	dc400115 	stw	r17,4(sp)
81120ddc:	dc000015 	stw	r16,0(sp)
81120de0:	20002b26 	beq	r4,zero,81120e90 <__floatsidf+0xc8>
81120de4:	2023883a 	mov	r17,r4
81120de8:	2020d7fa 	srli	r16,r4,31
81120dec:	20002d16 	blt	r4,zero,81120ea4 <__floatsidf+0xdc>
81120df0:	8809883a 	mov	r4,r17
81120df4:	112116c0 	call	8112116c <__clzsi2>
81120df8:	01410784 	movi	r5,1054
81120dfc:	288bc83a 	sub	r5,r5,r2
81120e00:	01010cc4 	movi	r4,1075
81120e04:	2149c83a 	sub	r4,r4,r5
81120e08:	00c007c4 	movi	r3,31
81120e0c:	1900160e 	bge	r3,r4,81120e68 <__floatsidf+0xa0>
81120e10:	00c104c4 	movi	r3,1043
81120e14:	1947c83a 	sub	r3,r3,r5
81120e18:	88c6983a 	sll	r3,r17,r3
81120e1c:	00800434 	movhi	r2,16
81120e20:	10bfffc4 	addi	r2,r2,-1
81120e24:	1886703a 	and	r3,r3,r2
81120e28:	2941ffcc 	andi	r5,r5,2047
81120e2c:	800d883a 	mov	r6,r16
81120e30:	0005883a 	mov	r2,zero
81120e34:	280a953a 	slli	r5,r5,20
81120e38:	31803fcc 	andi	r6,r6,255
81120e3c:	01000434 	movhi	r4,16
81120e40:	300c97fa 	slli	r6,r6,31
81120e44:	213fffc4 	addi	r4,r4,-1
81120e48:	1906703a 	and	r3,r3,r4
81120e4c:	1946b03a 	or	r3,r3,r5
81120e50:	1986b03a 	or	r3,r3,r6
81120e54:	dfc00217 	ldw	ra,8(sp)
81120e58:	dc400117 	ldw	r17,4(sp)
81120e5c:	dc000017 	ldw	r16,0(sp)
81120e60:	dec00304 	addi	sp,sp,12
81120e64:	f800283a 	ret
81120e68:	00c002c4 	movi	r3,11
81120e6c:	1887c83a 	sub	r3,r3,r2
81120e70:	88c6d83a 	srl	r3,r17,r3
81120e74:	8904983a 	sll	r2,r17,r4
81120e78:	01000434 	movhi	r4,16
81120e7c:	213fffc4 	addi	r4,r4,-1
81120e80:	2941ffcc 	andi	r5,r5,2047
81120e84:	1906703a 	and	r3,r3,r4
81120e88:	800d883a 	mov	r6,r16
81120e8c:	003fe906 	br	81120e34 <__reset+0xfb100e34>
81120e90:	000d883a 	mov	r6,zero
81120e94:	000b883a 	mov	r5,zero
81120e98:	0007883a 	mov	r3,zero
81120e9c:	0005883a 	mov	r2,zero
81120ea0:	003fe406 	br	81120e34 <__reset+0xfb100e34>
81120ea4:	0123c83a 	sub	r17,zero,r4
81120ea8:	003fd106 	br	81120df0 <__reset+0xfb100df0>

81120eac <__extendsfdf2>:
81120eac:	200ad5fa 	srli	r5,r4,23
81120eb0:	defffd04 	addi	sp,sp,-12
81120eb4:	de00012e 	bgeu	sp,et,81120ebc <__extendsfdf2+0x10>
81120eb8:	003b68fa 	trap	3
81120ebc:	29403fcc 	andi	r5,r5,255
81120ec0:	dc400115 	stw	r17,4(sp)
81120ec4:	29800044 	addi	r6,r5,1
81120ec8:	04402034 	movhi	r17,128
81120ecc:	dc000015 	stw	r16,0(sp)
81120ed0:	8c7fffc4 	addi	r17,r17,-1
81120ed4:	dfc00215 	stw	ra,8(sp)
81120ed8:	31803fcc 	andi	r6,r6,255
81120edc:	00800044 	movi	r2,1
81120ee0:	8922703a 	and	r17,r17,r4
81120ee4:	2020d7fa 	srli	r16,r4,31
81120ee8:	1180110e 	bge	r2,r6,81120f30 <__extendsfdf2+0x84>
81120eec:	880cd0fa 	srli	r6,r17,3
81120ef0:	8822977a 	slli	r17,r17,29
81120ef4:	2940e004 	addi	r5,r5,896
81120ef8:	2941ffcc 	andi	r5,r5,2047
81120efc:	2804953a 	slli	r2,r5,20
81120f00:	01400434 	movhi	r5,16
81120f04:	800697fa 	slli	r3,r16,31
81120f08:	297fffc4 	addi	r5,r5,-1
81120f0c:	314a703a 	and	r5,r6,r5
81120f10:	288ab03a 	or	r5,r5,r2
81120f14:	28c6b03a 	or	r3,r5,r3
81120f18:	8805883a 	mov	r2,r17
81120f1c:	dfc00217 	ldw	ra,8(sp)
81120f20:	dc400117 	ldw	r17,4(sp)
81120f24:	dc000017 	ldw	r16,0(sp)
81120f28:	dec00304 	addi	sp,sp,12
81120f2c:	f800283a 	ret
81120f30:	2800111e 	bne	r5,zero,81120f78 <__extendsfdf2+0xcc>
81120f34:	88001c26 	beq	r17,zero,81120fa8 <__extendsfdf2+0xfc>
81120f38:	8809883a 	mov	r4,r17
81120f3c:	112116c0 	call	8112116c <__clzsi2>
81120f40:	00c00284 	movi	r3,10
81120f44:	18801b16 	blt	r3,r2,81120fb4 <__extendsfdf2+0x108>
81120f48:	018002c4 	movi	r6,11
81120f4c:	308dc83a 	sub	r6,r6,r2
81120f50:	11000544 	addi	r4,r2,21
81120f54:	8986d83a 	srl	r3,r17,r6
81120f58:	8922983a 	sll	r17,r17,r4
81120f5c:	0180e244 	movi	r6,905
81120f60:	01400434 	movhi	r5,16
81120f64:	3085c83a 	sub	r2,r6,r2
81120f68:	297fffc4 	addi	r5,r5,-1
81120f6c:	194c703a 	and	r6,r3,r5
81120f70:	1141ffcc 	andi	r5,r2,2047
81120f74:	003fe006 	br	81120ef8 <__reset+0xfb100ef8>
81120f78:	88000826 	beq	r17,zero,81120f9c <__extendsfdf2+0xf0>
81120f7c:	880cd0fa 	srli	r6,r17,3
81120f80:	00800434 	movhi	r2,16
81120f84:	10bfffc4 	addi	r2,r2,-1
81120f88:	31800234 	orhi	r6,r6,8
81120f8c:	8822977a 	slli	r17,r17,29
81120f90:	308c703a 	and	r6,r6,r2
81120f94:	0141ffc4 	movi	r5,2047
81120f98:	003fd706 	br	81120ef8 <__reset+0xfb100ef8>
81120f9c:	0141ffc4 	movi	r5,2047
81120fa0:	000d883a 	mov	r6,zero
81120fa4:	003fd406 	br	81120ef8 <__reset+0xfb100ef8>
81120fa8:	000b883a 	mov	r5,zero
81120fac:	000d883a 	mov	r6,zero
81120fb0:	003fd106 	br	81120ef8 <__reset+0xfb100ef8>
81120fb4:	11bffd44 	addi	r6,r2,-11
81120fb8:	8986983a 	sll	r3,r17,r6
81120fbc:	0023883a 	mov	r17,zero
81120fc0:	003fe606 	br	81120f5c <__reset+0xfb100f5c>

81120fc4 <__truncdfsf2>:
81120fc4:	2810d53a 	srli	r8,r5,20
81120fc8:	01c00434 	movhi	r7,16
81120fcc:	39ffffc4 	addi	r7,r7,-1
81120fd0:	29ce703a 	and	r7,r5,r7
81120fd4:	4201ffcc 	andi	r8,r8,2047
81120fd8:	380e90fa 	slli	r7,r7,3
81120fdc:	200cd77a 	srli	r6,r4,29
81120fe0:	42400044 	addi	r9,r8,1
81120fe4:	4a41ffcc 	andi	r9,r9,2047
81120fe8:	00c00044 	movi	r3,1
81120fec:	280ad7fa 	srli	r5,r5,31
81120ff0:	31ceb03a 	or	r7,r6,r7
81120ff4:	200490fa 	slli	r2,r4,3
81120ff8:	1a40230e 	bge	r3,r9,81121088 <__truncdfsf2+0xc4>
81120ffc:	40ff2004 	addi	r3,r8,-896
81121000:	01803f84 	movi	r6,254
81121004:	30c01516 	blt	r6,r3,8112105c <__truncdfsf2+0x98>
81121008:	00c0380e 	bge	zero,r3,811210ec <__truncdfsf2+0x128>
8112100c:	200c91ba 	slli	r6,r4,6
81121010:	380e90fa 	slli	r7,r7,3
81121014:	1004d77a 	srli	r2,r2,29
81121018:	300cc03a 	cmpne	r6,r6,zero
8112101c:	31ccb03a 	or	r6,r6,r7
81121020:	308cb03a 	or	r6,r6,r2
81121024:	308001cc 	andi	r2,r6,7
81121028:	10000426 	beq	r2,zero,8112103c <__truncdfsf2+0x78>
8112102c:	308003cc 	andi	r2,r6,15
81121030:	01000104 	movi	r4,4
81121034:	11000126 	beq	r2,r4,8112103c <__truncdfsf2+0x78>
81121038:	31800104 	addi	r6,r6,4
8112103c:	3081002c 	andhi	r2,r6,1024
81121040:	10001626 	beq	r2,zero,8112109c <__truncdfsf2+0xd8>
81121044:	18c00044 	addi	r3,r3,1
81121048:	00803fc4 	movi	r2,255
8112104c:	18800326 	beq	r3,r2,8112105c <__truncdfsf2+0x98>
81121050:	300c91ba 	slli	r6,r6,6
81121054:	300cd27a 	srli	r6,r6,9
81121058:	00000206 	br	81121064 <__truncdfsf2+0xa0>
8112105c:	00ffffc4 	movi	r3,-1
81121060:	000d883a 	mov	r6,zero
81121064:	18c03fcc 	andi	r3,r3,255
81121068:	180895fa 	slli	r4,r3,23
8112106c:	00c02034 	movhi	r3,128
81121070:	280a97fa 	slli	r5,r5,31
81121074:	18ffffc4 	addi	r3,r3,-1
81121078:	30c6703a 	and	r3,r6,r3
8112107c:	1906b03a 	or	r3,r3,r4
81121080:	1944b03a 	or	r2,r3,r5
81121084:	f800283a 	ret
81121088:	40000b1e 	bne	r8,zero,811210b8 <__truncdfsf2+0xf4>
8112108c:	388cb03a 	or	r6,r7,r2
81121090:	0007883a 	mov	r3,zero
81121094:	30000426 	beq	r6,zero,811210a8 <__truncdfsf2+0xe4>
81121098:	01800144 	movi	r6,5
8112109c:	00803fc4 	movi	r2,255
811210a0:	300cd0fa 	srli	r6,r6,3
811210a4:	18800a26 	beq	r3,r2,811210d0 <__truncdfsf2+0x10c>
811210a8:	00802034 	movhi	r2,128
811210ac:	10bfffc4 	addi	r2,r2,-1
811210b0:	308c703a 	and	r6,r6,r2
811210b4:	003feb06 	br	81121064 <__reset+0xfb101064>
811210b8:	3888b03a 	or	r4,r7,r2
811210bc:	203fe726 	beq	r4,zero,8112105c <__reset+0xfb10105c>
811210c0:	380c90fa 	slli	r6,r7,3
811210c4:	00c03fc4 	movi	r3,255
811210c8:	31808034 	orhi	r6,r6,512
811210cc:	003fd506 	br	81121024 <__reset+0xfb101024>
811210d0:	303fe226 	beq	r6,zero,8112105c <__reset+0xfb10105c>
811210d4:	00802034 	movhi	r2,128
811210d8:	31801034 	orhi	r6,r6,64
811210dc:	10bfffc4 	addi	r2,r2,-1
811210e0:	00ffffc4 	movi	r3,-1
811210e4:	308c703a 	and	r6,r6,r2
811210e8:	003fde06 	br	81121064 <__reset+0xfb101064>
811210ec:	013ffa44 	movi	r4,-23
811210f0:	19000e16 	blt	r3,r4,8112112c <__truncdfsf2+0x168>
811210f4:	01000784 	movi	r4,30
811210f8:	20c9c83a 	sub	r4,r4,r3
811210fc:	018007c4 	movi	r6,31
81121100:	39c02034 	orhi	r7,r7,128
81121104:	31000b16 	blt	r6,r4,81121134 <__truncdfsf2+0x170>
81121108:	423f2084 	addi	r8,r8,-894
8112110c:	120c983a 	sll	r6,r2,r8
81121110:	3a0e983a 	sll	r7,r7,r8
81121114:	1104d83a 	srl	r2,r2,r4
81121118:	300cc03a 	cmpne	r6,r6,zero
8112111c:	31ceb03a 	or	r7,r6,r7
81121120:	388cb03a 	or	r6,r7,r2
81121124:	0007883a 	mov	r3,zero
81121128:	003fbe06 	br	81121024 <__reset+0xfb101024>
8112112c:	0007883a 	mov	r3,zero
81121130:	003fd906 	br	81121098 <__reset+0xfb101098>
81121134:	01bfff84 	movi	r6,-2
81121138:	30cdc83a 	sub	r6,r6,r3
8112113c:	00c00804 	movi	r3,32
81121140:	398cd83a 	srl	r6,r7,r6
81121144:	20c00726 	beq	r4,r3,81121164 <__truncdfsf2+0x1a0>
81121148:	423f2884 	addi	r8,r8,-862
8112114c:	3a0e983a 	sll	r7,r7,r8
81121150:	3884b03a 	or	r2,r7,r2
81121154:	1004c03a 	cmpne	r2,r2,zero
81121158:	118cb03a 	or	r6,r2,r6
8112115c:	0007883a 	mov	r3,zero
81121160:	003fb006 	br	81121024 <__reset+0xfb101024>
81121164:	000f883a 	mov	r7,zero
81121168:	003ff906 	br	81121150 <__reset+0xfb101150>

8112116c <__clzsi2>:
8112116c:	00bfffd4 	movui	r2,65535
81121170:	11000536 	bltu	r2,r4,81121188 <__clzsi2+0x1c>
81121174:	00803fc4 	movi	r2,255
81121178:	11000f36 	bltu	r2,r4,811211b8 <__clzsi2+0x4c>
8112117c:	00800804 	movi	r2,32
81121180:	0007883a 	mov	r3,zero
81121184:	00000506 	br	8112119c <__clzsi2+0x30>
81121188:	00804034 	movhi	r2,256
8112118c:	10bfffc4 	addi	r2,r2,-1
81121190:	11000c2e 	bgeu	r2,r4,811211c4 <__clzsi2+0x58>
81121194:	00800204 	movi	r2,8
81121198:	00c00604 	movi	r3,24
8112119c:	20c8d83a 	srl	r4,r4,r3
811211a0:	00e04574 	movhi	r3,33045
811211a4:	18c13204 	addi	r3,r3,1224
811211a8:	1909883a 	add	r4,r3,r4
811211ac:	20c00003 	ldbu	r3,0(r4)
811211b0:	10c5c83a 	sub	r2,r2,r3
811211b4:	f800283a 	ret
811211b8:	00800604 	movi	r2,24
811211bc:	00c00204 	movi	r3,8
811211c0:	003ff606 	br	8112119c <__reset+0xfb10119c>
811211c4:	00800404 	movi	r2,16
811211c8:	1007883a 	mov	r3,r2
811211cc:	003ff306 	br	8112119c <__reset+0xfb10119c>

811211d0 <atoi>:
811211d0:	01800284 	movi	r6,10
811211d4:	000b883a 	mov	r5,zero
811211d8:	11232041 	jmpi	81123204 <strtol>

811211dc <_atoi_r>:
811211dc:	01c00284 	movi	r7,10
811211e0:	000d883a 	mov	r6,zero
811211e4:	1122fc41 	jmpi	81122fc4 <_strtol_r>

811211e8 <atoll>:
811211e8:	01800284 	movi	r6,10
811211ec:	000b883a 	mov	r5,zero
811211f0:	11232201 	jmpi	81123220 <strtoll>

811211f4 <_atoll_r>:
811211f4:	01c00284 	movi	r7,10
811211f8:	000d883a 	mov	r6,zero
811211fc:	112323c1 	jmpi	8112323c <_strtoll_r>

81121200 <_fopen_r>:
81121200:	defffa04 	addi	sp,sp,-24
81121204:	3005883a 	mov	r2,r6
81121208:	de00012e 	bgeu	sp,et,81121210 <_fopen_r+0x10>
8112120c:	003b68fa 	trap	3
81121210:	d80d883a 	mov	r6,sp
81121214:	dcc00415 	stw	r19,16(sp)
81121218:	2827883a 	mov	r19,r5
8112121c:	100b883a 	mov	r5,r2
81121220:	dc800315 	stw	r18,12(sp)
81121224:	dfc00515 	stw	ra,20(sp)
81121228:	dc400215 	stw	r17,8(sp)
8112122c:	dc000115 	stw	r16,4(sp)
81121230:	2025883a 	mov	r18,r4
81121234:	112b5100 	call	8112b510 <__sflags>
81121238:	10002726 	beq	r2,zero,811212d8 <_fopen_r+0xd8>
8112123c:	9009883a 	mov	r4,r18
81121240:	1023883a 	mov	r17,r2
81121244:	112b3880 	call	8112b388 <__sfp>
81121248:	1021883a 	mov	r16,r2
8112124c:	10002226 	beq	r2,zero,811212d8 <_fopen_r+0xd8>
81121250:	d9800017 	ldw	r6,0(sp)
81121254:	01c06d84 	movi	r7,438
81121258:	980b883a 	mov	r5,r19
8112125c:	9009883a 	mov	r4,r18
81121260:	112266c0 	call	8112266c <_open_r>
81121264:	10001916 	blt	r2,zero,811212cc <_fopen_r+0xcc>
81121268:	8080038d 	sth	r2,14(r16)
8112126c:	00a044b4 	movhi	r2,33042
81121270:	108b5204 	addi	r2,r2,11592
81121274:	80800815 	stw	r2,32(r16)
81121278:	00a044b4 	movhi	r2,33042
8112127c:	108b6b04 	addi	r2,r2,11692
81121280:	80800915 	stw	r2,36(r16)
81121284:	00a044b4 	movhi	r2,33042
81121288:	108b8c04 	addi	r2,r2,11824
8112128c:	80800a15 	stw	r2,40(r16)
81121290:	00a044b4 	movhi	r2,33042
81121294:	108ba504 	addi	r2,r2,11924
81121298:	8440030d 	sth	r17,12(r16)
8112129c:	84000715 	stw	r16,28(r16)
811212a0:	80800b15 	stw	r2,44(r16)
811212a4:	8c40400c 	andi	r17,r17,256
811212a8:	88000d1e 	bne	r17,zero,811212e0 <_fopen_r+0xe0>
811212ac:	8005883a 	mov	r2,r16
811212b0:	dfc00517 	ldw	ra,20(sp)
811212b4:	dcc00417 	ldw	r19,16(sp)
811212b8:	dc800317 	ldw	r18,12(sp)
811212bc:	dc400217 	ldw	r17,8(sp)
811212c0:	dc000117 	ldw	r16,4(sp)
811212c4:	dec00604 	addi	sp,sp,24
811212c8:	f800283a 	ret
811212cc:	112b4d00 	call	8112b4d0 <__sfp_lock_acquire>
811212d0:	8000030d 	sth	zero,12(r16)
811212d4:	112b4d40 	call	8112b4d4 <__sfp_lock_release>
811212d8:	0005883a 	mov	r2,zero
811212dc:	003ff406 	br	811212b0 <__reset+0xfb1012b0>
811212e0:	01c00084 	movi	r7,2
811212e4:	000d883a 	mov	r6,zero
811212e8:	800b883a 	mov	r5,r16
811212ec:	9009883a 	mov	r4,r18
811212f0:	11214200 	call	81121420 <_fseek_r>
811212f4:	8005883a 	mov	r2,r16
811212f8:	003fed06 	br	811212b0 <__reset+0xfb1012b0>

811212fc <fopen>:
811212fc:	00a04574 	movhi	r2,33045
81121300:	108bed04 	addi	r2,r2,12212
81121304:	280d883a 	mov	r6,r5
81121308:	200b883a 	mov	r5,r4
8112130c:	11000017 	ldw	r4,0(r2)
81121310:	11212001 	jmpi	81121200 <_fopen_r>

81121314 <_fprintf_r>:
81121314:	defffe04 	addi	sp,sp,-8
81121318:	2809883a 	mov	r4,r5
8112131c:	300b883a 	mov	r5,r6
81121320:	de00012e 	bgeu	sp,et,81121328 <_fprintf_r+0x14>
81121324:	003b68fa 	trap	3
81121328:	dfc00015 	stw	ra,0(sp)
8112132c:	d9c00115 	stw	r7,4(sp)
81121330:	d9800104 	addi	r6,sp,4
81121334:	11279040 	call	81127904 <__vfprintf_internal>
81121338:	dfc00017 	ldw	ra,0(sp)
8112133c:	dec00204 	addi	sp,sp,8
81121340:	f800283a 	ret

81121344 <fprintf>:
81121344:	defffd04 	addi	sp,sp,-12
81121348:	de00012e 	bgeu	sp,et,81121350 <fprintf+0xc>
8112134c:	003b68fa 	trap	3
81121350:	dfc00015 	stw	ra,0(sp)
81121354:	d9800115 	stw	r6,4(sp)
81121358:	d9c00215 	stw	r7,8(sp)
8112135c:	d9800104 	addi	r6,sp,4
81121360:	11279040 	call	81127904 <__vfprintf_internal>
81121364:	dfc00017 	ldw	ra,0(sp)
81121368:	dec00304 	addi	sp,sp,12
8112136c:	f800283a 	ret

81121370 <_fputc_r>:
81121370:	defffc04 	addi	sp,sp,-16
81121374:	de00012e 	bgeu	sp,et,8112137c <_fputc_r+0xc>
81121378:	003b68fa 	trap	3
8112137c:	dc000215 	stw	r16,8(sp)
81121380:	dfc00315 	stw	ra,12(sp)
81121384:	2021883a 	mov	r16,r4
81121388:	20000726 	beq	r4,zero,811213a8 <_fputc_r+0x38>
8112138c:	20800e17 	ldw	r2,56(r4)
81121390:	1000051e 	bne	r2,zero,811213a8 <_fputc_r+0x38>
81121394:	d9400015 	stw	r5,0(sp)
81121398:	d9800115 	stw	r6,4(sp)
8112139c:	112b4c00 	call	8112b4c0 <__sinit>
811213a0:	d9800117 	ldw	r6,4(sp)
811213a4:	d9400017 	ldw	r5,0(sp)
811213a8:	8009883a 	mov	r4,r16
811213ac:	dfc00317 	ldw	ra,12(sp)
811213b0:	dc000217 	ldw	r16,8(sp)
811213b4:	dec00404 	addi	sp,sp,16
811213b8:	11227501 	jmpi	81122750 <_putc_r>

811213bc <fputc>:
811213bc:	00a04574 	movhi	r2,33045
811213c0:	defffc04 	addi	sp,sp,-16
811213c4:	108bed04 	addi	r2,r2,12212
811213c8:	de00012e 	bgeu	sp,et,811213d0 <fputc+0x14>
811213cc:	003b68fa 	trap	3
811213d0:	dc000115 	stw	r16,4(sp)
811213d4:	14000017 	ldw	r16,0(r2)
811213d8:	dc400215 	stw	r17,8(sp)
811213dc:	dfc00315 	stw	ra,12(sp)
811213e0:	2023883a 	mov	r17,r4
811213e4:	80000626 	beq	r16,zero,81121400 <fputc+0x44>
811213e8:	80800e17 	ldw	r2,56(r16)
811213ec:	1000041e 	bne	r2,zero,81121400 <fputc+0x44>
811213f0:	8009883a 	mov	r4,r16
811213f4:	d9400015 	stw	r5,0(sp)
811213f8:	112b4c00 	call	8112b4c0 <__sinit>
811213fc:	d9400017 	ldw	r5,0(sp)
81121400:	280d883a 	mov	r6,r5
81121404:	8009883a 	mov	r4,r16
81121408:	880b883a 	mov	r5,r17
8112140c:	dfc00317 	ldw	ra,12(sp)
81121410:	dc400217 	ldw	r17,8(sp)
81121414:	dc000117 	ldw	r16,4(sp)
81121418:	dec00404 	addi	sp,sp,16
8112141c:	11227501 	jmpi	81122750 <_putc_r>

81121420 <_fseek_r>:
81121420:	11214401 	jmpi	81121440 <_fseeko_r>

81121424 <fseek>:
81121424:	00a04574 	movhi	r2,33045
81121428:	108bed04 	addi	r2,r2,12212
8112142c:	300f883a 	mov	r7,r6
81121430:	280d883a 	mov	r6,r5
81121434:	200b883a 	mov	r5,r4
81121438:	11000017 	ldw	r4,0(r2)
8112143c:	11214401 	jmpi	81121440 <_fseeko_r>

81121440 <_fseeko_r>:
81121440:	deffe804 	addi	sp,sp,-96
81121444:	de00012e 	bgeu	sp,et,8112144c <_fseeko_r+0xc>
81121448:	003b68fa 	trap	3
8112144c:	dd401415 	stw	r21,80(sp)
81121450:	dc801115 	stw	r18,68(sp)
81121454:	dc401015 	stw	r17,64(sp)
81121458:	dc000f15 	stw	r16,60(sp)
8112145c:	dfc01715 	stw	ra,92(sp)
81121460:	ddc01615 	stw	r23,88(sp)
81121464:	dd801515 	stw	r22,84(sp)
81121468:	dd001315 	stw	r20,76(sp)
8112146c:	dcc01215 	stw	r19,72(sp)
81121470:	2023883a 	mov	r17,r4
81121474:	2821883a 	mov	r16,r5
81121478:	302b883a 	mov	r21,r6
8112147c:	3825883a 	mov	r18,r7
81121480:	20000226 	beq	r4,zero,8112148c <_fseeko_r+0x4c>
81121484:	20800e17 	ldw	r2,56(r4)
81121488:	10005a26 	beq	r2,zero,811215f4 <_fseeko_r+0x1b4>
8112148c:	8080030b 	ldhu	r2,12(r16)
81121490:	00c04204 	movi	r3,264
81121494:	1080420c 	andi	r2,r2,264
81121498:	10c05b26 	beq	r2,r3,81121608 <_fseeko_r+0x1c8>
8112149c:	85000a17 	ldw	r20,40(r16)
811214a0:	a000f626 	beq	r20,zero,8112187c <_fseeko_r+0x43c>
811214a4:	00800044 	movi	r2,1
811214a8:	90803e26 	beq	r18,r2,811215a4 <_fseeko_r+0x164>
811214ac:	00800084 	movi	r2,2
811214b0:	90801026 	beq	r18,r2,811214f4 <_fseeko_r+0xb4>
811214b4:	90000f26 	beq	r18,zero,811214f4 <_fseeko_r+0xb4>
811214b8:	00800584 	movi	r2,22
811214bc:	88800015 	stw	r2,0(r17)
811214c0:	04ffffc4 	movi	r19,-1
811214c4:	9805883a 	mov	r2,r19
811214c8:	dfc01717 	ldw	ra,92(sp)
811214cc:	ddc01617 	ldw	r23,88(sp)
811214d0:	dd801517 	ldw	r22,84(sp)
811214d4:	dd401417 	ldw	r21,80(sp)
811214d8:	dd001317 	ldw	r20,76(sp)
811214dc:	dcc01217 	ldw	r19,72(sp)
811214e0:	dc801117 	ldw	r18,68(sp)
811214e4:	dc401017 	ldw	r17,64(sp)
811214e8:	dc000f17 	ldw	r16,60(sp)
811214ec:	dec01804 	addi	sp,sp,96
811214f0:	f800283a 	ret
811214f4:	80800417 	ldw	r2,16(r16)
811214f8:	002f883a 	mov	r23,zero
811214fc:	0027883a 	mov	r19,zero
81121500:	1000cb26 	beq	r2,zero,81121830 <_fseeko_r+0x3f0>
81121504:	8080030b 	ldhu	r2,12(r16)
81121508:	10c2068c 	andi	r3,r2,2074
8112150c:	1800071e 	bne	r3,zero,8112152c <_fseeko_r+0xec>
81121510:	10c1000c 	andi	r3,r2,1024
81121514:	1800451e 	bne	r3,zero,8112162c <_fseeko_r+0x1ec>
81121518:	00e044b4 	movhi	r3,33042
8112151c:	18cb8c04 	addi	r3,r3,11824
81121520:	a0c0b726 	beq	r20,r3,81121800 <_fseeko_r+0x3c0>
81121524:	10820014 	ori	r2,r2,2048
81121528:	8080030d 	sth	r2,12(r16)
8112152c:	800b883a 	mov	r5,r16
81121530:	8809883a 	mov	r4,r17
81121534:	112b0c40 	call	8112b0c4 <_fflush_r>
81121538:	1027883a 	mov	r19,r2
8112153c:	103fe01e 	bne	r2,zero,811214c0 <__reset+0xfb1014c0>
81121540:	81400717 	ldw	r5,28(r16)
81121544:	900f883a 	mov	r7,r18
81121548:	a80d883a 	mov	r6,r21
8112154c:	8809883a 	mov	r4,r17
81121550:	a03ee83a 	callr	r20
81121554:	00ffffc4 	movi	r3,-1
81121558:	10ffd926 	beq	r2,r3,811214c0 <__reset+0xfb1014c0>
8112155c:	81400c17 	ldw	r5,48(r16)
81121560:	28000526 	beq	r5,zero,81121578 <_fseeko_r+0x138>
81121564:	80801004 	addi	r2,r16,64
81121568:	28800226 	beq	r5,r2,81121574 <_fseeko_r+0x134>
8112156c:	8809883a 	mov	r4,r17
81121570:	112b9580 	call	8112b958 <_free_r>
81121574:	80000c15 	stw	zero,48(r16)
81121578:	8080030b 	ldhu	r2,12(r16)
8112157c:	80c00417 	ldw	r3,16(r16)
81121580:	80000115 	stw	zero,4(r16)
81121584:	10bdf7cc 	andi	r2,r2,63455
81121588:	80c00015 	stw	r3,0(r16)
8112158c:	8080030d 	sth	r2,12(r16)
81121590:	01800204 	movi	r6,8
81121594:	000b883a 	mov	r5,zero
81121598:	81001704 	addi	r4,r16,92
8112159c:	11225440 	call	81122544 <memset>
811215a0:	003fc806 	br	811214c4 <__reset+0xfb1014c4>
811215a4:	800b883a 	mov	r5,r16
811215a8:	8809883a 	mov	r4,r17
811215ac:	112b0c40 	call	8112b0c4 <_fflush_r>
811215b0:	8080030b 	ldhu	r2,12(r16)
811215b4:	10c4000c 	andi	r3,r2,4096
811215b8:	18008726 	beq	r3,zero,811217d8 <_fseeko_r+0x398>
811215bc:	84c01417 	ldw	r19,80(r16)
811215c0:	10c0010c 	andi	r3,r2,4
811215c4:	1800431e 	bne	r3,zero,811216d4 <_fseeko_r+0x294>
811215c8:	1080020c 	andi	r2,r2,8
811215cc:	10008026 	beq	r2,zero,811217d0 <_fseeko_r+0x390>
811215d0:	80c00017 	ldw	r3,0(r16)
811215d4:	80800417 	ldw	r2,16(r16)
811215d8:	18000226 	beq	r3,zero,811215e4 <_fseeko_r+0x1a4>
811215dc:	1887c83a 	sub	r3,r3,r2
811215e0:	98e7883a 	add	r19,r19,r3
811215e4:	aceb883a 	add	r21,r21,r19
811215e8:	05c00044 	movi	r23,1
811215ec:	0025883a 	mov	r18,zero
811215f0:	003fc306 	br	81121500 <__reset+0xfb101500>
811215f4:	112b4c00 	call	8112b4c0 <__sinit>
811215f8:	8080030b 	ldhu	r2,12(r16)
811215fc:	00c04204 	movi	r3,264
81121600:	1080420c 	andi	r2,r2,264
81121604:	10ffa51e 	bne	r2,r3,8112149c <__reset+0xfb10149c>
81121608:	800b883a 	mov	r5,r16
8112160c:	8809883a 	mov	r4,r17
81121610:	112b0c40 	call	8112b0c4 <_fflush_r>
81121614:	003fa106 	br	8112149c <__reset+0xfb10149c>
81121618:	8080030b 	ldhu	r2,12(r16)
8112161c:	00c10004 	movi	r3,1024
81121620:	80c01315 	stw	r3,76(r16)
81121624:	10c4b03a 	or	r2,r2,r3
81121628:	8080030d 	sth	r2,12(r16)
8112162c:	9000311e 	bne	r18,zero,811216f4 <_fseeko_r+0x2b4>
81121630:	a82d883a 	mov	r22,r21
81121634:	b800371e 	bne	r23,zero,81121714 <_fseeko_r+0x2d4>
81121638:	8080030b 	ldhu	r2,12(r16)
8112163c:	1084000c 	andi	r2,r2,4096
81121640:	10007f26 	beq	r2,zero,81121840 <_fseeko_r+0x400>
81121644:	80801417 	ldw	r2,80(r16)
81121648:	81800117 	ldw	r6,4(r16)
8112164c:	81400c17 	ldw	r5,48(r16)
81121650:	11a7c83a 	sub	r19,r2,r6
81121654:	28008226 	beq	r5,zero,81121860 <_fseeko_r+0x420>
81121658:	81c00f17 	ldw	r7,60(r16)
8112165c:	99e7c83a 	sub	r19,r19,r7
81121660:	81000e17 	ldw	r4,56(r16)
81121664:	80800417 	ldw	r2,16(r16)
81121668:	99a7883a 	add	r19,r19,r6
8112166c:	2087c83a 	sub	r3,r4,r2
81121670:	98e7c83a 	sub	r19,r19,r3
81121674:	38c7883a 	add	r3,r7,r3
81121678:	b4c02b16 	blt	r22,r19,81121728 <_fseeko_r+0x2e8>
8112167c:	98c9883a 	add	r4,r19,r3
81121680:	b100292e 	bgeu	r22,r4,81121728 <_fseeko_r+0x2e8>
81121684:	b4e7c83a 	sub	r19,r22,r19
81121688:	14c5883a 	add	r2,r2,r19
8112168c:	1ce7c83a 	sub	r19,r3,r19
81121690:	80800015 	stw	r2,0(r16)
81121694:	84c00115 	stw	r19,4(r16)
81121698:	28000526 	beq	r5,zero,811216b0 <_fseeko_r+0x270>
8112169c:	80801004 	addi	r2,r16,64
811216a0:	28800226 	beq	r5,r2,811216ac <_fseeko_r+0x26c>
811216a4:	8809883a 	mov	r4,r17
811216a8:	112b9580 	call	8112b958 <_free_r>
811216ac:	80000c15 	stw	zero,48(r16)
811216b0:	8080030b 	ldhu	r2,12(r16)
811216b4:	01800204 	movi	r6,8
811216b8:	000b883a 	mov	r5,zero
811216bc:	10bff7cc 	andi	r2,r2,65503
811216c0:	8080030d 	sth	r2,12(r16)
811216c4:	81001704 	addi	r4,r16,92
811216c8:	11225440 	call	81122544 <memset>
811216cc:	0027883a 	mov	r19,zero
811216d0:	003f7c06 	br	811214c4 <__reset+0xfb1014c4>
811216d4:	80c00117 	ldw	r3,4(r16)
811216d8:	80800c17 	ldw	r2,48(r16)
811216dc:	98e7c83a 	sub	r19,r19,r3
811216e0:	10003b26 	beq	r2,zero,811217d0 <_fseeko_r+0x390>
811216e4:	80c00f17 	ldw	r3,60(r16)
811216e8:	80800417 	ldw	r2,16(r16)
811216ec:	98e7c83a 	sub	r19,r19,r3
811216f0:	003fbc06 	br	811215e4 <__reset+0xfb1015e4>
811216f4:	8140038f 	ldh	r5,14(r16)
811216f8:	d80d883a 	mov	r6,sp
811216fc:	8809883a 	mov	r4,r17
81121700:	11218a80 	call	811218a8 <_fstat_r>
81121704:	103f891e 	bne	r2,zero,8112152c <__reset+0xfb10152c>
81121708:	dd800417 	ldw	r22,16(sp)
8112170c:	adad883a 	add	r22,r21,r22
81121710:	b83fc926 	beq	r23,zero,81121638 <__reset+0xfb101638>
81121714:	81400c17 	ldw	r5,48(r16)
81121718:	81800117 	ldw	r6,4(r16)
8112171c:	28005026 	beq	r5,zero,81121860 <_fseeko_r+0x420>
81121720:	81c00f17 	ldw	r7,60(r16)
81121724:	003fce06 	br	81121660 <__reset+0xfb101660>
81121728:	84c01317 	ldw	r19,76(r16)
8112172c:	81400717 	ldw	r5,28(r16)
81121730:	000f883a 	mov	r7,zero
81121734:	04e7c83a 	sub	r19,zero,r19
81121738:	9da6703a 	and	r19,r19,r22
8112173c:	980d883a 	mov	r6,r19
81121740:	8809883a 	mov	r4,r17
81121744:	a03ee83a 	callr	r20
81121748:	00ffffc4 	movi	r3,-1
8112174c:	10ff7726 	beq	r2,r3,8112152c <__reset+0xfb10152c>
81121750:	80800417 	ldw	r2,16(r16)
81121754:	81400c17 	ldw	r5,48(r16)
81121758:	80000115 	stw	zero,4(r16)
8112175c:	80800015 	stw	r2,0(r16)
81121760:	28000526 	beq	r5,zero,81121778 <_fseeko_r+0x338>
81121764:	80801004 	addi	r2,r16,64
81121768:	28800226 	beq	r5,r2,81121774 <_fseeko_r+0x334>
8112176c:	8809883a 	mov	r4,r17
81121770:	112b9580 	call	8112b958 <_free_r>
81121774:	80000c15 	stw	zero,48(r16)
81121778:	8080030b 	ldhu	r2,12(r16)
8112177c:	b4e7c83a 	sub	r19,r22,r19
81121780:	10bff7cc 	andi	r2,r2,65503
81121784:	8080030d 	sth	r2,12(r16)
81121788:	98000b26 	beq	r19,zero,811217b8 <_fseeko_r+0x378>
8112178c:	800b883a 	mov	r5,r16
81121790:	8809883a 	mov	r4,r17
81121794:	11229c00 	call	811229c0 <__srefill_r>
81121798:	103f641e 	bne	r2,zero,8112152c <__reset+0xfb10152c>
8112179c:	80800117 	ldw	r2,4(r16)
811217a0:	14ff6236 	bltu	r2,r19,8112152c <__reset+0xfb10152c>
811217a4:	80c00017 	ldw	r3,0(r16)
811217a8:	14c5c83a 	sub	r2,r2,r19
811217ac:	80800115 	stw	r2,4(r16)
811217b0:	1ce7883a 	add	r19,r3,r19
811217b4:	84c00015 	stw	r19,0(r16)
811217b8:	01800204 	movi	r6,8
811217bc:	000b883a 	mov	r5,zero
811217c0:	81001704 	addi	r4,r16,92
811217c4:	11225440 	call	81122544 <memset>
811217c8:	0027883a 	mov	r19,zero
811217cc:	003f3d06 	br	811214c4 <__reset+0xfb1014c4>
811217d0:	80800417 	ldw	r2,16(r16)
811217d4:	003f8306 	br	811215e4 <__reset+0xfb1015e4>
811217d8:	81400717 	ldw	r5,28(r16)
811217dc:	900f883a 	mov	r7,r18
811217e0:	000d883a 	mov	r6,zero
811217e4:	8809883a 	mov	r4,r17
811217e8:	a03ee83a 	callr	r20
811217ec:	1027883a 	mov	r19,r2
811217f0:	00bfffc4 	movi	r2,-1
811217f4:	98bf3226 	beq	r19,r2,811214c0 <__reset+0xfb1014c0>
811217f8:	8080030b 	ldhu	r2,12(r16)
811217fc:	003f7006 	br	811215c0 <__reset+0xfb1015c0>
81121800:	8140038f 	ldh	r5,14(r16)
81121804:	283f4716 	blt	r5,zero,81121524 <__reset+0xfb101524>
81121808:	d80d883a 	mov	r6,sp
8112180c:	8809883a 	mov	r4,r17
81121810:	11218a80 	call	811218a8 <_fstat_r>
81121814:	1000041e 	bne	r2,zero,81121828 <_fseeko_r+0x3e8>
81121818:	d8800117 	ldw	r2,4(sp)
8112181c:	00e00014 	movui	r3,32768
81121820:	10bc000c 	andi	r2,r2,61440
81121824:	10ff7c26 	beq	r2,r3,81121618 <__reset+0xfb101618>
81121828:	8080030b 	ldhu	r2,12(r16)
8112182c:	003f3d06 	br	81121524 <__reset+0xfb101524>
81121830:	800b883a 	mov	r5,r16
81121834:	8809883a 	mov	r4,r17
81121838:	1121a1c0 	call	81121a1c <__smakebuf_r>
8112183c:	003f3106 	br	81121504 <__reset+0xfb101504>
81121840:	81400717 	ldw	r5,28(r16)
81121844:	01c00044 	movi	r7,1
81121848:	000d883a 	mov	r6,zero
8112184c:	8809883a 	mov	r4,r17
81121850:	a03ee83a 	callr	r20
81121854:	00ffffc4 	movi	r3,-1
81121858:	10ff7b1e 	bne	r2,r3,81121648 <__reset+0xfb101648>
8112185c:	003f3306 	br	8112152c <__reset+0xfb10152c>
81121860:	80c00017 	ldw	r3,0(r16)
81121864:	80800417 	ldw	r2,16(r16)
81121868:	000b883a 	mov	r5,zero
8112186c:	1887c83a 	sub	r3,r3,r2
81121870:	98e7c83a 	sub	r19,r19,r3
81121874:	30c7883a 	add	r3,r6,r3
81121878:	003f7f06 	br	81121678 <__reset+0xfb101678>
8112187c:	00800744 	movi	r2,29
81121880:	88800015 	stw	r2,0(r17)
81121884:	04ffffc4 	movi	r19,-1
81121888:	003f0e06 	br	811214c4 <__reset+0xfb1014c4>

8112188c <fseeko>:
8112188c:	00a04574 	movhi	r2,33045
81121890:	108bed04 	addi	r2,r2,12212
81121894:	300f883a 	mov	r7,r6
81121898:	280d883a 	mov	r6,r5
8112189c:	200b883a 	mov	r5,r4
811218a0:	11000017 	ldw	r4,0(r2)
811218a4:	11214401 	jmpi	81121440 <_fseeko_r>

811218a8 <_fstat_r>:
811218a8:	defffd04 	addi	sp,sp,-12
811218ac:	de00012e 	bgeu	sp,et,811218b4 <_fstat_r+0xc>
811218b0:	003b68fa 	trap	3
811218b4:	2805883a 	mov	r2,r5
811218b8:	dc000015 	stw	r16,0(sp)
811218bc:	04204574 	movhi	r16,33045
811218c0:	dc400115 	stw	r17,4(sp)
811218c4:	840c6004 	addi	r16,r16,12672
811218c8:	2023883a 	mov	r17,r4
811218cc:	300b883a 	mov	r5,r6
811218d0:	1009883a 	mov	r4,r2
811218d4:	dfc00215 	stw	ra,8(sp)
811218d8:	80000015 	stw	zero,0(r16)
811218dc:	11362f00 	call	811362f0 <fstat>
811218e0:	00ffffc4 	movi	r3,-1
811218e4:	10c00526 	beq	r2,r3,811218fc <_fstat_r+0x54>
811218e8:	dfc00217 	ldw	ra,8(sp)
811218ec:	dc400117 	ldw	r17,4(sp)
811218f0:	dc000017 	ldw	r16,0(sp)
811218f4:	dec00304 	addi	sp,sp,12
811218f8:	f800283a 	ret
811218fc:	80c00017 	ldw	r3,0(r16)
81121900:	183ff926 	beq	r3,zero,811218e8 <__reset+0xfb1018e8>
81121904:	88c00015 	stw	r3,0(r17)
81121908:	003ff706 	br	811218e8 <__reset+0xfb1018e8>

8112190c <_fwrite_r>:
8112190c:	defff504 	addi	sp,sp,-44
81121910:	de00012e 	bgeu	sp,et,81121918 <_fwrite_r+0xc>
81121914:	003b68fa 	trap	3
81121918:	dc800815 	stw	r18,32(sp)
8112191c:	39a5383a 	mul	r18,r7,r6
81121920:	d8800304 	addi	r2,sp,12
81121924:	d8800015 	stw	r2,0(sp)
81121928:	00800044 	movi	r2,1
8112192c:	dcc00915 	stw	r19,36(sp)
81121930:	dc400715 	stw	r17,28(sp)
81121934:	dc000615 	stw	r16,24(sp)
81121938:	d9400315 	stw	r5,12(sp)
8112193c:	dfc00a15 	stw	ra,40(sp)
81121940:	dc800415 	stw	r18,16(sp)
81121944:	dc800215 	stw	r18,8(sp)
81121948:	d8800115 	stw	r2,4(sp)
8112194c:	3027883a 	mov	r19,r6
81121950:	3821883a 	mov	r16,r7
81121954:	2023883a 	mov	r17,r4
81121958:	d9400b17 	ldw	r5,44(sp)
8112195c:	20000226 	beq	r4,zero,81121968 <_fwrite_r+0x5c>
81121960:	20800e17 	ldw	r2,56(r4)
81121964:	10001a26 	beq	r2,zero,811219d0 <_fwrite_r+0xc4>
81121968:	2880030b 	ldhu	r2,12(r5)
8112196c:	10c8000c 	andi	r3,r2,8192
81121970:	1800061e 	bne	r3,zero,8112198c <_fwrite_r+0x80>
81121974:	29001917 	ldw	r4,100(r5)
81121978:	00f7ffc4 	movi	r3,-8193
8112197c:	10880014 	ori	r2,r2,8192
81121980:	20c6703a 	and	r3,r4,r3
81121984:	2880030d 	sth	r2,12(r5)
81121988:	28c01915 	stw	r3,100(r5)
8112198c:	d80d883a 	mov	r6,sp
81121990:	8809883a 	mov	r4,r17
81121994:	112bc700 	call	8112bc70 <__sfvwrite_r>
81121998:	10000b26 	beq	r2,zero,811219c8 <_fwrite_r+0xbc>
8112199c:	d9000217 	ldw	r4,8(sp)
811219a0:	980b883a 	mov	r5,r19
811219a4:	9109c83a 	sub	r4,r18,r4
811219a8:	113497c0 	call	8113497c <__udivsi3>
811219ac:	dfc00a17 	ldw	ra,40(sp)
811219b0:	dcc00917 	ldw	r19,36(sp)
811219b4:	dc800817 	ldw	r18,32(sp)
811219b8:	dc400717 	ldw	r17,28(sp)
811219bc:	dc000617 	ldw	r16,24(sp)
811219c0:	dec00b04 	addi	sp,sp,44
811219c4:	f800283a 	ret
811219c8:	8005883a 	mov	r2,r16
811219cc:	003ff706 	br	811219ac <__reset+0xfb1019ac>
811219d0:	d9400515 	stw	r5,20(sp)
811219d4:	112b4c00 	call	8112b4c0 <__sinit>
811219d8:	d9400517 	ldw	r5,20(sp)
811219dc:	003fe206 	br	81121968 <__reset+0xfb101968>

811219e0 <fwrite>:
811219e0:	defffe04 	addi	sp,sp,-8
811219e4:	00a04574 	movhi	r2,33045
811219e8:	de00012e 	bgeu	sp,et,811219f0 <fwrite+0x10>
811219ec:	003b68fa 	trap	3
811219f0:	108bed04 	addi	r2,r2,12212
811219f4:	d9c00015 	stw	r7,0(sp)
811219f8:	300f883a 	mov	r7,r6
811219fc:	280d883a 	mov	r6,r5
81121a00:	200b883a 	mov	r5,r4
81121a04:	11000017 	ldw	r4,0(r2)
81121a08:	dfc00115 	stw	ra,4(sp)
81121a0c:	112190c0 	call	8112190c <_fwrite_r>
81121a10:	dfc00117 	ldw	ra,4(sp)
81121a14:	dec00204 	addi	sp,sp,8
81121a18:	f800283a 	ret

81121a1c <__smakebuf_r>:
81121a1c:	2880030b 	ldhu	r2,12(r5)
81121a20:	10c0008c 	andi	r3,r2,2
81121a24:	1800431e 	bne	r3,zero,81121b34 <__smakebuf_r+0x118>
81121a28:	deffec04 	addi	sp,sp,-80
81121a2c:	de00012e 	bgeu	sp,et,81121a34 <__smakebuf_r+0x18>
81121a30:	003b68fa 	trap	3
81121a34:	dc000f15 	stw	r16,60(sp)
81121a38:	2821883a 	mov	r16,r5
81121a3c:	2940038f 	ldh	r5,14(r5)
81121a40:	dc401015 	stw	r17,64(sp)
81121a44:	dfc01315 	stw	ra,76(sp)
81121a48:	dcc01215 	stw	r19,72(sp)
81121a4c:	dc801115 	stw	r18,68(sp)
81121a50:	2023883a 	mov	r17,r4
81121a54:	28001c16 	blt	r5,zero,81121ac8 <__smakebuf_r+0xac>
81121a58:	d80d883a 	mov	r6,sp
81121a5c:	11218a80 	call	811218a8 <_fstat_r>
81121a60:	10001816 	blt	r2,zero,81121ac4 <__smakebuf_r+0xa8>
81121a64:	d8800117 	ldw	r2,4(sp)
81121a68:	00e00014 	movui	r3,32768
81121a6c:	10bc000c 	andi	r2,r2,61440
81121a70:	14c80020 	cmpeqi	r19,r2,8192
81121a74:	10c03726 	beq	r2,r3,81121b54 <__smakebuf_r+0x138>
81121a78:	80c0030b 	ldhu	r3,12(r16)
81121a7c:	18c20014 	ori	r3,r3,2048
81121a80:	80c0030d 	sth	r3,12(r16)
81121a84:	00c80004 	movi	r3,8192
81121a88:	10c0521e 	bne	r2,r3,81121bd4 <__smakebuf_r+0x1b8>
81121a8c:	8140038f 	ldh	r5,14(r16)
81121a90:	8809883a 	mov	r4,r17
81121a94:	112c2cc0 	call	8112c2cc <_isatty_r>
81121a98:	10004c26 	beq	r2,zero,81121bcc <__smakebuf_r+0x1b0>
81121a9c:	8080030b 	ldhu	r2,12(r16)
81121aa0:	80c010c4 	addi	r3,r16,67
81121aa4:	80c00015 	stw	r3,0(r16)
81121aa8:	10800054 	ori	r2,r2,1
81121aac:	8080030d 	sth	r2,12(r16)
81121ab0:	00800044 	movi	r2,1
81121ab4:	80c00415 	stw	r3,16(r16)
81121ab8:	80800515 	stw	r2,20(r16)
81121abc:	04810004 	movi	r18,1024
81121ac0:	00000706 	br	81121ae0 <__smakebuf_r+0xc4>
81121ac4:	8080030b 	ldhu	r2,12(r16)
81121ac8:	10c0200c 	andi	r3,r2,128
81121acc:	18001f1e 	bne	r3,zero,81121b4c <__smakebuf_r+0x130>
81121ad0:	04810004 	movi	r18,1024
81121ad4:	10820014 	ori	r2,r2,2048
81121ad8:	8080030d 	sth	r2,12(r16)
81121adc:	0027883a 	mov	r19,zero
81121ae0:	900b883a 	mov	r5,r18
81121ae4:	8809883a 	mov	r4,r17
81121ae8:	1121be00 	call	81121be0 <_malloc_r>
81121aec:	10002c26 	beq	r2,zero,81121ba0 <__smakebuf_r+0x184>
81121af0:	80c0030b 	ldhu	r3,12(r16)
81121af4:	012044f4 	movhi	r4,33043
81121af8:	212c5804 	addi	r4,r4,-20128
81121afc:	89000f15 	stw	r4,60(r17)
81121b00:	18c02014 	ori	r3,r3,128
81121b04:	80c0030d 	sth	r3,12(r16)
81121b08:	80800015 	stw	r2,0(r16)
81121b0c:	80800415 	stw	r2,16(r16)
81121b10:	84800515 	stw	r18,20(r16)
81121b14:	98001a1e 	bne	r19,zero,81121b80 <__smakebuf_r+0x164>
81121b18:	dfc01317 	ldw	ra,76(sp)
81121b1c:	dcc01217 	ldw	r19,72(sp)
81121b20:	dc801117 	ldw	r18,68(sp)
81121b24:	dc401017 	ldw	r17,64(sp)
81121b28:	dc000f17 	ldw	r16,60(sp)
81121b2c:	dec01404 	addi	sp,sp,80
81121b30:	f800283a 	ret
81121b34:	288010c4 	addi	r2,r5,67
81121b38:	28800015 	stw	r2,0(r5)
81121b3c:	28800415 	stw	r2,16(r5)
81121b40:	00800044 	movi	r2,1
81121b44:	28800515 	stw	r2,20(r5)
81121b48:	f800283a 	ret
81121b4c:	04801004 	movi	r18,64
81121b50:	003fe006 	br	81121ad4 <__reset+0xfb101ad4>
81121b54:	81000a17 	ldw	r4,40(r16)
81121b58:	00e044b4 	movhi	r3,33042
81121b5c:	18cb8c04 	addi	r3,r3,11824
81121b60:	20ffc51e 	bne	r4,r3,81121a78 <__reset+0xfb101a78>
81121b64:	8080030b 	ldhu	r2,12(r16)
81121b68:	04810004 	movi	r18,1024
81121b6c:	84801315 	stw	r18,76(r16)
81121b70:	1484b03a 	or	r2,r2,r18
81121b74:	8080030d 	sth	r2,12(r16)
81121b78:	0027883a 	mov	r19,zero
81121b7c:	003fd806 	br	81121ae0 <__reset+0xfb101ae0>
81121b80:	8140038f 	ldh	r5,14(r16)
81121b84:	8809883a 	mov	r4,r17
81121b88:	112c2cc0 	call	8112c2cc <_isatty_r>
81121b8c:	103fe226 	beq	r2,zero,81121b18 <__reset+0xfb101b18>
81121b90:	8080030b 	ldhu	r2,12(r16)
81121b94:	10800054 	ori	r2,r2,1
81121b98:	8080030d 	sth	r2,12(r16)
81121b9c:	003fde06 	br	81121b18 <__reset+0xfb101b18>
81121ba0:	8080030b 	ldhu	r2,12(r16)
81121ba4:	10c0800c 	andi	r3,r2,512
81121ba8:	183fdb1e 	bne	r3,zero,81121b18 <__reset+0xfb101b18>
81121bac:	10800094 	ori	r2,r2,2
81121bb0:	80c010c4 	addi	r3,r16,67
81121bb4:	8080030d 	sth	r2,12(r16)
81121bb8:	00800044 	movi	r2,1
81121bbc:	80c00015 	stw	r3,0(r16)
81121bc0:	80c00415 	stw	r3,16(r16)
81121bc4:	80800515 	stw	r2,20(r16)
81121bc8:	003fd306 	br	81121b18 <__reset+0xfb101b18>
81121bcc:	04810004 	movi	r18,1024
81121bd0:	003fc306 	br	81121ae0 <__reset+0xfb101ae0>
81121bd4:	0027883a 	mov	r19,zero
81121bd8:	04810004 	movi	r18,1024
81121bdc:	003fc006 	br	81121ae0 <__reset+0xfb101ae0>

81121be0 <_malloc_r>:
81121be0:	defff504 	addi	sp,sp,-44
81121be4:	de00012e 	bgeu	sp,et,81121bec <_malloc_r+0xc>
81121be8:	003b68fa 	trap	3
81121bec:	288002c4 	addi	r2,r5,11
81121bf0:	dc800315 	stw	r18,12(sp)
81121bf4:	dfc00a15 	stw	ra,40(sp)
81121bf8:	df000915 	stw	fp,36(sp)
81121bfc:	ddc00815 	stw	r23,32(sp)
81121c00:	dd800715 	stw	r22,28(sp)
81121c04:	dd400615 	stw	r21,24(sp)
81121c08:	dd000515 	stw	r20,20(sp)
81121c0c:	dcc00415 	stw	r19,16(sp)
81121c10:	dc400215 	stw	r17,8(sp)
81121c14:	dc000115 	stw	r16,4(sp)
81121c18:	00c00584 	movi	r3,22
81121c1c:	2025883a 	mov	r18,r4
81121c20:	18807f2e 	bgeu	r3,r2,81121e20 <_malloc_r+0x240>
81121c24:	047ffe04 	movi	r17,-8
81121c28:	1462703a 	and	r17,r2,r17
81121c2c:	8800a316 	blt	r17,zero,81121ebc <_malloc_r+0x2dc>
81121c30:	8940a236 	bltu	r17,r5,81121ebc <_malloc_r+0x2dc>
81121c34:	1137e380 	call	81137e38 <__malloc_lock>
81121c38:	00807dc4 	movi	r2,503
81121c3c:	1441e92e 	bgeu	r2,r17,811223e4 <_malloc_r+0x804>
81121c40:	8804d27a 	srli	r2,r17,9
81121c44:	1000a126 	beq	r2,zero,81121ecc <_malloc_r+0x2ec>
81121c48:	00c00104 	movi	r3,4
81121c4c:	18811e36 	bltu	r3,r2,811220c8 <_malloc_r+0x4e8>
81121c50:	8804d1ba 	srli	r2,r17,6
81121c54:	12000e44 	addi	r8,r2,57
81121c58:	11c00e04 	addi	r7,r2,56
81121c5c:	4209883a 	add	r4,r8,r8
81121c60:	04e04574 	movhi	r19,33045
81121c64:	2109883a 	add	r4,r4,r4
81121c68:	9cc5ab04 	addi	r19,r19,5804
81121c6c:	2109883a 	add	r4,r4,r4
81121c70:	9909883a 	add	r4,r19,r4
81121c74:	24000117 	ldw	r16,4(r4)
81121c78:	213ffe04 	addi	r4,r4,-8
81121c7c:	24009726 	beq	r4,r16,81121edc <_malloc_r+0x2fc>
81121c80:	80800117 	ldw	r2,4(r16)
81121c84:	01bfff04 	movi	r6,-4
81121c88:	014003c4 	movi	r5,15
81121c8c:	1184703a 	and	r2,r2,r6
81121c90:	1447c83a 	sub	r3,r2,r17
81121c94:	28c00716 	blt	r5,r3,81121cb4 <_malloc_r+0xd4>
81121c98:	1800920e 	bge	r3,zero,81121ee4 <_malloc_r+0x304>
81121c9c:	84000317 	ldw	r16,12(r16)
81121ca0:	24008e26 	beq	r4,r16,81121edc <_malloc_r+0x2fc>
81121ca4:	80800117 	ldw	r2,4(r16)
81121ca8:	1184703a 	and	r2,r2,r6
81121cac:	1447c83a 	sub	r3,r2,r17
81121cb0:	28fff90e 	bge	r5,r3,81121c98 <__reset+0xfb101c98>
81121cb4:	3809883a 	mov	r4,r7
81121cb8:	01a04574 	movhi	r6,33045
81121cbc:	9c000417 	ldw	r16,16(r19)
81121cc0:	3185ab04 	addi	r6,r6,5804
81121cc4:	32000204 	addi	r8,r6,8
81121cc8:	82013426 	beq	r16,r8,8112219c <_malloc_r+0x5bc>
81121ccc:	80c00117 	ldw	r3,4(r16)
81121cd0:	00bfff04 	movi	r2,-4
81121cd4:	188e703a 	and	r7,r3,r2
81121cd8:	3c45c83a 	sub	r2,r7,r17
81121cdc:	00c003c4 	movi	r3,15
81121ce0:	18811f16 	blt	r3,r2,81122160 <_malloc_r+0x580>
81121ce4:	32000515 	stw	r8,20(r6)
81121ce8:	32000415 	stw	r8,16(r6)
81121cec:	10007f0e 	bge	r2,zero,81121eec <_malloc_r+0x30c>
81121cf0:	00807fc4 	movi	r2,511
81121cf4:	11c0fd36 	bltu	r2,r7,811220ec <_malloc_r+0x50c>
81121cf8:	3806d0fa 	srli	r3,r7,3
81121cfc:	01c00044 	movi	r7,1
81121d00:	30800117 	ldw	r2,4(r6)
81121d04:	19400044 	addi	r5,r3,1
81121d08:	294b883a 	add	r5,r5,r5
81121d0c:	1807d0ba 	srai	r3,r3,2
81121d10:	294b883a 	add	r5,r5,r5
81121d14:	294b883a 	add	r5,r5,r5
81121d18:	298b883a 	add	r5,r5,r6
81121d1c:	38c6983a 	sll	r3,r7,r3
81121d20:	29c00017 	ldw	r7,0(r5)
81121d24:	2a7ffe04 	addi	r9,r5,-8
81121d28:	1886b03a 	or	r3,r3,r2
81121d2c:	82400315 	stw	r9,12(r16)
81121d30:	81c00215 	stw	r7,8(r16)
81121d34:	30c00115 	stw	r3,4(r6)
81121d38:	2c000015 	stw	r16,0(r5)
81121d3c:	3c000315 	stw	r16,12(r7)
81121d40:	2005d0ba 	srai	r2,r4,2
81121d44:	01400044 	movi	r5,1
81121d48:	288a983a 	sll	r5,r5,r2
81121d4c:	19406f36 	bltu	r3,r5,81121f0c <_malloc_r+0x32c>
81121d50:	28c4703a 	and	r2,r5,r3
81121d54:	10000a1e 	bne	r2,zero,81121d80 <_malloc_r+0x1a0>
81121d58:	00bfff04 	movi	r2,-4
81121d5c:	294b883a 	add	r5,r5,r5
81121d60:	2088703a 	and	r4,r4,r2
81121d64:	28c4703a 	and	r2,r5,r3
81121d68:	21000104 	addi	r4,r4,4
81121d6c:	1000041e 	bne	r2,zero,81121d80 <_malloc_r+0x1a0>
81121d70:	294b883a 	add	r5,r5,r5
81121d74:	28c4703a 	and	r2,r5,r3
81121d78:	21000104 	addi	r4,r4,4
81121d7c:	103ffc26 	beq	r2,zero,81121d70 <__reset+0xfb101d70>
81121d80:	02bfff04 	movi	r10,-4
81121d84:	024003c4 	movi	r9,15
81121d88:	21800044 	addi	r6,r4,1
81121d8c:	318d883a 	add	r6,r6,r6
81121d90:	318d883a 	add	r6,r6,r6
81121d94:	318d883a 	add	r6,r6,r6
81121d98:	998d883a 	add	r6,r19,r6
81121d9c:	333ffe04 	addi	r12,r6,-8
81121da0:	2017883a 	mov	r11,r4
81121da4:	31800104 	addi	r6,r6,4
81121da8:	34000017 	ldw	r16,0(r6)
81121dac:	31fffd04 	addi	r7,r6,-12
81121db0:	81c0041e 	bne	r16,r7,81121dc4 <_malloc_r+0x1e4>
81121db4:	0000fb06 	br	811221a4 <_malloc_r+0x5c4>
81121db8:	1801030e 	bge	r3,zero,811221c8 <_malloc_r+0x5e8>
81121dbc:	84000317 	ldw	r16,12(r16)
81121dc0:	81c0f826 	beq	r16,r7,811221a4 <_malloc_r+0x5c4>
81121dc4:	80800117 	ldw	r2,4(r16)
81121dc8:	1284703a 	and	r2,r2,r10
81121dcc:	1447c83a 	sub	r3,r2,r17
81121dd0:	48fff90e 	bge	r9,r3,81121db8 <__reset+0xfb101db8>
81121dd4:	80800317 	ldw	r2,12(r16)
81121dd8:	81000217 	ldw	r4,8(r16)
81121ddc:	89400054 	ori	r5,r17,1
81121de0:	81400115 	stw	r5,4(r16)
81121de4:	20800315 	stw	r2,12(r4)
81121de8:	11000215 	stw	r4,8(r2)
81121dec:	8463883a 	add	r17,r16,r17
81121df0:	9c400515 	stw	r17,20(r19)
81121df4:	9c400415 	stw	r17,16(r19)
81121df8:	18800054 	ori	r2,r3,1
81121dfc:	88800115 	stw	r2,4(r17)
81121e00:	8a000315 	stw	r8,12(r17)
81121e04:	8a000215 	stw	r8,8(r17)
81121e08:	88e3883a 	add	r17,r17,r3
81121e0c:	88c00015 	stw	r3,0(r17)
81121e10:	9009883a 	mov	r4,r18
81121e14:	1137f600 	call	81137f60 <__malloc_unlock>
81121e18:	80800204 	addi	r2,r16,8
81121e1c:	00001b06 	br	81121e8c <_malloc_r+0x2ac>
81121e20:	04400404 	movi	r17,16
81121e24:	89402536 	bltu	r17,r5,81121ebc <_malloc_r+0x2dc>
81121e28:	1137e380 	call	81137e38 <__malloc_lock>
81121e2c:	00800184 	movi	r2,6
81121e30:	01000084 	movi	r4,2
81121e34:	04e04574 	movhi	r19,33045
81121e38:	1085883a 	add	r2,r2,r2
81121e3c:	9cc5ab04 	addi	r19,r19,5804
81121e40:	1085883a 	add	r2,r2,r2
81121e44:	9885883a 	add	r2,r19,r2
81121e48:	14000117 	ldw	r16,4(r2)
81121e4c:	10fffe04 	addi	r3,r2,-8
81121e50:	80c0d926 	beq	r16,r3,811221b8 <_malloc_r+0x5d8>
81121e54:	80c00117 	ldw	r3,4(r16)
81121e58:	81000317 	ldw	r4,12(r16)
81121e5c:	00bfff04 	movi	r2,-4
81121e60:	1884703a 	and	r2,r3,r2
81121e64:	81400217 	ldw	r5,8(r16)
81121e68:	8085883a 	add	r2,r16,r2
81121e6c:	10c00117 	ldw	r3,4(r2)
81121e70:	29000315 	stw	r4,12(r5)
81121e74:	21400215 	stw	r5,8(r4)
81121e78:	18c00054 	ori	r3,r3,1
81121e7c:	10c00115 	stw	r3,4(r2)
81121e80:	9009883a 	mov	r4,r18
81121e84:	1137f600 	call	81137f60 <__malloc_unlock>
81121e88:	80800204 	addi	r2,r16,8
81121e8c:	dfc00a17 	ldw	ra,40(sp)
81121e90:	df000917 	ldw	fp,36(sp)
81121e94:	ddc00817 	ldw	r23,32(sp)
81121e98:	dd800717 	ldw	r22,28(sp)
81121e9c:	dd400617 	ldw	r21,24(sp)
81121ea0:	dd000517 	ldw	r20,20(sp)
81121ea4:	dcc00417 	ldw	r19,16(sp)
81121ea8:	dc800317 	ldw	r18,12(sp)
81121eac:	dc400217 	ldw	r17,8(sp)
81121eb0:	dc000117 	ldw	r16,4(sp)
81121eb4:	dec00b04 	addi	sp,sp,44
81121eb8:	f800283a 	ret
81121ebc:	00800304 	movi	r2,12
81121ec0:	90800015 	stw	r2,0(r18)
81121ec4:	0005883a 	mov	r2,zero
81121ec8:	003ff006 	br	81121e8c <__reset+0xfb101e8c>
81121ecc:	01002004 	movi	r4,128
81121ed0:	02001004 	movi	r8,64
81121ed4:	01c00fc4 	movi	r7,63
81121ed8:	003f6106 	br	81121c60 <__reset+0xfb101c60>
81121edc:	4009883a 	mov	r4,r8
81121ee0:	003f7506 	br	81121cb8 <__reset+0xfb101cb8>
81121ee4:	81000317 	ldw	r4,12(r16)
81121ee8:	003fde06 	br	81121e64 <__reset+0xfb101e64>
81121eec:	81c5883a 	add	r2,r16,r7
81121ef0:	11400117 	ldw	r5,4(r2)
81121ef4:	9009883a 	mov	r4,r18
81121ef8:	29400054 	ori	r5,r5,1
81121efc:	11400115 	stw	r5,4(r2)
81121f00:	1137f600 	call	81137f60 <__malloc_unlock>
81121f04:	80800204 	addi	r2,r16,8
81121f08:	003fe006 	br	81121e8c <__reset+0xfb101e8c>
81121f0c:	9c000217 	ldw	r16,8(r19)
81121f10:	00bfff04 	movi	r2,-4
81121f14:	85800117 	ldw	r22,4(r16)
81121f18:	b0ac703a 	and	r22,r22,r2
81121f1c:	b4400336 	bltu	r22,r17,81121f2c <_malloc_r+0x34c>
81121f20:	b445c83a 	sub	r2,r22,r17
81121f24:	00c003c4 	movi	r3,15
81121f28:	18805d16 	blt	r3,r2,811220a0 <_malloc_r+0x4c0>
81121f2c:	05e04574 	movhi	r23,33045
81121f30:	00a04574 	movhi	r2,33045
81121f34:	108c6304 	addi	r2,r2,12684
81121f38:	bdcbee04 	addi	r23,r23,12216
81121f3c:	15400017 	ldw	r21,0(r2)
81121f40:	b8c00017 	ldw	r3,0(r23)
81121f44:	00bfffc4 	movi	r2,-1
81121f48:	858d883a 	add	r6,r16,r22
81121f4c:	8d6b883a 	add	r21,r17,r21
81121f50:	1880ea26 	beq	r3,r2,811222fc <_malloc_r+0x71c>
81121f54:	ad4403c4 	addi	r21,r21,4111
81121f58:	00bc0004 	movi	r2,-4096
81121f5c:	a8aa703a 	and	r21,r21,r2
81121f60:	a80b883a 	mov	r5,r21
81121f64:	9009883a 	mov	r4,r18
81121f68:	d9800015 	stw	r6,0(sp)
81121f6c:	1122b9c0 	call	81122b9c <_sbrk_r>
81121f70:	1029883a 	mov	r20,r2
81121f74:	00bfffc4 	movi	r2,-1
81121f78:	d9800017 	ldw	r6,0(sp)
81121f7c:	a080e826 	beq	r20,r2,81122320 <_malloc_r+0x740>
81121f80:	a180a636 	bltu	r20,r6,8112221c <_malloc_r+0x63c>
81121f84:	07204574 	movhi	fp,33045
81121f88:	e70cf004 	addi	fp,fp,13248
81121f8c:	e0800017 	ldw	r2,0(fp)
81121f90:	a887883a 	add	r3,r21,r2
81121f94:	e0c00015 	stw	r3,0(fp)
81121f98:	3500e626 	beq	r6,r20,81122334 <_malloc_r+0x754>
81121f9c:	b9000017 	ldw	r4,0(r23)
81121fa0:	00bfffc4 	movi	r2,-1
81121fa4:	2080ee26 	beq	r4,r2,81122360 <_malloc_r+0x780>
81121fa8:	a185c83a 	sub	r2,r20,r6
81121fac:	10c5883a 	add	r2,r2,r3
81121fb0:	e0800015 	stw	r2,0(fp)
81121fb4:	a0c001cc 	andi	r3,r20,7
81121fb8:	1800bc26 	beq	r3,zero,811222ac <_malloc_r+0x6cc>
81121fbc:	a0e9c83a 	sub	r20,r20,r3
81121fc0:	00840204 	movi	r2,4104
81121fc4:	a5000204 	addi	r20,r20,8
81121fc8:	10c7c83a 	sub	r3,r2,r3
81121fcc:	a545883a 	add	r2,r20,r21
81121fd0:	1083ffcc 	andi	r2,r2,4095
81121fd4:	18abc83a 	sub	r21,r3,r2
81121fd8:	a80b883a 	mov	r5,r21
81121fdc:	9009883a 	mov	r4,r18
81121fe0:	1122b9c0 	call	81122b9c <_sbrk_r>
81121fe4:	00ffffc4 	movi	r3,-1
81121fe8:	10c0e126 	beq	r2,r3,81122370 <_malloc_r+0x790>
81121fec:	1505c83a 	sub	r2,r2,r20
81121ff0:	1545883a 	add	r2,r2,r21
81121ff4:	10800054 	ori	r2,r2,1
81121ff8:	e0c00017 	ldw	r3,0(fp)
81121ffc:	9d000215 	stw	r20,8(r19)
81122000:	a0800115 	stw	r2,4(r20)
81122004:	a8c7883a 	add	r3,r21,r3
81122008:	e0c00015 	stw	r3,0(fp)
8112200c:	84c00e26 	beq	r16,r19,81122048 <_malloc_r+0x468>
81122010:	018003c4 	movi	r6,15
81122014:	3580a72e 	bgeu	r6,r22,811222b4 <_malloc_r+0x6d4>
81122018:	81400117 	ldw	r5,4(r16)
8112201c:	013ffe04 	movi	r4,-8
81122020:	b0bffd04 	addi	r2,r22,-12
81122024:	1104703a 	and	r2,r2,r4
81122028:	2900004c 	andi	r4,r5,1
8112202c:	2088b03a 	or	r4,r4,r2
81122030:	81000115 	stw	r4,4(r16)
81122034:	01400144 	movi	r5,5
81122038:	8089883a 	add	r4,r16,r2
8112203c:	21400115 	stw	r5,4(r4)
81122040:	21400215 	stw	r5,8(r4)
81122044:	3080cd36 	bltu	r6,r2,8112237c <_malloc_r+0x79c>
81122048:	00a04574 	movhi	r2,33045
8112204c:	108c6204 	addi	r2,r2,12680
81122050:	11000017 	ldw	r4,0(r2)
81122054:	20c0012e 	bgeu	r4,r3,8112205c <_malloc_r+0x47c>
81122058:	10c00015 	stw	r3,0(r2)
8112205c:	00a04574 	movhi	r2,33045
81122060:	108c6104 	addi	r2,r2,12676
81122064:	11000017 	ldw	r4,0(r2)
81122068:	9c000217 	ldw	r16,8(r19)
8112206c:	20c0012e 	bgeu	r4,r3,81122074 <_malloc_r+0x494>
81122070:	10c00015 	stw	r3,0(r2)
81122074:	80c00117 	ldw	r3,4(r16)
81122078:	00bfff04 	movi	r2,-4
8112207c:	1886703a 	and	r3,r3,r2
81122080:	1c45c83a 	sub	r2,r3,r17
81122084:	1c400236 	bltu	r3,r17,81122090 <_malloc_r+0x4b0>
81122088:	00c003c4 	movi	r3,15
8112208c:	18800416 	blt	r3,r2,811220a0 <_malloc_r+0x4c0>
81122090:	9009883a 	mov	r4,r18
81122094:	1137f600 	call	81137f60 <__malloc_unlock>
81122098:	0005883a 	mov	r2,zero
8112209c:	003f7b06 	br	81121e8c <__reset+0xfb101e8c>
811220a0:	88c00054 	ori	r3,r17,1
811220a4:	80c00115 	stw	r3,4(r16)
811220a8:	8463883a 	add	r17,r16,r17
811220ac:	10800054 	ori	r2,r2,1
811220b0:	9c400215 	stw	r17,8(r19)
811220b4:	88800115 	stw	r2,4(r17)
811220b8:	9009883a 	mov	r4,r18
811220bc:	1137f600 	call	81137f60 <__malloc_unlock>
811220c0:	80800204 	addi	r2,r16,8
811220c4:	003f7106 	br	81121e8c <__reset+0xfb101e8c>
811220c8:	00c00504 	movi	r3,20
811220cc:	18804a2e 	bgeu	r3,r2,811221f8 <_malloc_r+0x618>
811220d0:	00c01504 	movi	r3,84
811220d4:	18806e36 	bltu	r3,r2,81122290 <_malloc_r+0x6b0>
811220d8:	8804d33a 	srli	r2,r17,12
811220dc:	12001bc4 	addi	r8,r2,111
811220e0:	11c01b84 	addi	r7,r2,110
811220e4:	4209883a 	add	r4,r8,r8
811220e8:	003edd06 	br	81121c60 <__reset+0xfb101c60>
811220ec:	3804d27a 	srli	r2,r7,9
811220f0:	00c00104 	movi	r3,4
811220f4:	1880442e 	bgeu	r3,r2,81122208 <_malloc_r+0x628>
811220f8:	00c00504 	movi	r3,20
811220fc:	18808136 	bltu	r3,r2,81122304 <_malloc_r+0x724>
81122100:	11401704 	addi	r5,r2,92
81122104:	10c016c4 	addi	r3,r2,91
81122108:	294b883a 	add	r5,r5,r5
8112210c:	294b883a 	add	r5,r5,r5
81122110:	294b883a 	add	r5,r5,r5
81122114:	994b883a 	add	r5,r19,r5
81122118:	28800017 	ldw	r2,0(r5)
8112211c:	01a04574 	movhi	r6,33045
81122120:	297ffe04 	addi	r5,r5,-8
81122124:	3185ab04 	addi	r6,r6,5804
81122128:	28806526 	beq	r5,r2,811222c0 <_malloc_r+0x6e0>
8112212c:	01bfff04 	movi	r6,-4
81122130:	10c00117 	ldw	r3,4(r2)
81122134:	1986703a 	and	r3,r3,r6
81122138:	38c0022e 	bgeu	r7,r3,81122144 <_malloc_r+0x564>
8112213c:	10800217 	ldw	r2,8(r2)
81122140:	28bffb1e 	bne	r5,r2,81122130 <__reset+0xfb102130>
81122144:	11400317 	ldw	r5,12(r2)
81122148:	98c00117 	ldw	r3,4(r19)
8112214c:	81400315 	stw	r5,12(r16)
81122150:	80800215 	stw	r2,8(r16)
81122154:	2c000215 	stw	r16,8(r5)
81122158:	14000315 	stw	r16,12(r2)
8112215c:	003ef806 	br	81121d40 <__reset+0xfb101d40>
81122160:	88c00054 	ori	r3,r17,1
81122164:	80c00115 	stw	r3,4(r16)
81122168:	8463883a 	add	r17,r16,r17
8112216c:	34400515 	stw	r17,20(r6)
81122170:	34400415 	stw	r17,16(r6)
81122174:	10c00054 	ori	r3,r2,1
81122178:	8a000315 	stw	r8,12(r17)
8112217c:	8a000215 	stw	r8,8(r17)
81122180:	88c00115 	stw	r3,4(r17)
81122184:	88a3883a 	add	r17,r17,r2
81122188:	88800015 	stw	r2,0(r17)
8112218c:	9009883a 	mov	r4,r18
81122190:	1137f600 	call	81137f60 <__malloc_unlock>
81122194:	80800204 	addi	r2,r16,8
81122198:	003f3c06 	br	81121e8c <__reset+0xfb101e8c>
8112219c:	30c00117 	ldw	r3,4(r6)
811221a0:	003ee706 	br	81121d40 <__reset+0xfb101d40>
811221a4:	5ac00044 	addi	r11,r11,1
811221a8:	588000cc 	andi	r2,r11,3
811221ac:	31800204 	addi	r6,r6,8
811221b0:	103efd1e 	bne	r2,zero,81121da8 <__reset+0xfb101da8>
811221b4:	00002406 	br	81122248 <_malloc_r+0x668>
811221b8:	14000317 	ldw	r16,12(r2)
811221bc:	143f251e 	bne	r2,r16,81121e54 <__reset+0xfb101e54>
811221c0:	21000084 	addi	r4,r4,2
811221c4:	003ebc06 	br	81121cb8 <__reset+0xfb101cb8>
811221c8:	8085883a 	add	r2,r16,r2
811221cc:	10c00117 	ldw	r3,4(r2)
811221d0:	81000317 	ldw	r4,12(r16)
811221d4:	81400217 	ldw	r5,8(r16)
811221d8:	18c00054 	ori	r3,r3,1
811221dc:	10c00115 	stw	r3,4(r2)
811221e0:	29000315 	stw	r4,12(r5)
811221e4:	21400215 	stw	r5,8(r4)
811221e8:	9009883a 	mov	r4,r18
811221ec:	1137f600 	call	81137f60 <__malloc_unlock>
811221f0:	80800204 	addi	r2,r16,8
811221f4:	003f2506 	br	81121e8c <__reset+0xfb101e8c>
811221f8:	12001704 	addi	r8,r2,92
811221fc:	11c016c4 	addi	r7,r2,91
81122200:	4209883a 	add	r4,r8,r8
81122204:	003e9606 	br	81121c60 <__reset+0xfb101c60>
81122208:	3804d1ba 	srli	r2,r7,6
8112220c:	11400e44 	addi	r5,r2,57
81122210:	10c00e04 	addi	r3,r2,56
81122214:	294b883a 	add	r5,r5,r5
81122218:	003fbc06 	br	8112210c <__reset+0xfb10210c>
8112221c:	84ff5926 	beq	r16,r19,81121f84 <__reset+0xfb101f84>
81122220:	00a04574 	movhi	r2,33045
81122224:	1085ab04 	addi	r2,r2,5804
81122228:	14000217 	ldw	r16,8(r2)
8112222c:	00bfff04 	movi	r2,-4
81122230:	80c00117 	ldw	r3,4(r16)
81122234:	1886703a 	and	r3,r3,r2
81122238:	003f9106 	br	81122080 <__reset+0xfb102080>
8112223c:	60800217 	ldw	r2,8(r12)
81122240:	213fffc4 	addi	r4,r4,-1
81122244:	1300651e 	bne	r2,r12,811223dc <_malloc_r+0x7fc>
81122248:	208000cc 	andi	r2,r4,3
8112224c:	633ffe04 	addi	r12,r12,-8
81122250:	103ffa1e 	bne	r2,zero,8112223c <__reset+0xfb10223c>
81122254:	98800117 	ldw	r2,4(r19)
81122258:	0146303a 	nor	r3,zero,r5
8112225c:	1884703a 	and	r2,r3,r2
81122260:	98800115 	stw	r2,4(r19)
81122264:	294b883a 	add	r5,r5,r5
81122268:	117f2836 	bltu	r2,r5,81121f0c <__reset+0xfb101f0c>
8112226c:	283f2726 	beq	r5,zero,81121f0c <__reset+0xfb101f0c>
81122270:	2886703a 	and	r3,r5,r2
81122274:	5809883a 	mov	r4,r11
81122278:	183ec31e 	bne	r3,zero,81121d88 <__reset+0xfb101d88>
8112227c:	294b883a 	add	r5,r5,r5
81122280:	2886703a 	and	r3,r5,r2
81122284:	21000104 	addi	r4,r4,4
81122288:	183ffc26 	beq	r3,zero,8112227c <__reset+0xfb10227c>
8112228c:	003ebe06 	br	81121d88 <__reset+0xfb101d88>
81122290:	00c05504 	movi	r3,340
81122294:	18801236 	bltu	r3,r2,811222e0 <_malloc_r+0x700>
81122298:	8804d3fa 	srli	r2,r17,15
8112229c:	12001e04 	addi	r8,r2,120
811222a0:	11c01dc4 	addi	r7,r2,119
811222a4:	4209883a 	add	r4,r8,r8
811222a8:	003e6d06 	br	81121c60 <__reset+0xfb101c60>
811222ac:	00c40004 	movi	r3,4096
811222b0:	003f4606 	br	81121fcc <__reset+0xfb101fcc>
811222b4:	00800044 	movi	r2,1
811222b8:	a0800115 	stw	r2,4(r20)
811222bc:	003f7406 	br	81122090 <__reset+0xfb102090>
811222c0:	1805d0ba 	srai	r2,r3,2
811222c4:	01c00044 	movi	r7,1
811222c8:	30c00117 	ldw	r3,4(r6)
811222cc:	388e983a 	sll	r7,r7,r2
811222d0:	2805883a 	mov	r2,r5
811222d4:	38c6b03a 	or	r3,r7,r3
811222d8:	30c00115 	stw	r3,4(r6)
811222dc:	003f9b06 	br	8112214c <__reset+0xfb10214c>
811222e0:	00c15504 	movi	r3,1364
811222e4:	18801a36 	bltu	r3,r2,81122350 <_malloc_r+0x770>
811222e8:	8804d4ba 	srli	r2,r17,18
811222ec:	12001f44 	addi	r8,r2,125
811222f0:	11c01f04 	addi	r7,r2,124
811222f4:	4209883a 	add	r4,r8,r8
811222f8:	003e5906 	br	81121c60 <__reset+0xfb101c60>
811222fc:	ad400404 	addi	r21,r21,16
81122300:	003f1706 	br	81121f60 <__reset+0xfb101f60>
81122304:	00c01504 	movi	r3,84
81122308:	18802336 	bltu	r3,r2,81122398 <_malloc_r+0x7b8>
8112230c:	3804d33a 	srli	r2,r7,12
81122310:	11401bc4 	addi	r5,r2,111
81122314:	10c01b84 	addi	r3,r2,110
81122318:	294b883a 	add	r5,r5,r5
8112231c:	003f7b06 	br	8112210c <__reset+0xfb10210c>
81122320:	9c000217 	ldw	r16,8(r19)
81122324:	00bfff04 	movi	r2,-4
81122328:	80c00117 	ldw	r3,4(r16)
8112232c:	1886703a 	and	r3,r3,r2
81122330:	003f5306 	br	81122080 <__reset+0xfb102080>
81122334:	3083ffcc 	andi	r2,r6,4095
81122338:	103f181e 	bne	r2,zero,81121f9c <__reset+0xfb101f9c>
8112233c:	99000217 	ldw	r4,8(r19)
81122340:	b545883a 	add	r2,r22,r21
81122344:	10800054 	ori	r2,r2,1
81122348:	20800115 	stw	r2,4(r4)
8112234c:	003f3e06 	br	81122048 <__reset+0xfb102048>
81122350:	01003f84 	movi	r4,254
81122354:	02001fc4 	movi	r8,127
81122358:	01c01f84 	movi	r7,126
8112235c:	003e4006 	br	81121c60 <__reset+0xfb101c60>
81122360:	00a04574 	movhi	r2,33045
81122364:	108bee04 	addi	r2,r2,12216
81122368:	15000015 	stw	r20,0(r2)
8112236c:	003f1106 	br	81121fb4 <__reset+0xfb101fb4>
81122370:	00800044 	movi	r2,1
81122374:	002b883a 	mov	r21,zero
81122378:	003f1f06 	br	81121ff8 <__reset+0xfb101ff8>
8112237c:	81400204 	addi	r5,r16,8
81122380:	9009883a 	mov	r4,r18
81122384:	112b9580 	call	8112b958 <_free_r>
81122388:	00a04574 	movhi	r2,33045
8112238c:	108cf004 	addi	r2,r2,13248
81122390:	10c00017 	ldw	r3,0(r2)
81122394:	003f2c06 	br	81122048 <__reset+0xfb102048>
81122398:	00c05504 	movi	r3,340
8112239c:	18800536 	bltu	r3,r2,811223b4 <_malloc_r+0x7d4>
811223a0:	3804d3fa 	srli	r2,r7,15
811223a4:	11401e04 	addi	r5,r2,120
811223a8:	10c01dc4 	addi	r3,r2,119
811223ac:	294b883a 	add	r5,r5,r5
811223b0:	003f5606 	br	8112210c <__reset+0xfb10210c>
811223b4:	00c15504 	movi	r3,1364
811223b8:	18800536 	bltu	r3,r2,811223d0 <_malloc_r+0x7f0>
811223bc:	3804d4ba 	srli	r2,r7,18
811223c0:	11401f44 	addi	r5,r2,125
811223c4:	10c01f04 	addi	r3,r2,124
811223c8:	294b883a 	add	r5,r5,r5
811223cc:	003f4f06 	br	8112210c <__reset+0xfb10210c>
811223d0:	01403f84 	movi	r5,254
811223d4:	00c01f84 	movi	r3,126
811223d8:	003f4c06 	br	8112210c <__reset+0xfb10210c>
811223dc:	98800117 	ldw	r2,4(r19)
811223e0:	003fa006 	br	81122264 <__reset+0xfb102264>
811223e4:	8808d0fa 	srli	r4,r17,3
811223e8:	20800044 	addi	r2,r4,1
811223ec:	1085883a 	add	r2,r2,r2
811223f0:	003e9006 	br	81121e34 <__reset+0xfb101e34>

811223f4 <memcpy>:
811223f4:	defffd04 	addi	sp,sp,-12
811223f8:	de00012e 	bgeu	sp,et,81122400 <memcpy+0xc>
811223fc:	003b68fa 	trap	3
81122400:	00c003c4 	movi	r3,15
81122404:	dfc00215 	stw	ra,8(sp)
81122408:	dc400115 	stw	r17,4(sp)
8112240c:	dc000015 	stw	r16,0(sp)
81122410:	2005883a 	mov	r2,r4
81122414:	1980452e 	bgeu	r3,r6,8112252c <memcpy+0x138>
81122418:	2906b03a 	or	r3,r5,r4
8112241c:	18c000cc 	andi	r3,r3,3
81122420:	1800441e 	bne	r3,zero,81122534 <memcpy+0x140>
81122424:	347ffc04 	addi	r17,r6,-16
81122428:	8822d13a 	srli	r17,r17,4
8112242c:	28c00104 	addi	r3,r5,4
81122430:	23400104 	addi	r13,r4,4
81122434:	8820913a 	slli	r16,r17,4
81122438:	2b000204 	addi	r12,r5,8
8112243c:	22c00204 	addi	r11,r4,8
81122440:	84000504 	addi	r16,r16,20
81122444:	2a800304 	addi	r10,r5,12
81122448:	22400304 	addi	r9,r4,12
8112244c:	2c21883a 	add	r16,r5,r16
81122450:	2811883a 	mov	r8,r5
81122454:	200f883a 	mov	r7,r4
81122458:	41000017 	ldw	r4,0(r8)
8112245c:	1fc00017 	ldw	ra,0(r3)
81122460:	63c00017 	ldw	r15,0(r12)
81122464:	39000015 	stw	r4,0(r7)
81122468:	53800017 	ldw	r14,0(r10)
8112246c:	6fc00015 	stw	ra,0(r13)
81122470:	5bc00015 	stw	r15,0(r11)
81122474:	4b800015 	stw	r14,0(r9)
81122478:	18c00404 	addi	r3,r3,16
8112247c:	39c00404 	addi	r7,r7,16
81122480:	42000404 	addi	r8,r8,16
81122484:	6b400404 	addi	r13,r13,16
81122488:	63000404 	addi	r12,r12,16
8112248c:	5ac00404 	addi	r11,r11,16
81122490:	52800404 	addi	r10,r10,16
81122494:	4a400404 	addi	r9,r9,16
81122498:	1c3fef1e 	bne	r3,r16,81122458 <__reset+0xfb102458>
8112249c:	89c00044 	addi	r7,r17,1
811224a0:	380e913a 	slli	r7,r7,4
811224a4:	310003cc 	andi	r4,r6,15
811224a8:	02c000c4 	movi	r11,3
811224ac:	11c7883a 	add	r3,r2,r7
811224b0:	29cb883a 	add	r5,r5,r7
811224b4:	5900212e 	bgeu	r11,r4,8112253c <memcpy+0x148>
811224b8:	1813883a 	mov	r9,r3
811224bc:	2811883a 	mov	r8,r5
811224c0:	200f883a 	mov	r7,r4
811224c4:	42800017 	ldw	r10,0(r8)
811224c8:	4a400104 	addi	r9,r9,4
811224cc:	39ffff04 	addi	r7,r7,-4
811224d0:	4abfff15 	stw	r10,-4(r9)
811224d4:	42000104 	addi	r8,r8,4
811224d8:	59fffa36 	bltu	r11,r7,811224c4 <__reset+0xfb1024c4>
811224dc:	213fff04 	addi	r4,r4,-4
811224e0:	2008d0ba 	srli	r4,r4,2
811224e4:	318000cc 	andi	r6,r6,3
811224e8:	21000044 	addi	r4,r4,1
811224ec:	2109883a 	add	r4,r4,r4
811224f0:	2109883a 	add	r4,r4,r4
811224f4:	1907883a 	add	r3,r3,r4
811224f8:	290b883a 	add	r5,r5,r4
811224fc:	30000626 	beq	r6,zero,81122518 <memcpy+0x124>
81122500:	198d883a 	add	r6,r3,r6
81122504:	29c00003 	ldbu	r7,0(r5)
81122508:	18c00044 	addi	r3,r3,1
8112250c:	29400044 	addi	r5,r5,1
81122510:	19ffffc5 	stb	r7,-1(r3)
81122514:	19bffb1e 	bne	r3,r6,81122504 <__reset+0xfb102504>
81122518:	dfc00217 	ldw	ra,8(sp)
8112251c:	dc400117 	ldw	r17,4(sp)
81122520:	dc000017 	ldw	r16,0(sp)
81122524:	dec00304 	addi	sp,sp,12
81122528:	f800283a 	ret
8112252c:	2007883a 	mov	r3,r4
81122530:	003ff206 	br	811224fc <__reset+0xfb1024fc>
81122534:	2007883a 	mov	r3,r4
81122538:	003ff106 	br	81122500 <__reset+0xfb102500>
8112253c:	200d883a 	mov	r6,r4
81122540:	003fee06 	br	811224fc <__reset+0xfb1024fc>

81122544 <memset>:
81122544:	20c000cc 	andi	r3,r4,3
81122548:	2005883a 	mov	r2,r4
8112254c:	18004426 	beq	r3,zero,81122660 <memset+0x11c>
81122550:	31ffffc4 	addi	r7,r6,-1
81122554:	30004026 	beq	r6,zero,81122658 <memset+0x114>
81122558:	2813883a 	mov	r9,r5
8112255c:	200d883a 	mov	r6,r4
81122560:	2007883a 	mov	r3,r4
81122564:	00000406 	br	81122578 <memset+0x34>
81122568:	3a3fffc4 	addi	r8,r7,-1
8112256c:	31800044 	addi	r6,r6,1
81122570:	38003926 	beq	r7,zero,81122658 <memset+0x114>
81122574:	400f883a 	mov	r7,r8
81122578:	18c00044 	addi	r3,r3,1
8112257c:	32400005 	stb	r9,0(r6)
81122580:	1a0000cc 	andi	r8,r3,3
81122584:	403ff81e 	bne	r8,zero,81122568 <__reset+0xfb102568>
81122588:	010000c4 	movi	r4,3
8112258c:	21c02d2e 	bgeu	r4,r7,81122644 <memset+0x100>
81122590:	29003fcc 	andi	r4,r5,255
81122594:	200c923a 	slli	r6,r4,8
81122598:	3108b03a 	or	r4,r6,r4
8112259c:	200c943a 	slli	r6,r4,16
811225a0:	218cb03a 	or	r6,r4,r6
811225a4:	010003c4 	movi	r4,15
811225a8:	21c0182e 	bgeu	r4,r7,8112260c <memset+0xc8>
811225ac:	3b3ffc04 	addi	r12,r7,-16
811225b0:	6018d13a 	srli	r12,r12,4
811225b4:	1a000104 	addi	r8,r3,4
811225b8:	1ac00204 	addi	r11,r3,8
811225bc:	6008913a 	slli	r4,r12,4
811225c0:	1a800304 	addi	r10,r3,12
811225c4:	1813883a 	mov	r9,r3
811225c8:	21000504 	addi	r4,r4,20
811225cc:	1909883a 	add	r4,r3,r4
811225d0:	49800015 	stw	r6,0(r9)
811225d4:	41800015 	stw	r6,0(r8)
811225d8:	59800015 	stw	r6,0(r11)
811225dc:	51800015 	stw	r6,0(r10)
811225e0:	42000404 	addi	r8,r8,16
811225e4:	4a400404 	addi	r9,r9,16
811225e8:	5ac00404 	addi	r11,r11,16
811225ec:	52800404 	addi	r10,r10,16
811225f0:	413ff71e 	bne	r8,r4,811225d0 <__reset+0xfb1025d0>
811225f4:	63000044 	addi	r12,r12,1
811225f8:	6018913a 	slli	r12,r12,4
811225fc:	39c003cc 	andi	r7,r7,15
81122600:	010000c4 	movi	r4,3
81122604:	1b07883a 	add	r3,r3,r12
81122608:	21c00e2e 	bgeu	r4,r7,81122644 <memset+0x100>
8112260c:	1813883a 	mov	r9,r3
81122610:	3811883a 	mov	r8,r7
81122614:	010000c4 	movi	r4,3
81122618:	49800015 	stw	r6,0(r9)
8112261c:	423fff04 	addi	r8,r8,-4
81122620:	4a400104 	addi	r9,r9,4
81122624:	223ffc36 	bltu	r4,r8,81122618 <__reset+0xfb102618>
81122628:	393fff04 	addi	r4,r7,-4
8112262c:	2008d0ba 	srli	r4,r4,2
81122630:	39c000cc 	andi	r7,r7,3
81122634:	21000044 	addi	r4,r4,1
81122638:	2109883a 	add	r4,r4,r4
8112263c:	2109883a 	add	r4,r4,r4
81122640:	1907883a 	add	r3,r3,r4
81122644:	38000526 	beq	r7,zero,8112265c <memset+0x118>
81122648:	19cf883a 	add	r7,r3,r7
8112264c:	19400005 	stb	r5,0(r3)
81122650:	18c00044 	addi	r3,r3,1
81122654:	38fffd1e 	bne	r7,r3,8112264c <__reset+0xfb10264c>
81122658:	f800283a 	ret
8112265c:	f800283a 	ret
81122660:	2007883a 	mov	r3,r4
81122664:	300f883a 	mov	r7,r6
81122668:	003fc706 	br	81122588 <__reset+0xfb102588>

8112266c <_open_r>:
8112266c:	defffd04 	addi	sp,sp,-12
81122670:	de00012e 	bgeu	sp,et,81122678 <_open_r+0xc>
81122674:	003b68fa 	trap	3
81122678:	2805883a 	mov	r2,r5
8112267c:	dc000015 	stw	r16,0(sp)
81122680:	04204574 	movhi	r16,33045
81122684:	dc400115 	stw	r17,4(sp)
81122688:	300b883a 	mov	r5,r6
8112268c:	840c6004 	addi	r16,r16,12672
81122690:	2023883a 	mov	r17,r4
81122694:	380d883a 	mov	r6,r7
81122698:	1009883a 	mov	r4,r2
8112269c:	dfc00215 	stw	ra,8(sp)
811226a0:	80000015 	stw	zero,0(r16)
811226a4:	11374b80 	call	811374b8 <open>
811226a8:	00ffffc4 	movi	r3,-1
811226ac:	10c00526 	beq	r2,r3,811226c4 <_open_r+0x58>
811226b0:	dfc00217 	ldw	ra,8(sp)
811226b4:	dc400117 	ldw	r17,4(sp)
811226b8:	dc000017 	ldw	r16,0(sp)
811226bc:	dec00304 	addi	sp,sp,12
811226c0:	f800283a 	ret
811226c4:	80c00017 	ldw	r3,0(r16)
811226c8:	183ff926 	beq	r3,zero,811226b0 <__reset+0xfb1026b0>
811226cc:	88c00015 	stw	r3,0(r17)
811226d0:	003ff706 	br	811226b0 <__reset+0xfb1026b0>

811226d4 <_printf_r>:
811226d4:	defffd04 	addi	sp,sp,-12
811226d8:	2805883a 	mov	r2,r5
811226dc:	de00012e 	bgeu	sp,et,811226e4 <_printf_r+0x10>
811226e0:	003b68fa 	trap	3
811226e4:	dfc00015 	stw	ra,0(sp)
811226e8:	d9800115 	stw	r6,4(sp)
811226ec:	d9c00215 	stw	r7,8(sp)
811226f0:	21400217 	ldw	r5,8(r4)
811226f4:	d9c00104 	addi	r7,sp,4
811226f8:	100d883a 	mov	r6,r2
811226fc:	11257040 	call	81125704 <___vfprintf_internal_r>
81122700:	dfc00017 	ldw	ra,0(sp)
81122704:	dec00304 	addi	sp,sp,12
81122708:	f800283a 	ret

8112270c <printf>:
8112270c:	defffc04 	addi	sp,sp,-16
81122710:	de00012e 	bgeu	sp,et,81122718 <printf+0xc>
81122714:	003b68fa 	trap	3
81122718:	dfc00015 	stw	ra,0(sp)
8112271c:	d9400115 	stw	r5,4(sp)
81122720:	d9800215 	stw	r6,8(sp)
81122724:	d9c00315 	stw	r7,12(sp)
81122728:	00a04574 	movhi	r2,33045
8112272c:	108bed04 	addi	r2,r2,12212
81122730:	10800017 	ldw	r2,0(r2)
81122734:	200b883a 	mov	r5,r4
81122738:	d9800104 	addi	r6,sp,4
8112273c:	11000217 	ldw	r4,8(r2)
81122740:	11279040 	call	81127904 <__vfprintf_internal>
81122744:	dfc00017 	ldw	ra,0(sp)
81122748:	dec00404 	addi	sp,sp,16
8112274c:	f800283a 	ret

81122750 <_putc_r>:
81122750:	defffc04 	addi	sp,sp,-16
81122754:	de00012e 	bgeu	sp,et,8112275c <_putc_r+0xc>
81122758:	003b68fa 	trap	3
8112275c:	dc000215 	stw	r16,8(sp)
81122760:	dfc00315 	stw	ra,12(sp)
81122764:	2021883a 	mov	r16,r4
81122768:	20000226 	beq	r4,zero,81122774 <_putc_r+0x24>
8112276c:	20800e17 	ldw	r2,56(r4)
81122770:	10001b26 	beq	r2,zero,811227e0 <_putc_r+0x90>
81122774:	30800217 	ldw	r2,8(r6)
81122778:	10bfffc4 	addi	r2,r2,-1
8112277c:	30800215 	stw	r2,8(r6)
81122780:	10000a16 	blt	r2,zero,811227ac <_putc_r+0x5c>
81122784:	30800017 	ldw	r2,0(r6)
81122788:	11400005 	stb	r5,0(r2)
8112278c:	30800017 	ldw	r2,0(r6)
81122790:	10c00044 	addi	r3,r2,1
81122794:	30c00015 	stw	r3,0(r6)
81122798:	10800003 	ldbu	r2,0(r2)
8112279c:	dfc00317 	ldw	ra,12(sp)
811227a0:	dc000217 	ldw	r16,8(sp)
811227a4:	dec00404 	addi	sp,sp,16
811227a8:	f800283a 	ret
811227ac:	30c00617 	ldw	r3,24(r6)
811227b0:	10c00616 	blt	r2,r3,811227cc <_putc_r+0x7c>
811227b4:	30800017 	ldw	r2,0(r6)
811227b8:	00c00284 	movi	r3,10
811227bc:	11400005 	stb	r5,0(r2)
811227c0:	30800017 	ldw	r2,0(r6)
811227c4:	11400003 	ldbu	r5,0(r2)
811227c8:	28fff11e 	bne	r5,r3,81122790 <__reset+0xfb102790>
811227cc:	8009883a 	mov	r4,r16
811227d0:	dfc00317 	ldw	ra,12(sp)
811227d4:	dc000217 	ldw	r16,8(sp)
811227d8:	dec00404 	addi	sp,sp,16
811227dc:	11292881 	jmpi	81129288 <__swbuf_r>
811227e0:	d9400015 	stw	r5,0(sp)
811227e4:	d9800115 	stw	r6,4(sp)
811227e8:	112b4c00 	call	8112b4c0 <__sinit>
811227ec:	d9800117 	ldw	r6,4(sp)
811227f0:	d9400017 	ldw	r5,0(sp)
811227f4:	003fdf06 	br	81122774 <__reset+0xfb102774>

811227f8 <putc>:
811227f8:	00a04574 	movhi	r2,33045
811227fc:	defffc04 	addi	sp,sp,-16
81122800:	108bed04 	addi	r2,r2,12212
81122804:	de00012e 	bgeu	sp,et,8112280c <putc+0x14>
81122808:	003b68fa 	trap	3
8112280c:	dc000115 	stw	r16,4(sp)
81122810:	14000017 	ldw	r16,0(r2)
81122814:	dc400215 	stw	r17,8(sp)
81122818:	dfc00315 	stw	ra,12(sp)
8112281c:	2023883a 	mov	r17,r4
81122820:	80000226 	beq	r16,zero,8112282c <putc+0x34>
81122824:	80800e17 	ldw	r2,56(r16)
81122828:	10001a26 	beq	r2,zero,81122894 <putc+0x9c>
8112282c:	28800217 	ldw	r2,8(r5)
81122830:	10bfffc4 	addi	r2,r2,-1
81122834:	28800215 	stw	r2,8(r5)
81122838:	10000b16 	blt	r2,zero,81122868 <putc+0x70>
8112283c:	28800017 	ldw	r2,0(r5)
81122840:	14400005 	stb	r17,0(r2)
81122844:	28800017 	ldw	r2,0(r5)
81122848:	10c00044 	addi	r3,r2,1
8112284c:	28c00015 	stw	r3,0(r5)
81122850:	10800003 	ldbu	r2,0(r2)
81122854:	dfc00317 	ldw	ra,12(sp)
81122858:	dc400217 	ldw	r17,8(sp)
8112285c:	dc000117 	ldw	r16,4(sp)
81122860:	dec00404 	addi	sp,sp,16
81122864:	f800283a 	ret
81122868:	28c00617 	ldw	r3,24(r5)
8112286c:	10c00e16 	blt	r2,r3,811228a8 <putc+0xb0>
81122870:	28800017 	ldw	r2,0(r5)
81122874:	01000284 	movi	r4,10
81122878:	14400005 	stb	r17,0(r2)
8112287c:	28800017 	ldw	r2,0(r5)
81122880:	10c00003 	ldbu	r3,0(r2)
81122884:	193ff01e 	bne	r3,r4,81122848 <__reset+0xfb102848>
81122888:	280d883a 	mov	r6,r5
8112288c:	180b883a 	mov	r5,r3
81122890:	00000706 	br	811228b0 <putc+0xb8>
81122894:	8009883a 	mov	r4,r16
81122898:	d9400015 	stw	r5,0(sp)
8112289c:	112b4c00 	call	8112b4c0 <__sinit>
811228a0:	d9400017 	ldw	r5,0(sp)
811228a4:	003fe106 	br	8112282c <__reset+0xfb10282c>
811228a8:	280d883a 	mov	r6,r5
811228ac:	880b883a 	mov	r5,r17
811228b0:	8009883a 	mov	r4,r16
811228b4:	dfc00317 	ldw	ra,12(sp)
811228b8:	dc400217 	ldw	r17,8(sp)
811228bc:	dc000117 	ldw	r16,4(sp)
811228c0:	dec00404 	addi	sp,sp,16
811228c4:	11292881 	jmpi	81129288 <__swbuf_r>

811228c8 <_puts_r>:
811228c8:	defff604 	addi	sp,sp,-40
811228cc:	de00012e 	bgeu	sp,et,811228d4 <_puts_r+0xc>
811228d0:	003b68fa 	trap	3
811228d4:	dc000715 	stw	r16,28(sp)
811228d8:	2021883a 	mov	r16,r4
811228dc:	2809883a 	mov	r4,r5
811228e0:	dc400815 	stw	r17,32(sp)
811228e4:	dfc00915 	stw	ra,36(sp)
811228e8:	2823883a 	mov	r17,r5
811228ec:	1122ee80 	call	81122ee8 <strlen>
811228f0:	10c00044 	addi	r3,r2,1
811228f4:	d8800115 	stw	r2,4(sp)
811228f8:	00a04574 	movhi	r2,33045
811228fc:	10821404 	addi	r2,r2,2128
81122900:	d8800215 	stw	r2,8(sp)
81122904:	00800044 	movi	r2,1
81122908:	d8800315 	stw	r2,12(sp)
8112290c:	00800084 	movi	r2,2
81122910:	dc400015 	stw	r17,0(sp)
81122914:	d8c00615 	stw	r3,24(sp)
81122918:	dec00415 	stw	sp,16(sp)
8112291c:	d8800515 	stw	r2,20(sp)
81122920:	80000226 	beq	r16,zero,8112292c <_puts_r+0x64>
81122924:	80800e17 	ldw	r2,56(r16)
81122928:	10001426 	beq	r2,zero,8112297c <_puts_r+0xb4>
8112292c:	81400217 	ldw	r5,8(r16)
81122930:	2880030b 	ldhu	r2,12(r5)
81122934:	10c8000c 	andi	r3,r2,8192
81122938:	1800061e 	bne	r3,zero,81122954 <_puts_r+0x8c>
8112293c:	29001917 	ldw	r4,100(r5)
81122940:	00f7ffc4 	movi	r3,-8193
81122944:	10880014 	ori	r2,r2,8192
81122948:	20c6703a 	and	r3,r4,r3
8112294c:	2880030d 	sth	r2,12(r5)
81122950:	28c01915 	stw	r3,100(r5)
81122954:	d9800404 	addi	r6,sp,16
81122958:	8009883a 	mov	r4,r16
8112295c:	112bc700 	call	8112bc70 <__sfvwrite_r>
81122960:	1000091e 	bne	r2,zero,81122988 <_puts_r+0xc0>
81122964:	00800284 	movi	r2,10
81122968:	dfc00917 	ldw	ra,36(sp)
8112296c:	dc400817 	ldw	r17,32(sp)
81122970:	dc000717 	ldw	r16,28(sp)
81122974:	dec00a04 	addi	sp,sp,40
81122978:	f800283a 	ret
8112297c:	8009883a 	mov	r4,r16
81122980:	112b4c00 	call	8112b4c0 <__sinit>
81122984:	003fe906 	br	8112292c <__reset+0xfb10292c>
81122988:	00bfffc4 	movi	r2,-1
8112298c:	003ff606 	br	81122968 <__reset+0xfb102968>

81122990 <puts>:
81122990:	00a04574 	movhi	r2,33045
81122994:	108bed04 	addi	r2,r2,12212
81122998:	200b883a 	mov	r5,r4
8112299c:	11000017 	ldw	r4,0(r2)
811229a0:	11228c81 	jmpi	811228c8 <_puts_r>

811229a4 <lflush>:
811229a4:	2080030b 	ldhu	r2,12(r4)
811229a8:	00c00244 	movi	r3,9
811229ac:	1080024c 	andi	r2,r2,9
811229b0:	10c00226 	beq	r2,r3,811229bc <lflush+0x18>
811229b4:	0005883a 	mov	r2,zero
811229b8:	f800283a 	ret
811229bc:	112b1281 	jmpi	8112b128 <fflush>

811229c0 <__srefill_r>:
811229c0:	defffc04 	addi	sp,sp,-16
811229c4:	de00012e 	bgeu	sp,et,811229cc <__srefill_r+0xc>
811229c8:	003b68fa 	trap	3
811229cc:	dc400115 	stw	r17,4(sp)
811229d0:	dc000015 	stw	r16,0(sp)
811229d4:	dfc00315 	stw	ra,12(sp)
811229d8:	dc800215 	stw	r18,8(sp)
811229dc:	2023883a 	mov	r17,r4
811229e0:	2821883a 	mov	r16,r5
811229e4:	20000226 	beq	r4,zero,811229f0 <__srefill_r+0x30>
811229e8:	20800e17 	ldw	r2,56(r4)
811229ec:	10003c26 	beq	r2,zero,81122ae0 <__srefill_r+0x120>
811229f0:	80c0030b 	ldhu	r3,12(r16)
811229f4:	1908000c 	andi	r4,r3,8192
811229f8:	1805883a 	mov	r2,r3
811229fc:	2000071e 	bne	r4,zero,81122a1c <__srefill_r+0x5c>
81122a00:	81001917 	ldw	r4,100(r16)
81122a04:	18880014 	ori	r2,r3,8192
81122a08:	00f7ffc4 	movi	r3,-8193
81122a0c:	20c8703a 	and	r4,r4,r3
81122a10:	8080030d 	sth	r2,12(r16)
81122a14:	1007883a 	mov	r3,r2
81122a18:	81001915 	stw	r4,100(r16)
81122a1c:	80000115 	stw	zero,4(r16)
81122a20:	1100080c 	andi	r4,r2,32
81122a24:	2000571e 	bne	r4,zero,81122b84 <__srefill_r+0x1c4>
81122a28:	1100010c 	andi	r4,r2,4
81122a2c:	20001f26 	beq	r4,zero,81122aac <__srefill_r+0xec>
81122a30:	81400c17 	ldw	r5,48(r16)
81122a34:	28000826 	beq	r5,zero,81122a58 <__srefill_r+0x98>
81122a38:	80801004 	addi	r2,r16,64
81122a3c:	28800226 	beq	r5,r2,81122a48 <__srefill_r+0x88>
81122a40:	8809883a 	mov	r4,r17
81122a44:	112b9580 	call	8112b958 <_free_r>
81122a48:	80800f17 	ldw	r2,60(r16)
81122a4c:	80000c15 	stw	zero,48(r16)
81122a50:	80800115 	stw	r2,4(r16)
81122a54:	1000391e 	bne	r2,zero,81122b3c <__srefill_r+0x17c>
81122a58:	80800417 	ldw	r2,16(r16)
81122a5c:	10004b26 	beq	r2,zero,81122b8c <__srefill_r+0x1cc>
81122a60:	8480030b 	ldhu	r18,12(r16)
81122a64:	908000cc 	andi	r2,r18,3
81122a68:	10001f1e 	bne	r2,zero,81122ae8 <__srefill_r+0x128>
81122a6c:	81800417 	ldw	r6,16(r16)
81122a70:	80800817 	ldw	r2,32(r16)
81122a74:	81c00517 	ldw	r7,20(r16)
81122a78:	81400717 	ldw	r5,28(r16)
81122a7c:	81800015 	stw	r6,0(r16)
81122a80:	8809883a 	mov	r4,r17
81122a84:	103ee83a 	callr	r2
81122a88:	80800115 	stw	r2,4(r16)
81122a8c:	00800e0e 	bge	zero,r2,81122ac8 <__srefill_r+0x108>
81122a90:	0005883a 	mov	r2,zero
81122a94:	dfc00317 	ldw	ra,12(sp)
81122a98:	dc800217 	ldw	r18,8(sp)
81122a9c:	dc400117 	ldw	r17,4(sp)
81122aa0:	dc000017 	ldw	r16,0(sp)
81122aa4:	dec00404 	addi	sp,sp,16
81122aa8:	f800283a 	ret
81122aac:	1100040c 	andi	r4,r2,16
81122ab0:	20003026 	beq	r4,zero,81122b74 <__srefill_r+0x1b4>
81122ab4:	1080020c 	andi	r2,r2,8
81122ab8:	1000241e 	bne	r2,zero,81122b4c <__srefill_r+0x18c>
81122abc:	18c00114 	ori	r3,r3,4
81122ac0:	80c0030d 	sth	r3,12(r16)
81122ac4:	003fe406 	br	81122a58 <__reset+0xfb102a58>
81122ac8:	80c0030b 	ldhu	r3,12(r16)
81122acc:	1000161e 	bne	r2,zero,81122b28 <__srefill_r+0x168>
81122ad0:	18c00814 	ori	r3,r3,32
81122ad4:	00bfffc4 	movi	r2,-1
81122ad8:	80c0030d 	sth	r3,12(r16)
81122adc:	003fed06 	br	81122a94 <__reset+0xfb102a94>
81122ae0:	112b4c00 	call	8112b4c0 <__sinit>
81122ae4:	003fc206 	br	811229f0 <__reset+0xfb1029f0>
81122ae8:	00a04574 	movhi	r2,33045
81122aec:	108bec04 	addi	r2,r2,12208
81122af0:	11000017 	ldw	r4,0(r2)
81122af4:	016044b4 	movhi	r5,33042
81122af8:	00800044 	movi	r2,1
81122afc:	294a6904 	addi	r5,r5,10660
81122b00:	8080030d 	sth	r2,12(r16)
81122b04:	112c1340 	call	8112c134 <_fwalk>
81122b08:	00800244 	movi	r2,9
81122b0c:	8480030d 	sth	r18,12(r16)
81122b10:	9480024c 	andi	r18,r18,9
81122b14:	90bfd51e 	bne	r18,r2,81122a6c <__reset+0xfb102a6c>
81122b18:	800b883a 	mov	r5,r16
81122b1c:	8809883a 	mov	r4,r17
81122b20:	112aea00 	call	8112aea0 <__sflush_r>
81122b24:	003fd106 	br	81122a6c <__reset+0xfb102a6c>
81122b28:	18c01014 	ori	r3,r3,64
81122b2c:	80000115 	stw	zero,4(r16)
81122b30:	00bfffc4 	movi	r2,-1
81122b34:	80c0030d 	sth	r3,12(r16)
81122b38:	003fd606 	br	81122a94 <__reset+0xfb102a94>
81122b3c:	80c00e17 	ldw	r3,56(r16)
81122b40:	0005883a 	mov	r2,zero
81122b44:	80c00015 	stw	r3,0(r16)
81122b48:	003fd206 	br	81122a94 <__reset+0xfb102a94>
81122b4c:	800b883a 	mov	r5,r16
81122b50:	8809883a 	mov	r4,r17
81122b54:	112b0c40 	call	8112b0c4 <_fflush_r>
81122b58:	10000a1e 	bne	r2,zero,81122b84 <__srefill_r+0x1c4>
81122b5c:	8080030b 	ldhu	r2,12(r16)
81122b60:	00fffdc4 	movi	r3,-9
81122b64:	80000215 	stw	zero,8(r16)
81122b68:	1886703a 	and	r3,r3,r2
81122b6c:	80000615 	stw	zero,24(r16)
81122b70:	003fd206 	br	81122abc <__reset+0xfb102abc>
81122b74:	00800244 	movi	r2,9
81122b78:	88800015 	stw	r2,0(r17)
81122b7c:	18c01014 	ori	r3,r3,64
81122b80:	80c0030d 	sth	r3,12(r16)
81122b84:	00bfffc4 	movi	r2,-1
81122b88:	003fc206 	br	81122a94 <__reset+0xfb102a94>
81122b8c:	800b883a 	mov	r5,r16
81122b90:	8809883a 	mov	r4,r17
81122b94:	1121a1c0 	call	81121a1c <__smakebuf_r>
81122b98:	003fb106 	br	81122a60 <__reset+0xfb102a60>

81122b9c <_sbrk_r>:
81122b9c:	defffd04 	addi	sp,sp,-12
81122ba0:	de00012e 	bgeu	sp,et,81122ba8 <_sbrk_r+0xc>
81122ba4:	003b68fa 	trap	3
81122ba8:	dc000015 	stw	r16,0(sp)
81122bac:	04204574 	movhi	r16,33045
81122bb0:	dc400115 	stw	r17,4(sp)
81122bb4:	840c6004 	addi	r16,r16,12672
81122bb8:	2023883a 	mov	r17,r4
81122bbc:	2809883a 	mov	r4,r5
81122bc0:	dfc00215 	stw	ra,8(sp)
81122bc4:	80000015 	stw	zero,0(r16)
81122bc8:	11377c80 	call	811377c8 <sbrk>
81122bcc:	00ffffc4 	movi	r3,-1
81122bd0:	10c00526 	beq	r2,r3,81122be8 <_sbrk_r+0x4c>
81122bd4:	dfc00217 	ldw	ra,8(sp)
81122bd8:	dc400117 	ldw	r17,4(sp)
81122bdc:	dc000017 	ldw	r16,0(sp)
81122be0:	dec00304 	addi	sp,sp,12
81122be4:	f800283a 	ret
81122be8:	80c00017 	ldw	r3,0(r16)
81122bec:	183ff926 	beq	r3,zero,81122bd4 <__reset+0xfb102bd4>
81122bf0:	88c00015 	stw	r3,0(r17)
81122bf4:	003ff706 	br	81122bd4 <__reset+0xfb102bd4>

81122bf8 <scanf>:
81122bf8:	defffc04 	addi	sp,sp,-16
81122bfc:	de00012e 	bgeu	sp,et,81122c04 <scanf+0xc>
81122c00:	003b68fa 	trap	3
81122c04:	dfc00015 	stw	ra,0(sp)
81122c08:	d9400115 	stw	r5,4(sp)
81122c0c:	d9800215 	stw	r6,8(sp)
81122c10:	d9c00315 	stw	r7,12(sp)
81122c14:	00a04574 	movhi	r2,33045
81122c18:	108bed04 	addi	r2,r2,12212
81122c1c:	200d883a 	mov	r6,r4
81122c20:	11000017 	ldw	r4,0(r2)
81122c24:	d9c00104 	addi	r7,sp,4
81122c28:	21400117 	ldw	r5,4(r4)
81122c2c:	11292340 	call	81129234 <_vfscanf_r>
81122c30:	dfc00017 	ldw	ra,0(sp)
81122c34:	dec00404 	addi	sp,sp,16
81122c38:	f800283a 	ret

81122c3c <_scanf_r>:
81122c3c:	defffd04 	addi	sp,sp,-12
81122c40:	2805883a 	mov	r2,r5
81122c44:	de00012e 	bgeu	sp,et,81122c4c <_scanf_r+0x10>
81122c48:	003b68fa 	trap	3
81122c4c:	dfc00015 	stw	ra,0(sp)
81122c50:	d9800115 	stw	r6,4(sp)
81122c54:	d9c00215 	stw	r7,8(sp)
81122c58:	21400117 	ldw	r5,4(r4)
81122c5c:	d9c00104 	addi	r7,sp,4
81122c60:	100d883a 	mov	r6,r2
81122c64:	11292340 	call	81129234 <_vfscanf_r>
81122c68:	dfc00017 	ldw	ra,0(sp)
81122c6c:	dec00304 	addi	sp,sp,12
81122c70:	f800283a 	ret

81122c74 <_sprintf_r>:
81122c74:	deffe404 	addi	sp,sp,-112
81122c78:	2807883a 	mov	r3,r5
81122c7c:	de00012e 	bgeu	sp,et,81122c84 <_sprintf_r+0x10>
81122c80:	003b68fa 	trap	3
81122c84:	dfc01a15 	stw	ra,104(sp)
81122c88:	d9c01b15 	stw	r7,108(sp)
81122c8c:	00a00034 	movhi	r2,32768
81122c90:	10bfffc4 	addi	r2,r2,-1
81122c94:	02008204 	movi	r8,520
81122c98:	d8800215 	stw	r2,8(sp)
81122c9c:	d8800515 	stw	r2,20(sp)
81122ca0:	d9c01b04 	addi	r7,sp,108
81122ca4:	d80b883a 	mov	r5,sp
81122ca8:	00bfffc4 	movi	r2,-1
81122cac:	d8c00015 	stw	r3,0(sp)
81122cb0:	d8c00415 	stw	r3,16(sp)
81122cb4:	da00030d 	sth	r8,12(sp)
81122cb8:	d880038d 	sth	r2,14(sp)
81122cbc:	11235240 	call	81123524 <___svfprintf_internal_r>
81122cc0:	d8c00017 	ldw	r3,0(sp)
81122cc4:	18000005 	stb	zero,0(r3)
81122cc8:	dfc01a17 	ldw	ra,104(sp)
81122ccc:	dec01c04 	addi	sp,sp,112
81122cd0:	f800283a 	ret

81122cd4 <sprintf>:
81122cd4:	deffe304 	addi	sp,sp,-116
81122cd8:	2007883a 	mov	r3,r4
81122cdc:	de00012e 	bgeu	sp,et,81122ce4 <sprintf+0x10>
81122ce0:	003b68fa 	trap	3
81122ce4:	dfc01a15 	stw	ra,104(sp)
81122ce8:	d9801b15 	stw	r6,108(sp)
81122cec:	d9c01c15 	stw	r7,112(sp)
81122cf0:	01204574 	movhi	r4,33045
81122cf4:	210bed04 	addi	r4,r4,12212
81122cf8:	21000017 	ldw	r4,0(r4)
81122cfc:	00a00034 	movhi	r2,32768
81122d00:	10bfffc4 	addi	r2,r2,-1
81122d04:	280d883a 	mov	r6,r5
81122d08:	02008204 	movi	r8,520
81122d0c:	d8800215 	stw	r2,8(sp)
81122d10:	d8800515 	stw	r2,20(sp)
81122d14:	d9c01b04 	addi	r7,sp,108
81122d18:	d80b883a 	mov	r5,sp
81122d1c:	00bfffc4 	movi	r2,-1
81122d20:	d8c00015 	stw	r3,0(sp)
81122d24:	d8c00415 	stw	r3,16(sp)
81122d28:	da00030d 	sth	r8,12(sp)
81122d2c:	d880038d 	sth	r2,14(sp)
81122d30:	11235240 	call	81123524 <___svfprintf_internal_r>
81122d34:	d8c00017 	ldw	r3,0(sp)
81122d38:	18000005 	stb	zero,0(r3)
81122d3c:	dfc01a17 	ldw	ra,104(sp)
81122d40:	dec01d04 	addi	sp,sp,116
81122d44:	f800283a 	ret

81122d48 <__sread>:
81122d48:	defffe04 	addi	sp,sp,-8
81122d4c:	de00012e 	bgeu	sp,et,81122d54 <__sread+0xc>
81122d50:	003b68fa 	trap	3
81122d54:	dc000015 	stw	r16,0(sp)
81122d58:	2821883a 	mov	r16,r5
81122d5c:	2940038f 	ldh	r5,14(r5)
81122d60:	dfc00115 	stw	ra,4(sp)
81122d64:	112d9840 	call	8112d984 <_read_r>
81122d68:	10000716 	blt	r2,zero,81122d88 <__sread+0x40>
81122d6c:	80c01417 	ldw	r3,80(r16)
81122d70:	1887883a 	add	r3,r3,r2
81122d74:	80c01415 	stw	r3,80(r16)
81122d78:	dfc00117 	ldw	ra,4(sp)
81122d7c:	dc000017 	ldw	r16,0(sp)
81122d80:	dec00204 	addi	sp,sp,8
81122d84:	f800283a 	ret
81122d88:	80c0030b 	ldhu	r3,12(r16)
81122d8c:	18fbffcc 	andi	r3,r3,61439
81122d90:	80c0030d 	sth	r3,12(r16)
81122d94:	dfc00117 	ldw	ra,4(sp)
81122d98:	dc000017 	ldw	r16,0(sp)
81122d9c:	dec00204 	addi	sp,sp,8
81122da0:	f800283a 	ret

81122da4 <__seofread>:
81122da4:	0005883a 	mov	r2,zero
81122da8:	f800283a 	ret

81122dac <__swrite>:
81122dac:	defffb04 	addi	sp,sp,-20
81122db0:	de00012e 	bgeu	sp,et,81122db8 <__swrite+0xc>
81122db4:	003b68fa 	trap	3
81122db8:	2880030b 	ldhu	r2,12(r5)
81122dbc:	dcc00315 	stw	r19,12(sp)
81122dc0:	dc800215 	stw	r18,8(sp)
81122dc4:	dc400115 	stw	r17,4(sp)
81122dc8:	dc000015 	stw	r16,0(sp)
81122dcc:	dfc00415 	stw	ra,16(sp)
81122dd0:	10c0400c 	andi	r3,r2,256
81122dd4:	2821883a 	mov	r16,r5
81122dd8:	2023883a 	mov	r17,r4
81122ddc:	3025883a 	mov	r18,r6
81122de0:	3827883a 	mov	r19,r7
81122de4:	18000526 	beq	r3,zero,81122dfc <__swrite+0x50>
81122de8:	2940038f 	ldh	r5,14(r5)
81122dec:	01c00084 	movi	r7,2
81122df0:	000d883a 	mov	r6,zero
81122df4:	112c43c0 	call	8112c43c <_lseek_r>
81122df8:	8080030b 	ldhu	r2,12(r16)
81122dfc:	8140038f 	ldh	r5,14(r16)
81122e00:	10bbffcc 	andi	r2,r2,61439
81122e04:	980f883a 	mov	r7,r19
81122e08:	900d883a 	mov	r6,r18
81122e0c:	8809883a 	mov	r4,r17
81122e10:	8080030d 	sth	r2,12(r16)
81122e14:	dfc00417 	ldw	ra,16(sp)
81122e18:	dcc00317 	ldw	r19,12(sp)
81122e1c:	dc800217 	ldw	r18,8(sp)
81122e20:	dc400117 	ldw	r17,4(sp)
81122e24:	dc000017 	ldw	r16,0(sp)
81122e28:	dec00504 	addi	sp,sp,20
81122e2c:	11293e81 	jmpi	811293e8 <_write_r>

81122e30 <__sseek>:
81122e30:	defffe04 	addi	sp,sp,-8
81122e34:	de00012e 	bgeu	sp,et,81122e3c <__sseek+0xc>
81122e38:	003b68fa 	trap	3
81122e3c:	dc000015 	stw	r16,0(sp)
81122e40:	2821883a 	mov	r16,r5
81122e44:	2940038f 	ldh	r5,14(r5)
81122e48:	dfc00115 	stw	ra,4(sp)
81122e4c:	112c43c0 	call	8112c43c <_lseek_r>
81122e50:	00ffffc4 	movi	r3,-1
81122e54:	10c00826 	beq	r2,r3,81122e78 <__sseek+0x48>
81122e58:	80c0030b 	ldhu	r3,12(r16)
81122e5c:	80801415 	stw	r2,80(r16)
81122e60:	18c40014 	ori	r3,r3,4096
81122e64:	80c0030d 	sth	r3,12(r16)
81122e68:	dfc00117 	ldw	ra,4(sp)
81122e6c:	dc000017 	ldw	r16,0(sp)
81122e70:	dec00204 	addi	sp,sp,8
81122e74:	f800283a 	ret
81122e78:	80c0030b 	ldhu	r3,12(r16)
81122e7c:	18fbffcc 	andi	r3,r3,61439
81122e80:	80c0030d 	sth	r3,12(r16)
81122e84:	dfc00117 	ldw	ra,4(sp)
81122e88:	dc000017 	ldw	r16,0(sp)
81122e8c:	dec00204 	addi	sp,sp,8
81122e90:	f800283a 	ret

81122e94 <__sclose>:
81122e94:	2940038f 	ldh	r5,14(r5)
81122e98:	11295ac1 	jmpi	811295ac <_close_r>

81122e9c <strcspn>:
81122e9c:	21c00007 	ldb	r7,0(r4)
81122ea0:	38000f26 	beq	r7,zero,81122ee0 <strcspn+0x44>
81122ea4:	2a000007 	ldb	r8,0(r5)
81122ea8:	2005883a 	mov	r2,r4
81122eac:	40000726 	beq	r8,zero,81122ecc <strcspn+0x30>
81122eb0:	3a000926 	beq	r7,r8,81122ed8 <strcspn+0x3c>
81122eb4:	2807883a 	mov	r3,r5
81122eb8:	00000106 	br	81122ec0 <strcspn+0x24>
81122ebc:	31c00626 	beq	r6,r7,81122ed8 <strcspn+0x3c>
81122ec0:	18c00044 	addi	r3,r3,1
81122ec4:	19800007 	ldb	r6,0(r3)
81122ec8:	303ffc1e 	bne	r6,zero,81122ebc <__reset+0xfb102ebc>
81122ecc:	10800044 	addi	r2,r2,1
81122ed0:	11c00007 	ldb	r7,0(r2)
81122ed4:	383ff51e 	bne	r7,zero,81122eac <__reset+0xfb102eac>
81122ed8:	1105c83a 	sub	r2,r2,r4
81122edc:	f800283a 	ret
81122ee0:	0005883a 	mov	r2,zero
81122ee4:	f800283a 	ret

81122ee8 <strlen>:
81122ee8:	208000cc 	andi	r2,r4,3
81122eec:	10002026 	beq	r2,zero,81122f70 <strlen+0x88>
81122ef0:	20800007 	ldb	r2,0(r4)
81122ef4:	10002026 	beq	r2,zero,81122f78 <strlen+0x90>
81122ef8:	2005883a 	mov	r2,r4
81122efc:	00000206 	br	81122f08 <strlen+0x20>
81122f00:	10c00007 	ldb	r3,0(r2)
81122f04:	18001826 	beq	r3,zero,81122f68 <strlen+0x80>
81122f08:	10800044 	addi	r2,r2,1
81122f0c:	10c000cc 	andi	r3,r2,3
81122f10:	183ffb1e 	bne	r3,zero,81122f00 <__reset+0xfb102f00>
81122f14:	10c00017 	ldw	r3,0(r2)
81122f18:	01ffbff4 	movhi	r7,65279
81122f1c:	39ffbfc4 	addi	r7,r7,-257
81122f20:	00ca303a 	nor	r5,zero,r3
81122f24:	01a02074 	movhi	r6,32897
81122f28:	19c7883a 	add	r3,r3,r7
81122f2c:	31a02004 	addi	r6,r6,-32640
81122f30:	1946703a 	and	r3,r3,r5
81122f34:	1986703a 	and	r3,r3,r6
81122f38:	1800091e 	bne	r3,zero,81122f60 <strlen+0x78>
81122f3c:	10800104 	addi	r2,r2,4
81122f40:	10c00017 	ldw	r3,0(r2)
81122f44:	19cb883a 	add	r5,r3,r7
81122f48:	00c6303a 	nor	r3,zero,r3
81122f4c:	28c6703a 	and	r3,r5,r3
81122f50:	1986703a 	and	r3,r3,r6
81122f54:	183ff926 	beq	r3,zero,81122f3c <__reset+0xfb102f3c>
81122f58:	00000106 	br	81122f60 <strlen+0x78>
81122f5c:	10800044 	addi	r2,r2,1
81122f60:	10c00007 	ldb	r3,0(r2)
81122f64:	183ffd1e 	bne	r3,zero,81122f5c <__reset+0xfb102f5c>
81122f68:	1105c83a 	sub	r2,r2,r4
81122f6c:	f800283a 	ret
81122f70:	2005883a 	mov	r2,r4
81122f74:	003fe706 	br	81122f14 <__reset+0xfb102f14>
81122f78:	0005883a 	mov	r2,zero
81122f7c:	f800283a 	ret

81122f80 <strnlen>:
81122f80:	28000e26 	beq	r5,zero,81122fbc <strnlen+0x3c>
81122f84:	20800007 	ldb	r2,0(r4)
81122f88:	10000c26 	beq	r2,zero,81122fbc <strnlen+0x3c>
81122f8c:	20c00044 	addi	r3,r4,1
81122f90:	214b883a 	add	r5,r4,r5
81122f94:	28c00526 	beq	r5,r3,81122fac <strnlen+0x2c>
81122f98:	19800007 	ldb	r6,0(r3)
81122f9c:	19c00044 	addi	r7,r3,1
81122fa0:	30000426 	beq	r6,zero,81122fb4 <strnlen+0x34>
81122fa4:	3807883a 	mov	r3,r7
81122fa8:	28fffb1e 	bne	r5,r3,81122f98 <__reset+0xfb102f98>
81122fac:	2905c83a 	sub	r2,r5,r4
81122fb0:	f800283a 	ret
81122fb4:	1905c83a 	sub	r2,r3,r4
81122fb8:	f800283a 	ret
81122fbc:	0005883a 	mov	r2,zero
81122fc0:	f800283a 	ret

81122fc4 <_strtol_r>:
81122fc4:	00a04574 	movhi	r2,33045
81122fc8:	defff404 	addi	sp,sp,-48
81122fcc:	108beb04 	addi	r2,r2,12204
81122fd0:	de00012e 	bgeu	sp,et,81122fd8 <_strtol_r+0x14>
81122fd4:	003b68fa 	trap	3
81122fd8:	dd400715 	stw	r21,28(sp)
81122fdc:	15400017 	ldw	r21,0(r2)
81122fe0:	dd800815 	stw	r22,32(sp)
81122fe4:	dd000615 	stw	r20,24(sp)
81122fe8:	dcc00515 	stw	r19,20(sp)
81122fec:	d9000015 	stw	r4,0(sp)
81122ff0:	dfc00b15 	stw	ra,44(sp)
81122ff4:	df000a15 	stw	fp,40(sp)
81122ff8:	ddc00915 	stw	r23,36(sp)
81122ffc:	dc800415 	stw	r18,16(sp)
81123000:	dc400315 	stw	r17,12(sp)
81123004:	dc000215 	stw	r16,8(sp)
81123008:	2829883a 	mov	r20,r5
8112300c:	3027883a 	mov	r19,r6
81123010:	382d883a 	mov	r22,r7
81123014:	2809883a 	mov	r4,r5
81123018:	24000003 	ldbu	r16,0(r4)
8112301c:	24400044 	addi	r17,r4,1
81123020:	2007883a 	mov	r3,r4
81123024:	ac05883a 	add	r2,r21,r16
81123028:	10800043 	ldbu	r2,1(r2)
8112302c:	8809883a 	mov	r4,r17
81123030:	1080020c 	andi	r2,r2,8
81123034:	103ff81e 	bne	r2,zero,81123018 <__reset+0xfb103018>
81123038:	00800b44 	movi	r2,45
8112303c:	80805826 	beq	r16,r2,811231a0 <_strtol_r+0x1dc>
81123040:	00800ac4 	movi	r2,43
81123044:	80805a26 	beq	r16,r2,811231b0 <_strtol_r+0x1ec>
81123048:	0039883a 	mov	fp,zero
8112304c:	b0004426 	beq	r22,zero,81123160 <_strtol_r+0x19c>
81123050:	00800404 	movi	r2,16
81123054:	b0806026 	beq	r22,r2,811231d8 <_strtol_r+0x214>
81123058:	b02f883a 	mov	r23,r22
8112305c:	00a00034 	movhi	r2,32768
81123060:	e025003a 	cmpeq	r18,fp,zero
81123064:	14a5c83a 	sub	r18,r2,r18
81123068:	b80b883a 	mov	r5,r23
8112306c:	9009883a 	mov	r4,r18
81123070:	11349e00 	call	811349e0 <__umodsi3>
81123074:	b80b883a 	mov	r5,r23
81123078:	9009883a 	mov	r4,r18
8112307c:	d8800115 	stw	r2,4(sp)
81123080:	113497c0 	call	8113497c <__udivsi3>
81123084:	ac07883a 	add	r3,r21,r16
81123088:	18c00043 	ldbu	r3,1(r3)
8112308c:	880b883a 	mov	r5,r17
81123090:	000d883a 	mov	r6,zero
81123094:	1a00010c 	andi	r8,r3,4
81123098:	0009883a 	mov	r4,zero
8112309c:	02800044 	movi	r10,1
811230a0:	027fffc4 	movi	r9,-1
811230a4:	d9c00117 	ldw	r7,4(sp)
811230a8:	40000e26 	beq	r8,zero,811230e4 <_strtol_r+0x120>
811230ac:	843ff404 	addi	r16,r16,-48
811230b0:	8580120e 	bge	r16,r22,811230fc <_strtol_r+0x138>
811230b4:	32400526 	beq	r6,r9,811230cc <_strtol_r+0x108>
811230b8:	11002536 	bltu	r2,r4,81123150 <_strtol_r+0x18c>
811230bc:	20802326 	beq	r4,r2,8112314c <_strtol_r+0x188>
811230c0:	25c9383a 	mul	r4,r4,r23
811230c4:	01800044 	movi	r6,1
811230c8:	8109883a 	add	r4,r16,r4
811230cc:	2c000003 	ldbu	r16,0(r5)
811230d0:	29400044 	addi	r5,r5,1
811230d4:	ac07883a 	add	r3,r21,r16
811230d8:	18c00043 	ldbu	r3,1(r3)
811230dc:	1a00010c 	andi	r8,r3,4
811230e0:	403ff21e 	bne	r8,zero,811230ac <__reset+0xfb1030ac>
811230e4:	18c000cc 	andi	r3,r3,3
811230e8:	18000426 	beq	r3,zero,811230fc <_strtol_r+0x138>
811230ec:	1a801a26 	beq	r3,r10,81123158 <_strtol_r+0x194>
811230f0:	00c015c4 	movi	r3,87
811230f4:	80e1c83a 	sub	r16,r16,r3
811230f8:	85bfee16 	blt	r16,r22,811230b4 <__reset+0xfb1030b4>
811230fc:	00bfffc4 	movi	r2,-1
81123100:	30801e26 	beq	r6,r2,8112317c <_strtol_r+0x1b8>
81123104:	e0001b1e 	bne	fp,zero,81123174 <_strtol_r+0x1b0>
81123108:	2005883a 	mov	r2,r4
8112310c:	98000326 	beq	r19,zero,8112311c <_strtol_r+0x158>
81123110:	3000211e 	bne	r6,zero,81123198 <_strtol_r+0x1d4>
81123114:	a00b883a 	mov	r5,r20
81123118:	99400015 	stw	r5,0(r19)
8112311c:	dfc00b17 	ldw	ra,44(sp)
81123120:	df000a17 	ldw	fp,40(sp)
81123124:	ddc00917 	ldw	r23,36(sp)
81123128:	dd800817 	ldw	r22,32(sp)
8112312c:	dd400717 	ldw	r21,28(sp)
81123130:	dd000617 	ldw	r20,24(sp)
81123134:	dcc00517 	ldw	r19,20(sp)
81123138:	dc800417 	ldw	r18,16(sp)
8112313c:	dc400317 	ldw	r17,12(sp)
81123140:	dc000217 	ldw	r16,8(sp)
81123144:	dec00c04 	addi	sp,sp,48
81123148:	f800283a 	ret
8112314c:	3c3fdc0e 	bge	r7,r16,811230c0 <__reset+0xfb1030c0>
81123150:	01bfffc4 	movi	r6,-1
81123154:	003fdd06 	br	811230cc <__reset+0xfb1030cc>
81123158:	00c00dc4 	movi	r3,55
8112315c:	003fe506 	br	811230f4 <__reset+0xfb1030f4>
81123160:	00800c04 	movi	r2,48
81123164:	80801626 	beq	r16,r2,811231c0 <_strtol_r+0x1fc>
81123168:	05800284 	movi	r22,10
8112316c:	b02f883a 	mov	r23,r22
81123170:	003fba06 	br	8112305c <__reset+0xfb10305c>
81123174:	0109c83a 	sub	r4,zero,r4
81123178:	003fe306 	br	81123108 <__reset+0xfb103108>
8112317c:	d9000017 	ldw	r4,0(sp)
81123180:	00c00884 	movi	r3,34
81123184:	e005003a 	cmpeq	r2,fp,zero
81123188:	20c00015 	stw	r3,0(r4)
8112318c:	00e00034 	movhi	r3,32768
81123190:	1885c83a 	sub	r2,r3,r2
81123194:	983fe126 	beq	r19,zero,8112311c <__reset+0xfb10311c>
81123198:	297fffc4 	addi	r5,r5,-1
8112319c:	003fde06 	br	81123118 <__reset+0xfb103118>
811231a0:	1c400084 	addi	r17,r3,2
811231a4:	1c000043 	ldbu	r16,1(r3)
811231a8:	07000044 	movi	fp,1
811231ac:	003fa706 	br	8112304c <__reset+0xfb10304c>
811231b0:	1c400084 	addi	r17,r3,2
811231b4:	1c000043 	ldbu	r16,1(r3)
811231b8:	0039883a 	mov	fp,zero
811231bc:	003fa306 	br	8112304c <__reset+0xfb10304c>
811231c0:	88800003 	ldbu	r2,0(r17)
811231c4:	00c01604 	movi	r3,88
811231c8:	108037cc 	andi	r2,r2,223
811231cc:	10c00826 	beq	r2,r3,811231f0 <_strtol_r+0x22c>
811231d0:	05800204 	movi	r22,8
811231d4:	003fa006 	br	81123058 <__reset+0xfb103058>
811231d8:	00800c04 	movi	r2,48
811231dc:	80bf9e1e 	bne	r16,r2,81123058 <__reset+0xfb103058>
811231e0:	88800003 	ldbu	r2,0(r17)
811231e4:	00c01604 	movi	r3,88
811231e8:	108037cc 	andi	r2,r2,223
811231ec:	10ff9a1e 	bne	r2,r3,81123058 <__reset+0xfb103058>
811231f0:	05c00404 	movi	r23,16
811231f4:	8c000043 	ldbu	r16,1(r17)
811231f8:	b82d883a 	mov	r22,r23
811231fc:	8c400084 	addi	r17,r17,2
81123200:	003f9606 	br	8112305c <__reset+0xfb10305c>

81123204 <strtol>:
81123204:	00a04574 	movhi	r2,33045
81123208:	108bed04 	addi	r2,r2,12212
8112320c:	300f883a 	mov	r7,r6
81123210:	280d883a 	mov	r6,r5
81123214:	200b883a 	mov	r5,r4
81123218:	11000017 	ldw	r4,0(r2)
8112321c:	1122fc41 	jmpi	81122fc4 <_strtol_r>

81123220 <strtoll>:
81123220:	00a04574 	movhi	r2,33045
81123224:	108bed04 	addi	r2,r2,12212
81123228:	300f883a 	mov	r7,r6
8112322c:	280d883a 	mov	r6,r5
81123230:	200b883a 	mov	r5,r4
81123234:	11000017 	ldw	r4,0(r2)
81123238:	112323c1 	jmpi	8112323c <_strtoll_r>

8112323c <_strtoll_r>:
8112323c:	00a04574 	movhi	r2,33045
81123240:	defff304 	addi	sp,sp,-52
81123244:	108beb04 	addi	r2,r2,12204
81123248:	de00012e 	bgeu	sp,et,81123250 <_strtoll_r+0x14>
8112324c:	003b68fa 	trap	3
81123250:	dc800515 	stw	r18,20(sp)
81123254:	14800017 	ldw	r18,0(r2)
81123258:	dd800915 	stw	r22,36(sp)
8112325c:	dd400815 	stw	r21,32(sp)
81123260:	dcc00615 	stw	r19,24(sp)
81123264:	d9000015 	stw	r4,0(sp)
81123268:	dfc00c15 	stw	ra,48(sp)
8112326c:	df000b15 	stw	fp,44(sp)
81123270:	ddc00a15 	stw	r23,40(sp)
81123274:	dd000715 	stw	r20,28(sp)
81123278:	dc400415 	stw	r17,16(sp)
8112327c:	dc000315 	stw	r16,12(sp)
81123280:	282d883a 	mov	r22,r5
81123284:	302b883a 	mov	r21,r6
81123288:	3827883a 	mov	r19,r7
8112328c:	2809883a 	mov	r4,r5
81123290:	24000003 	ldbu	r16,0(r4)
81123294:	24400044 	addi	r17,r4,1
81123298:	2007883a 	mov	r3,r4
8112329c:	9405883a 	add	r2,r18,r16
811232a0:	10800043 	ldbu	r2,1(r2)
811232a4:	8809883a 	mov	r4,r17
811232a8:	1080020c 	andi	r2,r2,8
811232ac:	103ff81e 	bne	r2,zero,81123290 <__reset+0xfb103290>
811232b0:	00800b44 	movi	r2,45
811232b4:	80807826 	beq	r16,r2,81123498 <_strtoll_r+0x25c>
811232b8:	00800ac4 	movi	r2,43
811232bc:	80807a26 	beq	r16,r2,811234a8 <_strtoll_r+0x26c>
811232c0:	0039883a 	mov	fp,zero
811232c4:	98004e26 	beq	r19,zero,81123400 <_strtoll_r+0x1c4>
811232c8:	00800404 	movi	r2,16
811232cc:	98808226 	beq	r19,r2,811234d8 <_strtoll_r+0x29c>
811232d0:	982fd7fa 	srai	r23,r19,31
811232d4:	9829883a 	mov	r20,r19
811232d8:	e0004f26 	beq	fp,zero,81123418 <_strtoll_r+0x1dc>
811232dc:	0017883a 	mov	r11,zero
811232e0:	02a00034 	movhi	r10,32768
811232e4:	5809883a 	mov	r4,r11
811232e8:	500b883a 	mov	r5,r10
811232ec:	a00d883a 	mov	r6,r20
811232f0:	b80f883a 	mov	r7,r23
811232f4:	da800215 	stw	r10,8(sp)
811232f8:	dac00115 	stw	r11,4(sp)
811232fc:	11343440 	call	81134344 <__umoddi3>
81123300:	dac00117 	ldw	r11,4(sp)
81123304:	da800217 	ldw	r10,8(sp)
81123308:	a00d883a 	mov	r6,r20
8112330c:	5809883a 	mov	r4,r11
81123310:	500b883a 	mov	r5,r10
81123314:	b80f883a 	mov	r7,r23
81123318:	d8800115 	stw	r2,4(sp)
8112331c:	1133dc40 	call	81133dc4 <__udivdi3>
81123320:	9409883a 	add	r4,r18,r16
81123324:	21000043 	ldbu	r4,1(r4)
81123328:	1019883a 	mov	r12,r2
8112332c:	880b883a 	mov	r5,r17
81123330:	2240010c 	andi	r9,r4,4
81123334:	0015883a 	mov	r10,zero
81123338:	000d883a 	mov	r6,zero
8112333c:	000f883a 	mov	r7,zero
81123340:	03400044 	movi	r13,1
81123344:	02ffffc4 	movi	r11,-1
81123348:	da000117 	ldw	r8,4(sp)
8112334c:	48000d26 	beq	r9,zero,81123384 <_strtoll_r+0x148>
81123350:	843ff404 	addi	r16,r16,-48
81123354:	84c0110e 	bge	r16,r19,8112339c <_strtoll_r+0x160>
81123358:	52c00426 	beq	r10,r11,8112336c <_strtoll_r+0x130>
8112335c:	19c00236 	bltu	r3,r7,81123368 <_strtoll_r+0x12c>
81123360:	38c0311e 	bne	r7,r3,81123428 <_strtoll_r+0x1ec>
81123364:	6180302e 	bgeu	r12,r6,81123428 <_strtoll_r+0x1ec>
81123368:	02bfffc4 	movi	r10,-1
8112336c:	2c000003 	ldbu	r16,0(r5)
81123370:	29400044 	addi	r5,r5,1
81123374:	9409883a 	add	r4,r18,r16
81123378:	21000043 	ldbu	r4,1(r4)
8112337c:	2240010c 	andi	r9,r4,4
81123380:	483ff31e 	bne	r9,zero,81123350 <__reset+0xfb103350>
81123384:	210000cc 	andi	r4,r4,3
81123388:	20000426 	beq	r4,zero,8112339c <_strtoll_r+0x160>
8112338c:	23403426 	beq	r4,r13,81123460 <_strtoll_r+0x224>
81123390:	008015c4 	movi	r2,87
81123394:	80a1c83a 	sub	r16,r16,r2
81123398:	84ffef16 	blt	r16,r19,81123358 <__reset+0xfb103358>
8112339c:	00bfffc4 	movi	r2,-1
811233a0:	50803426 	beq	r10,r2,81123474 <_strtoll_r+0x238>
811233a4:	e0000426 	beq	fp,zero,811233b8 <_strtoll_r+0x17c>
811233a8:	018dc83a 	sub	r6,zero,r6
811233ac:	3004c03a 	cmpne	r2,r6,zero
811233b0:	01e1c83a 	sub	r16,zero,r7
811233b4:	808fc83a 	sub	r7,r16,r2
811233b8:	3005883a 	mov	r2,r6
811233bc:	3807883a 	mov	r3,r7
811233c0:	a8000326 	beq	r21,zero,811233d0 <_strtoll_r+0x194>
811233c4:	5000321e 	bne	r10,zero,81123490 <_strtoll_r+0x254>
811233c8:	b00b883a 	mov	r5,r22
811233cc:	a9400015 	stw	r5,0(r21)
811233d0:	dfc00c17 	ldw	ra,48(sp)
811233d4:	df000b17 	ldw	fp,44(sp)
811233d8:	ddc00a17 	ldw	r23,40(sp)
811233dc:	dd800917 	ldw	r22,36(sp)
811233e0:	dd400817 	ldw	r21,32(sp)
811233e4:	dd000717 	ldw	r20,28(sp)
811233e8:	dcc00617 	ldw	r19,24(sp)
811233ec:	dc800517 	ldw	r18,20(sp)
811233f0:	dc400417 	ldw	r17,16(sp)
811233f4:	dc000317 	ldw	r16,12(sp)
811233f8:	dec00d04 	addi	sp,sp,52
811233fc:	f800283a 	ret
81123400:	00800c04 	movi	r2,48
81123404:	80802c26 	beq	r16,r2,811234b8 <_strtoll_r+0x27c>
81123408:	05000284 	movi	r20,10
8112340c:	002f883a 	mov	r23,zero
81123410:	a027883a 	mov	r19,r20
81123414:	e03fb11e 	bne	fp,zero,811232dc <__reset+0xfb1032dc>
81123418:	02a00034 	movhi	r10,32768
8112341c:	52bfffc4 	addi	r10,r10,-1
81123420:	02ffffc4 	movi	r11,-1
81123424:	003faf06 	br	811232e4 <__reset+0xfb1032e4>
81123428:	33000f26 	beq	r6,r12,81123468 <_strtoll_r+0x22c>
8112342c:	b985383a 	mul	r2,r23,r6
81123430:	3d0f383a 	mul	r7,r7,r20
81123434:	3508383a 	mulxuu	r4,r6,r20
81123438:	350d383a 	mul	r6,r6,r20
8112343c:	8013d7fa 	srai	r9,r16,31
81123440:	388f883a 	add	r7,r7,r2
81123444:	818d883a 	add	r6,r16,r6
81123448:	390f883a 	add	r7,r7,r4
8112344c:	3421803a 	cmpltu	r16,r6,r16
81123450:	49cf883a 	add	r7,r9,r7
81123454:	81cf883a 	add	r7,r16,r7
81123458:	02800044 	movi	r10,1
8112345c:	003fc306 	br	8112336c <__reset+0xfb10336c>
81123460:	00800dc4 	movi	r2,55
81123464:	003fcb06 	br	81123394 <__reset+0xfb103394>
81123468:	38fff01e 	bne	r7,r3,8112342c <__reset+0xfb10342c>
8112346c:	443fbe16 	blt	r8,r16,81123368 <__reset+0xfb103368>
81123470:	003fee06 	br	8112342c <__reset+0xfb10342c>
81123474:	e0002426 	beq	fp,zero,81123508 <_strtoll_r+0x2cc>
81123478:	0005883a 	mov	r2,zero
8112347c:	00e00034 	movhi	r3,32768
81123480:	d9800017 	ldw	r6,0(sp)
81123484:	01000884 	movi	r4,34
81123488:	31000015 	stw	r4,0(r6)
8112348c:	a83fd026 	beq	r21,zero,811233d0 <__reset+0xfb1033d0>
81123490:	297fffc4 	addi	r5,r5,-1
81123494:	003fcd06 	br	811233cc <__reset+0xfb1033cc>
81123498:	1c400084 	addi	r17,r3,2
8112349c:	1c000043 	ldbu	r16,1(r3)
811234a0:	07000044 	movi	fp,1
811234a4:	003f8706 	br	811232c4 <__reset+0xfb1032c4>
811234a8:	1c400084 	addi	r17,r3,2
811234ac:	1c000043 	ldbu	r16,1(r3)
811234b0:	0039883a 	mov	fp,zero
811234b4:	003f8306 	br	811232c4 <__reset+0xfb1032c4>
811234b8:	88800003 	ldbu	r2,0(r17)
811234bc:	00c01604 	movi	r3,88
811234c0:	108037cc 	andi	r2,r2,223
811234c4:	10c00a26 	beq	r2,r3,811234f0 <_strtoll_r+0x2b4>
811234c8:	05000204 	movi	r20,8
811234cc:	002f883a 	mov	r23,zero
811234d0:	a027883a 	mov	r19,r20
811234d4:	003f8006 	br	811232d8 <__reset+0xfb1032d8>
811234d8:	00800c04 	movi	r2,48
811234dc:	80800e1e 	bne	r16,r2,81123518 <_strtoll_r+0x2dc>
811234e0:	88800003 	ldbu	r2,0(r17)
811234e4:	00c01604 	movi	r3,88
811234e8:	108037cc 	andi	r2,r2,223
811234ec:	10c00a1e 	bne	r2,r3,81123518 <_strtoll_r+0x2dc>
811234f0:	05000404 	movi	r20,16
811234f4:	8c000043 	ldbu	r16,1(r17)
811234f8:	002f883a 	mov	r23,zero
811234fc:	8c400084 	addi	r17,r17,2
81123500:	a027883a 	mov	r19,r20
81123504:	003f7406 	br	811232d8 <__reset+0xfb1032d8>
81123508:	00e00034 	movhi	r3,32768
8112350c:	18ffffc4 	addi	r3,r3,-1
81123510:	5005883a 	mov	r2,r10
81123514:	003fda06 	br	81123480 <__reset+0xfb103480>
81123518:	9829883a 	mov	r20,r19
8112351c:	002f883a 	mov	r23,zero
81123520:	003f6d06 	br	811232d8 <__reset+0xfb1032d8>

81123524 <___svfprintf_internal_r>:
81123524:	deffb704 	addi	sp,sp,-292
81123528:	de00012e 	bgeu	sp,et,81123530 <___svfprintf_internal_r+0xc>
8112352c:	003b68fa 	trap	3
81123530:	dfc04815 	stw	ra,288(sp)
81123534:	ddc04615 	stw	r23,280(sp)
81123538:	d9402c15 	stw	r5,176(sp)
8112353c:	d9003915 	stw	r4,228(sp)
81123540:	302f883a 	mov	r23,r6
81123544:	d9c02d15 	stw	r7,180(sp)
81123548:	df004715 	stw	fp,284(sp)
8112354c:	dd804515 	stw	r22,276(sp)
81123550:	dd404415 	stw	r21,272(sp)
81123554:	dd004315 	stw	r20,268(sp)
81123558:	dcc04215 	stw	r19,264(sp)
8112355c:	dc804115 	stw	r18,260(sp)
81123560:	dc404015 	stw	r17,256(sp)
81123564:	dc003f15 	stw	r16,252(sp)
81123568:	112c40c0 	call	8112c40c <_localeconv_r>
8112356c:	10800017 	ldw	r2,0(r2)
81123570:	1009883a 	mov	r4,r2
81123574:	d8803415 	stw	r2,208(sp)
81123578:	1122ee80 	call	81122ee8 <strlen>
8112357c:	d8c02c17 	ldw	r3,176(sp)
81123580:	d8803815 	stw	r2,224(sp)
81123584:	1880030b 	ldhu	r2,12(r3)
81123588:	1080200c 	andi	r2,r2,128
8112358c:	10000226 	beq	r2,zero,81123598 <___svfprintf_internal_r+0x74>
81123590:	18800417 	ldw	r2,16(r3)
81123594:	10067f26 	beq	r2,zero,81124f94 <___svfprintf_internal_r+0x1a70>
81123598:	dcc03917 	ldw	r19,228(sp)
8112359c:	d8c00404 	addi	r3,sp,16
811235a0:	05604574 	movhi	r21,33045
811235a4:	d9001e04 	addi	r4,sp,120
811235a8:	ad422584 	addi	r21,r21,2198
811235ac:	d8c01e15 	stw	r3,120(sp)
811235b0:	d8002015 	stw	zero,128(sp)
811235b4:	d8001f15 	stw	zero,124(sp)
811235b8:	d8003315 	stw	zero,204(sp)
811235bc:	d8003615 	stw	zero,216(sp)
811235c0:	d8003715 	stw	zero,220(sp)
811235c4:	1811883a 	mov	r8,r3
811235c8:	d8003a15 	stw	zero,232(sp)
811235cc:	d8003b15 	stw	zero,236(sp)
811235d0:	d8002f15 	stw	zero,188(sp)
811235d4:	d9002815 	stw	r4,160(sp)
811235d8:	b8800007 	ldb	r2,0(r23)
811235dc:	10026726 	beq	r2,zero,81123f7c <___svfprintf_internal_r+0xa58>
811235e0:	00c00944 	movi	r3,37
811235e4:	b821883a 	mov	r16,r23
811235e8:	10c0021e 	bne	r2,r3,811235f4 <___svfprintf_internal_r+0xd0>
811235ec:	00001406 	br	81123640 <___svfprintf_internal_r+0x11c>
811235f0:	10c00326 	beq	r2,r3,81123600 <___svfprintf_internal_r+0xdc>
811235f4:	84000044 	addi	r16,r16,1
811235f8:	80800007 	ldb	r2,0(r16)
811235fc:	103ffc1e 	bne	r2,zero,811235f0 <__reset+0xfb1035f0>
81123600:	85e3c83a 	sub	r17,r16,r23
81123604:	88000e26 	beq	r17,zero,81123640 <___svfprintf_internal_r+0x11c>
81123608:	d8c02017 	ldw	r3,128(sp)
8112360c:	d8801f17 	ldw	r2,124(sp)
81123610:	45c00015 	stw	r23,0(r8)
81123614:	1c47883a 	add	r3,r3,r17
81123618:	10800044 	addi	r2,r2,1
8112361c:	d8c02015 	stw	r3,128(sp)
81123620:	44400115 	stw	r17,4(r8)
81123624:	d8801f15 	stw	r2,124(sp)
81123628:	00c001c4 	movi	r3,7
8112362c:	18809716 	blt	r3,r2,8112388c <___svfprintf_internal_r+0x368>
81123630:	42000204 	addi	r8,r8,8
81123634:	d9402f17 	ldw	r5,188(sp)
81123638:	2c4b883a 	add	r5,r5,r17
8112363c:	d9402f15 	stw	r5,188(sp)
81123640:	80800007 	ldb	r2,0(r16)
81123644:	10009826 	beq	r2,zero,811238a8 <___svfprintf_internal_r+0x384>
81123648:	84400047 	ldb	r17,1(r16)
8112364c:	00bfffc4 	movi	r2,-1
81123650:	85c00044 	addi	r23,r16,1
81123654:	d8002785 	stb	zero,158(sp)
81123658:	0007883a 	mov	r3,zero
8112365c:	000f883a 	mov	r7,zero
81123660:	d8802915 	stw	r2,164(sp)
81123664:	d8003115 	stw	zero,196(sp)
81123668:	0025883a 	mov	r18,zero
8112366c:	01401604 	movi	r5,88
81123670:	01800244 	movi	r6,9
81123674:	02800a84 	movi	r10,42
81123678:	02401b04 	movi	r9,108
8112367c:	bdc00044 	addi	r23,r23,1
81123680:	88bff804 	addi	r2,r17,-32
81123684:	2882f036 	bltu	r5,r2,81124248 <___svfprintf_internal_r+0xd24>
81123688:	100490ba 	slli	r2,r2,2
8112368c:	012044b4 	movhi	r4,33042
81123690:	210da804 	addi	r4,r4,13984
81123694:	1105883a 	add	r2,r2,r4
81123698:	10800017 	ldw	r2,0(r2)
8112369c:	1000683a 	jmp	r2
811236a0:	811241b0 	cmpltui	r4,r16,18694
811236a4:	81124248 	cmpgei	r4,r16,18697
811236a8:	81124248 	cmpgei	r4,r16,18697
811236ac:	811241a4 	muli	r4,r16,18694
811236b0:	81124248 	cmpgei	r4,r16,18697
811236b4:	81124248 	cmpgei	r4,r16,18697
811236b8:	81124248 	cmpgei	r4,r16,18697
811236bc:	81124248 	cmpgei	r4,r16,18697
811236c0:	81124248 	cmpgei	r4,r16,18697
811236c4:	81124248 	cmpgei	r4,r16,18697
811236c8:	81123904 	addi	r4,r16,18660
811236cc:	811240e0 	cmpeqi	r4,r16,18691
811236d0:	81124248 	cmpgei	r4,r16,18697
811236d4:	81123814 	ori	r4,r16,18656
811236d8:	8112392c 	andhi	r4,r16,18660
811236dc:	81124248 	cmpgei	r4,r16,18697
811236e0:	811239a0 	cmpeqi	r4,r16,18662
811236e4:	8112396c 	andhi	r4,r16,18661
811236e8:	8112396c 	andhi	r4,r16,18661
811236ec:	8112396c 	andhi	r4,r16,18661
811236f0:	8112396c 	andhi	r4,r16,18661
811236f4:	8112396c 	andhi	r4,r16,18661
811236f8:	8112396c 	andhi	r4,r16,18661
811236fc:	8112396c 	andhi	r4,r16,18661
81123700:	8112396c 	andhi	r4,r16,18661
81123704:	8112396c 	andhi	r4,r16,18661
81123708:	81124248 	cmpgei	r4,r16,18697
8112370c:	81124248 	cmpgei	r4,r16,18697
81123710:	81124248 	cmpgei	r4,r16,18697
81123714:	81124248 	cmpgei	r4,r16,18697
81123718:	81124248 	cmpgei	r4,r16,18697
8112371c:	81124248 	cmpgei	r4,r16,18697
81123720:	81124248 	cmpgei	r4,r16,18697
81123724:	81124248 	cmpgei	r4,r16,18697
81123728:	81124248 	cmpgei	r4,r16,18697
8112372c:	81124248 	cmpgei	r4,r16,18697
81123730:	81123a58 	cmpnei	r4,r16,18665
81123734:	811239ac 	andhi	r4,r16,18662
81123738:	81124248 	cmpgei	r4,r16,18697
8112373c:	811239ac 	andhi	r4,r16,18662
81123740:	81124248 	cmpgei	r4,r16,18697
81123744:	81124248 	cmpgei	r4,r16,18697
81123748:	81124248 	cmpgei	r4,r16,18697
8112374c:	81124248 	cmpgei	r4,r16,18697
81123750:	81123a4c 	andi	r4,r16,18665
81123754:	81124248 	cmpgei	r4,r16,18697
81123758:	81124248 	cmpgei	r4,r16,18697
8112375c:	81123b14 	ori	r4,r16,18668
81123760:	81124248 	cmpgei	r4,r16,18697
81123764:	81124248 	cmpgei	r4,r16,18697
81123768:	81124248 	cmpgei	r4,r16,18697
8112376c:	81124248 	cmpgei	r4,r16,18697
81123770:	81124248 	cmpgei	r4,r16,18697
81123774:	81123f84 	addi	r4,r16,18686
81123778:	81124248 	cmpgei	r4,r16,18697
8112377c:	81124248 	cmpgei	r4,r16,18697
81123780:	81123fe4 	muli	r4,r16,18687
81123784:	81124248 	cmpgei	r4,r16,18697
81123788:	81124248 	cmpgei	r4,r16,18697
8112378c:	81124248 	cmpgei	r4,r16,18697
81123790:	81124248 	cmpgei	r4,r16,18697
81123794:	81124248 	cmpgei	r4,r16,18697
81123798:	81124248 	cmpgei	r4,r16,18697
8112379c:	81124248 	cmpgei	r4,r16,18697
811237a0:	81124248 	cmpgei	r4,r16,18697
811237a4:	81124248 	cmpgei	r4,r16,18697
811237a8:	81124248 	cmpgei	r4,r16,18697
811237ac:	81124094 	ori	r4,r16,18690
811237b0:	811241d0 	cmplti	r4,r16,18695
811237b4:	811239ac 	andhi	r4,r16,18662
811237b8:	811239ac 	andhi	r4,r16,18662
811237bc:	811239ac 	andhi	r4,r16,18662
811237c0:	81124224 	muli	r4,r16,18696
811237c4:	811241d0 	cmplti	r4,r16,18695
811237c8:	81124248 	cmpgei	r4,r16,18697
811237cc:	81124248 	cmpgei	r4,r16,18697
811237d0:	811241e0 	cmpeqi	r4,r16,18695
811237d4:	81124248 	cmpgei	r4,r16,18697
811237d8:	811241f0 	cmpltui	r4,r16,18695
811237dc:	811240d0 	cmplti	r4,r16,18691
811237e0:	81123820 	cmpeqi	r4,r16,18656
811237e4:	811240f0 	cmpltui	r4,r16,18691
811237e8:	81124248 	cmpgei	r4,r16,18697
811237ec:	811240fc 	xorhi	r4,r16,18691
811237f0:	81124248 	cmpgei	r4,r16,18697
811237f4:	81124158 	cmpnei	r4,r16,18693
811237f8:	81124248 	cmpgei	r4,r16,18697
811237fc:	81124248 	cmpgei	r4,r16,18697
81123800:	81124168 	cmpgeui	r4,r16,18693
81123804:	d9003117 	ldw	r4,196(sp)
81123808:	d8802d15 	stw	r2,180(sp)
8112380c:	0109c83a 	sub	r4,zero,r4
81123810:	d9003115 	stw	r4,196(sp)
81123814:	94800114 	ori	r18,r18,4
81123818:	bc400007 	ldb	r17,0(r23)
8112381c:	003f9706 	br	8112367c <__reset+0xfb10367c>
81123820:	00800c04 	movi	r2,48
81123824:	d9002d17 	ldw	r4,180(sp)
81123828:	d9402917 	ldw	r5,164(sp)
8112382c:	d8802705 	stb	r2,156(sp)
81123830:	00801e04 	movi	r2,120
81123834:	d8802745 	stb	r2,157(sp)
81123838:	d8002785 	stb	zero,158(sp)
8112383c:	20c00104 	addi	r3,r4,4
81123840:	25000017 	ldw	r20,0(r4)
81123844:	002d883a 	mov	r22,zero
81123848:	90800094 	ori	r2,r18,2
8112384c:	28028616 	blt	r5,zero,81124268 <___svfprintf_internal_r+0xd44>
81123850:	00bfdfc4 	movi	r2,-129
81123854:	90a4703a 	and	r18,r18,r2
81123858:	d8c02d15 	stw	r3,180(sp)
8112385c:	94800094 	ori	r18,r18,2
81123860:	a002731e 	bne	r20,zero,81124230 <___svfprintf_internal_r+0xd0c>
81123864:	00a04574 	movhi	r2,33045
81123868:	10821e04 	addi	r2,r2,2168
8112386c:	d8803a15 	stw	r2,232(sp)
81123870:	04401e04 	movi	r17,120
81123874:	d8c02917 	ldw	r3,164(sp)
81123878:	0039883a 	mov	fp,zero
8112387c:	1801d526 	beq	r3,zero,81123fd4 <___svfprintf_internal_r+0xab0>
81123880:	0029883a 	mov	r20,zero
81123884:	002d883a 	mov	r22,zero
81123888:	0001f106 	br	81124050 <___svfprintf_internal_r+0xb2c>
8112388c:	d9402c17 	ldw	r5,176(sp)
81123890:	d9801e04 	addi	r6,sp,120
81123894:	9809883a 	mov	r4,r19
81123898:	112fe5c0 	call	8112fe5c <__ssprint_r>
8112389c:	1000081e 	bne	r2,zero,811238c0 <___svfprintf_internal_r+0x39c>
811238a0:	da000404 	addi	r8,sp,16
811238a4:	003f6306 	br	81123634 <__reset+0xfb103634>
811238a8:	d8802017 	ldw	r2,128(sp)
811238ac:	10000426 	beq	r2,zero,811238c0 <___svfprintf_internal_r+0x39c>
811238b0:	d9402c17 	ldw	r5,176(sp)
811238b4:	d9003917 	ldw	r4,228(sp)
811238b8:	d9801e04 	addi	r6,sp,120
811238bc:	112fe5c0 	call	8112fe5c <__ssprint_r>
811238c0:	d8802c17 	ldw	r2,176(sp)
811238c4:	10c0030b 	ldhu	r3,12(r2)
811238c8:	d8802f17 	ldw	r2,188(sp)
811238cc:	18c0100c 	andi	r3,r3,64
811238d0:	1805f51e 	bne	r3,zero,811250a8 <___svfprintf_internal_r+0x1b84>
811238d4:	dfc04817 	ldw	ra,288(sp)
811238d8:	df004717 	ldw	fp,284(sp)
811238dc:	ddc04617 	ldw	r23,280(sp)
811238e0:	dd804517 	ldw	r22,276(sp)
811238e4:	dd404417 	ldw	r21,272(sp)
811238e8:	dd004317 	ldw	r20,268(sp)
811238ec:	dcc04217 	ldw	r19,264(sp)
811238f0:	dc804117 	ldw	r18,260(sp)
811238f4:	dc404017 	ldw	r17,256(sp)
811238f8:	dc003f17 	ldw	r16,252(sp)
811238fc:	dec04904 	addi	sp,sp,292
81123900:	f800283a 	ret
81123904:	d8802d17 	ldw	r2,180(sp)
81123908:	d9002d17 	ldw	r4,180(sp)
8112390c:	10800017 	ldw	r2,0(r2)
81123910:	d8803115 	stw	r2,196(sp)
81123914:	20800104 	addi	r2,r4,4
81123918:	d9003117 	ldw	r4,196(sp)
8112391c:	203fb916 	blt	r4,zero,81123804 <__reset+0xfb103804>
81123920:	d8802d15 	stw	r2,180(sp)
81123924:	bc400007 	ldb	r17,0(r23)
81123928:	003f5406 	br	8112367c <__reset+0xfb10367c>
8112392c:	bc400007 	ldb	r17,0(r23)
81123930:	bac00044 	addi	r11,r23,1
81123934:	8a873926 	beq	r17,r10,8112561c <___svfprintf_internal_r+0x20f8>
81123938:	88bff404 	addi	r2,r17,-48
8112393c:	0009883a 	mov	r4,zero
81123940:	30868836 	bltu	r6,r2,81125364 <___svfprintf_internal_r+0x1e40>
81123944:	5c400007 	ldb	r17,0(r11)
81123948:	210002a4 	muli	r4,r4,10
8112394c:	5dc00044 	addi	r23,r11,1
81123950:	b817883a 	mov	r11,r23
81123954:	2089883a 	add	r4,r4,r2
81123958:	88bff404 	addi	r2,r17,-48
8112395c:	30bff92e 	bgeu	r6,r2,81123944 <__reset+0xfb103944>
81123960:	2005d716 	blt	r4,zero,811250c0 <___svfprintf_internal_r+0x1b9c>
81123964:	d9002915 	stw	r4,164(sp)
81123968:	003f4506 	br	81123680 <__reset+0xfb103680>
8112396c:	b809883a 	mov	r4,r23
81123970:	d8003115 	stw	zero,196(sp)
81123974:	88bff404 	addi	r2,r17,-48
81123978:	0017883a 	mov	r11,zero
8112397c:	24400007 	ldb	r17,0(r4)
81123980:	5ac002a4 	muli	r11,r11,10
81123984:	bdc00044 	addi	r23,r23,1
81123988:	b809883a 	mov	r4,r23
8112398c:	12d7883a 	add	r11,r2,r11
81123990:	88bff404 	addi	r2,r17,-48
81123994:	30bff92e 	bgeu	r6,r2,8112397c <__reset+0xfb10397c>
81123998:	dac03115 	stw	r11,196(sp)
8112399c:	003f3806 	br	81123680 <__reset+0xfb103680>
811239a0:	94802014 	ori	r18,r18,128
811239a4:	bc400007 	ldb	r17,0(r23)
811239a8:	003f3406 	br	8112367c <__reset+0xfb10367c>
811239ac:	18c03fcc 	andi	r3,r3,255
811239b0:	1807471e 	bne	r3,zero,811256d0 <___svfprintf_internal_r+0x21ac>
811239b4:	9080020c 	andi	r2,r18,8
811239b8:	10047d26 	beq	r2,zero,81124bb0 <___svfprintf_internal_r+0x168c>
811239bc:	d8c02d17 	ldw	r3,180(sp)
811239c0:	d9002d17 	ldw	r4,180(sp)
811239c4:	d9402d17 	ldw	r5,180(sp)
811239c8:	18c00017 	ldw	r3,0(r3)
811239cc:	21000117 	ldw	r4,4(r4)
811239d0:	29400204 	addi	r5,r5,8
811239d4:	d8c03615 	stw	r3,216(sp)
811239d8:	d9003715 	stw	r4,220(sp)
811239dc:	d9402d15 	stw	r5,180(sp)
811239e0:	d9003617 	ldw	r4,216(sp)
811239e4:	d9403717 	ldw	r5,220(sp)
811239e8:	da003e15 	stw	r8,248(sp)
811239ec:	04000044 	movi	r16,1
811239f0:	112df580 	call	8112df58 <__fpclassifyd>
811239f4:	da003e17 	ldw	r8,248(sp)
811239f8:	14044b1e 	bne	r2,r16,81124b28 <___svfprintf_internal_r+0x1604>
811239fc:	d9003617 	ldw	r4,216(sp)
81123a00:	d9403717 	ldw	r5,220(sp)
81123a04:	000d883a 	mov	r6,zero
81123a08:	000f883a 	mov	r7,zero
81123a0c:	1135e600 	call	81135e60 <__ledf2>
81123a10:	da003e17 	ldw	r8,248(sp)
81123a14:	1005f316 	blt	r2,zero,811251e4 <___svfprintf_internal_r+0x1cc0>
81123a18:	df002783 	ldbu	fp,158(sp)
81123a1c:	008011c4 	movi	r2,71
81123a20:	1445590e 	bge	r2,r17,81124f88 <___svfprintf_internal_r+0x1a64>
81123a24:	04204574 	movhi	r16,33045
81123a28:	84021604 	addi	r16,r16,2136
81123a2c:	00c000c4 	movi	r3,3
81123a30:	00bfdfc4 	movi	r2,-129
81123a34:	d8c02a15 	stw	r3,168(sp)
81123a38:	90a4703a 	and	r18,r18,r2
81123a3c:	d8c02e15 	stw	r3,184(sp)
81123a40:	d8002915 	stw	zero,164(sp)
81123a44:	d8003215 	stw	zero,200(sp)
81123a48:	00006606 	br	81123be4 <___svfprintf_internal_r+0x6c0>
81123a4c:	94800214 	ori	r18,r18,8
81123a50:	bc400007 	ldb	r17,0(r23)
81123a54:	003f0906 	br	8112367c <__reset+0xfb10367c>
81123a58:	18c03fcc 	andi	r3,r3,255
81123a5c:	1807181e 	bne	r3,zero,811256c0 <___svfprintf_internal_r+0x219c>
81123a60:	94800414 	ori	r18,r18,16
81123a64:	9080080c 	andi	r2,r18,32
81123a68:	10039626 	beq	r2,zero,811248c4 <___svfprintf_internal_r+0x13a0>
81123a6c:	d9402d17 	ldw	r5,180(sp)
81123a70:	28800117 	ldw	r2,4(r5)
81123a74:	2d000017 	ldw	r20,0(r5)
81123a78:	29400204 	addi	r5,r5,8
81123a7c:	d9402d15 	stw	r5,180(sp)
81123a80:	102d883a 	mov	r22,r2
81123a84:	10039816 	blt	r2,zero,811248e8 <___svfprintf_internal_r+0x13c4>
81123a88:	d9402917 	ldw	r5,164(sp)
81123a8c:	df002783 	ldbu	fp,158(sp)
81123a90:	2803ab16 	blt	r5,zero,81124940 <___svfprintf_internal_r+0x141c>
81123a94:	00ffdfc4 	movi	r3,-129
81123a98:	a584b03a 	or	r2,r20,r22
81123a9c:	90e4703a 	and	r18,r18,r3
81123aa0:	10014a26 	beq	r2,zero,81123fcc <___svfprintf_internal_r+0xaa8>
81123aa4:	b0034b26 	beq	r22,zero,811247d4 <___svfprintf_internal_r+0x12b0>
81123aa8:	dc402a15 	stw	r17,168(sp)
81123aac:	dc001e04 	addi	r16,sp,120
81123ab0:	b023883a 	mov	r17,r22
81123ab4:	402d883a 	mov	r22,r8
81123ab8:	a009883a 	mov	r4,r20
81123abc:	880b883a 	mov	r5,r17
81123ac0:	01800284 	movi	r6,10
81123ac4:	000f883a 	mov	r7,zero
81123ac8:	11343440 	call	81134344 <__umoddi3>
81123acc:	10800c04 	addi	r2,r2,48
81123ad0:	843fffc4 	addi	r16,r16,-1
81123ad4:	a009883a 	mov	r4,r20
81123ad8:	880b883a 	mov	r5,r17
81123adc:	80800005 	stb	r2,0(r16)
81123ae0:	01800284 	movi	r6,10
81123ae4:	000f883a 	mov	r7,zero
81123ae8:	1133dc40 	call	81133dc4 <__udivdi3>
81123aec:	1029883a 	mov	r20,r2
81123af0:	10c4b03a 	or	r2,r2,r3
81123af4:	1823883a 	mov	r17,r3
81123af8:	103fef1e 	bne	r2,zero,81123ab8 <__reset+0xfb103ab8>
81123afc:	d8c02817 	ldw	r3,160(sp)
81123b00:	dc402a17 	ldw	r17,168(sp)
81123b04:	b011883a 	mov	r8,r22
81123b08:	1c07c83a 	sub	r3,r3,r16
81123b0c:	d8c02e15 	stw	r3,184(sp)
81123b10:	00002e06 	br	81123bcc <___svfprintf_internal_r+0x6a8>
81123b14:	18c03fcc 	andi	r3,r3,255
81123b18:	1806e71e 	bne	r3,zero,811256b8 <___svfprintf_internal_r+0x2194>
81123b1c:	94800414 	ori	r18,r18,16
81123b20:	9080080c 	andi	r2,r18,32
81123b24:	1002d426 	beq	r2,zero,81124678 <___svfprintf_internal_r+0x1154>
81123b28:	d9402d17 	ldw	r5,180(sp)
81123b2c:	d8c02917 	ldw	r3,164(sp)
81123b30:	d8002785 	stb	zero,158(sp)
81123b34:	28800204 	addi	r2,r5,8
81123b38:	2d000017 	ldw	r20,0(r5)
81123b3c:	2d800117 	ldw	r22,4(r5)
81123b40:	18041516 	blt	r3,zero,81124b98 <___svfprintf_internal_r+0x1674>
81123b44:	013fdfc4 	movi	r4,-129
81123b48:	a586b03a 	or	r3,r20,r22
81123b4c:	d8802d15 	stw	r2,180(sp)
81123b50:	9124703a 	and	r18,r18,r4
81123b54:	1802d51e 	bne	r3,zero,811246ac <___svfprintf_internal_r+0x1188>
81123b58:	d9402917 	ldw	r5,164(sp)
81123b5c:	0039883a 	mov	fp,zero
81123b60:	2806be26 	beq	r5,zero,8112565c <___svfprintf_internal_r+0x2138>
81123b64:	0029883a 	mov	r20,zero
81123b68:	002d883a 	mov	r22,zero
81123b6c:	dc001e04 	addi	r16,sp,120
81123b70:	a006d0fa 	srli	r3,r20,3
81123b74:	b008977a 	slli	r4,r22,29
81123b78:	b02cd0fa 	srli	r22,r22,3
81123b7c:	a50001cc 	andi	r20,r20,7
81123b80:	a0800c04 	addi	r2,r20,48
81123b84:	843fffc4 	addi	r16,r16,-1
81123b88:	20e8b03a 	or	r20,r4,r3
81123b8c:	80800005 	stb	r2,0(r16)
81123b90:	a586b03a 	or	r3,r20,r22
81123b94:	183ff61e 	bne	r3,zero,81123b70 <__reset+0xfb103b70>
81123b98:	90c0004c 	andi	r3,r18,1
81123b9c:	18013926 	beq	r3,zero,81124084 <___svfprintf_internal_r+0xb60>
81123ba0:	10803fcc 	andi	r2,r2,255
81123ba4:	1080201c 	xori	r2,r2,128
81123ba8:	10bfe004 	addi	r2,r2,-128
81123bac:	00c00c04 	movi	r3,48
81123bb0:	10c13426 	beq	r2,r3,81124084 <___svfprintf_internal_r+0xb60>
81123bb4:	80ffffc5 	stb	r3,-1(r16)
81123bb8:	d8c02817 	ldw	r3,160(sp)
81123bbc:	80bfffc4 	addi	r2,r16,-1
81123bc0:	1021883a 	mov	r16,r2
81123bc4:	1887c83a 	sub	r3,r3,r2
81123bc8:	d8c02e15 	stw	r3,184(sp)
81123bcc:	d8802e17 	ldw	r2,184(sp)
81123bd0:	d9002917 	ldw	r4,164(sp)
81123bd4:	1100010e 	bge	r2,r4,81123bdc <___svfprintf_internal_r+0x6b8>
81123bd8:	2005883a 	mov	r2,r4
81123bdc:	d8802a15 	stw	r2,168(sp)
81123be0:	d8003215 	stw	zero,200(sp)
81123be4:	e7003fcc 	andi	fp,fp,255
81123be8:	e700201c 	xori	fp,fp,128
81123bec:	e73fe004 	addi	fp,fp,-128
81123bf0:	e0000326 	beq	fp,zero,81123c00 <___svfprintf_internal_r+0x6dc>
81123bf4:	d8c02a17 	ldw	r3,168(sp)
81123bf8:	18c00044 	addi	r3,r3,1
81123bfc:	d8c02a15 	stw	r3,168(sp)
81123c00:	90c0008c 	andi	r3,r18,2
81123c04:	d8c02b15 	stw	r3,172(sp)
81123c08:	18000326 	beq	r3,zero,81123c18 <___svfprintf_internal_r+0x6f4>
81123c0c:	d8c02a17 	ldw	r3,168(sp)
81123c10:	18c00084 	addi	r3,r3,2
81123c14:	d8c02a15 	stw	r3,168(sp)
81123c18:	90c0210c 	andi	r3,r18,132
81123c1c:	d8c03015 	stw	r3,192(sp)
81123c20:	1801a11e 	bne	r3,zero,811242a8 <___svfprintf_internal_r+0xd84>
81123c24:	d9003117 	ldw	r4,196(sp)
81123c28:	d8c02a17 	ldw	r3,168(sp)
81123c2c:	20e9c83a 	sub	r20,r4,r3
81123c30:	05019d0e 	bge	zero,r20,811242a8 <___svfprintf_internal_r+0xd84>
81123c34:	02400404 	movi	r9,16
81123c38:	d8c02017 	ldw	r3,128(sp)
81123c3c:	d8801f17 	ldw	r2,124(sp)
81123c40:	4d051b0e 	bge	r9,r20,811250b0 <___svfprintf_internal_r+0x1b8c>
81123c44:	01604574 	movhi	r5,33045
81123c48:	29422984 	addi	r5,r5,2214
81123c4c:	dc403c15 	stw	r17,240(sp)
81123c50:	d9403515 	stw	r5,212(sp)
81123c54:	a023883a 	mov	r17,r20
81123c58:	482d883a 	mov	r22,r9
81123c5c:	9029883a 	mov	r20,r18
81123c60:	070001c4 	movi	fp,7
81123c64:	8025883a 	mov	r18,r16
81123c68:	dc002c17 	ldw	r16,176(sp)
81123c6c:	00000306 	br	81123c7c <___svfprintf_internal_r+0x758>
81123c70:	8c7ffc04 	addi	r17,r17,-16
81123c74:	42000204 	addi	r8,r8,8
81123c78:	b440130e 	bge	r22,r17,81123cc8 <___svfprintf_internal_r+0x7a4>
81123c7c:	01204574 	movhi	r4,33045
81123c80:	18c00404 	addi	r3,r3,16
81123c84:	10800044 	addi	r2,r2,1
81123c88:	21022984 	addi	r4,r4,2214
81123c8c:	41000015 	stw	r4,0(r8)
81123c90:	45800115 	stw	r22,4(r8)
81123c94:	d8c02015 	stw	r3,128(sp)
81123c98:	d8801f15 	stw	r2,124(sp)
81123c9c:	e0bff40e 	bge	fp,r2,81123c70 <__reset+0xfb103c70>
81123ca0:	d9801e04 	addi	r6,sp,120
81123ca4:	800b883a 	mov	r5,r16
81123ca8:	9809883a 	mov	r4,r19
81123cac:	112fe5c0 	call	8112fe5c <__ssprint_r>
81123cb0:	103f031e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81123cb4:	8c7ffc04 	addi	r17,r17,-16
81123cb8:	d8c02017 	ldw	r3,128(sp)
81123cbc:	d8801f17 	ldw	r2,124(sp)
81123cc0:	da000404 	addi	r8,sp,16
81123cc4:	b47fed16 	blt	r22,r17,81123c7c <__reset+0xfb103c7c>
81123cc8:	9021883a 	mov	r16,r18
81123ccc:	a025883a 	mov	r18,r20
81123cd0:	8829883a 	mov	r20,r17
81123cd4:	dc403c17 	ldw	r17,240(sp)
81123cd8:	d9403517 	ldw	r5,212(sp)
81123cdc:	a0c7883a 	add	r3,r20,r3
81123ce0:	10800044 	addi	r2,r2,1
81123ce4:	41400015 	stw	r5,0(r8)
81123ce8:	45000115 	stw	r20,4(r8)
81123cec:	d8c02015 	stw	r3,128(sp)
81123cf0:	d8801f15 	stw	r2,124(sp)
81123cf4:	010001c4 	movi	r4,7
81123cf8:	20829f16 	blt	r4,r2,81124778 <___svfprintf_internal_r+0x1254>
81123cfc:	df002787 	ldb	fp,158(sp)
81123d00:	42000204 	addi	r8,r8,8
81123d04:	e0000c26 	beq	fp,zero,81123d38 <___svfprintf_internal_r+0x814>
81123d08:	d8801f17 	ldw	r2,124(sp)
81123d0c:	d9002784 	addi	r4,sp,158
81123d10:	18c00044 	addi	r3,r3,1
81123d14:	10800044 	addi	r2,r2,1
81123d18:	41000015 	stw	r4,0(r8)
81123d1c:	01000044 	movi	r4,1
81123d20:	41000115 	stw	r4,4(r8)
81123d24:	d8c02015 	stw	r3,128(sp)
81123d28:	d8801f15 	stw	r2,124(sp)
81123d2c:	010001c4 	movi	r4,7
81123d30:	20823816 	blt	r4,r2,81124614 <___svfprintf_internal_r+0x10f0>
81123d34:	42000204 	addi	r8,r8,8
81123d38:	d8802b17 	ldw	r2,172(sp)
81123d3c:	10000c26 	beq	r2,zero,81123d70 <___svfprintf_internal_r+0x84c>
81123d40:	d8801f17 	ldw	r2,124(sp)
81123d44:	d9002704 	addi	r4,sp,156
81123d48:	18c00084 	addi	r3,r3,2
81123d4c:	10800044 	addi	r2,r2,1
81123d50:	41000015 	stw	r4,0(r8)
81123d54:	01000084 	movi	r4,2
81123d58:	41000115 	stw	r4,4(r8)
81123d5c:	d8c02015 	stw	r3,128(sp)
81123d60:	d8801f15 	stw	r2,124(sp)
81123d64:	010001c4 	movi	r4,7
81123d68:	20823216 	blt	r4,r2,81124634 <___svfprintf_internal_r+0x1110>
81123d6c:	42000204 	addi	r8,r8,8
81123d70:	d9003017 	ldw	r4,192(sp)
81123d74:	00802004 	movi	r2,128
81123d78:	20819726 	beq	r4,r2,811243d8 <___svfprintf_internal_r+0xeb4>
81123d7c:	d9402917 	ldw	r5,164(sp)
81123d80:	d8802e17 	ldw	r2,184(sp)
81123d84:	28adc83a 	sub	r22,r5,r2
81123d88:	05802f0e 	bge	zero,r22,81123e48 <___svfprintf_internal_r+0x924>
81123d8c:	07000404 	movi	fp,16
81123d90:	d8801f17 	ldw	r2,124(sp)
81123d94:	e583c00e 	bge	fp,r22,81124c98 <___svfprintf_internal_r+0x1774>
81123d98:	01604574 	movhi	r5,33045
81123d9c:	29422584 	addi	r5,r5,2198
81123da0:	dc402915 	stw	r17,164(sp)
81123da4:	d9402b15 	stw	r5,172(sp)
81123da8:	b023883a 	mov	r17,r22
81123dac:	050001c4 	movi	r20,7
81123db0:	902d883a 	mov	r22,r18
81123db4:	8025883a 	mov	r18,r16
81123db8:	dc002c17 	ldw	r16,176(sp)
81123dbc:	00000306 	br	81123dcc <___svfprintf_internal_r+0x8a8>
81123dc0:	8c7ffc04 	addi	r17,r17,-16
81123dc4:	42000204 	addi	r8,r8,8
81123dc8:	e440110e 	bge	fp,r17,81123e10 <___svfprintf_internal_r+0x8ec>
81123dcc:	18c00404 	addi	r3,r3,16
81123dd0:	10800044 	addi	r2,r2,1
81123dd4:	45400015 	stw	r21,0(r8)
81123dd8:	47000115 	stw	fp,4(r8)
81123ddc:	d8c02015 	stw	r3,128(sp)
81123de0:	d8801f15 	stw	r2,124(sp)
81123de4:	a0bff60e 	bge	r20,r2,81123dc0 <__reset+0xfb103dc0>
81123de8:	d9801e04 	addi	r6,sp,120
81123dec:	800b883a 	mov	r5,r16
81123df0:	9809883a 	mov	r4,r19
81123df4:	112fe5c0 	call	8112fe5c <__ssprint_r>
81123df8:	103eb11e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81123dfc:	8c7ffc04 	addi	r17,r17,-16
81123e00:	d8c02017 	ldw	r3,128(sp)
81123e04:	d8801f17 	ldw	r2,124(sp)
81123e08:	da000404 	addi	r8,sp,16
81123e0c:	e47fef16 	blt	fp,r17,81123dcc <__reset+0xfb103dcc>
81123e10:	9021883a 	mov	r16,r18
81123e14:	b025883a 	mov	r18,r22
81123e18:	882d883a 	mov	r22,r17
81123e1c:	dc402917 	ldw	r17,164(sp)
81123e20:	d9002b17 	ldw	r4,172(sp)
81123e24:	1d87883a 	add	r3,r3,r22
81123e28:	10800044 	addi	r2,r2,1
81123e2c:	41000015 	stw	r4,0(r8)
81123e30:	45800115 	stw	r22,4(r8)
81123e34:	d8c02015 	stw	r3,128(sp)
81123e38:	d8801f15 	stw	r2,124(sp)
81123e3c:	010001c4 	movi	r4,7
81123e40:	2081ec16 	blt	r4,r2,811245f4 <___svfprintf_internal_r+0x10d0>
81123e44:	42000204 	addi	r8,r8,8
81123e48:	9080400c 	andi	r2,r18,256
81123e4c:	1001181e 	bne	r2,zero,811242b0 <___svfprintf_internal_r+0xd8c>
81123e50:	d9402e17 	ldw	r5,184(sp)
81123e54:	d8801f17 	ldw	r2,124(sp)
81123e58:	44000015 	stw	r16,0(r8)
81123e5c:	1947883a 	add	r3,r3,r5
81123e60:	10800044 	addi	r2,r2,1
81123e64:	41400115 	stw	r5,4(r8)
81123e68:	d8c02015 	stw	r3,128(sp)
81123e6c:	d8801f15 	stw	r2,124(sp)
81123e70:	010001c4 	movi	r4,7
81123e74:	2081d116 	blt	r4,r2,811245bc <___svfprintf_internal_r+0x1098>
81123e78:	42000204 	addi	r8,r8,8
81123e7c:	9480010c 	andi	r18,r18,4
81123e80:	90003226 	beq	r18,zero,81123f4c <___svfprintf_internal_r+0xa28>
81123e84:	d9403117 	ldw	r5,196(sp)
81123e88:	d8802a17 	ldw	r2,168(sp)
81123e8c:	28a1c83a 	sub	r16,r5,r2
81123e90:	04002e0e 	bge	zero,r16,81123f4c <___svfprintf_internal_r+0xa28>
81123e94:	04400404 	movi	r17,16
81123e98:	d8801f17 	ldw	r2,124(sp)
81123e9c:	8c04b90e 	bge	r17,r16,81125184 <___svfprintf_internal_r+0x1c60>
81123ea0:	01604574 	movhi	r5,33045
81123ea4:	29422984 	addi	r5,r5,2214
81123ea8:	d9403515 	stw	r5,212(sp)
81123eac:	048001c4 	movi	r18,7
81123eb0:	dd002c17 	ldw	r20,176(sp)
81123eb4:	00000306 	br	81123ec4 <___svfprintf_internal_r+0x9a0>
81123eb8:	843ffc04 	addi	r16,r16,-16
81123ebc:	42000204 	addi	r8,r8,8
81123ec0:	8c00130e 	bge	r17,r16,81123f10 <___svfprintf_internal_r+0x9ec>
81123ec4:	01204574 	movhi	r4,33045
81123ec8:	18c00404 	addi	r3,r3,16
81123ecc:	10800044 	addi	r2,r2,1
81123ed0:	21022984 	addi	r4,r4,2214
81123ed4:	41000015 	stw	r4,0(r8)
81123ed8:	44400115 	stw	r17,4(r8)
81123edc:	d8c02015 	stw	r3,128(sp)
81123ee0:	d8801f15 	stw	r2,124(sp)
81123ee4:	90bff40e 	bge	r18,r2,81123eb8 <__reset+0xfb103eb8>
81123ee8:	d9801e04 	addi	r6,sp,120
81123eec:	a00b883a 	mov	r5,r20
81123ef0:	9809883a 	mov	r4,r19
81123ef4:	112fe5c0 	call	8112fe5c <__ssprint_r>
81123ef8:	103e711e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81123efc:	843ffc04 	addi	r16,r16,-16
81123f00:	d8c02017 	ldw	r3,128(sp)
81123f04:	d8801f17 	ldw	r2,124(sp)
81123f08:	da000404 	addi	r8,sp,16
81123f0c:	8c3fed16 	blt	r17,r16,81123ec4 <__reset+0xfb103ec4>
81123f10:	d9403517 	ldw	r5,212(sp)
81123f14:	1c07883a 	add	r3,r3,r16
81123f18:	10800044 	addi	r2,r2,1
81123f1c:	41400015 	stw	r5,0(r8)
81123f20:	44000115 	stw	r16,4(r8)
81123f24:	d8c02015 	stw	r3,128(sp)
81123f28:	d8801f15 	stw	r2,124(sp)
81123f2c:	010001c4 	movi	r4,7
81123f30:	2080060e 	bge	r4,r2,81123f4c <___svfprintf_internal_r+0xa28>
81123f34:	d9402c17 	ldw	r5,176(sp)
81123f38:	d9801e04 	addi	r6,sp,120
81123f3c:	9809883a 	mov	r4,r19
81123f40:	112fe5c0 	call	8112fe5c <__ssprint_r>
81123f44:	103e5e1e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81123f48:	d8c02017 	ldw	r3,128(sp)
81123f4c:	d8803117 	ldw	r2,196(sp)
81123f50:	d9002a17 	ldw	r4,168(sp)
81123f54:	1100010e 	bge	r2,r4,81123f5c <___svfprintf_internal_r+0xa38>
81123f58:	2005883a 	mov	r2,r4
81123f5c:	d9402f17 	ldw	r5,188(sp)
81123f60:	288b883a 	add	r5,r5,r2
81123f64:	d9402f15 	stw	r5,188(sp)
81123f68:	18019c1e 	bne	r3,zero,811245dc <___svfprintf_internal_r+0x10b8>
81123f6c:	b8800007 	ldb	r2,0(r23)
81123f70:	d8001f15 	stw	zero,124(sp)
81123f74:	da000404 	addi	r8,sp,16
81123f78:	103d991e 	bne	r2,zero,811235e0 <__reset+0xfb1035e0>
81123f7c:	b821883a 	mov	r16,r23
81123f80:	003daf06 	br	81123640 <__reset+0xfb103640>
81123f84:	18c03fcc 	andi	r3,r3,255
81123f88:	1805c71e 	bne	r3,zero,811256a8 <___svfprintf_internal_r+0x2184>
81123f8c:	94800414 	ori	r18,r18,16
81123f90:	9080080c 	andi	r2,r18,32
81123f94:	10020126 	beq	r2,zero,8112479c <___svfprintf_internal_r+0x1278>
81123f98:	d8802d17 	ldw	r2,180(sp)
81123f9c:	d9002917 	ldw	r4,164(sp)
81123fa0:	d8002785 	stb	zero,158(sp)
81123fa4:	10c00204 	addi	r3,r2,8
81123fa8:	15000017 	ldw	r20,0(r2)
81123fac:	15800117 	ldw	r22,4(r2)
81123fb0:	20038e16 	blt	r4,zero,81124dec <___svfprintf_internal_r+0x18c8>
81123fb4:	013fdfc4 	movi	r4,-129
81123fb8:	a584b03a 	or	r2,r20,r22
81123fbc:	d8c02d15 	stw	r3,180(sp)
81123fc0:	9124703a 	and	r18,r18,r4
81123fc4:	0039883a 	mov	fp,zero
81123fc8:	103eb61e 	bne	r2,zero,81123aa4 <__reset+0xfb103aa4>
81123fcc:	d8802917 	ldw	r2,164(sp)
81123fd0:	1002c81e 	bne	r2,zero,81124af4 <___svfprintf_internal_r+0x15d0>
81123fd4:	d8002915 	stw	zero,164(sp)
81123fd8:	d8002e15 	stw	zero,184(sp)
81123fdc:	dc001e04 	addi	r16,sp,120
81123fe0:	003efa06 	br	81123bcc <__reset+0xfb103bcc>
81123fe4:	18c03fcc 	andi	r3,r3,255
81123fe8:	1805ad1e 	bne	r3,zero,811256a0 <___svfprintf_internal_r+0x217c>
81123fec:	01604574 	movhi	r5,33045
81123ff0:	29421904 	addi	r5,r5,2148
81123ff4:	d9403a15 	stw	r5,232(sp)
81123ff8:	9080080c 	andi	r2,r18,32
81123ffc:	10006126 	beq	r2,zero,81124184 <___svfprintf_internal_r+0xc60>
81124000:	d8802d17 	ldw	r2,180(sp)
81124004:	15000017 	ldw	r20,0(r2)
81124008:	15800117 	ldw	r22,4(r2)
8112400c:	10800204 	addi	r2,r2,8
81124010:	d8802d15 	stw	r2,180(sp)
81124014:	9080004c 	andi	r2,r18,1
81124018:	10018e26 	beq	r2,zero,81124654 <___svfprintf_internal_r+0x1130>
8112401c:	a584b03a 	or	r2,r20,r22
81124020:	10030926 	beq	r2,zero,81124c48 <___svfprintf_internal_r+0x1724>
81124024:	d8c02917 	ldw	r3,164(sp)
81124028:	00800c04 	movi	r2,48
8112402c:	d8802705 	stb	r2,156(sp)
81124030:	dc402745 	stb	r17,157(sp)
81124034:	d8002785 	stb	zero,158(sp)
81124038:	90800094 	ori	r2,r18,2
8112403c:	18048716 	blt	r3,zero,8112525c <___svfprintf_internal_r+0x1d38>
81124040:	00bfdfc4 	movi	r2,-129
81124044:	90a4703a 	and	r18,r18,r2
81124048:	94800094 	ori	r18,r18,2
8112404c:	0039883a 	mov	fp,zero
81124050:	d9003a17 	ldw	r4,232(sp)
81124054:	dc001e04 	addi	r16,sp,120
81124058:	a08003cc 	andi	r2,r20,15
8112405c:	b006973a 	slli	r3,r22,28
81124060:	2085883a 	add	r2,r4,r2
81124064:	a028d13a 	srli	r20,r20,4
81124068:	10800003 	ldbu	r2,0(r2)
8112406c:	b02cd13a 	srli	r22,r22,4
81124070:	843fffc4 	addi	r16,r16,-1
81124074:	1d28b03a 	or	r20,r3,r20
81124078:	80800005 	stb	r2,0(r16)
8112407c:	a584b03a 	or	r2,r20,r22
81124080:	103ff51e 	bne	r2,zero,81124058 <__reset+0xfb104058>
81124084:	d8c02817 	ldw	r3,160(sp)
81124088:	1c07c83a 	sub	r3,r3,r16
8112408c:	d8c02e15 	stw	r3,184(sp)
81124090:	003ece06 	br	81123bcc <__reset+0xfb103bcc>
81124094:	d8c02d17 	ldw	r3,180(sp)
81124098:	d9002d17 	ldw	r4,180(sp)
8112409c:	d8002785 	stb	zero,158(sp)
811240a0:	18800017 	ldw	r2,0(r3)
811240a4:	21000104 	addi	r4,r4,4
811240a8:	00c00044 	movi	r3,1
811240ac:	d8c02a15 	stw	r3,168(sp)
811240b0:	d8801405 	stb	r2,80(sp)
811240b4:	d9002d15 	stw	r4,180(sp)
811240b8:	d8c02e15 	stw	r3,184(sp)
811240bc:	d8002915 	stw	zero,164(sp)
811240c0:	d8003215 	stw	zero,200(sp)
811240c4:	dc001404 	addi	r16,sp,80
811240c8:	0039883a 	mov	fp,zero
811240cc:	003ecc06 	br	81123c00 <__reset+0xfb103c00>
811240d0:	18c03fcc 	andi	r3,r3,255
811240d4:	183e9226 	beq	r3,zero,81123b20 <__reset+0xfb103b20>
811240d8:	d9c02785 	stb	r7,158(sp)
811240dc:	003e9006 	br	81123b20 <__reset+0xfb103b20>
811240e0:	00c00044 	movi	r3,1
811240e4:	01c00ac4 	movi	r7,43
811240e8:	bc400007 	ldb	r17,0(r23)
811240ec:	003d6306 	br	8112367c <__reset+0xfb10367c>
811240f0:	94800814 	ori	r18,r18,32
811240f4:	bc400007 	ldb	r17,0(r23)
811240f8:	003d6006 	br	8112367c <__reset+0xfb10367c>
811240fc:	d8c02d17 	ldw	r3,180(sp)
81124100:	d8002785 	stb	zero,158(sp)
81124104:	1c000017 	ldw	r16,0(r3)
81124108:	1d000104 	addi	r20,r3,4
8112410c:	80040f26 	beq	r16,zero,8112514c <___svfprintf_internal_r+0x1c28>
81124110:	d9002917 	ldw	r4,164(sp)
81124114:	2003dc16 	blt	r4,zero,81125088 <___svfprintf_internal_r+0x1b64>
81124118:	200d883a 	mov	r6,r4
8112411c:	000b883a 	mov	r5,zero
81124120:	8009883a 	mov	r4,r16
81124124:	da003e15 	stw	r8,248(sp)
81124128:	112c6e80 	call	8112c6e8 <memchr>
8112412c:	da003e17 	ldw	r8,248(sp)
81124130:	10045826 	beq	r2,zero,81125294 <___svfprintf_internal_r+0x1d70>
81124134:	1405c83a 	sub	r2,r2,r16
81124138:	d8802e15 	stw	r2,184(sp)
8112413c:	1003d816 	blt	r2,zero,811250a0 <___svfprintf_internal_r+0x1b7c>
81124140:	df002783 	ldbu	fp,158(sp)
81124144:	d8802a15 	stw	r2,168(sp)
81124148:	dd002d15 	stw	r20,180(sp)
8112414c:	d8002915 	stw	zero,164(sp)
81124150:	d8003215 	stw	zero,200(sp)
81124154:	003ea306 	br	81123be4 <__reset+0xfb103be4>
81124158:	18c03fcc 	andi	r3,r3,255
8112415c:	183f8c26 	beq	r3,zero,81123f90 <__reset+0xfb103f90>
81124160:	d9c02785 	stb	r7,158(sp)
81124164:	003f8a06 	br	81123f90 <__reset+0xfb103f90>
81124168:	18c03fcc 	andi	r3,r3,255
8112416c:	1805631e 	bne	r3,zero,811256fc <___svfprintf_internal_r+0x21d8>
81124170:	01604574 	movhi	r5,33045
81124174:	29421e04 	addi	r5,r5,2168
81124178:	d9403a15 	stw	r5,232(sp)
8112417c:	9080080c 	andi	r2,r18,32
81124180:	103f9f1e 	bne	r2,zero,81124000 <__reset+0xfb104000>
81124184:	9080040c 	andi	r2,r18,16
81124188:	10029c26 	beq	r2,zero,81124bfc <___svfprintf_internal_r+0x16d8>
8112418c:	d8c02d17 	ldw	r3,180(sp)
81124190:	002d883a 	mov	r22,zero
81124194:	1d000017 	ldw	r20,0(r3)
81124198:	18c00104 	addi	r3,r3,4
8112419c:	d8c02d15 	stw	r3,180(sp)
811241a0:	003f9c06 	br	81124014 <__reset+0xfb104014>
811241a4:	94800054 	ori	r18,r18,1
811241a8:	bc400007 	ldb	r17,0(r23)
811241ac:	003d3306 	br	8112367c <__reset+0xfb10367c>
811241b0:	38803fcc 	andi	r2,r7,255
811241b4:	1080201c 	xori	r2,r2,128
811241b8:	10bfe004 	addi	r2,r2,-128
811241bc:	1002971e 	bne	r2,zero,81124c1c <___svfprintf_internal_r+0x16f8>
811241c0:	00c00044 	movi	r3,1
811241c4:	01c00804 	movi	r7,32
811241c8:	bc400007 	ldb	r17,0(r23)
811241cc:	003d2b06 	br	8112367c <__reset+0xfb10367c>
811241d0:	18c03fcc 	andi	r3,r3,255
811241d4:	183e2326 	beq	r3,zero,81123a64 <__reset+0xfb103a64>
811241d8:	d9c02785 	stb	r7,158(sp)
811241dc:	003e2106 	br	81123a64 <__reset+0xfb103a64>
811241e0:	bc400007 	ldb	r17,0(r23)
811241e4:	8a430426 	beq	r17,r9,81124df8 <___svfprintf_internal_r+0x18d4>
811241e8:	94800414 	ori	r18,r18,16
811241ec:	003d2306 	br	8112367c <__reset+0xfb10367c>
811241f0:	18c03fcc 	andi	r3,r3,255
811241f4:	18053f1e 	bne	r3,zero,811256f4 <___svfprintf_internal_r+0x21d0>
811241f8:	9080080c 	andi	r2,r18,32
811241fc:	10028926 	beq	r2,zero,81124c24 <___svfprintf_internal_r+0x1700>
81124200:	d9402d17 	ldw	r5,180(sp)
81124204:	d9002f17 	ldw	r4,188(sp)
81124208:	28800017 	ldw	r2,0(r5)
8112420c:	2007d7fa 	srai	r3,r4,31
81124210:	29400104 	addi	r5,r5,4
81124214:	d9402d15 	stw	r5,180(sp)
81124218:	11000015 	stw	r4,0(r2)
8112421c:	10c00115 	stw	r3,4(r2)
81124220:	003ced06 	br	811235d8 <__reset+0xfb1035d8>
81124224:	94801014 	ori	r18,r18,64
81124228:	bc400007 	ldb	r17,0(r23)
8112422c:	003d1306 	br	8112367c <__reset+0xfb10367c>
81124230:	01204574 	movhi	r4,33045
81124234:	21021e04 	addi	r4,r4,2168
81124238:	0039883a 	mov	fp,zero
8112423c:	d9003a15 	stw	r4,232(sp)
81124240:	04401e04 	movi	r17,120
81124244:	003f8206 	br	81124050 <__reset+0xfb104050>
81124248:	18c03fcc 	andi	r3,r3,255
8112424c:	1805221e 	bne	r3,zero,811256d8 <___svfprintf_internal_r+0x21b4>
81124250:	883d9526 	beq	r17,zero,811238a8 <__reset+0xfb1038a8>
81124254:	00c00044 	movi	r3,1
81124258:	d8c02a15 	stw	r3,168(sp)
8112425c:	dc401405 	stb	r17,80(sp)
81124260:	d8002785 	stb	zero,158(sp)
81124264:	003f9406 	br	811240b8 <__reset+0xfb1040b8>
81124268:	01204574 	movhi	r4,33045
8112426c:	21021e04 	addi	r4,r4,2168
81124270:	d9003a15 	stw	r4,232(sp)
81124274:	d8c02d15 	stw	r3,180(sp)
81124278:	1025883a 	mov	r18,r2
8112427c:	04401e04 	movi	r17,120
81124280:	a584b03a 	or	r2,r20,r22
81124284:	1000fa1e 	bne	r2,zero,81124670 <___svfprintf_internal_r+0x114c>
81124288:	0039883a 	mov	fp,zero
8112428c:	00800084 	movi	r2,2
81124290:	10803fcc 	andi	r2,r2,255
81124294:	00c00044 	movi	r3,1
81124298:	10c21626 	beq	r2,r3,81124af4 <___svfprintf_internal_r+0x15d0>
8112429c:	00c00084 	movi	r3,2
811242a0:	10fe301e 	bne	r2,r3,81123b64 <__reset+0xfb103b64>
811242a4:	003d7606 	br	81123880 <__reset+0xfb103880>
811242a8:	d8c02017 	ldw	r3,128(sp)
811242ac:	003e9506 	br	81123d04 <__reset+0xfb103d04>
811242b0:	00801944 	movi	r2,101
811242b4:	14407c0e 	bge	r2,r17,811244a8 <___svfprintf_internal_r+0xf84>
811242b8:	d9003617 	ldw	r4,216(sp)
811242bc:	d9403717 	ldw	r5,220(sp)
811242c0:	000d883a 	mov	r6,zero
811242c4:	000f883a 	mov	r7,zero
811242c8:	d8c03d15 	stw	r3,244(sp)
811242cc:	da003e15 	stw	r8,248(sp)
811242d0:	1135dd80 	call	81135dd8 <__eqdf2>
811242d4:	d8c03d17 	ldw	r3,244(sp)
811242d8:	da003e17 	ldw	r8,248(sp)
811242dc:	1000f51e 	bne	r2,zero,811246b4 <___svfprintf_internal_r+0x1190>
811242e0:	d8801f17 	ldw	r2,124(sp)
811242e4:	01204574 	movhi	r4,33045
811242e8:	21022504 	addi	r4,r4,2196
811242ec:	18c00044 	addi	r3,r3,1
811242f0:	10800044 	addi	r2,r2,1
811242f4:	41000015 	stw	r4,0(r8)
811242f8:	01000044 	movi	r4,1
811242fc:	41000115 	stw	r4,4(r8)
81124300:	d8c02015 	stw	r3,128(sp)
81124304:	d8801f15 	stw	r2,124(sp)
81124308:	010001c4 	movi	r4,7
8112430c:	20826616 	blt	r4,r2,81124ca8 <___svfprintf_internal_r+0x1784>
81124310:	42000204 	addi	r8,r8,8
81124314:	d8802617 	ldw	r2,152(sp)
81124318:	d9403317 	ldw	r5,204(sp)
8112431c:	11400216 	blt	r2,r5,81124328 <___svfprintf_internal_r+0xe04>
81124320:	9080004c 	andi	r2,r18,1
81124324:	103ed526 	beq	r2,zero,81123e7c <__reset+0xfb103e7c>
81124328:	d8803817 	ldw	r2,224(sp)
8112432c:	d9003417 	ldw	r4,208(sp)
81124330:	d9403817 	ldw	r5,224(sp)
81124334:	1887883a 	add	r3,r3,r2
81124338:	d8801f17 	ldw	r2,124(sp)
8112433c:	41000015 	stw	r4,0(r8)
81124340:	41400115 	stw	r5,4(r8)
81124344:	10800044 	addi	r2,r2,1
81124348:	d8c02015 	stw	r3,128(sp)
8112434c:	d8801f15 	stw	r2,124(sp)
81124350:	010001c4 	movi	r4,7
81124354:	2082af16 	blt	r4,r2,81124e14 <___svfprintf_internal_r+0x18f0>
81124358:	42000204 	addi	r8,r8,8
8112435c:	d8803317 	ldw	r2,204(sp)
81124360:	143fffc4 	addi	r16,r2,-1
81124364:	043ec50e 	bge	zero,r16,81123e7c <__reset+0xfb103e7c>
81124368:	04400404 	movi	r17,16
8112436c:	d8801f17 	ldw	r2,124(sp)
81124370:	8c00860e 	bge	r17,r16,8112458c <___svfprintf_internal_r+0x1068>
81124374:	01604574 	movhi	r5,33045
81124378:	29422584 	addi	r5,r5,2198
8112437c:	d9402b15 	stw	r5,172(sp)
81124380:	058001c4 	movi	r22,7
81124384:	dd002c17 	ldw	r20,176(sp)
81124388:	00000306 	br	81124398 <___svfprintf_internal_r+0xe74>
8112438c:	42000204 	addi	r8,r8,8
81124390:	843ffc04 	addi	r16,r16,-16
81124394:	8c00800e 	bge	r17,r16,81124598 <___svfprintf_internal_r+0x1074>
81124398:	18c00404 	addi	r3,r3,16
8112439c:	10800044 	addi	r2,r2,1
811243a0:	45400015 	stw	r21,0(r8)
811243a4:	44400115 	stw	r17,4(r8)
811243a8:	d8c02015 	stw	r3,128(sp)
811243ac:	d8801f15 	stw	r2,124(sp)
811243b0:	b0bff60e 	bge	r22,r2,8112438c <__reset+0xfb10438c>
811243b4:	d9801e04 	addi	r6,sp,120
811243b8:	a00b883a 	mov	r5,r20
811243bc:	9809883a 	mov	r4,r19
811243c0:	112fe5c0 	call	8112fe5c <__ssprint_r>
811243c4:	103d3e1e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
811243c8:	d8c02017 	ldw	r3,128(sp)
811243cc:	d8801f17 	ldw	r2,124(sp)
811243d0:	da000404 	addi	r8,sp,16
811243d4:	003fee06 	br	81124390 <__reset+0xfb104390>
811243d8:	d9403117 	ldw	r5,196(sp)
811243dc:	d8802a17 	ldw	r2,168(sp)
811243e0:	28adc83a 	sub	r22,r5,r2
811243e4:	05be650e 	bge	zero,r22,81123d7c <__reset+0xfb103d7c>
811243e8:	07000404 	movi	fp,16
811243ec:	d8801f17 	ldw	r2,124(sp)
811243f0:	e583a20e 	bge	fp,r22,8112527c <___svfprintf_internal_r+0x1d58>
811243f4:	01604574 	movhi	r5,33045
811243f8:	29422584 	addi	r5,r5,2198
811243fc:	dc403015 	stw	r17,192(sp)
81124400:	d9402b15 	stw	r5,172(sp)
81124404:	b023883a 	mov	r17,r22
81124408:	050001c4 	movi	r20,7
8112440c:	902d883a 	mov	r22,r18
81124410:	8025883a 	mov	r18,r16
81124414:	dc002c17 	ldw	r16,176(sp)
81124418:	00000306 	br	81124428 <___svfprintf_internal_r+0xf04>
8112441c:	8c7ffc04 	addi	r17,r17,-16
81124420:	42000204 	addi	r8,r8,8
81124424:	e440110e 	bge	fp,r17,8112446c <___svfprintf_internal_r+0xf48>
81124428:	18c00404 	addi	r3,r3,16
8112442c:	10800044 	addi	r2,r2,1
81124430:	45400015 	stw	r21,0(r8)
81124434:	47000115 	stw	fp,4(r8)
81124438:	d8c02015 	stw	r3,128(sp)
8112443c:	d8801f15 	stw	r2,124(sp)
81124440:	a0bff60e 	bge	r20,r2,8112441c <__reset+0xfb10441c>
81124444:	d9801e04 	addi	r6,sp,120
81124448:	800b883a 	mov	r5,r16
8112444c:	9809883a 	mov	r4,r19
81124450:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124454:	103d1a1e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124458:	8c7ffc04 	addi	r17,r17,-16
8112445c:	d8c02017 	ldw	r3,128(sp)
81124460:	d8801f17 	ldw	r2,124(sp)
81124464:	da000404 	addi	r8,sp,16
81124468:	e47fef16 	blt	fp,r17,81124428 <__reset+0xfb104428>
8112446c:	9021883a 	mov	r16,r18
81124470:	b025883a 	mov	r18,r22
81124474:	882d883a 	mov	r22,r17
81124478:	dc403017 	ldw	r17,192(sp)
8112447c:	d9002b17 	ldw	r4,172(sp)
81124480:	1d87883a 	add	r3,r3,r22
81124484:	10800044 	addi	r2,r2,1
81124488:	41000015 	stw	r4,0(r8)
8112448c:	45800115 	stw	r22,4(r8)
81124490:	d8c02015 	stw	r3,128(sp)
81124494:	d8801f15 	stw	r2,124(sp)
81124498:	010001c4 	movi	r4,7
8112449c:	20819a16 	blt	r4,r2,81124b08 <___svfprintf_internal_r+0x15e4>
811244a0:	42000204 	addi	r8,r8,8
811244a4:	003e3506 	br	81123d7c <__reset+0xfb103d7c>
811244a8:	d9403317 	ldw	r5,204(sp)
811244ac:	00800044 	movi	r2,1
811244b0:	18c00044 	addi	r3,r3,1
811244b4:	1141710e 	bge	r2,r5,81124a7c <___svfprintf_internal_r+0x1558>
811244b8:	dc401f17 	ldw	r17,124(sp)
811244bc:	00800044 	movi	r2,1
811244c0:	40800115 	stw	r2,4(r8)
811244c4:	8c400044 	addi	r17,r17,1
811244c8:	44000015 	stw	r16,0(r8)
811244cc:	d8c02015 	stw	r3,128(sp)
811244d0:	dc401f15 	stw	r17,124(sp)
811244d4:	008001c4 	movi	r2,7
811244d8:	14417416 	blt	r2,r17,81124aac <___svfprintf_internal_r+0x1588>
811244dc:	42000204 	addi	r8,r8,8
811244e0:	d8803817 	ldw	r2,224(sp)
811244e4:	d9003417 	ldw	r4,208(sp)
811244e8:	8c400044 	addi	r17,r17,1
811244ec:	10c7883a 	add	r3,r2,r3
811244f0:	40800115 	stw	r2,4(r8)
811244f4:	41000015 	stw	r4,0(r8)
811244f8:	d8c02015 	stw	r3,128(sp)
811244fc:	dc401f15 	stw	r17,124(sp)
81124500:	008001c4 	movi	r2,7
81124504:	14417216 	blt	r2,r17,81124ad0 <___svfprintf_internal_r+0x15ac>
81124508:	45800204 	addi	r22,r8,8
8112450c:	d9003617 	ldw	r4,216(sp)
81124510:	d9403717 	ldw	r5,220(sp)
81124514:	000d883a 	mov	r6,zero
81124518:	000f883a 	mov	r7,zero
8112451c:	d8c03d15 	stw	r3,244(sp)
81124520:	1135dd80 	call	81135dd8 <__eqdf2>
81124524:	d8c03d17 	ldw	r3,244(sp)
81124528:	1000b326 	beq	r2,zero,811247f8 <___svfprintf_internal_r+0x12d4>
8112452c:	d9403317 	ldw	r5,204(sp)
81124530:	84000044 	addi	r16,r16,1
81124534:	8c400044 	addi	r17,r17,1
81124538:	28bfffc4 	addi	r2,r5,-1
8112453c:	1887883a 	add	r3,r3,r2
81124540:	b0800115 	stw	r2,4(r22)
81124544:	b4000015 	stw	r16,0(r22)
81124548:	d8c02015 	stw	r3,128(sp)
8112454c:	dc401f15 	stw	r17,124(sp)
81124550:	008001c4 	movi	r2,7
81124554:	1440d216 	blt	r2,r17,811248a0 <___svfprintf_internal_r+0x137c>
81124558:	b5800204 	addi	r22,r22,8
8112455c:	d9003b17 	ldw	r4,236(sp)
81124560:	df0022c4 	addi	fp,sp,139
81124564:	8c400044 	addi	r17,r17,1
81124568:	20c7883a 	add	r3,r4,r3
8112456c:	b7000015 	stw	fp,0(r22)
81124570:	b1000115 	stw	r4,4(r22)
81124574:	d8c02015 	stw	r3,128(sp)
81124578:	dc401f15 	stw	r17,124(sp)
8112457c:	008001c4 	movi	r2,7
81124580:	14400e16 	blt	r2,r17,811245bc <___svfprintf_internal_r+0x1098>
81124584:	b2000204 	addi	r8,r22,8
81124588:	003e3c06 	br	81123e7c <__reset+0xfb103e7c>
8112458c:	01204574 	movhi	r4,33045
81124590:	21022584 	addi	r4,r4,2198
81124594:	d9002b15 	stw	r4,172(sp)
81124598:	d9002b17 	ldw	r4,172(sp)
8112459c:	1c07883a 	add	r3,r3,r16
811245a0:	44000115 	stw	r16,4(r8)
811245a4:	41000015 	stw	r4,0(r8)
811245a8:	10800044 	addi	r2,r2,1
811245ac:	d8c02015 	stw	r3,128(sp)
811245b0:	d8801f15 	stw	r2,124(sp)
811245b4:	010001c4 	movi	r4,7
811245b8:	20be2f0e 	bge	r4,r2,81123e78 <__reset+0xfb103e78>
811245bc:	d9402c17 	ldw	r5,176(sp)
811245c0:	d9801e04 	addi	r6,sp,120
811245c4:	9809883a 	mov	r4,r19
811245c8:	112fe5c0 	call	8112fe5c <__ssprint_r>
811245cc:	103cbc1e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
811245d0:	d8c02017 	ldw	r3,128(sp)
811245d4:	da000404 	addi	r8,sp,16
811245d8:	003e2806 	br	81123e7c <__reset+0xfb103e7c>
811245dc:	d9402c17 	ldw	r5,176(sp)
811245e0:	d9801e04 	addi	r6,sp,120
811245e4:	9809883a 	mov	r4,r19
811245e8:	112fe5c0 	call	8112fe5c <__ssprint_r>
811245ec:	103e5f26 	beq	r2,zero,81123f6c <__reset+0xfb103f6c>
811245f0:	003cb306 	br	811238c0 <__reset+0xfb1038c0>
811245f4:	d9402c17 	ldw	r5,176(sp)
811245f8:	d9801e04 	addi	r6,sp,120
811245fc:	9809883a 	mov	r4,r19
81124600:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124604:	103cae1e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124608:	d8c02017 	ldw	r3,128(sp)
8112460c:	da000404 	addi	r8,sp,16
81124610:	003e0d06 	br	81123e48 <__reset+0xfb103e48>
81124614:	d9402c17 	ldw	r5,176(sp)
81124618:	d9801e04 	addi	r6,sp,120
8112461c:	9809883a 	mov	r4,r19
81124620:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124624:	103ca61e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124628:	d8c02017 	ldw	r3,128(sp)
8112462c:	da000404 	addi	r8,sp,16
81124630:	003dc106 	br	81123d38 <__reset+0xfb103d38>
81124634:	d9402c17 	ldw	r5,176(sp)
81124638:	d9801e04 	addi	r6,sp,120
8112463c:	9809883a 	mov	r4,r19
81124640:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124644:	103c9e1e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124648:	d8c02017 	ldw	r3,128(sp)
8112464c:	da000404 	addi	r8,sp,16
81124650:	003dc706 	br	81123d70 <__reset+0xfb103d70>
81124654:	d8802917 	ldw	r2,164(sp)
81124658:	d8002785 	stb	zero,158(sp)
8112465c:	103f0816 	blt	r2,zero,81124280 <__reset+0xfb104280>
81124660:	00ffdfc4 	movi	r3,-129
81124664:	a584b03a 	or	r2,r20,r22
81124668:	90e4703a 	and	r18,r18,r3
8112466c:	103c8126 	beq	r2,zero,81123874 <__reset+0xfb103874>
81124670:	0039883a 	mov	fp,zero
81124674:	003e7606 	br	81124050 <__reset+0xfb104050>
81124678:	9080040c 	andi	r2,r18,16
8112467c:	10013d26 	beq	r2,zero,81124b74 <___svfprintf_internal_r+0x1650>
81124680:	d9002d17 	ldw	r4,180(sp)
81124684:	d9402917 	ldw	r5,164(sp)
81124688:	d8002785 	stb	zero,158(sp)
8112468c:	20800104 	addi	r2,r4,4
81124690:	25000017 	ldw	r20,0(r4)
81124694:	002d883a 	mov	r22,zero
81124698:	28013f16 	blt	r5,zero,81124b98 <___svfprintf_internal_r+0x1674>
8112469c:	00ffdfc4 	movi	r3,-129
811246a0:	d8802d15 	stw	r2,180(sp)
811246a4:	90e4703a 	and	r18,r18,r3
811246a8:	a03d2b26 	beq	r20,zero,81123b58 <__reset+0xfb103b58>
811246ac:	0039883a 	mov	fp,zero
811246b0:	003d2e06 	br	81123b6c <__reset+0xfb103b6c>
811246b4:	dc402617 	ldw	r17,152(sp)
811246b8:	0441830e 	bge	zero,r17,81124cc8 <___svfprintf_internal_r+0x17a4>
811246bc:	dc403217 	ldw	r17,200(sp)
811246c0:	d8803317 	ldw	r2,204(sp)
811246c4:	1440010e 	bge	r2,r17,811246cc <___svfprintf_internal_r+0x11a8>
811246c8:	1023883a 	mov	r17,r2
811246cc:	04400a0e 	bge	zero,r17,811246f8 <___svfprintf_internal_r+0x11d4>
811246d0:	d8801f17 	ldw	r2,124(sp)
811246d4:	1c47883a 	add	r3,r3,r17
811246d8:	44000015 	stw	r16,0(r8)
811246dc:	10800044 	addi	r2,r2,1
811246e0:	44400115 	stw	r17,4(r8)
811246e4:	d8c02015 	stw	r3,128(sp)
811246e8:	d8801f15 	stw	r2,124(sp)
811246ec:	010001c4 	movi	r4,7
811246f0:	20827516 	blt	r4,r2,811250c8 <___svfprintf_internal_r+0x1ba4>
811246f4:	42000204 	addi	r8,r8,8
811246f8:	88027b16 	blt	r17,zero,811250e8 <___svfprintf_internal_r+0x1bc4>
811246fc:	d9003217 	ldw	r4,200(sp)
81124700:	2463c83a 	sub	r17,r4,r17
81124704:	0440990e 	bge	zero,r17,8112496c <___svfprintf_internal_r+0x1448>
81124708:	05800404 	movi	r22,16
8112470c:	d8801f17 	ldw	r2,124(sp)
81124710:	b441530e 	bge	r22,r17,81124c60 <___svfprintf_internal_r+0x173c>
81124714:	01204574 	movhi	r4,33045
81124718:	21022584 	addi	r4,r4,2198
8112471c:	d9002b15 	stw	r4,172(sp)
81124720:	070001c4 	movi	fp,7
81124724:	dd002c17 	ldw	r20,176(sp)
81124728:	00000306 	br	81124738 <___svfprintf_internal_r+0x1214>
8112472c:	42000204 	addi	r8,r8,8
81124730:	8c7ffc04 	addi	r17,r17,-16
81124734:	b4414d0e 	bge	r22,r17,81124c6c <___svfprintf_internal_r+0x1748>
81124738:	18c00404 	addi	r3,r3,16
8112473c:	10800044 	addi	r2,r2,1
81124740:	45400015 	stw	r21,0(r8)
81124744:	45800115 	stw	r22,4(r8)
81124748:	d8c02015 	stw	r3,128(sp)
8112474c:	d8801f15 	stw	r2,124(sp)
81124750:	e0bff60e 	bge	fp,r2,8112472c <__reset+0xfb10472c>
81124754:	d9801e04 	addi	r6,sp,120
81124758:	a00b883a 	mov	r5,r20
8112475c:	9809883a 	mov	r4,r19
81124760:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124764:	103c561e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124768:	d8c02017 	ldw	r3,128(sp)
8112476c:	d8801f17 	ldw	r2,124(sp)
81124770:	da000404 	addi	r8,sp,16
81124774:	003fee06 	br	81124730 <__reset+0xfb104730>
81124778:	d9402c17 	ldw	r5,176(sp)
8112477c:	d9801e04 	addi	r6,sp,120
81124780:	9809883a 	mov	r4,r19
81124784:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124788:	103c4d1e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
8112478c:	d8c02017 	ldw	r3,128(sp)
81124790:	df002787 	ldb	fp,158(sp)
81124794:	da000404 	addi	r8,sp,16
81124798:	003d5a06 	br	81123d04 <__reset+0xfb103d04>
8112479c:	9080040c 	andi	r2,r18,16
811247a0:	10005c26 	beq	r2,zero,81124914 <___svfprintf_internal_r+0x13f0>
811247a4:	d9402d17 	ldw	r5,180(sp)
811247a8:	d8c02917 	ldw	r3,164(sp)
811247ac:	d8002785 	stb	zero,158(sp)
811247b0:	28800104 	addi	r2,r5,4
811247b4:	2d000017 	ldw	r20,0(r5)
811247b8:	002d883a 	mov	r22,zero
811247bc:	18005e16 	blt	r3,zero,81124938 <___svfprintf_internal_r+0x1414>
811247c0:	00ffdfc4 	movi	r3,-129
811247c4:	d8802d15 	stw	r2,180(sp)
811247c8:	90e4703a 	and	r18,r18,r3
811247cc:	0039883a 	mov	fp,zero
811247d0:	a03dfe26 	beq	r20,zero,81123fcc <__reset+0xfb103fcc>
811247d4:	00800244 	movi	r2,9
811247d8:	153cb336 	bltu	r2,r20,81123aa8 <__reset+0xfb103aa8>
811247dc:	a5000c04 	addi	r20,r20,48
811247e0:	dc001dc4 	addi	r16,sp,119
811247e4:	dd001dc5 	stb	r20,119(sp)
811247e8:	d8c02817 	ldw	r3,160(sp)
811247ec:	1c07c83a 	sub	r3,r3,r16
811247f0:	d8c02e15 	stw	r3,184(sp)
811247f4:	003cf506 	br	81123bcc <__reset+0xfb103bcc>
811247f8:	d8803317 	ldw	r2,204(sp)
811247fc:	143fffc4 	addi	r16,r2,-1
81124800:	043f560e 	bge	zero,r16,8112455c <__reset+0xfb10455c>
81124804:	07000404 	movi	fp,16
81124808:	e403530e 	bge	fp,r16,81125558 <___svfprintf_internal_r+0x2034>
8112480c:	01604574 	movhi	r5,33045
81124810:	29422584 	addi	r5,r5,2198
81124814:	d9402b15 	stw	r5,172(sp)
81124818:	01c001c4 	movi	r7,7
8112481c:	dd002c17 	ldw	r20,176(sp)
81124820:	00000306 	br	81124830 <___svfprintf_internal_r+0x130c>
81124824:	843ffc04 	addi	r16,r16,-16
81124828:	b5800204 	addi	r22,r22,8
8112482c:	e400130e 	bge	fp,r16,8112487c <___svfprintf_internal_r+0x1358>
81124830:	18c00404 	addi	r3,r3,16
81124834:	8c400044 	addi	r17,r17,1
81124838:	b5400015 	stw	r21,0(r22)
8112483c:	b7000115 	stw	fp,4(r22)
81124840:	d8c02015 	stw	r3,128(sp)
81124844:	dc401f15 	stw	r17,124(sp)
81124848:	3c7ff60e 	bge	r7,r17,81124824 <__reset+0xfb104824>
8112484c:	d9801e04 	addi	r6,sp,120
81124850:	a00b883a 	mov	r5,r20
81124854:	9809883a 	mov	r4,r19
81124858:	d9c03d15 	stw	r7,244(sp)
8112485c:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124860:	d9c03d17 	ldw	r7,244(sp)
81124864:	103c161e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124868:	843ffc04 	addi	r16,r16,-16
8112486c:	d8c02017 	ldw	r3,128(sp)
81124870:	dc401f17 	ldw	r17,124(sp)
81124874:	dd800404 	addi	r22,sp,16
81124878:	e43fed16 	blt	fp,r16,81124830 <__reset+0xfb104830>
8112487c:	d8802b17 	ldw	r2,172(sp)
81124880:	1c07883a 	add	r3,r3,r16
81124884:	8c400044 	addi	r17,r17,1
81124888:	b0800015 	stw	r2,0(r22)
8112488c:	b4000115 	stw	r16,4(r22)
81124890:	d8c02015 	stw	r3,128(sp)
81124894:	dc401f15 	stw	r17,124(sp)
81124898:	008001c4 	movi	r2,7
8112489c:	147f2e0e 	bge	r2,r17,81124558 <__reset+0xfb104558>
811248a0:	d9402c17 	ldw	r5,176(sp)
811248a4:	d9801e04 	addi	r6,sp,120
811248a8:	9809883a 	mov	r4,r19
811248ac:	112fe5c0 	call	8112fe5c <__ssprint_r>
811248b0:	103c031e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
811248b4:	d8c02017 	ldw	r3,128(sp)
811248b8:	dc401f17 	ldw	r17,124(sp)
811248bc:	dd800404 	addi	r22,sp,16
811248c0:	003f2606 	br	8112455c <__reset+0xfb10455c>
811248c4:	9080040c 	andi	r2,r18,16
811248c8:	1000c326 	beq	r2,zero,81124bd8 <___svfprintf_internal_r+0x16b4>
811248cc:	d8802d17 	ldw	r2,180(sp)
811248d0:	15000017 	ldw	r20,0(r2)
811248d4:	10800104 	addi	r2,r2,4
811248d8:	d8802d15 	stw	r2,180(sp)
811248dc:	a02dd7fa 	srai	r22,r20,31
811248e0:	b005883a 	mov	r2,r22
811248e4:	103c680e 	bge	r2,zero,81123a88 <__reset+0xfb103a88>
811248e8:	0529c83a 	sub	r20,zero,r20
811248ec:	a004c03a 	cmpne	r2,r20,zero
811248f0:	05adc83a 	sub	r22,zero,r22
811248f4:	b0adc83a 	sub	r22,r22,r2
811248f8:	d8802917 	ldw	r2,164(sp)
811248fc:	07000b44 	movi	fp,45
81124900:	df002785 	stb	fp,158(sp)
81124904:	10022e16 	blt	r2,zero,811251c0 <___svfprintf_internal_r+0x1c9c>
81124908:	00bfdfc4 	movi	r2,-129
8112490c:	90a4703a 	and	r18,r18,r2
81124910:	003c6406 	br	81123aa4 <__reset+0xfb103aa4>
81124914:	9080100c 	andi	r2,r18,64
81124918:	d8002785 	stb	zero,158(sp)
8112491c:	10012526 	beq	r2,zero,81124db4 <___svfprintf_internal_r+0x1890>
81124920:	d9002d17 	ldw	r4,180(sp)
81124924:	d9402917 	ldw	r5,164(sp)
81124928:	002d883a 	mov	r22,zero
8112492c:	20800104 	addi	r2,r4,4
81124930:	2500000b 	ldhu	r20,0(r4)
81124934:	283fa20e 	bge	r5,zero,811247c0 <__reset+0xfb1047c0>
81124938:	d8802d15 	stw	r2,180(sp)
8112493c:	0039883a 	mov	fp,zero
81124940:	a584b03a 	or	r2,r20,r22
81124944:	103c571e 	bne	r2,zero,81123aa4 <__reset+0xfb103aa4>
81124948:	00800044 	movi	r2,1
8112494c:	003e5006 	br	81124290 <__reset+0xfb104290>
81124950:	d9402c17 	ldw	r5,176(sp)
81124954:	d9801e04 	addi	r6,sp,120
81124958:	9809883a 	mov	r4,r19
8112495c:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124960:	103bd71e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124964:	d8c02017 	ldw	r3,128(sp)
81124968:	da000404 	addi	r8,sp,16
8112496c:	d9003217 	ldw	r4,200(sp)
81124970:	d8802617 	ldw	r2,152(sp)
81124974:	d9403317 	ldw	r5,204(sp)
81124978:	8123883a 	add	r17,r16,r4
8112497c:	11400216 	blt	r2,r5,81124988 <___svfprintf_internal_r+0x1464>
81124980:	9100004c 	andi	r4,r18,1
81124984:	20000d26 	beq	r4,zero,811249bc <___svfprintf_internal_r+0x1498>
81124988:	d9003817 	ldw	r4,224(sp)
8112498c:	d9403417 	ldw	r5,208(sp)
81124990:	1907883a 	add	r3,r3,r4
81124994:	d9001f17 	ldw	r4,124(sp)
81124998:	41400015 	stw	r5,0(r8)
8112499c:	d9403817 	ldw	r5,224(sp)
811249a0:	21000044 	addi	r4,r4,1
811249a4:	d8c02015 	stw	r3,128(sp)
811249a8:	41400115 	stw	r5,4(r8)
811249ac:	d9001f15 	stw	r4,124(sp)
811249b0:	014001c4 	movi	r5,7
811249b4:	2901dc16 	blt	r5,r4,81125128 <___svfprintf_internal_r+0x1c04>
811249b8:	42000204 	addi	r8,r8,8
811249bc:	d9003317 	ldw	r4,204(sp)
811249c0:	8121883a 	add	r16,r16,r4
811249c4:	2085c83a 	sub	r2,r4,r2
811249c8:	8461c83a 	sub	r16,r16,r17
811249cc:	1400010e 	bge	r2,r16,811249d4 <___svfprintf_internal_r+0x14b0>
811249d0:	1021883a 	mov	r16,r2
811249d4:	04000a0e 	bge	zero,r16,81124a00 <___svfprintf_internal_r+0x14dc>
811249d8:	d9001f17 	ldw	r4,124(sp)
811249dc:	1c07883a 	add	r3,r3,r16
811249e0:	44400015 	stw	r17,0(r8)
811249e4:	21000044 	addi	r4,r4,1
811249e8:	44000115 	stw	r16,4(r8)
811249ec:	d8c02015 	stw	r3,128(sp)
811249f0:	d9001f15 	stw	r4,124(sp)
811249f4:	014001c4 	movi	r5,7
811249f8:	2901e616 	blt	r5,r4,81125194 <___svfprintf_internal_r+0x1c70>
811249fc:	42000204 	addi	r8,r8,8
81124a00:	8001f616 	blt	r16,zero,811251dc <___svfprintf_internal_r+0x1cb8>
81124a04:	1421c83a 	sub	r16,r2,r16
81124a08:	043d1c0e 	bge	zero,r16,81123e7c <__reset+0xfb103e7c>
81124a0c:	04400404 	movi	r17,16
81124a10:	d8801f17 	ldw	r2,124(sp)
81124a14:	8c3edd0e 	bge	r17,r16,8112458c <__reset+0xfb10458c>
81124a18:	01604574 	movhi	r5,33045
81124a1c:	29422584 	addi	r5,r5,2198
81124a20:	d9402b15 	stw	r5,172(sp)
81124a24:	058001c4 	movi	r22,7
81124a28:	dd002c17 	ldw	r20,176(sp)
81124a2c:	00000306 	br	81124a3c <___svfprintf_internal_r+0x1518>
81124a30:	42000204 	addi	r8,r8,8
81124a34:	843ffc04 	addi	r16,r16,-16
81124a38:	8c3ed70e 	bge	r17,r16,81124598 <__reset+0xfb104598>
81124a3c:	18c00404 	addi	r3,r3,16
81124a40:	10800044 	addi	r2,r2,1
81124a44:	45400015 	stw	r21,0(r8)
81124a48:	44400115 	stw	r17,4(r8)
81124a4c:	d8c02015 	stw	r3,128(sp)
81124a50:	d8801f15 	stw	r2,124(sp)
81124a54:	b0bff60e 	bge	r22,r2,81124a30 <__reset+0xfb104a30>
81124a58:	d9801e04 	addi	r6,sp,120
81124a5c:	a00b883a 	mov	r5,r20
81124a60:	9809883a 	mov	r4,r19
81124a64:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124a68:	103b951e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124a6c:	d8c02017 	ldw	r3,128(sp)
81124a70:	d8801f17 	ldw	r2,124(sp)
81124a74:	da000404 	addi	r8,sp,16
81124a78:	003fee06 	br	81124a34 <__reset+0xfb104a34>
81124a7c:	9088703a 	and	r4,r18,r2
81124a80:	203e8d1e 	bne	r4,zero,811244b8 <__reset+0xfb1044b8>
81124a84:	dc401f17 	ldw	r17,124(sp)
81124a88:	40800115 	stw	r2,4(r8)
81124a8c:	44000015 	stw	r16,0(r8)
81124a90:	8c400044 	addi	r17,r17,1
81124a94:	d8c02015 	stw	r3,128(sp)
81124a98:	dc401f15 	stw	r17,124(sp)
81124a9c:	008001c4 	movi	r2,7
81124aa0:	147f7f16 	blt	r2,r17,811248a0 <__reset+0xfb1048a0>
81124aa4:	45800204 	addi	r22,r8,8
81124aa8:	003eac06 	br	8112455c <__reset+0xfb10455c>
81124aac:	d9402c17 	ldw	r5,176(sp)
81124ab0:	d9801e04 	addi	r6,sp,120
81124ab4:	9809883a 	mov	r4,r19
81124ab8:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124abc:	103b801e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124ac0:	d8c02017 	ldw	r3,128(sp)
81124ac4:	dc401f17 	ldw	r17,124(sp)
81124ac8:	da000404 	addi	r8,sp,16
81124acc:	003e8406 	br	811244e0 <__reset+0xfb1044e0>
81124ad0:	d9402c17 	ldw	r5,176(sp)
81124ad4:	d9801e04 	addi	r6,sp,120
81124ad8:	9809883a 	mov	r4,r19
81124adc:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124ae0:	103b771e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124ae4:	d8c02017 	ldw	r3,128(sp)
81124ae8:	dc401f17 	ldw	r17,124(sp)
81124aec:	dd800404 	addi	r22,sp,16
81124af0:	003e8606 	br	8112450c <__reset+0xfb10450c>
81124af4:	0029883a 	mov	r20,zero
81124af8:	a5000c04 	addi	r20,r20,48
81124afc:	dc001dc4 	addi	r16,sp,119
81124b00:	dd001dc5 	stb	r20,119(sp)
81124b04:	003f3806 	br	811247e8 <__reset+0xfb1047e8>
81124b08:	d9402c17 	ldw	r5,176(sp)
81124b0c:	d9801e04 	addi	r6,sp,120
81124b10:	9809883a 	mov	r4,r19
81124b14:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124b18:	103b691e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124b1c:	d8c02017 	ldw	r3,128(sp)
81124b20:	da000404 	addi	r8,sp,16
81124b24:	003c9506 	br	81123d7c <__reset+0xfb103d7c>
81124b28:	d9003617 	ldw	r4,216(sp)
81124b2c:	d9403717 	ldw	r5,220(sp)
81124b30:	da003e15 	stw	r8,248(sp)
81124b34:	112df580 	call	8112df58 <__fpclassifyd>
81124b38:	da003e17 	ldw	r8,248(sp)
81124b3c:	1000bd1e 	bne	r2,zero,81124e34 <___svfprintf_internal_r+0x1910>
81124b40:	008011c4 	movi	r2,71
81124b44:	14411e0e 	bge	r2,r17,81124fc0 <___svfprintf_internal_r+0x1a9c>
81124b48:	04204574 	movhi	r16,33045
81124b4c:	84021804 	addi	r16,r16,2144
81124b50:	00c000c4 	movi	r3,3
81124b54:	00bfdfc4 	movi	r2,-129
81124b58:	d8c02a15 	stw	r3,168(sp)
81124b5c:	90a4703a 	and	r18,r18,r2
81124b60:	df002783 	ldbu	fp,158(sp)
81124b64:	d8c02e15 	stw	r3,184(sp)
81124b68:	d8002915 	stw	zero,164(sp)
81124b6c:	d8003215 	stw	zero,200(sp)
81124b70:	003c1c06 	br	81123be4 <__reset+0xfb103be4>
81124b74:	9080100c 	andi	r2,r18,64
81124b78:	d8002785 	stb	zero,158(sp)
81124b7c:	10009426 	beq	r2,zero,81124dd0 <___svfprintf_internal_r+0x18ac>
81124b80:	d8c02d17 	ldw	r3,180(sp)
81124b84:	d9002917 	ldw	r4,164(sp)
81124b88:	002d883a 	mov	r22,zero
81124b8c:	18800104 	addi	r2,r3,4
81124b90:	1d00000b 	ldhu	r20,0(r3)
81124b94:	203ec10e 	bge	r4,zero,8112469c <__reset+0xfb10469c>
81124b98:	a586b03a 	or	r3,r20,r22
81124b9c:	d8802d15 	stw	r2,180(sp)
81124ba0:	183ec21e 	bne	r3,zero,811246ac <__reset+0xfb1046ac>
81124ba4:	0039883a 	mov	fp,zero
81124ba8:	0005883a 	mov	r2,zero
81124bac:	003db806 	br	81124290 <__reset+0xfb104290>
81124bb0:	d8802d17 	ldw	r2,180(sp)
81124bb4:	d8c02d17 	ldw	r3,180(sp)
81124bb8:	d9002d17 	ldw	r4,180(sp)
81124bbc:	10800017 	ldw	r2,0(r2)
81124bc0:	18c00117 	ldw	r3,4(r3)
81124bc4:	21000204 	addi	r4,r4,8
81124bc8:	d8803615 	stw	r2,216(sp)
81124bcc:	d8c03715 	stw	r3,220(sp)
81124bd0:	d9002d15 	stw	r4,180(sp)
81124bd4:	003b8206 	br	811239e0 <__reset+0xfb1039e0>
81124bd8:	9080100c 	andi	r2,r18,64
81124bdc:	10010726 	beq	r2,zero,81124ffc <___svfprintf_internal_r+0x1ad8>
81124be0:	d8c02d17 	ldw	r3,180(sp)
81124be4:	1d00000f 	ldh	r20,0(r3)
81124be8:	18c00104 	addi	r3,r3,4
81124bec:	d8c02d15 	stw	r3,180(sp)
81124bf0:	a02dd7fa 	srai	r22,r20,31
81124bf4:	b005883a 	mov	r2,r22
81124bf8:	003ba206 	br	81123a84 <__reset+0xfb103a84>
81124bfc:	9080100c 	andi	r2,r18,64
81124c00:	10010526 	beq	r2,zero,81125018 <___svfprintf_internal_r+0x1af4>
81124c04:	d9002d17 	ldw	r4,180(sp)
81124c08:	002d883a 	mov	r22,zero
81124c0c:	2500000b 	ldhu	r20,0(r4)
81124c10:	21000104 	addi	r4,r4,4
81124c14:	d9002d15 	stw	r4,180(sp)
81124c18:	003cfe06 	br	81124014 <__reset+0xfb104014>
81124c1c:	bc400007 	ldb	r17,0(r23)
81124c20:	003a9606 	br	8112367c <__reset+0xfb10367c>
81124c24:	9080040c 	andi	r2,r18,16
81124c28:	10010126 	beq	r2,zero,81125030 <___svfprintf_internal_r+0x1b0c>
81124c2c:	d9402d17 	ldw	r5,180(sp)
81124c30:	d8c02f17 	ldw	r3,188(sp)
81124c34:	28800017 	ldw	r2,0(r5)
81124c38:	29400104 	addi	r5,r5,4
81124c3c:	d9402d15 	stw	r5,180(sp)
81124c40:	10c00015 	stw	r3,0(r2)
81124c44:	003a6406 	br	811235d8 <__reset+0xfb1035d8>
81124c48:	d9002917 	ldw	r4,164(sp)
81124c4c:	d8002785 	stb	zero,158(sp)
81124c50:	203d8d16 	blt	r4,zero,81124288 <__reset+0xfb104288>
81124c54:	00bfdfc4 	movi	r2,-129
81124c58:	90a4703a 	and	r18,r18,r2
81124c5c:	003b0506 	br	81123874 <__reset+0xfb103874>
81124c60:	01604574 	movhi	r5,33045
81124c64:	29422584 	addi	r5,r5,2198
81124c68:	d9402b15 	stw	r5,172(sp)
81124c6c:	d9402b17 	ldw	r5,172(sp)
81124c70:	1c47883a 	add	r3,r3,r17
81124c74:	10800044 	addi	r2,r2,1
81124c78:	41400015 	stw	r5,0(r8)
81124c7c:	44400115 	stw	r17,4(r8)
81124c80:	d8c02015 	stw	r3,128(sp)
81124c84:	d8801f15 	stw	r2,124(sp)
81124c88:	010001c4 	movi	r4,7
81124c8c:	20bf3016 	blt	r4,r2,81124950 <__reset+0xfb104950>
81124c90:	42000204 	addi	r8,r8,8
81124c94:	003f3506 	br	8112496c <__reset+0xfb10496c>
81124c98:	01204574 	movhi	r4,33045
81124c9c:	21022584 	addi	r4,r4,2198
81124ca0:	d9002b15 	stw	r4,172(sp)
81124ca4:	003c5e06 	br	81123e20 <__reset+0xfb103e20>
81124ca8:	d9402c17 	ldw	r5,176(sp)
81124cac:	d9801e04 	addi	r6,sp,120
81124cb0:	9809883a 	mov	r4,r19
81124cb4:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124cb8:	103b011e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124cbc:	d8c02017 	ldw	r3,128(sp)
81124cc0:	da000404 	addi	r8,sp,16
81124cc4:	003d9306 	br	81124314 <__reset+0xfb104314>
81124cc8:	d8801f17 	ldw	r2,124(sp)
81124ccc:	01604574 	movhi	r5,33045
81124cd0:	01000044 	movi	r4,1
81124cd4:	18c00044 	addi	r3,r3,1
81124cd8:	10800044 	addi	r2,r2,1
81124cdc:	29422504 	addi	r5,r5,2196
81124ce0:	41000115 	stw	r4,4(r8)
81124ce4:	41400015 	stw	r5,0(r8)
81124ce8:	d8c02015 	stw	r3,128(sp)
81124cec:	d8801f15 	stw	r2,124(sp)
81124cf0:	010001c4 	movi	r4,7
81124cf4:	2080b516 	blt	r4,r2,81124fcc <___svfprintf_internal_r+0x1aa8>
81124cf8:	42000204 	addi	r8,r8,8
81124cfc:	8800041e 	bne	r17,zero,81124d10 <___svfprintf_internal_r+0x17ec>
81124d00:	d8803317 	ldw	r2,204(sp)
81124d04:	1000021e 	bne	r2,zero,81124d10 <___svfprintf_internal_r+0x17ec>
81124d08:	9080004c 	andi	r2,r18,1
81124d0c:	103c5b26 	beq	r2,zero,81123e7c <__reset+0xfb103e7c>
81124d10:	d9003817 	ldw	r4,224(sp)
81124d14:	d8801f17 	ldw	r2,124(sp)
81124d18:	d9403417 	ldw	r5,208(sp)
81124d1c:	20c7883a 	add	r3,r4,r3
81124d20:	10800044 	addi	r2,r2,1
81124d24:	41000115 	stw	r4,4(r8)
81124d28:	41400015 	stw	r5,0(r8)
81124d2c:	d8c02015 	stw	r3,128(sp)
81124d30:	d8801f15 	stw	r2,124(sp)
81124d34:	010001c4 	movi	r4,7
81124d38:	20818016 	blt	r4,r2,8112533c <___svfprintf_internal_r+0x1e18>
81124d3c:	42000204 	addi	r8,r8,8
81124d40:	0463c83a 	sub	r17,zero,r17
81124d44:	0440cb0e 	bge	zero,r17,81125074 <___svfprintf_internal_r+0x1b50>
81124d48:	05800404 	movi	r22,16
81124d4c:	b440e80e 	bge	r22,r17,811250f0 <___svfprintf_internal_r+0x1bcc>
81124d50:	01604574 	movhi	r5,33045
81124d54:	29422584 	addi	r5,r5,2198
81124d58:	d9402b15 	stw	r5,172(sp)
81124d5c:	070001c4 	movi	fp,7
81124d60:	dd002c17 	ldw	r20,176(sp)
81124d64:	00000306 	br	81124d74 <___svfprintf_internal_r+0x1850>
81124d68:	42000204 	addi	r8,r8,8
81124d6c:	8c7ffc04 	addi	r17,r17,-16
81124d70:	b440e20e 	bge	r22,r17,811250fc <___svfprintf_internal_r+0x1bd8>
81124d74:	18c00404 	addi	r3,r3,16
81124d78:	10800044 	addi	r2,r2,1
81124d7c:	45400015 	stw	r21,0(r8)
81124d80:	45800115 	stw	r22,4(r8)
81124d84:	d8c02015 	stw	r3,128(sp)
81124d88:	d8801f15 	stw	r2,124(sp)
81124d8c:	e0bff60e 	bge	fp,r2,81124d68 <__reset+0xfb104d68>
81124d90:	d9801e04 	addi	r6,sp,120
81124d94:	a00b883a 	mov	r5,r20
81124d98:	9809883a 	mov	r4,r19
81124d9c:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124da0:	103ac71e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124da4:	d8c02017 	ldw	r3,128(sp)
81124da8:	d8801f17 	ldw	r2,124(sp)
81124dac:	da000404 	addi	r8,sp,16
81124db0:	003fee06 	br	81124d6c <__reset+0xfb104d6c>
81124db4:	d8c02d17 	ldw	r3,180(sp)
81124db8:	d9002917 	ldw	r4,164(sp)
81124dbc:	002d883a 	mov	r22,zero
81124dc0:	18800104 	addi	r2,r3,4
81124dc4:	1d000017 	ldw	r20,0(r3)
81124dc8:	203e7d0e 	bge	r4,zero,811247c0 <__reset+0xfb1047c0>
81124dcc:	003eda06 	br	81124938 <__reset+0xfb104938>
81124dd0:	d9402d17 	ldw	r5,180(sp)
81124dd4:	d8c02917 	ldw	r3,164(sp)
81124dd8:	002d883a 	mov	r22,zero
81124ddc:	28800104 	addi	r2,r5,4
81124de0:	2d000017 	ldw	r20,0(r5)
81124de4:	183e2d0e 	bge	r3,zero,8112469c <__reset+0xfb10469c>
81124de8:	003f6b06 	br	81124b98 <__reset+0xfb104b98>
81124dec:	d8c02d15 	stw	r3,180(sp)
81124df0:	0039883a 	mov	fp,zero
81124df4:	003ed206 	br	81124940 <__reset+0xfb104940>
81124df8:	bc400043 	ldbu	r17,1(r23)
81124dfc:	94800814 	ori	r18,r18,32
81124e00:	bdc00044 	addi	r23,r23,1
81124e04:	8c403fcc 	andi	r17,r17,255
81124e08:	8c40201c 	xori	r17,r17,128
81124e0c:	8c7fe004 	addi	r17,r17,-128
81124e10:	003a1a06 	br	8112367c <__reset+0xfb10367c>
81124e14:	d9402c17 	ldw	r5,176(sp)
81124e18:	d9801e04 	addi	r6,sp,120
81124e1c:	9809883a 	mov	r4,r19
81124e20:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124e24:	103aa61e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124e28:	d8c02017 	ldw	r3,128(sp)
81124e2c:	da000404 	addi	r8,sp,16
81124e30:	003d4a06 	br	8112435c <__reset+0xfb10435c>
81124e34:	d9002917 	ldw	r4,164(sp)
81124e38:	05bff7c4 	movi	r22,-33
81124e3c:	00bfffc4 	movi	r2,-1
81124e40:	8dac703a 	and	r22,r17,r22
81124e44:	20806a26 	beq	r4,r2,81124ff0 <___svfprintf_internal_r+0x1acc>
81124e48:	008011c4 	movi	r2,71
81124e4c:	b0813726 	beq	r22,r2,8112532c <___svfprintf_internal_r+0x1e08>
81124e50:	d9003717 	ldw	r4,220(sp)
81124e54:	90c04014 	ori	r3,r18,256
81124e58:	d8c02b15 	stw	r3,172(sp)
81124e5c:	20015d16 	blt	r4,zero,811253d4 <___svfprintf_internal_r+0x1eb0>
81124e60:	dd003717 	ldw	r20,220(sp)
81124e64:	d8002a05 	stb	zero,168(sp)
81124e68:	00801984 	movi	r2,102
81124e6c:	88814026 	beq	r17,r2,81125370 <___svfprintf_internal_r+0x1e4c>
81124e70:	00801184 	movi	r2,70
81124e74:	88817126 	beq	r17,r2,8112543c <___svfprintf_internal_r+0x1f18>
81124e78:	00801144 	movi	r2,69
81124e7c:	b0816226 	beq	r22,r2,81125408 <___svfprintf_internal_r+0x1ee4>
81124e80:	d8c02917 	ldw	r3,164(sp)
81124e84:	d8802104 	addi	r2,sp,132
81124e88:	d8800315 	stw	r2,12(sp)
81124e8c:	d9403617 	ldw	r5,216(sp)
81124e90:	d8802504 	addi	r2,sp,148
81124e94:	d8800215 	stw	r2,8(sp)
81124e98:	d8802604 	addi	r2,sp,152
81124e9c:	d8c00015 	stw	r3,0(sp)
81124ea0:	d8800115 	stw	r2,4(sp)
81124ea4:	01c00084 	movi	r7,2
81124ea8:	a00d883a 	mov	r6,r20
81124eac:	9809883a 	mov	r4,r19
81124eb0:	d8c03d15 	stw	r3,244(sp)
81124eb4:	da003e15 	stw	r8,248(sp)
81124eb8:	11298100 	call	81129810 <_dtoa_r>
81124ebc:	1021883a 	mov	r16,r2
81124ec0:	008019c4 	movi	r2,103
81124ec4:	d8c03d17 	ldw	r3,244(sp)
81124ec8:	da003e17 	ldw	r8,248(sp)
81124ecc:	8880e726 	beq	r17,r2,8112526c <___svfprintf_internal_r+0x1d48>
81124ed0:	008011c4 	movi	r2,71
81124ed4:	8880d426 	beq	r17,r2,81125228 <___svfprintf_internal_r+0x1d04>
81124ed8:	80f9883a 	add	fp,r16,r3
81124edc:	d9003617 	ldw	r4,216(sp)
81124ee0:	000d883a 	mov	r6,zero
81124ee4:	000f883a 	mov	r7,zero
81124ee8:	a00b883a 	mov	r5,r20
81124eec:	da003e15 	stw	r8,248(sp)
81124ef0:	1135dd80 	call	81135dd8 <__eqdf2>
81124ef4:	da003e17 	ldw	r8,248(sp)
81124ef8:	1000e426 	beq	r2,zero,8112528c <___svfprintf_internal_r+0x1d68>
81124efc:	d8802117 	ldw	r2,132(sp)
81124f00:	1700062e 	bgeu	r2,fp,81124f1c <___svfprintf_internal_r+0x19f8>
81124f04:	01000c04 	movi	r4,48
81124f08:	10c00044 	addi	r3,r2,1
81124f0c:	d8c02115 	stw	r3,132(sp)
81124f10:	11000005 	stb	r4,0(r2)
81124f14:	d8802117 	ldw	r2,132(sp)
81124f18:	173ffb36 	bltu	r2,fp,81124f08 <__reset+0xfb104f08>
81124f1c:	1405c83a 	sub	r2,r2,r16
81124f20:	d8803315 	stw	r2,204(sp)
81124f24:	008011c4 	movi	r2,71
81124f28:	b080c526 	beq	r22,r2,81125240 <___svfprintf_internal_r+0x1d1c>
81124f2c:	00801944 	movi	r2,101
81124f30:	1441d90e 	bge	r2,r17,81125698 <___svfprintf_internal_r+0x2174>
81124f34:	d8c02617 	ldw	r3,152(sp)
81124f38:	00801984 	movi	r2,102
81124f3c:	d8c03215 	stw	r3,200(sp)
81124f40:	88813426 	beq	r17,r2,81125414 <___svfprintf_internal_r+0x1ef0>
81124f44:	d8c03217 	ldw	r3,200(sp)
81124f48:	d9003317 	ldw	r4,204(sp)
81124f4c:	19012516 	blt	r3,r4,811253e4 <___svfprintf_internal_r+0x1ec0>
81124f50:	9480004c 	andi	r18,r18,1
81124f54:	9001841e 	bne	r18,zero,81125568 <___svfprintf_internal_r+0x2044>
81124f58:	1805883a 	mov	r2,r3
81124f5c:	1801cc16 	blt	r3,zero,81125690 <___svfprintf_internal_r+0x216c>
81124f60:	d8c03217 	ldw	r3,200(sp)
81124f64:	044019c4 	movi	r17,103
81124f68:	d8c02e15 	stw	r3,184(sp)
81124f6c:	df002a07 	ldb	fp,168(sp)
81124f70:	e000a61e 	bne	fp,zero,8112520c <___svfprintf_internal_r+0x1ce8>
81124f74:	df002783 	ldbu	fp,158(sp)
81124f78:	d8802a15 	stw	r2,168(sp)
81124f7c:	dc802b17 	ldw	r18,172(sp)
81124f80:	d8002915 	stw	zero,164(sp)
81124f84:	003b1706 	br	81123be4 <__reset+0xfb103be4>
81124f88:	04204574 	movhi	r16,33045
81124f8c:	84021504 	addi	r16,r16,2132
81124f90:	003aa606 	br	81123a2c <__reset+0xfb103a2c>
81124f94:	d9003917 	ldw	r4,228(sp)
81124f98:	04001004 	movi	r16,64
81124f9c:	800b883a 	mov	r5,r16
81124fa0:	1121be00 	call	81121be0 <_malloc_r>
81124fa4:	d9002c17 	ldw	r4,176(sp)
81124fa8:	20800015 	stw	r2,0(r4)
81124fac:	20800415 	stw	r2,16(r4)
81124fb0:	1001cb26 	beq	r2,zero,811256e0 <___svfprintf_internal_r+0x21bc>
81124fb4:	d8802c17 	ldw	r2,176(sp)
81124fb8:	14000515 	stw	r16,20(r2)
81124fbc:	00397606 	br	81123598 <__reset+0xfb103598>
81124fc0:	04204574 	movhi	r16,33045
81124fc4:	84021704 	addi	r16,r16,2140
81124fc8:	003ee106 	br	81124b50 <__reset+0xfb104b50>
81124fcc:	d9402c17 	ldw	r5,176(sp)
81124fd0:	d9801e04 	addi	r6,sp,120
81124fd4:	9809883a 	mov	r4,r19
81124fd8:	112fe5c0 	call	8112fe5c <__ssprint_r>
81124fdc:	103a381e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81124fe0:	dc402617 	ldw	r17,152(sp)
81124fe4:	d8c02017 	ldw	r3,128(sp)
81124fe8:	da000404 	addi	r8,sp,16
81124fec:	003f4306 	br	81124cfc <__reset+0xfb104cfc>
81124ff0:	01400184 	movi	r5,6
81124ff4:	d9402915 	stw	r5,164(sp)
81124ff8:	003f9506 	br	81124e50 <__reset+0xfb104e50>
81124ffc:	d9002d17 	ldw	r4,180(sp)
81125000:	25000017 	ldw	r20,0(r4)
81125004:	21000104 	addi	r4,r4,4
81125008:	d9002d15 	stw	r4,180(sp)
8112500c:	a02dd7fa 	srai	r22,r20,31
81125010:	b005883a 	mov	r2,r22
81125014:	003a9b06 	br	81123a84 <__reset+0xfb103a84>
81125018:	d9402d17 	ldw	r5,180(sp)
8112501c:	002d883a 	mov	r22,zero
81125020:	2d000017 	ldw	r20,0(r5)
81125024:	29400104 	addi	r5,r5,4
81125028:	d9402d15 	stw	r5,180(sp)
8112502c:	003bf906 	br	81124014 <__reset+0xfb104014>
81125030:	9480100c 	andi	r18,r18,64
81125034:	90006e26 	beq	r18,zero,811251f0 <___svfprintf_internal_r+0x1ccc>
81125038:	d9002d17 	ldw	r4,180(sp)
8112503c:	d9402f17 	ldw	r5,188(sp)
81125040:	20800017 	ldw	r2,0(r4)
81125044:	21000104 	addi	r4,r4,4
81125048:	d9002d15 	stw	r4,180(sp)
8112504c:	1140000d 	sth	r5,0(r2)
81125050:	00396106 	br	811235d8 <__reset+0xfb1035d8>
81125054:	d9402c17 	ldw	r5,176(sp)
81125058:	d9801e04 	addi	r6,sp,120
8112505c:	9809883a 	mov	r4,r19
81125060:	112fe5c0 	call	8112fe5c <__ssprint_r>
81125064:	103a161e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81125068:	d8c02017 	ldw	r3,128(sp)
8112506c:	d8801f17 	ldw	r2,124(sp)
81125070:	da000404 	addi	r8,sp,16
81125074:	d9403317 	ldw	r5,204(sp)
81125078:	10800044 	addi	r2,r2,1
8112507c:	44000015 	stw	r16,0(r8)
81125080:	28c7883a 	add	r3,r5,r3
81125084:	003b7706 	br	81123e64 <__reset+0xfb103e64>
81125088:	8009883a 	mov	r4,r16
8112508c:	da003e15 	stw	r8,248(sp)
81125090:	1122ee80 	call	81122ee8 <strlen>
81125094:	d8802e15 	stw	r2,184(sp)
81125098:	da003e17 	ldw	r8,248(sp)
8112509c:	103c280e 	bge	r2,zero,81124140 <__reset+0xfb104140>
811250a0:	0005883a 	mov	r2,zero
811250a4:	003c2606 	br	81124140 <__reset+0xfb104140>
811250a8:	00bfffc4 	movi	r2,-1
811250ac:	003a0906 	br	811238d4 <__reset+0xfb1038d4>
811250b0:	01204574 	movhi	r4,33045
811250b4:	21022984 	addi	r4,r4,2214
811250b8:	d9003515 	stw	r4,212(sp)
811250bc:	003b0606 	br	81123cd8 <__reset+0xfb103cd8>
811250c0:	013fffc4 	movi	r4,-1
811250c4:	003a2706 	br	81123964 <__reset+0xfb103964>
811250c8:	d9402c17 	ldw	r5,176(sp)
811250cc:	d9801e04 	addi	r6,sp,120
811250d0:	9809883a 	mov	r4,r19
811250d4:	112fe5c0 	call	8112fe5c <__ssprint_r>
811250d8:	1039f91e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
811250dc:	d8c02017 	ldw	r3,128(sp)
811250e0:	da000404 	addi	r8,sp,16
811250e4:	003d8406 	br	811246f8 <__reset+0xfb1046f8>
811250e8:	0023883a 	mov	r17,zero
811250ec:	003d8306 	br	811246fc <__reset+0xfb1046fc>
811250f0:	01204574 	movhi	r4,33045
811250f4:	21022584 	addi	r4,r4,2198
811250f8:	d9002b15 	stw	r4,172(sp)
811250fc:	d9002b17 	ldw	r4,172(sp)
81125100:	1c47883a 	add	r3,r3,r17
81125104:	10800044 	addi	r2,r2,1
81125108:	41000015 	stw	r4,0(r8)
8112510c:	44400115 	stw	r17,4(r8)
81125110:	d8c02015 	stw	r3,128(sp)
81125114:	d8801f15 	stw	r2,124(sp)
81125118:	010001c4 	movi	r4,7
8112511c:	20bfcd16 	blt	r4,r2,81125054 <__reset+0xfb105054>
81125120:	42000204 	addi	r8,r8,8
81125124:	003fd306 	br	81125074 <__reset+0xfb105074>
81125128:	d9402c17 	ldw	r5,176(sp)
8112512c:	d9801e04 	addi	r6,sp,120
81125130:	9809883a 	mov	r4,r19
81125134:	112fe5c0 	call	8112fe5c <__ssprint_r>
81125138:	1039e11e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
8112513c:	d8802617 	ldw	r2,152(sp)
81125140:	d8c02017 	ldw	r3,128(sp)
81125144:	da000404 	addi	r8,sp,16
81125148:	003e1c06 	br	811249bc <__reset+0xfb1049bc>
8112514c:	d8802917 	ldw	r2,164(sp)
81125150:	00c00184 	movi	r3,6
81125154:	1880012e 	bgeu	r3,r2,8112515c <___svfprintf_internal_r+0x1c38>
81125158:	1805883a 	mov	r2,r3
8112515c:	d8802e15 	stw	r2,184(sp)
81125160:	1000f316 	blt	r2,zero,81125530 <___svfprintf_internal_r+0x200c>
81125164:	04204574 	movhi	r16,33045
81125168:	d8802a15 	stw	r2,168(sp)
8112516c:	dd002d15 	stw	r20,180(sp)
81125170:	d8002915 	stw	zero,164(sp)
81125174:	d8003215 	stw	zero,200(sp)
81125178:	84022304 	addi	r16,r16,2188
8112517c:	0039883a 	mov	fp,zero
81125180:	003a9f06 	br	81123c00 <__reset+0xfb103c00>
81125184:	01204574 	movhi	r4,33045
81125188:	21022984 	addi	r4,r4,2214
8112518c:	d9003515 	stw	r4,212(sp)
81125190:	003b5f06 	br	81123f10 <__reset+0xfb103f10>
81125194:	d9402c17 	ldw	r5,176(sp)
81125198:	d9801e04 	addi	r6,sp,120
8112519c:	9809883a 	mov	r4,r19
811251a0:	112fe5c0 	call	8112fe5c <__ssprint_r>
811251a4:	1039c61e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
811251a8:	d8802617 	ldw	r2,152(sp)
811251ac:	d9403317 	ldw	r5,204(sp)
811251b0:	d8c02017 	ldw	r3,128(sp)
811251b4:	da000404 	addi	r8,sp,16
811251b8:	2885c83a 	sub	r2,r5,r2
811251bc:	003e1006 	br	81124a00 <__reset+0xfb104a00>
811251c0:	00800044 	movi	r2,1
811251c4:	10803fcc 	andi	r2,r2,255
811251c8:	00c00044 	movi	r3,1
811251cc:	10fa3526 	beq	r2,r3,81123aa4 <__reset+0xfb103aa4>
811251d0:	00c00084 	movi	r3,2
811251d4:	10fb9e26 	beq	r2,r3,81124050 <__reset+0xfb104050>
811251d8:	003a6406 	br	81123b6c <__reset+0xfb103b6c>
811251dc:	0021883a 	mov	r16,zero
811251e0:	003e0806 	br	81124a04 <__reset+0xfb104a04>
811251e4:	07000b44 	movi	fp,45
811251e8:	df002785 	stb	fp,158(sp)
811251ec:	003a0b06 	br	81123a1c <__reset+0xfb103a1c>
811251f0:	d8c02d17 	ldw	r3,180(sp)
811251f4:	d9002f17 	ldw	r4,188(sp)
811251f8:	18800017 	ldw	r2,0(r3)
811251fc:	18c00104 	addi	r3,r3,4
81125200:	d8c02d15 	stw	r3,180(sp)
81125204:	11000015 	stw	r4,0(r2)
81125208:	0038f306 	br	811235d8 <__reset+0xfb1035d8>
8112520c:	00c00b44 	movi	r3,45
81125210:	d8c02785 	stb	r3,158(sp)
81125214:	d8802a15 	stw	r2,168(sp)
81125218:	dc802b17 	ldw	r18,172(sp)
8112521c:	d8002915 	stw	zero,164(sp)
81125220:	07000b44 	movi	fp,45
81125224:	003a7306 	br	81123bf4 <__reset+0xfb103bf4>
81125228:	9080004c 	andi	r2,r18,1
8112522c:	1000941e 	bne	r2,zero,81125480 <___svfprintf_internal_r+0x1f5c>
81125230:	d8802117 	ldw	r2,132(sp)
81125234:	1405c83a 	sub	r2,r2,r16
81125238:	d8803315 	stw	r2,204(sp)
8112523c:	b441161e 	bne	r22,r17,81125698 <___svfprintf_internal_r+0x2174>
81125240:	dd802617 	ldw	r22,152(sp)
81125244:	00bfff44 	movi	r2,-3
81125248:	b0801a16 	blt	r22,r2,811252b4 <___svfprintf_internal_r+0x1d90>
8112524c:	d9402917 	ldw	r5,164(sp)
81125250:	2d801816 	blt	r5,r22,811252b4 <___svfprintf_internal_r+0x1d90>
81125254:	dd803215 	stw	r22,200(sp)
81125258:	003f3a06 	br	81124f44 <__reset+0xfb104f44>
8112525c:	1025883a 	mov	r18,r2
81125260:	0039883a 	mov	fp,zero
81125264:	00800084 	movi	r2,2
81125268:	003fd606 	br	811251c4 <__reset+0xfb1051c4>
8112526c:	9080004c 	andi	r2,r18,1
81125270:	103f191e 	bne	r2,zero,81124ed8 <__reset+0xfb104ed8>
81125274:	d8802117 	ldw	r2,132(sp)
81125278:	003f2806 	br	81124f1c <__reset+0xfb104f1c>
8112527c:	01204574 	movhi	r4,33045
81125280:	21022584 	addi	r4,r4,2198
81125284:	d9002b15 	stw	r4,172(sp)
81125288:	003c7c06 	br	8112447c <__reset+0xfb10447c>
8112528c:	e005883a 	mov	r2,fp
81125290:	003f2206 	br	81124f1c <__reset+0xfb104f1c>
81125294:	d9402917 	ldw	r5,164(sp)
81125298:	df002783 	ldbu	fp,158(sp)
8112529c:	dd002d15 	stw	r20,180(sp)
811252a0:	d9402a15 	stw	r5,168(sp)
811252a4:	d9402e15 	stw	r5,184(sp)
811252a8:	d8002915 	stw	zero,164(sp)
811252ac:	d8003215 	stw	zero,200(sp)
811252b0:	003a4c06 	br	81123be4 <__reset+0xfb103be4>
811252b4:	8c7fff84 	addi	r17,r17,-2
811252b8:	b5bfffc4 	addi	r22,r22,-1
811252bc:	dd802615 	stw	r22,152(sp)
811252c0:	dc4022c5 	stb	r17,139(sp)
811252c4:	b000c316 	blt	r22,zero,811255d4 <___svfprintf_internal_r+0x20b0>
811252c8:	00800ac4 	movi	r2,43
811252cc:	d8802305 	stb	r2,140(sp)
811252d0:	00800244 	movi	r2,9
811252d4:	15806e16 	blt	r2,r22,81125490 <___svfprintf_internal_r+0x1f6c>
811252d8:	00800c04 	movi	r2,48
811252dc:	b5800c04 	addi	r22,r22,48
811252e0:	d8802345 	stb	r2,141(sp)
811252e4:	dd802385 	stb	r22,142(sp)
811252e8:	d88023c4 	addi	r2,sp,143
811252ec:	df0022c4 	addi	fp,sp,139
811252f0:	d8c03317 	ldw	r3,204(sp)
811252f4:	1739c83a 	sub	fp,r2,fp
811252f8:	d9003317 	ldw	r4,204(sp)
811252fc:	e0c7883a 	add	r3,fp,r3
81125300:	df003b15 	stw	fp,236(sp)
81125304:	d8c02e15 	stw	r3,184(sp)
81125308:	00800044 	movi	r2,1
8112530c:	1100b70e 	bge	r2,r4,811255ec <___svfprintf_internal_r+0x20c8>
81125310:	d8c02e17 	ldw	r3,184(sp)
81125314:	18c00044 	addi	r3,r3,1
81125318:	d8c02e15 	stw	r3,184(sp)
8112531c:	1805883a 	mov	r2,r3
81125320:	1800b016 	blt	r3,zero,811255e4 <___svfprintf_internal_r+0x20c0>
81125324:	d8003215 	stw	zero,200(sp)
81125328:	003f1006 	br	81124f6c <__reset+0xfb104f6c>
8112532c:	d8802917 	ldw	r2,164(sp)
81125330:	103ec71e 	bne	r2,zero,81124e50 <__reset+0xfb104e50>
81125334:	dc002915 	stw	r16,164(sp)
81125338:	003ec506 	br	81124e50 <__reset+0xfb104e50>
8112533c:	d9402c17 	ldw	r5,176(sp)
81125340:	d9801e04 	addi	r6,sp,120
81125344:	9809883a 	mov	r4,r19
81125348:	112fe5c0 	call	8112fe5c <__ssprint_r>
8112534c:	10395c1e 	bne	r2,zero,811238c0 <__reset+0xfb1038c0>
81125350:	dc402617 	ldw	r17,152(sp)
81125354:	d8c02017 	ldw	r3,128(sp)
81125358:	d8801f17 	ldw	r2,124(sp)
8112535c:	da000404 	addi	r8,sp,16
81125360:	003e7706 	br	81124d40 <__reset+0xfb104d40>
81125364:	582f883a 	mov	r23,r11
81125368:	d8002915 	stw	zero,164(sp)
8112536c:	0038c406 	br	81123680 <__reset+0xfb103680>
81125370:	d8c02917 	ldw	r3,164(sp)
81125374:	d8802104 	addi	r2,sp,132
81125378:	d8800315 	stw	r2,12(sp)
8112537c:	d9403617 	ldw	r5,216(sp)
81125380:	d8802504 	addi	r2,sp,148
81125384:	d8800215 	stw	r2,8(sp)
81125388:	d8802604 	addi	r2,sp,152
8112538c:	d8c00015 	stw	r3,0(sp)
81125390:	9809883a 	mov	r4,r19
81125394:	d8800115 	stw	r2,4(sp)
81125398:	01c000c4 	movi	r7,3
8112539c:	a00d883a 	mov	r6,r20
811253a0:	da003e15 	stw	r8,248(sp)
811253a4:	11298100 	call	81129810 <_dtoa_r>
811253a8:	d9002917 	ldw	r4,164(sp)
811253ac:	da003e17 	ldw	r8,248(sp)
811253b0:	1021883a 	mov	r16,r2
811253b4:	1139883a 	add	fp,r2,r4
811253b8:	2007883a 	mov	r3,r4
811253bc:	81000007 	ldb	r4,0(r16)
811253c0:	00800c04 	movi	r2,48
811253c4:	20806f26 	beq	r4,r2,81125584 <___svfprintf_internal_r+0x2060>
811253c8:	d8c02617 	ldw	r3,152(sp)
811253cc:	e0f9883a 	add	fp,fp,r3
811253d0:	003ec206 	br	81124edc <__reset+0xfb104edc>
811253d4:	00c00b44 	movi	r3,45
811253d8:	2520003c 	xorhi	r20,r4,32768
811253dc:	d8c02a05 	stb	r3,168(sp)
811253e0:	003ea106 	br	81124e68 <__reset+0xfb104e68>
811253e4:	d8c03217 	ldw	r3,200(sp)
811253e8:	00c0890e 	bge	zero,r3,81125610 <___svfprintf_internal_r+0x20ec>
811253ec:	00800044 	movi	r2,1
811253f0:	d9003317 	ldw	r4,204(sp)
811253f4:	1105883a 	add	r2,r2,r4
811253f8:	d8802e15 	stw	r2,184(sp)
811253fc:	10005f16 	blt	r2,zero,8112557c <___svfprintf_internal_r+0x2058>
81125400:	044019c4 	movi	r17,103
81125404:	003ed906 	br	81124f6c <__reset+0xfb104f6c>
81125408:	d9002917 	ldw	r4,164(sp)
8112540c:	20c00044 	addi	r3,r4,1
81125410:	003e9c06 	br	81124e84 <__reset+0xfb104e84>
81125414:	d9002917 	ldw	r4,164(sp)
81125418:	00c0680e 	bge	zero,r3,811255bc <___svfprintf_internal_r+0x2098>
8112541c:	2000461e 	bne	r4,zero,81125538 <___svfprintf_internal_r+0x2014>
81125420:	9480004c 	andi	r18,r18,1
81125424:	9000441e 	bne	r18,zero,81125538 <___svfprintf_internal_r+0x2014>
81125428:	1805883a 	mov	r2,r3
8112542c:	1800a016 	blt	r3,zero,811256b0 <___svfprintf_internal_r+0x218c>
81125430:	d8c03217 	ldw	r3,200(sp)
81125434:	d8c02e15 	stw	r3,184(sp)
81125438:	003ecc06 	br	81124f6c <__reset+0xfb104f6c>
8112543c:	d9402917 	ldw	r5,164(sp)
81125440:	d8802104 	addi	r2,sp,132
81125444:	d8800315 	stw	r2,12(sp)
81125448:	d9400015 	stw	r5,0(sp)
8112544c:	d8802504 	addi	r2,sp,148
81125450:	d9403617 	ldw	r5,216(sp)
81125454:	d8800215 	stw	r2,8(sp)
81125458:	d8802604 	addi	r2,sp,152
8112545c:	d8800115 	stw	r2,4(sp)
81125460:	01c000c4 	movi	r7,3
81125464:	a00d883a 	mov	r6,r20
81125468:	9809883a 	mov	r4,r19
8112546c:	da003e15 	stw	r8,248(sp)
81125470:	11298100 	call	81129810 <_dtoa_r>
81125474:	d8c02917 	ldw	r3,164(sp)
81125478:	da003e17 	ldw	r8,248(sp)
8112547c:	1021883a 	mov	r16,r2
81125480:	00801184 	movi	r2,70
81125484:	80f9883a 	add	fp,r16,r3
81125488:	88bfcc26 	beq	r17,r2,811253bc <__reset+0xfb1053bc>
8112548c:	003e9306 	br	81124edc <__reset+0xfb104edc>
81125490:	df0022c4 	addi	fp,sp,139
81125494:	dc002915 	stw	r16,164(sp)
81125498:	9829883a 	mov	r20,r19
8112549c:	e021883a 	mov	r16,fp
811254a0:	4027883a 	mov	r19,r8
811254a4:	b009883a 	mov	r4,r22
811254a8:	01400284 	movi	r5,10
811254ac:	11349080 	call	81134908 <__modsi3>
811254b0:	10800c04 	addi	r2,r2,48
811254b4:	843fffc4 	addi	r16,r16,-1
811254b8:	b009883a 	mov	r4,r22
811254bc:	01400284 	movi	r5,10
811254c0:	80800005 	stb	r2,0(r16)
811254c4:	11348840 	call	81134884 <__divsi3>
811254c8:	102d883a 	mov	r22,r2
811254cc:	00800244 	movi	r2,9
811254d0:	15bff416 	blt	r2,r22,811254a4 <__reset+0xfb1054a4>
811254d4:	9811883a 	mov	r8,r19
811254d8:	b0800c04 	addi	r2,r22,48
811254dc:	a027883a 	mov	r19,r20
811254e0:	8029883a 	mov	r20,r16
811254e4:	a17fffc4 	addi	r5,r20,-1
811254e8:	a0bfffc5 	stb	r2,-1(r20)
811254ec:	dc002917 	ldw	r16,164(sp)
811254f0:	2f00752e 	bgeu	r5,fp,811256c8 <___svfprintf_internal_r+0x21a4>
811254f4:	d9c02384 	addi	r7,sp,142
811254f8:	3d0fc83a 	sub	r7,r7,r20
811254fc:	d9002344 	addi	r4,sp,141
81125500:	e1cf883a 	add	r7,fp,r7
81125504:	00000106 	br	8112550c <___svfprintf_internal_r+0x1fe8>
81125508:	28800003 	ldbu	r2,0(r5)
8112550c:	20800005 	stb	r2,0(r4)
81125510:	21000044 	addi	r4,r4,1
81125514:	29400044 	addi	r5,r5,1
81125518:	21fffb1e 	bne	r4,r7,81125508 <__reset+0xfb105508>
8112551c:	d8802304 	addi	r2,sp,140
81125520:	1505c83a 	sub	r2,r2,r20
81125524:	d8c02344 	addi	r3,sp,141
81125528:	1885883a 	add	r2,r3,r2
8112552c:	003f7006 	br	811252f0 <__reset+0xfb1052f0>
81125530:	0005883a 	mov	r2,zero
81125534:	003f0b06 	br	81125164 <__reset+0xfb105164>
81125538:	d9002917 	ldw	r4,164(sp)
8112553c:	d8c03217 	ldw	r3,200(sp)
81125540:	20800044 	addi	r2,r4,1
81125544:	1885883a 	add	r2,r3,r2
81125548:	d8802e15 	stw	r2,184(sp)
8112554c:	103e870e 	bge	r2,zero,81124f6c <__reset+0xfb104f6c>
81125550:	0005883a 	mov	r2,zero
81125554:	003e8506 	br	81124f6c <__reset+0xfb104f6c>
81125558:	01204574 	movhi	r4,33045
8112555c:	21022584 	addi	r4,r4,2198
81125560:	d9002b15 	stw	r4,172(sp)
81125564:	003cc506 	br	8112487c <__reset+0xfb10487c>
81125568:	d8c03217 	ldw	r3,200(sp)
8112556c:	18c00044 	addi	r3,r3,1
81125570:	d8c02e15 	stw	r3,184(sp)
81125574:	1805883a 	mov	r2,r3
81125578:	183fa10e 	bge	r3,zero,81125400 <__reset+0xfb105400>
8112557c:	0005883a 	mov	r2,zero
81125580:	003f9f06 	br	81125400 <__reset+0xfb105400>
81125584:	d9003617 	ldw	r4,216(sp)
81125588:	000d883a 	mov	r6,zero
8112558c:	000f883a 	mov	r7,zero
81125590:	a00b883a 	mov	r5,r20
81125594:	d8c03d15 	stw	r3,244(sp)
81125598:	da003e15 	stw	r8,248(sp)
8112559c:	1135dd80 	call	81135dd8 <__eqdf2>
811255a0:	d8c03d17 	ldw	r3,244(sp)
811255a4:	da003e17 	ldw	r8,248(sp)
811255a8:	103f8726 	beq	r2,zero,811253c8 <__reset+0xfb1053c8>
811255ac:	00800044 	movi	r2,1
811255b0:	10c7c83a 	sub	r3,r2,r3
811255b4:	d8c02615 	stw	r3,152(sp)
811255b8:	003f8406 	br	811253cc <__reset+0xfb1053cc>
811255bc:	20000e1e 	bne	r4,zero,811255f8 <___svfprintf_internal_r+0x20d4>
811255c0:	9480004c 	andi	r18,r18,1
811255c4:	90000c1e 	bne	r18,zero,811255f8 <___svfprintf_internal_r+0x20d4>
811255c8:	00800044 	movi	r2,1
811255cc:	d8802e15 	stw	r2,184(sp)
811255d0:	003e6606 	br	81124f6c <__reset+0xfb104f6c>
811255d4:	00800b44 	movi	r2,45
811255d8:	05adc83a 	sub	r22,zero,r22
811255dc:	d8802305 	stb	r2,140(sp)
811255e0:	003f3b06 	br	811252d0 <__reset+0xfb1052d0>
811255e4:	0005883a 	mov	r2,zero
811255e8:	003f4e06 	br	81125324 <__reset+0xfb105324>
811255ec:	90a4703a 	and	r18,r18,r2
811255f0:	903f4a26 	beq	r18,zero,8112531c <__reset+0xfb10531c>
811255f4:	003f4606 	br	81125310 <__reset+0xfb105310>
811255f8:	d8c02917 	ldw	r3,164(sp)
811255fc:	18c00084 	addi	r3,r3,2
81125600:	d8c02e15 	stw	r3,184(sp)
81125604:	1805883a 	mov	r2,r3
81125608:	183e580e 	bge	r3,zero,81124f6c <__reset+0xfb104f6c>
8112560c:	003fd006 	br	81125550 <__reset+0xfb105550>
81125610:	00800084 	movi	r2,2
81125614:	10c5c83a 	sub	r2,r2,r3
81125618:	003f7506 	br	811253f0 <__reset+0xfb1053f0>
8112561c:	d8802d17 	ldw	r2,180(sp)
81125620:	d9002d17 	ldw	r4,180(sp)
81125624:	bc400043 	ldbu	r17,1(r23)
81125628:	10800017 	ldw	r2,0(r2)
8112562c:	582f883a 	mov	r23,r11
81125630:	d8802915 	stw	r2,164(sp)
81125634:	20800104 	addi	r2,r4,4
81125638:	d9002917 	ldw	r4,164(sp)
8112563c:	d8802d15 	stw	r2,180(sp)
81125640:	203df00e 	bge	r4,zero,81124e04 <__reset+0xfb104e04>
81125644:	8c403fcc 	andi	r17,r17,255
81125648:	00bfffc4 	movi	r2,-1
8112564c:	8c40201c 	xori	r17,r17,128
81125650:	d8802915 	stw	r2,164(sp)
81125654:	8c7fe004 	addi	r17,r17,-128
81125658:	00380806 	br	8112367c <__reset+0xfb10367c>
8112565c:	9080004c 	andi	r2,r18,1
81125660:	0039883a 	mov	fp,zero
81125664:	10000726 	beq	r2,zero,81125684 <___svfprintf_internal_r+0x2160>
81125668:	d8c02817 	ldw	r3,160(sp)
8112566c:	dc001dc4 	addi	r16,sp,119
81125670:	00800c04 	movi	r2,48
81125674:	1c07c83a 	sub	r3,r3,r16
81125678:	d8801dc5 	stb	r2,119(sp)
8112567c:	d8c02e15 	stw	r3,184(sp)
81125680:	00395206 	br	81123bcc <__reset+0xfb103bcc>
81125684:	d8002e15 	stw	zero,184(sp)
81125688:	dc001e04 	addi	r16,sp,120
8112568c:	00394f06 	br	81123bcc <__reset+0xfb103bcc>
81125690:	0005883a 	mov	r2,zero
81125694:	003e3206 	br	81124f60 <__reset+0xfb104f60>
81125698:	dd802617 	ldw	r22,152(sp)
8112569c:	003f0606 	br	811252b8 <__reset+0xfb1052b8>
811256a0:	d9c02785 	stb	r7,158(sp)
811256a4:	003a5106 	br	81123fec <__reset+0xfb103fec>
811256a8:	d9c02785 	stb	r7,158(sp)
811256ac:	003a3706 	br	81123f8c <__reset+0xfb103f8c>
811256b0:	0005883a 	mov	r2,zero
811256b4:	003f5e06 	br	81125430 <__reset+0xfb105430>
811256b8:	d9c02785 	stb	r7,158(sp)
811256bc:	00391706 	br	81123b1c <__reset+0xfb103b1c>
811256c0:	d9c02785 	stb	r7,158(sp)
811256c4:	0038e606 	br	81123a60 <__reset+0xfb103a60>
811256c8:	d8802344 	addi	r2,sp,141
811256cc:	003f0806 	br	811252f0 <__reset+0xfb1052f0>
811256d0:	d9c02785 	stb	r7,158(sp)
811256d4:	0038b706 	br	811239b4 <__reset+0xfb1039b4>
811256d8:	d9c02785 	stb	r7,158(sp)
811256dc:	003adc06 	br	81124250 <__reset+0xfb104250>
811256e0:	d9403917 	ldw	r5,228(sp)
811256e4:	00800304 	movi	r2,12
811256e8:	28800015 	stw	r2,0(r5)
811256ec:	00bfffc4 	movi	r2,-1
811256f0:	00387806 	br	811238d4 <__reset+0xfb1038d4>
811256f4:	d9c02785 	stb	r7,158(sp)
811256f8:	003abf06 	br	811241f8 <__reset+0xfb1041f8>
811256fc:	d9c02785 	stb	r7,158(sp)
81125700:	003a9b06 	br	81124170 <__reset+0xfb104170>

81125704 <___vfprintf_internal_r>:
81125704:	deffb804 	addi	sp,sp,-288
81125708:	de00012e 	bgeu	sp,et,81125710 <___vfprintf_internal_r+0xc>
8112570c:	003b68fa 	trap	3
81125710:	dfc04715 	stw	ra,284(sp)
81125714:	ddc04515 	stw	r23,276(sp)
81125718:	dd404315 	stw	r21,268(sp)
8112571c:	d9002c15 	stw	r4,176(sp)
81125720:	282f883a 	mov	r23,r5
81125724:	302b883a 	mov	r21,r6
81125728:	d9c02d15 	stw	r7,180(sp)
8112572c:	df004615 	stw	fp,280(sp)
81125730:	dd804415 	stw	r22,272(sp)
81125734:	dd004215 	stw	r20,264(sp)
81125738:	dcc04115 	stw	r19,260(sp)
8112573c:	dc804015 	stw	r18,256(sp)
81125740:	dc403f15 	stw	r17,252(sp)
81125744:	dc003e15 	stw	r16,248(sp)
81125748:	112c40c0 	call	8112c40c <_localeconv_r>
8112574c:	10800017 	ldw	r2,0(r2)
81125750:	1009883a 	mov	r4,r2
81125754:	d8803415 	stw	r2,208(sp)
81125758:	1122ee80 	call	81122ee8 <strlen>
8112575c:	d8803715 	stw	r2,220(sp)
81125760:	d8802c17 	ldw	r2,176(sp)
81125764:	10000226 	beq	r2,zero,81125770 <___vfprintf_internal_r+0x6c>
81125768:	10800e17 	ldw	r2,56(r2)
8112576c:	1000f926 	beq	r2,zero,81125b54 <___vfprintf_internal_r+0x450>
81125770:	b880030b 	ldhu	r2,12(r23)
81125774:	10c8000c 	andi	r3,r2,8192
81125778:	1800061e 	bne	r3,zero,81125794 <___vfprintf_internal_r+0x90>
8112577c:	b9001917 	ldw	r4,100(r23)
81125780:	00f7ffc4 	movi	r3,-8193
81125784:	10880014 	ori	r2,r2,8192
81125788:	20c6703a 	and	r3,r4,r3
8112578c:	b880030d 	sth	r2,12(r23)
81125790:	b8c01915 	stw	r3,100(r23)
81125794:	10c0020c 	andi	r3,r2,8
81125798:	1800c126 	beq	r3,zero,81125aa0 <___vfprintf_internal_r+0x39c>
8112579c:	b8c00417 	ldw	r3,16(r23)
811257a0:	1800bf26 	beq	r3,zero,81125aa0 <___vfprintf_internal_r+0x39c>
811257a4:	1080068c 	andi	r2,r2,26
811257a8:	00c00284 	movi	r3,10
811257ac:	10c0c426 	beq	r2,r3,81125ac0 <___vfprintf_internal_r+0x3bc>
811257b0:	d8c00404 	addi	r3,sp,16
811257b4:	05204574 	movhi	r20,33045
811257b8:	d9001e04 	addi	r4,sp,120
811257bc:	a5022d84 	addi	r20,r20,2230
811257c0:	d8c01e15 	stw	r3,120(sp)
811257c4:	d8002015 	stw	zero,128(sp)
811257c8:	d8001f15 	stw	zero,124(sp)
811257cc:	d8003315 	stw	zero,204(sp)
811257d0:	d8003615 	stw	zero,216(sp)
811257d4:	d8003815 	stw	zero,224(sp)
811257d8:	1811883a 	mov	r8,r3
811257dc:	d8003915 	stw	zero,228(sp)
811257e0:	d8003a15 	stw	zero,232(sp)
811257e4:	d8002f15 	stw	zero,188(sp)
811257e8:	d9002815 	stw	r4,160(sp)
811257ec:	a8800007 	ldb	r2,0(r21)
811257f0:	10027b26 	beq	r2,zero,811261e0 <___vfprintf_internal_r+0xadc>
811257f4:	00c00944 	movi	r3,37
811257f8:	a821883a 	mov	r16,r21
811257fc:	10c0021e 	bne	r2,r3,81125808 <___vfprintf_internal_r+0x104>
81125800:	00001406 	br	81125854 <___vfprintf_internal_r+0x150>
81125804:	10c00326 	beq	r2,r3,81125814 <___vfprintf_internal_r+0x110>
81125808:	84000044 	addi	r16,r16,1
8112580c:	80800007 	ldb	r2,0(r16)
81125810:	103ffc1e 	bne	r2,zero,81125804 <__reset+0xfb105804>
81125814:	8563c83a 	sub	r17,r16,r21
81125818:	88000e26 	beq	r17,zero,81125854 <___vfprintf_internal_r+0x150>
8112581c:	d8c02017 	ldw	r3,128(sp)
81125820:	d8801f17 	ldw	r2,124(sp)
81125824:	45400015 	stw	r21,0(r8)
81125828:	1c47883a 	add	r3,r3,r17
8112582c:	10800044 	addi	r2,r2,1
81125830:	d8c02015 	stw	r3,128(sp)
81125834:	44400115 	stw	r17,4(r8)
81125838:	d8801f15 	stw	r2,124(sp)
8112583c:	00c001c4 	movi	r3,7
81125840:	1880a716 	blt	r3,r2,81125ae0 <___vfprintf_internal_r+0x3dc>
81125844:	42000204 	addi	r8,r8,8
81125848:	d9402f17 	ldw	r5,188(sp)
8112584c:	2c4b883a 	add	r5,r5,r17
81125850:	d9402f15 	stw	r5,188(sp)
81125854:	80800007 	ldb	r2,0(r16)
81125858:	1000a826 	beq	r2,zero,81125afc <___vfprintf_internal_r+0x3f8>
8112585c:	84400047 	ldb	r17,1(r16)
81125860:	00bfffc4 	movi	r2,-1
81125864:	85400044 	addi	r21,r16,1
81125868:	d8002785 	stb	zero,158(sp)
8112586c:	0007883a 	mov	r3,zero
81125870:	000f883a 	mov	r7,zero
81125874:	d8802915 	stw	r2,164(sp)
81125878:	d8003115 	stw	zero,196(sp)
8112587c:	0025883a 	mov	r18,zero
81125880:	01401604 	movi	r5,88
81125884:	01800244 	movi	r6,9
81125888:	02800a84 	movi	r10,42
8112588c:	02401b04 	movi	r9,108
81125890:	ad400044 	addi	r21,r21,1
81125894:	88bff804 	addi	r2,r17,-32
81125898:	28830436 	bltu	r5,r2,811264ac <___vfprintf_internal_r+0xda8>
8112589c:	100490ba 	slli	r2,r2,2
811258a0:	012044b4 	movhi	r4,33042
811258a4:	21162d04 	addi	r4,r4,22708
811258a8:	1105883a 	add	r2,r2,r4
811258ac:	10800017 	ldw	r2,0(r2)
811258b0:	1000683a 	jmp	r2
811258b4:	811263cc 	andi	r4,r16,18831
811258b8:	811264ac 	andhi	r4,r16,18834
811258bc:	811264ac 	andhi	r4,r16,18834
811258c0:	811263ec 	andhi	r4,r16,18831
811258c4:	811264ac 	andhi	r4,r16,18834
811258c8:	811264ac 	andhi	r4,r16,18834
811258cc:	811264ac 	andhi	r4,r16,18834
811258d0:	811264ac 	andhi	r4,r16,18834
811258d4:	811264ac 	andhi	r4,r16,18834
811258d8:	811264ac 	andhi	r4,r16,18834
811258dc:	81125b60 	cmpeqi	r4,r16,18797
811258e0:	81126308 	cmpgei	r4,r16,18828
811258e4:	811264ac 	andhi	r4,r16,18834
811258e8:	81125a28 	cmpgeui	r4,r16,18792
811258ec:	81125b88 	cmpgei	r4,r16,18798
811258f0:	811264ac 	andhi	r4,r16,18834
811258f4:	81125bc8 	cmpgei	r4,r16,18799
811258f8:	81125bd4 	ori	r4,r16,18799
811258fc:	81125bd4 	ori	r4,r16,18799
81125900:	81125bd4 	ori	r4,r16,18799
81125904:	81125bd4 	ori	r4,r16,18799
81125908:	81125bd4 	ori	r4,r16,18799
8112590c:	81125bd4 	ori	r4,r16,18799
81125910:	81125bd4 	ori	r4,r16,18799
81125914:	81125bd4 	ori	r4,r16,18799
81125918:	81125bd4 	ori	r4,r16,18799
8112591c:	811264ac 	andhi	r4,r16,18834
81125920:	811264ac 	andhi	r4,r16,18834
81125924:	811264ac 	andhi	r4,r16,18834
81125928:	811264ac 	andhi	r4,r16,18834
8112592c:	811264ac 	andhi	r4,r16,18834
81125930:	811264ac 	andhi	r4,r16,18834
81125934:	811264ac 	andhi	r4,r16,18834
81125938:	811264ac 	andhi	r4,r16,18834
8112593c:	811264ac 	andhi	r4,r16,18834
81125940:	811264ac 	andhi	r4,r16,18834
81125944:	81125c08 	cmpgei	r4,r16,18800
81125948:	81125cc4 	addi	r4,r16,18803
8112594c:	811264ac 	andhi	r4,r16,18834
81125950:	81125cc4 	addi	r4,r16,18803
81125954:	811264ac 	andhi	r4,r16,18834
81125958:	811264ac 	andhi	r4,r16,18834
8112595c:	811264ac 	andhi	r4,r16,18834
81125960:	811264ac 	andhi	r4,r16,18834
81125964:	81125d64 	muli	r4,r16,18805
81125968:	811264ac 	andhi	r4,r16,18834
8112596c:	811264ac 	andhi	r4,r16,18834
81125970:	81125d70 	cmpltui	r4,r16,18805
81125974:	811264ac 	andhi	r4,r16,18834
81125978:	811264ac 	andhi	r4,r16,18834
8112597c:	811264ac 	andhi	r4,r16,18834
81125980:	811264ac 	andhi	r4,r16,18834
81125984:	811264ac 	andhi	r4,r16,18834
81125988:	811261e8 	cmpgeui	r4,r16,18823
8112598c:	811264ac 	andhi	r4,r16,18834
81125990:	811264ac 	andhi	r4,r16,18834
81125994:	81126248 	cmpgei	r4,r16,18825
81125998:	811264ac 	andhi	r4,r16,18834
8112599c:	811264ac 	andhi	r4,r16,18834
811259a0:	811264ac 	andhi	r4,r16,18834
811259a4:	811264ac 	andhi	r4,r16,18834
811259a8:	811264ac 	andhi	r4,r16,18834
811259ac:	811264ac 	andhi	r4,r16,18834
811259b0:	811264ac 	andhi	r4,r16,18834
811259b4:	811264ac 	andhi	r4,r16,18834
811259b8:	811264ac 	andhi	r4,r16,18834
811259bc:	811264ac 	andhi	r4,r16,18834
811259c0:	81126458 	cmpnei	r4,r16,18833
811259c4:	811263f8 	rdprs	r4,r16,18831
811259c8:	81125cc4 	addi	r4,r16,18803
811259cc:	81125cc4 	addi	r4,r16,18803
811259d0:	81125cc4 	addi	r4,r16,18803
811259d4:	81126408 	cmpgei	r4,r16,18832
811259d8:	811263f8 	rdprs	r4,r16,18831
811259dc:	811264ac 	andhi	r4,r16,18834
811259e0:	811264ac 	andhi	r4,r16,18834
811259e4:	81126414 	ori	r4,r16,18832
811259e8:	811264ac 	andhi	r4,r16,18834
811259ec:	81126424 	muli	r4,r16,18832
811259f0:	811262f8 	rdprs	r4,r16,18827
811259f4:	81125a34 	orhi	r4,r16,18792
811259f8:	81126318 	cmpnei	r4,r16,18828
811259fc:	811264ac 	andhi	r4,r16,18834
81125a00:	81126324 	muli	r4,r16,18828
81125a04:	811264ac 	andhi	r4,r16,18834
81125a08:	81126380 	call	88112638 <__reset+0x20f2638>
81125a0c:	811264ac 	andhi	r4,r16,18834
81125a10:	811264ac 	andhi	r4,r16,18834
81125a14:	81126390 	cmplti	r4,r16,18830
81125a18:	d9003117 	ldw	r4,196(sp)
81125a1c:	d8802d15 	stw	r2,180(sp)
81125a20:	0109c83a 	sub	r4,zero,r4
81125a24:	d9003115 	stw	r4,196(sp)
81125a28:	94800114 	ori	r18,r18,4
81125a2c:	ac400007 	ldb	r17,0(r21)
81125a30:	003f9706 	br	81125890 <__reset+0xfb105890>
81125a34:	00800c04 	movi	r2,48
81125a38:	d9002d17 	ldw	r4,180(sp)
81125a3c:	d9402917 	ldw	r5,164(sp)
81125a40:	d8802705 	stb	r2,156(sp)
81125a44:	00801e04 	movi	r2,120
81125a48:	d8802745 	stb	r2,157(sp)
81125a4c:	d8002785 	stb	zero,158(sp)
81125a50:	20c00104 	addi	r3,r4,4
81125a54:	24c00017 	ldw	r19,0(r4)
81125a58:	002d883a 	mov	r22,zero
81125a5c:	90800094 	ori	r2,r18,2
81125a60:	28029a16 	blt	r5,zero,811264cc <___vfprintf_internal_r+0xdc8>
81125a64:	00bfdfc4 	movi	r2,-129
81125a68:	90a4703a 	and	r18,r18,r2
81125a6c:	d8c02d15 	stw	r3,180(sp)
81125a70:	94800094 	ori	r18,r18,2
81125a74:	9802871e 	bne	r19,zero,81126494 <___vfprintf_internal_r+0xd90>
81125a78:	00a04574 	movhi	r2,33045
81125a7c:	10821e04 	addi	r2,r2,2168
81125a80:	d8803915 	stw	r2,228(sp)
81125a84:	04401e04 	movi	r17,120
81125a88:	d8802917 	ldw	r2,164(sp)
81125a8c:	0039883a 	mov	fp,zero
81125a90:	1001e926 	beq	r2,zero,81126238 <___vfprintf_internal_r+0xb34>
81125a94:	0027883a 	mov	r19,zero
81125a98:	002d883a 	mov	r22,zero
81125a9c:	00020506 	br	811262b4 <___vfprintf_internal_r+0xbb0>
81125aa0:	d9002c17 	ldw	r4,176(sp)
81125aa4:	b80b883a 	mov	r5,r23
81125aa8:	11294500 	call	81129450 <__swsetup_r>
81125aac:	1005ac1e 	bne	r2,zero,81127160 <___vfprintf_internal_r+0x1a5c>
81125ab0:	b880030b 	ldhu	r2,12(r23)
81125ab4:	00c00284 	movi	r3,10
81125ab8:	1080068c 	andi	r2,r2,26
81125abc:	10ff3c1e 	bne	r2,r3,811257b0 <__reset+0xfb1057b0>
81125ac0:	b880038f 	ldh	r2,14(r23)
81125ac4:	103f3a16 	blt	r2,zero,811257b0 <__reset+0xfb1057b0>
81125ac8:	d9c02d17 	ldw	r7,180(sp)
81125acc:	d9002c17 	ldw	r4,176(sp)
81125ad0:	a80d883a 	mov	r6,r21
81125ad4:	b80b883a 	mov	r5,r23
81125ad8:	11279200 	call	81127920 <__sbprintf>
81125adc:	00001106 	br	81125b24 <___vfprintf_internal_r+0x420>
81125ae0:	d9002c17 	ldw	r4,176(sp)
81125ae4:	d9801e04 	addi	r6,sp,120
81125ae8:	b80b883a 	mov	r5,r23
81125aec:	113160c0 	call	8113160c <__sprint_r>
81125af0:	1000081e 	bne	r2,zero,81125b14 <___vfprintf_internal_r+0x410>
81125af4:	da000404 	addi	r8,sp,16
81125af8:	003f5306 	br	81125848 <__reset+0xfb105848>
81125afc:	d8802017 	ldw	r2,128(sp)
81125b00:	10000426 	beq	r2,zero,81125b14 <___vfprintf_internal_r+0x410>
81125b04:	d9002c17 	ldw	r4,176(sp)
81125b08:	d9801e04 	addi	r6,sp,120
81125b0c:	b80b883a 	mov	r5,r23
81125b10:	113160c0 	call	8113160c <__sprint_r>
81125b14:	b880030b 	ldhu	r2,12(r23)
81125b18:	1080100c 	andi	r2,r2,64
81125b1c:	1005901e 	bne	r2,zero,81127160 <___vfprintf_internal_r+0x1a5c>
81125b20:	d8802f17 	ldw	r2,188(sp)
81125b24:	dfc04717 	ldw	ra,284(sp)
81125b28:	df004617 	ldw	fp,280(sp)
81125b2c:	ddc04517 	ldw	r23,276(sp)
81125b30:	dd804417 	ldw	r22,272(sp)
81125b34:	dd404317 	ldw	r21,268(sp)
81125b38:	dd004217 	ldw	r20,264(sp)
81125b3c:	dcc04117 	ldw	r19,260(sp)
81125b40:	dc804017 	ldw	r18,256(sp)
81125b44:	dc403f17 	ldw	r17,252(sp)
81125b48:	dc003e17 	ldw	r16,248(sp)
81125b4c:	dec04804 	addi	sp,sp,288
81125b50:	f800283a 	ret
81125b54:	d9002c17 	ldw	r4,176(sp)
81125b58:	112b4c00 	call	8112b4c0 <__sinit>
81125b5c:	003f0406 	br	81125770 <__reset+0xfb105770>
81125b60:	d8802d17 	ldw	r2,180(sp)
81125b64:	d9002d17 	ldw	r4,180(sp)
81125b68:	10800017 	ldw	r2,0(r2)
81125b6c:	d8803115 	stw	r2,196(sp)
81125b70:	20800104 	addi	r2,r4,4
81125b74:	d9003117 	ldw	r4,196(sp)
81125b78:	203fa716 	blt	r4,zero,81125a18 <__reset+0xfb105a18>
81125b7c:	d8802d15 	stw	r2,180(sp)
81125b80:	ac400007 	ldb	r17,0(r21)
81125b84:	003f4206 	br	81125890 <__reset+0xfb105890>
81125b88:	ac400007 	ldb	r17,0(r21)
81125b8c:	aac00044 	addi	r11,r21,1
81125b90:	8a872826 	beq	r17,r10,81127834 <___vfprintf_internal_r+0x2130>
81125b94:	88bff404 	addi	r2,r17,-48
81125b98:	0009883a 	mov	r4,zero
81125b9c:	30867d36 	bltu	r6,r2,81127594 <___vfprintf_internal_r+0x1e90>
81125ba0:	5c400007 	ldb	r17,0(r11)
81125ba4:	210002a4 	muli	r4,r4,10
81125ba8:	5d400044 	addi	r21,r11,1
81125bac:	a817883a 	mov	r11,r21
81125bb0:	2089883a 	add	r4,r4,r2
81125bb4:	88bff404 	addi	r2,r17,-48
81125bb8:	30bff92e 	bgeu	r6,r2,81125ba0 <__reset+0xfb105ba0>
81125bbc:	2005c916 	blt	r4,zero,811272e4 <___vfprintf_internal_r+0x1be0>
81125bc0:	d9002915 	stw	r4,164(sp)
81125bc4:	003f3306 	br	81125894 <__reset+0xfb105894>
81125bc8:	94802014 	ori	r18,r18,128
81125bcc:	ac400007 	ldb	r17,0(r21)
81125bd0:	003f2f06 	br	81125890 <__reset+0xfb105890>
81125bd4:	a809883a 	mov	r4,r21
81125bd8:	d8003115 	stw	zero,196(sp)
81125bdc:	88bff404 	addi	r2,r17,-48
81125be0:	0017883a 	mov	r11,zero
81125be4:	24400007 	ldb	r17,0(r4)
81125be8:	5ac002a4 	muli	r11,r11,10
81125bec:	ad400044 	addi	r21,r21,1
81125bf0:	a809883a 	mov	r4,r21
81125bf4:	12d7883a 	add	r11,r2,r11
81125bf8:	88bff404 	addi	r2,r17,-48
81125bfc:	30bff92e 	bgeu	r6,r2,81125be4 <__reset+0xfb105be4>
81125c00:	dac03115 	stw	r11,196(sp)
81125c04:	003f2306 	br	81125894 <__reset+0xfb105894>
81125c08:	18c03fcc 	andi	r3,r3,255
81125c0c:	18072b1e 	bne	r3,zero,811278bc <___vfprintf_internal_r+0x21b8>
81125c10:	94800414 	ori	r18,r18,16
81125c14:	9080080c 	andi	r2,r18,32
81125c18:	10037b26 	beq	r2,zero,81126a08 <___vfprintf_internal_r+0x1304>
81125c1c:	d9402d17 	ldw	r5,180(sp)
81125c20:	28800117 	ldw	r2,4(r5)
81125c24:	2cc00017 	ldw	r19,0(r5)
81125c28:	29400204 	addi	r5,r5,8
81125c2c:	d9402d15 	stw	r5,180(sp)
81125c30:	102d883a 	mov	r22,r2
81125c34:	10044b16 	blt	r2,zero,81126d64 <___vfprintf_internal_r+0x1660>
81125c38:	d9402917 	ldw	r5,164(sp)
81125c3c:	df002783 	ldbu	fp,158(sp)
81125c40:	2803bc16 	blt	r5,zero,81126b34 <___vfprintf_internal_r+0x1430>
81125c44:	00ffdfc4 	movi	r3,-129
81125c48:	9d84b03a 	or	r2,r19,r22
81125c4c:	90e4703a 	and	r18,r18,r3
81125c50:	10017726 	beq	r2,zero,81126230 <___vfprintf_internal_r+0xb2c>
81125c54:	b0038326 	beq	r22,zero,81126a64 <___vfprintf_internal_r+0x1360>
81125c58:	dc402a15 	stw	r17,168(sp)
81125c5c:	dc001e04 	addi	r16,sp,120
81125c60:	b023883a 	mov	r17,r22
81125c64:	402d883a 	mov	r22,r8
81125c68:	9809883a 	mov	r4,r19
81125c6c:	880b883a 	mov	r5,r17
81125c70:	01800284 	movi	r6,10
81125c74:	000f883a 	mov	r7,zero
81125c78:	11343440 	call	81134344 <__umoddi3>
81125c7c:	10800c04 	addi	r2,r2,48
81125c80:	843fffc4 	addi	r16,r16,-1
81125c84:	9809883a 	mov	r4,r19
81125c88:	880b883a 	mov	r5,r17
81125c8c:	80800005 	stb	r2,0(r16)
81125c90:	01800284 	movi	r6,10
81125c94:	000f883a 	mov	r7,zero
81125c98:	1133dc40 	call	81133dc4 <__udivdi3>
81125c9c:	1027883a 	mov	r19,r2
81125ca0:	10c4b03a 	or	r2,r2,r3
81125ca4:	1823883a 	mov	r17,r3
81125ca8:	103fef1e 	bne	r2,zero,81125c68 <__reset+0xfb105c68>
81125cac:	d8c02817 	ldw	r3,160(sp)
81125cb0:	dc402a17 	ldw	r17,168(sp)
81125cb4:	b011883a 	mov	r8,r22
81125cb8:	1c07c83a 	sub	r3,r3,r16
81125cbc:	d8c02e15 	stw	r3,184(sp)
81125cc0:	00005906 	br	81125e28 <___vfprintf_internal_r+0x724>
81125cc4:	18c03fcc 	andi	r3,r3,255
81125cc8:	1806fa1e 	bne	r3,zero,811278b4 <___vfprintf_internal_r+0x21b0>
81125ccc:	9080020c 	andi	r2,r18,8
81125cd0:	10048a26 	beq	r2,zero,81126efc <___vfprintf_internal_r+0x17f8>
81125cd4:	d8c02d17 	ldw	r3,180(sp)
81125cd8:	d9002d17 	ldw	r4,180(sp)
81125cdc:	d9402d17 	ldw	r5,180(sp)
81125ce0:	18c00017 	ldw	r3,0(r3)
81125ce4:	21000117 	ldw	r4,4(r4)
81125ce8:	29400204 	addi	r5,r5,8
81125cec:	d8c03615 	stw	r3,216(sp)
81125cf0:	d9003815 	stw	r4,224(sp)
81125cf4:	d9402d15 	stw	r5,180(sp)
81125cf8:	d9003617 	ldw	r4,216(sp)
81125cfc:	d9403817 	ldw	r5,224(sp)
81125d00:	da003d15 	stw	r8,244(sp)
81125d04:	04000044 	movi	r16,1
81125d08:	112df580 	call	8112df58 <__fpclassifyd>
81125d0c:	da003d17 	ldw	r8,244(sp)
81125d10:	14041f1e 	bne	r2,r16,81126d90 <___vfprintf_internal_r+0x168c>
81125d14:	d9003617 	ldw	r4,216(sp)
81125d18:	d9403817 	ldw	r5,224(sp)
81125d1c:	000d883a 	mov	r6,zero
81125d20:	000f883a 	mov	r7,zero
81125d24:	1135e600 	call	81135e60 <__ledf2>
81125d28:	da003d17 	ldw	r8,244(sp)
81125d2c:	1005be16 	blt	r2,zero,81127428 <___vfprintf_internal_r+0x1d24>
81125d30:	df002783 	ldbu	fp,158(sp)
81125d34:	008011c4 	movi	r2,71
81125d38:	1445330e 	bge	r2,r17,81127208 <___vfprintf_internal_r+0x1b04>
81125d3c:	04204574 	movhi	r16,33045
81125d40:	84021604 	addi	r16,r16,2136
81125d44:	00c000c4 	movi	r3,3
81125d48:	00bfdfc4 	movi	r2,-129
81125d4c:	d8c02a15 	stw	r3,168(sp)
81125d50:	90a4703a 	and	r18,r18,r2
81125d54:	d8c02e15 	stw	r3,184(sp)
81125d58:	d8002915 	stw	zero,164(sp)
81125d5c:	d8003215 	stw	zero,200(sp)
81125d60:	00003706 	br	81125e40 <___vfprintf_internal_r+0x73c>
81125d64:	94800214 	ori	r18,r18,8
81125d68:	ac400007 	ldb	r17,0(r21)
81125d6c:	003ec806 	br	81125890 <__reset+0xfb105890>
81125d70:	18c03fcc 	andi	r3,r3,255
81125d74:	1806db1e 	bne	r3,zero,811278e4 <___vfprintf_internal_r+0x21e0>
81125d78:	94800414 	ori	r18,r18,16
81125d7c:	9080080c 	andi	r2,r18,32
81125d80:	1002d826 	beq	r2,zero,811268e4 <___vfprintf_internal_r+0x11e0>
81125d84:	d9402d17 	ldw	r5,180(sp)
81125d88:	d8c02917 	ldw	r3,164(sp)
81125d8c:	d8002785 	stb	zero,158(sp)
81125d90:	28800204 	addi	r2,r5,8
81125d94:	2cc00017 	ldw	r19,0(r5)
81125d98:	2d800117 	ldw	r22,4(r5)
81125d9c:	18048f16 	blt	r3,zero,81126fdc <___vfprintf_internal_r+0x18d8>
81125da0:	013fdfc4 	movi	r4,-129
81125da4:	9d86b03a 	or	r3,r19,r22
81125da8:	d8802d15 	stw	r2,180(sp)
81125dac:	9124703a 	and	r18,r18,r4
81125db0:	1802d91e 	bne	r3,zero,81126918 <___vfprintf_internal_r+0x1214>
81125db4:	d8c02917 	ldw	r3,164(sp)
81125db8:	0039883a 	mov	fp,zero
81125dbc:	1805c326 	beq	r3,zero,811274cc <___vfprintf_internal_r+0x1dc8>
81125dc0:	0027883a 	mov	r19,zero
81125dc4:	002d883a 	mov	r22,zero
81125dc8:	dc001e04 	addi	r16,sp,120
81125dcc:	9806d0fa 	srli	r3,r19,3
81125dd0:	b008977a 	slli	r4,r22,29
81125dd4:	b02cd0fa 	srli	r22,r22,3
81125dd8:	9cc001cc 	andi	r19,r19,7
81125ddc:	98800c04 	addi	r2,r19,48
81125de0:	843fffc4 	addi	r16,r16,-1
81125de4:	20e6b03a 	or	r19,r4,r3
81125de8:	80800005 	stb	r2,0(r16)
81125dec:	9d86b03a 	or	r3,r19,r22
81125df0:	183ff61e 	bne	r3,zero,81125dcc <__reset+0xfb105dcc>
81125df4:	90c0004c 	andi	r3,r18,1
81125df8:	18013b26 	beq	r3,zero,811262e8 <___vfprintf_internal_r+0xbe4>
81125dfc:	10803fcc 	andi	r2,r2,255
81125e00:	1080201c 	xori	r2,r2,128
81125e04:	10bfe004 	addi	r2,r2,-128
81125e08:	00c00c04 	movi	r3,48
81125e0c:	10c13626 	beq	r2,r3,811262e8 <___vfprintf_internal_r+0xbe4>
81125e10:	80ffffc5 	stb	r3,-1(r16)
81125e14:	d8c02817 	ldw	r3,160(sp)
81125e18:	80bfffc4 	addi	r2,r16,-1
81125e1c:	1021883a 	mov	r16,r2
81125e20:	1887c83a 	sub	r3,r3,r2
81125e24:	d8c02e15 	stw	r3,184(sp)
81125e28:	d8802e17 	ldw	r2,184(sp)
81125e2c:	d9002917 	ldw	r4,164(sp)
81125e30:	1100010e 	bge	r2,r4,81125e38 <___vfprintf_internal_r+0x734>
81125e34:	2005883a 	mov	r2,r4
81125e38:	d8802a15 	stw	r2,168(sp)
81125e3c:	d8003215 	stw	zero,200(sp)
81125e40:	e7003fcc 	andi	fp,fp,255
81125e44:	e700201c 	xori	fp,fp,128
81125e48:	e73fe004 	addi	fp,fp,-128
81125e4c:	e0000326 	beq	fp,zero,81125e5c <___vfprintf_internal_r+0x758>
81125e50:	d8c02a17 	ldw	r3,168(sp)
81125e54:	18c00044 	addi	r3,r3,1
81125e58:	d8c02a15 	stw	r3,168(sp)
81125e5c:	90c0008c 	andi	r3,r18,2
81125e60:	d8c02b15 	stw	r3,172(sp)
81125e64:	18000326 	beq	r3,zero,81125e74 <___vfprintf_internal_r+0x770>
81125e68:	d8c02a17 	ldw	r3,168(sp)
81125e6c:	18c00084 	addi	r3,r3,2
81125e70:	d8c02a15 	stw	r3,168(sp)
81125e74:	90c0210c 	andi	r3,r18,132
81125e78:	d8c03015 	stw	r3,192(sp)
81125e7c:	1801a31e 	bne	r3,zero,8112650c <___vfprintf_internal_r+0xe08>
81125e80:	d9003117 	ldw	r4,196(sp)
81125e84:	d8c02a17 	ldw	r3,168(sp)
81125e88:	20e7c83a 	sub	r19,r4,r3
81125e8c:	04c19f0e 	bge	zero,r19,8112650c <___vfprintf_internal_r+0xe08>
81125e90:	02400404 	movi	r9,16
81125e94:	d8c02017 	ldw	r3,128(sp)
81125e98:	d8801f17 	ldw	r2,124(sp)
81125e9c:	4cc50d0e 	bge	r9,r19,811272d4 <___vfprintf_internal_r+0x1bd0>
81125ea0:	01604574 	movhi	r5,33045
81125ea4:	29423184 	addi	r5,r5,2246
81125ea8:	dc403b15 	stw	r17,236(sp)
81125eac:	d9403515 	stw	r5,212(sp)
81125eb0:	9823883a 	mov	r17,r19
81125eb4:	482d883a 	mov	r22,r9
81125eb8:	9027883a 	mov	r19,r18
81125ebc:	070001c4 	movi	fp,7
81125ec0:	8025883a 	mov	r18,r16
81125ec4:	dc002c17 	ldw	r16,176(sp)
81125ec8:	00000306 	br	81125ed8 <___vfprintf_internal_r+0x7d4>
81125ecc:	8c7ffc04 	addi	r17,r17,-16
81125ed0:	42000204 	addi	r8,r8,8
81125ed4:	b440130e 	bge	r22,r17,81125f24 <___vfprintf_internal_r+0x820>
81125ed8:	01204574 	movhi	r4,33045
81125edc:	18c00404 	addi	r3,r3,16
81125ee0:	10800044 	addi	r2,r2,1
81125ee4:	21023184 	addi	r4,r4,2246
81125ee8:	41000015 	stw	r4,0(r8)
81125eec:	45800115 	stw	r22,4(r8)
81125ef0:	d8c02015 	stw	r3,128(sp)
81125ef4:	d8801f15 	stw	r2,124(sp)
81125ef8:	e0bff40e 	bge	fp,r2,81125ecc <__reset+0xfb105ecc>
81125efc:	d9801e04 	addi	r6,sp,120
81125f00:	b80b883a 	mov	r5,r23
81125f04:	8009883a 	mov	r4,r16
81125f08:	113160c0 	call	8113160c <__sprint_r>
81125f0c:	103f011e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81125f10:	8c7ffc04 	addi	r17,r17,-16
81125f14:	d8c02017 	ldw	r3,128(sp)
81125f18:	d8801f17 	ldw	r2,124(sp)
81125f1c:	da000404 	addi	r8,sp,16
81125f20:	b47fed16 	blt	r22,r17,81125ed8 <__reset+0xfb105ed8>
81125f24:	9021883a 	mov	r16,r18
81125f28:	9825883a 	mov	r18,r19
81125f2c:	8827883a 	mov	r19,r17
81125f30:	dc403b17 	ldw	r17,236(sp)
81125f34:	d9403517 	ldw	r5,212(sp)
81125f38:	98c7883a 	add	r3,r19,r3
81125f3c:	10800044 	addi	r2,r2,1
81125f40:	41400015 	stw	r5,0(r8)
81125f44:	44c00115 	stw	r19,4(r8)
81125f48:	d8c02015 	stw	r3,128(sp)
81125f4c:	d8801f15 	stw	r2,124(sp)
81125f50:	010001c4 	movi	r4,7
81125f54:	2082a316 	blt	r4,r2,811269e4 <___vfprintf_internal_r+0x12e0>
81125f58:	df002787 	ldb	fp,158(sp)
81125f5c:	42000204 	addi	r8,r8,8
81125f60:	e0000c26 	beq	fp,zero,81125f94 <___vfprintf_internal_r+0x890>
81125f64:	d8801f17 	ldw	r2,124(sp)
81125f68:	d9002784 	addi	r4,sp,158
81125f6c:	18c00044 	addi	r3,r3,1
81125f70:	10800044 	addi	r2,r2,1
81125f74:	41000015 	stw	r4,0(r8)
81125f78:	01000044 	movi	r4,1
81125f7c:	41000115 	stw	r4,4(r8)
81125f80:	d8c02015 	stw	r3,128(sp)
81125f84:	d8801f15 	stw	r2,124(sp)
81125f88:	010001c4 	movi	r4,7
81125f8c:	20823c16 	blt	r4,r2,81126880 <___vfprintf_internal_r+0x117c>
81125f90:	42000204 	addi	r8,r8,8
81125f94:	d8802b17 	ldw	r2,172(sp)
81125f98:	10000c26 	beq	r2,zero,81125fcc <___vfprintf_internal_r+0x8c8>
81125f9c:	d8801f17 	ldw	r2,124(sp)
81125fa0:	d9002704 	addi	r4,sp,156
81125fa4:	18c00084 	addi	r3,r3,2
81125fa8:	10800044 	addi	r2,r2,1
81125fac:	41000015 	stw	r4,0(r8)
81125fb0:	01000084 	movi	r4,2
81125fb4:	41000115 	stw	r4,4(r8)
81125fb8:	d8c02015 	stw	r3,128(sp)
81125fbc:	d8801f15 	stw	r2,124(sp)
81125fc0:	010001c4 	movi	r4,7
81125fc4:	20823616 	blt	r4,r2,811268a0 <___vfprintf_internal_r+0x119c>
81125fc8:	42000204 	addi	r8,r8,8
81125fcc:	d9003017 	ldw	r4,192(sp)
81125fd0:	00802004 	movi	r2,128
81125fd4:	20819926 	beq	r4,r2,8112663c <___vfprintf_internal_r+0xf38>
81125fd8:	d9402917 	ldw	r5,164(sp)
81125fdc:	d8802e17 	ldw	r2,184(sp)
81125fe0:	28adc83a 	sub	r22,r5,r2
81125fe4:	0580310e 	bge	zero,r22,811260ac <___vfprintf_internal_r+0x9a8>
81125fe8:	07000404 	movi	fp,16
81125fec:	d8801f17 	ldw	r2,124(sp)
81125ff0:	e584140e 	bge	fp,r22,81127044 <___vfprintf_internal_r+0x1940>
81125ff4:	01604574 	movhi	r5,33045
81125ff8:	29422d84 	addi	r5,r5,2230
81125ffc:	dc402915 	stw	r17,164(sp)
81126000:	d9402b15 	stw	r5,172(sp)
81126004:	b023883a 	mov	r17,r22
81126008:	04c001c4 	movi	r19,7
8112600c:	a82d883a 	mov	r22,r21
81126010:	902b883a 	mov	r21,r18
81126014:	8025883a 	mov	r18,r16
81126018:	dc002c17 	ldw	r16,176(sp)
8112601c:	00000306 	br	8112602c <___vfprintf_internal_r+0x928>
81126020:	8c7ffc04 	addi	r17,r17,-16
81126024:	42000204 	addi	r8,r8,8
81126028:	e440110e 	bge	fp,r17,81126070 <___vfprintf_internal_r+0x96c>
8112602c:	18c00404 	addi	r3,r3,16
81126030:	10800044 	addi	r2,r2,1
81126034:	45000015 	stw	r20,0(r8)
81126038:	47000115 	stw	fp,4(r8)
8112603c:	d8c02015 	stw	r3,128(sp)
81126040:	d8801f15 	stw	r2,124(sp)
81126044:	98bff60e 	bge	r19,r2,81126020 <__reset+0xfb106020>
81126048:	d9801e04 	addi	r6,sp,120
8112604c:	b80b883a 	mov	r5,r23
81126050:	8009883a 	mov	r4,r16
81126054:	113160c0 	call	8113160c <__sprint_r>
81126058:	103eae1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
8112605c:	8c7ffc04 	addi	r17,r17,-16
81126060:	d8c02017 	ldw	r3,128(sp)
81126064:	d8801f17 	ldw	r2,124(sp)
81126068:	da000404 	addi	r8,sp,16
8112606c:	e47fef16 	blt	fp,r17,8112602c <__reset+0xfb10602c>
81126070:	9021883a 	mov	r16,r18
81126074:	a825883a 	mov	r18,r21
81126078:	b02b883a 	mov	r21,r22
8112607c:	882d883a 	mov	r22,r17
81126080:	dc402917 	ldw	r17,164(sp)
81126084:	d9002b17 	ldw	r4,172(sp)
81126088:	1d87883a 	add	r3,r3,r22
8112608c:	10800044 	addi	r2,r2,1
81126090:	41000015 	stw	r4,0(r8)
81126094:	45800115 	stw	r22,4(r8)
81126098:	d8c02015 	stw	r3,128(sp)
8112609c:	d8801f15 	stw	r2,124(sp)
811260a0:	010001c4 	movi	r4,7
811260a4:	2081ee16 	blt	r4,r2,81126860 <___vfprintf_internal_r+0x115c>
811260a8:	42000204 	addi	r8,r8,8
811260ac:	9080400c 	andi	r2,r18,256
811260b0:	1001181e 	bne	r2,zero,81126514 <___vfprintf_internal_r+0xe10>
811260b4:	d9402e17 	ldw	r5,184(sp)
811260b8:	d8801f17 	ldw	r2,124(sp)
811260bc:	44000015 	stw	r16,0(r8)
811260c0:	1947883a 	add	r3,r3,r5
811260c4:	10800044 	addi	r2,r2,1
811260c8:	41400115 	stw	r5,4(r8)
811260cc:	d8c02015 	stw	r3,128(sp)
811260d0:	d8801f15 	stw	r2,124(sp)
811260d4:	010001c4 	movi	r4,7
811260d8:	2081d316 	blt	r4,r2,81126828 <___vfprintf_internal_r+0x1124>
811260dc:	42000204 	addi	r8,r8,8
811260e0:	9480010c 	andi	r18,r18,4
811260e4:	90003226 	beq	r18,zero,811261b0 <___vfprintf_internal_r+0xaac>
811260e8:	d9403117 	ldw	r5,196(sp)
811260ec:	d8802a17 	ldw	r2,168(sp)
811260f0:	28a1c83a 	sub	r16,r5,r2
811260f4:	04002e0e 	bge	zero,r16,811261b0 <___vfprintf_internal_r+0xaac>
811260f8:	04400404 	movi	r17,16
811260fc:	d8801f17 	ldw	r2,124(sp)
81126100:	8c04a20e 	bge	r17,r16,8112738c <___vfprintf_internal_r+0x1c88>
81126104:	01604574 	movhi	r5,33045
81126108:	29423184 	addi	r5,r5,2246
8112610c:	d9403515 	stw	r5,212(sp)
81126110:	048001c4 	movi	r18,7
81126114:	dcc02c17 	ldw	r19,176(sp)
81126118:	00000306 	br	81126128 <___vfprintf_internal_r+0xa24>
8112611c:	843ffc04 	addi	r16,r16,-16
81126120:	42000204 	addi	r8,r8,8
81126124:	8c00130e 	bge	r17,r16,81126174 <___vfprintf_internal_r+0xa70>
81126128:	01204574 	movhi	r4,33045
8112612c:	18c00404 	addi	r3,r3,16
81126130:	10800044 	addi	r2,r2,1
81126134:	21023184 	addi	r4,r4,2246
81126138:	41000015 	stw	r4,0(r8)
8112613c:	44400115 	stw	r17,4(r8)
81126140:	d8c02015 	stw	r3,128(sp)
81126144:	d8801f15 	stw	r2,124(sp)
81126148:	90bff40e 	bge	r18,r2,8112611c <__reset+0xfb10611c>
8112614c:	d9801e04 	addi	r6,sp,120
81126150:	b80b883a 	mov	r5,r23
81126154:	9809883a 	mov	r4,r19
81126158:	113160c0 	call	8113160c <__sprint_r>
8112615c:	103e6d1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126160:	843ffc04 	addi	r16,r16,-16
81126164:	d8c02017 	ldw	r3,128(sp)
81126168:	d8801f17 	ldw	r2,124(sp)
8112616c:	da000404 	addi	r8,sp,16
81126170:	8c3fed16 	blt	r17,r16,81126128 <__reset+0xfb106128>
81126174:	d9403517 	ldw	r5,212(sp)
81126178:	1c07883a 	add	r3,r3,r16
8112617c:	10800044 	addi	r2,r2,1
81126180:	41400015 	stw	r5,0(r8)
81126184:	44000115 	stw	r16,4(r8)
81126188:	d8c02015 	stw	r3,128(sp)
8112618c:	d8801f15 	stw	r2,124(sp)
81126190:	010001c4 	movi	r4,7
81126194:	2080060e 	bge	r4,r2,811261b0 <___vfprintf_internal_r+0xaac>
81126198:	d9002c17 	ldw	r4,176(sp)
8112619c:	d9801e04 	addi	r6,sp,120
811261a0:	b80b883a 	mov	r5,r23
811261a4:	113160c0 	call	8113160c <__sprint_r>
811261a8:	103e5a1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
811261ac:	d8c02017 	ldw	r3,128(sp)
811261b0:	d8803117 	ldw	r2,196(sp)
811261b4:	d9002a17 	ldw	r4,168(sp)
811261b8:	1100010e 	bge	r2,r4,811261c0 <___vfprintf_internal_r+0xabc>
811261bc:	2005883a 	mov	r2,r4
811261c0:	d9402f17 	ldw	r5,188(sp)
811261c4:	288b883a 	add	r5,r5,r2
811261c8:	d9402f15 	stw	r5,188(sp)
811261cc:	18019e1e 	bne	r3,zero,81126848 <___vfprintf_internal_r+0x1144>
811261d0:	a8800007 	ldb	r2,0(r21)
811261d4:	d8001f15 	stw	zero,124(sp)
811261d8:	da000404 	addi	r8,sp,16
811261dc:	103d851e 	bne	r2,zero,811257f4 <__reset+0xfb1057f4>
811261e0:	a821883a 	mov	r16,r21
811261e4:	003d9b06 	br	81125854 <__reset+0xfb105854>
811261e8:	18c03fcc 	andi	r3,r3,255
811261ec:	1805c11e 	bne	r3,zero,811278f4 <___vfprintf_internal_r+0x21f0>
811261f0:	94800414 	ori	r18,r18,16
811261f4:	9080080c 	andi	r2,r18,32
811261f8:	10020c26 	beq	r2,zero,81126a2c <___vfprintf_internal_r+0x1328>
811261fc:	d8802d17 	ldw	r2,180(sp)
81126200:	d9002917 	ldw	r4,164(sp)
81126204:	d8002785 	stb	zero,158(sp)
81126208:	10c00204 	addi	r3,r2,8
8112620c:	14c00017 	ldw	r19,0(r2)
81126210:	15800117 	ldw	r22,4(r2)
81126214:	20040f16 	blt	r4,zero,81127254 <___vfprintf_internal_r+0x1b50>
81126218:	013fdfc4 	movi	r4,-129
8112621c:	9d84b03a 	or	r2,r19,r22
81126220:	d8c02d15 	stw	r3,180(sp)
81126224:	9124703a 	and	r18,r18,r4
81126228:	0039883a 	mov	fp,zero
8112622c:	103e891e 	bne	r2,zero,81125c54 <__reset+0xfb105c54>
81126230:	d9002917 	ldw	r4,164(sp)
81126234:	2002c11e 	bne	r4,zero,81126d3c <___vfprintf_internal_r+0x1638>
81126238:	d8002915 	stw	zero,164(sp)
8112623c:	d8002e15 	stw	zero,184(sp)
81126240:	dc001e04 	addi	r16,sp,120
81126244:	003ef806 	br	81125e28 <__reset+0xfb105e28>
81126248:	18c03fcc 	andi	r3,r3,255
8112624c:	18059d1e 	bne	r3,zero,811278c4 <___vfprintf_internal_r+0x21c0>
81126250:	01604574 	movhi	r5,33045
81126254:	29421904 	addi	r5,r5,2148
81126258:	d9403915 	stw	r5,228(sp)
8112625c:	9080080c 	andi	r2,r18,32
81126260:	10005226 	beq	r2,zero,811263ac <___vfprintf_internal_r+0xca8>
81126264:	d8802d17 	ldw	r2,180(sp)
81126268:	14c00017 	ldw	r19,0(r2)
8112626c:	15800117 	ldw	r22,4(r2)
81126270:	10800204 	addi	r2,r2,8
81126274:	d8802d15 	stw	r2,180(sp)
81126278:	9080004c 	andi	r2,r18,1
8112627c:	10019026 	beq	r2,zero,811268c0 <___vfprintf_internal_r+0x11bc>
81126280:	9d84b03a 	or	r2,r19,r22
81126284:	10036926 	beq	r2,zero,8112702c <___vfprintf_internal_r+0x1928>
81126288:	d8c02917 	ldw	r3,164(sp)
8112628c:	00800c04 	movi	r2,48
81126290:	d8802705 	stb	r2,156(sp)
81126294:	dc402745 	stb	r17,157(sp)
81126298:	d8002785 	stb	zero,158(sp)
8112629c:	90800094 	ori	r2,r18,2
811262a0:	18045d16 	blt	r3,zero,81127418 <___vfprintf_internal_r+0x1d14>
811262a4:	00bfdfc4 	movi	r2,-129
811262a8:	90a4703a 	and	r18,r18,r2
811262ac:	94800094 	ori	r18,r18,2
811262b0:	0039883a 	mov	fp,zero
811262b4:	d9003917 	ldw	r4,228(sp)
811262b8:	dc001e04 	addi	r16,sp,120
811262bc:	988003cc 	andi	r2,r19,15
811262c0:	b006973a 	slli	r3,r22,28
811262c4:	2085883a 	add	r2,r4,r2
811262c8:	9826d13a 	srli	r19,r19,4
811262cc:	10800003 	ldbu	r2,0(r2)
811262d0:	b02cd13a 	srli	r22,r22,4
811262d4:	843fffc4 	addi	r16,r16,-1
811262d8:	1ce6b03a 	or	r19,r3,r19
811262dc:	80800005 	stb	r2,0(r16)
811262e0:	9d84b03a 	or	r2,r19,r22
811262e4:	103ff51e 	bne	r2,zero,811262bc <__reset+0xfb1062bc>
811262e8:	d8c02817 	ldw	r3,160(sp)
811262ec:	1c07c83a 	sub	r3,r3,r16
811262f0:	d8c02e15 	stw	r3,184(sp)
811262f4:	003ecc06 	br	81125e28 <__reset+0xfb105e28>
811262f8:	18c03fcc 	andi	r3,r3,255
811262fc:	183e9f26 	beq	r3,zero,81125d7c <__reset+0xfb105d7c>
81126300:	d9c02785 	stb	r7,158(sp)
81126304:	003e9d06 	br	81125d7c <__reset+0xfb105d7c>
81126308:	00c00044 	movi	r3,1
8112630c:	01c00ac4 	movi	r7,43
81126310:	ac400007 	ldb	r17,0(r21)
81126314:	003d5e06 	br	81125890 <__reset+0xfb105890>
81126318:	94800814 	ori	r18,r18,32
8112631c:	ac400007 	ldb	r17,0(r21)
81126320:	003d5b06 	br	81125890 <__reset+0xfb105890>
81126324:	d8c02d17 	ldw	r3,180(sp)
81126328:	d8002785 	stb	zero,158(sp)
8112632c:	1c000017 	ldw	r16,0(r3)
81126330:	1cc00104 	addi	r19,r3,4
81126334:	80041926 	beq	r16,zero,8112739c <___vfprintf_internal_r+0x1c98>
81126338:	d9002917 	ldw	r4,164(sp)
8112633c:	2003d016 	blt	r4,zero,81127280 <___vfprintf_internal_r+0x1b7c>
81126340:	200d883a 	mov	r6,r4
81126344:	000b883a 	mov	r5,zero
81126348:	8009883a 	mov	r4,r16
8112634c:	da003d15 	stw	r8,244(sp)
81126350:	112c6e80 	call	8112c6e8 <memchr>
81126354:	da003d17 	ldw	r8,244(sp)
81126358:	10045426 	beq	r2,zero,811274ac <___vfprintf_internal_r+0x1da8>
8112635c:	1405c83a 	sub	r2,r2,r16
81126360:	d8802e15 	stw	r2,184(sp)
81126364:	1003cc16 	blt	r2,zero,81127298 <___vfprintf_internal_r+0x1b94>
81126368:	df002783 	ldbu	fp,158(sp)
8112636c:	d8802a15 	stw	r2,168(sp)
81126370:	dcc02d15 	stw	r19,180(sp)
81126374:	d8002915 	stw	zero,164(sp)
81126378:	d8003215 	stw	zero,200(sp)
8112637c:	003eb006 	br	81125e40 <__reset+0xfb105e40>
81126380:	18c03fcc 	andi	r3,r3,255
81126384:	183f9b26 	beq	r3,zero,811261f4 <__reset+0xfb1061f4>
81126388:	d9c02785 	stb	r7,158(sp)
8112638c:	003f9906 	br	811261f4 <__reset+0xfb1061f4>
81126390:	18c03fcc 	andi	r3,r3,255
81126394:	1805551e 	bne	r3,zero,811278ec <___vfprintf_internal_r+0x21e8>
81126398:	01604574 	movhi	r5,33045
8112639c:	29421e04 	addi	r5,r5,2168
811263a0:	d9403915 	stw	r5,228(sp)
811263a4:	9080080c 	andi	r2,r18,32
811263a8:	103fae1e 	bne	r2,zero,81126264 <__reset+0xfb106264>
811263ac:	9080040c 	andi	r2,r18,16
811263b0:	1002de26 	beq	r2,zero,81126f2c <___vfprintf_internal_r+0x1828>
811263b4:	d8c02d17 	ldw	r3,180(sp)
811263b8:	002d883a 	mov	r22,zero
811263bc:	1cc00017 	ldw	r19,0(r3)
811263c0:	18c00104 	addi	r3,r3,4
811263c4:	d8c02d15 	stw	r3,180(sp)
811263c8:	003fab06 	br	81126278 <__reset+0xfb106278>
811263cc:	38803fcc 	andi	r2,r7,255
811263d0:	1080201c 	xori	r2,r2,128
811263d4:	10bfe004 	addi	r2,r2,-128
811263d8:	1002d21e 	bne	r2,zero,81126f24 <___vfprintf_internal_r+0x1820>
811263dc:	00c00044 	movi	r3,1
811263e0:	01c00804 	movi	r7,32
811263e4:	ac400007 	ldb	r17,0(r21)
811263e8:	003d2906 	br	81125890 <__reset+0xfb105890>
811263ec:	94800054 	ori	r18,r18,1
811263f0:	ac400007 	ldb	r17,0(r21)
811263f4:	003d2606 	br	81125890 <__reset+0xfb105890>
811263f8:	18c03fcc 	andi	r3,r3,255
811263fc:	183e0526 	beq	r3,zero,81125c14 <__reset+0xfb105c14>
81126400:	d9c02785 	stb	r7,158(sp)
81126404:	003e0306 	br	81125c14 <__reset+0xfb105c14>
81126408:	94801014 	ori	r18,r18,64
8112640c:	ac400007 	ldb	r17,0(r21)
81126410:	003d1f06 	br	81125890 <__reset+0xfb105890>
81126414:	ac400007 	ldb	r17,0(r21)
81126418:	8a438726 	beq	r17,r9,81127238 <___vfprintf_internal_r+0x1b34>
8112641c:	94800414 	ori	r18,r18,16
81126420:	003d1b06 	br	81125890 <__reset+0xfb105890>
81126424:	18c03fcc 	andi	r3,r3,255
81126428:	1805341e 	bne	r3,zero,811278fc <___vfprintf_internal_r+0x21f8>
8112642c:	9080080c 	andi	r2,r18,32
81126430:	1002cd26 	beq	r2,zero,81126f68 <___vfprintf_internal_r+0x1864>
81126434:	d9402d17 	ldw	r5,180(sp)
81126438:	d9002f17 	ldw	r4,188(sp)
8112643c:	28800017 	ldw	r2,0(r5)
81126440:	2007d7fa 	srai	r3,r4,31
81126444:	29400104 	addi	r5,r5,4
81126448:	d9402d15 	stw	r5,180(sp)
8112644c:	11000015 	stw	r4,0(r2)
81126450:	10c00115 	stw	r3,4(r2)
81126454:	003ce506 	br	811257ec <__reset+0xfb1057ec>
81126458:	d8c02d17 	ldw	r3,180(sp)
8112645c:	d9002d17 	ldw	r4,180(sp)
81126460:	d8002785 	stb	zero,158(sp)
81126464:	18800017 	ldw	r2,0(r3)
81126468:	21000104 	addi	r4,r4,4
8112646c:	00c00044 	movi	r3,1
81126470:	d8c02a15 	stw	r3,168(sp)
81126474:	d8801405 	stb	r2,80(sp)
81126478:	d9002d15 	stw	r4,180(sp)
8112647c:	d8c02e15 	stw	r3,184(sp)
81126480:	d8002915 	stw	zero,164(sp)
81126484:	d8003215 	stw	zero,200(sp)
81126488:	dc001404 	addi	r16,sp,80
8112648c:	0039883a 	mov	fp,zero
81126490:	003e7206 	br	81125e5c <__reset+0xfb105e5c>
81126494:	01204574 	movhi	r4,33045
81126498:	21021e04 	addi	r4,r4,2168
8112649c:	0039883a 	mov	fp,zero
811264a0:	d9003915 	stw	r4,228(sp)
811264a4:	04401e04 	movi	r17,120
811264a8:	003f8206 	br	811262b4 <__reset+0xfb1062b4>
811264ac:	18c03fcc 	andi	r3,r3,255
811264b0:	1805061e 	bne	r3,zero,811278cc <___vfprintf_internal_r+0x21c8>
811264b4:	883d9126 	beq	r17,zero,81125afc <__reset+0xfb105afc>
811264b8:	00c00044 	movi	r3,1
811264bc:	d8c02a15 	stw	r3,168(sp)
811264c0:	dc401405 	stb	r17,80(sp)
811264c4:	d8002785 	stb	zero,158(sp)
811264c8:	003fec06 	br	8112647c <__reset+0xfb10647c>
811264cc:	01604574 	movhi	r5,33045
811264d0:	29421e04 	addi	r5,r5,2168
811264d4:	d9403915 	stw	r5,228(sp)
811264d8:	d8c02d15 	stw	r3,180(sp)
811264dc:	1025883a 	mov	r18,r2
811264e0:	04401e04 	movi	r17,120
811264e4:	9d84b03a 	or	r2,r19,r22
811264e8:	1000fc1e 	bne	r2,zero,811268dc <___vfprintf_internal_r+0x11d8>
811264ec:	0039883a 	mov	fp,zero
811264f0:	00800084 	movi	r2,2
811264f4:	10803fcc 	andi	r2,r2,255
811264f8:	00c00044 	movi	r3,1
811264fc:	10c20f26 	beq	r2,r3,81126d3c <___vfprintf_internal_r+0x1638>
81126500:	00c00084 	movi	r3,2
81126504:	10fd6326 	beq	r2,r3,81125a94 <__reset+0xfb105a94>
81126508:	003e2d06 	br	81125dc0 <__reset+0xfb105dc0>
8112650c:	d8c02017 	ldw	r3,128(sp)
81126510:	003e9306 	br	81125f60 <__reset+0xfb105f60>
81126514:	00801944 	movi	r2,101
81126518:	14407e0e 	bge	r2,r17,81126714 <___vfprintf_internal_r+0x1010>
8112651c:	d9003617 	ldw	r4,216(sp)
81126520:	d9403817 	ldw	r5,224(sp)
81126524:	000d883a 	mov	r6,zero
81126528:	000f883a 	mov	r7,zero
8112652c:	d8c03c15 	stw	r3,240(sp)
81126530:	da003d15 	stw	r8,244(sp)
81126534:	1135dd80 	call	81135dd8 <__eqdf2>
81126538:	d8c03c17 	ldw	r3,240(sp)
8112653c:	da003d17 	ldw	r8,244(sp)
81126540:	1000f71e 	bne	r2,zero,81126920 <___vfprintf_internal_r+0x121c>
81126544:	d8801f17 	ldw	r2,124(sp)
81126548:	01204574 	movhi	r4,33045
8112654c:	21022504 	addi	r4,r4,2196
81126550:	18c00044 	addi	r3,r3,1
81126554:	10800044 	addi	r2,r2,1
81126558:	41000015 	stw	r4,0(r8)
8112655c:	01000044 	movi	r4,1
81126560:	41000115 	stw	r4,4(r8)
81126564:	d8c02015 	stw	r3,128(sp)
81126568:	d8801f15 	stw	r2,124(sp)
8112656c:	010001c4 	movi	r4,7
81126570:	2082b816 	blt	r4,r2,81127054 <___vfprintf_internal_r+0x1950>
81126574:	42000204 	addi	r8,r8,8
81126578:	d8802617 	ldw	r2,152(sp)
8112657c:	d9403317 	ldw	r5,204(sp)
81126580:	11400216 	blt	r2,r5,8112658c <___vfprintf_internal_r+0xe88>
81126584:	9080004c 	andi	r2,r18,1
81126588:	103ed526 	beq	r2,zero,811260e0 <__reset+0xfb1060e0>
8112658c:	d8803717 	ldw	r2,220(sp)
81126590:	d9003417 	ldw	r4,208(sp)
81126594:	d9403717 	ldw	r5,220(sp)
81126598:	1887883a 	add	r3,r3,r2
8112659c:	d8801f17 	ldw	r2,124(sp)
811265a0:	41000015 	stw	r4,0(r8)
811265a4:	41400115 	stw	r5,4(r8)
811265a8:	10800044 	addi	r2,r2,1
811265ac:	d8c02015 	stw	r3,128(sp)
811265b0:	d8801f15 	stw	r2,124(sp)
811265b4:	010001c4 	movi	r4,7
811265b8:	20832916 	blt	r4,r2,81127260 <___vfprintf_internal_r+0x1b5c>
811265bc:	42000204 	addi	r8,r8,8
811265c0:	d8803317 	ldw	r2,204(sp)
811265c4:	143fffc4 	addi	r16,r2,-1
811265c8:	043ec50e 	bge	zero,r16,811260e0 <__reset+0xfb1060e0>
811265cc:	04400404 	movi	r17,16
811265d0:	d8801f17 	ldw	r2,124(sp)
811265d4:	8c00880e 	bge	r17,r16,811267f8 <___vfprintf_internal_r+0x10f4>
811265d8:	01604574 	movhi	r5,33045
811265dc:	29422d84 	addi	r5,r5,2230
811265e0:	d9402b15 	stw	r5,172(sp)
811265e4:	058001c4 	movi	r22,7
811265e8:	dcc02c17 	ldw	r19,176(sp)
811265ec:	00000306 	br	811265fc <___vfprintf_internal_r+0xef8>
811265f0:	42000204 	addi	r8,r8,8
811265f4:	843ffc04 	addi	r16,r16,-16
811265f8:	8c00820e 	bge	r17,r16,81126804 <___vfprintf_internal_r+0x1100>
811265fc:	18c00404 	addi	r3,r3,16
81126600:	10800044 	addi	r2,r2,1
81126604:	45000015 	stw	r20,0(r8)
81126608:	44400115 	stw	r17,4(r8)
8112660c:	d8c02015 	stw	r3,128(sp)
81126610:	d8801f15 	stw	r2,124(sp)
81126614:	b0bff60e 	bge	r22,r2,811265f0 <__reset+0xfb1065f0>
81126618:	d9801e04 	addi	r6,sp,120
8112661c:	b80b883a 	mov	r5,r23
81126620:	9809883a 	mov	r4,r19
81126624:	113160c0 	call	8113160c <__sprint_r>
81126628:	103d3a1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
8112662c:	d8c02017 	ldw	r3,128(sp)
81126630:	d8801f17 	ldw	r2,124(sp)
81126634:	da000404 	addi	r8,sp,16
81126638:	003fee06 	br	811265f4 <__reset+0xfb1065f4>
8112663c:	d9403117 	ldw	r5,196(sp)
81126640:	d8802a17 	ldw	r2,168(sp)
81126644:	28adc83a 	sub	r22,r5,r2
81126648:	05be630e 	bge	zero,r22,81125fd8 <__reset+0xfb105fd8>
8112664c:	07000404 	movi	fp,16
81126650:	d8801f17 	ldw	r2,124(sp)
81126654:	e5838f0e 	bge	fp,r22,81127494 <___vfprintf_internal_r+0x1d90>
81126658:	01604574 	movhi	r5,33045
8112665c:	29422d84 	addi	r5,r5,2230
81126660:	dc403015 	stw	r17,192(sp)
81126664:	d9402b15 	stw	r5,172(sp)
81126668:	b023883a 	mov	r17,r22
8112666c:	04c001c4 	movi	r19,7
81126670:	a82d883a 	mov	r22,r21
81126674:	902b883a 	mov	r21,r18
81126678:	8025883a 	mov	r18,r16
8112667c:	dc002c17 	ldw	r16,176(sp)
81126680:	00000306 	br	81126690 <___vfprintf_internal_r+0xf8c>
81126684:	8c7ffc04 	addi	r17,r17,-16
81126688:	42000204 	addi	r8,r8,8
8112668c:	e440110e 	bge	fp,r17,811266d4 <___vfprintf_internal_r+0xfd0>
81126690:	18c00404 	addi	r3,r3,16
81126694:	10800044 	addi	r2,r2,1
81126698:	45000015 	stw	r20,0(r8)
8112669c:	47000115 	stw	fp,4(r8)
811266a0:	d8c02015 	stw	r3,128(sp)
811266a4:	d8801f15 	stw	r2,124(sp)
811266a8:	98bff60e 	bge	r19,r2,81126684 <__reset+0xfb106684>
811266ac:	d9801e04 	addi	r6,sp,120
811266b0:	b80b883a 	mov	r5,r23
811266b4:	8009883a 	mov	r4,r16
811266b8:	113160c0 	call	8113160c <__sprint_r>
811266bc:	103d151e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
811266c0:	8c7ffc04 	addi	r17,r17,-16
811266c4:	d8c02017 	ldw	r3,128(sp)
811266c8:	d8801f17 	ldw	r2,124(sp)
811266cc:	da000404 	addi	r8,sp,16
811266d0:	e47fef16 	blt	fp,r17,81126690 <__reset+0xfb106690>
811266d4:	9021883a 	mov	r16,r18
811266d8:	a825883a 	mov	r18,r21
811266dc:	b02b883a 	mov	r21,r22
811266e0:	882d883a 	mov	r22,r17
811266e4:	dc403017 	ldw	r17,192(sp)
811266e8:	d9002b17 	ldw	r4,172(sp)
811266ec:	1d87883a 	add	r3,r3,r22
811266f0:	10800044 	addi	r2,r2,1
811266f4:	41000015 	stw	r4,0(r8)
811266f8:	45800115 	stw	r22,4(r8)
811266fc:	d8c02015 	stw	r3,128(sp)
81126700:	d8801f15 	stw	r2,124(sp)
81126704:	010001c4 	movi	r4,7
81126708:	20818e16 	blt	r4,r2,81126d44 <___vfprintf_internal_r+0x1640>
8112670c:	42000204 	addi	r8,r8,8
81126710:	003e3106 	br	81125fd8 <__reset+0xfb105fd8>
81126714:	d9403317 	ldw	r5,204(sp)
81126718:	00800044 	movi	r2,1
8112671c:	18c00044 	addi	r3,r3,1
81126720:	1141530e 	bge	r2,r5,81126c70 <___vfprintf_internal_r+0x156c>
81126724:	dc401f17 	ldw	r17,124(sp)
81126728:	00800044 	movi	r2,1
8112672c:	40800115 	stw	r2,4(r8)
81126730:	8c400044 	addi	r17,r17,1
81126734:	44000015 	stw	r16,0(r8)
81126738:	d8c02015 	stw	r3,128(sp)
8112673c:	dc401f15 	stw	r17,124(sp)
81126740:	008001c4 	movi	r2,7
81126744:	14416b16 	blt	r2,r17,81126cf4 <___vfprintf_internal_r+0x15f0>
81126748:	42000204 	addi	r8,r8,8
8112674c:	d8803717 	ldw	r2,220(sp)
81126750:	d9003417 	ldw	r4,208(sp)
81126754:	8c400044 	addi	r17,r17,1
81126758:	10c7883a 	add	r3,r2,r3
8112675c:	40800115 	stw	r2,4(r8)
81126760:	41000015 	stw	r4,0(r8)
81126764:	d8c02015 	stw	r3,128(sp)
81126768:	dc401f15 	stw	r17,124(sp)
8112676c:	008001c4 	movi	r2,7
81126770:	14416916 	blt	r2,r17,81126d18 <___vfprintf_internal_r+0x1614>
81126774:	45800204 	addi	r22,r8,8
81126778:	d9003617 	ldw	r4,216(sp)
8112677c:	d9403817 	ldw	r5,224(sp)
81126780:	000d883a 	mov	r6,zero
81126784:	000f883a 	mov	r7,zero
81126788:	d8c03c15 	stw	r3,240(sp)
8112678c:	1135dd80 	call	81135dd8 <__eqdf2>
81126790:	d8c03c17 	ldw	r3,240(sp)
81126794:	1000bc26 	beq	r2,zero,81126a88 <___vfprintf_internal_r+0x1384>
81126798:	d9403317 	ldw	r5,204(sp)
8112679c:	84000044 	addi	r16,r16,1
811267a0:	8c400044 	addi	r17,r17,1
811267a4:	28bfffc4 	addi	r2,r5,-1
811267a8:	1887883a 	add	r3,r3,r2
811267ac:	b0800115 	stw	r2,4(r22)
811267b0:	b4000015 	stw	r16,0(r22)
811267b4:	d8c02015 	stw	r3,128(sp)
811267b8:	dc401f15 	stw	r17,124(sp)
811267bc:	008001c4 	movi	r2,7
811267c0:	14414316 	blt	r2,r17,81126cd0 <___vfprintf_internal_r+0x15cc>
811267c4:	b5800204 	addi	r22,r22,8
811267c8:	d9003a17 	ldw	r4,232(sp)
811267cc:	df0022c4 	addi	fp,sp,139
811267d0:	8c400044 	addi	r17,r17,1
811267d4:	20c7883a 	add	r3,r4,r3
811267d8:	b7000015 	stw	fp,0(r22)
811267dc:	b1000115 	stw	r4,4(r22)
811267e0:	d8c02015 	stw	r3,128(sp)
811267e4:	dc401f15 	stw	r17,124(sp)
811267e8:	008001c4 	movi	r2,7
811267ec:	14400e16 	blt	r2,r17,81126828 <___vfprintf_internal_r+0x1124>
811267f0:	b2000204 	addi	r8,r22,8
811267f4:	003e3a06 	br	811260e0 <__reset+0xfb1060e0>
811267f8:	01204574 	movhi	r4,33045
811267fc:	21022d84 	addi	r4,r4,2230
81126800:	d9002b15 	stw	r4,172(sp)
81126804:	d9002b17 	ldw	r4,172(sp)
81126808:	1c07883a 	add	r3,r3,r16
8112680c:	44000115 	stw	r16,4(r8)
81126810:	41000015 	stw	r4,0(r8)
81126814:	10800044 	addi	r2,r2,1
81126818:	d8c02015 	stw	r3,128(sp)
8112681c:	d8801f15 	stw	r2,124(sp)
81126820:	010001c4 	movi	r4,7
81126824:	20be2d0e 	bge	r4,r2,811260dc <__reset+0xfb1060dc>
81126828:	d9002c17 	ldw	r4,176(sp)
8112682c:	d9801e04 	addi	r6,sp,120
81126830:	b80b883a 	mov	r5,r23
81126834:	113160c0 	call	8113160c <__sprint_r>
81126838:	103cb61e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
8112683c:	d8c02017 	ldw	r3,128(sp)
81126840:	da000404 	addi	r8,sp,16
81126844:	003e2606 	br	811260e0 <__reset+0xfb1060e0>
81126848:	d9002c17 	ldw	r4,176(sp)
8112684c:	d9801e04 	addi	r6,sp,120
81126850:	b80b883a 	mov	r5,r23
81126854:	113160c0 	call	8113160c <__sprint_r>
81126858:	103e5d26 	beq	r2,zero,811261d0 <__reset+0xfb1061d0>
8112685c:	003cad06 	br	81125b14 <__reset+0xfb105b14>
81126860:	d9002c17 	ldw	r4,176(sp)
81126864:	d9801e04 	addi	r6,sp,120
81126868:	b80b883a 	mov	r5,r23
8112686c:	113160c0 	call	8113160c <__sprint_r>
81126870:	103ca81e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126874:	d8c02017 	ldw	r3,128(sp)
81126878:	da000404 	addi	r8,sp,16
8112687c:	003e0b06 	br	811260ac <__reset+0xfb1060ac>
81126880:	d9002c17 	ldw	r4,176(sp)
81126884:	d9801e04 	addi	r6,sp,120
81126888:	b80b883a 	mov	r5,r23
8112688c:	113160c0 	call	8113160c <__sprint_r>
81126890:	103ca01e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126894:	d8c02017 	ldw	r3,128(sp)
81126898:	da000404 	addi	r8,sp,16
8112689c:	003dbd06 	br	81125f94 <__reset+0xfb105f94>
811268a0:	d9002c17 	ldw	r4,176(sp)
811268a4:	d9801e04 	addi	r6,sp,120
811268a8:	b80b883a 	mov	r5,r23
811268ac:	113160c0 	call	8113160c <__sprint_r>
811268b0:	103c981e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
811268b4:	d8c02017 	ldw	r3,128(sp)
811268b8:	da000404 	addi	r8,sp,16
811268bc:	003dc306 	br	81125fcc <__reset+0xfb105fcc>
811268c0:	d8802917 	ldw	r2,164(sp)
811268c4:	d8002785 	stb	zero,158(sp)
811268c8:	103f0616 	blt	r2,zero,811264e4 <__reset+0xfb1064e4>
811268cc:	00ffdfc4 	movi	r3,-129
811268d0:	9d84b03a 	or	r2,r19,r22
811268d4:	90e4703a 	and	r18,r18,r3
811268d8:	103c6b26 	beq	r2,zero,81125a88 <__reset+0xfb105a88>
811268dc:	0039883a 	mov	fp,zero
811268e0:	003e7406 	br	811262b4 <__reset+0xfb1062b4>
811268e4:	9080040c 	andi	r2,r18,16
811268e8:	1001b326 	beq	r2,zero,81126fb8 <___vfprintf_internal_r+0x18b4>
811268ec:	d9002d17 	ldw	r4,180(sp)
811268f0:	d9402917 	ldw	r5,164(sp)
811268f4:	d8002785 	stb	zero,158(sp)
811268f8:	20800104 	addi	r2,r4,4
811268fc:	24c00017 	ldw	r19,0(r4)
81126900:	002d883a 	mov	r22,zero
81126904:	2801b516 	blt	r5,zero,81126fdc <___vfprintf_internal_r+0x18d8>
81126908:	00ffdfc4 	movi	r3,-129
8112690c:	d8802d15 	stw	r2,180(sp)
81126910:	90e4703a 	and	r18,r18,r3
81126914:	983d2726 	beq	r19,zero,81125db4 <__reset+0xfb105db4>
81126918:	0039883a 	mov	fp,zero
8112691c:	003d2a06 	br	81125dc8 <__reset+0xfb105dc8>
81126920:	dc402617 	ldw	r17,152(sp)
81126924:	0441d30e 	bge	zero,r17,81127074 <___vfprintf_internal_r+0x1970>
81126928:	dc403217 	ldw	r17,200(sp)
8112692c:	d8803317 	ldw	r2,204(sp)
81126930:	1440010e 	bge	r2,r17,81126938 <___vfprintf_internal_r+0x1234>
81126934:	1023883a 	mov	r17,r2
81126938:	04400a0e 	bge	zero,r17,81126964 <___vfprintf_internal_r+0x1260>
8112693c:	d8801f17 	ldw	r2,124(sp)
81126940:	1c47883a 	add	r3,r3,r17
81126944:	44000015 	stw	r16,0(r8)
81126948:	10800044 	addi	r2,r2,1
8112694c:	44400115 	stw	r17,4(r8)
81126950:	d8c02015 	stw	r3,128(sp)
81126954:	d8801f15 	stw	r2,124(sp)
81126958:	010001c4 	movi	r4,7
8112695c:	20826516 	blt	r4,r2,811272f4 <___vfprintf_internal_r+0x1bf0>
81126960:	42000204 	addi	r8,r8,8
81126964:	88026116 	blt	r17,zero,811272ec <___vfprintf_internal_r+0x1be8>
81126968:	d9003217 	ldw	r4,200(sp)
8112696c:	2463c83a 	sub	r17,r4,r17
81126970:	04407b0e 	bge	zero,r17,81126b60 <___vfprintf_internal_r+0x145c>
81126974:	05800404 	movi	r22,16
81126978:	d8801f17 	ldw	r2,124(sp)
8112697c:	b4419d0e 	bge	r22,r17,81126ff4 <___vfprintf_internal_r+0x18f0>
81126980:	01204574 	movhi	r4,33045
81126984:	21022d84 	addi	r4,r4,2230
81126988:	d9002b15 	stw	r4,172(sp)
8112698c:	070001c4 	movi	fp,7
81126990:	dcc02c17 	ldw	r19,176(sp)
81126994:	00000306 	br	811269a4 <___vfprintf_internal_r+0x12a0>
81126998:	42000204 	addi	r8,r8,8
8112699c:	8c7ffc04 	addi	r17,r17,-16
811269a0:	b441970e 	bge	r22,r17,81127000 <___vfprintf_internal_r+0x18fc>
811269a4:	18c00404 	addi	r3,r3,16
811269a8:	10800044 	addi	r2,r2,1
811269ac:	45000015 	stw	r20,0(r8)
811269b0:	45800115 	stw	r22,4(r8)
811269b4:	d8c02015 	stw	r3,128(sp)
811269b8:	d8801f15 	stw	r2,124(sp)
811269bc:	e0bff60e 	bge	fp,r2,81126998 <__reset+0xfb106998>
811269c0:	d9801e04 	addi	r6,sp,120
811269c4:	b80b883a 	mov	r5,r23
811269c8:	9809883a 	mov	r4,r19
811269cc:	113160c0 	call	8113160c <__sprint_r>
811269d0:	103c501e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
811269d4:	d8c02017 	ldw	r3,128(sp)
811269d8:	d8801f17 	ldw	r2,124(sp)
811269dc:	da000404 	addi	r8,sp,16
811269e0:	003fee06 	br	8112699c <__reset+0xfb10699c>
811269e4:	d9002c17 	ldw	r4,176(sp)
811269e8:	d9801e04 	addi	r6,sp,120
811269ec:	b80b883a 	mov	r5,r23
811269f0:	113160c0 	call	8113160c <__sprint_r>
811269f4:	103c471e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
811269f8:	d8c02017 	ldw	r3,128(sp)
811269fc:	df002787 	ldb	fp,158(sp)
81126a00:	da000404 	addi	r8,sp,16
81126a04:	003d5606 	br	81125f60 <__reset+0xfb105f60>
81126a08:	9080040c 	andi	r2,r18,16
81126a0c:	10016126 	beq	r2,zero,81126f94 <___vfprintf_internal_r+0x1890>
81126a10:	d8802d17 	ldw	r2,180(sp)
81126a14:	14c00017 	ldw	r19,0(r2)
81126a18:	10800104 	addi	r2,r2,4
81126a1c:	d8802d15 	stw	r2,180(sp)
81126a20:	982dd7fa 	srai	r22,r19,31
81126a24:	b005883a 	mov	r2,r22
81126a28:	003c8206 	br	81125c34 <__reset+0xfb105c34>
81126a2c:	9080040c 	andi	r2,r18,16
81126a30:	10003526 	beq	r2,zero,81126b08 <___vfprintf_internal_r+0x1404>
81126a34:	d9402d17 	ldw	r5,180(sp)
81126a38:	d8c02917 	ldw	r3,164(sp)
81126a3c:	d8002785 	stb	zero,158(sp)
81126a40:	28800104 	addi	r2,r5,4
81126a44:	2cc00017 	ldw	r19,0(r5)
81126a48:	002d883a 	mov	r22,zero
81126a4c:	18003716 	blt	r3,zero,81126b2c <___vfprintf_internal_r+0x1428>
81126a50:	00ffdfc4 	movi	r3,-129
81126a54:	d8802d15 	stw	r2,180(sp)
81126a58:	90e4703a 	and	r18,r18,r3
81126a5c:	0039883a 	mov	fp,zero
81126a60:	983df326 	beq	r19,zero,81126230 <__reset+0xfb106230>
81126a64:	00800244 	movi	r2,9
81126a68:	14fc7b36 	bltu	r2,r19,81125c58 <__reset+0xfb105c58>
81126a6c:	d8c02817 	ldw	r3,160(sp)
81126a70:	dc001dc4 	addi	r16,sp,119
81126a74:	9cc00c04 	addi	r19,r19,48
81126a78:	1c07c83a 	sub	r3,r3,r16
81126a7c:	dcc01dc5 	stb	r19,119(sp)
81126a80:	d8c02e15 	stw	r3,184(sp)
81126a84:	003ce806 	br	81125e28 <__reset+0xfb105e28>
81126a88:	d8803317 	ldw	r2,204(sp)
81126a8c:	143fffc4 	addi	r16,r2,-1
81126a90:	043f4d0e 	bge	zero,r16,811267c8 <__reset+0xfb1067c8>
81126a94:	07000404 	movi	fp,16
81126a98:	e400810e 	bge	fp,r16,81126ca0 <___vfprintf_internal_r+0x159c>
81126a9c:	01604574 	movhi	r5,33045
81126aa0:	29422d84 	addi	r5,r5,2230
81126aa4:	d9402b15 	stw	r5,172(sp)
81126aa8:	01c001c4 	movi	r7,7
81126aac:	dcc02c17 	ldw	r19,176(sp)
81126ab0:	00000306 	br	81126ac0 <___vfprintf_internal_r+0x13bc>
81126ab4:	b5800204 	addi	r22,r22,8
81126ab8:	843ffc04 	addi	r16,r16,-16
81126abc:	e4007b0e 	bge	fp,r16,81126cac <___vfprintf_internal_r+0x15a8>
81126ac0:	18c00404 	addi	r3,r3,16
81126ac4:	8c400044 	addi	r17,r17,1
81126ac8:	b5000015 	stw	r20,0(r22)
81126acc:	b7000115 	stw	fp,4(r22)
81126ad0:	d8c02015 	stw	r3,128(sp)
81126ad4:	dc401f15 	stw	r17,124(sp)
81126ad8:	3c7ff60e 	bge	r7,r17,81126ab4 <__reset+0xfb106ab4>
81126adc:	d9801e04 	addi	r6,sp,120
81126ae0:	b80b883a 	mov	r5,r23
81126ae4:	9809883a 	mov	r4,r19
81126ae8:	d9c03c15 	stw	r7,240(sp)
81126aec:	113160c0 	call	8113160c <__sprint_r>
81126af0:	d9c03c17 	ldw	r7,240(sp)
81126af4:	103c071e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126af8:	d8c02017 	ldw	r3,128(sp)
81126afc:	dc401f17 	ldw	r17,124(sp)
81126b00:	dd800404 	addi	r22,sp,16
81126b04:	003fec06 	br	81126ab8 <__reset+0xfb106ab8>
81126b08:	9080100c 	andi	r2,r18,64
81126b0c:	d8002785 	stb	zero,158(sp)
81126b10:	10010e26 	beq	r2,zero,81126f4c <___vfprintf_internal_r+0x1848>
81126b14:	d9002d17 	ldw	r4,180(sp)
81126b18:	d9402917 	ldw	r5,164(sp)
81126b1c:	002d883a 	mov	r22,zero
81126b20:	20800104 	addi	r2,r4,4
81126b24:	24c0000b 	ldhu	r19,0(r4)
81126b28:	283fc90e 	bge	r5,zero,81126a50 <__reset+0xfb106a50>
81126b2c:	d8802d15 	stw	r2,180(sp)
81126b30:	0039883a 	mov	fp,zero
81126b34:	9d84b03a 	or	r2,r19,r22
81126b38:	103c461e 	bne	r2,zero,81125c54 <__reset+0xfb105c54>
81126b3c:	00800044 	movi	r2,1
81126b40:	003e6c06 	br	811264f4 <__reset+0xfb1064f4>
81126b44:	d9002c17 	ldw	r4,176(sp)
81126b48:	d9801e04 	addi	r6,sp,120
81126b4c:	b80b883a 	mov	r5,r23
81126b50:	113160c0 	call	8113160c <__sprint_r>
81126b54:	103bef1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126b58:	d8c02017 	ldw	r3,128(sp)
81126b5c:	da000404 	addi	r8,sp,16
81126b60:	d9003217 	ldw	r4,200(sp)
81126b64:	d8802617 	ldw	r2,152(sp)
81126b68:	d9403317 	ldw	r5,204(sp)
81126b6c:	8123883a 	add	r17,r16,r4
81126b70:	11400216 	blt	r2,r5,81126b7c <___vfprintf_internal_r+0x1478>
81126b74:	9100004c 	andi	r4,r18,1
81126b78:	20000d26 	beq	r4,zero,81126bb0 <___vfprintf_internal_r+0x14ac>
81126b7c:	d9003717 	ldw	r4,220(sp)
81126b80:	d9403417 	ldw	r5,208(sp)
81126b84:	1907883a 	add	r3,r3,r4
81126b88:	d9001f17 	ldw	r4,124(sp)
81126b8c:	41400015 	stw	r5,0(r8)
81126b90:	d9403717 	ldw	r5,220(sp)
81126b94:	21000044 	addi	r4,r4,1
81126b98:	d8c02015 	stw	r3,128(sp)
81126b9c:	41400115 	stw	r5,4(r8)
81126ba0:	d9001f15 	stw	r4,124(sp)
81126ba4:	014001c4 	movi	r5,7
81126ba8:	2901e816 	blt	r5,r4,8112734c <___vfprintf_internal_r+0x1c48>
81126bac:	42000204 	addi	r8,r8,8
81126bb0:	d9003317 	ldw	r4,204(sp)
81126bb4:	8121883a 	add	r16,r16,r4
81126bb8:	2085c83a 	sub	r2,r4,r2
81126bbc:	8461c83a 	sub	r16,r16,r17
81126bc0:	1400010e 	bge	r2,r16,81126bc8 <___vfprintf_internal_r+0x14c4>
81126bc4:	1021883a 	mov	r16,r2
81126bc8:	04000a0e 	bge	zero,r16,81126bf4 <___vfprintf_internal_r+0x14f0>
81126bcc:	d9001f17 	ldw	r4,124(sp)
81126bd0:	1c07883a 	add	r3,r3,r16
81126bd4:	44400015 	stw	r17,0(r8)
81126bd8:	21000044 	addi	r4,r4,1
81126bdc:	44000115 	stw	r16,4(r8)
81126be0:	d8c02015 	stw	r3,128(sp)
81126be4:	d9001f15 	stw	r4,124(sp)
81126be8:	014001c4 	movi	r5,7
81126bec:	2901fb16 	blt	r5,r4,811273dc <___vfprintf_internal_r+0x1cd8>
81126bf0:	42000204 	addi	r8,r8,8
81126bf4:	8001f716 	blt	r16,zero,811273d4 <___vfprintf_internal_r+0x1cd0>
81126bf8:	1421c83a 	sub	r16,r2,r16
81126bfc:	043d380e 	bge	zero,r16,811260e0 <__reset+0xfb1060e0>
81126c00:	04400404 	movi	r17,16
81126c04:	d8801f17 	ldw	r2,124(sp)
81126c08:	8c3efb0e 	bge	r17,r16,811267f8 <__reset+0xfb1067f8>
81126c0c:	01604574 	movhi	r5,33045
81126c10:	29422d84 	addi	r5,r5,2230
81126c14:	d9402b15 	stw	r5,172(sp)
81126c18:	058001c4 	movi	r22,7
81126c1c:	dcc02c17 	ldw	r19,176(sp)
81126c20:	00000306 	br	81126c30 <___vfprintf_internal_r+0x152c>
81126c24:	42000204 	addi	r8,r8,8
81126c28:	843ffc04 	addi	r16,r16,-16
81126c2c:	8c3ef50e 	bge	r17,r16,81126804 <__reset+0xfb106804>
81126c30:	18c00404 	addi	r3,r3,16
81126c34:	10800044 	addi	r2,r2,1
81126c38:	45000015 	stw	r20,0(r8)
81126c3c:	44400115 	stw	r17,4(r8)
81126c40:	d8c02015 	stw	r3,128(sp)
81126c44:	d8801f15 	stw	r2,124(sp)
81126c48:	b0bff60e 	bge	r22,r2,81126c24 <__reset+0xfb106c24>
81126c4c:	d9801e04 	addi	r6,sp,120
81126c50:	b80b883a 	mov	r5,r23
81126c54:	9809883a 	mov	r4,r19
81126c58:	113160c0 	call	8113160c <__sprint_r>
81126c5c:	103bad1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126c60:	d8c02017 	ldw	r3,128(sp)
81126c64:	d8801f17 	ldw	r2,124(sp)
81126c68:	da000404 	addi	r8,sp,16
81126c6c:	003fee06 	br	81126c28 <__reset+0xfb106c28>
81126c70:	9088703a 	and	r4,r18,r2
81126c74:	203eab1e 	bne	r4,zero,81126724 <__reset+0xfb106724>
81126c78:	dc401f17 	ldw	r17,124(sp)
81126c7c:	40800115 	stw	r2,4(r8)
81126c80:	44000015 	stw	r16,0(r8)
81126c84:	8c400044 	addi	r17,r17,1
81126c88:	d8c02015 	stw	r3,128(sp)
81126c8c:	dc401f15 	stw	r17,124(sp)
81126c90:	008001c4 	movi	r2,7
81126c94:	14400e16 	blt	r2,r17,81126cd0 <___vfprintf_internal_r+0x15cc>
81126c98:	45800204 	addi	r22,r8,8
81126c9c:	003eca06 	br	811267c8 <__reset+0xfb1067c8>
81126ca0:	01204574 	movhi	r4,33045
81126ca4:	21022d84 	addi	r4,r4,2230
81126ca8:	d9002b15 	stw	r4,172(sp)
81126cac:	d8802b17 	ldw	r2,172(sp)
81126cb0:	1c07883a 	add	r3,r3,r16
81126cb4:	8c400044 	addi	r17,r17,1
81126cb8:	b0800015 	stw	r2,0(r22)
81126cbc:	b4000115 	stw	r16,4(r22)
81126cc0:	d8c02015 	stw	r3,128(sp)
81126cc4:	dc401f15 	stw	r17,124(sp)
81126cc8:	008001c4 	movi	r2,7
81126ccc:	147ebd0e 	bge	r2,r17,811267c4 <__reset+0xfb1067c4>
81126cd0:	d9002c17 	ldw	r4,176(sp)
81126cd4:	d9801e04 	addi	r6,sp,120
81126cd8:	b80b883a 	mov	r5,r23
81126cdc:	113160c0 	call	8113160c <__sprint_r>
81126ce0:	103b8c1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126ce4:	d8c02017 	ldw	r3,128(sp)
81126ce8:	dc401f17 	ldw	r17,124(sp)
81126cec:	dd800404 	addi	r22,sp,16
81126cf0:	003eb506 	br	811267c8 <__reset+0xfb1067c8>
81126cf4:	d9002c17 	ldw	r4,176(sp)
81126cf8:	d9801e04 	addi	r6,sp,120
81126cfc:	b80b883a 	mov	r5,r23
81126d00:	113160c0 	call	8113160c <__sprint_r>
81126d04:	103b831e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126d08:	d8c02017 	ldw	r3,128(sp)
81126d0c:	dc401f17 	ldw	r17,124(sp)
81126d10:	da000404 	addi	r8,sp,16
81126d14:	003e8d06 	br	8112674c <__reset+0xfb10674c>
81126d18:	d9002c17 	ldw	r4,176(sp)
81126d1c:	d9801e04 	addi	r6,sp,120
81126d20:	b80b883a 	mov	r5,r23
81126d24:	113160c0 	call	8113160c <__sprint_r>
81126d28:	103b7a1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126d2c:	d8c02017 	ldw	r3,128(sp)
81126d30:	dc401f17 	ldw	r17,124(sp)
81126d34:	dd800404 	addi	r22,sp,16
81126d38:	003e8f06 	br	81126778 <__reset+0xfb106778>
81126d3c:	0027883a 	mov	r19,zero
81126d40:	003f4a06 	br	81126a6c <__reset+0xfb106a6c>
81126d44:	d9002c17 	ldw	r4,176(sp)
81126d48:	d9801e04 	addi	r6,sp,120
81126d4c:	b80b883a 	mov	r5,r23
81126d50:	113160c0 	call	8113160c <__sprint_r>
81126d54:	103b6f1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81126d58:	d8c02017 	ldw	r3,128(sp)
81126d5c:	da000404 	addi	r8,sp,16
81126d60:	003c9d06 	br	81125fd8 <__reset+0xfb105fd8>
81126d64:	04e7c83a 	sub	r19,zero,r19
81126d68:	9804c03a 	cmpne	r2,r19,zero
81126d6c:	05adc83a 	sub	r22,zero,r22
81126d70:	b0adc83a 	sub	r22,r22,r2
81126d74:	d8802917 	ldw	r2,164(sp)
81126d78:	07000b44 	movi	fp,45
81126d7c:	df002785 	stb	fp,158(sp)
81126d80:	10017b16 	blt	r2,zero,81127370 <___vfprintf_internal_r+0x1c6c>
81126d84:	00bfdfc4 	movi	r2,-129
81126d88:	90a4703a 	and	r18,r18,r2
81126d8c:	003bb106 	br	81125c54 <__reset+0xfb105c54>
81126d90:	d9003617 	ldw	r4,216(sp)
81126d94:	d9403817 	ldw	r5,224(sp)
81126d98:	da003d15 	stw	r8,244(sp)
81126d9c:	112df580 	call	8112df58 <__fpclassifyd>
81126da0:	da003d17 	ldw	r8,244(sp)
81126da4:	1000f026 	beq	r2,zero,81127168 <___vfprintf_internal_r+0x1a64>
81126da8:	d9002917 	ldw	r4,164(sp)
81126dac:	05bff7c4 	movi	r22,-33
81126db0:	00bfffc4 	movi	r2,-1
81126db4:	8dac703a 	and	r22,r17,r22
81126db8:	20820026 	beq	r4,r2,811275bc <___vfprintf_internal_r+0x1eb8>
81126dbc:	008011c4 	movi	r2,71
81126dc0:	b081f726 	beq	r22,r2,811275a0 <___vfprintf_internal_r+0x1e9c>
81126dc4:	d9003817 	ldw	r4,224(sp)
81126dc8:	90c04014 	ori	r3,r18,256
81126dcc:	d8c02b15 	stw	r3,172(sp)
81126dd0:	20021516 	blt	r4,zero,81127628 <___vfprintf_internal_r+0x1f24>
81126dd4:	dcc03817 	ldw	r19,224(sp)
81126dd8:	d8002a05 	stb	zero,168(sp)
81126ddc:	00801984 	movi	r2,102
81126de0:	8881f926 	beq	r17,r2,811275c8 <___vfprintf_internal_r+0x1ec4>
81126de4:	00801184 	movi	r2,70
81126de8:	88821c26 	beq	r17,r2,8112765c <___vfprintf_internal_r+0x1f58>
81126dec:	00801144 	movi	r2,69
81126df0:	b081ef26 	beq	r22,r2,811275b0 <___vfprintf_internal_r+0x1eac>
81126df4:	d8c02917 	ldw	r3,164(sp)
81126df8:	d8802104 	addi	r2,sp,132
81126dfc:	d8800315 	stw	r2,12(sp)
81126e00:	d9403617 	ldw	r5,216(sp)
81126e04:	d8802504 	addi	r2,sp,148
81126e08:	d9002c17 	ldw	r4,176(sp)
81126e0c:	d8800215 	stw	r2,8(sp)
81126e10:	d8802604 	addi	r2,sp,152
81126e14:	d8c00015 	stw	r3,0(sp)
81126e18:	d8800115 	stw	r2,4(sp)
81126e1c:	01c00084 	movi	r7,2
81126e20:	980d883a 	mov	r6,r19
81126e24:	d8c03c15 	stw	r3,240(sp)
81126e28:	da003d15 	stw	r8,244(sp)
81126e2c:	11298100 	call	81129810 <_dtoa_r>
81126e30:	1021883a 	mov	r16,r2
81126e34:	008019c4 	movi	r2,103
81126e38:	d8c03c17 	ldw	r3,240(sp)
81126e3c:	da003d17 	ldw	r8,244(sp)
81126e40:	88817126 	beq	r17,r2,81127408 <___vfprintf_internal_r+0x1d04>
81126e44:	008011c4 	movi	r2,71
81126e48:	88829226 	beq	r17,r2,81127894 <___vfprintf_internal_r+0x2190>
81126e4c:	80f9883a 	add	fp,r16,r3
81126e50:	d9003617 	ldw	r4,216(sp)
81126e54:	000d883a 	mov	r6,zero
81126e58:	000f883a 	mov	r7,zero
81126e5c:	980b883a 	mov	r5,r19
81126e60:	da003d15 	stw	r8,244(sp)
81126e64:	1135dd80 	call	81135dd8 <__eqdf2>
81126e68:	da003d17 	ldw	r8,244(sp)
81126e6c:	10018d26 	beq	r2,zero,811274a4 <___vfprintf_internal_r+0x1da0>
81126e70:	d8802117 	ldw	r2,132(sp)
81126e74:	1700062e 	bgeu	r2,fp,81126e90 <___vfprintf_internal_r+0x178c>
81126e78:	01000c04 	movi	r4,48
81126e7c:	10c00044 	addi	r3,r2,1
81126e80:	d8c02115 	stw	r3,132(sp)
81126e84:	11000005 	stb	r4,0(r2)
81126e88:	d8802117 	ldw	r2,132(sp)
81126e8c:	173ffb36 	bltu	r2,fp,81126e7c <__reset+0xfb106e7c>
81126e90:	1405c83a 	sub	r2,r2,r16
81126e94:	d8803315 	stw	r2,204(sp)
81126e98:	008011c4 	movi	r2,71
81126e9c:	b0817626 	beq	r22,r2,81127478 <___vfprintf_internal_r+0x1d74>
81126ea0:	00801944 	movi	r2,101
81126ea4:	1442810e 	bge	r2,r17,811278ac <___vfprintf_internal_r+0x21a8>
81126ea8:	d8c02617 	ldw	r3,152(sp)
81126eac:	00801984 	movi	r2,102
81126eb0:	d8c03215 	stw	r3,200(sp)
81126eb4:	8881fe26 	beq	r17,r2,811276b0 <___vfprintf_internal_r+0x1fac>
81126eb8:	d8c03217 	ldw	r3,200(sp)
81126ebc:	d9003317 	ldw	r4,204(sp)
81126ec0:	1901dd16 	blt	r3,r4,81127638 <___vfprintf_internal_r+0x1f34>
81126ec4:	9480004c 	andi	r18,r18,1
81126ec8:	90022b1e 	bne	r18,zero,81127778 <___vfprintf_internal_r+0x2074>
81126ecc:	1805883a 	mov	r2,r3
81126ed0:	18028016 	blt	r3,zero,811278d4 <___vfprintf_internal_r+0x21d0>
81126ed4:	d8c03217 	ldw	r3,200(sp)
81126ed8:	044019c4 	movi	r17,103
81126edc:	d8c02e15 	stw	r3,184(sp)
81126ee0:	df002a07 	ldb	fp,168(sp)
81126ee4:	e001531e 	bne	fp,zero,81127434 <___vfprintf_internal_r+0x1d30>
81126ee8:	df002783 	ldbu	fp,158(sp)
81126eec:	d8802a15 	stw	r2,168(sp)
81126ef0:	dc802b17 	ldw	r18,172(sp)
81126ef4:	d8002915 	stw	zero,164(sp)
81126ef8:	003bd106 	br	81125e40 <__reset+0xfb105e40>
81126efc:	d8802d17 	ldw	r2,180(sp)
81126f00:	d8c02d17 	ldw	r3,180(sp)
81126f04:	d9002d17 	ldw	r4,180(sp)
81126f08:	10800017 	ldw	r2,0(r2)
81126f0c:	18c00117 	ldw	r3,4(r3)
81126f10:	21000204 	addi	r4,r4,8
81126f14:	d8803615 	stw	r2,216(sp)
81126f18:	d8c03815 	stw	r3,224(sp)
81126f1c:	d9002d15 	stw	r4,180(sp)
81126f20:	003b7506 	br	81125cf8 <__reset+0xfb105cf8>
81126f24:	ac400007 	ldb	r17,0(r21)
81126f28:	003a5906 	br	81125890 <__reset+0xfb105890>
81126f2c:	9080100c 	andi	r2,r18,64
81126f30:	1000a826 	beq	r2,zero,811271d4 <___vfprintf_internal_r+0x1ad0>
81126f34:	d9002d17 	ldw	r4,180(sp)
81126f38:	002d883a 	mov	r22,zero
81126f3c:	24c0000b 	ldhu	r19,0(r4)
81126f40:	21000104 	addi	r4,r4,4
81126f44:	d9002d15 	stw	r4,180(sp)
81126f48:	003ccb06 	br	81126278 <__reset+0xfb106278>
81126f4c:	d8c02d17 	ldw	r3,180(sp)
81126f50:	d9002917 	ldw	r4,164(sp)
81126f54:	002d883a 	mov	r22,zero
81126f58:	18800104 	addi	r2,r3,4
81126f5c:	1cc00017 	ldw	r19,0(r3)
81126f60:	203ebb0e 	bge	r4,zero,81126a50 <__reset+0xfb106a50>
81126f64:	003ef106 	br	81126b2c <__reset+0xfb106b2c>
81126f68:	9080040c 	andi	r2,r18,16
81126f6c:	1000921e 	bne	r2,zero,811271b8 <___vfprintf_internal_r+0x1ab4>
81126f70:	9480100c 	andi	r18,r18,64
81126f74:	90013926 	beq	r18,zero,8112745c <___vfprintf_internal_r+0x1d58>
81126f78:	d9002d17 	ldw	r4,180(sp)
81126f7c:	d9402f17 	ldw	r5,188(sp)
81126f80:	20800017 	ldw	r2,0(r4)
81126f84:	21000104 	addi	r4,r4,4
81126f88:	d9002d15 	stw	r4,180(sp)
81126f8c:	1140000d 	sth	r5,0(r2)
81126f90:	003a1606 	br	811257ec <__reset+0xfb1057ec>
81126f94:	9080100c 	andi	r2,r18,64
81126f98:	10008026 	beq	r2,zero,8112719c <___vfprintf_internal_r+0x1a98>
81126f9c:	d8c02d17 	ldw	r3,180(sp)
81126fa0:	1cc0000f 	ldh	r19,0(r3)
81126fa4:	18c00104 	addi	r3,r3,4
81126fa8:	d8c02d15 	stw	r3,180(sp)
81126fac:	982dd7fa 	srai	r22,r19,31
81126fb0:	b005883a 	mov	r2,r22
81126fb4:	003b1f06 	br	81125c34 <__reset+0xfb105c34>
81126fb8:	9080100c 	andi	r2,r18,64
81126fbc:	d8002785 	stb	zero,158(sp)
81126fc0:	10008a1e 	bne	r2,zero,811271ec <___vfprintf_internal_r+0x1ae8>
81126fc4:	d9402d17 	ldw	r5,180(sp)
81126fc8:	d8c02917 	ldw	r3,164(sp)
81126fcc:	002d883a 	mov	r22,zero
81126fd0:	28800104 	addi	r2,r5,4
81126fd4:	2cc00017 	ldw	r19,0(r5)
81126fd8:	183e4b0e 	bge	r3,zero,81126908 <__reset+0xfb106908>
81126fdc:	9d86b03a 	or	r3,r19,r22
81126fe0:	d8802d15 	stw	r2,180(sp)
81126fe4:	183e4c1e 	bne	r3,zero,81126918 <__reset+0xfb106918>
81126fe8:	0039883a 	mov	fp,zero
81126fec:	0005883a 	mov	r2,zero
81126ff0:	003d4006 	br	811264f4 <__reset+0xfb1064f4>
81126ff4:	01604574 	movhi	r5,33045
81126ff8:	29422d84 	addi	r5,r5,2230
81126ffc:	d9402b15 	stw	r5,172(sp)
81127000:	d9402b17 	ldw	r5,172(sp)
81127004:	1c47883a 	add	r3,r3,r17
81127008:	10800044 	addi	r2,r2,1
8112700c:	41400015 	stw	r5,0(r8)
81127010:	44400115 	stw	r17,4(r8)
81127014:	d8c02015 	stw	r3,128(sp)
81127018:	d8801f15 	stw	r2,124(sp)
8112701c:	010001c4 	movi	r4,7
81127020:	20bec816 	blt	r4,r2,81126b44 <__reset+0xfb106b44>
81127024:	42000204 	addi	r8,r8,8
81127028:	003ecd06 	br	81126b60 <__reset+0xfb106b60>
8112702c:	d9002917 	ldw	r4,164(sp)
81127030:	d8002785 	stb	zero,158(sp)
81127034:	203d2d16 	blt	r4,zero,811264ec <__reset+0xfb1064ec>
81127038:	00bfdfc4 	movi	r2,-129
8112703c:	90a4703a 	and	r18,r18,r2
81127040:	003a9106 	br	81125a88 <__reset+0xfb105a88>
81127044:	01204574 	movhi	r4,33045
81127048:	21022d84 	addi	r4,r4,2230
8112704c:	d9002b15 	stw	r4,172(sp)
81127050:	003c0c06 	br	81126084 <__reset+0xfb106084>
81127054:	d9002c17 	ldw	r4,176(sp)
81127058:	d9801e04 	addi	r6,sp,120
8112705c:	b80b883a 	mov	r5,r23
81127060:	113160c0 	call	8113160c <__sprint_r>
81127064:	103aab1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81127068:	d8c02017 	ldw	r3,128(sp)
8112706c:	da000404 	addi	r8,sp,16
81127070:	003d4106 	br	81126578 <__reset+0xfb106578>
81127074:	d8801f17 	ldw	r2,124(sp)
81127078:	01604574 	movhi	r5,33045
8112707c:	01000044 	movi	r4,1
81127080:	18c00044 	addi	r3,r3,1
81127084:	10800044 	addi	r2,r2,1
81127088:	29422504 	addi	r5,r5,2196
8112708c:	41000115 	stw	r4,4(r8)
81127090:	41400015 	stw	r5,0(r8)
81127094:	d8c02015 	stw	r3,128(sp)
81127098:	d8801f15 	stw	r2,124(sp)
8112709c:	010001c4 	movi	r4,7
811270a0:	20805c16 	blt	r4,r2,81127214 <___vfprintf_internal_r+0x1b10>
811270a4:	42000204 	addi	r8,r8,8
811270a8:	8800041e 	bne	r17,zero,811270bc <___vfprintf_internal_r+0x19b8>
811270ac:	d8803317 	ldw	r2,204(sp)
811270b0:	1000021e 	bne	r2,zero,811270bc <___vfprintf_internal_r+0x19b8>
811270b4:	9080004c 	andi	r2,r18,1
811270b8:	103c0926 	beq	r2,zero,811260e0 <__reset+0xfb1060e0>
811270bc:	d9003717 	ldw	r4,220(sp)
811270c0:	d8801f17 	ldw	r2,124(sp)
811270c4:	d9403417 	ldw	r5,208(sp)
811270c8:	20c7883a 	add	r3,r4,r3
811270cc:	10800044 	addi	r2,r2,1
811270d0:	41000115 	stw	r4,4(r8)
811270d4:	41400015 	stw	r5,0(r8)
811270d8:	d8c02015 	stw	r3,128(sp)
811270dc:	d8801f15 	stw	r2,124(sp)
811270e0:	010001c4 	movi	r4,7
811270e4:	20812116 	blt	r4,r2,8112756c <___vfprintf_internal_r+0x1e68>
811270e8:	42000204 	addi	r8,r8,8
811270ec:	0463c83a 	sub	r17,zero,r17
811270f0:	0440730e 	bge	zero,r17,811272c0 <___vfprintf_internal_r+0x1bbc>
811270f4:	05800404 	movi	r22,16
811270f8:	b440860e 	bge	r22,r17,81127314 <___vfprintf_internal_r+0x1c10>
811270fc:	01604574 	movhi	r5,33045
81127100:	29422d84 	addi	r5,r5,2230
81127104:	d9402b15 	stw	r5,172(sp)
81127108:	070001c4 	movi	fp,7
8112710c:	dcc02c17 	ldw	r19,176(sp)
81127110:	00000306 	br	81127120 <___vfprintf_internal_r+0x1a1c>
81127114:	42000204 	addi	r8,r8,8
81127118:	8c7ffc04 	addi	r17,r17,-16
8112711c:	b440800e 	bge	r22,r17,81127320 <___vfprintf_internal_r+0x1c1c>
81127120:	18c00404 	addi	r3,r3,16
81127124:	10800044 	addi	r2,r2,1
81127128:	45000015 	stw	r20,0(r8)
8112712c:	45800115 	stw	r22,4(r8)
81127130:	d8c02015 	stw	r3,128(sp)
81127134:	d8801f15 	stw	r2,124(sp)
81127138:	e0bff60e 	bge	fp,r2,81127114 <__reset+0xfb107114>
8112713c:	d9801e04 	addi	r6,sp,120
81127140:	b80b883a 	mov	r5,r23
81127144:	9809883a 	mov	r4,r19
81127148:	113160c0 	call	8113160c <__sprint_r>
8112714c:	103a711e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81127150:	d8c02017 	ldw	r3,128(sp)
81127154:	d8801f17 	ldw	r2,124(sp)
81127158:	da000404 	addi	r8,sp,16
8112715c:	003fee06 	br	81127118 <__reset+0xfb107118>
81127160:	00bfffc4 	movi	r2,-1
81127164:	003a6f06 	br	81125b24 <__reset+0xfb105b24>
81127168:	008011c4 	movi	r2,71
8112716c:	1440b816 	blt	r2,r17,81127450 <___vfprintf_internal_r+0x1d4c>
81127170:	04204574 	movhi	r16,33045
81127174:	84021704 	addi	r16,r16,2140
81127178:	00c000c4 	movi	r3,3
8112717c:	00bfdfc4 	movi	r2,-129
81127180:	d8c02a15 	stw	r3,168(sp)
81127184:	90a4703a 	and	r18,r18,r2
81127188:	df002783 	ldbu	fp,158(sp)
8112718c:	d8c02e15 	stw	r3,184(sp)
81127190:	d8002915 	stw	zero,164(sp)
81127194:	d8003215 	stw	zero,200(sp)
81127198:	003b2906 	br	81125e40 <__reset+0xfb105e40>
8112719c:	d9002d17 	ldw	r4,180(sp)
811271a0:	24c00017 	ldw	r19,0(r4)
811271a4:	21000104 	addi	r4,r4,4
811271a8:	d9002d15 	stw	r4,180(sp)
811271ac:	982dd7fa 	srai	r22,r19,31
811271b0:	b005883a 	mov	r2,r22
811271b4:	003a9f06 	br	81125c34 <__reset+0xfb105c34>
811271b8:	d9402d17 	ldw	r5,180(sp)
811271bc:	d8c02f17 	ldw	r3,188(sp)
811271c0:	28800017 	ldw	r2,0(r5)
811271c4:	29400104 	addi	r5,r5,4
811271c8:	d9402d15 	stw	r5,180(sp)
811271cc:	10c00015 	stw	r3,0(r2)
811271d0:	00398606 	br	811257ec <__reset+0xfb1057ec>
811271d4:	d9402d17 	ldw	r5,180(sp)
811271d8:	002d883a 	mov	r22,zero
811271dc:	2cc00017 	ldw	r19,0(r5)
811271e0:	29400104 	addi	r5,r5,4
811271e4:	d9402d15 	stw	r5,180(sp)
811271e8:	003c2306 	br	81126278 <__reset+0xfb106278>
811271ec:	d8c02d17 	ldw	r3,180(sp)
811271f0:	d9002917 	ldw	r4,164(sp)
811271f4:	002d883a 	mov	r22,zero
811271f8:	18800104 	addi	r2,r3,4
811271fc:	1cc0000b 	ldhu	r19,0(r3)
81127200:	203dc10e 	bge	r4,zero,81126908 <__reset+0xfb106908>
81127204:	003f7506 	br	81126fdc <__reset+0xfb106fdc>
81127208:	04204574 	movhi	r16,33045
8112720c:	84021504 	addi	r16,r16,2132
81127210:	003acc06 	br	81125d44 <__reset+0xfb105d44>
81127214:	d9002c17 	ldw	r4,176(sp)
81127218:	d9801e04 	addi	r6,sp,120
8112721c:	b80b883a 	mov	r5,r23
81127220:	113160c0 	call	8113160c <__sprint_r>
81127224:	103a3b1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81127228:	dc402617 	ldw	r17,152(sp)
8112722c:	d8c02017 	ldw	r3,128(sp)
81127230:	da000404 	addi	r8,sp,16
81127234:	003f9c06 	br	811270a8 <__reset+0xfb1070a8>
81127238:	ac400043 	ldbu	r17,1(r21)
8112723c:	94800814 	ori	r18,r18,32
81127240:	ad400044 	addi	r21,r21,1
81127244:	8c403fcc 	andi	r17,r17,255
81127248:	8c40201c 	xori	r17,r17,128
8112724c:	8c7fe004 	addi	r17,r17,-128
81127250:	00398f06 	br	81125890 <__reset+0xfb105890>
81127254:	d8c02d15 	stw	r3,180(sp)
81127258:	0039883a 	mov	fp,zero
8112725c:	003e3506 	br	81126b34 <__reset+0xfb106b34>
81127260:	d9002c17 	ldw	r4,176(sp)
81127264:	d9801e04 	addi	r6,sp,120
81127268:	b80b883a 	mov	r5,r23
8112726c:	113160c0 	call	8113160c <__sprint_r>
81127270:	103a281e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81127274:	d8c02017 	ldw	r3,128(sp)
81127278:	da000404 	addi	r8,sp,16
8112727c:	003cd006 	br	811265c0 <__reset+0xfb1065c0>
81127280:	8009883a 	mov	r4,r16
81127284:	da003d15 	stw	r8,244(sp)
81127288:	1122ee80 	call	81122ee8 <strlen>
8112728c:	d8802e15 	stw	r2,184(sp)
81127290:	da003d17 	ldw	r8,244(sp)
81127294:	103c340e 	bge	r2,zero,81126368 <__reset+0xfb106368>
81127298:	0005883a 	mov	r2,zero
8112729c:	003c3206 	br	81126368 <__reset+0xfb106368>
811272a0:	d9002c17 	ldw	r4,176(sp)
811272a4:	d9801e04 	addi	r6,sp,120
811272a8:	b80b883a 	mov	r5,r23
811272ac:	113160c0 	call	8113160c <__sprint_r>
811272b0:	103a181e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
811272b4:	d8c02017 	ldw	r3,128(sp)
811272b8:	d8801f17 	ldw	r2,124(sp)
811272bc:	da000404 	addi	r8,sp,16
811272c0:	d9403317 	ldw	r5,204(sp)
811272c4:	10800044 	addi	r2,r2,1
811272c8:	44000015 	stw	r16,0(r8)
811272cc:	28c7883a 	add	r3,r5,r3
811272d0:	003b7d06 	br	811260c8 <__reset+0xfb1060c8>
811272d4:	01204574 	movhi	r4,33045
811272d8:	21023184 	addi	r4,r4,2246
811272dc:	d9003515 	stw	r4,212(sp)
811272e0:	003b1406 	br	81125f34 <__reset+0xfb105f34>
811272e4:	013fffc4 	movi	r4,-1
811272e8:	003a3506 	br	81125bc0 <__reset+0xfb105bc0>
811272ec:	0023883a 	mov	r17,zero
811272f0:	003d9d06 	br	81126968 <__reset+0xfb106968>
811272f4:	d9002c17 	ldw	r4,176(sp)
811272f8:	d9801e04 	addi	r6,sp,120
811272fc:	b80b883a 	mov	r5,r23
81127300:	113160c0 	call	8113160c <__sprint_r>
81127304:	103a031e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81127308:	d8c02017 	ldw	r3,128(sp)
8112730c:	da000404 	addi	r8,sp,16
81127310:	003d9406 	br	81126964 <__reset+0xfb106964>
81127314:	01204574 	movhi	r4,33045
81127318:	21022d84 	addi	r4,r4,2230
8112731c:	d9002b15 	stw	r4,172(sp)
81127320:	d9002b17 	ldw	r4,172(sp)
81127324:	1c47883a 	add	r3,r3,r17
81127328:	10800044 	addi	r2,r2,1
8112732c:	41000015 	stw	r4,0(r8)
81127330:	44400115 	stw	r17,4(r8)
81127334:	d8c02015 	stw	r3,128(sp)
81127338:	d8801f15 	stw	r2,124(sp)
8112733c:	010001c4 	movi	r4,7
81127340:	20bfd716 	blt	r4,r2,811272a0 <__reset+0xfb1072a0>
81127344:	42000204 	addi	r8,r8,8
81127348:	003fdd06 	br	811272c0 <__reset+0xfb1072c0>
8112734c:	d9002c17 	ldw	r4,176(sp)
81127350:	d9801e04 	addi	r6,sp,120
81127354:	b80b883a 	mov	r5,r23
81127358:	113160c0 	call	8113160c <__sprint_r>
8112735c:	1039ed1e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81127360:	d8802617 	ldw	r2,152(sp)
81127364:	d8c02017 	ldw	r3,128(sp)
81127368:	da000404 	addi	r8,sp,16
8112736c:	003e1006 	br	81126bb0 <__reset+0xfb106bb0>
81127370:	00800044 	movi	r2,1
81127374:	10803fcc 	andi	r2,r2,255
81127378:	00c00044 	movi	r3,1
8112737c:	10fa3526 	beq	r2,r3,81125c54 <__reset+0xfb105c54>
81127380:	00c00084 	movi	r3,2
81127384:	10fbcb26 	beq	r2,r3,811262b4 <__reset+0xfb1062b4>
81127388:	003a8f06 	br	81125dc8 <__reset+0xfb105dc8>
8112738c:	01204574 	movhi	r4,33045
81127390:	21023184 	addi	r4,r4,2246
81127394:	d9003515 	stw	r4,212(sp)
81127398:	003b7606 	br	81126174 <__reset+0xfb106174>
8112739c:	d8802917 	ldw	r2,164(sp)
811273a0:	00c00184 	movi	r3,6
811273a4:	1880012e 	bgeu	r3,r2,811273ac <___vfprintf_internal_r+0x1ca8>
811273a8:	1805883a 	mov	r2,r3
811273ac:	d8802e15 	stw	r2,184(sp)
811273b0:	1000ef16 	blt	r2,zero,81127770 <___vfprintf_internal_r+0x206c>
811273b4:	04204574 	movhi	r16,33045
811273b8:	d8802a15 	stw	r2,168(sp)
811273bc:	dcc02d15 	stw	r19,180(sp)
811273c0:	d8002915 	stw	zero,164(sp)
811273c4:	d8003215 	stw	zero,200(sp)
811273c8:	84022304 	addi	r16,r16,2188
811273cc:	0039883a 	mov	fp,zero
811273d0:	003aa206 	br	81125e5c <__reset+0xfb105e5c>
811273d4:	0021883a 	mov	r16,zero
811273d8:	003e0706 	br	81126bf8 <__reset+0xfb106bf8>
811273dc:	d9002c17 	ldw	r4,176(sp)
811273e0:	d9801e04 	addi	r6,sp,120
811273e4:	b80b883a 	mov	r5,r23
811273e8:	113160c0 	call	8113160c <__sprint_r>
811273ec:	1039c91e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
811273f0:	d8802617 	ldw	r2,152(sp)
811273f4:	d9403317 	ldw	r5,204(sp)
811273f8:	d8c02017 	ldw	r3,128(sp)
811273fc:	da000404 	addi	r8,sp,16
81127400:	2885c83a 	sub	r2,r5,r2
81127404:	003dfb06 	br	81126bf4 <__reset+0xfb106bf4>
81127408:	9080004c 	andi	r2,r18,1
8112740c:	103e8f1e 	bne	r2,zero,81126e4c <__reset+0xfb106e4c>
81127410:	d8802117 	ldw	r2,132(sp)
81127414:	003e9e06 	br	81126e90 <__reset+0xfb106e90>
81127418:	1025883a 	mov	r18,r2
8112741c:	0039883a 	mov	fp,zero
81127420:	00800084 	movi	r2,2
81127424:	003fd306 	br	81127374 <__reset+0xfb107374>
81127428:	07000b44 	movi	fp,45
8112742c:	df002785 	stb	fp,158(sp)
81127430:	003a4006 	br	81125d34 <__reset+0xfb105d34>
81127434:	00c00b44 	movi	r3,45
81127438:	d8c02785 	stb	r3,158(sp)
8112743c:	d8802a15 	stw	r2,168(sp)
81127440:	dc802b17 	ldw	r18,172(sp)
81127444:	d8002915 	stw	zero,164(sp)
81127448:	07000b44 	movi	fp,45
8112744c:	003a8006 	br	81125e50 <__reset+0xfb105e50>
81127450:	04204574 	movhi	r16,33045
81127454:	84021804 	addi	r16,r16,2144
81127458:	003f4706 	br	81127178 <__reset+0xfb107178>
8112745c:	d8c02d17 	ldw	r3,180(sp)
81127460:	d9002f17 	ldw	r4,188(sp)
81127464:	18800017 	ldw	r2,0(r3)
81127468:	18c00104 	addi	r3,r3,4
8112746c:	d8c02d15 	stw	r3,180(sp)
81127470:	11000015 	stw	r4,0(r2)
81127474:	0038dd06 	br	811257ec <__reset+0xfb1057ec>
81127478:	dd802617 	ldw	r22,152(sp)
8112747c:	00bfff44 	movi	r2,-3
81127480:	b0801c16 	blt	r22,r2,811274f4 <___vfprintf_internal_r+0x1df0>
81127484:	d9402917 	ldw	r5,164(sp)
81127488:	2d801a16 	blt	r5,r22,811274f4 <___vfprintf_internal_r+0x1df0>
8112748c:	dd803215 	stw	r22,200(sp)
81127490:	003e8906 	br	81126eb8 <__reset+0xfb106eb8>
81127494:	01204574 	movhi	r4,33045
81127498:	21022d84 	addi	r4,r4,2230
8112749c:	d9002b15 	stw	r4,172(sp)
811274a0:	003c9106 	br	811266e8 <__reset+0xfb1066e8>
811274a4:	e005883a 	mov	r2,fp
811274a8:	003e7906 	br	81126e90 <__reset+0xfb106e90>
811274ac:	d9402917 	ldw	r5,164(sp)
811274b0:	df002783 	ldbu	fp,158(sp)
811274b4:	dcc02d15 	stw	r19,180(sp)
811274b8:	d9402a15 	stw	r5,168(sp)
811274bc:	d9402e15 	stw	r5,184(sp)
811274c0:	d8002915 	stw	zero,164(sp)
811274c4:	d8003215 	stw	zero,200(sp)
811274c8:	003a5d06 	br	81125e40 <__reset+0xfb105e40>
811274cc:	9080004c 	andi	r2,r18,1
811274d0:	0039883a 	mov	fp,zero
811274d4:	10000426 	beq	r2,zero,811274e8 <___vfprintf_internal_r+0x1de4>
811274d8:	00800c04 	movi	r2,48
811274dc:	dc001dc4 	addi	r16,sp,119
811274e0:	d8801dc5 	stb	r2,119(sp)
811274e4:	003b8006 	br	811262e8 <__reset+0xfb1062e8>
811274e8:	d8002e15 	stw	zero,184(sp)
811274ec:	dc001e04 	addi	r16,sp,120
811274f0:	003a4d06 	br	81125e28 <__reset+0xfb105e28>
811274f4:	8c7fff84 	addi	r17,r17,-2
811274f8:	b5bfffc4 	addi	r22,r22,-1
811274fc:	dd802615 	stw	r22,152(sp)
81127500:	dc4022c5 	stb	r17,139(sp)
81127504:	b000bf16 	blt	r22,zero,81127804 <___vfprintf_internal_r+0x2100>
81127508:	00800ac4 	movi	r2,43
8112750c:	d8802305 	stb	r2,140(sp)
81127510:	00800244 	movi	r2,9
81127514:	15807016 	blt	r2,r22,811276d8 <___vfprintf_internal_r+0x1fd4>
81127518:	00800c04 	movi	r2,48
8112751c:	b5800c04 	addi	r22,r22,48
81127520:	d8802345 	stb	r2,141(sp)
81127524:	dd802385 	stb	r22,142(sp)
81127528:	d88023c4 	addi	r2,sp,143
8112752c:	df0022c4 	addi	fp,sp,139
81127530:	d8c03317 	ldw	r3,204(sp)
81127534:	1739c83a 	sub	fp,r2,fp
81127538:	d9003317 	ldw	r4,204(sp)
8112753c:	e0c7883a 	add	r3,fp,r3
81127540:	df003a15 	stw	fp,232(sp)
81127544:	d8c02e15 	stw	r3,184(sp)
81127548:	00800044 	movi	r2,1
8112754c:	1100b30e 	bge	r2,r4,8112781c <___vfprintf_internal_r+0x2118>
81127550:	d8c02e17 	ldw	r3,184(sp)
81127554:	18c00044 	addi	r3,r3,1
81127558:	d8c02e15 	stw	r3,184(sp)
8112755c:	1805883a 	mov	r2,r3
81127560:	1800ac16 	blt	r3,zero,81127814 <___vfprintf_internal_r+0x2110>
81127564:	d8003215 	stw	zero,200(sp)
81127568:	003e5d06 	br	81126ee0 <__reset+0xfb106ee0>
8112756c:	d9002c17 	ldw	r4,176(sp)
81127570:	d9801e04 	addi	r6,sp,120
81127574:	b80b883a 	mov	r5,r23
81127578:	113160c0 	call	8113160c <__sprint_r>
8112757c:	1039651e 	bne	r2,zero,81125b14 <__reset+0xfb105b14>
81127580:	dc402617 	ldw	r17,152(sp)
81127584:	d8c02017 	ldw	r3,128(sp)
81127588:	d8801f17 	ldw	r2,124(sp)
8112758c:	da000404 	addi	r8,sp,16
81127590:	003ed606 	br	811270ec <__reset+0xfb1070ec>
81127594:	582b883a 	mov	r21,r11
81127598:	d8002915 	stw	zero,164(sp)
8112759c:	0038bd06 	br	81125894 <__reset+0xfb105894>
811275a0:	d8802917 	ldw	r2,164(sp)
811275a4:	103e071e 	bne	r2,zero,81126dc4 <__reset+0xfb106dc4>
811275a8:	dc002915 	stw	r16,164(sp)
811275ac:	003e0506 	br	81126dc4 <__reset+0xfb106dc4>
811275b0:	d9002917 	ldw	r4,164(sp)
811275b4:	20c00044 	addi	r3,r4,1
811275b8:	003e0f06 	br	81126df8 <__reset+0xfb106df8>
811275bc:	01400184 	movi	r5,6
811275c0:	d9402915 	stw	r5,164(sp)
811275c4:	003dff06 	br	81126dc4 <__reset+0xfb106dc4>
811275c8:	d8802104 	addi	r2,sp,132
811275cc:	d8800315 	stw	r2,12(sp)
811275d0:	d8802504 	addi	r2,sp,148
811275d4:	d8800215 	stw	r2,8(sp)
811275d8:	d8802604 	addi	r2,sp,152
811275dc:	d8800115 	stw	r2,4(sp)
811275e0:	d8802917 	ldw	r2,164(sp)
811275e4:	d9403617 	ldw	r5,216(sp)
811275e8:	d9002c17 	ldw	r4,176(sp)
811275ec:	d8800015 	stw	r2,0(sp)
811275f0:	01c000c4 	movi	r7,3
811275f4:	980d883a 	mov	r6,r19
811275f8:	da003d15 	stw	r8,244(sp)
811275fc:	11298100 	call	81129810 <_dtoa_r>
81127600:	d8c02917 	ldw	r3,164(sp)
81127604:	da003d17 	ldw	r8,244(sp)
81127608:	1021883a 	mov	r16,r2
8112760c:	10f9883a 	add	fp,r2,r3
81127610:	81000007 	ldb	r4,0(r16)
81127614:	00800c04 	movi	r2,48
81127618:	20805e26 	beq	r4,r2,81127794 <___vfprintf_internal_r+0x2090>
8112761c:	d8c02617 	ldw	r3,152(sp)
81127620:	e0f9883a 	add	fp,fp,r3
81127624:	003e0a06 	br	81126e50 <__reset+0xfb106e50>
81127628:	00c00b44 	movi	r3,45
8112762c:	24e0003c 	xorhi	r19,r4,32768
81127630:	d8c02a05 	stb	r3,168(sp)
81127634:	003de906 	br	81126ddc <__reset+0xfb106ddc>
81127638:	d8c03217 	ldw	r3,200(sp)
8112763c:	00c07a0e 	bge	zero,r3,81127828 <___vfprintf_internal_r+0x2124>
81127640:	00800044 	movi	r2,1
81127644:	d9003317 	ldw	r4,204(sp)
81127648:	1105883a 	add	r2,r2,r4
8112764c:	d8802e15 	stw	r2,184(sp)
81127650:	10004e16 	blt	r2,zero,8112778c <___vfprintf_internal_r+0x2088>
81127654:	044019c4 	movi	r17,103
81127658:	003e2106 	br	81126ee0 <__reset+0xfb106ee0>
8112765c:	d9002917 	ldw	r4,164(sp)
81127660:	d8802104 	addi	r2,sp,132
81127664:	d8800315 	stw	r2,12(sp)
81127668:	d9000015 	stw	r4,0(sp)
8112766c:	d8802504 	addi	r2,sp,148
81127670:	d9403617 	ldw	r5,216(sp)
81127674:	d9002c17 	ldw	r4,176(sp)
81127678:	d8800215 	stw	r2,8(sp)
8112767c:	d8802604 	addi	r2,sp,152
81127680:	d8800115 	stw	r2,4(sp)
81127684:	01c000c4 	movi	r7,3
81127688:	980d883a 	mov	r6,r19
8112768c:	da003d15 	stw	r8,244(sp)
81127690:	11298100 	call	81129810 <_dtoa_r>
81127694:	d8c02917 	ldw	r3,164(sp)
81127698:	da003d17 	ldw	r8,244(sp)
8112769c:	1021883a 	mov	r16,r2
811276a0:	00801184 	movi	r2,70
811276a4:	80f9883a 	add	fp,r16,r3
811276a8:	88bfd926 	beq	r17,r2,81127610 <__reset+0xfb107610>
811276ac:	003de806 	br	81126e50 <__reset+0xfb106e50>
811276b0:	d9002917 	ldw	r4,164(sp)
811276b4:	00c04d0e 	bge	zero,r3,811277ec <___vfprintf_internal_r+0x20e8>
811276b8:	2000441e 	bne	r4,zero,811277cc <___vfprintf_internal_r+0x20c8>
811276bc:	9480004c 	andi	r18,r18,1
811276c0:	9000421e 	bne	r18,zero,811277cc <___vfprintf_internal_r+0x20c8>
811276c4:	1805883a 	mov	r2,r3
811276c8:	18007016 	blt	r3,zero,8112788c <___vfprintf_internal_r+0x2188>
811276cc:	d8c03217 	ldw	r3,200(sp)
811276d0:	d8c02e15 	stw	r3,184(sp)
811276d4:	003e0206 	br	81126ee0 <__reset+0xfb106ee0>
811276d8:	df0022c4 	addi	fp,sp,139
811276dc:	dc002915 	stw	r16,164(sp)
811276e0:	4027883a 	mov	r19,r8
811276e4:	e021883a 	mov	r16,fp
811276e8:	b009883a 	mov	r4,r22
811276ec:	01400284 	movi	r5,10
811276f0:	11349080 	call	81134908 <__modsi3>
811276f4:	10800c04 	addi	r2,r2,48
811276f8:	843fffc4 	addi	r16,r16,-1
811276fc:	b009883a 	mov	r4,r22
81127700:	01400284 	movi	r5,10
81127704:	80800005 	stb	r2,0(r16)
81127708:	11348840 	call	81134884 <__divsi3>
8112770c:	102d883a 	mov	r22,r2
81127710:	00800244 	movi	r2,9
81127714:	15bff416 	blt	r2,r22,811276e8 <__reset+0xfb1076e8>
81127718:	9811883a 	mov	r8,r19
8112771c:	b0800c04 	addi	r2,r22,48
81127720:	8027883a 	mov	r19,r16
81127724:	997fffc4 	addi	r5,r19,-1
81127728:	98bfffc5 	stb	r2,-1(r19)
8112772c:	dc002917 	ldw	r16,164(sp)
81127730:	2f006a2e 	bgeu	r5,fp,811278dc <___vfprintf_internal_r+0x21d8>
81127734:	d9c02384 	addi	r7,sp,142
81127738:	3ccfc83a 	sub	r7,r7,r19
8112773c:	d9002344 	addi	r4,sp,141
81127740:	e1cf883a 	add	r7,fp,r7
81127744:	00000106 	br	8112774c <___vfprintf_internal_r+0x2048>
81127748:	28800003 	ldbu	r2,0(r5)
8112774c:	20800005 	stb	r2,0(r4)
81127750:	21000044 	addi	r4,r4,1
81127754:	29400044 	addi	r5,r5,1
81127758:	393ffb1e 	bne	r7,r4,81127748 <__reset+0xfb107748>
8112775c:	d8802304 	addi	r2,sp,140
81127760:	14c5c83a 	sub	r2,r2,r19
81127764:	d8c02344 	addi	r3,sp,141
81127768:	1885883a 	add	r2,r3,r2
8112776c:	003f7006 	br	81127530 <__reset+0xfb107530>
81127770:	0005883a 	mov	r2,zero
81127774:	003f0f06 	br	811273b4 <__reset+0xfb1073b4>
81127778:	d8c03217 	ldw	r3,200(sp)
8112777c:	18c00044 	addi	r3,r3,1
81127780:	d8c02e15 	stw	r3,184(sp)
81127784:	1805883a 	mov	r2,r3
81127788:	183fb20e 	bge	r3,zero,81127654 <__reset+0xfb107654>
8112778c:	0005883a 	mov	r2,zero
81127790:	003fb006 	br	81127654 <__reset+0xfb107654>
81127794:	d9003617 	ldw	r4,216(sp)
81127798:	000d883a 	mov	r6,zero
8112779c:	000f883a 	mov	r7,zero
811277a0:	980b883a 	mov	r5,r19
811277a4:	d8c03c15 	stw	r3,240(sp)
811277a8:	da003d15 	stw	r8,244(sp)
811277ac:	1135dd80 	call	81135dd8 <__eqdf2>
811277b0:	d8c03c17 	ldw	r3,240(sp)
811277b4:	da003d17 	ldw	r8,244(sp)
811277b8:	103f9826 	beq	r2,zero,8112761c <__reset+0xfb10761c>
811277bc:	00800044 	movi	r2,1
811277c0:	10c7c83a 	sub	r3,r2,r3
811277c4:	d8c02615 	stw	r3,152(sp)
811277c8:	003f9506 	br	81127620 <__reset+0xfb107620>
811277cc:	d9002917 	ldw	r4,164(sp)
811277d0:	d8c03217 	ldw	r3,200(sp)
811277d4:	20800044 	addi	r2,r4,1
811277d8:	1885883a 	add	r2,r3,r2
811277dc:	d8802e15 	stw	r2,184(sp)
811277e0:	103dbf0e 	bge	r2,zero,81126ee0 <__reset+0xfb106ee0>
811277e4:	0005883a 	mov	r2,zero
811277e8:	003dbd06 	br	81126ee0 <__reset+0xfb106ee0>
811277ec:	2000211e 	bne	r4,zero,81127874 <___vfprintf_internal_r+0x2170>
811277f0:	9480004c 	andi	r18,r18,1
811277f4:	90001f1e 	bne	r18,zero,81127874 <___vfprintf_internal_r+0x2170>
811277f8:	00800044 	movi	r2,1
811277fc:	d8802e15 	stw	r2,184(sp)
81127800:	003db706 	br	81126ee0 <__reset+0xfb106ee0>
81127804:	00800b44 	movi	r2,45
81127808:	05adc83a 	sub	r22,zero,r22
8112780c:	d8802305 	stb	r2,140(sp)
81127810:	003f3f06 	br	81127510 <__reset+0xfb107510>
81127814:	0005883a 	mov	r2,zero
81127818:	003f5206 	br	81127564 <__reset+0xfb107564>
8112781c:	90a4703a 	and	r18,r18,r2
81127820:	903f4e26 	beq	r18,zero,8112755c <__reset+0xfb10755c>
81127824:	003f4a06 	br	81127550 <__reset+0xfb107550>
81127828:	00800084 	movi	r2,2
8112782c:	10c5c83a 	sub	r2,r2,r3
81127830:	003f8406 	br	81127644 <__reset+0xfb107644>
81127834:	d8802d17 	ldw	r2,180(sp)
81127838:	d9002d17 	ldw	r4,180(sp)
8112783c:	ac400043 	ldbu	r17,1(r21)
81127840:	10800017 	ldw	r2,0(r2)
81127844:	582b883a 	mov	r21,r11
81127848:	d8802915 	stw	r2,164(sp)
8112784c:	20800104 	addi	r2,r4,4
81127850:	d9002917 	ldw	r4,164(sp)
81127854:	d8802d15 	stw	r2,180(sp)
81127858:	203e7a0e 	bge	r4,zero,81127244 <__reset+0xfb107244>
8112785c:	8c403fcc 	andi	r17,r17,255
81127860:	00bfffc4 	movi	r2,-1
81127864:	8c40201c 	xori	r17,r17,128
81127868:	d8802915 	stw	r2,164(sp)
8112786c:	8c7fe004 	addi	r17,r17,-128
81127870:	00380706 	br	81125890 <__reset+0xfb105890>
81127874:	d8c02917 	ldw	r3,164(sp)
81127878:	18c00084 	addi	r3,r3,2
8112787c:	d8c02e15 	stw	r3,184(sp)
81127880:	1805883a 	mov	r2,r3
81127884:	183d960e 	bge	r3,zero,81126ee0 <__reset+0xfb106ee0>
81127888:	003fd606 	br	811277e4 <__reset+0xfb1077e4>
8112788c:	0005883a 	mov	r2,zero
81127890:	003f8e06 	br	811276cc <__reset+0xfb1076cc>
81127894:	9080004c 	andi	r2,r18,1
81127898:	103f811e 	bne	r2,zero,811276a0 <__reset+0xfb1076a0>
8112789c:	d8802117 	ldw	r2,132(sp)
811278a0:	1405c83a 	sub	r2,r2,r16
811278a4:	d8803315 	stw	r2,204(sp)
811278a8:	b47ef326 	beq	r22,r17,81127478 <__reset+0xfb107478>
811278ac:	dd802617 	ldw	r22,152(sp)
811278b0:	003f1106 	br	811274f8 <__reset+0xfb1074f8>
811278b4:	d9c02785 	stb	r7,158(sp)
811278b8:	00390406 	br	81125ccc <__reset+0xfb105ccc>
811278bc:	d9c02785 	stb	r7,158(sp)
811278c0:	0038d306 	br	81125c10 <__reset+0xfb105c10>
811278c4:	d9c02785 	stb	r7,158(sp)
811278c8:	003a6106 	br	81126250 <__reset+0xfb106250>
811278cc:	d9c02785 	stb	r7,158(sp)
811278d0:	003af806 	br	811264b4 <__reset+0xfb1064b4>
811278d4:	0005883a 	mov	r2,zero
811278d8:	003d7e06 	br	81126ed4 <__reset+0xfb106ed4>
811278dc:	d8802344 	addi	r2,sp,141
811278e0:	003f1306 	br	81127530 <__reset+0xfb107530>
811278e4:	d9c02785 	stb	r7,158(sp)
811278e8:	00392306 	br	81125d78 <__reset+0xfb105d78>
811278ec:	d9c02785 	stb	r7,158(sp)
811278f0:	003aa906 	br	81126398 <__reset+0xfb106398>
811278f4:	d9c02785 	stb	r7,158(sp)
811278f8:	003a3d06 	br	811261f0 <__reset+0xfb1061f0>
811278fc:	d9c02785 	stb	r7,158(sp)
81127900:	003aca06 	br	8112642c <__reset+0xfb10642c>

81127904 <__vfprintf_internal>:
81127904:	00a04574 	movhi	r2,33045
81127908:	108bed04 	addi	r2,r2,12212
8112790c:	300f883a 	mov	r7,r6
81127910:	280d883a 	mov	r6,r5
81127914:	200b883a 	mov	r5,r4
81127918:	11000017 	ldw	r4,0(r2)
8112791c:	11257041 	jmpi	81125704 <___vfprintf_internal_r>

81127920 <__sbprintf>:
81127920:	defee204 	addi	sp,sp,-1144
81127924:	de00012e 	bgeu	sp,et,8112792c <__sbprintf+0xc>
81127928:	003b68fa 	trap	3
8112792c:	2880030b 	ldhu	r2,12(r5)
81127930:	2ac01917 	ldw	r11,100(r5)
81127934:	2a80038b 	ldhu	r10,14(r5)
81127938:	2a400717 	ldw	r9,28(r5)
8112793c:	2a000917 	ldw	r8,36(r5)
81127940:	00c10004 	movi	r3,1024
81127944:	dc011a15 	stw	r16,1128(sp)
81127948:	10bfff4c 	andi	r2,r2,65533
8112794c:	2821883a 	mov	r16,r5
81127950:	d8cb883a 	add	r5,sp,r3
81127954:	dc811c15 	stw	r18,1136(sp)
81127958:	dc411b15 	stw	r17,1132(sp)
8112795c:	dfc11d15 	stw	ra,1140(sp)
81127960:	2025883a 	mov	r18,r4
81127964:	d881030d 	sth	r2,1036(sp)
81127968:	dac11915 	stw	r11,1124(sp)
8112796c:	da81038d 	sth	r10,1038(sp)
81127970:	da410715 	stw	r9,1052(sp)
81127974:	da010915 	stw	r8,1060(sp)
81127978:	dec10015 	stw	sp,1024(sp)
8112797c:	dec10415 	stw	sp,1040(sp)
81127980:	d8c10215 	stw	r3,1032(sp)
81127984:	d8c10515 	stw	r3,1044(sp)
81127988:	d8010615 	stw	zero,1048(sp)
8112798c:	11257040 	call	81125704 <___vfprintf_internal_r>
81127990:	1023883a 	mov	r17,r2
81127994:	10000416 	blt	r2,zero,811279a8 <__sbprintf+0x88>
81127998:	d9410004 	addi	r5,sp,1024
8112799c:	9009883a 	mov	r4,r18
811279a0:	112b0c40 	call	8112b0c4 <_fflush_r>
811279a4:	10000d1e 	bne	r2,zero,811279dc <__sbprintf+0xbc>
811279a8:	d881030b 	ldhu	r2,1036(sp)
811279ac:	1080100c 	andi	r2,r2,64
811279b0:	10000326 	beq	r2,zero,811279c0 <__sbprintf+0xa0>
811279b4:	8080030b 	ldhu	r2,12(r16)
811279b8:	10801014 	ori	r2,r2,64
811279bc:	8080030d 	sth	r2,12(r16)
811279c0:	8805883a 	mov	r2,r17
811279c4:	dfc11d17 	ldw	ra,1140(sp)
811279c8:	dc811c17 	ldw	r18,1136(sp)
811279cc:	dc411b17 	ldw	r17,1132(sp)
811279d0:	dc011a17 	ldw	r16,1128(sp)
811279d4:	dec11e04 	addi	sp,sp,1144
811279d8:	f800283a 	ret
811279dc:	047fffc4 	movi	r17,-1
811279e0:	003ff106 	br	811279a8 <__reset+0xfb1079a8>

811279e4 <__svfscanf_r>:
811279e4:	deff4b04 	addi	sp,sp,-724
811279e8:	de00012e 	bgeu	sp,et,811279f0 <__svfscanf_r+0xc>
811279ec:	003b68fa 	trap	3
811279f0:	2880030b 	ldhu	r2,12(r5)
811279f4:	df00b315 	stw	fp,716(sp)
811279f8:	dd80b115 	stw	r22,708(sp)
811279fc:	dfc0b415 	stw	ra,720(sp)
81127a00:	ddc0b215 	stw	r23,712(sp)
81127a04:	dd40b015 	stw	r21,704(sp)
81127a08:	dd00af15 	stw	r20,700(sp)
81127a0c:	dcc0ae15 	stw	r19,696(sp)
81127a10:	dc80ad15 	stw	r18,692(sp)
81127a14:	dc40ac15 	stw	r17,688(sp)
81127a18:	dc00ab15 	stw	r16,684(sp)
81127a1c:	10c8000c 	andi	r3,r2,8192
81127a20:	d9c09c15 	stw	r7,624(sp)
81127a24:	2839883a 	mov	fp,r5
81127a28:	202d883a 	mov	r22,r4
81127a2c:	1800061e 	bne	r3,zero,81127a48 <__svfscanf_r+0x64>
81127a30:	29001917 	ldw	r4,100(r5)
81127a34:	00f7ffc4 	movi	r3,-8193
81127a38:	10880014 	ori	r2,r2,8192
81127a3c:	20c6703a 	and	r3,r4,r3
81127a40:	2880030d 	sth	r2,12(r5)
81127a44:	28c01915 	stw	r3,100(r5)
81127a48:	30800003 	ldbu	r2,0(r6)
81127a4c:	0021883a 	mov	r16,zero
81127a50:	05e04574 	movhi	r23,33045
81127a54:	d800a115 	stw	zero,644(sp)
81127a58:	d8009e15 	stw	zero,632(sp)
81127a5c:	d800a015 	stw	zero,640(sp)
81127a60:	d8809b15 	stw	r2,620(sp)
81127a64:	bdcbeb04 	addi	r23,r23,12204
81127a68:	8025883a 	mov	r18,r16
81127a6c:	35000044 	addi	r20,r6,1
81127a70:	10001e26 	beq	r2,zero,81127aec <__svfscanf_r+0x108>
81127a74:	b9c00017 	ldw	r7,0(r23)
81127a78:	3887883a 	add	r3,r7,r2
81127a7c:	18c00043 	ldbu	r3,1(r3)
81127a80:	18c0020c 	andi	r3,r3,8
81127a84:	18001b26 	beq	r3,zero,81127af4 <__svfscanf_r+0x110>
81127a88:	e0800117 	ldw	r2,4(fp)
81127a8c:	00800e0e 	bge	zero,r2,81127ac8 <__svfscanf_r+0xe4>
81127a90:	e0c00017 	ldw	r3,0(fp)
81127a94:	b9000017 	ldw	r4,0(r23)
81127a98:	18800003 	ldbu	r2,0(r3)
81127a9c:	2085883a 	add	r2,r4,r2
81127aa0:	10800043 	ldbu	r2,1(r2)
81127aa4:	1080020c 	andi	r2,r2,8
81127aa8:	10000b26 	beq	r2,zero,81127ad8 <__svfscanf_r+0xf4>
81127aac:	e0800117 	ldw	r2,4(fp)
81127ab0:	18c00044 	addi	r3,r3,1
81127ab4:	e0c00015 	stw	r3,0(fp)
81127ab8:	10bfffc4 	addi	r2,r2,-1
81127abc:	e0800115 	stw	r2,4(fp)
81127ac0:	94800044 	addi	r18,r18,1
81127ac4:	00bff216 	blt	zero,r2,81127a90 <__reset+0xfb107a90>
81127ac8:	e00b883a 	mov	r5,fp
81127acc:	b009883a 	mov	r4,r22
81127ad0:	11229c00 	call	811229c0 <__srefill_r>
81127ad4:	103fee26 	beq	r2,zero,81127a90 <__reset+0xfb107a90>
81127ad8:	a00d883a 	mov	r6,r20
81127adc:	30800003 	ldbu	r2,0(r6)
81127ae0:	35000044 	addi	r20,r6,1
81127ae4:	d8809b15 	stw	r2,620(sp)
81127ae8:	103fe21e 	bne	r2,zero,81127a74 <__reset+0xfb107a74>
81127aec:	d880a017 	ldw	r2,640(sp)
81127af0:	00009906 	br	81127d58 <__svfscanf_r+0x374>
81127af4:	00c00944 	movi	r3,37
81127af8:	10c0881e 	bne	r2,r3,81127d1c <__svfscanf_r+0x338>
81127afc:	30c00043 	ldbu	r3,1(r6)
81127b00:	0023883a 	mov	r17,zero
81127b04:	0027883a 	mov	r19,zero
81127b08:	01001e04 	movi	r4,120
81127b0c:	01401b04 	movi	r5,108
81127b10:	a1800044 	addi	r6,r20,1
81127b14:	20c0a236 	bltu	r4,r3,81127da0 <__svfscanf_r+0x3bc>
81127b18:	180490ba 	slli	r2,r3,2
81127b1c:	022044b4 	movhi	r8,33042
81127b20:	421ecc04 	addi	r8,r8,31536
81127b24:	1205883a 	add	r2,r2,r8
81127b28:	10800017 	ldw	r2,0(r2)
81127b2c:	1000683a 	jmp	r2
81127b30:	81127d54 	ori	r4,r16,18933
81127b34:	81127da0 	cmpeqi	r4,r16,18934
81127b38:	81127da0 	cmpeqi	r4,r16,18934
81127b3c:	81127da0 	cmpeqi	r4,r16,18934
81127b40:	81127da0 	cmpeqi	r4,r16,18934
81127b44:	81127da0 	cmpeqi	r4,r16,18934
81127b48:	81127da0 	cmpeqi	r4,r16,18934
81127b4c:	81127da0 	cmpeqi	r4,r16,18934
81127b50:	81127da0 	cmpeqi	r4,r16,18934
81127b54:	81127da0 	cmpeqi	r4,r16,18934
81127b58:	81127da0 	cmpeqi	r4,r16,18934
81127b5c:	81127da0 	cmpeqi	r4,r16,18934
81127b60:	81127da0 	cmpeqi	r4,r16,18934
81127b64:	81127da0 	cmpeqi	r4,r16,18934
81127b68:	81127da0 	cmpeqi	r4,r16,18934
81127b6c:	81127da0 	cmpeqi	r4,r16,18934
81127b70:	81127da0 	cmpeqi	r4,r16,18934
81127b74:	81127da0 	cmpeqi	r4,r16,18934
81127b78:	81127da0 	cmpeqi	r4,r16,18934
81127b7c:	81127da0 	cmpeqi	r4,r16,18934
81127b80:	81127da0 	cmpeqi	r4,r16,18934
81127b84:	81127da0 	cmpeqi	r4,r16,18934
81127b88:	81127da0 	cmpeqi	r4,r16,18934
81127b8c:	81127da0 	cmpeqi	r4,r16,18934
81127b90:	81127da0 	cmpeqi	r4,r16,18934
81127b94:	81127da0 	cmpeqi	r4,r16,18934
81127b98:	81127da0 	cmpeqi	r4,r16,18934
81127b9c:	81127da0 	cmpeqi	r4,r16,18934
81127ba0:	81127da0 	cmpeqi	r4,r16,18934
81127ba4:	81127da0 	cmpeqi	r4,r16,18934
81127ba8:	81127da0 	cmpeqi	r4,r16,18934
81127bac:	81127da0 	cmpeqi	r4,r16,18934
81127bb0:	81127da0 	cmpeqi	r4,r16,18934
81127bb4:	81127da0 	cmpeqi	r4,r16,18934
81127bb8:	81127da0 	cmpeqi	r4,r16,18934
81127bbc:	81127da0 	cmpeqi	r4,r16,18934
81127bc0:	81127da0 	cmpeqi	r4,r16,18934
81127bc4:	81127d14 	ori	r4,r16,18932
81127bc8:	81127da0 	cmpeqi	r4,r16,18934
81127bcc:	81127da0 	cmpeqi	r4,r16,18934
81127bd0:	81127da0 	cmpeqi	r4,r16,18934
81127bd4:	81127da0 	cmpeqi	r4,r16,18934
81127bd8:	81127d88 	cmpgei	r4,r16,18934
81127bdc:	81127da0 	cmpeqi	r4,r16,18934
81127be0:	81127da0 	cmpeqi	r4,r16,18934
81127be4:	81127da0 	cmpeqi	r4,r16,18934
81127be8:	81127da0 	cmpeqi	r4,r16,18934
81127bec:	81127da0 	cmpeqi	r4,r16,18934
81127bf0:	81127ebc 	xorhi	r4,r16,18938
81127bf4:	81127ebc 	xorhi	r4,r16,18938
81127bf8:	81127ebc 	xorhi	r4,r16,18938
81127bfc:	81127ebc 	xorhi	r4,r16,18938
81127c00:	81127ebc 	xorhi	r4,r16,18938
81127c04:	81127ebc 	xorhi	r4,r16,18938
81127c08:	81127ebc 	xorhi	r4,r16,18938
81127c0c:	81127ebc 	xorhi	r4,r16,18938
81127c10:	81127ebc 	xorhi	r4,r16,18938
81127c14:	81127ebc 	xorhi	r4,r16,18938
81127c18:	81127da0 	cmpeqi	r4,r16,18934
81127c1c:	81127da0 	cmpeqi	r4,r16,18934
81127c20:	81127da0 	cmpeqi	r4,r16,18934
81127c24:	81127da0 	cmpeqi	r4,r16,18934
81127c28:	81127da0 	cmpeqi	r4,r16,18934
81127c2c:	81127da0 	cmpeqi	r4,r16,18934
81127c30:	81127da0 	cmpeqi	r4,r16,18934
81127c34:	81127da0 	cmpeqi	r4,r16,18934
81127c38:	81127da0 	cmpeqi	r4,r16,18934
81127c3c:	81127da0 	cmpeqi	r4,r16,18934
81127c40:	81127e90 	cmplti	r4,r16,18938
81127c44:	81127f40 	call	881127f4 <__reset+0x20f27f4>
81127c48:	81127da0 	cmpeqi	r4,r16,18934
81127c4c:	81127f40 	call	881127f4 <__reset+0x20f27f4>
81127c50:	81127da0 	cmpeqi	r4,r16,18934
81127c54:	81127da0 	cmpeqi	r4,r16,18934
81127c58:	81127da0 	cmpeqi	r4,r16,18934
81127c5c:	81127da0 	cmpeqi	r4,r16,18934
81127c60:	81127f2c 	andhi	r4,r16,18940
81127c64:	81127da0 	cmpeqi	r4,r16,18934
81127c68:	81127da0 	cmpeqi	r4,r16,18934
81127c6c:	81127f00 	call	881127f0 <__reset+0x20f27f0>
81127c70:	81127da0 	cmpeqi	r4,r16,18934
81127c74:	81127da0 	cmpeqi	r4,r16,18934
81127c78:	81127da0 	cmpeqi	r4,r16,18934
81127c7c:	81127da0 	cmpeqi	r4,r16,18934
81127c80:	81127da0 	cmpeqi	r4,r16,18934
81127c84:	81127da0 	cmpeqi	r4,r16,18934
81127c88:	81127da0 	cmpeqi	r4,r16,18934
81127c8c:	81127da0 	cmpeqi	r4,r16,18934
81127c90:	81127ed8 	cmpnei	r4,r16,18939
81127c94:	81127da0 	cmpeqi	r4,r16,18934
81127c98:	81127da0 	cmpeqi	r4,r16,18934
81127c9c:	81128074 	orhi	r4,r16,18945
81127ca0:	81127da0 	cmpeqi	r4,r16,18934
81127ca4:	81127da0 	cmpeqi	r4,r16,18934
81127ca8:	81127da0 	cmpeqi	r4,r16,18934
81127cac:	81127da0 	cmpeqi	r4,r16,18934
81127cb0:	81127da0 	cmpeqi	r4,r16,18934
81127cb4:	81127da0 	cmpeqi	r4,r16,18934
81127cb8:	81127da0 	cmpeqi	r4,r16,18934
81127cbc:	81127ff8 	rdprs	r4,r16,18943
81127cc0:	81127fd0 	cmplti	r4,r16,18943
81127cc4:	81127f40 	call	881127f4 <__reset+0x20f27f4>
81127cc8:	81127f40 	call	881127f4 <__reset+0x20f27f4>
81127ccc:	81127f40 	call	881127f4 <__reset+0x20f27f4>
81127cd0:	81127fbc 	xorhi	r4,r16,18942
81127cd4:	81128100 	call	88112810 <__reset+0x20f2810>
81127cd8:	81127da0 	cmpeqi	r4,r16,18934
81127cdc:	81127da0 	cmpeqi	r4,r16,18934
81127ce0:	81127fa8 	cmpgeui	r4,r16,18942
81127ce4:	81127da0 	cmpeqi	r4,r16,18934
81127ce8:	81127f78 	rdprs	r4,r16,18941
81127cec:	81127f54 	ori	r4,r16,18941
81127cf0:	81127e64 	muli	r4,r16,18937
81127cf4:	81127da0 	cmpeqi	r4,r16,18934
81127cf8:	81127da0 	cmpeqi	r4,r16,18934
81127cfc:	81127e50 	cmplti	r4,r16,18937
81127d00:	81127da0 	cmpeqi	r4,r16,18934
81127d04:	81127dd8 	cmpnei	r4,r16,18935
81127d08:	81127da0 	cmpeqi	r4,r16,18934
81127d0c:	81127da0 	cmpeqi	r4,r16,18934
81127d10:	81127ed8 	cmpnei	r4,r16,18939
81127d14:	d9809d15 	stw	r6,628(sp)
81127d18:	3029883a 	mov	r20,r6
81127d1c:	e0800117 	ldw	r2,4(fp)
81127d20:	0081aa0e 	bge	zero,r2,811283cc <__svfscanf_r+0x9e8>
81127d24:	e0800017 	ldw	r2,0(fp)
81127d28:	a0ffffc3 	ldbu	r3,-1(r20)
81127d2c:	11000003 	ldbu	r4,0(r2)
81127d30:	20ff6e1e 	bne	r4,r3,81127aec <__reset+0xfb107aec>
81127d34:	e0c00117 	ldw	r3,4(fp)
81127d38:	10800044 	addi	r2,r2,1
81127d3c:	e0800015 	stw	r2,0(fp)
81127d40:	18bfffc4 	addi	r2,r3,-1
81127d44:	e0800115 	stw	r2,4(fp)
81127d48:	94800044 	addi	r18,r18,1
81127d4c:	a00d883a 	mov	r6,r20
81127d50:	003f6206 	br	81127adc <__reset+0xfb107adc>
81127d54:	00bfffc4 	movi	r2,-1
81127d58:	dfc0b417 	ldw	ra,720(sp)
81127d5c:	df00b317 	ldw	fp,716(sp)
81127d60:	ddc0b217 	ldw	r23,712(sp)
81127d64:	dd80b117 	ldw	r22,708(sp)
81127d68:	dd40b017 	ldw	r21,704(sp)
81127d6c:	dd00af17 	ldw	r20,700(sp)
81127d70:	dcc0ae17 	ldw	r19,696(sp)
81127d74:	dc80ad17 	ldw	r18,692(sp)
81127d78:	dc40ac17 	ldw	r17,688(sp)
81127d7c:	dc00ab17 	ldw	r16,684(sp)
81127d80:	dec0b504 	addi	sp,sp,724
81127d84:	f800283a 	ret
81127d88:	a0800043 	ldbu	r2,1(r20)
81127d8c:	3029883a 	mov	r20,r6
81127d90:	8c400414 	ori	r17,r17,16
81127d94:	10c03fcc 	andi	r3,r2,255
81127d98:	a1800044 	addi	r6,r20,1
81127d9c:	20ff5e2e 	bgeu	r4,r3,81127b18 <__reset+0xfb107b18>
81127da0:	38c7883a 	add	r3,r7,r3
81127da4:	18800043 	ldbu	r2,1(r3)
81127da8:	d9809d15 	stw	r6,628(sp)
81127dac:	00c00044 	movi	r3,1
81127db0:	108000cc 	andi	r2,r2,3
81127db4:	10c18f26 	beq	r2,r3,811283f4 <__svfscanf_r+0xa10>
81127db8:	e0800117 	ldw	r2,4(fp)
81127dbc:	00808716 	blt	zero,r2,81127fdc <__svfscanf_r+0x5f8>
81127dc0:	e00b883a 	mov	r5,fp
81127dc4:	b009883a 	mov	r4,r22
81127dc8:	11229c00 	call	811229c0 <__srefill_r>
81127dcc:	1001431e 	bne	r2,zero,811282dc <__svfscanf_r+0x8f8>
81127dd0:	b9c00017 	ldw	r7,0(r23)
81127dd4:	00008106 	br	81127fdc <__svfscanf_r+0x5f8>
81127dd8:	e0800117 	ldw	r2,4(fp)
81127ddc:	d9809d15 	stw	r6,628(sp)
81127de0:	0081a30e 	bge	zero,r2,81128470 <__svfscanf_r+0xa8c>
81127de4:	00a044f4 	movhi	r2,33043
81127de8:	10be4304 	addi	r2,r2,-1780
81127dec:	02000284 	movi	r8,10
81127df0:	d880a115 	stw	r2,644(sp)
81127df4:	da009e15 	stw	r8,632(sp)
81127df8:	050000c4 	movi	r20,3
81127dfc:	e0c00017 	ldw	r3,0(fp)
81127e00:	00000206 	br	81127e0c <__svfscanf_r+0x428>
81127e04:	18c00044 	addi	r3,r3,1
81127e08:	e0c00015 	stw	r3,0(fp)
81127e0c:	19000003 	ldbu	r4,0(r3)
81127e10:	20803fcc 	andi	r2,r4,255
81127e14:	3885883a 	add	r2,r7,r2
81127e18:	10800043 	ldbu	r2,1(r2)
81127e1c:	1140020c 	andi	r5,r2,8
81127e20:	2801ab26 	beq	r5,zero,811284d0 <__svfscanf_r+0xaec>
81127e24:	e0800117 	ldw	r2,4(fp)
81127e28:	94800044 	addi	r18,r18,1
81127e2c:	10bfffc4 	addi	r2,r2,-1
81127e30:	e0800115 	stw	r2,4(fp)
81127e34:	00bff316 	blt	zero,r2,81127e04 <__reset+0xfb107e04>
81127e38:	e00b883a 	mov	r5,fp
81127e3c:	b009883a 	mov	r4,r22
81127e40:	11229c00 	call	811229c0 <__srefill_r>
81127e44:	1001251e 	bne	r2,zero,811282dc <__svfscanf_r+0x8f8>
81127e48:	b9c00017 	ldw	r7,0(r23)
81127e4c:	003feb06 	br	81127dfc <__reset+0xfb107dfc>
81127e50:	e0800117 	ldw	r2,4(fp)
81127e54:	d9809d15 	stw	r6,628(sp)
81127e58:	00818b0e 	bge	zero,r2,81128488 <__svfscanf_r+0xaa4>
81127e5c:	05000084 	movi	r20,2
81127e60:	003fe606 	br	81127dfc <__reset+0xfb107dfc>
81127e64:	e0800117 	ldw	r2,4(fp)
81127e68:	d9809d15 	stw	r6,628(sp)
81127e6c:	8c408814 	ori	r17,r17,544
81127e70:	00801d0e 	bge	zero,r2,81127ee8 <__svfscanf_r+0x504>
81127e74:	00a044f4 	movhi	r2,33043
81127e78:	10be4304 	addi	r2,r2,-1780
81127e7c:	02000404 	movi	r8,16
81127e80:	d880a115 	stw	r2,644(sp)
81127e84:	da009e15 	stw	r8,632(sp)
81127e88:	050000c4 	movi	r20,3
81127e8c:	003fdb06 	br	81127dfc <__reset+0xfb107dfc>
81127e90:	e0800117 	ldw	r2,4(fp)
81127e94:	d9809d15 	stw	r6,628(sp)
81127e98:	8c400054 	ori	r17,r17,1
81127e9c:	00bfc80e 	bge	zero,r2,81127dc0 <__reset+0xfb107dc0>
81127ea0:	00e044b4 	movhi	r3,33042
81127ea4:	18cbf104 	addi	r3,r3,12228
81127ea8:	02000284 	movi	r8,10
81127eac:	d8c0a115 	stw	r3,644(sp)
81127eb0:	da009e15 	stw	r8,632(sp)
81127eb4:	050000c4 	movi	r20,3
81127eb8:	003fd006 	br	81127dfc <__reset+0xfb107dfc>
81127ebc:	9cc002a4 	muli	r19,r19,10
81127ec0:	a0800043 	ldbu	r2,1(r20)
81127ec4:	3029883a 	mov	r20,r6
81127ec8:	98e7883a 	add	r19,r19,r3
81127ecc:	9cfff404 	addi	r19,r19,-48
81127ed0:	10c03fcc 	andi	r3,r2,255
81127ed4:	003f0e06 	br	81127b10 <__reset+0xfb107b10>
81127ed8:	e0800117 	ldw	r2,4(fp)
81127edc:	d9809d15 	stw	r6,628(sp)
81127ee0:	8c408014 	ori	r17,r17,512
81127ee4:	00bfe316 	blt	zero,r2,81127e74 <__reset+0xfb107e74>
81127ee8:	e00b883a 	mov	r5,fp
81127eec:	b009883a 	mov	r4,r22
81127ef0:	11229c00 	call	811229c0 <__srefill_r>
81127ef4:	1000f91e 	bne	r2,zero,811282dc <__svfscanf_r+0x8f8>
81127ef8:	b9c00017 	ldw	r7,0(r23)
81127efc:	003fdd06 	br	81127e74 <__reset+0xfb107e74>
81127f00:	e0800117 	ldw	r2,4(fp)
81127f04:	d9809d15 	stw	r6,628(sp)
81127f08:	8c400054 	ori	r17,r17,1
81127f0c:	0080140e 	bge	zero,r2,81127f60 <__svfscanf_r+0x57c>
81127f10:	00a044f4 	movhi	r2,33043
81127f14:	10be4304 	addi	r2,r2,-1780
81127f18:	02000204 	movi	r8,8
81127f1c:	d880a115 	stw	r2,644(sp)
81127f20:	da009e15 	stw	r8,632(sp)
81127f24:	050000c4 	movi	r20,3
81127f28:	003fb406 	br	81127dfc <__reset+0xfb107dfc>
81127f2c:	a0800043 	ldbu	r2,1(r20)
81127f30:	8c400094 	ori	r17,r17,2
81127f34:	3029883a 	mov	r20,r6
81127f38:	10c03fcc 	andi	r3,r2,255
81127f3c:	003ef406 	br	81127b10 <__reset+0xfb107b10>
81127f40:	e0800117 	ldw	r2,4(fp)
81127f44:	d9809d15 	stw	r6,628(sp)
81127f48:	0081420e 	bge	zero,r2,81128454 <__svfscanf_r+0xa70>
81127f4c:	05000104 	movi	r20,4
81127f50:	003faa06 	br	81127dfc <__reset+0xfb107dfc>
81127f54:	e0800117 	ldw	r2,4(fp)
81127f58:	d9809d15 	stw	r6,628(sp)
81127f5c:	00bfec16 	blt	zero,r2,81127f10 <__reset+0xfb107f10>
81127f60:	e00b883a 	mov	r5,fp
81127f64:	b009883a 	mov	r4,r22
81127f68:	11229c00 	call	811229c0 <__srefill_r>
81127f6c:	1000db1e 	bne	r2,zero,811282dc <__svfscanf_r+0x8f8>
81127f70:	b9c00017 	ldw	r7,0(r23)
81127f74:	003fe606 	br	81127f10 <__reset+0xfb107f10>
81127f78:	d9809d15 	stw	r6,628(sp)
81127f7c:	8880040c 	andi	r2,r17,16
81127f80:	10009c1e 	bne	r2,zero,811281f4 <__svfscanf_r+0x810>
81127f84:	8880010c 	andi	r2,r17,4
81127f88:	10011e26 	beq	r2,zero,81128404 <__svfscanf_r+0xa20>
81127f8c:	da009c17 	ldw	r8,624(sp)
81127f90:	3029883a 	mov	r20,r6
81127f94:	40800017 	ldw	r2,0(r8)
81127f98:	42000104 	addi	r8,r8,4
81127f9c:	da009c15 	stw	r8,624(sp)
81127fa0:	1480000d 	sth	r18,0(r2)
81127fa4:	003ecc06 	br	81127ad8 <__reset+0xfb107ad8>
81127fa8:	a0c00043 	ldbu	r3,1(r20)
81127fac:	19410c26 	beq	r3,r5,811283e0 <__svfscanf_r+0x9fc>
81127fb0:	8c400054 	ori	r17,r17,1
81127fb4:	3029883a 	mov	r20,r6
81127fb8:	003ed506 	br	81127b10 <__reset+0xfb107b10>
81127fbc:	a0800043 	ldbu	r2,1(r20)
81127fc0:	8c400114 	ori	r17,r17,4
81127fc4:	3029883a 	mov	r20,r6
81127fc8:	10c03fcc 	andi	r3,r2,255
81127fcc:	003ed006 	br	81127b10 <__reset+0xfb107b10>
81127fd0:	e0800117 	ldw	r2,4(fp)
81127fd4:	d9809d15 	stw	r6,628(sp)
81127fd8:	00bf790e 	bge	zero,r2,81127dc0 <__reset+0xfb107dc0>
81127fdc:	00a044b4 	movhi	r2,33042
81127fe0:	108bf104 	addi	r2,r2,12228
81127fe4:	02000284 	movi	r8,10
81127fe8:	d880a115 	stw	r2,644(sp)
81127fec:	da009e15 	stw	r8,632(sp)
81127ff0:	050000c4 	movi	r20,3
81127ff4:	003f8106 	br	81127dfc <__reset+0xfb107dfc>
81127ff8:	e0800117 	ldw	r2,4(fp)
81127ffc:	d9809d15 	stw	r6,628(sp)
81128000:	0080c40e 	bge	zero,r2,81128314 <__svfscanf_r+0x930>
81128004:	9800011e 	bne	r19,zero,8112800c <__svfscanf_r+0x628>
81128008:	04c00044 	movi	r19,1
8112800c:	8880004c 	andi	r2,r17,1
81128010:	1000441e 	bne	r2,zero,81128124 <__svfscanf_r+0x740>
81128014:	8c40040c 	andi	r17,r17,16
81128018:	8800da26 	beq	r17,zero,81128384 <__svfscanf_r+0x9a0>
8112801c:	0021883a 	mov	r16,zero
81128020:	00000806 	br	81128044 <__svfscanf_r+0x660>
81128024:	1887883a 	add	r3,r3,r2
81128028:	e00b883a 	mov	r5,fp
8112802c:	b009883a 	mov	r4,r22
81128030:	e0c00015 	stw	r3,0(fp)
81128034:	80a1883a 	add	r16,r16,r2
81128038:	98a7c83a 	sub	r19,r19,r2
8112803c:	11229c00 	call	811229c0 <__srefill_r>
81128040:	1000ca1e 	bne	r2,zero,8112836c <__svfscanf_r+0x988>
81128044:	e0800117 	ldw	r2,4(fp)
81128048:	e0c00017 	ldw	r3,0(fp)
8112804c:	14fff516 	blt	r2,r19,81128024 <__reset+0xfb108024>
81128050:	14c5c83a 	sub	r2,r2,r19
81128054:	1cd5883a 	add	r10,r3,r19
81128058:	84e1883a 	add	r16,r16,r19
8112805c:	e0800115 	stw	r2,4(fp)
81128060:	e2800015 	stw	r10,0(fp)
81128064:	dd009d17 	ldw	r20,628(sp)
81128068:	9425883a 	add	r18,r18,r16
8112806c:	a00d883a 	mov	r6,r20
81128070:	003e9a06 	br	81127adc <__reset+0xfb107adc>
81128074:	300b883a 	mov	r5,r6
81128078:	d9005884 	addi	r4,sp,354
8112807c:	d9809d15 	stw	r6,628(sp)
81128080:	112dfcc0 	call	8112dfcc <__sccl>
81128084:	1029883a 	mov	r20,r2
81128088:	e0800117 	ldw	r2,4(fp)
8112808c:	0081050e 	bge	zero,r2,811284a4 <__svfscanf_r+0xac0>
81128090:	e1000017 	ldw	r4,0(fp)
81128094:	20800003 	ldbu	r2,0(r4)
81128098:	98005926 	beq	r19,zero,81128200 <__svfscanf_r+0x81c>
8112809c:	8c40040c 	andi	r17,r17,16
811280a0:	88005a26 	beq	r17,zero,8112820c <__svfscanf_r+0x828>
811280a4:	9823883a 	mov	r17,r19
811280a8:	0021883a 	mov	r16,zero
811280ac:	00000106 	br	811280b4 <__svfscanf_r+0x6d0>
811280b0:	20800003 	ldbu	r2,0(r4)
811280b4:	10803fcc 	andi	r2,r2,255
811280b8:	d8c05884 	addi	r3,sp,354
811280bc:	1885883a 	add	r2,r3,r2
811280c0:	10800007 	ldb	r2,0(r2)
811280c4:	1000ad26 	beq	r2,zero,8112837c <__svfscanf_r+0x998>
811280c8:	e0800117 	ldw	r2,4(fp)
811280cc:	21000044 	addi	r4,r4,1
811280d0:	84000044 	addi	r16,r16,1
811280d4:	10bfffc4 	addi	r2,r2,-1
811280d8:	e0800115 	stw	r2,4(fp)
811280dc:	e1000015 	stw	r4,0(fp)
811280e0:	84c0a026 	beq	r16,r19,81128364 <__svfscanf_r+0x980>
811280e4:	00bff216 	blt	zero,r2,811280b0 <__reset+0xfb1080b0>
811280e8:	e00b883a 	mov	r5,fp
811280ec:	b009883a 	mov	r4,r22
811280f0:	11229c00 	call	811229c0 <__srefill_r>
811280f4:	10009a1e 	bne	r2,zero,81128360 <__svfscanf_r+0x97c>
811280f8:	e1000017 	ldw	r4,0(fp)
811280fc:	003fec06 	br	811280b0 <__reset+0xfb1080b0>
81128100:	e0800117 	ldw	r2,4(fp)
81128104:	d9809d15 	stw	r6,628(sp)
81128108:	0080eb0e 	bge	zero,r2,811284b8 <__svfscanf_r+0xad4>
8112810c:	00a044b4 	movhi	r2,33042
81128110:	108bf104 	addi	r2,r2,12228
81128114:	d880a115 	stw	r2,644(sp)
81128118:	d8009e15 	stw	zero,632(sp)
8112811c:	050000c4 	movi	r20,3
81128120:	003f3606 	br	81127dfc <__reset+0xfb107dfc>
81128124:	dd409904 	addi	r21,sp,612
81128128:	8c40040c 	andi	r17,r17,16
8112812c:	01800204 	movi	r6,8
81128130:	000b883a 	mov	r5,zero
81128134:	a809883a 	mov	r4,r21
81128138:	dc409f15 	stw	r17,636(sp)
8112813c:	11225440 	call	81122544 <memset>
81128140:	dc409f17 	ldw	r17,636(sp)
81128144:	88006e26 	beq	r17,zero,81128300 <__svfscanf_r+0x91c>
81128148:	0029883a 	mov	r20,zero
8112814c:	0023883a 	mov	r17,zero
81128150:	112c3e80 	call	8112c3e8 <__locale_mb_cur_max>
81128154:	14406126 	beq	r2,r17,811282dc <__svfscanf_r+0x8f8>
81128158:	e0800017 	ldw	r2,0(fp)
8112815c:	e0c00117 	ldw	r3,4(fp)
81128160:	d9000104 	addi	r4,sp,4
81128164:	12000003 	ldbu	r8,0(r2)
81128168:	18ffffc4 	addi	r3,r3,-1
8112816c:	10800044 	addi	r2,r2,1
81128170:	e0c00115 	stw	r3,4(fp)
81128174:	e0800015 	stw	r2,0(fp)
81128178:	8c000044 	addi	r16,r17,1
8112817c:	dd400015 	stw	r21,0(sp)
81128180:	2463883a 	add	r17,r4,r17
81128184:	200d883a 	mov	r6,r4
81128188:	a00b883a 	mov	r5,r20
8112818c:	800f883a 	mov	r7,r16
81128190:	b009883a 	mov	r4,r22
81128194:	8a000005 	stb	r8,0(r17)
81128198:	112c4a40 	call	8112c4a4 <_mbrtowc_r>
8112819c:	017fffc4 	movi	r5,-1
811281a0:	11404e26 	beq	r2,r5,811282dc <__svfscanf_r+0x8f8>
811281a4:	1000601e 	bne	r2,zero,81128328 <__svfscanf_r+0x944>
811281a8:	da009f17 	ldw	r8,636(sp)
811281ac:	4000641e 	bne	r8,zero,81128340 <__svfscanf_r+0x95c>
811281b0:	a0000015 	stw	zero,0(r20)
811281b4:	9425883a 	add	r18,r18,r16
811281b8:	9967883a 	add	r19,r19,r5
811281bc:	a5000104 	addi	r20,r20,4
811281c0:	e0800117 	ldw	r2,4(fp)
811281c4:	0023883a 	mov	r17,zero
811281c8:	00804b16 	blt	zero,r2,811282f8 <__svfscanf_r+0x914>
811281cc:	e00b883a 	mov	r5,fp
811281d0:	b009883a 	mov	r4,r22
811281d4:	11229c00 	call	811229c0 <__srefill_r>
811281d8:	10004726 	beq	r2,zero,811282f8 <__svfscanf_r+0x914>
811281dc:	88003f1e 	bne	r17,zero,811282dc <__svfscanf_r+0x8f8>
811281e0:	d8c09f17 	ldw	r3,636(sp)
811281e4:	1800031e 	bne	r3,zero,811281f4 <__svfscanf_r+0x810>
811281e8:	da00a017 	ldw	r8,640(sp)
811281ec:	42000044 	addi	r8,r8,1
811281f0:	da00a015 	stw	r8,640(sp)
811281f4:	dd009d17 	ldw	r20,628(sp)
811281f8:	a00d883a 	mov	r6,r20
811281fc:	003e3706 	br	81127adc <__reset+0xfb107adc>
81128200:	8c40040c 	andi	r17,r17,16
81128204:	04ffffc4 	movi	r19,-1
81128208:	883fa61e 	bne	r17,zero,811280a4 <__reset+0xfb1080a4>
8112820c:	da009c17 	ldw	r8,624(sp)
81128210:	9abfffc4 	addi	r10,r19,-1
81128214:	44000017 	ldw	r16,0(r8)
81128218:	44400104 	addi	r17,r8,4
8112821c:	8007883a 	mov	r3,r16
81128220:	82ab883a 	add	r21,r16,r10
81128224:	00000306 	br	81128234 <__svfscanf_r+0x850>
81128228:	e1000017 	ldw	r4,0(fp)
8112822c:	9807883a 	mov	r3,r19
81128230:	20800003 	ldbu	r2,0(r4)
81128234:	10803fcc 	andi	r2,r2,255
81128238:	d9405884 	addi	r5,sp,354
8112823c:	2885883a 	add	r2,r5,r2
81128240:	10800007 	ldb	r2,0(r2)
81128244:	10004b26 	beq	r2,zero,81128374 <__svfscanf_r+0x990>
81128248:	e0800117 	ldw	r2,4(fp)
8112824c:	21400044 	addi	r5,r4,1
81128250:	e1400015 	stw	r5,0(fp)
81128254:	10bfffc4 	addi	r2,r2,-1
81128258:	e0800115 	stw	r2,4(fp)
8112825c:	20800003 	ldbu	r2,0(r4)
81128260:	1cc00044 	addi	r19,r3,1
81128264:	18800005 	stb	r2,0(r3)
81128268:	1d400726 	beq	r3,r21,81128288 <__svfscanf_r+0x8a4>
8112826c:	e0800117 	ldw	r2,4(fp)
81128270:	00bfed16 	blt	zero,r2,81128228 <__reset+0xfb108228>
81128274:	e00b883a 	mov	r5,fp
81128278:	b009883a 	mov	r4,r22
8112827c:	11229c00 	call	811229c0 <__srefill_r>
81128280:	103fe926 	beq	r2,zero,81128228 <__reset+0xfb108228>
81128284:	84c01526 	beq	r16,r19,811282dc <__svfscanf_r+0x8f8>
81128288:	9c21c83a 	sub	r16,r19,r16
8112828c:	803e1726 	beq	r16,zero,81127aec <__reset+0xfb107aec>
81128290:	da00a017 	ldw	r8,640(sp)
81128294:	98000005 	stb	zero,0(r19)
81128298:	dc409c15 	stw	r17,624(sp)
8112829c:	42000044 	addi	r8,r8,1
811282a0:	da00a015 	stw	r8,640(sp)
811282a4:	9425883a 	add	r18,r18,r16
811282a8:	a00d883a 	mov	r6,r20
811282ac:	003e0b06 	br	81127adc <__reset+0xfb107adc>
811282b0:	017fff84 	movi	r5,-2
811282b4:	11439b1e 	bne	r2,r5,81129124 <__svfscanf_r+0x1740>
811282b8:	8821883a 	mov	r16,r17
811282bc:	e0800117 	ldw	r2,4(fp)
811282c0:	0082e516 	blt	zero,r2,81128e58 <__svfscanf_r+0x1474>
811282c4:	e00b883a 	mov	r5,fp
811282c8:	b009883a 	mov	r4,r22
811282cc:	11229c00 	call	811229c0 <__srefill_r>
811282d0:	1002e126 	beq	r2,zero,81128e58 <__svfscanf_r+0x1474>
811282d4:	dc409f17 	ldw	r17,636(sp)
811282d8:	8002e826 	beq	r16,zero,81128e7c <__svfscanf_r+0x1498>
811282dc:	da00a017 	ldw	r8,640(sp)
811282e0:	403e9c26 	beq	r8,zero,81127d54 <__reset+0xfb107d54>
811282e4:	e080030b 	ldhu	r2,12(fp)
811282e8:	1080100c 	andi	r2,r2,64
811282ec:	103e991e 	bne	r2,zero,81127d54 <__reset+0xfb107d54>
811282f0:	4005883a 	mov	r2,r8
811282f4:	003e9806 	br	81127d58 <__reset+0xfb107d58>
811282f8:	983f951e 	bne	r19,zero,81128150 <__reset+0xfb108150>
811282fc:	003fb806 	br	811281e0 <__reset+0xfb1081e0>
81128300:	da009c17 	ldw	r8,624(sp)
81128304:	45000017 	ldw	r20,0(r8)
81128308:	42000104 	addi	r8,r8,4
8112830c:	da009c15 	stw	r8,624(sp)
81128310:	003f8e06 	br	8112814c <__reset+0xfb10814c>
81128314:	e00b883a 	mov	r5,fp
81128318:	b009883a 	mov	r4,r22
8112831c:	11229c00 	call	811229c0 <__srefill_r>
81128320:	103f3826 	beq	r2,zero,81128004 <__reset+0xfb108004>
81128324:	003fed06 	br	811282dc <__reset+0xfb1082dc>
81128328:	00ffff84 	movi	r3,-2
8112832c:	10c0071e 	bne	r2,r3,8112834c <__svfscanf_r+0x968>
81128330:	e0800117 	ldw	r2,4(fp)
81128334:	8023883a 	mov	r17,r16
81128338:	00bf8516 	blt	zero,r2,81128150 <__reset+0xfb108150>
8112833c:	003fa306 	br	811281cc <__reset+0xfb1081cc>
81128340:	9425883a 	add	r18,r18,r16
81128344:	9cffffc4 	addi	r19,r19,-1
81128348:	003f9d06 	br	811281c0 <__reset+0xfb1081c0>
8112834c:	da009f17 	ldw	r8,636(sp)
81128350:	9425883a 	add	r18,r18,r16
81128354:	9cffffc4 	addi	r19,r19,-1
81128358:	403f9826 	beq	r8,zero,811281bc <__reset+0xfb1081bc>
8112835c:	003f9806 	br	811281c0 <__reset+0xfb1081c0>
81128360:	8023883a 	mov	r17,r16
81128364:	8821883a 	mov	r16,r17
81128368:	003fce06 	br	811282a4 <__reset+0xfb1082a4>
8112836c:	803f3d1e 	bne	r16,zero,81128064 <__reset+0xfb108064>
81128370:	003fda06 	br	811282dc <__reset+0xfb1082dc>
81128374:	1827883a 	mov	r19,r3
81128378:	003fc306 	br	81128288 <__reset+0xfb108288>
8112837c:	803fc91e 	bne	r16,zero,811282a4 <__reset+0xfb1082a4>
81128380:	003dda06 	br	81127aec <__reset+0xfb107aec>
81128384:	da009c17 	ldw	r8,624(sp)
81128388:	df000015 	stw	fp,0(sp)
8112838c:	980f883a 	mov	r7,r19
81128390:	41400017 	ldw	r5,0(r8)
81128394:	01800044 	movi	r6,1
81128398:	b009883a 	mov	r4,r22
8112839c:	112b5bc0 	call	8112b5bc <_fread_r>
811283a0:	da009c17 	ldw	r8,624(sp)
811283a4:	40c00104 	addi	r3,r8,4
811283a8:	103fcc26 	beq	r2,zero,811282dc <__reset+0xfb1082dc>
811283ac:	da00a017 	ldw	r8,640(sp)
811283b0:	dd009d17 	ldw	r20,628(sp)
811283b4:	90a5883a 	add	r18,r18,r2
811283b8:	42000044 	addi	r8,r8,1
811283bc:	da00a015 	stw	r8,640(sp)
811283c0:	d8c09c15 	stw	r3,624(sp)
811283c4:	a00d883a 	mov	r6,r20
811283c8:	003dc406 	br	81127adc <__reset+0xfb107adc>
811283cc:	e00b883a 	mov	r5,fp
811283d0:	b009883a 	mov	r4,r22
811283d4:	11229c00 	call	811229c0 <__srefill_r>
811283d8:	103e5226 	beq	r2,zero,81127d24 <__reset+0xfb107d24>
811283dc:	003fbf06 	br	811282dc <__reset+0xfb1082dc>
811283e0:	a0800083 	ldbu	r2,2(r20)
811283e4:	8c400094 	ori	r17,r17,2
811283e8:	a5000084 	addi	r20,r20,2
811283ec:	10c03fcc 	andi	r3,r2,255
811283f0:	003dc706 	br	81127b10 <__reset+0xfb107b10>
811283f4:	e0800117 	ldw	r2,4(fp)
811283f8:	88e2b03a 	or	r17,r17,r3
811283fc:	00bef716 	blt	zero,r2,81127fdc <__reset+0xfb107fdc>
81128400:	003e6f06 	br	81127dc0 <__reset+0xfb107dc0>
81128404:	8880004c 	andi	r2,r17,1
81128408:	10000b1e 	bne	r2,zero,81128438 <__svfscanf_r+0xa54>
8112840c:	8c40008c 	andi	r17,r17,2
81128410:	88000926 	beq	r17,zero,81128438 <__svfscanf_r+0xa54>
81128414:	da009c17 	ldw	r8,624(sp)
81128418:	9007d7fa 	srai	r3,r18,31
8112841c:	dd009d17 	ldw	r20,628(sp)
81128420:	40800017 	ldw	r2,0(r8)
81128424:	42000104 	addi	r8,r8,4
81128428:	da009c15 	stw	r8,624(sp)
8112842c:	14800015 	stw	r18,0(r2)
81128430:	10c00115 	stw	r3,4(r2)
81128434:	003da806 	br	81127ad8 <__reset+0xfb107ad8>
81128438:	da009c17 	ldw	r8,624(sp)
8112843c:	dd009d17 	ldw	r20,628(sp)
81128440:	40800017 	ldw	r2,0(r8)
81128444:	42000104 	addi	r8,r8,4
81128448:	da009c15 	stw	r8,624(sp)
8112844c:	14800015 	stw	r18,0(r2)
81128450:	003da106 	br	81127ad8 <__reset+0xfb107ad8>
81128454:	e00b883a 	mov	r5,fp
81128458:	b009883a 	mov	r4,r22
8112845c:	11229c00 	call	811229c0 <__srefill_r>
81128460:	103f9e1e 	bne	r2,zero,811282dc <__reset+0xfb1082dc>
81128464:	b9c00017 	ldw	r7,0(r23)
81128468:	05000104 	movi	r20,4
8112846c:	003e6306 	br	81127dfc <__reset+0xfb107dfc>
81128470:	e00b883a 	mov	r5,fp
81128474:	b009883a 	mov	r4,r22
81128478:	11229c00 	call	811229c0 <__srefill_r>
8112847c:	103f971e 	bne	r2,zero,811282dc <__reset+0xfb1082dc>
81128480:	b9c00017 	ldw	r7,0(r23)
81128484:	003e5706 	br	81127de4 <__reset+0xfb107de4>
81128488:	e00b883a 	mov	r5,fp
8112848c:	b009883a 	mov	r4,r22
81128490:	11229c00 	call	811229c0 <__srefill_r>
81128494:	103f911e 	bne	r2,zero,811282dc <__reset+0xfb1082dc>
81128498:	b9c00017 	ldw	r7,0(r23)
8112849c:	05000084 	movi	r20,2
811284a0:	003e5606 	br	81127dfc <__reset+0xfb107dfc>
811284a4:	e00b883a 	mov	r5,fp
811284a8:	b009883a 	mov	r4,r22
811284ac:	11229c00 	call	811229c0 <__srefill_r>
811284b0:	103ef726 	beq	r2,zero,81128090 <__reset+0xfb108090>
811284b4:	003f8906 	br	811282dc <__reset+0xfb1082dc>
811284b8:	e00b883a 	mov	r5,fp
811284bc:	b009883a 	mov	r4,r22
811284c0:	11229c00 	call	811229c0 <__srefill_r>
811284c4:	103f851e 	bne	r2,zero,811282dc <__reset+0xfb1082dc>
811284c8:	b9c00017 	ldw	r7,0(r23)
811284cc:	003f0f06 	br	8112810c <__reset+0xfb10810c>
811284d0:	014000c4 	movi	r5,3
811284d4:	a1414a26 	beq	r20,r5,81128a00 <__svfscanf_r+0x101c>
811284d8:	01000104 	movi	r4,4
811284dc:	a101f11e 	bne	r20,r4,81128ca4 <__svfscanf_r+0x12c0>
811284e0:	b009883a 	mov	r4,r22
811284e4:	112c40c0 	call	8112c40c <_localeconv_r>
811284e8:	10800017 	ldw	r2,0(r2)
811284ec:	98ffffc4 	addi	r3,r19,-1
811284f0:	d880a315 	stw	r2,652(sp)
811284f4:	00805704 	movi	r2,348
811284f8:	10c21e2e 	bgeu	r2,r3,81128d74 <__svfscanf_r+0x1390>
811284fc:	9cffa8c4 	addi	r19,r19,-349
81128500:	dcc0a215 	stw	r19,648(sp)
81128504:	04c05744 	movi	r19,349
81128508:	8d01e014 	ori	r20,r17,1920
8112850c:	0023883a 	mov	r17,zero
81128510:	dc000104 	addi	r16,sp,4
81128514:	8805883a 	mov	r2,r17
81128518:	0019883a 	mov	r12,zero
8112851c:	8023883a 	mov	r17,r16
81128520:	b007883a 	mov	r3,r22
81128524:	9821883a 	mov	r16,r19
81128528:	002b883a 	mov	r21,zero
8112852c:	d800a515 	stw	zero,660(sp)
81128530:	d800a415 	stw	zero,656(sp)
81128534:	d8009f15 	stw	zero,636(sp)
81128538:	01c01384 	movi	r7,78
8112853c:	602d883a 	mov	r22,r12
81128540:	1027883a 	mov	r19,r2
81128544:	e1000017 	ldw	r4,0(fp)
81128548:	21400003 	ldbu	r5,0(r4)
8112854c:	28bff544 	addi	r2,r5,-43
81128550:	10803fcc 	andi	r2,r2,255
81128554:	38810e36 	bltu	r7,r2,81128990 <__svfscanf_r+0xfac>
81128558:	100490ba 	slli	r2,r2,2
8112855c:	01a044f4 	movhi	r6,33043
81128560:	31a15c04 	addi	r6,r6,-31376
81128564:	1185883a 	add	r2,r2,r6
81128568:	10800017 	ldw	r2,0(r2)
8112856c:	1000683a 	jmp	r2
81128570:	81128868 	cmpgeui	r4,r16,18977
81128574:	81128990 	cmplti	r4,r16,18982
81128578:	81128868 	cmpgeui	r4,r16,18977
8112857c:	81128990 	cmplti	r4,r16,18982
81128580:	81128990 	cmplti	r4,r16,18982
81128584:	8112883c 	xorhi	r4,r16,18976
81128588:	811286ac 	andhi	r4,r16,18970
8112858c:	811286ac 	andhi	r4,r16,18970
81128590:	811286ac 	andhi	r4,r16,18970
81128594:	811286ac 	andhi	r4,r16,18970
81128598:	811286ac 	andhi	r4,r16,18970
8112859c:	811286ac 	andhi	r4,r16,18970
811285a0:	811286ac 	andhi	r4,r16,18970
811285a4:	811286ac 	andhi	r4,r16,18970
811285a8:	811286ac 	andhi	r4,r16,18970
811285ac:	81128990 	cmplti	r4,r16,18982
811285b0:	81128990 	cmplti	r4,r16,18982
811285b4:	81128990 	cmplti	r4,r16,18982
811285b8:	81128990 	cmplti	r4,r16,18982
811285bc:	81128990 	cmplti	r4,r16,18982
811285c0:	81128990 	cmplti	r4,r16,18982
811285c4:	81128990 	cmplti	r4,r16,18982
811285c8:	81128980 	call	88112898 <__reset+0x20f2898>
811285cc:	81128990 	cmplti	r4,r16,18982
811285d0:	81128990 	cmplti	r4,r16,18982
811285d4:	81128990 	cmplti	r4,r16,18982
811285d8:	8112893c 	xorhi	r4,r16,18980
811285dc:	81128920 	cmpeqi	r4,r16,18980
811285e0:	81128990 	cmplti	r4,r16,18982
811285e4:	81128990 	cmplti	r4,r16,18982
811285e8:	811288ec 	andhi	r4,r16,18979
811285ec:	81128990 	cmplti	r4,r16,18982
811285f0:	81128990 	cmplti	r4,r16,18982
811285f4:	81128990 	cmplti	r4,r16,18982
811285f8:	81128990 	cmplti	r4,r16,18982
811285fc:	811288b4 	orhi	r4,r16,18978
81128600:	81128990 	cmplti	r4,r16,18982
81128604:	81128990 	cmplti	r4,r16,18982
81128608:	81128990 	cmplti	r4,r16,18982
8112860c:	81128990 	cmplti	r4,r16,18982
81128610:	81128990 	cmplti	r4,r16,18982
81128614:	81128898 	cmpnei	r4,r16,18978
81128618:	81128990 	cmplti	r4,r16,18982
8112861c:	81128990 	cmplti	r4,r16,18982
81128620:	81128990 	cmplti	r4,r16,18982
81128624:	81128990 	cmplti	r4,r16,18982
81128628:	8112887c 	xorhi	r4,r16,18977
8112862c:	81128990 	cmplti	r4,r16,18982
81128630:	81128990 	cmplti	r4,r16,18982
81128634:	81128990 	cmplti	r4,r16,18982
81128638:	81128990 	cmplti	r4,r16,18982
8112863c:	81128990 	cmplti	r4,r16,18982
81128640:	81128990 	cmplti	r4,r16,18982
81128644:	81128990 	cmplti	r4,r16,18982
81128648:	81128980 	call	88112898 <__reset+0x20f2898>
8112864c:	81128990 	cmplti	r4,r16,18982
81128650:	81128990 	cmplti	r4,r16,18982
81128654:	81128990 	cmplti	r4,r16,18982
81128658:	8112893c 	xorhi	r4,r16,18980
8112865c:	81128920 	cmpeqi	r4,r16,18980
81128660:	81128990 	cmplti	r4,r16,18982
81128664:	81128990 	cmplti	r4,r16,18982
81128668:	811288ec 	andhi	r4,r16,18979
8112866c:	81128990 	cmplti	r4,r16,18982
81128670:	81128990 	cmplti	r4,r16,18982
81128674:	81128990 	cmplti	r4,r16,18982
81128678:	81128990 	cmplti	r4,r16,18982
8112867c:	811288b4 	orhi	r4,r16,18978
81128680:	81128990 	cmplti	r4,r16,18982
81128684:	81128990 	cmplti	r4,r16,18982
81128688:	81128990 	cmplti	r4,r16,18982
8112868c:	81128990 	cmplti	r4,r16,18982
81128690:	81128990 	cmplti	r4,r16,18982
81128694:	81128898 	cmpnei	r4,r16,18978
81128698:	81128990 	cmplti	r4,r16,18982
8112869c:	81128990 	cmplti	r4,r16,18982
811286a0:	81128990 	cmplti	r4,r16,18982
811286a4:	81128990 	cmplti	r4,r16,18982
811286a8:	8112887c 	xorhi	r4,r16,18977
811286ac:	a8803fcc 	andi	r2,r21,255
811286b0:	1080201c 	xori	r2,r2,128
811286b4:	10bfe004 	addi	r2,r2,-128
811286b8:	b085883a 	add	r2,r22,r2
811286bc:	10000d1e 	bne	r2,zero,811286f4 <__svfscanf_r+0xd10>
811286c0:	00bf9fc4 	movi	r2,-385
811286c4:	a0a8703a 	and	r20,r20,r2
811286c8:	89400005 	stb	r5,0(r17)
811286cc:	8c400044 	addi	r17,r17,1
811286d0:	e0800117 	ldw	r2,4(fp)
811286d4:	843fffc4 	addi	r16,r16,-1
811286d8:	94800044 	addi	r18,r18,1
811286dc:	10bfffc4 	addi	r2,r2,-1
811286e0:	e0800115 	stw	r2,4(fp)
811286e4:	0080b40e 	bge	zero,r2,811289b8 <__svfscanf_r+0xfd4>
811286e8:	21000044 	addi	r4,r4,1
811286ec:	e1000015 	stw	r4,0(fp)
811286f0:	803f941e 	bne	r16,zero,81128544 <__reset+0xfb108544>
811286f4:	8821883a 	mov	r16,r17
811286f8:	b019883a 	mov	r12,r22
811286fc:	9823883a 	mov	r17,r19
81128700:	182d883a 	mov	r22,r3
81128704:	9801961e 	bne	r19,zero,81128d60 <__svfscanf_r+0x137c>
81128708:	633fffc4 	addi	r12,r12,-1
8112870c:	00800044 	movi	r2,1
81128710:	1302882e 	bgeu	r2,r12,81129134 <__svfscanf_r+0x1750>
81128714:	a8803fcc 	andi	r2,r21,255
81128718:	1080201c 	xori	r2,r2,128
8112871c:	10bfe004 	addi	r2,r2,-128
81128720:	113fffc4 	addi	r4,r2,-1
81128724:	01400184 	movi	r5,6
81128728:	29001136 	bltu	r5,r4,81128770 <__svfscanf_r+0xd8c>
8112872c:	01000084 	movi	r4,2
81128730:	2082900e 	bge	r4,r2,81129174 <__svfscanf_r+0x1790>
81128734:	00c000c4 	movi	r3,3
81128738:	10c00d26 	beq	r2,r3,81128770 <__svfscanf_r+0xd8c>
8112873c:	9425c83a 	sub	r18,r18,r16
81128740:	1827883a 	mov	r19,r3
81128744:	843fffc4 	addi	r16,r16,-1
81128748:	81400007 	ldb	r5,0(r16)
8112874c:	e00d883a 	mov	r6,fp
81128750:	b009883a 	mov	r4,r22
81128754:	11313540 	call	81131354 <_ungetc_r>
81128758:	a8bfffc4 	addi	r2,r21,-1
8112875c:	10c03fcc 	andi	r3,r2,255
81128760:	8493883a 	add	r9,r16,r18
81128764:	102b883a 	mov	r21,r2
81128768:	98fff636 	bltu	r19,r3,81128744 <__reset+0xfb108744>
8112876c:	4825883a 	mov	r18,r9
81128770:	a080400c 	andi	r2,r20,256
81128774:	10001426 	beq	r2,zero,811287c8 <__svfscanf_r+0xde4>
81128778:	a081000c 	andi	r2,r20,1024
8112877c:	1002571e 	bne	r2,zero,811290dc <__svfscanf_r+0x16f8>
81128780:	817fffc7 	ldb	r5,-1(r16)
81128784:	00801944 	movi	r2,101
81128788:	84ffffc4 	addi	r19,r16,-1
8112878c:	957fffc4 	addi	r21,r18,-1
81128790:	28800826 	beq	r5,r2,811287b4 <__svfscanf_r+0xdd0>
81128794:	00801144 	movi	r2,69
81128798:	28800626 	beq	r5,r2,811287b4 <__svfscanf_r+0xdd0>
8112879c:	e00d883a 	mov	r6,fp
811287a0:	b009883a 	mov	r4,r22
811287a4:	11313540 	call	81131354 <_ungetc_r>
811287a8:	817fff87 	ldb	r5,-2(r16)
811287ac:	84ffff84 	addi	r19,r16,-2
811287b0:	957fff84 	addi	r21,r18,-2
811287b4:	e00d883a 	mov	r6,fp
811287b8:	b009883a 	mov	r4,r22
811287bc:	11313540 	call	81131354 <_ungetc_r>
811287c0:	a825883a 	mov	r18,r21
811287c4:	9821883a 	mov	r16,r19
811287c8:	a080040c 	andi	r2,r20,16
811287cc:	103e891e 	bne	r2,zero,811281f4 <__reset+0xfb1081f4>
811287d0:	80000005 	stb	zero,0(r16)
811287d4:	a081800c 	andi	r2,r20,1536
811287d8:	01010004 	movi	r4,1024
811287dc:	1101dd26 	beq	r2,r4,81128f54 <__svfscanf_r+0x1570>
811287e0:	da00a417 	ldw	r8,656(sp)
811287e4:	4001e71e 	bne	r8,zero,81128f84 <__svfscanf_r+0x15a0>
811287e8:	000d883a 	mov	r6,zero
811287ec:	d9400104 	addi	r5,sp,4
811287f0:	b009883a 	mov	r4,r22
811287f4:	112e1ec0 	call	8112e1ec <_strtod_r>
811287f8:	1021883a 	mov	r16,r2
811287fc:	a080004c 	andi	r2,r20,1
81128800:	1000021e 	bne	r2,zero,8112880c <__svfscanf_r+0xe28>
81128804:	a2c0008c 	andi	r11,r20,2
81128808:	5801e826 	beq	r11,zero,81128fac <__svfscanf_r+0x15c8>
8112880c:	da009c17 	ldw	r8,624(sp)
81128810:	40800017 	ldw	r2,0(r8)
81128814:	42000104 	addi	r8,r8,4
81128818:	da009c15 	stw	r8,624(sp)
8112881c:	14000015 	stw	r16,0(r2)
81128820:	10c00115 	stw	r3,4(r2)
81128824:	da00a017 	ldw	r8,640(sp)
81128828:	dd009d17 	ldw	r20,628(sp)
8112882c:	42000044 	addi	r8,r8,1
81128830:	da00a015 	stw	r8,640(sp)
81128834:	a00d883a 	mov	r6,r20
81128838:	003ca806 	br	81127adc <__reset+0xfb107adc>
8112883c:	a080400c 	andi	r2,r20,256
81128840:	103f9a26 	beq	r2,zero,811286ac <__reset+0xfb1086ac>
81128844:	da00a217 	ldw	r8,648(sp)
81128848:	00bfdfc4 	movi	r2,-129
8112884c:	a0a8703a 	and	r20,r20,r2
81128850:	9cc00044 	addi	r19,r19,1
81128854:	403f9e26 	beq	r8,zero,811286d0 <__reset+0xfb1086d0>
81128858:	423fffc4 	addi	r8,r8,-1
8112885c:	da00a215 	stw	r8,648(sp)
81128860:	84000044 	addi	r16,r16,1
81128864:	003f9a06 	br	811286d0 <__reset+0xfb1086d0>
81128868:	a080200c 	andi	r2,r20,128
8112886c:	103fa126 	beq	r2,zero,811286f4 <__reset+0xfb1086f4>
81128870:	00bfdfc4 	movi	r2,-129
81128874:	a0a8703a 	and	r20,r20,r2
81128878:	003f9306 	br	811286c8 <__reset+0xfb1086c8>
8112887c:	a8803fcc 	andi	r2,r21,255
81128880:	1080201c 	xori	r2,r2,128
81128884:	10bfe004 	addi	r2,r2,-128
81128888:	020001c4 	movi	r8,7
8112888c:	123f991e 	bne	r2,r8,811286f4 <__reset+0xfb1086f4>
81128890:	05400204 	movi	r21,8
81128894:	003f8c06 	br	811286c8 <__reset+0xfb1086c8>
81128898:	a8803fcc 	andi	r2,r21,255
8112889c:	1080201c 	xori	r2,r2,128
811288a0:	10bfe004 	addi	r2,r2,-128
811288a4:	01800184 	movi	r6,6
811288a8:	11bf921e 	bne	r2,r6,811286f4 <__reset+0xfb1086f4>
811288ac:	054001c4 	movi	r21,7
811288b0:	003f8506 	br	811286c8 <__reset+0xfb1086c8>
811288b4:	b000491e 	bne	r22,zero,811289dc <__svfscanf_r+0xff8>
811288b8:	9800031e 	bne	r19,zero,811288c8 <__svfscanf_r+0xee4>
811288bc:	a081c00c 	andi	r2,r20,1792
811288c0:	0181c004 	movi	r6,1792
811288c4:	11819f26 	beq	r2,r6,81128f44 <__svfscanf_r+0x1560>
811288c8:	a8803fcc 	andi	r2,r21,255
811288cc:	1080201c 	xori	r2,r2,128
811288d0:	10bfe004 	addi	r2,r2,-128
811288d4:	01800044 	movi	r6,1
811288d8:	11800226 	beq	r2,r6,811288e4 <__svfscanf_r+0xf00>
811288dc:	01800104 	movi	r6,4
811288e0:	11bf841e 	bne	r2,r6,811286f4 <__reset+0xfb1086f4>
811288e4:	ad400044 	addi	r21,r21,1
811288e8:	003f7706 	br	811286c8 <__reset+0xfb1086c8>
811288ec:	a8803fcc 	andi	r2,r21,255
811288f0:	1080201c 	xori	r2,r2,128
811288f4:	10bfe004 	addi	r2,r2,-128
811288f8:	10003c1e 	bne	r2,zero,811289ec <__svfscanf_r+0x1008>
811288fc:	9801141e 	bne	r19,zero,81128d50 <__svfscanf_r+0x136c>
81128900:	a081c00c 	andi	r2,r20,1792
81128904:	0181c004 	movi	r6,1792
81128908:	11818226 	beq	r2,r6,81128f14 <__svfscanf_r+0x1530>
8112890c:	8821883a 	mov	r16,r17
81128910:	b019883a 	mov	r12,r22
81128914:	9823883a 	mov	r17,r19
81128918:	182d883a 	mov	r22,r3
8112891c:	003f7a06 	br	81128708 <__reset+0xfb108708>
81128920:	a8803fcc 	andi	r2,r21,255
81128924:	1080201c 	xori	r2,r2,128
81128928:	10bfe004 	addi	r2,r2,-128
8112892c:	01800084 	movi	r6,2
81128930:	11bf701e 	bne	r2,r6,811286f4 <__reset+0xfb1086f4>
81128934:	054000c4 	movi	r21,3
81128938:	003f6306 	br	811286c8 <__reset+0xfb1086c8>
8112893c:	a081400c 	andi	r2,r20,1280
81128940:	01810004 	movi	r6,1024
81128944:	11800326 	beq	r2,r6,81128954 <__svfscanf_r+0xf70>
81128948:	a184703a 	and	r2,r20,r6
8112894c:	103f6926 	beq	r2,zero,811286f4 <__reset+0xfb1086f4>
81128950:	983fee26 	beq	r19,zero,8112890c <__reset+0xfb10890c>
81128954:	a080800c 	andi	r2,r20,512
81128958:	1000041e 	bne	r2,zero,8112896c <__svfscanf_r+0xf88>
8112895c:	da009f17 	ldw	r8,636(sp)
81128960:	dc40a515 	stw	r17,660(sp)
81128964:	9a27c83a 	sub	r19,r19,r8
81128968:	dcc0a415 	stw	r19,656(sp)
8112896c:	00be1fc4 	movi	r2,-1921
81128970:	a0a8703a 	and	r20,r20,r2
81128974:	a5006014 	ori	r20,r20,384
81128978:	0027883a 	mov	r19,zero
8112897c:	003f5206 	br	811286c8 <__reset+0xfb1086c8>
81128980:	00800044 	movi	r2,1
81128984:	b0bf5b1e 	bne	r22,r2,811286f4 <__reset+0xfb1086f4>
81128988:	05800084 	movi	r22,2
8112898c:	003f4e06 	br	811286c8 <__reset+0xfb1086c8>
81128990:	d980a317 	ldw	r6,652(sp)
81128994:	30800003 	ldbu	r2,0(r6)
81128998:	29803fcc 	andi	r6,r5,255
8112899c:	30bf551e 	bne	r6,r2,811286f4 <__reset+0xfb1086f4>
811289a0:	a080800c 	andi	r2,r20,512
811289a4:	103f5326 	beq	r2,zero,811286f4 <__reset+0xfb1086f4>
811289a8:	023f5fc4 	movi	r8,-641
811289ac:	a228703a 	and	r20,r20,r8
811289b0:	dcc09f15 	stw	r19,636(sp)
811289b4:	003f4406 	br	811286c8 <__reset+0xfb1086c8>
811289b8:	1809883a 	mov	r4,r3
811289bc:	e00b883a 	mov	r5,fp
811289c0:	d8c0a615 	stw	r3,664(sp)
811289c4:	d9c0aa15 	stw	r7,680(sp)
811289c8:	11229c00 	call	811229c0 <__srefill_r>
811289cc:	d8c0a617 	ldw	r3,664(sp)
811289d0:	d9c0aa17 	ldw	r7,680(sp)
811289d4:	103f4626 	beq	r2,zero,811286f0 <__reset+0xfb1086f0>
811289d8:	003f4606 	br	811286f4 <__reset+0xfb1086f4>
811289dc:	00800084 	movi	r2,2
811289e0:	b0bfb91e 	bne	r22,r2,811288c8 <__reset+0xfb1088c8>
811289e4:	058000c4 	movi	r22,3
811289e8:	003f3706 	br	811286c8 <__reset+0xfb1086c8>
811289ec:	018000c4 	movi	r6,3
811289f0:	11bfbc26 	beq	r2,r6,811288e4 <__reset+0xfb1088e4>
811289f4:	01800144 	movi	r6,5
811289f8:	11bfba26 	beq	r2,r6,811288e4 <__reset+0xfb1088e4>
811289fc:	003f3d06 	br	811286f4 <__reset+0xfb1086f4>
81128a00:	98bfffc4 	addi	r2,r19,-1
81128a04:	01405704 	movi	r5,348
81128a08:	2880d82e 	bgeu	r5,r2,81128d6c <__svfscanf_r+0x1388>
81128a0c:	99ffa8c4 	addi	r7,r19,-349
81128a10:	04c05744 	movi	r19,349
81128a14:	8c436014 	ori	r17,r17,3456
81128a18:	9013883a 	mov	r9,r18
81128a1c:	8825883a 	mov	r18,r17
81128a20:	dc409e17 	ldw	r17,632(sp)
81128a24:	0029883a 	mov	r20,zero
81128a28:	dc000104 	addi	r16,sp,4
81128a2c:	05401344 	movi	r21,77
81128a30:	02c08004 	movi	r11,512
81128a34:	01bf7fc4 	movi	r6,-513
81128a38:	023fdfc4 	movi	r8,-129
81128a3c:	20bff544 	addi	r2,r4,-43
81128a40:	10803fcc 	andi	r2,r2,255
81128a44:	a8807236 	bltu	r21,r2,81128c10 <__svfscanf_r+0x122c>
81128a48:	100490ba 	slli	r2,r2,2
81128a4c:	016044f4 	movhi	r5,33043
81128a50:	29629804 	addi	r5,r5,-30112
81128a54:	1145883a 	add	r2,r2,r5
81128a58:	10800017 	ldw	r2,0(r2)
81128a5c:	1000683a 	jmp	r2
81128a60:	81128c94 	ori	r4,r16,18994
81128a64:	81128c10 	cmplti	r4,r16,18992
81128a68:	81128c94 	ori	r4,r16,18994
81128a6c:	81128c10 	cmplti	r4,r16,18992
81128a70:	81128c10 	cmplti	r4,r16,18992
81128a74:	81128c6c 	andhi	r4,r16,18993
81128a78:	81128c4c 	andi	r4,r16,18993
81128a7c:	81128c4c 	andi	r4,r16,18993
81128a80:	81128c4c 	andi	r4,r16,18993
81128a84:	81128c4c 	andi	r4,r16,18993
81128a88:	81128c4c 	andi	r4,r16,18993
81128a8c:	81128c4c 	andi	r4,r16,18993
81128a90:	81128c4c 	andi	r4,r16,18993
81128a94:	81128bf4 	orhi	r4,r16,18991
81128a98:	81128bf4 	orhi	r4,r16,18991
81128a9c:	81128c10 	cmplti	r4,r16,18992
81128aa0:	81128c10 	cmplti	r4,r16,18992
81128aa4:	81128c10 	cmplti	r4,r16,18992
81128aa8:	81128c10 	cmplti	r4,r16,18992
81128aac:	81128c10 	cmplti	r4,r16,18992
81128ab0:	81128c10 	cmplti	r4,r16,18992
81128ab4:	81128c10 	cmplti	r4,r16,18992
81128ab8:	81128be0 	cmpeqi	r4,r16,18991
81128abc:	81128be0 	cmpeqi	r4,r16,18991
81128ac0:	81128be0 	cmpeqi	r4,r16,18991
81128ac4:	81128be0 	cmpeqi	r4,r16,18991
81128ac8:	81128be0 	cmpeqi	r4,r16,18991
81128acc:	81128be0 	cmpeqi	r4,r16,18991
81128ad0:	81128c10 	cmplti	r4,r16,18992
81128ad4:	81128c10 	cmplti	r4,r16,18992
81128ad8:	81128c10 	cmplti	r4,r16,18992
81128adc:	81128c10 	cmplti	r4,r16,18992
81128ae0:	81128c10 	cmplti	r4,r16,18992
81128ae4:	81128c10 	cmplti	r4,r16,18992
81128ae8:	81128c10 	cmplti	r4,r16,18992
81128aec:	81128c10 	cmplti	r4,r16,18992
81128af0:	81128c10 	cmplti	r4,r16,18992
81128af4:	81128c10 	cmplti	r4,r16,18992
81128af8:	81128c10 	cmplti	r4,r16,18992
81128afc:	81128c10 	cmplti	r4,r16,18992
81128b00:	81128c10 	cmplti	r4,r16,18992
81128b04:	81128c10 	cmplti	r4,r16,18992
81128b08:	81128c10 	cmplti	r4,r16,18992
81128b0c:	81128c10 	cmplti	r4,r16,18992
81128b10:	81128c10 	cmplti	r4,r16,18992
81128b14:	81128b98 	cmpnei	r4,r16,18990
81128b18:	81128c10 	cmplti	r4,r16,18992
81128b1c:	81128c10 	cmplti	r4,r16,18992
81128b20:	81128c10 	cmplti	r4,r16,18992
81128b24:	81128c10 	cmplti	r4,r16,18992
81128b28:	81128c10 	cmplti	r4,r16,18992
81128b2c:	81128c10 	cmplti	r4,r16,18992
81128b30:	81128c10 	cmplti	r4,r16,18992
81128b34:	81128c10 	cmplti	r4,r16,18992
81128b38:	81128be0 	cmpeqi	r4,r16,18991
81128b3c:	81128be0 	cmpeqi	r4,r16,18991
81128b40:	81128be0 	cmpeqi	r4,r16,18991
81128b44:	81128be0 	cmpeqi	r4,r16,18991
81128b48:	81128be0 	cmpeqi	r4,r16,18991
81128b4c:	81128be0 	cmpeqi	r4,r16,18991
81128b50:	81128c10 	cmplti	r4,r16,18992
81128b54:	81128c10 	cmplti	r4,r16,18992
81128b58:	81128c10 	cmplti	r4,r16,18992
81128b5c:	81128c10 	cmplti	r4,r16,18992
81128b60:	81128c10 	cmplti	r4,r16,18992
81128b64:	81128c10 	cmplti	r4,r16,18992
81128b68:	81128c10 	cmplti	r4,r16,18992
81128b6c:	81128c10 	cmplti	r4,r16,18992
81128b70:	81128c10 	cmplti	r4,r16,18992
81128b74:	81128c10 	cmplti	r4,r16,18992
81128b78:	81128c10 	cmplti	r4,r16,18992
81128b7c:	81128c10 	cmplti	r4,r16,18992
81128b80:	81128c10 	cmplti	r4,r16,18992
81128b84:	81128c10 	cmplti	r4,r16,18992
81128b88:	81128c10 	cmplti	r4,r16,18992
81128b8c:	81128c10 	cmplti	r4,r16,18992
81128b90:	81128c10 	cmplti	r4,r16,18992
81128b94:	81128b98 	cmpnei	r4,r16,18990
81128b98:	9081800c 	andi	r2,r18,1536
81128b9c:	12c01c1e 	bne	r2,r11,81128c10 <__svfscanf_r+0x122c>
81128ba0:	91a4703a 	and	r18,r18,r6
81128ba4:	94814014 	ori	r18,r18,1280
81128ba8:	04400404 	movi	r17,16
81128bac:	81000005 	stb	r4,0(r16)
81128bb0:	84000044 	addi	r16,r16,1
81128bb4:	e0800117 	ldw	r2,4(fp)
81128bb8:	10bfffc4 	addi	r2,r2,-1
81128bbc:	e0800115 	stw	r2,4(fp)
81128bc0:	0080540e 	bge	zero,r2,81128d14 <__svfscanf_r+0x1330>
81128bc4:	18c00044 	addi	r3,r3,1
81128bc8:	e0c00015 	stw	r3,0(fp)
81128bcc:	9cffffc4 	addi	r19,r19,-1
81128bd0:	98000f26 	beq	r19,zero,81128c10 <__svfscanf_r+0x122c>
81128bd4:	e0c00017 	ldw	r3,0(fp)
81128bd8:	19000003 	ldbu	r4,0(r3)
81128bdc:	003f9706 	br	81128a3c <__reset+0xfb108a3c>
81128be0:	00800284 	movi	r2,10
81128be4:	14400a0e 	bge	r2,r17,81128c10 <__svfscanf_r+0x122c>
81128be8:	00bd1fc4 	movi	r2,-2945
81128bec:	90a4703a 	and	r18,r18,r2
81128bf0:	003fee06 	br	81128bac <__reset+0xfb108bac>
81128bf4:	01604574 	movhi	r5,33045
81128bf8:	8c63883a 	add	r17,r17,r17
81128bfc:	29423784 	addi	r5,r5,2270
81128c00:	2c45883a 	add	r2,r5,r17
81128c04:	1440000f 	ldh	r17,0(r2)
81128c08:	00800204 	movi	r2,8
81128c0c:	147ff616 	blt	r2,r17,81128be8 <__reset+0xfb108be8>
81128c10:	dc409e15 	stw	r17,632(sp)
81128c14:	9023883a 	mov	r17,r18
81128c18:	8880400c 	andi	r2,r17,256
81128c1c:	4825883a 	mov	r18,r9
81128c20:	10000426 	beq	r2,zero,81128c34 <__svfscanf_r+0x1250>
81128c24:	d9800104 	addi	r6,sp,4
81128c28:	3400be36 	bltu	r6,r16,81128f24 <__svfscanf_r+0x1540>
81128c2c:	da000104 	addi	r8,sp,4
81128c30:	443bae26 	beq	r8,r16,81127aec <__reset+0xfb107aec>
81128c34:	8880040c 	andi	r2,r17,16
81128c38:	10009326 	beq	r2,zero,81128e88 <__svfscanf_r+0x14a4>
81128c3c:	d8800104 	addi	r2,sp,4
81128c40:	80a1c83a 	sub	r16,r16,r2
81128c44:	8521883a 	add	r16,r16,r20
81128c48:	003d0606 	br	81128064 <__reset+0xfb108064>
81128c4c:	01604574 	movhi	r5,33045
81128c50:	8c63883a 	add	r17,r17,r17
81128c54:	29423784 	addi	r5,r5,2270
81128c58:	2c45883a 	add	r2,r5,r17
81128c5c:	1440000f 	ldh	r17,0(r2)
81128c60:	00bd1fc4 	movi	r2,-2945
81128c64:	90a4703a 	and	r18,r18,r2
81128c68:	003fd006 	br	81128bac <__reset+0xfb108bac>
81128c6c:	9082000c 	andi	r2,r18,2048
81128c70:	103fce26 	beq	r2,zero,81128bac <__reset+0xfb108bac>
81128c74:	8800021e 	bne	r17,zero,81128c80 <__svfscanf_r+0x129c>
81128c78:	94808014 	ori	r18,r18,512
81128c7c:	04400204 	movi	r17,8
81128c80:	9081000c 	andi	r2,r18,1024
81128c84:	10009426 	beq	r2,zero,81128ed8 <__svfscanf_r+0x14f4>
81128c88:	00be9fc4 	movi	r2,-1409
81128c8c:	90a4703a 	and	r18,r18,r2
81128c90:	003fc606 	br	81128bac <__reset+0xfb108bac>
81128c94:	9080200c 	andi	r2,r18,128
81128c98:	103fdd26 	beq	r2,zero,81128c10 <__reset+0xfb108c10>
81128c9c:	9224703a 	and	r18,r18,r8
81128ca0:	003fc206 	br	81128bac <__reset+0xfb108bac>
81128ca4:	9800011e 	bne	r19,zero,81128cac <__svfscanf_r+0x12c8>
81128ca8:	04ffffc4 	movi	r19,-1
81128cac:	8900004c 	andi	r4,r17,1
81128cb0:	20005b1e 	bne	r4,zero,81128e20 <__svfscanf_r+0x143c>
81128cb4:	8c40040c 	andi	r17,r17,16
81128cb8:	88003026 	beq	r17,zero,81128d7c <__svfscanf_r+0x1398>
81128cbc:	0021883a 	mov	r16,zero
81128cc0:	00000306 	br	81128cd0 <__svfscanf_r+0x12ec>
81128cc4:	18800003 	ldbu	r2,0(r3)
81128cc8:	3885883a 	add	r2,r7,r2
81128ccc:	10800043 	ldbu	r2,1(r2)
81128cd0:	1080020c 	andi	r2,r2,8
81128cd4:	103ce31e 	bne	r2,zero,81128064 <__reset+0xfb108064>
81128cd8:	e0800117 	ldw	r2,4(fp)
81128cdc:	18c00044 	addi	r3,r3,1
81128ce0:	84000044 	addi	r16,r16,1
81128ce4:	10bfffc4 	addi	r2,r2,-1
81128ce8:	e0800115 	stw	r2,4(fp)
81128cec:	e0c00015 	stw	r3,0(fp)
81128cf0:	84fcdc26 	beq	r16,r19,81128064 <__reset+0xfb108064>
81128cf4:	00bff316 	blt	zero,r2,81128cc4 <__reset+0xfb108cc4>
81128cf8:	e00b883a 	mov	r5,fp
81128cfc:	b009883a 	mov	r4,r22
81128d00:	11229c00 	call	811229c0 <__srefill_r>
81128d04:	103cd71e 	bne	r2,zero,81128064 <__reset+0xfb108064>
81128d08:	b9c00017 	ldw	r7,0(r23)
81128d0c:	e0c00017 	ldw	r3,0(fp)
81128d10:	003fec06 	br	81128cc4 <__reset+0xfb108cc4>
81128d14:	e00b883a 	mov	r5,fp
81128d18:	b009883a 	mov	r4,r22
81128d1c:	d980a715 	stw	r6,668(sp)
81128d20:	d9c0aa15 	stw	r7,680(sp)
81128d24:	da00a815 	stw	r8,672(sp)
81128d28:	da40a915 	stw	r9,676(sp)
81128d2c:	dac0a615 	stw	r11,664(sp)
81128d30:	11229c00 	call	811229c0 <__srefill_r>
81128d34:	d980a717 	ldw	r6,668(sp)
81128d38:	d9c0aa17 	ldw	r7,680(sp)
81128d3c:	da00a817 	ldw	r8,672(sp)
81128d40:	da40a917 	ldw	r9,676(sp)
81128d44:	dac0a617 	ldw	r11,664(sp)
81128d48:	103fa026 	beq	r2,zero,81128bcc <__reset+0xfb108bcc>
81128d4c:	003fb006 	br	81128c10 <__reset+0xfb108c10>
81128d50:	8821883a 	mov	r16,r17
81128d54:	b019883a 	mov	r12,r22
81128d58:	9823883a 	mov	r17,r19
81128d5c:	182d883a 	mov	r22,r3
81128d60:	00bfbfc4 	movi	r2,-257
81128d64:	a0a8703a 	and	r20,r20,r2
81128d68:	003e6706 	br	81128708 <__reset+0xfb108708>
81128d6c:	000f883a 	mov	r7,zero
81128d70:	003f2806 	br	81128a14 <__reset+0xfb108a14>
81128d74:	d800a215 	stw	zero,648(sp)
81128d78:	003de306 	br	81128508 <__reset+0xfb108508>
81128d7c:	da009c17 	ldw	r8,624(sp)
81128d80:	9abfffc4 	addi	r10,r19,-1
81128d84:	44400017 	ldw	r17,0(r8)
81128d88:	44000104 	addi	r16,r8,4
81128d8c:	880b883a 	mov	r5,r17
81128d90:	8aa9883a 	add	r20,r17,r10
81128d94:	00000606 	br	81128db0 <__svfscanf_r+0x13cc>
81128d98:	e0c00017 	ldw	r3,0(fp)
81128d9c:	b9000017 	ldw	r4,0(r23)
81128da0:	a80b883a 	mov	r5,r21
81128da4:	18800003 	ldbu	r2,0(r3)
81128da8:	2085883a 	add	r2,r4,r2
81128dac:	10800043 	ldbu	r2,1(r2)
81128db0:	1080020c 	andi	r2,r2,8
81128db4:	1000551e 	bne	r2,zero,81128f0c <__svfscanf_r+0x1528>
81128db8:	e0800117 	ldw	r2,4(fp)
81128dbc:	19000044 	addi	r4,r3,1
81128dc0:	e1000015 	stw	r4,0(fp)
81128dc4:	10bfffc4 	addi	r2,r2,-1
81128dc8:	e0800115 	stw	r2,4(fp)
81128dcc:	18800003 	ldbu	r2,0(r3)
81128dd0:	2d400044 	addi	r21,r5,1
81128dd4:	a827883a 	mov	r19,r21
81128dd8:	28800005 	stb	r2,0(r5)
81128ddc:	2d000626 	beq	r5,r20,81128df8 <__svfscanf_r+0x1414>
81128de0:	e0800117 	ldw	r2,4(fp)
81128de4:	00bfec16 	blt	zero,r2,81128d98 <__reset+0xfb108d98>
81128de8:	e00b883a 	mov	r5,fp
81128dec:	b009883a 	mov	r4,r22
81128df0:	11229c00 	call	811229c0 <__srefill_r>
81128df4:	103fe826 	beq	r2,zero,81128d98 <__reset+0xfb108d98>
81128df8:	da00a017 	ldw	r8,640(sp)
81128dfc:	dd009d17 	ldw	r20,628(sp)
81128e00:	9c63c83a 	sub	r17,r19,r17
81128e04:	42000044 	addi	r8,r8,1
81128e08:	98000005 	stb	zero,0(r19)
81128e0c:	9465883a 	add	r18,r18,r17
81128e10:	da00a015 	stw	r8,640(sp)
81128e14:	dc009c15 	stw	r16,624(sp)
81128e18:	a00d883a 	mov	r6,r20
81128e1c:	003b2f06 	br	81127adc <__reset+0xfb107adc>
81128e20:	dd409904 	addi	r21,sp,612
81128e24:	8c40040c 	andi	r17,r17,16
81128e28:	01800204 	movi	r6,8
81128e2c:	000b883a 	mov	r5,zero
81128e30:	a809883a 	mov	r4,r21
81128e34:	11225440 	call	81122544 <memset>
81128e38:	8800401e 	bne	r17,zero,81128f3c <__svfscanf_r+0x1558>
81128e3c:	da009c17 	ldw	r8,624(sp)
81128e40:	45000017 	ldw	r20,0(r8)
81128e44:	42000104 	addi	r8,r8,4
81128e48:	da009c15 	stw	r8,624(sp)
81128e4c:	000d883a 	mov	r6,zero
81128e50:	3021883a 	mov	r16,r6
81128e54:	dc409f15 	stw	r17,636(sp)
81128e58:	e0800017 	ldw	r2,0(fp)
81128e5c:	b8c00017 	ldw	r3,0(r23)
81128e60:	10800003 	ldbu	r2,0(r2)
81128e64:	1885883a 	add	r2,r3,r2
81128e68:	10800043 	ldbu	r2,1(r2)
81128e6c:	1080020c 	andi	r2,r2,8
81128e70:	1000011e 	bne	r2,zero,81128e78 <__svfscanf_r+0x1494>
81128e74:	9800701e 	bne	r19,zero,81129038 <__svfscanf_r+0x1654>
81128e78:	dc409f17 	ldw	r17,636(sp)
81128e7c:	883cdd1e 	bne	r17,zero,811281f4 <__reset+0xfb1081f4>
81128e80:	a0000015 	stw	zero,0(r20)
81128e84:	003cd806 	br	811281e8 <__reset+0xfb1081e8>
81128e88:	d9c09e17 	ldw	r7,632(sp)
81128e8c:	da00a117 	ldw	r8,644(sp)
81128e90:	000d883a 	mov	r6,zero
81128e94:	d9400104 	addi	r5,sp,4
81128e98:	b009883a 	mov	r4,r22
81128e9c:	80000005 	stb	zero,0(r16)
81128ea0:	403ee83a 	callr	r8
81128ea4:	88c0080c 	andi	r3,r17,32
81128ea8:	1800121e 	bne	r3,zero,81128ef4 <__svfscanf_r+0x1510>
81128eac:	88c0010c 	andi	r3,r17,4
81128eb0:	18004d26 	beq	r3,zero,81128fe8 <__svfscanf_r+0x1604>
81128eb4:	da009c17 	ldw	r8,624(sp)
81128eb8:	40c00017 	ldw	r3,0(r8)
81128ebc:	42000104 	addi	r8,r8,4
81128ec0:	da009c15 	stw	r8,624(sp)
81128ec4:	1880000d 	sth	r2,0(r3)
81128ec8:	da00a017 	ldw	r8,640(sp)
81128ecc:	42000044 	addi	r8,r8,1
81128ed0:	da00a015 	stw	r8,640(sp)
81128ed4:	003f5906 	br	81128c3c <__reset+0xfb108c3c>
81128ed8:	00bf1fc4 	movi	r2,-897
81128edc:	90a4703a 	and	r18,r18,r2
81128ee0:	38000226 	beq	r7,zero,81128eec <__svfscanf_r+0x1508>
81128ee4:	39ffffc4 	addi	r7,r7,-1
81128ee8:	9cc00044 	addi	r19,r19,1
81128eec:	a5000044 	addi	r20,r20,1
81128ef0:	003f3006 	br	81128bb4 <__reset+0xfb108bb4>
81128ef4:	da009c17 	ldw	r8,624(sp)
81128ef8:	40c00017 	ldw	r3,0(r8)
81128efc:	42000104 	addi	r8,r8,4
81128f00:	da009c15 	stw	r8,624(sp)
81128f04:	18800015 	stw	r2,0(r3)
81128f08:	003fef06 	br	81128ec8 <__reset+0xfb108ec8>
81128f0c:	2827883a 	mov	r19,r5
81128f10:	003fb906 	br	81128df8 <__reset+0xfb108df8>
81128f14:	01be1fc4 	movi	r6,-1921
81128f18:	a1a8703a 	and	r20,r20,r6
81128f1c:	05400044 	movi	r21,1
81128f20:	003de906 	br	811286c8 <__reset+0xfb1086c8>
81128f24:	817fffc7 	ldb	r5,-1(r16)
81128f28:	e00d883a 	mov	r6,fp
81128f2c:	b009883a 	mov	r4,r22
81128f30:	843fffc4 	addi	r16,r16,-1
81128f34:	11313540 	call	81131354 <_ungetc_r>
81128f38:	003f3c06 	br	81128c2c <__reset+0xfb108c2c>
81128f3c:	dd009b04 	addi	r20,sp,620
81128f40:	003fc206 	br	81128e4c <__reset+0xfb108e4c>
81128f44:	00be1fc4 	movi	r2,-1921
81128f48:	a0a8703a 	and	r20,r20,r2
81128f4c:	05800044 	movi	r22,1
81128f50:	003ddd06 	br	811286c8 <__reset+0xfb1086c8>
81128f54:	d8c09f17 	ldw	r3,636(sp)
81128f58:	88e3c83a 	sub	r17,r17,r3
81128f5c:	044dc83a 	sub	r6,zero,r17
81128f60:	883e2126 	beq	r17,zero,811287e8 <__reset+0xfb1087e8>
81128f64:	d88055c4 	addi	r2,sp,343
81128f68:	80800136 	bltu	r16,r2,81128f70 <__svfscanf_r+0x158c>
81128f6c:	dc005584 	addi	r16,sp,342
81128f70:	01604574 	movhi	r5,33045
81128f74:	29423604 	addi	r5,r5,2264
81128f78:	8009883a 	mov	r4,r16
81128f7c:	1122cd40 	call	81122cd4 <sprintf>
81128f80:	003e1906 	br	811287e8 <__reset+0xfb1087e8>
81128f84:	d8c0a517 	ldw	r3,660(sp)
81128f88:	000d883a 	mov	r6,zero
81128f8c:	01c00284 	movi	r7,10
81128f90:	19400044 	addi	r5,r3,1
81128f94:	b009883a 	mov	r4,r22
81128f98:	1122fc40 	call	81122fc4 <_strtol_r>
81128f9c:	da00a417 	ldw	r8,656(sp)
81128fa0:	dc00a517 	ldw	r16,660(sp)
81128fa4:	120dc83a 	sub	r6,r2,r8
81128fa8:	003fee06 	br	81128f64 <__reset+0xfb108f64>
81128fac:	da009c17 	ldw	r8,624(sp)
81128fb0:	180b883a 	mov	r5,r3
81128fb4:	8009883a 	mov	r4,r16
81128fb8:	45000017 	ldw	r20,0(r8)
81128fbc:	44400104 	addi	r17,r8,4
81128fc0:	d8c0a615 	stw	r3,664(sp)
81128fc4:	112df580 	call	8112df58 <__fpclassifyd>
81128fc8:	d8c0a617 	ldw	r3,664(sp)
81128fcc:	10006426 	beq	r2,zero,81129160 <__svfscanf_r+0x177c>
81128fd0:	8009883a 	mov	r4,r16
81128fd4:	180b883a 	mov	r5,r3
81128fd8:	1120fc40 	call	81120fc4 <__truncdfsf2>
81128fdc:	a0800015 	stw	r2,0(r20)
81128fe0:	dc409c15 	stw	r17,624(sp)
81128fe4:	003e0f06 	br	81128824 <__reset+0xfb108824>
81128fe8:	88c0004c 	andi	r3,r17,1
81128fec:	183fc11e 	bne	r3,zero,81128ef4 <__reset+0xfb108ef4>
81128ff0:	8c40008c 	andi	r17,r17,2
81128ff4:	883fbf26 	beq	r17,zero,81128ef4 <__reset+0xfb108ef4>
81128ff8:	da00a117 	ldw	r8,644(sp)
81128ffc:	00a044f4 	movhi	r2,33043
81129000:	10be4304 	addi	r2,r2,-1780
81129004:	d9c09e17 	ldw	r7,632(sp)
81129008:	000d883a 	mov	r6,zero
8112900c:	d9400104 	addi	r5,sp,4
81129010:	b009883a 	mov	r4,r22
81129014:	40806226 	beq	r8,r2,811291a0 <__svfscanf_r+0x17bc>
81129018:	112323c0 	call	8112323c <_strtoll_r>
8112901c:	da009c17 	ldw	r8,624(sp)
81129020:	41000017 	ldw	r4,0(r8)
81129024:	42000104 	addi	r8,r8,4
81129028:	da009c15 	stw	r8,624(sp)
8112902c:	20800015 	stw	r2,0(r4)
81129030:	20c00115 	stw	r3,4(r4)
81129034:	003fa406 	br	81128ec8 <__reset+0xfb108ec8>
81129038:	112c3e80 	call	8112c3e8 <__locale_mb_cur_max>
8112903c:	80bca726 	beq	r16,r2,811282dc <__reset+0xfb1082dc>
81129040:	e0800017 	ldw	r2,0(fp)
81129044:	e1000117 	ldw	r4,4(fp)
81129048:	d8c00104 	addi	r3,sp,4
8112904c:	12000003 	ldbu	r8,0(r2)
81129050:	213fffc4 	addi	r4,r4,-1
81129054:	10800044 	addi	r2,r2,1
81129058:	e1000115 	stw	r4,4(fp)
8112905c:	e0800015 	stw	r2,0(fp)
81129060:	84400044 	addi	r17,r16,1
81129064:	dd400015 	stw	r21,0(sp)
81129068:	1c21883a 	add	r16,r3,r16
8112906c:	b009883a 	mov	r4,r22
81129070:	880f883a 	mov	r7,r17
81129074:	180d883a 	mov	r6,r3
81129078:	a00b883a 	mov	r5,r20
8112907c:	82000005 	stb	r8,0(r16)
81129080:	112c4a40 	call	8112c4a4 <_mbrtowc_r>
81129084:	013fffc4 	movi	r4,-1
81129088:	113c9426 	beq	r2,r4,811282dc <__reset+0xfb1082dc>
8112908c:	103c881e 	bne	r2,zero,811282b0 <__reset+0xfb1082b0>
81129090:	a0000015 	stw	zero,0(r20)
81129094:	0009883a 	mov	r4,zero
81129098:	112c3280 	call	8112c328 <iswspace>
8112909c:	10001a26 	beq	r2,zero,81129108 <__svfscanf_r+0x1724>
811290a0:	8821883a 	mov	r16,r17
811290a4:	dc409f17 	ldw	r17,636(sp)
811290a8:	803f7426 	beq	r16,zero,81128e7c <__reset+0xfb108e7c>
811290ac:	843fffc4 	addi	r16,r16,-1
811290b0:	d9800104 	addi	r6,sp,4
811290b4:	342b883a 	add	r21,r6,r16
811290b8:	00000106 	br	811290c0 <__svfscanf_r+0x16dc>
811290bc:	843fffc4 	addi	r16,r16,-1
811290c0:	a9400003 	ldbu	r5,0(r21)
811290c4:	e00d883a 	mov	r6,fp
811290c8:	b009883a 	mov	r4,r22
811290cc:	11313540 	call	81131354 <_ungetc_r>
811290d0:	ad7fffc4 	addi	r21,r21,-1
811290d4:	803ff91e 	bne	r16,zero,811290bc <__reset+0xfb1090bc>
811290d8:	003f6806 	br	81128e7c <__reset+0xfb108e7c>
811290dc:	d9800104 	addi	r6,sp,4
811290e0:	802b883a 	mov	r21,r16
811290e4:	343a812e 	bgeu	r6,r16,81127aec <__reset+0xfb107aec>
811290e8:	ad7fffc4 	addi	r21,r21,-1
811290ec:	a9400007 	ldb	r5,0(r21)
811290f0:	e00d883a 	mov	r6,fp
811290f4:	b009883a 	mov	r4,r22
811290f8:	11313540 	call	81131354 <_ungetc_r>
811290fc:	da000104 	addi	r8,sp,4
81129100:	457ff91e 	bne	r8,r21,811290e8 <__reset+0xfb1090e8>
81129104:	003a7906 	br	81127aec <__reset+0xfb107aec>
81129108:	da009f17 	ldw	r8,636(sp)
8112910c:	9465883a 	add	r18,r18,r17
81129110:	9cffffc4 	addi	r19,r19,-1
81129114:	4000051e 	bne	r8,zero,8112912c <__svfscanf_r+0x1748>
81129118:	a5000104 	addi	r20,r20,4
8112911c:	0021883a 	mov	r16,zero
81129120:	003c6606 	br	811282bc <__reset+0xfb1082bc>
81129124:	a1000017 	ldw	r4,0(r20)
81129128:	003fdb06 	br	81129098 <__reset+0xfb109098>
8112912c:	0021883a 	mov	r16,zero
81129130:	003c6206 	br	811282bc <__reset+0xfb1082bc>
81129134:	d8800104 	addi	r2,sp,4
81129138:	802b883a 	mov	r21,r16
8112913c:	143a6b2e 	bgeu	r2,r16,81127aec <__reset+0xfb107aec>
81129140:	ad7fffc4 	addi	r21,r21,-1
81129144:	a9400007 	ldb	r5,0(r21)
81129148:	e00d883a 	mov	r6,fp
8112914c:	b009883a 	mov	r4,r22
81129150:	11313540 	call	81131354 <_ungetc_r>
81129154:	d8c00104 	addi	r3,sp,4
81129158:	1d7ff91e 	bne	r3,r21,81129140 <__reset+0xfb109140>
8112915c:	003a6306 	br	81127aec <__reset+0xfb107aec>
81129160:	0009883a 	mov	r4,zero
81129164:	112e09c0 	call	8112e09c <nanf>
81129168:	a0800015 	stw	r2,0(r20)
8112916c:	dc409c15 	stw	r17,624(sp)
81129170:	003dac06 	br	81128824 <__reset+0xfb108824>
81129174:	d9000104 	addi	r4,sp,4
81129178:	802b883a 	mov	r21,r16
8112917c:	243a5b2e 	bgeu	r4,r16,81127aec <__reset+0xfb107aec>
81129180:	ad7fffc4 	addi	r21,r21,-1
81129184:	a9400007 	ldb	r5,0(r21)
81129188:	e00d883a 	mov	r6,fp
8112918c:	b009883a 	mov	r4,r22
81129190:	11313540 	call	81131354 <_ungetc_r>
81129194:	d9400104 	addi	r5,sp,4
81129198:	2d7ff91e 	bne	r5,r21,81129180 <__reset+0xfb109180>
8112919c:	003a5306 	br	81127aec <__reset+0xfb107aec>
811291a0:	112fb7c0 	call	8112fb7c <_strtoull_r>
811291a4:	003f9d06 	br	8112901c <__reset+0xfb10901c>

811291a8 <vfscanf>:
811291a8:	00a04574 	movhi	r2,33045
811291ac:	defffb04 	addi	sp,sp,-20
811291b0:	108bed04 	addi	r2,r2,12212
811291b4:	de00012e 	bgeu	sp,et,811291bc <vfscanf+0x14>
811291b8:	003b68fa 	trap	3
811291bc:	dc000215 	stw	r16,8(sp)
811291c0:	14000017 	ldw	r16,0(r2)
811291c4:	dc400315 	stw	r17,12(sp)
811291c8:	dfc00415 	stw	ra,16(sp)
811291cc:	2023883a 	mov	r17,r4
811291d0:	80000826 	beq	r16,zero,811291f4 <vfscanf+0x4c>
811291d4:	80800e17 	ldw	r2,56(r16)
811291d8:	1000061e 	bne	r2,zero,811291f4 <vfscanf+0x4c>
811291dc:	8009883a 	mov	r4,r16
811291e0:	d9400015 	stw	r5,0(sp)
811291e4:	d9800115 	stw	r6,4(sp)
811291e8:	112b4c00 	call	8112b4c0 <__sinit>
811291ec:	d9800117 	ldw	r6,4(sp)
811291f0:	d9400017 	ldw	r5,0(sp)
811291f4:	300f883a 	mov	r7,r6
811291f8:	8009883a 	mov	r4,r16
811291fc:	280d883a 	mov	r6,r5
81129200:	880b883a 	mov	r5,r17
81129204:	dfc00417 	ldw	ra,16(sp)
81129208:	dc400317 	ldw	r17,12(sp)
8112920c:	dc000217 	ldw	r16,8(sp)
81129210:	dec00504 	addi	sp,sp,20
81129214:	11279e41 	jmpi	811279e4 <__svfscanf_r>

81129218 <__svfscanf>:
81129218:	00a04574 	movhi	r2,33045
8112921c:	108bed04 	addi	r2,r2,12212
81129220:	300f883a 	mov	r7,r6
81129224:	280d883a 	mov	r6,r5
81129228:	200b883a 	mov	r5,r4
8112922c:	11000017 	ldw	r4,0(r2)
81129230:	11279e41 	jmpi	811279e4 <__svfscanf_r>

81129234 <_vfscanf_r>:
81129234:	defffb04 	addi	sp,sp,-20
81129238:	de00012e 	bgeu	sp,et,81129240 <_vfscanf_r+0xc>
8112923c:	003b68fa 	trap	3
81129240:	dc000315 	stw	r16,12(sp)
81129244:	dfc00415 	stw	ra,16(sp)
81129248:	2021883a 	mov	r16,r4
8112924c:	20000926 	beq	r4,zero,81129274 <_vfscanf_r+0x40>
81129250:	20800e17 	ldw	r2,56(r4)
81129254:	1000071e 	bne	r2,zero,81129274 <_vfscanf_r+0x40>
81129258:	d9400015 	stw	r5,0(sp)
8112925c:	d9800115 	stw	r6,4(sp)
81129260:	d9c00215 	stw	r7,8(sp)
81129264:	112b4c00 	call	8112b4c0 <__sinit>
81129268:	d9c00217 	ldw	r7,8(sp)
8112926c:	d9800117 	ldw	r6,4(sp)
81129270:	d9400017 	ldw	r5,0(sp)
81129274:	8009883a 	mov	r4,r16
81129278:	dfc00417 	ldw	ra,16(sp)
8112927c:	dc000317 	ldw	r16,12(sp)
81129280:	dec00504 	addi	sp,sp,20
81129284:	11279e41 	jmpi	811279e4 <__svfscanf_r>

81129288 <__swbuf_r>:
81129288:	defffb04 	addi	sp,sp,-20
8112928c:	de00012e 	bgeu	sp,et,81129294 <__swbuf_r+0xc>
81129290:	003b68fa 	trap	3
81129294:	dcc00315 	stw	r19,12(sp)
81129298:	dc800215 	stw	r18,8(sp)
8112929c:	dc000015 	stw	r16,0(sp)
811292a0:	dfc00415 	stw	ra,16(sp)
811292a4:	dc400115 	stw	r17,4(sp)
811292a8:	2025883a 	mov	r18,r4
811292ac:	2827883a 	mov	r19,r5
811292b0:	3021883a 	mov	r16,r6
811292b4:	20000226 	beq	r4,zero,811292c0 <__swbuf_r+0x38>
811292b8:	20800e17 	ldw	r2,56(r4)
811292bc:	10004226 	beq	r2,zero,811293c8 <__swbuf_r+0x140>
811292c0:	80800617 	ldw	r2,24(r16)
811292c4:	8100030b 	ldhu	r4,12(r16)
811292c8:	80800215 	stw	r2,8(r16)
811292cc:	2080020c 	andi	r2,r4,8
811292d0:	10003626 	beq	r2,zero,811293ac <__swbuf_r+0x124>
811292d4:	80c00417 	ldw	r3,16(r16)
811292d8:	18003426 	beq	r3,zero,811293ac <__swbuf_r+0x124>
811292dc:	2088000c 	andi	r2,r4,8192
811292e0:	9c403fcc 	andi	r17,r19,255
811292e4:	10001a26 	beq	r2,zero,81129350 <__swbuf_r+0xc8>
811292e8:	80800017 	ldw	r2,0(r16)
811292ec:	81000517 	ldw	r4,20(r16)
811292f0:	10c7c83a 	sub	r3,r2,r3
811292f4:	1900200e 	bge	r3,r4,81129378 <__swbuf_r+0xf0>
811292f8:	18c00044 	addi	r3,r3,1
811292fc:	81000217 	ldw	r4,8(r16)
81129300:	11400044 	addi	r5,r2,1
81129304:	81400015 	stw	r5,0(r16)
81129308:	213fffc4 	addi	r4,r4,-1
8112930c:	81000215 	stw	r4,8(r16)
81129310:	14c00005 	stb	r19,0(r2)
81129314:	80800517 	ldw	r2,20(r16)
81129318:	10c01e26 	beq	r2,r3,81129394 <__swbuf_r+0x10c>
8112931c:	8080030b 	ldhu	r2,12(r16)
81129320:	1080004c 	andi	r2,r2,1
81129324:	10000226 	beq	r2,zero,81129330 <__swbuf_r+0xa8>
81129328:	00800284 	movi	r2,10
8112932c:	88801926 	beq	r17,r2,81129394 <__swbuf_r+0x10c>
81129330:	8805883a 	mov	r2,r17
81129334:	dfc00417 	ldw	ra,16(sp)
81129338:	dcc00317 	ldw	r19,12(sp)
8112933c:	dc800217 	ldw	r18,8(sp)
81129340:	dc400117 	ldw	r17,4(sp)
81129344:	dc000017 	ldw	r16,0(sp)
81129348:	dec00504 	addi	sp,sp,20
8112934c:	f800283a 	ret
81129350:	81401917 	ldw	r5,100(r16)
81129354:	00b7ffc4 	movi	r2,-8193
81129358:	21080014 	ori	r4,r4,8192
8112935c:	2884703a 	and	r2,r5,r2
81129360:	80801915 	stw	r2,100(r16)
81129364:	80800017 	ldw	r2,0(r16)
81129368:	8100030d 	sth	r4,12(r16)
8112936c:	81000517 	ldw	r4,20(r16)
81129370:	10c7c83a 	sub	r3,r2,r3
81129374:	193fe016 	blt	r3,r4,811292f8 <__reset+0xfb1092f8>
81129378:	800b883a 	mov	r5,r16
8112937c:	9009883a 	mov	r4,r18
81129380:	112b0c40 	call	8112b0c4 <_fflush_r>
81129384:	1000071e 	bne	r2,zero,811293a4 <__swbuf_r+0x11c>
81129388:	80800017 	ldw	r2,0(r16)
8112938c:	00c00044 	movi	r3,1
81129390:	003fda06 	br	811292fc <__reset+0xfb1092fc>
81129394:	800b883a 	mov	r5,r16
81129398:	9009883a 	mov	r4,r18
8112939c:	112b0c40 	call	8112b0c4 <_fflush_r>
811293a0:	103fe326 	beq	r2,zero,81129330 <__reset+0xfb109330>
811293a4:	00bfffc4 	movi	r2,-1
811293a8:	003fe206 	br	81129334 <__reset+0xfb109334>
811293ac:	800b883a 	mov	r5,r16
811293b0:	9009883a 	mov	r4,r18
811293b4:	11294500 	call	81129450 <__swsetup_r>
811293b8:	103ffa1e 	bne	r2,zero,811293a4 <__reset+0xfb1093a4>
811293bc:	8100030b 	ldhu	r4,12(r16)
811293c0:	80c00417 	ldw	r3,16(r16)
811293c4:	003fc506 	br	811292dc <__reset+0xfb1092dc>
811293c8:	112b4c00 	call	8112b4c0 <__sinit>
811293cc:	003fbc06 	br	811292c0 <__reset+0xfb1092c0>

811293d0 <__swbuf>:
811293d0:	00a04574 	movhi	r2,33045
811293d4:	108bed04 	addi	r2,r2,12212
811293d8:	280d883a 	mov	r6,r5
811293dc:	200b883a 	mov	r5,r4
811293e0:	11000017 	ldw	r4,0(r2)
811293e4:	11292881 	jmpi	81129288 <__swbuf_r>

811293e8 <_write_r>:
811293e8:	defffd04 	addi	sp,sp,-12
811293ec:	de00012e 	bgeu	sp,et,811293f4 <_write_r+0xc>
811293f0:	003b68fa 	trap	3
811293f4:	2805883a 	mov	r2,r5
811293f8:	dc000015 	stw	r16,0(sp)
811293fc:	04204574 	movhi	r16,33045
81129400:	dc400115 	stw	r17,4(sp)
81129404:	300b883a 	mov	r5,r6
81129408:	840c6004 	addi	r16,r16,12672
8112940c:	2023883a 	mov	r17,r4
81129410:	380d883a 	mov	r6,r7
81129414:	1009883a 	mov	r4,r2
81129418:	dfc00215 	stw	ra,8(sp)
8112941c:	80000015 	stw	zero,0(r16)
81129420:	1137bf80 	call	81137bf8 <write>
81129424:	00ffffc4 	movi	r3,-1
81129428:	10c00526 	beq	r2,r3,81129440 <_write_r+0x58>
8112942c:	dfc00217 	ldw	ra,8(sp)
81129430:	dc400117 	ldw	r17,4(sp)
81129434:	dc000017 	ldw	r16,0(sp)
81129438:	dec00304 	addi	sp,sp,12
8112943c:	f800283a 	ret
81129440:	80c00017 	ldw	r3,0(r16)
81129444:	183ff926 	beq	r3,zero,8112942c <__reset+0xfb10942c>
81129448:	88c00015 	stw	r3,0(r17)
8112944c:	003ff706 	br	8112942c <__reset+0xfb10942c>

81129450 <__swsetup_r>:
81129450:	00a04574 	movhi	r2,33045
81129454:	defffd04 	addi	sp,sp,-12
81129458:	108bed04 	addi	r2,r2,12212
8112945c:	de00012e 	bgeu	sp,et,81129464 <__swsetup_r+0x14>
81129460:	003b68fa 	trap	3
81129464:	dc400115 	stw	r17,4(sp)
81129468:	2023883a 	mov	r17,r4
8112946c:	11000017 	ldw	r4,0(r2)
81129470:	dc000015 	stw	r16,0(sp)
81129474:	dfc00215 	stw	ra,8(sp)
81129478:	2821883a 	mov	r16,r5
8112947c:	20000226 	beq	r4,zero,81129488 <__swsetup_r+0x38>
81129480:	20800e17 	ldw	r2,56(r4)
81129484:	10003126 	beq	r2,zero,8112954c <__swsetup_r+0xfc>
81129488:	8080030b 	ldhu	r2,12(r16)
8112948c:	10c0020c 	andi	r3,r2,8
81129490:	1009883a 	mov	r4,r2
81129494:	18000f26 	beq	r3,zero,811294d4 <__swsetup_r+0x84>
81129498:	80c00417 	ldw	r3,16(r16)
8112949c:	18001526 	beq	r3,zero,811294f4 <__swsetup_r+0xa4>
811294a0:	1100004c 	andi	r4,r2,1
811294a4:	20001c1e 	bne	r4,zero,81129518 <__swsetup_r+0xc8>
811294a8:	1080008c 	andi	r2,r2,2
811294ac:	1000291e 	bne	r2,zero,81129554 <__swsetup_r+0x104>
811294b0:	80800517 	ldw	r2,20(r16)
811294b4:	80800215 	stw	r2,8(r16)
811294b8:	18001c26 	beq	r3,zero,8112952c <__swsetup_r+0xdc>
811294bc:	0005883a 	mov	r2,zero
811294c0:	dfc00217 	ldw	ra,8(sp)
811294c4:	dc400117 	ldw	r17,4(sp)
811294c8:	dc000017 	ldw	r16,0(sp)
811294cc:	dec00304 	addi	sp,sp,12
811294d0:	f800283a 	ret
811294d4:	2080040c 	andi	r2,r4,16
811294d8:	10002e26 	beq	r2,zero,81129594 <__swsetup_r+0x144>
811294dc:	2080010c 	andi	r2,r4,4
811294e0:	10001e1e 	bne	r2,zero,8112955c <__swsetup_r+0x10c>
811294e4:	80c00417 	ldw	r3,16(r16)
811294e8:	20800214 	ori	r2,r4,8
811294ec:	8080030d 	sth	r2,12(r16)
811294f0:	183feb1e 	bne	r3,zero,811294a0 <__reset+0xfb1094a0>
811294f4:	1100a00c 	andi	r4,r2,640
811294f8:	01408004 	movi	r5,512
811294fc:	217fe826 	beq	r4,r5,811294a0 <__reset+0xfb1094a0>
81129500:	800b883a 	mov	r5,r16
81129504:	8809883a 	mov	r4,r17
81129508:	1121a1c0 	call	81121a1c <__smakebuf_r>
8112950c:	8080030b 	ldhu	r2,12(r16)
81129510:	80c00417 	ldw	r3,16(r16)
81129514:	003fe206 	br	811294a0 <__reset+0xfb1094a0>
81129518:	80800517 	ldw	r2,20(r16)
8112951c:	80000215 	stw	zero,8(r16)
81129520:	0085c83a 	sub	r2,zero,r2
81129524:	80800615 	stw	r2,24(r16)
81129528:	183fe41e 	bne	r3,zero,811294bc <__reset+0xfb1094bc>
8112952c:	80c0030b 	ldhu	r3,12(r16)
81129530:	0005883a 	mov	r2,zero
81129534:	1900200c 	andi	r4,r3,128
81129538:	203fe126 	beq	r4,zero,811294c0 <__reset+0xfb1094c0>
8112953c:	18c01014 	ori	r3,r3,64
81129540:	80c0030d 	sth	r3,12(r16)
81129544:	00bfffc4 	movi	r2,-1
81129548:	003fdd06 	br	811294c0 <__reset+0xfb1094c0>
8112954c:	112b4c00 	call	8112b4c0 <__sinit>
81129550:	003fcd06 	br	81129488 <__reset+0xfb109488>
81129554:	0005883a 	mov	r2,zero
81129558:	003fd606 	br	811294b4 <__reset+0xfb1094b4>
8112955c:	81400c17 	ldw	r5,48(r16)
81129560:	28000626 	beq	r5,zero,8112957c <__swsetup_r+0x12c>
81129564:	80801004 	addi	r2,r16,64
81129568:	28800326 	beq	r5,r2,81129578 <__swsetup_r+0x128>
8112956c:	8809883a 	mov	r4,r17
81129570:	112b9580 	call	8112b958 <_free_r>
81129574:	8100030b 	ldhu	r4,12(r16)
81129578:	80000c15 	stw	zero,48(r16)
8112957c:	80c00417 	ldw	r3,16(r16)
81129580:	00bff6c4 	movi	r2,-37
81129584:	1108703a 	and	r4,r2,r4
81129588:	80000115 	stw	zero,4(r16)
8112958c:	80c00015 	stw	r3,0(r16)
81129590:	003fd506 	br	811294e8 <__reset+0xfb1094e8>
81129594:	00800244 	movi	r2,9
81129598:	88800015 	stw	r2,0(r17)
8112959c:	20801014 	ori	r2,r4,64
811295a0:	8080030d 	sth	r2,12(r16)
811295a4:	00bfffc4 	movi	r2,-1
811295a8:	003fc506 	br	811294c0 <__reset+0xfb1094c0>

811295ac <_close_r>:
811295ac:	defffd04 	addi	sp,sp,-12
811295b0:	de00012e 	bgeu	sp,et,811295b8 <_close_r+0xc>
811295b4:	003b68fa 	trap	3
811295b8:	dc000015 	stw	r16,0(sp)
811295bc:	04204574 	movhi	r16,33045
811295c0:	dc400115 	stw	r17,4(sp)
811295c4:	840c6004 	addi	r16,r16,12672
811295c8:	2023883a 	mov	r17,r4
811295cc:	2809883a 	mov	r4,r5
811295d0:	dfc00215 	stw	ra,8(sp)
811295d4:	80000015 	stw	zero,0(r16)
811295d8:	11361780 	call	81136178 <close>
811295dc:	00ffffc4 	movi	r3,-1
811295e0:	10c00526 	beq	r2,r3,811295f8 <_close_r+0x4c>
811295e4:	dfc00217 	ldw	ra,8(sp)
811295e8:	dc400117 	ldw	r17,4(sp)
811295ec:	dc000017 	ldw	r16,0(sp)
811295f0:	dec00304 	addi	sp,sp,12
811295f4:	f800283a 	ret
811295f8:	80c00017 	ldw	r3,0(r16)
811295fc:	183ff926 	beq	r3,zero,811295e4 <__reset+0xfb1095e4>
81129600:	88c00015 	stw	r3,0(r17)
81129604:	003ff706 	br	811295e4 <__reset+0xfb1095e4>

81129608 <quorem>:
81129608:	defff704 	addi	sp,sp,-36
8112960c:	de00012e 	bgeu	sp,et,81129614 <quorem+0xc>
81129610:	003b68fa 	trap	3
81129614:	dc800215 	stw	r18,8(sp)
81129618:	20800417 	ldw	r2,16(r4)
8112961c:	2c800417 	ldw	r18,16(r5)
81129620:	dfc00815 	stw	ra,32(sp)
81129624:	ddc00715 	stw	r23,28(sp)
81129628:	dd800615 	stw	r22,24(sp)
8112962c:	dd400515 	stw	r21,20(sp)
81129630:	dd000415 	stw	r20,16(sp)
81129634:	dcc00315 	stw	r19,12(sp)
81129638:	dc400115 	stw	r17,4(sp)
8112963c:	dc000015 	stw	r16,0(sp)
81129640:	14807116 	blt	r2,r18,81129808 <quorem+0x200>
81129644:	94bfffc4 	addi	r18,r18,-1
81129648:	94ad883a 	add	r22,r18,r18
8112964c:	b5ad883a 	add	r22,r22,r22
81129650:	2c400504 	addi	r17,r5,20
81129654:	8da9883a 	add	r20,r17,r22
81129658:	25400504 	addi	r21,r4,20
8112965c:	282f883a 	mov	r23,r5
81129660:	adad883a 	add	r22,r21,r22
81129664:	a1400017 	ldw	r5,0(r20)
81129668:	2021883a 	mov	r16,r4
8112966c:	b1000017 	ldw	r4,0(r22)
81129670:	29400044 	addi	r5,r5,1
81129674:	113497c0 	call	8113497c <__udivsi3>
81129678:	1027883a 	mov	r19,r2
8112967c:	10002c26 	beq	r2,zero,81129730 <quorem+0x128>
81129680:	a813883a 	mov	r9,r21
81129684:	880b883a 	mov	r5,r17
81129688:	0009883a 	mov	r4,zero
8112968c:	000d883a 	mov	r6,zero
81129690:	2a000017 	ldw	r8,0(r5)
81129694:	49c00017 	ldw	r7,0(r9)
81129698:	29400104 	addi	r5,r5,4
8112969c:	40bfffcc 	andi	r2,r8,65535
811296a0:	14c5383a 	mul	r2,r2,r19
811296a4:	4010d43a 	srli	r8,r8,16
811296a8:	38ffffcc 	andi	r3,r7,65535
811296ac:	1105883a 	add	r2,r2,r4
811296b0:	1008d43a 	srli	r4,r2,16
811296b4:	44d1383a 	mul	r8,r8,r19
811296b8:	198d883a 	add	r6,r3,r6
811296bc:	10ffffcc 	andi	r3,r2,65535
811296c0:	30c7c83a 	sub	r3,r6,r3
811296c4:	380ed43a 	srli	r7,r7,16
811296c8:	4105883a 	add	r2,r8,r4
811296cc:	180dd43a 	srai	r6,r3,16
811296d0:	113fffcc 	andi	r4,r2,65535
811296d4:	390fc83a 	sub	r7,r7,r4
811296d8:	398d883a 	add	r6,r7,r6
811296dc:	300e943a 	slli	r7,r6,16
811296e0:	18ffffcc 	andi	r3,r3,65535
811296e4:	1008d43a 	srli	r4,r2,16
811296e8:	38ceb03a 	or	r7,r7,r3
811296ec:	49c00015 	stw	r7,0(r9)
811296f0:	300dd43a 	srai	r6,r6,16
811296f4:	4a400104 	addi	r9,r9,4
811296f8:	a17fe52e 	bgeu	r20,r5,81129690 <__reset+0xfb109690>
811296fc:	b0800017 	ldw	r2,0(r22)
81129700:	10000b1e 	bne	r2,zero,81129730 <quorem+0x128>
81129704:	b0bfff04 	addi	r2,r22,-4
81129708:	a880082e 	bgeu	r21,r2,8112972c <quorem+0x124>
8112970c:	b0ffff17 	ldw	r3,-4(r22)
81129710:	18000326 	beq	r3,zero,81129720 <quorem+0x118>
81129714:	00000506 	br	8112972c <quorem+0x124>
81129718:	10c00017 	ldw	r3,0(r2)
8112971c:	1800031e 	bne	r3,zero,8112972c <quorem+0x124>
81129720:	10bfff04 	addi	r2,r2,-4
81129724:	94bfffc4 	addi	r18,r18,-1
81129728:	a8bffb36 	bltu	r21,r2,81129718 <__reset+0xfb109718>
8112972c:	84800415 	stw	r18,16(r16)
81129730:	b80b883a 	mov	r5,r23
81129734:	8009883a 	mov	r4,r16
81129738:	112d2280 	call	8112d228 <__mcmp>
8112973c:	10002616 	blt	r2,zero,811297d8 <quorem+0x1d0>
81129740:	9cc00044 	addi	r19,r19,1
81129744:	a805883a 	mov	r2,r21
81129748:	000b883a 	mov	r5,zero
8112974c:	11000017 	ldw	r4,0(r2)
81129750:	89800017 	ldw	r6,0(r17)
81129754:	10800104 	addi	r2,r2,4
81129758:	20ffffcc 	andi	r3,r4,65535
8112975c:	194b883a 	add	r5,r3,r5
81129760:	30ffffcc 	andi	r3,r6,65535
81129764:	28c7c83a 	sub	r3,r5,r3
81129768:	300cd43a 	srli	r6,r6,16
8112976c:	2008d43a 	srli	r4,r4,16
81129770:	180bd43a 	srai	r5,r3,16
81129774:	18ffffcc 	andi	r3,r3,65535
81129778:	2189c83a 	sub	r4,r4,r6
8112977c:	2149883a 	add	r4,r4,r5
81129780:	200c943a 	slli	r6,r4,16
81129784:	8c400104 	addi	r17,r17,4
81129788:	200bd43a 	srai	r5,r4,16
8112978c:	30c6b03a 	or	r3,r6,r3
81129790:	10ffff15 	stw	r3,-4(r2)
81129794:	a47fed2e 	bgeu	r20,r17,8112974c <__reset+0xfb10974c>
81129798:	9485883a 	add	r2,r18,r18
8112979c:	1085883a 	add	r2,r2,r2
811297a0:	a887883a 	add	r3,r21,r2
811297a4:	18800017 	ldw	r2,0(r3)
811297a8:	10000b1e 	bne	r2,zero,811297d8 <quorem+0x1d0>
811297ac:	18bfff04 	addi	r2,r3,-4
811297b0:	a880082e 	bgeu	r21,r2,811297d4 <quorem+0x1cc>
811297b4:	18ffff17 	ldw	r3,-4(r3)
811297b8:	18000326 	beq	r3,zero,811297c8 <quorem+0x1c0>
811297bc:	00000506 	br	811297d4 <quorem+0x1cc>
811297c0:	10c00017 	ldw	r3,0(r2)
811297c4:	1800031e 	bne	r3,zero,811297d4 <quorem+0x1cc>
811297c8:	10bfff04 	addi	r2,r2,-4
811297cc:	94bfffc4 	addi	r18,r18,-1
811297d0:	a8bffb36 	bltu	r21,r2,811297c0 <__reset+0xfb1097c0>
811297d4:	84800415 	stw	r18,16(r16)
811297d8:	9805883a 	mov	r2,r19
811297dc:	dfc00817 	ldw	ra,32(sp)
811297e0:	ddc00717 	ldw	r23,28(sp)
811297e4:	dd800617 	ldw	r22,24(sp)
811297e8:	dd400517 	ldw	r21,20(sp)
811297ec:	dd000417 	ldw	r20,16(sp)
811297f0:	dcc00317 	ldw	r19,12(sp)
811297f4:	dc800217 	ldw	r18,8(sp)
811297f8:	dc400117 	ldw	r17,4(sp)
811297fc:	dc000017 	ldw	r16,0(sp)
81129800:	dec00904 	addi	sp,sp,36
81129804:	f800283a 	ret
81129808:	0005883a 	mov	r2,zero
8112980c:	003ff306 	br	811297dc <__reset+0xfb1097dc>

81129810 <_dtoa_r>:
81129810:	deffde04 	addi	sp,sp,-136
81129814:	de00012e 	bgeu	sp,et,8112981c <_dtoa_r+0xc>
81129818:	003b68fa 	trap	3
8112981c:	20801017 	ldw	r2,64(r4)
81129820:	df002015 	stw	fp,128(sp)
81129824:	dcc01b15 	stw	r19,108(sp)
81129828:	dc801a15 	stw	r18,104(sp)
8112982c:	dc401915 	stw	r17,100(sp)
81129830:	dc001815 	stw	r16,96(sp)
81129834:	dfc02115 	stw	ra,132(sp)
81129838:	ddc01f15 	stw	r23,124(sp)
8112983c:	dd801e15 	stw	r22,120(sp)
81129840:	dd401d15 	stw	r21,116(sp)
81129844:	dd001c15 	stw	r20,112(sp)
81129848:	d9c00315 	stw	r7,12(sp)
8112984c:	2039883a 	mov	fp,r4
81129850:	3023883a 	mov	r17,r6
81129854:	2825883a 	mov	r18,r5
81129858:	dc002417 	ldw	r16,144(sp)
8112985c:	3027883a 	mov	r19,r6
81129860:	10000826 	beq	r2,zero,81129884 <_dtoa_r+0x74>
81129864:	21801117 	ldw	r6,68(r4)
81129868:	00c00044 	movi	r3,1
8112986c:	100b883a 	mov	r5,r2
81129870:	1986983a 	sll	r3,r3,r6
81129874:	11800115 	stw	r6,4(r2)
81129878:	10c00215 	stw	r3,8(r2)
8112987c:	112c9d80 	call	8112c9d8 <_Bfree>
81129880:	e0001015 	stw	zero,64(fp)
81129884:	88002e16 	blt	r17,zero,81129940 <_dtoa_r+0x130>
81129888:	80000015 	stw	zero,0(r16)
8112988c:	889ffc2c 	andhi	r2,r17,32752
81129890:	00dffc34 	movhi	r3,32752
81129894:	10c01c26 	beq	r2,r3,81129908 <_dtoa_r+0xf8>
81129898:	000d883a 	mov	r6,zero
8112989c:	000f883a 	mov	r7,zero
811298a0:	9009883a 	mov	r4,r18
811298a4:	980b883a 	mov	r5,r19
811298a8:	1135dd80 	call	81135dd8 <__eqdf2>
811298ac:	10002b1e 	bne	r2,zero,8112995c <_dtoa_r+0x14c>
811298b0:	d9c02317 	ldw	r7,140(sp)
811298b4:	00800044 	movi	r2,1
811298b8:	38800015 	stw	r2,0(r7)
811298bc:	d8802517 	ldw	r2,148(sp)
811298c0:	10019e26 	beq	r2,zero,81129f3c <_dtoa_r+0x72c>
811298c4:	d8c02517 	ldw	r3,148(sp)
811298c8:	00a04574 	movhi	r2,33045
811298cc:	10822544 	addi	r2,r2,2197
811298d0:	18800015 	stw	r2,0(r3)
811298d4:	10bfffc4 	addi	r2,r2,-1
811298d8:	dfc02117 	ldw	ra,132(sp)
811298dc:	df002017 	ldw	fp,128(sp)
811298e0:	ddc01f17 	ldw	r23,124(sp)
811298e4:	dd801e17 	ldw	r22,120(sp)
811298e8:	dd401d17 	ldw	r21,116(sp)
811298ec:	dd001c17 	ldw	r20,112(sp)
811298f0:	dcc01b17 	ldw	r19,108(sp)
811298f4:	dc801a17 	ldw	r18,104(sp)
811298f8:	dc401917 	ldw	r17,100(sp)
811298fc:	dc001817 	ldw	r16,96(sp)
81129900:	dec02204 	addi	sp,sp,136
81129904:	f800283a 	ret
81129908:	d8c02317 	ldw	r3,140(sp)
8112990c:	0089c3c4 	movi	r2,9999
81129910:	18800015 	stw	r2,0(r3)
81129914:	90017726 	beq	r18,zero,81129ef4 <_dtoa_r+0x6e4>
81129918:	00a04574 	movhi	r2,33045
8112991c:	10824304 	addi	r2,r2,2316
81129920:	d9002517 	ldw	r4,148(sp)
81129924:	203fec26 	beq	r4,zero,811298d8 <__reset+0xfb1098d8>
81129928:	10c000c7 	ldb	r3,3(r2)
8112992c:	1801781e 	bne	r3,zero,81129f10 <_dtoa_r+0x700>
81129930:	10c000c4 	addi	r3,r2,3
81129934:	d9802517 	ldw	r6,148(sp)
81129938:	30c00015 	stw	r3,0(r6)
8112993c:	003fe606 	br	811298d8 <__reset+0xfb1098d8>
81129940:	04e00034 	movhi	r19,32768
81129944:	9cffffc4 	addi	r19,r19,-1
81129948:	00800044 	movi	r2,1
8112994c:	8ce6703a 	and	r19,r17,r19
81129950:	80800015 	stw	r2,0(r16)
81129954:	9823883a 	mov	r17,r19
81129958:	003fcc06 	br	8112988c <__reset+0xfb10988c>
8112995c:	d8800204 	addi	r2,sp,8
81129960:	d8800015 	stw	r2,0(sp)
81129964:	d9c00104 	addi	r7,sp,4
81129968:	900b883a 	mov	r5,r18
8112996c:	980d883a 	mov	r6,r19
81129970:	e009883a 	mov	r4,fp
81129974:	8820d53a 	srli	r16,r17,20
81129978:	112d6040 	call	8112d604 <__d2b>
8112997c:	d8800915 	stw	r2,36(sp)
81129980:	8001651e 	bne	r16,zero,81129f18 <_dtoa_r+0x708>
81129984:	dd800217 	ldw	r22,8(sp)
81129988:	dc000117 	ldw	r16,4(sp)
8112998c:	00800804 	movi	r2,32
81129990:	b421883a 	add	r16,r22,r16
81129994:	80c10c84 	addi	r3,r16,1074
81129998:	10c2d10e 	bge	r2,r3,8112a4e0 <_dtoa_r+0xcd0>
8112999c:	00801004 	movi	r2,64
811299a0:	81010484 	addi	r4,r16,1042
811299a4:	10c7c83a 	sub	r3,r2,r3
811299a8:	9108d83a 	srl	r4,r18,r4
811299ac:	88e2983a 	sll	r17,r17,r3
811299b0:	2448b03a 	or	r4,r4,r17
811299b4:	1135f540 	call	81135f54 <__floatunsidf>
811299b8:	017f8434 	movhi	r5,65040
811299bc:	01800044 	movi	r6,1
811299c0:	1009883a 	mov	r4,r2
811299c4:	194b883a 	add	r5,r3,r5
811299c8:	843fffc4 	addi	r16,r16,-1
811299cc:	d9801115 	stw	r6,68(sp)
811299d0:	000d883a 	mov	r6,zero
811299d4:	01cffe34 	movhi	r7,16376
811299d8:	11204440 	call	81120444 <__subdf3>
811299dc:	0198dbf4 	movhi	r6,25455
811299e0:	01cff4f4 	movhi	r7,16339
811299e4:	3190d844 	addi	r6,r6,17249
811299e8:	39e1e9c4 	addi	r7,r7,-30809
811299ec:	1009883a 	mov	r4,r2
811299f0:	180b883a 	mov	r5,r3
811299f4:	111fd240 	call	8111fd24 <__muldf3>
811299f8:	01a2d874 	movhi	r6,35681
811299fc:	01cff1f4 	movhi	r7,16327
81129a00:	31b22cc4 	addi	r6,r6,-14157
81129a04:	39e28a04 	addi	r7,r7,-30168
81129a08:	180b883a 	mov	r5,r3
81129a0c:	1009883a 	mov	r4,r2
81129a10:	1134c340 	call	81134c34 <__adddf3>
81129a14:	8009883a 	mov	r4,r16
81129a18:	1029883a 	mov	r20,r2
81129a1c:	1823883a 	mov	r17,r3
81129a20:	1120dc80 	call	81120dc8 <__floatsidf>
81129a24:	019427f4 	movhi	r6,20639
81129a28:	01cff4f4 	movhi	r7,16339
81129a2c:	319e7ec4 	addi	r6,r6,31227
81129a30:	39d104c4 	addi	r7,r7,17427
81129a34:	1009883a 	mov	r4,r2
81129a38:	180b883a 	mov	r5,r3
81129a3c:	111fd240 	call	8111fd24 <__muldf3>
81129a40:	100d883a 	mov	r6,r2
81129a44:	180f883a 	mov	r7,r3
81129a48:	a009883a 	mov	r4,r20
81129a4c:	880b883a 	mov	r5,r17
81129a50:	1134c340 	call	81134c34 <__adddf3>
81129a54:	1009883a 	mov	r4,r2
81129a58:	180b883a 	mov	r5,r3
81129a5c:	1029883a 	mov	r20,r2
81129a60:	1823883a 	mov	r17,r3
81129a64:	1120d480 	call	81120d48 <__fixdfsi>
81129a68:	000d883a 	mov	r6,zero
81129a6c:	000f883a 	mov	r7,zero
81129a70:	a009883a 	mov	r4,r20
81129a74:	880b883a 	mov	r5,r17
81129a78:	d8800515 	stw	r2,20(sp)
81129a7c:	1135e600 	call	81135e60 <__ledf2>
81129a80:	10028716 	blt	r2,zero,8112a4a0 <_dtoa_r+0xc90>
81129a84:	d8c00517 	ldw	r3,20(sp)
81129a88:	00800584 	movi	r2,22
81129a8c:	10c27536 	bltu	r2,r3,8112a464 <_dtoa_r+0xc54>
81129a90:	180490fa 	slli	r2,r3,3
81129a94:	00e04574 	movhi	r3,33045
81129a98:	18c25e04 	addi	r3,r3,2424
81129a9c:	1885883a 	add	r2,r3,r2
81129aa0:	11000017 	ldw	r4,0(r2)
81129aa4:	11400117 	ldw	r5,4(r2)
81129aa8:	900d883a 	mov	r6,r18
81129aac:	980f883a 	mov	r7,r19
81129ab0:	111fc480 	call	8111fc48 <__gedf2>
81129ab4:	00828d0e 	bge	zero,r2,8112a4ec <_dtoa_r+0xcdc>
81129ab8:	d9000517 	ldw	r4,20(sp)
81129abc:	d8000e15 	stw	zero,56(sp)
81129ac0:	213fffc4 	addi	r4,r4,-1
81129ac4:	d9000515 	stw	r4,20(sp)
81129ac8:	b42dc83a 	sub	r22,r22,r16
81129acc:	b5bfffc4 	addi	r22,r22,-1
81129ad0:	b0026f16 	blt	r22,zero,8112a490 <_dtoa_r+0xc80>
81129ad4:	d8000815 	stw	zero,32(sp)
81129ad8:	d9c00517 	ldw	r7,20(sp)
81129adc:	38026416 	blt	r7,zero,8112a470 <_dtoa_r+0xc60>
81129ae0:	b1ed883a 	add	r22,r22,r7
81129ae4:	d9c00d15 	stw	r7,52(sp)
81129ae8:	d8000a15 	stw	zero,40(sp)
81129aec:	d9800317 	ldw	r6,12(sp)
81129af0:	00800244 	movi	r2,9
81129af4:	11811436 	bltu	r2,r6,81129f48 <_dtoa_r+0x738>
81129af8:	00800144 	movi	r2,5
81129afc:	1184e10e 	bge	r2,r6,8112ae84 <_dtoa_r+0x1674>
81129b00:	31bfff04 	addi	r6,r6,-4
81129b04:	d9800315 	stw	r6,12(sp)
81129b08:	0023883a 	mov	r17,zero
81129b0c:	d9800317 	ldw	r6,12(sp)
81129b10:	008000c4 	movi	r2,3
81129b14:	30836726 	beq	r6,r2,8112a8b4 <_dtoa_r+0x10a4>
81129b18:	1183410e 	bge	r2,r6,8112a820 <_dtoa_r+0x1010>
81129b1c:	d9c00317 	ldw	r7,12(sp)
81129b20:	00800104 	movi	r2,4
81129b24:	38827c26 	beq	r7,r2,8112a518 <_dtoa_r+0xd08>
81129b28:	00800144 	movi	r2,5
81129b2c:	3884c41e 	bne	r7,r2,8112ae40 <_dtoa_r+0x1630>
81129b30:	00800044 	movi	r2,1
81129b34:	d8800b15 	stw	r2,44(sp)
81129b38:	d8c00517 	ldw	r3,20(sp)
81129b3c:	d9002217 	ldw	r4,136(sp)
81129b40:	1907883a 	add	r3,r3,r4
81129b44:	19800044 	addi	r6,r3,1
81129b48:	d8c00c15 	stw	r3,48(sp)
81129b4c:	d9800615 	stw	r6,24(sp)
81129b50:	0183a40e 	bge	zero,r6,8112a9e4 <_dtoa_r+0x11d4>
81129b54:	d9800617 	ldw	r6,24(sp)
81129b58:	3021883a 	mov	r16,r6
81129b5c:	e0001115 	stw	zero,68(fp)
81129b60:	008005c4 	movi	r2,23
81129b64:	1184c92e 	bgeu	r2,r6,8112ae8c <_dtoa_r+0x167c>
81129b68:	00c00044 	movi	r3,1
81129b6c:	00800104 	movi	r2,4
81129b70:	1085883a 	add	r2,r2,r2
81129b74:	11000504 	addi	r4,r2,20
81129b78:	180b883a 	mov	r5,r3
81129b7c:	18c00044 	addi	r3,r3,1
81129b80:	313ffb2e 	bgeu	r6,r4,81129b70 <__reset+0xfb109b70>
81129b84:	e1401115 	stw	r5,68(fp)
81129b88:	e009883a 	mov	r4,fp
81129b8c:	112c9280 	call	8112c928 <_Balloc>
81129b90:	d8800715 	stw	r2,28(sp)
81129b94:	e0801015 	stw	r2,64(fp)
81129b98:	00800384 	movi	r2,14
81129b9c:	1400f736 	bltu	r2,r16,81129f7c <_dtoa_r+0x76c>
81129ba0:	8800f626 	beq	r17,zero,81129f7c <_dtoa_r+0x76c>
81129ba4:	d9c00517 	ldw	r7,20(sp)
81129ba8:	01c39a0e 	bge	zero,r7,8112aa14 <_dtoa_r+0x1204>
81129bac:	388003cc 	andi	r2,r7,15
81129bb0:	100490fa 	slli	r2,r2,3
81129bb4:	382bd13a 	srai	r21,r7,4
81129bb8:	00e04574 	movhi	r3,33045
81129bbc:	18c25e04 	addi	r3,r3,2424
81129bc0:	1885883a 	add	r2,r3,r2
81129bc4:	a8c0040c 	andi	r3,r21,16
81129bc8:	12400017 	ldw	r9,0(r2)
81129bcc:	12000117 	ldw	r8,4(r2)
81129bd0:	18037926 	beq	r3,zero,8112a9b8 <_dtoa_r+0x11a8>
81129bd4:	00a04574 	movhi	r2,33045
81129bd8:	10825404 	addi	r2,r2,2384
81129bdc:	11800817 	ldw	r6,32(r2)
81129be0:	11c00917 	ldw	r7,36(r2)
81129be4:	9009883a 	mov	r4,r18
81129be8:	980b883a 	mov	r5,r19
81129bec:	da001715 	stw	r8,92(sp)
81129bf0:	da401615 	stw	r9,88(sp)
81129bf4:	11354e80 	call	811354e8 <__divdf3>
81129bf8:	da001717 	ldw	r8,92(sp)
81129bfc:	da401617 	ldw	r9,88(sp)
81129c00:	ad4003cc 	andi	r21,r21,15
81129c04:	040000c4 	movi	r16,3
81129c08:	1023883a 	mov	r17,r2
81129c0c:	1829883a 	mov	r20,r3
81129c10:	a8001126 	beq	r21,zero,81129c58 <_dtoa_r+0x448>
81129c14:	05e04574 	movhi	r23,33045
81129c18:	bdc25404 	addi	r23,r23,2384
81129c1c:	4805883a 	mov	r2,r9
81129c20:	4007883a 	mov	r3,r8
81129c24:	a980004c 	andi	r6,r21,1
81129c28:	1009883a 	mov	r4,r2
81129c2c:	a82bd07a 	srai	r21,r21,1
81129c30:	180b883a 	mov	r5,r3
81129c34:	30000426 	beq	r6,zero,81129c48 <_dtoa_r+0x438>
81129c38:	b9800017 	ldw	r6,0(r23)
81129c3c:	b9c00117 	ldw	r7,4(r23)
81129c40:	84000044 	addi	r16,r16,1
81129c44:	111fd240 	call	8111fd24 <__muldf3>
81129c48:	bdc00204 	addi	r23,r23,8
81129c4c:	a83ff51e 	bne	r21,zero,81129c24 <__reset+0xfb109c24>
81129c50:	1013883a 	mov	r9,r2
81129c54:	1811883a 	mov	r8,r3
81129c58:	480d883a 	mov	r6,r9
81129c5c:	400f883a 	mov	r7,r8
81129c60:	8809883a 	mov	r4,r17
81129c64:	a00b883a 	mov	r5,r20
81129c68:	11354e80 	call	811354e8 <__divdf3>
81129c6c:	d8800f15 	stw	r2,60(sp)
81129c70:	d8c01015 	stw	r3,64(sp)
81129c74:	d8c00e17 	ldw	r3,56(sp)
81129c78:	18000626 	beq	r3,zero,81129c94 <_dtoa_r+0x484>
81129c7c:	d9000f17 	ldw	r4,60(sp)
81129c80:	d9401017 	ldw	r5,64(sp)
81129c84:	000d883a 	mov	r6,zero
81129c88:	01cffc34 	movhi	r7,16368
81129c8c:	1135e600 	call	81135e60 <__ledf2>
81129c90:	10040b16 	blt	r2,zero,8112acc0 <_dtoa_r+0x14b0>
81129c94:	8009883a 	mov	r4,r16
81129c98:	1120dc80 	call	81120dc8 <__floatsidf>
81129c9c:	d9800f17 	ldw	r6,60(sp)
81129ca0:	d9c01017 	ldw	r7,64(sp)
81129ca4:	1009883a 	mov	r4,r2
81129ca8:	180b883a 	mov	r5,r3
81129cac:	111fd240 	call	8111fd24 <__muldf3>
81129cb0:	000d883a 	mov	r6,zero
81129cb4:	01d00734 	movhi	r7,16412
81129cb8:	1009883a 	mov	r4,r2
81129cbc:	180b883a 	mov	r5,r3
81129cc0:	1134c340 	call	81134c34 <__adddf3>
81129cc4:	1021883a 	mov	r16,r2
81129cc8:	d8800617 	ldw	r2,24(sp)
81129ccc:	047f3034 	movhi	r17,64704
81129cd0:	1c63883a 	add	r17,r3,r17
81129cd4:	10031826 	beq	r2,zero,8112a938 <_dtoa_r+0x1128>
81129cd8:	d8c00517 	ldw	r3,20(sp)
81129cdc:	db000617 	ldw	r12,24(sp)
81129ce0:	d8c01315 	stw	r3,76(sp)
81129ce4:	d9000b17 	ldw	r4,44(sp)
81129ce8:	20038f26 	beq	r4,zero,8112ab28 <_dtoa_r+0x1318>
81129cec:	60bfffc4 	addi	r2,r12,-1
81129cf0:	100490fa 	slli	r2,r2,3
81129cf4:	00e04574 	movhi	r3,33045
81129cf8:	18c25e04 	addi	r3,r3,2424
81129cfc:	1885883a 	add	r2,r3,r2
81129d00:	11800017 	ldw	r6,0(r2)
81129d04:	11c00117 	ldw	r7,4(r2)
81129d08:	d8800717 	ldw	r2,28(sp)
81129d0c:	0009883a 	mov	r4,zero
81129d10:	014ff834 	movhi	r5,16352
81129d14:	db001615 	stw	r12,88(sp)
81129d18:	15c00044 	addi	r23,r2,1
81129d1c:	11354e80 	call	811354e8 <__divdf3>
81129d20:	800d883a 	mov	r6,r16
81129d24:	880f883a 	mov	r7,r17
81129d28:	1009883a 	mov	r4,r2
81129d2c:	180b883a 	mov	r5,r3
81129d30:	11204440 	call	81120444 <__subdf3>
81129d34:	d9401017 	ldw	r5,64(sp)
81129d38:	d9000f17 	ldw	r4,60(sp)
81129d3c:	102b883a 	mov	r21,r2
81129d40:	d8c01215 	stw	r3,72(sp)
81129d44:	1120d480 	call	81120d48 <__fixdfsi>
81129d48:	1009883a 	mov	r4,r2
81129d4c:	1029883a 	mov	r20,r2
81129d50:	1120dc80 	call	81120dc8 <__floatsidf>
81129d54:	d9000f17 	ldw	r4,60(sp)
81129d58:	d9401017 	ldw	r5,64(sp)
81129d5c:	100d883a 	mov	r6,r2
81129d60:	180f883a 	mov	r7,r3
81129d64:	11204440 	call	81120444 <__subdf3>
81129d68:	1823883a 	mov	r17,r3
81129d6c:	d8c00717 	ldw	r3,28(sp)
81129d70:	d9401217 	ldw	r5,72(sp)
81129d74:	a2000c04 	addi	r8,r20,48
81129d78:	1021883a 	mov	r16,r2
81129d7c:	1a000005 	stb	r8,0(r3)
81129d80:	800d883a 	mov	r6,r16
81129d84:	880f883a 	mov	r7,r17
81129d88:	a809883a 	mov	r4,r21
81129d8c:	4029883a 	mov	r20,r8
81129d90:	111fc480 	call	8111fc48 <__gedf2>
81129d94:	00841d16 	blt	zero,r2,8112ae0c <_dtoa_r+0x15fc>
81129d98:	800d883a 	mov	r6,r16
81129d9c:	880f883a 	mov	r7,r17
81129da0:	0009883a 	mov	r4,zero
81129da4:	014ffc34 	movhi	r5,16368
81129da8:	11204440 	call	81120444 <__subdf3>
81129dac:	d9401217 	ldw	r5,72(sp)
81129db0:	100d883a 	mov	r6,r2
81129db4:	180f883a 	mov	r7,r3
81129db8:	a809883a 	mov	r4,r21
81129dbc:	111fc480 	call	8111fc48 <__gedf2>
81129dc0:	db001617 	ldw	r12,88(sp)
81129dc4:	00840e16 	blt	zero,r2,8112ae00 <_dtoa_r+0x15f0>
81129dc8:	00800044 	movi	r2,1
81129dcc:	13006b0e 	bge	r2,r12,81129f7c <_dtoa_r+0x76c>
81129dd0:	d9000717 	ldw	r4,28(sp)
81129dd4:	dd800f15 	stw	r22,60(sp)
81129dd8:	dcc01015 	stw	r19,64(sp)
81129ddc:	2319883a 	add	r12,r4,r12
81129de0:	dcc01217 	ldw	r19,72(sp)
81129de4:	602d883a 	mov	r22,r12
81129de8:	dc801215 	stw	r18,72(sp)
81129dec:	b825883a 	mov	r18,r23
81129df0:	00000906 	br	81129e18 <_dtoa_r+0x608>
81129df4:	11204440 	call	81120444 <__subdf3>
81129df8:	a80d883a 	mov	r6,r21
81129dfc:	980f883a 	mov	r7,r19
81129e00:	1009883a 	mov	r4,r2
81129e04:	180b883a 	mov	r5,r3
81129e08:	1135e600 	call	81135e60 <__ledf2>
81129e0c:	1003e816 	blt	r2,zero,8112adb0 <_dtoa_r+0x15a0>
81129e10:	b825883a 	mov	r18,r23
81129e14:	bd83e926 	beq	r23,r22,8112adbc <_dtoa_r+0x15ac>
81129e18:	a809883a 	mov	r4,r21
81129e1c:	980b883a 	mov	r5,r19
81129e20:	000d883a 	mov	r6,zero
81129e24:	01d00934 	movhi	r7,16420
81129e28:	111fd240 	call	8111fd24 <__muldf3>
81129e2c:	000d883a 	mov	r6,zero
81129e30:	01d00934 	movhi	r7,16420
81129e34:	8009883a 	mov	r4,r16
81129e38:	880b883a 	mov	r5,r17
81129e3c:	102b883a 	mov	r21,r2
81129e40:	1827883a 	mov	r19,r3
81129e44:	111fd240 	call	8111fd24 <__muldf3>
81129e48:	180b883a 	mov	r5,r3
81129e4c:	1009883a 	mov	r4,r2
81129e50:	1821883a 	mov	r16,r3
81129e54:	1023883a 	mov	r17,r2
81129e58:	1120d480 	call	81120d48 <__fixdfsi>
81129e5c:	1009883a 	mov	r4,r2
81129e60:	1029883a 	mov	r20,r2
81129e64:	1120dc80 	call	81120dc8 <__floatsidf>
81129e68:	8809883a 	mov	r4,r17
81129e6c:	800b883a 	mov	r5,r16
81129e70:	100d883a 	mov	r6,r2
81129e74:	180f883a 	mov	r7,r3
81129e78:	11204440 	call	81120444 <__subdf3>
81129e7c:	a5000c04 	addi	r20,r20,48
81129e80:	a80d883a 	mov	r6,r21
81129e84:	980f883a 	mov	r7,r19
81129e88:	1009883a 	mov	r4,r2
81129e8c:	180b883a 	mov	r5,r3
81129e90:	95000005 	stb	r20,0(r18)
81129e94:	1021883a 	mov	r16,r2
81129e98:	1823883a 	mov	r17,r3
81129e9c:	1135e600 	call	81135e60 <__ledf2>
81129ea0:	bdc00044 	addi	r23,r23,1
81129ea4:	800d883a 	mov	r6,r16
81129ea8:	880f883a 	mov	r7,r17
81129eac:	0009883a 	mov	r4,zero
81129eb0:	014ffc34 	movhi	r5,16368
81129eb4:	103fcf0e 	bge	r2,zero,81129df4 <__reset+0xfb109df4>
81129eb8:	d8c01317 	ldw	r3,76(sp)
81129ebc:	d8c00515 	stw	r3,20(sp)
81129ec0:	d9400917 	ldw	r5,36(sp)
81129ec4:	e009883a 	mov	r4,fp
81129ec8:	112c9d80 	call	8112c9d8 <_Bfree>
81129ecc:	d9000517 	ldw	r4,20(sp)
81129ed0:	d9802317 	ldw	r6,140(sp)
81129ed4:	d9c02517 	ldw	r7,148(sp)
81129ed8:	b8000005 	stb	zero,0(r23)
81129edc:	20800044 	addi	r2,r4,1
81129ee0:	30800015 	stw	r2,0(r6)
81129ee4:	3802aa26 	beq	r7,zero,8112a990 <_dtoa_r+0x1180>
81129ee8:	3dc00015 	stw	r23,0(r7)
81129eec:	d8800717 	ldw	r2,28(sp)
81129ef0:	003e7906 	br	811298d8 <__reset+0xfb1098d8>
81129ef4:	00800434 	movhi	r2,16
81129ef8:	10bfffc4 	addi	r2,r2,-1
81129efc:	88a2703a 	and	r17,r17,r2
81129f00:	883e851e 	bne	r17,zero,81129918 <__reset+0xfb109918>
81129f04:	00a04574 	movhi	r2,33045
81129f08:	10824004 	addi	r2,r2,2304
81129f0c:	003e8406 	br	81129920 <__reset+0xfb109920>
81129f10:	10c00204 	addi	r3,r2,8
81129f14:	003e8706 	br	81129934 <__reset+0xfb109934>
81129f18:	01400434 	movhi	r5,16
81129f1c:	297fffc4 	addi	r5,r5,-1
81129f20:	994a703a 	and	r5,r19,r5
81129f24:	9009883a 	mov	r4,r18
81129f28:	843f0044 	addi	r16,r16,-1023
81129f2c:	294ffc34 	orhi	r5,r5,16368
81129f30:	dd800217 	ldw	r22,8(sp)
81129f34:	d8001115 	stw	zero,68(sp)
81129f38:	003ea506 	br	811299d0 <__reset+0xfb1099d0>
81129f3c:	00a04574 	movhi	r2,33045
81129f40:	10822504 	addi	r2,r2,2196
81129f44:	003e6406 	br	811298d8 <__reset+0xfb1098d8>
81129f48:	e0001115 	stw	zero,68(fp)
81129f4c:	000b883a 	mov	r5,zero
81129f50:	e009883a 	mov	r4,fp
81129f54:	112c9280 	call	8112c928 <_Balloc>
81129f58:	01bfffc4 	movi	r6,-1
81129f5c:	01c00044 	movi	r7,1
81129f60:	d8800715 	stw	r2,28(sp)
81129f64:	d9800c15 	stw	r6,48(sp)
81129f68:	e0801015 	stw	r2,64(fp)
81129f6c:	d8000315 	stw	zero,12(sp)
81129f70:	d9c00b15 	stw	r7,44(sp)
81129f74:	d9800615 	stw	r6,24(sp)
81129f78:	d8002215 	stw	zero,136(sp)
81129f7c:	d8800117 	ldw	r2,4(sp)
81129f80:	10008916 	blt	r2,zero,8112a1a8 <_dtoa_r+0x998>
81129f84:	d9000517 	ldw	r4,20(sp)
81129f88:	00c00384 	movi	r3,14
81129f8c:	19008616 	blt	r3,r4,8112a1a8 <_dtoa_r+0x998>
81129f90:	200490fa 	slli	r2,r4,3
81129f94:	00e04574 	movhi	r3,33045
81129f98:	d9802217 	ldw	r6,136(sp)
81129f9c:	18c25e04 	addi	r3,r3,2424
81129fa0:	1885883a 	add	r2,r3,r2
81129fa4:	14000017 	ldw	r16,0(r2)
81129fa8:	14400117 	ldw	r17,4(r2)
81129fac:	30016316 	blt	r6,zero,8112a53c <_dtoa_r+0xd2c>
81129fb0:	800d883a 	mov	r6,r16
81129fb4:	880f883a 	mov	r7,r17
81129fb8:	9009883a 	mov	r4,r18
81129fbc:	980b883a 	mov	r5,r19
81129fc0:	11354e80 	call	811354e8 <__divdf3>
81129fc4:	180b883a 	mov	r5,r3
81129fc8:	1009883a 	mov	r4,r2
81129fcc:	1120d480 	call	81120d48 <__fixdfsi>
81129fd0:	1009883a 	mov	r4,r2
81129fd4:	102b883a 	mov	r21,r2
81129fd8:	1120dc80 	call	81120dc8 <__floatsidf>
81129fdc:	800d883a 	mov	r6,r16
81129fe0:	880f883a 	mov	r7,r17
81129fe4:	1009883a 	mov	r4,r2
81129fe8:	180b883a 	mov	r5,r3
81129fec:	111fd240 	call	8111fd24 <__muldf3>
81129ff0:	100d883a 	mov	r6,r2
81129ff4:	180f883a 	mov	r7,r3
81129ff8:	9009883a 	mov	r4,r18
81129ffc:	980b883a 	mov	r5,r19
8112a000:	11204440 	call	81120444 <__subdf3>
8112a004:	d9c00717 	ldw	r7,28(sp)
8112a008:	1009883a 	mov	r4,r2
8112a00c:	a8800c04 	addi	r2,r21,48
8112a010:	38800005 	stb	r2,0(r7)
8112a014:	3dc00044 	addi	r23,r7,1
8112a018:	d9c00617 	ldw	r7,24(sp)
8112a01c:	01800044 	movi	r6,1
8112a020:	180b883a 	mov	r5,r3
8112a024:	2005883a 	mov	r2,r4
8112a028:	39803826 	beq	r7,r6,8112a10c <_dtoa_r+0x8fc>
8112a02c:	000d883a 	mov	r6,zero
8112a030:	01d00934 	movhi	r7,16420
8112a034:	111fd240 	call	8111fd24 <__muldf3>
8112a038:	000d883a 	mov	r6,zero
8112a03c:	000f883a 	mov	r7,zero
8112a040:	1009883a 	mov	r4,r2
8112a044:	180b883a 	mov	r5,r3
8112a048:	1025883a 	mov	r18,r2
8112a04c:	1827883a 	mov	r19,r3
8112a050:	1135dd80 	call	81135dd8 <__eqdf2>
8112a054:	103f9a26 	beq	r2,zero,81129ec0 <__reset+0xfb109ec0>
8112a058:	d9c00617 	ldw	r7,24(sp)
8112a05c:	d8c00717 	ldw	r3,28(sp)
8112a060:	b829883a 	mov	r20,r23
8112a064:	38bfffc4 	addi	r2,r7,-1
8112a068:	18ad883a 	add	r22,r3,r2
8112a06c:	00000a06 	br	8112a098 <_dtoa_r+0x888>
8112a070:	111fd240 	call	8111fd24 <__muldf3>
8112a074:	000d883a 	mov	r6,zero
8112a078:	000f883a 	mov	r7,zero
8112a07c:	1009883a 	mov	r4,r2
8112a080:	180b883a 	mov	r5,r3
8112a084:	1025883a 	mov	r18,r2
8112a088:	1827883a 	mov	r19,r3
8112a08c:	b829883a 	mov	r20,r23
8112a090:	1135dd80 	call	81135dd8 <__eqdf2>
8112a094:	103f8a26 	beq	r2,zero,81129ec0 <__reset+0xfb109ec0>
8112a098:	800d883a 	mov	r6,r16
8112a09c:	880f883a 	mov	r7,r17
8112a0a0:	9009883a 	mov	r4,r18
8112a0a4:	980b883a 	mov	r5,r19
8112a0a8:	11354e80 	call	811354e8 <__divdf3>
8112a0ac:	180b883a 	mov	r5,r3
8112a0b0:	1009883a 	mov	r4,r2
8112a0b4:	1120d480 	call	81120d48 <__fixdfsi>
8112a0b8:	1009883a 	mov	r4,r2
8112a0bc:	102b883a 	mov	r21,r2
8112a0c0:	1120dc80 	call	81120dc8 <__floatsidf>
8112a0c4:	800d883a 	mov	r6,r16
8112a0c8:	880f883a 	mov	r7,r17
8112a0cc:	1009883a 	mov	r4,r2
8112a0d0:	180b883a 	mov	r5,r3
8112a0d4:	111fd240 	call	8111fd24 <__muldf3>
8112a0d8:	100d883a 	mov	r6,r2
8112a0dc:	180f883a 	mov	r7,r3
8112a0e0:	9009883a 	mov	r4,r18
8112a0e4:	980b883a 	mov	r5,r19
8112a0e8:	11204440 	call	81120444 <__subdf3>
8112a0ec:	aa000c04 	addi	r8,r21,48
8112a0f0:	a2000005 	stb	r8,0(r20)
8112a0f4:	000d883a 	mov	r6,zero
8112a0f8:	01d00934 	movhi	r7,16420
8112a0fc:	1009883a 	mov	r4,r2
8112a100:	180b883a 	mov	r5,r3
8112a104:	a5c00044 	addi	r23,r20,1
8112a108:	b53fd91e 	bne	r22,r20,8112a070 <__reset+0xfb10a070>
8112a10c:	100d883a 	mov	r6,r2
8112a110:	180f883a 	mov	r7,r3
8112a114:	1009883a 	mov	r4,r2
8112a118:	180b883a 	mov	r5,r3
8112a11c:	1134c340 	call	81134c34 <__adddf3>
8112a120:	100d883a 	mov	r6,r2
8112a124:	180f883a 	mov	r7,r3
8112a128:	8009883a 	mov	r4,r16
8112a12c:	880b883a 	mov	r5,r17
8112a130:	1027883a 	mov	r19,r2
8112a134:	1825883a 	mov	r18,r3
8112a138:	1135e600 	call	81135e60 <__ledf2>
8112a13c:	10000816 	blt	r2,zero,8112a160 <_dtoa_r+0x950>
8112a140:	980d883a 	mov	r6,r19
8112a144:	900f883a 	mov	r7,r18
8112a148:	8009883a 	mov	r4,r16
8112a14c:	880b883a 	mov	r5,r17
8112a150:	1135dd80 	call	81135dd8 <__eqdf2>
8112a154:	103f5a1e 	bne	r2,zero,81129ec0 <__reset+0xfb109ec0>
8112a158:	ad40004c 	andi	r21,r21,1
8112a15c:	a83f5826 	beq	r21,zero,81129ec0 <__reset+0xfb109ec0>
8112a160:	bd3fffc3 	ldbu	r20,-1(r23)
8112a164:	b8bfffc4 	addi	r2,r23,-1
8112a168:	1007883a 	mov	r3,r2
8112a16c:	01400e44 	movi	r5,57
8112a170:	d9800717 	ldw	r6,28(sp)
8112a174:	00000506 	br	8112a18c <_dtoa_r+0x97c>
8112a178:	18ffffc4 	addi	r3,r3,-1
8112a17c:	11824726 	beq	r2,r6,8112aa9c <_dtoa_r+0x128c>
8112a180:	1d000003 	ldbu	r20,0(r3)
8112a184:	102f883a 	mov	r23,r2
8112a188:	10bfffc4 	addi	r2,r2,-1
8112a18c:	a1003fcc 	andi	r4,r20,255
8112a190:	2100201c 	xori	r4,r4,128
8112a194:	213fe004 	addi	r4,r4,-128
8112a198:	217ff726 	beq	r4,r5,8112a178 <__reset+0xfb10a178>
8112a19c:	a2000044 	addi	r8,r20,1
8112a1a0:	12000005 	stb	r8,0(r2)
8112a1a4:	003f4606 	br	81129ec0 <__reset+0xfb109ec0>
8112a1a8:	d9000b17 	ldw	r4,44(sp)
8112a1ac:	2000c826 	beq	r4,zero,8112a4d0 <_dtoa_r+0xcc0>
8112a1b0:	d9800317 	ldw	r6,12(sp)
8112a1b4:	00c00044 	movi	r3,1
8112a1b8:	1980f90e 	bge	r3,r6,8112a5a0 <_dtoa_r+0xd90>
8112a1bc:	d8800617 	ldw	r2,24(sp)
8112a1c0:	d8c00a17 	ldw	r3,40(sp)
8112a1c4:	157fffc4 	addi	r21,r2,-1
8112a1c8:	1d41f316 	blt	r3,r21,8112a998 <_dtoa_r+0x1188>
8112a1cc:	1d6bc83a 	sub	r21,r3,r21
8112a1d0:	d9c00617 	ldw	r7,24(sp)
8112a1d4:	3802aa16 	blt	r7,zero,8112ac80 <_dtoa_r+0x1470>
8112a1d8:	dd000817 	ldw	r20,32(sp)
8112a1dc:	d8800617 	ldw	r2,24(sp)
8112a1e0:	d8c00817 	ldw	r3,32(sp)
8112a1e4:	01400044 	movi	r5,1
8112a1e8:	e009883a 	mov	r4,fp
8112a1ec:	1887883a 	add	r3,r3,r2
8112a1f0:	d8c00815 	stw	r3,32(sp)
8112a1f4:	b0ad883a 	add	r22,r22,r2
8112a1f8:	112cd4c0 	call	8112cd4c <__i2b>
8112a1fc:	1023883a 	mov	r17,r2
8112a200:	a0000826 	beq	r20,zero,8112a224 <_dtoa_r+0xa14>
8112a204:	0580070e 	bge	zero,r22,8112a224 <_dtoa_r+0xa14>
8112a208:	a005883a 	mov	r2,r20
8112a20c:	b500b916 	blt	r22,r20,8112a4f4 <_dtoa_r+0xce4>
8112a210:	d9000817 	ldw	r4,32(sp)
8112a214:	a0a9c83a 	sub	r20,r20,r2
8112a218:	b0adc83a 	sub	r22,r22,r2
8112a21c:	2089c83a 	sub	r4,r4,r2
8112a220:	d9000815 	stw	r4,32(sp)
8112a224:	d9800a17 	ldw	r6,40(sp)
8112a228:	0181810e 	bge	zero,r6,8112a830 <_dtoa_r+0x1020>
8112a22c:	d9c00b17 	ldw	r7,44(sp)
8112a230:	3800b326 	beq	r7,zero,8112a500 <_dtoa_r+0xcf0>
8112a234:	a800b226 	beq	r21,zero,8112a500 <_dtoa_r+0xcf0>
8112a238:	880b883a 	mov	r5,r17
8112a23c:	a80d883a 	mov	r6,r21
8112a240:	e009883a 	mov	r4,fp
8112a244:	112cf900 	call	8112cf90 <__pow5mult>
8112a248:	d9800917 	ldw	r6,36(sp)
8112a24c:	100b883a 	mov	r5,r2
8112a250:	e009883a 	mov	r4,fp
8112a254:	1023883a 	mov	r17,r2
8112a258:	112cd900 	call	8112cd90 <__multiply>
8112a25c:	1021883a 	mov	r16,r2
8112a260:	d8800a17 	ldw	r2,40(sp)
8112a264:	d9400917 	ldw	r5,36(sp)
8112a268:	e009883a 	mov	r4,fp
8112a26c:	1545c83a 	sub	r2,r2,r21
8112a270:	d8800a15 	stw	r2,40(sp)
8112a274:	112c9d80 	call	8112c9d8 <_Bfree>
8112a278:	d8c00a17 	ldw	r3,40(sp)
8112a27c:	18009f1e 	bne	r3,zero,8112a4fc <_dtoa_r+0xcec>
8112a280:	05c00044 	movi	r23,1
8112a284:	e009883a 	mov	r4,fp
8112a288:	b80b883a 	mov	r5,r23
8112a28c:	112cd4c0 	call	8112cd4c <__i2b>
8112a290:	d9000d17 	ldw	r4,52(sp)
8112a294:	102b883a 	mov	r21,r2
8112a298:	2000ce26 	beq	r4,zero,8112a5d4 <_dtoa_r+0xdc4>
8112a29c:	200d883a 	mov	r6,r4
8112a2a0:	100b883a 	mov	r5,r2
8112a2a4:	e009883a 	mov	r4,fp
8112a2a8:	112cf900 	call	8112cf90 <__pow5mult>
8112a2ac:	d9800317 	ldw	r6,12(sp)
8112a2b0:	102b883a 	mov	r21,r2
8112a2b4:	b981810e 	bge	r23,r6,8112a8bc <_dtoa_r+0x10ac>
8112a2b8:	0027883a 	mov	r19,zero
8112a2bc:	a8800417 	ldw	r2,16(r21)
8112a2c0:	05c00804 	movi	r23,32
8112a2c4:	10800104 	addi	r2,r2,4
8112a2c8:	1085883a 	add	r2,r2,r2
8112a2cc:	1085883a 	add	r2,r2,r2
8112a2d0:	a885883a 	add	r2,r21,r2
8112a2d4:	11000017 	ldw	r4,0(r2)
8112a2d8:	112cc340 	call	8112cc34 <__hi0bits>
8112a2dc:	b885c83a 	sub	r2,r23,r2
8112a2e0:	1585883a 	add	r2,r2,r22
8112a2e4:	108007cc 	andi	r2,r2,31
8112a2e8:	1000b326 	beq	r2,zero,8112a5b8 <_dtoa_r+0xda8>
8112a2ec:	00c00804 	movi	r3,32
8112a2f0:	1887c83a 	sub	r3,r3,r2
8112a2f4:	01000104 	movi	r4,4
8112a2f8:	20c2cd0e 	bge	r4,r3,8112ae30 <_dtoa_r+0x1620>
8112a2fc:	00c00704 	movi	r3,28
8112a300:	1885c83a 	sub	r2,r3,r2
8112a304:	d8c00817 	ldw	r3,32(sp)
8112a308:	a0a9883a 	add	r20,r20,r2
8112a30c:	b0ad883a 	add	r22,r22,r2
8112a310:	1887883a 	add	r3,r3,r2
8112a314:	d8c00815 	stw	r3,32(sp)
8112a318:	d9800817 	ldw	r6,32(sp)
8112a31c:	0180040e 	bge	zero,r6,8112a330 <_dtoa_r+0xb20>
8112a320:	800b883a 	mov	r5,r16
8112a324:	e009883a 	mov	r4,fp
8112a328:	112d0d80 	call	8112d0d8 <__lshift>
8112a32c:	1021883a 	mov	r16,r2
8112a330:	0580050e 	bge	zero,r22,8112a348 <_dtoa_r+0xb38>
8112a334:	a80b883a 	mov	r5,r21
8112a338:	b00d883a 	mov	r6,r22
8112a33c:	e009883a 	mov	r4,fp
8112a340:	112d0d80 	call	8112d0d8 <__lshift>
8112a344:	102b883a 	mov	r21,r2
8112a348:	d9c00e17 	ldw	r7,56(sp)
8112a34c:	3801211e 	bne	r7,zero,8112a7d4 <_dtoa_r+0xfc4>
8112a350:	d9800617 	ldw	r6,24(sp)
8112a354:	0181380e 	bge	zero,r6,8112a838 <_dtoa_r+0x1028>
8112a358:	d8c00b17 	ldw	r3,44(sp)
8112a35c:	1800ab1e 	bne	r3,zero,8112a60c <_dtoa_r+0xdfc>
8112a360:	dc800717 	ldw	r18,28(sp)
8112a364:	dcc00617 	ldw	r19,24(sp)
8112a368:	9029883a 	mov	r20,r18
8112a36c:	00000206 	br	8112a378 <_dtoa_r+0xb68>
8112a370:	112ca000 	call	8112ca00 <__multadd>
8112a374:	1021883a 	mov	r16,r2
8112a378:	a80b883a 	mov	r5,r21
8112a37c:	8009883a 	mov	r4,r16
8112a380:	11296080 	call	81129608 <quorem>
8112a384:	10800c04 	addi	r2,r2,48
8112a388:	90800005 	stb	r2,0(r18)
8112a38c:	94800044 	addi	r18,r18,1
8112a390:	9507c83a 	sub	r3,r18,r20
8112a394:	000f883a 	mov	r7,zero
8112a398:	01800284 	movi	r6,10
8112a39c:	800b883a 	mov	r5,r16
8112a3a0:	e009883a 	mov	r4,fp
8112a3a4:	1cfff216 	blt	r3,r19,8112a370 <__reset+0xfb10a370>
8112a3a8:	1011883a 	mov	r8,r2
8112a3ac:	d8800617 	ldw	r2,24(sp)
8112a3b0:	0082370e 	bge	zero,r2,8112ac90 <_dtoa_r+0x1480>
8112a3b4:	d9000717 	ldw	r4,28(sp)
8112a3b8:	0025883a 	mov	r18,zero
8112a3bc:	20af883a 	add	r23,r4,r2
8112a3c0:	01800044 	movi	r6,1
8112a3c4:	800b883a 	mov	r5,r16
8112a3c8:	e009883a 	mov	r4,fp
8112a3cc:	da001715 	stw	r8,92(sp)
8112a3d0:	112d0d80 	call	8112d0d8 <__lshift>
8112a3d4:	a80b883a 	mov	r5,r21
8112a3d8:	1009883a 	mov	r4,r2
8112a3dc:	d8800915 	stw	r2,36(sp)
8112a3e0:	112d2280 	call	8112d228 <__mcmp>
8112a3e4:	da001717 	ldw	r8,92(sp)
8112a3e8:	0081800e 	bge	zero,r2,8112a9ec <_dtoa_r+0x11dc>
8112a3ec:	b93fffc3 	ldbu	r4,-1(r23)
8112a3f0:	b8bfffc4 	addi	r2,r23,-1
8112a3f4:	1007883a 	mov	r3,r2
8112a3f8:	01800e44 	movi	r6,57
8112a3fc:	d9c00717 	ldw	r7,28(sp)
8112a400:	00000506 	br	8112a418 <_dtoa_r+0xc08>
8112a404:	18ffffc4 	addi	r3,r3,-1
8112a408:	11c12326 	beq	r2,r7,8112a898 <_dtoa_r+0x1088>
8112a40c:	19000003 	ldbu	r4,0(r3)
8112a410:	102f883a 	mov	r23,r2
8112a414:	10bfffc4 	addi	r2,r2,-1
8112a418:	21403fcc 	andi	r5,r4,255
8112a41c:	2940201c 	xori	r5,r5,128
8112a420:	297fe004 	addi	r5,r5,-128
8112a424:	29bff726 	beq	r5,r6,8112a404 <__reset+0xfb10a404>
8112a428:	21000044 	addi	r4,r4,1
8112a42c:	11000005 	stb	r4,0(r2)
8112a430:	a80b883a 	mov	r5,r21
8112a434:	e009883a 	mov	r4,fp
8112a438:	112c9d80 	call	8112c9d8 <_Bfree>
8112a43c:	883ea026 	beq	r17,zero,81129ec0 <__reset+0xfb109ec0>
8112a440:	90000426 	beq	r18,zero,8112a454 <_dtoa_r+0xc44>
8112a444:	94400326 	beq	r18,r17,8112a454 <_dtoa_r+0xc44>
8112a448:	900b883a 	mov	r5,r18
8112a44c:	e009883a 	mov	r4,fp
8112a450:	112c9d80 	call	8112c9d8 <_Bfree>
8112a454:	880b883a 	mov	r5,r17
8112a458:	e009883a 	mov	r4,fp
8112a45c:	112c9d80 	call	8112c9d8 <_Bfree>
8112a460:	003e9706 	br	81129ec0 <__reset+0xfb109ec0>
8112a464:	01800044 	movi	r6,1
8112a468:	d9800e15 	stw	r6,56(sp)
8112a46c:	003d9606 	br	81129ac8 <__reset+0xfb109ac8>
8112a470:	d8800817 	ldw	r2,32(sp)
8112a474:	d8c00517 	ldw	r3,20(sp)
8112a478:	d8000d15 	stw	zero,52(sp)
8112a47c:	10c5c83a 	sub	r2,r2,r3
8112a480:	00c9c83a 	sub	r4,zero,r3
8112a484:	d8800815 	stw	r2,32(sp)
8112a488:	d9000a15 	stw	r4,40(sp)
8112a48c:	003d9706 	br	81129aec <__reset+0xfb109aec>
8112a490:	05adc83a 	sub	r22,zero,r22
8112a494:	dd800815 	stw	r22,32(sp)
8112a498:	002d883a 	mov	r22,zero
8112a49c:	003d8e06 	br	81129ad8 <__reset+0xfb109ad8>
8112a4a0:	d9000517 	ldw	r4,20(sp)
8112a4a4:	1120dc80 	call	81120dc8 <__floatsidf>
8112a4a8:	100d883a 	mov	r6,r2
8112a4ac:	180f883a 	mov	r7,r3
8112a4b0:	a009883a 	mov	r4,r20
8112a4b4:	880b883a 	mov	r5,r17
8112a4b8:	1135dd80 	call	81135dd8 <__eqdf2>
8112a4bc:	103d7126 	beq	r2,zero,81129a84 <__reset+0xfb109a84>
8112a4c0:	d9c00517 	ldw	r7,20(sp)
8112a4c4:	39ffffc4 	addi	r7,r7,-1
8112a4c8:	d9c00515 	stw	r7,20(sp)
8112a4cc:	003d6d06 	br	81129a84 <__reset+0xfb109a84>
8112a4d0:	dd400a17 	ldw	r21,40(sp)
8112a4d4:	dd000817 	ldw	r20,32(sp)
8112a4d8:	0023883a 	mov	r17,zero
8112a4dc:	003f4806 	br	8112a200 <__reset+0xfb10a200>
8112a4e0:	10e3c83a 	sub	r17,r2,r3
8112a4e4:	9448983a 	sll	r4,r18,r17
8112a4e8:	003d3206 	br	811299b4 <__reset+0xfb1099b4>
8112a4ec:	d8000e15 	stw	zero,56(sp)
8112a4f0:	003d7506 	br	81129ac8 <__reset+0xfb109ac8>
8112a4f4:	b005883a 	mov	r2,r22
8112a4f8:	003f4506 	br	8112a210 <__reset+0xfb10a210>
8112a4fc:	dc000915 	stw	r16,36(sp)
8112a500:	d9800a17 	ldw	r6,40(sp)
8112a504:	d9400917 	ldw	r5,36(sp)
8112a508:	e009883a 	mov	r4,fp
8112a50c:	112cf900 	call	8112cf90 <__pow5mult>
8112a510:	1021883a 	mov	r16,r2
8112a514:	003f5a06 	br	8112a280 <__reset+0xfb10a280>
8112a518:	01c00044 	movi	r7,1
8112a51c:	d9c00b15 	stw	r7,44(sp)
8112a520:	d8802217 	ldw	r2,136(sp)
8112a524:	0081280e 	bge	zero,r2,8112a9c8 <_dtoa_r+0x11b8>
8112a528:	100d883a 	mov	r6,r2
8112a52c:	1021883a 	mov	r16,r2
8112a530:	d8800c15 	stw	r2,48(sp)
8112a534:	d8800615 	stw	r2,24(sp)
8112a538:	003d8806 	br	81129b5c <__reset+0xfb109b5c>
8112a53c:	d8800617 	ldw	r2,24(sp)
8112a540:	00be9b16 	blt	zero,r2,81129fb0 <__reset+0xfb109fb0>
8112a544:	10010f1e 	bne	r2,zero,8112a984 <_dtoa_r+0x1174>
8112a548:	880b883a 	mov	r5,r17
8112a54c:	000d883a 	mov	r6,zero
8112a550:	01d00534 	movhi	r7,16404
8112a554:	8009883a 	mov	r4,r16
8112a558:	111fd240 	call	8111fd24 <__muldf3>
8112a55c:	900d883a 	mov	r6,r18
8112a560:	980f883a 	mov	r7,r19
8112a564:	1009883a 	mov	r4,r2
8112a568:	180b883a 	mov	r5,r3
8112a56c:	111fc480 	call	8111fc48 <__gedf2>
8112a570:	002b883a 	mov	r21,zero
8112a574:	0023883a 	mov	r17,zero
8112a578:	1000bf16 	blt	r2,zero,8112a878 <_dtoa_r+0x1068>
8112a57c:	d9802217 	ldw	r6,136(sp)
8112a580:	ddc00717 	ldw	r23,28(sp)
8112a584:	018c303a 	nor	r6,zero,r6
8112a588:	d9800515 	stw	r6,20(sp)
8112a58c:	a80b883a 	mov	r5,r21
8112a590:	e009883a 	mov	r4,fp
8112a594:	112c9d80 	call	8112c9d8 <_Bfree>
8112a598:	883e4926 	beq	r17,zero,81129ec0 <__reset+0xfb109ec0>
8112a59c:	003fad06 	br	8112a454 <__reset+0xfb10a454>
8112a5a0:	d9c01117 	ldw	r7,68(sp)
8112a5a4:	3801bc26 	beq	r7,zero,8112ac98 <_dtoa_r+0x1488>
8112a5a8:	10810cc4 	addi	r2,r2,1075
8112a5ac:	dd400a17 	ldw	r21,40(sp)
8112a5b0:	dd000817 	ldw	r20,32(sp)
8112a5b4:	003f0a06 	br	8112a1e0 <__reset+0xfb10a1e0>
8112a5b8:	00800704 	movi	r2,28
8112a5bc:	d9000817 	ldw	r4,32(sp)
8112a5c0:	a0a9883a 	add	r20,r20,r2
8112a5c4:	b0ad883a 	add	r22,r22,r2
8112a5c8:	2089883a 	add	r4,r4,r2
8112a5cc:	d9000815 	stw	r4,32(sp)
8112a5d0:	003f5106 	br	8112a318 <__reset+0xfb10a318>
8112a5d4:	d8c00317 	ldw	r3,12(sp)
8112a5d8:	b8c1fc0e 	bge	r23,r3,8112adcc <_dtoa_r+0x15bc>
8112a5dc:	0027883a 	mov	r19,zero
8112a5e0:	b805883a 	mov	r2,r23
8112a5e4:	003f3e06 	br	8112a2e0 <__reset+0xfb10a2e0>
8112a5e8:	880b883a 	mov	r5,r17
8112a5ec:	e009883a 	mov	r4,fp
8112a5f0:	000f883a 	mov	r7,zero
8112a5f4:	01800284 	movi	r6,10
8112a5f8:	112ca000 	call	8112ca00 <__multadd>
8112a5fc:	d9000c17 	ldw	r4,48(sp)
8112a600:	1023883a 	mov	r17,r2
8112a604:	0102040e 	bge	zero,r4,8112ae18 <_dtoa_r+0x1608>
8112a608:	d9000615 	stw	r4,24(sp)
8112a60c:	0500050e 	bge	zero,r20,8112a624 <_dtoa_r+0xe14>
8112a610:	880b883a 	mov	r5,r17
8112a614:	a00d883a 	mov	r6,r20
8112a618:	e009883a 	mov	r4,fp
8112a61c:	112d0d80 	call	8112d0d8 <__lshift>
8112a620:	1023883a 	mov	r17,r2
8112a624:	9801241e 	bne	r19,zero,8112aab8 <_dtoa_r+0x12a8>
8112a628:	8829883a 	mov	r20,r17
8112a62c:	d9000617 	ldw	r4,24(sp)
8112a630:	dcc00717 	ldw	r19,28(sp)
8112a634:	9480004c 	andi	r18,r18,1
8112a638:	20bfffc4 	addi	r2,r4,-1
8112a63c:	9885883a 	add	r2,r19,r2
8112a640:	d8800415 	stw	r2,16(sp)
8112a644:	dc800615 	stw	r18,24(sp)
8112a648:	a80b883a 	mov	r5,r21
8112a64c:	8009883a 	mov	r4,r16
8112a650:	11296080 	call	81129608 <quorem>
8112a654:	880b883a 	mov	r5,r17
8112a658:	8009883a 	mov	r4,r16
8112a65c:	102f883a 	mov	r23,r2
8112a660:	112d2280 	call	8112d228 <__mcmp>
8112a664:	a80b883a 	mov	r5,r21
8112a668:	a00d883a 	mov	r6,r20
8112a66c:	e009883a 	mov	r4,fp
8112a670:	102d883a 	mov	r22,r2
8112a674:	112d2880 	call	8112d288 <__mdiff>
8112a678:	1007883a 	mov	r3,r2
8112a67c:	10800317 	ldw	r2,12(r2)
8112a680:	bc800c04 	addi	r18,r23,48
8112a684:	180b883a 	mov	r5,r3
8112a688:	10004e1e 	bne	r2,zero,8112a7c4 <_dtoa_r+0xfb4>
8112a68c:	8009883a 	mov	r4,r16
8112a690:	d8c01615 	stw	r3,88(sp)
8112a694:	112d2280 	call	8112d228 <__mcmp>
8112a698:	d8c01617 	ldw	r3,88(sp)
8112a69c:	e009883a 	mov	r4,fp
8112a6a0:	d8801615 	stw	r2,88(sp)
8112a6a4:	180b883a 	mov	r5,r3
8112a6a8:	112c9d80 	call	8112c9d8 <_Bfree>
8112a6ac:	d8801617 	ldw	r2,88(sp)
8112a6b0:	1000041e 	bne	r2,zero,8112a6c4 <_dtoa_r+0xeb4>
8112a6b4:	d9800317 	ldw	r6,12(sp)
8112a6b8:	3000021e 	bne	r6,zero,8112a6c4 <_dtoa_r+0xeb4>
8112a6bc:	d8c00617 	ldw	r3,24(sp)
8112a6c0:	18003726 	beq	r3,zero,8112a7a0 <_dtoa_r+0xf90>
8112a6c4:	b0002016 	blt	r22,zero,8112a748 <_dtoa_r+0xf38>
8112a6c8:	b000041e 	bne	r22,zero,8112a6dc <_dtoa_r+0xecc>
8112a6cc:	d9000317 	ldw	r4,12(sp)
8112a6d0:	2000021e 	bne	r4,zero,8112a6dc <_dtoa_r+0xecc>
8112a6d4:	d8c00617 	ldw	r3,24(sp)
8112a6d8:	18001b26 	beq	r3,zero,8112a748 <_dtoa_r+0xf38>
8112a6dc:	00810716 	blt	zero,r2,8112aafc <_dtoa_r+0x12ec>
8112a6e0:	d8c00417 	ldw	r3,16(sp)
8112a6e4:	9d800044 	addi	r22,r19,1
8112a6e8:	9c800005 	stb	r18,0(r19)
8112a6ec:	b02f883a 	mov	r23,r22
8112a6f0:	98c10626 	beq	r19,r3,8112ab0c <_dtoa_r+0x12fc>
8112a6f4:	800b883a 	mov	r5,r16
8112a6f8:	000f883a 	mov	r7,zero
8112a6fc:	01800284 	movi	r6,10
8112a700:	e009883a 	mov	r4,fp
8112a704:	112ca000 	call	8112ca00 <__multadd>
8112a708:	1021883a 	mov	r16,r2
8112a70c:	000f883a 	mov	r7,zero
8112a710:	01800284 	movi	r6,10
8112a714:	880b883a 	mov	r5,r17
8112a718:	e009883a 	mov	r4,fp
8112a71c:	8d002526 	beq	r17,r20,8112a7b4 <_dtoa_r+0xfa4>
8112a720:	112ca000 	call	8112ca00 <__multadd>
8112a724:	a00b883a 	mov	r5,r20
8112a728:	000f883a 	mov	r7,zero
8112a72c:	01800284 	movi	r6,10
8112a730:	e009883a 	mov	r4,fp
8112a734:	1023883a 	mov	r17,r2
8112a738:	112ca000 	call	8112ca00 <__multadd>
8112a73c:	1029883a 	mov	r20,r2
8112a740:	b027883a 	mov	r19,r22
8112a744:	003fc006 	br	8112a648 <__reset+0xfb10a648>
8112a748:	9011883a 	mov	r8,r18
8112a74c:	00800e0e 	bge	zero,r2,8112a788 <_dtoa_r+0xf78>
8112a750:	800b883a 	mov	r5,r16
8112a754:	01800044 	movi	r6,1
8112a758:	e009883a 	mov	r4,fp
8112a75c:	da001715 	stw	r8,92(sp)
8112a760:	112d0d80 	call	8112d0d8 <__lshift>
8112a764:	a80b883a 	mov	r5,r21
8112a768:	1009883a 	mov	r4,r2
8112a76c:	1021883a 	mov	r16,r2
8112a770:	112d2280 	call	8112d228 <__mcmp>
8112a774:	da001717 	ldw	r8,92(sp)
8112a778:	0081960e 	bge	zero,r2,8112add4 <_dtoa_r+0x15c4>
8112a77c:	00800e44 	movi	r2,57
8112a780:	40817026 	beq	r8,r2,8112ad44 <_dtoa_r+0x1534>
8112a784:	ba000c44 	addi	r8,r23,49
8112a788:	8825883a 	mov	r18,r17
8112a78c:	9dc00044 	addi	r23,r19,1
8112a790:	9a000005 	stb	r8,0(r19)
8112a794:	a023883a 	mov	r17,r20
8112a798:	dc000915 	stw	r16,36(sp)
8112a79c:	003f2406 	br	8112a430 <__reset+0xfb10a430>
8112a7a0:	00800e44 	movi	r2,57
8112a7a4:	9011883a 	mov	r8,r18
8112a7a8:	90816626 	beq	r18,r2,8112ad44 <_dtoa_r+0x1534>
8112a7ac:	05bff516 	blt	zero,r22,8112a784 <__reset+0xfb10a784>
8112a7b0:	003ff506 	br	8112a788 <__reset+0xfb10a788>
8112a7b4:	112ca000 	call	8112ca00 <__multadd>
8112a7b8:	1023883a 	mov	r17,r2
8112a7bc:	1029883a 	mov	r20,r2
8112a7c0:	003fdf06 	br	8112a740 <__reset+0xfb10a740>
8112a7c4:	e009883a 	mov	r4,fp
8112a7c8:	112c9d80 	call	8112c9d8 <_Bfree>
8112a7cc:	00800044 	movi	r2,1
8112a7d0:	003fbc06 	br	8112a6c4 <__reset+0xfb10a6c4>
8112a7d4:	a80b883a 	mov	r5,r21
8112a7d8:	8009883a 	mov	r4,r16
8112a7dc:	112d2280 	call	8112d228 <__mcmp>
8112a7e0:	103edb0e 	bge	r2,zero,8112a350 <__reset+0xfb10a350>
8112a7e4:	800b883a 	mov	r5,r16
8112a7e8:	000f883a 	mov	r7,zero
8112a7ec:	01800284 	movi	r6,10
8112a7f0:	e009883a 	mov	r4,fp
8112a7f4:	112ca000 	call	8112ca00 <__multadd>
8112a7f8:	1021883a 	mov	r16,r2
8112a7fc:	d8800517 	ldw	r2,20(sp)
8112a800:	d8c00b17 	ldw	r3,44(sp)
8112a804:	10bfffc4 	addi	r2,r2,-1
8112a808:	d8800515 	stw	r2,20(sp)
8112a80c:	183f761e 	bne	r3,zero,8112a5e8 <__reset+0xfb10a5e8>
8112a810:	d9000c17 	ldw	r4,48(sp)
8112a814:	0101730e 	bge	zero,r4,8112ade4 <_dtoa_r+0x15d4>
8112a818:	d9000615 	stw	r4,24(sp)
8112a81c:	003ed006 	br	8112a360 <__reset+0xfb10a360>
8112a820:	00800084 	movi	r2,2
8112a824:	3081861e 	bne	r6,r2,8112ae40 <_dtoa_r+0x1630>
8112a828:	d8000b15 	stw	zero,44(sp)
8112a82c:	003f3c06 	br	8112a520 <__reset+0xfb10a520>
8112a830:	dc000917 	ldw	r16,36(sp)
8112a834:	003e9206 	br	8112a280 <__reset+0xfb10a280>
8112a838:	d9c00317 	ldw	r7,12(sp)
8112a83c:	00800084 	movi	r2,2
8112a840:	11fec50e 	bge	r2,r7,8112a358 <__reset+0xfb10a358>
8112a844:	d9000617 	ldw	r4,24(sp)
8112a848:	20013c1e 	bne	r4,zero,8112ad3c <_dtoa_r+0x152c>
8112a84c:	a80b883a 	mov	r5,r21
8112a850:	000f883a 	mov	r7,zero
8112a854:	01800144 	movi	r6,5
8112a858:	e009883a 	mov	r4,fp
8112a85c:	112ca000 	call	8112ca00 <__multadd>
8112a860:	100b883a 	mov	r5,r2
8112a864:	8009883a 	mov	r4,r16
8112a868:	102b883a 	mov	r21,r2
8112a86c:	112d2280 	call	8112d228 <__mcmp>
8112a870:	dc000915 	stw	r16,36(sp)
8112a874:	00bf410e 	bge	zero,r2,8112a57c <__reset+0xfb10a57c>
8112a878:	d9c00717 	ldw	r7,28(sp)
8112a87c:	00800c44 	movi	r2,49
8112a880:	38800005 	stb	r2,0(r7)
8112a884:	d8800517 	ldw	r2,20(sp)
8112a888:	3dc00044 	addi	r23,r7,1
8112a88c:	10800044 	addi	r2,r2,1
8112a890:	d8800515 	stw	r2,20(sp)
8112a894:	003f3d06 	br	8112a58c <__reset+0xfb10a58c>
8112a898:	d9800517 	ldw	r6,20(sp)
8112a89c:	d9c00717 	ldw	r7,28(sp)
8112a8a0:	00800c44 	movi	r2,49
8112a8a4:	31800044 	addi	r6,r6,1
8112a8a8:	d9800515 	stw	r6,20(sp)
8112a8ac:	38800005 	stb	r2,0(r7)
8112a8b0:	003edf06 	br	8112a430 <__reset+0xfb10a430>
8112a8b4:	d8000b15 	stw	zero,44(sp)
8112a8b8:	003c9f06 	br	81129b38 <__reset+0xfb109b38>
8112a8bc:	903e7e1e 	bne	r18,zero,8112a2b8 <__reset+0xfb10a2b8>
8112a8c0:	00800434 	movhi	r2,16
8112a8c4:	10bfffc4 	addi	r2,r2,-1
8112a8c8:	9884703a 	and	r2,r19,r2
8112a8cc:	1000ea1e 	bne	r2,zero,8112ac78 <_dtoa_r+0x1468>
8112a8d0:	9cdffc2c 	andhi	r19,r19,32752
8112a8d4:	9800e826 	beq	r19,zero,8112ac78 <_dtoa_r+0x1468>
8112a8d8:	d9c00817 	ldw	r7,32(sp)
8112a8dc:	b5800044 	addi	r22,r22,1
8112a8e0:	04c00044 	movi	r19,1
8112a8e4:	39c00044 	addi	r7,r7,1
8112a8e8:	d9c00815 	stw	r7,32(sp)
8112a8ec:	d8800d17 	ldw	r2,52(sp)
8112a8f0:	103e721e 	bne	r2,zero,8112a2bc <__reset+0xfb10a2bc>
8112a8f4:	00800044 	movi	r2,1
8112a8f8:	003e7906 	br	8112a2e0 <__reset+0xfb10a2e0>
8112a8fc:	8009883a 	mov	r4,r16
8112a900:	1120dc80 	call	81120dc8 <__floatsidf>
8112a904:	d9800f17 	ldw	r6,60(sp)
8112a908:	d9c01017 	ldw	r7,64(sp)
8112a90c:	1009883a 	mov	r4,r2
8112a910:	180b883a 	mov	r5,r3
8112a914:	111fd240 	call	8111fd24 <__muldf3>
8112a918:	000d883a 	mov	r6,zero
8112a91c:	01d00734 	movhi	r7,16412
8112a920:	1009883a 	mov	r4,r2
8112a924:	180b883a 	mov	r5,r3
8112a928:	1134c340 	call	81134c34 <__adddf3>
8112a92c:	047f3034 	movhi	r17,64704
8112a930:	1021883a 	mov	r16,r2
8112a934:	1c63883a 	add	r17,r3,r17
8112a938:	d9000f17 	ldw	r4,60(sp)
8112a93c:	d9401017 	ldw	r5,64(sp)
8112a940:	000d883a 	mov	r6,zero
8112a944:	01d00534 	movhi	r7,16404
8112a948:	11204440 	call	81120444 <__subdf3>
8112a94c:	800d883a 	mov	r6,r16
8112a950:	880f883a 	mov	r7,r17
8112a954:	1009883a 	mov	r4,r2
8112a958:	180b883a 	mov	r5,r3
8112a95c:	102b883a 	mov	r21,r2
8112a960:	1829883a 	mov	r20,r3
8112a964:	111fc480 	call	8111fc48 <__gedf2>
8112a968:	00806c16 	blt	zero,r2,8112ab1c <_dtoa_r+0x130c>
8112a96c:	89e0003c 	xorhi	r7,r17,32768
8112a970:	800d883a 	mov	r6,r16
8112a974:	a809883a 	mov	r4,r21
8112a978:	a00b883a 	mov	r5,r20
8112a97c:	1135e600 	call	81135e60 <__ledf2>
8112a980:	103d7e0e 	bge	r2,zero,81129f7c <__reset+0xfb109f7c>
8112a984:	002b883a 	mov	r21,zero
8112a988:	0023883a 	mov	r17,zero
8112a98c:	003efb06 	br	8112a57c <__reset+0xfb10a57c>
8112a990:	d8800717 	ldw	r2,28(sp)
8112a994:	003bd006 	br	811298d8 <__reset+0xfb1098d8>
8112a998:	d9000a17 	ldw	r4,40(sp)
8112a99c:	d9800d17 	ldw	r6,52(sp)
8112a9a0:	dd400a15 	stw	r21,40(sp)
8112a9a4:	a905c83a 	sub	r2,r21,r4
8112a9a8:	308d883a 	add	r6,r6,r2
8112a9ac:	d9800d15 	stw	r6,52(sp)
8112a9b0:	002b883a 	mov	r21,zero
8112a9b4:	003e0606 	br	8112a1d0 <__reset+0xfb10a1d0>
8112a9b8:	9023883a 	mov	r17,r18
8112a9bc:	9829883a 	mov	r20,r19
8112a9c0:	04000084 	movi	r16,2
8112a9c4:	003c9206 	br	81129c10 <__reset+0xfb109c10>
8112a9c8:	04000044 	movi	r16,1
8112a9cc:	dc000c15 	stw	r16,48(sp)
8112a9d0:	dc000615 	stw	r16,24(sp)
8112a9d4:	dc002215 	stw	r16,136(sp)
8112a9d8:	e0001115 	stw	zero,68(fp)
8112a9dc:	000b883a 	mov	r5,zero
8112a9e0:	003c6906 	br	81129b88 <__reset+0xfb109b88>
8112a9e4:	3021883a 	mov	r16,r6
8112a9e8:	003ffb06 	br	8112a9d8 <__reset+0xfb10a9d8>
8112a9ec:	1000021e 	bne	r2,zero,8112a9f8 <_dtoa_r+0x11e8>
8112a9f0:	4200004c 	andi	r8,r8,1
8112a9f4:	403e7d1e 	bne	r8,zero,8112a3ec <__reset+0xfb10a3ec>
8112a9f8:	01000c04 	movi	r4,48
8112a9fc:	00000106 	br	8112aa04 <_dtoa_r+0x11f4>
8112aa00:	102f883a 	mov	r23,r2
8112aa04:	b8bfffc4 	addi	r2,r23,-1
8112aa08:	10c00007 	ldb	r3,0(r2)
8112aa0c:	193ffc26 	beq	r3,r4,8112aa00 <__reset+0xfb10aa00>
8112aa10:	003e8706 	br	8112a430 <__reset+0xfb10a430>
8112aa14:	d8800517 	ldw	r2,20(sp)
8112aa18:	00a3c83a 	sub	r17,zero,r2
8112aa1c:	8800a426 	beq	r17,zero,8112acb0 <_dtoa_r+0x14a0>
8112aa20:	888003cc 	andi	r2,r17,15
8112aa24:	100490fa 	slli	r2,r2,3
8112aa28:	00e04574 	movhi	r3,33045
8112aa2c:	18c25e04 	addi	r3,r3,2424
8112aa30:	1885883a 	add	r2,r3,r2
8112aa34:	11800017 	ldw	r6,0(r2)
8112aa38:	11c00117 	ldw	r7,4(r2)
8112aa3c:	9009883a 	mov	r4,r18
8112aa40:	980b883a 	mov	r5,r19
8112aa44:	8823d13a 	srai	r17,r17,4
8112aa48:	111fd240 	call	8111fd24 <__muldf3>
8112aa4c:	d8800f15 	stw	r2,60(sp)
8112aa50:	d8c01015 	stw	r3,64(sp)
8112aa54:	8800e826 	beq	r17,zero,8112adf8 <_dtoa_r+0x15e8>
8112aa58:	05204574 	movhi	r20,33045
8112aa5c:	a5025404 	addi	r20,r20,2384
8112aa60:	04000084 	movi	r16,2
8112aa64:	8980004c 	andi	r6,r17,1
8112aa68:	1009883a 	mov	r4,r2
8112aa6c:	8823d07a 	srai	r17,r17,1
8112aa70:	180b883a 	mov	r5,r3
8112aa74:	30000426 	beq	r6,zero,8112aa88 <_dtoa_r+0x1278>
8112aa78:	a1800017 	ldw	r6,0(r20)
8112aa7c:	a1c00117 	ldw	r7,4(r20)
8112aa80:	84000044 	addi	r16,r16,1
8112aa84:	111fd240 	call	8111fd24 <__muldf3>
8112aa88:	a5000204 	addi	r20,r20,8
8112aa8c:	883ff51e 	bne	r17,zero,8112aa64 <__reset+0xfb10aa64>
8112aa90:	d8800f15 	stw	r2,60(sp)
8112aa94:	d8c01015 	stw	r3,64(sp)
8112aa98:	003c7606 	br	81129c74 <__reset+0xfb109c74>
8112aa9c:	00c00c04 	movi	r3,48
8112aaa0:	10c00005 	stb	r3,0(r2)
8112aaa4:	d8c00517 	ldw	r3,20(sp)
8112aaa8:	bd3fffc3 	ldbu	r20,-1(r23)
8112aaac:	18c00044 	addi	r3,r3,1
8112aab0:	d8c00515 	stw	r3,20(sp)
8112aab4:	003db906 	br	8112a19c <__reset+0xfb10a19c>
8112aab8:	89400117 	ldw	r5,4(r17)
8112aabc:	e009883a 	mov	r4,fp
8112aac0:	112c9280 	call	8112c928 <_Balloc>
8112aac4:	89800417 	ldw	r6,16(r17)
8112aac8:	89400304 	addi	r5,r17,12
8112aacc:	11000304 	addi	r4,r2,12
8112aad0:	31800084 	addi	r6,r6,2
8112aad4:	318d883a 	add	r6,r6,r6
8112aad8:	318d883a 	add	r6,r6,r6
8112aadc:	1027883a 	mov	r19,r2
8112aae0:	11223f40 	call	811223f4 <memcpy>
8112aae4:	01800044 	movi	r6,1
8112aae8:	980b883a 	mov	r5,r19
8112aaec:	e009883a 	mov	r4,fp
8112aaf0:	112d0d80 	call	8112d0d8 <__lshift>
8112aaf4:	1029883a 	mov	r20,r2
8112aaf8:	003ecc06 	br	8112a62c <__reset+0xfb10a62c>
8112aafc:	00800e44 	movi	r2,57
8112ab00:	90809026 	beq	r18,r2,8112ad44 <_dtoa_r+0x1534>
8112ab04:	92000044 	addi	r8,r18,1
8112ab08:	003f1f06 	br	8112a788 <__reset+0xfb10a788>
8112ab0c:	9011883a 	mov	r8,r18
8112ab10:	8825883a 	mov	r18,r17
8112ab14:	a023883a 	mov	r17,r20
8112ab18:	003e2906 	br	8112a3c0 <__reset+0xfb10a3c0>
8112ab1c:	002b883a 	mov	r21,zero
8112ab20:	0023883a 	mov	r17,zero
8112ab24:	003f5406 	br	8112a878 <__reset+0xfb10a878>
8112ab28:	61bfffc4 	addi	r6,r12,-1
8112ab2c:	300490fa 	slli	r2,r6,3
8112ab30:	00e04574 	movhi	r3,33045
8112ab34:	18c25e04 	addi	r3,r3,2424
8112ab38:	1885883a 	add	r2,r3,r2
8112ab3c:	11000017 	ldw	r4,0(r2)
8112ab40:	11400117 	ldw	r5,4(r2)
8112ab44:	d8800717 	ldw	r2,28(sp)
8112ab48:	880f883a 	mov	r7,r17
8112ab4c:	d9801215 	stw	r6,72(sp)
8112ab50:	800d883a 	mov	r6,r16
8112ab54:	db001615 	stw	r12,88(sp)
8112ab58:	15c00044 	addi	r23,r2,1
8112ab5c:	111fd240 	call	8111fd24 <__muldf3>
8112ab60:	d9401017 	ldw	r5,64(sp)
8112ab64:	d9000f17 	ldw	r4,60(sp)
8112ab68:	d8c01515 	stw	r3,84(sp)
8112ab6c:	d8801415 	stw	r2,80(sp)
8112ab70:	1120d480 	call	81120d48 <__fixdfsi>
8112ab74:	1009883a 	mov	r4,r2
8112ab78:	1021883a 	mov	r16,r2
8112ab7c:	1120dc80 	call	81120dc8 <__floatsidf>
8112ab80:	d9000f17 	ldw	r4,60(sp)
8112ab84:	d9401017 	ldw	r5,64(sp)
8112ab88:	100d883a 	mov	r6,r2
8112ab8c:	180f883a 	mov	r7,r3
8112ab90:	11204440 	call	81120444 <__subdf3>
8112ab94:	1829883a 	mov	r20,r3
8112ab98:	d8c00717 	ldw	r3,28(sp)
8112ab9c:	84000c04 	addi	r16,r16,48
8112aba0:	1023883a 	mov	r17,r2
8112aba4:	1c000005 	stb	r16,0(r3)
8112aba8:	db001617 	ldw	r12,88(sp)
8112abac:	00800044 	movi	r2,1
8112abb0:	60802226 	beq	r12,r2,8112ac3c <_dtoa_r+0x142c>
8112abb4:	d9c00717 	ldw	r7,28(sp)
8112abb8:	8805883a 	mov	r2,r17
8112abbc:	b82b883a 	mov	r21,r23
8112abc0:	3b19883a 	add	r12,r7,r12
8112abc4:	6023883a 	mov	r17,r12
8112abc8:	a007883a 	mov	r3,r20
8112abcc:	dc800f15 	stw	r18,60(sp)
8112abd0:	000d883a 	mov	r6,zero
8112abd4:	01d00934 	movhi	r7,16420
8112abd8:	1009883a 	mov	r4,r2
8112abdc:	180b883a 	mov	r5,r3
8112abe0:	111fd240 	call	8111fd24 <__muldf3>
8112abe4:	180b883a 	mov	r5,r3
8112abe8:	1009883a 	mov	r4,r2
8112abec:	1829883a 	mov	r20,r3
8112abf0:	1025883a 	mov	r18,r2
8112abf4:	1120d480 	call	81120d48 <__fixdfsi>
8112abf8:	1009883a 	mov	r4,r2
8112abfc:	1021883a 	mov	r16,r2
8112ac00:	1120dc80 	call	81120dc8 <__floatsidf>
8112ac04:	100d883a 	mov	r6,r2
8112ac08:	180f883a 	mov	r7,r3
8112ac0c:	9009883a 	mov	r4,r18
8112ac10:	a00b883a 	mov	r5,r20
8112ac14:	84000c04 	addi	r16,r16,48
8112ac18:	11204440 	call	81120444 <__subdf3>
8112ac1c:	ad400044 	addi	r21,r21,1
8112ac20:	ac3fffc5 	stb	r16,-1(r21)
8112ac24:	ac7fea1e 	bne	r21,r17,8112abd0 <__reset+0xfb10abd0>
8112ac28:	1023883a 	mov	r17,r2
8112ac2c:	d8801217 	ldw	r2,72(sp)
8112ac30:	dc800f17 	ldw	r18,60(sp)
8112ac34:	1829883a 	mov	r20,r3
8112ac38:	b8af883a 	add	r23,r23,r2
8112ac3c:	d9001417 	ldw	r4,80(sp)
8112ac40:	d9401517 	ldw	r5,84(sp)
8112ac44:	000d883a 	mov	r6,zero
8112ac48:	01cff834 	movhi	r7,16352
8112ac4c:	1134c340 	call	81134c34 <__adddf3>
8112ac50:	880d883a 	mov	r6,r17
8112ac54:	a00f883a 	mov	r7,r20
8112ac58:	1009883a 	mov	r4,r2
8112ac5c:	180b883a 	mov	r5,r3
8112ac60:	1135e600 	call	81135e60 <__ledf2>
8112ac64:	10003e0e 	bge	r2,zero,8112ad60 <_dtoa_r+0x1550>
8112ac68:	d9001317 	ldw	r4,76(sp)
8112ac6c:	bd3fffc3 	ldbu	r20,-1(r23)
8112ac70:	d9000515 	stw	r4,20(sp)
8112ac74:	003d3b06 	br	8112a164 <__reset+0xfb10a164>
8112ac78:	0027883a 	mov	r19,zero
8112ac7c:	003f1b06 	br	8112a8ec <__reset+0xfb10a8ec>
8112ac80:	d8800817 	ldw	r2,32(sp)
8112ac84:	11e9c83a 	sub	r20,r2,r7
8112ac88:	0005883a 	mov	r2,zero
8112ac8c:	003d5406 	br	8112a1e0 <__reset+0xfb10a1e0>
8112ac90:	00800044 	movi	r2,1
8112ac94:	003dc706 	br	8112a3b4 <__reset+0xfb10a3b4>
8112ac98:	d8c00217 	ldw	r3,8(sp)
8112ac9c:	00800d84 	movi	r2,54
8112aca0:	dd400a17 	ldw	r21,40(sp)
8112aca4:	10c5c83a 	sub	r2,r2,r3
8112aca8:	dd000817 	ldw	r20,32(sp)
8112acac:	003d4c06 	br	8112a1e0 <__reset+0xfb10a1e0>
8112acb0:	dc800f15 	stw	r18,60(sp)
8112acb4:	dcc01015 	stw	r19,64(sp)
8112acb8:	04000084 	movi	r16,2
8112acbc:	003bed06 	br	81129c74 <__reset+0xfb109c74>
8112acc0:	d9000617 	ldw	r4,24(sp)
8112acc4:	203f0d26 	beq	r4,zero,8112a8fc <__reset+0xfb10a8fc>
8112acc8:	d9800c17 	ldw	r6,48(sp)
8112accc:	01bcab0e 	bge	zero,r6,81129f7c <__reset+0xfb109f7c>
8112acd0:	d9401017 	ldw	r5,64(sp)
8112acd4:	d9000f17 	ldw	r4,60(sp)
8112acd8:	000d883a 	mov	r6,zero
8112acdc:	01d00934 	movhi	r7,16420
8112ace0:	111fd240 	call	8111fd24 <__muldf3>
8112ace4:	81000044 	addi	r4,r16,1
8112ace8:	d8800f15 	stw	r2,60(sp)
8112acec:	d8c01015 	stw	r3,64(sp)
8112acf0:	1120dc80 	call	81120dc8 <__floatsidf>
8112acf4:	d9800f17 	ldw	r6,60(sp)
8112acf8:	d9c01017 	ldw	r7,64(sp)
8112acfc:	1009883a 	mov	r4,r2
8112ad00:	180b883a 	mov	r5,r3
8112ad04:	111fd240 	call	8111fd24 <__muldf3>
8112ad08:	01d00734 	movhi	r7,16412
8112ad0c:	000d883a 	mov	r6,zero
8112ad10:	1009883a 	mov	r4,r2
8112ad14:	180b883a 	mov	r5,r3
8112ad18:	1134c340 	call	81134c34 <__adddf3>
8112ad1c:	d9c00517 	ldw	r7,20(sp)
8112ad20:	047f3034 	movhi	r17,64704
8112ad24:	1021883a 	mov	r16,r2
8112ad28:	39ffffc4 	addi	r7,r7,-1
8112ad2c:	d9c01315 	stw	r7,76(sp)
8112ad30:	1c63883a 	add	r17,r3,r17
8112ad34:	db000c17 	ldw	r12,48(sp)
8112ad38:	003bea06 	br	81129ce4 <__reset+0xfb109ce4>
8112ad3c:	dc000915 	stw	r16,36(sp)
8112ad40:	003e0e06 	br	8112a57c <__reset+0xfb10a57c>
8112ad44:	01000e44 	movi	r4,57
8112ad48:	8825883a 	mov	r18,r17
8112ad4c:	9dc00044 	addi	r23,r19,1
8112ad50:	99000005 	stb	r4,0(r19)
8112ad54:	a023883a 	mov	r17,r20
8112ad58:	dc000915 	stw	r16,36(sp)
8112ad5c:	003da406 	br	8112a3f0 <__reset+0xfb10a3f0>
8112ad60:	d9801417 	ldw	r6,80(sp)
8112ad64:	d9c01517 	ldw	r7,84(sp)
8112ad68:	0009883a 	mov	r4,zero
8112ad6c:	014ff834 	movhi	r5,16352
8112ad70:	11204440 	call	81120444 <__subdf3>
8112ad74:	880d883a 	mov	r6,r17
8112ad78:	a00f883a 	mov	r7,r20
8112ad7c:	1009883a 	mov	r4,r2
8112ad80:	180b883a 	mov	r5,r3
8112ad84:	111fc480 	call	8111fc48 <__gedf2>
8112ad88:	00bc7c0e 	bge	zero,r2,81129f7c <__reset+0xfb109f7c>
8112ad8c:	01000c04 	movi	r4,48
8112ad90:	00000106 	br	8112ad98 <_dtoa_r+0x1588>
8112ad94:	102f883a 	mov	r23,r2
8112ad98:	b8bfffc4 	addi	r2,r23,-1
8112ad9c:	10c00007 	ldb	r3,0(r2)
8112ada0:	193ffc26 	beq	r3,r4,8112ad94 <__reset+0xfb10ad94>
8112ada4:	d9801317 	ldw	r6,76(sp)
8112ada8:	d9800515 	stw	r6,20(sp)
8112adac:	003c4406 	br	81129ec0 <__reset+0xfb109ec0>
8112adb0:	d9801317 	ldw	r6,76(sp)
8112adb4:	d9800515 	stw	r6,20(sp)
8112adb8:	003cea06 	br	8112a164 <__reset+0xfb10a164>
8112adbc:	dd800f17 	ldw	r22,60(sp)
8112adc0:	dcc01017 	ldw	r19,64(sp)
8112adc4:	dc801217 	ldw	r18,72(sp)
8112adc8:	003c6c06 	br	81129f7c <__reset+0xfb109f7c>
8112adcc:	903e031e 	bne	r18,zero,8112a5dc <__reset+0xfb10a5dc>
8112add0:	003ebb06 	br	8112a8c0 <__reset+0xfb10a8c0>
8112add4:	103e6c1e 	bne	r2,zero,8112a788 <__reset+0xfb10a788>
8112add8:	4080004c 	andi	r2,r8,1
8112addc:	103e6a26 	beq	r2,zero,8112a788 <__reset+0xfb10a788>
8112ade0:	003e6606 	br	8112a77c <__reset+0xfb10a77c>
8112ade4:	d8c00317 	ldw	r3,12(sp)
8112ade8:	00800084 	movi	r2,2
8112adec:	10c02916 	blt	r2,r3,8112ae94 <_dtoa_r+0x1684>
8112adf0:	d9000c17 	ldw	r4,48(sp)
8112adf4:	003e8806 	br	8112a818 <__reset+0xfb10a818>
8112adf8:	04000084 	movi	r16,2
8112adfc:	003b9d06 	br	81129c74 <__reset+0xfb109c74>
8112ae00:	d9001317 	ldw	r4,76(sp)
8112ae04:	d9000515 	stw	r4,20(sp)
8112ae08:	003cd606 	br	8112a164 <__reset+0xfb10a164>
8112ae0c:	d8801317 	ldw	r2,76(sp)
8112ae10:	d8800515 	stw	r2,20(sp)
8112ae14:	003c2a06 	br	81129ec0 <__reset+0xfb109ec0>
8112ae18:	d9800317 	ldw	r6,12(sp)
8112ae1c:	00800084 	movi	r2,2
8112ae20:	11801516 	blt	r2,r6,8112ae78 <_dtoa_r+0x1668>
8112ae24:	d9c00c17 	ldw	r7,48(sp)
8112ae28:	d9c00615 	stw	r7,24(sp)
8112ae2c:	003df706 	br	8112a60c <__reset+0xfb10a60c>
8112ae30:	193d3926 	beq	r3,r4,8112a318 <__reset+0xfb10a318>
8112ae34:	00c00f04 	movi	r3,60
8112ae38:	1885c83a 	sub	r2,r3,r2
8112ae3c:	003ddf06 	br	8112a5bc <__reset+0xfb10a5bc>
8112ae40:	e009883a 	mov	r4,fp
8112ae44:	e0001115 	stw	zero,68(fp)
8112ae48:	000b883a 	mov	r5,zero
8112ae4c:	112c9280 	call	8112c928 <_Balloc>
8112ae50:	d8800715 	stw	r2,28(sp)
8112ae54:	d8c00717 	ldw	r3,28(sp)
8112ae58:	00bfffc4 	movi	r2,-1
8112ae5c:	01000044 	movi	r4,1
8112ae60:	d8800c15 	stw	r2,48(sp)
8112ae64:	e0c01015 	stw	r3,64(fp)
8112ae68:	d9000b15 	stw	r4,44(sp)
8112ae6c:	d8800615 	stw	r2,24(sp)
8112ae70:	d8002215 	stw	zero,136(sp)
8112ae74:	003c4106 	br	81129f7c <__reset+0xfb109f7c>
8112ae78:	d8c00c17 	ldw	r3,48(sp)
8112ae7c:	d8c00615 	stw	r3,24(sp)
8112ae80:	003e7006 	br	8112a844 <__reset+0xfb10a844>
8112ae84:	04400044 	movi	r17,1
8112ae88:	003b2006 	br	81129b0c <__reset+0xfb109b0c>
8112ae8c:	000b883a 	mov	r5,zero
8112ae90:	003b3d06 	br	81129b88 <__reset+0xfb109b88>
8112ae94:	d8800c17 	ldw	r2,48(sp)
8112ae98:	d8800615 	stw	r2,24(sp)
8112ae9c:	003e6906 	br	8112a844 <__reset+0xfb10a844>

8112aea0 <__sflush_r>:
8112aea0:	defffb04 	addi	sp,sp,-20
8112aea4:	de00012e 	bgeu	sp,et,8112aeac <__sflush_r+0xc>
8112aea8:	003b68fa 	trap	3
8112aeac:	2880030b 	ldhu	r2,12(r5)
8112aeb0:	dcc00315 	stw	r19,12(sp)
8112aeb4:	dc400115 	stw	r17,4(sp)
8112aeb8:	dfc00415 	stw	ra,16(sp)
8112aebc:	dc800215 	stw	r18,8(sp)
8112aec0:	dc000015 	stw	r16,0(sp)
8112aec4:	10c0020c 	andi	r3,r2,8
8112aec8:	2823883a 	mov	r17,r5
8112aecc:	2027883a 	mov	r19,r4
8112aed0:	1800311e 	bne	r3,zero,8112af98 <__sflush_r+0xf8>
8112aed4:	28c00117 	ldw	r3,4(r5)
8112aed8:	10820014 	ori	r2,r2,2048
8112aedc:	2880030d 	sth	r2,12(r5)
8112aee0:	00c04b0e 	bge	zero,r3,8112b010 <__sflush_r+0x170>
8112aee4:	8a000a17 	ldw	r8,40(r17)
8112aee8:	40002326 	beq	r8,zero,8112af78 <__sflush_r+0xd8>
8112aeec:	9c000017 	ldw	r16,0(r19)
8112aef0:	10c4000c 	andi	r3,r2,4096
8112aef4:	98000015 	stw	zero,0(r19)
8112aef8:	18004826 	beq	r3,zero,8112b01c <__sflush_r+0x17c>
8112aefc:	89801417 	ldw	r6,80(r17)
8112af00:	10c0010c 	andi	r3,r2,4
8112af04:	18000626 	beq	r3,zero,8112af20 <__sflush_r+0x80>
8112af08:	88c00117 	ldw	r3,4(r17)
8112af0c:	88800c17 	ldw	r2,48(r17)
8112af10:	30cdc83a 	sub	r6,r6,r3
8112af14:	10000226 	beq	r2,zero,8112af20 <__sflush_r+0x80>
8112af18:	88800f17 	ldw	r2,60(r17)
8112af1c:	308dc83a 	sub	r6,r6,r2
8112af20:	89400717 	ldw	r5,28(r17)
8112af24:	000f883a 	mov	r7,zero
8112af28:	9809883a 	mov	r4,r19
8112af2c:	403ee83a 	callr	r8
8112af30:	00ffffc4 	movi	r3,-1
8112af34:	10c04426 	beq	r2,r3,8112b048 <__sflush_r+0x1a8>
8112af38:	88c0030b 	ldhu	r3,12(r17)
8112af3c:	89000417 	ldw	r4,16(r17)
8112af40:	88000115 	stw	zero,4(r17)
8112af44:	197dffcc 	andi	r5,r3,63487
8112af48:	8940030d 	sth	r5,12(r17)
8112af4c:	89000015 	stw	r4,0(r17)
8112af50:	18c4000c 	andi	r3,r3,4096
8112af54:	18002c1e 	bne	r3,zero,8112b008 <__sflush_r+0x168>
8112af58:	89400c17 	ldw	r5,48(r17)
8112af5c:	9c000015 	stw	r16,0(r19)
8112af60:	28000526 	beq	r5,zero,8112af78 <__sflush_r+0xd8>
8112af64:	88801004 	addi	r2,r17,64
8112af68:	28800226 	beq	r5,r2,8112af74 <__sflush_r+0xd4>
8112af6c:	9809883a 	mov	r4,r19
8112af70:	112b9580 	call	8112b958 <_free_r>
8112af74:	88000c15 	stw	zero,48(r17)
8112af78:	0005883a 	mov	r2,zero
8112af7c:	dfc00417 	ldw	ra,16(sp)
8112af80:	dcc00317 	ldw	r19,12(sp)
8112af84:	dc800217 	ldw	r18,8(sp)
8112af88:	dc400117 	ldw	r17,4(sp)
8112af8c:	dc000017 	ldw	r16,0(sp)
8112af90:	dec00504 	addi	sp,sp,20
8112af94:	f800283a 	ret
8112af98:	2c800417 	ldw	r18,16(r5)
8112af9c:	903ff626 	beq	r18,zero,8112af78 <__reset+0xfb10af78>
8112afa0:	2c000017 	ldw	r16,0(r5)
8112afa4:	108000cc 	andi	r2,r2,3
8112afa8:	2c800015 	stw	r18,0(r5)
8112afac:	84a1c83a 	sub	r16,r16,r18
8112afb0:	1000131e 	bne	r2,zero,8112b000 <__sflush_r+0x160>
8112afb4:	28800517 	ldw	r2,20(r5)
8112afb8:	88800215 	stw	r2,8(r17)
8112afbc:	04000316 	blt	zero,r16,8112afcc <__sflush_r+0x12c>
8112afc0:	003fed06 	br	8112af78 <__reset+0xfb10af78>
8112afc4:	90a5883a 	add	r18,r18,r2
8112afc8:	043feb0e 	bge	zero,r16,8112af78 <__reset+0xfb10af78>
8112afcc:	88800917 	ldw	r2,36(r17)
8112afd0:	89400717 	ldw	r5,28(r17)
8112afd4:	800f883a 	mov	r7,r16
8112afd8:	900d883a 	mov	r6,r18
8112afdc:	9809883a 	mov	r4,r19
8112afe0:	103ee83a 	callr	r2
8112afe4:	80a1c83a 	sub	r16,r16,r2
8112afe8:	00bff616 	blt	zero,r2,8112afc4 <__reset+0xfb10afc4>
8112afec:	88c0030b 	ldhu	r3,12(r17)
8112aff0:	00bfffc4 	movi	r2,-1
8112aff4:	18c01014 	ori	r3,r3,64
8112aff8:	88c0030d 	sth	r3,12(r17)
8112affc:	003fdf06 	br	8112af7c <__reset+0xfb10af7c>
8112b000:	0005883a 	mov	r2,zero
8112b004:	003fec06 	br	8112afb8 <__reset+0xfb10afb8>
8112b008:	88801415 	stw	r2,80(r17)
8112b00c:	003fd206 	br	8112af58 <__reset+0xfb10af58>
8112b010:	28c00f17 	ldw	r3,60(r5)
8112b014:	00ffb316 	blt	zero,r3,8112aee4 <__reset+0xfb10aee4>
8112b018:	003fd706 	br	8112af78 <__reset+0xfb10af78>
8112b01c:	89400717 	ldw	r5,28(r17)
8112b020:	000d883a 	mov	r6,zero
8112b024:	01c00044 	movi	r7,1
8112b028:	9809883a 	mov	r4,r19
8112b02c:	403ee83a 	callr	r8
8112b030:	100d883a 	mov	r6,r2
8112b034:	00bfffc4 	movi	r2,-1
8112b038:	30801426 	beq	r6,r2,8112b08c <__sflush_r+0x1ec>
8112b03c:	8880030b 	ldhu	r2,12(r17)
8112b040:	8a000a17 	ldw	r8,40(r17)
8112b044:	003fae06 	br	8112af00 <__reset+0xfb10af00>
8112b048:	98c00017 	ldw	r3,0(r19)
8112b04c:	183fba26 	beq	r3,zero,8112af38 <__reset+0xfb10af38>
8112b050:	01000744 	movi	r4,29
8112b054:	19000626 	beq	r3,r4,8112b070 <__sflush_r+0x1d0>
8112b058:	01000584 	movi	r4,22
8112b05c:	19000426 	beq	r3,r4,8112b070 <__sflush_r+0x1d0>
8112b060:	88c0030b 	ldhu	r3,12(r17)
8112b064:	18c01014 	ori	r3,r3,64
8112b068:	88c0030d 	sth	r3,12(r17)
8112b06c:	003fc306 	br	8112af7c <__reset+0xfb10af7c>
8112b070:	8880030b 	ldhu	r2,12(r17)
8112b074:	88c00417 	ldw	r3,16(r17)
8112b078:	88000115 	stw	zero,4(r17)
8112b07c:	10bdffcc 	andi	r2,r2,63487
8112b080:	8880030d 	sth	r2,12(r17)
8112b084:	88c00015 	stw	r3,0(r17)
8112b088:	003fb306 	br	8112af58 <__reset+0xfb10af58>
8112b08c:	98800017 	ldw	r2,0(r19)
8112b090:	103fea26 	beq	r2,zero,8112b03c <__reset+0xfb10b03c>
8112b094:	00c00744 	movi	r3,29
8112b098:	10c00226 	beq	r2,r3,8112b0a4 <__sflush_r+0x204>
8112b09c:	00c00584 	movi	r3,22
8112b0a0:	10c0031e 	bne	r2,r3,8112b0b0 <__sflush_r+0x210>
8112b0a4:	9c000015 	stw	r16,0(r19)
8112b0a8:	0005883a 	mov	r2,zero
8112b0ac:	003fb306 	br	8112af7c <__reset+0xfb10af7c>
8112b0b0:	88c0030b 	ldhu	r3,12(r17)
8112b0b4:	3005883a 	mov	r2,r6
8112b0b8:	18c01014 	ori	r3,r3,64
8112b0bc:	88c0030d 	sth	r3,12(r17)
8112b0c0:	003fae06 	br	8112af7c <__reset+0xfb10af7c>

8112b0c4 <_fflush_r>:
8112b0c4:	defffd04 	addi	sp,sp,-12
8112b0c8:	de00012e 	bgeu	sp,et,8112b0d0 <_fflush_r+0xc>
8112b0cc:	003b68fa 	trap	3
8112b0d0:	dc000115 	stw	r16,4(sp)
8112b0d4:	dfc00215 	stw	ra,8(sp)
8112b0d8:	2021883a 	mov	r16,r4
8112b0dc:	20000226 	beq	r4,zero,8112b0e8 <_fflush_r+0x24>
8112b0e0:	20800e17 	ldw	r2,56(r4)
8112b0e4:	10000c26 	beq	r2,zero,8112b118 <_fflush_r+0x54>
8112b0e8:	2880030f 	ldh	r2,12(r5)
8112b0ec:	1000051e 	bne	r2,zero,8112b104 <_fflush_r+0x40>
8112b0f0:	0005883a 	mov	r2,zero
8112b0f4:	dfc00217 	ldw	ra,8(sp)
8112b0f8:	dc000117 	ldw	r16,4(sp)
8112b0fc:	dec00304 	addi	sp,sp,12
8112b100:	f800283a 	ret
8112b104:	8009883a 	mov	r4,r16
8112b108:	dfc00217 	ldw	ra,8(sp)
8112b10c:	dc000117 	ldw	r16,4(sp)
8112b110:	dec00304 	addi	sp,sp,12
8112b114:	112aea01 	jmpi	8112aea0 <__sflush_r>
8112b118:	d9400015 	stw	r5,0(sp)
8112b11c:	112b4c00 	call	8112b4c0 <__sinit>
8112b120:	d9400017 	ldw	r5,0(sp)
8112b124:	003ff006 	br	8112b0e8 <__reset+0xfb10b0e8>

8112b128 <fflush>:
8112b128:	20000526 	beq	r4,zero,8112b140 <fflush+0x18>
8112b12c:	00a04574 	movhi	r2,33045
8112b130:	108bed04 	addi	r2,r2,12212
8112b134:	200b883a 	mov	r5,r4
8112b138:	11000017 	ldw	r4,0(r2)
8112b13c:	112b0c41 	jmpi	8112b0c4 <_fflush_r>
8112b140:	00a04574 	movhi	r2,33045
8112b144:	108bec04 	addi	r2,r2,12208
8112b148:	11000017 	ldw	r4,0(r2)
8112b14c:	016044f4 	movhi	r5,33043
8112b150:	296c3104 	addi	r5,r5,-20284
8112b154:	112c2001 	jmpi	8112c200 <_fwalk_reent>

8112b158 <__fp_unlock>:
8112b158:	0005883a 	mov	r2,zero
8112b15c:	f800283a 	ret

8112b160 <_cleanup_r>:
8112b160:	016044f4 	movhi	r5,33043
8112b164:	294b0d04 	addi	r5,r5,11316
8112b168:	112c2001 	jmpi	8112c200 <_fwalk_reent>

8112b16c <__sinit.part.1>:
8112b16c:	defff704 	addi	sp,sp,-36
8112b170:	00e044f4 	movhi	r3,33043
8112b174:	de00012e 	bgeu	sp,et,8112b17c <__sinit.part.1+0x10>
8112b178:	003b68fa 	trap	3
8112b17c:	18ec5804 	addi	r3,r3,-20128
8112b180:	dfc00815 	stw	ra,32(sp)
8112b184:	ddc00715 	stw	r23,28(sp)
8112b188:	dd800615 	stw	r22,24(sp)
8112b18c:	dd400515 	stw	r21,20(sp)
8112b190:	dd000415 	stw	r20,16(sp)
8112b194:	dcc00315 	stw	r19,12(sp)
8112b198:	dc800215 	stw	r18,8(sp)
8112b19c:	dc400115 	stw	r17,4(sp)
8112b1a0:	dc000015 	stw	r16,0(sp)
8112b1a4:	24000117 	ldw	r16,4(r4)
8112b1a8:	20c00f15 	stw	r3,60(r4)
8112b1ac:	2080bb04 	addi	r2,r4,748
8112b1b0:	00c000c4 	movi	r3,3
8112b1b4:	20c0b915 	stw	r3,740(r4)
8112b1b8:	2080ba15 	stw	r2,744(r4)
8112b1bc:	2000b815 	stw	zero,736(r4)
8112b1c0:	05c00204 	movi	r23,8
8112b1c4:	00800104 	movi	r2,4
8112b1c8:	2025883a 	mov	r18,r4
8112b1cc:	b80d883a 	mov	r6,r23
8112b1d0:	81001704 	addi	r4,r16,92
8112b1d4:	000b883a 	mov	r5,zero
8112b1d8:	80000015 	stw	zero,0(r16)
8112b1dc:	80000115 	stw	zero,4(r16)
8112b1e0:	80000215 	stw	zero,8(r16)
8112b1e4:	8080030d 	sth	r2,12(r16)
8112b1e8:	80001915 	stw	zero,100(r16)
8112b1ec:	8000038d 	sth	zero,14(r16)
8112b1f0:	80000415 	stw	zero,16(r16)
8112b1f4:	80000515 	stw	zero,20(r16)
8112b1f8:	80000615 	stw	zero,24(r16)
8112b1fc:	11225440 	call	81122544 <memset>
8112b200:	05a044b4 	movhi	r22,33042
8112b204:	94400217 	ldw	r17,8(r18)
8112b208:	056044b4 	movhi	r21,33042
8112b20c:	052044b4 	movhi	r20,33042
8112b210:	04e044b4 	movhi	r19,33042
8112b214:	b58b5204 	addi	r22,r22,11592
8112b218:	ad4b6b04 	addi	r21,r21,11692
8112b21c:	a50b8c04 	addi	r20,r20,11824
8112b220:	9ccba504 	addi	r19,r19,11924
8112b224:	85800815 	stw	r22,32(r16)
8112b228:	85400915 	stw	r21,36(r16)
8112b22c:	85000a15 	stw	r20,40(r16)
8112b230:	84c00b15 	stw	r19,44(r16)
8112b234:	84000715 	stw	r16,28(r16)
8112b238:	00800284 	movi	r2,10
8112b23c:	8880030d 	sth	r2,12(r17)
8112b240:	00800044 	movi	r2,1
8112b244:	b80d883a 	mov	r6,r23
8112b248:	89001704 	addi	r4,r17,92
8112b24c:	000b883a 	mov	r5,zero
8112b250:	88000015 	stw	zero,0(r17)
8112b254:	88000115 	stw	zero,4(r17)
8112b258:	88000215 	stw	zero,8(r17)
8112b25c:	88001915 	stw	zero,100(r17)
8112b260:	8880038d 	sth	r2,14(r17)
8112b264:	88000415 	stw	zero,16(r17)
8112b268:	88000515 	stw	zero,20(r17)
8112b26c:	88000615 	stw	zero,24(r17)
8112b270:	11225440 	call	81122544 <memset>
8112b274:	94000317 	ldw	r16,12(r18)
8112b278:	00800484 	movi	r2,18
8112b27c:	8c400715 	stw	r17,28(r17)
8112b280:	8d800815 	stw	r22,32(r17)
8112b284:	8d400915 	stw	r21,36(r17)
8112b288:	8d000a15 	stw	r20,40(r17)
8112b28c:	8cc00b15 	stw	r19,44(r17)
8112b290:	8080030d 	sth	r2,12(r16)
8112b294:	00800084 	movi	r2,2
8112b298:	80000015 	stw	zero,0(r16)
8112b29c:	80000115 	stw	zero,4(r16)
8112b2a0:	80000215 	stw	zero,8(r16)
8112b2a4:	80001915 	stw	zero,100(r16)
8112b2a8:	8080038d 	sth	r2,14(r16)
8112b2ac:	80000415 	stw	zero,16(r16)
8112b2b0:	80000515 	stw	zero,20(r16)
8112b2b4:	80000615 	stw	zero,24(r16)
8112b2b8:	b80d883a 	mov	r6,r23
8112b2bc:	000b883a 	mov	r5,zero
8112b2c0:	81001704 	addi	r4,r16,92
8112b2c4:	11225440 	call	81122544 <memset>
8112b2c8:	00800044 	movi	r2,1
8112b2cc:	84000715 	stw	r16,28(r16)
8112b2d0:	85800815 	stw	r22,32(r16)
8112b2d4:	85400915 	stw	r21,36(r16)
8112b2d8:	85000a15 	stw	r20,40(r16)
8112b2dc:	84c00b15 	stw	r19,44(r16)
8112b2e0:	90800e15 	stw	r2,56(r18)
8112b2e4:	dfc00817 	ldw	ra,32(sp)
8112b2e8:	ddc00717 	ldw	r23,28(sp)
8112b2ec:	dd800617 	ldw	r22,24(sp)
8112b2f0:	dd400517 	ldw	r21,20(sp)
8112b2f4:	dd000417 	ldw	r20,16(sp)
8112b2f8:	dcc00317 	ldw	r19,12(sp)
8112b2fc:	dc800217 	ldw	r18,8(sp)
8112b300:	dc400117 	ldw	r17,4(sp)
8112b304:	dc000017 	ldw	r16,0(sp)
8112b308:	dec00904 	addi	sp,sp,36
8112b30c:	f800283a 	ret

8112b310 <__fp_lock>:
8112b310:	0005883a 	mov	r2,zero
8112b314:	f800283a 	ret

8112b318 <__sfmoreglue>:
8112b318:	defffc04 	addi	sp,sp,-16
8112b31c:	de00012e 	bgeu	sp,et,8112b324 <__sfmoreglue+0xc>
8112b320:	003b68fa 	trap	3
8112b324:	dc400115 	stw	r17,4(sp)
8112b328:	2c7fffc4 	addi	r17,r5,-1
8112b32c:	8c401a24 	muli	r17,r17,104
8112b330:	dc800215 	stw	r18,8(sp)
8112b334:	2825883a 	mov	r18,r5
8112b338:	89401d04 	addi	r5,r17,116
8112b33c:	dc000015 	stw	r16,0(sp)
8112b340:	dfc00315 	stw	ra,12(sp)
8112b344:	1121be00 	call	81121be0 <_malloc_r>
8112b348:	1021883a 	mov	r16,r2
8112b34c:	10000726 	beq	r2,zero,8112b36c <__sfmoreglue+0x54>
8112b350:	11000304 	addi	r4,r2,12
8112b354:	10000015 	stw	zero,0(r2)
8112b358:	14800115 	stw	r18,4(r2)
8112b35c:	11000215 	stw	r4,8(r2)
8112b360:	89801a04 	addi	r6,r17,104
8112b364:	000b883a 	mov	r5,zero
8112b368:	11225440 	call	81122544 <memset>
8112b36c:	8005883a 	mov	r2,r16
8112b370:	dfc00317 	ldw	ra,12(sp)
8112b374:	dc800217 	ldw	r18,8(sp)
8112b378:	dc400117 	ldw	r17,4(sp)
8112b37c:	dc000017 	ldw	r16,0(sp)
8112b380:	dec00404 	addi	sp,sp,16
8112b384:	f800283a 	ret

8112b388 <__sfp>:
8112b388:	defffb04 	addi	sp,sp,-20
8112b38c:	de00012e 	bgeu	sp,et,8112b394 <__sfp+0xc>
8112b390:	003b68fa 	trap	3
8112b394:	dc000015 	stw	r16,0(sp)
8112b398:	04204574 	movhi	r16,33045
8112b39c:	840bec04 	addi	r16,r16,12208
8112b3a0:	dcc00315 	stw	r19,12(sp)
8112b3a4:	2027883a 	mov	r19,r4
8112b3a8:	81000017 	ldw	r4,0(r16)
8112b3ac:	dfc00415 	stw	ra,16(sp)
8112b3b0:	dc800215 	stw	r18,8(sp)
8112b3b4:	20800e17 	ldw	r2,56(r4)
8112b3b8:	dc400115 	stw	r17,4(sp)
8112b3bc:	1000021e 	bne	r2,zero,8112b3c8 <__sfp+0x40>
8112b3c0:	112b16c0 	call	8112b16c <__sinit.part.1>
8112b3c4:	81000017 	ldw	r4,0(r16)
8112b3c8:	2480b804 	addi	r18,r4,736
8112b3cc:	047fffc4 	movi	r17,-1
8112b3d0:	91000117 	ldw	r4,4(r18)
8112b3d4:	94000217 	ldw	r16,8(r18)
8112b3d8:	213fffc4 	addi	r4,r4,-1
8112b3dc:	20000a16 	blt	r4,zero,8112b408 <__sfp+0x80>
8112b3e0:	8080030f 	ldh	r2,12(r16)
8112b3e4:	10000c26 	beq	r2,zero,8112b418 <__sfp+0x90>
8112b3e8:	80c01d04 	addi	r3,r16,116
8112b3ec:	00000206 	br	8112b3f8 <__sfp+0x70>
8112b3f0:	18bfe60f 	ldh	r2,-104(r3)
8112b3f4:	10000826 	beq	r2,zero,8112b418 <__sfp+0x90>
8112b3f8:	213fffc4 	addi	r4,r4,-1
8112b3fc:	1c3ffd04 	addi	r16,r3,-12
8112b400:	18c01a04 	addi	r3,r3,104
8112b404:	247ffa1e 	bne	r4,r17,8112b3f0 <__reset+0xfb10b3f0>
8112b408:	90800017 	ldw	r2,0(r18)
8112b40c:	10001d26 	beq	r2,zero,8112b484 <__sfp+0xfc>
8112b410:	1025883a 	mov	r18,r2
8112b414:	003fee06 	br	8112b3d0 <__reset+0xfb10b3d0>
8112b418:	00bfffc4 	movi	r2,-1
8112b41c:	8080038d 	sth	r2,14(r16)
8112b420:	00800044 	movi	r2,1
8112b424:	8080030d 	sth	r2,12(r16)
8112b428:	80001915 	stw	zero,100(r16)
8112b42c:	80000015 	stw	zero,0(r16)
8112b430:	80000215 	stw	zero,8(r16)
8112b434:	80000115 	stw	zero,4(r16)
8112b438:	80000415 	stw	zero,16(r16)
8112b43c:	80000515 	stw	zero,20(r16)
8112b440:	80000615 	stw	zero,24(r16)
8112b444:	01800204 	movi	r6,8
8112b448:	000b883a 	mov	r5,zero
8112b44c:	81001704 	addi	r4,r16,92
8112b450:	11225440 	call	81122544 <memset>
8112b454:	8005883a 	mov	r2,r16
8112b458:	80000c15 	stw	zero,48(r16)
8112b45c:	80000d15 	stw	zero,52(r16)
8112b460:	80001115 	stw	zero,68(r16)
8112b464:	80001215 	stw	zero,72(r16)
8112b468:	dfc00417 	ldw	ra,16(sp)
8112b46c:	dcc00317 	ldw	r19,12(sp)
8112b470:	dc800217 	ldw	r18,8(sp)
8112b474:	dc400117 	ldw	r17,4(sp)
8112b478:	dc000017 	ldw	r16,0(sp)
8112b47c:	dec00504 	addi	sp,sp,20
8112b480:	f800283a 	ret
8112b484:	01400104 	movi	r5,4
8112b488:	9809883a 	mov	r4,r19
8112b48c:	112b3180 	call	8112b318 <__sfmoreglue>
8112b490:	90800015 	stw	r2,0(r18)
8112b494:	103fde1e 	bne	r2,zero,8112b410 <__reset+0xfb10b410>
8112b498:	00800304 	movi	r2,12
8112b49c:	98800015 	stw	r2,0(r19)
8112b4a0:	0005883a 	mov	r2,zero
8112b4a4:	003ff006 	br	8112b468 <__reset+0xfb10b468>

8112b4a8 <_cleanup>:
8112b4a8:	00a04574 	movhi	r2,33045
8112b4ac:	108bec04 	addi	r2,r2,12208
8112b4b0:	11000017 	ldw	r4,0(r2)
8112b4b4:	016044f4 	movhi	r5,33043
8112b4b8:	294b0d04 	addi	r5,r5,11316
8112b4bc:	112c2001 	jmpi	8112c200 <_fwalk_reent>

8112b4c0 <__sinit>:
8112b4c0:	20800e17 	ldw	r2,56(r4)
8112b4c4:	10000126 	beq	r2,zero,8112b4cc <__sinit+0xc>
8112b4c8:	f800283a 	ret
8112b4cc:	112b16c1 	jmpi	8112b16c <__sinit.part.1>

8112b4d0 <__sfp_lock_acquire>:
8112b4d0:	f800283a 	ret

8112b4d4 <__sfp_lock_release>:
8112b4d4:	f800283a 	ret

8112b4d8 <__sinit_lock_acquire>:
8112b4d8:	f800283a 	ret

8112b4dc <__sinit_lock_release>:
8112b4dc:	f800283a 	ret

8112b4e0 <__fp_lock_all>:
8112b4e0:	00a04574 	movhi	r2,33045
8112b4e4:	108bed04 	addi	r2,r2,12212
8112b4e8:	11000017 	ldw	r4,0(r2)
8112b4ec:	016044f4 	movhi	r5,33043
8112b4f0:	296cc404 	addi	r5,r5,-19696
8112b4f4:	112c1341 	jmpi	8112c134 <_fwalk>

8112b4f8 <__fp_unlock_all>:
8112b4f8:	00a04574 	movhi	r2,33045
8112b4fc:	108bed04 	addi	r2,r2,12212
8112b500:	11000017 	ldw	r4,0(r2)
8112b504:	016044f4 	movhi	r5,33043
8112b508:	296c5604 	addi	r5,r5,-20136
8112b50c:	112c1341 	jmpi	8112c134 <_fwalk>

8112b510 <__sflags>:
8112b510:	28800007 	ldb	r2,0(r5)
8112b514:	00c01c84 	movi	r3,114
8112b518:	10c02426 	beq	r2,r3,8112b5ac <__sflags+0x9c>
8112b51c:	00c01dc4 	movi	r3,119
8112b520:	10c01e26 	beq	r2,r3,8112b59c <__sflags+0x8c>
8112b524:	00c01844 	movi	r3,97
8112b528:	10c00426 	beq	r2,r3,8112b53c <__sflags+0x2c>
8112b52c:	00800584 	movi	r2,22
8112b530:	20800015 	stw	r2,0(r4)
8112b534:	0005883a 	mov	r2,zero
8112b538:	f800283a 	ret
8112b53c:	02c08204 	movi	r11,520
8112b540:	01000044 	movi	r4,1
8112b544:	00804204 	movi	r2,264
8112b548:	01c00ac4 	movi	r7,43
8112b54c:	02bff8c4 	movi	r10,-29
8112b550:	027fff04 	movi	r9,-4
8112b554:	02001e04 	movi	r8,120
8112b558:	29400044 	addi	r5,r5,1
8112b55c:	28c00007 	ldb	r3,0(r5)
8112b560:	18000626 	beq	r3,zero,8112b57c <__sflags+0x6c>
8112b564:	19c00826 	beq	r3,r7,8112b588 <__sflags+0x78>
8112b568:	1a3ffb1e 	bne	r3,r8,8112b558 <__reset+0xfb10b558>
8112b56c:	29400044 	addi	r5,r5,1
8112b570:	28c00007 	ldb	r3,0(r5)
8112b574:	21020014 	ori	r4,r4,2048
8112b578:	183ffa1e 	bne	r3,zero,8112b564 <__reset+0xfb10b564>
8112b57c:	22c8b03a 	or	r4,r4,r11
8112b580:	31000015 	stw	r4,0(r6)
8112b584:	f800283a 	ret
8112b588:	1284703a 	and	r2,r2,r10
8112b58c:	2248703a 	and	r4,r4,r9
8112b590:	10800414 	ori	r2,r2,16
8112b594:	21000094 	ori	r4,r4,2
8112b598:	003fef06 	br	8112b558 <__reset+0xfb10b558>
8112b59c:	02c18004 	movi	r11,1536
8112b5a0:	01000044 	movi	r4,1
8112b5a4:	00800204 	movi	r2,8
8112b5a8:	003fe706 	br	8112b548 <__reset+0xfb10b548>
8112b5ac:	0017883a 	mov	r11,zero
8112b5b0:	0009883a 	mov	r4,zero
8112b5b4:	00800104 	movi	r2,4
8112b5b8:	003fe306 	br	8112b548 <__reset+0xfb10b548>

8112b5bc <_fread_r>:
8112b5bc:	defff404 	addi	sp,sp,-48
8112b5c0:	de00012e 	bgeu	sp,et,8112b5c8 <_fread_r+0xc>
8112b5c4:	003b68fa 	trap	3
8112b5c8:	dd800815 	stw	r22,32(sp)
8112b5cc:	39ad383a 	mul	r22,r7,r6
8112b5d0:	dc000215 	stw	r16,8(sp)
8112b5d4:	dfc00b15 	stw	ra,44(sp)
8112b5d8:	df000a15 	stw	fp,40(sp)
8112b5dc:	ddc00915 	stw	r23,36(sp)
8112b5e0:	dd400715 	stw	r21,28(sp)
8112b5e4:	dd000615 	stw	r20,24(sp)
8112b5e8:	dcc00515 	stw	r19,20(sp)
8112b5ec:	dc800415 	stw	r18,16(sp)
8112b5f0:	dc400315 	stw	r17,12(sp)
8112b5f4:	dc000c17 	ldw	r16,48(sp)
8112b5f8:	b0003b26 	beq	r22,zero,8112b6e8 <_fread_r+0x12c>
8112b5fc:	302f883a 	mov	r23,r6
8112b600:	382b883a 	mov	r21,r7
8112b604:	2029883a 	mov	r20,r4
8112b608:	2827883a 	mov	r19,r5
8112b60c:	20000226 	beq	r4,zero,8112b618 <_fread_r+0x5c>
8112b610:	20800e17 	ldw	r2,56(r4)
8112b614:	10006e26 	beq	r2,zero,8112b7d0 <_fread_r+0x214>
8112b618:	8080030b 	ldhu	r2,12(r16)
8112b61c:	10c8000c 	andi	r3,r2,8192
8112b620:	1800061e 	bne	r3,zero,8112b63c <_fread_r+0x80>
8112b624:	81001917 	ldw	r4,100(r16)
8112b628:	00f7ffc4 	movi	r3,-8193
8112b62c:	10880014 	ori	r2,r2,8192
8112b630:	20c6703a 	and	r3,r4,r3
8112b634:	8080030d 	sth	r2,12(r16)
8112b638:	80c01915 	stw	r3,100(r16)
8112b63c:	84400117 	ldw	r17,4(r16)
8112b640:	88005f16 	blt	r17,zero,8112b7c0 <_fread_r+0x204>
8112b644:	8809883a 	mov	r4,r17
8112b648:	1080008c 	andi	r2,r2,2
8112b64c:	1000281e 	bne	r2,zero,8112b6f0 <_fread_r+0x134>
8112b650:	b025883a 	mov	r18,r22
8112b654:	00000b06 	br	8112b684 <_fread_r+0xc8>
8112b658:	11223f40 	call	811223f4 <memcpy>
8112b65c:	80800017 	ldw	r2,0(r16)
8112b660:	9c67883a 	add	r19,r19,r17
8112b664:	9465c83a 	sub	r18,r18,r17
8112b668:	1463883a 	add	r17,r2,r17
8112b66c:	800b883a 	mov	r5,r16
8112b670:	a009883a 	mov	r4,r20
8112b674:	84400015 	stw	r17,0(r16)
8112b678:	11229c00 	call	811229c0 <__srefill_r>
8112b67c:	10004c1e 	bne	r2,zero,8112b7b0 <_fread_r+0x1f4>
8112b680:	84400117 	ldw	r17,4(r16)
8112b684:	880d883a 	mov	r6,r17
8112b688:	9809883a 	mov	r4,r19
8112b68c:	81400017 	ldw	r5,0(r16)
8112b690:	8cbff136 	bltu	r17,r18,8112b658 <__reset+0xfb10b658>
8112b694:	900d883a 	mov	r6,r18
8112b698:	11223f40 	call	811223f4 <memcpy>
8112b69c:	80c00117 	ldw	r3,4(r16)
8112b6a0:	81000017 	ldw	r4,0(r16)
8112b6a4:	a805883a 	mov	r2,r21
8112b6a8:	1c87c83a 	sub	r3,r3,r18
8112b6ac:	24a5883a 	add	r18,r4,r18
8112b6b0:	80c00115 	stw	r3,4(r16)
8112b6b4:	84800015 	stw	r18,0(r16)
8112b6b8:	dfc00b17 	ldw	ra,44(sp)
8112b6bc:	df000a17 	ldw	fp,40(sp)
8112b6c0:	ddc00917 	ldw	r23,36(sp)
8112b6c4:	dd800817 	ldw	r22,32(sp)
8112b6c8:	dd400717 	ldw	r21,28(sp)
8112b6cc:	dd000617 	ldw	r20,24(sp)
8112b6d0:	dcc00517 	ldw	r19,20(sp)
8112b6d4:	dc800417 	ldw	r18,16(sp)
8112b6d8:	dc400317 	ldw	r17,12(sp)
8112b6dc:	dc000217 	ldw	r16,8(sp)
8112b6e0:	dec00c04 	addi	sp,sp,48
8112b6e4:	f800283a 	ret
8112b6e8:	0005883a 	mov	r2,zero
8112b6ec:	003ff206 	br	8112b6b8 <__reset+0xfb10b6b8>
8112b6f0:	b007883a 	mov	r3,r22
8112b6f4:	2580012e 	bgeu	r4,r22,8112b6fc <_fread_r+0x140>
8112b6f8:	2007883a 	mov	r3,r4
8112b6fc:	81400017 	ldw	r5,0(r16)
8112b700:	180d883a 	mov	r6,r3
8112b704:	9809883a 	mov	r4,r19
8112b708:	d8c00115 	stw	r3,4(sp)
8112b70c:	11223f40 	call	811223f4 <memcpy>
8112b710:	d8c00117 	ldw	r3,4(sp)
8112b714:	84400017 	ldw	r17,0(r16)
8112b718:	80800117 	ldw	r2,4(r16)
8112b71c:	81400c17 	ldw	r5,48(r16)
8112b720:	88e3883a 	add	r17,r17,r3
8112b724:	10c5c83a 	sub	r2,r2,r3
8112b728:	84400015 	stw	r17,0(r16)
8112b72c:	80800115 	stw	r2,4(r16)
8112b730:	b0e5c83a 	sub	r18,r22,r3
8112b734:	28002b26 	beq	r5,zero,8112b7e4 <_fread_r+0x228>
8112b738:	90002b26 	beq	r18,zero,8112b7e8 <_fread_r+0x22c>
8112b73c:	80801004 	addi	r2,r16,64
8112b740:	28800526 	beq	r5,r2,8112b758 <_fread_r+0x19c>
8112b744:	a009883a 	mov	r4,r20
8112b748:	d8c00115 	stw	r3,4(sp)
8112b74c:	112b9580 	call	8112b958 <_free_r>
8112b750:	d8c00117 	ldw	r3,4(sp)
8112b754:	84400017 	ldw	r17,0(r16)
8112b758:	80000c15 	stw	zero,48(r16)
8112b75c:	80800517 	ldw	r2,20(r16)
8112b760:	87000417 	ldw	fp,16(r16)
8112b764:	98e7883a 	add	r19,r19,r3
8112b768:	d8800015 	stw	r2,0(sp)
8112b76c:	00000106 	br	8112b774 <_fread_r+0x1b8>
8112b770:	90001d26 	beq	r18,zero,8112b7e8 <_fread_r+0x22c>
8112b774:	84c00415 	stw	r19,16(r16)
8112b778:	84800515 	stw	r18,20(r16)
8112b77c:	84c00015 	stw	r19,0(r16)
8112b780:	a009883a 	mov	r4,r20
8112b784:	800b883a 	mov	r5,r16
8112b788:	11229c00 	call	811229c0 <__srefill_r>
8112b78c:	d9000017 	ldw	r4,0(sp)
8112b790:	80c00117 	ldw	r3,4(r16)
8112b794:	87000415 	stw	fp,16(r16)
8112b798:	81000515 	stw	r4,20(r16)
8112b79c:	84400015 	stw	r17,0(r16)
8112b7a0:	80000115 	stw	zero,4(r16)
8112b7a4:	90e5c83a 	sub	r18,r18,r3
8112b7a8:	98e7883a 	add	r19,r19,r3
8112b7ac:	103ff026 	beq	r2,zero,8112b770 <__reset+0xfb10b770>
8112b7b0:	b80b883a 	mov	r5,r23
8112b7b4:	b489c83a 	sub	r4,r22,r18
8112b7b8:	113497c0 	call	8113497c <__udivsi3>
8112b7bc:	003fbe06 	br	8112b6b8 <__reset+0xfb10b6b8>
8112b7c0:	80000115 	stw	zero,4(r16)
8112b7c4:	0009883a 	mov	r4,zero
8112b7c8:	0023883a 	mov	r17,zero
8112b7cc:	003f9e06 	br	8112b648 <__reset+0xfb10b648>
8112b7d0:	112b4c00 	call	8112b4c0 <__sinit>
8112b7d4:	8080030b 	ldhu	r2,12(r16)
8112b7d8:	10c8000c 	andi	r3,r2,8192
8112b7dc:	183f971e 	bne	r3,zero,8112b63c <__reset+0xfb10b63c>
8112b7e0:	003f9006 	br	8112b624 <__reset+0xfb10b624>
8112b7e4:	903fdd1e 	bne	r18,zero,8112b75c <__reset+0xfb10b75c>
8112b7e8:	a805883a 	mov	r2,r21
8112b7ec:	003fb206 	br	8112b6b8 <__reset+0xfb10b6b8>

8112b7f0 <fread>:
8112b7f0:	defffe04 	addi	sp,sp,-8
8112b7f4:	00a04574 	movhi	r2,33045
8112b7f8:	de00012e 	bgeu	sp,et,8112b800 <fread+0x10>
8112b7fc:	003b68fa 	trap	3
8112b800:	108bed04 	addi	r2,r2,12212
8112b804:	d9c00015 	stw	r7,0(sp)
8112b808:	300f883a 	mov	r7,r6
8112b80c:	280d883a 	mov	r6,r5
8112b810:	200b883a 	mov	r5,r4
8112b814:	11000017 	ldw	r4,0(r2)
8112b818:	dfc00115 	stw	ra,4(sp)
8112b81c:	112b5bc0 	call	8112b5bc <_fread_r>
8112b820:	dfc00117 	ldw	ra,4(sp)
8112b824:	dec00204 	addi	sp,sp,8
8112b828:	f800283a 	ret

8112b82c <_malloc_trim_r>:
8112b82c:	defffb04 	addi	sp,sp,-20
8112b830:	de00012e 	bgeu	sp,et,8112b838 <_malloc_trim_r+0xc>
8112b834:	003b68fa 	trap	3
8112b838:	dcc00315 	stw	r19,12(sp)
8112b83c:	04e04574 	movhi	r19,33045
8112b840:	dc800215 	stw	r18,8(sp)
8112b844:	dc400115 	stw	r17,4(sp)
8112b848:	dc000015 	stw	r16,0(sp)
8112b84c:	dfc00415 	stw	ra,16(sp)
8112b850:	2821883a 	mov	r16,r5
8112b854:	9cc5ab04 	addi	r19,r19,5804
8112b858:	2025883a 	mov	r18,r4
8112b85c:	1137e380 	call	81137e38 <__malloc_lock>
8112b860:	98800217 	ldw	r2,8(r19)
8112b864:	14400117 	ldw	r17,4(r2)
8112b868:	00bfff04 	movi	r2,-4
8112b86c:	88a2703a 	and	r17,r17,r2
8112b870:	8c21c83a 	sub	r16,r17,r16
8112b874:	8403fbc4 	addi	r16,r16,4079
8112b878:	8020d33a 	srli	r16,r16,12
8112b87c:	0083ffc4 	movi	r2,4095
8112b880:	843fffc4 	addi	r16,r16,-1
8112b884:	8020933a 	slli	r16,r16,12
8112b888:	1400060e 	bge	r2,r16,8112b8a4 <_malloc_trim_r+0x78>
8112b88c:	000b883a 	mov	r5,zero
8112b890:	9009883a 	mov	r4,r18
8112b894:	1122b9c0 	call	81122b9c <_sbrk_r>
8112b898:	98c00217 	ldw	r3,8(r19)
8112b89c:	1c47883a 	add	r3,r3,r17
8112b8a0:	10c00a26 	beq	r2,r3,8112b8cc <_malloc_trim_r+0xa0>
8112b8a4:	9009883a 	mov	r4,r18
8112b8a8:	1137f600 	call	81137f60 <__malloc_unlock>
8112b8ac:	0005883a 	mov	r2,zero
8112b8b0:	dfc00417 	ldw	ra,16(sp)
8112b8b4:	dcc00317 	ldw	r19,12(sp)
8112b8b8:	dc800217 	ldw	r18,8(sp)
8112b8bc:	dc400117 	ldw	r17,4(sp)
8112b8c0:	dc000017 	ldw	r16,0(sp)
8112b8c4:	dec00504 	addi	sp,sp,20
8112b8c8:	f800283a 	ret
8112b8cc:	040bc83a 	sub	r5,zero,r16
8112b8d0:	9009883a 	mov	r4,r18
8112b8d4:	1122b9c0 	call	81122b9c <_sbrk_r>
8112b8d8:	00ffffc4 	movi	r3,-1
8112b8dc:	10c00d26 	beq	r2,r3,8112b914 <_malloc_trim_r+0xe8>
8112b8e0:	00e04574 	movhi	r3,33045
8112b8e4:	18ccf004 	addi	r3,r3,13248
8112b8e8:	18800017 	ldw	r2,0(r3)
8112b8ec:	99000217 	ldw	r4,8(r19)
8112b8f0:	8c23c83a 	sub	r17,r17,r16
8112b8f4:	8c400054 	ori	r17,r17,1
8112b8f8:	1421c83a 	sub	r16,r2,r16
8112b8fc:	24400115 	stw	r17,4(r4)
8112b900:	9009883a 	mov	r4,r18
8112b904:	1c000015 	stw	r16,0(r3)
8112b908:	1137f600 	call	81137f60 <__malloc_unlock>
8112b90c:	00800044 	movi	r2,1
8112b910:	003fe706 	br	8112b8b0 <__reset+0xfb10b8b0>
8112b914:	000b883a 	mov	r5,zero
8112b918:	9009883a 	mov	r4,r18
8112b91c:	1122b9c0 	call	81122b9c <_sbrk_r>
8112b920:	99000217 	ldw	r4,8(r19)
8112b924:	014003c4 	movi	r5,15
8112b928:	1107c83a 	sub	r3,r2,r4
8112b92c:	28ffdd0e 	bge	r5,r3,8112b8a4 <__reset+0xfb10b8a4>
8112b930:	01604574 	movhi	r5,33045
8112b934:	294bee04 	addi	r5,r5,12216
8112b938:	29400017 	ldw	r5,0(r5)
8112b93c:	18c00054 	ori	r3,r3,1
8112b940:	20c00115 	stw	r3,4(r4)
8112b944:	00e04574 	movhi	r3,33045
8112b948:	1145c83a 	sub	r2,r2,r5
8112b94c:	18ccf004 	addi	r3,r3,13248
8112b950:	18800015 	stw	r2,0(r3)
8112b954:	003fd306 	br	8112b8a4 <__reset+0xfb10b8a4>

8112b958 <_free_r>:
8112b958:	28004326 	beq	r5,zero,8112ba68 <_free_r+0x110>
8112b95c:	defffd04 	addi	sp,sp,-12
8112b960:	de00012e 	bgeu	sp,et,8112b968 <_free_r+0x10>
8112b964:	003b68fa 	trap	3
8112b968:	dc400115 	stw	r17,4(sp)
8112b96c:	dc000015 	stw	r16,0(sp)
8112b970:	2023883a 	mov	r17,r4
8112b974:	2821883a 	mov	r16,r5
8112b978:	dfc00215 	stw	ra,8(sp)
8112b97c:	1137e380 	call	81137e38 <__malloc_lock>
8112b980:	81ffff17 	ldw	r7,-4(r16)
8112b984:	00bfff84 	movi	r2,-2
8112b988:	01204574 	movhi	r4,33045
8112b98c:	81bffe04 	addi	r6,r16,-8
8112b990:	3884703a 	and	r2,r7,r2
8112b994:	2105ab04 	addi	r4,r4,5804
8112b998:	308b883a 	add	r5,r6,r2
8112b99c:	2a400117 	ldw	r9,4(r5)
8112b9a0:	22000217 	ldw	r8,8(r4)
8112b9a4:	00ffff04 	movi	r3,-4
8112b9a8:	48c6703a 	and	r3,r9,r3
8112b9ac:	2a005726 	beq	r5,r8,8112bb0c <_free_r+0x1b4>
8112b9b0:	28c00115 	stw	r3,4(r5)
8112b9b4:	39c0004c 	andi	r7,r7,1
8112b9b8:	3800091e 	bne	r7,zero,8112b9e0 <_free_r+0x88>
8112b9bc:	823ffe17 	ldw	r8,-8(r16)
8112b9c0:	22400204 	addi	r9,r4,8
8112b9c4:	320dc83a 	sub	r6,r6,r8
8112b9c8:	31c00217 	ldw	r7,8(r6)
8112b9cc:	1205883a 	add	r2,r2,r8
8112b9d0:	3a406526 	beq	r7,r9,8112bb68 <_free_r+0x210>
8112b9d4:	32000317 	ldw	r8,12(r6)
8112b9d8:	3a000315 	stw	r8,12(r7)
8112b9dc:	41c00215 	stw	r7,8(r8)
8112b9e0:	28cf883a 	add	r7,r5,r3
8112b9e4:	39c00117 	ldw	r7,4(r7)
8112b9e8:	39c0004c 	andi	r7,r7,1
8112b9ec:	38003a26 	beq	r7,zero,8112bad8 <_free_r+0x180>
8112b9f0:	10c00054 	ori	r3,r2,1
8112b9f4:	30c00115 	stw	r3,4(r6)
8112b9f8:	3087883a 	add	r3,r6,r2
8112b9fc:	18800015 	stw	r2,0(r3)
8112ba00:	00c07fc4 	movi	r3,511
8112ba04:	18801936 	bltu	r3,r2,8112ba6c <_free_r+0x114>
8112ba08:	1004d0fa 	srli	r2,r2,3
8112ba0c:	01c00044 	movi	r7,1
8112ba10:	21400117 	ldw	r5,4(r4)
8112ba14:	10c00044 	addi	r3,r2,1
8112ba18:	18c7883a 	add	r3,r3,r3
8112ba1c:	1005d0ba 	srai	r2,r2,2
8112ba20:	18c7883a 	add	r3,r3,r3
8112ba24:	18c7883a 	add	r3,r3,r3
8112ba28:	1907883a 	add	r3,r3,r4
8112ba2c:	3884983a 	sll	r2,r7,r2
8112ba30:	19c00017 	ldw	r7,0(r3)
8112ba34:	1a3ffe04 	addi	r8,r3,-8
8112ba38:	1144b03a 	or	r2,r2,r5
8112ba3c:	32000315 	stw	r8,12(r6)
8112ba40:	31c00215 	stw	r7,8(r6)
8112ba44:	20800115 	stw	r2,4(r4)
8112ba48:	19800015 	stw	r6,0(r3)
8112ba4c:	39800315 	stw	r6,12(r7)
8112ba50:	8809883a 	mov	r4,r17
8112ba54:	dfc00217 	ldw	ra,8(sp)
8112ba58:	dc400117 	ldw	r17,4(sp)
8112ba5c:	dc000017 	ldw	r16,0(sp)
8112ba60:	dec00304 	addi	sp,sp,12
8112ba64:	1137f601 	jmpi	81137f60 <__malloc_unlock>
8112ba68:	f800283a 	ret
8112ba6c:	100ad27a 	srli	r5,r2,9
8112ba70:	00c00104 	movi	r3,4
8112ba74:	19404a36 	bltu	r3,r5,8112bba0 <_free_r+0x248>
8112ba78:	100ad1ba 	srli	r5,r2,6
8112ba7c:	28c00e44 	addi	r3,r5,57
8112ba80:	18c7883a 	add	r3,r3,r3
8112ba84:	29400e04 	addi	r5,r5,56
8112ba88:	18c7883a 	add	r3,r3,r3
8112ba8c:	18c7883a 	add	r3,r3,r3
8112ba90:	1909883a 	add	r4,r3,r4
8112ba94:	20c00017 	ldw	r3,0(r4)
8112ba98:	01e04574 	movhi	r7,33045
8112ba9c:	213ffe04 	addi	r4,r4,-8
8112baa0:	39c5ab04 	addi	r7,r7,5804
8112baa4:	20c04426 	beq	r4,r3,8112bbb8 <_free_r+0x260>
8112baa8:	01ffff04 	movi	r7,-4
8112baac:	19400117 	ldw	r5,4(r3)
8112bab0:	29ca703a 	and	r5,r5,r7
8112bab4:	1140022e 	bgeu	r2,r5,8112bac0 <_free_r+0x168>
8112bab8:	18c00217 	ldw	r3,8(r3)
8112babc:	20fffb1e 	bne	r4,r3,8112baac <__reset+0xfb10baac>
8112bac0:	19000317 	ldw	r4,12(r3)
8112bac4:	31000315 	stw	r4,12(r6)
8112bac8:	30c00215 	stw	r3,8(r6)
8112bacc:	21800215 	stw	r6,8(r4)
8112bad0:	19800315 	stw	r6,12(r3)
8112bad4:	003fde06 	br	8112ba50 <__reset+0xfb10ba50>
8112bad8:	29c00217 	ldw	r7,8(r5)
8112badc:	10c5883a 	add	r2,r2,r3
8112bae0:	00e04574 	movhi	r3,33045
8112bae4:	18c5ad04 	addi	r3,r3,5812
8112bae8:	38c03b26 	beq	r7,r3,8112bbd8 <_free_r+0x280>
8112baec:	2a000317 	ldw	r8,12(r5)
8112baf0:	11400054 	ori	r5,r2,1
8112baf4:	3087883a 	add	r3,r6,r2
8112baf8:	3a000315 	stw	r8,12(r7)
8112bafc:	41c00215 	stw	r7,8(r8)
8112bb00:	31400115 	stw	r5,4(r6)
8112bb04:	18800015 	stw	r2,0(r3)
8112bb08:	003fbd06 	br	8112ba00 <__reset+0xfb10ba00>
8112bb0c:	39c0004c 	andi	r7,r7,1
8112bb10:	10c5883a 	add	r2,r2,r3
8112bb14:	3800071e 	bne	r7,zero,8112bb34 <_free_r+0x1dc>
8112bb18:	81fffe17 	ldw	r7,-8(r16)
8112bb1c:	31cdc83a 	sub	r6,r6,r7
8112bb20:	30c00317 	ldw	r3,12(r6)
8112bb24:	31400217 	ldw	r5,8(r6)
8112bb28:	11c5883a 	add	r2,r2,r7
8112bb2c:	28c00315 	stw	r3,12(r5)
8112bb30:	19400215 	stw	r5,8(r3)
8112bb34:	10c00054 	ori	r3,r2,1
8112bb38:	30c00115 	stw	r3,4(r6)
8112bb3c:	00e04574 	movhi	r3,33045
8112bb40:	18cbef04 	addi	r3,r3,12220
8112bb44:	18c00017 	ldw	r3,0(r3)
8112bb48:	21800215 	stw	r6,8(r4)
8112bb4c:	10ffc036 	bltu	r2,r3,8112ba50 <__reset+0xfb10ba50>
8112bb50:	00a04574 	movhi	r2,33045
8112bb54:	108c6304 	addi	r2,r2,12684
8112bb58:	11400017 	ldw	r5,0(r2)
8112bb5c:	8809883a 	mov	r4,r17
8112bb60:	112b82c0 	call	8112b82c <_malloc_trim_r>
8112bb64:	003fba06 	br	8112ba50 <__reset+0xfb10ba50>
8112bb68:	28c9883a 	add	r4,r5,r3
8112bb6c:	21000117 	ldw	r4,4(r4)
8112bb70:	2100004c 	andi	r4,r4,1
8112bb74:	2000391e 	bne	r4,zero,8112bc5c <_free_r+0x304>
8112bb78:	29c00217 	ldw	r7,8(r5)
8112bb7c:	29000317 	ldw	r4,12(r5)
8112bb80:	1885883a 	add	r2,r3,r2
8112bb84:	10c00054 	ori	r3,r2,1
8112bb88:	39000315 	stw	r4,12(r7)
8112bb8c:	21c00215 	stw	r7,8(r4)
8112bb90:	30c00115 	stw	r3,4(r6)
8112bb94:	308d883a 	add	r6,r6,r2
8112bb98:	30800015 	stw	r2,0(r6)
8112bb9c:	003fac06 	br	8112ba50 <__reset+0xfb10ba50>
8112bba0:	00c00504 	movi	r3,20
8112bba4:	19401536 	bltu	r3,r5,8112bbfc <_free_r+0x2a4>
8112bba8:	28c01704 	addi	r3,r5,92
8112bbac:	18c7883a 	add	r3,r3,r3
8112bbb0:	294016c4 	addi	r5,r5,91
8112bbb4:	003fb406 	br	8112ba88 <__reset+0xfb10ba88>
8112bbb8:	280bd0ba 	srai	r5,r5,2
8112bbbc:	00c00044 	movi	r3,1
8112bbc0:	38800117 	ldw	r2,4(r7)
8112bbc4:	194a983a 	sll	r5,r3,r5
8112bbc8:	2007883a 	mov	r3,r4
8112bbcc:	2884b03a 	or	r2,r5,r2
8112bbd0:	38800115 	stw	r2,4(r7)
8112bbd4:	003fbb06 	br	8112bac4 <__reset+0xfb10bac4>
8112bbd8:	21800515 	stw	r6,20(r4)
8112bbdc:	21800415 	stw	r6,16(r4)
8112bbe0:	10c00054 	ori	r3,r2,1
8112bbe4:	31c00315 	stw	r7,12(r6)
8112bbe8:	31c00215 	stw	r7,8(r6)
8112bbec:	30c00115 	stw	r3,4(r6)
8112bbf0:	308d883a 	add	r6,r6,r2
8112bbf4:	30800015 	stw	r2,0(r6)
8112bbf8:	003f9506 	br	8112ba50 <__reset+0xfb10ba50>
8112bbfc:	00c01504 	movi	r3,84
8112bc00:	19400536 	bltu	r3,r5,8112bc18 <_free_r+0x2c0>
8112bc04:	100ad33a 	srli	r5,r2,12
8112bc08:	28c01bc4 	addi	r3,r5,111
8112bc0c:	18c7883a 	add	r3,r3,r3
8112bc10:	29401b84 	addi	r5,r5,110
8112bc14:	003f9c06 	br	8112ba88 <__reset+0xfb10ba88>
8112bc18:	00c05504 	movi	r3,340
8112bc1c:	19400536 	bltu	r3,r5,8112bc34 <_free_r+0x2dc>
8112bc20:	100ad3fa 	srli	r5,r2,15
8112bc24:	28c01e04 	addi	r3,r5,120
8112bc28:	18c7883a 	add	r3,r3,r3
8112bc2c:	29401dc4 	addi	r5,r5,119
8112bc30:	003f9506 	br	8112ba88 <__reset+0xfb10ba88>
8112bc34:	00c15504 	movi	r3,1364
8112bc38:	19400536 	bltu	r3,r5,8112bc50 <_free_r+0x2f8>
8112bc3c:	100ad4ba 	srli	r5,r2,18
8112bc40:	28c01f44 	addi	r3,r5,125
8112bc44:	18c7883a 	add	r3,r3,r3
8112bc48:	29401f04 	addi	r5,r5,124
8112bc4c:	003f8e06 	br	8112ba88 <__reset+0xfb10ba88>
8112bc50:	00c03f84 	movi	r3,254
8112bc54:	01401f84 	movi	r5,126
8112bc58:	003f8b06 	br	8112ba88 <__reset+0xfb10ba88>
8112bc5c:	10c00054 	ori	r3,r2,1
8112bc60:	30c00115 	stw	r3,4(r6)
8112bc64:	308d883a 	add	r6,r6,r2
8112bc68:	30800015 	stw	r2,0(r6)
8112bc6c:	003f7806 	br	8112ba50 <__reset+0xfb10ba50>

8112bc70 <__sfvwrite_r>:
8112bc70:	30800217 	ldw	r2,8(r6)
8112bc74:	10006926 	beq	r2,zero,8112be1c <__sfvwrite_r+0x1ac>
8112bc78:	defff404 	addi	sp,sp,-48
8112bc7c:	de00012e 	bgeu	sp,et,8112bc84 <__sfvwrite_r+0x14>
8112bc80:	003b68fa 	trap	3
8112bc84:	28c0030b 	ldhu	r3,12(r5)
8112bc88:	dd400715 	stw	r21,28(sp)
8112bc8c:	dd000615 	stw	r20,24(sp)
8112bc90:	dc000215 	stw	r16,8(sp)
8112bc94:	dfc00b15 	stw	ra,44(sp)
8112bc98:	df000a15 	stw	fp,40(sp)
8112bc9c:	ddc00915 	stw	r23,36(sp)
8112bca0:	dd800815 	stw	r22,32(sp)
8112bca4:	dcc00515 	stw	r19,20(sp)
8112bca8:	dc800415 	stw	r18,16(sp)
8112bcac:	dc400315 	stw	r17,12(sp)
8112bcb0:	1880020c 	andi	r2,r3,8
8112bcb4:	2821883a 	mov	r16,r5
8112bcb8:	202b883a 	mov	r21,r4
8112bcbc:	3029883a 	mov	r20,r6
8112bcc0:	10002726 	beq	r2,zero,8112bd60 <__sfvwrite_r+0xf0>
8112bcc4:	28800417 	ldw	r2,16(r5)
8112bcc8:	10002526 	beq	r2,zero,8112bd60 <__sfvwrite_r+0xf0>
8112bccc:	1880008c 	andi	r2,r3,2
8112bcd0:	a4400017 	ldw	r17,0(r20)
8112bcd4:	10002a26 	beq	r2,zero,8112bd80 <__sfvwrite_r+0x110>
8112bcd8:	05a00034 	movhi	r22,32768
8112bcdc:	0027883a 	mov	r19,zero
8112bce0:	0025883a 	mov	r18,zero
8112bce4:	b5bf0004 	addi	r22,r22,-1024
8112bce8:	980d883a 	mov	r6,r19
8112bcec:	a809883a 	mov	r4,r21
8112bcf0:	90004626 	beq	r18,zero,8112be0c <__sfvwrite_r+0x19c>
8112bcf4:	900f883a 	mov	r7,r18
8112bcf8:	b480022e 	bgeu	r22,r18,8112bd04 <__sfvwrite_r+0x94>
8112bcfc:	01e00034 	movhi	r7,32768
8112bd00:	39ff0004 	addi	r7,r7,-1024
8112bd04:	80800917 	ldw	r2,36(r16)
8112bd08:	81400717 	ldw	r5,28(r16)
8112bd0c:	103ee83a 	callr	r2
8112bd10:	0080570e 	bge	zero,r2,8112be70 <__sfvwrite_r+0x200>
8112bd14:	a0c00217 	ldw	r3,8(r20)
8112bd18:	98a7883a 	add	r19,r19,r2
8112bd1c:	90a5c83a 	sub	r18,r18,r2
8112bd20:	1885c83a 	sub	r2,r3,r2
8112bd24:	a0800215 	stw	r2,8(r20)
8112bd28:	103fef1e 	bne	r2,zero,8112bce8 <__reset+0xfb10bce8>
8112bd2c:	0005883a 	mov	r2,zero
8112bd30:	dfc00b17 	ldw	ra,44(sp)
8112bd34:	df000a17 	ldw	fp,40(sp)
8112bd38:	ddc00917 	ldw	r23,36(sp)
8112bd3c:	dd800817 	ldw	r22,32(sp)
8112bd40:	dd400717 	ldw	r21,28(sp)
8112bd44:	dd000617 	ldw	r20,24(sp)
8112bd48:	dcc00517 	ldw	r19,20(sp)
8112bd4c:	dc800417 	ldw	r18,16(sp)
8112bd50:	dc400317 	ldw	r17,12(sp)
8112bd54:	dc000217 	ldw	r16,8(sp)
8112bd58:	dec00c04 	addi	sp,sp,48
8112bd5c:	f800283a 	ret
8112bd60:	800b883a 	mov	r5,r16
8112bd64:	a809883a 	mov	r4,r21
8112bd68:	11294500 	call	81129450 <__swsetup_r>
8112bd6c:	1000eb1e 	bne	r2,zero,8112c11c <__sfvwrite_r+0x4ac>
8112bd70:	80c0030b 	ldhu	r3,12(r16)
8112bd74:	a4400017 	ldw	r17,0(r20)
8112bd78:	1880008c 	andi	r2,r3,2
8112bd7c:	103fd61e 	bne	r2,zero,8112bcd8 <__reset+0xfb10bcd8>
8112bd80:	1880004c 	andi	r2,r3,1
8112bd84:	10003f1e 	bne	r2,zero,8112be84 <__sfvwrite_r+0x214>
8112bd88:	0039883a 	mov	fp,zero
8112bd8c:	0025883a 	mov	r18,zero
8112bd90:	90001a26 	beq	r18,zero,8112bdfc <__sfvwrite_r+0x18c>
8112bd94:	1880800c 	andi	r2,r3,512
8112bd98:	84c00217 	ldw	r19,8(r16)
8112bd9c:	10002126 	beq	r2,zero,8112be24 <__sfvwrite_r+0x1b4>
8112bda0:	982f883a 	mov	r23,r19
8112bda4:	94c09336 	bltu	r18,r19,8112bff4 <__sfvwrite_r+0x384>
8112bda8:	1881200c 	andi	r2,r3,1152
8112bdac:	10009e1e 	bne	r2,zero,8112c028 <__sfvwrite_r+0x3b8>
8112bdb0:	81000017 	ldw	r4,0(r16)
8112bdb4:	b80d883a 	mov	r6,r23
8112bdb8:	e00b883a 	mov	r5,fp
8112bdbc:	112c7cc0 	call	8112c7cc <memmove>
8112bdc0:	80c00217 	ldw	r3,8(r16)
8112bdc4:	81000017 	ldw	r4,0(r16)
8112bdc8:	9005883a 	mov	r2,r18
8112bdcc:	1ce7c83a 	sub	r19,r3,r19
8112bdd0:	25cf883a 	add	r7,r4,r23
8112bdd4:	84c00215 	stw	r19,8(r16)
8112bdd8:	81c00015 	stw	r7,0(r16)
8112bddc:	a0c00217 	ldw	r3,8(r20)
8112bde0:	e0b9883a 	add	fp,fp,r2
8112bde4:	90a5c83a 	sub	r18,r18,r2
8112bde8:	18a7c83a 	sub	r19,r3,r2
8112bdec:	a4c00215 	stw	r19,8(r20)
8112bdf0:	983fce26 	beq	r19,zero,8112bd2c <__reset+0xfb10bd2c>
8112bdf4:	80c0030b 	ldhu	r3,12(r16)
8112bdf8:	903fe61e 	bne	r18,zero,8112bd94 <__reset+0xfb10bd94>
8112bdfc:	8f000017 	ldw	fp,0(r17)
8112be00:	8c800117 	ldw	r18,4(r17)
8112be04:	8c400204 	addi	r17,r17,8
8112be08:	003fe106 	br	8112bd90 <__reset+0xfb10bd90>
8112be0c:	8cc00017 	ldw	r19,0(r17)
8112be10:	8c800117 	ldw	r18,4(r17)
8112be14:	8c400204 	addi	r17,r17,8
8112be18:	003fb306 	br	8112bce8 <__reset+0xfb10bce8>
8112be1c:	0005883a 	mov	r2,zero
8112be20:	f800283a 	ret
8112be24:	81000017 	ldw	r4,0(r16)
8112be28:	80800417 	ldw	r2,16(r16)
8112be2c:	11005736 	bltu	r2,r4,8112bf8c <__sfvwrite_r+0x31c>
8112be30:	85c00517 	ldw	r23,20(r16)
8112be34:	95c05536 	bltu	r18,r23,8112bf8c <__sfvwrite_r+0x31c>
8112be38:	00a00034 	movhi	r2,32768
8112be3c:	10bfffc4 	addi	r2,r2,-1
8112be40:	9009883a 	mov	r4,r18
8112be44:	1480012e 	bgeu	r2,r18,8112be4c <__sfvwrite_r+0x1dc>
8112be48:	1009883a 	mov	r4,r2
8112be4c:	b80b883a 	mov	r5,r23
8112be50:	11348840 	call	81134884 <__divsi3>
8112be54:	15cf383a 	mul	r7,r2,r23
8112be58:	81400717 	ldw	r5,28(r16)
8112be5c:	80800917 	ldw	r2,36(r16)
8112be60:	e00d883a 	mov	r6,fp
8112be64:	a809883a 	mov	r4,r21
8112be68:	103ee83a 	callr	r2
8112be6c:	00bfdb16 	blt	zero,r2,8112bddc <__reset+0xfb10bddc>
8112be70:	8080030b 	ldhu	r2,12(r16)
8112be74:	10801014 	ori	r2,r2,64
8112be78:	8080030d 	sth	r2,12(r16)
8112be7c:	00bfffc4 	movi	r2,-1
8112be80:	003fab06 	br	8112bd30 <__reset+0xfb10bd30>
8112be84:	0027883a 	mov	r19,zero
8112be88:	0011883a 	mov	r8,zero
8112be8c:	0039883a 	mov	fp,zero
8112be90:	0025883a 	mov	r18,zero
8112be94:	90001f26 	beq	r18,zero,8112bf14 <__sfvwrite_r+0x2a4>
8112be98:	40005a26 	beq	r8,zero,8112c004 <__sfvwrite_r+0x394>
8112be9c:	982d883a 	mov	r22,r19
8112bea0:	94c0012e 	bgeu	r18,r19,8112bea8 <__sfvwrite_r+0x238>
8112bea4:	902d883a 	mov	r22,r18
8112bea8:	81000017 	ldw	r4,0(r16)
8112beac:	80800417 	ldw	r2,16(r16)
8112beb0:	b02f883a 	mov	r23,r22
8112beb4:	81c00517 	ldw	r7,20(r16)
8112beb8:	1100032e 	bgeu	r2,r4,8112bec8 <__sfvwrite_r+0x258>
8112bebc:	80c00217 	ldw	r3,8(r16)
8112bec0:	38c7883a 	add	r3,r7,r3
8112bec4:	1d801816 	blt	r3,r22,8112bf28 <__sfvwrite_r+0x2b8>
8112bec8:	b1c03e16 	blt	r22,r7,8112bfc4 <__sfvwrite_r+0x354>
8112becc:	80800917 	ldw	r2,36(r16)
8112bed0:	81400717 	ldw	r5,28(r16)
8112bed4:	e00d883a 	mov	r6,fp
8112bed8:	da000115 	stw	r8,4(sp)
8112bedc:	a809883a 	mov	r4,r21
8112bee0:	103ee83a 	callr	r2
8112bee4:	102f883a 	mov	r23,r2
8112bee8:	da000117 	ldw	r8,4(sp)
8112beec:	00bfe00e 	bge	zero,r2,8112be70 <__reset+0xfb10be70>
8112bef0:	9de7c83a 	sub	r19,r19,r23
8112bef4:	98001f26 	beq	r19,zero,8112bf74 <__sfvwrite_r+0x304>
8112bef8:	a0800217 	ldw	r2,8(r20)
8112befc:	e5f9883a 	add	fp,fp,r23
8112bf00:	95e5c83a 	sub	r18,r18,r23
8112bf04:	15efc83a 	sub	r23,r2,r23
8112bf08:	a5c00215 	stw	r23,8(r20)
8112bf0c:	b83f8726 	beq	r23,zero,8112bd2c <__reset+0xfb10bd2c>
8112bf10:	903fe11e 	bne	r18,zero,8112be98 <__reset+0xfb10be98>
8112bf14:	8f000017 	ldw	fp,0(r17)
8112bf18:	8c800117 	ldw	r18,4(r17)
8112bf1c:	0011883a 	mov	r8,zero
8112bf20:	8c400204 	addi	r17,r17,8
8112bf24:	003fdb06 	br	8112be94 <__reset+0xfb10be94>
8112bf28:	180d883a 	mov	r6,r3
8112bf2c:	e00b883a 	mov	r5,fp
8112bf30:	da000115 	stw	r8,4(sp)
8112bf34:	d8c00015 	stw	r3,0(sp)
8112bf38:	112c7cc0 	call	8112c7cc <memmove>
8112bf3c:	d8c00017 	ldw	r3,0(sp)
8112bf40:	80800017 	ldw	r2,0(r16)
8112bf44:	800b883a 	mov	r5,r16
8112bf48:	a809883a 	mov	r4,r21
8112bf4c:	10c5883a 	add	r2,r2,r3
8112bf50:	80800015 	stw	r2,0(r16)
8112bf54:	d8c00015 	stw	r3,0(sp)
8112bf58:	112b0c40 	call	8112b0c4 <_fflush_r>
8112bf5c:	d8c00017 	ldw	r3,0(sp)
8112bf60:	da000117 	ldw	r8,4(sp)
8112bf64:	103fc21e 	bne	r2,zero,8112be70 <__reset+0xfb10be70>
8112bf68:	182f883a 	mov	r23,r3
8112bf6c:	9de7c83a 	sub	r19,r19,r23
8112bf70:	983fe11e 	bne	r19,zero,8112bef8 <__reset+0xfb10bef8>
8112bf74:	800b883a 	mov	r5,r16
8112bf78:	a809883a 	mov	r4,r21
8112bf7c:	112b0c40 	call	8112b0c4 <_fflush_r>
8112bf80:	103fbb1e 	bne	r2,zero,8112be70 <__reset+0xfb10be70>
8112bf84:	0011883a 	mov	r8,zero
8112bf88:	003fdb06 	br	8112bef8 <__reset+0xfb10bef8>
8112bf8c:	94c0012e 	bgeu	r18,r19,8112bf94 <__sfvwrite_r+0x324>
8112bf90:	9027883a 	mov	r19,r18
8112bf94:	980d883a 	mov	r6,r19
8112bf98:	e00b883a 	mov	r5,fp
8112bf9c:	112c7cc0 	call	8112c7cc <memmove>
8112bfa0:	80800217 	ldw	r2,8(r16)
8112bfa4:	80c00017 	ldw	r3,0(r16)
8112bfa8:	14c5c83a 	sub	r2,r2,r19
8112bfac:	1cc7883a 	add	r3,r3,r19
8112bfb0:	80800215 	stw	r2,8(r16)
8112bfb4:	80c00015 	stw	r3,0(r16)
8112bfb8:	10004326 	beq	r2,zero,8112c0c8 <__sfvwrite_r+0x458>
8112bfbc:	9805883a 	mov	r2,r19
8112bfc0:	003f8606 	br	8112bddc <__reset+0xfb10bddc>
8112bfc4:	b00d883a 	mov	r6,r22
8112bfc8:	e00b883a 	mov	r5,fp
8112bfcc:	da000115 	stw	r8,4(sp)
8112bfd0:	112c7cc0 	call	8112c7cc <memmove>
8112bfd4:	80800217 	ldw	r2,8(r16)
8112bfd8:	80c00017 	ldw	r3,0(r16)
8112bfdc:	da000117 	ldw	r8,4(sp)
8112bfe0:	1585c83a 	sub	r2,r2,r22
8112bfe4:	1dad883a 	add	r22,r3,r22
8112bfe8:	80800215 	stw	r2,8(r16)
8112bfec:	85800015 	stw	r22,0(r16)
8112bff0:	003fbf06 	br	8112bef0 <__reset+0xfb10bef0>
8112bff4:	81000017 	ldw	r4,0(r16)
8112bff8:	9027883a 	mov	r19,r18
8112bffc:	902f883a 	mov	r23,r18
8112c000:	003f6c06 	br	8112bdb4 <__reset+0xfb10bdb4>
8112c004:	900d883a 	mov	r6,r18
8112c008:	01400284 	movi	r5,10
8112c00c:	e009883a 	mov	r4,fp
8112c010:	112c6e80 	call	8112c6e8 <memchr>
8112c014:	10003e26 	beq	r2,zero,8112c110 <__sfvwrite_r+0x4a0>
8112c018:	10800044 	addi	r2,r2,1
8112c01c:	1727c83a 	sub	r19,r2,fp
8112c020:	02000044 	movi	r8,1
8112c024:	003f9d06 	br	8112be9c <__reset+0xfb10be9c>
8112c028:	80800517 	ldw	r2,20(r16)
8112c02c:	81400417 	ldw	r5,16(r16)
8112c030:	81c00017 	ldw	r7,0(r16)
8112c034:	10a7883a 	add	r19,r2,r2
8112c038:	9885883a 	add	r2,r19,r2
8112c03c:	1026d7fa 	srli	r19,r2,31
8112c040:	396dc83a 	sub	r22,r7,r5
8112c044:	b1000044 	addi	r4,r22,1
8112c048:	9885883a 	add	r2,r19,r2
8112c04c:	1027d07a 	srai	r19,r2,1
8112c050:	2485883a 	add	r2,r4,r18
8112c054:	980d883a 	mov	r6,r19
8112c058:	9880022e 	bgeu	r19,r2,8112c064 <__sfvwrite_r+0x3f4>
8112c05c:	1027883a 	mov	r19,r2
8112c060:	100d883a 	mov	r6,r2
8112c064:	18c1000c 	andi	r3,r3,1024
8112c068:	18001c26 	beq	r3,zero,8112c0dc <__sfvwrite_r+0x46c>
8112c06c:	300b883a 	mov	r5,r6
8112c070:	a809883a 	mov	r4,r21
8112c074:	1121be00 	call	81121be0 <_malloc_r>
8112c078:	102f883a 	mov	r23,r2
8112c07c:	10002926 	beq	r2,zero,8112c124 <__sfvwrite_r+0x4b4>
8112c080:	81400417 	ldw	r5,16(r16)
8112c084:	b00d883a 	mov	r6,r22
8112c088:	1009883a 	mov	r4,r2
8112c08c:	11223f40 	call	811223f4 <memcpy>
8112c090:	8080030b 	ldhu	r2,12(r16)
8112c094:	00fedfc4 	movi	r3,-1153
8112c098:	10c4703a 	and	r2,r2,r3
8112c09c:	10802014 	ori	r2,r2,128
8112c0a0:	8080030d 	sth	r2,12(r16)
8112c0a4:	bd89883a 	add	r4,r23,r22
8112c0a8:	9d8fc83a 	sub	r7,r19,r22
8112c0ac:	85c00415 	stw	r23,16(r16)
8112c0b0:	84c00515 	stw	r19,20(r16)
8112c0b4:	81000015 	stw	r4,0(r16)
8112c0b8:	9027883a 	mov	r19,r18
8112c0bc:	81c00215 	stw	r7,8(r16)
8112c0c0:	902f883a 	mov	r23,r18
8112c0c4:	003f3b06 	br	8112bdb4 <__reset+0xfb10bdb4>
8112c0c8:	800b883a 	mov	r5,r16
8112c0cc:	a809883a 	mov	r4,r21
8112c0d0:	112b0c40 	call	8112b0c4 <_fflush_r>
8112c0d4:	103fb926 	beq	r2,zero,8112bfbc <__reset+0xfb10bfbc>
8112c0d8:	003f6506 	br	8112be70 <__reset+0xfb10be70>
8112c0dc:	a809883a 	mov	r4,r21
8112c0e0:	112d9ec0 	call	8112d9ec <_realloc_r>
8112c0e4:	102f883a 	mov	r23,r2
8112c0e8:	103fee1e 	bne	r2,zero,8112c0a4 <__reset+0xfb10c0a4>
8112c0ec:	81400417 	ldw	r5,16(r16)
8112c0f0:	a809883a 	mov	r4,r21
8112c0f4:	112b9580 	call	8112b958 <_free_r>
8112c0f8:	8080030b 	ldhu	r2,12(r16)
8112c0fc:	00ffdfc4 	movi	r3,-129
8112c100:	1884703a 	and	r2,r3,r2
8112c104:	00c00304 	movi	r3,12
8112c108:	a8c00015 	stw	r3,0(r21)
8112c10c:	003f5906 	br	8112be74 <__reset+0xfb10be74>
8112c110:	94c00044 	addi	r19,r18,1
8112c114:	02000044 	movi	r8,1
8112c118:	003f6006 	br	8112be9c <__reset+0xfb10be9c>
8112c11c:	00bfffc4 	movi	r2,-1
8112c120:	003f0306 	br	8112bd30 <__reset+0xfb10bd30>
8112c124:	00800304 	movi	r2,12
8112c128:	a8800015 	stw	r2,0(r21)
8112c12c:	8080030b 	ldhu	r2,12(r16)
8112c130:	003f5006 	br	8112be74 <__reset+0xfb10be74>

8112c134 <_fwalk>:
8112c134:	defff704 	addi	sp,sp,-36
8112c138:	de00012e 	bgeu	sp,et,8112c140 <_fwalk+0xc>
8112c13c:	003b68fa 	trap	3
8112c140:	dd000415 	stw	r20,16(sp)
8112c144:	dfc00815 	stw	ra,32(sp)
8112c148:	ddc00715 	stw	r23,28(sp)
8112c14c:	dd800615 	stw	r22,24(sp)
8112c150:	dd400515 	stw	r21,20(sp)
8112c154:	dcc00315 	stw	r19,12(sp)
8112c158:	dc800215 	stw	r18,8(sp)
8112c15c:	dc400115 	stw	r17,4(sp)
8112c160:	dc000015 	stw	r16,0(sp)
8112c164:	2500b804 	addi	r20,r4,736
8112c168:	a0002326 	beq	r20,zero,8112c1f8 <_fwalk+0xc4>
8112c16c:	282b883a 	mov	r21,r5
8112c170:	002f883a 	mov	r23,zero
8112c174:	05800044 	movi	r22,1
8112c178:	04ffffc4 	movi	r19,-1
8112c17c:	a4400117 	ldw	r17,4(r20)
8112c180:	a4800217 	ldw	r18,8(r20)
8112c184:	8c7fffc4 	addi	r17,r17,-1
8112c188:	88000d16 	blt	r17,zero,8112c1c0 <_fwalk+0x8c>
8112c18c:	94000304 	addi	r16,r18,12
8112c190:	94800384 	addi	r18,r18,14
8112c194:	8080000b 	ldhu	r2,0(r16)
8112c198:	8c7fffc4 	addi	r17,r17,-1
8112c19c:	813ffd04 	addi	r4,r16,-12
8112c1a0:	b080042e 	bgeu	r22,r2,8112c1b4 <_fwalk+0x80>
8112c1a4:	9080000f 	ldh	r2,0(r18)
8112c1a8:	14c00226 	beq	r2,r19,8112c1b4 <_fwalk+0x80>
8112c1ac:	a83ee83a 	callr	r21
8112c1b0:	b8aeb03a 	or	r23,r23,r2
8112c1b4:	84001a04 	addi	r16,r16,104
8112c1b8:	94801a04 	addi	r18,r18,104
8112c1bc:	8cfff51e 	bne	r17,r19,8112c194 <__reset+0xfb10c194>
8112c1c0:	a5000017 	ldw	r20,0(r20)
8112c1c4:	a03fed1e 	bne	r20,zero,8112c17c <__reset+0xfb10c17c>
8112c1c8:	b805883a 	mov	r2,r23
8112c1cc:	dfc00817 	ldw	ra,32(sp)
8112c1d0:	ddc00717 	ldw	r23,28(sp)
8112c1d4:	dd800617 	ldw	r22,24(sp)
8112c1d8:	dd400517 	ldw	r21,20(sp)
8112c1dc:	dd000417 	ldw	r20,16(sp)
8112c1e0:	dcc00317 	ldw	r19,12(sp)
8112c1e4:	dc800217 	ldw	r18,8(sp)
8112c1e8:	dc400117 	ldw	r17,4(sp)
8112c1ec:	dc000017 	ldw	r16,0(sp)
8112c1f0:	dec00904 	addi	sp,sp,36
8112c1f4:	f800283a 	ret
8112c1f8:	002f883a 	mov	r23,zero
8112c1fc:	003ff206 	br	8112c1c8 <__reset+0xfb10c1c8>

8112c200 <_fwalk_reent>:
8112c200:	defff704 	addi	sp,sp,-36
8112c204:	de00012e 	bgeu	sp,et,8112c20c <_fwalk_reent+0xc>
8112c208:	003b68fa 	trap	3
8112c20c:	dd000415 	stw	r20,16(sp)
8112c210:	dfc00815 	stw	ra,32(sp)
8112c214:	ddc00715 	stw	r23,28(sp)
8112c218:	dd800615 	stw	r22,24(sp)
8112c21c:	dd400515 	stw	r21,20(sp)
8112c220:	dcc00315 	stw	r19,12(sp)
8112c224:	dc800215 	stw	r18,8(sp)
8112c228:	dc400115 	stw	r17,4(sp)
8112c22c:	dc000015 	stw	r16,0(sp)
8112c230:	2500b804 	addi	r20,r4,736
8112c234:	a0002326 	beq	r20,zero,8112c2c4 <_fwalk_reent+0xc4>
8112c238:	282b883a 	mov	r21,r5
8112c23c:	2027883a 	mov	r19,r4
8112c240:	002f883a 	mov	r23,zero
8112c244:	05800044 	movi	r22,1
8112c248:	04bfffc4 	movi	r18,-1
8112c24c:	a4400117 	ldw	r17,4(r20)
8112c250:	a4000217 	ldw	r16,8(r20)
8112c254:	8c7fffc4 	addi	r17,r17,-1
8112c258:	88000c16 	blt	r17,zero,8112c28c <_fwalk_reent+0x8c>
8112c25c:	84000304 	addi	r16,r16,12
8112c260:	8080000b 	ldhu	r2,0(r16)
8112c264:	8c7fffc4 	addi	r17,r17,-1
8112c268:	817ffd04 	addi	r5,r16,-12
8112c26c:	b080052e 	bgeu	r22,r2,8112c284 <_fwalk_reent+0x84>
8112c270:	8080008f 	ldh	r2,2(r16)
8112c274:	9809883a 	mov	r4,r19
8112c278:	14800226 	beq	r2,r18,8112c284 <_fwalk_reent+0x84>
8112c27c:	a83ee83a 	callr	r21
8112c280:	b8aeb03a 	or	r23,r23,r2
8112c284:	84001a04 	addi	r16,r16,104
8112c288:	8cbff51e 	bne	r17,r18,8112c260 <__reset+0xfb10c260>
8112c28c:	a5000017 	ldw	r20,0(r20)
8112c290:	a03fee1e 	bne	r20,zero,8112c24c <__reset+0xfb10c24c>
8112c294:	b805883a 	mov	r2,r23
8112c298:	dfc00817 	ldw	ra,32(sp)
8112c29c:	ddc00717 	ldw	r23,28(sp)
8112c2a0:	dd800617 	ldw	r22,24(sp)
8112c2a4:	dd400517 	ldw	r21,20(sp)
8112c2a8:	dd000417 	ldw	r20,16(sp)
8112c2ac:	dcc00317 	ldw	r19,12(sp)
8112c2b0:	dc800217 	ldw	r18,8(sp)
8112c2b4:	dc400117 	ldw	r17,4(sp)
8112c2b8:	dc000017 	ldw	r16,0(sp)
8112c2bc:	dec00904 	addi	sp,sp,36
8112c2c0:	f800283a 	ret
8112c2c4:	002f883a 	mov	r23,zero
8112c2c8:	003ff206 	br	8112c294 <__reset+0xfb10c294>

8112c2cc <_isatty_r>:
8112c2cc:	defffd04 	addi	sp,sp,-12
8112c2d0:	de00012e 	bgeu	sp,et,8112c2d8 <_isatty_r+0xc>
8112c2d4:	003b68fa 	trap	3
8112c2d8:	dc000015 	stw	r16,0(sp)
8112c2dc:	04204574 	movhi	r16,33045
8112c2e0:	dc400115 	stw	r17,4(sp)
8112c2e4:	840c6004 	addi	r16,r16,12672
8112c2e8:	2023883a 	mov	r17,r4
8112c2ec:	2809883a 	mov	r4,r5
8112c2f0:	dfc00215 	stw	ra,8(sp)
8112c2f4:	80000015 	stw	zero,0(r16)
8112c2f8:	11365740 	call	81136574 <isatty>
8112c2fc:	00ffffc4 	movi	r3,-1
8112c300:	10c00526 	beq	r2,r3,8112c318 <_isatty_r+0x4c>
8112c304:	dfc00217 	ldw	ra,8(sp)
8112c308:	dc400117 	ldw	r17,4(sp)
8112c30c:	dc000017 	ldw	r16,0(sp)
8112c310:	dec00304 	addi	sp,sp,12
8112c314:	f800283a 	ret
8112c318:	80c00017 	ldw	r3,0(r16)
8112c31c:	183ff926 	beq	r3,zero,8112c304 <__reset+0xfb10c304>
8112c320:	88c00015 	stw	r3,0(r17)
8112c324:	003ff706 	br	8112c304 <__reset+0xfb10c304>

8112c328 <iswspace>:
8112c328:	00803fc4 	movi	r2,255
8112c32c:	11000836 	bltu	r2,r4,8112c350 <iswspace+0x28>
8112c330:	00a04574 	movhi	r2,33045
8112c334:	108beb04 	addi	r2,r2,12204
8112c338:	10800017 	ldw	r2,0(r2)
8112c33c:	1109883a 	add	r4,r2,r4
8112c340:	20800043 	ldbu	r2,1(r4)
8112c344:	1080020c 	andi	r2,r2,8
8112c348:	10803fcc 	andi	r2,r2,255
8112c34c:	f800283a 	ret
8112c350:	0005883a 	mov	r2,zero
8112c354:	f800283a 	ret

8112c358 <_setlocale_r>:
8112c358:	30001d26 	beq	r6,zero,8112c3d0 <_setlocale_r+0x78>
8112c35c:	01604574 	movhi	r5,33045
8112c360:	defffe04 	addi	sp,sp,-8
8112c364:	29424404 	addi	r5,r5,2320
8112c368:	3009883a 	mov	r4,r6
8112c36c:	de00012e 	bgeu	sp,et,8112c374 <_setlocale_r+0x1c>
8112c370:	003b68fa 	trap	3
8112c374:	dc000015 	stw	r16,0(sp)
8112c378:	dfc00115 	stw	ra,4(sp)
8112c37c:	3021883a 	mov	r16,r6
8112c380:	112e0a40 	call	8112e0a4 <strcmp>
8112c384:	1000061e 	bne	r2,zero,8112c3a0 <_setlocale_r+0x48>
8112c388:	00a04574 	movhi	r2,33045
8112c38c:	10821304 	addi	r2,r2,2124
8112c390:	dfc00117 	ldw	ra,4(sp)
8112c394:	dc000017 	ldw	r16,0(sp)
8112c398:	dec00204 	addi	sp,sp,8
8112c39c:	f800283a 	ret
8112c3a0:	01604574 	movhi	r5,33045
8112c3a4:	29421304 	addi	r5,r5,2124
8112c3a8:	8009883a 	mov	r4,r16
8112c3ac:	112e0a40 	call	8112e0a4 <strcmp>
8112c3b0:	103ff526 	beq	r2,zero,8112c388 <__reset+0xfb10c388>
8112c3b4:	01604574 	movhi	r5,33045
8112c3b8:	29421d04 	addi	r5,r5,2164
8112c3bc:	8009883a 	mov	r4,r16
8112c3c0:	112e0a40 	call	8112e0a4 <strcmp>
8112c3c4:	103ff026 	beq	r2,zero,8112c388 <__reset+0xfb10c388>
8112c3c8:	0005883a 	mov	r2,zero
8112c3cc:	003ff006 	br	8112c390 <__reset+0xfb10c390>
8112c3d0:	00a04574 	movhi	r2,33045
8112c3d4:	10821304 	addi	r2,r2,2124
8112c3d8:	f800283a 	ret

8112c3dc <__locale_charset>:
8112c3dc:	00a04574 	movhi	r2,33045
8112c3e0:	1086b504 	addi	r2,r2,6868
8112c3e4:	f800283a 	ret

8112c3e8 <__locale_mb_cur_max>:
8112c3e8:	00a04574 	movhi	r2,33045
8112c3ec:	108bf004 	addi	r2,r2,12224
8112c3f0:	10800017 	ldw	r2,0(r2)
8112c3f4:	f800283a 	ret

8112c3f8 <__locale_msgcharset>:
8112c3f8:	00a04574 	movhi	r2,33045
8112c3fc:	1086ad04 	addi	r2,r2,6836
8112c400:	f800283a 	ret

8112c404 <__locale_cjk_lang>:
8112c404:	0005883a 	mov	r2,zero
8112c408:	f800283a 	ret

8112c40c <_localeconv_r>:
8112c40c:	00a04574 	movhi	r2,33045
8112c410:	1086bd04 	addi	r2,r2,6900
8112c414:	f800283a 	ret

8112c418 <setlocale>:
8112c418:	00a04574 	movhi	r2,33045
8112c41c:	108bed04 	addi	r2,r2,12212
8112c420:	280d883a 	mov	r6,r5
8112c424:	200b883a 	mov	r5,r4
8112c428:	11000017 	ldw	r4,0(r2)
8112c42c:	112c3581 	jmpi	8112c358 <_setlocale_r>

8112c430 <localeconv>:
8112c430:	00a04574 	movhi	r2,33045
8112c434:	1086bd04 	addi	r2,r2,6900
8112c438:	f800283a 	ret

8112c43c <_lseek_r>:
8112c43c:	defffd04 	addi	sp,sp,-12
8112c440:	de00012e 	bgeu	sp,et,8112c448 <_lseek_r+0xc>
8112c444:	003b68fa 	trap	3
8112c448:	2805883a 	mov	r2,r5
8112c44c:	dc000015 	stw	r16,0(sp)
8112c450:	04204574 	movhi	r16,33045
8112c454:	dc400115 	stw	r17,4(sp)
8112c458:	300b883a 	mov	r5,r6
8112c45c:	840c6004 	addi	r16,r16,12672
8112c460:	2023883a 	mov	r17,r4
8112c464:	380d883a 	mov	r6,r7
8112c468:	1009883a 	mov	r4,r2
8112c46c:	dfc00215 	stw	ra,8(sp)
8112c470:	80000015 	stw	zero,0(r16)
8112c474:	11371700 	call	81137170 <lseek>
8112c478:	00ffffc4 	movi	r3,-1
8112c47c:	10c00526 	beq	r2,r3,8112c494 <_lseek_r+0x58>
8112c480:	dfc00217 	ldw	ra,8(sp)
8112c484:	dc400117 	ldw	r17,4(sp)
8112c488:	dc000017 	ldw	r16,0(sp)
8112c48c:	dec00304 	addi	sp,sp,12
8112c490:	f800283a 	ret
8112c494:	80c00017 	ldw	r3,0(r16)
8112c498:	183ff926 	beq	r3,zero,8112c480 <__reset+0xfb10c480>
8112c49c:	88c00015 	stw	r3,0(r17)
8112c4a0:	003ff706 	br	8112c480 <__reset+0xfb10c480>

8112c4a4 <_mbrtowc_r>:
8112c4a4:	defff704 	addi	sp,sp,-36
8112c4a8:	00a04574 	movhi	r2,33045
8112c4ac:	de00012e 	bgeu	sp,et,8112c4b4 <_mbrtowc_r+0x10>
8112c4b0:	003b68fa 	trap	3
8112c4b4:	108bf104 	addi	r2,r2,12228
8112c4b8:	dc800715 	stw	r18,28(sp)
8112c4bc:	dc400615 	stw	r17,24(sp)
8112c4c0:	dc000515 	stw	r16,20(sp)
8112c4c4:	dfc00815 	stw	ra,32(sp)
8112c4c8:	2021883a 	mov	r16,r4
8112c4cc:	dc400917 	ldw	r17,36(sp)
8112c4d0:	14800017 	ldw	r18,0(r2)
8112c4d4:	30001626 	beq	r6,zero,8112c530 <_mbrtowc_r+0x8c>
8112c4d8:	d9400215 	stw	r5,8(sp)
8112c4dc:	d9800315 	stw	r6,12(sp)
8112c4e0:	d9c00415 	stw	r7,16(sp)
8112c4e4:	112c3dc0 	call	8112c3dc <__locale_charset>
8112c4e8:	d9c00417 	ldw	r7,16(sp)
8112c4ec:	d9800317 	ldw	r6,12(sp)
8112c4f0:	d9400217 	ldw	r5,8(sp)
8112c4f4:	d8800015 	stw	r2,0(sp)
8112c4f8:	dc400115 	stw	r17,4(sp)
8112c4fc:	8009883a 	mov	r4,r16
8112c500:	903ee83a 	callr	r18
8112c504:	00ffffc4 	movi	r3,-1
8112c508:	10c0031e 	bne	r2,r3,8112c518 <_mbrtowc_r+0x74>
8112c50c:	88000015 	stw	zero,0(r17)
8112c510:	00c02284 	movi	r3,138
8112c514:	80c00015 	stw	r3,0(r16)
8112c518:	dfc00817 	ldw	ra,32(sp)
8112c51c:	dc800717 	ldw	r18,28(sp)
8112c520:	dc400617 	ldw	r17,24(sp)
8112c524:	dc000517 	ldw	r16,20(sp)
8112c528:	dec00904 	addi	sp,sp,36
8112c52c:	f800283a 	ret
8112c530:	112c3dc0 	call	8112c3dc <__locale_charset>
8112c534:	01a04574 	movhi	r6,33045
8112c538:	31821d04 	addi	r6,r6,2164
8112c53c:	dc400115 	stw	r17,4(sp)
8112c540:	d8800015 	stw	r2,0(sp)
8112c544:	01c00044 	movi	r7,1
8112c548:	000b883a 	mov	r5,zero
8112c54c:	8009883a 	mov	r4,r16
8112c550:	903ee83a 	callr	r18
8112c554:	003feb06 	br	8112c504 <__reset+0xfb10c504>

8112c558 <mbrtowc>:
8112c558:	defff704 	addi	sp,sp,-36
8112c55c:	00a04574 	movhi	r2,33045
8112c560:	de00012e 	bgeu	sp,et,8112c568 <mbrtowc+0x10>
8112c564:	003b68fa 	trap	3
8112c568:	108bed04 	addi	r2,r2,12212
8112c56c:	dc800415 	stw	r18,16(sp)
8112c570:	dc400315 	stw	r17,12(sp)
8112c574:	dfc00815 	stw	ra,32(sp)
8112c578:	dd400715 	stw	r21,28(sp)
8112c57c:	dd000615 	stw	r20,24(sp)
8112c580:	dcc00515 	stw	r19,20(sp)
8112c584:	dc000215 	stw	r16,8(sp)
8112c588:	3825883a 	mov	r18,r7
8112c58c:	14400017 	ldw	r17,0(r2)
8112c590:	28001c26 	beq	r5,zero,8112c604 <mbrtowc+0xac>
8112c594:	00a04574 	movhi	r2,33045
8112c598:	108bf104 	addi	r2,r2,12228
8112c59c:	15400017 	ldw	r21,0(r2)
8112c5a0:	2821883a 	mov	r16,r5
8112c5a4:	2027883a 	mov	r19,r4
8112c5a8:	3029883a 	mov	r20,r6
8112c5ac:	112c3dc0 	call	8112c3dc <__locale_charset>
8112c5b0:	d8800015 	stw	r2,0(sp)
8112c5b4:	dc800115 	stw	r18,4(sp)
8112c5b8:	a00f883a 	mov	r7,r20
8112c5bc:	800d883a 	mov	r6,r16
8112c5c0:	980b883a 	mov	r5,r19
8112c5c4:	8809883a 	mov	r4,r17
8112c5c8:	a83ee83a 	callr	r21
8112c5cc:	00ffffc4 	movi	r3,-1
8112c5d0:	10c0031e 	bne	r2,r3,8112c5e0 <mbrtowc+0x88>
8112c5d4:	90000015 	stw	zero,0(r18)
8112c5d8:	00c02284 	movi	r3,138
8112c5dc:	88c00015 	stw	r3,0(r17)
8112c5e0:	dfc00817 	ldw	ra,32(sp)
8112c5e4:	dd400717 	ldw	r21,28(sp)
8112c5e8:	dd000617 	ldw	r20,24(sp)
8112c5ec:	dcc00517 	ldw	r19,20(sp)
8112c5f0:	dc800417 	ldw	r18,16(sp)
8112c5f4:	dc400317 	ldw	r17,12(sp)
8112c5f8:	dc000217 	ldw	r16,8(sp)
8112c5fc:	dec00904 	addi	sp,sp,36
8112c600:	f800283a 	ret
8112c604:	00a04574 	movhi	r2,33045
8112c608:	108bf104 	addi	r2,r2,12228
8112c60c:	14000017 	ldw	r16,0(r2)
8112c610:	112c3dc0 	call	8112c3dc <__locale_charset>
8112c614:	01a04574 	movhi	r6,33045
8112c618:	31821d04 	addi	r6,r6,2164
8112c61c:	dc800115 	stw	r18,4(sp)
8112c620:	d8800015 	stw	r2,0(sp)
8112c624:	01c00044 	movi	r7,1
8112c628:	000b883a 	mov	r5,zero
8112c62c:	8809883a 	mov	r4,r17
8112c630:	803ee83a 	callr	r16
8112c634:	003fe506 	br	8112c5cc <__reset+0xfb10c5cc>

8112c638 <__ascii_mbtowc>:
8112c638:	deffff04 	addi	sp,sp,-4
8112c63c:	de00012e 	bgeu	sp,et,8112c644 <__ascii_mbtowc+0xc>
8112c640:	003b68fa 	trap	3
8112c644:	28000826 	beq	r5,zero,8112c668 <__ascii_mbtowc+0x30>
8112c648:	30000926 	beq	r6,zero,8112c670 <__ascii_mbtowc+0x38>
8112c64c:	38000b26 	beq	r7,zero,8112c67c <__ascii_mbtowc+0x44>
8112c650:	30800003 	ldbu	r2,0(r6)
8112c654:	28800015 	stw	r2,0(r5)
8112c658:	30800003 	ldbu	r2,0(r6)
8112c65c:	1004c03a 	cmpne	r2,r2,zero
8112c660:	dec00104 	addi	sp,sp,4
8112c664:	f800283a 	ret
8112c668:	d80b883a 	mov	r5,sp
8112c66c:	303ff71e 	bne	r6,zero,8112c64c <__reset+0xfb10c64c>
8112c670:	0005883a 	mov	r2,zero
8112c674:	dec00104 	addi	sp,sp,4
8112c678:	f800283a 	ret
8112c67c:	00bfff84 	movi	r2,-2
8112c680:	003ff706 	br	8112c660 <__reset+0xfb10c660>

8112c684 <_mbtowc_r>:
8112c684:	00a04574 	movhi	r2,33045
8112c688:	defff804 	addi	sp,sp,-32
8112c68c:	108bf104 	addi	r2,r2,12228
8112c690:	de00012e 	bgeu	sp,et,8112c698 <_mbtowc_r+0x14>
8112c694:	003b68fa 	trap	3
8112c698:	dfc00715 	stw	ra,28(sp)
8112c69c:	dc000615 	stw	r16,24(sp)
8112c6a0:	14000017 	ldw	r16,0(r2)
8112c6a4:	d9000215 	stw	r4,8(sp)
8112c6a8:	d9400315 	stw	r5,12(sp)
8112c6ac:	d9800415 	stw	r6,16(sp)
8112c6b0:	d9c00515 	stw	r7,20(sp)
8112c6b4:	112c3dc0 	call	8112c3dc <__locale_charset>
8112c6b8:	d8800015 	stw	r2,0(sp)
8112c6bc:	d8800817 	ldw	r2,32(sp)
8112c6c0:	d9c00517 	ldw	r7,20(sp)
8112c6c4:	d9800417 	ldw	r6,16(sp)
8112c6c8:	d9400317 	ldw	r5,12(sp)
8112c6cc:	d9000217 	ldw	r4,8(sp)
8112c6d0:	d8800115 	stw	r2,4(sp)
8112c6d4:	803ee83a 	callr	r16
8112c6d8:	dfc00717 	ldw	ra,28(sp)
8112c6dc:	dc000617 	ldw	r16,24(sp)
8112c6e0:	dec00804 	addi	sp,sp,32
8112c6e4:	f800283a 	ret

8112c6e8 <memchr>:
8112c6e8:	208000cc 	andi	r2,r4,3
8112c6ec:	280f883a 	mov	r7,r5
8112c6f0:	10003426 	beq	r2,zero,8112c7c4 <memchr+0xdc>
8112c6f4:	30bfffc4 	addi	r2,r6,-1
8112c6f8:	30001a26 	beq	r6,zero,8112c764 <memchr+0x7c>
8112c6fc:	20c00003 	ldbu	r3,0(r4)
8112c700:	29803fcc 	andi	r6,r5,255
8112c704:	30c0051e 	bne	r6,r3,8112c71c <memchr+0x34>
8112c708:	00001806 	br	8112c76c <memchr+0x84>
8112c70c:	10001526 	beq	r2,zero,8112c764 <memchr+0x7c>
8112c710:	20c00003 	ldbu	r3,0(r4)
8112c714:	10bfffc4 	addi	r2,r2,-1
8112c718:	30c01426 	beq	r6,r3,8112c76c <memchr+0x84>
8112c71c:	21000044 	addi	r4,r4,1
8112c720:	20c000cc 	andi	r3,r4,3
8112c724:	183ff91e 	bne	r3,zero,8112c70c <__reset+0xfb10c70c>
8112c728:	020000c4 	movi	r8,3
8112c72c:	40801136 	bltu	r8,r2,8112c774 <memchr+0x8c>
8112c730:	10000c26 	beq	r2,zero,8112c764 <memchr+0x7c>
8112c734:	20c00003 	ldbu	r3,0(r4)
8112c738:	29403fcc 	andi	r5,r5,255
8112c73c:	28c00b26 	beq	r5,r3,8112c76c <memchr+0x84>
8112c740:	20c00044 	addi	r3,r4,1
8112c744:	39803fcc 	andi	r6,r7,255
8112c748:	2089883a 	add	r4,r4,r2
8112c74c:	00000306 	br	8112c75c <memchr+0x74>
8112c750:	18c00044 	addi	r3,r3,1
8112c754:	197fffc3 	ldbu	r5,-1(r3)
8112c758:	31400526 	beq	r6,r5,8112c770 <memchr+0x88>
8112c75c:	1805883a 	mov	r2,r3
8112c760:	20fffb1e 	bne	r4,r3,8112c750 <__reset+0xfb10c750>
8112c764:	0005883a 	mov	r2,zero
8112c768:	f800283a 	ret
8112c76c:	2005883a 	mov	r2,r4
8112c770:	f800283a 	ret
8112c774:	28c03fcc 	andi	r3,r5,255
8112c778:	1812923a 	slli	r9,r3,8
8112c77c:	02ffbff4 	movhi	r11,65279
8112c780:	02a02074 	movhi	r10,32897
8112c784:	48d2b03a 	or	r9,r9,r3
8112c788:	4806943a 	slli	r3,r9,16
8112c78c:	5affbfc4 	addi	r11,r11,-257
8112c790:	52a02004 	addi	r10,r10,-32640
8112c794:	48d2b03a 	or	r9,r9,r3
8112c798:	20c00017 	ldw	r3,0(r4)
8112c79c:	48c6f03a 	xor	r3,r9,r3
8112c7a0:	1acd883a 	add	r6,r3,r11
8112c7a4:	00c6303a 	nor	r3,zero,r3
8112c7a8:	30c6703a 	and	r3,r6,r3
8112c7ac:	1a86703a 	and	r3,r3,r10
8112c7b0:	183fe01e 	bne	r3,zero,8112c734 <__reset+0xfb10c734>
8112c7b4:	10bfff04 	addi	r2,r2,-4
8112c7b8:	21000104 	addi	r4,r4,4
8112c7bc:	40bff636 	bltu	r8,r2,8112c798 <__reset+0xfb10c798>
8112c7c0:	003fdb06 	br	8112c730 <__reset+0xfb10c730>
8112c7c4:	3005883a 	mov	r2,r6
8112c7c8:	003fd706 	br	8112c728 <__reset+0xfb10c728>

8112c7cc <memmove>:
8112c7cc:	2005883a 	mov	r2,r4
8112c7d0:	29000b2e 	bgeu	r5,r4,8112c800 <memmove+0x34>
8112c7d4:	298f883a 	add	r7,r5,r6
8112c7d8:	21c0092e 	bgeu	r4,r7,8112c800 <memmove+0x34>
8112c7dc:	2187883a 	add	r3,r4,r6
8112c7e0:	198bc83a 	sub	r5,r3,r6
8112c7e4:	30004826 	beq	r6,zero,8112c908 <memmove+0x13c>
8112c7e8:	39ffffc4 	addi	r7,r7,-1
8112c7ec:	39000003 	ldbu	r4,0(r7)
8112c7f0:	18ffffc4 	addi	r3,r3,-1
8112c7f4:	19000005 	stb	r4,0(r3)
8112c7f8:	28fffb1e 	bne	r5,r3,8112c7e8 <__reset+0xfb10c7e8>
8112c7fc:	f800283a 	ret
8112c800:	00c003c4 	movi	r3,15
8112c804:	1980412e 	bgeu	r3,r6,8112c90c <memmove+0x140>
8112c808:	2886b03a 	or	r3,r5,r2
8112c80c:	18c000cc 	andi	r3,r3,3
8112c810:	1800401e 	bne	r3,zero,8112c914 <memmove+0x148>
8112c814:	33fffc04 	addi	r15,r6,-16
8112c818:	781ed13a 	srli	r15,r15,4
8112c81c:	28c00104 	addi	r3,r5,4
8112c820:	13400104 	addi	r13,r2,4
8112c824:	781c913a 	slli	r14,r15,4
8112c828:	2b000204 	addi	r12,r5,8
8112c82c:	12c00204 	addi	r11,r2,8
8112c830:	73800504 	addi	r14,r14,20
8112c834:	2a800304 	addi	r10,r5,12
8112c838:	12400304 	addi	r9,r2,12
8112c83c:	2b9d883a 	add	r14,r5,r14
8112c840:	2811883a 	mov	r8,r5
8112c844:	100f883a 	mov	r7,r2
8112c848:	41000017 	ldw	r4,0(r8)
8112c84c:	39c00404 	addi	r7,r7,16
8112c850:	18c00404 	addi	r3,r3,16
8112c854:	393ffc15 	stw	r4,-16(r7)
8112c858:	193ffc17 	ldw	r4,-16(r3)
8112c85c:	6b400404 	addi	r13,r13,16
8112c860:	5ac00404 	addi	r11,r11,16
8112c864:	693ffc15 	stw	r4,-16(r13)
8112c868:	61000017 	ldw	r4,0(r12)
8112c86c:	4a400404 	addi	r9,r9,16
8112c870:	42000404 	addi	r8,r8,16
8112c874:	593ffc15 	stw	r4,-16(r11)
8112c878:	51000017 	ldw	r4,0(r10)
8112c87c:	63000404 	addi	r12,r12,16
8112c880:	52800404 	addi	r10,r10,16
8112c884:	493ffc15 	stw	r4,-16(r9)
8112c888:	1bbfef1e 	bne	r3,r14,8112c848 <__reset+0xfb10c848>
8112c88c:	79000044 	addi	r4,r15,1
8112c890:	2008913a 	slli	r4,r4,4
8112c894:	328003cc 	andi	r10,r6,15
8112c898:	02c000c4 	movi	r11,3
8112c89c:	1107883a 	add	r3,r2,r4
8112c8a0:	290b883a 	add	r5,r5,r4
8112c8a4:	5a801e2e 	bgeu	r11,r10,8112c920 <memmove+0x154>
8112c8a8:	1813883a 	mov	r9,r3
8112c8ac:	2811883a 	mov	r8,r5
8112c8b0:	500f883a 	mov	r7,r10
8112c8b4:	41000017 	ldw	r4,0(r8)
8112c8b8:	4a400104 	addi	r9,r9,4
8112c8bc:	39ffff04 	addi	r7,r7,-4
8112c8c0:	493fff15 	stw	r4,-4(r9)
8112c8c4:	42000104 	addi	r8,r8,4
8112c8c8:	59fffa36 	bltu	r11,r7,8112c8b4 <__reset+0xfb10c8b4>
8112c8cc:	513fff04 	addi	r4,r10,-4
8112c8d0:	2008d0ba 	srli	r4,r4,2
8112c8d4:	318000cc 	andi	r6,r6,3
8112c8d8:	21000044 	addi	r4,r4,1
8112c8dc:	2109883a 	add	r4,r4,r4
8112c8e0:	2109883a 	add	r4,r4,r4
8112c8e4:	1907883a 	add	r3,r3,r4
8112c8e8:	290b883a 	add	r5,r5,r4
8112c8ec:	30000b26 	beq	r6,zero,8112c91c <memmove+0x150>
8112c8f0:	198d883a 	add	r6,r3,r6
8112c8f4:	29c00003 	ldbu	r7,0(r5)
8112c8f8:	18c00044 	addi	r3,r3,1
8112c8fc:	29400044 	addi	r5,r5,1
8112c900:	19ffffc5 	stb	r7,-1(r3)
8112c904:	19bffb1e 	bne	r3,r6,8112c8f4 <__reset+0xfb10c8f4>
8112c908:	f800283a 	ret
8112c90c:	1007883a 	mov	r3,r2
8112c910:	003ff606 	br	8112c8ec <__reset+0xfb10c8ec>
8112c914:	1007883a 	mov	r3,r2
8112c918:	003ff506 	br	8112c8f0 <__reset+0xfb10c8f0>
8112c91c:	f800283a 	ret
8112c920:	500d883a 	mov	r6,r10
8112c924:	003ff106 	br	8112c8ec <__reset+0xfb10c8ec>

8112c928 <_Balloc>:
8112c928:	defffc04 	addi	sp,sp,-16
8112c92c:	de00012e 	bgeu	sp,et,8112c934 <_Balloc+0xc>
8112c930:	003b68fa 	trap	3
8112c934:	20801317 	ldw	r2,76(r4)
8112c938:	dc400115 	stw	r17,4(sp)
8112c93c:	dc000015 	stw	r16,0(sp)
8112c940:	dfc00315 	stw	ra,12(sp)
8112c944:	dc800215 	stw	r18,8(sp)
8112c948:	2023883a 	mov	r17,r4
8112c94c:	2821883a 	mov	r16,r5
8112c950:	10000f26 	beq	r2,zero,8112c990 <_Balloc+0x68>
8112c954:	8407883a 	add	r3,r16,r16
8112c958:	18c7883a 	add	r3,r3,r3
8112c95c:	10c7883a 	add	r3,r2,r3
8112c960:	18800017 	ldw	r2,0(r3)
8112c964:	10001126 	beq	r2,zero,8112c9ac <_Balloc+0x84>
8112c968:	11000017 	ldw	r4,0(r2)
8112c96c:	19000015 	stw	r4,0(r3)
8112c970:	10000415 	stw	zero,16(r2)
8112c974:	10000315 	stw	zero,12(r2)
8112c978:	dfc00317 	ldw	ra,12(sp)
8112c97c:	dc800217 	ldw	r18,8(sp)
8112c980:	dc400117 	ldw	r17,4(sp)
8112c984:	dc000017 	ldw	r16,0(sp)
8112c988:	dec00404 	addi	sp,sp,16
8112c98c:	f800283a 	ret
8112c990:	01800844 	movi	r6,33
8112c994:	01400104 	movi	r5,4
8112c998:	1132b680 	call	81132b68 <_calloc_r>
8112c99c:	88801315 	stw	r2,76(r17)
8112c9a0:	103fec1e 	bne	r2,zero,8112c954 <__reset+0xfb10c954>
8112c9a4:	0005883a 	mov	r2,zero
8112c9a8:	003ff306 	br	8112c978 <__reset+0xfb10c978>
8112c9ac:	01400044 	movi	r5,1
8112c9b0:	2c24983a 	sll	r18,r5,r16
8112c9b4:	8809883a 	mov	r4,r17
8112c9b8:	91800144 	addi	r6,r18,5
8112c9bc:	318d883a 	add	r6,r6,r6
8112c9c0:	318d883a 	add	r6,r6,r6
8112c9c4:	1132b680 	call	81132b68 <_calloc_r>
8112c9c8:	103ff626 	beq	r2,zero,8112c9a4 <__reset+0xfb10c9a4>
8112c9cc:	14000115 	stw	r16,4(r2)
8112c9d0:	14800215 	stw	r18,8(r2)
8112c9d4:	003fe606 	br	8112c970 <__reset+0xfb10c970>

8112c9d8 <_Bfree>:
8112c9d8:	28000826 	beq	r5,zero,8112c9fc <_Bfree+0x24>
8112c9dc:	28c00117 	ldw	r3,4(r5)
8112c9e0:	20801317 	ldw	r2,76(r4)
8112c9e4:	18c7883a 	add	r3,r3,r3
8112c9e8:	18c7883a 	add	r3,r3,r3
8112c9ec:	10c5883a 	add	r2,r2,r3
8112c9f0:	10c00017 	ldw	r3,0(r2)
8112c9f4:	28c00015 	stw	r3,0(r5)
8112c9f8:	11400015 	stw	r5,0(r2)
8112c9fc:	f800283a 	ret

8112ca00 <__multadd>:
8112ca00:	defffa04 	addi	sp,sp,-24
8112ca04:	de00012e 	bgeu	sp,et,8112ca0c <__multadd+0xc>
8112ca08:	003b68fa 	trap	3
8112ca0c:	0011883a 	mov	r8,zero
8112ca10:	dc800315 	stw	r18,12(sp)
8112ca14:	dc400215 	stw	r17,8(sp)
8112ca18:	dc000115 	stw	r16,4(sp)
8112ca1c:	2823883a 	mov	r17,r5
8112ca20:	2c000417 	ldw	r16,16(r5)
8112ca24:	dfc00515 	stw	ra,20(sp)
8112ca28:	dcc00415 	stw	r19,16(sp)
8112ca2c:	2025883a 	mov	r18,r4
8112ca30:	29400504 	addi	r5,r5,20
8112ca34:	28c00017 	ldw	r3,0(r5)
8112ca38:	29400104 	addi	r5,r5,4
8112ca3c:	42000044 	addi	r8,r8,1
8112ca40:	18bfffcc 	andi	r2,r3,65535
8112ca44:	1185383a 	mul	r2,r2,r6
8112ca48:	1806d43a 	srli	r3,r3,16
8112ca4c:	11cf883a 	add	r7,r2,r7
8112ca50:	3808d43a 	srli	r4,r7,16
8112ca54:	1987383a 	mul	r3,r3,r6
8112ca58:	38bfffcc 	andi	r2,r7,65535
8112ca5c:	1907883a 	add	r3,r3,r4
8112ca60:	1808943a 	slli	r4,r3,16
8112ca64:	180ed43a 	srli	r7,r3,16
8112ca68:	2085883a 	add	r2,r4,r2
8112ca6c:	28bfff15 	stw	r2,-4(r5)
8112ca70:	443ff016 	blt	r8,r16,8112ca34 <__reset+0xfb10ca34>
8112ca74:	38000926 	beq	r7,zero,8112ca9c <__multadd+0x9c>
8112ca78:	88800217 	ldw	r2,8(r17)
8112ca7c:	80800f0e 	bge	r16,r2,8112cabc <__multadd+0xbc>
8112ca80:	80800144 	addi	r2,r16,5
8112ca84:	1085883a 	add	r2,r2,r2
8112ca88:	1085883a 	add	r2,r2,r2
8112ca8c:	8885883a 	add	r2,r17,r2
8112ca90:	11c00015 	stw	r7,0(r2)
8112ca94:	84000044 	addi	r16,r16,1
8112ca98:	8c000415 	stw	r16,16(r17)
8112ca9c:	8805883a 	mov	r2,r17
8112caa0:	dfc00517 	ldw	ra,20(sp)
8112caa4:	dcc00417 	ldw	r19,16(sp)
8112caa8:	dc800317 	ldw	r18,12(sp)
8112caac:	dc400217 	ldw	r17,8(sp)
8112cab0:	dc000117 	ldw	r16,4(sp)
8112cab4:	dec00604 	addi	sp,sp,24
8112cab8:	f800283a 	ret
8112cabc:	89400117 	ldw	r5,4(r17)
8112cac0:	9009883a 	mov	r4,r18
8112cac4:	d9c00015 	stw	r7,0(sp)
8112cac8:	29400044 	addi	r5,r5,1
8112cacc:	112c9280 	call	8112c928 <_Balloc>
8112cad0:	89800417 	ldw	r6,16(r17)
8112cad4:	89400304 	addi	r5,r17,12
8112cad8:	11000304 	addi	r4,r2,12
8112cadc:	31800084 	addi	r6,r6,2
8112cae0:	318d883a 	add	r6,r6,r6
8112cae4:	318d883a 	add	r6,r6,r6
8112cae8:	1027883a 	mov	r19,r2
8112caec:	11223f40 	call	811223f4 <memcpy>
8112caf0:	d9c00017 	ldw	r7,0(sp)
8112caf4:	88000a26 	beq	r17,zero,8112cb20 <__multadd+0x120>
8112caf8:	88c00117 	ldw	r3,4(r17)
8112cafc:	90801317 	ldw	r2,76(r18)
8112cb00:	18c7883a 	add	r3,r3,r3
8112cb04:	18c7883a 	add	r3,r3,r3
8112cb08:	10c5883a 	add	r2,r2,r3
8112cb0c:	10c00017 	ldw	r3,0(r2)
8112cb10:	88c00015 	stw	r3,0(r17)
8112cb14:	14400015 	stw	r17,0(r2)
8112cb18:	9823883a 	mov	r17,r19
8112cb1c:	003fd806 	br	8112ca80 <__reset+0xfb10ca80>
8112cb20:	9823883a 	mov	r17,r19
8112cb24:	003fd606 	br	8112ca80 <__reset+0xfb10ca80>

8112cb28 <__s2b>:
8112cb28:	defff904 	addi	sp,sp,-28
8112cb2c:	de00012e 	bgeu	sp,et,8112cb34 <__s2b+0xc>
8112cb30:	003b68fa 	trap	3
8112cb34:	dc400115 	stw	r17,4(sp)
8112cb38:	dc000015 	stw	r16,0(sp)
8112cb3c:	2023883a 	mov	r17,r4
8112cb40:	2821883a 	mov	r16,r5
8112cb44:	39000204 	addi	r4,r7,8
8112cb48:	01400244 	movi	r5,9
8112cb4c:	dcc00315 	stw	r19,12(sp)
8112cb50:	dc800215 	stw	r18,8(sp)
8112cb54:	dfc00615 	stw	ra,24(sp)
8112cb58:	dd400515 	stw	r21,20(sp)
8112cb5c:	dd000415 	stw	r20,16(sp)
8112cb60:	3825883a 	mov	r18,r7
8112cb64:	3027883a 	mov	r19,r6
8112cb68:	11348840 	call	81134884 <__divsi3>
8112cb6c:	00c00044 	movi	r3,1
8112cb70:	000b883a 	mov	r5,zero
8112cb74:	1880030e 	bge	r3,r2,8112cb84 <__s2b+0x5c>
8112cb78:	18c7883a 	add	r3,r3,r3
8112cb7c:	29400044 	addi	r5,r5,1
8112cb80:	18bffd16 	blt	r3,r2,8112cb78 <__reset+0xfb10cb78>
8112cb84:	8809883a 	mov	r4,r17
8112cb88:	112c9280 	call	8112c928 <_Balloc>
8112cb8c:	d8c00717 	ldw	r3,28(sp)
8112cb90:	10c00515 	stw	r3,20(r2)
8112cb94:	00c00044 	movi	r3,1
8112cb98:	10c00415 	stw	r3,16(r2)
8112cb9c:	00c00244 	movi	r3,9
8112cba0:	1cc0210e 	bge	r3,r19,8112cc28 <__s2b+0x100>
8112cba4:	80eb883a 	add	r21,r16,r3
8112cba8:	a829883a 	mov	r20,r21
8112cbac:	84e1883a 	add	r16,r16,r19
8112cbb0:	a1c00007 	ldb	r7,0(r20)
8112cbb4:	01800284 	movi	r6,10
8112cbb8:	a5000044 	addi	r20,r20,1
8112cbbc:	100b883a 	mov	r5,r2
8112cbc0:	39fff404 	addi	r7,r7,-48
8112cbc4:	8809883a 	mov	r4,r17
8112cbc8:	112ca000 	call	8112ca00 <__multadd>
8112cbcc:	a43ff81e 	bne	r20,r16,8112cbb0 <__reset+0xfb10cbb0>
8112cbd0:	ace1883a 	add	r16,r21,r19
8112cbd4:	843ffe04 	addi	r16,r16,-8
8112cbd8:	9c800a0e 	bge	r19,r18,8112cc04 <__s2b+0xdc>
8112cbdc:	94e5c83a 	sub	r18,r18,r19
8112cbe0:	84a5883a 	add	r18,r16,r18
8112cbe4:	81c00007 	ldb	r7,0(r16)
8112cbe8:	01800284 	movi	r6,10
8112cbec:	84000044 	addi	r16,r16,1
8112cbf0:	100b883a 	mov	r5,r2
8112cbf4:	39fff404 	addi	r7,r7,-48
8112cbf8:	8809883a 	mov	r4,r17
8112cbfc:	112ca000 	call	8112ca00 <__multadd>
8112cc00:	84bff81e 	bne	r16,r18,8112cbe4 <__reset+0xfb10cbe4>
8112cc04:	dfc00617 	ldw	ra,24(sp)
8112cc08:	dd400517 	ldw	r21,20(sp)
8112cc0c:	dd000417 	ldw	r20,16(sp)
8112cc10:	dcc00317 	ldw	r19,12(sp)
8112cc14:	dc800217 	ldw	r18,8(sp)
8112cc18:	dc400117 	ldw	r17,4(sp)
8112cc1c:	dc000017 	ldw	r16,0(sp)
8112cc20:	dec00704 	addi	sp,sp,28
8112cc24:	f800283a 	ret
8112cc28:	84000284 	addi	r16,r16,10
8112cc2c:	1827883a 	mov	r19,r3
8112cc30:	003fe906 	br	8112cbd8 <__reset+0xfb10cbd8>

8112cc34 <__hi0bits>:
8112cc34:	20bfffec 	andhi	r2,r4,65535
8112cc38:	1000141e 	bne	r2,zero,8112cc8c <__hi0bits+0x58>
8112cc3c:	2008943a 	slli	r4,r4,16
8112cc40:	00800404 	movi	r2,16
8112cc44:	20ffc02c 	andhi	r3,r4,65280
8112cc48:	1800021e 	bne	r3,zero,8112cc54 <__hi0bits+0x20>
8112cc4c:	2008923a 	slli	r4,r4,8
8112cc50:	10800204 	addi	r2,r2,8
8112cc54:	20fc002c 	andhi	r3,r4,61440
8112cc58:	1800021e 	bne	r3,zero,8112cc64 <__hi0bits+0x30>
8112cc5c:	2008913a 	slli	r4,r4,4
8112cc60:	10800104 	addi	r2,r2,4
8112cc64:	20f0002c 	andhi	r3,r4,49152
8112cc68:	1800031e 	bne	r3,zero,8112cc78 <__hi0bits+0x44>
8112cc6c:	2109883a 	add	r4,r4,r4
8112cc70:	10800084 	addi	r2,r2,2
8112cc74:	2109883a 	add	r4,r4,r4
8112cc78:	20000316 	blt	r4,zero,8112cc88 <__hi0bits+0x54>
8112cc7c:	2110002c 	andhi	r4,r4,16384
8112cc80:	2000041e 	bne	r4,zero,8112cc94 <__hi0bits+0x60>
8112cc84:	00800804 	movi	r2,32
8112cc88:	f800283a 	ret
8112cc8c:	0005883a 	mov	r2,zero
8112cc90:	003fec06 	br	8112cc44 <__reset+0xfb10cc44>
8112cc94:	10800044 	addi	r2,r2,1
8112cc98:	f800283a 	ret

8112cc9c <__lo0bits>:
8112cc9c:	20c00017 	ldw	r3,0(r4)
8112cca0:	188001cc 	andi	r2,r3,7
8112cca4:	10000826 	beq	r2,zero,8112ccc8 <__lo0bits+0x2c>
8112cca8:	1880004c 	andi	r2,r3,1
8112ccac:	1000211e 	bne	r2,zero,8112cd34 <__lo0bits+0x98>
8112ccb0:	1880008c 	andi	r2,r3,2
8112ccb4:	1000211e 	bne	r2,zero,8112cd3c <__lo0bits+0xa0>
8112ccb8:	1806d0ba 	srli	r3,r3,2
8112ccbc:	00800084 	movi	r2,2
8112ccc0:	20c00015 	stw	r3,0(r4)
8112ccc4:	f800283a 	ret
8112ccc8:	18bfffcc 	andi	r2,r3,65535
8112cccc:	10001326 	beq	r2,zero,8112cd1c <__lo0bits+0x80>
8112ccd0:	0005883a 	mov	r2,zero
8112ccd4:	19403fcc 	andi	r5,r3,255
8112ccd8:	2800021e 	bne	r5,zero,8112cce4 <__lo0bits+0x48>
8112ccdc:	1806d23a 	srli	r3,r3,8
8112cce0:	10800204 	addi	r2,r2,8
8112cce4:	194003cc 	andi	r5,r3,15
8112cce8:	2800021e 	bne	r5,zero,8112ccf4 <__lo0bits+0x58>
8112ccec:	1806d13a 	srli	r3,r3,4
8112ccf0:	10800104 	addi	r2,r2,4
8112ccf4:	194000cc 	andi	r5,r3,3
8112ccf8:	2800021e 	bne	r5,zero,8112cd04 <__lo0bits+0x68>
8112ccfc:	1806d0ba 	srli	r3,r3,2
8112cd00:	10800084 	addi	r2,r2,2
8112cd04:	1940004c 	andi	r5,r3,1
8112cd08:	2800081e 	bne	r5,zero,8112cd2c <__lo0bits+0x90>
8112cd0c:	1806d07a 	srli	r3,r3,1
8112cd10:	1800051e 	bne	r3,zero,8112cd28 <__lo0bits+0x8c>
8112cd14:	00800804 	movi	r2,32
8112cd18:	f800283a 	ret
8112cd1c:	1806d43a 	srli	r3,r3,16
8112cd20:	00800404 	movi	r2,16
8112cd24:	003feb06 	br	8112ccd4 <__reset+0xfb10ccd4>
8112cd28:	10800044 	addi	r2,r2,1
8112cd2c:	20c00015 	stw	r3,0(r4)
8112cd30:	f800283a 	ret
8112cd34:	0005883a 	mov	r2,zero
8112cd38:	f800283a 	ret
8112cd3c:	1806d07a 	srli	r3,r3,1
8112cd40:	00800044 	movi	r2,1
8112cd44:	20c00015 	stw	r3,0(r4)
8112cd48:	f800283a 	ret

8112cd4c <__i2b>:
8112cd4c:	defffd04 	addi	sp,sp,-12
8112cd50:	de00012e 	bgeu	sp,et,8112cd58 <__i2b+0xc>
8112cd54:	003b68fa 	trap	3
8112cd58:	dc000015 	stw	r16,0(sp)
8112cd5c:	04000044 	movi	r16,1
8112cd60:	dc400115 	stw	r17,4(sp)
8112cd64:	2823883a 	mov	r17,r5
8112cd68:	800b883a 	mov	r5,r16
8112cd6c:	dfc00215 	stw	ra,8(sp)
8112cd70:	112c9280 	call	8112c928 <_Balloc>
8112cd74:	14400515 	stw	r17,20(r2)
8112cd78:	14000415 	stw	r16,16(r2)
8112cd7c:	dfc00217 	ldw	ra,8(sp)
8112cd80:	dc400117 	ldw	r17,4(sp)
8112cd84:	dc000017 	ldw	r16,0(sp)
8112cd88:	dec00304 	addi	sp,sp,12
8112cd8c:	f800283a 	ret

8112cd90 <__multiply>:
8112cd90:	defffa04 	addi	sp,sp,-24
8112cd94:	de00012e 	bgeu	sp,et,8112cd9c <__multiply+0xc>
8112cd98:	003b68fa 	trap	3
8112cd9c:	dcc00315 	stw	r19,12(sp)
8112cda0:	dc800215 	stw	r18,8(sp)
8112cda4:	34c00417 	ldw	r19,16(r6)
8112cda8:	2c800417 	ldw	r18,16(r5)
8112cdac:	dd000415 	stw	r20,16(sp)
8112cdb0:	dc400115 	stw	r17,4(sp)
8112cdb4:	dfc00515 	stw	ra,20(sp)
8112cdb8:	dc000015 	stw	r16,0(sp)
8112cdbc:	2829883a 	mov	r20,r5
8112cdc0:	3023883a 	mov	r17,r6
8112cdc4:	94c0050e 	bge	r18,r19,8112cddc <__multiply+0x4c>
8112cdc8:	9007883a 	mov	r3,r18
8112cdcc:	3029883a 	mov	r20,r6
8112cdd0:	9825883a 	mov	r18,r19
8112cdd4:	2823883a 	mov	r17,r5
8112cdd8:	1827883a 	mov	r19,r3
8112cddc:	a0800217 	ldw	r2,8(r20)
8112cde0:	94e1883a 	add	r16,r18,r19
8112cde4:	a1400117 	ldw	r5,4(r20)
8112cde8:	1400010e 	bge	r2,r16,8112cdf0 <__multiply+0x60>
8112cdec:	29400044 	addi	r5,r5,1
8112cdf0:	112c9280 	call	8112c928 <_Balloc>
8112cdf4:	8415883a 	add	r10,r16,r16
8112cdf8:	12c00504 	addi	r11,r2,20
8112cdfc:	5295883a 	add	r10,r10,r10
8112ce00:	5a95883a 	add	r10,r11,r10
8112ce04:	5807883a 	mov	r3,r11
8112ce08:	5a80032e 	bgeu	r11,r10,8112ce18 <__multiply+0x88>
8112ce0c:	18000015 	stw	zero,0(r3)
8112ce10:	18c00104 	addi	r3,r3,4
8112ce14:	1abffd36 	bltu	r3,r10,8112ce0c <__reset+0xfb10ce0c>
8112ce18:	9ce7883a 	add	r19,r19,r19
8112ce1c:	94a5883a 	add	r18,r18,r18
8112ce20:	89800504 	addi	r6,r17,20
8112ce24:	9ce7883a 	add	r19,r19,r19
8112ce28:	a3400504 	addi	r13,r20,20
8112ce2c:	94a5883a 	add	r18,r18,r18
8112ce30:	34d9883a 	add	r12,r6,r19
8112ce34:	6c93883a 	add	r9,r13,r18
8112ce38:	3300422e 	bgeu	r6,r12,8112cf44 <__multiply+0x1b4>
8112ce3c:	37c00017 	ldw	ra,0(r6)
8112ce40:	fbffffcc 	andi	r15,ra,65535
8112ce44:	78001b26 	beq	r15,zero,8112ceb4 <__multiply+0x124>
8112ce48:	5811883a 	mov	r8,r11
8112ce4c:	681d883a 	mov	r14,r13
8112ce50:	000f883a 	mov	r7,zero
8112ce54:	71000017 	ldw	r4,0(r14)
8112ce58:	40c00017 	ldw	r3,0(r8)
8112ce5c:	73800104 	addi	r14,r14,4
8112ce60:	217fffcc 	andi	r5,r4,65535
8112ce64:	2bcb383a 	mul	r5,r5,r15
8112ce68:	2008d43a 	srli	r4,r4,16
8112ce6c:	1c7fffcc 	andi	r17,r3,65535
8112ce70:	2c4b883a 	add	r5,r5,r17
8112ce74:	29cb883a 	add	r5,r5,r7
8112ce78:	23c9383a 	mul	r4,r4,r15
8112ce7c:	1806d43a 	srli	r3,r3,16
8112ce80:	280ed43a 	srli	r7,r5,16
8112ce84:	297fffcc 	andi	r5,r5,65535
8112ce88:	20c7883a 	add	r3,r4,r3
8112ce8c:	19c7883a 	add	r3,r3,r7
8112ce90:	1808943a 	slli	r4,r3,16
8112ce94:	4023883a 	mov	r17,r8
8112ce98:	180ed43a 	srli	r7,r3,16
8112ce9c:	214ab03a 	or	r5,r4,r5
8112cea0:	41400015 	stw	r5,0(r8)
8112cea4:	42000104 	addi	r8,r8,4
8112cea8:	727fea36 	bltu	r14,r9,8112ce54 <__reset+0xfb10ce54>
8112ceac:	89c00115 	stw	r7,4(r17)
8112ceb0:	37c00017 	ldw	ra,0(r6)
8112ceb4:	f83ed43a 	srli	ra,ra,16
8112ceb8:	f8001f26 	beq	ra,zero,8112cf38 <__multiply+0x1a8>
8112cebc:	58c00017 	ldw	r3,0(r11)
8112cec0:	681d883a 	mov	r14,r13
8112cec4:	581f883a 	mov	r15,r11
8112cec8:	1811883a 	mov	r8,r3
8112cecc:	5825883a 	mov	r18,r11
8112ced0:	000f883a 	mov	r7,zero
8112ced4:	00000106 	br	8112cedc <__multiply+0x14c>
8112ced8:	8825883a 	mov	r18,r17
8112cedc:	7140000b 	ldhu	r5,0(r14)
8112cee0:	4010d43a 	srli	r8,r8,16
8112cee4:	193fffcc 	andi	r4,r3,65535
8112cee8:	2fcb383a 	mul	r5,r5,ra
8112ceec:	7bc00104 	addi	r15,r15,4
8112cef0:	73800104 	addi	r14,r14,4
8112cef4:	2a0b883a 	add	r5,r5,r8
8112cef8:	29cb883a 	add	r5,r5,r7
8112cefc:	2806943a 	slli	r3,r5,16
8112cf00:	94400104 	addi	r17,r18,4
8112cf04:	280ad43a 	srli	r5,r5,16
8112cf08:	1908b03a 	or	r4,r3,r4
8112cf0c:	793fff15 	stw	r4,-4(r15)
8112cf10:	70ffff17 	ldw	r3,-4(r14)
8112cf14:	8a000017 	ldw	r8,0(r17)
8112cf18:	1806d43a 	srli	r3,r3,16
8112cf1c:	413fffcc 	andi	r4,r8,65535
8112cf20:	1fc7383a 	mul	r3,r3,ra
8112cf24:	1907883a 	add	r3,r3,r4
8112cf28:	1947883a 	add	r3,r3,r5
8112cf2c:	180ed43a 	srli	r7,r3,16
8112cf30:	727fe936 	bltu	r14,r9,8112ced8 <__reset+0xfb10ced8>
8112cf34:	90c00115 	stw	r3,4(r18)
8112cf38:	31800104 	addi	r6,r6,4
8112cf3c:	5ac00104 	addi	r11,r11,4
8112cf40:	333fbe36 	bltu	r6,r12,8112ce3c <__reset+0xfb10ce3c>
8112cf44:	0400090e 	bge	zero,r16,8112cf6c <__multiply+0x1dc>
8112cf48:	50ffff17 	ldw	r3,-4(r10)
8112cf4c:	52bfff04 	addi	r10,r10,-4
8112cf50:	18000326 	beq	r3,zero,8112cf60 <__multiply+0x1d0>
8112cf54:	00000506 	br	8112cf6c <__multiply+0x1dc>
8112cf58:	50c00017 	ldw	r3,0(r10)
8112cf5c:	1800031e 	bne	r3,zero,8112cf6c <__multiply+0x1dc>
8112cf60:	843fffc4 	addi	r16,r16,-1
8112cf64:	52bfff04 	addi	r10,r10,-4
8112cf68:	803ffb1e 	bne	r16,zero,8112cf58 <__reset+0xfb10cf58>
8112cf6c:	14000415 	stw	r16,16(r2)
8112cf70:	dfc00517 	ldw	ra,20(sp)
8112cf74:	dd000417 	ldw	r20,16(sp)
8112cf78:	dcc00317 	ldw	r19,12(sp)
8112cf7c:	dc800217 	ldw	r18,8(sp)
8112cf80:	dc400117 	ldw	r17,4(sp)
8112cf84:	dc000017 	ldw	r16,0(sp)
8112cf88:	dec00604 	addi	sp,sp,24
8112cf8c:	f800283a 	ret

8112cf90 <__pow5mult>:
8112cf90:	defffa04 	addi	sp,sp,-24
8112cf94:	de00012e 	bgeu	sp,et,8112cf9c <__pow5mult+0xc>
8112cf98:	003b68fa 	trap	3
8112cf9c:	308000cc 	andi	r2,r6,3
8112cfa0:	dcc00315 	stw	r19,12(sp)
8112cfa4:	dc000015 	stw	r16,0(sp)
8112cfa8:	dfc00515 	stw	ra,20(sp)
8112cfac:	dd000415 	stw	r20,16(sp)
8112cfb0:	dc800215 	stw	r18,8(sp)
8112cfb4:	dc400115 	stw	r17,4(sp)
8112cfb8:	3021883a 	mov	r16,r6
8112cfbc:	2027883a 	mov	r19,r4
8112cfc0:	10002f1e 	bne	r2,zero,8112d080 <__pow5mult+0xf0>
8112cfc4:	2825883a 	mov	r18,r5
8112cfc8:	8021d0ba 	srai	r16,r16,2
8112cfcc:	80001a26 	beq	r16,zero,8112d038 <__pow5mult+0xa8>
8112cfd0:	9c401217 	ldw	r17,72(r19)
8112cfd4:	8800061e 	bne	r17,zero,8112cff0 <__pow5mult+0x60>
8112cfd8:	00003406 	br	8112d0ac <__pow5mult+0x11c>
8112cfdc:	8021d07a 	srai	r16,r16,1
8112cfe0:	80001526 	beq	r16,zero,8112d038 <__pow5mult+0xa8>
8112cfe4:	88800017 	ldw	r2,0(r17)
8112cfe8:	10001c26 	beq	r2,zero,8112d05c <__pow5mult+0xcc>
8112cfec:	1023883a 	mov	r17,r2
8112cff0:	8080004c 	andi	r2,r16,1
8112cff4:	103ff926 	beq	r2,zero,8112cfdc <__reset+0xfb10cfdc>
8112cff8:	880d883a 	mov	r6,r17
8112cffc:	900b883a 	mov	r5,r18
8112d000:	9809883a 	mov	r4,r19
8112d004:	112cd900 	call	8112cd90 <__multiply>
8112d008:	90001b26 	beq	r18,zero,8112d078 <__pow5mult+0xe8>
8112d00c:	91000117 	ldw	r4,4(r18)
8112d010:	98c01317 	ldw	r3,76(r19)
8112d014:	8021d07a 	srai	r16,r16,1
8112d018:	2109883a 	add	r4,r4,r4
8112d01c:	2109883a 	add	r4,r4,r4
8112d020:	1907883a 	add	r3,r3,r4
8112d024:	19000017 	ldw	r4,0(r3)
8112d028:	91000015 	stw	r4,0(r18)
8112d02c:	1c800015 	stw	r18,0(r3)
8112d030:	1025883a 	mov	r18,r2
8112d034:	803feb1e 	bne	r16,zero,8112cfe4 <__reset+0xfb10cfe4>
8112d038:	9005883a 	mov	r2,r18
8112d03c:	dfc00517 	ldw	ra,20(sp)
8112d040:	dd000417 	ldw	r20,16(sp)
8112d044:	dcc00317 	ldw	r19,12(sp)
8112d048:	dc800217 	ldw	r18,8(sp)
8112d04c:	dc400117 	ldw	r17,4(sp)
8112d050:	dc000017 	ldw	r16,0(sp)
8112d054:	dec00604 	addi	sp,sp,24
8112d058:	f800283a 	ret
8112d05c:	880d883a 	mov	r6,r17
8112d060:	880b883a 	mov	r5,r17
8112d064:	9809883a 	mov	r4,r19
8112d068:	112cd900 	call	8112cd90 <__multiply>
8112d06c:	88800015 	stw	r2,0(r17)
8112d070:	10000015 	stw	zero,0(r2)
8112d074:	003fdd06 	br	8112cfec <__reset+0xfb10cfec>
8112d078:	1025883a 	mov	r18,r2
8112d07c:	003fd706 	br	8112cfdc <__reset+0xfb10cfdc>
8112d080:	10bfffc4 	addi	r2,r2,-1
8112d084:	1085883a 	add	r2,r2,r2
8112d088:	00e04574 	movhi	r3,33045
8112d08c:	18c24704 	addi	r3,r3,2332
8112d090:	1085883a 	add	r2,r2,r2
8112d094:	1885883a 	add	r2,r3,r2
8112d098:	11800017 	ldw	r6,0(r2)
8112d09c:	000f883a 	mov	r7,zero
8112d0a0:	112ca000 	call	8112ca00 <__multadd>
8112d0a4:	1025883a 	mov	r18,r2
8112d0a8:	003fc706 	br	8112cfc8 <__reset+0xfb10cfc8>
8112d0ac:	05000044 	movi	r20,1
8112d0b0:	a00b883a 	mov	r5,r20
8112d0b4:	9809883a 	mov	r4,r19
8112d0b8:	112c9280 	call	8112c928 <_Balloc>
8112d0bc:	1023883a 	mov	r17,r2
8112d0c0:	00809c44 	movi	r2,625
8112d0c4:	88800515 	stw	r2,20(r17)
8112d0c8:	8d000415 	stw	r20,16(r17)
8112d0cc:	9c401215 	stw	r17,72(r19)
8112d0d0:	88000015 	stw	zero,0(r17)
8112d0d4:	003fc606 	br	8112cff0 <__reset+0xfb10cff0>

8112d0d8 <__lshift>:
8112d0d8:	defff904 	addi	sp,sp,-28
8112d0dc:	de00012e 	bgeu	sp,et,8112d0e4 <__lshift+0xc>
8112d0e0:	003b68fa 	trap	3
8112d0e4:	dd400515 	stw	r21,20(sp)
8112d0e8:	dcc00315 	stw	r19,12(sp)
8112d0ec:	302bd17a 	srai	r21,r6,5
8112d0f0:	2cc00417 	ldw	r19,16(r5)
8112d0f4:	28800217 	ldw	r2,8(r5)
8112d0f8:	dd000415 	stw	r20,16(sp)
8112d0fc:	ace7883a 	add	r19,r21,r19
8112d100:	dc800215 	stw	r18,8(sp)
8112d104:	dc400115 	stw	r17,4(sp)
8112d108:	dc000015 	stw	r16,0(sp)
8112d10c:	dfc00615 	stw	ra,24(sp)
8112d110:	9c000044 	addi	r16,r19,1
8112d114:	2823883a 	mov	r17,r5
8112d118:	3029883a 	mov	r20,r6
8112d11c:	2025883a 	mov	r18,r4
8112d120:	29400117 	ldw	r5,4(r5)
8112d124:	1400030e 	bge	r2,r16,8112d134 <__lshift+0x5c>
8112d128:	1085883a 	add	r2,r2,r2
8112d12c:	29400044 	addi	r5,r5,1
8112d130:	143ffd16 	blt	r2,r16,8112d128 <__reset+0xfb10d128>
8112d134:	9009883a 	mov	r4,r18
8112d138:	112c9280 	call	8112c928 <_Balloc>
8112d13c:	10c00504 	addi	r3,r2,20
8112d140:	0540070e 	bge	zero,r21,8112d160 <__lshift+0x88>
8112d144:	ad6b883a 	add	r21,r21,r21
8112d148:	ad6b883a 	add	r21,r21,r21
8112d14c:	1809883a 	mov	r4,r3
8112d150:	1d47883a 	add	r3,r3,r21
8112d154:	20000015 	stw	zero,0(r4)
8112d158:	21000104 	addi	r4,r4,4
8112d15c:	193ffd1e 	bne	r3,r4,8112d154 <__reset+0xfb10d154>
8112d160:	8a000417 	ldw	r8,16(r17)
8112d164:	89000504 	addi	r4,r17,20
8112d168:	a18007cc 	andi	r6,r20,31
8112d16c:	4211883a 	add	r8,r8,r8
8112d170:	4211883a 	add	r8,r8,r8
8112d174:	2211883a 	add	r8,r4,r8
8112d178:	30002326 	beq	r6,zero,8112d208 <__lshift+0x130>
8112d17c:	02400804 	movi	r9,32
8112d180:	4993c83a 	sub	r9,r9,r6
8112d184:	000b883a 	mov	r5,zero
8112d188:	21c00017 	ldw	r7,0(r4)
8112d18c:	1815883a 	mov	r10,r3
8112d190:	18c00104 	addi	r3,r3,4
8112d194:	398e983a 	sll	r7,r7,r6
8112d198:	21000104 	addi	r4,r4,4
8112d19c:	394ab03a 	or	r5,r7,r5
8112d1a0:	197fff15 	stw	r5,-4(r3)
8112d1a4:	217fff17 	ldw	r5,-4(r4)
8112d1a8:	2a4ad83a 	srl	r5,r5,r9
8112d1ac:	223ff636 	bltu	r4,r8,8112d188 <__reset+0xfb10d188>
8112d1b0:	51400115 	stw	r5,4(r10)
8112d1b4:	28001a1e 	bne	r5,zero,8112d220 <__lshift+0x148>
8112d1b8:	843fffc4 	addi	r16,r16,-1
8112d1bc:	14000415 	stw	r16,16(r2)
8112d1c0:	88000826 	beq	r17,zero,8112d1e4 <__lshift+0x10c>
8112d1c4:	89000117 	ldw	r4,4(r17)
8112d1c8:	90c01317 	ldw	r3,76(r18)
8112d1cc:	2109883a 	add	r4,r4,r4
8112d1d0:	2109883a 	add	r4,r4,r4
8112d1d4:	1907883a 	add	r3,r3,r4
8112d1d8:	19000017 	ldw	r4,0(r3)
8112d1dc:	89000015 	stw	r4,0(r17)
8112d1e0:	1c400015 	stw	r17,0(r3)
8112d1e4:	dfc00617 	ldw	ra,24(sp)
8112d1e8:	dd400517 	ldw	r21,20(sp)
8112d1ec:	dd000417 	ldw	r20,16(sp)
8112d1f0:	dcc00317 	ldw	r19,12(sp)
8112d1f4:	dc800217 	ldw	r18,8(sp)
8112d1f8:	dc400117 	ldw	r17,4(sp)
8112d1fc:	dc000017 	ldw	r16,0(sp)
8112d200:	dec00704 	addi	sp,sp,28
8112d204:	f800283a 	ret
8112d208:	21400017 	ldw	r5,0(r4)
8112d20c:	18c00104 	addi	r3,r3,4
8112d210:	21000104 	addi	r4,r4,4
8112d214:	197fff15 	stw	r5,-4(r3)
8112d218:	223ffb36 	bltu	r4,r8,8112d208 <__reset+0xfb10d208>
8112d21c:	003fe606 	br	8112d1b8 <__reset+0xfb10d1b8>
8112d220:	9c000084 	addi	r16,r19,2
8112d224:	003fe406 	br	8112d1b8 <__reset+0xfb10d1b8>

8112d228 <__mcmp>:
8112d228:	20800417 	ldw	r2,16(r4)
8112d22c:	28c00417 	ldw	r3,16(r5)
8112d230:	10c5c83a 	sub	r2,r2,r3
8112d234:	1000111e 	bne	r2,zero,8112d27c <__mcmp+0x54>
8112d238:	18c7883a 	add	r3,r3,r3
8112d23c:	18c7883a 	add	r3,r3,r3
8112d240:	21000504 	addi	r4,r4,20
8112d244:	29400504 	addi	r5,r5,20
8112d248:	20c5883a 	add	r2,r4,r3
8112d24c:	28cb883a 	add	r5,r5,r3
8112d250:	00000106 	br	8112d258 <__mcmp+0x30>
8112d254:	20800a2e 	bgeu	r4,r2,8112d280 <__mcmp+0x58>
8112d258:	10bfff04 	addi	r2,r2,-4
8112d25c:	297fff04 	addi	r5,r5,-4
8112d260:	11800017 	ldw	r6,0(r2)
8112d264:	28c00017 	ldw	r3,0(r5)
8112d268:	30fffa26 	beq	r6,r3,8112d254 <__reset+0xfb10d254>
8112d26c:	30c00236 	bltu	r6,r3,8112d278 <__mcmp+0x50>
8112d270:	00800044 	movi	r2,1
8112d274:	f800283a 	ret
8112d278:	00bfffc4 	movi	r2,-1
8112d27c:	f800283a 	ret
8112d280:	0005883a 	mov	r2,zero
8112d284:	f800283a 	ret

8112d288 <__mdiff>:
8112d288:	defffa04 	addi	sp,sp,-24
8112d28c:	de00012e 	bgeu	sp,et,8112d294 <__mdiff+0xc>
8112d290:	003b68fa 	trap	3
8112d294:	28c00417 	ldw	r3,16(r5)
8112d298:	30800417 	ldw	r2,16(r6)
8112d29c:	dcc00315 	stw	r19,12(sp)
8112d2a0:	dc800215 	stw	r18,8(sp)
8112d2a4:	dfc00515 	stw	ra,20(sp)
8112d2a8:	dd000415 	stw	r20,16(sp)
8112d2ac:	dc400115 	stw	r17,4(sp)
8112d2b0:	dc000015 	stw	r16,0(sp)
8112d2b4:	1887c83a 	sub	r3,r3,r2
8112d2b8:	2825883a 	mov	r18,r5
8112d2bc:	3027883a 	mov	r19,r6
8112d2c0:	1800141e 	bne	r3,zero,8112d314 <__mdiff+0x8c>
8112d2c4:	1085883a 	add	r2,r2,r2
8112d2c8:	1085883a 	add	r2,r2,r2
8112d2cc:	2a000504 	addi	r8,r5,20
8112d2d0:	34000504 	addi	r16,r6,20
8112d2d4:	4087883a 	add	r3,r8,r2
8112d2d8:	8085883a 	add	r2,r16,r2
8112d2dc:	00000106 	br	8112d2e4 <__mdiff+0x5c>
8112d2e0:	40c0592e 	bgeu	r8,r3,8112d448 <__mdiff+0x1c0>
8112d2e4:	18ffff04 	addi	r3,r3,-4
8112d2e8:	10bfff04 	addi	r2,r2,-4
8112d2ec:	19c00017 	ldw	r7,0(r3)
8112d2f0:	11400017 	ldw	r5,0(r2)
8112d2f4:	397ffa26 	beq	r7,r5,8112d2e0 <__reset+0xfb10d2e0>
8112d2f8:	3940592e 	bgeu	r7,r5,8112d460 <__mdiff+0x1d8>
8112d2fc:	9005883a 	mov	r2,r18
8112d300:	4023883a 	mov	r17,r8
8112d304:	9825883a 	mov	r18,r19
8112d308:	05000044 	movi	r20,1
8112d30c:	1027883a 	mov	r19,r2
8112d310:	00000406 	br	8112d324 <__mdiff+0x9c>
8112d314:	18005616 	blt	r3,zero,8112d470 <__mdiff+0x1e8>
8112d318:	34400504 	addi	r17,r6,20
8112d31c:	2c000504 	addi	r16,r5,20
8112d320:	0029883a 	mov	r20,zero
8112d324:	91400117 	ldw	r5,4(r18)
8112d328:	112c9280 	call	8112c928 <_Balloc>
8112d32c:	92400417 	ldw	r9,16(r18)
8112d330:	9b000417 	ldw	r12,16(r19)
8112d334:	12c00504 	addi	r11,r2,20
8112d338:	4a51883a 	add	r8,r9,r9
8112d33c:	6319883a 	add	r12,r12,r12
8112d340:	4211883a 	add	r8,r8,r8
8112d344:	6319883a 	add	r12,r12,r12
8112d348:	15000315 	stw	r20,12(r2)
8112d34c:	8211883a 	add	r8,r16,r8
8112d350:	8b19883a 	add	r12,r17,r12
8112d354:	0007883a 	mov	r3,zero
8112d358:	81400017 	ldw	r5,0(r16)
8112d35c:	89c00017 	ldw	r7,0(r17)
8112d360:	59800104 	addi	r6,r11,4
8112d364:	293fffcc 	andi	r4,r5,65535
8112d368:	20c7883a 	add	r3,r4,r3
8112d36c:	393fffcc 	andi	r4,r7,65535
8112d370:	1909c83a 	sub	r4,r3,r4
8112d374:	280ad43a 	srli	r5,r5,16
8112d378:	380ed43a 	srli	r7,r7,16
8112d37c:	2007d43a 	srai	r3,r4,16
8112d380:	213fffcc 	andi	r4,r4,65535
8112d384:	29cbc83a 	sub	r5,r5,r7
8112d388:	28c7883a 	add	r3,r5,r3
8112d38c:	180a943a 	slli	r5,r3,16
8112d390:	8c400104 	addi	r17,r17,4
8112d394:	84000104 	addi	r16,r16,4
8112d398:	2908b03a 	or	r4,r5,r4
8112d39c:	59000015 	stw	r4,0(r11)
8112d3a0:	1807d43a 	srai	r3,r3,16
8112d3a4:	3015883a 	mov	r10,r6
8112d3a8:	3017883a 	mov	r11,r6
8112d3ac:	8b3fea36 	bltu	r17,r12,8112d358 <__reset+0xfb10d358>
8112d3b0:	8200162e 	bgeu	r16,r8,8112d40c <__mdiff+0x184>
8112d3b4:	8017883a 	mov	r11,r16
8112d3b8:	59400017 	ldw	r5,0(r11)
8112d3bc:	31800104 	addi	r6,r6,4
8112d3c0:	5ac00104 	addi	r11,r11,4
8112d3c4:	293fffcc 	andi	r4,r5,65535
8112d3c8:	20c7883a 	add	r3,r4,r3
8112d3cc:	280ed43a 	srli	r7,r5,16
8112d3d0:	180bd43a 	srai	r5,r3,16
8112d3d4:	193fffcc 	andi	r4,r3,65535
8112d3d8:	3947883a 	add	r3,r7,r5
8112d3dc:	180a943a 	slli	r5,r3,16
8112d3e0:	1807d43a 	srai	r3,r3,16
8112d3e4:	2908b03a 	or	r4,r5,r4
8112d3e8:	313fff15 	stw	r4,-4(r6)
8112d3ec:	5a3ff236 	bltu	r11,r8,8112d3b8 <__reset+0xfb10d3b8>
8112d3f0:	0406303a 	nor	r3,zero,r16
8112d3f4:	1a07883a 	add	r3,r3,r8
8112d3f8:	1806d0ba 	srli	r3,r3,2
8112d3fc:	18c00044 	addi	r3,r3,1
8112d400:	18c7883a 	add	r3,r3,r3
8112d404:	18c7883a 	add	r3,r3,r3
8112d408:	50d5883a 	add	r10,r10,r3
8112d40c:	50ffff04 	addi	r3,r10,-4
8112d410:	2000041e 	bne	r4,zero,8112d424 <__mdiff+0x19c>
8112d414:	18ffff04 	addi	r3,r3,-4
8112d418:	19000017 	ldw	r4,0(r3)
8112d41c:	4a7fffc4 	addi	r9,r9,-1
8112d420:	203ffc26 	beq	r4,zero,8112d414 <__reset+0xfb10d414>
8112d424:	12400415 	stw	r9,16(r2)
8112d428:	dfc00517 	ldw	ra,20(sp)
8112d42c:	dd000417 	ldw	r20,16(sp)
8112d430:	dcc00317 	ldw	r19,12(sp)
8112d434:	dc800217 	ldw	r18,8(sp)
8112d438:	dc400117 	ldw	r17,4(sp)
8112d43c:	dc000017 	ldw	r16,0(sp)
8112d440:	dec00604 	addi	sp,sp,24
8112d444:	f800283a 	ret
8112d448:	000b883a 	mov	r5,zero
8112d44c:	112c9280 	call	8112c928 <_Balloc>
8112d450:	00c00044 	movi	r3,1
8112d454:	10c00415 	stw	r3,16(r2)
8112d458:	10000515 	stw	zero,20(r2)
8112d45c:	003ff206 	br	8112d428 <__reset+0xfb10d428>
8112d460:	8023883a 	mov	r17,r16
8112d464:	0029883a 	mov	r20,zero
8112d468:	4021883a 	mov	r16,r8
8112d46c:	003fad06 	br	8112d324 <__reset+0xfb10d324>
8112d470:	9005883a 	mov	r2,r18
8112d474:	94400504 	addi	r17,r18,20
8112d478:	9c000504 	addi	r16,r19,20
8112d47c:	9825883a 	mov	r18,r19
8112d480:	05000044 	movi	r20,1
8112d484:	1027883a 	mov	r19,r2
8112d488:	003fa606 	br	8112d324 <__reset+0xfb10d324>

8112d48c <__ulp>:
8112d48c:	295ffc2c 	andhi	r5,r5,32752
8112d490:	00bf3034 	movhi	r2,64704
8112d494:	2887883a 	add	r3,r5,r2
8112d498:	00c0020e 	bge	zero,r3,8112d4a4 <__ulp+0x18>
8112d49c:	0005883a 	mov	r2,zero
8112d4a0:	f800283a 	ret
8112d4a4:	00c7c83a 	sub	r3,zero,r3
8112d4a8:	1807d53a 	srai	r3,r3,20
8112d4ac:	008004c4 	movi	r2,19
8112d4b0:	10c00b0e 	bge	r2,r3,8112d4e0 <__ulp+0x54>
8112d4b4:	18bffb04 	addi	r2,r3,-20
8112d4b8:	01000784 	movi	r4,30
8112d4bc:	0007883a 	mov	r3,zero
8112d4c0:	20800516 	blt	r4,r2,8112d4d8 <__ulp+0x4c>
8112d4c4:	010007c4 	movi	r4,31
8112d4c8:	2089c83a 	sub	r4,r4,r2
8112d4cc:	00800044 	movi	r2,1
8112d4d0:	1104983a 	sll	r2,r2,r4
8112d4d4:	f800283a 	ret
8112d4d8:	00800044 	movi	r2,1
8112d4dc:	f800283a 	ret
8112d4e0:	01400234 	movhi	r5,8
8112d4e4:	28c7d83a 	sra	r3,r5,r3
8112d4e8:	0005883a 	mov	r2,zero
8112d4ec:	f800283a 	ret

8112d4f0 <__b2d>:
8112d4f0:	defffa04 	addi	sp,sp,-24
8112d4f4:	de00012e 	bgeu	sp,et,8112d4fc <__b2d+0xc>
8112d4f8:	003b68fa 	trap	3
8112d4fc:	dc000015 	stw	r16,0(sp)
8112d500:	24000417 	ldw	r16,16(r4)
8112d504:	dc400115 	stw	r17,4(sp)
8112d508:	24400504 	addi	r17,r4,20
8112d50c:	8421883a 	add	r16,r16,r16
8112d510:	8421883a 	add	r16,r16,r16
8112d514:	8c21883a 	add	r16,r17,r16
8112d518:	dc800215 	stw	r18,8(sp)
8112d51c:	84bfff17 	ldw	r18,-4(r16)
8112d520:	dd000415 	stw	r20,16(sp)
8112d524:	dcc00315 	stw	r19,12(sp)
8112d528:	9009883a 	mov	r4,r18
8112d52c:	2829883a 	mov	r20,r5
8112d530:	dfc00515 	stw	ra,20(sp)
8112d534:	112cc340 	call	8112cc34 <__hi0bits>
8112d538:	00c00804 	movi	r3,32
8112d53c:	1889c83a 	sub	r4,r3,r2
8112d540:	a1000015 	stw	r4,0(r20)
8112d544:	01000284 	movi	r4,10
8112d548:	84ffff04 	addi	r19,r16,-4
8112d54c:	20801216 	blt	r4,r2,8112d598 <__b2d+0xa8>
8112d550:	018002c4 	movi	r6,11
8112d554:	308dc83a 	sub	r6,r6,r2
8112d558:	9186d83a 	srl	r3,r18,r6
8112d55c:	18cffc34 	orhi	r3,r3,16368
8112d560:	8cc0212e 	bgeu	r17,r19,8112d5e8 <__b2d+0xf8>
8112d564:	813ffe17 	ldw	r4,-8(r16)
8112d568:	218cd83a 	srl	r6,r4,r6
8112d56c:	10800544 	addi	r2,r2,21
8112d570:	9084983a 	sll	r2,r18,r2
8112d574:	1184b03a 	or	r2,r2,r6
8112d578:	dfc00517 	ldw	ra,20(sp)
8112d57c:	dd000417 	ldw	r20,16(sp)
8112d580:	dcc00317 	ldw	r19,12(sp)
8112d584:	dc800217 	ldw	r18,8(sp)
8112d588:	dc400117 	ldw	r17,4(sp)
8112d58c:	dc000017 	ldw	r16,0(sp)
8112d590:	dec00604 	addi	sp,sp,24
8112d594:	f800283a 	ret
8112d598:	8cc00f2e 	bgeu	r17,r19,8112d5d8 <__b2d+0xe8>
8112d59c:	117ffd44 	addi	r5,r2,-11
8112d5a0:	80bffe17 	ldw	r2,-8(r16)
8112d5a4:	28000e26 	beq	r5,zero,8112d5e0 <__b2d+0xf0>
8112d5a8:	1949c83a 	sub	r4,r3,r5
8112d5ac:	9164983a 	sll	r18,r18,r5
8112d5b0:	1106d83a 	srl	r3,r2,r4
8112d5b4:	81bffe04 	addi	r6,r16,-8
8112d5b8:	948ffc34 	orhi	r18,r18,16368
8112d5bc:	90c6b03a 	or	r3,r18,r3
8112d5c0:	89800e2e 	bgeu	r17,r6,8112d5fc <__b2d+0x10c>
8112d5c4:	81bffd17 	ldw	r6,-12(r16)
8112d5c8:	1144983a 	sll	r2,r2,r5
8112d5cc:	310ad83a 	srl	r5,r6,r4
8112d5d0:	2884b03a 	or	r2,r5,r2
8112d5d4:	003fe806 	br	8112d578 <__reset+0xfb10d578>
8112d5d8:	10bffd44 	addi	r2,r2,-11
8112d5dc:	1000041e 	bne	r2,zero,8112d5f0 <__b2d+0x100>
8112d5e0:	90cffc34 	orhi	r3,r18,16368
8112d5e4:	003fe406 	br	8112d578 <__reset+0xfb10d578>
8112d5e8:	000d883a 	mov	r6,zero
8112d5ec:	003fdf06 	br	8112d56c <__reset+0xfb10d56c>
8112d5f0:	90a4983a 	sll	r18,r18,r2
8112d5f4:	0005883a 	mov	r2,zero
8112d5f8:	003ff906 	br	8112d5e0 <__reset+0xfb10d5e0>
8112d5fc:	1144983a 	sll	r2,r2,r5
8112d600:	003fdd06 	br	8112d578 <__reset+0xfb10d578>

8112d604 <__d2b>:
8112d604:	defff804 	addi	sp,sp,-32
8112d608:	de00012e 	bgeu	sp,et,8112d610 <__d2b+0xc>
8112d60c:	003b68fa 	trap	3
8112d610:	dc000215 	stw	r16,8(sp)
8112d614:	3021883a 	mov	r16,r6
8112d618:	dc400315 	stw	r17,12(sp)
8112d61c:	8022907a 	slli	r17,r16,1
8112d620:	dd000615 	stw	r20,24(sp)
8112d624:	2829883a 	mov	r20,r5
8112d628:	01400044 	movi	r5,1
8112d62c:	dcc00515 	stw	r19,20(sp)
8112d630:	dc800415 	stw	r18,16(sp)
8112d634:	dfc00715 	stw	ra,28(sp)
8112d638:	3825883a 	mov	r18,r7
8112d63c:	8822d57a 	srli	r17,r17,21
8112d640:	112c9280 	call	8112c928 <_Balloc>
8112d644:	1027883a 	mov	r19,r2
8112d648:	00800434 	movhi	r2,16
8112d64c:	10bfffc4 	addi	r2,r2,-1
8112d650:	808c703a 	and	r6,r16,r2
8112d654:	88000126 	beq	r17,zero,8112d65c <__d2b+0x58>
8112d658:	31800434 	orhi	r6,r6,16
8112d65c:	d9800015 	stw	r6,0(sp)
8112d660:	a0002426 	beq	r20,zero,8112d6f4 <__d2b+0xf0>
8112d664:	d9000104 	addi	r4,sp,4
8112d668:	dd000115 	stw	r20,4(sp)
8112d66c:	112cc9c0 	call	8112cc9c <__lo0bits>
8112d670:	d8c00017 	ldw	r3,0(sp)
8112d674:	10002f1e 	bne	r2,zero,8112d734 <__d2b+0x130>
8112d678:	d9000117 	ldw	r4,4(sp)
8112d67c:	99000515 	stw	r4,20(r19)
8112d680:	1821003a 	cmpeq	r16,r3,zero
8112d684:	01000084 	movi	r4,2
8112d688:	2421c83a 	sub	r16,r4,r16
8112d68c:	98c00615 	stw	r3,24(r19)
8112d690:	9c000415 	stw	r16,16(r19)
8112d694:	88001f1e 	bne	r17,zero,8112d714 <__d2b+0x110>
8112d698:	10bef384 	addi	r2,r2,-1074
8112d69c:	90800015 	stw	r2,0(r18)
8112d6a0:	00900034 	movhi	r2,16384
8112d6a4:	10bfffc4 	addi	r2,r2,-1
8112d6a8:	8085883a 	add	r2,r16,r2
8112d6ac:	1085883a 	add	r2,r2,r2
8112d6b0:	1085883a 	add	r2,r2,r2
8112d6b4:	9885883a 	add	r2,r19,r2
8112d6b8:	11000517 	ldw	r4,20(r2)
8112d6bc:	8020917a 	slli	r16,r16,5
8112d6c0:	112cc340 	call	8112cc34 <__hi0bits>
8112d6c4:	d8c00817 	ldw	r3,32(sp)
8112d6c8:	8085c83a 	sub	r2,r16,r2
8112d6cc:	18800015 	stw	r2,0(r3)
8112d6d0:	9805883a 	mov	r2,r19
8112d6d4:	dfc00717 	ldw	ra,28(sp)
8112d6d8:	dd000617 	ldw	r20,24(sp)
8112d6dc:	dcc00517 	ldw	r19,20(sp)
8112d6e0:	dc800417 	ldw	r18,16(sp)
8112d6e4:	dc400317 	ldw	r17,12(sp)
8112d6e8:	dc000217 	ldw	r16,8(sp)
8112d6ec:	dec00804 	addi	sp,sp,32
8112d6f0:	f800283a 	ret
8112d6f4:	d809883a 	mov	r4,sp
8112d6f8:	112cc9c0 	call	8112cc9c <__lo0bits>
8112d6fc:	d8c00017 	ldw	r3,0(sp)
8112d700:	04000044 	movi	r16,1
8112d704:	9c000415 	stw	r16,16(r19)
8112d708:	98c00515 	stw	r3,20(r19)
8112d70c:	10800804 	addi	r2,r2,32
8112d710:	883fe126 	beq	r17,zero,8112d698 <__reset+0xfb10d698>
8112d714:	00c00d44 	movi	r3,53
8112d718:	8c7ef344 	addi	r17,r17,-1075
8112d71c:	88a3883a 	add	r17,r17,r2
8112d720:	1885c83a 	sub	r2,r3,r2
8112d724:	d8c00817 	ldw	r3,32(sp)
8112d728:	94400015 	stw	r17,0(r18)
8112d72c:	18800015 	stw	r2,0(r3)
8112d730:	003fe706 	br	8112d6d0 <__reset+0xfb10d6d0>
8112d734:	01000804 	movi	r4,32
8112d738:	2089c83a 	sub	r4,r4,r2
8112d73c:	1908983a 	sll	r4,r3,r4
8112d740:	d9400117 	ldw	r5,4(sp)
8112d744:	1886d83a 	srl	r3,r3,r2
8112d748:	2148b03a 	or	r4,r4,r5
8112d74c:	99000515 	stw	r4,20(r19)
8112d750:	d8c00015 	stw	r3,0(sp)
8112d754:	003fca06 	br	8112d680 <__reset+0xfb10d680>

8112d758 <__ratio>:
8112d758:	defff904 	addi	sp,sp,-28
8112d75c:	de00012e 	bgeu	sp,et,8112d764 <__ratio+0xc>
8112d760:	003b68fa 	trap	3
8112d764:	dc400315 	stw	r17,12(sp)
8112d768:	2823883a 	mov	r17,r5
8112d76c:	d9400104 	addi	r5,sp,4
8112d770:	dfc00615 	stw	ra,24(sp)
8112d774:	dcc00515 	stw	r19,20(sp)
8112d778:	dc800415 	stw	r18,16(sp)
8112d77c:	2027883a 	mov	r19,r4
8112d780:	dc000215 	stw	r16,8(sp)
8112d784:	112d4f00 	call	8112d4f0 <__b2d>
8112d788:	d80b883a 	mov	r5,sp
8112d78c:	8809883a 	mov	r4,r17
8112d790:	1025883a 	mov	r18,r2
8112d794:	1821883a 	mov	r16,r3
8112d798:	112d4f00 	call	8112d4f0 <__b2d>
8112d79c:	8a000417 	ldw	r8,16(r17)
8112d7a0:	99000417 	ldw	r4,16(r19)
8112d7a4:	d9400117 	ldw	r5,4(sp)
8112d7a8:	2209c83a 	sub	r4,r4,r8
8112d7ac:	2010917a 	slli	r8,r4,5
8112d7b0:	d9000017 	ldw	r4,0(sp)
8112d7b4:	2909c83a 	sub	r4,r5,r4
8112d7b8:	4109883a 	add	r4,r8,r4
8112d7bc:	01000e0e 	bge	zero,r4,8112d7f8 <__ratio+0xa0>
8112d7c0:	2008953a 	slli	r4,r4,20
8112d7c4:	2421883a 	add	r16,r4,r16
8112d7c8:	100d883a 	mov	r6,r2
8112d7cc:	180f883a 	mov	r7,r3
8112d7d0:	9009883a 	mov	r4,r18
8112d7d4:	800b883a 	mov	r5,r16
8112d7d8:	11354e80 	call	811354e8 <__divdf3>
8112d7dc:	dfc00617 	ldw	ra,24(sp)
8112d7e0:	dcc00517 	ldw	r19,20(sp)
8112d7e4:	dc800417 	ldw	r18,16(sp)
8112d7e8:	dc400317 	ldw	r17,12(sp)
8112d7ec:	dc000217 	ldw	r16,8(sp)
8112d7f0:	dec00704 	addi	sp,sp,28
8112d7f4:	f800283a 	ret
8112d7f8:	2008953a 	slli	r4,r4,20
8112d7fc:	1907c83a 	sub	r3,r3,r4
8112d800:	003ff106 	br	8112d7c8 <__reset+0xfb10d7c8>

8112d804 <_mprec_log10>:
8112d804:	defffe04 	addi	sp,sp,-8
8112d808:	de00012e 	bgeu	sp,et,8112d810 <_mprec_log10+0xc>
8112d80c:	003b68fa 	trap	3
8112d810:	008005c4 	movi	r2,23
8112d814:	dc000015 	stw	r16,0(sp)
8112d818:	dfc00115 	stw	ra,4(sp)
8112d81c:	2021883a 	mov	r16,r4
8112d820:	11000d0e 	bge	r2,r4,8112d858 <_mprec_log10+0x54>
8112d824:	0005883a 	mov	r2,zero
8112d828:	00cffc34 	movhi	r3,16368
8112d82c:	843fffc4 	addi	r16,r16,-1
8112d830:	000d883a 	mov	r6,zero
8112d834:	01d00934 	movhi	r7,16420
8112d838:	1009883a 	mov	r4,r2
8112d83c:	180b883a 	mov	r5,r3
8112d840:	111fd240 	call	8111fd24 <__muldf3>
8112d844:	803ff91e 	bne	r16,zero,8112d82c <__reset+0xfb10d82c>
8112d848:	dfc00117 	ldw	ra,4(sp)
8112d84c:	dc000017 	ldw	r16,0(sp)
8112d850:	dec00204 	addi	sp,sp,8
8112d854:	f800283a 	ret
8112d858:	202090fa 	slli	r16,r4,3
8112d85c:	00a04574 	movhi	r2,33045
8112d860:	10825e04 	addi	r2,r2,2424
8112d864:	1421883a 	add	r16,r2,r16
8112d868:	80800017 	ldw	r2,0(r16)
8112d86c:	80c00117 	ldw	r3,4(r16)
8112d870:	dfc00117 	ldw	ra,4(sp)
8112d874:	dc000017 	ldw	r16,0(sp)
8112d878:	dec00204 	addi	sp,sp,8
8112d87c:	f800283a 	ret

8112d880 <__copybits>:
8112d880:	297fffc4 	addi	r5,r5,-1
8112d884:	280fd17a 	srai	r7,r5,5
8112d888:	30c00417 	ldw	r3,16(r6)
8112d88c:	30800504 	addi	r2,r6,20
8112d890:	39c00044 	addi	r7,r7,1
8112d894:	18c7883a 	add	r3,r3,r3
8112d898:	39cf883a 	add	r7,r7,r7
8112d89c:	18c7883a 	add	r3,r3,r3
8112d8a0:	39cf883a 	add	r7,r7,r7
8112d8a4:	10c7883a 	add	r3,r2,r3
8112d8a8:	21cf883a 	add	r7,r4,r7
8112d8ac:	10c00d2e 	bgeu	r2,r3,8112d8e4 <__copybits+0x64>
8112d8b0:	200b883a 	mov	r5,r4
8112d8b4:	12000017 	ldw	r8,0(r2)
8112d8b8:	29400104 	addi	r5,r5,4
8112d8bc:	10800104 	addi	r2,r2,4
8112d8c0:	2a3fff15 	stw	r8,-4(r5)
8112d8c4:	10fffb36 	bltu	r2,r3,8112d8b4 <__reset+0xfb10d8b4>
8112d8c8:	1985c83a 	sub	r2,r3,r6
8112d8cc:	10bffac4 	addi	r2,r2,-21
8112d8d0:	1004d0ba 	srli	r2,r2,2
8112d8d4:	10800044 	addi	r2,r2,1
8112d8d8:	1085883a 	add	r2,r2,r2
8112d8dc:	1085883a 	add	r2,r2,r2
8112d8e0:	2089883a 	add	r4,r4,r2
8112d8e4:	21c0032e 	bgeu	r4,r7,8112d8f4 <__copybits+0x74>
8112d8e8:	20000015 	stw	zero,0(r4)
8112d8ec:	21000104 	addi	r4,r4,4
8112d8f0:	21fffd36 	bltu	r4,r7,8112d8e8 <__reset+0xfb10d8e8>
8112d8f4:	f800283a 	ret

8112d8f8 <__any_on>:
8112d8f8:	20c00417 	ldw	r3,16(r4)
8112d8fc:	2805d17a 	srai	r2,r5,5
8112d900:	21000504 	addi	r4,r4,20
8112d904:	18800d0e 	bge	r3,r2,8112d93c <__any_on+0x44>
8112d908:	18c7883a 	add	r3,r3,r3
8112d90c:	18c7883a 	add	r3,r3,r3
8112d910:	20c7883a 	add	r3,r4,r3
8112d914:	20c0192e 	bgeu	r4,r3,8112d97c <__any_on+0x84>
8112d918:	18bfff17 	ldw	r2,-4(r3)
8112d91c:	18ffff04 	addi	r3,r3,-4
8112d920:	1000041e 	bne	r2,zero,8112d934 <__any_on+0x3c>
8112d924:	20c0142e 	bgeu	r4,r3,8112d978 <__any_on+0x80>
8112d928:	18ffff04 	addi	r3,r3,-4
8112d92c:	19400017 	ldw	r5,0(r3)
8112d930:	283ffc26 	beq	r5,zero,8112d924 <__reset+0xfb10d924>
8112d934:	00800044 	movi	r2,1
8112d938:	f800283a 	ret
8112d93c:	10c00a0e 	bge	r2,r3,8112d968 <__any_on+0x70>
8112d940:	1085883a 	add	r2,r2,r2
8112d944:	1085883a 	add	r2,r2,r2
8112d948:	294007cc 	andi	r5,r5,31
8112d94c:	2087883a 	add	r3,r4,r2
8112d950:	283ff026 	beq	r5,zero,8112d914 <__reset+0xfb10d914>
8112d954:	19800017 	ldw	r6,0(r3)
8112d958:	3144d83a 	srl	r2,r6,r5
8112d95c:	114a983a 	sll	r5,r2,r5
8112d960:	317ff41e 	bne	r6,r5,8112d934 <__reset+0xfb10d934>
8112d964:	003feb06 	br	8112d914 <__reset+0xfb10d914>
8112d968:	1085883a 	add	r2,r2,r2
8112d96c:	1085883a 	add	r2,r2,r2
8112d970:	2087883a 	add	r3,r4,r2
8112d974:	003fe706 	br	8112d914 <__reset+0xfb10d914>
8112d978:	f800283a 	ret
8112d97c:	0005883a 	mov	r2,zero
8112d980:	f800283a 	ret

8112d984 <_read_r>:
8112d984:	defffd04 	addi	sp,sp,-12
8112d988:	de00012e 	bgeu	sp,et,8112d990 <_read_r+0xc>
8112d98c:	003b68fa 	trap	3
8112d990:	2805883a 	mov	r2,r5
8112d994:	dc000015 	stw	r16,0(sp)
8112d998:	04204574 	movhi	r16,33045
8112d99c:	dc400115 	stw	r17,4(sp)
8112d9a0:	300b883a 	mov	r5,r6
8112d9a4:	840c6004 	addi	r16,r16,12672
8112d9a8:	2023883a 	mov	r17,r4
8112d9ac:	380d883a 	mov	r6,r7
8112d9b0:	1009883a 	mov	r4,r2
8112d9b4:	dfc00215 	stw	ra,8(sp)
8112d9b8:	80000015 	stw	zero,0(r16)
8112d9bc:	11376580 	call	81137658 <read>
8112d9c0:	00ffffc4 	movi	r3,-1
8112d9c4:	10c00526 	beq	r2,r3,8112d9dc <_read_r+0x58>
8112d9c8:	dfc00217 	ldw	ra,8(sp)
8112d9cc:	dc400117 	ldw	r17,4(sp)
8112d9d0:	dc000017 	ldw	r16,0(sp)
8112d9d4:	dec00304 	addi	sp,sp,12
8112d9d8:	f800283a 	ret
8112d9dc:	80c00017 	ldw	r3,0(r16)
8112d9e0:	183ff926 	beq	r3,zero,8112d9c8 <__reset+0xfb10d9c8>
8112d9e4:	88c00015 	stw	r3,0(r17)
8112d9e8:	003ff706 	br	8112d9c8 <__reset+0xfb10d9c8>

8112d9ec <_realloc_r>:
8112d9ec:	defff604 	addi	sp,sp,-40
8112d9f0:	de00012e 	bgeu	sp,et,8112d9f8 <_realloc_r+0xc>
8112d9f4:	003b68fa 	trap	3
8112d9f8:	dc800215 	stw	r18,8(sp)
8112d9fc:	dfc00915 	stw	ra,36(sp)
8112da00:	df000815 	stw	fp,32(sp)
8112da04:	ddc00715 	stw	r23,28(sp)
8112da08:	dd800615 	stw	r22,24(sp)
8112da0c:	dd400515 	stw	r21,20(sp)
8112da10:	dd000415 	stw	r20,16(sp)
8112da14:	dcc00315 	stw	r19,12(sp)
8112da18:	dc400115 	stw	r17,4(sp)
8112da1c:	dc000015 	stw	r16,0(sp)
8112da20:	3025883a 	mov	r18,r6
8112da24:	2800b726 	beq	r5,zero,8112dd04 <_realloc_r+0x318>
8112da28:	282b883a 	mov	r21,r5
8112da2c:	2029883a 	mov	r20,r4
8112da30:	1137e380 	call	81137e38 <__malloc_lock>
8112da34:	a8bfff17 	ldw	r2,-4(r21)
8112da38:	043fff04 	movi	r16,-4
8112da3c:	90c002c4 	addi	r3,r18,11
8112da40:	01000584 	movi	r4,22
8112da44:	acfffe04 	addi	r19,r21,-8
8112da48:	1420703a 	and	r16,r2,r16
8112da4c:	20c0332e 	bgeu	r4,r3,8112db1c <_realloc_r+0x130>
8112da50:	047ffe04 	movi	r17,-8
8112da54:	1c62703a 	and	r17,r3,r17
8112da58:	8807883a 	mov	r3,r17
8112da5c:	88005816 	blt	r17,zero,8112dbc0 <_realloc_r+0x1d4>
8112da60:	8c805736 	bltu	r17,r18,8112dbc0 <_realloc_r+0x1d4>
8112da64:	80c0300e 	bge	r16,r3,8112db28 <_realloc_r+0x13c>
8112da68:	07204574 	movhi	fp,33045
8112da6c:	e705ab04 	addi	fp,fp,5804
8112da70:	e1c00217 	ldw	r7,8(fp)
8112da74:	9c09883a 	add	r4,r19,r16
8112da78:	22000117 	ldw	r8,4(r4)
8112da7c:	21c06326 	beq	r4,r7,8112dc0c <_realloc_r+0x220>
8112da80:	017fff84 	movi	r5,-2
8112da84:	414a703a 	and	r5,r8,r5
8112da88:	214b883a 	add	r5,r4,r5
8112da8c:	29800117 	ldw	r6,4(r5)
8112da90:	3180004c 	andi	r6,r6,1
8112da94:	30003f26 	beq	r6,zero,8112db94 <_realloc_r+0x1a8>
8112da98:	1080004c 	andi	r2,r2,1
8112da9c:	10008326 	beq	r2,zero,8112dcac <_realloc_r+0x2c0>
8112daa0:	900b883a 	mov	r5,r18
8112daa4:	a009883a 	mov	r4,r20
8112daa8:	1121be00 	call	81121be0 <_malloc_r>
8112daac:	1025883a 	mov	r18,r2
8112dab0:	10011e26 	beq	r2,zero,8112df2c <_realloc_r+0x540>
8112dab4:	a93fff17 	ldw	r4,-4(r21)
8112dab8:	10fffe04 	addi	r3,r2,-8
8112dabc:	00bfff84 	movi	r2,-2
8112dac0:	2084703a 	and	r2,r4,r2
8112dac4:	9885883a 	add	r2,r19,r2
8112dac8:	1880ee26 	beq	r3,r2,8112de84 <_realloc_r+0x498>
8112dacc:	81bfff04 	addi	r6,r16,-4
8112dad0:	00800904 	movi	r2,36
8112dad4:	1180b836 	bltu	r2,r6,8112ddb8 <_realloc_r+0x3cc>
8112dad8:	00c004c4 	movi	r3,19
8112dadc:	19809636 	bltu	r3,r6,8112dd38 <_realloc_r+0x34c>
8112dae0:	9005883a 	mov	r2,r18
8112dae4:	a807883a 	mov	r3,r21
8112dae8:	19000017 	ldw	r4,0(r3)
8112daec:	11000015 	stw	r4,0(r2)
8112daf0:	19000117 	ldw	r4,4(r3)
8112daf4:	11000115 	stw	r4,4(r2)
8112daf8:	18c00217 	ldw	r3,8(r3)
8112dafc:	10c00215 	stw	r3,8(r2)
8112db00:	a80b883a 	mov	r5,r21
8112db04:	a009883a 	mov	r4,r20
8112db08:	112b9580 	call	8112b958 <_free_r>
8112db0c:	a009883a 	mov	r4,r20
8112db10:	1137f600 	call	81137f60 <__malloc_unlock>
8112db14:	9005883a 	mov	r2,r18
8112db18:	00001206 	br	8112db64 <_realloc_r+0x178>
8112db1c:	00c00404 	movi	r3,16
8112db20:	1823883a 	mov	r17,r3
8112db24:	003fce06 	br	8112da60 <__reset+0xfb10da60>
8112db28:	a825883a 	mov	r18,r21
8112db2c:	8445c83a 	sub	r2,r16,r17
8112db30:	00c003c4 	movi	r3,15
8112db34:	18802636 	bltu	r3,r2,8112dbd0 <_realloc_r+0x1e4>
8112db38:	99800117 	ldw	r6,4(r19)
8112db3c:	9c07883a 	add	r3,r19,r16
8112db40:	3180004c 	andi	r6,r6,1
8112db44:	3420b03a 	or	r16,r6,r16
8112db48:	9c000115 	stw	r16,4(r19)
8112db4c:	18800117 	ldw	r2,4(r3)
8112db50:	10800054 	ori	r2,r2,1
8112db54:	18800115 	stw	r2,4(r3)
8112db58:	a009883a 	mov	r4,r20
8112db5c:	1137f600 	call	81137f60 <__malloc_unlock>
8112db60:	9005883a 	mov	r2,r18
8112db64:	dfc00917 	ldw	ra,36(sp)
8112db68:	df000817 	ldw	fp,32(sp)
8112db6c:	ddc00717 	ldw	r23,28(sp)
8112db70:	dd800617 	ldw	r22,24(sp)
8112db74:	dd400517 	ldw	r21,20(sp)
8112db78:	dd000417 	ldw	r20,16(sp)
8112db7c:	dcc00317 	ldw	r19,12(sp)
8112db80:	dc800217 	ldw	r18,8(sp)
8112db84:	dc400117 	ldw	r17,4(sp)
8112db88:	dc000017 	ldw	r16,0(sp)
8112db8c:	dec00a04 	addi	sp,sp,40
8112db90:	f800283a 	ret
8112db94:	017fff04 	movi	r5,-4
8112db98:	414a703a 	and	r5,r8,r5
8112db9c:	814d883a 	add	r6,r16,r5
8112dba0:	30c01f16 	blt	r6,r3,8112dc20 <_realloc_r+0x234>
8112dba4:	20800317 	ldw	r2,12(r4)
8112dba8:	20c00217 	ldw	r3,8(r4)
8112dbac:	a825883a 	mov	r18,r21
8112dbb0:	3021883a 	mov	r16,r6
8112dbb4:	18800315 	stw	r2,12(r3)
8112dbb8:	10c00215 	stw	r3,8(r2)
8112dbbc:	003fdb06 	br	8112db2c <__reset+0xfb10db2c>
8112dbc0:	00800304 	movi	r2,12
8112dbc4:	a0800015 	stw	r2,0(r20)
8112dbc8:	0005883a 	mov	r2,zero
8112dbcc:	003fe506 	br	8112db64 <__reset+0xfb10db64>
8112dbd0:	98c00117 	ldw	r3,4(r19)
8112dbd4:	9c4b883a 	add	r5,r19,r17
8112dbd8:	11000054 	ori	r4,r2,1
8112dbdc:	18c0004c 	andi	r3,r3,1
8112dbe0:	1c62b03a 	or	r17,r3,r17
8112dbe4:	9c400115 	stw	r17,4(r19)
8112dbe8:	29000115 	stw	r4,4(r5)
8112dbec:	2885883a 	add	r2,r5,r2
8112dbf0:	10c00117 	ldw	r3,4(r2)
8112dbf4:	29400204 	addi	r5,r5,8
8112dbf8:	a009883a 	mov	r4,r20
8112dbfc:	18c00054 	ori	r3,r3,1
8112dc00:	10c00115 	stw	r3,4(r2)
8112dc04:	112b9580 	call	8112b958 <_free_r>
8112dc08:	003fd306 	br	8112db58 <__reset+0xfb10db58>
8112dc0c:	017fff04 	movi	r5,-4
8112dc10:	414a703a 	and	r5,r8,r5
8112dc14:	89800404 	addi	r6,r17,16
8112dc18:	8151883a 	add	r8,r16,r5
8112dc1c:	4180590e 	bge	r8,r6,8112dd84 <_realloc_r+0x398>
8112dc20:	1080004c 	andi	r2,r2,1
8112dc24:	103f9e1e 	bne	r2,zero,8112daa0 <__reset+0xfb10daa0>
8112dc28:	adbffe17 	ldw	r22,-8(r21)
8112dc2c:	00bfff04 	movi	r2,-4
8112dc30:	9dadc83a 	sub	r22,r19,r22
8112dc34:	b1800117 	ldw	r6,4(r22)
8112dc38:	3084703a 	and	r2,r6,r2
8112dc3c:	20002026 	beq	r4,zero,8112dcc0 <_realloc_r+0x2d4>
8112dc40:	80af883a 	add	r23,r16,r2
8112dc44:	b96f883a 	add	r23,r23,r5
8112dc48:	21c05f26 	beq	r4,r7,8112ddc8 <_realloc_r+0x3dc>
8112dc4c:	b8c01c16 	blt	r23,r3,8112dcc0 <_realloc_r+0x2d4>
8112dc50:	20800317 	ldw	r2,12(r4)
8112dc54:	20c00217 	ldw	r3,8(r4)
8112dc58:	81bfff04 	addi	r6,r16,-4
8112dc5c:	01000904 	movi	r4,36
8112dc60:	18800315 	stw	r2,12(r3)
8112dc64:	10c00215 	stw	r3,8(r2)
8112dc68:	b0c00217 	ldw	r3,8(r22)
8112dc6c:	b0800317 	ldw	r2,12(r22)
8112dc70:	b4800204 	addi	r18,r22,8
8112dc74:	18800315 	stw	r2,12(r3)
8112dc78:	10c00215 	stw	r3,8(r2)
8112dc7c:	21801b36 	bltu	r4,r6,8112dcec <_realloc_r+0x300>
8112dc80:	008004c4 	movi	r2,19
8112dc84:	1180352e 	bgeu	r2,r6,8112dd5c <_realloc_r+0x370>
8112dc88:	a8800017 	ldw	r2,0(r21)
8112dc8c:	b0800215 	stw	r2,8(r22)
8112dc90:	a8800117 	ldw	r2,4(r21)
8112dc94:	b0800315 	stw	r2,12(r22)
8112dc98:	008006c4 	movi	r2,27
8112dc9c:	11807f36 	bltu	r2,r6,8112de9c <_realloc_r+0x4b0>
8112dca0:	b0800404 	addi	r2,r22,16
8112dca4:	ad400204 	addi	r21,r21,8
8112dca8:	00002d06 	br	8112dd60 <_realloc_r+0x374>
8112dcac:	adbffe17 	ldw	r22,-8(r21)
8112dcb0:	00bfff04 	movi	r2,-4
8112dcb4:	9dadc83a 	sub	r22,r19,r22
8112dcb8:	b1000117 	ldw	r4,4(r22)
8112dcbc:	2084703a 	and	r2,r4,r2
8112dcc0:	b03f7726 	beq	r22,zero,8112daa0 <__reset+0xfb10daa0>
8112dcc4:	80af883a 	add	r23,r16,r2
8112dcc8:	b8ff7516 	blt	r23,r3,8112daa0 <__reset+0xfb10daa0>
8112dccc:	b0800317 	ldw	r2,12(r22)
8112dcd0:	b0c00217 	ldw	r3,8(r22)
8112dcd4:	81bfff04 	addi	r6,r16,-4
8112dcd8:	01000904 	movi	r4,36
8112dcdc:	18800315 	stw	r2,12(r3)
8112dce0:	10c00215 	stw	r3,8(r2)
8112dce4:	b4800204 	addi	r18,r22,8
8112dce8:	21bfe52e 	bgeu	r4,r6,8112dc80 <__reset+0xfb10dc80>
8112dcec:	a80b883a 	mov	r5,r21
8112dcf0:	9009883a 	mov	r4,r18
8112dcf4:	112c7cc0 	call	8112c7cc <memmove>
8112dcf8:	b821883a 	mov	r16,r23
8112dcfc:	b027883a 	mov	r19,r22
8112dd00:	003f8a06 	br	8112db2c <__reset+0xfb10db2c>
8112dd04:	300b883a 	mov	r5,r6
8112dd08:	dfc00917 	ldw	ra,36(sp)
8112dd0c:	df000817 	ldw	fp,32(sp)
8112dd10:	ddc00717 	ldw	r23,28(sp)
8112dd14:	dd800617 	ldw	r22,24(sp)
8112dd18:	dd400517 	ldw	r21,20(sp)
8112dd1c:	dd000417 	ldw	r20,16(sp)
8112dd20:	dcc00317 	ldw	r19,12(sp)
8112dd24:	dc800217 	ldw	r18,8(sp)
8112dd28:	dc400117 	ldw	r17,4(sp)
8112dd2c:	dc000017 	ldw	r16,0(sp)
8112dd30:	dec00a04 	addi	sp,sp,40
8112dd34:	1121be01 	jmpi	81121be0 <_malloc_r>
8112dd38:	a8c00017 	ldw	r3,0(r21)
8112dd3c:	90c00015 	stw	r3,0(r18)
8112dd40:	a8c00117 	ldw	r3,4(r21)
8112dd44:	90c00115 	stw	r3,4(r18)
8112dd48:	00c006c4 	movi	r3,27
8112dd4c:	19804536 	bltu	r3,r6,8112de64 <_realloc_r+0x478>
8112dd50:	90800204 	addi	r2,r18,8
8112dd54:	a8c00204 	addi	r3,r21,8
8112dd58:	003f6306 	br	8112dae8 <__reset+0xfb10dae8>
8112dd5c:	9005883a 	mov	r2,r18
8112dd60:	a8c00017 	ldw	r3,0(r21)
8112dd64:	b821883a 	mov	r16,r23
8112dd68:	b027883a 	mov	r19,r22
8112dd6c:	10c00015 	stw	r3,0(r2)
8112dd70:	a8c00117 	ldw	r3,4(r21)
8112dd74:	10c00115 	stw	r3,4(r2)
8112dd78:	a8c00217 	ldw	r3,8(r21)
8112dd7c:	10c00215 	stw	r3,8(r2)
8112dd80:	003f6a06 	br	8112db2c <__reset+0xfb10db2c>
8112dd84:	9c67883a 	add	r19,r19,r17
8112dd88:	4445c83a 	sub	r2,r8,r17
8112dd8c:	e4c00215 	stw	r19,8(fp)
8112dd90:	10800054 	ori	r2,r2,1
8112dd94:	98800115 	stw	r2,4(r19)
8112dd98:	a8bfff17 	ldw	r2,-4(r21)
8112dd9c:	a009883a 	mov	r4,r20
8112dda0:	1080004c 	andi	r2,r2,1
8112dda4:	1462b03a 	or	r17,r2,r17
8112dda8:	ac7fff15 	stw	r17,-4(r21)
8112ddac:	1137f600 	call	81137f60 <__malloc_unlock>
8112ddb0:	a805883a 	mov	r2,r21
8112ddb4:	003f6b06 	br	8112db64 <__reset+0xfb10db64>
8112ddb8:	a80b883a 	mov	r5,r21
8112ddbc:	9009883a 	mov	r4,r18
8112ddc0:	112c7cc0 	call	8112c7cc <memmove>
8112ddc4:	003f4e06 	br	8112db00 <__reset+0xfb10db00>
8112ddc8:	89000404 	addi	r4,r17,16
8112ddcc:	b93fbc16 	blt	r23,r4,8112dcc0 <__reset+0xfb10dcc0>
8112ddd0:	b0800317 	ldw	r2,12(r22)
8112ddd4:	b0c00217 	ldw	r3,8(r22)
8112ddd8:	81bfff04 	addi	r6,r16,-4
8112dddc:	01000904 	movi	r4,36
8112dde0:	18800315 	stw	r2,12(r3)
8112dde4:	10c00215 	stw	r3,8(r2)
8112dde8:	b4800204 	addi	r18,r22,8
8112ddec:	21804336 	bltu	r4,r6,8112defc <_realloc_r+0x510>
8112ddf0:	008004c4 	movi	r2,19
8112ddf4:	11803f2e 	bgeu	r2,r6,8112def4 <_realloc_r+0x508>
8112ddf8:	a8800017 	ldw	r2,0(r21)
8112ddfc:	b0800215 	stw	r2,8(r22)
8112de00:	a8800117 	ldw	r2,4(r21)
8112de04:	b0800315 	stw	r2,12(r22)
8112de08:	008006c4 	movi	r2,27
8112de0c:	11803f36 	bltu	r2,r6,8112df0c <_realloc_r+0x520>
8112de10:	b0800404 	addi	r2,r22,16
8112de14:	ad400204 	addi	r21,r21,8
8112de18:	a8c00017 	ldw	r3,0(r21)
8112de1c:	10c00015 	stw	r3,0(r2)
8112de20:	a8c00117 	ldw	r3,4(r21)
8112de24:	10c00115 	stw	r3,4(r2)
8112de28:	a8c00217 	ldw	r3,8(r21)
8112de2c:	10c00215 	stw	r3,8(r2)
8112de30:	b447883a 	add	r3,r22,r17
8112de34:	bc45c83a 	sub	r2,r23,r17
8112de38:	e0c00215 	stw	r3,8(fp)
8112de3c:	10800054 	ori	r2,r2,1
8112de40:	18800115 	stw	r2,4(r3)
8112de44:	b0800117 	ldw	r2,4(r22)
8112de48:	a009883a 	mov	r4,r20
8112de4c:	1080004c 	andi	r2,r2,1
8112de50:	1462b03a 	or	r17,r2,r17
8112de54:	b4400115 	stw	r17,4(r22)
8112de58:	1137f600 	call	81137f60 <__malloc_unlock>
8112de5c:	9005883a 	mov	r2,r18
8112de60:	003f4006 	br	8112db64 <__reset+0xfb10db64>
8112de64:	a8c00217 	ldw	r3,8(r21)
8112de68:	90c00215 	stw	r3,8(r18)
8112de6c:	a8c00317 	ldw	r3,12(r21)
8112de70:	90c00315 	stw	r3,12(r18)
8112de74:	30801126 	beq	r6,r2,8112debc <_realloc_r+0x4d0>
8112de78:	90800404 	addi	r2,r18,16
8112de7c:	a8c00404 	addi	r3,r21,16
8112de80:	003f1906 	br	8112dae8 <__reset+0xfb10dae8>
8112de84:	90ffff17 	ldw	r3,-4(r18)
8112de88:	00bfff04 	movi	r2,-4
8112de8c:	a825883a 	mov	r18,r21
8112de90:	1884703a 	and	r2,r3,r2
8112de94:	80a1883a 	add	r16,r16,r2
8112de98:	003f2406 	br	8112db2c <__reset+0xfb10db2c>
8112de9c:	a8800217 	ldw	r2,8(r21)
8112dea0:	b0800415 	stw	r2,16(r22)
8112dea4:	a8800317 	ldw	r2,12(r21)
8112dea8:	b0800515 	stw	r2,20(r22)
8112deac:	31000a26 	beq	r6,r4,8112ded8 <_realloc_r+0x4ec>
8112deb0:	b0800604 	addi	r2,r22,24
8112deb4:	ad400404 	addi	r21,r21,16
8112deb8:	003fa906 	br	8112dd60 <__reset+0xfb10dd60>
8112debc:	a9000417 	ldw	r4,16(r21)
8112dec0:	90800604 	addi	r2,r18,24
8112dec4:	a8c00604 	addi	r3,r21,24
8112dec8:	91000415 	stw	r4,16(r18)
8112decc:	a9000517 	ldw	r4,20(r21)
8112ded0:	91000515 	stw	r4,20(r18)
8112ded4:	003f0406 	br	8112dae8 <__reset+0xfb10dae8>
8112ded8:	a8c00417 	ldw	r3,16(r21)
8112dedc:	ad400604 	addi	r21,r21,24
8112dee0:	b0800804 	addi	r2,r22,32
8112dee4:	b0c00615 	stw	r3,24(r22)
8112dee8:	a8ffff17 	ldw	r3,-4(r21)
8112deec:	b0c00715 	stw	r3,28(r22)
8112def0:	003f9b06 	br	8112dd60 <__reset+0xfb10dd60>
8112def4:	9005883a 	mov	r2,r18
8112def8:	003fc706 	br	8112de18 <__reset+0xfb10de18>
8112defc:	a80b883a 	mov	r5,r21
8112df00:	9009883a 	mov	r4,r18
8112df04:	112c7cc0 	call	8112c7cc <memmove>
8112df08:	003fc906 	br	8112de30 <__reset+0xfb10de30>
8112df0c:	a8800217 	ldw	r2,8(r21)
8112df10:	b0800415 	stw	r2,16(r22)
8112df14:	a8800317 	ldw	r2,12(r21)
8112df18:	b0800515 	stw	r2,20(r22)
8112df1c:	31000726 	beq	r6,r4,8112df3c <_realloc_r+0x550>
8112df20:	b0800604 	addi	r2,r22,24
8112df24:	ad400404 	addi	r21,r21,16
8112df28:	003fbb06 	br	8112de18 <__reset+0xfb10de18>
8112df2c:	a009883a 	mov	r4,r20
8112df30:	1137f600 	call	81137f60 <__malloc_unlock>
8112df34:	0005883a 	mov	r2,zero
8112df38:	003f0a06 	br	8112db64 <__reset+0xfb10db64>
8112df3c:	a8c00417 	ldw	r3,16(r21)
8112df40:	ad400604 	addi	r21,r21,24
8112df44:	b0800804 	addi	r2,r22,32
8112df48:	b0c00615 	stw	r3,24(r22)
8112df4c:	a8ffff17 	ldw	r3,-4(r21)
8112df50:	b0c00715 	stw	r3,28(r22)
8112df54:	003fb006 	br	8112de18 <__reset+0xfb10de18>

8112df58 <__fpclassifyd>:
8112df58:	00a00034 	movhi	r2,32768
8112df5c:	10bfffc4 	addi	r2,r2,-1
8112df60:	2884703a 	and	r2,r5,r2
8112df64:	10000726 	beq	r2,zero,8112df84 <__fpclassifyd+0x2c>
8112df68:	00fffc34 	movhi	r3,65520
8112df6c:	019ff834 	movhi	r6,32736
8112df70:	28c7883a 	add	r3,r5,r3
8112df74:	31bfffc4 	addi	r6,r6,-1
8112df78:	30c00536 	bltu	r6,r3,8112df90 <__fpclassifyd+0x38>
8112df7c:	00800104 	movi	r2,4
8112df80:	f800283a 	ret
8112df84:	2000021e 	bne	r4,zero,8112df90 <__fpclassifyd+0x38>
8112df88:	00800084 	movi	r2,2
8112df8c:	f800283a 	ret
8112df90:	00dffc34 	movhi	r3,32752
8112df94:	019ff834 	movhi	r6,32736
8112df98:	28cb883a 	add	r5,r5,r3
8112df9c:	31bfffc4 	addi	r6,r6,-1
8112dfa0:	317ff62e 	bgeu	r6,r5,8112df7c <__reset+0xfb10df7c>
8112dfa4:	01400434 	movhi	r5,16
8112dfa8:	297fffc4 	addi	r5,r5,-1
8112dfac:	28800236 	bltu	r5,r2,8112dfb8 <__fpclassifyd+0x60>
8112dfb0:	008000c4 	movi	r2,3
8112dfb4:	f800283a 	ret
8112dfb8:	10c00226 	beq	r2,r3,8112dfc4 <__fpclassifyd+0x6c>
8112dfbc:	0005883a 	mov	r2,zero
8112dfc0:	f800283a 	ret
8112dfc4:	2005003a 	cmpeq	r2,r4,zero
8112dfc8:	f800283a 	ret

8112dfcc <__sccl>:
8112dfcc:	2a000003 	ldbu	r8,0(r5)
8112dfd0:	00801784 	movi	r2,94
8112dfd4:	40802a26 	beq	r8,r2,8112e080 <__sccl+0xb4>
8112dfd8:	29400044 	addi	r5,r5,1
8112dfdc:	000f883a 	mov	r7,zero
8112dfe0:	0013883a 	mov	r9,zero
8112dfe4:	2007883a 	mov	r3,r4
8112dfe8:	21804004 	addi	r6,r4,256
8112dfec:	19c00005 	stb	r7,0(r3)
8112dff0:	18c00044 	addi	r3,r3,1
8112dff4:	19bffd1e 	bne	r3,r6,8112dfec <__reset+0xfb10dfec>
8112dff8:	40001126 	beq	r8,zero,8112e040 <__sccl+0x74>
8112dffc:	00800044 	movi	r2,1
8112e000:	124fc83a 	sub	r7,r2,r9
8112e004:	02800b44 	movi	r10,45
8112e008:	02c01744 	movi	r11,93
8112e00c:	2205883a 	add	r2,r4,r8
8112e010:	11c00005 	stb	r7,0(r2)
8112e014:	28800044 	addi	r2,r5,1
8112e018:	28c00003 	ldbu	r3,0(r5)
8112e01c:	1a800a26 	beq	r3,r10,8112e048 <__sccl+0x7c>
8112e020:	1ac00426 	beq	r3,r11,8112e034 <__sccl+0x68>
8112e024:	18000426 	beq	r3,zero,8112e038 <__sccl+0x6c>
8112e028:	1811883a 	mov	r8,r3
8112e02c:	100b883a 	mov	r5,r2
8112e030:	003ff606 	br	8112e00c <__reset+0xfb10e00c>
8112e034:	f800283a 	ret
8112e038:	2805883a 	mov	r2,r5
8112e03c:	f800283a 	ret
8112e040:	28bfffc4 	addi	r2,r5,-1
8112e044:	f800283a 	ret
8112e048:	12400003 	ldbu	r9,0(r2)
8112e04c:	4ac01126 	beq	r9,r11,8112e094 <__sccl+0xc8>
8112e050:	4a001016 	blt	r9,r8,8112e094 <__sccl+0xc8>
8112e054:	41800044 	addi	r6,r8,1
8112e058:	29400084 	addi	r5,r5,2
8112e05c:	2187883a 	add	r3,r4,r6
8112e060:	00000106 	br	8112e068 <__sccl+0x9c>
8112e064:	31800044 	addi	r6,r6,1
8112e068:	19c00005 	stb	r7,0(r3)
8112e06c:	3011883a 	mov	r8,r6
8112e070:	18c00044 	addi	r3,r3,1
8112e074:	327ffb16 	blt	r6,r9,8112e064 <__reset+0xfb10e064>
8112e078:	10800084 	addi	r2,r2,2
8112e07c:	003fe606 	br	8112e018 <__reset+0xfb10e018>
8112e080:	2a000043 	ldbu	r8,1(r5)
8112e084:	01c00044 	movi	r7,1
8112e088:	29400084 	addi	r5,r5,2
8112e08c:	02400044 	movi	r9,1
8112e090:	003fd406 	br	8112dfe4 <__reset+0xfb10dfe4>
8112e094:	5011883a 	mov	r8,r10
8112e098:	003fe406 	br	8112e02c <__reset+0xfb10e02c>

8112e09c <nanf>:
8112e09c:	009ff034 	movhi	r2,32704
8112e0a0:	f800283a 	ret

8112e0a4 <strcmp>:
8112e0a4:	2144b03a 	or	r2,r4,r5
8112e0a8:	108000cc 	andi	r2,r2,3
8112e0ac:	1000171e 	bne	r2,zero,8112e10c <strcmp+0x68>
8112e0b0:	20800017 	ldw	r2,0(r4)
8112e0b4:	28c00017 	ldw	r3,0(r5)
8112e0b8:	10c0141e 	bne	r2,r3,8112e10c <strcmp+0x68>
8112e0bc:	027fbff4 	movhi	r9,65279
8112e0c0:	4a7fbfc4 	addi	r9,r9,-257
8112e0c4:	0086303a 	nor	r3,zero,r2
8112e0c8:	02202074 	movhi	r8,32897
8112e0cc:	1245883a 	add	r2,r2,r9
8112e0d0:	42202004 	addi	r8,r8,-32640
8112e0d4:	10c4703a 	and	r2,r2,r3
8112e0d8:	1204703a 	and	r2,r2,r8
8112e0dc:	10000226 	beq	r2,zero,8112e0e8 <strcmp+0x44>
8112e0e0:	00002306 	br	8112e170 <strcmp+0xcc>
8112e0e4:	1000221e 	bne	r2,zero,8112e170 <strcmp+0xcc>
8112e0e8:	21000104 	addi	r4,r4,4
8112e0ec:	20c00017 	ldw	r3,0(r4)
8112e0f0:	29400104 	addi	r5,r5,4
8112e0f4:	29800017 	ldw	r6,0(r5)
8112e0f8:	1a4f883a 	add	r7,r3,r9
8112e0fc:	00c4303a 	nor	r2,zero,r3
8112e100:	3884703a 	and	r2,r7,r2
8112e104:	1204703a 	and	r2,r2,r8
8112e108:	19bff626 	beq	r3,r6,8112e0e4 <__reset+0xfb10e0e4>
8112e10c:	20800003 	ldbu	r2,0(r4)
8112e110:	10c03fcc 	andi	r3,r2,255
8112e114:	18c0201c 	xori	r3,r3,128
8112e118:	18ffe004 	addi	r3,r3,-128
8112e11c:	18000c26 	beq	r3,zero,8112e150 <strcmp+0xac>
8112e120:	29800007 	ldb	r6,0(r5)
8112e124:	19800326 	beq	r3,r6,8112e134 <strcmp+0x90>
8112e128:	00001306 	br	8112e178 <strcmp+0xd4>
8112e12c:	29800007 	ldb	r6,0(r5)
8112e130:	11800b1e 	bne	r2,r6,8112e160 <strcmp+0xbc>
8112e134:	21000044 	addi	r4,r4,1
8112e138:	20c00003 	ldbu	r3,0(r4)
8112e13c:	29400044 	addi	r5,r5,1
8112e140:	18803fcc 	andi	r2,r3,255
8112e144:	1080201c 	xori	r2,r2,128
8112e148:	10bfe004 	addi	r2,r2,-128
8112e14c:	103ff71e 	bne	r2,zero,8112e12c <__reset+0xfb10e12c>
8112e150:	0007883a 	mov	r3,zero
8112e154:	28800003 	ldbu	r2,0(r5)
8112e158:	1885c83a 	sub	r2,r3,r2
8112e15c:	f800283a 	ret
8112e160:	28800003 	ldbu	r2,0(r5)
8112e164:	18c03fcc 	andi	r3,r3,255
8112e168:	1885c83a 	sub	r2,r3,r2
8112e16c:	f800283a 	ret
8112e170:	0005883a 	mov	r2,zero
8112e174:	f800283a 	ret
8112e178:	10c03fcc 	andi	r3,r2,255
8112e17c:	003ff506 	br	8112e154 <__reset+0xfb10e154>

8112e180 <sulp>:
8112e180:	defffd04 	addi	sp,sp,-12
8112e184:	de00012e 	bgeu	sp,et,8112e18c <sulp+0xc>
8112e188:	003b68fa 	trap	3
8112e18c:	dc400115 	stw	r17,4(sp)
8112e190:	3023883a 	mov	r17,r6
8112e194:	dc000015 	stw	r16,0(sp)
8112e198:	dfc00215 	stw	ra,8(sp)
8112e19c:	2821883a 	mov	r16,r5
8112e1a0:	112d48c0 	call	8112d48c <__ulp>
8112e1a4:	88000c26 	beq	r17,zero,8112e1d8 <sulp+0x58>
8112e1a8:	841ffc2c 	andhi	r16,r16,32752
8112e1ac:	8020d53a 	srli	r16,r16,20
8112e1b0:	01c01ac4 	movi	r7,107
8112e1b4:	3c21c83a 	sub	r16,r7,r16
8112e1b8:	0400070e 	bge	zero,r16,8112e1d8 <sulp+0x58>
8112e1bc:	8020953a 	slli	r16,r16,20
8112e1c0:	01cffc34 	movhi	r7,16368
8112e1c4:	000d883a 	mov	r6,zero
8112e1c8:	81cf883a 	add	r7,r16,r7
8112e1cc:	1009883a 	mov	r4,r2
8112e1d0:	180b883a 	mov	r5,r3
8112e1d4:	111fd240 	call	8111fd24 <__muldf3>
8112e1d8:	dfc00217 	ldw	ra,8(sp)
8112e1dc:	dc400117 	ldw	r17,4(sp)
8112e1e0:	dc000017 	ldw	r16,0(sp)
8112e1e4:	dec00304 	addi	sp,sp,12
8112e1e8:	f800283a 	ret

8112e1ec <_strtod_r>:
8112e1ec:	deffe204 	addi	sp,sp,-120
8112e1f0:	de00012e 	bgeu	sp,et,8112e1f8 <_strtod_r+0xc>
8112e1f4:	003b68fa 	trap	3
8112e1f8:	ddc01b15 	stw	r23,108(sp)
8112e1fc:	dd001815 	stw	r20,96(sp)
8112e200:	dc801615 	stw	r18,88(sp)
8112e204:	dc401515 	stw	r17,84(sp)
8112e208:	dc001415 	stw	r16,80(sp)
8112e20c:	d9400615 	stw	r5,24(sp)
8112e210:	dfc01d15 	stw	ra,116(sp)
8112e214:	df001c15 	stw	fp,112(sp)
8112e218:	dd801a15 	stw	r22,104(sp)
8112e21c:	dd401915 	stw	r21,100(sp)
8112e220:	dcc01715 	stw	r19,92(sp)
8112e224:	2021883a 	mov	r16,r4
8112e228:	d8000515 	stw	zero,20(sp)
8112e22c:	2809883a 	mov	r4,r5
8112e230:	20800003 	ldbu	r2,0(r4)
8112e234:	01e044f4 	movhi	r7,33043
8112e238:	282f883a 	mov	r23,r5
8112e23c:	10c03fcc 	andi	r3,r2,255
8112e240:	01400b44 	movi	r5,45
8112e244:	39f89a04 	addi	r7,r7,-7576
8112e248:	3029883a 	mov	r20,r6
8112e24c:	0025883a 	mov	r18,zero
8112e250:	0023883a 	mov	r17,zero
8112e254:	28c0ba36 	bltu	r5,r3,8112e540 <_strtod_r+0x354>
8112e258:	180690ba 	slli	r3,r3,2
8112e25c:	19c7883a 	add	r3,r3,r7
8112e260:	18c00017 	ldw	r3,0(r3)
8112e264:	1800683a 	jmp	r3
8112e268:	8112e328 	cmpgeui	r4,r16,19340
8112e26c:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e270:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e274:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e278:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e27c:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e280:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e284:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e288:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e28c:	8112e52c 	andhi	r4,r16,19348
8112e290:	8112e52c 	andhi	r4,r16,19348
8112e294:	8112e52c 	andhi	r4,r16,19348
8112e298:	8112e52c 	andhi	r4,r16,19348
8112e29c:	8112e52c 	andhi	r4,r16,19348
8112e2a0:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2a4:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2a8:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2ac:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2b0:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2b4:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2b8:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2bc:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2c0:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2c4:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2c8:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2cc:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2d0:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2d4:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2d8:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2dc:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2e0:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2e4:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2e8:	8112e52c 	andhi	r4,r16,19348
8112e2ec:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2f0:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2f4:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2f8:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e2fc:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e300:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e304:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e308:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e30c:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e310:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e314:	8112e380 	call	88112e38 <__reset+0x20f2e38>
8112e318:	8112e540 	call	88112e54 <__reset+0x20f2e54>
8112e31c:	8112e520 	cmpeqi	r4,r16,19348
8112e320:	00801244 	movi	r2,73
8112e324:	88843526 	beq	r17,r2,8112f3fc <_strtod_r+0x1210>
8112e328:	002b883a 	mov	r21,zero
8112e32c:	002d883a 	mov	r22,zero
8112e330:	a0000526 	beq	r20,zero,8112e348 <_strtod_r+0x15c>
8112e334:	d8000715 	stw	zero,28(sp)
8112e338:	a5c00015 	stw	r23,0(r20)
8112e33c:	d9000717 	ldw	r4,28(sp)
8112e340:	20000126 	beq	r4,zero,8112e348 <_strtod_r+0x15c>
8112e344:	b5a0003c 	xorhi	r22,r22,32768
8112e348:	a805883a 	mov	r2,r21
8112e34c:	b007883a 	mov	r3,r22
8112e350:	dfc01d17 	ldw	ra,116(sp)
8112e354:	df001c17 	ldw	fp,112(sp)
8112e358:	ddc01b17 	ldw	r23,108(sp)
8112e35c:	dd801a17 	ldw	r22,104(sp)
8112e360:	dd401917 	ldw	r21,100(sp)
8112e364:	dd001817 	ldw	r20,96(sp)
8112e368:	dcc01717 	ldw	r19,92(sp)
8112e36c:	dc801617 	ldw	r18,88(sp)
8112e370:	dc401517 	ldw	r17,84(sp)
8112e374:	dc001417 	ldw	r16,80(sp)
8112e378:	dec01e04 	addi	sp,sp,120
8112e37c:	f800283a 	ret
8112e380:	d8000715 	stw	zero,28(sp)
8112e384:	24c00044 	addi	r19,r4,1
8112e388:	dcc00615 	stw	r19,24(sp)
8112e38c:	20800043 	ldbu	r2,1(r4)
8112e390:	10c03fcc 	andi	r3,r2,255
8112e394:	18c0201c 	xori	r3,r3,128
8112e398:	18ffe004 	addi	r3,r3,-128
8112e39c:	183fe226 	beq	r3,zero,8112e328 <__reset+0xfb10e328>
8112e3a0:	11403fcc 	andi	r5,r2,255
8112e3a4:	2940201c 	xori	r5,r5,128
8112e3a8:	297fe004 	addi	r5,r5,-128
8112e3ac:	00c00c04 	movi	r3,48
8112e3b0:	28c0e526 	beq	r5,r3,8112e748 <_strtod_r+0x55c>
8112e3b4:	dcc00815 	stw	r19,32(sp)
8112e3b8:	0025883a 	mov	r18,zero
8112e3bc:	10fff404 	addi	r3,r2,-48
8112e3c0:	18c03fcc 	andi	r3,r3,255
8112e3c4:	01000244 	movi	r4,9
8112e3c8:	20c37536 	bltu	r4,r3,8112f1a0 <_strtod_r+0xfb4>
8112e3cc:	dd400817 	ldw	r21,32(sp)
8112e3d0:	0027883a 	mov	r19,zero
8112e3d4:	0039883a 	mov	fp,zero
8112e3d8:	002d883a 	mov	r22,zero
8112e3dc:	01400204 	movi	r5,8
8112e3e0:	2d805a16 	blt	r5,r22,8112e54c <_strtod_r+0x360>
8112e3e4:	e70002a4 	muli	fp,fp,10
8112e3e8:	10c03fcc 	andi	r3,r2,255
8112e3ec:	18c0201c 	xori	r3,r3,128
8112e3f0:	18ffe004 	addi	r3,r3,-128
8112e3f4:	e0f9883a 	add	fp,fp,r3
8112e3f8:	e73ff404 	addi	fp,fp,-48
8112e3fc:	ad400044 	addi	r21,r21,1
8112e400:	dd400615 	stw	r21,24(sp)
8112e404:	a8800003 	ldbu	r2,0(r21)
8112e408:	b5800044 	addi	r22,r22,1
8112e40c:	10fff404 	addi	r3,r2,-48
8112e410:	18c03fcc 	andi	r3,r3,255
8112e414:	20fff22e 	bgeu	r4,r3,8112e3e0 <__reset+0xfb10e3e0>
8112e418:	14403fcc 	andi	r17,r2,255
8112e41c:	8c40201c 	xori	r17,r17,128
8112e420:	8c7fe004 	addi	r17,r17,-128
8112e424:	8009883a 	mov	r4,r16
8112e428:	112c40c0 	call	8112c40c <_localeconv_r>
8112e42c:	11400017 	ldw	r5,0(r2)
8112e430:	8009883a 	mov	r4,r16
8112e434:	d9401315 	stw	r5,76(sp)
8112e438:	112c40c0 	call	8112c40c <_localeconv_r>
8112e43c:	11000017 	ldw	r4,0(r2)
8112e440:	1122ee80 	call	81122ee8 <strlen>
8112e444:	d9401317 	ldw	r5,76(sp)
8112e448:	100d883a 	mov	r6,r2
8112e44c:	a809883a 	mov	r4,r21
8112e450:	1133af40 	call	81133af4 <strncmp>
8112e454:	1000ce26 	beq	r2,zero,8112e790 <_strtod_r+0x5a4>
8112e458:	b013883a 	mov	r9,r22
8112e45c:	000b883a 	mov	r5,zero
8112e460:	0015883a 	mov	r10,zero
8112e464:	0017883a 	mov	r11,zero
8112e468:	00801944 	movi	r2,101
8112e46c:	88807826 	beq	r17,r2,8112e650 <_strtod_r+0x464>
8112e470:	00801144 	movi	r2,69
8112e474:	88807626 	beq	r17,r2,8112e650 <_strtod_r+0x464>
8112e478:	002b883a 	mov	r21,zero
8112e47c:	48003d1e 	bne	r9,zero,8112e574 <_strtod_r+0x388>
8112e480:	2800391e 	bne	r5,zero,8112e568 <_strtod_r+0x37c>
8112e484:	9000381e 	bne	r18,zero,8112e568 <_strtod_r+0x37c>
8112e488:	583fa71e 	bne	r11,zero,8112e328 <__reset+0xfb10e328>
8112e48c:	00801384 	movi	r2,78
8112e490:	88800526 	beq	r17,r2,8112e4a8 <_strtod_r+0x2bc>
8112e494:	147fa20e 	bge	r2,r17,8112e320 <__reset+0xfb10e320>
8112e498:	00801a44 	movi	r2,105
8112e49c:	8883d726 	beq	r17,r2,8112f3fc <_strtod_r+0x1210>
8112e4a0:	00801b84 	movi	r2,110
8112e4a4:	88bfa01e 	bne	r17,r2,8112e328 <__reset+0xfb10e328>
8112e4a8:	01604574 	movhi	r5,33045
8112e4ac:	d9000617 	ldw	r4,24(sp)
8112e4b0:	29429304 	addi	r5,r5,2636
8112e4b4:	01c00644 	movi	r7,25
8112e4b8:	00000b06 	br	8112e4e8 <_strtod_r+0x2fc>
8112e4bc:	21000044 	addi	r4,r4,1
8112e4c0:	20800003 	ldbu	r2,0(r4)
8112e4c4:	10ffefc4 	addi	r3,r2,-65
8112e4c8:	10803fcc 	andi	r2,r2,255
8112e4cc:	1080201c 	xori	r2,r2,128
8112e4d0:	18c03fcc 	andi	r3,r3,255
8112e4d4:	10bfe004 	addi	r2,r2,-128
8112e4d8:	38c00136 	bltu	r7,r3,8112e4e0 <_strtod_r+0x2f4>
8112e4dc:	10800804 	addi	r2,r2,32
8112e4e0:	29400044 	addi	r5,r5,1
8112e4e4:	11bf901e 	bne	r2,r6,8112e328 <__reset+0xfb10e328>
8112e4e8:	29800007 	ldb	r6,0(r5)
8112e4ec:	303ff31e 	bne	r6,zero,8112e4bc <__reset+0xfb10e4bc>
8112e4f0:	20800044 	addi	r2,r4,1
8112e4f4:	d8800615 	stw	r2,24(sp)
8112e4f8:	20c00047 	ldb	r3,1(r4)
8112e4fc:	00800a04 	movi	r2,40
8112e500:	18849d26 	beq	r3,r2,8112f778 <_strtod_r+0x158c>
8112e504:	047ffe34 	movhi	r17,65528
8112e508:	0025883a 	mov	r18,zero
8112e50c:	902b883a 	mov	r21,r18
8112e510:	882d883a 	mov	r22,r17
8112e514:	a03f8926 	beq	r20,zero,8112e33c <__reset+0xfb10e33c>
8112e518:	ddc00617 	ldw	r23,24(sp)
8112e51c:	003f8606 	br	8112e338 <__reset+0xfb10e338>
8112e520:	00800044 	movi	r2,1
8112e524:	d8800715 	stw	r2,28(sp)
8112e528:	003f9606 	br	8112e384 <__reset+0xfb10e384>
8112e52c:	21000044 	addi	r4,r4,1
8112e530:	d9000615 	stw	r4,24(sp)
8112e534:	20800003 	ldbu	r2,0(r4)
8112e538:	10c03fcc 	andi	r3,r2,255
8112e53c:	28ff462e 	bgeu	r5,r3,8112e258 <__reset+0xfb10e258>
8112e540:	2027883a 	mov	r19,r4
8112e544:	d8000715 	stw	zero,28(sp)
8112e548:	003f9506 	br	8112e3a0 <__reset+0xfb10e3a0>
8112e54c:	9cc002a4 	muli	r19,r19,10
8112e550:	10803fcc 	andi	r2,r2,255
8112e554:	1080201c 	xori	r2,r2,128
8112e558:	10bfe004 	addi	r2,r2,-128
8112e55c:	9885883a 	add	r2,r19,r2
8112e560:	14fff404 	addi	r19,r2,-48
8112e564:	003fa506 	br	8112e3fc <__reset+0xfb10e3fc>
8112e568:	002b883a 	mov	r21,zero
8112e56c:	002d883a 	mov	r22,zero
8112e570:	003fe806 	br	8112e514 <__reset+0xfb10e514>
8112e574:	aaabc83a 	sub	r21,r21,r10
8112e578:	b000011e 	bne	r22,zero,8112e580 <_strtod_r+0x394>
8112e57c:	482d883a 	mov	r22,r9
8112e580:	00800404 	movi	r2,16
8112e584:	482f883a 	mov	r23,r9
8112e588:	1240010e 	bge	r2,r9,8112e590 <_strtod_r+0x3a4>
8112e58c:	102f883a 	mov	r23,r2
8112e590:	e009883a 	mov	r4,fp
8112e594:	da401315 	stw	r9,76(sp)
8112e598:	1135f540 	call	81135f54 <__floatunsidf>
8112e59c:	1025883a 	mov	r18,r2
8112e5a0:	00800244 	movi	r2,9
8112e5a4:	1823883a 	mov	r17,r3
8112e5a8:	da401317 	ldw	r9,76(sp)
8112e5ac:	15c0160e 	bge	r2,r23,8112e608 <_strtod_r+0x41c>
8112e5b0:	b8bffdc4 	addi	r2,r23,-9
8112e5b4:	100490fa 	slli	r2,r2,3
8112e5b8:	180b883a 	mov	r5,r3
8112e5bc:	00e04574 	movhi	r3,33045
8112e5c0:	18c25e04 	addi	r3,r3,2424
8112e5c4:	1885883a 	add	r2,r3,r2
8112e5c8:	11800017 	ldw	r6,0(r2)
8112e5cc:	11c00117 	ldw	r7,4(r2)
8112e5d0:	9009883a 	mov	r4,r18
8112e5d4:	111fd240 	call	8111fd24 <__muldf3>
8112e5d8:	9809883a 	mov	r4,r19
8112e5dc:	1025883a 	mov	r18,r2
8112e5e0:	1823883a 	mov	r17,r3
8112e5e4:	1135f540 	call	81135f54 <__floatunsidf>
8112e5e8:	9009883a 	mov	r4,r18
8112e5ec:	880b883a 	mov	r5,r17
8112e5f0:	100d883a 	mov	r6,r2
8112e5f4:	180f883a 	mov	r7,r3
8112e5f8:	1134c340 	call	81134c34 <__adddf3>
8112e5fc:	da401317 	ldw	r9,76(sp)
8112e600:	1025883a 	mov	r18,r2
8112e604:	1823883a 	mov	r17,r3
8112e608:	008003c4 	movi	r2,15
8112e60c:	12407b16 	blt	r2,r9,8112e7fc <_strtod_r+0x610>
8112e610:	a83fbe26 	beq	r21,zero,8112e50c <__reset+0xfb10e50c>
8112e614:	0543670e 	bge	zero,r21,8112f3b4 <_strtod_r+0x11c8>
8112e618:	00c00584 	movi	r3,22
8112e61c:	1d42e816 	blt	r3,r21,8112f1c0 <_strtod_r+0xfd4>
8112e620:	a82a90fa 	slli	r21,r21,3
8112e624:	00a04574 	movhi	r2,33045
8112e628:	10825e04 	addi	r2,r2,2424
8112e62c:	1545883a 	add	r2,r2,r21
8112e630:	11000017 	ldw	r4,0(r2)
8112e634:	11400117 	ldw	r5,4(r2)
8112e638:	900d883a 	mov	r6,r18
8112e63c:	880f883a 	mov	r7,r17
8112e640:	111fd240 	call	8111fd24 <__muldf3>
8112e644:	102b883a 	mov	r21,r2
8112e648:	182d883a 	mov	r22,r3
8112e64c:	003fb106 	br	8112e514 <__reset+0xfb10e514>
8112e650:	4801b526 	beq	r9,zero,8112ed28 <_strtod_r+0xb3c>
8112e654:	ddc00617 	ldw	r23,24(sp)
8112e658:	00c00ac4 	movi	r3,43
8112e65c:	b8800044 	addi	r2,r23,1
8112e660:	d8800615 	stw	r2,24(sp)
8112e664:	b8800047 	ldb	r2,1(r23)
8112e668:	10c1e926 	beq	r2,r3,8112ee10 <_strtod_r+0xc24>
8112e66c:	00c00b44 	movi	r3,45
8112e670:	10c1ec26 	beq	r2,r3,8112ee24 <_strtod_r+0xc38>
8112e674:	1023883a 	mov	r17,r2
8112e678:	0019883a 	mov	r12,zero
8112e67c:	88bff404 	addi	r2,r17,-48
8112e680:	00c00244 	movi	r3,9
8112e684:	1881b736 	bltu	r3,r2,8112ed64 <_strtod_r+0xb78>
8112e688:	00800c04 	movi	r2,48
8112e68c:	8880071e 	bne	r17,r2,8112e6ac <_strtod_r+0x4c0>
8112e690:	d8800617 	ldw	r2,24(sp)
8112e694:	8807883a 	mov	r3,r17
8112e698:	10800044 	addi	r2,r2,1
8112e69c:	d8800615 	stw	r2,24(sp)
8112e6a0:	14400007 	ldb	r17,0(r2)
8112e6a4:	10800044 	addi	r2,r2,1
8112e6a8:	88fffc26 	beq	r17,r3,8112e69c <__reset+0xfb10e69c>
8112e6ac:	88bff3c4 	addi	r2,r17,-49
8112e6b0:	00c00204 	movi	r3,8
8112e6b4:	18bf7036 	bltu	r3,r2,8112e478 <__reset+0xfb10e478>
8112e6b8:	db800617 	ldw	r14,24(sp)
8112e6bc:	88bff404 	addi	r2,r17,-48
8112e6c0:	03400244 	movi	r13,9
8112e6c4:	71c00044 	addi	r7,r14,1
8112e6c8:	d9c00615 	stw	r7,24(sp)
8112e6cc:	74400043 	ldbu	r17,1(r14)
8112e6d0:	88fff404 	addi	r3,r17,-48
8112e6d4:	8c403fcc 	andi	r17,r17,255
8112e6d8:	8c40201c 	xori	r17,r17,128
8112e6dc:	18c03fcc 	andi	r3,r3,255
8112e6e0:	8c7fe004 	addi	r17,r17,-128
8112e6e4:	68c00e36 	bltu	r13,r3,8112e720 <_strtod_r+0x534>
8112e6e8:	71000084 	addi	r4,r14,2
8112e6ec:	d9000615 	stw	r4,24(sp)
8112e6f0:	108002a4 	muli	r2,r2,10
8112e6f4:	21800003 	ldbu	r6,0(r4)
8112e6f8:	200f883a 	mov	r7,r4
8112e6fc:	1463883a 	add	r17,r2,r17
8112e700:	30fff404 	addi	r3,r6,-48
8112e704:	88bff404 	addi	r2,r17,-48
8112e708:	34403fcc 	andi	r17,r6,255
8112e70c:	8c40201c 	xori	r17,r17,128
8112e710:	18c03fcc 	andi	r3,r3,255
8112e714:	8c7fe004 	addi	r17,r17,-128
8112e718:	21000044 	addi	r4,r4,1
8112e71c:	68fff32e 	bgeu	r13,r3,8112e6ec <__reset+0xfb10e6ec>
8112e720:	3b8fc83a 	sub	r7,r7,r14
8112e724:	00c00204 	movi	r3,8
8112e728:	19c29716 	blt	r3,r7,8112f188 <_strtod_r+0xf9c>
8112e72c:	102b883a 	mov	r21,r2
8112e730:	009387c4 	movi	r2,19999
8112e734:	1540010e 	bge	r2,r21,8112e73c <_strtod_r+0x550>
8112e738:	102b883a 	mov	r21,r2
8112e73c:	603f4f26 	beq	r12,zero,8112e47c <__reset+0xfb10e47c>
8112e740:	056bc83a 	sub	r21,zero,r21
8112e744:	003f4d06 	br	8112e47c <__reset+0xfb10e47c>
8112e748:	98800047 	ldb	r2,1(r19)
8112e74c:	00c01604 	movi	r3,88
8112e750:	10c1de26 	beq	r2,r3,8112eecc <_strtod_r+0xce0>
8112e754:	00c01e04 	movi	r3,120
8112e758:	10c1dc26 	beq	r2,r3,8112eecc <_strtod_r+0xce0>
8112e75c:	98c00044 	addi	r3,r19,1
8112e760:	1827883a 	mov	r19,r3
8112e764:	d8c00615 	stw	r3,24(sp)
8112e768:	18c00044 	addi	r3,r3,1
8112e76c:	18bfffc3 	ldbu	r2,-1(r3)
8112e770:	11003fcc 	andi	r4,r2,255
8112e774:	2100201c 	xori	r4,r4,128
8112e778:	213fe004 	addi	r4,r4,-128
8112e77c:	217ff826 	beq	r4,r5,8112e760 <__reset+0xfb10e760>
8112e780:	203f7926 	beq	r4,zero,8112e568 <__reset+0xfb10e568>
8112e784:	dcc00815 	stw	r19,32(sp)
8112e788:	04800044 	movi	r18,1
8112e78c:	003f0b06 	br	8112e3bc <__reset+0xfb10e3bc>
8112e790:	8009883a 	mov	r4,r16
8112e794:	112c40c0 	call	8112c40c <_localeconv_r>
8112e798:	11000017 	ldw	r4,0(r2)
8112e79c:	1122ee80 	call	81122ee8 <strlen>
8112e7a0:	d8c00617 	ldw	r3,24(sp)
8112e7a4:	1885883a 	add	r2,r3,r2
8112e7a8:	d8800615 	stw	r2,24(sp)
8112e7ac:	14400007 	ldb	r17,0(r2)
8112e7b0:	b001881e 	bne	r22,zero,8112edd4 <_strtod_r+0xbe8>
8112e7b4:	00c00c04 	movi	r3,48
8112e7b8:	88c3391e 	bne	r17,r3,8112f4a0 <_strtod_r+0x12b4>
8112e7bc:	10c00044 	addi	r3,r2,1
8112e7c0:	8809883a 	mov	r4,r17
8112e7c4:	d8c00615 	stw	r3,24(sp)
8112e7c8:	1c400007 	ldb	r17,0(r3)
8112e7cc:	188bc83a 	sub	r5,r3,r2
8112e7d0:	18c00044 	addi	r3,r3,1
8112e7d4:	893ffb26 	beq	r17,r4,8112e7c4 <__reset+0xfb10e7c4>
8112e7d8:	88bff3c4 	addi	r2,r17,-49
8112e7dc:	00c00204 	movi	r3,8
8112e7e0:	1882e72e 	bgeu	r3,r2,8112f380 <_strtod_r+0x1194>
8112e7e4:	00801944 	movi	r2,101
8112e7e8:	88814d26 	beq	r17,r2,8112ed20 <_strtod_r+0xb34>
8112e7ec:	0013883a 	mov	r9,zero
8112e7f0:	0015883a 	mov	r10,zero
8112e7f4:	02c00044 	movi	r11,1
8112e7f8:	003f1d06 	br	8112e470 <__reset+0xfb10e470>
8112e7fc:	4defc83a 	sub	r23,r9,r23
8112e800:	bd6f883a 	add	r23,r23,r21
8112e804:	05c21e0e 	bge	zero,r23,8112f080 <_strtod_r+0xe94>
8112e808:	b88003cc 	andi	r2,r23,15
8112e80c:	10000d26 	beq	r2,zero,8112e844 <_strtod_r+0x658>
8112e810:	100490fa 	slli	r2,r2,3
8112e814:	00e04574 	movhi	r3,33045
8112e818:	18c25e04 	addi	r3,r3,2424
8112e81c:	1885883a 	add	r2,r3,r2
8112e820:	11000017 	ldw	r4,0(r2)
8112e824:	11400117 	ldw	r5,4(r2)
8112e828:	900d883a 	mov	r6,r18
8112e82c:	880f883a 	mov	r7,r17
8112e830:	da401315 	stw	r9,76(sp)
8112e834:	111fd240 	call	8111fd24 <__muldf3>
8112e838:	da401317 	ldw	r9,76(sp)
8112e83c:	1025883a 	mov	r18,r2
8112e840:	1823883a 	mov	r17,r3
8112e844:	023ffc04 	movi	r8,-16
8112e848:	ba10703a 	and	r8,r23,r8
8112e84c:	40003c26 	beq	r8,zero,8112e940 <_strtod_r+0x754>
8112e850:	00804d04 	movi	r2,308
8112e854:	1201cd16 	blt	r2,r8,8112ef8c <_strtod_r+0xda0>
8112e858:	4011d13a 	srai	r8,r8,4
8112e85c:	03000044 	movi	r12,1
8112e860:	62037c0e 	bge	r12,r8,8112f654 <_strtod_r+0x1468>
8112e864:	01204574 	movhi	r4,33045
8112e868:	21025404 	addi	r4,r4,2384
8112e86c:	2015883a 	mov	r10,r4
8112e870:	0027883a 	mov	r19,zero
8112e874:	d9000915 	stw	r4,36(sp)
8112e878:	9005883a 	mov	r2,r18
8112e87c:	8807883a 	mov	r3,r17
8112e880:	dc000c15 	stw	r16,48(sp)
8112e884:	dc800e15 	stw	r18,56(sp)
8112e888:	9821883a 	mov	r16,r19
8112e88c:	0009883a 	mov	r4,zero
8112e890:	8827883a 	mov	r19,r17
8112e894:	602f883a 	mov	r23,r12
8112e898:	da400a15 	stw	r9,40(sp)
8112e89c:	5025883a 	mov	r18,r10
8112e8a0:	4023883a 	mov	r17,r8
8112e8a4:	8980004c 	andi	r6,r17,1
8112e8a8:	30000626 	beq	r6,zero,8112e8c4 <_strtod_r+0x6d8>
8112e8ac:	91800017 	ldw	r6,0(r18)
8112e8b0:	91c00117 	ldw	r7,4(r18)
8112e8b4:	1009883a 	mov	r4,r2
8112e8b8:	180b883a 	mov	r5,r3
8112e8bc:	111fd240 	call	8111fd24 <__muldf3>
8112e8c0:	01000044 	movi	r4,1
8112e8c4:	8823d07a 	srai	r17,r17,1
8112e8c8:	84000044 	addi	r16,r16,1
8112e8cc:	94800204 	addi	r18,r18,8
8112e8d0:	8dfff41e 	bne	r17,r23,8112e8a4 <__reset+0xfb10e8a4>
8112e8d4:	21003fcc 	andi	r4,r4,255
8112e8d8:	9823883a 	mov	r17,r19
8112e8dc:	da400a17 	ldw	r9,40(sp)
8112e8e0:	8027883a 	mov	r19,r16
8112e8e4:	dc800e17 	ldw	r18,56(sp)
8112e8e8:	dc000c17 	ldw	r16,48(sp)
8112e8ec:	2003b11e 	bne	r4,zero,8112f7b4 <_strtod_r+0x15c8>
8112e8f0:	981690fa 	slli	r11,r19,3
8112e8f4:	d8800917 	ldw	r2,36(sp)
8112e8f8:	01ff2c34 	movhi	r7,64688
8112e8fc:	900d883a 	mov	r6,r18
8112e900:	12ef883a 	add	r23,r2,r11
8112e904:	b9000017 	ldw	r4,0(r23)
8112e908:	b9400117 	ldw	r5,4(r23)
8112e90c:	89cf883a 	add	r7,r17,r7
8112e910:	da401315 	stw	r9,76(sp)
8112e914:	111fd240 	call	8111fd24 <__muldf3>
8112e918:	1025883a 	mov	r18,r2
8112e91c:	011f2834 	movhi	r4,31904
8112e920:	189ffc2c 	andhi	r2,r3,32752
8112e924:	da401317 	ldw	r9,76(sp)
8112e928:	20819836 	bltu	r4,r2,8112ef8c <_strtod_r+0xda0>
8112e92c:	011f2434 	movhi	r4,31888
8112e930:	2083382e 	bgeu	r4,r2,8112f614 <_strtod_r+0x1428>
8112e934:	045ffc34 	movhi	r17,32752
8112e938:	8c7fffc4 	addi	r17,r17,-1
8112e93c:	04bfffc4 	movi	r18,-1
8112e940:	d8000915 	stw	zero,36(sp)
8112e944:	d9400817 	ldw	r5,32(sp)
8112e948:	df000015 	stw	fp,0(sp)
8112e94c:	480f883a 	mov	r7,r9
8112e950:	b00d883a 	mov	r6,r22
8112e954:	8009883a 	mov	r4,r16
8112e958:	112cb280 	call	8112cb28 <__s2b>
8112e95c:	d8800815 	stw	r2,32(sp)
8112e960:	10018a26 	beq	r2,zero,8112ef8c <_strtod_r+0xda0>
8112e964:	a807d7fa 	srai	r3,r21,31
8112e968:	0545c83a 	sub	r2,zero,r21
8112e96c:	dd400a15 	stw	r21,40(sp)
8112e970:	1886703a 	and	r3,r3,r2
8112e974:	d8c00c15 	stw	r3,48(sp)
8112e978:	a8013516 	blt	r21,zero,8112ee50 <_strtod_r+0xc64>
8112e97c:	d9400817 	ldw	r5,32(sp)
8112e980:	0011883a 	mov	r8,zero
8112e984:	0027883a 	mov	r19,zero
8112e988:	29400304 	addi	r5,r5,12
8112e98c:	d9400f15 	stw	r5,60(sp)
8112e990:	402b883a 	mov	r21,r8
8112e994:	dd001215 	stw	r20,72(sp)
8112e998:	d8800817 	ldw	r2,32(sp)
8112e99c:	8009883a 	mov	r4,r16
8112e9a0:	11400117 	ldw	r5,4(r2)
8112e9a4:	112c9280 	call	8112c928 <_Balloc>
8112e9a8:	1029883a 	mov	r20,r2
8112e9ac:	10012d26 	beq	r2,zero,8112ee64 <_strtod_r+0xc78>
8112e9b0:	d8c00817 	ldw	r3,32(sp)
8112e9b4:	d9400f17 	ldw	r5,60(sp)
8112e9b8:	11000304 	addi	r4,r2,12
8112e9bc:	19800417 	ldw	r6,16(r3)
8112e9c0:	31800084 	addi	r6,r6,2
8112e9c4:	318d883a 	add	r6,r6,r6
8112e9c8:	318d883a 	add	r6,r6,r6
8112e9cc:	11223f40 	call	811223f4 <memcpy>
8112e9d0:	d9000204 	addi	r4,sp,8
8112e9d4:	d9000015 	stw	r4,0(sp)
8112e9d8:	d9c00404 	addi	r7,sp,16
8112e9dc:	900b883a 	mov	r5,r18
8112e9e0:	880d883a 	mov	r6,r17
8112e9e4:	8009883a 	mov	r4,r16
8112e9e8:	112d6040 	call	8112d604 <__d2b>
8112e9ec:	d8800515 	stw	r2,20(sp)
8112e9f0:	dc801115 	stw	r18,68(sp)
8112e9f4:	dc401015 	stw	r17,64(sp)
8112e9f8:	10027c26 	beq	r2,zero,8112f3ec <_strtod_r+0x1200>
8112e9fc:	01400044 	movi	r5,1
8112ea00:	8009883a 	mov	r4,r16
8112ea04:	112cd4c0 	call	8112cd4c <__i2b>
8112ea08:	1027883a 	mov	r19,r2
8112ea0c:	10011526 	beq	r2,zero,8112ee64 <_strtod_r+0xc78>
8112ea10:	d8800417 	ldw	r2,16(sp)
8112ea14:	1000c816 	blt	r2,zero,8112ed38 <_strtod_r+0xb4c>
8112ea18:	d9400c17 	ldw	r5,48(sp)
8112ea1c:	d9000a17 	ldw	r4,40(sp)
8112ea20:	28ad883a 	add	r22,r5,r2
8112ea24:	d9400917 	ldw	r5,36(sp)
8112ea28:	df000217 	ldw	fp,8(sp)
8112ea2c:	05ff0084 	movi	r23,-1022
8112ea30:	1147c83a 	sub	r3,r2,r5
8112ea34:	1f07883a 	add	r3,r3,fp
8112ea38:	00800d84 	movi	r2,54
8112ea3c:	18ffffc4 	addi	r3,r3,-1
8112ea40:	1739c83a 	sub	fp,r2,fp
8112ea44:	1dc0a50e 	bge	r3,r23,8112ecdc <_strtod_r+0xaf0>
8112ea48:	b8efc83a 	sub	r23,r23,r3
8112ea4c:	008007c4 	movi	r2,31
8112ea50:	e5f9c83a 	sub	fp,fp,r23
8112ea54:	15c0bc16 	blt	r2,r23,8112ed48 <_strtod_r+0xb5c>
8112ea58:	00800044 	movi	r2,1
8112ea5c:	15c4983a 	sll	r2,r2,r23
8112ea60:	d8000b15 	stw	zero,44(sp)
8112ea64:	d8800d15 	stw	r2,52(sp)
8112ea68:	2707883a 	add	r3,r4,fp
8112ea6c:	d9000917 	ldw	r4,36(sp)
8112ea70:	b739883a 	add	fp,r22,fp
8112ea74:	20ef883a 	add	r23,r4,r3
8112ea78:	b009883a 	mov	r4,r22
8112ea7c:	e580010e 	bge	fp,r22,8112ea84 <_strtod_r+0x898>
8112ea80:	e009883a 	mov	r4,fp
8112ea84:	b805883a 	mov	r2,r23
8112ea88:	25c0010e 	bge	r4,r23,8112ea90 <_strtod_r+0x8a4>
8112ea8c:	2005883a 	mov	r2,r4
8112ea90:	0080030e 	bge	zero,r2,8112eaa0 <_strtod_r+0x8b4>
8112ea94:	e0b9c83a 	sub	fp,fp,r2
8112ea98:	b8afc83a 	sub	r23,r23,r2
8112ea9c:	b0adc83a 	sub	r22,r22,r2
8112eaa0:	d9400c17 	ldw	r5,48(sp)
8112eaa4:	28001126 	beq	r5,zero,8112eaec <_strtod_r+0x900>
8112eaa8:	280d883a 	mov	r6,r5
8112eaac:	8009883a 	mov	r4,r16
8112eab0:	980b883a 	mov	r5,r19
8112eab4:	112cf900 	call	8112cf90 <__pow5mult>
8112eab8:	1027883a 	mov	r19,r2
8112eabc:	1000e926 	beq	r2,zero,8112ee64 <_strtod_r+0xc78>
8112eac0:	d9800517 	ldw	r6,20(sp)
8112eac4:	100b883a 	mov	r5,r2
8112eac8:	8009883a 	mov	r4,r16
8112eacc:	112cd900 	call	8112cd90 <__multiply>
8112ead0:	1000e426 	beq	r2,zero,8112ee64 <_strtod_r+0xc78>
8112ead4:	d9400517 	ldw	r5,20(sp)
8112ead8:	8009883a 	mov	r4,r16
8112eadc:	d8801315 	stw	r2,76(sp)
8112eae0:	112c9d80 	call	8112c9d8 <_Bfree>
8112eae4:	d8801317 	ldw	r2,76(sp)
8112eae8:	d8800515 	stw	r2,20(sp)
8112eaec:	0700060e 	bge	zero,fp,8112eb08 <_strtod_r+0x91c>
8112eaf0:	d9400517 	ldw	r5,20(sp)
8112eaf4:	e00d883a 	mov	r6,fp
8112eaf8:	8009883a 	mov	r4,r16
8112eafc:	112d0d80 	call	8112d0d8 <__lshift>
8112eb00:	d8800515 	stw	r2,20(sp)
8112eb04:	10023926 	beq	r2,zero,8112f3ec <_strtod_r+0x1200>
8112eb08:	d8800a17 	ldw	r2,40(sp)
8112eb0c:	10000626 	beq	r2,zero,8112eb28 <_strtod_r+0x93c>
8112eb10:	d9800a17 	ldw	r6,40(sp)
8112eb14:	a00b883a 	mov	r5,r20
8112eb18:	8009883a 	mov	r4,r16
8112eb1c:	112cf900 	call	8112cf90 <__pow5mult>
8112eb20:	1029883a 	mov	r20,r2
8112eb24:	1000cf26 	beq	r2,zero,8112ee64 <_strtod_r+0xc78>
8112eb28:	05c0060e 	bge	zero,r23,8112eb44 <_strtod_r+0x958>
8112eb2c:	a00b883a 	mov	r5,r20
8112eb30:	b80d883a 	mov	r6,r23
8112eb34:	8009883a 	mov	r4,r16
8112eb38:	112d0d80 	call	8112d0d8 <__lshift>
8112eb3c:	1029883a 	mov	r20,r2
8112eb40:	1000c826 	beq	r2,zero,8112ee64 <_strtod_r+0xc78>
8112eb44:	0580060e 	bge	zero,r22,8112eb60 <_strtod_r+0x974>
8112eb48:	980b883a 	mov	r5,r19
8112eb4c:	b00d883a 	mov	r6,r22
8112eb50:	8009883a 	mov	r4,r16
8112eb54:	112d0d80 	call	8112d0d8 <__lshift>
8112eb58:	1027883a 	mov	r19,r2
8112eb5c:	1000c126 	beq	r2,zero,8112ee64 <_strtod_r+0xc78>
8112eb60:	d9400517 	ldw	r5,20(sp)
8112eb64:	a00d883a 	mov	r6,r20
8112eb68:	8009883a 	mov	r4,r16
8112eb6c:	112d2880 	call	8112d288 <__mdiff>
8112eb70:	102b883a 	mov	r21,r2
8112eb74:	1000bb26 	beq	r2,zero,8112ee64 <_strtod_r+0xc78>
8112eb78:	10c00317 	ldw	r3,12(r2)
8112eb7c:	980b883a 	mov	r5,r19
8112eb80:	10000315 	stw	zero,12(r2)
8112eb84:	1009883a 	mov	r4,r2
8112eb88:	d8c00e15 	stw	r3,56(sp)
8112eb8c:	112d2280 	call	8112d228 <__mcmp>
8112eb90:	10027616 	blt	r2,zero,8112f56c <_strtod_r+0x1380>
8112eb94:	10024426 	beq	r2,zero,8112f4a8 <_strtod_r+0x12bc>
8112eb98:	980b883a 	mov	r5,r19
8112eb9c:	a809883a 	mov	r4,r21
8112eba0:	112d7580 	call	8112d758 <__ratio>
8112eba4:	000d883a 	mov	r6,zero
8112eba8:	01d00034 	movhi	r7,16384
8112ebac:	1009883a 	mov	r4,r2
8112ebb0:	180b883a 	mov	r5,r3
8112ebb4:	102f883a 	mov	r23,r2
8112ebb8:	182d883a 	mov	r22,r3
8112ebbc:	1135e600 	call	81135e60 <__ledf2>
8112ebc0:	00804a16 	blt	zero,r2,8112ecec <_strtod_r+0xb00>
8112ebc4:	d9400e17 	ldw	r5,56(sp)
8112ebc8:	28006b26 	beq	r5,zero,8112ed78 <_strtod_r+0xb8c>
8112ebcc:	058ffc34 	movhi	r22,16368
8112ebd0:	d8000b15 	stw	zero,44(sp)
8112ebd4:	d8000d15 	stw	zero,52(sp)
8112ebd8:	b02f883a 	mov	r23,r22
8112ebdc:	8f1ffc2c 	andhi	fp,r17,32752
8112ebe0:	009ff834 	movhi	r2,32736
8112ebe4:	e080cd26 	beq	fp,r2,8112ef1c <_strtod_r+0xd30>
8112ebe8:	d9400917 	ldw	r5,36(sp)
8112ebec:	28001a26 	beq	r5,zero,8112ec58 <_strtod_r+0xa6c>
8112ebf0:	0081a834 	movhi	r2,1696
8112ebf4:	17001836 	bltu	r2,fp,8112ec58 <_strtod_r+0xa6c>
8112ebf8:	d9000d17 	ldw	r4,52(sp)
8112ebfc:	01d07834 	movhi	r7,16864
8112ec00:	39ffffc4 	addi	r7,r7,-1
8112ec04:	01bff034 	movhi	r6,65472
8112ec08:	b80b883a 	mov	r5,r23
8112ec0c:	1135e600 	call	81135e60 <__ledf2>
8112ec10:	00800e16 	blt	zero,r2,8112ec4c <_strtod_r+0xa60>
8112ec14:	d9000d17 	ldw	r4,52(sp)
8112ec18:	b80b883a 	mov	r5,r23
8112ec1c:	111f15c0 	call	8111f15c <__fixunsdfsi>
8112ec20:	10018126 	beq	r2,zero,8112f228 <_strtod_r+0x103c>
8112ec24:	1009883a 	mov	r4,r2
8112ec28:	1135f540 	call	81135f54 <__floatunsidf>
8112ec2c:	d8800d15 	stw	r2,52(sp)
8112ec30:	182f883a 	mov	r23,r3
8112ec34:	d8800e17 	ldw	r2,56(sp)
8112ec38:	1001791e 	bne	r2,zero,8112f220 <_strtod_r+0x1034>
8112ec3c:	ba20003c 	xorhi	r8,r23,32768
8112ec40:	d8c00d17 	ldw	r3,52(sp)
8112ec44:	402d883a 	mov	r22,r8
8112ec48:	d8c00b15 	stw	r3,44(sp)
8112ec4c:	0081ac34 	movhi	r2,1712
8112ec50:	b091883a 	add	r8,r22,r2
8112ec54:	472dc83a 	sub	r22,r8,fp
8112ec58:	9009883a 	mov	r4,r18
8112ec5c:	880b883a 	mov	r5,r17
8112ec60:	112d48c0 	call	8112d48c <__ulp>
8112ec64:	d9000b17 	ldw	r4,44(sp)
8112ec68:	b00b883a 	mov	r5,r22
8112ec6c:	100d883a 	mov	r6,r2
8112ec70:	180f883a 	mov	r7,r3
8112ec74:	111fd240 	call	8111fd24 <__muldf3>
8112ec78:	900d883a 	mov	r6,r18
8112ec7c:	880f883a 	mov	r7,r17
8112ec80:	1009883a 	mov	r4,r2
8112ec84:	180b883a 	mov	r5,r3
8112ec88:	1134c340 	call	81134c34 <__adddf3>
8112ec8c:	1025883a 	mov	r18,r2
8112ec90:	1823883a 	mov	r17,r3
8112ec94:	182d883a 	mov	r22,r3
8112ec98:	d9000917 	ldw	r4,36(sp)
8112ec9c:	2000021e 	bne	r4,zero,8112eca8 <_strtod_r+0xabc>
8112eca0:	b09ffc2c 	andhi	r2,r22,32752
8112eca4:	e080be26 	beq	fp,r2,8112efa0 <_strtod_r+0xdb4>
8112eca8:	d9400517 	ldw	r5,20(sp)
8112ecac:	8009883a 	mov	r4,r16
8112ecb0:	112c9d80 	call	8112c9d8 <_Bfree>
8112ecb4:	a00b883a 	mov	r5,r20
8112ecb8:	8009883a 	mov	r4,r16
8112ecbc:	112c9d80 	call	8112c9d8 <_Bfree>
8112ecc0:	980b883a 	mov	r5,r19
8112ecc4:	8009883a 	mov	r4,r16
8112ecc8:	112c9d80 	call	8112c9d8 <_Bfree>
8112eccc:	a80b883a 	mov	r5,r21
8112ecd0:	8009883a 	mov	r4,r16
8112ecd4:	112c9d80 	call	8112c9d8 <_Bfree>
8112ecd8:	003f2f06 	br	8112e998 <__reset+0xfb10e998>
8112ecdc:	00c00044 	movi	r3,1
8112ece0:	d8000b15 	stw	zero,44(sp)
8112ece4:	d8c00d15 	stw	r3,52(sp)
8112ece8:	003f5f06 	br	8112ea68 <__reset+0xfb10ea68>
8112ecec:	b809883a 	mov	r4,r23
8112ecf0:	000d883a 	mov	r6,zero
8112ecf4:	01cff834 	movhi	r7,16352
8112ecf8:	b00b883a 	mov	r5,r22
8112ecfc:	111fd240 	call	8111fd24 <__muldf3>
8112ed00:	d9000e17 	ldw	r4,56(sp)
8112ed04:	d8800d15 	stw	r2,52(sp)
8112ed08:	182f883a 	mov	r23,r3
8112ed0c:	2000181e 	bne	r4,zero,8112ed70 <_strtod_r+0xb84>
8112ed10:	1a20003c 	xorhi	r8,r3,32768
8112ed14:	d8800b15 	stw	r2,44(sp)
8112ed18:	402d883a 	mov	r22,r8
8112ed1c:	003faf06 	br	8112ebdc <__reset+0xfb10ebdc>
8112ed20:	0015883a 	mov	r10,zero
8112ed24:	02c00044 	movi	r11,1
8112ed28:	2800011e 	bne	r5,zero,8112ed30 <_strtod_r+0xb44>
8112ed2c:	903d7e26 	beq	r18,zero,8112e328 <__reset+0xfb10e328>
8112ed30:	0013883a 	mov	r9,zero
8112ed34:	003e4706 	br	8112e654 <__reset+0xfb10e654>
8112ed38:	d8c00a17 	ldw	r3,40(sp)
8112ed3c:	dd800c17 	ldw	r22,48(sp)
8112ed40:	1889c83a 	sub	r4,r3,r2
8112ed44:	003f3706 	br	8112ea24 <__reset+0xfb10ea24>
8112ed48:	00bef884 	movi	r2,-1054
8112ed4c:	05c00044 	movi	r23,1
8112ed50:	10c5c83a 	sub	r2,r2,r3
8112ed54:	b884983a 	sll	r2,r23,r2
8112ed58:	ddc00d15 	stw	r23,52(sp)
8112ed5c:	d8800b15 	stw	r2,44(sp)
8112ed60:	003f4106 	br	8112ea68 <__reset+0xfb10ea68>
8112ed64:	ddc00615 	stw	r23,24(sp)
8112ed68:	002b883a 	mov	r21,zero
8112ed6c:	003dc306 	br	8112e47c <__reset+0xfb10e47c>
8112ed70:	1811883a 	mov	r8,r3
8112ed74:	003fe706 	br	8112ed14 <__reset+0xfb10ed14>
8112ed78:	90002e1e 	bne	r18,zero,8112ee34 <_strtod_r+0xc48>
8112ed7c:	00c00434 	movhi	r3,16
8112ed80:	18ffffc4 	addi	r3,r3,-1
8112ed84:	88c4703a 	and	r2,r17,r3
8112ed88:	10002c1e 	bne	r2,zero,8112ee3c <_strtod_r+0xc50>
8112ed8c:	000d883a 	mov	r6,zero
8112ed90:	01cffc34 	movhi	r7,16368
8112ed94:	b809883a 	mov	r4,r23
8112ed98:	b00b883a 	mov	r5,r22
8112ed9c:	1135e600 	call	81135e60 <__ledf2>
8112eda0:	10021716 	blt	r2,zero,8112f600 <_strtod_r+0x1414>
8112eda4:	b809883a 	mov	r4,r23
8112eda8:	b00b883a 	mov	r5,r22
8112edac:	000d883a 	mov	r6,zero
8112edb0:	01cff834 	movhi	r7,16352
8112edb4:	111fd240 	call	8111fd24 <__muldf3>
8112edb8:	d8800d15 	stw	r2,52(sp)
8112edbc:	182f883a 	mov	r23,r3
8112edc0:	102d883a 	mov	r22,r2
8112edc4:	1a20003c 	xorhi	r8,r3,32768
8112edc8:	dd800b15 	stw	r22,44(sp)
8112edcc:	402d883a 	mov	r22,r8
8112edd0:	003f8206 	br	8112ebdc <__reset+0xfb10ebdc>
8112edd4:	b013883a 	mov	r9,r22
8112edd8:	000b883a 	mov	r5,zero
8112eddc:	0015883a 	mov	r10,zero
8112ede0:	893ff404 	addi	r4,r17,-48
8112ede4:	00800244 	movi	r2,9
8112ede8:	11001036 	bltu	r2,r4,8112ee2c <_strtod_r+0xc40>
8112edec:	28c00044 	addi	r3,r5,1
8112edf0:	2023883a 	mov	r17,r4
8112edf4:	20014d1e 	bne	r4,zero,8112f32c <_strtod_r+0x1140>
8112edf8:	d9800617 	ldw	r6,24(sp)
8112edfc:	180b883a 	mov	r5,r3
8112ee00:	30800044 	addi	r2,r6,1
8112ee04:	d8800615 	stw	r2,24(sp)
8112ee08:	34400047 	ldb	r17,1(r6)
8112ee0c:	003ff406 	br	8112ede0 <__reset+0xfb10ede0>
8112ee10:	0019883a 	mov	r12,zero
8112ee14:	b8800084 	addi	r2,r23,2
8112ee18:	d8800615 	stw	r2,24(sp)
8112ee1c:	bc400087 	ldb	r17,2(r23)
8112ee20:	003e1606 	br	8112e67c <__reset+0xfb10e67c>
8112ee24:	03000044 	movi	r12,1
8112ee28:	003ffa06 	br	8112ee14 <__reset+0xfb10ee14>
8112ee2c:	02c00044 	movi	r11,1
8112ee30:	003d8d06 	br	8112e468 <__reset+0xfb10e468>
8112ee34:	00800044 	movi	r2,1
8112ee38:	9080fe26 	beq	r18,r2,8112f234 <_strtod_r+0x1048>
8112ee3c:	d8000b15 	stw	zero,44(sp)
8112ee40:	05affc34 	movhi	r22,49136
8112ee44:	d8000d15 	stw	zero,52(sp)
8112ee48:	05cffc34 	movhi	r23,16368
8112ee4c:	003f6306 	br	8112ebdc <__reset+0xfb10ebdc>
8112ee50:	d8000a15 	stw	zero,40(sp)
8112ee54:	003ec906 	br	8112e97c <__reset+0xfb10e97c>
8112ee58:	d9001117 	ldw	r4,68(sp)
8112ee5c:	00bfffc4 	movi	r2,-1
8112ee60:	2080461e 	bne	r4,r2,8112ef7c <_strtod_r+0xd90>
8112ee64:	dd000a15 	stw	r20,40(sp)
8112ee68:	dd001217 	ldw	r20,72(sp)
8112ee6c:	a811883a 	mov	r8,r21
8112ee70:	d8800517 	ldw	r2,20(sp)
8112ee74:	00c00884 	movi	r3,34
8112ee78:	80c00015 	stw	r3,0(r16)
8112ee7c:	002b883a 	mov	r21,zero
8112ee80:	059ffc34 	movhi	r22,32752
8112ee84:	100b883a 	mov	r5,r2
8112ee88:	8009883a 	mov	r4,r16
8112ee8c:	da001315 	stw	r8,76(sp)
8112ee90:	112c9d80 	call	8112c9d8 <_Bfree>
8112ee94:	d9400a17 	ldw	r5,40(sp)
8112ee98:	8009883a 	mov	r4,r16
8112ee9c:	112c9d80 	call	8112c9d8 <_Bfree>
8112eea0:	980b883a 	mov	r5,r19
8112eea4:	8009883a 	mov	r4,r16
8112eea8:	112c9d80 	call	8112c9d8 <_Bfree>
8112eeac:	d9400817 	ldw	r5,32(sp)
8112eeb0:	8009883a 	mov	r4,r16
8112eeb4:	112c9d80 	call	8112c9d8 <_Bfree>
8112eeb8:	da001317 	ldw	r8,76(sp)
8112eebc:	8009883a 	mov	r4,r16
8112eec0:	400b883a 	mov	r5,r8
8112eec4:	112c9d80 	call	8112c9d8 <_Bfree>
8112eec8:	003d9206 	br	8112e514 <__reset+0xfb10e514>
8112eecc:	d8c00717 	ldw	r3,28(sp)
8112eed0:	d8800504 	addi	r2,sp,20
8112eed4:	01a04574 	movhi	r6,33045
8112eed8:	31829904 	addi	r6,r6,2660
8112eedc:	d8c00115 	stw	r3,4(sp)
8112eee0:	d8800015 	stw	r2,0(sp)
8112eee4:	d9c00404 	addi	r7,sp,16
8112eee8:	d9400604 	addi	r5,sp,24
8112eeec:	8009883a 	mov	r4,r16
8112eef0:	11330580 	call	81133058 <__gethex>
8112eef4:	154001cc 	andi	r21,r2,7
8112eef8:	a83d9b26 	beq	r21,zero,8112e568 <__reset+0xfb10e568>
8112eefc:	00c00184 	movi	r3,6
8112ef00:	a8c0d61e 	bne	r21,r3,8112f25c <_strtod_r+0x1070>
8112ef04:	9cc00044 	addi	r19,r19,1
8112ef08:	dcc00615 	stw	r19,24(sp)
8112ef0c:	002b883a 	mov	r21,zero
8112ef10:	002d883a 	mov	r22,zero
8112ef14:	d8000715 	stw	zero,28(sp)
8112ef18:	003d7e06 	br	8112e514 <__reset+0xfb10e514>
8112ef1c:	00bf2c34 	movhi	r2,64688
8112ef20:	88a3883a 	add	r17,r17,r2
8112ef24:	9009883a 	mov	r4,r18
8112ef28:	880b883a 	mov	r5,r17
8112ef2c:	112d48c0 	call	8112d48c <__ulp>
8112ef30:	d9000b17 	ldw	r4,44(sp)
8112ef34:	100d883a 	mov	r6,r2
8112ef38:	180f883a 	mov	r7,r3
8112ef3c:	b00b883a 	mov	r5,r22
8112ef40:	111fd240 	call	8111fd24 <__muldf3>
8112ef44:	900d883a 	mov	r6,r18
8112ef48:	180b883a 	mov	r5,r3
8112ef4c:	880f883a 	mov	r7,r17
8112ef50:	1009883a 	mov	r4,r2
8112ef54:	1134c340 	call	81134c34 <__adddf3>
8112ef58:	015f2834 	movhi	r5,31904
8112ef5c:	1025883a 	mov	r18,r2
8112ef60:	297fffc4 	addi	r5,r5,-1
8112ef64:	189ffc2c 	andhi	r2,r3,32752
8112ef68:	2880892e 	bgeu	r5,r2,8112f190 <_strtod_r+0xfa4>
8112ef6c:	d8801017 	ldw	r2,64(sp)
8112ef70:	00dffc34 	movhi	r3,32752
8112ef74:	18ffffc4 	addi	r3,r3,-1
8112ef78:	10ffb726 	beq	r2,r3,8112ee58 <__reset+0xfb10ee58>
8112ef7c:	045ffc34 	movhi	r17,32752
8112ef80:	8c7fffc4 	addi	r17,r17,-1
8112ef84:	04bfffc4 	movi	r18,-1
8112ef88:	003f4706 	br	8112eca8 <__reset+0xfb10eca8>
8112ef8c:	00800884 	movi	r2,34
8112ef90:	80800015 	stw	r2,0(r16)
8112ef94:	002b883a 	mov	r21,zero
8112ef98:	059ffc34 	movhi	r22,32752
8112ef9c:	003d5d06 	br	8112e514 <__reset+0xfb10e514>
8112efa0:	d9000d17 	ldw	r4,52(sp)
8112efa4:	b80b883a 	mov	r5,r23
8112efa8:	1120d480 	call	81120d48 <__fixdfsi>
8112efac:	1009883a 	mov	r4,r2
8112efb0:	1120dc80 	call	81120dc8 <__floatsidf>
8112efb4:	d9000d17 	ldw	r4,52(sp)
8112efb8:	b80b883a 	mov	r5,r23
8112efbc:	100d883a 	mov	r6,r2
8112efc0:	180f883a 	mov	r7,r3
8112efc4:	11204440 	call	81120444 <__subdf3>
8112efc8:	d9400e17 	ldw	r5,56(sp)
8112efcc:	1039883a 	mov	fp,r2
8112efd0:	182f883a 	mov	r23,r3
8112efd4:	2800141e 	bne	r5,zero,8112f028 <_strtod_r+0xe3c>
8112efd8:	9000131e 	bne	r18,zero,8112f028 <_strtod_r+0xe3c>
8112efdc:	00800434 	movhi	r2,16
8112efe0:	10bfffc4 	addi	r2,r2,-1
8112efe4:	b0ac703a 	and	r22,r22,r2
8112efe8:	b0000f1e 	bne	r22,zero,8112f028 <_strtod_r+0xe3c>
8112efec:	01a52834 	movhi	r6,38048
8112eff0:	01cff434 	movhi	r7,16336
8112eff4:	318d6544 	addi	r6,r6,13717
8112eff8:	39ffffc4 	addi	r7,r7,-1
8112effc:	e009883a 	mov	r4,fp
8112f000:	180b883a 	mov	r5,r3
8112f004:	1135e600 	call	81135e60 <__ledf2>
8112f008:	103f270e 	bge	r2,zero,8112eca8 <__reset+0xfb10eca8>
8112f00c:	dd000a15 	stw	r20,40(sp)
8112f010:	a811883a 	mov	r8,r21
8112f014:	dd001217 	ldw	r20,72(sp)
8112f018:	d8800517 	ldw	r2,20(sp)
8112f01c:	002b883a 	mov	r21,zero
8112f020:	882d883a 	mov	r22,r17
8112f024:	003f9706 	br	8112ee84 <__reset+0xfb10ee84>
8112f028:	01a52834 	movhi	r6,38048
8112f02c:	01cff834 	movhi	r7,16352
8112f030:	318d6544 	addi	r6,r6,13717
8112f034:	39ffffc4 	addi	r7,r7,-1
8112f038:	e009883a 	mov	r4,fp
8112f03c:	b80b883a 	mov	r5,r23
8112f040:	1135e600 	call	81135e60 <__ledf2>
8112f044:	10000716 	blt	r2,zero,8112f064 <_strtod_r+0xe78>
8112f048:	018d6c34 	movhi	r6,13744
8112f04c:	31b94d44 	addi	r6,r6,-6859
8112f050:	01cff834 	movhi	r7,16352
8112f054:	e009883a 	mov	r4,fp
8112f058:	b80b883a 	mov	r5,r23
8112f05c:	111fc480 	call	8111fc48 <__gedf2>
8112f060:	00bf110e 	bge	zero,r2,8112eca8 <__reset+0xfb10eca8>
8112f064:	dd000a15 	stw	r20,40(sp)
8112f068:	a811883a 	mov	r8,r21
8112f06c:	dd001217 	ldw	r20,72(sp)
8112f070:	d8800517 	ldw	r2,20(sp)
8112f074:	902b883a 	mov	r21,r18
8112f078:	882d883a 	mov	r22,r17
8112f07c:	003f8106 	br	8112ee84 <__reset+0xfb10ee84>
8112f080:	b83e2f26 	beq	r23,zero,8112e940 <__reset+0xfb10e940>
8112f084:	05efc83a 	sub	r23,zero,r23
8112f088:	b88003cc 	andi	r2,r23,15
8112f08c:	10000d26 	beq	r2,zero,8112f0c4 <_strtod_r+0xed8>
8112f090:	100490fa 	slli	r2,r2,3
8112f094:	00e04574 	movhi	r3,33045
8112f098:	18c25e04 	addi	r3,r3,2424
8112f09c:	1885883a 	add	r2,r3,r2
8112f0a0:	11800017 	ldw	r6,0(r2)
8112f0a4:	11c00117 	ldw	r7,4(r2)
8112f0a8:	9009883a 	mov	r4,r18
8112f0ac:	880b883a 	mov	r5,r17
8112f0b0:	da401315 	stw	r9,76(sp)
8112f0b4:	11354e80 	call	811354e8 <__divdf3>
8112f0b8:	da401317 	ldw	r9,76(sp)
8112f0bc:	1025883a 	mov	r18,r2
8112f0c0:	1823883a 	mov	r17,r3
8112f0c4:	b82fd13a 	srai	r23,r23,4
8112f0c8:	b83e1d26 	beq	r23,zero,8112e940 <__reset+0xfb10e940>
8112f0cc:	008007c4 	movi	r2,31
8112f0d0:	15c02816 	blt	r2,r23,8112f174 <_strtod_r+0xf88>
8112f0d4:	b880040c 	andi	r2,r23,16
8112f0d8:	10019726 	beq	r2,zero,8112f738 <_strtod_r+0x154c>
8112f0dc:	05c1880e 	bge	zero,r23,8112f700 <_strtod_r+0x1514>
8112f0e0:	00c01a84 	movi	r3,106
8112f0e4:	d8c00915 	stw	r3,36(sp)
8112f0e8:	04e04574 	movhi	r19,33045
8112f0ec:	9cc29e04 	addi	r19,r19,2680
8112f0f0:	8807883a 	mov	r3,r17
8112f0f4:	9005883a 	mov	r2,r18
8112f0f8:	8023883a 	mov	r17,r16
8112f0fc:	0009883a 	mov	r4,zero
8112f100:	9821883a 	mov	r16,r19
8112f104:	da400a15 	stw	r9,40(sp)
8112f108:	1827883a 	mov	r19,r3
8112f10c:	b980004c 	andi	r6,r23,1
8112f110:	30000626 	beq	r6,zero,8112f12c <_strtod_r+0xf40>
8112f114:	81800017 	ldw	r6,0(r16)
8112f118:	81c00117 	ldw	r7,4(r16)
8112f11c:	1009883a 	mov	r4,r2
8112f120:	180b883a 	mov	r5,r3
8112f124:	111fd240 	call	8111fd24 <__muldf3>
8112f128:	01000044 	movi	r4,1
8112f12c:	b82fd07a 	srai	r23,r23,1
8112f130:	84000204 	addi	r16,r16,8
8112f134:	b83ff51e 	bne	r23,zero,8112f10c <__reset+0xfb10f10c>
8112f138:	21003fcc 	andi	r4,r4,255
8112f13c:	8821883a 	mov	r16,r17
8112f140:	da400a17 	ldw	r9,40(sp)
8112f144:	9823883a 	mov	r17,r19
8112f148:	2001a51e 	bne	r4,zero,8112f7e0 <_strtod_r+0x15f4>
8112f14c:	d9000917 	ldw	r4,36(sp)
8112f150:	20016d1e 	bne	r4,zero,8112f708 <_strtod_r+0x151c>
8112f154:	000d883a 	mov	r6,zero
8112f158:	000f883a 	mov	r7,zero
8112f15c:	9009883a 	mov	r4,r18
8112f160:	880b883a 	mov	r5,r17
8112f164:	da401315 	stw	r9,76(sp)
8112f168:	1135dd80 	call	81135dd8 <__eqdf2>
8112f16c:	da401317 	ldw	r9,76(sp)
8112f170:	103df41e 	bne	r2,zero,8112e944 <__reset+0xfb10e944>
8112f174:	00800884 	movi	r2,34
8112f178:	80800015 	stw	r2,0(r16)
8112f17c:	002b883a 	mov	r21,zero
8112f180:	002d883a 	mov	r22,zero
8112f184:	003ce306 	br	8112e514 <__reset+0xfb10e514>
8112f188:	055387c4 	movi	r21,19999
8112f18c:	003d6b06 	br	8112e73c <__reset+0xfb10e73c>
8112f190:	0440d434 	movhi	r17,848
8112f194:	1c63883a 	add	r17,r3,r17
8112f198:	882d883a 	mov	r22,r17
8112f19c:	003ebe06 	br	8112ec98 <__reset+0xfb10ec98>
8112f1a0:	14403fcc 	andi	r17,r2,255
8112f1a4:	8c40201c 	xori	r17,r17,128
8112f1a8:	8c7fe004 	addi	r17,r17,-128
8112f1ac:	dd400817 	ldw	r21,32(sp)
8112f1b0:	0027883a 	mov	r19,zero
8112f1b4:	0039883a 	mov	fp,zero
8112f1b8:	002d883a 	mov	r22,zero
8112f1bc:	003c9906 	br	8112e424 <__reset+0xfb10e424>
8112f1c0:	00c00944 	movi	r3,37
8112f1c4:	1a47c83a 	sub	r3,r3,r9
8112f1c8:	1d7d8c16 	blt	r3,r21,8112e7fc <__reset+0xfb10e7fc>
8112f1cc:	1261c83a 	sub	r16,r2,r9
8112f1d0:	800490fa 	slli	r2,r16,3
8112f1d4:	04e04574 	movhi	r19,33045
8112f1d8:	9cc25e04 	addi	r19,r19,2424
8112f1dc:	9885883a 	add	r2,r19,r2
8112f1e0:	11000017 	ldw	r4,0(r2)
8112f1e4:	11400117 	ldw	r5,4(r2)
8112f1e8:	900d883a 	mov	r6,r18
8112f1ec:	880f883a 	mov	r7,r17
8112f1f0:	111fd240 	call	8111fd24 <__muldf3>
8112f1f4:	ac0dc83a 	sub	r6,r21,r16
8112f1f8:	300c90fa 	slli	r6,r6,3
8112f1fc:	1009883a 	mov	r4,r2
8112f200:	180b883a 	mov	r5,r3
8112f204:	9985883a 	add	r2,r19,r6
8112f208:	11800017 	ldw	r6,0(r2)
8112f20c:	11c00117 	ldw	r7,4(r2)
8112f210:	111fd240 	call	8111fd24 <__muldf3>
8112f214:	102b883a 	mov	r21,r2
8112f218:	182d883a 	mov	r22,r3
8112f21c:	003cbd06 	br	8112e514 <__reset+0xfb10e514>
8112f220:	b811883a 	mov	r8,r23
8112f224:	003e8606 	br	8112ec40 <__reset+0xfb10ec40>
8112f228:	d8000d15 	stw	zero,52(sp)
8112f22c:	05cffc34 	movhi	r23,16368
8112f230:	003e8006 	br	8112ec34 <__reset+0xfb10ec34>
8112f234:	883f011e 	bne	r17,zero,8112ee3c <__reset+0xfb10ee3c>
8112f238:	dd000a15 	stw	r20,40(sp)
8112f23c:	dd001217 	ldw	r20,72(sp)
8112f240:	a811883a 	mov	r8,r21
8112f244:	00800884 	movi	r2,34
8112f248:	80800015 	stw	r2,0(r16)
8112f24c:	002b883a 	mov	r21,zero
8112f250:	d8800517 	ldw	r2,20(sp)
8112f254:	002d883a 	mov	r22,zero
8112f258:	003f0a06 	br	8112ee84 <__reset+0xfb10ee84>
8112f25c:	d9800517 	ldw	r6,20(sp)
8112f260:	30000826 	beq	r6,zero,8112f284 <_strtod_r+0x1098>
8112f264:	01400d44 	movi	r5,53
8112f268:	d9000204 	addi	r4,sp,8
8112f26c:	d8801315 	stw	r2,76(sp)
8112f270:	112d8800 	call	8112d880 <__copybits>
8112f274:	d9400517 	ldw	r5,20(sp)
8112f278:	8009883a 	mov	r4,r16
8112f27c:	112c9d80 	call	8112c9d8 <_Bfree>
8112f280:	d8801317 	ldw	r2,76(sp)
8112f284:	00c00184 	movi	r3,6
8112f288:	1d400f36 	bltu	r3,r21,8112f2c8 <_strtod_r+0x10dc>
8112f28c:	a82a90ba 	slli	r21,r21,2
8112f290:	00e044f4 	movhi	r3,33043
8112f294:	18fca904 	addi	r3,r3,-3420
8112f298:	a8eb883a 	add	r21,r21,r3
8112f29c:	a8c00017 	ldw	r3,0(r21)
8112f2a0:	1800683a 	jmp	r3
8112f2a4:	8112f320 	cmpeqi	r4,r16,19404
8112f2a8:	8112f2f8 	rdprs	r4,r16,19403
8112f2ac:	8112f2dc 	xori	r4,r16,19403
8112f2b0:	8112f2c0 	call	88112f2c <__reset+0x20f2f2c>
8112f2b4:	8112f2e8 	cmpgeui	r4,r16,19403
8112f2b8:	8112f2f8 	rdprs	r4,r16,19403
8112f2bc:	8112f320 	cmpeqi	r4,r16,19404
8112f2c0:	045ffc34 	movhi	r17,32752
8112f2c4:	0025883a 	mov	r18,zero
8112f2c8:	1080020c 	andi	r2,r2,8
8112f2cc:	902b883a 	mov	r21,r18
8112f2d0:	103c8f26 	beq	r2,zero,8112e510 <__reset+0xfb10e510>
8112f2d4:	8da00034 	orhi	r22,r17,32768
8112f2d8:	003c8e06 	br	8112e514 <__reset+0xfb10e514>
8112f2dc:	dc800217 	ldw	r18,8(sp)
8112f2e0:	dc400317 	ldw	r17,12(sp)
8112f2e4:	003ff806 	br	8112f2c8 <__reset+0xfb10f2c8>
8112f2e8:	04600034 	movhi	r17,32768
8112f2ec:	8c7fffc4 	addi	r17,r17,-1
8112f2f0:	04bfffc4 	movi	r18,-1
8112f2f4:	003ff406 	br	8112f2c8 <__reset+0xfb10f2c8>
8112f2f8:	d8c00417 	ldw	r3,16(sp)
8112f2fc:	dc400317 	ldw	r17,12(sp)
8112f300:	013ffc34 	movhi	r4,65520
8112f304:	18c10cc4 	addi	r3,r3,1075
8112f308:	1806953a 	slli	r3,r3,20
8112f30c:	213fffc4 	addi	r4,r4,-1
8112f310:	8922703a 	and	r17,r17,r4
8112f314:	dc800217 	ldw	r18,8(sp)
8112f318:	88e2b03a 	or	r17,r17,r3
8112f31c:	003fea06 	br	8112f2c8 <__reset+0xfb10f2c8>
8112f320:	0023883a 	mov	r17,zero
8112f324:	0025883a 	mov	r18,zero
8112f328:	003fe706 	br	8112f2c8 <__reset+0xfb10f2c8>
8112f32c:	01800044 	movi	r6,1
8112f330:	50d5883a 	add	r10,r10,r3
8112f334:	2a4b883a 	add	r5,r5,r9
8112f338:	19811a26 	beq	r3,r6,8112f7a4 <_strtod_r+0x15b8>
8112f33c:	01800204 	movi	r6,8
8112f340:	01c00404 	movi	r7,16
8112f344:	4a400044 	addi	r9,r9,1
8112f348:	48bfffc4 	addi	r2,r9,-1
8112f34c:	30801616 	blt	r6,r2,8112f3a8 <_strtod_r+0x11bc>
8112f350:	e70002a4 	muli	fp,fp,10
8112f354:	497ffb1e 	bne	r9,r5,8112f344 <__reset+0xfb10f344>
8112f358:	d9800617 	ldw	r6,24(sp)
8112f35c:	4a400044 	addi	r9,r9,1
8112f360:	00c00204 	movi	r3,8
8112f364:	19400c0e 	bge	r3,r5,8112f398 <_strtod_r+0x11ac>
8112f368:	00800404 	movi	r2,16
8112f36c:	000b883a 	mov	r5,zero
8112f370:	127ea316 	blt	r2,r9,8112ee00 <__reset+0xfb10ee00>
8112f374:	988002a4 	muli	r2,r19,10
8112f378:	20a7883a 	add	r19,r4,r2
8112f37c:	003ea006 	br	8112ee00 <__reset+0xfb10ee00>
8112f380:	d8800617 	ldw	r2,24(sp)
8112f384:	8c7ff404 	addi	r17,r17,-48
8112f388:	2a800044 	addi	r10,r5,1
8112f38c:	d8800815 	stw	r2,32(sp)
8112f390:	100d883a 	mov	r6,r2
8112f394:	02400044 	movi	r9,1
8112f398:	e08002a4 	muli	r2,fp,10
8112f39c:	000b883a 	mov	r5,zero
8112f3a0:	88b9883a 	add	fp,r17,r2
8112f3a4:	003e9606 	br	8112ee00 <__reset+0xfb10ee00>
8112f3a8:	3a7fea16 	blt	r7,r9,8112f354 <__reset+0xfb10f354>
8112f3ac:	9cc002a4 	muli	r19,r19,10
8112f3b0:	003fe806 	br	8112f354 <__reset+0xfb10f354>
8112f3b4:	00bffa84 	movi	r2,-22
8112f3b8:	a8bd1016 	blt	r21,r2,8112e7fc <__reset+0xfb10e7fc>
8112f3bc:	a82a90fa 	slli	r21,r21,3
8112f3c0:	00a04574 	movhi	r2,33045
8112f3c4:	10825e04 	addi	r2,r2,2424
8112f3c8:	1545c83a 	sub	r2,r2,r21
8112f3cc:	11800017 	ldw	r6,0(r2)
8112f3d0:	11c00117 	ldw	r7,4(r2)
8112f3d4:	9009883a 	mov	r4,r18
8112f3d8:	880b883a 	mov	r5,r17
8112f3dc:	11354e80 	call	811354e8 <__divdf3>
8112f3e0:	102b883a 	mov	r21,r2
8112f3e4:	182d883a 	mov	r22,r3
8112f3e8:	003c4a06 	br	8112e514 <__reset+0xfb10e514>
8112f3ec:	dd000a15 	stw	r20,40(sp)
8112f3f0:	a811883a 	mov	r8,r21
8112f3f4:	dd001217 	ldw	r20,72(sp)
8112f3f8:	003e9e06 	br	8112ee74 <__reset+0xfb10ee74>
8112f3fc:	01604574 	movhi	r5,33045
8112f400:	d9000617 	ldw	r4,24(sp)
8112f404:	29429004 	addi	r5,r5,2624
8112f408:	01c00644 	movi	r7,25
8112f40c:	00000b06 	br	8112f43c <_strtod_r+0x1250>
8112f410:	21000044 	addi	r4,r4,1
8112f414:	20800003 	ldbu	r2,0(r4)
8112f418:	10ffefc4 	addi	r3,r2,-65
8112f41c:	10803fcc 	andi	r2,r2,255
8112f420:	1080201c 	xori	r2,r2,128
8112f424:	18c03fcc 	andi	r3,r3,255
8112f428:	10bfe004 	addi	r2,r2,-128
8112f42c:	38c00136 	bltu	r7,r3,8112f434 <_strtod_r+0x1248>
8112f430:	10800804 	addi	r2,r2,32
8112f434:	29400044 	addi	r5,r5,1
8112f438:	11bbbb1e 	bne	r2,r6,8112e328 <__reset+0xfb10e328>
8112f43c:	29800007 	ldb	r6,0(r5)
8112f440:	303ff31e 	bne	r6,zero,8112f410 <__reset+0xfb10f410>
8112f444:	01a04574 	movhi	r6,33045
8112f448:	d9000615 	stw	r4,24(sp)
8112f44c:	31829104 	addi	r6,r6,2628
8112f450:	200b883a 	mov	r5,r4
8112f454:	02000644 	movi	r8,25
8112f458:	00000a06 	br	8112f484 <_strtod_r+0x1298>
8112f45c:	28800003 	ldbu	r2,0(r5)
8112f460:	10ffefc4 	addi	r3,r2,-65
8112f464:	10803fcc 	andi	r2,r2,255
8112f468:	1080201c 	xori	r2,r2,128
8112f46c:	18c03fcc 	andi	r3,r3,255
8112f470:	10bfe004 	addi	r2,r2,-128
8112f474:	40c00136 	bltu	r8,r3,8112f47c <_strtod_r+0x1290>
8112f478:	10800804 	addi	r2,r2,32
8112f47c:	31800044 	addi	r6,r6,1
8112f480:	11c0711e 	bne	r2,r7,8112f648 <_strtod_r+0x145c>
8112f484:	31c00007 	ldb	r7,0(r6)
8112f488:	29400044 	addi	r5,r5,1
8112f48c:	383ff31e 	bne	r7,zero,8112f45c <__reset+0xfb10f45c>
8112f490:	d9400615 	stw	r5,24(sp)
8112f494:	045ffc34 	movhi	r17,32752
8112f498:	0025883a 	mov	r18,zero
8112f49c:	003c1b06 	br	8112e50c <__reset+0xfb10e50c>
8112f4a0:	000b883a 	mov	r5,zero
8112f4a4:	003ccc06 	br	8112e7d8 <__reset+0xfb10e7d8>
8112f4a8:	d9400e17 	ldw	r5,56(sp)
8112f4ac:	dd000a15 	stw	r20,40(sp)
8112f4b0:	00800434 	movhi	r2,16
8112f4b4:	a811883a 	mov	r8,r21
8112f4b8:	dd001217 	ldw	r20,72(sp)
8112f4bc:	dd401117 	ldw	r21,68(sp)
8112f4c0:	dd801017 	ldw	r22,64(sp)
8112f4c4:	10bfffc4 	addi	r2,r2,-1
8112f4c8:	28005626 	beq	r5,zero,8112f624 <_strtod_r+0x1438>
8112f4cc:	8886703a 	and	r3,r17,r2
8112f4d0:	18807826 	beq	r3,r2,8112f6b4 <_strtod_r+0x14c8>
8112f4d4:	d8c00b17 	ldw	r3,44(sp)
8112f4d8:	18005726 	beq	r3,zero,8112f638 <_strtod_r+0x144c>
8112f4dc:	1c44703a 	and	r2,r3,r17
8112f4e0:	10000f26 	beq	r2,zero,8112f520 <_strtod_r+0x1334>
8112f4e4:	d9000e17 	ldw	r4,56(sp)
8112f4e8:	d9800917 	ldw	r6,36(sp)
8112f4ec:	20005e26 	beq	r4,zero,8112f668 <_strtod_r+0x147c>
8112f4f0:	9009883a 	mov	r4,r18
8112f4f4:	880b883a 	mov	r5,r17
8112f4f8:	da001315 	stw	r8,76(sp)
8112f4fc:	112e1800 	call	8112e180 <sulp>
8112f500:	100d883a 	mov	r6,r2
8112f504:	180f883a 	mov	r7,r3
8112f508:	9009883a 	mov	r4,r18
8112f50c:	880b883a 	mov	r5,r17
8112f510:	1134c340 	call	81134c34 <__adddf3>
8112f514:	da001317 	ldw	r8,76(sp)
8112f518:	102b883a 	mov	r21,r2
8112f51c:	182d883a 	mov	r22,r3
8112f520:	d8c00917 	ldw	r3,36(sp)
8112f524:	18000f26 	beq	r3,zero,8112f564 <_strtod_r+0x1378>
8112f528:	a809883a 	mov	r4,r21
8112f52c:	b00b883a 	mov	r5,r22
8112f530:	000d883a 	mov	r6,zero
8112f534:	01ce5434 	movhi	r7,14672
8112f538:	da001315 	stw	r8,76(sp)
8112f53c:	111fd240 	call	8111fd24 <__muldf3>
8112f540:	102b883a 	mov	r21,r2
8112f544:	182d883a 	mov	r22,r3
8112f548:	da001317 	ldw	r8,76(sp)
8112f54c:	1800051e 	bne	r3,zero,8112f564 <_strtod_r+0x1378>
8112f550:	d8800517 	ldw	r2,20(sp)
8112f554:	a83e4b1e 	bne	r21,zero,8112ee84 <__reset+0xfb10ee84>
8112f558:	00c00884 	movi	r3,34
8112f55c:	80c00015 	stw	r3,0(r16)
8112f560:	003e4806 	br	8112ee84 <__reset+0xfb10ee84>
8112f564:	d8800517 	ldw	r2,20(sp)
8112f568:	003e4606 	br	8112ee84 <__reset+0xfb10ee84>
8112f56c:	d9000e17 	ldw	r4,56(sp)
8112f570:	dd000a15 	stw	r20,40(sp)
8112f574:	a811883a 	mov	r8,r21
8112f578:	dd001217 	ldw	r20,72(sp)
8112f57c:	dd401117 	ldw	r21,68(sp)
8112f580:	dd801017 	ldw	r22,64(sp)
8112f584:	203fe61e 	bne	r4,zero,8112f520 <__reset+0xfb10f520>
8112f588:	903fe51e 	bne	r18,zero,8112f520 <__reset+0xfb10f520>
8112f58c:	00800434 	movhi	r2,16
8112f590:	10bfffc4 	addi	r2,r2,-1
8112f594:	8884703a 	and	r2,r17,r2
8112f598:	103fe11e 	bne	r2,zero,8112f520 <__reset+0xfb10f520>
8112f59c:	8ddffc2c 	andhi	r23,r17,32752
8112f5a0:	0081ac34 	movhi	r2,1712
8112f5a4:	15ffde2e 	bgeu	r2,r23,8112f520 <__reset+0xfb10f520>
8112f5a8:	40800517 	ldw	r2,20(r8)
8112f5ac:	1000031e 	bne	r2,zero,8112f5bc <_strtod_r+0x13d0>
8112f5b0:	40800417 	ldw	r2,16(r8)
8112f5b4:	00c00044 	movi	r3,1
8112f5b8:	18bfd90e 	bge	r3,r2,8112f520 <__reset+0xfb10f520>
8112f5bc:	400b883a 	mov	r5,r8
8112f5c0:	01800044 	movi	r6,1
8112f5c4:	8009883a 	mov	r4,r16
8112f5c8:	112d0d80 	call	8112d0d8 <__lshift>
8112f5cc:	980b883a 	mov	r5,r19
8112f5d0:	1009883a 	mov	r4,r2
8112f5d4:	d8801315 	stw	r2,76(sp)
8112f5d8:	112d2280 	call	8112d228 <__mcmp>
8112f5dc:	da001317 	ldw	r8,76(sp)
8112f5e0:	00bfcf0e 	bge	zero,r2,8112f520 <__reset+0xfb10f520>
8112f5e4:	d8c00917 	ldw	r3,36(sp)
8112f5e8:	18005c26 	beq	r3,zero,8112f75c <_strtod_r+0x1570>
8112f5ec:	0081ac34 	movhi	r2,1712
8112f5f0:	15c05a16 	blt	r2,r23,8112f75c <_strtod_r+0x1570>
8112f5f4:	0080dc34 	movhi	r2,880
8112f5f8:	15ffcb16 	blt	r2,r23,8112f528 <__reset+0xfb10f528>
8112f5fc:	003f1106 	br	8112f244 <__reset+0xfb10f244>
8112f600:	002d883a 	mov	r22,zero
8112f604:	022ff834 	movhi	r8,49120
8112f608:	d8000d15 	stw	zero,52(sp)
8112f60c:	05cff834 	movhi	r23,16352
8112f610:	003ded06 	br	8112edc8 <__reset+0xfb10edc8>
8112f614:	0440d434 	movhi	r17,848
8112f618:	1c63883a 	add	r17,r3,r17
8112f61c:	d8000915 	stw	zero,36(sp)
8112f620:	003cc806 	br	8112e944 <__reset+0xfb10e944>
8112f624:	8884703a 	and	r2,r17,r2
8112f628:	103faa1e 	bne	r2,zero,8112f4d4 <__reset+0xfb10f4d4>
8112f62c:	903fa91e 	bne	r18,zero,8112f4d4 <__reset+0xfb10f4d4>
8112f630:	8ddffc2c 	andhi	r23,r17,32752
8112f634:	003feb06 	br	8112f5e4 <__reset+0xfb10f5e4>
8112f638:	d8c00d17 	ldw	r3,52(sp)
8112f63c:	1cae703a 	and	r23,r3,r18
8112f640:	b83fb726 	beq	r23,zero,8112f520 <__reset+0xfb10f520>
8112f644:	003fa706 	br	8112f4e4 <__reset+0xfb10f4e4>
8112f648:	21000044 	addi	r4,r4,1
8112f64c:	d9000615 	stw	r4,24(sp)
8112f650:	003f9006 	br	8112f494 <__reset+0xfb10f494>
8112f654:	01604574 	movhi	r5,33045
8112f658:	29425404 	addi	r5,r5,2384
8112f65c:	d9400915 	stw	r5,36(sp)
8112f660:	0027883a 	mov	r19,zero
8112f664:	003ca206 	br	8112e8f0 <__reset+0xfb10e8f0>
8112f668:	9009883a 	mov	r4,r18
8112f66c:	880b883a 	mov	r5,r17
8112f670:	da001315 	stw	r8,76(sp)
8112f674:	112e1800 	call	8112e180 <sulp>
8112f678:	100d883a 	mov	r6,r2
8112f67c:	180f883a 	mov	r7,r3
8112f680:	9009883a 	mov	r4,r18
8112f684:	880b883a 	mov	r5,r17
8112f688:	11204440 	call	81120444 <__subdf3>
8112f68c:	000d883a 	mov	r6,zero
8112f690:	000f883a 	mov	r7,zero
8112f694:	1009883a 	mov	r4,r2
8112f698:	180b883a 	mov	r5,r3
8112f69c:	102b883a 	mov	r21,r2
8112f6a0:	182d883a 	mov	r22,r3
8112f6a4:	1135dd80 	call	81135dd8 <__eqdf2>
8112f6a8:	da001317 	ldw	r8,76(sp)
8112f6ac:	103ee526 	beq	r2,zero,8112f244 <__reset+0xfb10f244>
8112f6b0:	003f9b06 	br	8112f520 <__reset+0xfb10f520>
8112f6b4:	d8800917 	ldw	r2,36(sp)
8112f6b8:	10002226 	beq	r2,zero,8112f744 <_strtod_r+0x1558>
8112f6bc:	889ffc2c 	andhi	r2,r17,32752
8112f6c0:	00c1a834 	movhi	r3,1696
8112f6c4:	18801f36 	bltu	r3,r2,8112f744 <_strtod_r+0x1558>
8112f6c8:	1004d53a 	srli	r2,r2,20
8112f6cc:	00c01ac4 	movi	r3,107
8112f6d0:	1887c83a 	sub	r3,r3,r2
8112f6d4:	00bfffc4 	movi	r2,-1
8112f6d8:	10c4983a 	sll	r2,r2,r3
8112f6dc:	14bf7d1e 	bne	r2,r18,8112f4d4 <__reset+0xfb10f4d4>
8112f6e0:	00dffc34 	movhi	r3,32752
8112f6e4:	18ffffc4 	addi	r3,r3,-1
8112f6e8:	88c03526 	beq	r17,r3,8112f7c0 <_strtod_r+0x15d4>
8112f6ec:	8c5ffc2c 	andhi	r17,r17,32752
8112f6f0:	00800434 	movhi	r2,16
8112f6f4:	002b883a 	mov	r21,zero
8112f6f8:	88ad883a 	add	r22,r17,r2
8112f6fc:	003f8806 	br	8112f520 <__reset+0xfb10f520>
8112f700:	01401a84 	movi	r5,106
8112f704:	d9400915 	stw	r5,36(sp)
8112f708:	8ddffc2c 	andhi	r23,r17,32752
8112f70c:	b82ed53a 	srli	r23,r23,20
8112f710:	00801ac4 	movi	r2,107
8112f714:	15c5c83a 	sub	r2,r2,r23
8112f718:	00be8e0e 	bge	zero,r2,8112f154 <__reset+0xfb10f154>
8112f71c:	00c007c4 	movi	r3,31
8112f720:	18800a0e 	bge	r3,r2,8112f74c <_strtod_r+0x1560>
8112f724:	00c00d04 	movi	r3,52
8112f728:	0025883a 	mov	r18,zero
8112f72c:	1880270e 	bge	r3,r2,8112f7cc <_strtod_r+0x15e0>
8112f730:	0440dc34 	movhi	r17,880
8112f734:	003e8706 	br	8112f154 <__reset+0xfb10f154>
8112f738:	d8000915 	stw	zero,36(sp)
8112f73c:	05fe6a16 	blt	zero,r23,8112f0e8 <__reset+0xfb10f0e8>
8112f740:	003e8406 	br	8112f154 <__reset+0xfb10f154>
8112f744:	00bfffc4 	movi	r2,-1
8112f748:	003fe406 	br	8112f6dc <__reset+0xfb10f6dc>
8112f74c:	00ffffc4 	movi	r3,-1
8112f750:	1884983a 	sll	r2,r3,r2
8112f754:	14a4703a 	and	r18,r2,r18
8112f758:	003e7e06 	br	8112f154 <__reset+0xfb10f154>
8112f75c:	00bffc34 	movhi	r2,65520
8112f760:	b8af883a 	add	r23,r23,r2
8112f764:	057fffc4 	movi	r21,-1
8112f768:	00800434 	movhi	r2,16
8112f76c:	1545883a 	add	r2,r2,r21
8112f770:	b8acb03a 	or	r22,r23,r2
8112f774:	003f6a06 	br	8112f520 <__reset+0xfb10f520>
8112f778:	01604574 	movhi	r5,33045
8112f77c:	29429404 	addi	r5,r5,2640
8112f780:	d9800204 	addi	r6,sp,8
8112f784:	d9000604 	addi	r4,sp,24
8112f788:	11338900 	call	81133890 <__hexnan>
8112f78c:	00c00144 	movi	r3,5
8112f790:	10fb5c1e 	bne	r2,r3,8112e504 <__reset+0xfb10e504>
8112f794:	dc400317 	ldw	r17,12(sp)
8112f798:	dc800217 	ldw	r18,8(sp)
8112f79c:	8c5ffc34 	orhi	r17,r17,32752
8112f7a0:	003b5a06 	br	8112e50c <__reset+0xfb10e50c>
8112f7a4:	480b883a 	mov	r5,r9
8112f7a8:	d9800617 	ldw	r6,24(sp)
8112f7ac:	4a400044 	addi	r9,r9,1
8112f7b0:	003eeb06 	br	8112f360 <__reset+0xfb10f360>
8112f7b4:	1025883a 	mov	r18,r2
8112f7b8:	1823883a 	mov	r17,r3
8112f7bc:	003c4c06 	br	8112e8f0 <__reset+0xfb10e8f0>
8112f7c0:	00ffffc4 	movi	r3,-1
8112f7c4:	10ffc91e 	bne	r2,r3,8112f6ec <__reset+0xfb10f6ec>
8112f7c8:	003da906 	br	8112ee70 <__reset+0xfb10ee70>
8112f7cc:	10bff804 	addi	r2,r2,-32
8112f7d0:	00ffffc4 	movi	r3,-1
8112f7d4:	1884983a 	sll	r2,r3,r2
8112f7d8:	1462703a 	and	r17,r2,r17
8112f7dc:	003e5d06 	br	8112f154 <__reset+0xfb10f154>
8112f7e0:	1025883a 	mov	r18,r2
8112f7e4:	1823883a 	mov	r17,r3
8112f7e8:	003e5806 	br	8112f14c <__reset+0xfb10f14c>

8112f7ec <strtod>:
8112f7ec:	00a04574 	movhi	r2,33045
8112f7f0:	108bed04 	addi	r2,r2,12212
8112f7f4:	280d883a 	mov	r6,r5
8112f7f8:	200b883a 	mov	r5,r4
8112f7fc:	11000017 	ldw	r4,0(r2)
8112f800:	112e1ec1 	jmpi	8112e1ec <_strtod_r>

8112f804 <strtof>:
8112f804:	defffb04 	addi	sp,sp,-20
8112f808:	de00012e 	bgeu	sp,et,8112f810 <strtof+0xc>
8112f80c:	003b68fa 	trap	3
8112f810:	dcc00315 	stw	r19,12(sp)
8112f814:	04e04574 	movhi	r19,33045
8112f818:	9ccbed04 	addi	r19,r19,12212
8112f81c:	280d883a 	mov	r6,r5
8112f820:	200b883a 	mov	r5,r4
8112f824:	99000017 	ldw	r4,0(r19)
8112f828:	dfc00415 	stw	ra,16(sp)
8112f82c:	dc800215 	stw	r18,8(sp)
8112f830:	dc400115 	stw	r17,4(sp)
8112f834:	dc000015 	stw	r16,0(sp)
8112f838:	112e1ec0 	call	8112e1ec <_strtod_r>
8112f83c:	1009883a 	mov	r4,r2
8112f840:	180b883a 	mov	r5,r3
8112f844:	1025883a 	mov	r18,r2
8112f848:	1823883a 	mov	r17,r3
8112f84c:	1120fc40 	call	81120fc4 <__truncdfsf2>
8112f850:	000b883a 	mov	r5,zero
8112f854:	1009883a 	mov	r4,r2
8112f858:	1021883a 	mov	r16,r2
8112f85c:	1134a380 	call	81134a38 <__eqsf2>
8112f860:	1000111e 	bne	r2,zero,8112f8a8 <strtof+0xa4>
8112f864:	000d883a 	mov	r6,zero
8112f868:	000f883a 	mov	r7,zero
8112f86c:	9009883a 	mov	r4,r18
8112f870:	880b883a 	mov	r5,r17
8112f874:	1135dd80 	call	81135dd8 <__eqdf2>
8112f878:	10000b26 	beq	r2,zero,8112f8a8 <strtof+0xa4>
8112f87c:	98800017 	ldw	r2,0(r19)
8112f880:	00c00884 	movi	r3,34
8112f884:	10c00015 	stw	r3,0(r2)
8112f888:	8005883a 	mov	r2,r16
8112f88c:	dfc00417 	ldw	ra,16(sp)
8112f890:	dcc00317 	ldw	r19,12(sp)
8112f894:	dc800217 	ldw	r18,8(sp)
8112f898:	dc400117 	ldw	r17,4(sp)
8112f89c:	dc000017 	ldw	r16,0(sp)
8112f8a0:	dec00504 	addi	sp,sp,20
8112f8a4:	f800283a 	ret
8112f8a8:	015fe034 	movhi	r5,32640
8112f8ac:	297fffc4 	addi	r5,r5,-1
8112f8b0:	8009883a 	mov	r4,r16
8112f8b4:	1134ab00 	call	81134ab0 <__gesf2>
8112f8b8:	0080070e 	bge	zero,r2,8112f8d8 <strtof+0xd4>
8112f8bc:	01dffc34 	movhi	r7,32752
8112f8c0:	39ffffc4 	addi	r7,r7,-1
8112f8c4:	01bfffc4 	movi	r6,-1
8112f8c8:	9009883a 	mov	r4,r18
8112f8cc:	880b883a 	mov	r5,r17
8112f8d0:	111fc480 	call	8111fc48 <__gedf2>
8112f8d4:	00bfe90e 	bge	zero,r2,8112f87c <__reset+0xfb10f87c>
8112f8d8:	017fe034 	movhi	r5,65408
8112f8dc:	297fffc4 	addi	r5,r5,-1
8112f8e0:	8009883a 	mov	r4,r16
8112f8e4:	1134b6c0 	call	81134b6c <__lesf2>
8112f8e8:	103fe70e 	bge	r2,zero,8112f888 <__reset+0xfb10f888>
8112f8ec:	01fffc34 	movhi	r7,65520
8112f8f0:	39ffffc4 	addi	r7,r7,-1
8112f8f4:	01bfffc4 	movi	r6,-1
8112f8f8:	9009883a 	mov	r4,r18
8112f8fc:	880b883a 	mov	r5,r17
8112f900:	1135e600 	call	81135e60 <__ledf2>
8112f904:	103fdd0e 	bge	r2,zero,8112f87c <__reset+0xfb10f87c>
8112f908:	003fdf06 	br	8112f888 <__reset+0xfb10f888>

8112f90c <_strtoul_r>:
8112f90c:	00a04574 	movhi	r2,33045
8112f910:	defff604 	addi	sp,sp,-40
8112f914:	108beb04 	addi	r2,r2,12204
8112f918:	de00012e 	bgeu	sp,et,8112f920 <_strtoul_r+0x14>
8112f91c:	003b68fa 	trap	3
8112f920:	dc800315 	stw	r18,12(sp)
8112f924:	14800017 	ldw	r18,0(r2)
8112f928:	dd400615 	stw	r21,24(sp)
8112f92c:	dd000515 	stw	r20,20(sp)
8112f930:	dcc00415 	stw	r19,16(sp)
8112f934:	2029883a 	mov	r20,r4
8112f938:	dfc00915 	stw	ra,36(sp)
8112f93c:	ddc00815 	stw	r23,32(sp)
8112f940:	dd800715 	stw	r22,28(sp)
8112f944:	dc400215 	stw	r17,8(sp)
8112f948:	dc000115 	stw	r16,4(sp)
8112f94c:	2827883a 	mov	r19,r5
8112f950:	382b883a 	mov	r21,r7
8112f954:	2809883a 	mov	r4,r5
8112f958:	24000003 	ldbu	r16,0(r4)
8112f95c:	24400044 	addi	r17,r4,1
8112f960:	2007883a 	mov	r3,r4
8112f964:	9405883a 	add	r2,r18,r16
8112f968:	10800043 	ldbu	r2,1(r2)
8112f96c:	8809883a 	mov	r4,r17
8112f970:	1080020c 	andi	r2,r2,8
8112f974:	103ff81e 	bne	r2,zero,8112f958 <__reset+0xfb10f958>
8112f978:	00800b44 	movi	r2,45
8112f97c:	80805326 	beq	r16,r2,8112facc <_strtoul_r+0x1c0>
8112f980:	00800ac4 	movi	r2,43
8112f984:	80805526 	beq	r16,r2,8112fadc <_strtoul_r+0x1d0>
8112f988:	002f883a 	mov	r23,zero
8112f98c:	a8000f26 	beq	r21,zero,8112f9cc <_strtoul_r+0xc0>
8112f990:	00800404 	movi	r2,16
8112f994:	a8805f26 	beq	r21,r2,8112fb14 <_strtoul_r+0x208>
8112f998:	013fffc4 	movi	r4,-1
8112f99c:	a80b883a 	mov	r5,r21
8112f9a0:	d9800015 	stw	r6,0(sp)
8112f9a4:	113497c0 	call	8113497c <__udivsi3>
8112f9a8:	a80b883a 	mov	r5,r21
8112f9ac:	013fffc4 	movi	r4,-1
8112f9b0:	102d883a 	mov	r22,r2
8112f9b4:	11349e00 	call	811349e0 <__umodsi3>
8112f9b8:	d9800017 	ldw	r6,0(sp)
8112f9bc:	1019883a 	mov	r12,r2
8112f9c0:	a817883a 	mov	r11,r21
8112f9c4:	b00f883a 	mov	r7,r22
8112f9c8:	00000706 	br	8112f9e8 <_strtoul_r+0xdc>
8112f9cc:	00800c04 	movi	r2,48
8112f9d0:	80804626 	beq	r16,r2,8112faec <_strtoul_r+0x1e0>
8112f9d4:	05400284 	movi	r21,10
8112f9d8:	01c666b4 	movhi	r7,6554
8112f9dc:	03000144 	movi	r12,5
8112f9e0:	39e66644 	addi	r7,r7,-26215
8112f9e4:	a817883a 	mov	r11,r21
8112f9e8:	9407883a 	add	r3,r18,r16
8112f9ec:	18c00043 	ldbu	r3,1(r3)
8112f9f0:	8809883a 	mov	r4,r17
8112f9f4:	0011883a 	mov	r8,zero
8112f9f8:	1940010c 	andi	r5,r3,4
8112f9fc:	0005883a 	mov	r2,zero
8112fa00:	02800044 	movi	r10,1
8112fa04:	027fffc4 	movi	r9,-1
8112fa08:	28000e26 	beq	r5,zero,8112fa44 <_strtoul_r+0x138>
8112fa0c:	843ff404 	addi	r16,r16,-48
8112fa10:	8540120e 	bge	r16,r21,8112fa5c <_strtoul_r+0x150>
8112fa14:	42400526 	beq	r8,r9,8112fa2c <_strtoul_r+0x120>
8112fa18:	38802236 	bltu	r7,r2,8112faa4 <_strtoul_r+0x198>
8112fa1c:	11c02026 	beq	r2,r7,8112faa0 <_strtoul_r+0x194>
8112fa20:	12c5383a 	mul	r2,r2,r11
8112fa24:	02000044 	movi	r8,1
8112fa28:	8085883a 	add	r2,r16,r2
8112fa2c:	24000003 	ldbu	r16,0(r4)
8112fa30:	21000044 	addi	r4,r4,1
8112fa34:	9407883a 	add	r3,r18,r16
8112fa38:	18c00043 	ldbu	r3,1(r3)
8112fa3c:	1940010c 	andi	r5,r3,4
8112fa40:	283ff21e 	bne	r5,zero,8112fa0c <__reset+0xfb10fa0c>
8112fa44:	18c000cc 	andi	r3,r3,3
8112fa48:	18000426 	beq	r3,zero,8112fa5c <_strtoul_r+0x150>
8112fa4c:	1a801726 	beq	r3,r10,8112faac <_strtoul_r+0x1a0>
8112fa50:	00c015c4 	movi	r3,87
8112fa54:	80e1c83a 	sub	r16,r16,r3
8112fa58:	857fee16 	blt	r16,r21,8112fa14 <__reset+0xfb10fa14>
8112fa5c:	40001516 	blt	r8,zero,8112fab4 <_strtoul_r+0x1a8>
8112fa60:	b8000126 	beq	r23,zero,8112fa68 <_strtoul_r+0x15c>
8112fa64:	0085c83a 	sub	r2,zero,r2
8112fa68:	30000226 	beq	r6,zero,8112fa74 <_strtoul_r+0x168>
8112fa6c:	4000151e 	bne	r8,zero,8112fac4 <_strtoul_r+0x1b8>
8112fa70:	34c00015 	stw	r19,0(r6)
8112fa74:	dfc00917 	ldw	ra,36(sp)
8112fa78:	ddc00817 	ldw	r23,32(sp)
8112fa7c:	dd800717 	ldw	r22,28(sp)
8112fa80:	dd400617 	ldw	r21,24(sp)
8112fa84:	dd000517 	ldw	r20,20(sp)
8112fa88:	dcc00417 	ldw	r19,16(sp)
8112fa8c:	dc800317 	ldw	r18,12(sp)
8112fa90:	dc400217 	ldw	r17,8(sp)
8112fa94:	dc000117 	ldw	r16,4(sp)
8112fa98:	dec00a04 	addi	sp,sp,40
8112fa9c:	f800283a 	ret
8112faa0:	643fdf0e 	bge	r12,r16,8112fa20 <__reset+0xfb10fa20>
8112faa4:	023fffc4 	movi	r8,-1
8112faa8:	003fe006 	br	8112fa2c <__reset+0xfb10fa2c>
8112faac:	00c00dc4 	movi	r3,55
8112fab0:	003fe806 	br	8112fa54 <__reset+0xfb10fa54>
8112fab4:	00800884 	movi	r2,34
8112fab8:	a0800015 	stw	r2,0(r20)
8112fabc:	00bfffc4 	movi	r2,-1
8112fac0:	303fec26 	beq	r6,zero,8112fa74 <__reset+0xfb10fa74>
8112fac4:	24ffffc4 	addi	r19,r4,-1
8112fac8:	003fe906 	br	8112fa70 <__reset+0xfb10fa70>
8112facc:	1c400084 	addi	r17,r3,2
8112fad0:	1c000043 	ldbu	r16,1(r3)
8112fad4:	05c00044 	movi	r23,1
8112fad8:	003fac06 	br	8112f98c <__reset+0xfb10f98c>
8112fadc:	1c400084 	addi	r17,r3,2
8112fae0:	1c000043 	ldbu	r16,1(r3)
8112fae4:	002f883a 	mov	r23,zero
8112fae8:	003fa806 	br	8112f98c <__reset+0xfb10f98c>
8112faec:	88800003 	ldbu	r2,0(r17)
8112faf0:	00c01604 	movi	r3,88
8112faf4:	108037cc 	andi	r2,r2,223
8112faf8:	10c00c26 	beq	r2,r3,8112fb2c <_strtoul_r+0x220>
8112fafc:	05400204 	movi	r21,8
8112fb00:	01c80034 	movhi	r7,8192
8112fb04:	030001c4 	movi	r12,7
8112fb08:	39ffffc4 	addi	r7,r7,-1
8112fb0c:	a817883a 	mov	r11,r21
8112fb10:	003fb506 	br	8112f9e8 <__reset+0xfb10f9e8>
8112fb14:	00800c04 	movi	r2,48
8112fb18:	80800c1e 	bne	r16,r2,8112fb4c <_strtoul_r+0x240>
8112fb1c:	88800003 	ldbu	r2,0(r17)
8112fb20:	00c01604 	movi	r3,88
8112fb24:	108037cc 	andi	r2,r2,223
8112fb28:	10c0081e 	bne	r2,r3,8112fb4c <_strtoul_r+0x240>
8112fb2c:	02c00404 	movi	r11,16
8112fb30:	05840034 	movhi	r22,4096
8112fb34:	8c000043 	ldbu	r16,1(r17)
8112fb38:	030003c4 	movi	r12,15
8112fb3c:	8c400084 	addi	r17,r17,2
8112fb40:	b5bfffc4 	addi	r22,r22,-1
8112fb44:	582b883a 	mov	r21,r11
8112fb48:	003f9e06 	br	8112f9c4 <__reset+0xfb10f9c4>
8112fb4c:	01c40034 	movhi	r7,4096
8112fb50:	030003c4 	movi	r12,15
8112fb54:	39ffffc4 	addi	r7,r7,-1
8112fb58:	a817883a 	mov	r11,r21
8112fb5c:	003fa206 	br	8112f9e8 <__reset+0xfb10f9e8>

8112fb60 <strtoul>:
8112fb60:	00a04574 	movhi	r2,33045
8112fb64:	108bed04 	addi	r2,r2,12212
8112fb68:	300f883a 	mov	r7,r6
8112fb6c:	280d883a 	mov	r6,r5
8112fb70:	200b883a 	mov	r5,r4
8112fb74:	11000017 	ldw	r4,0(r2)
8112fb78:	112f90c1 	jmpi	8112f90c <_strtoul_r>

8112fb7c <_strtoull_r>:
8112fb7c:	00a04574 	movhi	r2,33045
8112fb80:	defff404 	addi	sp,sp,-48
8112fb84:	108beb04 	addi	r2,r2,12204
8112fb88:	de00012e 	bgeu	sp,et,8112fb90 <_strtoull_r+0x14>
8112fb8c:	003b68fa 	trap	3
8112fb90:	dc400315 	stw	r17,12(sp)
8112fb94:	14400017 	ldw	r17,0(r2)
8112fb98:	dd400715 	stw	r21,28(sp)
8112fb9c:	dd000615 	stw	r20,24(sp)
8112fba0:	dcc00515 	stw	r19,20(sp)
8112fba4:	dc800415 	stw	r18,16(sp)
8112fba8:	dfc00b15 	stw	ra,44(sp)
8112fbac:	df000a15 	stw	fp,40(sp)
8112fbb0:	ddc00915 	stw	r23,36(sp)
8112fbb4:	dd800815 	stw	r22,32(sp)
8112fbb8:	dc000215 	stw	r16,8(sp)
8112fbbc:	2827883a 	mov	r19,r5
8112fbc0:	202b883a 	mov	r21,r4
8112fbc4:	3029883a 	mov	r20,r6
8112fbc8:	3825883a 	mov	r18,r7
8112fbcc:	2807883a 	mov	r3,r5
8112fbd0:	1c000003 	ldbu	r16,0(r3)
8112fbd4:	1f000044 	addi	fp,r3,1
8112fbd8:	1809883a 	mov	r4,r3
8112fbdc:	8c05883a 	add	r2,r17,r16
8112fbe0:	10800043 	ldbu	r2,1(r2)
8112fbe4:	e007883a 	mov	r3,fp
8112fbe8:	1080020c 	andi	r2,r2,8
8112fbec:	103ff81e 	bne	r2,zero,8112fbd0 <__reset+0xfb10fbd0>
8112fbf0:	00800b44 	movi	r2,45
8112fbf4:	80806e26 	beq	r16,r2,8112fdb0 <_strtoull_r+0x234>
8112fbf8:	00800ac4 	movi	r2,43
8112fbfc:	80807026 	beq	r16,r2,8112fdc0 <_strtoull_r+0x244>
8112fc00:	002f883a 	mov	r23,zero
8112fc04:	90001426 	beq	r18,zero,8112fc58 <_strtoull_r+0xdc>
8112fc08:	00800404 	movi	r2,16
8112fc0c:	90807c26 	beq	r18,r2,8112fe00 <_strtoull_r+0x284>
8112fc10:	902dd7fa 	srai	r22,r18,31
8112fc14:	013fffc4 	movi	r4,-1
8112fc18:	200b883a 	mov	r5,r4
8112fc1c:	900d883a 	mov	r6,r18
8112fc20:	b00f883a 	mov	r7,r22
8112fc24:	1133dc40 	call	81133dc4 <__udivdi3>
8112fc28:	013fffc4 	movi	r4,-1
8112fc2c:	900d883a 	mov	r6,r18
8112fc30:	b00f883a 	mov	r7,r22
8112fc34:	200b883a 	mov	r5,r4
8112fc38:	d8c00115 	stw	r3,4(sp)
8112fc3c:	d8800015 	stw	r2,0(sp)
8112fc40:	11343440 	call	81134344 <__umoddi3>
8112fc44:	101b883a 	mov	r13,r2
8112fc48:	9015883a 	mov	r10,r18
8112fc4c:	dac00017 	ldw	r11,0(sp)
8112fc50:	da000117 	ldw	r8,4(sp)
8112fc54:	00000a06 	br	8112fc80 <_strtoull_r+0x104>
8112fc58:	00800c04 	movi	r2,48
8112fc5c:	80805c26 	beq	r16,r2,8112fdd0 <_strtoull_r+0x254>
8112fc60:	02800284 	movi	r10,10
8112fc64:	02e666b4 	movhi	r11,39322
8112fc68:	020666b4 	movhi	r8,6554
8112fc6c:	03400144 	movi	r13,5
8112fc70:	5ae66644 	addi	r11,r11,-26215
8112fc74:	42266644 	addi	r8,r8,-26215
8112fc78:	002d883a 	mov	r22,zero
8112fc7c:	5025883a 	mov	r18,r10
8112fc80:	8c0b883a 	add	r5,r17,r16
8112fc84:	29400043 	ldbu	r5,1(r5)
8112fc88:	e009883a 	mov	r4,fp
8112fc8c:	000f883a 	mov	r7,zero
8112fc90:	2980010c 	andi	r6,r5,4
8112fc94:	0005883a 	mov	r2,zero
8112fc98:	0007883a 	mov	r3,zero
8112fc9c:	03000044 	movi	r12,1
8112fca0:	027fffc4 	movi	r9,-1
8112fca4:	30000d26 	beq	r6,zero,8112fcdc <_strtoull_r+0x160>
8112fca8:	843ff404 	addi	r16,r16,-48
8112fcac:	8480110e 	bge	r16,r18,8112fcf4 <_strtoull_r+0x178>
8112fcb0:	3a400426 	beq	r7,r9,8112fcc4 <_strtoull_r+0x148>
8112fcb4:	40c00236 	bltu	r8,r3,8112fcc0 <_strtoull_r+0x144>
8112fcb8:	1a00231e 	bne	r3,r8,8112fd48 <_strtoull_r+0x1cc>
8112fcbc:	5880222e 	bgeu	r11,r2,8112fd48 <_strtoull_r+0x1cc>
8112fcc0:	01ffffc4 	movi	r7,-1
8112fcc4:	24000003 	ldbu	r16,0(r4)
8112fcc8:	21000044 	addi	r4,r4,1
8112fccc:	8c0b883a 	add	r5,r17,r16
8112fcd0:	29400043 	ldbu	r5,1(r5)
8112fcd4:	2980010c 	andi	r6,r5,4
8112fcd8:	303ff31e 	bne	r6,zero,8112fca8 <__reset+0xfb10fca8>
8112fcdc:	294000cc 	andi	r5,r5,3
8112fce0:	28000426 	beq	r5,zero,8112fcf4 <_strtoull_r+0x178>
8112fce4:	2b002626 	beq	r5,r12,8112fd80 <_strtoull_r+0x204>
8112fce8:	014015c4 	movi	r5,87
8112fcec:	8161c83a 	sub	r16,r16,r5
8112fcf0:	84bfef16 	blt	r16,r18,8112fcb0 <__reset+0xfb10fcb0>
8112fcf4:	38002716 	blt	r7,zero,8112fd94 <_strtoull_r+0x218>
8112fcf8:	b8000426 	beq	r23,zero,8112fd0c <_strtoull_r+0x190>
8112fcfc:	0085c83a 	sub	r2,zero,r2
8112fd00:	100ac03a 	cmpne	r5,r2,zero
8112fd04:	00e1c83a 	sub	r16,zero,r3
8112fd08:	8147c83a 	sub	r3,r16,r5
8112fd0c:	a0000226 	beq	r20,zero,8112fd18 <_strtoull_r+0x19c>
8112fd10:	3800251e 	bne	r7,zero,8112fda8 <_strtoull_r+0x22c>
8112fd14:	a4c00015 	stw	r19,0(r20)
8112fd18:	dfc00b17 	ldw	ra,44(sp)
8112fd1c:	df000a17 	ldw	fp,40(sp)
8112fd20:	ddc00917 	ldw	r23,36(sp)
8112fd24:	dd800817 	ldw	r22,32(sp)
8112fd28:	dd400717 	ldw	r21,28(sp)
8112fd2c:	dd000617 	ldw	r20,24(sp)
8112fd30:	dcc00517 	ldw	r19,20(sp)
8112fd34:	dc800417 	ldw	r18,16(sp)
8112fd38:	dc400317 	ldw	r17,12(sp)
8112fd3c:	dc000217 	ldw	r16,8(sp)
8112fd40:	dec00c04 	addi	sp,sp,48
8112fd44:	f800283a 	ret
8112fd48:	12c00f26 	beq	r2,r11,8112fd88 <_strtoull_r+0x20c>
8112fd4c:	b08d383a 	mul	r6,r22,r2
8112fd50:	1a87383a 	mul	r3,r3,r10
8112fd54:	128a383a 	mulxuu	r5,r2,r10
8112fd58:	1285383a 	mul	r2,r2,r10
8112fd5c:	800fd7fa 	srai	r7,r16,31
8112fd60:	1987883a 	add	r3,r3,r6
8112fd64:	8085883a 	add	r2,r16,r2
8112fd68:	1947883a 	add	r3,r3,r5
8112fd6c:	38c7883a 	add	r3,r7,r3
8112fd70:	1421803a 	cmpltu	r16,r2,r16
8112fd74:	80c7883a 	add	r3,r16,r3
8112fd78:	01c00044 	movi	r7,1
8112fd7c:	003fd106 	br	8112fcc4 <__reset+0xfb10fcc4>
8112fd80:	01400dc4 	movi	r5,55
8112fd84:	003fd906 	br	8112fcec <__reset+0xfb10fcec>
8112fd88:	1a3ff01e 	bne	r3,r8,8112fd4c <__reset+0xfb10fd4c>
8112fd8c:	6c3fcc16 	blt	r13,r16,8112fcc0 <__reset+0xfb10fcc0>
8112fd90:	003fee06 	br	8112fd4c <__reset+0xfb10fd4c>
8112fd94:	00800884 	movi	r2,34
8112fd98:	a8800015 	stw	r2,0(r21)
8112fd9c:	00bfffc4 	movi	r2,-1
8112fda0:	1007883a 	mov	r3,r2
8112fda4:	a03fdc26 	beq	r20,zero,8112fd18 <__reset+0xfb10fd18>
8112fda8:	24ffffc4 	addi	r19,r4,-1
8112fdac:	003fd906 	br	8112fd14 <__reset+0xfb10fd14>
8112fdb0:	27000084 	addi	fp,r4,2
8112fdb4:	24000043 	ldbu	r16,1(r4)
8112fdb8:	05c00044 	movi	r23,1
8112fdbc:	003f9106 	br	8112fc04 <__reset+0xfb10fc04>
8112fdc0:	27000084 	addi	fp,r4,2
8112fdc4:	24000043 	ldbu	r16,1(r4)
8112fdc8:	002f883a 	mov	r23,zero
8112fdcc:	003f8d06 	br	8112fc04 <__reset+0xfb10fc04>
8112fdd0:	e0800003 	ldbu	r2,0(fp)
8112fdd4:	00c01604 	movi	r3,88
8112fdd8:	108037cc 	andi	r2,r2,223
8112fddc:	10c00e26 	beq	r2,r3,8112fe18 <_strtoull_r+0x29c>
8112fde0:	02800204 	movi	r10,8
8112fde4:	02ffffc4 	movi	r11,-1
8112fde8:	02080034 	movhi	r8,8192
8112fdec:	034001c4 	movi	r13,7
8112fdf0:	42d1883a 	add	r8,r8,r11
8112fdf4:	002d883a 	mov	r22,zero
8112fdf8:	5025883a 	mov	r18,r10
8112fdfc:	003fa006 	br	8112fc80 <__reset+0xfb10fc80>
8112fe00:	00800c04 	movi	r2,48
8112fe04:	80800e1e 	bne	r16,r2,8112fe40 <_strtoull_r+0x2c4>
8112fe08:	e0800003 	ldbu	r2,0(fp)
8112fe0c:	00c01604 	movi	r3,88
8112fe10:	108037cc 	andi	r2,r2,223
8112fe14:	10c00a1e 	bne	r2,r3,8112fe40 <_strtoull_r+0x2c4>
8112fe18:	02800404 	movi	r10,16
8112fe1c:	02ffffc4 	movi	r11,-1
8112fe20:	02040034 	movhi	r8,4096
8112fe24:	e4000043 	ldbu	r16,1(fp)
8112fe28:	034003c4 	movi	r13,15
8112fe2c:	e7000084 	addi	fp,fp,2
8112fe30:	42d1883a 	add	r8,r8,r11
8112fe34:	002d883a 	mov	r22,zero
8112fe38:	5025883a 	mov	r18,r10
8112fe3c:	003f9006 	br	8112fc80 <__reset+0xfb10fc80>
8112fe40:	02ffffc4 	movi	r11,-1
8112fe44:	02040034 	movhi	r8,4096
8112fe48:	034003c4 	movi	r13,15
8112fe4c:	42d1883a 	add	r8,r8,r11
8112fe50:	9015883a 	mov	r10,r18
8112fe54:	002d883a 	mov	r22,zero
8112fe58:	003f8906 	br	8112fc80 <__reset+0xfb10fc80>

8112fe5c <__ssprint_r>:
8112fe5c:	defff604 	addi	sp,sp,-40
8112fe60:	de00012e 	bgeu	sp,et,8112fe68 <__ssprint_r+0xc>
8112fe64:	003b68fa 	trap	3
8112fe68:	30800217 	ldw	r2,8(r6)
8112fe6c:	dc800215 	stw	r18,8(sp)
8112fe70:	dfc00915 	stw	ra,36(sp)
8112fe74:	df000815 	stw	fp,32(sp)
8112fe78:	ddc00715 	stw	r23,28(sp)
8112fe7c:	dd800615 	stw	r22,24(sp)
8112fe80:	dd400515 	stw	r21,20(sp)
8112fe84:	dd000415 	stw	r20,16(sp)
8112fe88:	dcc00315 	stw	r19,12(sp)
8112fe8c:	dc400115 	stw	r17,4(sp)
8112fe90:	dc000015 	stw	r16,0(sp)
8112fe94:	3025883a 	mov	r18,r6
8112fe98:	10005826 	beq	r2,zero,8112fffc <__ssprint_r+0x1a0>
8112fe9c:	2027883a 	mov	r19,r4
8112fea0:	35c00017 	ldw	r23,0(r6)
8112fea4:	29000017 	ldw	r4,0(r5)
8112fea8:	28800217 	ldw	r2,8(r5)
8112feac:	2823883a 	mov	r17,r5
8112feb0:	0039883a 	mov	fp,zero
8112feb4:	0021883a 	mov	r16,zero
8112feb8:	80003926 	beq	r16,zero,8112ffa0 <__ssprint_r+0x144>
8112febc:	102b883a 	mov	r21,r2
8112fec0:	102d883a 	mov	r22,r2
8112fec4:	80803a36 	bltu	r16,r2,8112ffb0 <__ssprint_r+0x154>
8112fec8:	88c0030b 	ldhu	r3,12(r17)
8112fecc:	1881200c 	andi	r2,r3,1152
8112fed0:	10002626 	beq	r2,zero,8112ff6c <__ssprint_r+0x110>
8112fed4:	88800517 	ldw	r2,20(r17)
8112fed8:	89400417 	ldw	r5,16(r17)
8112fedc:	81800044 	addi	r6,r16,1
8112fee0:	108f883a 	add	r7,r2,r2
8112fee4:	3885883a 	add	r2,r7,r2
8112fee8:	100ed7fa 	srli	r7,r2,31
8112feec:	216dc83a 	sub	r22,r4,r5
8112fef0:	3589883a 	add	r4,r6,r22
8112fef4:	3885883a 	add	r2,r7,r2
8112fef8:	102bd07a 	srai	r21,r2,1
8112fefc:	a80d883a 	mov	r6,r21
8112ff00:	a900022e 	bgeu	r21,r4,8112ff0c <__ssprint_r+0xb0>
8112ff04:	202b883a 	mov	r21,r4
8112ff08:	200d883a 	mov	r6,r4
8112ff0c:	18c1000c 	andi	r3,r3,1024
8112ff10:	18002a26 	beq	r3,zero,8112ffbc <__ssprint_r+0x160>
8112ff14:	300b883a 	mov	r5,r6
8112ff18:	9809883a 	mov	r4,r19
8112ff1c:	1121be00 	call	81121be0 <_malloc_r>
8112ff20:	1029883a 	mov	r20,r2
8112ff24:	10002c26 	beq	r2,zero,8112ffd8 <__ssprint_r+0x17c>
8112ff28:	89400417 	ldw	r5,16(r17)
8112ff2c:	b00d883a 	mov	r6,r22
8112ff30:	1009883a 	mov	r4,r2
8112ff34:	11223f40 	call	811223f4 <memcpy>
8112ff38:	8880030b 	ldhu	r2,12(r17)
8112ff3c:	00fedfc4 	movi	r3,-1153
8112ff40:	10c4703a 	and	r2,r2,r3
8112ff44:	10802014 	ori	r2,r2,128
8112ff48:	8880030d 	sth	r2,12(r17)
8112ff4c:	a589883a 	add	r4,r20,r22
8112ff50:	adadc83a 	sub	r22,r21,r22
8112ff54:	8d400515 	stw	r21,20(r17)
8112ff58:	8d800215 	stw	r22,8(r17)
8112ff5c:	8d000415 	stw	r20,16(r17)
8112ff60:	89000015 	stw	r4,0(r17)
8112ff64:	802b883a 	mov	r21,r16
8112ff68:	802d883a 	mov	r22,r16
8112ff6c:	b00d883a 	mov	r6,r22
8112ff70:	e00b883a 	mov	r5,fp
8112ff74:	112c7cc0 	call	8112c7cc <memmove>
8112ff78:	88800217 	ldw	r2,8(r17)
8112ff7c:	89000017 	ldw	r4,0(r17)
8112ff80:	90c00217 	ldw	r3,8(r18)
8112ff84:	1545c83a 	sub	r2,r2,r21
8112ff88:	2589883a 	add	r4,r4,r22
8112ff8c:	88800215 	stw	r2,8(r17)
8112ff90:	89000015 	stw	r4,0(r17)
8112ff94:	1c21c83a 	sub	r16,r3,r16
8112ff98:	94000215 	stw	r16,8(r18)
8112ff9c:	80001726 	beq	r16,zero,8112fffc <__ssprint_r+0x1a0>
8112ffa0:	bf000017 	ldw	fp,0(r23)
8112ffa4:	bc000117 	ldw	r16,4(r23)
8112ffa8:	bdc00204 	addi	r23,r23,8
8112ffac:	003fc206 	br	8112feb8 <__reset+0xfb10feb8>
8112ffb0:	802b883a 	mov	r21,r16
8112ffb4:	802d883a 	mov	r22,r16
8112ffb8:	003fec06 	br	8112ff6c <__reset+0xfb10ff6c>
8112ffbc:	9809883a 	mov	r4,r19
8112ffc0:	112d9ec0 	call	8112d9ec <_realloc_r>
8112ffc4:	1029883a 	mov	r20,r2
8112ffc8:	103fe01e 	bne	r2,zero,8112ff4c <__reset+0xfb10ff4c>
8112ffcc:	89400417 	ldw	r5,16(r17)
8112ffd0:	9809883a 	mov	r4,r19
8112ffd4:	112b9580 	call	8112b958 <_free_r>
8112ffd8:	88c0030b 	ldhu	r3,12(r17)
8112ffdc:	00800304 	movi	r2,12
8112ffe0:	98800015 	stw	r2,0(r19)
8112ffe4:	18c01014 	ori	r3,r3,64
8112ffe8:	88c0030d 	sth	r3,12(r17)
8112ffec:	00bfffc4 	movi	r2,-1
8112fff0:	90000215 	stw	zero,8(r18)
8112fff4:	90000115 	stw	zero,4(r18)
8112fff8:	00000206 	br	81130004 <__ssprint_r+0x1a8>
8112fffc:	90000115 	stw	zero,4(r18)
81130000:	0005883a 	mov	r2,zero
81130004:	dfc00917 	ldw	ra,36(sp)
81130008:	df000817 	ldw	fp,32(sp)
8113000c:	ddc00717 	ldw	r23,28(sp)
81130010:	dd800617 	ldw	r22,24(sp)
81130014:	dd400517 	ldw	r21,20(sp)
81130018:	dd000417 	ldw	r20,16(sp)
8113001c:	dcc00317 	ldw	r19,12(sp)
81130020:	dc800217 	ldw	r18,8(sp)
81130024:	dc400117 	ldw	r17,4(sp)
81130028:	dc000017 	ldw	r16,0(sp)
8113002c:	dec00a04 	addi	sp,sp,40
81130030:	f800283a 	ret

81130034 <___svfiprintf_internal_r>:
81130034:	deffc804 	addi	sp,sp,-224
81130038:	de00012e 	bgeu	sp,et,81130040 <___svfiprintf_internal_r+0xc>
8113003c:	003b68fa 	trap	3
81130040:	2880030b 	ldhu	r2,12(r5)
81130044:	dcc03115 	stw	r19,196(sp)
81130048:	dfc03715 	stw	ra,220(sp)
8113004c:	df003615 	stw	fp,216(sp)
81130050:	ddc03515 	stw	r23,212(sp)
81130054:	dd803415 	stw	r22,208(sp)
81130058:	dd403315 	stw	r21,204(sp)
8113005c:	dd003215 	stw	r20,200(sp)
81130060:	dc803015 	stw	r18,192(sp)
81130064:	dc402f15 	stw	r17,188(sp)
81130068:	dc002e15 	stw	r16,184(sp)
8113006c:	d9402715 	stw	r5,156(sp)
81130070:	d9002a15 	stw	r4,168(sp)
81130074:	1080200c 	andi	r2,r2,128
81130078:	d9c02315 	stw	r7,140(sp)
8113007c:	3027883a 	mov	r19,r6
81130080:	10000226 	beq	r2,zero,8113008c <___svfiprintf_internal_r+0x58>
81130084:	28800417 	ldw	r2,16(r5)
81130088:	10041d26 	beq	r2,zero,81131100 <___svfiprintf_internal_r+0x10cc>
8113008c:	dac01a04 	addi	r11,sp,104
81130090:	dac01e15 	stw	r11,120(sp)
81130094:	d8801e17 	ldw	r2,120(sp)
81130098:	dac019c4 	addi	r11,sp,103
8113009c:	dd402a17 	ldw	r21,168(sp)
811300a0:	ddc02717 	ldw	r23,156(sp)
811300a4:	05a04574 	movhi	r22,33045
811300a8:	05204574 	movhi	r20,33045
811300ac:	dac01f15 	stw	r11,124(sp)
811300b0:	12d7c83a 	sub	r11,r2,r11
811300b4:	b582ac04 	addi	r22,r22,2736
811300b8:	a502a804 	addi	r20,r20,2720
811300bc:	dec01a15 	stw	sp,104(sp)
811300c0:	d8001c15 	stw	zero,112(sp)
811300c4:	d8001b15 	stw	zero,108(sp)
811300c8:	d811883a 	mov	r8,sp
811300cc:	d8002915 	stw	zero,164(sp)
811300d0:	d8002515 	stw	zero,148(sp)
811300d4:	dac02b15 	stw	r11,172(sp)
811300d8:	98800007 	ldb	r2,0(r19)
811300dc:	1002dd26 	beq	r2,zero,81130c54 <___svfiprintf_internal_r+0xc20>
811300e0:	00c00944 	movi	r3,37
811300e4:	9823883a 	mov	r17,r19
811300e8:	10c0021e 	bne	r2,r3,811300f4 <___svfiprintf_internal_r+0xc0>
811300ec:	00001406 	br	81130140 <___svfiprintf_internal_r+0x10c>
811300f0:	10c00326 	beq	r2,r3,81130100 <___svfiprintf_internal_r+0xcc>
811300f4:	8c400044 	addi	r17,r17,1
811300f8:	88800007 	ldb	r2,0(r17)
811300fc:	103ffc1e 	bne	r2,zero,811300f0 <__reset+0xfb1100f0>
81130100:	8ce1c83a 	sub	r16,r17,r19
81130104:	80000e26 	beq	r16,zero,81130140 <___svfiprintf_internal_r+0x10c>
81130108:	d8c01c17 	ldw	r3,112(sp)
8113010c:	d8801b17 	ldw	r2,108(sp)
81130110:	44c00015 	stw	r19,0(r8)
81130114:	1c07883a 	add	r3,r3,r16
81130118:	10800044 	addi	r2,r2,1
8113011c:	d8c01c15 	stw	r3,112(sp)
81130120:	44000115 	stw	r16,4(r8)
81130124:	d8801b15 	stw	r2,108(sp)
81130128:	00c001c4 	movi	r3,7
8113012c:	18831e16 	blt	r3,r2,81130da8 <___svfiprintf_internal_r+0xd74>
81130130:	42000204 	addi	r8,r8,8
81130134:	dac02517 	ldw	r11,148(sp)
81130138:	5c17883a 	add	r11,r11,r16
8113013c:	dac02515 	stw	r11,148(sp)
81130140:	88800007 	ldb	r2,0(r17)
81130144:	1002c526 	beq	r2,zero,81130c5c <___svfiprintf_internal_r+0xc28>
81130148:	88c00047 	ldb	r3,1(r17)
8113014c:	8cc00044 	addi	r19,r17,1
81130150:	d8001d85 	stb	zero,118(sp)
81130154:	0009883a 	mov	r4,zero
81130158:	000f883a 	mov	r7,zero
8113015c:	043fffc4 	movi	r16,-1
81130160:	d8002415 	stw	zero,144(sp)
81130164:	0025883a 	mov	r18,zero
81130168:	01401604 	movi	r5,88
8113016c:	01800244 	movi	r6,9
81130170:	02800a84 	movi	r10,42
81130174:	02401b04 	movi	r9,108
81130178:	9cc00044 	addi	r19,r19,1
8113017c:	18bff804 	addi	r2,r3,-32
81130180:	2881dd36 	bltu	r5,r2,811308f8 <___svfiprintf_internal_r+0x8c4>
81130184:	100490ba 	slli	r2,r2,2
81130188:	02e044f4 	movhi	r11,33043
8113018c:	5ac06704 	addi	r11,r11,412
81130190:	12c5883a 	add	r2,r2,r11
81130194:	10800017 	ldw	r2,0(r2)
81130198:	1000683a 	jmp	r2
8113019c:	81130398 	cmpnei	r4,r16,19470
811301a0:	811308f8 	rdprs	r4,r16,19491
811301a4:	811308f8 	rdprs	r4,r16,19491
811301a8:	8113038c 	andi	r4,r16,19470
811301ac:	811308f8 	rdprs	r4,r16,19491
811301b0:	811308f8 	rdprs	r4,r16,19491
811301b4:	811308f8 	rdprs	r4,r16,19491
811301b8:	811308f8 	rdprs	r4,r16,19491
811301bc:	811308f8 	rdprs	r4,r16,19491
811301c0:	811308f8 	rdprs	r4,r16,19491
811301c4:	81130300 	call	88113030 <__reset+0x20f3030>
811301c8:	811304dc 	xori	r4,r16,19475
811301cc:	811308f8 	rdprs	r4,r16,19491
811301d0:	8113032c 	andhi	r4,r16,19468
811301d4:	8113092c 	andhi	r4,r16,19492
811301d8:	811308f8 	rdprs	r4,r16,19491
811301dc:	81130920 	cmpeqi	r4,r16,19492
811301e0:	811308c0 	call	8811308c <__reset+0x20f308c>
811301e4:	811308c0 	call	8811308c <__reset+0x20f308c>
811301e8:	811308c0 	call	8811308c <__reset+0x20f308c>
811301ec:	811308c0 	call	8811308c <__reset+0x20f308c>
811301f0:	811308c0 	call	8811308c <__reset+0x20f308c>
811301f4:	811308c0 	call	8811308c <__reset+0x20f308c>
811301f8:	811308c0 	call	8811308c <__reset+0x20f308c>
811301fc:	811308c0 	call	8811308c <__reset+0x20f308c>
81130200:	811308c0 	call	8811308c <__reset+0x20f308c>
81130204:	811308f8 	rdprs	r4,r16,19491
81130208:	811308f8 	rdprs	r4,r16,19491
8113020c:	811308f8 	rdprs	r4,r16,19491
81130210:	811308f8 	rdprs	r4,r16,19491
81130214:	811308f8 	rdprs	r4,r16,19491
81130218:	811308f8 	rdprs	r4,r16,19491
8113021c:	811308f8 	rdprs	r4,r16,19491
81130220:	811308f8 	rdprs	r4,r16,19491
81130224:	811308f8 	rdprs	r4,r16,19491
81130228:	811308f8 	rdprs	r4,r16,19491
8113022c:	8113085c 	xori	r4,r16,19489
81130230:	811308f8 	rdprs	r4,r16,19491
81130234:	811308f8 	rdprs	r4,r16,19491
81130238:	811308f8 	rdprs	r4,r16,19491
8113023c:	811308f8 	rdprs	r4,r16,19491
81130240:	811308f8 	rdprs	r4,r16,19491
81130244:	811308f8 	rdprs	r4,r16,19491
81130248:	811308f8 	rdprs	r4,r16,19491
8113024c:	811308f8 	rdprs	r4,r16,19491
81130250:	811308f8 	rdprs	r4,r16,19491
81130254:	811308f8 	rdprs	r4,r16,19491
81130258:	811309d4 	ori	r4,r16,19495
8113025c:	811308f8 	rdprs	r4,r16,19491
81130260:	811308f8 	rdprs	r4,r16,19491
81130264:	811308f8 	rdprs	r4,r16,19491
81130268:	811308f8 	rdprs	r4,r16,19491
8113026c:	811308f8 	rdprs	r4,r16,19491
81130270:	8113096c 	andhi	r4,r16,19493
81130274:	811308f8 	rdprs	r4,r16,19491
81130278:	811308f8 	rdprs	r4,r16,19491
8113027c:	811306a0 	cmpeqi	r4,r16,19482
81130280:	811308f8 	rdprs	r4,r16,19491
81130284:	811308f8 	rdprs	r4,r16,19491
81130288:	811308f8 	rdprs	r4,r16,19491
8113028c:	811308f8 	rdprs	r4,r16,19491
81130290:	811308f8 	rdprs	r4,r16,19491
81130294:	811308f8 	rdprs	r4,r16,19491
81130298:	811308f8 	rdprs	r4,r16,19491
8113029c:	811308f8 	rdprs	r4,r16,19491
811302a0:	811308f8 	rdprs	r4,r16,19491
811302a4:	811308f8 	rdprs	r4,r16,19491
811302a8:	81130590 	cmplti	r4,r16,19478
811302ac:	8113073c 	xorhi	r4,r16,19484
811302b0:	811308f8 	rdprs	r4,r16,19491
811302b4:	811308f8 	rdprs	r4,r16,19491
811302b8:	811308f8 	rdprs	r4,r16,19491
811302bc:	81130730 	cmpltui	r4,r16,19484
811302c0:	8113073c 	xorhi	r4,r16,19484
811302c4:	811308f8 	rdprs	r4,r16,19491
811302c8:	811308f8 	rdprs	r4,r16,19491
811302cc:	81130720 	cmpeqi	r4,r16,19484
811302d0:	811308f8 	rdprs	r4,r16,19491
811302d4:	811306e4 	muli	r4,r16,19483
811302d8:	811304ec 	andhi	r4,r16,19475
811302dc:	81130338 	rdprs	r4,r16,19468
811302e0:	81130850 	cmplti	r4,r16,19489
811302e4:	811308f8 	rdprs	r4,r16,19491
811302e8:	81130804 	addi	r4,r16,19488
811302ec:	811308f8 	rdprs	r4,r16,19491
811302f0:	8113045c 	xori	r4,r16,19473
811302f4:	811308f8 	rdprs	r4,r16,19491
811302f8:	811308f8 	rdprs	r4,r16,19491
811302fc:	811303b8 	rdprs	r4,r16,19470
81130300:	dac02317 	ldw	r11,140(sp)
81130304:	5ac00017 	ldw	r11,0(r11)
81130308:	dac02415 	stw	r11,144(sp)
8113030c:	dac02317 	ldw	r11,140(sp)
81130310:	58800104 	addi	r2,r11,4
81130314:	dac02417 	ldw	r11,144(sp)
81130318:	5802e90e 	bge	r11,zero,81130ec0 <___svfiprintf_internal_r+0xe8c>
8113031c:	dac02417 	ldw	r11,144(sp)
81130320:	d8802315 	stw	r2,140(sp)
81130324:	02d7c83a 	sub	r11,zero,r11
81130328:	dac02415 	stw	r11,144(sp)
8113032c:	94800114 	ori	r18,r18,4
81130330:	98c00007 	ldb	r3,0(r19)
81130334:	003f9006 	br	81130178 <__reset+0xfb110178>
81130338:	00800c04 	movi	r2,48
8113033c:	dac02317 	ldw	r11,140(sp)
81130340:	d8801d05 	stb	r2,116(sp)
81130344:	00801e04 	movi	r2,120
81130348:	d8801d45 	stb	r2,117(sp)
8113034c:	d8001d85 	stb	zero,118(sp)
81130350:	58c00104 	addi	r3,r11,4
81130354:	5f000017 	ldw	fp,0(r11)
81130358:	0013883a 	mov	r9,zero
8113035c:	90800094 	ori	r2,r18,2
81130360:	80032b16 	blt	r16,zero,81131010 <___svfiprintf_internal_r+0xfdc>
81130364:	00bfdfc4 	movi	r2,-129
81130368:	90a4703a 	and	r18,r18,r2
8113036c:	d8c02315 	stw	r3,140(sp)
81130370:	94800094 	ori	r18,r18,2
81130374:	e002dc26 	beq	fp,zero,81130ee8 <___svfiprintf_internal_r+0xeb4>
81130378:	01204574 	movhi	r4,33045
8113037c:	21021e04 	addi	r4,r4,2168
81130380:	0015883a 	mov	r10,zero
81130384:	d9002915 	stw	r4,164(sp)
81130388:	00002306 	br	81130418 <___svfiprintf_internal_r+0x3e4>
8113038c:	94800054 	ori	r18,r18,1
81130390:	98c00007 	ldb	r3,0(r19)
81130394:	003f7806 	br	81130178 <__reset+0xfb110178>
81130398:	38803fcc 	andi	r2,r7,255
8113039c:	1080201c 	xori	r2,r2,128
811303a0:	10bfe004 	addi	r2,r2,-128
811303a4:	1002f31e 	bne	r2,zero,81130f74 <___svfiprintf_internal_r+0xf40>
811303a8:	01000044 	movi	r4,1
811303ac:	01c00804 	movi	r7,32
811303b0:	98c00007 	ldb	r3,0(r19)
811303b4:	003f7006 	br	81130178 <__reset+0xfb110178>
811303b8:	21003fcc 	andi	r4,r4,255
811303bc:	2003aa1e 	bne	r4,zero,81131268 <___svfiprintf_internal_r+0x1234>
811303c0:	00a04574 	movhi	r2,33045
811303c4:	10821e04 	addi	r2,r2,2168
811303c8:	d8802915 	stw	r2,164(sp)
811303cc:	9080080c 	andi	r2,r18,32
811303d0:	1000ba26 	beq	r2,zero,811306bc <___svfiprintf_internal_r+0x688>
811303d4:	dac02317 	ldw	r11,140(sp)
811303d8:	5f000017 	ldw	fp,0(r11)
811303dc:	5a400117 	ldw	r9,4(r11)
811303e0:	5ac00204 	addi	r11,r11,8
811303e4:	dac02315 	stw	r11,140(sp)
811303e8:	9080004c 	andi	r2,r18,1
811303ec:	10029026 	beq	r2,zero,81130e30 <___svfiprintf_internal_r+0xdfc>
811303f0:	e244b03a 	or	r2,fp,r9
811303f4:	1002d41e 	bne	r2,zero,81130f48 <___svfiprintf_internal_r+0xf14>
811303f8:	d8001d85 	stb	zero,118(sp)
811303fc:	80030b16 	blt	r16,zero,8113102c <___svfiprintf_internal_r+0xff8>
81130400:	00bfdfc4 	movi	r2,-129
81130404:	90a4703a 	and	r18,r18,r2
81130408:	0015883a 	mov	r10,zero
8113040c:	80002426 	beq	r16,zero,811304a0 <___svfiprintf_internal_r+0x46c>
81130410:	0039883a 	mov	fp,zero
81130414:	0013883a 	mov	r9,zero
81130418:	d9002917 	ldw	r4,164(sp)
8113041c:	dc401a04 	addi	r17,sp,104
81130420:	e08003cc 	andi	r2,fp,15
81130424:	4806973a 	slli	r3,r9,28
81130428:	2085883a 	add	r2,r4,r2
8113042c:	e038d13a 	srli	fp,fp,4
81130430:	10800003 	ldbu	r2,0(r2)
81130434:	4812d13a 	srli	r9,r9,4
81130438:	8c7fffc4 	addi	r17,r17,-1
8113043c:	1f38b03a 	or	fp,r3,fp
81130440:	88800005 	stb	r2,0(r17)
81130444:	e244b03a 	or	r2,fp,r9
81130448:	103ff51e 	bne	r2,zero,81130420 <__reset+0xfb110420>
8113044c:	dac01e17 	ldw	r11,120(sp)
81130450:	5c57c83a 	sub	r11,r11,r17
81130454:	dac02115 	stw	r11,132(sp)
81130458:	00001406 	br	811304ac <___svfiprintf_internal_r+0x478>
8113045c:	21003fcc 	andi	r4,r4,255
81130460:	2003741e 	bne	r4,zero,81131234 <___svfiprintf_internal_r+0x1200>
81130464:	9080080c 	andi	r2,r18,32
81130468:	10014526 	beq	r2,zero,81130980 <___svfiprintf_internal_r+0x94c>
8113046c:	dac02317 	ldw	r11,140(sp)
81130470:	d8001d85 	stb	zero,118(sp)
81130474:	58c00204 	addi	r3,r11,8
81130478:	5f000017 	ldw	fp,0(r11)
8113047c:	5a400117 	ldw	r9,4(r11)
81130480:	8002d916 	blt	r16,zero,81130fe8 <___svfiprintf_internal_r+0xfb4>
81130484:	013fdfc4 	movi	r4,-129
81130488:	e244b03a 	or	r2,fp,r9
8113048c:	d8c02315 	stw	r3,140(sp)
81130490:	9124703a 	and	r18,r18,r4
81130494:	0015883a 	mov	r10,zero
81130498:	1000b91e 	bne	r2,zero,81130780 <___svfiprintf_internal_r+0x74c>
8113049c:	8002e61e 	bne	r16,zero,81131038 <___svfiprintf_internal_r+0x1004>
811304a0:	0021883a 	mov	r16,zero
811304a4:	d8002115 	stw	zero,132(sp)
811304a8:	dc401a04 	addi	r17,sp,104
811304ac:	d8c02117 	ldw	r3,132(sp)
811304b0:	dc002015 	stw	r16,128(sp)
811304b4:	80c0010e 	bge	r16,r3,811304bc <___svfiprintf_internal_r+0x488>
811304b8:	d8c02015 	stw	r3,128(sp)
811304bc:	52803fcc 	andi	r10,r10,255
811304c0:	5280201c 	xori	r10,r10,128
811304c4:	52bfe004 	addi	r10,r10,-128
811304c8:	50003c26 	beq	r10,zero,811305bc <___svfiprintf_internal_r+0x588>
811304cc:	dac02017 	ldw	r11,128(sp)
811304d0:	5ac00044 	addi	r11,r11,1
811304d4:	dac02015 	stw	r11,128(sp)
811304d8:	00003806 	br	811305bc <___svfiprintf_internal_r+0x588>
811304dc:	01000044 	movi	r4,1
811304e0:	01c00ac4 	movi	r7,43
811304e4:	98c00007 	ldb	r3,0(r19)
811304e8:	003f2306 	br	81130178 <__reset+0xfb110178>
811304ec:	21003fcc 	andi	r4,r4,255
811304f0:	2003481e 	bne	r4,zero,81131214 <___svfiprintf_internal_r+0x11e0>
811304f4:	9080080c 	andi	r2,r18,32
811304f8:	10013b26 	beq	r2,zero,811309e8 <___svfiprintf_internal_r+0x9b4>
811304fc:	dac02317 	ldw	r11,140(sp)
81130500:	d8001d85 	stb	zero,118(sp)
81130504:	58800204 	addi	r2,r11,8
81130508:	5f000017 	ldw	fp,0(r11)
8113050c:	5a400117 	ldw	r9,4(r11)
81130510:	8002a816 	blt	r16,zero,81130fb4 <___svfiprintf_internal_r+0xf80>
81130514:	013fdfc4 	movi	r4,-129
81130518:	e246b03a 	or	r3,fp,r9
8113051c:	d8802315 	stw	r2,140(sp)
81130520:	9124703a 	and	r18,r18,r4
81130524:	18013c26 	beq	r3,zero,81130a18 <___svfiprintf_internal_r+0x9e4>
81130528:	0015883a 	mov	r10,zero
8113052c:	dc401a04 	addi	r17,sp,104
81130530:	e006d0fa 	srli	r3,fp,3
81130534:	4808977a 	slli	r4,r9,29
81130538:	4812d0fa 	srli	r9,r9,3
8113053c:	e70001cc 	andi	fp,fp,7
81130540:	e0800c04 	addi	r2,fp,48
81130544:	8c7fffc4 	addi	r17,r17,-1
81130548:	20f8b03a 	or	fp,r4,r3
8113054c:	88800005 	stb	r2,0(r17)
81130550:	e246b03a 	or	r3,fp,r9
81130554:	183ff61e 	bne	r3,zero,81130530 <__reset+0xfb110530>
81130558:	90c0004c 	andi	r3,r18,1
8113055c:	1800a526 	beq	r3,zero,811307f4 <___svfiprintf_internal_r+0x7c0>
81130560:	10803fcc 	andi	r2,r2,255
81130564:	1080201c 	xori	r2,r2,128
81130568:	10bfe004 	addi	r2,r2,-128
8113056c:	00c00c04 	movi	r3,48
81130570:	10ffb626 	beq	r2,r3,8113044c <__reset+0xfb11044c>
81130574:	88ffffc5 	stb	r3,-1(r17)
81130578:	d8c01e17 	ldw	r3,120(sp)
8113057c:	88bfffc4 	addi	r2,r17,-1
81130580:	1023883a 	mov	r17,r2
81130584:	1887c83a 	sub	r3,r3,r2
81130588:	d8c02115 	stw	r3,132(sp)
8113058c:	003fc706 	br	811304ac <__reset+0xfb1104ac>
81130590:	dac02317 	ldw	r11,140(sp)
81130594:	00c00044 	movi	r3,1
81130598:	d8c02015 	stw	r3,128(sp)
8113059c:	58800017 	ldw	r2,0(r11)
811305a0:	5ac00104 	addi	r11,r11,4
811305a4:	d8001d85 	stb	zero,118(sp)
811305a8:	d8801005 	stb	r2,64(sp)
811305ac:	dac02315 	stw	r11,140(sp)
811305b0:	d8c02115 	stw	r3,132(sp)
811305b4:	dc401004 	addi	r17,sp,64
811305b8:	0021883a 	mov	r16,zero
811305bc:	90c0008c 	andi	r3,r18,2
811305c0:	d8c02215 	stw	r3,136(sp)
811305c4:	18000326 	beq	r3,zero,811305d4 <___svfiprintf_internal_r+0x5a0>
811305c8:	dac02017 	ldw	r11,128(sp)
811305cc:	5ac00084 	addi	r11,r11,2
811305d0:	dac02015 	stw	r11,128(sp)
811305d4:	90c0210c 	andi	r3,r18,132
811305d8:	d8c02615 	stw	r3,152(sp)
811305dc:	1801131e 	bne	r3,zero,81130a2c <___svfiprintf_internal_r+0x9f8>
811305e0:	dac02417 	ldw	r11,144(sp)
811305e4:	d8c02017 	ldw	r3,128(sp)
811305e8:	58f9c83a 	sub	fp,r11,r3
811305ec:	07010f0e 	bge	zero,fp,81130a2c <___svfiprintf_internal_r+0x9f8>
811305f0:	02400404 	movi	r9,16
811305f4:	d8c01c17 	ldw	r3,112(sp)
811305f8:	d8801b17 	ldw	r2,108(sp)
811305fc:	4f02d60e 	bge	r9,fp,81131158 <___svfiprintf_internal_r+0x1124>
81130600:	01604574 	movhi	r5,33045
81130604:	2942ac04 	addi	r5,r5,2736
81130608:	d9402815 	stw	r5,160(sp)
8113060c:	028001c4 	movi	r10,7
81130610:	00000306 	br	81130620 <___svfiprintf_internal_r+0x5ec>
81130614:	e73ffc04 	addi	fp,fp,-16
81130618:	42000204 	addi	r8,r8,8
8113061c:	4f00150e 	bge	r9,fp,81130674 <___svfiprintf_internal_r+0x640>
81130620:	18c00404 	addi	r3,r3,16
81130624:	10800044 	addi	r2,r2,1
81130628:	45800015 	stw	r22,0(r8)
8113062c:	42400115 	stw	r9,4(r8)
81130630:	d8c01c15 	stw	r3,112(sp)
81130634:	d8801b15 	stw	r2,108(sp)
81130638:	50bff60e 	bge	r10,r2,81130614 <__reset+0xfb110614>
8113063c:	d9801a04 	addi	r6,sp,104
81130640:	b80b883a 	mov	r5,r23
81130644:	a809883a 	mov	r4,r21
81130648:	da402c15 	stw	r9,176(sp)
8113064c:	da802d15 	stw	r10,180(sp)
81130650:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130654:	da402c17 	ldw	r9,176(sp)
81130658:	da802d17 	ldw	r10,180(sp)
8113065c:	1001851e 	bne	r2,zero,81130c74 <___svfiprintf_internal_r+0xc40>
81130660:	e73ffc04 	addi	fp,fp,-16
81130664:	d8c01c17 	ldw	r3,112(sp)
81130668:	d8801b17 	ldw	r2,108(sp)
8113066c:	d811883a 	mov	r8,sp
81130670:	4f3feb16 	blt	r9,fp,81130620 <__reset+0xfb110620>
81130674:	dac02817 	ldw	r11,160(sp)
81130678:	e0c7883a 	add	r3,fp,r3
8113067c:	10800044 	addi	r2,r2,1
81130680:	42c00015 	stw	r11,0(r8)
81130684:	47000115 	stw	fp,4(r8)
81130688:	d8c01c15 	stw	r3,112(sp)
8113068c:	d8801b15 	stw	r2,108(sp)
81130690:	010001c4 	movi	r4,7
81130694:	2081ee16 	blt	r4,r2,81130e50 <___svfiprintf_internal_r+0xe1c>
81130698:	42000204 	addi	r8,r8,8
8113069c:	0000e506 	br	81130a34 <___svfiprintf_internal_r+0xa00>
811306a0:	21003fcc 	andi	r4,r4,255
811306a4:	2002dd1e 	bne	r4,zero,8113121c <___svfiprintf_internal_r+0x11e8>
811306a8:	00a04574 	movhi	r2,33045
811306ac:	10821904 	addi	r2,r2,2148
811306b0:	d8802915 	stw	r2,164(sp)
811306b4:	9080080c 	andi	r2,r18,32
811306b8:	103f461e 	bne	r2,zero,811303d4 <__reset+0xfb1103d4>
811306bc:	9080040c 	andi	r2,r18,16
811306c0:	10022e1e 	bne	r2,zero,81130f7c <___svfiprintf_internal_r+0xf48>
811306c4:	9080100c 	andi	r2,r18,64
811306c8:	dac02317 	ldw	r11,140(sp)
811306cc:	10027326 	beq	r2,zero,8113109c <___svfiprintf_internal_r+0x1068>
811306d0:	5f00000b 	ldhu	fp,0(r11)
811306d4:	5ac00104 	addi	r11,r11,4
811306d8:	0013883a 	mov	r9,zero
811306dc:	dac02315 	stw	r11,140(sp)
811306e0:	003f4106 	br	811303e8 <__reset+0xfb1103e8>
811306e4:	21003fcc 	andi	r4,r4,255
811306e8:	2002e11e 	bne	r4,zero,81131270 <___svfiprintf_internal_r+0x123c>
811306ec:	9080080c 	andi	r2,r18,32
811306f0:	1002011e 	bne	r2,zero,81130ef8 <___svfiprintf_internal_r+0xec4>
811306f4:	9080040c 	andi	r2,r18,16
811306f8:	10023e1e 	bne	r2,zero,81130ff4 <___svfiprintf_internal_r+0xfc0>
811306fc:	9480100c 	andi	r18,r18,64
81130700:	90023c26 	beq	r18,zero,81130ff4 <___svfiprintf_internal_r+0xfc0>
81130704:	dac02317 	ldw	r11,140(sp)
81130708:	58800017 	ldw	r2,0(r11)
8113070c:	5ac00104 	addi	r11,r11,4
81130710:	dac02315 	stw	r11,140(sp)
81130714:	dac02517 	ldw	r11,148(sp)
81130718:	12c0000d 	sth	r11,0(r2)
8113071c:	003e6e06 	br	811300d8 <__reset+0xfb1100d8>
81130720:	98c00007 	ldb	r3,0(r19)
81130724:	1a422926 	beq	r3,r9,81130fcc <___svfiprintf_internal_r+0xf98>
81130728:	94800414 	ori	r18,r18,16
8113072c:	003e9206 	br	81130178 <__reset+0xfb110178>
81130730:	94801014 	ori	r18,r18,64
81130734:	98c00007 	ldb	r3,0(r19)
81130738:	003e8f06 	br	81130178 <__reset+0xfb110178>
8113073c:	21003fcc 	andi	r4,r4,255
81130740:	2002c71e 	bne	r4,zero,81131260 <___svfiprintf_internal_r+0x122c>
81130744:	9080080c 	andi	r2,r18,32
81130748:	10004926 	beq	r2,zero,81130870 <___svfiprintf_internal_r+0x83c>
8113074c:	dac02317 	ldw	r11,140(sp)
81130750:	58800117 	ldw	r2,4(r11)
81130754:	5f000017 	ldw	fp,0(r11)
81130758:	5ac00204 	addi	r11,r11,8
8113075c:	dac02315 	stw	r11,140(sp)
81130760:	1013883a 	mov	r9,r2
81130764:	10004b16 	blt	r2,zero,81130894 <___svfiprintf_internal_r+0x860>
81130768:	da801d83 	ldbu	r10,118(sp)
8113076c:	8001cb16 	blt	r16,zero,81130e9c <___svfiprintf_internal_r+0xe68>
81130770:	00ffdfc4 	movi	r3,-129
81130774:	e244b03a 	or	r2,fp,r9
81130778:	90e4703a 	and	r18,r18,r3
8113077c:	103f4726 	beq	r2,zero,8113049c <__reset+0xfb11049c>
81130780:	48008c26 	beq	r9,zero,811309b4 <___svfiprintf_internal_r+0x980>
81130784:	dc802015 	stw	r18,128(sp)
81130788:	dc002115 	stw	r16,132(sp)
8113078c:	dc401a04 	addi	r17,sp,104
81130790:	e021883a 	mov	r16,fp
81130794:	da002215 	stw	r8,136(sp)
81130798:	5039883a 	mov	fp,r10
8113079c:	4825883a 	mov	r18,r9
811307a0:	8009883a 	mov	r4,r16
811307a4:	900b883a 	mov	r5,r18
811307a8:	01800284 	movi	r6,10
811307ac:	000f883a 	mov	r7,zero
811307b0:	11343440 	call	81134344 <__umoddi3>
811307b4:	10800c04 	addi	r2,r2,48
811307b8:	8c7fffc4 	addi	r17,r17,-1
811307bc:	8009883a 	mov	r4,r16
811307c0:	900b883a 	mov	r5,r18
811307c4:	88800005 	stb	r2,0(r17)
811307c8:	01800284 	movi	r6,10
811307cc:	000f883a 	mov	r7,zero
811307d0:	1133dc40 	call	81133dc4 <__udivdi3>
811307d4:	1021883a 	mov	r16,r2
811307d8:	10c4b03a 	or	r2,r2,r3
811307dc:	1825883a 	mov	r18,r3
811307e0:	103fef1e 	bne	r2,zero,811307a0 <__reset+0xfb1107a0>
811307e4:	dc802017 	ldw	r18,128(sp)
811307e8:	dc002117 	ldw	r16,132(sp)
811307ec:	da002217 	ldw	r8,136(sp)
811307f0:	e015883a 	mov	r10,fp
811307f4:	d8c01e17 	ldw	r3,120(sp)
811307f8:	1c47c83a 	sub	r3,r3,r17
811307fc:	d8c02115 	stw	r3,132(sp)
81130800:	003f2a06 	br	811304ac <__reset+0xfb1104ac>
81130804:	dac02317 	ldw	r11,140(sp)
81130808:	d8001d85 	stb	zero,118(sp)
8113080c:	5c400017 	ldw	r17,0(r11)
81130810:	5f000104 	addi	fp,r11,4
81130814:	88022f26 	beq	r17,zero,811310d4 <___svfiprintf_internal_r+0x10a0>
81130818:	80022516 	blt	r16,zero,811310b0 <___svfiprintf_internal_r+0x107c>
8113081c:	800d883a 	mov	r6,r16
81130820:	000b883a 	mov	r5,zero
81130824:	8809883a 	mov	r4,r17
81130828:	da002c15 	stw	r8,176(sp)
8113082c:	112c6e80 	call	8112c6e8 <memchr>
81130830:	da002c17 	ldw	r8,176(sp)
81130834:	10026426 	beq	r2,zero,811311c8 <___svfiprintf_internal_r+0x1194>
81130838:	1445c83a 	sub	r2,r2,r17
8113083c:	d8802115 	stw	r2,132(sp)
81130840:	da801d83 	ldbu	r10,118(sp)
81130844:	df002315 	stw	fp,140(sp)
81130848:	0021883a 	mov	r16,zero
8113084c:	003f1706 	br	811304ac <__reset+0xfb1104ac>
81130850:	94800814 	ori	r18,r18,32
81130854:	98c00007 	ldb	r3,0(r19)
81130858:	003e4706 	br	81130178 <__reset+0xfb110178>
8113085c:	21003fcc 	andi	r4,r4,255
81130860:	2002701e 	bne	r4,zero,81131224 <___svfiprintf_internal_r+0x11f0>
81130864:	94800414 	ori	r18,r18,16
81130868:	9080080c 	andi	r2,r18,32
8113086c:	103fb71e 	bne	r2,zero,8113074c <__reset+0xfb11074c>
81130870:	9080040c 	andi	r2,r18,16
81130874:	1001ab26 	beq	r2,zero,81130f24 <___svfiprintf_internal_r+0xef0>
81130878:	dac02317 	ldw	r11,140(sp)
8113087c:	5f000017 	ldw	fp,0(r11)
81130880:	5ac00104 	addi	r11,r11,4
81130884:	dac02315 	stw	r11,140(sp)
81130888:	e013d7fa 	srai	r9,fp,31
8113088c:	4805883a 	mov	r2,r9
81130890:	103fb50e 	bge	r2,zero,81130768 <__reset+0xfb110768>
81130894:	0739c83a 	sub	fp,zero,fp
81130898:	02800b44 	movi	r10,45
8113089c:	e004c03a 	cmpne	r2,fp,zero
811308a0:	0253c83a 	sub	r9,zero,r9
811308a4:	da801d85 	stb	r10,118(sp)
811308a8:	4893c83a 	sub	r9,r9,r2
811308ac:	80023016 	blt	r16,zero,81131170 <___svfiprintf_internal_r+0x113c>
811308b0:	00bfdfc4 	movi	r2,-129
811308b4:	90a4703a 	and	r18,r18,r2
811308b8:	483fb21e 	bne	r9,zero,81130784 <__reset+0xfb110784>
811308bc:	00003d06 	br	811309b4 <___svfiprintf_internal_r+0x980>
811308c0:	9817883a 	mov	r11,r19
811308c4:	d8002415 	stw	zero,144(sp)
811308c8:	18bff404 	addi	r2,r3,-48
811308cc:	0019883a 	mov	r12,zero
811308d0:	58c00007 	ldb	r3,0(r11)
811308d4:	630002a4 	muli	r12,r12,10
811308d8:	9cc00044 	addi	r19,r19,1
811308dc:	9817883a 	mov	r11,r19
811308e0:	1319883a 	add	r12,r2,r12
811308e4:	18bff404 	addi	r2,r3,-48
811308e8:	30bff92e 	bgeu	r6,r2,811308d0 <__reset+0xfb1108d0>
811308ec:	db002415 	stw	r12,144(sp)
811308f0:	18bff804 	addi	r2,r3,-32
811308f4:	28be232e 	bgeu	r5,r2,81130184 <__reset+0xfb110184>
811308f8:	21003fcc 	andi	r4,r4,255
811308fc:	20024b1e 	bne	r4,zero,8113122c <___svfiprintf_internal_r+0x11f8>
81130900:	1800d626 	beq	r3,zero,81130c5c <___svfiprintf_internal_r+0xc28>
81130904:	02c00044 	movi	r11,1
81130908:	dac02015 	stw	r11,128(sp)
8113090c:	d8c01005 	stb	r3,64(sp)
81130910:	d8001d85 	stb	zero,118(sp)
81130914:	dac02115 	stw	r11,132(sp)
81130918:	dc401004 	addi	r17,sp,64
8113091c:	003f2606 	br	811305b8 <__reset+0xfb1105b8>
81130920:	94802014 	ori	r18,r18,128
81130924:	98c00007 	ldb	r3,0(r19)
81130928:	003e1306 	br	81130178 <__reset+0xfb110178>
8113092c:	98c00007 	ldb	r3,0(r19)
81130930:	9ac00044 	addi	r11,r19,1
81130934:	1a822b26 	beq	r3,r10,811311e4 <___svfiprintf_internal_r+0x11b0>
81130938:	18bff404 	addi	r2,r3,-48
8113093c:	0021883a 	mov	r16,zero
81130940:	30821e36 	bltu	r6,r2,811311bc <___svfiprintf_internal_r+0x1188>
81130944:	58c00007 	ldb	r3,0(r11)
81130948:	840002a4 	muli	r16,r16,10
8113094c:	5cc00044 	addi	r19,r11,1
81130950:	9817883a 	mov	r11,r19
81130954:	80a1883a 	add	r16,r16,r2
81130958:	18bff404 	addi	r2,r3,-48
8113095c:	30bff92e 	bgeu	r6,r2,81130944 <__reset+0xfb110944>
81130960:	803e060e 	bge	r16,zero,8113017c <__reset+0xfb11017c>
81130964:	043fffc4 	movi	r16,-1
81130968:	003e0406 	br	8113017c <__reset+0xfb11017c>
8113096c:	21003fcc 	andi	r4,r4,255
81130970:	2002371e 	bne	r4,zero,81131250 <___svfiprintf_internal_r+0x121c>
81130974:	94800414 	ori	r18,r18,16
81130978:	9080080c 	andi	r2,r18,32
8113097c:	103ebb1e 	bne	r2,zero,8113046c <__reset+0xfb11046c>
81130980:	9080040c 	andi	r2,r18,16
81130984:	10013b26 	beq	r2,zero,81130e74 <___svfiprintf_internal_r+0xe40>
81130988:	dac02317 	ldw	r11,140(sp)
8113098c:	d8001d85 	stb	zero,118(sp)
81130990:	0013883a 	mov	r9,zero
81130994:	58800104 	addi	r2,r11,4
81130998:	5f000017 	ldw	fp,0(r11)
8113099c:	80013d16 	blt	r16,zero,81130e94 <___svfiprintf_internal_r+0xe60>
811309a0:	00ffdfc4 	movi	r3,-129
811309a4:	d8802315 	stw	r2,140(sp)
811309a8:	90e4703a 	and	r18,r18,r3
811309ac:	0015883a 	mov	r10,zero
811309b0:	e03eba26 	beq	fp,zero,8113049c <__reset+0xfb11049c>
811309b4:	00800244 	movi	r2,9
811309b8:	173f7236 	bltu	r2,fp,81130784 <__reset+0xfb110784>
811309bc:	dac02b17 	ldw	r11,172(sp)
811309c0:	e7000c04 	addi	fp,fp,48
811309c4:	df0019c5 	stb	fp,103(sp)
811309c8:	dac02115 	stw	r11,132(sp)
811309cc:	dc4019c4 	addi	r17,sp,103
811309d0:	003eb606 	br	811304ac <__reset+0xfb1104ac>
811309d4:	21003fcc 	andi	r4,r4,255
811309d8:	20021f1e 	bne	r4,zero,81131258 <___svfiprintf_internal_r+0x1224>
811309dc:	94800414 	ori	r18,r18,16
811309e0:	9080080c 	andi	r2,r18,32
811309e4:	103ec51e 	bne	r2,zero,811304fc <__reset+0xfb1104fc>
811309e8:	9080040c 	andi	r2,r18,16
811309ec:	10016926 	beq	r2,zero,81130f94 <___svfiprintf_internal_r+0xf60>
811309f0:	dac02317 	ldw	r11,140(sp)
811309f4:	d8001d85 	stb	zero,118(sp)
811309f8:	0013883a 	mov	r9,zero
811309fc:	58800104 	addi	r2,r11,4
81130a00:	5f000017 	ldw	fp,0(r11)
81130a04:	80016b16 	blt	r16,zero,81130fb4 <___svfiprintf_internal_r+0xf80>
81130a08:	00ffdfc4 	movi	r3,-129
81130a0c:	d8802315 	stw	r2,140(sp)
81130a10:	90e4703a 	and	r18,r18,r3
81130a14:	e03ec41e 	bne	fp,zero,81130528 <__reset+0xfb110528>
81130a18:	0015883a 	mov	r10,zero
81130a1c:	8001c226 	beq	r16,zero,81131128 <___svfiprintf_internal_r+0x10f4>
81130a20:	0039883a 	mov	fp,zero
81130a24:	0013883a 	mov	r9,zero
81130a28:	003ec006 	br	8113052c <__reset+0xfb11052c>
81130a2c:	d8c01c17 	ldw	r3,112(sp)
81130a30:	d8801b17 	ldw	r2,108(sp)
81130a34:	d9001d87 	ldb	r4,118(sp)
81130a38:	20000b26 	beq	r4,zero,81130a68 <___svfiprintf_internal_r+0xa34>
81130a3c:	d9001d84 	addi	r4,sp,118
81130a40:	18c00044 	addi	r3,r3,1
81130a44:	10800044 	addi	r2,r2,1
81130a48:	41000015 	stw	r4,0(r8)
81130a4c:	01000044 	movi	r4,1
81130a50:	41000115 	stw	r4,4(r8)
81130a54:	d8c01c15 	stw	r3,112(sp)
81130a58:	d8801b15 	stw	r2,108(sp)
81130a5c:	010001c4 	movi	r4,7
81130a60:	2080e116 	blt	r4,r2,81130de8 <___svfiprintf_internal_r+0xdb4>
81130a64:	42000204 	addi	r8,r8,8
81130a68:	dac02217 	ldw	r11,136(sp)
81130a6c:	58000b26 	beq	r11,zero,81130a9c <___svfiprintf_internal_r+0xa68>
81130a70:	d9001d04 	addi	r4,sp,116
81130a74:	18c00084 	addi	r3,r3,2
81130a78:	10800044 	addi	r2,r2,1
81130a7c:	41000015 	stw	r4,0(r8)
81130a80:	01000084 	movi	r4,2
81130a84:	41000115 	stw	r4,4(r8)
81130a88:	d8c01c15 	stw	r3,112(sp)
81130a8c:	d8801b15 	stw	r2,108(sp)
81130a90:	010001c4 	movi	r4,7
81130a94:	2080dd16 	blt	r4,r2,81130e0c <___svfiprintf_internal_r+0xdd8>
81130a98:	42000204 	addi	r8,r8,8
81130a9c:	dac02617 	ldw	r11,152(sp)
81130aa0:	01002004 	movi	r4,128
81130aa4:	59008426 	beq	r11,r4,81130cb8 <___svfiprintf_internal_r+0xc84>
81130aa8:	dac02117 	ldw	r11,132(sp)
81130aac:	82e1c83a 	sub	r16,r16,r11
81130ab0:	0400270e 	bge	zero,r16,81130b50 <___svfiprintf_internal_r+0xb1c>
81130ab4:	01c00404 	movi	r7,16
81130ab8:	3c016a0e 	bge	r7,r16,81131064 <___svfiprintf_internal_r+0x1030>
81130abc:	01604574 	movhi	r5,33045
81130ac0:	2942a804 	addi	r5,r5,2720
81130ac4:	d9402215 	stw	r5,136(sp)
81130ac8:	070001c4 	movi	fp,7
81130acc:	00000306 	br	81130adc <___svfiprintf_internal_r+0xaa8>
81130ad0:	843ffc04 	addi	r16,r16,-16
81130ad4:	42000204 	addi	r8,r8,8
81130ad8:	3c00130e 	bge	r7,r16,81130b28 <___svfiprintf_internal_r+0xaf4>
81130adc:	18c00404 	addi	r3,r3,16
81130ae0:	10800044 	addi	r2,r2,1
81130ae4:	45000015 	stw	r20,0(r8)
81130ae8:	41c00115 	stw	r7,4(r8)
81130aec:	d8c01c15 	stw	r3,112(sp)
81130af0:	d8801b15 	stw	r2,108(sp)
81130af4:	e0bff60e 	bge	fp,r2,81130ad0 <__reset+0xfb110ad0>
81130af8:	d9801a04 	addi	r6,sp,104
81130afc:	b80b883a 	mov	r5,r23
81130b00:	a809883a 	mov	r4,r21
81130b04:	d9c02c15 	stw	r7,176(sp)
81130b08:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130b0c:	d9c02c17 	ldw	r7,176(sp)
81130b10:	1000581e 	bne	r2,zero,81130c74 <___svfiprintf_internal_r+0xc40>
81130b14:	843ffc04 	addi	r16,r16,-16
81130b18:	d8c01c17 	ldw	r3,112(sp)
81130b1c:	d8801b17 	ldw	r2,108(sp)
81130b20:	d811883a 	mov	r8,sp
81130b24:	3c3fed16 	blt	r7,r16,81130adc <__reset+0xfb110adc>
81130b28:	dac02217 	ldw	r11,136(sp)
81130b2c:	1c07883a 	add	r3,r3,r16
81130b30:	10800044 	addi	r2,r2,1
81130b34:	42c00015 	stw	r11,0(r8)
81130b38:	44000115 	stw	r16,4(r8)
81130b3c:	d8c01c15 	stw	r3,112(sp)
81130b40:	d8801b15 	stw	r2,108(sp)
81130b44:	010001c4 	movi	r4,7
81130b48:	20809e16 	blt	r4,r2,81130dc4 <___svfiprintf_internal_r+0xd90>
81130b4c:	42000204 	addi	r8,r8,8
81130b50:	dac02117 	ldw	r11,132(sp)
81130b54:	10800044 	addi	r2,r2,1
81130b58:	44400015 	stw	r17,0(r8)
81130b5c:	58c7883a 	add	r3,r11,r3
81130b60:	42c00115 	stw	r11,4(r8)
81130b64:	d8c01c15 	stw	r3,112(sp)
81130b68:	d8801b15 	stw	r2,108(sp)
81130b6c:	010001c4 	movi	r4,7
81130b70:	20807f16 	blt	r4,r2,81130d70 <___svfiprintf_internal_r+0xd3c>
81130b74:	42000204 	addi	r8,r8,8
81130b78:	9480010c 	andi	r18,r18,4
81130b7c:	90002926 	beq	r18,zero,81130c24 <___svfiprintf_internal_r+0xbf0>
81130b80:	dac02417 	ldw	r11,144(sp)
81130b84:	d8802017 	ldw	r2,128(sp)
81130b88:	58a1c83a 	sub	r16,r11,r2
81130b8c:	0400250e 	bge	zero,r16,81130c24 <___svfiprintf_internal_r+0xbf0>
81130b90:	04400404 	movi	r17,16
81130b94:	d8801b17 	ldw	r2,108(sp)
81130b98:	8c017c0e 	bge	r17,r16,8113118c <___svfiprintf_internal_r+0x1158>
81130b9c:	01604574 	movhi	r5,33045
81130ba0:	2942ac04 	addi	r5,r5,2736
81130ba4:	d9402815 	stw	r5,160(sp)
81130ba8:	048001c4 	movi	r18,7
81130bac:	00000306 	br	81130bbc <___svfiprintf_internal_r+0xb88>
81130bb0:	843ffc04 	addi	r16,r16,-16
81130bb4:	42000204 	addi	r8,r8,8
81130bb8:	8c00110e 	bge	r17,r16,81130c00 <___svfiprintf_internal_r+0xbcc>
81130bbc:	18c00404 	addi	r3,r3,16
81130bc0:	10800044 	addi	r2,r2,1
81130bc4:	45800015 	stw	r22,0(r8)
81130bc8:	44400115 	stw	r17,4(r8)
81130bcc:	d8c01c15 	stw	r3,112(sp)
81130bd0:	d8801b15 	stw	r2,108(sp)
81130bd4:	90bff60e 	bge	r18,r2,81130bb0 <__reset+0xfb110bb0>
81130bd8:	d9801a04 	addi	r6,sp,104
81130bdc:	b80b883a 	mov	r5,r23
81130be0:	a809883a 	mov	r4,r21
81130be4:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130be8:	1000221e 	bne	r2,zero,81130c74 <___svfiprintf_internal_r+0xc40>
81130bec:	843ffc04 	addi	r16,r16,-16
81130bf0:	d8c01c17 	ldw	r3,112(sp)
81130bf4:	d8801b17 	ldw	r2,108(sp)
81130bf8:	d811883a 	mov	r8,sp
81130bfc:	8c3fef16 	blt	r17,r16,81130bbc <__reset+0xfb110bbc>
81130c00:	dac02817 	ldw	r11,160(sp)
81130c04:	1c07883a 	add	r3,r3,r16
81130c08:	10800044 	addi	r2,r2,1
81130c0c:	42c00015 	stw	r11,0(r8)
81130c10:	44000115 	stw	r16,4(r8)
81130c14:	d8c01c15 	stw	r3,112(sp)
81130c18:	d8801b15 	stw	r2,108(sp)
81130c1c:	010001c4 	movi	r4,7
81130c20:	2080aa16 	blt	r4,r2,81130ecc <___svfiprintf_internal_r+0xe98>
81130c24:	d8802417 	ldw	r2,144(sp)
81130c28:	dac02017 	ldw	r11,128(sp)
81130c2c:	12c0010e 	bge	r2,r11,81130c34 <___svfiprintf_internal_r+0xc00>
81130c30:	5805883a 	mov	r2,r11
81130c34:	dac02517 	ldw	r11,148(sp)
81130c38:	5897883a 	add	r11,r11,r2
81130c3c:	dac02515 	stw	r11,148(sp)
81130c40:	1800531e 	bne	r3,zero,81130d90 <___svfiprintf_internal_r+0xd5c>
81130c44:	98800007 	ldb	r2,0(r19)
81130c48:	d8001b15 	stw	zero,108(sp)
81130c4c:	d811883a 	mov	r8,sp
81130c50:	103d231e 	bne	r2,zero,811300e0 <__reset+0xfb1100e0>
81130c54:	9823883a 	mov	r17,r19
81130c58:	003d3906 	br	81130140 <__reset+0xfb110140>
81130c5c:	d8801c17 	ldw	r2,112(sp)
81130c60:	10000426 	beq	r2,zero,81130c74 <___svfiprintf_internal_r+0xc40>
81130c64:	d9402717 	ldw	r5,156(sp)
81130c68:	d9002a17 	ldw	r4,168(sp)
81130c6c:	d9801a04 	addi	r6,sp,104
81130c70:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130c74:	dac02717 	ldw	r11,156(sp)
81130c78:	d8802517 	ldw	r2,148(sp)
81130c7c:	58c0030b 	ldhu	r3,12(r11)
81130c80:	18c0100c 	andi	r3,r3,64
81130c84:	1801381e 	bne	r3,zero,81131168 <___svfiprintf_internal_r+0x1134>
81130c88:	dfc03717 	ldw	ra,220(sp)
81130c8c:	df003617 	ldw	fp,216(sp)
81130c90:	ddc03517 	ldw	r23,212(sp)
81130c94:	dd803417 	ldw	r22,208(sp)
81130c98:	dd403317 	ldw	r21,204(sp)
81130c9c:	dd003217 	ldw	r20,200(sp)
81130ca0:	dcc03117 	ldw	r19,196(sp)
81130ca4:	dc803017 	ldw	r18,192(sp)
81130ca8:	dc402f17 	ldw	r17,188(sp)
81130cac:	dc002e17 	ldw	r16,184(sp)
81130cb0:	dec03804 	addi	sp,sp,224
81130cb4:	f800283a 	ret
81130cb8:	dac02417 	ldw	r11,144(sp)
81130cbc:	d9002017 	ldw	r4,128(sp)
81130cc0:	5939c83a 	sub	fp,r11,r4
81130cc4:	073f780e 	bge	zero,fp,81130aa8 <__reset+0xfb110aa8>
81130cc8:	02400404 	movi	r9,16
81130ccc:	4f01370e 	bge	r9,fp,811311ac <___svfiprintf_internal_r+0x1178>
81130cd0:	02e04574 	movhi	r11,33045
81130cd4:	5ac2a804 	addi	r11,r11,2720
81130cd8:	dac02215 	stw	r11,136(sp)
81130cdc:	028001c4 	movi	r10,7
81130ce0:	00000306 	br	81130cf0 <___svfiprintf_internal_r+0xcbc>
81130ce4:	e73ffc04 	addi	fp,fp,-16
81130ce8:	42000204 	addi	r8,r8,8
81130cec:	4f00150e 	bge	r9,fp,81130d44 <___svfiprintf_internal_r+0xd10>
81130cf0:	18c00404 	addi	r3,r3,16
81130cf4:	10800044 	addi	r2,r2,1
81130cf8:	45000015 	stw	r20,0(r8)
81130cfc:	42400115 	stw	r9,4(r8)
81130d00:	d8c01c15 	stw	r3,112(sp)
81130d04:	d8801b15 	stw	r2,108(sp)
81130d08:	50bff60e 	bge	r10,r2,81130ce4 <__reset+0xfb110ce4>
81130d0c:	d9801a04 	addi	r6,sp,104
81130d10:	b80b883a 	mov	r5,r23
81130d14:	a809883a 	mov	r4,r21
81130d18:	da402c15 	stw	r9,176(sp)
81130d1c:	da802d15 	stw	r10,180(sp)
81130d20:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130d24:	da402c17 	ldw	r9,176(sp)
81130d28:	da802d17 	ldw	r10,180(sp)
81130d2c:	103fd11e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81130d30:	e73ffc04 	addi	fp,fp,-16
81130d34:	d8c01c17 	ldw	r3,112(sp)
81130d38:	d8801b17 	ldw	r2,108(sp)
81130d3c:	d811883a 	mov	r8,sp
81130d40:	4f3feb16 	blt	r9,fp,81130cf0 <__reset+0xfb110cf0>
81130d44:	dac02217 	ldw	r11,136(sp)
81130d48:	1f07883a 	add	r3,r3,fp
81130d4c:	10800044 	addi	r2,r2,1
81130d50:	42c00015 	stw	r11,0(r8)
81130d54:	47000115 	stw	fp,4(r8)
81130d58:	d8c01c15 	stw	r3,112(sp)
81130d5c:	d8801b15 	stw	r2,108(sp)
81130d60:	010001c4 	movi	r4,7
81130d64:	2080b616 	blt	r4,r2,81131040 <___svfiprintf_internal_r+0x100c>
81130d68:	42000204 	addi	r8,r8,8
81130d6c:	003f4e06 	br	81130aa8 <__reset+0xfb110aa8>
81130d70:	d9801a04 	addi	r6,sp,104
81130d74:	b80b883a 	mov	r5,r23
81130d78:	a809883a 	mov	r4,r21
81130d7c:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130d80:	103fbc1e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81130d84:	d8c01c17 	ldw	r3,112(sp)
81130d88:	d811883a 	mov	r8,sp
81130d8c:	003f7a06 	br	81130b78 <__reset+0xfb110b78>
81130d90:	d9801a04 	addi	r6,sp,104
81130d94:	b80b883a 	mov	r5,r23
81130d98:	a809883a 	mov	r4,r21
81130d9c:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130da0:	103fa826 	beq	r2,zero,81130c44 <__reset+0xfb110c44>
81130da4:	003fb306 	br	81130c74 <__reset+0xfb110c74>
81130da8:	d9801a04 	addi	r6,sp,104
81130dac:	b80b883a 	mov	r5,r23
81130db0:	a809883a 	mov	r4,r21
81130db4:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130db8:	103fae1e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81130dbc:	d811883a 	mov	r8,sp
81130dc0:	003cdc06 	br	81130134 <__reset+0xfb110134>
81130dc4:	d9801a04 	addi	r6,sp,104
81130dc8:	b80b883a 	mov	r5,r23
81130dcc:	a809883a 	mov	r4,r21
81130dd0:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130dd4:	103fa71e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81130dd8:	d8c01c17 	ldw	r3,112(sp)
81130ddc:	d8801b17 	ldw	r2,108(sp)
81130de0:	d811883a 	mov	r8,sp
81130de4:	003f5a06 	br	81130b50 <__reset+0xfb110b50>
81130de8:	d9801a04 	addi	r6,sp,104
81130dec:	b80b883a 	mov	r5,r23
81130df0:	a809883a 	mov	r4,r21
81130df4:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130df8:	103f9e1e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81130dfc:	d8c01c17 	ldw	r3,112(sp)
81130e00:	d8801b17 	ldw	r2,108(sp)
81130e04:	d811883a 	mov	r8,sp
81130e08:	003f1706 	br	81130a68 <__reset+0xfb110a68>
81130e0c:	d9801a04 	addi	r6,sp,104
81130e10:	b80b883a 	mov	r5,r23
81130e14:	a809883a 	mov	r4,r21
81130e18:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130e1c:	103f951e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81130e20:	d8c01c17 	ldw	r3,112(sp)
81130e24:	d8801b17 	ldw	r2,108(sp)
81130e28:	d811883a 	mov	r8,sp
81130e2c:	003f1b06 	br	81130a9c <__reset+0xfb110a9c>
81130e30:	d8001d85 	stb	zero,118(sp)
81130e34:	80007b16 	blt	r16,zero,81131024 <___svfiprintf_internal_r+0xff0>
81130e38:	00ffdfc4 	movi	r3,-129
81130e3c:	e244b03a 	or	r2,fp,r9
81130e40:	90e4703a 	and	r18,r18,r3
81130e44:	103d7026 	beq	r2,zero,81130408 <__reset+0xfb110408>
81130e48:	0015883a 	mov	r10,zero
81130e4c:	003d7206 	br	81130418 <__reset+0xfb110418>
81130e50:	d9801a04 	addi	r6,sp,104
81130e54:	b80b883a 	mov	r5,r23
81130e58:	a809883a 	mov	r4,r21
81130e5c:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130e60:	103f841e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81130e64:	d8c01c17 	ldw	r3,112(sp)
81130e68:	d8801b17 	ldw	r2,108(sp)
81130e6c:	d811883a 	mov	r8,sp
81130e70:	003ef006 	br	81130a34 <__reset+0xfb110a34>
81130e74:	9080100c 	andi	r2,r18,64
81130e78:	d8001d85 	stb	zero,118(sp)
81130e7c:	dac02317 	ldw	r11,140(sp)
81130e80:	10008126 	beq	r2,zero,81131088 <___svfiprintf_internal_r+0x1054>
81130e84:	58800104 	addi	r2,r11,4
81130e88:	5f00000b 	ldhu	fp,0(r11)
81130e8c:	0013883a 	mov	r9,zero
81130e90:	803ec30e 	bge	r16,zero,811309a0 <__reset+0xfb1109a0>
81130e94:	d8802315 	stw	r2,140(sp)
81130e98:	0015883a 	mov	r10,zero
81130e9c:	e244b03a 	or	r2,fp,r9
81130ea0:	103e371e 	bne	r2,zero,81130780 <__reset+0xfb110780>
81130ea4:	00800044 	movi	r2,1
81130ea8:	10803fcc 	andi	r2,r2,255
81130eac:	00c00044 	movi	r3,1
81130eb0:	10c06126 	beq	r2,r3,81131038 <___svfiprintf_internal_r+0x1004>
81130eb4:	00c00084 	movi	r3,2
81130eb8:	10fd5526 	beq	r2,r3,81130410 <__reset+0xfb110410>
81130ebc:	003ed806 	br	81130a20 <__reset+0xfb110a20>
81130ec0:	d8802315 	stw	r2,140(sp)
81130ec4:	98c00007 	ldb	r3,0(r19)
81130ec8:	003cab06 	br	81130178 <__reset+0xfb110178>
81130ecc:	d9801a04 	addi	r6,sp,104
81130ed0:	b80b883a 	mov	r5,r23
81130ed4:	a809883a 	mov	r4,r21
81130ed8:	112fe5c0 	call	8112fe5c <__ssprint_r>
81130edc:	103f651e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81130ee0:	d8c01c17 	ldw	r3,112(sp)
81130ee4:	003f4f06 	br	81130c24 <__reset+0xfb110c24>
81130ee8:	00a04574 	movhi	r2,33045
81130eec:	10821e04 	addi	r2,r2,2168
81130ef0:	d8802915 	stw	r2,164(sp)
81130ef4:	003d4406 	br	81130408 <__reset+0xfb110408>
81130ef8:	dac02317 	ldw	r11,140(sp)
81130efc:	58800017 	ldw	r2,0(r11)
81130f00:	dac02517 	ldw	r11,148(sp)
81130f04:	5807d7fa 	srai	r3,r11,31
81130f08:	dac02317 	ldw	r11,140(sp)
81130f0c:	10c00115 	stw	r3,4(r2)
81130f10:	5ac00104 	addi	r11,r11,4
81130f14:	dac02315 	stw	r11,140(sp)
81130f18:	dac02517 	ldw	r11,148(sp)
81130f1c:	12c00015 	stw	r11,0(r2)
81130f20:	003c6d06 	br	811300d8 <__reset+0xfb1100d8>
81130f24:	9080100c 	andi	r2,r18,64
81130f28:	dac02317 	ldw	r11,140(sp)
81130f2c:	103e5326 	beq	r2,zero,8113087c <__reset+0xfb11087c>
81130f30:	5f00000f 	ldh	fp,0(r11)
81130f34:	5ac00104 	addi	r11,r11,4
81130f38:	dac02315 	stw	r11,140(sp)
81130f3c:	e013d7fa 	srai	r9,fp,31
81130f40:	4805883a 	mov	r2,r9
81130f44:	003e0706 	br	81130764 <__reset+0xfb110764>
81130f48:	00800c04 	movi	r2,48
81130f4c:	d8801d05 	stb	r2,116(sp)
81130f50:	d8c01d45 	stb	r3,117(sp)
81130f54:	d8001d85 	stb	zero,118(sp)
81130f58:	90800094 	ori	r2,r18,2
81130f5c:	80008f16 	blt	r16,zero,8113119c <___svfiprintf_internal_r+0x1168>
81130f60:	00bfdfc4 	movi	r2,-129
81130f64:	90a4703a 	and	r18,r18,r2
81130f68:	94800094 	ori	r18,r18,2
81130f6c:	0015883a 	mov	r10,zero
81130f70:	003d2906 	br	81130418 <__reset+0xfb110418>
81130f74:	98c00007 	ldb	r3,0(r19)
81130f78:	003c7f06 	br	81130178 <__reset+0xfb110178>
81130f7c:	dac02317 	ldw	r11,140(sp)
81130f80:	0013883a 	mov	r9,zero
81130f84:	5f000017 	ldw	fp,0(r11)
81130f88:	5ac00104 	addi	r11,r11,4
81130f8c:	dac02315 	stw	r11,140(sp)
81130f90:	003d1506 	br	811303e8 <__reset+0xfb1103e8>
81130f94:	9080100c 	andi	r2,r18,64
81130f98:	d8001d85 	stb	zero,118(sp)
81130f9c:	dac02317 	ldw	r11,140(sp)
81130fa0:	10003426 	beq	r2,zero,81131074 <___svfiprintf_internal_r+0x1040>
81130fa4:	58800104 	addi	r2,r11,4
81130fa8:	5f00000b 	ldhu	fp,0(r11)
81130fac:	0013883a 	mov	r9,zero
81130fb0:	803e950e 	bge	r16,zero,81130a08 <__reset+0xfb110a08>
81130fb4:	e246b03a 	or	r3,fp,r9
81130fb8:	d8802315 	stw	r2,140(sp)
81130fbc:	183d5a1e 	bne	r3,zero,81130528 <__reset+0xfb110528>
81130fc0:	0015883a 	mov	r10,zero
81130fc4:	0005883a 	mov	r2,zero
81130fc8:	003fb706 	br	81130ea8 <__reset+0xfb110ea8>
81130fcc:	98c00043 	ldbu	r3,1(r19)
81130fd0:	94800814 	ori	r18,r18,32
81130fd4:	9cc00044 	addi	r19,r19,1
81130fd8:	18c03fcc 	andi	r3,r3,255
81130fdc:	18c0201c 	xori	r3,r3,128
81130fe0:	18ffe004 	addi	r3,r3,-128
81130fe4:	003c6406 	br	81130178 <__reset+0xfb110178>
81130fe8:	d8c02315 	stw	r3,140(sp)
81130fec:	0015883a 	mov	r10,zero
81130ff0:	003faa06 	br	81130e9c <__reset+0xfb110e9c>
81130ff4:	dac02317 	ldw	r11,140(sp)
81130ff8:	58800017 	ldw	r2,0(r11)
81130ffc:	5ac00104 	addi	r11,r11,4
81131000:	dac02315 	stw	r11,140(sp)
81131004:	dac02517 	ldw	r11,148(sp)
81131008:	12c00015 	stw	r11,0(r2)
8113100c:	003c3206 	br	811300d8 <__reset+0xfb1100d8>
81131010:	01204574 	movhi	r4,33045
81131014:	21021e04 	addi	r4,r4,2168
81131018:	d9002915 	stw	r4,164(sp)
8113101c:	d8c02315 	stw	r3,140(sp)
81131020:	1025883a 	mov	r18,r2
81131024:	e244b03a 	or	r2,fp,r9
81131028:	103f871e 	bne	r2,zero,81130e48 <__reset+0xfb110e48>
8113102c:	0015883a 	mov	r10,zero
81131030:	00800084 	movi	r2,2
81131034:	003f9c06 	br	81130ea8 <__reset+0xfb110ea8>
81131038:	0039883a 	mov	fp,zero
8113103c:	003e5f06 	br	811309bc <__reset+0xfb1109bc>
81131040:	d9801a04 	addi	r6,sp,104
81131044:	b80b883a 	mov	r5,r23
81131048:	a809883a 	mov	r4,r21
8113104c:	112fe5c0 	call	8112fe5c <__ssprint_r>
81131050:	103f081e 	bne	r2,zero,81130c74 <__reset+0xfb110c74>
81131054:	d8c01c17 	ldw	r3,112(sp)
81131058:	d8801b17 	ldw	r2,108(sp)
8113105c:	d811883a 	mov	r8,sp
81131060:	003e9106 	br	81130aa8 <__reset+0xfb110aa8>
81131064:	01204574 	movhi	r4,33045
81131068:	2102a804 	addi	r4,r4,2720
8113106c:	d9002215 	stw	r4,136(sp)
81131070:	003ead06 	br	81130b28 <__reset+0xfb110b28>
81131074:	58800104 	addi	r2,r11,4
81131078:	5f000017 	ldw	fp,0(r11)
8113107c:	0013883a 	mov	r9,zero
81131080:	803e610e 	bge	r16,zero,81130a08 <__reset+0xfb110a08>
81131084:	003fcb06 	br	81130fb4 <__reset+0xfb110fb4>
81131088:	58800104 	addi	r2,r11,4
8113108c:	5f000017 	ldw	fp,0(r11)
81131090:	0013883a 	mov	r9,zero
81131094:	803e420e 	bge	r16,zero,811309a0 <__reset+0xfb1109a0>
81131098:	003f7e06 	br	81130e94 <__reset+0xfb110e94>
8113109c:	5f000017 	ldw	fp,0(r11)
811310a0:	5ac00104 	addi	r11,r11,4
811310a4:	0013883a 	mov	r9,zero
811310a8:	dac02315 	stw	r11,140(sp)
811310ac:	003cce06 	br	811303e8 <__reset+0xfb1103e8>
811310b0:	8809883a 	mov	r4,r17
811310b4:	da002c15 	stw	r8,176(sp)
811310b8:	1122ee80 	call	81122ee8 <strlen>
811310bc:	d8802115 	stw	r2,132(sp)
811310c0:	da801d83 	ldbu	r10,118(sp)
811310c4:	df002315 	stw	fp,140(sp)
811310c8:	0021883a 	mov	r16,zero
811310cc:	da002c17 	ldw	r8,176(sp)
811310d0:	003cf606 	br	811304ac <__reset+0xfb1104ac>
811310d4:	00800184 	movi	r2,6
811310d8:	1400012e 	bgeu	r2,r16,811310e0 <___svfiprintf_internal_r+0x10ac>
811310dc:	1021883a 	mov	r16,r2
811310e0:	dc002115 	stw	r16,132(sp)
811310e4:	8005883a 	mov	r2,r16
811310e8:	80003c16 	blt	r16,zero,811311dc <___svfiprintf_internal_r+0x11a8>
811310ec:	04604574 	movhi	r17,33045
811310f0:	d8802015 	stw	r2,128(sp)
811310f4:	df002315 	stw	fp,140(sp)
811310f8:	8c422304 	addi	r17,r17,2188
811310fc:	003d2e06 	br	811305b8 <__reset+0xfb1105b8>
81131100:	04001004 	movi	r16,64
81131104:	800b883a 	mov	r5,r16
81131108:	1121be00 	call	81121be0 <_malloc_r>
8113110c:	dac02717 	ldw	r11,156(sp)
81131110:	58800015 	stw	r2,0(r11)
81131114:	58800415 	stw	r2,16(r11)
81131118:	10004826 	beq	r2,zero,8113123c <___svfiprintf_internal_r+0x1208>
8113111c:	dac02717 	ldw	r11,156(sp)
81131120:	5c000515 	stw	r16,20(r11)
81131124:	003bd906 	br	8113008c <__reset+0xfb11008c>
81131128:	9080004c 	andi	r2,r18,1
8113112c:	0015883a 	mov	r10,zero
81131130:	10000626 	beq	r2,zero,8113114c <___svfiprintf_internal_r+0x1118>
81131134:	dac02b17 	ldw	r11,172(sp)
81131138:	00800c04 	movi	r2,48
8113113c:	d88019c5 	stb	r2,103(sp)
81131140:	dac02115 	stw	r11,132(sp)
81131144:	dc4019c4 	addi	r17,sp,103
81131148:	003cd806 	br	811304ac <__reset+0xfb1104ac>
8113114c:	d8002115 	stw	zero,132(sp)
81131150:	dc401a04 	addi	r17,sp,104
81131154:	003cd506 	br	811304ac <__reset+0xfb1104ac>
81131158:	01204574 	movhi	r4,33045
8113115c:	2102ac04 	addi	r4,r4,2736
81131160:	d9002815 	stw	r4,160(sp)
81131164:	003d4306 	br	81130674 <__reset+0xfb110674>
81131168:	00bfffc4 	movi	r2,-1
8113116c:	003ec606 	br	81130c88 <__reset+0xfb110c88>
81131170:	00800044 	movi	r2,1
81131174:	10803fcc 	andi	r2,r2,255
81131178:	00c00044 	movi	r3,1
8113117c:	10fd8026 	beq	r2,r3,81130780 <__reset+0xfb110780>
81131180:	00c00084 	movi	r3,2
81131184:	10fca426 	beq	r2,r3,81130418 <__reset+0xfb110418>
81131188:	003ce806 	br	8113052c <__reset+0xfb11052c>
8113118c:	01204574 	movhi	r4,33045
81131190:	2102ac04 	addi	r4,r4,2736
81131194:	d9002815 	stw	r4,160(sp)
81131198:	003e9906 	br	81130c00 <__reset+0xfb110c00>
8113119c:	1025883a 	mov	r18,r2
811311a0:	0015883a 	mov	r10,zero
811311a4:	00800084 	movi	r2,2
811311a8:	003ff206 	br	81131174 <__reset+0xfb111174>
811311ac:	01604574 	movhi	r5,33045
811311b0:	2942a804 	addi	r5,r5,2720
811311b4:	d9402215 	stw	r5,136(sp)
811311b8:	003ee206 	br	81130d44 <__reset+0xfb110d44>
811311bc:	5827883a 	mov	r19,r11
811311c0:	0021883a 	mov	r16,zero
811311c4:	003bed06 	br	8113017c <__reset+0xfb11017c>
811311c8:	dc002115 	stw	r16,132(sp)
811311cc:	da801d83 	ldbu	r10,118(sp)
811311d0:	df002315 	stw	fp,140(sp)
811311d4:	0021883a 	mov	r16,zero
811311d8:	003cb406 	br	811304ac <__reset+0xfb1104ac>
811311dc:	0005883a 	mov	r2,zero
811311e0:	003fc206 	br	811310ec <__reset+0xfb1110ec>
811311e4:	d8802317 	ldw	r2,140(sp)
811311e8:	98c00043 	ldbu	r3,1(r19)
811311ec:	5827883a 	mov	r19,r11
811311f0:	14000017 	ldw	r16,0(r2)
811311f4:	10800104 	addi	r2,r2,4
811311f8:	d8802315 	stw	r2,140(sp)
811311fc:	803f760e 	bge	r16,zero,81130fd8 <__reset+0xfb110fd8>
81131200:	18c03fcc 	andi	r3,r3,255
81131204:	18c0201c 	xori	r3,r3,128
81131208:	043fffc4 	movi	r16,-1
8113120c:	18ffe004 	addi	r3,r3,-128
81131210:	003bd906 	br	81130178 <__reset+0xfb110178>
81131214:	d9c01d85 	stb	r7,118(sp)
81131218:	003cb606 	br	811304f4 <__reset+0xfb1104f4>
8113121c:	d9c01d85 	stb	r7,118(sp)
81131220:	003d2106 	br	811306a8 <__reset+0xfb1106a8>
81131224:	d9c01d85 	stb	r7,118(sp)
81131228:	003d8e06 	br	81130864 <__reset+0xfb110864>
8113122c:	d9c01d85 	stb	r7,118(sp)
81131230:	003db306 	br	81130900 <__reset+0xfb110900>
81131234:	d9c01d85 	stb	r7,118(sp)
81131238:	003c8a06 	br	81130464 <__reset+0xfb110464>
8113123c:	dac02a17 	ldw	r11,168(sp)
81131240:	00800304 	movi	r2,12
81131244:	58800015 	stw	r2,0(r11)
81131248:	00bfffc4 	movi	r2,-1
8113124c:	003e8e06 	br	81130c88 <__reset+0xfb110c88>
81131250:	d9c01d85 	stb	r7,118(sp)
81131254:	003dc706 	br	81130974 <__reset+0xfb110974>
81131258:	d9c01d85 	stb	r7,118(sp)
8113125c:	003ddf06 	br	811309dc <__reset+0xfb1109dc>
81131260:	d9c01d85 	stb	r7,118(sp)
81131264:	003d3706 	br	81130744 <__reset+0xfb110744>
81131268:	d9c01d85 	stb	r7,118(sp)
8113126c:	003c5406 	br	811303c0 <__reset+0xfb1103c0>
81131270:	d9c01d85 	stb	r7,118(sp)
81131274:	003d1d06 	br	811306ec <__reset+0xfb1106ec>

81131278 <__submore>:
81131278:	defffa04 	addi	sp,sp,-24
8113127c:	de00012e 	bgeu	sp,et,81131284 <__submore+0xc>
81131280:	003b68fa 	trap	3
81131284:	dc000015 	stw	r16,0(sp)
81131288:	2821883a 	mov	r16,r5
8113128c:	29400c17 	ldw	r5,48(r5)
81131290:	dfc00515 	stw	ra,20(sp)
81131294:	dd000415 	stw	r20,16(sp)
81131298:	dcc00315 	stw	r19,12(sp)
8113129c:	dc800215 	stw	r18,8(sp)
811312a0:	dc400115 	stw	r17,4(sp)
811312a4:	80801004 	addi	r2,r16,64
811312a8:	28801726 	beq	r5,r2,81131308 <__submore+0x90>
811312ac:	84400d17 	ldw	r17,52(r16)
811312b0:	8c67883a 	add	r19,r17,r17
811312b4:	980d883a 	mov	r6,r19
811312b8:	112d9ec0 	call	8112d9ec <_realloc_r>
811312bc:	1025883a 	mov	r18,r2
811312c0:	10002226 	beq	r2,zero,8113134c <__submore+0xd4>
811312c4:	1469883a 	add	r20,r2,r17
811312c8:	880d883a 	mov	r6,r17
811312cc:	100b883a 	mov	r5,r2
811312d0:	a009883a 	mov	r4,r20
811312d4:	11223f40 	call	811223f4 <memcpy>
811312d8:	0005883a 	mov	r2,zero
811312dc:	85000015 	stw	r20,0(r16)
811312e0:	84800c15 	stw	r18,48(r16)
811312e4:	84c00d15 	stw	r19,52(r16)
811312e8:	dfc00517 	ldw	ra,20(sp)
811312ec:	dd000417 	ldw	r20,16(sp)
811312f0:	dcc00317 	ldw	r19,12(sp)
811312f4:	dc800217 	ldw	r18,8(sp)
811312f8:	dc400117 	ldw	r17,4(sp)
811312fc:	dc000017 	ldw	r16,0(sp)
81131300:	dec00604 	addi	sp,sp,24
81131304:	f800283a 	ret
81131308:	04410004 	movi	r17,1024
8113130c:	880b883a 	mov	r5,r17
81131310:	1121be00 	call	81121be0 <_malloc_r>
81131314:	1007883a 	mov	r3,r2
81131318:	10000c26 	beq	r2,zero,8113134c <__submore+0xd4>
8113131c:	80801083 	ldbu	r2,66(r16)
81131320:	80c00c15 	stw	r3,48(r16)
81131324:	84400d15 	stw	r17,52(r16)
81131328:	1880ffc5 	stb	r2,1023(r3)
8113132c:	81401043 	ldbu	r5,65(r16)
81131330:	1900ff44 	addi	r4,r3,1021
81131334:	0005883a 	mov	r2,zero
81131338:	1940ff85 	stb	r5,1022(r3)
8113133c:	81401003 	ldbu	r5,64(r16)
81131340:	1940ff45 	stb	r5,1021(r3)
81131344:	81000015 	stw	r4,0(r16)
81131348:	003fe706 	br	811312e8 <__reset+0xfb1112e8>
8113134c:	00bfffc4 	movi	r2,-1
81131350:	003fe506 	br	811312e8 <__reset+0xfb1112e8>

81131354 <_ungetc_r>:
81131354:	00bfffc4 	movi	r2,-1
81131358:	28806326 	beq	r5,r2,811314e8 <_ungetc_r+0x194>
8113135c:	defffb04 	addi	sp,sp,-20
81131360:	de00012e 	bgeu	sp,et,81131368 <_ungetc_r+0x14>
81131364:	003b68fa 	trap	3
81131368:	dcc00315 	stw	r19,12(sp)
8113136c:	dc400115 	stw	r17,4(sp)
81131370:	dc000015 	stw	r16,0(sp)
81131374:	dfc00415 	stw	ra,16(sp)
81131378:	dc800215 	stw	r18,8(sp)
8113137c:	2023883a 	mov	r17,r4
81131380:	3021883a 	mov	r16,r6
81131384:	2827883a 	mov	r19,r5
81131388:	20000226 	beq	r4,zero,81131394 <_ungetc_r+0x40>
8113138c:	20800e17 	ldw	r2,56(r4)
81131390:	10002e26 	beq	r2,zero,8113144c <_ungetc_r+0xf8>
81131394:	80c0030b 	ldhu	r3,12(r16)
81131398:	1888000c 	andi	r2,r3,8192
8113139c:	1000051e 	bne	r2,zero,811313b4 <_ungetc_r+0x60>
811313a0:	81001917 	ldw	r4,100(r16)
811313a4:	00b7ffc4 	movi	r2,-8193
811313a8:	18c80014 	ori	r3,r3,8192
811313ac:	2084703a 	and	r2,r4,r2
811313b0:	80801915 	stw	r2,100(r16)
811313b4:	00bff7c4 	movi	r2,-33
811313b8:	1884703a 	and	r2,r3,r2
811313bc:	8080030d 	sth	r2,12(r16)
811313c0:	1900010c 	andi	r4,r3,4
811313c4:	2000061e 	bne	r4,zero,811313e0 <_ungetc_r+0x8c>
811313c8:	1900040c 	andi	r4,r3,16
811313cc:	20001d26 	beq	r4,zero,81131444 <_ungetc_r+0xf0>
811313d0:	18c0020c 	andi	r3,r3,8
811313d4:	1800331e 	bne	r3,zero,811314a4 <_ungetc_r+0x150>
811313d8:	10800114 	ori	r2,r2,4
811313dc:	8080030d 	sth	r2,12(r16)
811313e0:	80800c17 	ldw	r2,48(r16)
811313e4:	9c803fcc 	andi	r18,r19,255
811313e8:	10001a26 	beq	r2,zero,81131454 <_ungetc_r+0x100>
811313ec:	80c00117 	ldw	r3,4(r16)
811313f0:	80800d17 	ldw	r2,52(r16)
811313f4:	18800f0e 	bge	r3,r2,81131434 <_ungetc_r+0xe0>
811313f8:	80c00017 	ldw	r3,0(r16)
811313fc:	9005883a 	mov	r2,r18
81131400:	193fffc4 	addi	r4,r3,-1
81131404:	81000015 	stw	r4,0(r16)
81131408:	1cffffc5 	stb	r19,-1(r3)
8113140c:	80c00117 	ldw	r3,4(r16)
81131410:	18c00044 	addi	r3,r3,1
81131414:	80c00115 	stw	r3,4(r16)
81131418:	dfc00417 	ldw	ra,16(sp)
8113141c:	dcc00317 	ldw	r19,12(sp)
81131420:	dc800217 	ldw	r18,8(sp)
81131424:	dc400117 	ldw	r17,4(sp)
81131428:	dc000017 	ldw	r16,0(sp)
8113142c:	dec00504 	addi	sp,sp,20
81131430:	f800283a 	ret
81131434:	800b883a 	mov	r5,r16
81131438:	8809883a 	mov	r4,r17
8113143c:	11312780 	call	81131278 <__submore>
81131440:	103fed26 	beq	r2,zero,811313f8 <__reset+0xfb1113f8>
81131444:	00bfffc4 	movi	r2,-1
81131448:	003ff306 	br	81131418 <__reset+0xfb111418>
8113144c:	112b4c00 	call	8112b4c0 <__sinit>
81131450:	003fd006 	br	81131394 <__reset+0xfb111394>
81131454:	80c00417 	ldw	r3,16(r16)
81131458:	80800017 	ldw	r2,0(r16)
8113145c:	18000326 	beq	r3,zero,8113146c <_ungetc_r+0x118>
81131460:	1880022e 	bgeu	r3,r2,8113146c <_ungetc_r+0x118>
81131464:	10ffffc3 	ldbu	r3,-1(r2)
81131468:	90c01826 	beq	r18,r3,811314cc <_ungetc_r+0x178>
8113146c:	81400117 	ldw	r5,4(r16)
81131470:	80800e15 	stw	r2,56(r16)
81131474:	008000c4 	movi	r2,3
81131478:	81001004 	addi	r4,r16,64
8113147c:	80c01084 	addi	r3,r16,66
81131480:	80800d15 	stw	r2,52(r16)
81131484:	00800044 	movi	r2,1
81131488:	80800115 	stw	r2,4(r16)
8113148c:	81400f15 	stw	r5,60(r16)
81131490:	81000c15 	stw	r4,48(r16)
81131494:	84c01085 	stb	r19,66(r16)
81131498:	80c00015 	stw	r3,0(r16)
8113149c:	9005883a 	mov	r2,r18
811314a0:	003fdd06 	br	81131418 <__reset+0xfb111418>
811314a4:	800b883a 	mov	r5,r16
811314a8:	8809883a 	mov	r4,r17
811314ac:	112b0c40 	call	8112b0c4 <_fflush_r>
811314b0:	103fe41e 	bne	r2,zero,81131444 <__reset+0xfb111444>
811314b4:	8080030b 	ldhu	r2,12(r16)
811314b8:	00fffdc4 	movi	r3,-9
811314bc:	80000215 	stw	zero,8(r16)
811314c0:	1884703a 	and	r2,r3,r2
811314c4:	80000615 	stw	zero,24(r16)
811314c8:	003fc306 	br	811313d8 <__reset+0xfb1113d8>
811314cc:	80c00117 	ldw	r3,4(r16)
811314d0:	10bfffc4 	addi	r2,r2,-1
811314d4:	80800015 	stw	r2,0(r16)
811314d8:	18800044 	addi	r2,r3,1
811314dc:	80800115 	stw	r2,4(r16)
811314e0:	9005883a 	mov	r2,r18
811314e4:	003fcc06 	br	81131418 <__reset+0xfb111418>
811314e8:	00bfffc4 	movi	r2,-1
811314ec:	f800283a 	ret

811314f0 <ungetc>:
811314f0:	00a04574 	movhi	r2,33045
811314f4:	108bed04 	addi	r2,r2,12212
811314f8:	280d883a 	mov	r6,r5
811314fc:	200b883a 	mov	r5,r4
81131500:	11000017 	ldw	r4,0(r2)
81131504:	11313541 	jmpi	81131354 <_ungetc_r>

81131508 <__sprint_r.part.0>:
81131508:	defff604 	addi	sp,sp,-40
8113150c:	de00012e 	bgeu	sp,et,81131514 <__sprint_r.part.0+0xc>
81131510:	003b68fa 	trap	3
81131514:	28801917 	ldw	r2,100(r5)
81131518:	dd400515 	stw	r21,20(sp)
8113151c:	dfc00915 	stw	ra,36(sp)
81131520:	df000815 	stw	fp,32(sp)
81131524:	ddc00715 	stw	r23,28(sp)
81131528:	dd800615 	stw	r22,24(sp)
8113152c:	dd000415 	stw	r20,16(sp)
81131530:	dcc00315 	stw	r19,12(sp)
81131534:	dc800215 	stw	r18,8(sp)
81131538:	dc400115 	stw	r17,4(sp)
8113153c:	dc000015 	stw	r16,0(sp)
81131540:	1088000c 	andi	r2,r2,8192
81131544:	302b883a 	mov	r21,r6
81131548:	10002e26 	beq	r2,zero,81131604 <__sprint_r.part.0+0xfc>
8113154c:	30800217 	ldw	r2,8(r6)
81131550:	35800017 	ldw	r22,0(r6)
81131554:	10002926 	beq	r2,zero,811315fc <__sprint_r.part.0+0xf4>
81131558:	2827883a 	mov	r19,r5
8113155c:	2029883a 	mov	r20,r4
81131560:	b5c00104 	addi	r23,r22,4
81131564:	04bfffc4 	movi	r18,-1
81131568:	bc400017 	ldw	r17,0(r23)
8113156c:	b4000017 	ldw	r16,0(r22)
81131570:	0039883a 	mov	fp,zero
81131574:	8822d0ba 	srli	r17,r17,2
81131578:	8800031e 	bne	r17,zero,81131588 <__sprint_r.part.0+0x80>
8113157c:	00001806 	br	811315e0 <__sprint_r.part.0+0xd8>
81131580:	84000104 	addi	r16,r16,4
81131584:	8f001526 	beq	r17,fp,811315dc <__sprint_r.part.0+0xd4>
81131588:	81400017 	ldw	r5,0(r16)
8113158c:	980d883a 	mov	r6,r19
81131590:	a009883a 	mov	r4,r20
81131594:	1132eac0 	call	81132eac <_fputwc_r>
81131598:	e7000044 	addi	fp,fp,1
8113159c:	14bff81e 	bne	r2,r18,81131580 <__reset+0xfb111580>
811315a0:	9005883a 	mov	r2,r18
811315a4:	a8000215 	stw	zero,8(r21)
811315a8:	a8000115 	stw	zero,4(r21)
811315ac:	dfc00917 	ldw	ra,36(sp)
811315b0:	df000817 	ldw	fp,32(sp)
811315b4:	ddc00717 	ldw	r23,28(sp)
811315b8:	dd800617 	ldw	r22,24(sp)
811315bc:	dd400517 	ldw	r21,20(sp)
811315c0:	dd000417 	ldw	r20,16(sp)
811315c4:	dcc00317 	ldw	r19,12(sp)
811315c8:	dc800217 	ldw	r18,8(sp)
811315cc:	dc400117 	ldw	r17,4(sp)
811315d0:	dc000017 	ldw	r16,0(sp)
811315d4:	dec00a04 	addi	sp,sp,40
811315d8:	f800283a 	ret
811315dc:	a8800217 	ldw	r2,8(r21)
811315e0:	8c63883a 	add	r17,r17,r17
811315e4:	8c63883a 	add	r17,r17,r17
811315e8:	1445c83a 	sub	r2,r2,r17
811315ec:	a8800215 	stw	r2,8(r21)
811315f0:	b5800204 	addi	r22,r22,8
811315f4:	bdc00204 	addi	r23,r23,8
811315f8:	103fdb1e 	bne	r2,zero,81131568 <__reset+0xfb111568>
811315fc:	0005883a 	mov	r2,zero
81131600:	003fe806 	br	811315a4 <__reset+0xfb1115a4>
81131604:	112bc700 	call	8112bc70 <__sfvwrite_r>
81131608:	003fe606 	br	811315a4 <__reset+0xfb1115a4>

8113160c <__sprint_r>:
8113160c:	30c00217 	ldw	r3,8(r6)
81131610:	18000126 	beq	r3,zero,81131618 <__sprint_r+0xc>
81131614:	11315081 	jmpi	81131508 <__sprint_r.part.0>
81131618:	30000115 	stw	zero,4(r6)
8113161c:	0005883a 	mov	r2,zero
81131620:	f800283a 	ret

81131624 <___vfiprintf_internal_r>:
81131624:	deffc904 	addi	sp,sp,-220
81131628:	de00012e 	bgeu	sp,et,81131630 <___vfiprintf_internal_r+0xc>
8113162c:	003b68fa 	trap	3
81131630:	df003515 	stw	fp,212(sp)
81131634:	dd003115 	stw	r20,196(sp)
81131638:	dfc03615 	stw	ra,216(sp)
8113163c:	ddc03415 	stw	r23,208(sp)
81131640:	dd803315 	stw	r22,204(sp)
81131644:	dd403215 	stw	r21,200(sp)
81131648:	dcc03015 	stw	r19,192(sp)
8113164c:	dc802f15 	stw	r18,188(sp)
81131650:	dc402e15 	stw	r17,184(sp)
81131654:	dc002d15 	stw	r16,180(sp)
81131658:	d9002015 	stw	r4,128(sp)
8113165c:	d9c02215 	stw	r7,136(sp)
81131660:	2829883a 	mov	r20,r5
81131664:	3039883a 	mov	fp,r6
81131668:	20000226 	beq	r4,zero,81131674 <___vfiprintf_internal_r+0x50>
8113166c:	20800e17 	ldw	r2,56(r4)
81131670:	1000cf26 	beq	r2,zero,811319b0 <___vfiprintf_internal_r+0x38c>
81131674:	a080030b 	ldhu	r2,12(r20)
81131678:	10c8000c 	andi	r3,r2,8192
8113167c:	1800061e 	bne	r3,zero,81131698 <___vfiprintf_internal_r+0x74>
81131680:	a1001917 	ldw	r4,100(r20)
81131684:	00f7ffc4 	movi	r3,-8193
81131688:	10880014 	ori	r2,r2,8192
8113168c:	20c6703a 	and	r3,r4,r3
81131690:	a080030d 	sth	r2,12(r20)
81131694:	a0c01915 	stw	r3,100(r20)
81131698:	10c0020c 	andi	r3,r2,8
8113169c:	1800a926 	beq	r3,zero,81131944 <___vfiprintf_internal_r+0x320>
811316a0:	a0c00417 	ldw	r3,16(r20)
811316a4:	1800a726 	beq	r3,zero,81131944 <___vfiprintf_internal_r+0x320>
811316a8:	1080068c 	andi	r2,r2,26
811316ac:	00c00284 	movi	r3,10
811316b0:	10c0ac26 	beq	r2,r3,81131964 <___vfiprintf_internal_r+0x340>
811316b4:	da801a04 	addi	r10,sp,104
811316b8:	da801e15 	stw	r10,120(sp)
811316bc:	d8801e17 	ldw	r2,120(sp)
811316c0:	da8019c4 	addi	r10,sp,103
811316c4:	05a04574 	movhi	r22,33045
811316c8:	05e04574 	movhi	r23,33045
811316cc:	da801f15 	stw	r10,124(sp)
811316d0:	1295c83a 	sub	r10,r2,r10
811316d4:	b582b404 	addi	r22,r22,2768
811316d8:	bdc2b004 	addi	r23,r23,2752
811316dc:	dec01a15 	stw	sp,104(sp)
811316e0:	d8001c15 	stw	zero,112(sp)
811316e4:	d8001b15 	stw	zero,108(sp)
811316e8:	d8002615 	stw	zero,152(sp)
811316ec:	d8002315 	stw	zero,140(sp)
811316f0:	da802715 	stw	r10,156(sp)
811316f4:	d811883a 	mov	r8,sp
811316f8:	dd002115 	stw	r20,132(sp)
811316fc:	e021883a 	mov	r16,fp
81131700:	80800007 	ldb	r2,0(r16)
81131704:	1003ea26 	beq	r2,zero,811326b0 <___vfiprintf_internal_r+0x108c>
81131708:	00c00944 	movi	r3,37
8113170c:	8025883a 	mov	r18,r16
81131710:	10c0021e 	bne	r2,r3,8113171c <___vfiprintf_internal_r+0xf8>
81131714:	00001606 	br	81131770 <___vfiprintf_internal_r+0x14c>
81131718:	10c00326 	beq	r2,r3,81131728 <___vfiprintf_internal_r+0x104>
8113171c:	94800044 	addi	r18,r18,1
81131720:	90800007 	ldb	r2,0(r18)
81131724:	103ffc1e 	bne	r2,zero,81131718 <__reset+0xfb111718>
81131728:	9423c83a 	sub	r17,r18,r16
8113172c:	88001026 	beq	r17,zero,81131770 <___vfiprintf_internal_r+0x14c>
81131730:	d8c01c17 	ldw	r3,112(sp)
81131734:	d8801b17 	ldw	r2,108(sp)
81131738:	44000015 	stw	r16,0(r8)
8113173c:	88c7883a 	add	r3,r17,r3
81131740:	10800044 	addi	r2,r2,1
81131744:	44400115 	stw	r17,4(r8)
81131748:	d8c01c15 	stw	r3,112(sp)
8113174c:	d8801b15 	stw	r2,108(sp)
81131750:	010001c4 	movi	r4,7
81131754:	2080760e 	bge	r4,r2,81131930 <___vfiprintf_internal_r+0x30c>
81131758:	1803821e 	bne	r3,zero,81132564 <___vfiprintf_internal_r+0xf40>
8113175c:	da802317 	ldw	r10,140(sp)
81131760:	d8001b15 	stw	zero,108(sp)
81131764:	d811883a 	mov	r8,sp
81131768:	5455883a 	add	r10,r10,r17
8113176c:	da802315 	stw	r10,140(sp)
81131770:	90800007 	ldb	r2,0(r18)
81131774:	10044626 	beq	r2,zero,81132890 <___vfiprintf_internal_r+0x126c>
81131778:	90c00047 	ldb	r3,1(r18)
8113177c:	94000044 	addi	r16,r18,1
81131780:	d8001d85 	stb	zero,118(sp)
81131784:	0009883a 	mov	r4,zero
81131788:	000f883a 	mov	r7,zero
8113178c:	027fffc4 	movi	r9,-1
81131790:	0023883a 	mov	r17,zero
81131794:	0029883a 	mov	r20,zero
81131798:	01401604 	movi	r5,88
8113179c:	01800244 	movi	r6,9
811317a0:	03400a84 	movi	r13,42
811317a4:	03001b04 	movi	r12,108
811317a8:	84000044 	addi	r16,r16,1
811317ac:	18bff804 	addi	r2,r3,-32
811317b0:	28827336 	bltu	r5,r2,81132180 <___vfiprintf_internal_r+0xb5c>
811317b4:	100490ba 	slli	r2,r2,2
811317b8:	02a044f4 	movhi	r10,33043
811317bc:	5285f304 	addi	r10,r10,6092
811317c0:	1285883a 	add	r2,r2,r10
811317c4:	10800017 	ldw	r2,0(r2)
811317c8:	1000683a 	jmp	r2
811317cc:	81131eb4 	orhi	r4,r16,19578
811317d0:	81132180 	call	88113218 <__reset+0x20f3218>
811317d4:	81132180 	call	88113218 <__reset+0x20f3218>
811317d8:	81131ed4 	ori	r4,r16,19579
811317dc:	81132180 	call	88113218 <__reset+0x20f3218>
811317e0:	81132180 	call	88113218 <__reset+0x20f3218>
811317e4:	81132180 	call	88113218 <__reset+0x20f3218>
811317e8:	81132180 	call	88113218 <__reset+0x20f3218>
811317ec:	81132180 	call	88113218 <__reset+0x20f3218>
811317f0:	81132180 	call	88113218 <__reset+0x20f3218>
811317f4:	811320bc 	xorhi	r4,r16,19586
811317f8:	811320d8 	cmpnei	r4,r16,19587
811317fc:	81132180 	call	88113218 <__reset+0x20f3218>
81131800:	811319c0 	call	8811319c <__reset+0x20f319c>
81131804:	811320e8 	cmpgeui	r4,r16,19587
81131808:	81132180 	call	88113218 <__reset+0x20f3218>
8113180c:	81131ee0 	cmpeqi	r4,r16,19579
81131810:	81131eec 	andhi	r4,r16,19579
81131814:	81131eec 	andhi	r4,r16,19579
81131818:	81131eec 	andhi	r4,r16,19579
8113181c:	81131eec 	andhi	r4,r16,19579
81131820:	81131eec 	andhi	r4,r16,19579
81131824:	81131eec 	andhi	r4,r16,19579
81131828:	81131eec 	andhi	r4,r16,19579
8113182c:	81131eec 	andhi	r4,r16,19579
81131830:	81131eec 	andhi	r4,r16,19579
81131834:	81132180 	call	88113218 <__reset+0x20f3218>
81131838:	81132180 	call	88113218 <__reset+0x20f3218>
8113183c:	81132180 	call	88113218 <__reset+0x20f3218>
81131840:	81132180 	call	88113218 <__reset+0x20f3218>
81131844:	81132180 	call	88113218 <__reset+0x20f3218>
81131848:	81132180 	call	88113218 <__reset+0x20f3218>
8113184c:	81132180 	call	88113218 <__reset+0x20f3218>
81131850:	81132180 	call	88113218 <__reset+0x20f3218>
81131854:	81132180 	call	88113218 <__reset+0x20f3218>
81131858:	81132180 	call	88113218 <__reset+0x20f3218>
8113185c:	81131f18 	cmpnei	r4,r16,19580
81131860:	81132180 	call	88113218 <__reset+0x20f3218>
81131864:	81132180 	call	88113218 <__reset+0x20f3218>
81131868:	81132180 	call	88113218 <__reset+0x20f3218>
8113186c:	81132180 	call	88113218 <__reset+0x20f3218>
81131870:	81132180 	call	88113218 <__reset+0x20f3218>
81131874:	81132180 	call	88113218 <__reset+0x20f3218>
81131878:	81132180 	call	88113218 <__reset+0x20f3218>
8113187c:	81132180 	call	88113218 <__reset+0x20f3218>
81131880:	81132180 	call	88113218 <__reset+0x20f3218>
81131884:	81132180 	call	88113218 <__reset+0x20f3218>
81131888:	81131f50 	cmplti	r4,r16,19581
8113188c:	81132180 	call	88113218 <__reset+0x20f3218>
81131890:	81132180 	call	88113218 <__reset+0x20f3218>
81131894:	81132180 	call	88113218 <__reset+0x20f3218>
81131898:	81132180 	call	88113218 <__reset+0x20f3218>
8113189c:	81132180 	call	88113218 <__reset+0x20f3218>
811318a0:	81131fa8 	cmpgeui	r4,r16,19582
811318a4:	81132180 	call	88113218 <__reset+0x20f3218>
811318a8:	81132180 	call	88113218 <__reset+0x20f3218>
811318ac:	81132018 	cmpnei	r4,r16,19584
811318b0:	81132180 	call	88113218 <__reset+0x20f3218>
811318b4:	81132180 	call	88113218 <__reset+0x20f3218>
811318b8:	81132180 	call	88113218 <__reset+0x20f3218>
811318bc:	81132180 	call	88113218 <__reset+0x20f3218>
811318c0:	81132180 	call	88113218 <__reset+0x20f3218>
811318c4:	81132180 	call	88113218 <__reset+0x20f3218>
811318c8:	81132180 	call	88113218 <__reset+0x20f3218>
811318cc:	81132180 	call	88113218 <__reset+0x20f3218>
811318d0:	81132180 	call	88113218 <__reset+0x20f3218>
811318d4:	81132180 	call	88113218 <__reset+0x20f3218>
811318d8:	81131dc4 	addi	r4,r16,19575
811318dc:	81131df0 	cmpltui	r4,r16,19575
811318e0:	81132180 	call	88113218 <__reset+0x20f3218>
811318e4:	81132180 	call	88113218 <__reset+0x20f3218>
811318e8:	81132180 	call	88113218 <__reset+0x20f3218>
811318ec:	81132128 	cmpgeui	r4,r16,19588
811318f0:	81131df0 	cmpltui	r4,r16,19575
811318f4:	81132180 	call	88113218 <__reset+0x20f3218>
811318f8:	81132180 	call	88113218 <__reset+0x20f3218>
811318fc:	81131c84 	addi	r4,r16,19570
81131900:	81132180 	call	88113218 <__reset+0x20f3218>
81131904:	81131c94 	ori	r4,r16,19570
81131908:	81131cd0 	cmplti	r4,r16,19571
8113190c:	811319cc 	andi	r4,r16,19559
81131910:	81131c78 	rdprs	r4,r16,19569
81131914:	81132180 	call	88113218 <__reset+0x20f3218>
81131918:	81132054 	ori	r4,r16,19585
8113191c:	81132180 	call	88113218 <__reset+0x20f3218>
81131920:	811320ac 	andhi	r4,r16,19586
81131924:	81132180 	call	88113218 <__reset+0x20f3218>
81131928:	81132180 	call	88113218 <__reset+0x20f3218>
8113192c:	81131d70 	cmpltui	r4,r16,19573
81131930:	42000204 	addi	r8,r8,8
81131934:	da802317 	ldw	r10,140(sp)
81131938:	5455883a 	add	r10,r10,r17
8113193c:	da802315 	stw	r10,140(sp)
81131940:	003f8b06 	br	81131770 <__reset+0xfb111770>
81131944:	d9002017 	ldw	r4,128(sp)
81131948:	a00b883a 	mov	r5,r20
8113194c:	11294500 	call	81129450 <__swsetup_r>
81131950:	1003b11e 	bne	r2,zero,81132818 <___vfiprintf_internal_r+0x11f4>
81131954:	a080030b 	ldhu	r2,12(r20)
81131958:	00c00284 	movi	r3,10
8113195c:	1080068c 	andi	r2,r2,26
81131960:	10ff541e 	bne	r2,r3,811316b4 <__reset+0xfb1116b4>
81131964:	a080038f 	ldh	r2,14(r20)
81131968:	103f5216 	blt	r2,zero,811316b4 <__reset+0xfb1116b4>
8113196c:	d9c02217 	ldw	r7,136(sp)
81131970:	d9002017 	ldw	r4,128(sp)
81131974:	e00d883a 	mov	r6,fp
81131978:	a00b883a 	mov	r5,r20
8113197c:	1132aa40 	call	81132aa4 <__sbprintf>
81131980:	dfc03617 	ldw	ra,216(sp)
81131984:	df003517 	ldw	fp,212(sp)
81131988:	ddc03417 	ldw	r23,208(sp)
8113198c:	dd803317 	ldw	r22,204(sp)
81131990:	dd403217 	ldw	r21,200(sp)
81131994:	dd003117 	ldw	r20,196(sp)
81131998:	dcc03017 	ldw	r19,192(sp)
8113199c:	dc802f17 	ldw	r18,188(sp)
811319a0:	dc402e17 	ldw	r17,184(sp)
811319a4:	dc002d17 	ldw	r16,180(sp)
811319a8:	dec03704 	addi	sp,sp,220
811319ac:	f800283a 	ret
811319b0:	112b4c00 	call	8112b4c0 <__sinit>
811319b4:	003f2f06 	br	81131674 <__reset+0xfb111674>
811319b8:	0463c83a 	sub	r17,zero,r17
811319bc:	d8802215 	stw	r2,136(sp)
811319c0:	a5000114 	ori	r20,r20,4
811319c4:	80c00007 	ldb	r3,0(r16)
811319c8:	003f7706 	br	811317a8 <__reset+0xfb1117a8>
811319cc:	00800c04 	movi	r2,48
811319d0:	da802217 	ldw	r10,136(sp)
811319d4:	d8801d05 	stb	r2,116(sp)
811319d8:	00801e04 	movi	r2,120
811319dc:	d8801d45 	stb	r2,117(sp)
811319e0:	d8001d85 	stb	zero,118(sp)
811319e4:	50c00104 	addi	r3,r10,4
811319e8:	54800017 	ldw	r18,0(r10)
811319ec:	0027883a 	mov	r19,zero
811319f0:	a0800094 	ori	r2,r20,2
811319f4:	48030b16 	blt	r9,zero,81132624 <___vfiprintf_internal_r+0x1000>
811319f8:	00bfdfc4 	movi	r2,-129
811319fc:	a096703a 	and	r11,r20,r2
81131a00:	d8c02215 	stw	r3,136(sp)
81131a04:	5d000094 	ori	r20,r11,2
81131a08:	90032b1e 	bne	r18,zero,811326b8 <___vfiprintf_internal_r+0x1094>
81131a0c:	00a04574 	movhi	r2,33045
81131a10:	10821e04 	addi	r2,r2,2168
81131a14:	d8802615 	stw	r2,152(sp)
81131a18:	0039883a 	mov	fp,zero
81131a1c:	48017b1e 	bne	r9,zero,8113200c <___vfiprintf_internal_r+0x9e8>
81131a20:	0013883a 	mov	r9,zero
81131a24:	0027883a 	mov	r19,zero
81131a28:	dd401a04 	addi	r21,sp,104
81131a2c:	4825883a 	mov	r18,r9
81131a30:	4cc0010e 	bge	r9,r19,81131a38 <___vfiprintf_internal_r+0x414>
81131a34:	9825883a 	mov	r18,r19
81131a38:	e7003fcc 	andi	fp,fp,255
81131a3c:	e700201c 	xori	fp,fp,128
81131a40:	e73fe004 	addi	fp,fp,-128
81131a44:	e0000126 	beq	fp,zero,81131a4c <___vfiprintf_internal_r+0x428>
81131a48:	94800044 	addi	r18,r18,1
81131a4c:	a380008c 	andi	r14,r20,2
81131a50:	70000126 	beq	r14,zero,81131a58 <___vfiprintf_internal_r+0x434>
81131a54:	94800084 	addi	r18,r18,2
81131a58:	a700210c 	andi	fp,r20,132
81131a5c:	e001df1e 	bne	fp,zero,811321dc <___vfiprintf_internal_r+0xbb8>
81131a60:	8c87c83a 	sub	r3,r17,r18
81131a64:	00c1dd0e 	bge	zero,r3,811321dc <___vfiprintf_internal_r+0xbb8>
81131a68:	01c00404 	movi	r7,16
81131a6c:	d8801c17 	ldw	r2,112(sp)
81131a70:	38c3ad0e 	bge	r7,r3,81132928 <___vfiprintf_internal_r+0x1304>
81131a74:	02a04574 	movhi	r10,33045
81131a78:	5282b404 	addi	r10,r10,2768
81131a7c:	dc002915 	stw	r16,164(sp)
81131a80:	d9801b17 	ldw	r6,108(sp)
81131a84:	da802415 	stw	r10,144(sp)
81131a88:	03c001c4 	movi	r15,7
81131a8c:	da402515 	stw	r9,148(sp)
81131a90:	db802815 	stw	r14,160(sp)
81131a94:	1821883a 	mov	r16,r3
81131a98:	00000506 	br	81131ab0 <___vfiprintf_internal_r+0x48c>
81131a9c:	31400084 	addi	r5,r6,2
81131aa0:	42000204 	addi	r8,r8,8
81131aa4:	200d883a 	mov	r6,r4
81131aa8:	843ffc04 	addi	r16,r16,-16
81131aac:	3c000d0e 	bge	r7,r16,81131ae4 <___vfiprintf_internal_r+0x4c0>
81131ab0:	10800404 	addi	r2,r2,16
81131ab4:	31000044 	addi	r4,r6,1
81131ab8:	45800015 	stw	r22,0(r8)
81131abc:	41c00115 	stw	r7,4(r8)
81131ac0:	d8801c15 	stw	r2,112(sp)
81131ac4:	d9001b15 	stw	r4,108(sp)
81131ac8:	793ff40e 	bge	r15,r4,81131a9c <__reset+0xfb111a9c>
81131acc:	1001b51e 	bne	r2,zero,811321a4 <___vfiprintf_internal_r+0xb80>
81131ad0:	843ffc04 	addi	r16,r16,-16
81131ad4:	000d883a 	mov	r6,zero
81131ad8:	01400044 	movi	r5,1
81131adc:	d811883a 	mov	r8,sp
81131ae0:	3c3ff316 	blt	r7,r16,81131ab0 <__reset+0xfb111ab0>
81131ae4:	8007883a 	mov	r3,r16
81131ae8:	da402517 	ldw	r9,148(sp)
81131aec:	db802817 	ldw	r14,160(sp)
81131af0:	dc002917 	ldw	r16,164(sp)
81131af4:	da802417 	ldw	r10,144(sp)
81131af8:	1885883a 	add	r2,r3,r2
81131afc:	40c00115 	stw	r3,4(r8)
81131b00:	42800015 	stw	r10,0(r8)
81131b04:	d8801c15 	stw	r2,112(sp)
81131b08:	d9401b15 	stw	r5,108(sp)
81131b0c:	00c001c4 	movi	r3,7
81131b10:	19426016 	blt	r3,r5,81132494 <___vfiprintf_internal_r+0xe70>
81131b14:	d8c01d87 	ldb	r3,118(sp)
81131b18:	42000204 	addi	r8,r8,8
81131b1c:	29000044 	addi	r4,r5,1
81131b20:	1801b31e 	bne	r3,zero,811321f0 <___vfiprintf_internal_r+0xbcc>
81131b24:	7001c026 	beq	r14,zero,81132228 <___vfiprintf_internal_r+0xc04>
81131b28:	d8c01d04 	addi	r3,sp,116
81131b2c:	10800084 	addi	r2,r2,2
81131b30:	40c00015 	stw	r3,0(r8)
81131b34:	00c00084 	movi	r3,2
81131b38:	40c00115 	stw	r3,4(r8)
81131b3c:	d8801c15 	stw	r2,112(sp)
81131b40:	d9001b15 	stw	r4,108(sp)
81131b44:	00c001c4 	movi	r3,7
81131b48:	1902650e 	bge	r3,r4,811324e0 <___vfiprintf_internal_r+0xebc>
81131b4c:	10029a1e 	bne	r2,zero,811325b8 <___vfiprintf_internal_r+0xf94>
81131b50:	00c02004 	movi	r3,128
81131b54:	01000044 	movi	r4,1
81131b58:	000b883a 	mov	r5,zero
81131b5c:	d811883a 	mov	r8,sp
81131b60:	e0c1b31e 	bne	fp,r3,81132230 <___vfiprintf_internal_r+0xc0c>
81131b64:	8cb9c83a 	sub	fp,r17,r18
81131b68:	0701b10e 	bge	zero,fp,81132230 <___vfiprintf_internal_r+0xc0c>
81131b6c:	01c00404 	movi	r7,16
81131b70:	3f03890e 	bge	r7,fp,81132998 <___vfiprintf_internal_r+0x1374>
81131b74:	00e04574 	movhi	r3,33045
81131b78:	18c2b004 	addi	r3,r3,2752
81131b7c:	d8c02415 	stw	r3,144(sp)
81131b80:	8007883a 	mov	r3,r16
81131b84:	034001c4 	movi	r13,7
81131b88:	e021883a 	mov	r16,fp
81131b8c:	da402515 	stw	r9,148(sp)
81131b90:	1839883a 	mov	fp,r3
81131b94:	00000506 	br	81131bac <___vfiprintf_internal_r+0x588>
81131b98:	29800084 	addi	r6,r5,2
81131b9c:	42000204 	addi	r8,r8,8
81131ba0:	180b883a 	mov	r5,r3
81131ba4:	843ffc04 	addi	r16,r16,-16
81131ba8:	3c000d0e 	bge	r7,r16,81131be0 <___vfiprintf_internal_r+0x5bc>
81131bac:	10800404 	addi	r2,r2,16
81131bb0:	28c00044 	addi	r3,r5,1
81131bb4:	45c00015 	stw	r23,0(r8)
81131bb8:	41c00115 	stw	r7,4(r8)
81131bbc:	d8801c15 	stw	r2,112(sp)
81131bc0:	d8c01b15 	stw	r3,108(sp)
81131bc4:	68fff40e 	bge	r13,r3,81131b98 <__reset+0xfb111b98>
81131bc8:	1002241e 	bne	r2,zero,8113245c <___vfiprintf_internal_r+0xe38>
81131bcc:	843ffc04 	addi	r16,r16,-16
81131bd0:	01800044 	movi	r6,1
81131bd4:	000b883a 	mov	r5,zero
81131bd8:	d811883a 	mov	r8,sp
81131bdc:	3c3ff316 	blt	r7,r16,81131bac <__reset+0xfb111bac>
81131be0:	da402517 	ldw	r9,148(sp)
81131be4:	e007883a 	mov	r3,fp
81131be8:	8039883a 	mov	fp,r16
81131bec:	1821883a 	mov	r16,r3
81131bf0:	d8c02417 	ldw	r3,144(sp)
81131bf4:	1705883a 	add	r2,r2,fp
81131bf8:	47000115 	stw	fp,4(r8)
81131bfc:	40c00015 	stw	r3,0(r8)
81131c00:	d8801c15 	stw	r2,112(sp)
81131c04:	d9801b15 	stw	r6,108(sp)
81131c08:	00c001c4 	movi	r3,7
81131c0c:	19827616 	blt	r3,r6,811325e8 <___vfiprintf_internal_r+0xfc4>
81131c10:	4cf9c83a 	sub	fp,r9,r19
81131c14:	42000204 	addi	r8,r8,8
81131c18:	31000044 	addi	r4,r6,1
81131c1c:	300b883a 	mov	r5,r6
81131c20:	07018516 	blt	zero,fp,81132238 <___vfiprintf_internal_r+0xc14>
81131c24:	9885883a 	add	r2,r19,r2
81131c28:	45400015 	stw	r21,0(r8)
81131c2c:	44c00115 	stw	r19,4(r8)
81131c30:	d8801c15 	stw	r2,112(sp)
81131c34:	d9001b15 	stw	r4,108(sp)
81131c38:	00c001c4 	movi	r3,7
81131c3c:	1901dd0e 	bge	r3,r4,811323b4 <___vfiprintf_internal_r+0xd90>
81131c40:	1002401e 	bne	r2,zero,81132544 <___vfiprintf_internal_r+0xf20>
81131c44:	d8001b15 	stw	zero,108(sp)
81131c48:	a2c0010c 	andi	r11,r20,4
81131c4c:	58000226 	beq	r11,zero,81131c58 <___vfiprintf_internal_r+0x634>
81131c50:	8ca7c83a 	sub	r19,r17,r18
81131c54:	04c2f216 	blt	zero,r19,81132820 <___vfiprintf_internal_r+0x11fc>
81131c58:	8c80010e 	bge	r17,r18,81131c60 <___vfiprintf_internal_r+0x63c>
81131c5c:	9023883a 	mov	r17,r18
81131c60:	da802317 	ldw	r10,140(sp)
81131c64:	5455883a 	add	r10,r10,r17
81131c68:	da802315 	stw	r10,140(sp)
81131c6c:	d8001b15 	stw	zero,108(sp)
81131c70:	d811883a 	mov	r8,sp
81131c74:	003ea206 	br	81131700 <__reset+0xfb111700>
81131c78:	a5000814 	ori	r20,r20,32
81131c7c:	80c00007 	ldb	r3,0(r16)
81131c80:	003ec906 	br	811317a8 <__reset+0xfb1117a8>
81131c84:	80c00007 	ldb	r3,0(r16)
81131c88:	1b030926 	beq	r3,r12,811328b0 <___vfiprintf_internal_r+0x128c>
81131c8c:	a5000414 	ori	r20,r20,16
81131c90:	003ec506 	br	811317a8 <__reset+0xfb1117a8>
81131c94:	21003fcc 	andi	r4,r4,255
81131c98:	20035e1e 	bne	r4,zero,81132a14 <___vfiprintf_internal_r+0x13f0>
81131c9c:	a080080c 	andi	r2,r20,32
81131ca0:	1002a526 	beq	r2,zero,81132738 <___vfiprintf_internal_r+0x1114>
81131ca4:	da802217 	ldw	r10,136(sp)
81131ca8:	50800017 	ldw	r2,0(r10)
81131cac:	da802317 	ldw	r10,140(sp)
81131cb0:	5007d7fa 	srai	r3,r10,31
81131cb4:	da802217 	ldw	r10,136(sp)
81131cb8:	10c00115 	stw	r3,4(r2)
81131cbc:	52800104 	addi	r10,r10,4
81131cc0:	da802215 	stw	r10,136(sp)
81131cc4:	da802317 	ldw	r10,140(sp)
81131cc8:	12800015 	stw	r10,0(r2)
81131ccc:	003e8c06 	br	81131700 <__reset+0xfb111700>
81131cd0:	21003fcc 	andi	r4,r4,255
81131cd4:	2003511e 	bne	r4,zero,81132a1c <___vfiprintf_internal_r+0x13f8>
81131cd8:	a080080c 	andi	r2,r20,32
81131cdc:	1000a126 	beq	r2,zero,81131f64 <___vfiprintf_internal_r+0x940>
81131ce0:	da802217 	ldw	r10,136(sp)
81131ce4:	d8001d85 	stb	zero,118(sp)
81131ce8:	50800204 	addi	r2,r10,8
81131cec:	54800017 	ldw	r18,0(r10)
81131cf0:	54c00117 	ldw	r19,4(r10)
81131cf4:	4802b416 	blt	r9,zero,811327c8 <___vfiprintf_internal_r+0x11a4>
81131cf8:	013fdfc4 	movi	r4,-129
81131cfc:	94c6b03a 	or	r3,r18,r19
81131d00:	d8802215 	stw	r2,136(sp)
81131d04:	a128703a 	and	r20,r20,r4
81131d08:	1800a226 	beq	r3,zero,81131f94 <___vfiprintf_internal_r+0x970>
81131d0c:	0039883a 	mov	fp,zero
81131d10:	dd401a04 	addi	r21,sp,104
81131d14:	9006d0fa 	srli	r3,r18,3
81131d18:	9808977a 	slli	r4,r19,29
81131d1c:	9826d0fa 	srli	r19,r19,3
81131d20:	948001cc 	andi	r18,r18,7
81131d24:	90800c04 	addi	r2,r18,48
81131d28:	ad7fffc4 	addi	r21,r21,-1
81131d2c:	20e4b03a 	or	r18,r4,r3
81131d30:	a8800005 	stb	r2,0(r21)
81131d34:	94c6b03a 	or	r3,r18,r19
81131d38:	183ff61e 	bne	r3,zero,81131d14 <__reset+0xfb111d14>
81131d3c:	a0c0004c 	andi	r3,r20,1
81131d40:	18005926 	beq	r3,zero,81131ea8 <___vfiprintf_internal_r+0x884>
81131d44:	10803fcc 	andi	r2,r2,255
81131d48:	1080201c 	xori	r2,r2,128
81131d4c:	10bfe004 	addi	r2,r2,-128
81131d50:	00c00c04 	movi	r3,48
81131d54:	10c05426 	beq	r2,r3,81131ea8 <___vfiprintf_internal_r+0x884>
81131d58:	da801e17 	ldw	r10,120(sp)
81131d5c:	a8bfffc4 	addi	r2,r21,-1
81131d60:	a8ffffc5 	stb	r3,-1(r21)
81131d64:	50a7c83a 	sub	r19,r10,r2
81131d68:	102b883a 	mov	r21,r2
81131d6c:	003f2f06 	br	81131a2c <__reset+0xfb111a2c>
81131d70:	21003fcc 	andi	r4,r4,255
81131d74:	2003421e 	bne	r4,zero,81132a80 <___vfiprintf_internal_r+0x145c>
81131d78:	00a04574 	movhi	r2,33045
81131d7c:	10821e04 	addi	r2,r2,2168
81131d80:	d8802615 	stw	r2,152(sp)
81131d84:	a080080c 	andi	r2,r20,32
81131d88:	1000aa26 	beq	r2,zero,81132034 <___vfiprintf_internal_r+0xa10>
81131d8c:	da802217 	ldw	r10,136(sp)
81131d90:	54800017 	ldw	r18,0(r10)
81131d94:	54c00117 	ldw	r19,4(r10)
81131d98:	52800204 	addi	r10,r10,8
81131d9c:	da802215 	stw	r10,136(sp)
81131da0:	a080004c 	andi	r2,r20,1
81131da4:	1001d226 	beq	r2,zero,811324f0 <___vfiprintf_internal_r+0xecc>
81131da8:	94c4b03a 	or	r2,r18,r19
81131dac:	1002351e 	bne	r2,zero,81132684 <___vfiprintf_internal_r+0x1060>
81131db0:	d8001d85 	stb	zero,118(sp)
81131db4:	48022216 	blt	r9,zero,81132640 <___vfiprintf_internal_r+0x101c>
81131db8:	00bfdfc4 	movi	r2,-129
81131dbc:	a0a8703a 	and	r20,r20,r2
81131dc0:	003f1506 	br	81131a18 <__reset+0xfb111a18>
81131dc4:	da802217 	ldw	r10,136(sp)
81131dc8:	04800044 	movi	r18,1
81131dcc:	d8001d85 	stb	zero,118(sp)
81131dd0:	50800017 	ldw	r2,0(r10)
81131dd4:	52800104 	addi	r10,r10,4
81131dd8:	da802215 	stw	r10,136(sp)
81131ddc:	d8801005 	stb	r2,64(sp)
81131de0:	9027883a 	mov	r19,r18
81131de4:	dd401004 	addi	r21,sp,64
81131de8:	0013883a 	mov	r9,zero
81131dec:	003f1706 	br	81131a4c <__reset+0xfb111a4c>
81131df0:	21003fcc 	andi	r4,r4,255
81131df4:	2003201e 	bne	r4,zero,81132a78 <___vfiprintf_internal_r+0x1454>
81131df8:	a080080c 	andi	r2,r20,32
81131dfc:	10004b26 	beq	r2,zero,81131f2c <___vfiprintf_internal_r+0x908>
81131e00:	da802217 	ldw	r10,136(sp)
81131e04:	50800117 	ldw	r2,4(r10)
81131e08:	54800017 	ldw	r18,0(r10)
81131e0c:	52800204 	addi	r10,r10,8
81131e10:	da802215 	stw	r10,136(sp)
81131e14:	1027883a 	mov	r19,r2
81131e18:	10022c16 	blt	r2,zero,811326cc <___vfiprintf_internal_r+0x10a8>
81131e1c:	df001d83 	ldbu	fp,118(sp)
81131e20:	48007216 	blt	r9,zero,81131fec <___vfiprintf_internal_r+0x9c8>
81131e24:	00ffdfc4 	movi	r3,-129
81131e28:	94c4b03a 	or	r2,r18,r19
81131e2c:	a0e8703a 	and	r20,r20,r3
81131e30:	1000cc26 	beq	r2,zero,81132164 <___vfiprintf_internal_r+0xb40>
81131e34:	98021026 	beq	r19,zero,81132678 <___vfiprintf_internal_r+0x1054>
81131e38:	dc402415 	stw	r17,144(sp)
81131e3c:	dc002515 	stw	r16,148(sp)
81131e40:	9823883a 	mov	r17,r19
81131e44:	9021883a 	mov	r16,r18
81131e48:	dd401a04 	addi	r21,sp,104
81131e4c:	4825883a 	mov	r18,r9
81131e50:	4027883a 	mov	r19,r8
81131e54:	8009883a 	mov	r4,r16
81131e58:	880b883a 	mov	r5,r17
81131e5c:	01800284 	movi	r6,10
81131e60:	000f883a 	mov	r7,zero
81131e64:	11343440 	call	81134344 <__umoddi3>
81131e68:	10800c04 	addi	r2,r2,48
81131e6c:	ad7fffc4 	addi	r21,r21,-1
81131e70:	8009883a 	mov	r4,r16
81131e74:	880b883a 	mov	r5,r17
81131e78:	a8800005 	stb	r2,0(r21)
81131e7c:	01800284 	movi	r6,10
81131e80:	000f883a 	mov	r7,zero
81131e84:	1133dc40 	call	81133dc4 <__udivdi3>
81131e88:	1021883a 	mov	r16,r2
81131e8c:	10c4b03a 	or	r2,r2,r3
81131e90:	1823883a 	mov	r17,r3
81131e94:	103fef1e 	bne	r2,zero,81131e54 <__reset+0xfb111e54>
81131e98:	dc402417 	ldw	r17,144(sp)
81131e9c:	dc002517 	ldw	r16,148(sp)
81131ea0:	9013883a 	mov	r9,r18
81131ea4:	9811883a 	mov	r8,r19
81131ea8:	da801e17 	ldw	r10,120(sp)
81131eac:	5567c83a 	sub	r19,r10,r21
81131eb0:	003ede06 	br	81131a2c <__reset+0xfb111a2c>
81131eb4:	38803fcc 	andi	r2,r7,255
81131eb8:	1080201c 	xori	r2,r2,128
81131ebc:	10bfe004 	addi	r2,r2,-128
81131ec0:	1002371e 	bne	r2,zero,811327a0 <___vfiprintf_internal_r+0x117c>
81131ec4:	01000044 	movi	r4,1
81131ec8:	01c00804 	movi	r7,32
81131ecc:	80c00007 	ldb	r3,0(r16)
81131ed0:	003e3506 	br	811317a8 <__reset+0xfb1117a8>
81131ed4:	a5000054 	ori	r20,r20,1
81131ed8:	80c00007 	ldb	r3,0(r16)
81131edc:	003e3206 	br	811317a8 <__reset+0xfb1117a8>
81131ee0:	a5002014 	ori	r20,r20,128
81131ee4:	80c00007 	ldb	r3,0(r16)
81131ee8:	003e2f06 	br	811317a8 <__reset+0xfb1117a8>
81131eec:	8015883a 	mov	r10,r16
81131ef0:	0023883a 	mov	r17,zero
81131ef4:	18bff404 	addi	r2,r3,-48
81131ef8:	50c00007 	ldb	r3,0(r10)
81131efc:	8c4002a4 	muli	r17,r17,10
81131f00:	84000044 	addi	r16,r16,1
81131f04:	8015883a 	mov	r10,r16
81131f08:	1463883a 	add	r17,r2,r17
81131f0c:	18bff404 	addi	r2,r3,-48
81131f10:	30bff92e 	bgeu	r6,r2,81131ef8 <__reset+0xfb111ef8>
81131f14:	003e2506 	br	811317ac <__reset+0xfb1117ac>
81131f18:	21003fcc 	andi	r4,r4,255
81131f1c:	2002d41e 	bne	r4,zero,81132a70 <___vfiprintf_internal_r+0x144c>
81131f20:	a5000414 	ori	r20,r20,16
81131f24:	a080080c 	andi	r2,r20,32
81131f28:	103fb51e 	bne	r2,zero,81131e00 <__reset+0xfb111e00>
81131f2c:	a080040c 	andi	r2,r20,16
81131f30:	1001f826 	beq	r2,zero,81132714 <___vfiprintf_internal_r+0x10f0>
81131f34:	da802217 	ldw	r10,136(sp)
81131f38:	54800017 	ldw	r18,0(r10)
81131f3c:	52800104 	addi	r10,r10,4
81131f40:	da802215 	stw	r10,136(sp)
81131f44:	9027d7fa 	srai	r19,r18,31
81131f48:	9805883a 	mov	r2,r19
81131f4c:	003fb206 	br	81131e18 <__reset+0xfb111e18>
81131f50:	21003fcc 	andi	r4,r4,255
81131f54:	2002c41e 	bne	r4,zero,81132a68 <___vfiprintf_internal_r+0x1444>
81131f58:	a5000414 	ori	r20,r20,16
81131f5c:	a080080c 	andi	r2,r20,32
81131f60:	103f5f1e 	bne	r2,zero,81131ce0 <__reset+0xfb111ce0>
81131f64:	a080040c 	andi	r2,r20,16
81131f68:	10020f26 	beq	r2,zero,811327a8 <___vfiprintf_internal_r+0x1184>
81131f6c:	da802217 	ldw	r10,136(sp)
81131f70:	d8001d85 	stb	zero,118(sp)
81131f74:	0027883a 	mov	r19,zero
81131f78:	50800104 	addi	r2,r10,4
81131f7c:	54800017 	ldw	r18,0(r10)
81131f80:	48021116 	blt	r9,zero,811327c8 <___vfiprintf_internal_r+0x11a4>
81131f84:	00ffdfc4 	movi	r3,-129
81131f88:	d8802215 	stw	r2,136(sp)
81131f8c:	a0e8703a 	and	r20,r20,r3
81131f90:	903f5e1e 	bne	r18,zero,81131d0c <__reset+0xfb111d0c>
81131f94:	0039883a 	mov	fp,zero
81131f98:	4802a626 	beq	r9,zero,81132a34 <___vfiprintf_internal_r+0x1410>
81131f9c:	0025883a 	mov	r18,zero
81131fa0:	0027883a 	mov	r19,zero
81131fa4:	003f5a06 	br	81131d10 <__reset+0xfb111d10>
81131fa8:	21003fcc 	andi	r4,r4,255
81131fac:	20029f1e 	bne	r4,zero,81132a2c <___vfiprintf_internal_r+0x1408>
81131fb0:	a5000414 	ori	r20,r20,16
81131fb4:	a080080c 	andi	r2,r20,32
81131fb8:	10005e1e 	bne	r2,zero,81132134 <___vfiprintf_internal_r+0xb10>
81131fbc:	a080040c 	andi	r2,r20,16
81131fc0:	1001a21e 	bne	r2,zero,8113264c <___vfiprintf_internal_r+0x1028>
81131fc4:	a080100c 	andi	r2,r20,64
81131fc8:	d8001d85 	stb	zero,118(sp)
81131fcc:	da802217 	ldw	r10,136(sp)
81131fd0:	1002231e 	bne	r2,zero,81132860 <___vfiprintf_internal_r+0x123c>
81131fd4:	50800104 	addi	r2,r10,4
81131fd8:	54800017 	ldw	r18,0(r10)
81131fdc:	0027883a 	mov	r19,zero
81131fe0:	4801a00e 	bge	r9,zero,81132664 <___vfiprintf_internal_r+0x1040>
81131fe4:	d8802215 	stw	r2,136(sp)
81131fe8:	0039883a 	mov	fp,zero
81131fec:	94c4b03a 	or	r2,r18,r19
81131ff0:	103f901e 	bne	r2,zero,81131e34 <__reset+0xfb111e34>
81131ff4:	00800044 	movi	r2,1
81131ff8:	10803fcc 	andi	r2,r2,255
81131ffc:	00c00044 	movi	r3,1
81132000:	10c05926 	beq	r2,r3,81132168 <___vfiprintf_internal_r+0xb44>
81132004:	00c00084 	movi	r3,2
81132008:	10ffe41e 	bne	r2,r3,81131f9c <__reset+0xfb111f9c>
8113200c:	0025883a 	mov	r18,zero
81132010:	0027883a 	mov	r19,zero
81132014:	00013d06 	br	8113250c <___vfiprintf_internal_r+0xee8>
81132018:	21003fcc 	andi	r4,r4,255
8113201c:	2002811e 	bne	r4,zero,81132a24 <___vfiprintf_internal_r+0x1400>
81132020:	00a04574 	movhi	r2,33045
81132024:	10821904 	addi	r2,r2,2148
81132028:	d8802615 	stw	r2,152(sp)
8113202c:	a080080c 	andi	r2,r20,32
81132030:	103f561e 	bne	r2,zero,81131d8c <__reset+0xfb111d8c>
81132034:	a080040c 	andi	r2,r20,16
81132038:	1001d126 	beq	r2,zero,81132780 <___vfiprintf_internal_r+0x115c>
8113203c:	da802217 	ldw	r10,136(sp)
81132040:	0027883a 	mov	r19,zero
81132044:	54800017 	ldw	r18,0(r10)
81132048:	52800104 	addi	r10,r10,4
8113204c:	da802215 	stw	r10,136(sp)
81132050:	003f5306 	br	81131da0 <__reset+0xfb111da0>
81132054:	da802217 	ldw	r10,136(sp)
81132058:	d8001d85 	stb	zero,118(sp)
8113205c:	55400017 	ldw	r21,0(r10)
81132060:	50c00104 	addi	r3,r10,4
81132064:	a8024226 	beq	r21,zero,81132970 <___vfiprintf_internal_r+0x134c>
81132068:	48021816 	blt	r9,zero,811328cc <___vfiprintf_internal_r+0x12a8>
8113206c:	480d883a 	mov	r6,r9
81132070:	000b883a 	mov	r5,zero
81132074:	a809883a 	mov	r4,r21
81132078:	d8c02a15 	stw	r3,168(sp)
8113207c:	da002b15 	stw	r8,172(sp)
81132080:	da402c15 	stw	r9,176(sp)
81132084:	112c6e80 	call	8112c6e8 <memchr>
81132088:	d8c02a17 	ldw	r3,168(sp)
8113208c:	da002b17 	ldw	r8,172(sp)
81132090:	da402c17 	ldw	r9,176(sp)
81132094:	10024826 	beq	r2,zero,811329b8 <___vfiprintf_internal_r+0x1394>
81132098:	1567c83a 	sub	r19,r2,r21
8113209c:	df001d83 	ldbu	fp,118(sp)
811320a0:	d8c02215 	stw	r3,136(sp)
811320a4:	0013883a 	mov	r9,zero
811320a8:	003e6006 	br	81131a2c <__reset+0xfb111a2c>
811320ac:	21003fcc 	andi	r4,r4,255
811320b0:	203fc026 	beq	r4,zero,81131fb4 <__reset+0xfb111fb4>
811320b4:	d9c01d85 	stb	r7,118(sp)
811320b8:	003fbe06 	br	81131fb4 <__reset+0xfb111fb4>
811320bc:	da802217 	ldw	r10,136(sp)
811320c0:	54400017 	ldw	r17,0(r10)
811320c4:	50800104 	addi	r2,r10,4
811320c8:	883e3b16 	blt	r17,zero,811319b8 <__reset+0xfb1119b8>
811320cc:	d8802215 	stw	r2,136(sp)
811320d0:	80c00007 	ldb	r3,0(r16)
811320d4:	003db406 	br	811317a8 <__reset+0xfb1117a8>
811320d8:	01000044 	movi	r4,1
811320dc:	01c00ac4 	movi	r7,43
811320e0:	80c00007 	ldb	r3,0(r16)
811320e4:	003db006 	br	811317a8 <__reset+0xfb1117a8>
811320e8:	80c00007 	ldb	r3,0(r16)
811320ec:	82800044 	addi	r10,r16,1
811320f0:	1b423c26 	beq	r3,r13,811329e4 <___vfiprintf_internal_r+0x13c0>
811320f4:	18bff404 	addi	r2,r3,-48
811320f8:	0013883a 	mov	r9,zero
811320fc:	30822b36 	bltu	r6,r2,811329ac <___vfiprintf_internal_r+0x1388>
81132100:	50c00007 	ldb	r3,0(r10)
81132104:	4a4002a4 	muli	r9,r9,10
81132108:	54000044 	addi	r16,r10,1
8113210c:	8015883a 	mov	r10,r16
81132110:	4893883a 	add	r9,r9,r2
81132114:	18bff404 	addi	r2,r3,-48
81132118:	30bff92e 	bgeu	r6,r2,81132100 <__reset+0xfb112100>
8113211c:	483da30e 	bge	r9,zero,811317ac <__reset+0xfb1117ac>
81132120:	027fffc4 	movi	r9,-1
81132124:	003da106 	br	811317ac <__reset+0xfb1117ac>
81132128:	a5001014 	ori	r20,r20,64
8113212c:	80c00007 	ldb	r3,0(r16)
81132130:	003d9d06 	br	811317a8 <__reset+0xfb1117a8>
81132134:	da802217 	ldw	r10,136(sp)
81132138:	d8001d85 	stb	zero,118(sp)
8113213c:	50c00204 	addi	r3,r10,8
81132140:	54800017 	ldw	r18,0(r10)
81132144:	54c00117 	ldw	r19,4(r10)
81132148:	4801ca16 	blt	r9,zero,81132874 <___vfiprintf_internal_r+0x1250>
8113214c:	013fdfc4 	movi	r4,-129
81132150:	94c4b03a 	or	r2,r18,r19
81132154:	d8c02215 	stw	r3,136(sp)
81132158:	a128703a 	and	r20,r20,r4
8113215c:	0039883a 	mov	fp,zero
81132160:	103f341e 	bne	r2,zero,81131e34 <__reset+0xfb111e34>
81132164:	483e2e26 	beq	r9,zero,81131a20 <__reset+0xfb111a20>
81132168:	0025883a 	mov	r18,zero
8113216c:	94800c04 	addi	r18,r18,48
81132170:	dc8019c5 	stb	r18,103(sp)
81132174:	dcc02717 	ldw	r19,156(sp)
81132178:	dd4019c4 	addi	r21,sp,103
8113217c:	003e2b06 	br	81131a2c <__reset+0xfb111a2c>
81132180:	21003fcc 	andi	r4,r4,255
81132184:	2002361e 	bne	r4,zero,81132a60 <___vfiprintf_internal_r+0x143c>
81132188:	1801c126 	beq	r3,zero,81132890 <___vfiprintf_internal_r+0x126c>
8113218c:	04800044 	movi	r18,1
81132190:	d8c01005 	stb	r3,64(sp)
81132194:	d8001d85 	stb	zero,118(sp)
81132198:	9027883a 	mov	r19,r18
8113219c:	dd401004 	addi	r21,sp,64
811321a0:	003f1106 	br	81131de8 <__reset+0xfb111de8>
811321a4:	d9402117 	ldw	r5,132(sp)
811321a8:	d9002017 	ldw	r4,128(sp)
811321ac:	d9801a04 	addi	r6,sp,104
811321b0:	d9c02b15 	stw	r7,172(sp)
811321b4:	dbc02a15 	stw	r15,168(sp)
811321b8:	11315080 	call	81131508 <__sprint_r.part.0>
811321bc:	d9c02b17 	ldw	r7,172(sp)
811321c0:	dbc02a17 	ldw	r15,168(sp)
811321c4:	10006d1e 	bne	r2,zero,8113237c <___vfiprintf_internal_r+0xd58>
811321c8:	d9801b17 	ldw	r6,108(sp)
811321cc:	d8801c17 	ldw	r2,112(sp)
811321d0:	d811883a 	mov	r8,sp
811321d4:	31400044 	addi	r5,r6,1
811321d8:	003e3306 	br	81131aa8 <__reset+0xfb111aa8>
811321dc:	d9401b17 	ldw	r5,108(sp)
811321e0:	d8801c17 	ldw	r2,112(sp)
811321e4:	29000044 	addi	r4,r5,1
811321e8:	d8c01d87 	ldb	r3,118(sp)
811321ec:	183e4d26 	beq	r3,zero,81131b24 <__reset+0xfb111b24>
811321f0:	00c00044 	movi	r3,1
811321f4:	d9401d84 	addi	r5,sp,118
811321f8:	10c5883a 	add	r2,r2,r3
811321fc:	41400015 	stw	r5,0(r8)
81132200:	40c00115 	stw	r3,4(r8)
81132204:	d8801c15 	stw	r2,112(sp)
81132208:	d9001b15 	stw	r4,108(sp)
8113220c:	014001c4 	movi	r5,7
81132210:	2900a90e 	bge	r5,r4,811324b8 <___vfiprintf_internal_r+0xe94>
81132214:	1000da1e 	bne	r2,zero,81132580 <___vfiprintf_internal_r+0xf5c>
81132218:	7000ab1e 	bne	r14,zero,811324c8 <___vfiprintf_internal_r+0xea4>
8113221c:	000b883a 	mov	r5,zero
81132220:	1809883a 	mov	r4,r3
81132224:	d811883a 	mov	r8,sp
81132228:	00c02004 	movi	r3,128
8113222c:	e0fe4d26 	beq	fp,r3,81131b64 <__reset+0xfb111b64>
81132230:	4cf9c83a 	sub	fp,r9,r19
81132234:	073e7b0e 	bge	zero,fp,81131c24 <__reset+0xfb111c24>
81132238:	01c00404 	movi	r7,16
8113223c:	3f01900e 	bge	r7,fp,81132880 <___vfiprintf_internal_r+0x125c>
81132240:	00e04574 	movhi	r3,33045
81132244:	18c2b004 	addi	r3,r3,2752
81132248:	d8c02415 	stw	r3,144(sp)
8113224c:	034001c4 	movi	r13,7
81132250:	00000506 	br	81132268 <___vfiprintf_internal_r+0xc44>
81132254:	29000084 	addi	r4,r5,2
81132258:	42000204 	addi	r8,r8,8
8113225c:	180b883a 	mov	r5,r3
81132260:	e73ffc04 	addi	fp,fp,-16
81132264:	3f000d0e 	bge	r7,fp,8113229c <___vfiprintf_internal_r+0xc78>
81132268:	10800404 	addi	r2,r2,16
8113226c:	28c00044 	addi	r3,r5,1
81132270:	45c00015 	stw	r23,0(r8)
81132274:	41c00115 	stw	r7,4(r8)
81132278:	d8801c15 	stw	r2,112(sp)
8113227c:	d8c01b15 	stw	r3,108(sp)
81132280:	68fff40e 	bge	r13,r3,81132254 <__reset+0xfb112254>
81132284:	1000101e 	bne	r2,zero,811322c8 <___vfiprintf_internal_r+0xca4>
81132288:	e73ffc04 	addi	fp,fp,-16
8113228c:	01000044 	movi	r4,1
81132290:	000b883a 	mov	r5,zero
81132294:	d811883a 	mov	r8,sp
81132298:	3f3ff316 	blt	r7,fp,81132268 <__reset+0xfb112268>
8113229c:	da802417 	ldw	r10,144(sp)
811322a0:	1705883a 	add	r2,r2,fp
811322a4:	47000115 	stw	fp,4(r8)
811322a8:	42800015 	stw	r10,0(r8)
811322ac:	d8801c15 	stw	r2,112(sp)
811322b0:	d9001b15 	stw	r4,108(sp)
811322b4:	00c001c4 	movi	r3,7
811322b8:	19003616 	blt	r3,r4,81132394 <___vfiprintf_internal_r+0xd70>
811322bc:	42000204 	addi	r8,r8,8
811322c0:	21000044 	addi	r4,r4,1
811322c4:	003e5706 	br	81131c24 <__reset+0xfb111c24>
811322c8:	d9402117 	ldw	r5,132(sp)
811322cc:	d9002017 	ldw	r4,128(sp)
811322d0:	d9801a04 	addi	r6,sp,104
811322d4:	d9c02b15 	stw	r7,172(sp)
811322d8:	db402a15 	stw	r13,168(sp)
811322dc:	11315080 	call	81131508 <__sprint_r.part.0>
811322e0:	d9c02b17 	ldw	r7,172(sp)
811322e4:	db402a17 	ldw	r13,168(sp)
811322e8:	1000241e 	bne	r2,zero,8113237c <___vfiprintf_internal_r+0xd58>
811322ec:	d9401b17 	ldw	r5,108(sp)
811322f0:	d8801c17 	ldw	r2,112(sp)
811322f4:	d811883a 	mov	r8,sp
811322f8:	29000044 	addi	r4,r5,1
811322fc:	003fd806 	br	81132260 <__reset+0xfb112260>
81132300:	d9401b17 	ldw	r5,108(sp)
81132304:	00e04574 	movhi	r3,33045
81132308:	18c2b404 	addi	r3,r3,2768
8113230c:	d8c02415 	stw	r3,144(sp)
81132310:	29400044 	addi	r5,r5,1
81132314:	d8c02417 	ldw	r3,144(sp)
81132318:	14c5883a 	add	r2,r2,r19
8113231c:	44c00115 	stw	r19,4(r8)
81132320:	40c00015 	stw	r3,0(r8)
81132324:	d8801c15 	stw	r2,112(sp)
81132328:	d9401b15 	stw	r5,108(sp)
8113232c:	00c001c4 	movi	r3,7
81132330:	1940070e 	bge	r3,r5,81132350 <___vfiprintf_internal_r+0xd2c>
81132334:	103e4826 	beq	r2,zero,81131c58 <__reset+0xfb111c58>
81132338:	d9402117 	ldw	r5,132(sp)
8113233c:	d9002017 	ldw	r4,128(sp)
81132340:	d9801a04 	addi	r6,sp,104
81132344:	11315080 	call	81131508 <__sprint_r.part.0>
81132348:	10000c1e 	bne	r2,zero,8113237c <___vfiprintf_internal_r+0xd58>
8113234c:	d8801c17 	ldw	r2,112(sp)
81132350:	8c80010e 	bge	r17,r18,81132358 <___vfiprintf_internal_r+0xd34>
81132354:	9023883a 	mov	r17,r18
81132358:	da802317 	ldw	r10,140(sp)
8113235c:	5455883a 	add	r10,r10,r17
81132360:	da802315 	stw	r10,140(sp)
81132364:	103e4126 	beq	r2,zero,81131c6c <__reset+0xfb111c6c>
81132368:	d9402117 	ldw	r5,132(sp)
8113236c:	d9002017 	ldw	r4,128(sp)
81132370:	d9801a04 	addi	r6,sp,104
81132374:	11315080 	call	81131508 <__sprint_r.part.0>
81132378:	103e3c26 	beq	r2,zero,81131c6c <__reset+0xfb111c6c>
8113237c:	dd002117 	ldw	r20,132(sp)
81132380:	a080030b 	ldhu	r2,12(r20)
81132384:	1080100c 	andi	r2,r2,64
81132388:	1001231e 	bne	r2,zero,81132818 <___vfiprintf_internal_r+0x11f4>
8113238c:	d8802317 	ldw	r2,140(sp)
81132390:	003d7b06 	br	81131980 <__reset+0xfb111980>
81132394:	1000991e 	bne	r2,zero,811325fc <___vfiprintf_internal_r+0xfd8>
81132398:	00c00044 	movi	r3,1
8113239c:	9805883a 	mov	r2,r19
811323a0:	dd400015 	stw	r21,0(sp)
811323a4:	dcc00115 	stw	r19,4(sp)
811323a8:	dcc01c15 	stw	r19,112(sp)
811323ac:	d8c01b15 	stw	r3,108(sp)
811323b0:	d811883a 	mov	r8,sp
811323b4:	42000204 	addi	r8,r8,8
811323b8:	a2c0010c 	andi	r11,r20,4
811323bc:	583fe426 	beq	r11,zero,81132350 <__reset+0xfb112350>
811323c0:	8ca7c83a 	sub	r19,r17,r18
811323c4:	04ffe20e 	bge	zero,r19,81132350 <__reset+0xfb112350>
811323c8:	01c00404 	movi	r7,16
811323cc:	3cffcc0e 	bge	r7,r19,81132300 <__reset+0xfb112300>
811323d0:	02a04574 	movhi	r10,33045
811323d4:	5282b404 	addi	r10,r10,2768
811323d8:	d9001b17 	ldw	r4,108(sp)
811323dc:	da802415 	stw	r10,144(sp)
811323e0:	382b883a 	mov	r21,r7
811323e4:	050001c4 	movi	r20,7
811323e8:	df002017 	ldw	fp,128(sp)
811323ec:	00000506 	br	81132404 <___vfiprintf_internal_r+0xde0>
811323f0:	21400084 	addi	r5,r4,2
811323f4:	42000204 	addi	r8,r8,8
811323f8:	1809883a 	mov	r4,r3
811323fc:	9cfffc04 	addi	r19,r19,-16
81132400:	acffc40e 	bge	r21,r19,81132314 <__reset+0xfb112314>
81132404:	10800404 	addi	r2,r2,16
81132408:	20c00044 	addi	r3,r4,1
8113240c:	45800015 	stw	r22,0(r8)
81132410:	45400115 	stw	r21,4(r8)
81132414:	d8801c15 	stw	r2,112(sp)
81132418:	d8c01b15 	stw	r3,108(sp)
8113241c:	a0fff40e 	bge	r20,r3,811323f0 <__reset+0xfb1123f0>
81132420:	1000041e 	bne	r2,zero,81132434 <___vfiprintf_internal_r+0xe10>
81132424:	01400044 	movi	r5,1
81132428:	0009883a 	mov	r4,zero
8113242c:	d811883a 	mov	r8,sp
81132430:	003ff206 	br	811323fc <__reset+0xfb1123fc>
81132434:	d9402117 	ldw	r5,132(sp)
81132438:	d9801a04 	addi	r6,sp,104
8113243c:	e009883a 	mov	r4,fp
81132440:	11315080 	call	81131508 <__sprint_r.part.0>
81132444:	103fcd1e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
81132448:	d9001b17 	ldw	r4,108(sp)
8113244c:	d8801c17 	ldw	r2,112(sp)
81132450:	d811883a 	mov	r8,sp
81132454:	21400044 	addi	r5,r4,1
81132458:	003fe806 	br	811323fc <__reset+0xfb1123fc>
8113245c:	d9402117 	ldw	r5,132(sp)
81132460:	d9002017 	ldw	r4,128(sp)
81132464:	d9801a04 	addi	r6,sp,104
81132468:	d9c02b15 	stw	r7,172(sp)
8113246c:	db402a15 	stw	r13,168(sp)
81132470:	11315080 	call	81131508 <__sprint_r.part.0>
81132474:	d9c02b17 	ldw	r7,172(sp)
81132478:	db402a17 	ldw	r13,168(sp)
8113247c:	103fbf1e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
81132480:	d9401b17 	ldw	r5,108(sp)
81132484:	d8801c17 	ldw	r2,112(sp)
81132488:	d811883a 	mov	r8,sp
8113248c:	29800044 	addi	r6,r5,1
81132490:	003dc406 	br	81131ba4 <__reset+0xfb111ba4>
81132494:	1000d21e 	bne	r2,zero,811327e0 <___vfiprintf_internal_r+0x11bc>
81132498:	d8c01d87 	ldb	r3,118(sp)
8113249c:	18009526 	beq	r3,zero,811326f4 <___vfiprintf_internal_r+0x10d0>
811324a0:	00800044 	movi	r2,1
811324a4:	d8c01d84 	addi	r3,sp,118
811324a8:	1009883a 	mov	r4,r2
811324ac:	d8c00015 	stw	r3,0(sp)
811324b0:	d8800115 	stw	r2,4(sp)
811324b4:	d811883a 	mov	r8,sp
811324b8:	200b883a 	mov	r5,r4
811324bc:	42000204 	addi	r8,r8,8
811324c0:	21000044 	addi	r4,r4,1
811324c4:	003d9706 	br	81131b24 <__reset+0xfb111b24>
811324c8:	d9001d04 	addi	r4,sp,116
811324cc:	00800084 	movi	r2,2
811324d0:	d9000015 	stw	r4,0(sp)
811324d4:	d8800115 	stw	r2,4(sp)
811324d8:	1809883a 	mov	r4,r3
811324dc:	d811883a 	mov	r8,sp
811324e0:	200b883a 	mov	r5,r4
811324e4:	42000204 	addi	r8,r8,8
811324e8:	21000044 	addi	r4,r4,1
811324ec:	003f4e06 	br	81132228 <__reset+0xfb112228>
811324f0:	d8001d85 	stb	zero,118(sp)
811324f4:	48005016 	blt	r9,zero,81132638 <___vfiprintf_internal_r+0x1014>
811324f8:	00ffdfc4 	movi	r3,-129
811324fc:	94c4b03a 	or	r2,r18,r19
81132500:	a0e8703a 	and	r20,r20,r3
81132504:	103d4426 	beq	r2,zero,81131a18 <__reset+0xfb111a18>
81132508:	0039883a 	mov	fp,zero
8113250c:	d9002617 	ldw	r4,152(sp)
81132510:	dd401a04 	addi	r21,sp,104
81132514:	908003cc 	andi	r2,r18,15
81132518:	9806973a 	slli	r3,r19,28
8113251c:	2085883a 	add	r2,r4,r2
81132520:	9024d13a 	srli	r18,r18,4
81132524:	10800003 	ldbu	r2,0(r2)
81132528:	9826d13a 	srli	r19,r19,4
8113252c:	ad7fffc4 	addi	r21,r21,-1
81132530:	1ca4b03a 	or	r18,r3,r18
81132534:	a8800005 	stb	r2,0(r21)
81132538:	94c4b03a 	or	r2,r18,r19
8113253c:	103ff51e 	bne	r2,zero,81132514 <__reset+0xfb112514>
81132540:	003e5906 	br	81131ea8 <__reset+0xfb111ea8>
81132544:	d9402117 	ldw	r5,132(sp)
81132548:	d9002017 	ldw	r4,128(sp)
8113254c:	d9801a04 	addi	r6,sp,104
81132550:	11315080 	call	81131508 <__sprint_r.part.0>
81132554:	103f891e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
81132558:	d8801c17 	ldw	r2,112(sp)
8113255c:	d811883a 	mov	r8,sp
81132560:	003f9506 	br	811323b8 <__reset+0xfb1123b8>
81132564:	d9402117 	ldw	r5,132(sp)
81132568:	d9002017 	ldw	r4,128(sp)
8113256c:	d9801a04 	addi	r6,sp,104
81132570:	11315080 	call	81131508 <__sprint_r.part.0>
81132574:	103f811e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
81132578:	d811883a 	mov	r8,sp
8113257c:	003ced06 	br	81131934 <__reset+0xfb111934>
81132580:	d9402117 	ldw	r5,132(sp)
81132584:	d9002017 	ldw	r4,128(sp)
81132588:	d9801a04 	addi	r6,sp,104
8113258c:	da402c15 	stw	r9,176(sp)
81132590:	db802a15 	stw	r14,168(sp)
81132594:	11315080 	call	81131508 <__sprint_r.part.0>
81132598:	da402c17 	ldw	r9,176(sp)
8113259c:	db802a17 	ldw	r14,168(sp)
811325a0:	103f761e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
811325a4:	d9401b17 	ldw	r5,108(sp)
811325a8:	d8801c17 	ldw	r2,112(sp)
811325ac:	d811883a 	mov	r8,sp
811325b0:	29000044 	addi	r4,r5,1
811325b4:	003d5b06 	br	81131b24 <__reset+0xfb111b24>
811325b8:	d9402117 	ldw	r5,132(sp)
811325bc:	d9002017 	ldw	r4,128(sp)
811325c0:	d9801a04 	addi	r6,sp,104
811325c4:	da402c15 	stw	r9,176(sp)
811325c8:	11315080 	call	81131508 <__sprint_r.part.0>
811325cc:	da402c17 	ldw	r9,176(sp)
811325d0:	103f6a1e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
811325d4:	d9401b17 	ldw	r5,108(sp)
811325d8:	d8801c17 	ldw	r2,112(sp)
811325dc:	d811883a 	mov	r8,sp
811325e0:	29000044 	addi	r4,r5,1
811325e4:	003f1006 	br	81132228 <__reset+0xfb112228>
811325e8:	1000c31e 	bne	r2,zero,811328f8 <___vfiprintf_internal_r+0x12d4>
811325ec:	01000044 	movi	r4,1
811325f0:	000b883a 	mov	r5,zero
811325f4:	d811883a 	mov	r8,sp
811325f8:	003f0d06 	br	81132230 <__reset+0xfb112230>
811325fc:	d9402117 	ldw	r5,132(sp)
81132600:	d9002017 	ldw	r4,128(sp)
81132604:	d9801a04 	addi	r6,sp,104
81132608:	11315080 	call	81131508 <__sprint_r.part.0>
8113260c:	103f5b1e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
81132610:	d9001b17 	ldw	r4,108(sp)
81132614:	d8801c17 	ldw	r2,112(sp)
81132618:	d811883a 	mov	r8,sp
8113261c:	21000044 	addi	r4,r4,1
81132620:	003d8006 	br	81131c24 <__reset+0xfb111c24>
81132624:	01204574 	movhi	r4,33045
81132628:	21021e04 	addi	r4,r4,2168
8113262c:	d9002615 	stw	r4,152(sp)
81132630:	d8c02215 	stw	r3,136(sp)
81132634:	1029883a 	mov	r20,r2
81132638:	94c4b03a 	or	r2,r18,r19
8113263c:	103fb21e 	bne	r2,zero,81132508 <__reset+0xfb112508>
81132640:	0039883a 	mov	fp,zero
81132644:	00800084 	movi	r2,2
81132648:	003e6b06 	br	81131ff8 <__reset+0xfb111ff8>
8113264c:	da802217 	ldw	r10,136(sp)
81132650:	d8001d85 	stb	zero,118(sp)
81132654:	0027883a 	mov	r19,zero
81132658:	50800104 	addi	r2,r10,4
8113265c:	54800017 	ldw	r18,0(r10)
81132660:	483e6016 	blt	r9,zero,81131fe4 <__reset+0xfb111fe4>
81132664:	00ffdfc4 	movi	r3,-129
81132668:	d8802215 	stw	r2,136(sp)
8113266c:	a0e8703a 	and	r20,r20,r3
81132670:	0039883a 	mov	fp,zero
81132674:	903ebb26 	beq	r18,zero,81132164 <__reset+0xfb112164>
81132678:	00800244 	movi	r2,9
8113267c:	14bdee36 	bltu	r2,r18,81131e38 <__reset+0xfb111e38>
81132680:	003eba06 	br	8113216c <__reset+0xfb11216c>
81132684:	00800c04 	movi	r2,48
81132688:	d8c01d45 	stb	r3,117(sp)
8113268c:	d8801d05 	stb	r2,116(sp)
81132690:	d8001d85 	stb	zero,118(sp)
81132694:	a0c00094 	ori	r3,r20,2
81132698:	4800a916 	blt	r9,zero,81132940 <___vfiprintf_internal_r+0x131c>
8113269c:	00bfdfc4 	movi	r2,-129
811326a0:	a096703a 	and	r11,r20,r2
811326a4:	5d000094 	ori	r20,r11,2
811326a8:	0039883a 	mov	fp,zero
811326ac:	003f9706 	br	8113250c <__reset+0xfb11250c>
811326b0:	8025883a 	mov	r18,r16
811326b4:	003c2e06 	br	81131770 <__reset+0xfb111770>
811326b8:	00a04574 	movhi	r2,33045
811326bc:	10821e04 	addi	r2,r2,2168
811326c0:	0039883a 	mov	fp,zero
811326c4:	d8802615 	stw	r2,152(sp)
811326c8:	003f9006 	br	8113250c <__reset+0xfb11250c>
811326cc:	04a5c83a 	sub	r18,zero,r18
811326d0:	07000b44 	movi	fp,45
811326d4:	9004c03a 	cmpne	r2,r18,zero
811326d8:	04e7c83a 	sub	r19,zero,r19
811326dc:	df001d85 	stb	fp,118(sp)
811326e0:	98a7c83a 	sub	r19,r19,r2
811326e4:	48009f16 	blt	r9,zero,81132964 <___vfiprintf_internal_r+0x1340>
811326e8:	00bfdfc4 	movi	r2,-129
811326ec:	a0a8703a 	and	r20,r20,r2
811326f0:	003dd006 	br	81131e34 <__reset+0xfb111e34>
811326f4:	70004c26 	beq	r14,zero,81132828 <___vfiprintf_internal_r+0x1204>
811326f8:	00800084 	movi	r2,2
811326fc:	d8c01d04 	addi	r3,sp,116
81132700:	d8c00015 	stw	r3,0(sp)
81132704:	d8800115 	stw	r2,4(sp)
81132708:	01000044 	movi	r4,1
8113270c:	d811883a 	mov	r8,sp
81132710:	003f7306 	br	811324e0 <__reset+0xfb1124e0>
81132714:	a080100c 	andi	r2,r20,64
81132718:	da802217 	ldw	r10,136(sp)
8113271c:	103e0626 	beq	r2,zero,81131f38 <__reset+0xfb111f38>
81132720:	5480000f 	ldh	r18,0(r10)
81132724:	52800104 	addi	r10,r10,4
81132728:	da802215 	stw	r10,136(sp)
8113272c:	9027d7fa 	srai	r19,r18,31
81132730:	9805883a 	mov	r2,r19
81132734:	003db806 	br	81131e18 <__reset+0xfb111e18>
81132738:	a080040c 	andi	r2,r20,16
8113273c:	1000091e 	bne	r2,zero,81132764 <___vfiprintf_internal_r+0x1140>
81132740:	a2c0100c 	andi	r11,r20,64
81132744:	58000726 	beq	r11,zero,81132764 <___vfiprintf_internal_r+0x1140>
81132748:	da802217 	ldw	r10,136(sp)
8113274c:	50800017 	ldw	r2,0(r10)
81132750:	52800104 	addi	r10,r10,4
81132754:	da802215 	stw	r10,136(sp)
81132758:	da802317 	ldw	r10,140(sp)
8113275c:	1280000d 	sth	r10,0(r2)
81132760:	003be706 	br	81131700 <__reset+0xfb111700>
81132764:	da802217 	ldw	r10,136(sp)
81132768:	50800017 	ldw	r2,0(r10)
8113276c:	52800104 	addi	r10,r10,4
81132770:	da802215 	stw	r10,136(sp)
81132774:	da802317 	ldw	r10,140(sp)
81132778:	12800015 	stw	r10,0(r2)
8113277c:	003be006 	br	81131700 <__reset+0xfb111700>
81132780:	a080100c 	andi	r2,r20,64
81132784:	da802217 	ldw	r10,136(sp)
81132788:	10003026 	beq	r2,zero,8113284c <___vfiprintf_internal_r+0x1228>
8113278c:	5480000b 	ldhu	r18,0(r10)
81132790:	52800104 	addi	r10,r10,4
81132794:	0027883a 	mov	r19,zero
81132798:	da802215 	stw	r10,136(sp)
8113279c:	003d8006 	br	81131da0 <__reset+0xfb111da0>
811327a0:	80c00007 	ldb	r3,0(r16)
811327a4:	003c0006 	br	811317a8 <__reset+0xfb1117a8>
811327a8:	a080100c 	andi	r2,r20,64
811327ac:	d8001d85 	stb	zero,118(sp)
811327b0:	da802217 	ldw	r10,136(sp)
811327b4:	1000201e 	bne	r2,zero,81132838 <___vfiprintf_internal_r+0x1214>
811327b8:	50800104 	addi	r2,r10,4
811327bc:	54800017 	ldw	r18,0(r10)
811327c0:	0027883a 	mov	r19,zero
811327c4:	483def0e 	bge	r9,zero,81131f84 <__reset+0xfb111f84>
811327c8:	94c6b03a 	or	r3,r18,r19
811327cc:	d8802215 	stw	r2,136(sp)
811327d0:	183d4e1e 	bne	r3,zero,81131d0c <__reset+0xfb111d0c>
811327d4:	0039883a 	mov	fp,zero
811327d8:	0005883a 	mov	r2,zero
811327dc:	003e0606 	br	81131ff8 <__reset+0xfb111ff8>
811327e0:	d9402117 	ldw	r5,132(sp)
811327e4:	d9002017 	ldw	r4,128(sp)
811327e8:	d9801a04 	addi	r6,sp,104
811327ec:	da402c15 	stw	r9,176(sp)
811327f0:	db802a15 	stw	r14,168(sp)
811327f4:	11315080 	call	81131508 <__sprint_r.part.0>
811327f8:	da402c17 	ldw	r9,176(sp)
811327fc:	db802a17 	ldw	r14,168(sp)
81132800:	103ede1e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
81132804:	d9401b17 	ldw	r5,108(sp)
81132808:	d8801c17 	ldw	r2,112(sp)
8113280c:	d811883a 	mov	r8,sp
81132810:	29000044 	addi	r4,r5,1
81132814:	003e7406 	br	811321e8 <__reset+0xfb1121e8>
81132818:	00bfffc4 	movi	r2,-1
8113281c:	003c5806 	br	81131980 <__reset+0xfb111980>
81132820:	d811883a 	mov	r8,sp
81132824:	003ee806 	br	811323c8 <__reset+0xfb1123c8>
81132828:	000b883a 	mov	r5,zero
8113282c:	01000044 	movi	r4,1
81132830:	d811883a 	mov	r8,sp
81132834:	003e7c06 	br	81132228 <__reset+0xfb112228>
81132838:	50800104 	addi	r2,r10,4
8113283c:	5480000b 	ldhu	r18,0(r10)
81132840:	0027883a 	mov	r19,zero
81132844:	483dcf0e 	bge	r9,zero,81131f84 <__reset+0xfb111f84>
81132848:	003fdf06 	br	811327c8 <__reset+0xfb1127c8>
8113284c:	54800017 	ldw	r18,0(r10)
81132850:	52800104 	addi	r10,r10,4
81132854:	0027883a 	mov	r19,zero
81132858:	da802215 	stw	r10,136(sp)
8113285c:	003d5006 	br	81131da0 <__reset+0xfb111da0>
81132860:	50800104 	addi	r2,r10,4
81132864:	5480000b 	ldhu	r18,0(r10)
81132868:	0027883a 	mov	r19,zero
8113286c:	483f7d0e 	bge	r9,zero,81132664 <__reset+0xfb112664>
81132870:	003ddc06 	br	81131fe4 <__reset+0xfb111fe4>
81132874:	d8c02215 	stw	r3,136(sp)
81132878:	0039883a 	mov	fp,zero
8113287c:	003ddb06 	br	81131fec <__reset+0xfb111fec>
81132880:	02a04574 	movhi	r10,33045
81132884:	5282b004 	addi	r10,r10,2752
81132888:	da802415 	stw	r10,144(sp)
8113288c:	003e8306 	br	8113229c <__reset+0xfb11229c>
81132890:	d8801c17 	ldw	r2,112(sp)
81132894:	dd002117 	ldw	r20,132(sp)
81132898:	103eb926 	beq	r2,zero,81132380 <__reset+0xfb112380>
8113289c:	d9002017 	ldw	r4,128(sp)
811328a0:	d9801a04 	addi	r6,sp,104
811328a4:	a00b883a 	mov	r5,r20
811328a8:	11315080 	call	81131508 <__sprint_r.part.0>
811328ac:	003eb406 	br	81132380 <__reset+0xfb112380>
811328b0:	80c00043 	ldbu	r3,1(r16)
811328b4:	a5000814 	ori	r20,r20,32
811328b8:	84000044 	addi	r16,r16,1
811328bc:	18c03fcc 	andi	r3,r3,255
811328c0:	18c0201c 	xori	r3,r3,128
811328c4:	18ffe004 	addi	r3,r3,-128
811328c8:	003bb706 	br	811317a8 <__reset+0xfb1117a8>
811328cc:	a809883a 	mov	r4,r21
811328d0:	d8c02a15 	stw	r3,168(sp)
811328d4:	da002b15 	stw	r8,172(sp)
811328d8:	1122ee80 	call	81122ee8 <strlen>
811328dc:	d8c02a17 	ldw	r3,168(sp)
811328e0:	1027883a 	mov	r19,r2
811328e4:	df001d83 	ldbu	fp,118(sp)
811328e8:	d8c02215 	stw	r3,136(sp)
811328ec:	0013883a 	mov	r9,zero
811328f0:	da002b17 	ldw	r8,172(sp)
811328f4:	003c4d06 	br	81131a2c <__reset+0xfb111a2c>
811328f8:	d9402117 	ldw	r5,132(sp)
811328fc:	d9002017 	ldw	r4,128(sp)
81132900:	d9801a04 	addi	r6,sp,104
81132904:	da402c15 	stw	r9,176(sp)
81132908:	11315080 	call	81131508 <__sprint_r.part.0>
8113290c:	da402c17 	ldw	r9,176(sp)
81132910:	103e9a1e 	bne	r2,zero,8113237c <__reset+0xfb11237c>
81132914:	d9401b17 	ldw	r5,108(sp)
81132918:	d8801c17 	ldw	r2,112(sp)
8113291c:	d811883a 	mov	r8,sp
81132920:	29000044 	addi	r4,r5,1
81132924:	003e4206 	br	81132230 <__reset+0xfb112230>
81132928:	d9401b17 	ldw	r5,108(sp)
8113292c:	01204574 	movhi	r4,33045
81132930:	2102b404 	addi	r4,r4,2768
81132934:	d9002415 	stw	r4,144(sp)
81132938:	29400044 	addi	r5,r5,1
8113293c:	003c6d06 	br	81131af4 <__reset+0xfb111af4>
81132940:	0039883a 	mov	fp,zero
81132944:	00800084 	movi	r2,2
81132948:	10803fcc 	andi	r2,r2,255
8113294c:	01000044 	movi	r4,1
81132950:	11001e26 	beq	r2,r4,811329cc <___vfiprintf_internal_r+0x13a8>
81132954:	01000084 	movi	r4,2
81132958:	11001e1e 	bne	r2,r4,811329d4 <___vfiprintf_internal_r+0x13b0>
8113295c:	1829883a 	mov	r20,r3
81132960:	003eea06 	br	8113250c <__reset+0xfb11250c>
81132964:	a007883a 	mov	r3,r20
81132968:	00800044 	movi	r2,1
8113296c:	003ff606 	br	81132948 <__reset+0xfb112948>
81132970:	00800184 	movi	r2,6
81132974:	1240012e 	bgeu	r2,r9,8113297c <___vfiprintf_internal_r+0x1358>
81132978:	1013883a 	mov	r9,r2
8113297c:	4827883a 	mov	r19,r9
81132980:	4825883a 	mov	r18,r9
81132984:	48001516 	blt	r9,zero,811329dc <___vfiprintf_internal_r+0x13b8>
81132988:	05604574 	movhi	r21,33045
8113298c:	d8c02215 	stw	r3,136(sp)
81132990:	ad422304 	addi	r21,r21,2188
81132994:	003d1406 	br	81131de8 <__reset+0xfb111de8>
81132998:	02a04574 	movhi	r10,33045
8113299c:	5282b004 	addi	r10,r10,2752
811329a0:	da802415 	stw	r10,144(sp)
811329a4:	200d883a 	mov	r6,r4
811329a8:	003c9106 	br	81131bf0 <__reset+0xfb111bf0>
811329ac:	5021883a 	mov	r16,r10
811329b0:	0013883a 	mov	r9,zero
811329b4:	003b7d06 	br	811317ac <__reset+0xfb1117ac>
811329b8:	4827883a 	mov	r19,r9
811329bc:	df001d83 	ldbu	fp,118(sp)
811329c0:	d8c02215 	stw	r3,136(sp)
811329c4:	0013883a 	mov	r9,zero
811329c8:	003c1806 	br	81131a2c <__reset+0xfb111a2c>
811329cc:	1829883a 	mov	r20,r3
811329d0:	003d1806 	br	81131e34 <__reset+0xfb111e34>
811329d4:	1829883a 	mov	r20,r3
811329d8:	003ccd06 	br	81131d10 <__reset+0xfb111d10>
811329dc:	0025883a 	mov	r18,zero
811329e0:	003fe906 	br	81132988 <__reset+0xfb112988>
811329e4:	d8802217 	ldw	r2,136(sp)
811329e8:	80c00043 	ldbu	r3,1(r16)
811329ec:	5021883a 	mov	r16,r10
811329f0:	12400017 	ldw	r9,0(r2)
811329f4:	10800104 	addi	r2,r2,4
811329f8:	d8802215 	stw	r2,136(sp)
811329fc:	483faf0e 	bge	r9,zero,811328bc <__reset+0xfb1128bc>
81132a00:	18c03fcc 	andi	r3,r3,255
81132a04:	18c0201c 	xori	r3,r3,128
81132a08:	027fffc4 	movi	r9,-1
81132a0c:	18ffe004 	addi	r3,r3,-128
81132a10:	003b6506 	br	811317a8 <__reset+0xfb1117a8>
81132a14:	d9c01d85 	stb	r7,118(sp)
81132a18:	003ca006 	br	81131c9c <__reset+0xfb111c9c>
81132a1c:	d9c01d85 	stb	r7,118(sp)
81132a20:	003cad06 	br	81131cd8 <__reset+0xfb111cd8>
81132a24:	d9c01d85 	stb	r7,118(sp)
81132a28:	003d7d06 	br	81132020 <__reset+0xfb112020>
81132a2c:	d9c01d85 	stb	r7,118(sp)
81132a30:	003d5f06 	br	81131fb0 <__reset+0xfb111fb0>
81132a34:	a080004c 	andi	r2,r20,1
81132a38:	0039883a 	mov	fp,zero
81132a3c:	10000526 	beq	r2,zero,81132a54 <___vfiprintf_internal_r+0x1430>
81132a40:	00800c04 	movi	r2,48
81132a44:	d88019c5 	stb	r2,103(sp)
81132a48:	dcc02717 	ldw	r19,156(sp)
81132a4c:	dd4019c4 	addi	r21,sp,103
81132a50:	003bf606 	br	81131a2c <__reset+0xfb111a2c>
81132a54:	0027883a 	mov	r19,zero
81132a58:	dd401a04 	addi	r21,sp,104
81132a5c:	003bf306 	br	81131a2c <__reset+0xfb111a2c>
81132a60:	d9c01d85 	stb	r7,118(sp)
81132a64:	003dc806 	br	81132188 <__reset+0xfb112188>
81132a68:	d9c01d85 	stb	r7,118(sp)
81132a6c:	003d3a06 	br	81131f58 <__reset+0xfb111f58>
81132a70:	d9c01d85 	stb	r7,118(sp)
81132a74:	003d2a06 	br	81131f20 <__reset+0xfb111f20>
81132a78:	d9c01d85 	stb	r7,118(sp)
81132a7c:	003cde06 	br	81131df8 <__reset+0xfb111df8>
81132a80:	d9c01d85 	stb	r7,118(sp)
81132a84:	003cbc06 	br	81131d78 <__reset+0xfb111d78>

81132a88 <__vfiprintf_internal>:
81132a88:	00a04574 	movhi	r2,33045
81132a8c:	108bed04 	addi	r2,r2,12212
81132a90:	300f883a 	mov	r7,r6
81132a94:	280d883a 	mov	r6,r5
81132a98:	200b883a 	mov	r5,r4
81132a9c:	11000017 	ldw	r4,0(r2)
81132aa0:	11316241 	jmpi	81131624 <___vfiprintf_internal_r>

81132aa4 <__sbprintf>:
81132aa4:	defee204 	addi	sp,sp,-1144
81132aa8:	de00012e 	bgeu	sp,et,81132ab0 <__sbprintf+0xc>
81132aac:	003b68fa 	trap	3
81132ab0:	2880030b 	ldhu	r2,12(r5)
81132ab4:	2ac01917 	ldw	r11,100(r5)
81132ab8:	2a80038b 	ldhu	r10,14(r5)
81132abc:	2a400717 	ldw	r9,28(r5)
81132ac0:	2a000917 	ldw	r8,36(r5)
81132ac4:	00c10004 	movi	r3,1024
81132ac8:	dc011a15 	stw	r16,1128(sp)
81132acc:	10bfff4c 	andi	r2,r2,65533
81132ad0:	2821883a 	mov	r16,r5
81132ad4:	d8cb883a 	add	r5,sp,r3
81132ad8:	dc811c15 	stw	r18,1136(sp)
81132adc:	dc411b15 	stw	r17,1132(sp)
81132ae0:	dfc11d15 	stw	ra,1140(sp)
81132ae4:	2025883a 	mov	r18,r4
81132ae8:	d881030d 	sth	r2,1036(sp)
81132aec:	dac11915 	stw	r11,1124(sp)
81132af0:	da81038d 	sth	r10,1038(sp)
81132af4:	da410715 	stw	r9,1052(sp)
81132af8:	da010915 	stw	r8,1060(sp)
81132afc:	dec10015 	stw	sp,1024(sp)
81132b00:	dec10415 	stw	sp,1040(sp)
81132b04:	d8c10215 	stw	r3,1032(sp)
81132b08:	d8c10515 	stw	r3,1044(sp)
81132b0c:	d8010615 	stw	zero,1048(sp)
81132b10:	11316240 	call	81131624 <___vfiprintf_internal_r>
81132b14:	1023883a 	mov	r17,r2
81132b18:	10000416 	blt	r2,zero,81132b2c <__sbprintf+0x88>
81132b1c:	d9410004 	addi	r5,sp,1024
81132b20:	9009883a 	mov	r4,r18
81132b24:	112b0c40 	call	8112b0c4 <_fflush_r>
81132b28:	10000d1e 	bne	r2,zero,81132b60 <__sbprintf+0xbc>
81132b2c:	d881030b 	ldhu	r2,1036(sp)
81132b30:	1080100c 	andi	r2,r2,64
81132b34:	10000326 	beq	r2,zero,81132b44 <__sbprintf+0xa0>
81132b38:	8080030b 	ldhu	r2,12(r16)
81132b3c:	10801014 	ori	r2,r2,64
81132b40:	8080030d 	sth	r2,12(r16)
81132b44:	8805883a 	mov	r2,r17
81132b48:	dfc11d17 	ldw	ra,1140(sp)
81132b4c:	dc811c17 	ldw	r18,1136(sp)
81132b50:	dc411b17 	ldw	r17,1132(sp)
81132b54:	dc011a17 	ldw	r16,1128(sp)
81132b58:	dec11e04 	addi	sp,sp,1144
81132b5c:	f800283a 	ret
81132b60:	047fffc4 	movi	r17,-1
81132b64:	003ff106 	br	81132b2c <__reset+0xfb112b2c>

81132b68 <_calloc_r>:
81132b68:	298b383a 	mul	r5,r5,r6
81132b6c:	defffe04 	addi	sp,sp,-8
81132b70:	de00012e 	bgeu	sp,et,81132b78 <_calloc_r+0x10>
81132b74:	003b68fa 	trap	3
81132b78:	dfc00115 	stw	ra,4(sp)
81132b7c:	dc000015 	stw	r16,0(sp)
81132b80:	1121be00 	call	81121be0 <_malloc_r>
81132b84:	10002926 	beq	r2,zero,81132c2c <_calloc_r+0xc4>
81132b88:	11bfff17 	ldw	r6,-4(r2)
81132b8c:	1021883a 	mov	r16,r2
81132b90:	00bfff04 	movi	r2,-4
81132b94:	308c703a 	and	r6,r6,r2
81132b98:	00c00904 	movi	r3,36
81132b9c:	308d883a 	add	r6,r6,r2
81132ba0:	19801636 	bltu	r3,r6,81132bfc <_calloc_r+0x94>
81132ba4:	008004c4 	movi	r2,19
81132ba8:	11800b2e 	bgeu	r2,r6,81132bd8 <_calloc_r+0x70>
81132bac:	80000015 	stw	zero,0(r16)
81132bb0:	80000115 	stw	zero,4(r16)
81132bb4:	008006c4 	movi	r2,27
81132bb8:	11801a2e 	bgeu	r2,r6,81132c24 <_calloc_r+0xbc>
81132bbc:	80000215 	stw	zero,8(r16)
81132bc0:	80000315 	stw	zero,12(r16)
81132bc4:	30c0151e 	bne	r6,r3,81132c1c <_calloc_r+0xb4>
81132bc8:	80000415 	stw	zero,16(r16)
81132bcc:	80800604 	addi	r2,r16,24
81132bd0:	80000515 	stw	zero,20(r16)
81132bd4:	00000106 	br	81132bdc <_calloc_r+0x74>
81132bd8:	8005883a 	mov	r2,r16
81132bdc:	10000015 	stw	zero,0(r2)
81132be0:	10000115 	stw	zero,4(r2)
81132be4:	10000215 	stw	zero,8(r2)
81132be8:	8005883a 	mov	r2,r16
81132bec:	dfc00117 	ldw	ra,4(sp)
81132bf0:	dc000017 	ldw	r16,0(sp)
81132bf4:	dec00204 	addi	sp,sp,8
81132bf8:	f800283a 	ret
81132bfc:	000b883a 	mov	r5,zero
81132c00:	8009883a 	mov	r4,r16
81132c04:	11225440 	call	81122544 <memset>
81132c08:	8005883a 	mov	r2,r16
81132c0c:	dfc00117 	ldw	ra,4(sp)
81132c10:	dc000017 	ldw	r16,0(sp)
81132c14:	dec00204 	addi	sp,sp,8
81132c18:	f800283a 	ret
81132c1c:	80800404 	addi	r2,r16,16
81132c20:	003fee06 	br	81132bdc <__reset+0xfb112bdc>
81132c24:	80800204 	addi	r2,r16,8
81132c28:	003fec06 	br	81132bdc <__reset+0xfb112bdc>
81132c2c:	0005883a 	mov	r2,zero
81132c30:	003fee06 	br	81132bec <__reset+0xfb112bec>

81132c34 <_fclose_r>:
81132c34:	28003b26 	beq	r5,zero,81132d24 <_fclose_r+0xf0>
81132c38:	defffc04 	addi	sp,sp,-16
81132c3c:	de00012e 	bgeu	sp,et,81132c44 <_fclose_r+0x10>
81132c40:	003b68fa 	trap	3
81132c44:	dc400115 	stw	r17,4(sp)
81132c48:	dc000015 	stw	r16,0(sp)
81132c4c:	dfc00315 	stw	ra,12(sp)
81132c50:	dc800215 	stw	r18,8(sp)
81132c54:	2023883a 	mov	r17,r4
81132c58:	2821883a 	mov	r16,r5
81132c5c:	20000226 	beq	r4,zero,81132c68 <_fclose_r+0x34>
81132c60:	20800e17 	ldw	r2,56(r4)
81132c64:	10002726 	beq	r2,zero,81132d04 <_fclose_r+0xd0>
81132c68:	8080030f 	ldh	r2,12(r16)
81132c6c:	1000071e 	bne	r2,zero,81132c8c <_fclose_r+0x58>
81132c70:	0005883a 	mov	r2,zero
81132c74:	dfc00317 	ldw	ra,12(sp)
81132c78:	dc800217 	ldw	r18,8(sp)
81132c7c:	dc400117 	ldw	r17,4(sp)
81132c80:	dc000017 	ldw	r16,0(sp)
81132c84:	dec00404 	addi	sp,sp,16
81132c88:	f800283a 	ret
81132c8c:	800b883a 	mov	r5,r16
81132c90:	8809883a 	mov	r4,r17
81132c94:	112aea00 	call	8112aea0 <__sflush_r>
81132c98:	1025883a 	mov	r18,r2
81132c9c:	80800b17 	ldw	r2,44(r16)
81132ca0:	10000426 	beq	r2,zero,81132cb4 <_fclose_r+0x80>
81132ca4:	81400717 	ldw	r5,28(r16)
81132ca8:	8809883a 	mov	r4,r17
81132cac:	103ee83a 	callr	r2
81132cb0:	10001616 	blt	r2,zero,81132d0c <_fclose_r+0xd8>
81132cb4:	8080030b 	ldhu	r2,12(r16)
81132cb8:	1080200c 	andi	r2,r2,128
81132cbc:	1000151e 	bne	r2,zero,81132d14 <_fclose_r+0xe0>
81132cc0:	81400c17 	ldw	r5,48(r16)
81132cc4:	28000526 	beq	r5,zero,81132cdc <_fclose_r+0xa8>
81132cc8:	80801004 	addi	r2,r16,64
81132ccc:	28800226 	beq	r5,r2,81132cd8 <_fclose_r+0xa4>
81132cd0:	8809883a 	mov	r4,r17
81132cd4:	112b9580 	call	8112b958 <_free_r>
81132cd8:	80000c15 	stw	zero,48(r16)
81132cdc:	81401117 	ldw	r5,68(r16)
81132ce0:	28000326 	beq	r5,zero,81132cf0 <_fclose_r+0xbc>
81132ce4:	8809883a 	mov	r4,r17
81132ce8:	112b9580 	call	8112b958 <_free_r>
81132cec:	80001115 	stw	zero,68(r16)
81132cf0:	112b4d00 	call	8112b4d0 <__sfp_lock_acquire>
81132cf4:	8000030d 	sth	zero,12(r16)
81132cf8:	112b4d40 	call	8112b4d4 <__sfp_lock_release>
81132cfc:	9005883a 	mov	r2,r18
81132d00:	003fdc06 	br	81132c74 <__reset+0xfb112c74>
81132d04:	112b4c00 	call	8112b4c0 <__sinit>
81132d08:	003fd706 	br	81132c68 <__reset+0xfb112c68>
81132d0c:	04bfffc4 	movi	r18,-1
81132d10:	003fe806 	br	81132cb4 <__reset+0xfb112cb4>
81132d14:	81400417 	ldw	r5,16(r16)
81132d18:	8809883a 	mov	r4,r17
81132d1c:	112b9580 	call	8112b958 <_free_r>
81132d20:	003fe706 	br	81132cc0 <__reset+0xfb112cc0>
81132d24:	0005883a 	mov	r2,zero
81132d28:	f800283a 	ret

81132d2c <fclose>:
81132d2c:	00a04574 	movhi	r2,33045
81132d30:	108bed04 	addi	r2,r2,12212
81132d34:	200b883a 	mov	r5,r4
81132d38:	11000017 	ldw	r4,0(r2)
81132d3c:	1132c341 	jmpi	81132c34 <_fclose_r>

81132d40 <__fputwc>:
81132d40:	defff804 	addi	sp,sp,-32
81132d44:	de00012e 	bgeu	sp,et,81132d4c <__fputwc+0xc>
81132d48:	003b68fa 	trap	3
81132d4c:	dcc00415 	stw	r19,16(sp)
81132d50:	dc800315 	stw	r18,12(sp)
81132d54:	dc000115 	stw	r16,4(sp)
81132d58:	dfc00715 	stw	ra,28(sp)
81132d5c:	dd400615 	stw	r21,24(sp)
81132d60:	dd000515 	stw	r20,20(sp)
81132d64:	dc400215 	stw	r17,8(sp)
81132d68:	2027883a 	mov	r19,r4
81132d6c:	2825883a 	mov	r18,r5
81132d70:	3021883a 	mov	r16,r6
81132d74:	112c3e80 	call	8112c3e8 <__locale_mb_cur_max>
81132d78:	00c00044 	movi	r3,1
81132d7c:	10c03e26 	beq	r2,r3,81132e78 <__fputwc+0x138>
81132d80:	81c01704 	addi	r7,r16,92
81132d84:	900d883a 	mov	r6,r18
81132d88:	d80b883a 	mov	r5,sp
81132d8c:	9809883a 	mov	r4,r19
81132d90:	1133bc40 	call	81133bc4 <_wcrtomb_r>
81132d94:	1029883a 	mov	r20,r2
81132d98:	00bfffc4 	movi	r2,-1
81132d9c:	a0802026 	beq	r20,r2,81132e20 <__fputwc+0xe0>
81132da0:	d9400003 	ldbu	r5,0(sp)
81132da4:	a0001c26 	beq	r20,zero,81132e18 <__fputwc+0xd8>
81132da8:	0023883a 	mov	r17,zero
81132dac:	05400284 	movi	r21,10
81132db0:	00000906 	br	81132dd8 <__fputwc+0x98>
81132db4:	80800017 	ldw	r2,0(r16)
81132db8:	11400005 	stb	r5,0(r2)
81132dbc:	80c00017 	ldw	r3,0(r16)
81132dc0:	18c00044 	addi	r3,r3,1
81132dc4:	80c00015 	stw	r3,0(r16)
81132dc8:	8c400044 	addi	r17,r17,1
81132dcc:	dc45883a 	add	r2,sp,r17
81132dd0:	8d00112e 	bgeu	r17,r20,81132e18 <__fputwc+0xd8>
81132dd4:	11400003 	ldbu	r5,0(r2)
81132dd8:	80c00217 	ldw	r3,8(r16)
81132ddc:	18ffffc4 	addi	r3,r3,-1
81132de0:	80c00215 	stw	r3,8(r16)
81132de4:	183ff30e 	bge	r3,zero,81132db4 <__reset+0xfb112db4>
81132de8:	80800617 	ldw	r2,24(r16)
81132dec:	18801916 	blt	r3,r2,81132e54 <__fputwc+0x114>
81132df0:	80800017 	ldw	r2,0(r16)
81132df4:	11400005 	stb	r5,0(r2)
81132df8:	80800017 	ldw	r2,0(r16)
81132dfc:	10c00003 	ldbu	r3,0(r2)
81132e00:	10800044 	addi	r2,r2,1
81132e04:	1d402326 	beq	r3,r21,81132e94 <__fputwc+0x154>
81132e08:	80800015 	stw	r2,0(r16)
81132e0c:	8c400044 	addi	r17,r17,1
81132e10:	dc45883a 	add	r2,sp,r17
81132e14:	8d3fef36 	bltu	r17,r20,81132dd4 <__reset+0xfb112dd4>
81132e18:	9005883a 	mov	r2,r18
81132e1c:	00000406 	br	81132e30 <__fputwc+0xf0>
81132e20:	80c0030b 	ldhu	r3,12(r16)
81132e24:	a005883a 	mov	r2,r20
81132e28:	18c01014 	ori	r3,r3,64
81132e2c:	80c0030d 	sth	r3,12(r16)
81132e30:	dfc00717 	ldw	ra,28(sp)
81132e34:	dd400617 	ldw	r21,24(sp)
81132e38:	dd000517 	ldw	r20,20(sp)
81132e3c:	dcc00417 	ldw	r19,16(sp)
81132e40:	dc800317 	ldw	r18,12(sp)
81132e44:	dc400217 	ldw	r17,8(sp)
81132e48:	dc000117 	ldw	r16,4(sp)
81132e4c:	dec00804 	addi	sp,sp,32
81132e50:	f800283a 	ret
81132e54:	800d883a 	mov	r6,r16
81132e58:	29403fcc 	andi	r5,r5,255
81132e5c:	9809883a 	mov	r4,r19
81132e60:	11292880 	call	81129288 <__swbuf_r>
81132e64:	10bfffe0 	cmpeqi	r2,r2,-1
81132e68:	10803fcc 	andi	r2,r2,255
81132e6c:	103fd626 	beq	r2,zero,81132dc8 <__reset+0xfb112dc8>
81132e70:	00bfffc4 	movi	r2,-1
81132e74:	003fee06 	br	81132e30 <__reset+0xfb112e30>
81132e78:	90ffffc4 	addi	r3,r18,-1
81132e7c:	01003f84 	movi	r4,254
81132e80:	20ffbf36 	bltu	r4,r3,81132d80 <__reset+0xfb112d80>
81132e84:	900b883a 	mov	r5,r18
81132e88:	dc800005 	stb	r18,0(sp)
81132e8c:	1029883a 	mov	r20,r2
81132e90:	003fc506 	br	81132da8 <__reset+0xfb112da8>
81132e94:	800d883a 	mov	r6,r16
81132e98:	a80b883a 	mov	r5,r21
81132e9c:	9809883a 	mov	r4,r19
81132ea0:	11292880 	call	81129288 <__swbuf_r>
81132ea4:	10bfffe0 	cmpeqi	r2,r2,-1
81132ea8:	003fef06 	br	81132e68 <__reset+0xfb112e68>

81132eac <_fputwc_r>:
81132eac:	3080030b 	ldhu	r2,12(r6)
81132eb0:	10c8000c 	andi	r3,r2,8192
81132eb4:	1800051e 	bne	r3,zero,81132ecc <_fputwc_r+0x20>
81132eb8:	30c01917 	ldw	r3,100(r6)
81132ebc:	10880014 	ori	r2,r2,8192
81132ec0:	3080030d 	sth	r2,12(r6)
81132ec4:	18880014 	ori	r2,r3,8192
81132ec8:	30801915 	stw	r2,100(r6)
81132ecc:	1132d401 	jmpi	81132d40 <__fputwc>

81132ed0 <fputwc>:
81132ed0:	00a04574 	movhi	r2,33045
81132ed4:	defffc04 	addi	sp,sp,-16
81132ed8:	108bed04 	addi	r2,r2,12212
81132edc:	de00012e 	bgeu	sp,et,81132ee4 <fputwc+0x14>
81132ee0:	003b68fa 	trap	3
81132ee4:	dc000115 	stw	r16,4(sp)
81132ee8:	14000017 	ldw	r16,0(r2)
81132eec:	dc400215 	stw	r17,8(sp)
81132ef0:	dfc00315 	stw	ra,12(sp)
81132ef4:	2023883a 	mov	r17,r4
81132ef8:	80000226 	beq	r16,zero,81132f04 <fputwc+0x34>
81132efc:	80800e17 	ldw	r2,56(r16)
81132f00:	10001026 	beq	r2,zero,81132f44 <fputwc+0x74>
81132f04:	2880030b 	ldhu	r2,12(r5)
81132f08:	10c8000c 	andi	r3,r2,8192
81132f0c:	1800051e 	bne	r3,zero,81132f24 <fputwc+0x54>
81132f10:	28c01917 	ldw	r3,100(r5)
81132f14:	10880014 	ori	r2,r2,8192
81132f18:	2880030d 	sth	r2,12(r5)
81132f1c:	18880014 	ori	r2,r3,8192
81132f20:	28801915 	stw	r2,100(r5)
81132f24:	280d883a 	mov	r6,r5
81132f28:	8009883a 	mov	r4,r16
81132f2c:	880b883a 	mov	r5,r17
81132f30:	dfc00317 	ldw	ra,12(sp)
81132f34:	dc400217 	ldw	r17,8(sp)
81132f38:	dc000117 	ldw	r16,4(sp)
81132f3c:	dec00404 	addi	sp,sp,16
81132f40:	1132d401 	jmpi	81132d40 <__fputwc>
81132f44:	8009883a 	mov	r4,r16
81132f48:	d9400015 	stw	r5,0(sp)
81132f4c:	112b4c00 	call	8112b4c0 <__sinit>
81132f50:	d9400017 	ldw	r5,0(sp)
81132f54:	003feb06 	br	81132f04 <__reset+0xfb112f04>

81132f58 <rshift>:
81132f58:	2807d17a 	srai	r3,r5,5
81132f5c:	20800417 	ldw	r2,16(r4)
81132f60:	22000504 	addi	r8,r4,20
81132f64:	1880250e 	bge	r3,r2,81132ffc <rshift+0xa4>
81132f68:	1085883a 	add	r2,r2,r2
81132f6c:	18c7883a 	add	r3,r3,r3
81132f70:	1085883a 	add	r2,r2,r2
81132f74:	18c7883a 	add	r3,r3,r3
81132f78:	294007cc 	andi	r5,r5,31
81132f7c:	4085883a 	add	r2,r8,r2
81132f80:	40c7883a 	add	r3,r8,r3
81132f84:	28002026 	beq	r5,zero,81133008 <rshift+0xb0>
81132f88:	19800017 	ldw	r6,0(r3)
81132f8c:	02c00804 	movi	r11,32
81132f90:	19c00104 	addi	r7,r3,4
81132f94:	5957c83a 	sub	r11,r11,r5
81132f98:	314cd83a 	srl	r6,r6,r5
81132f9c:	38802c2e 	bgeu	r7,r2,81133050 <rshift+0xf8>
81132fa0:	4015883a 	mov	r10,r8
81132fa4:	3a400017 	ldw	r9,0(r7)
81132fa8:	52800104 	addi	r10,r10,4
81132fac:	39c00104 	addi	r7,r7,4
81132fb0:	4ad2983a 	sll	r9,r9,r11
81132fb4:	498cb03a 	or	r6,r9,r6
81132fb8:	51bfff15 	stw	r6,-4(r10)
81132fbc:	39bfff17 	ldw	r6,-4(r7)
81132fc0:	314cd83a 	srl	r6,r6,r5
81132fc4:	38bff736 	bltu	r7,r2,81132fa4 <__reset+0xfb112fa4>
81132fc8:	10c7c83a 	sub	r3,r2,r3
81132fcc:	18fffec4 	addi	r3,r3,-5
81132fd0:	1806d0ba 	srli	r3,r3,2
81132fd4:	18c00044 	addi	r3,r3,1
81132fd8:	18c7883a 	add	r3,r3,r3
81132fdc:	18c7883a 	add	r3,r3,r3
81132fe0:	40c7883a 	add	r3,r8,r3
81132fe4:	19800015 	stw	r6,0(r3)
81132fe8:	30000126 	beq	r6,zero,81132ff0 <rshift+0x98>
81132fec:	18c00104 	addi	r3,r3,4
81132ff0:	1a05c83a 	sub	r2,r3,r8
81132ff4:	1005d0ba 	srai	r2,r2,2
81132ff8:	00001206 	br	81133044 <rshift+0xec>
81132ffc:	20000415 	stw	zero,16(r4)
81133000:	20000515 	stw	zero,20(r4)
81133004:	f800283a 	ret
81133008:	18bffc2e 	bgeu	r3,r2,81132ffc <__reset+0xfb112ffc>
8113300c:	180d883a 	mov	r6,r3
81133010:	400b883a 	mov	r5,r8
81133014:	31c00017 	ldw	r7,0(r6)
81133018:	29400104 	addi	r5,r5,4
8113301c:	31800104 	addi	r6,r6,4
81133020:	29ffff15 	stw	r7,-4(r5)
81133024:	30bffb36 	bltu	r6,r2,81133014 <__reset+0xfb113014>
81133028:	00c6303a 	nor	r3,zero,r3
8113302c:	1885883a 	add	r2,r3,r2
81133030:	1004d0ba 	srli	r2,r2,2
81133034:	10800044 	addi	r2,r2,1
81133038:	1085883a 	add	r2,r2,r2
8113303c:	1085883a 	add	r2,r2,r2
81133040:	1005d0ba 	srai	r2,r2,2
81133044:	20800415 	stw	r2,16(r4)
81133048:	103fed26 	beq	r2,zero,81133000 <__reset+0xfb113000>
8113304c:	f800283a 	ret
81133050:	4007883a 	mov	r3,r8
81133054:	003fe306 	br	81132fe4 <__reset+0xfb112fe4>

81133058 <__gethex>:
81133058:	deffeb04 	addi	sp,sp,-84
8113305c:	de00012e 	bgeu	sp,et,81133064 <__gethex+0xc>
81133060:	003b68fa 	trap	3
81133064:	dfc01415 	stw	ra,80(sp)
81133068:	dd801115 	stw	r22,68(sp)
8113306c:	dcc00e15 	stw	r19,56(sp)
81133070:	dc800d15 	stw	r18,52(sp)
81133074:	2827883a 	mov	r19,r5
81133078:	d9000115 	stw	r4,4(sp)
8113307c:	d9800015 	stw	r6,0(sp)
81133080:	d9c00415 	stw	r7,16(sp)
81133084:	df001315 	stw	fp,76(sp)
81133088:	ddc01215 	stw	r23,72(sp)
8113308c:	dd401015 	stw	r21,64(sp)
81133090:	dd000f15 	stw	r20,60(sp)
81133094:	dc400c15 	stw	r17,48(sp)
81133098:	dc000b15 	stw	r16,44(sp)
8113309c:	112c40c0 	call	8112c40c <_localeconv_r>
811330a0:	14800017 	ldw	r18,0(r2)
811330a4:	9009883a 	mov	r4,r18
811330a8:	1122ee80 	call	81122ee8 <strlen>
811330ac:	98c00017 	ldw	r3,0(r19)
811330b0:	102d883a 	mov	r22,r2
811330b4:	9085883a 	add	r2,r18,r2
811330b8:	10bfffc3 	ldbu	r2,-1(r2)
811330bc:	19000083 	ldbu	r4,2(r3)
811330c0:	d8800305 	stb	r2,12(sp)
811330c4:	00800c04 	movi	r2,48
811330c8:	2081521e 	bne	r4,r2,81133614 <__gethex+0x5bc>
811330cc:	017fff84 	movi	r5,-2
811330d0:	188000c4 	addi	r2,r3,3
811330d4:	28cbc83a 	sub	r5,r5,r3
811330d8:	200d883a 	mov	r6,r4
811330dc:	28a3883a 	add	r17,r5,r2
811330e0:	102b883a 	mov	r21,r2
811330e4:	10800044 	addi	r2,r2,1
811330e8:	113fffc3 	ldbu	r4,-1(r2)
811330ec:	21bffb26 	beq	r4,r6,811330dc <__reset+0xfb1130dc>
811330f0:	05204574 	movhi	r20,33045
811330f4:	a502b804 	addi	r20,r20,2784
811330f8:	a109883a 	add	r4,r20,r4
811330fc:	20800003 	ldbu	r2,0(r4)
81133100:	10008826 	beq	r2,zero,81133324 <__gethex+0x2cc>
81133104:	a8800003 	ldbu	r2,0(r21)
81133108:	0015883a 	mov	r10,zero
8113310c:	002f883a 	mov	r23,zero
81133110:	a085883a 	add	r2,r20,r2
81133114:	10800003 	ldbu	r2,0(r2)
81133118:	a821883a 	mov	r16,r21
8113311c:	10000526 	beq	r2,zero,81133134 <__gethex+0xdc>
81133120:	84000044 	addi	r16,r16,1
81133124:	80800003 	ldbu	r2,0(r16)
81133128:	a085883a 	add	r2,r20,r2
8113312c:	10800003 	ldbu	r2,0(r2)
81133130:	103ffb1e 	bne	r2,zero,81133120 <__reset+0xfb113120>
81133134:	b00d883a 	mov	r6,r22
81133138:	900b883a 	mov	r5,r18
8113313c:	8009883a 	mov	r4,r16
81133140:	da800a15 	stw	r10,40(sp)
81133144:	1133af40 	call	81133af4 <strncmp>
81133148:	da800a17 	ldw	r10,40(sp)
8113314c:	1000031e 	bne	r2,zero,8113315c <__gethex+0x104>
81133150:	b8015226 	beq	r23,zero,8113369c <__gethex+0x644>
81133154:	80800003 	ldbu	r2,0(r16)
81133158:	00000206 	br	81133164 <__gethex+0x10c>
8113315c:	80800003 	ldbu	r2,0(r16)
81133160:	b8011f26 	beq	r23,zero,811335e0 <__gethex+0x588>
81133164:	85efc83a 	sub	r23,r16,r23
81133168:	bdef883a 	add	r23,r23,r23
8113316c:	bdef883a 	add	r23,r23,r23
81133170:	05efc83a 	sub	r23,zero,r23
81133174:	10803fcc 	andi	r2,r2,255
81133178:	01001404 	movi	r4,80
8113317c:	11008626 	beq	r2,r4,81133398 <__gethex+0x340>
81133180:	01001c04 	movi	r4,112
81133184:	11008426 	beq	r2,r4,81133398 <__gethex+0x340>
81133188:	8039883a 	mov	fp,r16
8113318c:	9c000015 	stw	r16,0(r19)
81133190:	5000711e 	bne	r10,zero,81133358 <__gethex+0x300>
81133194:	e545c83a 	sub	r2,fp,r21
81133198:	10bfffc4 	addi	r2,r2,-1
8113319c:	010001c4 	movi	r4,7
811331a0:	000b883a 	mov	r5,zero
811331a4:	2080030e 	bge	r4,r2,811331b4 <__gethex+0x15c>
811331a8:	1005d07a 	srai	r2,r2,1
811331ac:	29400044 	addi	r5,r5,1
811331b0:	20bffd16 	blt	r4,r2,811331a8 <__reset+0xfb1131a8>
811331b4:	d9000117 	ldw	r4,4(sp)
811331b8:	112c9280 	call	8112c928 <_Balloc>
811331bc:	10c00504 	addi	r3,r2,20
811331c0:	d8c00215 	stw	r3,8(sp)
811331c4:	1021883a 	mov	r16,r2
811331c8:	af01732e 	bgeu	r21,fp,81133798 <__gethex+0x740>
811331cc:	dc400303 	ldbu	r17,12(sp)
811331d0:	03400044 	movi	r13,1
811331d4:	1815883a 	mov	r10,r3
811331d8:	0013883a 	mov	r9,zero
811331dc:	0027883a 	mov	r19,zero
811331e0:	6d9bc83a 	sub	r13,r13,r22
811331e4:	02c00804 	movi	r11,32
811331e8:	e0bfffc3 	ldbu	r2,-1(fp)
811331ec:	e3bfffc4 	addi	r14,fp,-1
811331f0:	88803026 	beq	r17,r2,811332b4 <__gethex+0x25c>
811331f4:	9ac04526 	beq	r19,r11,8113330c <__gethex+0x2b4>
811331f8:	980b883a 	mov	r5,r19
811331fc:	9cc00104 	addi	r19,r19,4
81133200:	e13fffc3 	ldbu	r4,-1(fp)
81133204:	7039883a 	mov	fp,r14
81133208:	a109883a 	add	r4,r20,r4
8113320c:	20800003 	ldbu	r2,0(r4)
81133210:	108003cc 	andi	r2,r2,15
81133214:	1144983a 	sll	r2,r2,r5
81133218:	4892b03a 	or	r9,r9,r2
8113321c:	af3ff236 	bltu	r21,fp,811331e8 <__reset+0xfb1131e8>
81133220:	d8c00217 	ldw	r3,8(sp)
81133224:	50800104 	addi	r2,r10,4
81133228:	52400015 	stw	r9,0(r10)
8113322c:	10c5c83a 	sub	r2,r2,r3
81133230:	1005d0ba 	srai	r2,r2,2
81133234:	4809883a 	mov	r4,r9
81133238:	80800415 	stw	r2,16(r16)
8113323c:	1022917a 	slli	r17,r2,5
81133240:	112cc340 	call	8112cc34 <__hi0bits>
81133244:	d8c00017 	ldw	r3,0(sp)
81133248:	8885c83a 	sub	r2,r17,r2
8113324c:	1c800017 	ldw	r18,0(r3)
81133250:	9080c716 	blt	r18,r2,81133570 <__gethex+0x518>
81133254:	1480e416 	blt	r2,r18,811335e8 <__gethex+0x590>
81133258:	0027883a 	mov	r19,zero
8113325c:	d8c00017 	ldw	r3,0(sp)
81133260:	18800217 	ldw	r2,8(r3)
81133264:	15c08d16 	blt	r2,r23,8113349c <__gethex+0x444>
81133268:	d8c00017 	ldw	r3,0(sp)
8113326c:	18800117 	ldw	r2,4(r3)
81133270:	b880aa0e 	bge	r23,r2,8113351c <__gethex+0x4c4>
81133274:	15efc83a 	sub	r23,r2,r23
81133278:	bc80ed16 	blt	r23,r18,81133630 <__gethex+0x5d8>
8113327c:	18c00317 	ldw	r3,12(r3)
81133280:	01000084 	movi	r4,2
81133284:	19014926 	beq	r3,r4,811337ac <__gethex+0x754>
81133288:	010000c4 	movi	r4,3
8113328c:	19012e26 	beq	r3,r4,81133748 <__gethex+0x6f0>
81133290:	01000044 	movi	r4,1
81133294:	19014826 	beq	r3,r4,811337b8 <__gethex+0x760>
81133298:	d9000117 	ldw	r4,4(sp)
8113329c:	800b883a 	mov	r5,r16
811332a0:	112c9d80 	call	8112c9d8 <_Bfree>
811332a4:	d8801517 	ldw	r2,84(sp)
811332a8:	10000015 	stw	zero,0(r2)
811332ac:	00801404 	movi	r2,80
811332b0:	00002b06 	br	81133360 <__gethex+0x308>
811332b4:	735f883a 	add	r15,r14,r13
811332b8:	7d7fce36 	bltu	r15,r21,811331f4 <__reset+0xfb1131f4>
811332bc:	7809883a 	mov	r4,r15
811332c0:	b00d883a 	mov	r6,r22
811332c4:	900b883a 	mov	r5,r18
811332c8:	da400515 	stw	r9,20(sp)
811332cc:	da800a15 	stw	r10,40(sp)
811332d0:	dac00915 	stw	r11,36(sp)
811332d4:	db400815 	stw	r13,32(sp)
811332d8:	db800615 	stw	r14,24(sp)
811332dc:	dbc00715 	stw	r15,28(sp)
811332e0:	1133af40 	call	81133af4 <strncmp>
811332e4:	da400517 	ldw	r9,20(sp)
811332e8:	da800a17 	ldw	r10,40(sp)
811332ec:	dac00917 	ldw	r11,36(sp)
811332f0:	db400817 	ldw	r13,32(sp)
811332f4:	db800617 	ldw	r14,24(sp)
811332f8:	dbc00717 	ldw	r15,28(sp)
811332fc:	103fbd1e 	bne	r2,zero,811331f4 <__reset+0xfb1131f4>
81133300:	7839883a 	mov	fp,r15
81133304:	af3fb836 	bltu	r21,fp,811331e8 <__reset+0xfb1131e8>
81133308:	003fc506 	br	81133220 <__reset+0xfb113220>
8113330c:	04c00104 	movi	r19,4
81133310:	52400015 	stw	r9,0(r10)
81133314:	000b883a 	mov	r5,zero
81133318:	54d5883a 	add	r10,r10,r19
8113331c:	0013883a 	mov	r9,zero
81133320:	003fb706 	br	81133200 <__reset+0xfb113200>
81133324:	b00d883a 	mov	r6,r22
81133328:	900b883a 	mov	r5,r18
8113332c:	a809883a 	mov	r4,r21
81133330:	1133af40 	call	81133af4 <strncmp>
81133334:	10006426 	beq	r2,zero,811334c8 <__gethex+0x470>
81133338:	a8800003 	ldbu	r2,0(r21)
8113333c:	a821883a 	mov	r16,r21
81133340:	10803fcc 	andi	r2,r2,255
81133344:	01001404 	movi	r4,80
81133348:	11001126 	beq	r2,r4,81133390 <__gethex+0x338>
8113334c:	01001c04 	movi	r4,112
81133350:	11000f26 	beq	r2,r4,81133390 <__gethex+0x338>
81133354:	9c000015 	stw	r16,0(r19)
81133358:	8800831e 	bne	r17,zero,81133568 <__gethex+0x510>
8113335c:	00800184 	movi	r2,6
81133360:	dfc01417 	ldw	ra,80(sp)
81133364:	df001317 	ldw	fp,76(sp)
81133368:	ddc01217 	ldw	r23,72(sp)
8113336c:	dd801117 	ldw	r22,68(sp)
81133370:	dd401017 	ldw	r21,64(sp)
81133374:	dd000f17 	ldw	r20,60(sp)
81133378:	dcc00e17 	ldw	r19,56(sp)
8113337c:	dc800d17 	ldw	r18,52(sp)
81133380:	dc400c17 	ldw	r17,48(sp)
81133384:	dc000b17 	ldw	r16,44(sp)
81133388:	dec01504 	addi	sp,sp,84
8113338c:	f800283a 	ret
81133390:	002f883a 	mov	r23,zero
81133394:	02800044 	movi	r10,1
81133398:	80800043 	ldbu	r2,1(r16)
8113339c:	01400ac4 	movi	r5,43
811333a0:	11003fcc 	andi	r4,r2,255
811333a4:	21406e26 	beq	r4,r5,81133560 <__gethex+0x508>
811333a8:	01400b44 	movi	r5,45
811333ac:	21404226 	beq	r4,r5,811334b8 <__gethex+0x460>
811333b0:	81400044 	addi	r5,r16,1
811333b4:	000d883a 	mov	r6,zero
811333b8:	10803fcc 	andi	r2,r2,255
811333bc:	a085883a 	add	r2,r20,r2
811333c0:	11000003 	ldbu	r4,0(r2)
811333c4:	03000604 	movi	r12,24
811333c8:	20bfffc4 	addi	r2,r4,-1
811333cc:	10803fcc 	andi	r2,r2,255
811333d0:	60bf6d36 	bltu	r12,r2,81133188 <__reset+0xfb113188>
811333d4:	2ac00043 	ldbu	r11,1(r5)
811333d8:	20803fcc 	andi	r2,r4,255
811333dc:	01204574 	movhi	r4,33045
811333e0:	2102b804 	addi	r4,r4,2784
811333e4:	22c9883a 	add	r4,r4,r11
811333e8:	23400003 	ldbu	r13,0(r4)
811333ec:	10bffc04 	addi	r2,r2,-16
811333f0:	29400044 	addi	r5,r5,1
811333f4:	693fffc4 	addi	r4,r13,-1
811333f8:	21003fcc 	andi	r4,r4,255
811333fc:	6b403fcc 	andi	r13,r13,255
81133400:	61000b36 	bltu	r12,r4,81133430 <__gethex+0x3d8>
81133404:	29400044 	addi	r5,r5,1
81133408:	29000003 	ldbu	r4,0(r5)
8113340c:	108002a4 	muli	r2,r2,10
81133410:	a109883a 	add	r4,r20,r4
81133414:	22c00003 	ldbu	r11,0(r4)
81133418:	1345883a 	add	r2,r2,r13
8113341c:	10bffc04 	addi	r2,r2,-16
81133420:	593fffc4 	addi	r4,r11,-1
81133424:	21003fcc 	andi	r4,r4,255
81133428:	5b403fcc 	andi	r13,r11,255
8113342c:	613ff52e 	bgeu	r12,r4,81133404 <__reset+0xfb113404>
81133430:	30000126 	beq	r6,zero,81133438 <__gethex+0x3e0>
81133434:	0085c83a 	sub	r2,zero,r2
81133438:	8039883a 	mov	fp,r16
8113343c:	b8af883a 	add	r23,r23,r2
81133440:	2821883a 	mov	r16,r5
81133444:	003f5106 	br	8113318c <__reset+0xfb11318c>
81133448:	80800217 	ldw	r2,8(r16)
8113344c:	e080f00e 	bge	fp,r2,81133810 <__gethex+0x7b8>
81133450:	e007883a 	mov	r3,fp
81133454:	18800144 	addi	r2,r3,5
81133458:	1085883a 	add	r2,r2,r2
8113345c:	18c00044 	addi	r3,r3,1
81133460:	1085883a 	add	r2,r2,r2
81133464:	8085883a 	add	r2,r16,r2
81133468:	80c00415 	stw	r3,16(r16)
8113346c:	01000044 	movi	r4,1
81133470:	11000015 	stw	r4,0(r2)
81133474:	00800084 	movi	r2,2
81133478:	8880d826 	beq	r17,r2,811337dc <__gethex+0x784>
8113347c:	e0c0ac0e 	bge	fp,r3,81133730 <__gethex+0x6d8>
81133480:	01400044 	movi	r5,1
81133484:	8009883a 	mov	r4,r16
81133488:	1132f580 	call	81132f58 <rshift>
8113348c:	d8c00017 	ldw	r3,0(sp)
81133490:	bdc00044 	addi	r23,r23,1
81133494:	18800217 	ldw	r2,8(r3)
81133498:	15c0a70e 	bge	r2,r23,81133738 <__gethex+0x6e0>
8113349c:	d9000117 	ldw	r4,4(sp)
811334a0:	800b883a 	mov	r5,r16
811334a4:	112c9d80 	call	8112c9d8 <_Bfree>
811334a8:	d9001517 	ldw	r4,84(sp)
811334ac:	008028c4 	movi	r2,163
811334b0:	20000015 	stw	zero,0(r4)
811334b4:	003faa06 	br	81133360 <__reset+0xfb113360>
811334b8:	01800044 	movi	r6,1
811334bc:	80800083 	ldbu	r2,2(r16)
811334c0:	81400084 	addi	r5,r16,2
811334c4:	003fbc06 	br	811333b8 <__reset+0xfb1133b8>
811334c8:	ada1883a 	add	r16,r21,r22
811334cc:	81000003 	ldbu	r4,0(r16)
811334d0:	21403fcc 	andi	r5,r4,255
811334d4:	a145883a 	add	r2,r20,r5
811334d8:	10800003 	ldbu	r2,0(r2)
811334dc:	11803fcc 	andi	r6,r2,255
811334e0:	30004f26 	beq	r6,zero,81133620 <__gethex+0x5c8>
811334e4:	00c00c04 	movi	r3,48
811334e8:	802b883a 	mov	r21,r16
811334ec:	28c0061e 	bne	r5,r3,81133508 <__gethex+0x4b0>
811334f0:	2809883a 	mov	r4,r5
811334f4:	ad400044 	addi	r21,r21,1
811334f8:	a8800003 	ldbu	r2,0(r21)
811334fc:	113ffd26 	beq	r2,r4,811334f4 <__reset+0xfb1134f4>
81133500:	a085883a 	add	r2,r20,r2
81133504:	10800003 	ldbu	r2,0(r2)
81133508:	10803fcc 	andi	r2,r2,255
8113350c:	1015003a 	cmpeq	r10,r2,zero
81133510:	802f883a 	mov	r23,r16
81133514:	04400044 	movi	r17,1
81133518:	003eff06 	br	81133118 <__reset+0xfb113118>
8113351c:	04400044 	movi	r17,1
81133520:	98000926 	beq	r19,zero,81133548 <__gethex+0x4f0>
81133524:	d8c00017 	ldw	r3,0(sp)
81133528:	18800317 	ldw	r2,12(r3)
8113352c:	00c00084 	movi	r3,2
81133530:	10c06826 	beq	r2,r3,811336d4 <__gethex+0x67c>
81133534:	00c000c4 	movi	r3,3
81133538:	10c06a26 	beq	r2,r3,811336e4 <__gethex+0x68c>
8113353c:	00c00044 	movi	r3,1
81133540:	10c08d26 	beq	r2,r3,81133778 <__gethex+0x720>
81133544:	8c400414 	ori	r17,r17,16
81133548:	d9001517 	ldw	r4,84(sp)
8113354c:	d8c00417 	ldw	r3,16(sp)
81133550:	8805883a 	mov	r2,r17
81133554:	24000015 	stw	r16,0(r4)
81133558:	1dc00015 	stw	r23,0(r3)
8113355c:	003f8006 	br	81133360 <__reset+0xfb113360>
81133560:	000d883a 	mov	r6,zero
81133564:	003fd506 	br	811334bc <__reset+0xfb1134bc>
81133568:	0005883a 	mov	r2,zero
8113356c:	003f7c06 	br	81133360 <__reset+0xfb113360>
81133570:	14a3c83a 	sub	r17,r2,r18
81133574:	880b883a 	mov	r5,r17
81133578:	8009883a 	mov	r4,r16
8113357c:	112d8f80 	call	8112d8f8 <__any_on>
81133580:	10002926 	beq	r2,zero,81133628 <__gethex+0x5d0>
81133584:	897fffc4 	addi	r5,r17,-1
81133588:	2807d17a 	srai	r3,r5,5
8113358c:	d8800217 	ldw	r2,8(sp)
81133590:	290007cc 	andi	r4,r5,31
81133594:	18c7883a 	add	r3,r3,r3
81133598:	18c7883a 	add	r3,r3,r3
8113359c:	04c00044 	movi	r19,1
811335a0:	10c7883a 	add	r3,r2,r3
811335a4:	9908983a 	sll	r4,r19,r4
811335a8:	18c00017 	ldw	r3,0(r3)
811335ac:	20c6703a 	and	r3,r4,r3
811335b0:	18000626 	beq	r3,zero,811335cc <__gethex+0x574>
811335b4:	99407b0e 	bge	r19,r5,811337a4 <__gethex+0x74c>
811335b8:	897fff84 	addi	r5,r17,-2
811335bc:	8009883a 	mov	r4,r16
811335c0:	112d8f80 	call	8112d8f8 <__any_on>
811335c4:	10007726 	beq	r2,zero,811337a4 <__gethex+0x74c>
811335c8:	04c000c4 	movi	r19,3
811335cc:	880b883a 	mov	r5,r17
811335d0:	8009883a 	mov	r4,r16
811335d4:	1132f580 	call	81132f58 <rshift>
811335d8:	bc6f883a 	add	r23,r23,r17
811335dc:	003f1f06 	br	8113325c <__reset+0xfb11325c>
811335e0:	002f883a 	mov	r23,zero
811335e4:	003ee306 	br	81133174 <__reset+0xfb113174>
811335e8:	d9000117 	ldw	r4,4(sp)
811335ec:	90a3c83a 	sub	r17,r18,r2
811335f0:	800b883a 	mov	r5,r16
811335f4:	880d883a 	mov	r6,r17
811335f8:	112d0d80 	call	8112d0d8 <__lshift>
811335fc:	10c00504 	addi	r3,r2,20
81133600:	1021883a 	mov	r16,r2
81133604:	bc6fc83a 	sub	r23,r23,r17
81133608:	d8c00215 	stw	r3,8(sp)
8113360c:	0027883a 	mov	r19,zero
81133610:	003f1206 	br	8113325c <__reset+0xfb11325c>
81133614:	1d400084 	addi	r21,r3,2
81133618:	0023883a 	mov	r17,zero
8113361c:	003eb406 	br	811330f0 <__reset+0xfb1130f0>
81133620:	2005883a 	mov	r2,r4
81133624:	003f4606 	br	81133340 <__reset+0xfb113340>
81133628:	0027883a 	mov	r19,zero
8113362c:	003fe706 	br	811335cc <__reset+0xfb1135cc>
81133630:	bc7fffc4 	addi	r17,r23,-1
81133634:	9800421e 	bne	r19,zero,81133740 <__gethex+0x6e8>
81133638:	88000426 	beq	r17,zero,8113364c <__gethex+0x5f4>
8113363c:	880b883a 	mov	r5,r17
81133640:	8009883a 	mov	r4,r16
81133644:	112d8f80 	call	8112d8f8 <__any_on>
81133648:	1027883a 	mov	r19,r2
8113364c:	8805d17a 	srai	r2,r17,5
81133650:	d8c00217 	ldw	r3,8(sp)
81133654:	8c4007cc 	andi	r17,r17,31
81133658:	1085883a 	add	r2,r2,r2
8113365c:	1085883a 	add	r2,r2,r2
81133660:	1885883a 	add	r2,r3,r2
81133664:	00c00044 	movi	r3,1
81133668:	1c62983a 	sll	r17,r3,r17
8113366c:	10800017 	ldw	r2,0(r2)
81133670:	8884703a 	and	r2,r17,r2
81133674:	10000126 	beq	r2,zero,8113367c <__gethex+0x624>
81133678:	9cc00094 	ori	r19,r19,2
8113367c:	b80b883a 	mov	r5,r23
81133680:	8009883a 	mov	r4,r16
81133684:	1132f580 	call	81132f58 <rshift>
81133688:	d8c00017 	ldw	r3,0(sp)
8113368c:	95e5c83a 	sub	r18,r18,r23
81133690:	04400084 	movi	r17,2
81133694:	1dc00117 	ldw	r23,4(r3)
81133698:	003fa106 	br	81133520 <__reset+0xfb113520>
8113369c:	85af883a 	add	r23,r16,r22
811336a0:	b8800003 	ldbu	r2,0(r23)
811336a4:	b821883a 	mov	r16,r23
811336a8:	11003fcc 	andi	r4,r2,255
811336ac:	a109883a 	add	r4,r20,r4
811336b0:	21000003 	ldbu	r4,0(r4)
811336b4:	203eaa26 	beq	r4,zero,81133160 <__reset+0xfb113160>
811336b8:	84000044 	addi	r16,r16,1
811336bc:	80800003 	ldbu	r2,0(r16)
811336c0:	11003fcc 	andi	r4,r2,255
811336c4:	a109883a 	add	r4,r20,r4
811336c8:	21000003 	ldbu	r4,0(r4)
811336cc:	203ffa1e 	bne	r4,zero,811336b8 <__reset+0xfb1136b8>
811336d0:	003ea306 	br	81133160 <__reset+0xfb113160>
811336d4:	d9001617 	ldw	r4,88(sp)
811336d8:	00800044 	movi	r2,1
811336dc:	1109c83a 	sub	r4,r2,r4
811336e0:	d9001615 	stw	r4,88(sp)
811336e4:	d8801617 	ldw	r2,88(sp)
811336e8:	103f9626 	beq	r2,zero,81133544 <__reset+0xfb113544>
811336ec:	87000417 	ldw	fp,16(r16)
811336f0:	d9800217 	ldw	r6,8(sp)
811336f4:	013fffc4 	movi	r4,-1
811336f8:	e727883a 	add	r19,fp,fp
811336fc:	9ce7883a 	add	r19,r19,r19
81133700:	3005883a 	mov	r2,r6
81133704:	34cb883a 	add	r5,r6,r19
81133708:	00000306 	br	81133718 <__gethex+0x6c0>
8113370c:	10000015 	stw	zero,0(r2)
81133710:	10800104 	addi	r2,r2,4
81133714:	117f4c2e 	bgeu	r2,r5,81133448 <__reset+0xfb113448>
81133718:	10c00017 	ldw	r3,0(r2)
8113371c:	193ffb26 	beq	r3,r4,8113370c <__reset+0xfb11370c>
81133720:	18c00044 	addi	r3,r3,1
81133724:	10c00015 	stw	r3,0(r2)
81133728:	00800084 	movi	r2,2
8113372c:	88802b26 	beq	r17,r2,811337dc <__gethex+0x784>
81133730:	948007cc 	andi	r18,r18,31
81133734:	90002f1e 	bne	r18,zero,811337f4 <__gethex+0x79c>
81133738:	04400844 	movi	r17,33
8113373c:	003f8206 	br	81133548 <__reset+0xfb113548>
81133740:	04c00044 	movi	r19,1
81133744:	003fc106 	br	8113364c <__reset+0xfb11364c>
81133748:	d8c01617 	ldw	r3,88(sp)
8113374c:	183ed226 	beq	r3,zero,81133298 <__reset+0xfb113298>
81133750:	d8c00417 	ldw	r3,16(sp)
81133754:	d9001517 	ldw	r4,84(sp)
81133758:	18800015 	stw	r2,0(r3)
8113375c:	d8c00217 	ldw	r3,8(sp)
81133760:	00800044 	movi	r2,1
81133764:	80800415 	stw	r2,16(r16)
81133768:	18800015 	stw	r2,0(r3)
8113376c:	24000015 	stw	r16,0(r4)
81133770:	00801884 	movi	r2,98
81133774:	003efa06 	br	81133360 <__reset+0xfb113360>
81133778:	9880008c 	andi	r2,r19,2
8113377c:	103f7126 	beq	r2,zero,81133544 <__reset+0xfb113544>
81133780:	d8c00217 	ldw	r3,8(sp)
81133784:	18800017 	ldw	r2,0(r3)
81133788:	9884b03a 	or	r2,r19,r2
8113378c:	1080004c 	andi	r2,r2,1
81133790:	103fd61e 	bne	r2,zero,811336ec <__reset+0xfb1136ec>
81133794:	003f6b06 	br	81133544 <__reset+0xfb113544>
81133798:	da800217 	ldw	r10,8(sp)
8113379c:	0013883a 	mov	r9,zero
811337a0:	003e9f06 	br	81133220 <__reset+0xfb113220>
811337a4:	04c00084 	movi	r19,2
811337a8:	003f8806 	br	811335cc <__reset+0xfb1135cc>
811337ac:	d9001617 	ldw	r4,88(sp)
811337b0:	203fe726 	beq	r4,zero,81133750 <__reset+0xfb113750>
811337b4:	003eb806 	br	81133298 <__reset+0xfb113298>
811337b8:	95feb71e 	bne	r18,r23,81133298 <__reset+0xfb113298>
811337bc:	1cbfe40e 	bge	r3,r18,81133750 <__reset+0xfb113750>
811337c0:	917fffc4 	addi	r5,r18,-1
811337c4:	8009883a 	mov	r4,r16
811337c8:	112d8f80 	call	8112d8f8 <__any_on>
811337cc:	103eb226 	beq	r2,zero,81133298 <__reset+0xfb113298>
811337d0:	d8c00017 	ldw	r3,0(sp)
811337d4:	18800117 	ldw	r2,4(r3)
811337d8:	003fdd06 	br	81133750 <__reset+0xfb113750>
811337dc:	d8c00017 	ldw	r3,0(sp)
811337e0:	18800017 	ldw	r2,0(r3)
811337e4:	10bfffc4 	addi	r2,r2,-1
811337e8:	90801c26 	beq	r18,r2,8113385c <__gethex+0x804>
811337ec:	04400884 	movi	r17,34
811337f0:	003f5506 	br	81133548 <__reset+0xfb113548>
811337f4:	34c5883a 	add	r2,r6,r19
811337f8:	113fff17 	ldw	r4,-4(r2)
811337fc:	112cc340 	call	8112cc34 <__hi0bits>
81133800:	00c00804 	movi	r3,32
81133804:	1ca5c83a 	sub	r18,r3,r18
81133808:	14bfcb0e 	bge	r2,r18,81133738 <__reset+0xfb113738>
8113380c:	003f1c06 	br	81133480 <__reset+0xfb113480>
81133810:	81400117 	ldw	r5,4(r16)
81133814:	d9000117 	ldw	r4,4(sp)
81133818:	29400044 	addi	r5,r5,1
8113381c:	112c9280 	call	8112c928 <_Balloc>
81133820:	81800417 	ldw	r6,16(r16)
81133824:	81400304 	addi	r5,r16,12
81133828:	11000304 	addi	r4,r2,12
8113382c:	31800084 	addi	r6,r6,2
81133830:	318d883a 	add	r6,r6,r6
81133834:	318d883a 	add	r6,r6,r6
81133838:	1029883a 	mov	r20,r2
8113383c:	11223f40 	call	811223f4 <memcpy>
81133840:	d9000117 	ldw	r4,4(sp)
81133844:	800b883a 	mov	r5,r16
81133848:	a021883a 	mov	r16,r20
8113384c:	112c9d80 	call	8112c9d8 <_Bfree>
81133850:	a0c00417 	ldw	r3,16(r20)
81133854:	a1800504 	addi	r6,r20,20
81133858:	003efe06 	br	81133454 <__reset+0xfb113454>
8113385c:	9005d17a 	srai	r2,r18,5
81133860:	944007cc 	andi	r17,r18,31
81133864:	1085883a 	add	r2,r2,r2
81133868:	1085883a 	add	r2,r2,r2
8113386c:	3087883a 	add	r3,r6,r2
81133870:	00800044 	movi	r2,1
81133874:	1462983a 	sll	r17,r2,r17
81133878:	18800017 	ldw	r2,0(r3)
8113387c:	8884703a 	and	r2,r17,r2
81133880:	1022c03a 	cmpne	r17,r2,zero
81133884:	00800884 	movi	r2,34
81133888:	1463c83a 	sub	r17,r2,r17
8113388c:	003f2e06 	br	81133548 <__reset+0xfb113548>

81133890 <__hexnan>:
81133890:	defff904 	addi	sp,sp,-28
81133894:	de00012e 	bgeu	sp,et,8113389c <__hexnan+0xc>
81133898:	003b68fa 	trap	3
8113389c:	dc800215 	stw	r18,8(sp)
811338a0:	2c800017 	ldw	r18,0(r5)
811338a4:	dfc00615 	stw	ra,24(sp)
811338a8:	dd400515 	stw	r21,20(sp)
811338ac:	901fd17a 	srai	r15,r18,5
811338b0:	dd000415 	stw	r20,16(sp)
811338b4:	dcc00315 	stw	r19,12(sp)
811338b8:	7bdf883a 	add	r15,r15,r15
811338bc:	7bdf883a 	add	r15,r15,r15
811338c0:	dc400115 	stw	r17,4(sp)
811338c4:	dc000015 	stw	r16,0(sp)
811338c8:	948007cc 	andi	r18,r18,31
811338cc:	33df883a 	add	r15,r6,r15
811338d0:	90000126 	beq	r18,zero,811338d8 <__hexnan+0x48>
811338d4:	7bc00104 	addi	r15,r15,4
811338d8:	22000017 	ldw	r8,0(r4)
811338dc:	7affff04 	addi	r11,r15,-4
811338e0:	03a04574 	movhi	r14,33045
811338e4:	783fff15 	stw	zero,-4(r15)
811338e8:	581b883a 	mov	r13,r11
811338ec:	580b883a 	mov	r5,r11
811338f0:	000f883a 	mov	r7,zero
811338f4:	003f883a 	mov	ra,zero
811338f8:	0019883a 	mov	r12,zero
811338fc:	7382b804 	addi	r14,r14,2784
81133900:	04400204 	movi	r17,8
81133904:	04000804 	movi	r16,32
81133908:	04c001c4 	movi	r19,7
8113390c:	42000044 	addi	r8,r8,1
81133910:	40c00003 	ldbu	r3,0(r8)
81133914:	18001d26 	beq	r3,zero,8113398c <__hexnan+0xfc>
81133918:	70c5883a 	add	r2,r14,r3
8113391c:	10800003 	ldbu	r2,0(r2)
81133920:	12403fcc 	andi	r9,r2,255
81133924:	4800301e 	bne	r9,zero,811339e8 <__hexnan+0x158>
81133928:	80c04236 	bltu	r16,r3,81133a34 <__hexnan+0x1a4>
8113392c:	fb3ff70e 	bge	ra,r12,8113390c <__reset+0xfb11390c>
81133930:	2b40112e 	bgeu	r5,r13,81133978 <__hexnan+0xe8>
81133934:	99c01016 	blt	r19,r7,81133978 <__hexnan+0xe8>
81133938:	89e9c83a 	sub	r20,r17,r7
8113393c:	a529883a 	add	r20,r20,r20
81133940:	2a800017 	ldw	r10,0(r5)
81133944:	a529883a 	add	r20,r20,r20
81133948:	852bc83a 	sub	r21,r16,r20
8113394c:	28c00104 	addi	r3,r5,4
81133950:	2805883a 	mov	r2,r5
81133954:	19c00017 	ldw	r7,0(r3)
81133958:	10800104 	addi	r2,r2,4
8113395c:	18c00104 	addi	r3,r3,4
81133960:	3d52983a 	sll	r9,r7,r21
81133964:	4a92b03a 	or	r9,r9,r10
81133968:	3d14d83a 	srl	r10,r7,r20
8113396c:	127fff15 	stw	r9,-4(r2)
81133970:	1abfff15 	stw	r10,-4(r3)
81133974:	137ff736 	bltu	r2,r13,81133954 <__reset+0xfb113954>
81133978:	31402836 	bltu	r6,r5,81133a1c <__hexnan+0x18c>
8113397c:	42000044 	addi	r8,r8,1
81133980:	40c00003 	ldbu	r3,0(r8)
81133984:	01c00204 	movi	r7,8
81133988:	183fe31e 	bne	r3,zero,81133918 <__reset+0xfb113918>
8113398c:	60002b26 	beq	r12,zero,81133a3c <__hexnan+0x1ac>
81133990:	2b40022e 	bgeu	r5,r13,8113399c <__hexnan+0x10c>
81133994:	008001c4 	movi	r2,7
81133998:	11c0430e 	bge	r2,r7,81133aa8 <__hexnan+0x218>
8113399c:	3140312e 	bgeu	r6,r5,81133a64 <__hexnan+0x1d4>
811339a0:	3007883a 	mov	r3,r6
811339a4:	29000017 	ldw	r4,0(r5)
811339a8:	18800104 	addi	r2,r3,4
811339ac:	29400104 	addi	r5,r5,4
811339b0:	19000015 	stw	r4,0(r3)
811339b4:	1007883a 	mov	r3,r2
811339b8:	597ffa2e 	bgeu	r11,r5,811339a4 <__reset+0xfb1139a4>
811339bc:	10000015 	stw	zero,0(r2)
811339c0:	10800104 	addi	r2,r2,4
811339c4:	58bffd2e 	bgeu	r11,r2,811339bc <__reset+0xfb1139bc>
811339c8:	78bfff17 	ldw	r2,-4(r15)
811339cc:	1000041e 	bne	r2,zero,811339e0 <__hexnan+0x150>
811339d0:	32c02d26 	beq	r6,r11,81133a88 <__hexnan+0x1f8>
811339d4:	5affff04 	addi	r11,r11,-4
811339d8:	58800017 	ldw	r2,0(r11)
811339dc:	103ffc26 	beq	r2,zero,811339d0 <__reset+0xfb1139d0>
811339e0:	00800144 	movi	r2,5
811339e4:	00001606 	br	81133a40 <__hexnan+0x1b0>
811339e8:	39c00044 	addi	r7,r7,1
811339ec:	63000044 	addi	r12,r12,1
811339f0:	89c0040e 	bge	r17,r7,81133a04 <__hexnan+0x174>
811339f4:	317fc52e 	bgeu	r6,r5,8113390c <__reset+0xfb11390c>
811339f8:	283fff15 	stw	zero,-4(r5)
811339fc:	01c00044 	movi	r7,1
81133a00:	297fff04 	addi	r5,r5,-4
81133a04:	28c00017 	ldw	r3,0(r5)
81133a08:	108003cc 	andi	r2,r2,15
81133a0c:	1806913a 	slli	r3,r3,4
81133a10:	1884b03a 	or	r2,r3,r2
81133a14:	28800015 	stw	r2,0(r5)
81133a18:	003fbc06 	br	8113390c <__reset+0xfb11390c>
81133a1c:	2b7fff04 	addi	r13,r5,-4
81133a20:	283fff15 	stw	zero,-4(r5)
81133a24:	603f883a 	mov	ra,r12
81133a28:	680b883a 	mov	r5,r13
81133a2c:	000f883a 	mov	r7,zero
81133a30:	003fb606 	br	8113390c <__reset+0xfb11390c>
81133a34:	00800a44 	movi	r2,41
81133a38:	18801726 	beq	r3,r2,81133a98 <__hexnan+0x208>
81133a3c:	00800104 	movi	r2,4
81133a40:	dfc00617 	ldw	ra,24(sp)
81133a44:	dd400517 	ldw	r21,20(sp)
81133a48:	dd000417 	ldw	r20,16(sp)
81133a4c:	dcc00317 	ldw	r19,12(sp)
81133a50:	dc800217 	ldw	r18,8(sp)
81133a54:	dc400117 	ldw	r17,4(sp)
81133a58:	dc000017 	ldw	r16,0(sp)
81133a5c:	dec00704 	addi	sp,sp,28
81133a60:	f800283a 	ret
81133a64:	903fd826 	beq	r18,zero,811339c8 <__reset+0xfb1139c8>
81133a68:	00c00804 	movi	r3,32
81133a6c:	1ca5c83a 	sub	r18,r3,r18
81133a70:	00ffffc4 	movi	r3,-1
81133a74:	78bfff17 	ldw	r2,-4(r15)
81133a78:	1c86d83a 	srl	r3,r3,r18
81133a7c:	1884703a 	and	r2,r3,r2
81133a80:	78bfff15 	stw	r2,-4(r15)
81133a84:	003fd106 	br	811339cc <__reset+0xfb1139cc>
81133a88:	00800044 	movi	r2,1
81133a8c:	58800015 	stw	r2,0(r11)
81133a90:	00800144 	movi	r2,5
81133a94:	003fea06 	br	81133a40 <__reset+0xfb113a40>
81133a98:	42000044 	addi	r8,r8,1
81133a9c:	22000015 	stw	r8,0(r4)
81133aa0:	603fbb1e 	bne	r12,zero,81133990 <__reset+0xfb113990>
81133aa4:	003fe506 	br	81133a3c <__reset+0xfb113a3c>
81133aa8:	02400204 	movi	r9,8
81133aac:	49d3c83a 	sub	r9,r9,r7
81133ab0:	4a53883a 	add	r9,r9,r9
81133ab4:	2a000017 	ldw	r8,0(r5)
81133ab8:	4a53883a 	add	r9,r9,r9
81133abc:	02800804 	movi	r10,32
81133ac0:	5255c83a 	sub	r10,r10,r9
81133ac4:	28c00104 	addi	r3,r5,4
81133ac8:	2805883a 	mov	r2,r5
81133acc:	19c00017 	ldw	r7,0(r3)
81133ad0:	10800104 	addi	r2,r2,4
81133ad4:	18c00104 	addi	r3,r3,4
81133ad8:	3a88983a 	sll	r4,r7,r10
81133adc:	2208b03a 	or	r4,r4,r8
81133ae0:	3a50d83a 	srl	r8,r7,r9
81133ae4:	113fff15 	stw	r4,-4(r2)
81133ae8:	1a3fff15 	stw	r8,-4(r3)
81133aec:	137ff736 	bltu	r2,r13,81133acc <__reset+0xfb113acc>
81133af0:	003faa06 	br	8113399c <__reset+0xfb11399c>

81133af4 <strncmp>:
81133af4:	30003126 	beq	r6,zero,81133bbc <strncmp+0xc8>
81133af8:	2144b03a 	or	r2,r4,r5
81133afc:	108000cc 	andi	r2,r2,3
81133b00:	10001e1e 	bne	r2,zero,81133b7c <strncmp+0x88>
81133b04:	024000c4 	movi	r9,3
81133b08:	49801c2e 	bgeu	r9,r6,81133b7c <strncmp+0x88>
81133b0c:	20800017 	ldw	r2,0(r4)
81133b10:	28c00017 	ldw	r3,0(r5)
81133b14:	10c0191e 	bne	r2,r3,81133b7c <strncmp+0x88>
81133b18:	31bfff04 	addi	r6,r6,-4
81133b1c:	30002726 	beq	r6,zero,81133bbc <strncmp+0xc8>
81133b20:	02ffbff4 	movhi	r11,65279
81133b24:	5affbfc4 	addi	r11,r11,-257
81133b28:	0086303a 	nor	r3,zero,r2
81133b2c:	02a02074 	movhi	r10,32897
81133b30:	12c5883a 	add	r2,r2,r11
81133b34:	52a02004 	addi	r10,r10,-32640
81133b38:	10c4703a 	and	r2,r2,r3
81133b3c:	1284703a 	and	r2,r2,r10
81133b40:	10000b26 	beq	r2,zero,81133b70 <strncmp+0x7c>
81133b44:	00001d06 	br	81133bbc <strncmp+0xc8>
81133b48:	20c00017 	ldw	r3,0(r4)
81133b4c:	29c00017 	ldw	r7,0(r5)
81133b50:	1ad1883a 	add	r8,r3,r11
81133b54:	00c4303a 	nor	r2,zero,r3
81133b58:	4084703a 	and	r2,r8,r2
81133b5c:	1284703a 	and	r2,r2,r10
81133b60:	19c0061e 	bne	r3,r7,81133b7c <strncmp+0x88>
81133b64:	31bfff04 	addi	r6,r6,-4
81133b68:	30001426 	beq	r6,zero,81133bbc <strncmp+0xc8>
81133b6c:	1000131e 	bne	r2,zero,81133bbc <strncmp+0xc8>
81133b70:	21000104 	addi	r4,r4,4
81133b74:	29400104 	addi	r5,r5,4
81133b78:	49bff336 	bltu	r9,r6,81133b48 <__reset+0xfb113b48>
81133b7c:	28800007 	ldb	r2,0(r5)
81133b80:	20c00007 	ldb	r3,0(r4)
81133b84:	31bfffc4 	addi	r6,r6,-1
81133b88:	10c0081e 	bne	r2,r3,81133bac <strncmp+0xb8>
81133b8c:	30000b26 	beq	r6,zero,81133bbc <strncmp+0xc8>
81133b90:	10000a26 	beq	r2,zero,81133bbc <strncmp+0xc8>
81133b94:	21000044 	addi	r4,r4,1
81133b98:	29400044 	addi	r5,r5,1
81133b9c:	20800007 	ldb	r2,0(r4)
81133ba0:	28c00007 	ldb	r3,0(r5)
81133ba4:	31bfffc4 	addi	r6,r6,-1
81133ba8:	10fff826 	beq	r2,r3,81133b8c <__reset+0xfb113b8c>
81133bac:	20800003 	ldbu	r2,0(r4)
81133bb0:	28c00003 	ldbu	r3,0(r5)
81133bb4:	10c5c83a 	sub	r2,r2,r3
81133bb8:	f800283a 	ret
81133bbc:	0005883a 	mov	r2,zero
81133bc0:	f800283a 	ret

81133bc4 <_wcrtomb_r>:
81133bc4:	defff604 	addi	sp,sp,-40
81133bc8:	00a04574 	movhi	r2,33045
81133bcc:	de00012e 	bgeu	sp,et,81133bd4 <_wcrtomb_r+0x10>
81133bd0:	003b68fa 	trap	3
81133bd4:	108bf204 	addi	r2,r2,12232
81133bd8:	dc800815 	stw	r18,32(sp)
81133bdc:	dc400715 	stw	r17,28(sp)
81133be0:	dc000615 	stw	r16,24(sp)
81133be4:	dfc00915 	stw	ra,36(sp)
81133be8:	2021883a 	mov	r16,r4
81133bec:	3823883a 	mov	r17,r7
81133bf0:	14800017 	ldw	r18,0(r2)
81133bf4:	28001426 	beq	r5,zero,81133c48 <_wcrtomb_r+0x84>
81133bf8:	d9400415 	stw	r5,16(sp)
81133bfc:	d9800515 	stw	r6,20(sp)
81133c00:	112c3dc0 	call	8112c3dc <__locale_charset>
81133c04:	d9800517 	ldw	r6,20(sp)
81133c08:	d9400417 	ldw	r5,16(sp)
81133c0c:	100f883a 	mov	r7,r2
81133c10:	dc400015 	stw	r17,0(sp)
81133c14:	8009883a 	mov	r4,r16
81133c18:	903ee83a 	callr	r18
81133c1c:	00ffffc4 	movi	r3,-1
81133c20:	10c0031e 	bne	r2,r3,81133c30 <_wcrtomb_r+0x6c>
81133c24:	88000015 	stw	zero,0(r17)
81133c28:	00c02284 	movi	r3,138
81133c2c:	80c00015 	stw	r3,0(r16)
81133c30:	dfc00917 	ldw	ra,36(sp)
81133c34:	dc800817 	ldw	r18,32(sp)
81133c38:	dc400717 	ldw	r17,28(sp)
81133c3c:	dc000617 	ldw	r16,24(sp)
81133c40:	dec00a04 	addi	sp,sp,40
81133c44:	f800283a 	ret
81133c48:	112c3dc0 	call	8112c3dc <__locale_charset>
81133c4c:	100f883a 	mov	r7,r2
81133c50:	dc400015 	stw	r17,0(sp)
81133c54:	000d883a 	mov	r6,zero
81133c58:	d9400104 	addi	r5,sp,4
81133c5c:	8009883a 	mov	r4,r16
81133c60:	903ee83a 	callr	r18
81133c64:	003fed06 	br	81133c1c <__reset+0xfb113c1c>

81133c68 <wcrtomb>:
81133c68:	defff604 	addi	sp,sp,-40
81133c6c:	00a04574 	movhi	r2,33045
81133c70:	de00012e 	bgeu	sp,et,81133c78 <wcrtomb+0x10>
81133c74:	003b68fa 	trap	3
81133c78:	108bed04 	addi	r2,r2,12212
81133c7c:	dc800615 	stw	r18,24(sp)
81133c80:	dc400515 	stw	r17,20(sp)
81133c84:	dfc00915 	stw	ra,36(sp)
81133c88:	dd000815 	stw	r20,32(sp)
81133c8c:	dcc00715 	stw	r19,28(sp)
81133c90:	dc000415 	stw	r16,16(sp)
81133c94:	3025883a 	mov	r18,r6
81133c98:	14400017 	ldw	r17,0(r2)
81133c9c:	20001926 	beq	r4,zero,81133d04 <wcrtomb+0x9c>
81133ca0:	00a04574 	movhi	r2,33045
81133ca4:	108bf204 	addi	r2,r2,12232
81133ca8:	15000017 	ldw	r20,0(r2)
81133cac:	2021883a 	mov	r16,r4
81133cb0:	2827883a 	mov	r19,r5
81133cb4:	112c3dc0 	call	8112c3dc <__locale_charset>
81133cb8:	100f883a 	mov	r7,r2
81133cbc:	dc800015 	stw	r18,0(sp)
81133cc0:	980d883a 	mov	r6,r19
81133cc4:	800b883a 	mov	r5,r16
81133cc8:	8809883a 	mov	r4,r17
81133ccc:	a03ee83a 	callr	r20
81133cd0:	00ffffc4 	movi	r3,-1
81133cd4:	10c0031e 	bne	r2,r3,81133ce4 <wcrtomb+0x7c>
81133cd8:	90000015 	stw	zero,0(r18)
81133cdc:	00c02284 	movi	r3,138
81133ce0:	88c00015 	stw	r3,0(r17)
81133ce4:	dfc00917 	ldw	ra,36(sp)
81133ce8:	dd000817 	ldw	r20,32(sp)
81133cec:	dcc00717 	ldw	r19,28(sp)
81133cf0:	dc800617 	ldw	r18,24(sp)
81133cf4:	dc400517 	ldw	r17,20(sp)
81133cf8:	dc000417 	ldw	r16,16(sp)
81133cfc:	dec00a04 	addi	sp,sp,40
81133d00:	f800283a 	ret
81133d04:	00a04574 	movhi	r2,33045
81133d08:	108bf204 	addi	r2,r2,12232
81133d0c:	14000017 	ldw	r16,0(r2)
81133d10:	112c3dc0 	call	8112c3dc <__locale_charset>
81133d14:	100f883a 	mov	r7,r2
81133d18:	dc800015 	stw	r18,0(sp)
81133d1c:	000d883a 	mov	r6,zero
81133d20:	d9400104 	addi	r5,sp,4
81133d24:	8809883a 	mov	r4,r17
81133d28:	803ee83a 	callr	r16
81133d2c:	003fe806 	br	81133cd0 <__reset+0xfb113cd0>

81133d30 <__ascii_wctomb>:
81133d30:	28000526 	beq	r5,zero,81133d48 <__ascii_wctomb+0x18>
81133d34:	00803fc4 	movi	r2,255
81133d38:	11800536 	bltu	r2,r6,81133d50 <__ascii_wctomb+0x20>
81133d3c:	29800005 	stb	r6,0(r5)
81133d40:	00800044 	movi	r2,1
81133d44:	f800283a 	ret
81133d48:	0005883a 	mov	r2,zero
81133d4c:	f800283a 	ret
81133d50:	00802284 	movi	r2,138
81133d54:	20800015 	stw	r2,0(r4)
81133d58:	00bfffc4 	movi	r2,-1
81133d5c:	f800283a 	ret

81133d60 <_wctomb_r>:
81133d60:	00a04574 	movhi	r2,33045
81133d64:	defff904 	addi	sp,sp,-28
81133d68:	108bf204 	addi	r2,r2,12232
81133d6c:	de00012e 	bgeu	sp,et,81133d74 <_wctomb_r+0x14>
81133d70:	003b68fa 	trap	3
81133d74:	dfc00615 	stw	ra,24(sp)
81133d78:	dc400515 	stw	r17,20(sp)
81133d7c:	dc000415 	stw	r16,16(sp)
81133d80:	3823883a 	mov	r17,r7
81133d84:	14000017 	ldw	r16,0(r2)
81133d88:	d9000115 	stw	r4,4(sp)
81133d8c:	d9400215 	stw	r5,8(sp)
81133d90:	d9800315 	stw	r6,12(sp)
81133d94:	112c3dc0 	call	8112c3dc <__locale_charset>
81133d98:	d9800317 	ldw	r6,12(sp)
81133d9c:	d9400217 	ldw	r5,8(sp)
81133da0:	d9000117 	ldw	r4,4(sp)
81133da4:	100f883a 	mov	r7,r2
81133da8:	dc400015 	stw	r17,0(sp)
81133dac:	803ee83a 	callr	r16
81133db0:	dfc00617 	ldw	ra,24(sp)
81133db4:	dc400517 	ldw	r17,20(sp)
81133db8:	dc000417 	ldw	r16,16(sp)
81133dbc:	dec00704 	addi	sp,sp,28
81133dc0:	f800283a 	ret

81133dc4 <__udivdi3>:
81133dc4:	defff504 	addi	sp,sp,-44
81133dc8:	de00012e 	bgeu	sp,et,81133dd0 <__udivdi3+0xc>
81133dcc:	003b68fa 	trap	3
81133dd0:	dcc00415 	stw	r19,16(sp)
81133dd4:	dc000115 	stw	r16,4(sp)
81133dd8:	dfc00a15 	stw	ra,40(sp)
81133ddc:	df000915 	stw	fp,36(sp)
81133de0:	ddc00815 	stw	r23,32(sp)
81133de4:	dd800715 	stw	r22,28(sp)
81133de8:	dd400615 	stw	r21,24(sp)
81133dec:	dd000515 	stw	r20,20(sp)
81133df0:	dc800315 	stw	r18,12(sp)
81133df4:	dc400215 	stw	r17,8(sp)
81133df8:	2027883a 	mov	r19,r4
81133dfc:	2821883a 	mov	r16,r5
81133e00:	3800411e 	bne	r7,zero,81133f08 <__udivdi3+0x144>
81133e04:	3023883a 	mov	r17,r6
81133e08:	2025883a 	mov	r18,r4
81133e0c:	2980522e 	bgeu	r5,r6,81133f58 <__udivdi3+0x194>
81133e10:	00bfffd4 	movui	r2,65535
81133e14:	282d883a 	mov	r22,r5
81133e18:	1180a836 	bltu	r2,r6,811340bc <__udivdi3+0x2f8>
81133e1c:	00803fc4 	movi	r2,255
81133e20:	1185803a 	cmpltu	r2,r2,r6
81133e24:	100490fa 	slli	r2,r2,3
81133e28:	3086d83a 	srl	r3,r6,r2
81133e2c:	01204574 	movhi	r4,33045
81133e30:	21013204 	addi	r4,r4,1224
81133e34:	20c7883a 	add	r3,r4,r3
81133e38:	18c00003 	ldbu	r3,0(r3)
81133e3c:	1885883a 	add	r2,r3,r2
81133e40:	00c00804 	movi	r3,32
81133e44:	1887c83a 	sub	r3,r3,r2
81133e48:	18000526 	beq	r3,zero,81133e60 <__udivdi3+0x9c>
81133e4c:	80e0983a 	sll	r16,r16,r3
81133e50:	9884d83a 	srl	r2,r19,r2
81133e54:	30e2983a 	sll	r17,r6,r3
81133e58:	98e4983a 	sll	r18,r19,r3
81133e5c:	142cb03a 	or	r22,r2,r16
81133e60:	882ad43a 	srli	r21,r17,16
81133e64:	b009883a 	mov	r4,r22
81133e68:	8d3fffcc 	andi	r20,r17,65535
81133e6c:	a80b883a 	mov	r5,r21
81133e70:	11349e00 	call	811349e0 <__umodsi3>
81133e74:	b009883a 	mov	r4,r22
81133e78:	a80b883a 	mov	r5,r21
81133e7c:	1027883a 	mov	r19,r2
81133e80:	113497c0 	call	8113497c <__udivsi3>
81133e84:	102d883a 	mov	r22,r2
81133e88:	9826943a 	slli	r19,r19,16
81133e8c:	9004d43a 	srli	r2,r18,16
81133e90:	a5a1383a 	mul	r16,r20,r22
81133e94:	14c4b03a 	or	r2,r2,r19
81133e98:	1400052e 	bgeu	r2,r16,81133eb0 <__udivdi3+0xec>
81133e9c:	1445883a 	add	r2,r2,r17
81133ea0:	b0ffffc4 	addi	r3,r22,-1
81133ea4:	14400136 	bltu	r2,r17,81133eac <__udivdi3+0xe8>
81133ea8:	14012336 	bltu	r2,r16,81134338 <__udivdi3+0x574>
81133eac:	182d883a 	mov	r22,r3
81133eb0:	1421c83a 	sub	r16,r2,r16
81133eb4:	a80b883a 	mov	r5,r21
81133eb8:	8009883a 	mov	r4,r16
81133ebc:	11349e00 	call	811349e0 <__umodsi3>
81133ec0:	1027883a 	mov	r19,r2
81133ec4:	a80b883a 	mov	r5,r21
81133ec8:	8009883a 	mov	r4,r16
81133ecc:	113497c0 	call	8113497c <__udivsi3>
81133ed0:	9826943a 	slli	r19,r19,16
81133ed4:	a0a9383a 	mul	r20,r20,r2
81133ed8:	94bfffcc 	andi	r18,r18,65535
81133edc:	94e4b03a 	or	r18,r18,r19
81133ee0:	9500052e 	bgeu	r18,r20,81133ef8 <__udivdi3+0x134>
81133ee4:	8ca5883a 	add	r18,r17,r18
81133ee8:	10ffffc4 	addi	r3,r2,-1
81133eec:	9440f136 	bltu	r18,r17,811342b4 <__udivdi3+0x4f0>
81133ef0:	9500f02e 	bgeu	r18,r20,811342b4 <__udivdi3+0x4f0>
81133ef4:	10bfff84 	addi	r2,r2,-2
81133ef8:	b00c943a 	slli	r6,r22,16
81133efc:	0007883a 	mov	r3,zero
81133f00:	3084b03a 	or	r2,r6,r2
81133f04:	00005906 	br	8113406c <__udivdi3+0x2a8>
81133f08:	29c05636 	bltu	r5,r7,81134064 <__udivdi3+0x2a0>
81133f0c:	00bfffd4 	movui	r2,65535
81133f10:	11c0622e 	bgeu	r2,r7,8113409c <__udivdi3+0x2d8>
81133f14:	00804034 	movhi	r2,256
81133f18:	10bfffc4 	addi	r2,r2,-1
81133f1c:	11c0ee36 	bltu	r2,r7,811342d8 <__udivdi3+0x514>
81133f20:	00800404 	movi	r2,16
81133f24:	3886d83a 	srl	r3,r7,r2
81133f28:	01204574 	movhi	r4,33045
81133f2c:	21013204 	addi	r4,r4,1224
81133f30:	20c7883a 	add	r3,r4,r3
81133f34:	18c00003 	ldbu	r3,0(r3)
81133f38:	05400804 	movi	r21,32
81133f3c:	1885883a 	add	r2,r3,r2
81133f40:	a8abc83a 	sub	r21,r21,r2
81133f44:	a800621e 	bne	r21,zero,811340d0 <__udivdi3+0x30c>
81133f48:	3c00e936 	bltu	r7,r16,811342f0 <__udivdi3+0x52c>
81133f4c:	9985403a 	cmpgeu	r2,r19,r6
81133f50:	0007883a 	mov	r3,zero
81133f54:	00004506 	br	8113406c <__udivdi3+0x2a8>
81133f58:	3000041e 	bne	r6,zero,81133f6c <__udivdi3+0x1a8>
81133f5c:	000b883a 	mov	r5,zero
81133f60:	01000044 	movi	r4,1
81133f64:	113497c0 	call	8113497c <__udivsi3>
81133f68:	1023883a 	mov	r17,r2
81133f6c:	00bfffd4 	movui	r2,65535
81133f70:	14404e2e 	bgeu	r2,r17,811340ac <__udivdi3+0x2e8>
81133f74:	00804034 	movhi	r2,256
81133f78:	10bfffc4 	addi	r2,r2,-1
81133f7c:	1440d836 	bltu	r2,r17,811342e0 <__udivdi3+0x51c>
81133f80:	00800404 	movi	r2,16
81133f84:	8886d83a 	srl	r3,r17,r2
81133f88:	01204574 	movhi	r4,33045
81133f8c:	21013204 	addi	r4,r4,1224
81133f90:	20c7883a 	add	r3,r4,r3
81133f94:	18c00003 	ldbu	r3,0(r3)
81133f98:	1885883a 	add	r2,r3,r2
81133f9c:	00c00804 	movi	r3,32
81133fa0:	1887c83a 	sub	r3,r3,r2
81133fa4:	18008f1e 	bne	r3,zero,811341e4 <__udivdi3+0x420>
81133fa8:	882ad43a 	srli	r21,r17,16
81133fac:	8461c83a 	sub	r16,r16,r17
81133fb0:	8d3fffcc 	andi	r20,r17,65535
81133fb4:	00c00044 	movi	r3,1
81133fb8:	8009883a 	mov	r4,r16
81133fbc:	a80b883a 	mov	r5,r21
81133fc0:	d8c00015 	stw	r3,0(sp)
81133fc4:	11349e00 	call	811349e0 <__umodsi3>
81133fc8:	8009883a 	mov	r4,r16
81133fcc:	a80b883a 	mov	r5,r21
81133fd0:	1027883a 	mov	r19,r2
81133fd4:	113497c0 	call	8113497c <__udivsi3>
81133fd8:	9826943a 	slli	r19,r19,16
81133fdc:	9008d43a 	srli	r4,r18,16
81133fe0:	1521383a 	mul	r16,r2,r20
81133fe4:	102d883a 	mov	r22,r2
81133fe8:	24c8b03a 	or	r4,r4,r19
81133fec:	d8c00017 	ldw	r3,0(sp)
81133ff0:	2400052e 	bgeu	r4,r16,81134008 <__udivdi3+0x244>
81133ff4:	2449883a 	add	r4,r4,r17
81133ff8:	b0bfffc4 	addi	r2,r22,-1
81133ffc:	24400136 	bltu	r4,r17,81134004 <__udivdi3+0x240>
81134000:	2400ca36 	bltu	r4,r16,8113432c <__udivdi3+0x568>
81134004:	102d883a 	mov	r22,r2
81134008:	2421c83a 	sub	r16,r4,r16
8113400c:	a80b883a 	mov	r5,r21
81134010:	8009883a 	mov	r4,r16
81134014:	d8c00015 	stw	r3,0(sp)
81134018:	11349e00 	call	811349e0 <__umodsi3>
8113401c:	1027883a 	mov	r19,r2
81134020:	a80b883a 	mov	r5,r21
81134024:	8009883a 	mov	r4,r16
81134028:	113497c0 	call	8113497c <__udivsi3>
8113402c:	9826943a 	slli	r19,r19,16
81134030:	1529383a 	mul	r20,r2,r20
81134034:	94bfffcc 	andi	r18,r18,65535
81134038:	94e4b03a 	or	r18,r18,r19
8113403c:	d8c00017 	ldw	r3,0(sp)
81134040:	9500052e 	bgeu	r18,r20,81134058 <__udivdi3+0x294>
81134044:	8ca5883a 	add	r18,r17,r18
81134048:	113fffc4 	addi	r4,r2,-1
8113404c:	94409736 	bltu	r18,r17,811342ac <__udivdi3+0x4e8>
81134050:	9500962e 	bgeu	r18,r20,811342ac <__udivdi3+0x4e8>
81134054:	10bfff84 	addi	r2,r2,-2
81134058:	b00c943a 	slli	r6,r22,16
8113405c:	3084b03a 	or	r2,r6,r2
81134060:	00000206 	br	8113406c <__udivdi3+0x2a8>
81134064:	0007883a 	mov	r3,zero
81134068:	0005883a 	mov	r2,zero
8113406c:	dfc00a17 	ldw	ra,40(sp)
81134070:	df000917 	ldw	fp,36(sp)
81134074:	ddc00817 	ldw	r23,32(sp)
81134078:	dd800717 	ldw	r22,28(sp)
8113407c:	dd400617 	ldw	r21,24(sp)
81134080:	dd000517 	ldw	r20,20(sp)
81134084:	dcc00417 	ldw	r19,16(sp)
81134088:	dc800317 	ldw	r18,12(sp)
8113408c:	dc400217 	ldw	r17,8(sp)
81134090:	dc000117 	ldw	r16,4(sp)
81134094:	dec00b04 	addi	sp,sp,44
81134098:	f800283a 	ret
8113409c:	00803fc4 	movi	r2,255
811340a0:	11c5803a 	cmpltu	r2,r2,r7
811340a4:	100490fa 	slli	r2,r2,3
811340a8:	003f9e06 	br	81133f24 <__reset+0xfb113f24>
811340ac:	00803fc4 	movi	r2,255
811340b0:	1445803a 	cmpltu	r2,r2,r17
811340b4:	100490fa 	slli	r2,r2,3
811340b8:	003fb206 	br	81133f84 <__reset+0xfb113f84>
811340bc:	00804034 	movhi	r2,256
811340c0:	10bfffc4 	addi	r2,r2,-1
811340c4:	11808836 	bltu	r2,r6,811342e8 <__udivdi3+0x524>
811340c8:	00800404 	movi	r2,16
811340cc:	003f5606 	br	81133e28 <__reset+0xfb113e28>
811340d0:	30aed83a 	srl	r23,r6,r2
811340d4:	3d4e983a 	sll	r7,r7,r21
811340d8:	80acd83a 	srl	r22,r16,r2
811340dc:	9884d83a 	srl	r2,r19,r2
811340e0:	3deeb03a 	or	r23,r7,r23
811340e4:	b824d43a 	srli	r18,r23,16
811340e8:	8560983a 	sll	r16,r16,r21
811340ec:	b009883a 	mov	r4,r22
811340f0:	900b883a 	mov	r5,r18
811340f4:	3568983a 	sll	r20,r6,r21
811340f8:	1420b03a 	or	r16,r2,r16
811340fc:	11349e00 	call	811349e0 <__umodsi3>
81134100:	b009883a 	mov	r4,r22
81134104:	900b883a 	mov	r5,r18
81134108:	1023883a 	mov	r17,r2
8113410c:	113497c0 	call	8113497c <__udivsi3>
81134110:	8808943a 	slli	r4,r17,16
81134114:	bf3fffcc 	andi	fp,r23,65535
81134118:	8006d43a 	srli	r3,r16,16
8113411c:	e0a3383a 	mul	r17,fp,r2
81134120:	100d883a 	mov	r6,r2
81134124:	1906b03a 	or	r3,r3,r4
81134128:	1c40042e 	bgeu	r3,r17,8113413c <__udivdi3+0x378>
8113412c:	1dc7883a 	add	r3,r3,r23
81134130:	10bfffc4 	addi	r2,r2,-1
81134134:	1dc0752e 	bgeu	r3,r23,8113430c <__udivdi3+0x548>
81134138:	100d883a 	mov	r6,r2
8113413c:	1c63c83a 	sub	r17,r3,r17
81134140:	900b883a 	mov	r5,r18
81134144:	8809883a 	mov	r4,r17
81134148:	d9800015 	stw	r6,0(sp)
8113414c:	11349e00 	call	811349e0 <__umodsi3>
81134150:	102d883a 	mov	r22,r2
81134154:	8809883a 	mov	r4,r17
81134158:	900b883a 	mov	r5,r18
8113415c:	113497c0 	call	8113497c <__udivsi3>
81134160:	b02c943a 	slli	r22,r22,16
81134164:	e089383a 	mul	r4,fp,r2
81134168:	843fffcc 	andi	r16,r16,65535
8113416c:	85a0b03a 	or	r16,r16,r22
81134170:	d9800017 	ldw	r6,0(sp)
81134174:	8100042e 	bgeu	r16,r4,81134188 <__udivdi3+0x3c4>
81134178:	85e1883a 	add	r16,r16,r23
8113417c:	10ffffc4 	addi	r3,r2,-1
81134180:	85c05e2e 	bgeu	r16,r23,811342fc <__udivdi3+0x538>
81134184:	1805883a 	mov	r2,r3
81134188:	300c943a 	slli	r6,r6,16
8113418c:	a17fffcc 	andi	r5,r20,65535
81134190:	a028d43a 	srli	r20,r20,16
81134194:	3084b03a 	or	r2,r6,r2
81134198:	10ffffcc 	andi	r3,r2,65535
8113419c:	100cd43a 	srli	r6,r2,16
811341a0:	194f383a 	mul	r7,r3,r5
811341a4:	1d07383a 	mul	r3,r3,r20
811341a8:	314b383a 	mul	r5,r6,r5
811341ac:	3810d43a 	srli	r8,r7,16
811341b0:	8121c83a 	sub	r16,r16,r4
811341b4:	1947883a 	add	r3,r3,r5
811341b8:	40c7883a 	add	r3,r8,r3
811341bc:	350d383a 	mul	r6,r6,r20
811341c0:	1940022e 	bgeu	r3,r5,811341cc <__udivdi3+0x408>
811341c4:	01000074 	movhi	r4,1
811341c8:	310d883a 	add	r6,r6,r4
811341cc:	1828d43a 	srli	r20,r3,16
811341d0:	a18d883a 	add	r6,r20,r6
811341d4:	81803e36 	bltu	r16,r6,811342d0 <__udivdi3+0x50c>
811341d8:	81803826 	beq	r16,r6,811342bc <__udivdi3+0x4f8>
811341dc:	0007883a 	mov	r3,zero
811341e0:	003fa206 	br	8113406c <__reset+0xfb11406c>
811341e4:	88e2983a 	sll	r17,r17,r3
811341e8:	80a8d83a 	srl	r20,r16,r2
811341ec:	80e0983a 	sll	r16,r16,r3
811341f0:	882ad43a 	srli	r21,r17,16
811341f4:	9884d83a 	srl	r2,r19,r2
811341f8:	a009883a 	mov	r4,r20
811341fc:	a80b883a 	mov	r5,r21
81134200:	142eb03a 	or	r23,r2,r16
81134204:	98e4983a 	sll	r18,r19,r3
81134208:	11349e00 	call	811349e0 <__umodsi3>
8113420c:	a009883a 	mov	r4,r20
81134210:	a80b883a 	mov	r5,r21
81134214:	1021883a 	mov	r16,r2
81134218:	113497c0 	call	8113497c <__udivsi3>
8113421c:	1039883a 	mov	fp,r2
81134220:	8d3fffcc 	andi	r20,r17,65535
81134224:	8020943a 	slli	r16,r16,16
81134228:	b804d43a 	srli	r2,r23,16
8113422c:	a72d383a 	mul	r22,r20,fp
81134230:	1404b03a 	or	r2,r2,r16
81134234:	1580062e 	bgeu	r2,r22,81134250 <__udivdi3+0x48c>
81134238:	1445883a 	add	r2,r2,r17
8113423c:	e0ffffc4 	addi	r3,fp,-1
81134240:	14403836 	bltu	r2,r17,81134324 <__udivdi3+0x560>
81134244:	1580372e 	bgeu	r2,r22,81134324 <__udivdi3+0x560>
81134248:	e73fff84 	addi	fp,fp,-2
8113424c:	1445883a 	add	r2,r2,r17
81134250:	15adc83a 	sub	r22,r2,r22
81134254:	a80b883a 	mov	r5,r21
81134258:	b009883a 	mov	r4,r22
8113425c:	11349e00 	call	811349e0 <__umodsi3>
81134260:	1027883a 	mov	r19,r2
81134264:	b009883a 	mov	r4,r22
81134268:	a80b883a 	mov	r5,r21
8113426c:	113497c0 	call	8113497c <__udivsi3>
81134270:	9826943a 	slli	r19,r19,16
81134274:	a0a1383a 	mul	r16,r20,r2
81134278:	b93fffcc 	andi	r4,r23,65535
8113427c:	24c8b03a 	or	r4,r4,r19
81134280:	2400062e 	bgeu	r4,r16,8113429c <__udivdi3+0x4d8>
81134284:	2449883a 	add	r4,r4,r17
81134288:	10ffffc4 	addi	r3,r2,-1
8113428c:	24402336 	bltu	r4,r17,8113431c <__udivdi3+0x558>
81134290:	2400222e 	bgeu	r4,r16,8113431c <__udivdi3+0x558>
81134294:	10bfff84 	addi	r2,r2,-2
81134298:	2449883a 	add	r4,r4,r17
8113429c:	e038943a 	slli	fp,fp,16
811342a0:	2421c83a 	sub	r16,r4,r16
811342a4:	e086b03a 	or	r3,fp,r2
811342a8:	003f4306 	br	81133fb8 <__reset+0xfb113fb8>
811342ac:	2005883a 	mov	r2,r4
811342b0:	003f6906 	br	81134058 <__reset+0xfb114058>
811342b4:	1805883a 	mov	r2,r3
811342b8:	003f0f06 	br	81133ef8 <__reset+0xfb113ef8>
811342bc:	1806943a 	slli	r3,r3,16
811342c0:	9d66983a 	sll	r19,r19,r21
811342c4:	39ffffcc 	andi	r7,r7,65535
811342c8:	19c7883a 	add	r3,r3,r7
811342cc:	98ffc32e 	bgeu	r19,r3,811341dc <__reset+0xfb1141dc>
811342d0:	10bfffc4 	addi	r2,r2,-1
811342d4:	003fc106 	br	811341dc <__reset+0xfb1141dc>
811342d8:	00800604 	movi	r2,24
811342dc:	003f1106 	br	81133f24 <__reset+0xfb113f24>
811342e0:	00800604 	movi	r2,24
811342e4:	003f2706 	br	81133f84 <__reset+0xfb113f84>
811342e8:	00800604 	movi	r2,24
811342ec:	003ece06 	br	81133e28 <__reset+0xfb113e28>
811342f0:	0007883a 	mov	r3,zero
811342f4:	00800044 	movi	r2,1
811342f8:	003f5c06 	br	8113406c <__reset+0xfb11406c>
811342fc:	813fa12e 	bgeu	r16,r4,81134184 <__reset+0xfb114184>
81134300:	10bfff84 	addi	r2,r2,-2
81134304:	85e1883a 	add	r16,r16,r23
81134308:	003f9f06 	br	81134188 <__reset+0xfb114188>
8113430c:	1c7f8a2e 	bgeu	r3,r17,81134138 <__reset+0xfb114138>
81134310:	31bfff84 	addi	r6,r6,-2
81134314:	1dc7883a 	add	r3,r3,r23
81134318:	003f8806 	br	8113413c <__reset+0xfb11413c>
8113431c:	1805883a 	mov	r2,r3
81134320:	003fde06 	br	8113429c <__reset+0xfb11429c>
81134324:	1839883a 	mov	fp,r3
81134328:	003fc906 	br	81134250 <__reset+0xfb114250>
8113432c:	b5bfff84 	addi	r22,r22,-2
81134330:	2449883a 	add	r4,r4,r17
81134334:	003f3406 	br	81134008 <__reset+0xfb114008>
81134338:	b5bfff84 	addi	r22,r22,-2
8113433c:	1445883a 	add	r2,r2,r17
81134340:	003edb06 	br	81133eb0 <__reset+0xfb113eb0>

81134344 <__umoddi3>:
81134344:	defff404 	addi	sp,sp,-48
81134348:	de00012e 	bgeu	sp,et,81134350 <__umoddi3+0xc>
8113434c:	003b68fa 	trap	3
81134350:	df000a15 	stw	fp,40(sp)
81134354:	dc400315 	stw	r17,12(sp)
81134358:	dc000215 	stw	r16,8(sp)
8113435c:	dfc00b15 	stw	ra,44(sp)
81134360:	ddc00915 	stw	r23,36(sp)
81134364:	dd800815 	stw	r22,32(sp)
81134368:	dd400715 	stw	r21,28(sp)
8113436c:	dd000615 	stw	r20,24(sp)
81134370:	dcc00515 	stw	r19,20(sp)
81134374:	dc800415 	stw	r18,16(sp)
81134378:	2021883a 	mov	r16,r4
8113437c:	2823883a 	mov	r17,r5
81134380:	2839883a 	mov	fp,r5
81134384:	38003c1e 	bne	r7,zero,81134478 <__umoddi3+0x134>
81134388:	3027883a 	mov	r19,r6
8113438c:	2029883a 	mov	r20,r4
81134390:	2980512e 	bgeu	r5,r6,811344d8 <__umoddi3+0x194>
81134394:	00bfffd4 	movui	r2,65535
81134398:	11809a36 	bltu	r2,r6,81134604 <__umoddi3+0x2c0>
8113439c:	01003fc4 	movi	r4,255
811343a0:	2189803a 	cmpltu	r4,r4,r6
811343a4:	200890fa 	slli	r4,r4,3
811343a8:	3104d83a 	srl	r2,r6,r4
811343ac:	00e04574 	movhi	r3,33045
811343b0:	18c13204 	addi	r3,r3,1224
811343b4:	1885883a 	add	r2,r3,r2
811343b8:	10c00003 	ldbu	r3,0(r2)
811343bc:	00800804 	movi	r2,32
811343c0:	1909883a 	add	r4,r3,r4
811343c4:	1125c83a 	sub	r18,r2,r4
811343c8:	90000526 	beq	r18,zero,811343e0 <__umoddi3+0x9c>
811343cc:	8ca2983a 	sll	r17,r17,r18
811343d0:	8108d83a 	srl	r4,r16,r4
811343d4:	34a6983a 	sll	r19,r6,r18
811343d8:	84a8983a 	sll	r20,r16,r18
811343dc:	2478b03a 	or	fp,r4,r17
811343e0:	982ed43a 	srli	r23,r19,16
811343e4:	e009883a 	mov	r4,fp
811343e8:	9dbfffcc 	andi	r22,r19,65535
811343ec:	b80b883a 	mov	r5,r23
811343f0:	11349e00 	call	811349e0 <__umodsi3>
811343f4:	e009883a 	mov	r4,fp
811343f8:	b80b883a 	mov	r5,r23
811343fc:	102b883a 	mov	r21,r2
81134400:	113497c0 	call	8113497c <__udivsi3>
81134404:	a806943a 	slli	r3,r21,16
81134408:	a008d43a 	srli	r4,r20,16
8113440c:	b085383a 	mul	r2,r22,r2
81134410:	20c8b03a 	or	r4,r4,r3
81134414:	2080032e 	bgeu	r4,r2,81134424 <__umoddi3+0xe0>
81134418:	24c9883a 	add	r4,r4,r19
8113441c:	24c00136 	bltu	r4,r19,81134424 <__umoddi3+0xe0>
81134420:	20811036 	bltu	r4,r2,81134864 <__umoddi3+0x520>
81134424:	20abc83a 	sub	r21,r4,r2
81134428:	b80b883a 	mov	r5,r23
8113442c:	a809883a 	mov	r4,r21
81134430:	11349e00 	call	811349e0 <__umodsi3>
81134434:	1023883a 	mov	r17,r2
81134438:	b80b883a 	mov	r5,r23
8113443c:	a809883a 	mov	r4,r21
81134440:	113497c0 	call	8113497c <__udivsi3>
81134444:	8822943a 	slli	r17,r17,16
81134448:	b085383a 	mul	r2,r22,r2
8113444c:	a0ffffcc 	andi	r3,r20,65535
81134450:	1c46b03a 	or	r3,r3,r17
81134454:	1880042e 	bgeu	r3,r2,81134468 <__umoddi3+0x124>
81134458:	1cc7883a 	add	r3,r3,r19
8113445c:	1cc00236 	bltu	r3,r19,81134468 <__umoddi3+0x124>
81134460:	1880012e 	bgeu	r3,r2,81134468 <__umoddi3+0x124>
81134464:	1cc7883a 	add	r3,r3,r19
81134468:	1885c83a 	sub	r2,r3,r2
8113446c:	1484d83a 	srl	r2,r2,r18
81134470:	0007883a 	mov	r3,zero
81134474:	00004f06 	br	811345b4 <__umoddi3+0x270>
81134478:	29c04c36 	bltu	r5,r7,811345ac <__umoddi3+0x268>
8113447c:	00bfffd4 	movui	r2,65535
81134480:	11c0582e 	bgeu	r2,r7,811345e4 <__umoddi3+0x2a0>
81134484:	00804034 	movhi	r2,256
81134488:	10bfffc4 	addi	r2,r2,-1
8113448c:	11c0e736 	bltu	r2,r7,8113482c <__umoddi3+0x4e8>
81134490:	01000404 	movi	r4,16
81134494:	3904d83a 	srl	r2,r7,r4
81134498:	00e04574 	movhi	r3,33045
8113449c:	18c13204 	addi	r3,r3,1224
811344a0:	1885883a 	add	r2,r3,r2
811344a4:	14c00003 	ldbu	r19,0(r2)
811344a8:	00c00804 	movi	r3,32
811344ac:	9927883a 	add	r19,r19,r4
811344b0:	1ce9c83a 	sub	r20,r3,r19
811344b4:	a000581e 	bne	r20,zero,81134618 <__umoddi3+0x2d4>
811344b8:	3c400136 	bltu	r7,r17,811344c0 <__umoddi3+0x17c>
811344bc:	8180eb36 	bltu	r16,r6,8113486c <__umoddi3+0x528>
811344c0:	8185c83a 	sub	r2,r16,r6
811344c4:	89e3c83a 	sub	r17,r17,r7
811344c8:	8089803a 	cmpltu	r4,r16,r2
811344cc:	8939c83a 	sub	fp,r17,r4
811344d0:	e007883a 	mov	r3,fp
811344d4:	00003706 	br	811345b4 <__umoddi3+0x270>
811344d8:	3000041e 	bne	r6,zero,811344ec <__umoddi3+0x1a8>
811344dc:	000b883a 	mov	r5,zero
811344e0:	01000044 	movi	r4,1
811344e4:	113497c0 	call	8113497c <__udivsi3>
811344e8:	1027883a 	mov	r19,r2
811344ec:	00bfffd4 	movui	r2,65535
811344f0:	14c0402e 	bgeu	r2,r19,811345f4 <__umoddi3+0x2b0>
811344f4:	00804034 	movhi	r2,256
811344f8:	10bfffc4 	addi	r2,r2,-1
811344fc:	14c0cd36 	bltu	r2,r19,81134834 <__umoddi3+0x4f0>
81134500:	00800404 	movi	r2,16
81134504:	9886d83a 	srl	r3,r19,r2
81134508:	01204574 	movhi	r4,33045
8113450c:	21013204 	addi	r4,r4,1224
81134510:	20c7883a 	add	r3,r4,r3
81134514:	18c00003 	ldbu	r3,0(r3)
81134518:	1887883a 	add	r3,r3,r2
8113451c:	00800804 	movi	r2,32
81134520:	10e5c83a 	sub	r18,r2,r3
81134524:	9000901e 	bne	r18,zero,81134768 <__umoddi3+0x424>
81134528:	982cd43a 	srli	r22,r19,16
8113452c:	8ce3c83a 	sub	r17,r17,r19
81134530:	9d7fffcc 	andi	r21,r19,65535
81134534:	b00b883a 	mov	r5,r22
81134538:	8809883a 	mov	r4,r17
8113453c:	11349e00 	call	811349e0 <__umodsi3>
81134540:	8809883a 	mov	r4,r17
81134544:	b00b883a 	mov	r5,r22
81134548:	1021883a 	mov	r16,r2
8113454c:	113497c0 	call	8113497c <__udivsi3>
81134550:	8006943a 	slli	r3,r16,16
81134554:	a008d43a 	srli	r4,r20,16
81134558:	1545383a 	mul	r2,r2,r21
8113455c:	20c8b03a 	or	r4,r4,r3
81134560:	2080042e 	bgeu	r4,r2,81134574 <__umoddi3+0x230>
81134564:	24c9883a 	add	r4,r4,r19
81134568:	24c00236 	bltu	r4,r19,81134574 <__umoddi3+0x230>
8113456c:	2080012e 	bgeu	r4,r2,81134574 <__umoddi3+0x230>
81134570:	24c9883a 	add	r4,r4,r19
81134574:	20a1c83a 	sub	r16,r4,r2
81134578:	b00b883a 	mov	r5,r22
8113457c:	8009883a 	mov	r4,r16
81134580:	11349e00 	call	811349e0 <__umodsi3>
81134584:	1023883a 	mov	r17,r2
81134588:	b00b883a 	mov	r5,r22
8113458c:	8009883a 	mov	r4,r16
81134590:	113497c0 	call	8113497c <__udivsi3>
81134594:	8822943a 	slli	r17,r17,16
81134598:	1545383a 	mul	r2,r2,r21
8113459c:	a53fffcc 	andi	r20,r20,65535
811345a0:	a446b03a 	or	r3,r20,r17
811345a4:	18bfb02e 	bgeu	r3,r2,81134468 <__reset+0xfb114468>
811345a8:	003fab06 	br	81134458 <__reset+0xfb114458>
811345ac:	2005883a 	mov	r2,r4
811345b0:	2807883a 	mov	r3,r5
811345b4:	dfc00b17 	ldw	ra,44(sp)
811345b8:	df000a17 	ldw	fp,40(sp)
811345bc:	ddc00917 	ldw	r23,36(sp)
811345c0:	dd800817 	ldw	r22,32(sp)
811345c4:	dd400717 	ldw	r21,28(sp)
811345c8:	dd000617 	ldw	r20,24(sp)
811345cc:	dcc00517 	ldw	r19,20(sp)
811345d0:	dc800417 	ldw	r18,16(sp)
811345d4:	dc400317 	ldw	r17,12(sp)
811345d8:	dc000217 	ldw	r16,8(sp)
811345dc:	dec00c04 	addi	sp,sp,48
811345e0:	f800283a 	ret
811345e4:	04c03fc4 	movi	r19,255
811345e8:	99c9803a 	cmpltu	r4,r19,r7
811345ec:	200890fa 	slli	r4,r4,3
811345f0:	003fa806 	br	81134494 <__reset+0xfb114494>
811345f4:	00803fc4 	movi	r2,255
811345f8:	14c5803a 	cmpltu	r2,r2,r19
811345fc:	100490fa 	slli	r2,r2,3
81134600:	003fc006 	br	81134504 <__reset+0xfb114504>
81134604:	00804034 	movhi	r2,256
81134608:	10bfffc4 	addi	r2,r2,-1
8113460c:	11808b36 	bltu	r2,r6,8113483c <__umoddi3+0x4f8>
81134610:	01000404 	movi	r4,16
81134614:	003f6406 	br	811343a8 <__reset+0xfb1143a8>
81134618:	34c4d83a 	srl	r2,r6,r19
8113461c:	3d0e983a 	sll	r7,r7,r20
81134620:	8cf8d83a 	srl	fp,r17,r19
81134624:	8d10983a 	sll	r8,r17,r20
81134628:	38aab03a 	or	r21,r7,r2
8113462c:	a82cd43a 	srli	r22,r21,16
81134630:	84e2d83a 	srl	r17,r16,r19
81134634:	e009883a 	mov	r4,fp
81134638:	b00b883a 	mov	r5,r22
8113463c:	8a22b03a 	or	r17,r17,r8
81134640:	3524983a 	sll	r18,r6,r20
81134644:	11349e00 	call	811349e0 <__umodsi3>
81134648:	e009883a 	mov	r4,fp
8113464c:	b00b883a 	mov	r5,r22
81134650:	102f883a 	mov	r23,r2
81134654:	113497c0 	call	8113497c <__udivsi3>
81134658:	100d883a 	mov	r6,r2
8113465c:	b808943a 	slli	r4,r23,16
81134660:	aa3fffcc 	andi	r8,r21,65535
81134664:	8804d43a 	srli	r2,r17,16
81134668:	41af383a 	mul	r23,r8,r6
8113466c:	8520983a 	sll	r16,r16,r20
81134670:	1104b03a 	or	r2,r2,r4
81134674:	15c0042e 	bgeu	r2,r23,81134688 <__umoddi3+0x344>
81134678:	1545883a 	add	r2,r2,r21
8113467c:	30ffffc4 	addi	r3,r6,-1
81134680:	1540742e 	bgeu	r2,r21,81134854 <__umoddi3+0x510>
81134684:	180d883a 	mov	r6,r3
81134688:	15efc83a 	sub	r23,r2,r23
8113468c:	b00b883a 	mov	r5,r22
81134690:	b809883a 	mov	r4,r23
81134694:	d9800115 	stw	r6,4(sp)
81134698:	da000015 	stw	r8,0(sp)
8113469c:	11349e00 	call	811349e0 <__umodsi3>
811346a0:	b00b883a 	mov	r5,r22
811346a4:	b809883a 	mov	r4,r23
811346a8:	1039883a 	mov	fp,r2
811346ac:	113497c0 	call	8113497c <__udivsi3>
811346b0:	da000017 	ldw	r8,0(sp)
811346b4:	e038943a 	slli	fp,fp,16
811346b8:	100b883a 	mov	r5,r2
811346bc:	4089383a 	mul	r4,r8,r2
811346c0:	8a3fffcc 	andi	r8,r17,65535
811346c4:	4710b03a 	or	r8,r8,fp
811346c8:	d9800117 	ldw	r6,4(sp)
811346cc:	4100042e 	bgeu	r8,r4,811346e0 <__umoddi3+0x39c>
811346d0:	4551883a 	add	r8,r8,r21
811346d4:	10bfffc4 	addi	r2,r2,-1
811346d8:	45405a2e 	bgeu	r8,r21,81134844 <__umoddi3+0x500>
811346dc:	100b883a 	mov	r5,r2
811346e0:	300c943a 	slli	r6,r6,16
811346e4:	91ffffcc 	andi	r7,r18,65535
811346e8:	9004d43a 	srli	r2,r18,16
811346ec:	314cb03a 	or	r6,r6,r5
811346f0:	317fffcc 	andi	r5,r6,65535
811346f4:	300cd43a 	srli	r6,r6,16
811346f8:	29d3383a 	mul	r9,r5,r7
811346fc:	288b383a 	mul	r5,r5,r2
81134700:	31cf383a 	mul	r7,r6,r7
81134704:	4806d43a 	srli	r3,r9,16
81134708:	4111c83a 	sub	r8,r8,r4
8113470c:	29cb883a 	add	r5,r5,r7
81134710:	194b883a 	add	r5,r3,r5
81134714:	3085383a 	mul	r2,r6,r2
81134718:	29c0022e 	bgeu	r5,r7,81134724 <__umoddi3+0x3e0>
8113471c:	00c00074 	movhi	r3,1
81134720:	10c5883a 	add	r2,r2,r3
81134724:	2808d43a 	srli	r4,r5,16
81134728:	280a943a 	slli	r5,r5,16
8113472c:	4a7fffcc 	andi	r9,r9,65535
81134730:	2085883a 	add	r2,r4,r2
81134734:	2a4b883a 	add	r5,r5,r9
81134738:	40803636 	bltu	r8,r2,81134814 <__umoddi3+0x4d0>
8113473c:	40804d26 	beq	r8,r2,81134874 <__umoddi3+0x530>
81134740:	4089c83a 	sub	r4,r8,r2
81134744:	280f883a 	mov	r7,r5
81134748:	81cfc83a 	sub	r7,r16,r7
8113474c:	81c7803a 	cmpltu	r3,r16,r7
81134750:	20c7c83a 	sub	r3,r4,r3
81134754:	1cc4983a 	sll	r2,r3,r19
81134758:	3d0ed83a 	srl	r7,r7,r20
8113475c:	1d06d83a 	srl	r3,r3,r20
81134760:	11c4b03a 	or	r2,r2,r7
81134764:	003f9306 	br	811345b4 <__reset+0xfb1145b4>
81134768:	9ca6983a 	sll	r19,r19,r18
8113476c:	88e8d83a 	srl	r20,r17,r3
81134770:	80c4d83a 	srl	r2,r16,r3
81134774:	982cd43a 	srli	r22,r19,16
81134778:	8ca2983a 	sll	r17,r17,r18
8113477c:	a009883a 	mov	r4,r20
81134780:	b00b883a 	mov	r5,r22
81134784:	1478b03a 	or	fp,r2,r17
81134788:	11349e00 	call	811349e0 <__umodsi3>
8113478c:	a009883a 	mov	r4,r20
81134790:	b00b883a 	mov	r5,r22
81134794:	1023883a 	mov	r17,r2
81134798:	113497c0 	call	8113497c <__udivsi3>
8113479c:	9d7fffcc 	andi	r21,r19,65535
811347a0:	880a943a 	slli	r5,r17,16
811347a4:	e008d43a 	srli	r4,fp,16
811347a8:	a885383a 	mul	r2,r21,r2
811347ac:	84a8983a 	sll	r20,r16,r18
811347b0:	2148b03a 	or	r4,r4,r5
811347b4:	2080042e 	bgeu	r4,r2,811347c8 <__umoddi3+0x484>
811347b8:	24c9883a 	add	r4,r4,r19
811347bc:	24c00236 	bltu	r4,r19,811347c8 <__umoddi3+0x484>
811347c0:	2080012e 	bgeu	r4,r2,811347c8 <__umoddi3+0x484>
811347c4:	24c9883a 	add	r4,r4,r19
811347c8:	20a3c83a 	sub	r17,r4,r2
811347cc:	b00b883a 	mov	r5,r22
811347d0:	8809883a 	mov	r4,r17
811347d4:	11349e00 	call	811349e0 <__umodsi3>
811347d8:	102f883a 	mov	r23,r2
811347dc:	8809883a 	mov	r4,r17
811347e0:	b00b883a 	mov	r5,r22
811347e4:	113497c0 	call	8113497c <__udivsi3>
811347e8:	b82e943a 	slli	r23,r23,16
811347ec:	a885383a 	mul	r2,r21,r2
811347f0:	e13fffcc 	andi	r4,fp,65535
811347f4:	25c8b03a 	or	r4,r4,r23
811347f8:	2080042e 	bgeu	r4,r2,8113480c <__umoddi3+0x4c8>
811347fc:	24c9883a 	add	r4,r4,r19
81134800:	24c00236 	bltu	r4,r19,8113480c <__umoddi3+0x4c8>
81134804:	2080012e 	bgeu	r4,r2,8113480c <__umoddi3+0x4c8>
81134808:	24c9883a 	add	r4,r4,r19
8113480c:	20a3c83a 	sub	r17,r4,r2
81134810:	003f4806 	br	81134534 <__reset+0xfb114534>
81134814:	2c8fc83a 	sub	r7,r5,r18
81134818:	1545c83a 	sub	r2,r2,r21
8113481c:	29cb803a 	cmpltu	r5,r5,r7
81134820:	1145c83a 	sub	r2,r2,r5
81134824:	4089c83a 	sub	r4,r8,r2
81134828:	003fc706 	br	81134748 <__reset+0xfb114748>
8113482c:	01000604 	movi	r4,24
81134830:	003f1806 	br	81134494 <__reset+0xfb114494>
81134834:	00800604 	movi	r2,24
81134838:	003f3206 	br	81134504 <__reset+0xfb114504>
8113483c:	01000604 	movi	r4,24
81134840:	003ed906 	br	811343a8 <__reset+0xfb1143a8>
81134844:	413fa52e 	bgeu	r8,r4,811346dc <__reset+0xfb1146dc>
81134848:	297fff84 	addi	r5,r5,-2
8113484c:	4551883a 	add	r8,r8,r21
81134850:	003fa306 	br	811346e0 <__reset+0xfb1146e0>
81134854:	15ff8b2e 	bgeu	r2,r23,81134684 <__reset+0xfb114684>
81134858:	31bfff84 	addi	r6,r6,-2
8113485c:	1545883a 	add	r2,r2,r21
81134860:	003f8906 	br	81134688 <__reset+0xfb114688>
81134864:	24c9883a 	add	r4,r4,r19
81134868:	003eee06 	br	81134424 <__reset+0xfb114424>
8113486c:	8005883a 	mov	r2,r16
81134870:	003f1706 	br	811344d0 <__reset+0xfb1144d0>
81134874:	817fe736 	bltu	r16,r5,81134814 <__reset+0xfb114814>
81134878:	280f883a 	mov	r7,r5
8113487c:	0009883a 	mov	r4,zero
81134880:	003fb106 	br	81134748 <__reset+0xfb114748>

81134884 <__divsi3>:
81134884:	20001b16 	blt	r4,zero,811348f4 <__divsi3+0x70>
81134888:	000f883a 	mov	r7,zero
8113488c:	28001616 	blt	r5,zero,811348e8 <__divsi3+0x64>
81134890:	200d883a 	mov	r6,r4
81134894:	29001a2e 	bgeu	r5,r4,81134900 <__divsi3+0x7c>
81134898:	00800804 	movi	r2,32
8113489c:	00c00044 	movi	r3,1
811348a0:	00000106 	br	811348a8 <__divsi3+0x24>
811348a4:	10000d26 	beq	r2,zero,811348dc <__divsi3+0x58>
811348a8:	294b883a 	add	r5,r5,r5
811348ac:	10bfffc4 	addi	r2,r2,-1
811348b0:	18c7883a 	add	r3,r3,r3
811348b4:	293ffb36 	bltu	r5,r4,811348a4 <__reset+0xfb1148a4>
811348b8:	0005883a 	mov	r2,zero
811348bc:	18000726 	beq	r3,zero,811348dc <__divsi3+0x58>
811348c0:	0005883a 	mov	r2,zero
811348c4:	31400236 	bltu	r6,r5,811348d0 <__divsi3+0x4c>
811348c8:	314dc83a 	sub	r6,r6,r5
811348cc:	10c4b03a 	or	r2,r2,r3
811348d0:	1806d07a 	srli	r3,r3,1
811348d4:	280ad07a 	srli	r5,r5,1
811348d8:	183ffa1e 	bne	r3,zero,811348c4 <__reset+0xfb1148c4>
811348dc:	38000126 	beq	r7,zero,811348e4 <__divsi3+0x60>
811348e0:	0085c83a 	sub	r2,zero,r2
811348e4:	f800283a 	ret
811348e8:	014bc83a 	sub	r5,zero,r5
811348ec:	39c0005c 	xori	r7,r7,1
811348f0:	003fe706 	br	81134890 <__reset+0xfb114890>
811348f4:	0109c83a 	sub	r4,zero,r4
811348f8:	01c00044 	movi	r7,1
811348fc:	003fe306 	br	8113488c <__reset+0xfb11488c>
81134900:	00c00044 	movi	r3,1
81134904:	003fee06 	br	811348c0 <__reset+0xfb1148c0>

81134908 <__modsi3>:
81134908:	20001716 	blt	r4,zero,81134968 <__modsi3+0x60>
8113490c:	000f883a 	mov	r7,zero
81134910:	2005883a 	mov	r2,r4
81134914:	28001216 	blt	r5,zero,81134960 <__modsi3+0x58>
81134918:	2900162e 	bgeu	r5,r4,81134974 <__modsi3+0x6c>
8113491c:	01800804 	movi	r6,32
81134920:	00c00044 	movi	r3,1
81134924:	00000106 	br	8113492c <__modsi3+0x24>
81134928:	30000a26 	beq	r6,zero,81134954 <__modsi3+0x4c>
8113492c:	294b883a 	add	r5,r5,r5
81134930:	31bfffc4 	addi	r6,r6,-1
81134934:	18c7883a 	add	r3,r3,r3
81134938:	293ffb36 	bltu	r5,r4,81134928 <__reset+0xfb114928>
8113493c:	18000526 	beq	r3,zero,81134954 <__modsi3+0x4c>
81134940:	1806d07a 	srli	r3,r3,1
81134944:	11400136 	bltu	r2,r5,8113494c <__modsi3+0x44>
81134948:	1145c83a 	sub	r2,r2,r5
8113494c:	280ad07a 	srli	r5,r5,1
81134950:	183ffb1e 	bne	r3,zero,81134940 <__reset+0xfb114940>
81134954:	38000126 	beq	r7,zero,8113495c <__modsi3+0x54>
81134958:	0085c83a 	sub	r2,zero,r2
8113495c:	f800283a 	ret
81134960:	014bc83a 	sub	r5,zero,r5
81134964:	003fec06 	br	81134918 <__reset+0xfb114918>
81134968:	0109c83a 	sub	r4,zero,r4
8113496c:	01c00044 	movi	r7,1
81134970:	003fe706 	br	81134910 <__reset+0xfb114910>
81134974:	00c00044 	movi	r3,1
81134978:	003ff106 	br	81134940 <__reset+0xfb114940>

8113497c <__udivsi3>:
8113497c:	200d883a 	mov	r6,r4
81134980:	2900152e 	bgeu	r5,r4,811349d8 <__udivsi3+0x5c>
81134984:	28001416 	blt	r5,zero,811349d8 <__udivsi3+0x5c>
81134988:	00800804 	movi	r2,32
8113498c:	00c00044 	movi	r3,1
81134990:	00000206 	br	8113499c <__udivsi3+0x20>
81134994:	10000e26 	beq	r2,zero,811349d0 <__udivsi3+0x54>
81134998:	28000516 	blt	r5,zero,811349b0 <__udivsi3+0x34>
8113499c:	294b883a 	add	r5,r5,r5
811349a0:	10bfffc4 	addi	r2,r2,-1
811349a4:	18c7883a 	add	r3,r3,r3
811349a8:	293ffa36 	bltu	r5,r4,81134994 <__reset+0xfb114994>
811349ac:	18000826 	beq	r3,zero,811349d0 <__udivsi3+0x54>
811349b0:	0005883a 	mov	r2,zero
811349b4:	31400236 	bltu	r6,r5,811349c0 <__udivsi3+0x44>
811349b8:	314dc83a 	sub	r6,r6,r5
811349bc:	10c4b03a 	or	r2,r2,r3
811349c0:	1806d07a 	srli	r3,r3,1
811349c4:	280ad07a 	srli	r5,r5,1
811349c8:	183ffa1e 	bne	r3,zero,811349b4 <__reset+0xfb1149b4>
811349cc:	f800283a 	ret
811349d0:	0005883a 	mov	r2,zero
811349d4:	f800283a 	ret
811349d8:	00c00044 	movi	r3,1
811349dc:	003ff406 	br	811349b0 <__reset+0xfb1149b0>

811349e0 <__umodsi3>:
811349e0:	2005883a 	mov	r2,r4
811349e4:	2900122e 	bgeu	r5,r4,81134a30 <__umodsi3+0x50>
811349e8:	28001116 	blt	r5,zero,81134a30 <__umodsi3+0x50>
811349ec:	01800804 	movi	r6,32
811349f0:	00c00044 	movi	r3,1
811349f4:	00000206 	br	81134a00 <__umodsi3+0x20>
811349f8:	30000c26 	beq	r6,zero,81134a2c <__umodsi3+0x4c>
811349fc:	28000516 	blt	r5,zero,81134a14 <__umodsi3+0x34>
81134a00:	294b883a 	add	r5,r5,r5
81134a04:	31bfffc4 	addi	r6,r6,-1
81134a08:	18c7883a 	add	r3,r3,r3
81134a0c:	293ffa36 	bltu	r5,r4,811349f8 <__reset+0xfb1149f8>
81134a10:	18000626 	beq	r3,zero,81134a2c <__umodsi3+0x4c>
81134a14:	1806d07a 	srli	r3,r3,1
81134a18:	11400136 	bltu	r2,r5,81134a20 <__umodsi3+0x40>
81134a1c:	1145c83a 	sub	r2,r2,r5
81134a20:	280ad07a 	srli	r5,r5,1
81134a24:	183ffb1e 	bne	r3,zero,81134a14 <__reset+0xfb114a14>
81134a28:	f800283a 	ret
81134a2c:	f800283a 	ret
81134a30:	00c00044 	movi	r3,1
81134a34:	003ff706 	br	81134a14 <__reset+0xfb114a14>

81134a38 <__eqsf2>:
81134a38:	2006d5fa 	srli	r3,r4,23
81134a3c:	280cd5fa 	srli	r6,r5,23
81134a40:	01c02034 	movhi	r7,128
81134a44:	39ffffc4 	addi	r7,r7,-1
81134a48:	18c03fcc 	andi	r3,r3,255
81134a4c:	02003fc4 	movi	r8,255
81134a50:	3904703a 	and	r2,r7,r4
81134a54:	31803fcc 	andi	r6,r6,255
81134a58:	394e703a 	and	r7,r7,r5
81134a5c:	2008d7fa 	srli	r4,r4,31
81134a60:	280ad7fa 	srli	r5,r5,31
81134a64:	1a000d26 	beq	r3,r8,81134a9c <__eqsf2+0x64>
81134a68:	02003fc4 	movi	r8,255
81134a6c:	32000826 	beq	r6,r8,81134a90 <__eqsf2+0x58>
81134a70:	19800226 	beq	r3,r6,81134a7c <__eqsf2+0x44>
81134a74:	00800044 	movi	r2,1
81134a78:	f800283a 	ret
81134a7c:	11fffd1e 	bne	r2,r7,81134a74 <__reset+0xfb114a74>
81134a80:	21400926 	beq	r4,r5,81134aa8 <__eqsf2+0x70>
81134a84:	183ffb1e 	bne	r3,zero,81134a74 <__reset+0xfb114a74>
81134a88:	1004c03a 	cmpne	r2,r2,zero
81134a8c:	f800283a 	ret
81134a90:	383ff726 	beq	r7,zero,81134a70 <__reset+0xfb114a70>
81134a94:	00800044 	movi	r2,1
81134a98:	f800283a 	ret
81134a9c:	103ff226 	beq	r2,zero,81134a68 <__reset+0xfb114a68>
81134aa0:	00800044 	movi	r2,1
81134aa4:	f800283a 	ret
81134aa8:	0005883a 	mov	r2,zero
81134aac:	f800283a 	ret

81134ab0 <__gesf2>:
81134ab0:	2004d5fa 	srli	r2,r4,23
81134ab4:	2806d5fa 	srli	r3,r5,23
81134ab8:	01802034 	movhi	r6,128
81134abc:	31bfffc4 	addi	r6,r6,-1
81134ac0:	10803fcc 	andi	r2,r2,255
81134ac4:	01c03fc4 	movi	r7,255
81134ac8:	3110703a 	and	r8,r6,r4
81134acc:	18c03fcc 	andi	r3,r3,255
81134ad0:	314c703a 	and	r6,r6,r5
81134ad4:	2008d7fa 	srli	r4,r4,31
81134ad8:	280ad7fa 	srli	r5,r5,31
81134adc:	11c01926 	beq	r2,r7,81134b44 <__gesf2+0x94>
81134ae0:	01c03fc4 	movi	r7,255
81134ae4:	19c00f26 	beq	r3,r7,81134b24 <__gesf2+0x74>
81134ae8:	1000061e 	bne	r2,zero,81134b04 <__gesf2+0x54>
81134aec:	400f003a 	cmpeq	r7,r8,zero
81134af0:	1800071e 	bne	r3,zero,81134b10 <__gesf2+0x60>
81134af4:	3000061e 	bne	r6,zero,81134b10 <__gesf2+0x60>
81134af8:	0005883a 	mov	r2,zero
81134afc:	40000e1e 	bne	r8,zero,81134b38 <__gesf2+0x88>
81134b00:	f800283a 	ret
81134b04:	18000a1e 	bne	r3,zero,81134b30 <__gesf2+0x80>
81134b08:	30000b26 	beq	r6,zero,81134b38 <__gesf2+0x88>
81134b0c:	000f883a 	mov	r7,zero
81134b10:	29403fcc 	andi	r5,r5,255
81134b14:	38000726 	beq	r7,zero,81134b34 <__gesf2+0x84>
81134b18:	28000826 	beq	r5,zero,81134b3c <__gesf2+0x8c>
81134b1c:	00800044 	movi	r2,1
81134b20:	f800283a 	ret
81134b24:	303ff026 	beq	r6,zero,81134ae8 <__reset+0xfb114ae8>
81134b28:	00bfff84 	movi	r2,-2
81134b2c:	f800283a 	ret
81134b30:	29403fcc 	andi	r5,r5,255
81134b34:	21400526 	beq	r4,r5,81134b4c <__gesf2+0x9c>
81134b38:	203ff826 	beq	r4,zero,81134b1c <__reset+0xfb114b1c>
81134b3c:	00bfffc4 	movi	r2,-1
81134b40:	f800283a 	ret
81134b44:	403fe626 	beq	r8,zero,81134ae0 <__reset+0xfb114ae0>
81134b48:	003ff706 	br	81134b28 <__reset+0xfb114b28>
81134b4c:	18bffa16 	blt	r3,r2,81134b38 <__reset+0xfb114b38>
81134b50:	10c00216 	blt	r2,r3,81134b5c <__gesf2+0xac>
81134b54:	323ff836 	bltu	r6,r8,81134b38 <__reset+0xfb114b38>
81134b58:	4180022e 	bgeu	r8,r6,81134b64 <__gesf2+0xb4>
81134b5c:	203fef1e 	bne	r4,zero,81134b1c <__reset+0xfb114b1c>
81134b60:	003ff606 	br	81134b3c <__reset+0xfb114b3c>
81134b64:	0005883a 	mov	r2,zero
81134b68:	f800283a 	ret

81134b6c <__lesf2>:
81134b6c:	2004d5fa 	srli	r2,r4,23
81134b70:	280cd5fa 	srli	r6,r5,23
81134b74:	00c02034 	movhi	r3,128
81134b78:	18ffffc4 	addi	r3,r3,-1
81134b7c:	10803fcc 	andi	r2,r2,255
81134b80:	01c03fc4 	movi	r7,255
81134b84:	1910703a 	and	r8,r3,r4
81134b88:	31803fcc 	andi	r6,r6,255
81134b8c:	1946703a 	and	r3,r3,r5
81134b90:	2008d7fa 	srli	r4,r4,31
81134b94:	280ad7fa 	srli	r5,r5,31
81134b98:	11c01b26 	beq	r2,r7,81134c08 <__lesf2+0x9c>
81134b9c:	01c03fc4 	movi	r7,255
81134ba0:	31c01126 	beq	r6,r7,81134be8 <__lesf2+0x7c>
81134ba4:	1000071e 	bne	r2,zero,81134bc4 <__lesf2+0x58>
81134ba8:	400f003a 	cmpeq	r7,r8,zero
81134bac:	21003fcc 	andi	r4,r4,255
81134bb0:	3000081e 	bne	r6,zero,81134bd4 <__lesf2+0x68>
81134bb4:	1800071e 	bne	r3,zero,81134bd4 <__lesf2+0x68>
81134bb8:	0005883a 	mov	r2,zero
81134bbc:	40000f1e 	bne	r8,zero,81134bfc <__lesf2+0x90>
81134bc0:	f800283a 	ret
81134bc4:	21003fcc 	andi	r4,r4,255
81134bc8:	30000a1e 	bne	r6,zero,81134bf4 <__lesf2+0x88>
81134bcc:	18000b26 	beq	r3,zero,81134bfc <__lesf2+0x90>
81134bd0:	000f883a 	mov	r7,zero
81134bd4:	29403fcc 	andi	r5,r5,255
81134bd8:	38000726 	beq	r7,zero,81134bf8 <__lesf2+0x8c>
81134bdc:	28000826 	beq	r5,zero,81134c00 <__lesf2+0x94>
81134be0:	00800044 	movi	r2,1
81134be4:	f800283a 	ret
81134be8:	183fee26 	beq	r3,zero,81134ba4 <__reset+0xfb114ba4>
81134bec:	00800084 	movi	r2,2
81134bf0:	f800283a 	ret
81134bf4:	29403fcc 	andi	r5,r5,255
81134bf8:	21400626 	beq	r4,r5,81134c14 <__lesf2+0xa8>
81134bfc:	203ff826 	beq	r4,zero,81134be0 <__reset+0xfb114be0>
81134c00:	00bfffc4 	movi	r2,-1
81134c04:	f800283a 	ret
81134c08:	403fe426 	beq	r8,zero,81134b9c <__reset+0xfb114b9c>
81134c0c:	00800084 	movi	r2,2
81134c10:	f800283a 	ret
81134c14:	30bff916 	blt	r6,r2,81134bfc <__reset+0xfb114bfc>
81134c18:	11800216 	blt	r2,r6,81134c24 <__lesf2+0xb8>
81134c1c:	1a3ff736 	bltu	r3,r8,81134bfc <__reset+0xfb114bfc>
81134c20:	40c0022e 	bgeu	r8,r3,81134c2c <__lesf2+0xc0>
81134c24:	203fee1e 	bne	r4,zero,81134be0 <__reset+0xfb114be0>
81134c28:	003ff506 	br	81134c00 <__reset+0xfb114c00>
81134c2c:	0005883a 	mov	r2,zero
81134c30:	f800283a 	ret

81134c34 <__adddf3>:
81134c34:	02c00434 	movhi	r11,16
81134c38:	5affffc4 	addi	r11,r11,-1
81134c3c:	2806d7fa 	srli	r3,r5,31
81134c40:	2ad4703a 	and	r10,r5,r11
81134c44:	3ad2703a 	and	r9,r7,r11
81134c48:	3804d53a 	srli	r2,r7,20
81134c4c:	3018d77a 	srli	r12,r6,29
81134c50:	280ad53a 	srli	r5,r5,20
81134c54:	501490fa 	slli	r10,r10,3
81134c58:	2010d77a 	srli	r8,r4,29
81134c5c:	481290fa 	slli	r9,r9,3
81134c60:	380ed7fa 	srli	r7,r7,31
81134c64:	defffb04 	addi	sp,sp,-20
81134c68:	de00012e 	bgeu	sp,et,81134c70 <__adddf3+0x3c>
81134c6c:	003b68fa 	trap	3
81134c70:	dc800215 	stw	r18,8(sp)
81134c74:	dc400115 	stw	r17,4(sp)
81134c78:	dc000015 	stw	r16,0(sp)
81134c7c:	dfc00415 	stw	ra,16(sp)
81134c80:	dcc00315 	stw	r19,12(sp)
81134c84:	1c803fcc 	andi	r18,r3,255
81134c88:	2c01ffcc 	andi	r16,r5,2047
81134c8c:	5210b03a 	or	r8,r10,r8
81134c90:	202290fa 	slli	r17,r4,3
81134c94:	1081ffcc 	andi	r2,r2,2047
81134c98:	4b12b03a 	or	r9,r9,r12
81134c9c:	300c90fa 	slli	r6,r6,3
81134ca0:	91c07526 	beq	r18,r7,81134e78 <__adddf3+0x244>
81134ca4:	8087c83a 	sub	r3,r16,r2
81134ca8:	00c0ab0e 	bge	zero,r3,81134f58 <__adddf3+0x324>
81134cac:	10002a1e 	bne	r2,zero,81134d58 <__adddf3+0x124>
81134cb0:	4984b03a 	or	r2,r9,r6
81134cb4:	1000961e 	bne	r2,zero,81134f10 <__adddf3+0x2dc>
81134cb8:	888001cc 	andi	r2,r17,7
81134cbc:	10000726 	beq	r2,zero,81134cdc <__adddf3+0xa8>
81134cc0:	888003cc 	andi	r2,r17,15
81134cc4:	00c00104 	movi	r3,4
81134cc8:	10c00426 	beq	r2,r3,81134cdc <__adddf3+0xa8>
81134ccc:	88c7883a 	add	r3,r17,r3
81134cd0:	1c63803a 	cmpltu	r17,r3,r17
81134cd4:	4451883a 	add	r8,r8,r17
81134cd8:	1823883a 	mov	r17,r3
81134cdc:	4080202c 	andhi	r2,r8,128
81134ce0:	10005926 	beq	r2,zero,81134e48 <__adddf3+0x214>
81134ce4:	84000044 	addi	r16,r16,1
81134ce8:	0081ffc4 	movi	r2,2047
81134cec:	8080ba26 	beq	r16,r2,81134fd8 <__adddf3+0x3a4>
81134cf0:	00bfe034 	movhi	r2,65408
81134cf4:	10bfffc4 	addi	r2,r2,-1
81134cf8:	4090703a 	and	r8,r8,r2
81134cfc:	4004977a 	slli	r2,r8,29
81134d00:	4010927a 	slli	r8,r8,9
81134d04:	8822d0fa 	srli	r17,r17,3
81134d08:	8401ffcc 	andi	r16,r16,2047
81134d0c:	4010d33a 	srli	r8,r8,12
81134d10:	9007883a 	mov	r3,r18
81134d14:	1444b03a 	or	r2,r2,r17
81134d18:	8401ffcc 	andi	r16,r16,2047
81134d1c:	8020953a 	slli	r16,r16,20
81134d20:	18c03fcc 	andi	r3,r3,255
81134d24:	01000434 	movhi	r4,16
81134d28:	213fffc4 	addi	r4,r4,-1
81134d2c:	180697fa 	slli	r3,r3,31
81134d30:	4110703a 	and	r8,r8,r4
81134d34:	4410b03a 	or	r8,r8,r16
81134d38:	40c6b03a 	or	r3,r8,r3
81134d3c:	dfc00417 	ldw	ra,16(sp)
81134d40:	dcc00317 	ldw	r19,12(sp)
81134d44:	dc800217 	ldw	r18,8(sp)
81134d48:	dc400117 	ldw	r17,4(sp)
81134d4c:	dc000017 	ldw	r16,0(sp)
81134d50:	dec00504 	addi	sp,sp,20
81134d54:	f800283a 	ret
81134d58:	0081ffc4 	movi	r2,2047
81134d5c:	80bfd626 	beq	r16,r2,81134cb8 <__reset+0xfb114cb8>
81134d60:	4a402034 	orhi	r9,r9,128
81134d64:	00800e04 	movi	r2,56
81134d68:	10c09f16 	blt	r2,r3,81134fe8 <__adddf3+0x3b4>
81134d6c:	008007c4 	movi	r2,31
81134d70:	10c0c216 	blt	r2,r3,8113507c <__adddf3+0x448>
81134d74:	00800804 	movi	r2,32
81134d78:	10c5c83a 	sub	r2,r2,r3
81134d7c:	488a983a 	sll	r5,r9,r2
81134d80:	30c8d83a 	srl	r4,r6,r3
81134d84:	3084983a 	sll	r2,r6,r2
81134d88:	48c6d83a 	srl	r3,r9,r3
81134d8c:	290cb03a 	or	r6,r5,r4
81134d90:	1004c03a 	cmpne	r2,r2,zero
81134d94:	308cb03a 	or	r6,r6,r2
81134d98:	898dc83a 	sub	r6,r17,r6
81134d9c:	89a3803a 	cmpltu	r17,r17,r6
81134da0:	40d1c83a 	sub	r8,r8,r3
81134da4:	4451c83a 	sub	r8,r8,r17
81134da8:	3023883a 	mov	r17,r6
81134dac:	4080202c 	andhi	r2,r8,128
81134db0:	10002326 	beq	r2,zero,81134e40 <__adddf3+0x20c>
81134db4:	04c02034 	movhi	r19,128
81134db8:	9cffffc4 	addi	r19,r19,-1
81134dbc:	44e6703a 	and	r19,r8,r19
81134dc0:	98007626 	beq	r19,zero,81134f9c <__adddf3+0x368>
81134dc4:	9809883a 	mov	r4,r19
81134dc8:	112116c0 	call	8112116c <__clzsi2>
81134dcc:	10fffe04 	addi	r3,r2,-8
81134dd0:	010007c4 	movi	r4,31
81134dd4:	20c07716 	blt	r4,r3,81134fb4 <__adddf3+0x380>
81134dd8:	00800804 	movi	r2,32
81134ddc:	10c5c83a 	sub	r2,r2,r3
81134de0:	8884d83a 	srl	r2,r17,r2
81134de4:	98d0983a 	sll	r8,r19,r3
81134de8:	88e2983a 	sll	r17,r17,r3
81134dec:	1204b03a 	or	r2,r2,r8
81134df0:	1c007416 	blt	r3,r16,81134fc4 <__adddf3+0x390>
81134df4:	1c21c83a 	sub	r16,r3,r16
81134df8:	82000044 	addi	r8,r16,1
81134dfc:	00c007c4 	movi	r3,31
81134e00:	1a009116 	blt	r3,r8,81135048 <__adddf3+0x414>
81134e04:	00c00804 	movi	r3,32
81134e08:	1a07c83a 	sub	r3,r3,r8
81134e0c:	8a08d83a 	srl	r4,r17,r8
81134e10:	88e2983a 	sll	r17,r17,r3
81134e14:	10c6983a 	sll	r3,r2,r3
81134e18:	1210d83a 	srl	r8,r2,r8
81134e1c:	8804c03a 	cmpne	r2,r17,zero
81134e20:	1906b03a 	or	r3,r3,r4
81134e24:	18a2b03a 	or	r17,r3,r2
81134e28:	0021883a 	mov	r16,zero
81134e2c:	003fa206 	br	81134cb8 <__reset+0xfb114cb8>
81134e30:	1890b03a 	or	r8,r3,r2
81134e34:	40017d26 	beq	r8,zero,8113542c <__adddf3+0x7f8>
81134e38:	1011883a 	mov	r8,r2
81134e3c:	1823883a 	mov	r17,r3
81134e40:	888001cc 	andi	r2,r17,7
81134e44:	103f9e1e 	bne	r2,zero,81134cc0 <__reset+0xfb114cc0>
81134e48:	4004977a 	slli	r2,r8,29
81134e4c:	8822d0fa 	srli	r17,r17,3
81134e50:	4010d0fa 	srli	r8,r8,3
81134e54:	9007883a 	mov	r3,r18
81134e58:	1444b03a 	or	r2,r2,r17
81134e5c:	0101ffc4 	movi	r4,2047
81134e60:	81002426 	beq	r16,r4,81134ef4 <__adddf3+0x2c0>
81134e64:	8120703a 	and	r16,r16,r4
81134e68:	01000434 	movhi	r4,16
81134e6c:	213fffc4 	addi	r4,r4,-1
81134e70:	4110703a 	and	r8,r8,r4
81134e74:	003fa806 	br	81134d18 <__reset+0xfb114d18>
81134e78:	8089c83a 	sub	r4,r16,r2
81134e7c:	01005e0e 	bge	zero,r4,81134ff8 <__adddf3+0x3c4>
81134e80:	10002b26 	beq	r2,zero,81134f30 <__adddf3+0x2fc>
81134e84:	0081ffc4 	movi	r2,2047
81134e88:	80bf8b26 	beq	r16,r2,81134cb8 <__reset+0xfb114cb8>
81134e8c:	4a402034 	orhi	r9,r9,128
81134e90:	00800e04 	movi	r2,56
81134e94:	1100a40e 	bge	r2,r4,81135128 <__adddf3+0x4f4>
81134e98:	498cb03a 	or	r6,r9,r6
81134e9c:	300ac03a 	cmpne	r5,r6,zero
81134ea0:	0013883a 	mov	r9,zero
81134ea4:	2c4b883a 	add	r5,r5,r17
81134ea8:	2c63803a 	cmpltu	r17,r5,r17
81134eac:	4a11883a 	add	r8,r9,r8
81134eb0:	8a11883a 	add	r8,r17,r8
81134eb4:	2823883a 	mov	r17,r5
81134eb8:	4080202c 	andhi	r2,r8,128
81134ebc:	103fe026 	beq	r2,zero,81134e40 <__reset+0xfb114e40>
81134ec0:	84000044 	addi	r16,r16,1
81134ec4:	0081ffc4 	movi	r2,2047
81134ec8:	8080d226 	beq	r16,r2,81135214 <__adddf3+0x5e0>
81134ecc:	00bfe034 	movhi	r2,65408
81134ed0:	10bfffc4 	addi	r2,r2,-1
81134ed4:	4090703a 	and	r8,r8,r2
81134ed8:	880ad07a 	srli	r5,r17,1
81134edc:	400897fa 	slli	r4,r8,31
81134ee0:	88c0004c 	andi	r3,r17,1
81134ee4:	28e2b03a 	or	r17,r5,r3
81134ee8:	4010d07a 	srli	r8,r8,1
81134eec:	2462b03a 	or	r17,r4,r17
81134ef0:	003f7106 	br	81134cb8 <__reset+0xfb114cb8>
81134ef4:	4088b03a 	or	r4,r8,r2
81134ef8:	20014526 	beq	r4,zero,81135410 <__adddf3+0x7dc>
81134efc:	01000434 	movhi	r4,16
81134f00:	42000234 	orhi	r8,r8,8
81134f04:	213fffc4 	addi	r4,r4,-1
81134f08:	4110703a 	and	r8,r8,r4
81134f0c:	003f8206 	br	81134d18 <__reset+0xfb114d18>
81134f10:	18ffffc4 	addi	r3,r3,-1
81134f14:	1800491e 	bne	r3,zero,8113503c <__adddf3+0x408>
81134f18:	898bc83a 	sub	r5,r17,r6
81134f1c:	8963803a 	cmpltu	r17,r17,r5
81134f20:	4251c83a 	sub	r8,r8,r9
81134f24:	4451c83a 	sub	r8,r8,r17
81134f28:	2823883a 	mov	r17,r5
81134f2c:	003f9f06 	br	81134dac <__reset+0xfb114dac>
81134f30:	4984b03a 	or	r2,r9,r6
81134f34:	103f6026 	beq	r2,zero,81134cb8 <__reset+0xfb114cb8>
81134f38:	213fffc4 	addi	r4,r4,-1
81134f3c:	2000931e 	bne	r4,zero,8113518c <__adddf3+0x558>
81134f40:	898d883a 	add	r6,r17,r6
81134f44:	3463803a 	cmpltu	r17,r6,r17
81134f48:	4251883a 	add	r8,r8,r9
81134f4c:	8a11883a 	add	r8,r17,r8
81134f50:	3023883a 	mov	r17,r6
81134f54:	003fd806 	br	81134eb8 <__reset+0xfb114eb8>
81134f58:	1800541e 	bne	r3,zero,811350ac <__adddf3+0x478>
81134f5c:	80800044 	addi	r2,r16,1
81134f60:	1081ffcc 	andi	r2,r2,2047
81134f64:	00c00044 	movi	r3,1
81134f68:	1880a00e 	bge	r3,r2,811351ec <__adddf3+0x5b8>
81134f6c:	8989c83a 	sub	r4,r17,r6
81134f70:	8905803a 	cmpltu	r2,r17,r4
81134f74:	4267c83a 	sub	r19,r8,r9
81134f78:	98a7c83a 	sub	r19,r19,r2
81134f7c:	9880202c 	andhi	r2,r19,128
81134f80:	10006326 	beq	r2,zero,81135110 <__adddf3+0x4dc>
81134f84:	3463c83a 	sub	r17,r6,r17
81134f88:	4a07c83a 	sub	r3,r9,r8
81134f8c:	344d803a 	cmpltu	r6,r6,r17
81134f90:	19a7c83a 	sub	r19,r3,r6
81134f94:	3825883a 	mov	r18,r7
81134f98:	983f8a1e 	bne	r19,zero,81134dc4 <__reset+0xfb114dc4>
81134f9c:	8809883a 	mov	r4,r17
81134fa0:	112116c0 	call	8112116c <__clzsi2>
81134fa4:	10800804 	addi	r2,r2,32
81134fa8:	10fffe04 	addi	r3,r2,-8
81134fac:	010007c4 	movi	r4,31
81134fb0:	20ff890e 	bge	r4,r3,81134dd8 <__reset+0xfb114dd8>
81134fb4:	10bff604 	addi	r2,r2,-40
81134fb8:	8884983a 	sll	r2,r17,r2
81134fbc:	0023883a 	mov	r17,zero
81134fc0:	1c3f8c0e 	bge	r3,r16,81134df4 <__reset+0xfb114df4>
81134fc4:	023fe034 	movhi	r8,65408
81134fc8:	423fffc4 	addi	r8,r8,-1
81134fcc:	80e1c83a 	sub	r16,r16,r3
81134fd0:	1210703a 	and	r8,r2,r8
81134fd4:	003f3806 	br	81134cb8 <__reset+0xfb114cb8>
81134fd8:	9007883a 	mov	r3,r18
81134fdc:	0011883a 	mov	r8,zero
81134fe0:	0005883a 	mov	r2,zero
81134fe4:	003f4c06 	br	81134d18 <__reset+0xfb114d18>
81134fe8:	498cb03a 	or	r6,r9,r6
81134fec:	300cc03a 	cmpne	r6,r6,zero
81134ff0:	0007883a 	mov	r3,zero
81134ff4:	003f6806 	br	81134d98 <__reset+0xfb114d98>
81134ff8:	20009c1e 	bne	r4,zero,8113526c <__adddf3+0x638>
81134ffc:	80800044 	addi	r2,r16,1
81135000:	1141ffcc 	andi	r5,r2,2047
81135004:	01000044 	movi	r4,1
81135008:	2140670e 	bge	r4,r5,811351a8 <__adddf3+0x574>
8113500c:	0101ffc4 	movi	r4,2047
81135010:	11007f26 	beq	r2,r4,81135210 <__adddf3+0x5dc>
81135014:	898d883a 	add	r6,r17,r6
81135018:	4247883a 	add	r3,r8,r9
8113501c:	3451803a 	cmpltu	r8,r6,r17
81135020:	40d1883a 	add	r8,r8,r3
81135024:	402297fa 	slli	r17,r8,31
81135028:	300cd07a 	srli	r6,r6,1
8113502c:	4010d07a 	srli	r8,r8,1
81135030:	1021883a 	mov	r16,r2
81135034:	89a2b03a 	or	r17,r17,r6
81135038:	003f1f06 	br	81134cb8 <__reset+0xfb114cb8>
8113503c:	0081ffc4 	movi	r2,2047
81135040:	80bf481e 	bne	r16,r2,81134d64 <__reset+0xfb114d64>
81135044:	003f1c06 	br	81134cb8 <__reset+0xfb114cb8>
81135048:	843ff844 	addi	r16,r16,-31
8113504c:	01000804 	movi	r4,32
81135050:	1406d83a 	srl	r3,r2,r16
81135054:	41005026 	beq	r8,r4,81135198 <__adddf3+0x564>
81135058:	01001004 	movi	r4,64
8113505c:	2211c83a 	sub	r8,r4,r8
81135060:	1204983a 	sll	r2,r2,r8
81135064:	88a2b03a 	or	r17,r17,r2
81135068:	8822c03a 	cmpne	r17,r17,zero
8113506c:	1c62b03a 	or	r17,r3,r17
81135070:	0011883a 	mov	r8,zero
81135074:	0021883a 	mov	r16,zero
81135078:	003f7106 	br	81134e40 <__reset+0xfb114e40>
8113507c:	193ff804 	addi	r4,r3,-32
81135080:	00800804 	movi	r2,32
81135084:	4908d83a 	srl	r4,r9,r4
81135088:	18804526 	beq	r3,r2,811351a0 <__adddf3+0x56c>
8113508c:	00801004 	movi	r2,64
81135090:	10c5c83a 	sub	r2,r2,r3
81135094:	4886983a 	sll	r3,r9,r2
81135098:	198cb03a 	or	r6,r3,r6
8113509c:	300cc03a 	cmpne	r6,r6,zero
811350a0:	218cb03a 	or	r6,r4,r6
811350a4:	0007883a 	mov	r3,zero
811350a8:	003f3b06 	br	81134d98 <__reset+0xfb114d98>
811350ac:	80002a26 	beq	r16,zero,81135158 <__adddf3+0x524>
811350b0:	0101ffc4 	movi	r4,2047
811350b4:	11006826 	beq	r2,r4,81135258 <__adddf3+0x624>
811350b8:	00c7c83a 	sub	r3,zero,r3
811350bc:	42002034 	orhi	r8,r8,128
811350c0:	01000e04 	movi	r4,56
811350c4:	20c07c16 	blt	r4,r3,811352b8 <__adddf3+0x684>
811350c8:	010007c4 	movi	r4,31
811350cc:	20c0da16 	blt	r4,r3,81135438 <__adddf3+0x804>
811350d0:	01000804 	movi	r4,32
811350d4:	20c9c83a 	sub	r4,r4,r3
811350d8:	4114983a 	sll	r10,r8,r4
811350dc:	88cad83a 	srl	r5,r17,r3
811350e0:	8908983a 	sll	r4,r17,r4
811350e4:	40c6d83a 	srl	r3,r8,r3
811350e8:	5162b03a 	or	r17,r10,r5
811350ec:	2008c03a 	cmpne	r4,r4,zero
811350f0:	8922b03a 	or	r17,r17,r4
811350f4:	3463c83a 	sub	r17,r6,r17
811350f8:	48c7c83a 	sub	r3,r9,r3
811350fc:	344d803a 	cmpltu	r6,r6,r17
81135100:	1991c83a 	sub	r8,r3,r6
81135104:	1021883a 	mov	r16,r2
81135108:	3825883a 	mov	r18,r7
8113510c:	003f2706 	br	81134dac <__reset+0xfb114dac>
81135110:	24d0b03a 	or	r8,r4,r19
81135114:	40001b1e 	bne	r8,zero,81135184 <__adddf3+0x550>
81135118:	0005883a 	mov	r2,zero
8113511c:	0007883a 	mov	r3,zero
81135120:	0021883a 	mov	r16,zero
81135124:	003f4d06 	br	81134e5c <__reset+0xfb114e5c>
81135128:	008007c4 	movi	r2,31
8113512c:	11003c16 	blt	r2,r4,81135220 <__adddf3+0x5ec>
81135130:	00800804 	movi	r2,32
81135134:	1105c83a 	sub	r2,r2,r4
81135138:	488e983a 	sll	r7,r9,r2
8113513c:	310ad83a 	srl	r5,r6,r4
81135140:	3084983a 	sll	r2,r6,r2
81135144:	4912d83a 	srl	r9,r9,r4
81135148:	394ab03a 	or	r5,r7,r5
8113514c:	1004c03a 	cmpne	r2,r2,zero
81135150:	288ab03a 	or	r5,r5,r2
81135154:	003f5306 	br	81134ea4 <__reset+0xfb114ea4>
81135158:	4448b03a 	or	r4,r8,r17
8113515c:	20003e26 	beq	r4,zero,81135258 <__adddf3+0x624>
81135160:	00c6303a 	nor	r3,zero,r3
81135164:	18003a1e 	bne	r3,zero,81135250 <__adddf3+0x61c>
81135168:	3463c83a 	sub	r17,r6,r17
8113516c:	4a07c83a 	sub	r3,r9,r8
81135170:	344d803a 	cmpltu	r6,r6,r17
81135174:	1991c83a 	sub	r8,r3,r6
81135178:	1021883a 	mov	r16,r2
8113517c:	3825883a 	mov	r18,r7
81135180:	003f0a06 	br	81134dac <__reset+0xfb114dac>
81135184:	2023883a 	mov	r17,r4
81135188:	003f0d06 	br	81134dc0 <__reset+0xfb114dc0>
8113518c:	0081ffc4 	movi	r2,2047
81135190:	80bf3f1e 	bne	r16,r2,81134e90 <__reset+0xfb114e90>
81135194:	003ec806 	br	81134cb8 <__reset+0xfb114cb8>
81135198:	0005883a 	mov	r2,zero
8113519c:	003fb106 	br	81135064 <__reset+0xfb115064>
811351a0:	0007883a 	mov	r3,zero
811351a4:	003fbc06 	br	81135098 <__reset+0xfb115098>
811351a8:	4444b03a 	or	r2,r8,r17
811351ac:	8000871e 	bne	r16,zero,811353cc <__adddf3+0x798>
811351b0:	1000ba26 	beq	r2,zero,8113549c <__adddf3+0x868>
811351b4:	4984b03a 	or	r2,r9,r6
811351b8:	103ebf26 	beq	r2,zero,81134cb8 <__reset+0xfb114cb8>
811351bc:	8985883a 	add	r2,r17,r6
811351c0:	4247883a 	add	r3,r8,r9
811351c4:	1451803a 	cmpltu	r8,r2,r17
811351c8:	40d1883a 	add	r8,r8,r3
811351cc:	40c0202c 	andhi	r3,r8,128
811351d0:	1023883a 	mov	r17,r2
811351d4:	183f1a26 	beq	r3,zero,81134e40 <__reset+0xfb114e40>
811351d8:	00bfe034 	movhi	r2,65408
811351dc:	10bfffc4 	addi	r2,r2,-1
811351e0:	2021883a 	mov	r16,r4
811351e4:	4090703a 	and	r8,r8,r2
811351e8:	003eb306 	br	81134cb8 <__reset+0xfb114cb8>
811351ec:	4444b03a 	or	r2,r8,r17
811351f0:	8000291e 	bne	r16,zero,81135298 <__adddf3+0x664>
811351f4:	10004b1e 	bne	r2,zero,81135324 <__adddf3+0x6f0>
811351f8:	4990b03a 	or	r8,r9,r6
811351fc:	40008b26 	beq	r8,zero,8113542c <__adddf3+0x7f8>
81135200:	4811883a 	mov	r8,r9
81135204:	3023883a 	mov	r17,r6
81135208:	3825883a 	mov	r18,r7
8113520c:	003eaa06 	br	81134cb8 <__reset+0xfb114cb8>
81135210:	1021883a 	mov	r16,r2
81135214:	0011883a 	mov	r8,zero
81135218:	0005883a 	mov	r2,zero
8113521c:	003f0f06 	br	81134e5c <__reset+0xfb114e5c>
81135220:	217ff804 	addi	r5,r4,-32
81135224:	00800804 	movi	r2,32
81135228:	494ad83a 	srl	r5,r9,r5
8113522c:	20807d26 	beq	r4,r2,81135424 <__adddf3+0x7f0>
81135230:	00801004 	movi	r2,64
81135234:	1109c83a 	sub	r4,r2,r4
81135238:	4912983a 	sll	r9,r9,r4
8113523c:	498cb03a 	or	r6,r9,r6
81135240:	300cc03a 	cmpne	r6,r6,zero
81135244:	298ab03a 	or	r5,r5,r6
81135248:	0013883a 	mov	r9,zero
8113524c:	003f1506 	br	81134ea4 <__reset+0xfb114ea4>
81135250:	0101ffc4 	movi	r4,2047
81135254:	113f9a1e 	bne	r2,r4,811350c0 <__reset+0xfb1150c0>
81135258:	4811883a 	mov	r8,r9
8113525c:	3023883a 	mov	r17,r6
81135260:	1021883a 	mov	r16,r2
81135264:	3825883a 	mov	r18,r7
81135268:	003e9306 	br	81134cb8 <__reset+0xfb114cb8>
8113526c:	8000161e 	bne	r16,zero,811352c8 <__adddf3+0x694>
81135270:	444ab03a 	or	r5,r8,r17
81135274:	28005126 	beq	r5,zero,811353bc <__adddf3+0x788>
81135278:	0108303a 	nor	r4,zero,r4
8113527c:	20004d1e 	bne	r4,zero,811353b4 <__adddf3+0x780>
81135280:	89a3883a 	add	r17,r17,r6
81135284:	4253883a 	add	r9,r8,r9
81135288:	898d803a 	cmpltu	r6,r17,r6
8113528c:	3251883a 	add	r8,r6,r9
81135290:	1021883a 	mov	r16,r2
81135294:	003f0806 	br	81134eb8 <__reset+0xfb114eb8>
81135298:	1000301e 	bne	r2,zero,8113535c <__adddf3+0x728>
8113529c:	4984b03a 	or	r2,r9,r6
811352a0:	10007126 	beq	r2,zero,81135468 <__adddf3+0x834>
811352a4:	4811883a 	mov	r8,r9
811352a8:	3023883a 	mov	r17,r6
811352ac:	3825883a 	mov	r18,r7
811352b0:	0401ffc4 	movi	r16,2047
811352b4:	003e8006 	br	81134cb8 <__reset+0xfb114cb8>
811352b8:	4462b03a 	or	r17,r8,r17
811352bc:	8822c03a 	cmpne	r17,r17,zero
811352c0:	0007883a 	mov	r3,zero
811352c4:	003f8b06 	br	811350f4 <__reset+0xfb1150f4>
811352c8:	0141ffc4 	movi	r5,2047
811352cc:	11403b26 	beq	r2,r5,811353bc <__adddf3+0x788>
811352d0:	0109c83a 	sub	r4,zero,r4
811352d4:	42002034 	orhi	r8,r8,128
811352d8:	01400e04 	movi	r5,56
811352dc:	29006716 	blt	r5,r4,8113547c <__adddf3+0x848>
811352e0:	014007c4 	movi	r5,31
811352e4:	29007016 	blt	r5,r4,811354a8 <__adddf3+0x874>
811352e8:	01400804 	movi	r5,32
811352ec:	290bc83a 	sub	r5,r5,r4
811352f0:	4154983a 	sll	r10,r8,r5
811352f4:	890ed83a 	srl	r7,r17,r4
811352f8:	894a983a 	sll	r5,r17,r5
811352fc:	4108d83a 	srl	r4,r8,r4
81135300:	51e2b03a 	or	r17,r10,r7
81135304:	280ac03a 	cmpne	r5,r5,zero
81135308:	8962b03a 	or	r17,r17,r5
8113530c:	89a3883a 	add	r17,r17,r6
81135310:	2253883a 	add	r9,r4,r9
81135314:	898d803a 	cmpltu	r6,r17,r6
81135318:	3251883a 	add	r8,r6,r9
8113531c:	1021883a 	mov	r16,r2
81135320:	003ee506 	br	81134eb8 <__reset+0xfb114eb8>
81135324:	4984b03a 	or	r2,r9,r6
81135328:	103e6326 	beq	r2,zero,81134cb8 <__reset+0xfb114cb8>
8113532c:	8987c83a 	sub	r3,r17,r6
81135330:	88c9803a 	cmpltu	r4,r17,r3
81135334:	4245c83a 	sub	r2,r8,r9
81135338:	1105c83a 	sub	r2,r2,r4
8113533c:	1100202c 	andhi	r4,r2,128
81135340:	203ebb26 	beq	r4,zero,81134e30 <__reset+0xfb114e30>
81135344:	3463c83a 	sub	r17,r6,r17
81135348:	4a07c83a 	sub	r3,r9,r8
8113534c:	344d803a 	cmpltu	r6,r6,r17
81135350:	1991c83a 	sub	r8,r3,r6
81135354:	3825883a 	mov	r18,r7
81135358:	003e5706 	br	81134cb8 <__reset+0xfb114cb8>
8113535c:	4984b03a 	or	r2,r9,r6
81135360:	10002e26 	beq	r2,zero,8113541c <__adddf3+0x7e8>
81135364:	4004d0fa 	srli	r2,r8,3
81135368:	8822d0fa 	srli	r17,r17,3
8113536c:	4010977a 	slli	r8,r8,29
81135370:	10c0022c 	andhi	r3,r2,8
81135374:	4462b03a 	or	r17,r8,r17
81135378:	18000826 	beq	r3,zero,8113539c <__adddf3+0x768>
8113537c:	4808d0fa 	srli	r4,r9,3
81135380:	20c0022c 	andhi	r3,r4,8
81135384:	1800051e 	bne	r3,zero,8113539c <__adddf3+0x768>
81135388:	300cd0fa 	srli	r6,r6,3
8113538c:	4806977a 	slli	r3,r9,29
81135390:	2005883a 	mov	r2,r4
81135394:	3825883a 	mov	r18,r7
81135398:	19a2b03a 	or	r17,r3,r6
8113539c:	8810d77a 	srli	r8,r17,29
811353a0:	100490fa 	slli	r2,r2,3
811353a4:	882290fa 	slli	r17,r17,3
811353a8:	0401ffc4 	movi	r16,2047
811353ac:	4090b03a 	or	r8,r8,r2
811353b0:	003e4106 	br	81134cb8 <__reset+0xfb114cb8>
811353b4:	0141ffc4 	movi	r5,2047
811353b8:	117fc71e 	bne	r2,r5,811352d8 <__reset+0xfb1152d8>
811353bc:	4811883a 	mov	r8,r9
811353c0:	3023883a 	mov	r17,r6
811353c4:	1021883a 	mov	r16,r2
811353c8:	003e3b06 	br	81134cb8 <__reset+0xfb114cb8>
811353cc:	10002f26 	beq	r2,zero,8113548c <__adddf3+0x858>
811353d0:	4984b03a 	or	r2,r9,r6
811353d4:	10001126 	beq	r2,zero,8113541c <__adddf3+0x7e8>
811353d8:	4004d0fa 	srli	r2,r8,3
811353dc:	8822d0fa 	srli	r17,r17,3
811353e0:	4010977a 	slli	r8,r8,29
811353e4:	10c0022c 	andhi	r3,r2,8
811353e8:	4462b03a 	or	r17,r8,r17
811353ec:	183feb26 	beq	r3,zero,8113539c <__reset+0xfb11539c>
811353f0:	4808d0fa 	srli	r4,r9,3
811353f4:	20c0022c 	andhi	r3,r4,8
811353f8:	183fe81e 	bne	r3,zero,8113539c <__reset+0xfb11539c>
811353fc:	300cd0fa 	srli	r6,r6,3
81135400:	4806977a 	slli	r3,r9,29
81135404:	2005883a 	mov	r2,r4
81135408:	19a2b03a 	or	r17,r3,r6
8113540c:	003fe306 	br	8113539c <__reset+0xfb11539c>
81135410:	0011883a 	mov	r8,zero
81135414:	0005883a 	mov	r2,zero
81135418:	003e3f06 	br	81134d18 <__reset+0xfb114d18>
8113541c:	0401ffc4 	movi	r16,2047
81135420:	003e2506 	br	81134cb8 <__reset+0xfb114cb8>
81135424:	0013883a 	mov	r9,zero
81135428:	003f8406 	br	8113523c <__reset+0xfb11523c>
8113542c:	0005883a 	mov	r2,zero
81135430:	0007883a 	mov	r3,zero
81135434:	003e8906 	br	81134e5c <__reset+0xfb114e5c>
81135438:	197ff804 	addi	r5,r3,-32
8113543c:	01000804 	movi	r4,32
81135440:	414ad83a 	srl	r5,r8,r5
81135444:	19002426 	beq	r3,r4,811354d8 <__adddf3+0x8a4>
81135448:	01001004 	movi	r4,64
8113544c:	20c7c83a 	sub	r3,r4,r3
81135450:	40c6983a 	sll	r3,r8,r3
81135454:	1c46b03a 	or	r3,r3,r17
81135458:	1806c03a 	cmpne	r3,r3,zero
8113545c:	28e2b03a 	or	r17,r5,r3
81135460:	0007883a 	mov	r3,zero
81135464:	003f2306 	br	811350f4 <__reset+0xfb1150f4>
81135468:	0007883a 	mov	r3,zero
8113546c:	5811883a 	mov	r8,r11
81135470:	00bfffc4 	movi	r2,-1
81135474:	0401ffc4 	movi	r16,2047
81135478:	003e7806 	br	81134e5c <__reset+0xfb114e5c>
8113547c:	4462b03a 	or	r17,r8,r17
81135480:	8822c03a 	cmpne	r17,r17,zero
81135484:	0009883a 	mov	r4,zero
81135488:	003fa006 	br	8113530c <__reset+0xfb11530c>
8113548c:	4811883a 	mov	r8,r9
81135490:	3023883a 	mov	r17,r6
81135494:	0401ffc4 	movi	r16,2047
81135498:	003e0706 	br	81134cb8 <__reset+0xfb114cb8>
8113549c:	4811883a 	mov	r8,r9
811354a0:	3023883a 	mov	r17,r6
811354a4:	003e0406 	br	81134cb8 <__reset+0xfb114cb8>
811354a8:	21fff804 	addi	r7,r4,-32
811354ac:	01400804 	movi	r5,32
811354b0:	41ced83a 	srl	r7,r8,r7
811354b4:	21400a26 	beq	r4,r5,811354e0 <__adddf3+0x8ac>
811354b8:	01401004 	movi	r5,64
811354bc:	2909c83a 	sub	r4,r5,r4
811354c0:	4108983a 	sll	r4,r8,r4
811354c4:	2448b03a 	or	r4,r4,r17
811354c8:	2008c03a 	cmpne	r4,r4,zero
811354cc:	3922b03a 	or	r17,r7,r4
811354d0:	0009883a 	mov	r4,zero
811354d4:	003f8d06 	br	8113530c <__reset+0xfb11530c>
811354d8:	0007883a 	mov	r3,zero
811354dc:	003fdd06 	br	81135454 <__reset+0xfb115454>
811354e0:	0009883a 	mov	r4,zero
811354e4:	003ff706 	br	811354c4 <__reset+0xfb1154c4>

811354e8 <__divdf3>:
811354e8:	defff204 	addi	sp,sp,-56
811354ec:	de00012e 	bgeu	sp,et,811354f4 <__divdf3+0xc>
811354f0:	003b68fa 	trap	3
811354f4:	dd400915 	stw	r21,36(sp)
811354f8:	282ad53a 	srli	r21,r5,20
811354fc:	dd000815 	stw	r20,32(sp)
81135500:	2828d7fa 	srli	r20,r5,31
81135504:	dc000415 	stw	r16,16(sp)
81135508:	04000434 	movhi	r16,16
8113550c:	df000c15 	stw	fp,48(sp)
81135510:	843fffc4 	addi	r16,r16,-1
81135514:	dfc00d15 	stw	ra,52(sp)
81135518:	ddc00b15 	stw	r23,44(sp)
8113551c:	dd800a15 	stw	r22,40(sp)
81135520:	dcc00715 	stw	r19,28(sp)
81135524:	dc800615 	stw	r18,24(sp)
81135528:	dc400515 	stw	r17,20(sp)
8113552c:	ad41ffcc 	andi	r21,r21,2047
81135530:	2c20703a 	and	r16,r5,r16
81135534:	a7003fcc 	andi	fp,r20,255
81135538:	a8006126 	beq	r21,zero,811356c0 <__divdf3+0x1d8>
8113553c:	0081ffc4 	movi	r2,2047
81135540:	2025883a 	mov	r18,r4
81135544:	a8803726 	beq	r21,r2,81135624 <__divdf3+0x13c>
81135548:	80800434 	orhi	r2,r16,16
8113554c:	100490fa 	slli	r2,r2,3
81135550:	2020d77a 	srli	r16,r4,29
81135554:	202490fa 	slli	r18,r4,3
81135558:	ad7f0044 	addi	r21,r21,-1023
8113555c:	80a0b03a 	or	r16,r16,r2
81135560:	0027883a 	mov	r19,zero
81135564:	0013883a 	mov	r9,zero
81135568:	3804d53a 	srli	r2,r7,20
8113556c:	382cd7fa 	srli	r22,r7,31
81135570:	04400434 	movhi	r17,16
81135574:	8c7fffc4 	addi	r17,r17,-1
81135578:	1081ffcc 	andi	r2,r2,2047
8113557c:	3011883a 	mov	r8,r6
81135580:	3c62703a 	and	r17,r7,r17
81135584:	b5c03fcc 	andi	r23,r22,255
81135588:	10006c26 	beq	r2,zero,8113573c <__divdf3+0x254>
8113558c:	00c1ffc4 	movi	r3,2047
81135590:	10c06426 	beq	r2,r3,81135724 <__divdf3+0x23c>
81135594:	88c00434 	orhi	r3,r17,16
81135598:	180690fa 	slli	r3,r3,3
8113559c:	3022d77a 	srli	r17,r6,29
811355a0:	301090fa 	slli	r8,r6,3
811355a4:	10bf0044 	addi	r2,r2,-1023
811355a8:	88e2b03a 	or	r17,r17,r3
811355ac:	000f883a 	mov	r7,zero
811355b0:	a58cf03a 	xor	r6,r20,r22
811355b4:	3cc8b03a 	or	r4,r7,r19
811355b8:	a8abc83a 	sub	r21,r21,r2
811355bc:	008003c4 	movi	r2,15
811355c0:	3007883a 	mov	r3,r6
811355c4:	34c03fcc 	andi	r19,r6,255
811355c8:	11009036 	bltu	r2,r4,8113580c <__divdf3+0x324>
811355cc:	200890ba 	slli	r4,r4,2
811355d0:	00a044f4 	movhi	r2,33043
811355d4:	10957904 	addi	r2,r2,21988
811355d8:	2089883a 	add	r4,r4,r2
811355dc:	20800017 	ldw	r2,0(r4)
811355e0:	1000683a 	jmp	r2
811355e4:	8113580c 	andi	r4,r16,19808
811355e8:	8113565c 	xori	r4,r16,19801
811355ec:	811357fc 	xorhi	r4,r16,19807
811355f0:	81135650 	cmplti	r4,r16,19801
811355f4:	811357fc 	xorhi	r4,r16,19807
811355f8:	811357d0 	cmplti	r4,r16,19807
811355fc:	811357fc 	xorhi	r4,r16,19807
81135600:	81135650 	cmplti	r4,r16,19801
81135604:	8113565c 	xori	r4,r16,19801
81135608:	8113565c 	xori	r4,r16,19801
8113560c:	811357d0 	cmplti	r4,r16,19807
81135610:	81135650 	cmplti	r4,r16,19801
81135614:	81135640 	call	88113564 <__reset+0x20f3564>
81135618:	81135640 	call	88113564 <__reset+0x20f3564>
8113561c:	81135640 	call	88113564 <__reset+0x20f3564>
81135620:	81135af0 	cmpltui	r4,r16,19819
81135624:	2404b03a 	or	r2,r4,r16
81135628:	1000661e 	bne	r2,zero,811357c4 <__divdf3+0x2dc>
8113562c:	04c00204 	movi	r19,8
81135630:	0021883a 	mov	r16,zero
81135634:	0025883a 	mov	r18,zero
81135638:	02400084 	movi	r9,2
8113563c:	003fca06 	br	81135568 <__reset+0xfb115568>
81135640:	8023883a 	mov	r17,r16
81135644:	9011883a 	mov	r8,r18
81135648:	e02f883a 	mov	r23,fp
8113564c:	480f883a 	mov	r7,r9
81135650:	00800084 	movi	r2,2
81135654:	3881311e 	bne	r7,r2,81135b1c <__divdf3+0x634>
81135658:	b827883a 	mov	r19,r23
8113565c:	98c0004c 	andi	r3,r19,1
81135660:	0081ffc4 	movi	r2,2047
81135664:	000b883a 	mov	r5,zero
81135668:	0025883a 	mov	r18,zero
8113566c:	1004953a 	slli	r2,r2,20
81135670:	18c03fcc 	andi	r3,r3,255
81135674:	04400434 	movhi	r17,16
81135678:	8c7fffc4 	addi	r17,r17,-1
8113567c:	180697fa 	slli	r3,r3,31
81135680:	2c4a703a 	and	r5,r5,r17
81135684:	288ab03a 	or	r5,r5,r2
81135688:	28c6b03a 	or	r3,r5,r3
8113568c:	9005883a 	mov	r2,r18
81135690:	dfc00d17 	ldw	ra,52(sp)
81135694:	df000c17 	ldw	fp,48(sp)
81135698:	ddc00b17 	ldw	r23,44(sp)
8113569c:	dd800a17 	ldw	r22,40(sp)
811356a0:	dd400917 	ldw	r21,36(sp)
811356a4:	dd000817 	ldw	r20,32(sp)
811356a8:	dcc00717 	ldw	r19,28(sp)
811356ac:	dc800617 	ldw	r18,24(sp)
811356b0:	dc400517 	ldw	r17,20(sp)
811356b4:	dc000417 	ldw	r16,16(sp)
811356b8:	dec00e04 	addi	sp,sp,56
811356bc:	f800283a 	ret
811356c0:	2404b03a 	or	r2,r4,r16
811356c4:	2027883a 	mov	r19,r4
811356c8:	10003926 	beq	r2,zero,811357b0 <__divdf3+0x2c8>
811356cc:	80012e26 	beq	r16,zero,81135b88 <__divdf3+0x6a0>
811356d0:	8009883a 	mov	r4,r16
811356d4:	d9800315 	stw	r6,12(sp)
811356d8:	d9c00215 	stw	r7,8(sp)
811356dc:	112116c0 	call	8112116c <__clzsi2>
811356e0:	d9800317 	ldw	r6,12(sp)
811356e4:	d9c00217 	ldw	r7,8(sp)
811356e8:	113ffd44 	addi	r4,r2,-11
811356ec:	00c00704 	movi	r3,28
811356f0:	19012116 	blt	r3,r4,81135b78 <__divdf3+0x690>
811356f4:	00c00744 	movi	r3,29
811356f8:	147ffe04 	addi	r17,r2,-8
811356fc:	1907c83a 	sub	r3,r3,r4
81135700:	8460983a 	sll	r16,r16,r17
81135704:	98c6d83a 	srl	r3,r19,r3
81135708:	9c64983a 	sll	r18,r19,r17
8113570c:	1c20b03a 	or	r16,r3,r16
81135710:	1080fcc4 	addi	r2,r2,1011
81135714:	00abc83a 	sub	r21,zero,r2
81135718:	0027883a 	mov	r19,zero
8113571c:	0013883a 	mov	r9,zero
81135720:	003f9106 	br	81135568 <__reset+0xfb115568>
81135724:	3446b03a 	or	r3,r6,r17
81135728:	18001f1e 	bne	r3,zero,811357a8 <__divdf3+0x2c0>
8113572c:	0023883a 	mov	r17,zero
81135730:	0011883a 	mov	r8,zero
81135734:	01c00084 	movi	r7,2
81135738:	003f9d06 	br	811355b0 <__reset+0xfb1155b0>
8113573c:	3446b03a 	or	r3,r6,r17
81135740:	18001526 	beq	r3,zero,81135798 <__divdf3+0x2b0>
81135744:	88011b26 	beq	r17,zero,81135bb4 <__divdf3+0x6cc>
81135748:	8809883a 	mov	r4,r17
8113574c:	d9800315 	stw	r6,12(sp)
81135750:	da400115 	stw	r9,4(sp)
81135754:	112116c0 	call	8112116c <__clzsi2>
81135758:	d9800317 	ldw	r6,12(sp)
8113575c:	da400117 	ldw	r9,4(sp)
81135760:	113ffd44 	addi	r4,r2,-11
81135764:	00c00704 	movi	r3,28
81135768:	19010e16 	blt	r3,r4,81135ba4 <__divdf3+0x6bc>
8113576c:	00c00744 	movi	r3,29
81135770:	123ffe04 	addi	r8,r2,-8
81135774:	1907c83a 	sub	r3,r3,r4
81135778:	8a22983a 	sll	r17,r17,r8
8113577c:	30c6d83a 	srl	r3,r6,r3
81135780:	3210983a 	sll	r8,r6,r8
81135784:	1c62b03a 	or	r17,r3,r17
81135788:	1080fcc4 	addi	r2,r2,1011
8113578c:	0085c83a 	sub	r2,zero,r2
81135790:	000f883a 	mov	r7,zero
81135794:	003f8606 	br	811355b0 <__reset+0xfb1155b0>
81135798:	0023883a 	mov	r17,zero
8113579c:	0011883a 	mov	r8,zero
811357a0:	01c00044 	movi	r7,1
811357a4:	003f8206 	br	811355b0 <__reset+0xfb1155b0>
811357a8:	01c000c4 	movi	r7,3
811357ac:	003f8006 	br	811355b0 <__reset+0xfb1155b0>
811357b0:	04c00104 	movi	r19,4
811357b4:	0021883a 	mov	r16,zero
811357b8:	0025883a 	mov	r18,zero
811357bc:	02400044 	movi	r9,1
811357c0:	003f6906 	br	81135568 <__reset+0xfb115568>
811357c4:	04c00304 	movi	r19,12
811357c8:	024000c4 	movi	r9,3
811357cc:	003f6606 	br	81135568 <__reset+0xfb115568>
811357d0:	01400434 	movhi	r5,16
811357d4:	0007883a 	mov	r3,zero
811357d8:	297fffc4 	addi	r5,r5,-1
811357dc:	04bfffc4 	movi	r18,-1
811357e0:	0081ffc4 	movi	r2,2047
811357e4:	003fa106 	br	8113566c <__reset+0xfb11566c>
811357e8:	00c00044 	movi	r3,1
811357ec:	1887c83a 	sub	r3,r3,r2
811357f0:	01000e04 	movi	r4,56
811357f4:	20c1210e 	bge	r4,r3,81135c7c <__divdf3+0x794>
811357f8:	98c0004c 	andi	r3,r19,1
811357fc:	0005883a 	mov	r2,zero
81135800:	000b883a 	mov	r5,zero
81135804:	0025883a 	mov	r18,zero
81135808:	003f9806 	br	8113566c <__reset+0xfb11566c>
8113580c:	8c00fd36 	bltu	r17,r16,81135c04 <__divdf3+0x71c>
81135810:	8440fb26 	beq	r16,r17,81135c00 <__divdf3+0x718>
81135814:	8007883a 	mov	r3,r16
81135818:	ad7fffc4 	addi	r21,r21,-1
8113581c:	0021883a 	mov	r16,zero
81135820:	4004d63a 	srli	r2,r8,24
81135824:	8822923a 	slli	r17,r17,8
81135828:	1809883a 	mov	r4,r3
8113582c:	402c923a 	slli	r22,r8,8
81135830:	88b8b03a 	or	fp,r17,r2
81135834:	e028d43a 	srli	r20,fp,16
81135838:	d8c00015 	stw	r3,0(sp)
8113583c:	e5ffffcc 	andi	r23,fp,65535
81135840:	a00b883a 	mov	r5,r20
81135844:	113497c0 	call	8113497c <__udivsi3>
81135848:	d8c00017 	ldw	r3,0(sp)
8113584c:	a00b883a 	mov	r5,r20
81135850:	d8800315 	stw	r2,12(sp)
81135854:	1809883a 	mov	r4,r3
81135858:	11349e00 	call	811349e0 <__umodsi3>
8113585c:	d9800317 	ldw	r6,12(sp)
81135860:	1006943a 	slli	r3,r2,16
81135864:	9004d43a 	srli	r2,r18,16
81135868:	b9a3383a 	mul	r17,r23,r6
8113586c:	10c4b03a 	or	r2,r2,r3
81135870:	1440062e 	bgeu	r2,r17,8113588c <__divdf3+0x3a4>
81135874:	1705883a 	add	r2,r2,fp
81135878:	30ffffc4 	addi	r3,r6,-1
8113587c:	1700ee36 	bltu	r2,fp,81135c38 <__divdf3+0x750>
81135880:	1440ed2e 	bgeu	r2,r17,81135c38 <__divdf3+0x750>
81135884:	31bfff84 	addi	r6,r6,-2
81135888:	1705883a 	add	r2,r2,fp
8113588c:	1463c83a 	sub	r17,r2,r17
81135890:	a00b883a 	mov	r5,r20
81135894:	8809883a 	mov	r4,r17
81135898:	d9800315 	stw	r6,12(sp)
8113589c:	113497c0 	call	8113497c <__udivsi3>
811358a0:	a00b883a 	mov	r5,r20
811358a4:	8809883a 	mov	r4,r17
811358a8:	d8800215 	stw	r2,8(sp)
811358ac:	11349e00 	call	811349e0 <__umodsi3>
811358b0:	d9c00217 	ldw	r7,8(sp)
811358b4:	1004943a 	slli	r2,r2,16
811358b8:	94bfffcc 	andi	r18,r18,65535
811358bc:	b9d1383a 	mul	r8,r23,r7
811358c0:	90a4b03a 	or	r18,r18,r2
811358c4:	d9800317 	ldw	r6,12(sp)
811358c8:	9200062e 	bgeu	r18,r8,811358e4 <__divdf3+0x3fc>
811358cc:	9725883a 	add	r18,r18,fp
811358d0:	38bfffc4 	addi	r2,r7,-1
811358d4:	9700d636 	bltu	r18,fp,81135c30 <__divdf3+0x748>
811358d8:	9200d52e 	bgeu	r18,r8,81135c30 <__divdf3+0x748>
811358dc:	39ffff84 	addi	r7,r7,-2
811358e0:	9725883a 	add	r18,r18,fp
811358e4:	3004943a 	slli	r2,r6,16
811358e8:	b012d43a 	srli	r9,r22,16
811358ec:	b1bfffcc 	andi	r6,r22,65535
811358f0:	11e2b03a 	or	r17,r2,r7
811358f4:	8806d43a 	srli	r3,r17,16
811358f8:	893fffcc 	andi	r4,r17,65535
811358fc:	218b383a 	mul	r5,r4,r6
81135900:	30c5383a 	mul	r2,r6,r3
81135904:	2249383a 	mul	r4,r4,r9
81135908:	280ed43a 	srli	r7,r5,16
8113590c:	9225c83a 	sub	r18,r18,r8
81135910:	2089883a 	add	r4,r4,r2
81135914:	3909883a 	add	r4,r7,r4
81135918:	1a47383a 	mul	r3,r3,r9
8113591c:	2080022e 	bgeu	r4,r2,81135928 <__divdf3+0x440>
81135920:	00800074 	movhi	r2,1
81135924:	1887883a 	add	r3,r3,r2
81135928:	2004d43a 	srli	r2,r4,16
8113592c:	2008943a 	slli	r4,r4,16
81135930:	297fffcc 	andi	r5,r5,65535
81135934:	10c7883a 	add	r3,r2,r3
81135938:	2149883a 	add	r4,r4,r5
8113593c:	90c0a536 	bltu	r18,r3,81135bd4 <__divdf3+0x6ec>
81135940:	90c0bf26 	beq	r18,r3,81135c40 <__divdf3+0x758>
81135944:	90c7c83a 	sub	r3,r18,r3
81135948:	810fc83a 	sub	r7,r16,r4
8113594c:	81e5803a 	cmpltu	r18,r16,r7
81135950:	1ca5c83a 	sub	r18,r3,r18
81135954:	e480c126 	beq	fp,r18,81135c5c <__divdf3+0x774>
81135958:	a00b883a 	mov	r5,r20
8113595c:	9009883a 	mov	r4,r18
81135960:	d9800315 	stw	r6,12(sp)
81135964:	d9c00215 	stw	r7,8(sp)
81135968:	da400115 	stw	r9,4(sp)
8113596c:	113497c0 	call	8113497c <__udivsi3>
81135970:	a00b883a 	mov	r5,r20
81135974:	9009883a 	mov	r4,r18
81135978:	d8800015 	stw	r2,0(sp)
8113597c:	11349e00 	call	811349e0 <__umodsi3>
81135980:	d9c00217 	ldw	r7,8(sp)
81135984:	da000017 	ldw	r8,0(sp)
81135988:	1006943a 	slli	r3,r2,16
8113598c:	3804d43a 	srli	r2,r7,16
81135990:	ba21383a 	mul	r16,r23,r8
81135994:	d9800317 	ldw	r6,12(sp)
81135998:	10c4b03a 	or	r2,r2,r3
8113599c:	da400117 	ldw	r9,4(sp)
811359a0:	1400062e 	bgeu	r2,r16,811359bc <__divdf3+0x4d4>
811359a4:	1705883a 	add	r2,r2,fp
811359a8:	40ffffc4 	addi	r3,r8,-1
811359ac:	1700ad36 	bltu	r2,fp,81135c64 <__divdf3+0x77c>
811359b0:	1400ac2e 	bgeu	r2,r16,81135c64 <__divdf3+0x77c>
811359b4:	423fff84 	addi	r8,r8,-2
811359b8:	1705883a 	add	r2,r2,fp
811359bc:	1421c83a 	sub	r16,r2,r16
811359c0:	a00b883a 	mov	r5,r20
811359c4:	8009883a 	mov	r4,r16
811359c8:	d9800315 	stw	r6,12(sp)
811359cc:	d9c00215 	stw	r7,8(sp)
811359d0:	da000015 	stw	r8,0(sp)
811359d4:	da400115 	stw	r9,4(sp)
811359d8:	113497c0 	call	8113497c <__udivsi3>
811359dc:	8009883a 	mov	r4,r16
811359e0:	a00b883a 	mov	r5,r20
811359e4:	1025883a 	mov	r18,r2
811359e8:	11349e00 	call	811349e0 <__umodsi3>
811359ec:	d9c00217 	ldw	r7,8(sp)
811359f0:	1004943a 	slli	r2,r2,16
811359f4:	bcaf383a 	mul	r23,r23,r18
811359f8:	393fffcc 	andi	r4,r7,65535
811359fc:	2088b03a 	or	r4,r4,r2
81135a00:	d9800317 	ldw	r6,12(sp)
81135a04:	da000017 	ldw	r8,0(sp)
81135a08:	da400117 	ldw	r9,4(sp)
81135a0c:	25c0062e 	bgeu	r4,r23,81135a28 <__divdf3+0x540>
81135a10:	2709883a 	add	r4,r4,fp
81135a14:	90bfffc4 	addi	r2,r18,-1
81135a18:	27009436 	bltu	r4,fp,81135c6c <__divdf3+0x784>
81135a1c:	25c0932e 	bgeu	r4,r23,81135c6c <__divdf3+0x784>
81135a20:	94bfff84 	addi	r18,r18,-2
81135a24:	2709883a 	add	r4,r4,fp
81135a28:	4004943a 	slli	r2,r8,16
81135a2c:	25efc83a 	sub	r23,r4,r23
81135a30:	1490b03a 	or	r8,r2,r18
81135a34:	4008d43a 	srli	r4,r8,16
81135a38:	40ffffcc 	andi	r3,r8,65535
81135a3c:	30c5383a 	mul	r2,r6,r3
81135a40:	1a47383a 	mul	r3,r3,r9
81135a44:	310d383a 	mul	r6,r6,r4
81135a48:	100ad43a 	srli	r5,r2,16
81135a4c:	4913383a 	mul	r9,r9,r4
81135a50:	1987883a 	add	r3,r3,r6
81135a54:	28c7883a 	add	r3,r5,r3
81135a58:	1980022e 	bgeu	r3,r6,81135a64 <__divdf3+0x57c>
81135a5c:	01000074 	movhi	r4,1
81135a60:	4913883a 	add	r9,r9,r4
81135a64:	1808d43a 	srli	r4,r3,16
81135a68:	1806943a 	slli	r3,r3,16
81135a6c:	10bfffcc 	andi	r2,r2,65535
81135a70:	2253883a 	add	r9,r4,r9
81135a74:	1887883a 	add	r3,r3,r2
81135a78:	ba403836 	bltu	r23,r9,81135b5c <__divdf3+0x674>
81135a7c:	ba403626 	beq	r23,r9,81135b58 <__divdf3+0x670>
81135a80:	42000054 	ori	r8,r8,1
81135a84:	a880ffc4 	addi	r2,r21,1023
81135a88:	00bf570e 	bge	zero,r2,811357e8 <__reset+0xfb1157e8>
81135a8c:	40c001cc 	andi	r3,r8,7
81135a90:	18000726 	beq	r3,zero,81135ab0 <__divdf3+0x5c8>
81135a94:	40c003cc 	andi	r3,r8,15
81135a98:	01000104 	movi	r4,4
81135a9c:	19000426 	beq	r3,r4,81135ab0 <__divdf3+0x5c8>
81135aa0:	4107883a 	add	r3,r8,r4
81135aa4:	1a11803a 	cmpltu	r8,r3,r8
81135aa8:	8a23883a 	add	r17,r17,r8
81135aac:	1811883a 	mov	r8,r3
81135ab0:	88c0402c 	andhi	r3,r17,256
81135ab4:	18000426 	beq	r3,zero,81135ac8 <__divdf3+0x5e0>
81135ab8:	00ffc034 	movhi	r3,65280
81135abc:	18ffffc4 	addi	r3,r3,-1
81135ac0:	a8810004 	addi	r2,r21,1024
81135ac4:	88e2703a 	and	r17,r17,r3
81135ac8:	00c1ff84 	movi	r3,2046
81135acc:	18bee316 	blt	r3,r2,8113565c <__reset+0xfb11565c>
81135ad0:	8824977a 	slli	r18,r17,29
81135ad4:	4010d0fa 	srli	r8,r8,3
81135ad8:	8822927a 	slli	r17,r17,9
81135adc:	1081ffcc 	andi	r2,r2,2047
81135ae0:	9224b03a 	or	r18,r18,r8
81135ae4:	880ad33a 	srli	r5,r17,12
81135ae8:	98c0004c 	andi	r3,r19,1
81135aec:	003edf06 	br	8113566c <__reset+0xfb11566c>
81135af0:	8080022c 	andhi	r2,r16,8
81135af4:	10001226 	beq	r2,zero,81135b40 <__divdf3+0x658>
81135af8:	8880022c 	andhi	r2,r17,8
81135afc:	1000101e 	bne	r2,zero,81135b40 <__divdf3+0x658>
81135b00:	00800434 	movhi	r2,16
81135b04:	89400234 	orhi	r5,r17,8
81135b08:	10bfffc4 	addi	r2,r2,-1
81135b0c:	b007883a 	mov	r3,r22
81135b10:	288a703a 	and	r5,r5,r2
81135b14:	4025883a 	mov	r18,r8
81135b18:	003f3106 	br	811357e0 <__reset+0xfb1157e0>
81135b1c:	008000c4 	movi	r2,3
81135b20:	3880a626 	beq	r7,r2,81135dbc <__divdf3+0x8d4>
81135b24:	00800044 	movi	r2,1
81135b28:	3880521e 	bne	r7,r2,81135c74 <__divdf3+0x78c>
81135b2c:	b807883a 	mov	r3,r23
81135b30:	0005883a 	mov	r2,zero
81135b34:	000b883a 	mov	r5,zero
81135b38:	0025883a 	mov	r18,zero
81135b3c:	003ecb06 	br	8113566c <__reset+0xfb11566c>
81135b40:	00800434 	movhi	r2,16
81135b44:	81400234 	orhi	r5,r16,8
81135b48:	10bfffc4 	addi	r2,r2,-1
81135b4c:	a007883a 	mov	r3,r20
81135b50:	288a703a 	and	r5,r5,r2
81135b54:	003f2206 	br	811357e0 <__reset+0xfb1157e0>
81135b58:	183fca26 	beq	r3,zero,81135a84 <__reset+0xfb115a84>
81135b5c:	e5ef883a 	add	r23,fp,r23
81135b60:	40bfffc4 	addi	r2,r8,-1
81135b64:	bf00392e 	bgeu	r23,fp,81135c4c <__divdf3+0x764>
81135b68:	1011883a 	mov	r8,r2
81135b6c:	ba7fc41e 	bne	r23,r9,81135a80 <__reset+0xfb115a80>
81135b70:	b0ffc31e 	bne	r22,r3,81135a80 <__reset+0xfb115a80>
81135b74:	003fc306 	br	81135a84 <__reset+0xfb115a84>
81135b78:	143ff604 	addi	r16,r2,-40
81135b7c:	9c20983a 	sll	r16,r19,r16
81135b80:	0025883a 	mov	r18,zero
81135b84:	003ee206 	br	81135710 <__reset+0xfb115710>
81135b88:	d9800315 	stw	r6,12(sp)
81135b8c:	d9c00215 	stw	r7,8(sp)
81135b90:	112116c0 	call	8112116c <__clzsi2>
81135b94:	10800804 	addi	r2,r2,32
81135b98:	d9c00217 	ldw	r7,8(sp)
81135b9c:	d9800317 	ldw	r6,12(sp)
81135ba0:	003ed106 	br	811356e8 <__reset+0xfb1156e8>
81135ba4:	147ff604 	addi	r17,r2,-40
81135ba8:	3462983a 	sll	r17,r6,r17
81135bac:	0011883a 	mov	r8,zero
81135bb0:	003ef506 	br	81135788 <__reset+0xfb115788>
81135bb4:	3009883a 	mov	r4,r6
81135bb8:	d9800315 	stw	r6,12(sp)
81135bbc:	da400115 	stw	r9,4(sp)
81135bc0:	112116c0 	call	8112116c <__clzsi2>
81135bc4:	10800804 	addi	r2,r2,32
81135bc8:	da400117 	ldw	r9,4(sp)
81135bcc:	d9800317 	ldw	r6,12(sp)
81135bd0:	003ee306 	br	81135760 <__reset+0xfb115760>
81135bd4:	85a1883a 	add	r16,r16,r22
81135bd8:	8585803a 	cmpltu	r2,r16,r22
81135bdc:	1705883a 	add	r2,r2,fp
81135be0:	14a5883a 	add	r18,r2,r18
81135be4:	88bfffc4 	addi	r2,r17,-1
81135be8:	e4800c2e 	bgeu	fp,r18,81135c1c <__divdf3+0x734>
81135bec:	90c03e36 	bltu	r18,r3,81135ce8 <__divdf3+0x800>
81135bf0:	1c806926 	beq	r3,r18,81135d98 <__divdf3+0x8b0>
81135bf4:	90c7c83a 	sub	r3,r18,r3
81135bf8:	1023883a 	mov	r17,r2
81135bfc:	003f5206 	br	81135948 <__reset+0xfb115948>
81135c00:	923f0436 	bltu	r18,r8,81135814 <__reset+0xfb115814>
81135c04:	800897fa 	slli	r4,r16,31
81135c08:	9004d07a 	srli	r2,r18,1
81135c0c:	8006d07a 	srli	r3,r16,1
81135c10:	902097fa 	slli	r16,r18,31
81135c14:	20a4b03a 	or	r18,r4,r2
81135c18:	003f0106 	br	81135820 <__reset+0xfb115820>
81135c1c:	e4bff51e 	bne	fp,r18,81135bf4 <__reset+0xfb115bf4>
81135c20:	85bff22e 	bgeu	r16,r22,81135bec <__reset+0xfb115bec>
81135c24:	e0c7c83a 	sub	r3,fp,r3
81135c28:	1023883a 	mov	r17,r2
81135c2c:	003f4606 	br	81135948 <__reset+0xfb115948>
81135c30:	100f883a 	mov	r7,r2
81135c34:	003f2b06 	br	811358e4 <__reset+0xfb1158e4>
81135c38:	180d883a 	mov	r6,r3
81135c3c:	003f1306 	br	8113588c <__reset+0xfb11588c>
81135c40:	813fe436 	bltu	r16,r4,81135bd4 <__reset+0xfb115bd4>
81135c44:	0007883a 	mov	r3,zero
81135c48:	003f3f06 	br	81135948 <__reset+0xfb115948>
81135c4c:	ba402c36 	bltu	r23,r9,81135d00 <__divdf3+0x818>
81135c50:	4dc05426 	beq	r9,r23,81135da4 <__divdf3+0x8bc>
81135c54:	1011883a 	mov	r8,r2
81135c58:	003f8906 	br	81135a80 <__reset+0xfb115a80>
81135c5c:	023fffc4 	movi	r8,-1
81135c60:	003f8806 	br	81135a84 <__reset+0xfb115a84>
81135c64:	1811883a 	mov	r8,r3
81135c68:	003f5406 	br	811359bc <__reset+0xfb1159bc>
81135c6c:	1025883a 	mov	r18,r2
81135c70:	003f6d06 	br	81135a28 <__reset+0xfb115a28>
81135c74:	b827883a 	mov	r19,r23
81135c78:	003f8206 	br	81135a84 <__reset+0xfb115a84>
81135c7c:	010007c4 	movi	r4,31
81135c80:	20c02616 	blt	r4,r3,81135d1c <__divdf3+0x834>
81135c84:	00800804 	movi	r2,32
81135c88:	10c5c83a 	sub	r2,r2,r3
81135c8c:	888a983a 	sll	r5,r17,r2
81135c90:	40c8d83a 	srl	r4,r8,r3
81135c94:	4084983a 	sll	r2,r8,r2
81135c98:	88e2d83a 	srl	r17,r17,r3
81135c9c:	2906b03a 	or	r3,r5,r4
81135ca0:	1004c03a 	cmpne	r2,r2,zero
81135ca4:	1886b03a 	or	r3,r3,r2
81135ca8:	188001cc 	andi	r2,r3,7
81135cac:	10000726 	beq	r2,zero,81135ccc <__divdf3+0x7e4>
81135cb0:	188003cc 	andi	r2,r3,15
81135cb4:	01000104 	movi	r4,4
81135cb8:	11000426 	beq	r2,r4,81135ccc <__divdf3+0x7e4>
81135cbc:	1805883a 	mov	r2,r3
81135cc0:	10c00104 	addi	r3,r2,4
81135cc4:	1885803a 	cmpltu	r2,r3,r2
81135cc8:	88a3883a 	add	r17,r17,r2
81135ccc:	8880202c 	andhi	r2,r17,128
81135cd0:	10002726 	beq	r2,zero,81135d70 <__divdf3+0x888>
81135cd4:	98c0004c 	andi	r3,r19,1
81135cd8:	00800044 	movi	r2,1
81135cdc:	000b883a 	mov	r5,zero
81135ce0:	0025883a 	mov	r18,zero
81135ce4:	003e6106 	br	8113566c <__reset+0xfb11566c>
81135ce8:	85a1883a 	add	r16,r16,r22
81135cec:	8585803a 	cmpltu	r2,r16,r22
81135cf0:	1705883a 	add	r2,r2,fp
81135cf4:	14a5883a 	add	r18,r2,r18
81135cf8:	8c7fff84 	addi	r17,r17,-2
81135cfc:	003f1106 	br	81135944 <__reset+0xfb115944>
81135d00:	b589883a 	add	r4,r22,r22
81135d04:	25ad803a 	cmpltu	r22,r4,r22
81135d08:	b739883a 	add	fp,r22,fp
81135d0c:	40bfff84 	addi	r2,r8,-2
81135d10:	bf2f883a 	add	r23,r23,fp
81135d14:	202d883a 	mov	r22,r4
81135d18:	003f9306 	br	81135b68 <__reset+0xfb115b68>
81135d1c:	013ff844 	movi	r4,-31
81135d20:	2085c83a 	sub	r2,r4,r2
81135d24:	8888d83a 	srl	r4,r17,r2
81135d28:	00800804 	movi	r2,32
81135d2c:	18802126 	beq	r3,r2,81135db4 <__divdf3+0x8cc>
81135d30:	00801004 	movi	r2,64
81135d34:	10c5c83a 	sub	r2,r2,r3
81135d38:	8884983a 	sll	r2,r17,r2
81135d3c:	1204b03a 	or	r2,r2,r8
81135d40:	1004c03a 	cmpne	r2,r2,zero
81135d44:	2084b03a 	or	r2,r4,r2
81135d48:	144001cc 	andi	r17,r2,7
81135d4c:	88000d1e 	bne	r17,zero,81135d84 <__divdf3+0x89c>
81135d50:	000b883a 	mov	r5,zero
81135d54:	1024d0fa 	srli	r18,r2,3
81135d58:	98c0004c 	andi	r3,r19,1
81135d5c:	0005883a 	mov	r2,zero
81135d60:	9464b03a 	or	r18,r18,r17
81135d64:	003e4106 	br	8113566c <__reset+0xfb11566c>
81135d68:	1007883a 	mov	r3,r2
81135d6c:	0023883a 	mov	r17,zero
81135d70:	880a927a 	slli	r5,r17,9
81135d74:	1805883a 	mov	r2,r3
81135d78:	8822977a 	slli	r17,r17,29
81135d7c:	280ad33a 	srli	r5,r5,12
81135d80:	003ff406 	br	81135d54 <__reset+0xfb115d54>
81135d84:	10c003cc 	andi	r3,r2,15
81135d88:	01000104 	movi	r4,4
81135d8c:	193ff626 	beq	r3,r4,81135d68 <__reset+0xfb115d68>
81135d90:	0023883a 	mov	r17,zero
81135d94:	003fca06 	br	81135cc0 <__reset+0xfb115cc0>
81135d98:	813fd336 	bltu	r16,r4,81135ce8 <__reset+0xfb115ce8>
81135d9c:	1023883a 	mov	r17,r2
81135da0:	003fa806 	br	81135c44 <__reset+0xfb115c44>
81135da4:	b0ffd636 	bltu	r22,r3,81135d00 <__reset+0xfb115d00>
81135da8:	1011883a 	mov	r8,r2
81135dac:	b0ff341e 	bne	r22,r3,81135a80 <__reset+0xfb115a80>
81135db0:	003f3406 	br	81135a84 <__reset+0xfb115a84>
81135db4:	0005883a 	mov	r2,zero
81135db8:	003fe006 	br	81135d3c <__reset+0xfb115d3c>
81135dbc:	00800434 	movhi	r2,16
81135dc0:	89400234 	orhi	r5,r17,8
81135dc4:	10bfffc4 	addi	r2,r2,-1
81135dc8:	b807883a 	mov	r3,r23
81135dcc:	288a703a 	and	r5,r5,r2
81135dd0:	4025883a 	mov	r18,r8
81135dd4:	003e8206 	br	811357e0 <__reset+0xfb1157e0>

81135dd8 <__eqdf2>:
81135dd8:	2804d53a 	srli	r2,r5,20
81135ddc:	3806d53a 	srli	r3,r7,20
81135de0:	02000434 	movhi	r8,16
81135de4:	423fffc4 	addi	r8,r8,-1
81135de8:	1081ffcc 	andi	r2,r2,2047
81135dec:	0281ffc4 	movi	r10,2047
81135df0:	2a12703a 	and	r9,r5,r8
81135df4:	18c1ffcc 	andi	r3,r3,2047
81135df8:	3a10703a 	and	r8,r7,r8
81135dfc:	280ad7fa 	srli	r5,r5,31
81135e00:	380ed7fa 	srli	r7,r7,31
81135e04:	12801026 	beq	r2,r10,81135e48 <__eqdf2+0x70>
81135e08:	0281ffc4 	movi	r10,2047
81135e0c:	1a800a26 	beq	r3,r10,81135e38 <__eqdf2+0x60>
81135e10:	10c00226 	beq	r2,r3,81135e1c <__eqdf2+0x44>
81135e14:	00800044 	movi	r2,1
81135e18:	f800283a 	ret
81135e1c:	4a3ffd1e 	bne	r9,r8,81135e14 <__reset+0xfb115e14>
81135e20:	21bffc1e 	bne	r4,r6,81135e14 <__reset+0xfb115e14>
81135e24:	29c00c26 	beq	r5,r7,81135e58 <__eqdf2+0x80>
81135e28:	103ffa1e 	bne	r2,zero,81135e14 <__reset+0xfb115e14>
81135e2c:	2244b03a 	or	r2,r4,r9
81135e30:	1004c03a 	cmpne	r2,r2,zero
81135e34:	f800283a 	ret
81135e38:	3214b03a 	or	r10,r6,r8
81135e3c:	503ff426 	beq	r10,zero,81135e10 <__reset+0xfb115e10>
81135e40:	00800044 	movi	r2,1
81135e44:	f800283a 	ret
81135e48:	2254b03a 	or	r10,r4,r9
81135e4c:	503fee26 	beq	r10,zero,81135e08 <__reset+0xfb115e08>
81135e50:	00800044 	movi	r2,1
81135e54:	f800283a 	ret
81135e58:	0005883a 	mov	r2,zero
81135e5c:	f800283a 	ret

81135e60 <__ledf2>:
81135e60:	2804d53a 	srli	r2,r5,20
81135e64:	3810d53a 	srli	r8,r7,20
81135e68:	00c00434 	movhi	r3,16
81135e6c:	18ffffc4 	addi	r3,r3,-1
81135e70:	1081ffcc 	andi	r2,r2,2047
81135e74:	0241ffc4 	movi	r9,2047
81135e78:	28d4703a 	and	r10,r5,r3
81135e7c:	4201ffcc 	andi	r8,r8,2047
81135e80:	38c6703a 	and	r3,r7,r3
81135e84:	280ad7fa 	srli	r5,r5,31
81135e88:	380ed7fa 	srli	r7,r7,31
81135e8c:	12401f26 	beq	r2,r9,81135f0c <__ledf2+0xac>
81135e90:	0241ffc4 	movi	r9,2047
81135e94:	42401426 	beq	r8,r9,81135ee8 <__ledf2+0x88>
81135e98:	1000091e 	bne	r2,zero,81135ec0 <__ledf2+0x60>
81135e9c:	2296b03a 	or	r11,r4,r10
81135ea0:	5813003a 	cmpeq	r9,r11,zero
81135ea4:	29403fcc 	andi	r5,r5,255
81135ea8:	40000a1e 	bne	r8,zero,81135ed4 <__ledf2+0x74>
81135eac:	30d8b03a 	or	r12,r6,r3
81135eb0:	6000081e 	bne	r12,zero,81135ed4 <__ledf2+0x74>
81135eb4:	0005883a 	mov	r2,zero
81135eb8:	5800111e 	bne	r11,zero,81135f00 <__ledf2+0xa0>
81135ebc:	f800283a 	ret
81135ec0:	29403fcc 	andi	r5,r5,255
81135ec4:	40000c1e 	bne	r8,zero,81135ef8 <__ledf2+0x98>
81135ec8:	30d2b03a 	or	r9,r6,r3
81135ecc:	48000c26 	beq	r9,zero,81135f00 <__ledf2+0xa0>
81135ed0:	0013883a 	mov	r9,zero
81135ed4:	39c03fcc 	andi	r7,r7,255
81135ed8:	48000826 	beq	r9,zero,81135efc <__ledf2+0x9c>
81135edc:	38001126 	beq	r7,zero,81135f24 <__ledf2+0xc4>
81135ee0:	00800044 	movi	r2,1
81135ee4:	f800283a 	ret
81135ee8:	30d2b03a 	or	r9,r6,r3
81135eec:	483fea26 	beq	r9,zero,81135e98 <__reset+0xfb115e98>
81135ef0:	00800084 	movi	r2,2
81135ef4:	f800283a 	ret
81135ef8:	39c03fcc 	andi	r7,r7,255
81135efc:	39400726 	beq	r7,r5,81135f1c <__ledf2+0xbc>
81135f00:	2800081e 	bne	r5,zero,81135f24 <__ledf2+0xc4>
81135f04:	00800044 	movi	r2,1
81135f08:	f800283a 	ret
81135f0c:	2292b03a 	or	r9,r4,r10
81135f10:	483fdf26 	beq	r9,zero,81135e90 <__reset+0xfb115e90>
81135f14:	00800084 	movi	r2,2
81135f18:	f800283a 	ret
81135f1c:	4080030e 	bge	r8,r2,81135f2c <__ledf2+0xcc>
81135f20:	383fef26 	beq	r7,zero,81135ee0 <__reset+0xfb115ee0>
81135f24:	00bfffc4 	movi	r2,-1
81135f28:	f800283a 	ret
81135f2c:	123feb16 	blt	r2,r8,81135edc <__reset+0xfb115edc>
81135f30:	1abff336 	bltu	r3,r10,81135f00 <__reset+0xfb115f00>
81135f34:	50c00326 	beq	r10,r3,81135f44 <__ledf2+0xe4>
81135f38:	50c0042e 	bgeu	r10,r3,81135f4c <__ledf2+0xec>
81135f3c:	283fe81e 	bne	r5,zero,81135ee0 <__reset+0xfb115ee0>
81135f40:	003ff806 	br	81135f24 <__reset+0xfb115f24>
81135f44:	313fee36 	bltu	r6,r4,81135f00 <__reset+0xfb115f00>
81135f48:	21bffc36 	bltu	r4,r6,81135f3c <__reset+0xfb115f3c>
81135f4c:	0005883a 	mov	r2,zero
81135f50:	f800283a 	ret

81135f54 <__floatunsidf>:
81135f54:	defffe04 	addi	sp,sp,-8
81135f58:	de00012e 	bgeu	sp,et,81135f60 <__floatunsidf+0xc>
81135f5c:	003b68fa 	trap	3
81135f60:	dc000015 	stw	r16,0(sp)
81135f64:	dfc00115 	stw	ra,4(sp)
81135f68:	2021883a 	mov	r16,r4
81135f6c:	20002226 	beq	r4,zero,81135ff8 <__floatunsidf+0xa4>
81135f70:	112116c0 	call	8112116c <__clzsi2>
81135f74:	01010784 	movi	r4,1054
81135f78:	2089c83a 	sub	r4,r4,r2
81135f7c:	01810cc4 	movi	r6,1075
81135f80:	310dc83a 	sub	r6,r6,r4
81135f84:	00c007c4 	movi	r3,31
81135f88:	1980120e 	bge	r3,r6,81135fd4 <__floatunsidf+0x80>
81135f8c:	00c104c4 	movi	r3,1043
81135f90:	1907c83a 	sub	r3,r3,r4
81135f94:	80ca983a 	sll	r5,r16,r3
81135f98:	00800434 	movhi	r2,16
81135f9c:	10bfffc4 	addi	r2,r2,-1
81135fa0:	2101ffcc 	andi	r4,r4,2047
81135fa4:	0021883a 	mov	r16,zero
81135fa8:	288a703a 	and	r5,r5,r2
81135fac:	2008953a 	slli	r4,r4,20
81135fb0:	00c00434 	movhi	r3,16
81135fb4:	18ffffc4 	addi	r3,r3,-1
81135fb8:	28c6703a 	and	r3,r5,r3
81135fbc:	8005883a 	mov	r2,r16
81135fc0:	1906b03a 	or	r3,r3,r4
81135fc4:	dfc00117 	ldw	ra,4(sp)
81135fc8:	dc000017 	ldw	r16,0(sp)
81135fcc:	dec00204 	addi	sp,sp,8
81135fd0:	f800283a 	ret
81135fd4:	00c002c4 	movi	r3,11
81135fd8:	188bc83a 	sub	r5,r3,r2
81135fdc:	814ad83a 	srl	r5,r16,r5
81135fe0:	00c00434 	movhi	r3,16
81135fe4:	18ffffc4 	addi	r3,r3,-1
81135fe8:	81a0983a 	sll	r16,r16,r6
81135fec:	2101ffcc 	andi	r4,r4,2047
81135ff0:	28ca703a 	and	r5,r5,r3
81135ff4:	003fed06 	br	81135fac <__reset+0xfb115fac>
81135ff8:	0009883a 	mov	r4,zero
81135ffc:	000b883a 	mov	r5,zero
81136000:	003fea06 	br	81135fac <__reset+0xfb115fac>

81136004 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81136004:	defffb04 	addi	sp,sp,-20
81136008:	de00012e 	bgeu	sp,et,81136010 <alt_busy_sleep+0xc>
8113600c:	003b68fa 	trap	3
81136010:	df000415 	stw	fp,16(sp)
81136014:	df000404 	addi	fp,sp,16
81136018:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
8113601c:	008000c4 	movi	r2,3
81136020:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
81136024:	e0fffd17 	ldw	r3,-12(fp)
81136028:	008003f4 	movhi	r2,15
8113602c:	10909004 	addi	r2,r2,16960
81136030:	1887383a 	mul	r3,r3,r2
81136034:	00817db4 	movhi	r2,1526
81136038:	10b84004 	addi	r2,r2,-7936
8113603c:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81136040:	00a00034 	movhi	r2,32768
81136044:	10bfffc4 	addi	r2,r2,-1
81136048:	10c5203a 	divu	r2,r2,r3
8113604c:	e0ffff17 	ldw	r3,-4(fp)
81136050:	1885203a 	divu	r2,r3,r2
81136054:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81136058:	e0bffe17 	ldw	r2,-8(fp)
8113605c:	10002526 	beq	r2,zero,811360f4 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
81136060:	e03ffc15 	stw	zero,-16(fp)
81136064:	00001406 	br	811360b8 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81136068:	00a00034 	movhi	r2,32768
8113606c:	10bfffc4 	addi	r2,r2,-1
81136070:	10bfffc4 	addi	r2,r2,-1
81136074:	103ffe1e 	bne	r2,zero,81136070 <__reset+0xfb116070>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81136078:	e0fffd17 	ldw	r3,-12(fp)
8113607c:	008003f4 	movhi	r2,15
81136080:	10909004 	addi	r2,r2,16960
81136084:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81136088:	00817db4 	movhi	r2,1526
8113608c:	10b84004 	addi	r2,r2,-7936
81136090:	10c7203a 	divu	r3,r2,r3
81136094:	00a00034 	movhi	r2,32768
81136098:	10bfffc4 	addi	r2,r2,-1
8113609c:	10c5203a 	divu	r2,r2,r3
811360a0:	e0ffff17 	ldw	r3,-4(fp)
811360a4:	1885c83a 	sub	r2,r3,r2
811360a8:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
811360ac:	e0bffc17 	ldw	r2,-16(fp)
811360b0:	10800044 	addi	r2,r2,1
811360b4:	e0bffc15 	stw	r2,-16(fp)
811360b8:	e0fffc17 	ldw	r3,-16(fp)
811360bc:	e0bffe17 	ldw	r2,-8(fp)
811360c0:	18bfe916 	blt	r3,r2,81136068 <__reset+0xfb116068>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
811360c4:	e0fffd17 	ldw	r3,-12(fp)
811360c8:	008003f4 	movhi	r2,15
811360cc:	10909004 	addi	r2,r2,16960
811360d0:	1887383a 	mul	r3,r3,r2
811360d4:	00817db4 	movhi	r2,1526
811360d8:	10b84004 	addi	r2,r2,-7936
811360dc:	10c7203a 	divu	r3,r2,r3
811360e0:	e0bfff17 	ldw	r2,-4(fp)
811360e4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811360e8:	10bfffc4 	addi	r2,r2,-1
811360ec:	103ffe1e 	bne	r2,zero,811360e8 <__reset+0xfb1160e8>
811360f0:	00000b06 	br	81136120 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
811360f4:	e0fffd17 	ldw	r3,-12(fp)
811360f8:	008003f4 	movhi	r2,15
811360fc:	10909004 	addi	r2,r2,16960
81136100:	1887383a 	mul	r3,r3,r2
81136104:	00817db4 	movhi	r2,1526
81136108:	10b84004 	addi	r2,r2,-7936
8113610c:	10c7203a 	divu	r3,r2,r3
81136110:	e0bfff17 	ldw	r2,-4(fp)
81136114:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81136118:	10bfffc4 	addi	r2,r2,-1
8113611c:	00bffe16 	blt	zero,r2,81136118 <__reset+0xfb116118>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81136120:	0005883a 	mov	r2,zero
}
81136124:	e037883a 	mov	sp,fp
81136128:	df000017 	ldw	fp,0(sp)
8113612c:	dec00104 	addi	sp,sp,4
81136130:	f800283a 	ret

81136134 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136134:	defffe04 	addi	sp,sp,-8
81136138:	de00012e 	bgeu	sp,et,81136140 <alt_get_errno+0xc>
8113613c:	003b68fa 	trap	3
81136140:	dfc00115 	stw	ra,4(sp)
81136144:	df000015 	stw	fp,0(sp)
81136148:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113614c:	d0a01017 	ldw	r2,-32704(gp)
81136150:	10000326 	beq	r2,zero,81136160 <alt_get_errno+0x2c>
81136154:	d0a01017 	ldw	r2,-32704(gp)
81136158:	103ee83a 	callr	r2
8113615c:	00000106 	br	81136164 <alt_get_errno+0x30>
81136160:	d0a07804 	addi	r2,gp,-32288
}
81136164:	e037883a 	mov	sp,fp
81136168:	dfc00117 	ldw	ra,4(sp)
8113616c:	df000017 	ldw	fp,0(sp)
81136170:	dec00204 	addi	sp,sp,8
81136174:	f800283a 	ret

81136178 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81136178:	defffb04 	addi	sp,sp,-20
8113617c:	de00012e 	bgeu	sp,et,81136184 <close+0xc>
81136180:	003b68fa 	trap	3
81136184:	dfc00415 	stw	ra,16(sp)
81136188:	df000315 	stw	fp,12(sp)
8113618c:	df000304 	addi	fp,sp,12
81136190:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81136194:	e0bfff17 	ldw	r2,-4(fp)
81136198:	10000616 	blt	r2,zero,811361b4 <close+0x3c>
8113619c:	e0bfff17 	ldw	r2,-4(fp)
811361a0:	10c00324 	muli	r3,r2,12
811361a4:	00a04574 	movhi	r2,33045
811361a8:	1086d504 	addi	r2,r2,6996
811361ac:	1885883a 	add	r2,r3,r2
811361b0:	00000106 	br	811361b8 <close+0x40>
811361b4:	0005883a 	mov	r2,zero
811361b8:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
811361bc:	e0bffd17 	ldw	r2,-12(fp)
811361c0:	10001926 	beq	r2,zero,81136228 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
811361c4:	e0bffd17 	ldw	r2,-12(fp)
811361c8:	10800017 	ldw	r2,0(r2)
811361cc:	10800417 	ldw	r2,16(r2)
811361d0:	10000626 	beq	r2,zero,811361ec <close+0x74>
811361d4:	e0bffd17 	ldw	r2,-12(fp)
811361d8:	10800017 	ldw	r2,0(r2)
811361dc:	10800417 	ldw	r2,16(r2)
811361e0:	e13ffd17 	ldw	r4,-12(fp)
811361e4:	103ee83a 	callr	r2
811361e8:	00000106 	br	811361f0 <close+0x78>
811361ec:	0005883a 	mov	r2,zero
811361f0:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
811361f4:	e13fff17 	ldw	r4,-4(fp)
811361f8:	113775c0 	call	8113775c <alt_release_fd>
    if (rval < 0)
811361fc:	e0bffe17 	ldw	r2,-8(fp)
81136200:	1000070e 	bge	r2,zero,81136220 <close+0xa8>
    {
      ALT_ERRNO = -rval;
81136204:	11361340 	call	81136134 <alt_get_errno>
81136208:	1007883a 	mov	r3,r2
8113620c:	e0bffe17 	ldw	r2,-8(fp)
81136210:	0085c83a 	sub	r2,zero,r2
81136214:	18800015 	stw	r2,0(r3)
      return -1;
81136218:	00bfffc4 	movi	r2,-1
8113621c:	00000706 	br	8113623c <close+0xc4>
    }
    return 0;
81136220:	0005883a 	mov	r2,zero
81136224:	00000506 	br	8113623c <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81136228:	11361340 	call	81136134 <alt_get_errno>
8113622c:	1007883a 	mov	r3,r2
81136230:	00801444 	movi	r2,81
81136234:	18800015 	stw	r2,0(r3)
    return -1;
81136238:	00bfffc4 	movi	r2,-1
  }
}
8113623c:	e037883a 	mov	sp,fp
81136240:	dfc00117 	ldw	ra,4(sp)
81136244:	df000017 	ldw	fp,0(sp)
81136248:	dec00204 	addi	sp,sp,8
8113624c:	f800283a 	ret

81136250 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
81136250:	deffff04 	addi	sp,sp,-4
81136254:	de00012e 	bgeu	sp,et,8113625c <alt_dcache_flush_all+0xc>
81136258:	003b68fa 	trap	3
8113625c:	df000015 	stw	fp,0(sp)
81136260:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81136264:	0001883a 	nop
81136268:	e037883a 	mov	sp,fp
8113626c:	df000017 	ldw	fp,0(sp)
81136270:	dec00104 	addi	sp,sp,4
81136274:	f800283a 	ret

81136278 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81136278:	defffc04 	addi	sp,sp,-16
8113627c:	de00012e 	bgeu	sp,et,81136284 <alt_dev_null_write+0xc>
81136280:	003b68fa 	trap	3
81136284:	df000315 	stw	fp,12(sp)
81136288:	df000304 	addi	fp,sp,12
8113628c:	e13ffd15 	stw	r4,-12(fp)
81136290:	e17ffe15 	stw	r5,-8(fp)
81136294:	e1bfff15 	stw	r6,-4(fp)
  return len;
81136298:	e0bfff17 	ldw	r2,-4(fp)
}
8113629c:	e037883a 	mov	sp,fp
811362a0:	df000017 	ldw	fp,0(sp)
811362a4:	dec00104 	addi	sp,sp,4
811362a8:	f800283a 	ret

811362ac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811362ac:	defffe04 	addi	sp,sp,-8
811362b0:	de00012e 	bgeu	sp,et,811362b8 <alt_get_errno+0xc>
811362b4:	003b68fa 	trap	3
811362b8:	dfc00115 	stw	ra,4(sp)
811362bc:	df000015 	stw	fp,0(sp)
811362c0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811362c4:	d0a01017 	ldw	r2,-32704(gp)
811362c8:	10000326 	beq	r2,zero,811362d8 <alt_get_errno+0x2c>
811362cc:	d0a01017 	ldw	r2,-32704(gp)
811362d0:	103ee83a 	callr	r2
811362d4:	00000106 	br	811362dc <alt_get_errno+0x30>
811362d8:	d0a07804 	addi	r2,gp,-32288
}
811362dc:	e037883a 	mov	sp,fp
811362e0:	dfc00117 	ldw	ra,4(sp)
811362e4:	df000017 	ldw	fp,0(sp)
811362e8:	dec00204 	addi	sp,sp,8
811362ec:	f800283a 	ret

811362f0 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
811362f0:	defffb04 	addi	sp,sp,-20
811362f4:	de00012e 	bgeu	sp,et,811362fc <fstat+0xc>
811362f8:	003b68fa 	trap	3
811362fc:	dfc00415 	stw	ra,16(sp)
81136300:	df000315 	stw	fp,12(sp)
81136304:	df000304 	addi	fp,sp,12
81136308:	e13ffe15 	stw	r4,-8(fp)
8113630c:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81136310:	e0bffe17 	ldw	r2,-8(fp)
81136314:	10000616 	blt	r2,zero,81136330 <fstat+0x40>
81136318:	e0bffe17 	ldw	r2,-8(fp)
8113631c:	10c00324 	muli	r3,r2,12
81136320:	00a04574 	movhi	r2,33045
81136324:	1086d504 	addi	r2,r2,6996
81136328:	1885883a 	add	r2,r3,r2
8113632c:	00000106 	br	81136334 <fstat+0x44>
81136330:	0005883a 	mov	r2,zero
81136334:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81136338:	e0bffd17 	ldw	r2,-12(fp)
8113633c:	10001026 	beq	r2,zero,81136380 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81136340:	e0bffd17 	ldw	r2,-12(fp)
81136344:	10800017 	ldw	r2,0(r2)
81136348:	10800817 	ldw	r2,32(r2)
8113634c:	10000726 	beq	r2,zero,8113636c <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
81136350:	e0bffd17 	ldw	r2,-12(fp)
81136354:	10800017 	ldw	r2,0(r2)
81136358:	10800817 	ldw	r2,32(r2)
8113635c:	e17fff17 	ldw	r5,-4(fp)
81136360:	e13ffd17 	ldw	r4,-12(fp)
81136364:	103ee83a 	callr	r2
81136368:	00000a06 	br	81136394 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
8113636c:	e0bfff17 	ldw	r2,-4(fp)
81136370:	00c80004 	movi	r3,8192
81136374:	10c00115 	stw	r3,4(r2)
      return 0;
81136378:	0005883a 	mov	r2,zero
8113637c:	00000506 	br	81136394 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81136380:	11362ac0 	call	811362ac <alt_get_errno>
81136384:	1007883a 	mov	r3,r2
81136388:	00801444 	movi	r2,81
8113638c:	18800015 	stw	r2,0(r3)
    return -1;
81136390:	00bfffc4 	movi	r2,-1
  }
}
81136394:	e037883a 	mov	sp,fp
81136398:	dfc00117 	ldw	ra,4(sp)
8113639c:	df000017 	ldw	fp,0(sp)
811363a0:	dec00204 	addi	sp,sp,8
811363a4:	f800283a 	ret

811363a8 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
811363a8:	defff004 	addi	sp,sp,-64
811363ac:	de00012e 	bgeu	sp,et,811363b4 <alt_irq_register+0xc>
811363b0:	003b68fa 	trap	3
811363b4:	df000f15 	stw	fp,60(sp)
811363b8:	df000f04 	addi	fp,sp,60
811363bc:	e13ffd15 	stw	r4,-12(fp)
811363c0:	e17ffe15 	stw	r5,-8(fp)
811363c4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
811363c8:	00bffa84 	movi	r2,-22
811363cc:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
811363d0:	e0bffd17 	ldw	r2,-12(fp)
811363d4:	10800828 	cmpgeui	r2,r2,32
811363d8:	1000501e 	bne	r2,zero,8113651c <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811363dc:	0005303a 	rdctl	r2,status
811363e0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811363e4:	e0fff617 	ldw	r3,-40(fp)
811363e8:	00bfff84 	movi	r2,-2
811363ec:	1884703a 	and	r2,r3,r2
811363f0:	1001703a 	wrctl	status,r2
  
  return context;
811363f4:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
811363f8:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
811363fc:	00a045f4 	movhi	r2,33047
81136400:	10b47c04 	addi	r2,r2,-11792
81136404:	e0fffd17 	ldw	r3,-12(fp)
81136408:	180690fa 	slli	r3,r3,3
8113640c:	10c5883a 	add	r2,r2,r3
81136410:	e0ffff17 	ldw	r3,-4(fp)
81136414:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
81136418:	00a045f4 	movhi	r2,33047
8113641c:	10b47c04 	addi	r2,r2,-11792
81136420:	e0fffd17 	ldw	r3,-12(fp)
81136424:	180690fa 	slli	r3,r3,3
81136428:	10c5883a 	add	r2,r2,r3
8113642c:	10800104 	addi	r2,r2,4
81136430:	e0fffe17 	ldw	r3,-8(fp)
81136434:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
81136438:	e0bfff17 	ldw	r2,-4(fp)
8113643c:	10001926 	beq	r2,zero,811364a4 <alt_irq_register+0xfc>
81136440:	e0bffd17 	ldw	r2,-12(fp)
81136444:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136448:	0005303a 	rdctl	r2,status
8113644c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136450:	e0fff717 	ldw	r3,-36(fp)
81136454:	00bfff84 	movi	r2,-2
81136458:	1884703a 	and	r2,r3,r2
8113645c:	1001703a 	wrctl	status,r2
  
  return context;
81136460:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81136464:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81136468:	00c00044 	movi	r3,1
8113646c:	e0bff217 	ldw	r2,-56(fp)
81136470:	1884983a 	sll	r2,r3,r2
81136474:	1007883a 	mov	r3,r2
81136478:	d0a08017 	ldw	r2,-32256(gp)
8113647c:	1884b03a 	or	r2,r3,r2
81136480:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81136484:	d0a08017 	ldw	r2,-32256(gp)
81136488:	100170fa 	wrctl	ienable,r2
8113648c:	e0bff817 	ldw	r2,-32(fp)
81136490:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136494:	e0bff917 	ldw	r2,-28(fp)
81136498:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113649c:	0005883a 	mov	r2,zero
811364a0:	00001906 	br	81136508 <alt_irq_register+0x160>
811364a4:	e0bffd17 	ldw	r2,-12(fp)
811364a8:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811364ac:	0005303a 	rdctl	r2,status
811364b0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811364b4:	e0fffa17 	ldw	r3,-24(fp)
811364b8:	00bfff84 	movi	r2,-2
811364bc:	1884703a 	and	r2,r3,r2
811364c0:	1001703a 	wrctl	status,r2
  
  return context;
811364c4:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811364c8:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
811364cc:	00c00044 	movi	r3,1
811364d0:	e0bff417 	ldw	r2,-48(fp)
811364d4:	1884983a 	sll	r2,r3,r2
811364d8:	0084303a 	nor	r2,zero,r2
811364dc:	1007883a 	mov	r3,r2
811364e0:	d0a08017 	ldw	r2,-32256(gp)
811364e4:	1884703a 	and	r2,r3,r2
811364e8:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811364ec:	d0a08017 	ldw	r2,-32256(gp)
811364f0:	100170fa 	wrctl	ienable,r2
811364f4:	e0bffb17 	ldw	r2,-20(fp)
811364f8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811364fc:	e0bffc17 	ldw	r2,-16(fp)
81136500:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81136504:	0005883a 	mov	r2,zero
81136508:	e0bff115 	stw	r2,-60(fp)
8113650c:	e0bff317 	ldw	r2,-52(fp)
81136510:	e0bff515 	stw	r2,-44(fp)
81136514:	e0bff517 	ldw	r2,-44(fp)
81136518:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
8113651c:	e0bff117 	ldw	r2,-60(fp)
}
81136520:	e037883a 	mov	sp,fp
81136524:	df000017 	ldw	fp,0(sp)
81136528:	dec00104 	addi	sp,sp,4
8113652c:	f800283a 	ret

81136530 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136530:	defffe04 	addi	sp,sp,-8
81136534:	de00012e 	bgeu	sp,et,8113653c <alt_get_errno+0xc>
81136538:	003b68fa 	trap	3
8113653c:	dfc00115 	stw	ra,4(sp)
81136540:	df000015 	stw	fp,0(sp)
81136544:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81136548:	d0a01017 	ldw	r2,-32704(gp)
8113654c:	10000326 	beq	r2,zero,8113655c <alt_get_errno+0x2c>
81136550:	d0a01017 	ldw	r2,-32704(gp)
81136554:	103ee83a 	callr	r2
81136558:	00000106 	br	81136560 <alt_get_errno+0x30>
8113655c:	d0a07804 	addi	r2,gp,-32288
}
81136560:	e037883a 	mov	sp,fp
81136564:	dfc00117 	ldw	ra,4(sp)
81136568:	df000017 	ldw	fp,0(sp)
8113656c:	dec00204 	addi	sp,sp,8
81136570:	f800283a 	ret

81136574 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81136574:	deffed04 	addi	sp,sp,-76
81136578:	de00012e 	bgeu	sp,et,81136580 <isatty+0xc>
8113657c:	003b68fa 	trap	3
81136580:	dfc01215 	stw	ra,72(sp)
81136584:	df001115 	stw	fp,68(sp)
81136588:	df001104 	addi	fp,sp,68
8113658c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81136590:	e0bfff17 	ldw	r2,-4(fp)
81136594:	10000616 	blt	r2,zero,811365b0 <isatty+0x3c>
81136598:	e0bfff17 	ldw	r2,-4(fp)
8113659c:	10c00324 	muli	r3,r2,12
811365a0:	00a04574 	movhi	r2,33045
811365a4:	1086d504 	addi	r2,r2,6996
811365a8:	1885883a 	add	r2,r3,r2
811365ac:	00000106 	br	811365b4 <isatty+0x40>
811365b0:	0005883a 	mov	r2,zero
811365b4:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
811365b8:	e0bfef17 	ldw	r2,-68(fp)
811365bc:	10000e26 	beq	r2,zero,811365f8 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
811365c0:	e0bfef17 	ldw	r2,-68(fp)
811365c4:	10800017 	ldw	r2,0(r2)
811365c8:	10800817 	ldw	r2,32(r2)
811365cc:	1000021e 	bne	r2,zero,811365d8 <isatty+0x64>
    {
      return 1;
811365d0:	00800044 	movi	r2,1
811365d4:	00000d06 	br	8113660c <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
811365d8:	e0bff004 	addi	r2,fp,-64
811365dc:	100b883a 	mov	r5,r2
811365e0:	e13fff17 	ldw	r4,-4(fp)
811365e4:	11362f00 	call	811362f0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
811365e8:	e0bff117 	ldw	r2,-60(fp)
811365ec:	10880020 	cmpeqi	r2,r2,8192
811365f0:	10803fcc 	andi	r2,r2,255
811365f4:	00000506 	br	8113660c <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811365f8:	11365300 	call	81136530 <alt_get_errno>
811365fc:	1007883a 	mov	r3,r2
81136600:	00801444 	movi	r2,81
81136604:	18800015 	stw	r2,0(r3)
    return 0;
81136608:	0005883a 	mov	r2,zero
  }
}
8113660c:	e037883a 	mov	sp,fp
81136610:	dfc00117 	ldw	ra,4(sp)
81136614:	df000017 	ldw	fp,0(sp)
81136618:	dec00204 	addi	sp,sp,8
8113661c:	f800283a 	ret

81136620 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81136620:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81136624:	318c2404 	addi	r6,r6,12432

81136628 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
81136628:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
8113662c:	01c00826 	beq	zero,r7,81136650 <end_tx>

81136630 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
81136630:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81136634:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
81136638:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
8113663c:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81136640:	283ffb26 	beq	r5,zero,81136630 <__reset+0xfb116630>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81136644:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81136648:	21000044 	addi	r4,r4,1
	br tx_next_char
8113664c:	003ff606 	br	81136628 <__reset+0xfb116628>

81136650 <end_tx>:
end_tx:	
        ret
81136650:	f800283a 	ret

81136654 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81136654:	defffd04 	addi	sp,sp,-12
81136658:	de00012e 	bgeu	sp,et,81136660 <alt_log_txchar+0xc>
8113665c:	003b68fa 	trap	3
81136660:	df000215 	stw	fp,8(sp)
81136664:	df000204 	addi	fp,sp,8
81136668:	e13ffe15 	stw	r4,-8(fp)
8113666c:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81136670:	0001883a 	nop
81136674:	e0bfff17 	ldw	r2,-4(fp)
81136678:	10800104 	addi	r2,r2,4
8113667c:	10800037 	ldwio	r2,0(r2)
81136680:	10bfffec 	andhi	r2,r2,65535
81136684:	103ffb26 	beq	r2,zero,81136674 <__reset+0xfb116674>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81136688:	e0bfff17 	ldw	r2,-4(fp)
8113668c:	e0fffe17 	ldw	r3,-8(fp)
81136690:	10c00035 	stwio	r3,0(r2)
}
81136694:	0001883a 	nop
81136698:	e037883a 	mov	sp,fp
8113669c:	df000017 	ldw	fp,0(sp)
811366a0:	dec00104 	addi	sp,sp,4
811366a4:	f800283a 	ret

811366a8 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
811366a8:	defffb04 	addi	sp,sp,-20
811366ac:	de00012e 	bgeu	sp,et,811366b4 <alt_log_repchar+0xc>
811366b0:	003b68fa 	trap	3
811366b4:	dfc00415 	stw	ra,16(sp)
811366b8:	df000315 	stw	fp,12(sp)
811366bc:	df000304 	addi	fp,sp,12
811366c0:	2005883a 	mov	r2,r4
811366c4:	e17ffe15 	stw	r5,-8(fp)
811366c8:	e1bfff15 	stw	r6,-4(fp)
811366cc:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
811366d0:	00000506 	br	811366e8 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
811366d4:	e0bffd07 	ldb	r2,-12(fp)
811366d8:	e0ffff17 	ldw	r3,-4(fp)
811366dc:	180b883a 	mov	r5,r3
811366e0:	1009883a 	mov	r4,r2
811366e4:	11366540 	call	81136654 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
811366e8:	e0bffe17 	ldw	r2,-8(fp)
811366ec:	10ffffc4 	addi	r3,r2,-1
811366f0:	e0fffe15 	stw	r3,-8(fp)
811366f4:	00bff716 	blt	zero,r2,811366d4 <__reset+0xfb1166d4>
    alt_log_txchar(c,(char*) base);
}
811366f8:	0001883a 	nop
811366fc:	e037883a 	mov	sp,fp
81136700:	dfc00117 	ldw	ra,4(sp)
81136704:	df000017 	ldw	fp,0(sp)
81136708:	dec00204 	addi	sp,sp,8
8113670c:	f800283a 	ret

81136710 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81136710:	deffe904 	addi	sp,sp,-92
81136714:	de00012e 	bgeu	sp,et,8113671c <alt_log_private_printf+0xc>
81136718:	003b68fa 	trap	3
8113671c:	dfc01615 	stw	ra,88(sp)
81136720:	df001515 	stw	fp,84(sp)
81136724:	dc001415 	stw	r16,80(sp)
81136728:	df001504 	addi	fp,sp,84
8113672c:	e13ffc15 	stw	r4,-16(fp)
81136730:	e17ffd15 	stw	r5,-12(fp)
81136734:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
81136738:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
8113673c:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81136740:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81136744:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
81136748:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
8113674c:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81136750:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81136754:	e0bffc17 	ldw	r2,-16(fp)
81136758:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
8113675c:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
81136760:	00014b06 	br	81136c90 <alt_log_private_printf+0x580>
    {
    switch(state)
81136764:	e0bfec17 	ldw	r2,-80(fp)
81136768:	10c00060 	cmpeqi	r3,r2,1
8113676c:	18001b1e 	bne	r3,zero,811367dc <alt_log_private_printf+0xcc>
81136770:	10c000a0 	cmpeqi	r3,r2,2
81136774:	18002d1e 	bne	r3,zero,8113682c <alt_log_private_printf+0x11c>
81136778:	10000126 	beq	r2,zero,81136780 <alt_log_private_printf+0x70>
8113677c:	00014406 	br	81136c90 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81136780:	e0bffb07 	ldb	r2,-20(fp)
81136784:	10800958 	cmpnei	r2,r2,37
81136788:	10000e1e 	bne	r2,zero,811367c4 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
8113678c:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81136790:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81136794:	00800284 	movi	r2,10
81136798:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
8113679c:	00800044 	movi	r2,1
811367a0:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
811367a4:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
811367a8:	00bfffc4 	movi	r2,-1
811367ac:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
811367b0:	00bfffc4 	movi	r2,-1
811367b4:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
811367b8:	00800044 	movi	r2,1
811367bc:	e0bfec15 	stw	r2,-80(fp)
811367c0:	00013306 	br	81136c90 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
811367c4:	e0bffb07 	ldb	r2,-20(fp)
811367c8:	e0fffd17 	ldw	r3,-12(fp)
811367cc:	180b883a 	mov	r5,r3
811367d0:	1009883a 	mov	r4,r2
811367d4:	11366540 	call	81136654 <alt_log_txchar>
        }
        break;
811367d8:	00012d06 	br	81136c90 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
811367dc:	e0bffb07 	ldb	r2,-20(fp)
811367e0:	10800c18 	cmpnei	r2,r2,48
811367e4:	1000051e 	bne	r2,zero,811367fc <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
811367e8:	00800044 	movi	r2,1
811367ec:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
811367f0:	00800084 	movi	r2,2
811367f4:	e0bfec15 	stw	r2,-80(fp)
811367f8:	00012506 	br	81136c90 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
811367fc:	e0bffb07 	ldb	r2,-20(fp)
81136800:	10800958 	cmpnei	r2,r2,37
81136804:	1000071e 	bne	r2,zero,81136824 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81136808:	e0bffb07 	ldb	r2,-20(fp)
8113680c:	e0fffd17 	ldw	r3,-12(fp)
81136810:	180b883a 	mov	r5,r3
81136814:	1009883a 	mov	r4,r2
81136818:	11366540 	call	81136654 <alt_log_txchar>
          state = pfState_chars;
8113681c:	e03fec15 	stw	zero,-80(fp)
81136820:	00011b06 	br	81136c90 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81136824:	00800084 	movi	r2,2
81136828:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
8113682c:	e0bffb07 	ldb	r2,-20(fp)
81136830:	10800b98 	cmpnei	r2,r2,46
81136834:	1000021e 	bne	r2,zero,81136840 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81136838:	e03ff015 	stw	zero,-64(fp)
8113683c:	00011306 	br	81136c8c <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81136840:	e0bffb07 	ldb	r2,-20(fp)
81136844:	10800c10 	cmplti	r2,r2,48
81136848:	10001a1e 	bne	r2,zero,811368b4 <alt_log_private_printf+0x1a4>
8113684c:	e0bffb07 	ldb	r2,-20(fp)
81136850:	10800e88 	cmpgei	r2,r2,58
81136854:	1000171e 	bne	r2,zero,811368b4 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81136858:	e0bffb03 	ldbu	r2,-20(fp)
8113685c:	10bff404 	addi	r2,r2,-48
81136860:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81136864:	e0bff017 	ldw	r2,-64(fp)
81136868:	10000c0e 	bge	r2,zero,8113689c <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
8113686c:	e0bfef17 	ldw	r2,-68(fp)
81136870:	1000020e 	bge	r2,zero,8113687c <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81136874:	e03fef15 	stw	zero,-68(fp)
81136878:	00000306 	br	81136888 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
8113687c:	e0bfef17 	ldw	r2,-68(fp)
81136880:	108002a4 	muli	r2,r2,10
81136884:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81136888:	e0bffb07 	ldb	r2,-20(fp)
8113688c:	e0ffef17 	ldw	r3,-68(fp)
81136890:	1885883a 	add	r2,r3,r2
81136894:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81136898:	0000fc06 	br	81136c8c <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
8113689c:	e0bff017 	ldw	r2,-64(fp)
811368a0:	10c002a4 	muli	r3,r2,10
811368a4:	e0bffb07 	ldb	r2,-20(fp)
811368a8:	1885883a 	add	r2,r3,r2
811368ac:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
811368b0:	0000f606 	br	81136c8c <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
811368b4:	e0bffb07 	ldb	r2,-20(fp)
811368b8:	10801b18 	cmpnei	r2,r2,108
811368bc:	1000031e 	bne	r2,zero,811368cc <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
811368c0:	00800044 	movi	r2,1
811368c4:	e0bfee15 	stw	r2,-72(fp)
811368c8:	0000f006 	br	81136c8c <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
811368cc:	e0bffb07 	ldb	r2,-20(fp)
811368d0:	10bfea04 	addi	r2,r2,-88
811368d4:	10c00868 	cmpgeui	r3,r2,33
811368d8:	1800eb1e 	bne	r3,zero,81136c88 <alt_log_private_printf+0x578>
811368dc:	100690ba 	slli	r3,r2,2
811368e0:	00a044f4 	movhi	r2,33043
811368e4:	109a3d04 	addi	r2,r2,26868
811368e8:	1885883a 	add	r2,r3,r2
811368ec:	10800017 	ldw	r2,0(r2)
811368f0:	1000683a 	jmp	r2
811368f4:	81136bb4 	orhi	r4,r16,19886
811368f8:	81136c88 	cmpgei	r4,r16,19890
811368fc:	81136c88 	cmpgei	r4,r16,19890
81136900:	81136c88 	cmpgei	r4,r16,19890
81136904:	81136c88 	cmpgei	r4,r16,19890
81136908:	81136c88 	cmpgei	r4,r16,19890
8113690c:	81136c88 	cmpgei	r4,r16,19890
81136910:	81136c88 	cmpgei	r4,r16,19890
81136914:	81136c88 	cmpgei	r4,r16,19890
81136918:	81136c88 	cmpgei	r4,r16,19890
8113691c:	81136c88 	cmpgei	r4,r16,19890
81136920:	81136bcc 	andi	r4,r16,19887
81136924:	81136978 	rdprs	r4,r16,19877
81136928:	81136c88 	cmpgei	r4,r16,19890
8113692c:	81136c88 	cmpgei	r4,r16,19890
81136930:	81136c88 	cmpgei	r4,r16,19890
81136934:	81136c88 	cmpgei	r4,r16,19890
81136938:	81136978 	rdprs	r4,r16,19877
8113693c:	81136c88 	cmpgei	r4,r16,19890
81136940:	81136c88 	cmpgei	r4,r16,19890
81136944:	81136c88 	cmpgei	r4,r16,19890
81136948:	81136c88 	cmpgei	r4,r16,19890
8113694c:	81136c88 	cmpgei	r4,r16,19890
81136950:	81136b94 	ori	r4,r16,19886
81136954:	81136c88 	cmpgei	r4,r16,19890
81136958:	81136c88 	cmpgei	r4,r16,19890
8113695c:	81136c88 	cmpgei	r4,r16,19890
81136960:	81136c08 	cmpgei	r4,r16,19888
81136964:	81136c88 	cmpgei	r4,r16,19890
81136968:	81136b8c 	andi	r4,r16,19886
8113696c:	81136c88 	cmpgei	r4,r16,19890
81136970:	81136c88 	cmpgei	r4,r16,19890
81136974:	81136ba4 	muli	r4,r16,19886
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81136978:	e0bfee17 	ldw	r2,-72(fp)
8113697c:	10000e26 	beq	r2,zero,811369b8 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81136980:	e0bff217 	ldw	r2,-56(fp)
81136984:	10000626 	beq	r2,zero,811369a0 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81136988:	e0bffe17 	ldw	r2,-8(fp)
8113698c:	10c00104 	addi	r3,r2,4
81136990:	e0fffe15 	stw	r3,-8(fp)
81136994:	10800017 	ldw	r2,0(r2)
81136998:	e0bff415 	stw	r2,-48(fp)
8113699c:	00001306 	br	811369ec <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
811369a0:	e0bffe17 	ldw	r2,-8(fp)
811369a4:	10c00104 	addi	r3,r2,4
811369a8:	e0fffe15 	stw	r3,-8(fp)
811369ac:	10800017 	ldw	r2,0(r2)
811369b0:	e0bff415 	stw	r2,-48(fp)
811369b4:	00000d06 	br	811369ec <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
811369b8:	e0bff217 	ldw	r2,-56(fp)
811369bc:	10000626 	beq	r2,zero,811369d8 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
811369c0:	e0bffe17 	ldw	r2,-8(fp)
811369c4:	10c00104 	addi	r3,r2,4
811369c8:	e0fffe15 	stw	r3,-8(fp)
811369cc:	10800017 	ldw	r2,0(r2)
811369d0:	e0bff415 	stw	r2,-48(fp)
811369d4:	00000506 	br	811369ec <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
811369d8:	e0bffe17 	ldw	r2,-8(fp)
811369dc:	10c00104 	addi	r3,r2,4
811369e0:	e0fffe15 	stw	r3,-8(fp)
811369e4:	10800017 	ldw	r2,0(r2)
811369e8:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
811369ec:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
811369f0:	e0bff217 	ldw	r2,-56(fp)
811369f4:	10000726 	beq	r2,zero,81136a14 <alt_log_private_printf+0x304>
811369f8:	e0bff417 	ldw	r2,-48(fp)
811369fc:	1000050e 	bge	r2,zero,81136a14 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81136a00:	e0bff417 	ldw	r2,-48(fp)
81136a04:	0085c83a 	sub	r2,zero,r2
81136a08:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81136a0c:	00800044 	movi	r2,1
81136a10:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81136a14:	e0bff417 	ldw	r2,-48(fp)
81136a18:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81136a1c:	00800044 	movi	r2,1
81136a20:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81136a24:	00800044 	movi	r2,1
81136a28:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81136a2c:	00000706 	br	81136a4c <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81136a30:	e0bff817 	ldw	r2,-32(fp)
81136a34:	10800044 	addi	r2,r2,1
81136a38:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81136a3c:	e0bff117 	ldw	r2,-60(fp)
81136a40:	e0fff517 	ldw	r3,-44(fp)
81136a44:	1885383a 	mul	r2,r3,r2
81136a48:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81136a4c:	e0bff117 	ldw	r2,-60(fp)
81136a50:	e0fff617 	ldw	r3,-40(fp)
81136a54:	1885203a 	divu	r2,r3,r2
81136a58:	e0bff615 	stw	r2,-40(fp)
81136a5c:	e0bff617 	ldw	r2,-40(fp)
81136a60:	103ff31e 	bne	r2,zero,81136a30 <__reset+0xfb116a30>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81136a64:	e0ffef17 	ldw	r3,-68(fp)
81136a68:	e0bff817 	ldw	r2,-32(fp)
81136a6c:	1885c83a 	sub	r2,r3,r2
81136a70:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81136a74:	e0bfed17 	ldw	r2,-76(fp)
81136a78:	10000e26 	beq	r2,zero,81136ab4 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81136a7c:	e0bff717 	ldw	r2,-36(fp)
81136a80:	10000726 	beq	r2,zero,81136aa0 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81136a84:	e0bffd17 	ldw	r2,-12(fp)
81136a88:	100b883a 	mov	r5,r2
81136a8c:	01000b44 	movi	r4,45
81136a90:	11366540 	call	81136654 <alt_log_txchar>
                    fmtBeforeDecimal--;
81136a94:	e0bfef17 	ldw	r2,-68(fp)
81136a98:	10bfffc4 	addi	r2,r2,-1
81136a9c:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81136aa0:	e1bffd17 	ldw	r6,-12(fp)
81136aa4:	e17fef17 	ldw	r5,-68(fp)
81136aa8:	01000c04 	movi	r4,48
81136aac:	11366a80 	call	811366a8 <alt_log_repchar>
81136ab0:	00003206 	br	81136b7c <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81136ab4:	e0bff717 	ldw	r2,-36(fp)
81136ab8:	10000326 	beq	r2,zero,81136ac8 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81136abc:	e0bfef17 	ldw	r2,-68(fp)
81136ac0:	10bfffc4 	addi	r2,r2,-1
81136ac4:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81136ac8:	e1bffd17 	ldw	r6,-12(fp)
81136acc:	e17fef17 	ldw	r5,-68(fp)
81136ad0:	01000804 	movi	r4,32
81136ad4:	11366a80 	call	811366a8 <alt_log_repchar>
                    if(sign)
81136ad8:	e0bff717 	ldw	r2,-36(fp)
81136adc:	10002726 	beq	r2,zero,81136b7c <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81136ae0:	e0bffd17 	ldw	r2,-12(fp)
81136ae4:	100b883a 	mov	r5,r2
81136ae8:	01000b44 	movi	r4,45
81136aec:	11366540 	call	81136654 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81136af0:	00002206 	br	81136b7c <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81136af4:	e0fff417 	ldw	r3,-48(fp)
81136af8:	e0bff517 	ldw	r2,-44(fp)
81136afc:	1885203a 	divu	r2,r3,r2
81136b00:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81136b04:	e0bff903 	ldbu	r2,-28(fp)
81136b08:	10800c04 	addi	r2,r2,48
81136b0c:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81136b10:	e0bff903 	ldbu	r2,-28(fp)
81136b14:	10800eb0 	cmpltui	r2,r2,58
81136b18:	1000081e 	bne	r2,zero,81136b3c <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81136b1c:	e0bff317 	ldw	r2,-52(fp)
81136b20:	10000226 	beq	r2,zero,81136b2c <alt_log_private_printf+0x41c>
81136b24:	008001c4 	movi	r2,7
81136b28:	00000106 	br	81136b30 <alt_log_private_printf+0x420>
81136b2c:	008009c4 	movi	r2,39
81136b30:	e0fff903 	ldbu	r3,-28(fp)
81136b34:	10c5883a 	add	r2,r2,r3
81136b38:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81136b3c:	e0bff903 	ldbu	r2,-28(fp)
81136b40:	e0fffd17 	ldw	r3,-12(fp)
81136b44:	180b883a 	mov	r5,r3
81136b48:	1009883a 	mov	r4,r2
81136b4c:	11366540 	call	81136654 <alt_log_txchar>

                  v = v % p;
81136b50:	e0bff417 	ldw	r2,-48(fp)
81136b54:	e0fff517 	ldw	r3,-44(fp)
81136b58:	10c9203a 	divu	r4,r2,r3
81136b5c:	e0fff517 	ldw	r3,-44(fp)
81136b60:	20c7383a 	mul	r3,r4,r3
81136b64:	10c5c83a 	sub	r2,r2,r3
81136b68:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81136b6c:	e0bff117 	ldw	r2,-60(fp)
81136b70:	e0fff517 	ldw	r3,-44(fp)
81136b74:	1885203a 	divu	r2,r3,r2
81136b78:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81136b7c:	e0bff517 	ldw	r2,-44(fp)
81136b80:	103fdc1e 	bne	r2,zero,81136af4 <__reset+0xfb116af4>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81136b84:	e03fec15 	stw	zero,-80(fp)
              break;
81136b88:	00003f06 	br	81136c88 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81136b8c:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81136b90:	003f7906 	br	81136978 <__reset+0xfb116978>
            case 'o':
              fmtSigned = 0;
81136b94:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81136b98:	00800204 	movi	r2,8
81136b9c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81136ba0:	003f7506 	br	81136978 <__reset+0xfb116978>
            case 'x':
              fmtSigned = 0;
81136ba4:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81136ba8:	00800404 	movi	r2,16
81136bac:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81136bb0:	003f7106 	br	81136978 <__reset+0xfb116978>
            case 'X':
              fmtSigned = 0;
81136bb4:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81136bb8:	00800404 	movi	r2,16
81136bbc:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81136bc0:	00800044 	movi	r2,1
81136bc4:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81136bc8:	003f6b06 	br	81136978 <__reset+0xfb116978>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81136bcc:	e0bfef17 	ldw	r2,-68(fp)
81136bd0:	10bfffc4 	addi	r2,r2,-1
81136bd4:	e1bffd17 	ldw	r6,-12(fp)
81136bd8:	100b883a 	mov	r5,r2
81136bdc:	01000804 	movi	r4,32
81136be0:	11366a80 	call	811366a8 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81136be4:	e0bffe17 	ldw	r2,-8(fp)
81136be8:	10c00104 	addi	r3,r2,4
81136bec:	e0fffe15 	stw	r3,-8(fp)
81136bf0:	10800017 	ldw	r2,0(r2)
81136bf4:	e0fffd17 	ldw	r3,-12(fp)
81136bf8:	180b883a 	mov	r5,r3
81136bfc:	1009883a 	mov	r4,r2
81136c00:	11366540 	call	81136654 <alt_log_txchar>
              break;
81136c04:	00002006 	br	81136c88 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81136c08:	e0bffe17 	ldw	r2,-8(fp)
81136c0c:	10c00104 	addi	r3,r2,4
81136c10:	e0fffe15 	stw	r3,-8(fp)
81136c14:	10800017 	ldw	r2,0(r2)
81136c18:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81136c1c:	e43fef17 	ldw	r16,-68(fp)
81136c20:	e13ffa17 	ldw	r4,-24(fp)
81136c24:	1122ee80 	call	81122ee8 <strlen>
81136c28:	8085c83a 	sub	r2,r16,r2
81136c2c:	e1bffd17 	ldw	r6,-12(fp)
81136c30:	100b883a 	mov	r5,r2
81136c34:	01000804 	movi	r4,32
81136c38:	11366a80 	call	811366a8 <alt_log_repchar>

                while(*s)
81136c3c:	00000b06 	br	81136c6c <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81136c40:	e0bffa17 	ldw	r2,-24(fp)
81136c44:	10c00044 	addi	r3,r2,1
81136c48:	e0fffa15 	stw	r3,-24(fp)
81136c4c:	10800003 	ldbu	r2,0(r2)
81136c50:	10803fcc 	andi	r2,r2,255
81136c54:	1080201c 	xori	r2,r2,128
81136c58:	10bfe004 	addi	r2,r2,-128
81136c5c:	e0fffd17 	ldw	r3,-12(fp)
81136c60:	180b883a 	mov	r5,r3
81136c64:	1009883a 	mov	r4,r2
81136c68:	11366540 	call	81136654 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81136c6c:	e0bffa17 	ldw	r2,-24(fp)
81136c70:	10800003 	ldbu	r2,0(r2)
81136c74:	10803fcc 	andi	r2,r2,255
81136c78:	1080201c 	xori	r2,r2,128
81136c7c:	10bfe004 	addi	r2,r2,-128
81136c80:	103fef1e 	bne	r2,zero,81136c40 <__reset+0xfb116c40>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81136c84:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81136c88:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81136c8c:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81136c90:	e0bfeb17 	ldw	r2,-84(fp)
81136c94:	10c00044 	addi	r3,r2,1
81136c98:	e0ffeb15 	stw	r3,-84(fp)
81136c9c:	10800003 	ldbu	r2,0(r2)
81136ca0:	e0bffb05 	stb	r2,-20(fp)
81136ca4:	e0bffb07 	ldb	r2,-20(fp)
81136ca8:	103eae1e 	bne	r2,zero,81136764 <__reset+0xfb116764>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81136cac:	0001883a 	nop
81136cb0:	e6ffff04 	addi	sp,fp,-4
81136cb4:	dfc00217 	ldw	ra,8(sp)
81136cb8:	df000117 	ldw	fp,4(sp)
81136cbc:	dc000017 	ldw	r16,0(sp)
81136cc0:	dec00304 	addi	sp,sp,12
81136cc4:	f800283a 	ret

81136cc8 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81136cc8:	defff904 	addi	sp,sp,-28
81136ccc:	de00012e 	bgeu	sp,et,81136cd4 <alt_log_printf_proc+0xc>
81136cd0:	003b68fa 	trap	3
81136cd4:	dfc00315 	stw	ra,12(sp)
81136cd8:	df000215 	stw	fp,8(sp)
81136cdc:	df000204 	addi	fp,sp,8
81136ce0:	e13fff15 	stw	r4,-4(fp)
81136ce4:	e1400215 	stw	r5,8(fp)
81136ce8:	e1800315 	stw	r6,12(fp)
81136cec:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81136cf0:	e0800204 	addi	r2,fp,8
81136cf4:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81136cf8:	e0bffe17 	ldw	r2,-8(fp)
81136cfc:	100d883a 	mov	r6,r2
81136d00:	01604834 	movhi	r5,33056
81136d04:	294c2404 	addi	r5,r5,12432
81136d08:	e13fff17 	ldw	r4,-4(fp)
81136d0c:	11367100 	call	81136710 <alt_log_private_printf>
    return (0);
81136d10:	0005883a 	mov	r2,zero
}
81136d14:	e037883a 	mov	sp,fp
81136d18:	dfc00117 	ldw	ra,4(sp)
81136d1c:	df000017 	ldw	fp,0(sp)
81136d20:	dec00504 	addi	sp,sp,20
81136d24:	f800283a 	ret

81136d28 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81136d28:	defff904 	addi	sp,sp,-28
81136d2c:	de00012e 	bgeu	sp,et,81136d34 <altera_avalon_jtag_uart_report_log+0xc>
81136d30:	003b68fa 	trap	3
81136d34:	dfc00615 	stw	ra,24(sp)
81136d38:	df000515 	stw	fp,20(sp)
81136d3c:	dc400415 	stw	r17,16(sp)
81136d40:	dc000315 	stw	r16,12(sp)
81136d44:	df000504 	addi	fp,sp,20
81136d48:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81136d4c:	d0a08183 	ldbu	r2,-32250(gp)
81136d50:	10803fcc 	andi	r2,r2,255
81136d54:	10001426 	beq	r2,zero,81136da8 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81136d58:	e0bffd17 	ldw	r2,-12(fp)
81136d5c:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81136d60:	00a04574 	movhi	r2,33045
81136d64:	1082fb04 	addi	r2,r2,3052
81136d68:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81136d6c:	e0bffb17 	ldw	r2,-20(fp)
81136d70:	10800017 	ldw	r2,0(r2)
81136d74:	e1bffc17 	ldw	r6,-16(fp)
81136d78:	100b883a 	mov	r5,r2
81136d7c:	e13ffb17 	ldw	r4,-20(fp)
81136d80:	1136dc80 	call	81136dc8 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81136d84:	d0e08817 	ldw	r3,-32224(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81136d88:	00b33374 	movhi	r2,52429
81136d8c:	10b33344 	addi	r2,r2,-13107
81136d90:	1888383a 	mulxuu	r4,r3,r2
81136d94:	1885383a 	mul	r2,r3,r2
81136d98:	1021883a 	mov	r16,r2
81136d9c:	2023883a 	mov	r17,r4
81136da0:	8804d0fa 	srli	r2,r17,3
81136da4:	00000106 	br	81136dac <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81136da8:	0005883a 	mov	r2,zero
    }
}
81136dac:	e6fffe04 	addi	sp,fp,-8
81136db0:	dfc00317 	ldw	ra,12(sp)
81136db4:	df000217 	ldw	fp,8(sp)
81136db8:	dc400117 	ldw	r17,4(sp)
81136dbc:	dc000017 	ldw	r16,0(sp)
81136dc0:	dec00404 	addi	sp,sp,16
81136dc4:	f800283a 	ret

81136dc8 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81136dc8:	deffef04 	addi	sp,sp,-68
81136dcc:	de00012e 	bgeu	sp,et,81136dd4 <alt_log_jtag_uart_print_control_reg+0xc>
81136dd0:	003b68fa 	trap	3
81136dd4:	dfc01015 	stw	ra,64(sp)
81136dd8:	df000f15 	stw	fp,60(sp)
81136ddc:	df000f04 	addi	fp,sp,60
81136de0:	e13ffd15 	stw	r4,-12(fp)
81136de4:	e17ffe15 	stw	r5,-8(fp)
81136de8:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81136dec:	e0bffe17 	ldw	r2,-8(fp)
81136df0:	10800104 	addi	r2,r2,4
81136df4:	10800037 	ldwio	r2,0(r2)
81136df8:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81136dfc:	e0bff617 	ldw	r2,-40(fp)
81136e00:	1004d43a 	srli	r2,r2,16
81136e04:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81136e08:	e0bff617 	ldw	r2,-40(fp)
81136e0c:	1080008c 	andi	r2,r2,2
81136e10:	1004d07a 	srli	r2,r2,1
81136e14:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81136e18:	e0bff617 	ldw	r2,-40(fp)
81136e1c:	1080004c 	andi	r2,r2,1
81136e20:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
81136e24:	e0bff617 	ldw	r2,-40(fp)
81136e28:	1080400c 	andi	r2,r2,256
81136e2c:	1004d23a 	srli	r2,r2,8
81136e30:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
81136e34:	e0bff617 	ldw	r2,-40(fp)
81136e38:	1080800c 	andi	r2,r2,512
81136e3c:	1004d27a 	srli	r2,r2,9
81136e40:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
81136e44:	e0bff617 	ldw	r2,-40(fp)
81136e48:	1081000c 	andi	r2,r2,1024
81136e4c:	1004d2ba 	srli	r2,r2,10
81136e50:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
81136e54:	e0bffd17 	ldw	r2,-12(fp)
81136e58:	10c01017 	ldw	r3,64(r2)
81136e5c:	e0bffd17 	ldw	r2,-12(fp)
81136e60:	10800f17 	ldw	r2,60(r2)
81136e64:	1887c83a 	sub	r3,r3,r2
81136e68:	e0bff917 	ldw	r2,-28(fp)
81136e6c:	d8800415 	stw	r2,16(sp)
81136e70:	e0bff817 	ldw	r2,-32(fp)
81136e74:	d8800315 	stw	r2,12(sp)
81136e78:	e0bffa17 	ldw	r2,-24(fp)
81136e7c:	d8800215 	stw	r2,8(sp)
81136e80:	e0bffb17 	ldw	r2,-20(fp)
81136e84:	d8800115 	stw	r2,4(sp)
81136e88:	e0bffc17 	ldw	r2,-16(fp)
81136e8c:	d8800015 	stw	r2,0(sp)
81136e90:	e1fff717 	ldw	r7,-36(fp)
81136e94:	180d883a 	mov	r6,r3
81136e98:	e17fff17 	ldw	r5,-4(fp)
81136e9c:	01204574 	movhi	r4,33045
81136ea0:	2102fe04 	addi	r4,r4,3064
81136ea4:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81136ea8:	0001883a 	nop

}
81136eac:	e037883a 	mov	sp,fp
81136eb0:	dfc00117 	ldw	ra,4(sp)
81136eb4:	df000017 	ldw	fp,0(sp)
81136eb8:	dec00204 	addi	sp,sp,8
81136ebc:	f800283a 	ret

81136ec0 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81136ec0:	defffb04 	addi	sp,sp,-20
81136ec4:	de00012e 	bgeu	sp,et,81136ecc <alt_log_jtag_uart_startup_info+0xc>
81136ec8:	003b68fa 	trap	3
81136ecc:	dfc00415 	stw	ra,16(sp)
81136ed0:	df000315 	stw	fp,12(sp)
81136ed4:	df000304 	addi	fp,sp,12
81136ed8:	e13ffe15 	stw	r4,-8(fp)
81136edc:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81136ee0:	00a04574 	movhi	r2,33045
81136ee4:	10831004 	addi	r2,r2,3136
81136ee8:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81136eec:	e1bffd17 	ldw	r6,-12(fp)
81136ef0:	e17fff17 	ldw	r5,-4(fp)
81136ef4:	e13ffe17 	ldw	r4,-8(fp)
81136ef8:	1136dc80 	call	81136dc8 <alt_log_jtag_uart_print_control_reg>
     return;
81136efc:	0001883a 	nop
}
81136f00:	e037883a 	mov	sp,fp
81136f04:	dfc00117 	ldw	ra,4(sp)
81136f08:	df000017 	ldw	fp,0(sp)
81136f0c:	dec00204 	addi	sp,sp,8
81136f10:	f800283a 	ret

81136f14 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
81136f14:	defffb04 	addi	sp,sp,-20
81136f18:	de00012e 	bgeu	sp,et,81136f20 <alt_log_jtag_uart_isr_proc+0xc>
81136f1c:	003b68fa 	trap	3
81136f20:	dfc00415 	stw	ra,16(sp)
81136f24:	df000315 	stw	fp,12(sp)
81136f28:	df000304 	addi	fp,sp,12
81136f2c:	e13ffe15 	stw	r4,-8(fp)
81136f30:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
81136f34:	d0a081c3 	ldbu	r2,-32249(gp)
81136f38:	10803fcc 	andi	r2,r2,255
81136f3c:	10000826 	beq	r2,zero,81136f60 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
81136f40:	00a04574 	movhi	r2,33045
81136f44:	10831504 	addi	r2,r2,3156
81136f48:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
81136f4c:	e1bffd17 	ldw	r6,-12(fp)
81136f50:	e17ffe17 	ldw	r5,-8(fp)
81136f54:	e13fff17 	ldw	r4,-4(fp)
81136f58:	1136dc80 	call	81136dc8 <alt_log_jtag_uart_print_control_reg>
    }
    return;
81136f5c:	0001883a 	nop
81136f60:	0001883a 	nop
}
81136f64:	e037883a 	mov	sp,fp
81136f68:	dfc00117 	ldw	ra,4(sp)
81136f6c:	df000017 	ldw	fp,0(sp)
81136f70:	dec00204 	addi	sp,sp,8
81136f74:	f800283a 	ret

81136f78 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81136f78:	defffa04 	addi	sp,sp,-24
81136f7c:	de00012e 	bgeu	sp,et,81136f84 <alt_log_write+0xc>
81136f80:	003b68fa 	trap	3
81136f84:	dfc00515 	stw	ra,20(sp)
81136f88:	df000415 	stw	fp,16(sp)
81136f8c:	df000404 	addi	fp,sp,16
81136f90:	e13ffe15 	stw	r4,-8(fp)
81136f94:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81136f98:	d0a08103 	ldbu	r2,-32252(gp)
81136f9c:	10803fcc 	andi	r2,r2,255
81136fa0:	10004026 	beq	r2,zero,811370a4 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81136fa4:	e0bfff17 	ldw	r2,-4(fp)
81136fa8:	10c00430 	cmpltui	r3,r2,16
81136fac:	1800011e 	bne	r3,zero,81136fb4 <alt_log_write+0x3c>
81136fb0:	008003c4 	movi	r2,15
81136fb4:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81136fb8:	e0bffd17 	ldw	r2,-12(fp)
81136fbc:	10800088 	cmpgei	r2,r2,2
81136fc0:	10003726 	beq	r2,zero,811370a0 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81136fc4:	e0bffd17 	ldw	r2,-12(fp)
81136fc8:	100d883a 	mov	r6,r2
81136fcc:	e17ffe17 	ldw	r5,-8(fp)
81136fd0:	012045b4 	movhi	r4,33046
81136fd4:	211af604 	addi	r4,r4,27608
81136fd8:	114af440 	call	8114af44 <strncpy>
    alt_log_write_buf[length-1]='\n';
81136fdc:	e0bffd17 	ldw	r2,-12(fp)
81136fe0:	10ffffc4 	addi	r3,r2,-1
81136fe4:	00a045b4 	movhi	r2,33046
81136fe8:	109af604 	addi	r2,r2,27608
81136fec:	10c5883a 	add	r2,r2,r3
81136ff0:	00c00284 	movi	r3,10
81136ff4:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81136ff8:	00a045b4 	movhi	r2,33046
81136ffc:	109af604 	addi	r2,r2,27608
81137000:	e0fffd17 	ldw	r3,-12(fp)
81137004:	10c5883a 	add	r2,r2,r3
81137008:	00c00344 	movi	r3,13
8113700c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
81137010:	e0bffd17 	ldw	r2,-12(fp)
81137014:	10c00044 	addi	r3,r2,1
81137018:	00a045b4 	movhi	r2,33046
8113701c:	109af604 	addi	r2,r2,27608
81137020:	10c5883a 	add	r2,r2,r3
81137024:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81137028:	e03ffc15 	stw	zero,-16(fp)
8113702c:	00001306 	br	8113707c <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
81137030:	00a045b4 	movhi	r2,33046
81137034:	109af604 	addi	r2,r2,27608
81137038:	e0fffc17 	ldw	r3,-16(fp)
8113703c:	10c5883a 	add	r2,r2,r3
81137040:	10800003 	ldbu	r2,0(r2)
81137044:	10803fcc 	andi	r2,r2,255
81137048:	1080201c 	xori	r2,r2,128
8113704c:	10bfe004 	addi	r2,r2,-128
81137050:	10800118 	cmpnei	r2,r2,4
81137054:	1000061e 	bne	r2,zero,81137070 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
81137058:	00a045b4 	movhi	r2,33046
8113705c:	109af604 	addi	r2,r2,27608
81137060:	e0fffc17 	ldw	r3,-16(fp)
81137064:	10c5883a 	add	r2,r2,r3
81137068:	00c01104 	movi	r3,68
8113706c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81137070:	e0bffc17 	ldw	r2,-16(fp)
81137074:	10800044 	addi	r2,r2,1
81137078:	e0bffc15 	stw	r2,-16(fp)
8113707c:	e0fffc17 	ldw	r3,-16(fp)
81137080:	e0bffd17 	ldw	r2,-12(fp)
81137084:	18bfea16 	blt	r3,r2,81137030 <__reset+0xfb117030>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81137088:	016045b4 	movhi	r5,33046
8113708c:	295af604 	addi	r5,r5,27608
81137090:	01204574 	movhi	r4,33045
81137094:	21031804 	addi	r4,r4,3168
81137098:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
8113709c:	00000106 	br	811370a4 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
811370a0:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
811370a4:	e037883a 	mov	sp,fp
811370a8:	dfc00117 	ldw	ra,4(sp)
811370ac:	df000017 	ldw	fp,0(sp)
811370b0:	dec00204 	addi	sp,sp,8
811370b4:	f800283a 	ret

811370b8 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
811370b8:	defffe04 	addi	sp,sp,-8
811370bc:	de00012e 	bgeu	sp,et,811370c4 <alt_log_system_clock+0xc>
811370c0:	003b68fa 	trap	3
811370c4:	dfc00115 	stw	ra,4(sp)
811370c8:	df000015 	stw	fp,0(sp)
811370cc:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
811370d0:	d0a08143 	ldbu	r2,-32251(gp)
811370d4:	10803fcc 	andi	r2,r2,255
811370d8:	10000e26 	beq	r2,zero,81137114 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
811370dc:	d0a08417 	ldw	r2,-32240(gp)
811370e0:	10800044 	addi	r2,r2,1
811370e4:	d0a08415 	stw	r2,-32240(gp)
811370e8:	d0a08817 	ldw	r2,-32224(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
811370ec:	d0e08417 	ldw	r3,-32240(gp)
811370f0:	10c0082e 	bgeu	r2,r3,81137114 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
811370f4:	d0208415 	stw	zero,-32240(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
811370f8:	d0a08317 	ldw	r2,-32244(gp)
811370fc:	10c00044 	addi	r3,r2,1
81137100:	d0e08315 	stw	r3,-32244(gp)
81137104:	100b883a 	mov	r5,r2
81137108:	01204574 	movhi	r4,33045
8113710c:	21031c04 	addi	r4,r4,3184
81137110:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
        }
    }
}
81137114:	0001883a 	nop
81137118:	e037883a 	mov	sp,fp
8113711c:	dfc00117 	ldw	ra,4(sp)
81137120:	df000017 	ldw	fp,0(sp)
81137124:	dec00204 	addi	sp,sp,8
81137128:	f800283a 	ret

8113712c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113712c:	defffe04 	addi	sp,sp,-8
81137130:	de00012e 	bgeu	sp,et,81137138 <alt_get_errno+0xc>
81137134:	003b68fa 	trap	3
81137138:	dfc00115 	stw	ra,4(sp)
8113713c:	df000015 	stw	fp,0(sp)
81137140:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137144:	d0a01017 	ldw	r2,-32704(gp)
81137148:	10000326 	beq	r2,zero,81137158 <alt_get_errno+0x2c>
8113714c:	d0a01017 	ldw	r2,-32704(gp)
81137150:	103ee83a 	callr	r2
81137154:	00000106 	br	8113715c <alt_get_errno+0x30>
81137158:	d0a07804 	addi	r2,gp,-32288
}
8113715c:	e037883a 	mov	sp,fp
81137160:	dfc00117 	ldw	ra,4(sp)
81137164:	df000017 	ldw	fp,0(sp)
81137168:	dec00204 	addi	sp,sp,8
8113716c:	f800283a 	ret

81137170 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81137170:	defff904 	addi	sp,sp,-28
81137174:	de00012e 	bgeu	sp,et,8113717c <lseek+0xc>
81137178:	003b68fa 	trap	3
8113717c:	dfc00615 	stw	ra,24(sp)
81137180:	df000515 	stw	fp,20(sp)
81137184:	df000504 	addi	fp,sp,20
81137188:	e13ffd15 	stw	r4,-12(fp)
8113718c:	e17ffe15 	stw	r5,-8(fp)
81137190:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81137194:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137198:	e0bffd17 	ldw	r2,-12(fp)
8113719c:	10000616 	blt	r2,zero,811371b8 <lseek+0x48>
811371a0:	e0bffd17 	ldw	r2,-12(fp)
811371a4:	10c00324 	muli	r3,r2,12
811371a8:	00a04574 	movhi	r2,33045
811371ac:	1086d504 	addi	r2,r2,6996
811371b0:	1885883a 	add	r2,r3,r2
811371b4:	00000106 	br	811371bc <lseek+0x4c>
811371b8:	0005883a 	mov	r2,zero
811371bc:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
811371c0:	e0bffc17 	ldw	r2,-16(fp)
811371c4:	10001026 	beq	r2,zero,81137208 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
811371c8:	e0bffc17 	ldw	r2,-16(fp)
811371cc:	10800017 	ldw	r2,0(r2)
811371d0:	10800717 	ldw	r2,28(r2)
811371d4:	10000926 	beq	r2,zero,811371fc <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
811371d8:	e0bffc17 	ldw	r2,-16(fp)
811371dc:	10800017 	ldw	r2,0(r2)
811371e0:	10800717 	ldw	r2,28(r2)
811371e4:	e1bfff17 	ldw	r6,-4(fp)
811371e8:	e17ffe17 	ldw	r5,-8(fp)
811371ec:	e13ffc17 	ldw	r4,-16(fp)
811371f0:	103ee83a 	callr	r2
811371f4:	e0bffb15 	stw	r2,-20(fp)
811371f8:	00000506 	br	81137210 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
811371fc:	00bfde84 	movi	r2,-134
81137200:	e0bffb15 	stw	r2,-20(fp)
81137204:	00000206 	br	81137210 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81137208:	00bfebc4 	movi	r2,-81
8113720c:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81137210:	e0bffb17 	ldw	r2,-20(fp)
81137214:	1000070e 	bge	r2,zero,81137234 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81137218:	113712c0 	call	8113712c <alt_get_errno>
8113721c:	1007883a 	mov	r3,r2
81137220:	e0bffb17 	ldw	r2,-20(fp)
81137224:	0085c83a 	sub	r2,zero,r2
81137228:	18800015 	stw	r2,0(r3)
    rc = -1;
8113722c:	00bfffc4 	movi	r2,-1
81137230:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
81137234:	e0bffb17 	ldw	r2,-20(fp)
}
81137238:	e037883a 	mov	sp,fp
8113723c:	dfc00117 	ldw	ra,4(sp)
81137240:	df000017 	ldw	fp,0(sp)
81137244:	dec00204 	addi	sp,sp,8
81137248:	f800283a 	ret

8113724c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
8113724c:	defff904 	addi	sp,sp,-28
81137250:	de00012e 	bgeu	sp,et,81137258 <alt_main+0xc>
81137254:	003b68fa 	trap	3
81137258:	dfc00615 	stw	ra,24(sp)
8113725c:	df000515 	stw	fp,20(sp)
81137260:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81137264:	d0a01217 	ldw	r2,-32696(gp)
81137268:	10800058 	cmpnei	r2,r2,1
8113726c:	1000031e 	bne	r2,zero,8113727c <alt_main+0x30>
81137270:	01204574 	movhi	r4,33045
81137274:	21032204 	addi	r4,r4,3208
81137278:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
8113727c:	0009883a 	mov	r4,zero
81137280:	1141da40 	call	81141da4 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81137284:	d0a01217 	ldw	r2,-32696(gp)
81137288:	10800058 	cmpnei	r2,r2,1
8113728c:	1000031e 	bne	r2,zero,8113729c <alt_main+0x50>
81137290:	01204574 	movhi	r4,33045
81137294:	21033004 	addi	r4,r4,3264
81137298:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
  ALT_OS_INIT();
8113729c:	11388380 	call	81138838 <OSInit>
811372a0:	01000044 	movi	r4,1
811372a4:	113e5540 	call	8113e554 <OSSemCreate>
811372a8:	d0a08b15 	stw	r2,-32212(gp)
811372ac:	01000044 	movi	r4,1
811372b0:	113e5540 	call	8113e554 <OSSemCreate>
811372b4:	d0a08d15 	stw	r2,-32204(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
811372b8:	d0a01217 	ldw	r2,-32696(gp)
811372bc:	10800058 	cmpnei	r2,r2,1
811372c0:	1000031e 	bne	r2,zero,811372d0 <alt_main+0x84>
811372c4:	01204574 	movhi	r4,33045
811372c8:	21033e04 	addi	r4,r4,3320
811372cc:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
811372d0:	d0a07f04 	addi	r2,gp,-32260
811372d4:	e0bffc15 	stw	r2,-16(fp)
811372d8:	00800044 	movi	r2,1
811372dc:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811372e0:	e0bffd0b 	ldhu	r2,-12(fp)
811372e4:	1009883a 	mov	r4,r2
811372e8:	113e5540 	call	8113e554 <OSSemCreate>
811372ec:	1007883a 	mov	r3,r2
811372f0:	e0bffc17 	ldw	r2,-16(fp)
811372f4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
811372f8:	d0a01217 	ldw	r2,-32696(gp)
811372fc:	10800058 	cmpnei	r2,r2,1
81137300:	1000031e 	bne	r2,zero,81137310 <alt_main+0xc4>
81137304:	01204574 	movhi	r4,33045
81137308:	21034c04 	addi	r4,r4,3376
8113730c:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
  alt_sys_init();
81137310:	1141de40 	call	81141de4 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
81137314:	d0a01217 	ldw	r2,-32696(gp)
81137318:	10800058 	cmpnei	r2,r2,1
8113731c:	1000031e 	bne	r2,zero,8113732c <alt_main+0xe0>
81137320:	01204574 	movhi	r4,33045
81137324:	21035604 	addi	r4,r4,3416
81137328:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
8113732c:	d0a01217 	ldw	r2,-32696(gp)
81137330:	10800058 	cmpnei	r2,r2,1
81137334:	1000031e 	bne	r2,zero,81137344 <alt_main+0xf8>
81137338:	01204574 	movhi	r4,33045
8113733c:	21035f04 	addi	r4,r4,3452
81137340:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
81137344:	01a04574 	movhi	r6,33045
81137348:	31836704 	addi	r6,r6,3484
8113734c:	01604574 	movhi	r5,33045
81137350:	29436c04 	addi	r5,r5,3504
81137354:	01204574 	movhi	r4,33045
81137358:	21036c04 	addi	r4,r4,3504
8113735c:	114a6d40 	call	8114a6d4 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
81137360:	d0a01217 	ldw	r2,-32696(gp)
81137364:	10800058 	cmpnei	r2,r2,1
81137368:	1000031e 	bne	r2,zero,81137378 <alt_main+0x12c>
8113736c:	01204574 	movhi	r4,33045
81137370:	21037004 	addi	r4,r4,3520
81137374:	1136cc80 	call	81136cc8 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81137378:	d0a08517 	ldw	r2,-32236(gp)
8113737c:	d0e08617 	ldw	r3,-32232(gp)
81137380:	d1208717 	ldw	r4,-32228(gp)
81137384:	200d883a 	mov	r6,r4
81137388:	180b883a 	mov	r5,r3
8113738c:	1009883a 	mov	r4,r2
81137390:	1117b440 	call	81117b44 <main>
81137394:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81137398:	01000044 	movi	r4,1
8113739c:	11361780 	call	81136178 <close>
  exit (result);
811373a0:	e13ffb17 	ldw	r4,-20(fp)
811373a4:	114ae880 	call	8114ae88 <exit>

811373a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811373a8:	defffe04 	addi	sp,sp,-8
811373ac:	de00012e 	bgeu	sp,et,811373b4 <alt_get_errno+0xc>
811373b0:	003b68fa 	trap	3
811373b4:	dfc00115 	stw	ra,4(sp)
811373b8:	df000015 	stw	fp,0(sp)
811373bc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811373c0:	d0a01017 	ldw	r2,-32704(gp)
811373c4:	10000326 	beq	r2,zero,811373d4 <alt_get_errno+0x2c>
811373c8:	d0a01017 	ldw	r2,-32704(gp)
811373cc:	103ee83a 	callr	r2
811373d0:	00000106 	br	811373d8 <alt_get_errno+0x30>
811373d4:	d0a07804 	addi	r2,gp,-32288
}
811373d8:	e037883a 	mov	sp,fp
811373dc:	dfc00117 	ldw	ra,4(sp)
811373e0:	df000017 	ldw	fp,0(sp)
811373e4:	dec00204 	addi	sp,sp,8
811373e8:	f800283a 	ret

811373ec <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
811373ec:	defffd04 	addi	sp,sp,-12
811373f0:	de00012e 	bgeu	sp,et,811373f8 <alt_file_locked+0xc>
811373f4:	003b68fa 	trap	3
811373f8:	df000215 	stw	fp,8(sp)
811373fc:	df000204 	addi	fp,sp,8
81137400:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81137404:	e0bfff17 	ldw	r2,-4(fp)
81137408:	10800217 	ldw	r2,8(r2)
8113740c:	10d00034 	orhi	r3,r2,16384
81137410:	e0bfff17 	ldw	r2,-4(fp)
81137414:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81137418:	e03ffe15 	stw	zero,-8(fp)
8113741c:	00001d06 	br	81137494 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81137420:	00a04574 	movhi	r2,33045
81137424:	1086d504 	addi	r2,r2,6996
81137428:	e0fffe17 	ldw	r3,-8(fp)
8113742c:	18c00324 	muli	r3,r3,12
81137430:	10c5883a 	add	r2,r2,r3
81137434:	10c00017 	ldw	r3,0(r2)
81137438:	e0bfff17 	ldw	r2,-4(fp)
8113743c:	10800017 	ldw	r2,0(r2)
81137440:	1880111e 	bne	r3,r2,81137488 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81137444:	00a04574 	movhi	r2,33045
81137448:	1086d504 	addi	r2,r2,6996
8113744c:	e0fffe17 	ldw	r3,-8(fp)
81137450:	18c00324 	muli	r3,r3,12
81137454:	10c5883a 	add	r2,r2,r3
81137458:	10800204 	addi	r2,r2,8
8113745c:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81137460:	1000090e 	bge	r2,zero,81137488 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81137464:	e0bffe17 	ldw	r2,-8(fp)
81137468:	10c00324 	muli	r3,r2,12
8113746c:	00a04574 	movhi	r2,33045
81137470:	1086d504 	addi	r2,r2,6996
81137474:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81137478:	e0bfff17 	ldw	r2,-4(fp)
8113747c:	18800226 	beq	r3,r2,81137488 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
81137480:	00bffcc4 	movi	r2,-13
81137484:	00000806 	br	811374a8 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81137488:	e0bffe17 	ldw	r2,-8(fp)
8113748c:	10800044 	addi	r2,r2,1
81137490:	e0bffe15 	stw	r2,-8(fp)
81137494:	d0a00f17 	ldw	r2,-32708(gp)
81137498:	1007883a 	mov	r3,r2
8113749c:	e0bffe17 	ldw	r2,-8(fp)
811374a0:	18bfdf2e 	bgeu	r3,r2,81137420 <__reset+0xfb117420>
    }
  }
  
  /* The device is not locked */
 
  return 0;
811374a4:	0005883a 	mov	r2,zero
}
811374a8:	e037883a 	mov	sp,fp
811374ac:	df000017 	ldw	fp,0(sp)
811374b0:	dec00104 	addi	sp,sp,4
811374b4:	f800283a 	ret

811374b8 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
811374b8:	defff604 	addi	sp,sp,-40
811374bc:	de00012e 	bgeu	sp,et,811374c4 <open+0xc>
811374c0:	003b68fa 	trap	3
811374c4:	dfc00915 	stw	ra,36(sp)
811374c8:	df000815 	stw	fp,32(sp)
811374cc:	df000804 	addi	fp,sp,32
811374d0:	e13ffd15 	stw	r4,-12(fp)
811374d4:	e17ffe15 	stw	r5,-8(fp)
811374d8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
811374dc:	00bfffc4 	movi	r2,-1
811374e0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
811374e4:	00bffb44 	movi	r2,-19
811374e8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
811374ec:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
811374f0:	d1600d04 	addi	r5,gp,-32716
811374f4:	e13ffd17 	ldw	r4,-12(fp)
811374f8:	114a0b40 	call	8114a0b4 <alt_find_dev>
811374fc:	e0bff815 	stw	r2,-32(fp)
81137500:	e0bff817 	ldw	r2,-32(fp)
81137504:	1000051e 	bne	r2,zero,8113751c <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
81137508:	e13ffd17 	ldw	r4,-12(fp)
8113750c:	114a14c0 	call	8114a14c <alt_find_file>
81137510:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81137514:	00800044 	movi	r2,1
81137518:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
8113751c:	e0bff817 	ldw	r2,-32(fp)
81137520:	10002926 	beq	r2,zero,811375c8 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81137524:	e13ff817 	ldw	r4,-32(fp)
81137528:	114a25c0 	call	8114a25c <alt_get_fd>
8113752c:	e0bff915 	stw	r2,-28(fp)
81137530:	e0bff917 	ldw	r2,-28(fp)
81137534:	1000030e 	bge	r2,zero,81137544 <open+0x8c>
    {
      status = index;
81137538:	e0bff917 	ldw	r2,-28(fp)
8113753c:	e0bffa15 	stw	r2,-24(fp)
81137540:	00002306 	br	811375d0 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81137544:	e0bff917 	ldw	r2,-28(fp)
81137548:	10c00324 	muli	r3,r2,12
8113754c:	00a04574 	movhi	r2,33045
81137550:	1086d504 	addi	r2,r2,6996
81137554:	1885883a 	add	r2,r3,r2
81137558:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
8113755c:	e0fffe17 	ldw	r3,-8(fp)
81137560:	00900034 	movhi	r2,16384
81137564:	10bfffc4 	addi	r2,r2,-1
81137568:	1886703a 	and	r3,r3,r2
8113756c:	e0bffc17 	ldw	r2,-16(fp)
81137570:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81137574:	e0bffb17 	ldw	r2,-20(fp)
81137578:	1000051e 	bne	r2,zero,81137590 <open+0xd8>
8113757c:	e13ffc17 	ldw	r4,-16(fp)
81137580:	11373ec0 	call	811373ec <alt_file_locked>
81137584:	e0bffa15 	stw	r2,-24(fp)
81137588:	e0bffa17 	ldw	r2,-24(fp)
8113758c:	10001016 	blt	r2,zero,811375d0 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81137590:	e0bff817 	ldw	r2,-32(fp)
81137594:	10800317 	ldw	r2,12(r2)
81137598:	10000826 	beq	r2,zero,811375bc <open+0x104>
8113759c:	e0bff817 	ldw	r2,-32(fp)
811375a0:	10800317 	ldw	r2,12(r2)
811375a4:	e1ffff17 	ldw	r7,-4(fp)
811375a8:	e1bffe17 	ldw	r6,-8(fp)
811375ac:	e17ffd17 	ldw	r5,-12(fp)
811375b0:	e13ffc17 	ldw	r4,-16(fp)
811375b4:	103ee83a 	callr	r2
811375b8:	00000106 	br	811375c0 <open+0x108>
811375bc:	0005883a 	mov	r2,zero
811375c0:	e0bffa15 	stw	r2,-24(fp)
811375c4:	00000206 	br	811375d0 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
811375c8:	00bffb44 	movi	r2,-19
811375cc:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
811375d0:	e0bffa17 	ldw	r2,-24(fp)
811375d4:	1000090e 	bge	r2,zero,811375fc <open+0x144>
  {
    alt_release_fd (index);  
811375d8:	e13ff917 	ldw	r4,-28(fp)
811375dc:	113775c0 	call	8113775c <alt_release_fd>
    ALT_ERRNO = -status;
811375e0:	11373a80 	call	811373a8 <alt_get_errno>
811375e4:	1007883a 	mov	r3,r2
811375e8:	e0bffa17 	ldw	r2,-24(fp)
811375ec:	0085c83a 	sub	r2,zero,r2
811375f0:	18800015 	stw	r2,0(r3)
    return -1;
811375f4:	00bfffc4 	movi	r2,-1
811375f8:	00000106 	br	81137600 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
811375fc:	e0bff917 	ldw	r2,-28(fp)
}
81137600:	e037883a 	mov	sp,fp
81137604:	dfc00117 	ldw	ra,4(sp)
81137608:	df000017 	ldw	fp,0(sp)
8113760c:	dec00204 	addi	sp,sp,8
81137610:	f800283a 	ret

81137614 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137614:	defffe04 	addi	sp,sp,-8
81137618:	de00012e 	bgeu	sp,et,81137620 <alt_get_errno+0xc>
8113761c:	003b68fa 	trap	3
81137620:	dfc00115 	stw	ra,4(sp)
81137624:	df000015 	stw	fp,0(sp)
81137628:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113762c:	d0a01017 	ldw	r2,-32704(gp)
81137630:	10000326 	beq	r2,zero,81137640 <alt_get_errno+0x2c>
81137634:	d0a01017 	ldw	r2,-32704(gp)
81137638:	103ee83a 	callr	r2
8113763c:	00000106 	br	81137644 <alt_get_errno+0x30>
81137640:	d0a07804 	addi	r2,gp,-32288
}
81137644:	e037883a 	mov	sp,fp
81137648:	dfc00117 	ldw	ra,4(sp)
8113764c:	df000017 	ldw	fp,0(sp)
81137650:	dec00204 	addi	sp,sp,8
81137654:	f800283a 	ret

81137658 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81137658:	defff904 	addi	sp,sp,-28
8113765c:	de00012e 	bgeu	sp,et,81137664 <read+0xc>
81137660:	003b68fa 	trap	3
81137664:	dfc00615 	stw	ra,24(sp)
81137668:	df000515 	stw	fp,20(sp)
8113766c:	df000504 	addi	fp,sp,20
81137670:	e13ffd15 	stw	r4,-12(fp)
81137674:	e17ffe15 	stw	r5,-8(fp)
81137678:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113767c:	e0bffd17 	ldw	r2,-12(fp)
81137680:	10000616 	blt	r2,zero,8113769c <read+0x44>
81137684:	e0bffd17 	ldw	r2,-12(fp)
81137688:	10c00324 	muli	r3,r2,12
8113768c:	00a04574 	movhi	r2,33045
81137690:	1086d504 	addi	r2,r2,6996
81137694:	1885883a 	add	r2,r3,r2
81137698:	00000106 	br	811376a0 <read+0x48>
8113769c:	0005883a 	mov	r2,zero
811376a0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
811376a4:	e0bffb17 	ldw	r2,-20(fp)
811376a8:	10002226 	beq	r2,zero,81137734 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811376ac:	e0bffb17 	ldw	r2,-20(fp)
811376b0:	10800217 	ldw	r2,8(r2)
811376b4:	108000cc 	andi	r2,r2,3
811376b8:	10800060 	cmpeqi	r2,r2,1
811376bc:	1000181e 	bne	r2,zero,81137720 <read+0xc8>
        (fd->dev->read))
811376c0:	e0bffb17 	ldw	r2,-20(fp)
811376c4:	10800017 	ldw	r2,0(r2)
811376c8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811376cc:	10001426 	beq	r2,zero,81137720 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
811376d0:	e0bffb17 	ldw	r2,-20(fp)
811376d4:	10800017 	ldw	r2,0(r2)
811376d8:	10800517 	ldw	r2,20(r2)
811376dc:	e0ffff17 	ldw	r3,-4(fp)
811376e0:	180d883a 	mov	r6,r3
811376e4:	e17ffe17 	ldw	r5,-8(fp)
811376e8:	e13ffb17 	ldw	r4,-20(fp)
811376ec:	103ee83a 	callr	r2
811376f0:	e0bffc15 	stw	r2,-16(fp)
811376f4:	e0bffc17 	ldw	r2,-16(fp)
811376f8:	1000070e 	bge	r2,zero,81137718 <read+0xc0>
        {
          ALT_ERRNO = -rval;
811376fc:	11376140 	call	81137614 <alt_get_errno>
81137700:	1007883a 	mov	r3,r2
81137704:	e0bffc17 	ldw	r2,-16(fp)
81137708:	0085c83a 	sub	r2,zero,r2
8113770c:	18800015 	stw	r2,0(r3)
          return -1;
81137710:	00bfffc4 	movi	r2,-1
81137714:	00000c06 	br	81137748 <read+0xf0>
        }
        return rval;
81137718:	e0bffc17 	ldw	r2,-16(fp)
8113771c:	00000a06 	br	81137748 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81137720:	11376140 	call	81137614 <alt_get_errno>
81137724:	1007883a 	mov	r3,r2
81137728:	00800344 	movi	r2,13
8113772c:	18800015 	stw	r2,0(r3)
81137730:	00000406 	br	81137744 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81137734:	11376140 	call	81137614 <alt_get_errno>
81137738:	1007883a 	mov	r3,r2
8113773c:	00801444 	movi	r2,81
81137740:	18800015 	stw	r2,0(r3)
  }
  return -1;
81137744:	00bfffc4 	movi	r2,-1
}
81137748:	e037883a 	mov	sp,fp
8113774c:	dfc00117 	ldw	ra,4(sp)
81137750:	df000017 	ldw	fp,0(sp)
81137754:	dec00204 	addi	sp,sp,8
81137758:	f800283a 	ret

8113775c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
8113775c:	defffe04 	addi	sp,sp,-8
81137760:	de00012e 	bgeu	sp,et,81137768 <alt_release_fd+0xc>
81137764:	003b68fa 	trap	3
81137768:	df000115 	stw	fp,4(sp)
8113776c:	df000104 	addi	fp,sp,4
81137770:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81137774:	e0bfff17 	ldw	r2,-4(fp)
81137778:	108000d0 	cmplti	r2,r2,3
8113777c:	10000d1e 	bne	r2,zero,811377b4 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81137780:	00a04574 	movhi	r2,33045
81137784:	1086d504 	addi	r2,r2,6996
81137788:	e0ffff17 	ldw	r3,-4(fp)
8113778c:	18c00324 	muli	r3,r3,12
81137790:	10c5883a 	add	r2,r2,r3
81137794:	10800204 	addi	r2,r2,8
81137798:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
8113779c:	00a04574 	movhi	r2,33045
811377a0:	1086d504 	addi	r2,r2,6996
811377a4:	e0ffff17 	ldw	r3,-4(fp)
811377a8:	18c00324 	muli	r3,r3,12
811377ac:	10c5883a 	add	r2,r2,r3
811377b0:	10000015 	stw	zero,0(r2)
  }
}
811377b4:	0001883a 	nop
811377b8:	e037883a 	mov	sp,fp
811377bc:	df000017 	ldw	fp,0(sp)
811377c0:	dec00104 	addi	sp,sp,4
811377c4:	f800283a 	ret

811377c8 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
811377c8:	defff604 	addi	sp,sp,-40
811377cc:	de00012e 	bgeu	sp,et,811377d4 <sbrk+0xc>
811377d0:	003b68fa 	trap	3
811377d4:	df000915 	stw	fp,36(sp)
811377d8:	df000904 	addi	fp,sp,36
811377dc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811377e0:	0005303a 	rdctl	r2,status
811377e4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811377e8:	e0fffe17 	ldw	r3,-8(fp)
811377ec:	00bfff84 	movi	r2,-2
811377f0:	1884703a 	and	r2,r3,r2
811377f4:	1001703a 	wrctl	status,r2
  
  return context;
811377f8:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
811377fc:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81137800:	d0a01317 	ldw	r2,-32692(gp)
81137804:	10c000c4 	addi	r3,r2,3
81137808:	00bfff04 	movi	r2,-4
8113780c:	1884703a 	and	r2,r3,r2
81137810:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81137814:	d0e01317 	ldw	r3,-32692(gp)
81137818:	e0bfff17 	ldw	r2,-4(fp)
8113781c:	1887883a 	add	r3,r3,r2
81137820:	00a04834 	movhi	r2,33056
81137824:	10a80004 	addi	r2,r2,-24576
81137828:	10c0062e 	bgeu	r2,r3,81137844 <sbrk+0x7c>
8113782c:	e0bff817 	ldw	r2,-32(fp)
81137830:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137834:	e0bff717 	ldw	r2,-36(fp)
81137838:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
8113783c:	00bfffc4 	movi	r2,-1
81137840:	00001c06 	br	811378b4 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81137844:	d0a01317 	ldw	r2,-32692(gp)
81137848:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
8113784c:	d0e01317 	ldw	r3,-32692(gp)
81137850:	e0bfff17 	ldw	r2,-4(fp)
81137854:	1885883a 	add	r2,r3,r2
81137858:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
8113785c:	c005883a 	mov	r2,et
81137860:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81137864:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81137868:	e0bffa17 	ldw	r2,-24(fp)
8113786c:	18800c1e 	bne	r3,r2,811378a0 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81137870:	d805883a 	mov	r2,sp
81137874:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81137878:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
8113787c:	d0e01317 	ldw	r3,-32692(gp)
81137880:	18800136 	bltu	r3,r2,81137888 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81137884:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81137888:	d0a01317 	ldw	r2,-32692(gp)
8113788c:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81137890:	e0bffc17 	ldw	r2,-16(fp)
81137894:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81137898:	e0bffc17 	ldw	r2,-16(fp)
8113789c:	1031883a 	mov	et,r2
811378a0:	e0bff817 	ldw	r2,-32(fp)
811378a4:	e0bffd15 	stw	r2,-12(fp)
811378a8:	e0bffd17 	ldw	r2,-12(fp)
811378ac:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
811378b0:	e0bffa17 	ldw	r2,-24(fp)
} 
811378b4:	e037883a 	mov	sp,fp
811378b8:	df000017 	ldw	fp,0(sp)
811378bc:	dec00104 	addi	sp,sp,4
811378c0:	f800283a 	ret

811378c4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
811378c4:	defffa04 	addi	sp,sp,-24
811378c8:	de00012e 	bgeu	sp,et,811378d0 <alt_alarm_stop+0xc>
811378cc:	003b68fa 	trap	3
811378d0:	df000515 	stw	fp,20(sp)
811378d4:	df000504 	addi	fp,sp,20
811378d8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811378dc:	0005303a 	rdctl	r2,status
811378e0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811378e4:	e0fffc17 	ldw	r3,-16(fp)
811378e8:	00bfff84 	movi	r2,-2
811378ec:	1884703a 	and	r2,r3,r2
811378f0:	1001703a 	wrctl	status,r2
  
  return context;
811378f4:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
811378f8:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
811378fc:	e0bfff17 	ldw	r2,-4(fp)
81137900:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81137904:	e0bffd17 	ldw	r2,-12(fp)
81137908:	10800017 	ldw	r2,0(r2)
8113790c:	e0fffd17 	ldw	r3,-12(fp)
81137910:	18c00117 	ldw	r3,4(r3)
81137914:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81137918:	e0bffd17 	ldw	r2,-12(fp)
8113791c:	10800117 	ldw	r2,4(r2)
81137920:	e0fffd17 	ldw	r3,-12(fp)
81137924:	18c00017 	ldw	r3,0(r3)
81137928:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
8113792c:	e0bffd17 	ldw	r2,-12(fp)
81137930:	e0fffd17 	ldw	r3,-12(fp)
81137934:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81137938:	e0bffd17 	ldw	r2,-12(fp)
8113793c:	e0fffd17 	ldw	r3,-12(fp)
81137940:	10c00015 	stw	r3,0(r2)
81137944:	e0bffb17 	ldw	r2,-20(fp)
81137948:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113794c:	e0bffe17 	ldw	r2,-8(fp)
81137950:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81137954:	0001883a 	nop
81137958:	e037883a 	mov	sp,fp
8113795c:	df000017 	ldw	fp,0(sp)
81137960:	dec00104 	addi	sp,sp,4
81137964:	f800283a 	ret

81137968 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81137968:	defffb04 	addi	sp,sp,-20
8113796c:	de00012e 	bgeu	sp,et,81137974 <alt_tick+0xc>
81137970:	003b68fa 	trap	3
81137974:	dfc00415 	stw	ra,16(sp)
81137978:	df000315 	stw	fp,12(sp)
8113797c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81137980:	d0a01417 	ldw	r2,-32688(gp)
81137984:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81137988:	d0a08917 	ldw	r2,-32220(gp)
8113798c:	10800044 	addi	r2,r2,1
81137990:	d0a08915 	stw	r2,-32220(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81137994:	00002e06 	br	81137a50 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81137998:	e0bffd17 	ldw	r2,-12(fp)
8113799c:	10800017 	ldw	r2,0(r2)
811379a0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
811379a4:	e0bffd17 	ldw	r2,-12(fp)
811379a8:	10800403 	ldbu	r2,16(r2)
811379ac:	10803fcc 	andi	r2,r2,255
811379b0:	10000426 	beq	r2,zero,811379c4 <alt_tick+0x5c>
811379b4:	d0a08917 	ldw	r2,-32220(gp)
811379b8:	1000021e 	bne	r2,zero,811379c4 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
811379bc:	e0bffd17 	ldw	r2,-12(fp)
811379c0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
811379c4:	e0bffd17 	ldw	r2,-12(fp)
811379c8:	10800217 	ldw	r2,8(r2)
811379cc:	d0e08917 	ldw	r3,-32220(gp)
811379d0:	18801d36 	bltu	r3,r2,81137a48 <alt_tick+0xe0>
811379d4:	e0bffd17 	ldw	r2,-12(fp)
811379d8:	10800403 	ldbu	r2,16(r2)
811379dc:	10803fcc 	andi	r2,r2,255
811379e0:	1000191e 	bne	r2,zero,81137a48 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
811379e4:	e0bffd17 	ldw	r2,-12(fp)
811379e8:	10800317 	ldw	r2,12(r2)
811379ec:	e0fffd17 	ldw	r3,-12(fp)
811379f0:	18c00517 	ldw	r3,20(r3)
811379f4:	1809883a 	mov	r4,r3
811379f8:	103ee83a 	callr	r2
811379fc:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81137a00:	e0bfff17 	ldw	r2,-4(fp)
81137a04:	1000031e 	bne	r2,zero,81137a14 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81137a08:	e13ffd17 	ldw	r4,-12(fp)
81137a0c:	11378c40 	call	811378c4 <alt_alarm_stop>
81137a10:	00000d06 	br	81137a48 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81137a14:	e0bffd17 	ldw	r2,-12(fp)
81137a18:	10c00217 	ldw	r3,8(r2)
81137a1c:	e0bfff17 	ldw	r2,-4(fp)
81137a20:	1887883a 	add	r3,r3,r2
81137a24:	e0bffd17 	ldw	r2,-12(fp)
81137a28:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81137a2c:	e0bffd17 	ldw	r2,-12(fp)
81137a30:	10c00217 	ldw	r3,8(r2)
81137a34:	d0a08917 	ldw	r2,-32220(gp)
81137a38:	1880032e 	bgeu	r3,r2,81137a48 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81137a3c:	e0bffd17 	ldw	r2,-12(fp)
81137a40:	00c00044 	movi	r3,1
81137a44:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81137a48:	e0bffe17 	ldw	r2,-8(fp)
81137a4c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81137a50:	e0fffd17 	ldw	r3,-12(fp)
81137a54:	d0a01404 	addi	r2,gp,-32688
81137a58:	18bfcf1e 	bne	r3,r2,81137998 <__reset+0xfb117998>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81137a5c:	1138c980 	call	81138c98 <OSTimeTick>
}
81137a60:	0001883a 	nop
81137a64:	e037883a 	mov	sp,fp
81137a68:	dfc00117 	ldw	ra,4(sp)
81137a6c:	df000017 	ldw	fp,0(sp)
81137a70:	dec00204 	addi	sp,sp,8
81137a74:	f800283a 	ret

81137a78 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81137a78:	defffb04 	addi	sp,sp,-20
81137a7c:	de00012e 	bgeu	sp,et,81137a84 <usleep+0xc>
81137a80:	003b68fa 	trap	3
81137a84:	dfc00415 	stw	ra,16(sp)
81137a88:	df000315 	stw	fp,12(sp)
81137a8c:	df000304 	addi	fp,sp,12
81137a90:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81137a94:	d0a09103 	ldbu	r2,-32188(gp)
81137a98:	10803fcc 	andi	r2,r2,255
81137a9c:	1000031e 	bne	r2,zero,81137aac <usleep+0x34>
  {
    return alt_busy_sleep (us);
81137aa0:	e13fff17 	ldw	r4,-4(fp)
81137aa4:	11360040 	call	81136004 <alt_busy_sleep>
81137aa8:	00003d06 	br	81137ba0 <usleep+0x128>
81137aac:	d0a08817 	ldw	r2,-32224(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81137ab0:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81137ab4:	e0ffff17 	ldw	r3,-4(fp)
81137ab8:	0090c734 	movhi	r2,17180
81137abc:	10b7a0c4 	addi	r2,r2,-8573
81137ac0:	1888383a 	mulxuu	r4,r3,r2
81137ac4:	1885383a 	mul	r2,r3,r2
81137ac8:	1013883a 	mov	r9,r2
81137acc:	2015883a 	mov	r10,r4
81137ad0:	5006d4ba 	srli	r3,r10,18
81137ad4:	e0bffe17 	ldw	r2,-8(fp)
81137ad8:	1893383a 	mul	r9,r3,r2
81137adc:	e0ffff17 	ldw	r3,-4(fp)
81137ae0:	0090c734 	movhi	r2,17180
81137ae4:	10b7a0c4 	addi	r2,r2,-8573
81137ae8:	1888383a 	mulxuu	r4,r3,r2
81137aec:	1885383a 	mul	r2,r3,r2
81137af0:	100f883a 	mov	r7,r2
81137af4:	2011883a 	mov	r8,r4
81137af8:	4004d4ba 	srli	r2,r8,18
81137afc:	010003f4 	movhi	r4,15
81137b00:	21109004 	addi	r4,r4,16960
81137b04:	1105383a 	mul	r2,r2,r4
81137b08:	1885c83a 	sub	r2,r3,r2
81137b0c:	e0fffe17 	ldw	r3,-8(fp)
81137b10:	10c7383a 	mul	r3,r2,r3
81137b14:	0090c734 	movhi	r2,17180
81137b18:	10b7a0c4 	addi	r2,r2,-8573
81137b1c:	1888383a 	mulxuu	r4,r3,r2
81137b20:	1885383a 	mul	r2,r3,r2
81137b24:	100b883a 	mov	r5,r2
81137b28:	200d883a 	mov	r6,r4
81137b2c:	3004d4ba 	srli	r2,r6,18
81137b30:	4885883a 	add	r2,r9,r2
81137b34:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81137b38:	00000706 	br	81137b58 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81137b3c:	013fffd4 	movui	r4,65535
81137b40:	11407080 	call	81140708 <OSTimeDly>
    ticks -= 0xffff;
81137b44:	e0fffd17 	ldw	r3,-12(fp)
81137b48:	00bffff4 	movhi	r2,65535
81137b4c:	10800044 	addi	r2,r2,1
81137b50:	1885883a 	add	r2,r3,r2
81137b54:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81137b58:	e0bffd17 	ldw	r2,-12(fp)
81137b5c:	00ffffd4 	movui	r3,65535
81137b60:	18bff636 	bltu	r3,r2,81137b3c <__reset+0xfb117b3c>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81137b64:	e0bffd17 	ldw	r2,-12(fp)
81137b68:	10bfffcc 	andi	r2,r2,65535
81137b6c:	1009883a 	mov	r4,r2
81137b70:	11407080 	call	81140708 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81137b74:	008003f4 	movhi	r2,15
81137b78:	10909004 	addi	r2,r2,16960
81137b7c:	e0fffe17 	ldw	r3,-8(fp)
81137b80:	10c7203a 	divu	r3,r2,r3
81137b84:	e0bfff17 	ldw	r2,-4(fp)
81137b88:	10c9203a 	divu	r4,r2,r3
81137b8c:	20c7383a 	mul	r3,r4,r3
81137b90:	10c5c83a 	sub	r2,r2,r3
81137b94:	1009883a 	mov	r4,r2
81137b98:	11360040 	call	81136004 <alt_busy_sleep>

  return 0;  
81137b9c:	0005883a 	mov	r2,zero
}
81137ba0:	e037883a 	mov	sp,fp
81137ba4:	dfc00117 	ldw	ra,4(sp)
81137ba8:	df000017 	ldw	fp,0(sp)
81137bac:	dec00204 	addi	sp,sp,8
81137bb0:	f800283a 	ret

81137bb4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81137bb4:	defffe04 	addi	sp,sp,-8
81137bb8:	de00012e 	bgeu	sp,et,81137bc0 <alt_get_errno+0xc>
81137bbc:	003b68fa 	trap	3
81137bc0:	dfc00115 	stw	ra,4(sp)
81137bc4:	df000015 	stw	fp,0(sp)
81137bc8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137bcc:	d0a01017 	ldw	r2,-32704(gp)
81137bd0:	10000326 	beq	r2,zero,81137be0 <alt_get_errno+0x2c>
81137bd4:	d0a01017 	ldw	r2,-32704(gp)
81137bd8:	103ee83a 	callr	r2
81137bdc:	00000106 	br	81137be4 <alt_get_errno+0x30>
81137be0:	d0a07804 	addi	r2,gp,-32288
}
81137be4:	e037883a 	mov	sp,fp
81137be8:	dfc00117 	ldw	ra,4(sp)
81137bec:	df000017 	ldw	fp,0(sp)
81137bf0:	dec00204 	addi	sp,sp,8
81137bf4:	f800283a 	ret

81137bf8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81137bf8:	defff904 	addi	sp,sp,-28
81137bfc:	de00012e 	bgeu	sp,et,81137c04 <write+0xc>
81137c00:	003b68fa 	trap	3
81137c04:	dfc00615 	stw	ra,24(sp)
81137c08:	df000515 	stw	fp,20(sp)
81137c0c:	df000504 	addi	fp,sp,20
81137c10:	e13ffd15 	stw	r4,-12(fp)
81137c14:	e17ffe15 	stw	r5,-8(fp)
81137c18:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137c1c:	e0bffd17 	ldw	r2,-12(fp)
81137c20:	10000616 	blt	r2,zero,81137c3c <write+0x44>
81137c24:	e0bffd17 	ldw	r2,-12(fp)
81137c28:	10c00324 	muli	r3,r2,12
81137c2c:	00a04574 	movhi	r2,33045
81137c30:	1086d504 	addi	r2,r2,6996
81137c34:	1885883a 	add	r2,r3,r2
81137c38:	00000106 	br	81137c40 <write+0x48>
81137c3c:	0005883a 	mov	r2,zero
81137c40:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81137c44:	e0bffb17 	ldw	r2,-20(fp)
81137c48:	10002426 	beq	r2,zero,81137cdc <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81137c4c:	e0bffb17 	ldw	r2,-20(fp)
81137c50:	10800217 	ldw	r2,8(r2)
81137c54:	108000cc 	andi	r2,r2,3
81137c58:	10001b26 	beq	r2,zero,81137cc8 <write+0xd0>
81137c5c:	e0bffb17 	ldw	r2,-20(fp)
81137c60:	10800017 	ldw	r2,0(r2)
81137c64:	10800617 	ldw	r2,24(r2)
81137c68:	10001726 	beq	r2,zero,81137cc8 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81137c6c:	e17fff17 	ldw	r5,-4(fp)
81137c70:	e13ffe17 	ldw	r4,-8(fp)
81137c74:	1136f780 	call	81136f78 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81137c78:	e0bffb17 	ldw	r2,-20(fp)
81137c7c:	10800017 	ldw	r2,0(r2)
81137c80:	10800617 	ldw	r2,24(r2)
81137c84:	e0ffff17 	ldw	r3,-4(fp)
81137c88:	180d883a 	mov	r6,r3
81137c8c:	e17ffe17 	ldw	r5,-8(fp)
81137c90:	e13ffb17 	ldw	r4,-20(fp)
81137c94:	103ee83a 	callr	r2
81137c98:	e0bffc15 	stw	r2,-16(fp)
81137c9c:	e0bffc17 	ldw	r2,-16(fp)
81137ca0:	1000070e 	bge	r2,zero,81137cc0 <write+0xc8>
      {
        ALT_ERRNO = -rval;
81137ca4:	1137bb40 	call	81137bb4 <alt_get_errno>
81137ca8:	1007883a 	mov	r3,r2
81137cac:	e0bffc17 	ldw	r2,-16(fp)
81137cb0:	0085c83a 	sub	r2,zero,r2
81137cb4:	18800015 	stw	r2,0(r3)
        return -1;
81137cb8:	00bfffc4 	movi	r2,-1
81137cbc:	00000c06 	br	81137cf0 <write+0xf8>
      }
      return rval;
81137cc0:	e0bffc17 	ldw	r2,-16(fp)
81137cc4:	00000a06 	br	81137cf0 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81137cc8:	1137bb40 	call	81137bb4 <alt_get_errno>
81137ccc:	1007883a 	mov	r3,r2
81137cd0:	00800344 	movi	r2,13
81137cd4:	18800015 	stw	r2,0(r3)
81137cd8:	00000406 	br	81137cec <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81137cdc:	1137bb40 	call	81137bb4 <alt_get_errno>
81137ce0:	1007883a 	mov	r3,r2
81137ce4:	00801444 	movi	r2,81
81137ce8:	18800015 	stw	r2,0(r3)
  }
  return -1;
81137cec:	00bfffc4 	movi	r2,-1
}
81137cf0:	e037883a 	mov	sp,fp
81137cf4:	dfc00117 	ldw	ra,4(sp)
81137cf8:	df000017 	ldw	fp,0(sp)
81137cfc:	dec00204 	addi	sp,sp,8
81137d00:	f800283a 	ret

81137d04 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81137d04:	deffde04 	addi	sp,sp,-136
81137d08:	de00012e 	bgeu	sp,et,81137d10 <__env_lock+0xc>
81137d0c:	003b68fa 	trap	3
81137d10:	dfc02115 	stw	ra,132(sp)
81137d14:	df002015 	stw	fp,128(sp)
81137d18:	df002004 	addi	fp,sp,128
81137d1c:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81137d20:	e0bfe104 	addi	r2,fp,-124
81137d24:	100b883a 	mov	r5,r2
81137d28:	01003fc4 	movi	r4,255
81137d2c:	11405640 	call	81140564 <OSTaskQuery>
81137d30:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81137d34:	e0bffe83 	ldbu	r2,-6(fp)
81137d38:	10803fcc 	andi	r2,r2,255
81137d3c:	10001e1e 	bne	r2,zero,81137db8 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81137d40:	e0bfed83 	ldbu	r2,-74(fp)
81137d44:	10803fcc 	andi	r2,r2,255
81137d48:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81137d4c:	d0a08b17 	ldw	r2,-32212(gp)
81137d50:	e0fffc04 	addi	r3,fp,-16
81137d54:	180b883a 	mov	r5,r3
81137d58:	1009883a 	mov	r4,r2
81137d5c:	113ed1c0 	call	8113ed1c <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81137d60:	e0bffe03 	ldbu	r2,-8(fp)
81137d64:	10803fcc 	andi	r2,r2,255
81137d68:	10000726 	beq	r2,zero,81137d88 <__env_lock+0x84>
81137d6c:	d0a01617 	ldw	r2,-32680(gp)
81137d70:	e0ffe017 	ldw	r3,-128(fp)
81137d74:	1880041e 	bne	r3,r2,81137d88 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81137d78:	d0a08a17 	ldw	r2,-32216(gp)
81137d7c:	10800044 	addi	r2,r2,1
81137d80:	d0a08a15 	stw	r2,-32216(gp)
81137d84:	00000a06 	br	81137db0 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81137d88:	d0a08b17 	ldw	r2,-32212(gp)
81137d8c:	e0fffe84 	addi	r3,fp,-6
81137d90:	180d883a 	mov	r6,r3
81137d94:	000b883a 	mov	r5,zero
81137d98:	1009883a 	mov	r4,r2
81137d9c:	113e87c0 	call	8113e87c <OSSemPend>
    locks  = 1;
81137da0:	00800044 	movi	r2,1
81137da4:	d0a08a15 	stw	r2,-32216(gp)
    lockid = id;
81137da8:	e0bfe017 	ldw	r2,-128(fp)
81137dac:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81137db0:	0001883a 	nop
81137db4:	00000106 	br	81137dbc <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81137db8:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81137dbc:	e037883a 	mov	sp,fp
81137dc0:	dfc00117 	ldw	ra,4(sp)
81137dc4:	df000017 	ldw	fp,0(sp)
81137dc8:	dec00204 	addi	sp,sp,8
81137dcc:	f800283a 	ret

81137dd0 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81137dd0:	defffd04 	addi	sp,sp,-12
81137dd4:	de00012e 	bgeu	sp,et,81137ddc <__env_unlock+0xc>
81137dd8:	003b68fa 	trap	3
81137ddc:	dfc00215 	stw	ra,8(sp)
81137de0:	df000115 	stw	fp,4(sp)
81137de4:	df000104 	addi	fp,sp,4
81137de8:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81137dec:	d0a08a17 	ldw	r2,-32216(gp)
81137df0:	10000b26 	beq	r2,zero,81137e20 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81137df4:	d0a08a17 	ldw	r2,-32216(gp)
81137df8:	10bfffc4 	addi	r2,r2,-1
81137dfc:	d0a08a15 	stw	r2,-32216(gp)
81137e00:	d0a08a17 	ldw	r2,-32216(gp)
81137e04:	1000071e 	bne	r2,zero,81137e24 <__env_unlock+0x54>
  {
    lockid = -1;
81137e08:	00bfffc4 	movi	r2,-1
81137e0c:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81137e10:	d0a08b17 	ldw	r2,-32212(gp)
81137e14:	1009883a 	mov	r4,r2
81137e18:	113ec040 	call	8113ec04 <OSSemPost>
81137e1c:	00000106 	br	81137e24 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81137e20:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81137e24:	e037883a 	mov	sp,fp
81137e28:	dfc00117 	ldw	ra,4(sp)
81137e2c:	df000017 	ldw	fp,0(sp)
81137e30:	dec00204 	addi	sp,sp,8
81137e34:	f800283a 	ret

81137e38 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81137e38:	deffda04 	addi	sp,sp,-152
81137e3c:	de00012e 	bgeu	sp,et,81137e44 <__malloc_lock+0xc>
81137e40:	003b68fa 	trap	3
81137e44:	dfc02515 	stw	ra,148(sp)
81137e48:	df002415 	stw	fp,144(sp)
81137e4c:	df002404 	addi	fp,sp,144
81137e50:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137e54:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81137e58:	d0a09103 	ldbu	r2,-32188(gp)
81137e5c:	10803fcc 	andi	r2,r2,255
81137e60:	10800060 	cmpeqi	r2,r2,1
81137e64:	10003626 	beq	r2,zero,81137f40 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81137e68:	e0bfe104 	addi	r2,fp,-124
81137e6c:	100b883a 	mov	r5,r2
81137e70:	01003fc4 	movi	r4,255
81137e74:	11405640 	call	81140564 <OSTaskQuery>
81137e78:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81137e7c:	e0bffe83 	ldbu	r2,-6(fp)
81137e80:	10803fcc 	andi	r2,r2,255
81137e84:	1000301e 	bne	r2,zero,81137f48 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81137e88:	e0bfed83 	ldbu	r2,-74(fp)
81137e8c:	10803fcc 	andi	r2,r2,255
81137e90:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81137e94:	d0a08d17 	ldw	r2,-32204(gp)
81137e98:	e0fffc04 	addi	r3,fp,-16
81137e9c:	180b883a 	mov	r5,r3
81137ea0:	1009883a 	mov	r4,r2
81137ea4:	113ed1c0 	call	8113ed1c <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137ea8:	0005303a 	rdctl	r2,status
81137eac:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137eb0:	e0ffe017 	ldw	r3,-128(fp)
81137eb4:	00bfff84 	movi	r2,-2
81137eb8:	1884703a 	and	r2,r3,r2
81137ebc:	1001703a 	wrctl	status,r2
  
  return context;
81137ec0:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81137ec4:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81137ec8:	e0bffc0b 	ldhu	r2,-16(fp)
81137ecc:	10bfffcc 	andi	r2,r2,65535
81137ed0:	10000b1e 	bne	r2,zero,81137f00 <__malloc_lock+0xc8>
81137ed4:	d0a01717 	ldw	r2,-32676(gp)
81137ed8:	e0ffdd17 	ldw	r3,-140(fp)
81137edc:	1880081e 	bne	r3,r2,81137f00 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81137ee0:	d0a08c17 	ldw	r2,-32208(gp)
81137ee4:	10800044 	addi	r2,r2,1
81137ee8:	d0a08c15 	stw	r2,-32208(gp)
81137eec:	e0bfdc17 	ldw	r2,-144(fp)
81137ef0:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137ef4:	e0bfde17 	ldw	r2,-136(fp)
81137ef8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81137efc:	00000e06 	br	81137f38 <__malloc_lock+0x100>
81137f00:	e0bfdc17 	ldw	r2,-144(fp)
81137f04:	e0bfdf15 	stw	r2,-132(fp)
81137f08:	e0bfdf17 	ldw	r2,-132(fp)
81137f0c:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81137f10:	d0a08d17 	ldw	r2,-32204(gp)
81137f14:	e0fffe84 	addi	r3,fp,-6
81137f18:	180d883a 	mov	r6,r3
81137f1c:	000b883a 	mov	r5,zero
81137f20:	1009883a 	mov	r4,r2
81137f24:	113e87c0 	call	8113e87c <OSSemPend>
    locks  = 1;
81137f28:	00800044 	movi	r2,1
81137f2c:	d0a08c15 	stw	r2,-32208(gp)
    lockid = id;
81137f30:	e0bfdd17 	ldw	r2,-140(fp)
81137f34:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81137f38:	0001883a 	nop
81137f3c:	00000306 	br	81137f4c <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81137f40:	0001883a 	nop
81137f44:	00000106 	br	81137f4c <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81137f48:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81137f4c:	e037883a 	mov	sp,fp
81137f50:	dfc00117 	ldw	ra,4(sp)
81137f54:	df000017 	ldw	fp,0(sp)
81137f58:	dec00204 	addi	sp,sp,8
81137f5c:	f800283a 	ret

81137f60 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
81137f60:	defff804 	addi	sp,sp,-32
81137f64:	de00012e 	bgeu	sp,et,81137f6c <__malloc_unlock+0xc>
81137f68:	003b68fa 	trap	3
81137f6c:	dfc00715 	stw	ra,28(sp)
81137f70:	df000615 	stw	fp,24(sp)
81137f74:	df000604 	addi	fp,sp,24
81137f78:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137f7c:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
81137f80:	d0a09103 	ldbu	r2,-32188(gp)
81137f84:	10803fcc 	andi	r2,r2,255
81137f88:	10800060 	cmpeqi	r2,r2,1
81137f8c:	10002326 	beq	r2,zero,8113801c <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137f90:	0005303a 	rdctl	r2,status
81137f94:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137f98:	e0fffe17 	ldw	r3,-8(fp)
81137f9c:	00bfff84 	movi	r2,-2
81137fa0:	1884703a 	and	r2,r3,r2
81137fa4:	1001703a 	wrctl	status,r2
  
  return context;
81137fa8:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81137fac:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81137fb0:	d0a08c17 	ldw	r2,-32208(gp)
81137fb4:	1000051e 	bne	r2,zero,81137fcc <__malloc_unlock+0x6c>
81137fb8:	e0bffa17 	ldw	r2,-24(fp)
81137fbc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137fc0:	e0bffb17 	ldw	r2,-20(fp)
81137fc4:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81137fc8:	00001506 	br	81138020 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81137fcc:	d0a08c17 	ldw	r2,-32208(gp)
81137fd0:	10bfffc4 	addi	r2,r2,-1
81137fd4:	d0a08c15 	stw	r2,-32208(gp)
81137fd8:	d0a08c17 	ldw	r2,-32208(gp)
81137fdc:	10000a1e 	bne	r2,zero,81138008 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81137fe0:	00bfffc4 	movi	r2,-1
81137fe4:	d0a01715 	stw	r2,-32676(gp)
81137fe8:	e0bffa17 	ldw	r2,-24(fp)
81137fec:	e0bffc15 	stw	r2,-16(fp)
81137ff0:	e0bffc17 	ldw	r2,-16(fp)
81137ff4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81137ff8:	d0a08d17 	ldw	r2,-32204(gp)
81137ffc:	1009883a 	mov	r4,r2
81138000:	113ec040 	call	8113ec04 <OSSemPost>
81138004:	00000606 	br	81138020 <__malloc_unlock+0xc0>
81138008:	e0bffa17 	ldw	r2,-24(fp)
8113800c:	e0bffd15 	stw	r2,-12(fp)
81138010:	e0bffd17 	ldw	r2,-12(fp)
81138014:	1001703a 	wrctl	status,r2
81138018:	00000106 	br	81138020 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
8113801c:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81138020:	e037883a 	mov	sp,fp
81138024:	dfc00117 	ldw	ra,4(sp)
81138028:	df000017 	ldw	fp,0(sp)
8113802c:	dec00204 	addi	sp,sp,8
81138030:	f800283a 	ret

81138034 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81138034:	defff704 	addi	sp,sp,-36
81138038:	de00012e 	bgeu	sp,et,81138040 <OSEventNameGet+0xc>
8113803c:	003b68fa 	trap	3
81138040:	dfc00815 	stw	ra,32(sp)
81138044:	df000715 	stw	fp,28(sp)
81138048:	df000704 	addi	fp,sp,28
8113804c:	e13ffd15 	stw	r4,-12(fp)
81138050:	e17ffe15 	stw	r5,-8(fp)
81138054:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138058:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113805c:	e0bfff17 	ldw	r2,-4(fp)
81138060:	1000021e 	bne	r2,zero,8113806c <OSEventNameGet+0x38>
        return (0);
81138064:	0005883a 	mov	r2,zero
81138068:	00003706 	br	81138148 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8113806c:	e0bffd17 	ldw	r2,-12(fp)
81138070:	1000051e 	bne	r2,zero,81138088 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81138074:	e0bfff17 	ldw	r2,-4(fp)
81138078:	00c00104 	movi	r3,4
8113807c:	10c00005 	stb	r3,0(r2)
        return (0);
81138080:	0005883a 	mov	r2,zero
81138084:	00003006 	br	81138148 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81138088:	e0bffe17 	ldw	r2,-8(fp)
8113808c:	1000051e 	bne	r2,zero,811380a4 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81138090:	e0bfff17 	ldw	r2,-4(fp)
81138094:	00c00304 	movi	r3,12
81138098:	10c00005 	stb	r3,0(r2)
        return (0);
8113809c:	0005883a 	mov	r2,zero
811380a0:	00002906 	br	81138148 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811380a4:	d0a0a103 	ldbu	r2,-32124(gp)
811380a8:	10803fcc 	andi	r2,r2,255
811380ac:	10000526 	beq	r2,zero,811380c4 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
811380b0:	e0bfff17 	ldw	r2,-4(fp)
811380b4:	00c00444 	movi	r3,17
811380b8:	10c00005 	stb	r3,0(r2)
        return (0);
811380bc:	0005883a 	mov	r2,zero
811380c0:	00002106 	br	81138148 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
811380c4:	e0bffd17 	ldw	r2,-12(fp)
811380c8:	10800003 	ldbu	r2,0(r2)
811380cc:	10803fcc 	andi	r2,r2,255
811380d0:	10bfffc4 	addi	r2,r2,-1
811380d4:	10800128 	cmpgeui	r2,r2,4
811380d8:	10000526 	beq	r2,zero,811380f0 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
811380dc:	e0bfff17 	ldw	r2,-4(fp)
811380e0:	00c00044 	movi	r3,1
811380e4:	10c00005 	stb	r3,0(r2)
             return (0);
811380e8:	0005883a 	mov	r2,zero
811380ec:	00001606 	br	81138148 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
811380f0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811380f4:	0005303a 	rdctl	r2,status
811380f8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811380fc:	e0fffb17 	ldw	r3,-20(fp)
81138100:	00bfff84 	movi	r2,-2
81138104:	1884703a 	and	r2,r3,r2
81138108:	1001703a 	wrctl	status,r2
  
  return context;
8113810c:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81138110:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81138114:	e0bffd17 	ldw	r2,-12(fp)
81138118:	10800444 	addi	r2,r2,17
8113811c:	100b883a 	mov	r5,r2
81138120:	e13ffe17 	ldw	r4,-8(fp)
81138124:	1139b200 	call	81139b20 <OS_StrCopy>
81138128:	e0bffa05 	stb	r2,-24(fp)
8113812c:	e0bff917 	ldw	r2,-28(fp)
81138130:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138134:	e0bffc17 	ldw	r2,-16(fp)
81138138:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113813c:	e0bfff17 	ldw	r2,-4(fp)
81138140:	10000005 	stb	zero,0(r2)
    return (len);
81138144:	e0bffa03 	ldbu	r2,-24(fp)
}
81138148:	e037883a 	mov	sp,fp
8113814c:	dfc00117 	ldw	ra,4(sp)
81138150:	df000017 	ldw	fp,0(sp)
81138154:	dec00204 	addi	sp,sp,8
81138158:	f800283a 	ret

8113815c <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8113815c:	defff604 	addi	sp,sp,-40
81138160:	de00012e 	bgeu	sp,et,81138168 <OSEventNameSet+0xc>
81138164:	003b68fa 	trap	3
81138168:	dfc00915 	stw	ra,36(sp)
8113816c:	df000815 	stw	fp,32(sp)
81138170:	df000804 	addi	fp,sp,32
81138174:	e13ffd15 	stw	r4,-12(fp)
81138178:	e17ffe15 	stw	r5,-8(fp)
8113817c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138180:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81138184:	e0bfff17 	ldw	r2,-4(fp)
81138188:	10004026 	beq	r2,zero,8113828c <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8113818c:	e0bffd17 	ldw	r2,-12(fp)
81138190:	1000041e 	bne	r2,zero,811381a4 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81138194:	e0bfff17 	ldw	r2,-4(fp)
81138198:	00c00104 	movi	r3,4
8113819c:	10c00005 	stb	r3,0(r2)
        return;
811381a0:	00003b06 	br	81138290 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811381a4:	e0bffe17 	ldw	r2,-8(fp)
811381a8:	1000041e 	bne	r2,zero,811381bc <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
811381ac:	e0bfff17 	ldw	r2,-4(fp)
811381b0:	00c00304 	movi	r3,12
811381b4:	10c00005 	stb	r3,0(r2)
        return;
811381b8:	00003506 	br	81138290 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811381bc:	d0a0a103 	ldbu	r2,-32124(gp)
811381c0:	10803fcc 	andi	r2,r2,255
811381c4:	10000426 	beq	r2,zero,811381d8 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
811381c8:	e0bfff17 	ldw	r2,-4(fp)
811381cc:	00c00484 	movi	r3,18
811381d0:	10c00005 	stb	r3,0(r2)
        return;
811381d4:	00002e06 	br	81138290 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
811381d8:	e0bffd17 	ldw	r2,-12(fp)
811381dc:	10800003 	ldbu	r2,0(r2)
811381e0:	10803fcc 	andi	r2,r2,255
811381e4:	10bfffc4 	addi	r2,r2,-1
811381e8:	10800128 	cmpgeui	r2,r2,4
811381ec:	10000426 	beq	r2,zero,81138200 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
811381f0:	e0bfff17 	ldw	r2,-4(fp)
811381f4:	00c00044 	movi	r3,1
811381f8:	10c00005 	stb	r3,0(r2)
             return;
811381fc:	00002406 	br	81138290 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81138200:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138204:	0005303a 	rdctl	r2,status
81138208:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113820c:	e0fffc17 	ldw	r3,-16(fp)
81138210:	00bfff84 	movi	r2,-2
81138214:	1884703a 	and	r2,r3,r2
81138218:	1001703a 	wrctl	status,r2
  
  return context;
8113821c:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81138220:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
81138224:	e13ffe17 	ldw	r4,-8(fp)
81138228:	1139b9c0 	call	81139b9c <OS_StrLen>
8113822c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
81138230:	e0bffa03 	ldbu	r2,-24(fp)
81138234:	10800830 	cmpltui	r2,r2,32
81138238:	1000081e 	bne	r2,zero,8113825c <OSEventNameSet+0x100>
8113823c:	e0bff817 	ldw	r2,-32(fp)
81138240:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138244:	e0bff917 	ldw	r2,-28(fp)
81138248:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
8113824c:	e0bfff17 	ldw	r2,-4(fp)
81138250:	00c002c4 	movi	r3,11
81138254:	10c00005 	stb	r3,0(r2)
        return;
81138258:	00000d06 	br	81138290 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
8113825c:	e0bffd17 	ldw	r2,-12(fp)
81138260:	10800444 	addi	r2,r2,17
81138264:	e17ffe17 	ldw	r5,-8(fp)
81138268:	1009883a 	mov	r4,r2
8113826c:	1139b200 	call	81139b20 <OS_StrCopy>
81138270:	e0bff817 	ldw	r2,-32(fp)
81138274:	e0bffb15 	stw	r2,-20(fp)
81138278:	e0bffb17 	ldw	r2,-20(fp)
8113827c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138280:	e0bfff17 	ldw	r2,-4(fp)
81138284:	10000005 	stb	zero,0(r2)
81138288:	00000106 	br	81138290 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113828c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81138290:	e037883a 	mov	sp,fp
81138294:	dfc00117 	ldw	ra,4(sp)
81138298:	df000017 	ldw	fp,0(sp)
8113829c:	dec00204 	addi	sp,sp,8
811382a0:	f800283a 	ret

811382a4 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
811382a4:	deffed04 	addi	sp,sp,-76
811382a8:	de00012e 	bgeu	sp,et,811382b0 <OSEventPendMulti+0xc>
811382ac:	003b68fa 	trap	3
811382b0:	dfc01215 	stw	ra,72(sp)
811382b4:	df001115 	stw	fp,68(sp)
811382b8:	df001104 	addi	fp,sp,68
811382bc:	e13ffc15 	stw	r4,-16(fp)
811382c0:	e17ffd15 	stw	r5,-12(fp)
811382c4:	e1bffe15 	stw	r6,-8(fp)
811382c8:	3805883a 	mov	r2,r7
811382cc:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
811382d0:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
811382d4:	e0800217 	ldw	r2,8(fp)
811382d8:	1000021e 	bne	r2,zero,811382e4 <OSEventPendMulti+0x40>
        return (0);
811382dc:	0005883a 	mov	r2,zero
811382e0:	00015006 	br	81138824 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
811382e4:	e0bffc17 	ldw	r2,-16(fp)
811382e8:	1000051e 	bne	r2,zero,81138300 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
811382ec:	e0800217 	ldw	r2,8(fp)
811382f0:	00c00104 	movi	r3,4
811382f4:	10c00005 	stb	r3,0(r2)
        return (0);
811382f8:	0005883a 	mov	r2,zero
811382fc:	00014906 	br	81138824 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81138300:	e0bffd17 	ldw	r2,-12(fp)
81138304:	1000051e 	bne	r2,zero,8113831c <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81138308:	e0800217 	ldw	r2,8(fp)
8113830c:	00c00104 	movi	r3,4
81138310:	10c00005 	stb	r3,0(r2)
        return (0);
81138314:	0005883a 	mov	r2,zero
81138318:	00014206 	br	81138824 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
8113831c:	e0bffe17 	ldw	r2,-8(fp)
81138320:	1000051e 	bne	r2,zero,81138338 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
81138324:	e0800217 	ldw	r2,8(fp)
81138328:	00c00104 	movi	r3,4
8113832c:	10c00005 	stb	r3,0(r2)
        return (0);
81138330:	0005883a 	mov	r2,zero
81138334:	00013b06 	br	81138824 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
81138338:	e0bffd17 	ldw	r2,-12(fp)
8113833c:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
81138340:	e0bffc17 	ldw	r2,-16(fp)
81138344:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81138348:	e0bfef17 	ldw	r2,-68(fp)
8113834c:	10800017 	ldw	r2,0(r2)
81138350:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
81138354:	00001506 	br	811383ac <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
81138358:	e0bff017 	ldw	r2,-64(fp)
8113835c:	10800003 	ldbu	r2,0(r2)
81138360:	10803fcc 	andi	r2,r2,255
81138364:	10c000a0 	cmpeqi	r3,r2,2
81138368:	1800071e 	bne	r3,zero,81138388 <OSEventPendMulti+0xe4>
8113836c:	108000e0 	cmpeqi	r2,r2,3
81138370:	1000071e 	bne	r2,zero,81138390 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81138374:	e0800217 	ldw	r2,8(fp)
81138378:	00c00044 	movi	r3,1
8113837c:	10c00005 	stb	r3,0(r2)
                 return (0);
81138380:	0005883a 	mov	r2,zero
81138384:	00012706 	br	81138824 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81138388:	0001883a 	nop
8113838c:	00000106 	br	81138394 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81138390:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81138394:	e0bfef17 	ldw	r2,-68(fp)
81138398:	10800104 	addi	r2,r2,4
8113839c:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
811383a0:	e0bfef17 	ldw	r2,-68(fp)
811383a4:	10800017 	ldw	r2,0(r2)
811383a8:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
811383ac:	e0bff017 	ldw	r2,-64(fp)
811383b0:	103fe91e 	bne	r2,zero,81138358 <__reset+0xfb118358>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
811383b4:	d0a0a103 	ldbu	r2,-32124(gp)
811383b8:	10803fcc 	andi	r2,r2,255
811383bc:	10000526 	beq	r2,zero,811383d4 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
811383c0:	e0800217 	ldw	r2,8(fp)
811383c4:	00c00084 	movi	r3,2
811383c8:	10c00005 	stb	r3,0(r2)
        return (0);
811383cc:	0005883a 	mov	r2,zero
811383d0:	00011406 	br	81138824 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
811383d4:	d0a08f03 	ldbu	r2,-32196(gp)
811383d8:	10803fcc 	andi	r2,r2,255
811383dc:	10000526 	beq	r2,zero,811383f4 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
811383e0:	e0800217 	ldw	r2,8(fp)
811383e4:	00c00344 	movi	r3,13
811383e8:	10c00005 	stb	r3,0(r2)
        return (0);
811383ec:	0005883a 	mov	r2,zero
811383f0:	00010c06 	br	81138824 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811383f4:	0005303a 	rdctl	r2,status
811383f8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811383fc:	e0fffb17 	ldw	r3,-20(fp)
81138400:	00bfff84 	movi	r2,-2
81138404:	1884703a 	and	r2,r3,r2
81138408:	1001703a 	wrctl	status,r2
  
  return context;
8113840c:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81138410:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
81138414:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81138418:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
8113841c:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81138420:	e0bffc17 	ldw	r2,-16(fp)
81138424:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
81138428:	e0bfef17 	ldw	r2,-68(fp)
8113842c:	10800017 	ldw	r2,0(r2)
81138430:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81138434:	00006406 	br	811385c8 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
81138438:	e0bff017 	ldw	r2,-64(fp)
8113843c:	10800003 	ldbu	r2,0(r2)
81138440:	10803fcc 	andi	r2,r2,255
81138444:	10c000a0 	cmpeqi	r3,r2,2
81138448:	18001f1e 	bne	r3,zero,811384c8 <OSEventPendMulti+0x224>
8113844c:	108000e0 	cmpeqi	r2,r2,3
81138450:	10004c26 	beq	r2,zero,81138584 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
81138454:	e0bff017 	ldw	r2,-64(fp)
81138458:	1080020b 	ldhu	r2,8(r2)
8113845c:	10bfffcc 	andi	r2,r2,65535
81138460:	10001526 	beq	r2,zero,811384b8 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81138464:	e0bff017 	ldw	r2,-64(fp)
81138468:	1080020b 	ldhu	r2,8(r2)
8113846c:	10bfffc4 	addi	r2,r2,-1
81138470:	1007883a 	mov	r3,r2
81138474:	e0bff017 	ldw	r2,-64(fp)
81138478:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
8113847c:	e0bffd17 	ldw	r2,-12(fp)
81138480:	10c00104 	addi	r3,r2,4
81138484:	e0fffd15 	stw	r3,-12(fp)
81138488:	e0fff017 	ldw	r3,-64(fp)
8113848c:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
81138490:	00800044 	movi	r2,1
81138494:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81138498:	e0bffe17 	ldw	r2,-8(fp)
8113849c:	10c00104 	addi	r3,r2,4
811384a0:	e0fffe15 	stw	r3,-8(fp)
811384a4:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
811384a8:	e0bff18b 	ldhu	r2,-58(fp)
811384ac:	10800044 	addi	r2,r2,1
811384b0:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
811384b4:	00003e06 	br	811385b0 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
811384b8:	e0bff203 	ldbu	r2,-56(fp)
811384bc:	10800054 	ori	r2,r2,1
811384c0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811384c4:	00003a06 	br	811385b0 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
811384c8:	e0bff017 	ldw	r2,-64(fp)
811384cc:	10800117 	ldw	r2,4(r2)
811384d0:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
811384d4:	e0bff517 	ldw	r2,-44(fp)
811384d8:	1080058b 	ldhu	r2,22(r2)
811384dc:	10bfffcc 	andi	r2,r2,65535
811384e0:	10002426 	beq	r2,zero,81138574 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
811384e4:	e0bffe17 	ldw	r2,-8(fp)
811384e8:	10c00104 	addi	r3,r2,4
811384ec:	e0fffe15 	stw	r3,-8(fp)
811384f0:	e0fff517 	ldw	r3,-44(fp)
811384f4:	18c00417 	ldw	r3,16(r3)
811384f8:	19400104 	addi	r5,r3,4
811384fc:	e13ff517 	ldw	r4,-44(fp)
81138500:	21400415 	stw	r5,16(r4)
81138504:	18c00017 	ldw	r3,0(r3)
81138508:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
8113850c:	e0bff517 	ldw	r2,-44(fp)
81138510:	10c00417 	ldw	r3,16(r2)
81138514:	e0bff517 	ldw	r2,-44(fp)
81138518:	10800217 	ldw	r2,8(r2)
8113851c:	1880041e 	bne	r3,r2,81138530 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81138520:	e0bff517 	ldw	r2,-44(fp)
81138524:	10c00117 	ldw	r3,4(r2)
81138528:	e0bff517 	ldw	r2,-44(fp)
8113852c:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
81138530:	e0bff517 	ldw	r2,-44(fp)
81138534:	1080058b 	ldhu	r2,22(r2)
81138538:	10bfffc4 	addi	r2,r2,-1
8113853c:	1007883a 	mov	r3,r2
81138540:	e0bff517 	ldw	r2,-44(fp)
81138544:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81138548:	e0bffd17 	ldw	r2,-12(fp)
8113854c:	10c00104 	addi	r3,r2,4
81138550:	e0fffd15 	stw	r3,-12(fp)
81138554:	e0fff017 	ldw	r3,-64(fp)
81138558:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
8113855c:	00800044 	movi	r2,1
81138560:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81138564:	e0bff18b 	ldhu	r2,-58(fp)
81138568:	10800044 	addi	r2,r2,1
8113856c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
81138570:	00000f06 	br	811385b0 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81138574:	e0bff203 	ldbu	r2,-56(fp)
81138578:	10800114 	ori	r2,r2,4
8113857c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81138580:	00000b06 	br	811385b0 <OSEventPendMulti+0x30c>
81138584:	e0bff317 	ldw	r2,-52(fp)
81138588:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113858c:	e0bff417 	ldw	r2,-48(fp)
81138590:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81138594:	e0bffd17 	ldw	r2,-12(fp)
81138598:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
8113859c:	e0800217 	ldw	r2,8(fp)
811385a0:	00c00044 	movi	r3,1
811385a4:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
811385a8:	e0bff18b 	ldhu	r2,-58(fp)
811385ac:	00009d06 	br	81138824 <OSEventPendMulti+0x580>
        }
        pevents++;
811385b0:	e0bfef17 	ldw	r2,-68(fp)
811385b4:	10800104 	addi	r2,r2,4
811385b8:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
811385bc:	e0bfef17 	ldw	r2,-68(fp)
811385c0:	10800017 	ldw	r2,0(r2)
811385c4:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811385c8:	e0bff017 	ldw	r2,-64(fp)
811385cc:	103f9a1e 	bne	r2,zero,81138438 <__reset+0xfb118438>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
811385d0:	e0bff103 	ldbu	r2,-60(fp)
811385d4:	10800058 	cmpnei	r2,r2,1
811385d8:	10000a1e 	bne	r2,zero,81138604 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
811385dc:	e0bffd17 	ldw	r2,-12(fp)
811385e0:	10000015 	stw	zero,0(r2)
811385e4:	e0bff317 	ldw	r2,-52(fp)
811385e8:	e0bff615 	stw	r2,-40(fp)
811385ec:	e0bff617 	ldw	r2,-40(fp)
811385f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
811385f4:	e0800217 	ldw	r2,8(fp)
811385f8:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
811385fc:	e0bff18b 	ldhu	r2,-58(fp)
81138600:	00008806 	br	81138824 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81138604:	d0a0a217 	ldw	r2,-32120(gp)
81138608:	d0e0a217 	ldw	r3,-32120(gp)
8113860c:	19000c03 	ldbu	r4,48(r3)
81138610:	e0fff203 	ldbu	r3,-56(fp)
81138614:	20c6b03a 	or	r3,r4,r3
81138618:	1809883a 	mov	r4,r3
8113861c:	00ffe004 	movi	r3,-128
81138620:	20c6b03a 	or	r3,r4,r3
81138624:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81138628:	d0a0a217 	ldw	r2,-32120(gp)
8113862c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
81138630:	d0a0a217 	ldw	r2,-32120(gp)
81138634:	e0ffff0b 	ldhu	r3,-4(fp)
81138638:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
8113863c:	e13ffc17 	ldw	r4,-16(fp)
81138640:	11391c80 	call	811391c8 <OS_EventTaskWaitMulti>
81138644:	e0bff317 	ldw	r2,-52(fp)
81138648:	e0bff915 	stw	r2,-28(fp)
8113864c:	e0bff917 	ldw	r2,-28(fp)
81138650:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81138654:	11399cc0 	call	811399cc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138658:	0005303a 	rdctl	r2,status
8113865c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138660:	e0fff717 	ldw	r3,-36(fp)
81138664:	00bfff84 	movi	r2,-2
81138668:	1884703a 	and	r2,r3,r2
8113866c:	1001703a 	wrctl	status,r2
  
  return context;
81138670:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81138674:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81138678:	d0a0a217 	ldw	r2,-32120(gp)
8113867c:	10800c43 	ldbu	r2,49(r2)
81138680:	10803fcc 	andi	r2,r2,255
81138684:	10000226 	beq	r2,zero,81138690 <OSEventPendMulti+0x3ec>
81138688:	108000a0 	cmpeqi	r2,r2,2
8113868c:	10001826 	beq	r2,zero,811386f0 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
81138690:	d0a0a217 	ldw	r2,-32120(gp)
81138694:	10800717 	ldw	r2,28(r2)
81138698:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
8113869c:	e0bff017 	ldw	r2,-64(fp)
811386a0:	10000b26 	beq	r2,zero,811386d0 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
811386a4:	e0bffd17 	ldw	r2,-12(fp)
811386a8:	10c00104 	addi	r3,r2,4
811386ac:	e0fffd15 	stw	r3,-12(fp)
811386b0:	e0fff017 	ldw	r3,-64(fp)
811386b4:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
811386b8:	e0bffd17 	ldw	r2,-12(fp)
811386bc:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
811386c0:	e0bff18b 	ldhu	r2,-58(fp)
811386c4:	10800044 	addi	r2,r2,1
811386c8:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
811386cc:	00000d06 	br	81138704 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
811386d0:	d0a0a217 	ldw	r2,-32120(gp)
811386d4:	00c00044 	movi	r3,1
811386d8:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811386dc:	d0a0a217 	ldw	r2,-32120(gp)
811386e0:	e17ffc17 	ldw	r5,-16(fp)
811386e4:	1009883a 	mov	r4,r2
811386e8:	11393e00 	call	811393e0 <OS_EventTaskRemoveMulti>
             }
			 break;
811386ec:	00000506 	br	81138704 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811386f0:	d0a0a217 	ldw	r2,-32120(gp)
811386f4:	e17ffc17 	ldw	r5,-16(fp)
811386f8:	1009883a 	mov	r4,r2
811386fc:	11393e00 	call	811393e0 <OS_EventTaskRemoveMulti>
             break;
81138700:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81138704:	d0a0a217 	ldw	r2,-32120(gp)
81138708:	10800c43 	ldbu	r2,49(r2)
8113870c:	10803fcc 	andi	r2,r2,255
81138710:	10000326 	beq	r2,zero,81138720 <OSEventPendMulti+0x47c>
81138714:	108000a0 	cmpeqi	r2,r2,2
81138718:	1000231e 	bne	r2,zero,811387a8 <OSEventPendMulti+0x504>
8113871c:	00002a06 	br	811387c8 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81138720:	e0bff017 	ldw	r2,-64(fp)
81138724:	10800003 	ldbu	r2,0(r2)
81138728:	10803fcc 	andi	r2,r2,255
8113872c:	0080100e 	bge	zero,r2,81138770 <OSEventPendMulti+0x4cc>
81138730:	10c000d0 	cmplti	r3,r2,3
81138734:	1800071e 	bne	r3,zero,81138754 <OSEventPendMulti+0x4b0>
81138738:	108000e0 	cmpeqi	r2,r2,3
8113873c:	10000c26 	beq	r2,zero,81138770 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
81138740:	e0bffe17 	ldw	r2,-8(fp)
81138744:	10c00104 	addi	r3,r2,4
81138748:	e0fffe15 	stw	r3,-8(fp)
8113874c:	10000015 	stw	zero,0(r2)
                      break;
81138750:	00001206 	br	8113879c <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81138754:	e0bffe17 	ldw	r2,-8(fp)
81138758:	10c00104 	addi	r3,r2,4
8113875c:	e0fffe15 	stw	r3,-8(fp)
81138760:	d0e0a217 	ldw	r3,-32120(gp)
81138764:	18c00917 	ldw	r3,36(r3)
81138768:	10c00015 	stw	r3,0(r2)
                      break;
8113876c:	00000b06 	br	8113879c <OSEventPendMulti+0x4f8>
81138770:	e0bff317 	ldw	r2,-52(fp)
81138774:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138778:	e0bff817 	ldw	r2,-32(fp)
8113877c:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81138780:	e0bffd17 	ldw	r2,-12(fp)
81138784:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81138788:	e0800217 	ldw	r2,8(fp)
8113878c:	00c00044 	movi	r3,1
81138790:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81138794:	e0bff18b 	ldhu	r2,-58(fp)
81138798:	00002206 	br	81138824 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
8113879c:	e0800217 	ldw	r2,8(fp)
811387a0:	10000005 	stb	zero,0(r2)
             break;
811387a4:	00001006 	br	811387e8 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
811387a8:	e0bffe17 	ldw	r2,-8(fp)
811387ac:	10c00104 	addi	r3,r2,4
811387b0:	e0fffe15 	stw	r3,-8(fp)
811387b4:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
811387b8:	e0800217 	ldw	r2,8(fp)
811387bc:	00c00384 	movi	r3,14
811387c0:	10c00005 	stb	r3,0(r2)
             break;
811387c4:	00000806 	br	811387e8 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
811387c8:	e0bffe17 	ldw	r2,-8(fp)
811387cc:	10c00104 	addi	r3,r2,4
811387d0:	e0fffe15 	stw	r3,-8(fp)
811387d4:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
811387d8:	e0800217 	ldw	r2,8(fp)
811387dc:	00c00284 	movi	r3,10
811387e0:	10c00005 	stb	r3,0(r2)
             break;
811387e4:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
811387e8:	d0a0a217 	ldw	r2,-32120(gp)
811387ec:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
811387f0:	d0a0a217 	ldw	r2,-32120(gp)
811387f4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
811387f8:	d0a0a217 	ldw	r2,-32120(gp)
811387fc:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81138800:	d0a0a217 	ldw	r2,-32120(gp)
81138804:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81138808:	d0a0a217 	ldw	r2,-32120(gp)
8113880c:	10000915 	stw	zero,36(r2)
81138810:	e0bff317 	ldw	r2,-52(fp)
81138814:	e0bffa15 	stw	r2,-24(fp)
81138818:	e0bffa17 	ldw	r2,-24(fp)
8113881c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81138820:	e0bff18b 	ldhu	r2,-58(fp)
}
81138824:	e037883a 	mov	sp,fp
81138828:	dfc00117 	ldw	ra,4(sp)
8113882c:	df000017 	ldw	fp,0(sp)
81138830:	dec00204 	addi	sp,sp,8
81138834:	f800283a 	ret

81138838 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81138838:	defffe04 	addi	sp,sp,-8
8113883c:	de00012e 	bgeu	sp,et,81138844 <OSInit+0xc>
81138840:	003b68fa 	trap	3
81138844:	dfc00115 	stw	ra,4(sp)
81138848:	df000015 	stw	fp,0(sp)
8113884c:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81138850:	114ad3c0 	call	8114ad3c <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81138854:	11396400 	call	81139640 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81138858:	11396900 	call	81139690 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
8113885c:	11398140 	call	81139814 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81138860:	11395580 	call	81139558 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81138864:	113b7d40 	call	8113b7d4 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81138868:	113c11c0 	call	8113c11c <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
8113886c:	113e3ec0 	call	8113e3ec <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81138870:	11397040 	call	81139704 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81138874:	113978c0 	call	8113978c <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81138878:	11417900 	call	81141790 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
8113887c:	114ad680 	call	8114ad68 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81138880:	113a0f00 	call	8113a0f0 <OSDebugInit>
#endif
}
81138884:	0001883a 	nop
81138888:	e037883a 	mov	sp,fp
8113888c:	dfc00117 	ldw	ra,4(sp)
81138890:	df000017 	ldw	fp,0(sp)
81138894:	dec00204 	addi	sp,sp,8
81138898:	f800283a 	ret

8113889c <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
8113889c:	deffff04 	addi	sp,sp,-4
811388a0:	de00012e 	bgeu	sp,et,811388a8 <OSIntEnter+0xc>
811388a4:	003b68fa 	trap	3
811388a8:	df000015 	stw	fp,0(sp)
811388ac:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
811388b0:	d0a09103 	ldbu	r2,-32188(gp)
811388b4:	10803fcc 	andi	r2,r2,255
811388b8:	10800058 	cmpnei	r2,r2,1
811388bc:	1000071e 	bne	r2,zero,811388dc <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
811388c0:	d0a0a103 	ldbu	r2,-32124(gp)
811388c4:	10803fcc 	andi	r2,r2,255
811388c8:	10803fe0 	cmpeqi	r2,r2,255
811388cc:	1000031e 	bne	r2,zero,811388dc <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
811388d0:	d0a0a103 	ldbu	r2,-32124(gp)
811388d4:	10800044 	addi	r2,r2,1
811388d8:	d0a0a105 	stb	r2,-32124(gp)
        }
    }
}
811388dc:	0001883a 	nop
811388e0:	e037883a 	mov	sp,fp
811388e4:	df000017 	ldw	fp,0(sp)
811388e8:	dec00104 	addi	sp,sp,4
811388ec:	f800283a 	ret

811388f0 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
811388f0:	defffb04 	addi	sp,sp,-20
811388f4:	de00012e 	bgeu	sp,et,811388fc <OSIntExit+0xc>
811388f8:	003b68fa 	trap	3
811388fc:	dfc00415 	stw	ra,16(sp)
81138900:	df000315 	stw	fp,12(sp)
81138904:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138908:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
8113890c:	d0a09103 	ldbu	r2,-32188(gp)
81138910:	10803fcc 	andi	r2,r2,255
81138914:	10800058 	cmpnei	r2,r2,1
81138918:	10002f1e 	bne	r2,zero,811389d8 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113891c:	0005303a 	rdctl	r2,status
81138920:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138924:	e0ffff17 	ldw	r3,-4(fp)
81138928:	00bfff84 	movi	r2,-2
8113892c:	1884703a 	and	r2,r3,r2
81138930:	1001703a 	wrctl	status,r2
  
  return context;
81138934:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81138938:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
8113893c:	d0a0a103 	ldbu	r2,-32124(gp)
81138940:	10803fcc 	andi	r2,r2,255
81138944:	10000326 	beq	r2,zero,81138954 <OSIntExit+0x64>
            OSIntNesting--;
81138948:	d0a0a103 	ldbu	r2,-32124(gp)
8113894c:	10bfffc4 	addi	r2,r2,-1
81138950:	d0a0a105 	stb	r2,-32124(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81138954:	d0a0a103 	ldbu	r2,-32124(gp)
81138958:	10803fcc 	andi	r2,r2,255
8113895c:	10001a1e 	bne	r2,zero,811389c8 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81138960:	d0a08f03 	ldbu	r2,-32196(gp)
81138964:	10803fcc 	andi	r2,r2,255
81138968:	1000171e 	bne	r2,zero,811389c8 <OSIntExit+0xd8>
                OS_SchedNew();
8113896c:	1139aa40 	call	81139aa4 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81138970:	d0e09383 	ldbu	r3,-32178(gp)
81138974:	d0a093c3 	ldbu	r2,-32177(gp)
81138978:	18c03fcc 	andi	r3,r3,255
8113897c:	10803fcc 	andi	r2,r2,255
81138980:	18801126 	beq	r3,r2,811389c8 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81138984:	d0a09383 	ldbu	r2,-32178(gp)
81138988:	10c03fcc 	andi	r3,r2,255
8113898c:	00a045f4 	movhi	r2,33047
81138990:	10b2f704 	addi	r2,r2,-13348
81138994:	18c7883a 	add	r3,r3,r3
81138998:	18c7883a 	add	r3,r3,r3
8113899c:	10c5883a 	add	r2,r2,r3
811389a0:	10800017 	ldw	r2,0(r2)
811389a4:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
811389a8:	d0a09c17 	ldw	r2,-32144(gp)
811389ac:	10c00e17 	ldw	r3,56(r2)
811389b0:	18c00044 	addi	r3,r3,1
811389b4:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
811389b8:	d0a09617 	ldw	r2,-32168(gp)
811389bc:	10800044 	addi	r2,r2,1
811389c0:	d0a09615 	stw	r2,-32168(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
811389c4:	114a9fc0 	call	8114a9fc <OSCtxSw>
811389c8:	e0bffd17 	ldw	r2,-12(fp)
811389cc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811389d0:	e0bffe17 	ldw	r2,-8(fp)
811389d4:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
811389d8:	0001883a 	nop
811389dc:	e037883a 	mov	sp,fp
811389e0:	dfc00117 	ldw	ra,4(sp)
811389e4:	df000017 	ldw	fp,0(sp)
811389e8:	dec00204 	addi	sp,sp,8
811389ec:	f800283a 	ret

811389f0 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
811389f0:	defffc04 	addi	sp,sp,-16
811389f4:	de00012e 	bgeu	sp,et,811389fc <OSSchedLock+0xc>
811389f8:	003b68fa 	trap	3
811389fc:	df000315 	stw	fp,12(sp)
81138a00:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138a04:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81138a08:	d0a09103 	ldbu	r2,-32188(gp)
81138a0c:	10803fcc 	andi	r2,r2,255
81138a10:	10800058 	cmpnei	r2,r2,1
81138a14:	1000161e 	bne	r2,zero,81138a70 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138a18:	0005303a 	rdctl	r2,status
81138a1c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138a20:	e0ffff17 	ldw	r3,-4(fp)
81138a24:	00bfff84 	movi	r2,-2
81138a28:	1884703a 	and	r2,r3,r2
81138a2c:	1001703a 	wrctl	status,r2
  
  return context;
81138a30:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81138a34:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81138a38:	d0a0a103 	ldbu	r2,-32124(gp)
81138a3c:	10803fcc 	andi	r2,r2,255
81138a40:	1000071e 	bne	r2,zero,81138a60 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81138a44:	d0a08f03 	ldbu	r2,-32196(gp)
81138a48:	10803fcc 	andi	r2,r2,255
81138a4c:	10803fe0 	cmpeqi	r2,r2,255
81138a50:	1000031e 	bne	r2,zero,81138a60 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81138a54:	d0a08f03 	ldbu	r2,-32196(gp)
81138a58:	10800044 	addi	r2,r2,1
81138a5c:	d0a08f05 	stb	r2,-32196(gp)
81138a60:	e0bffd17 	ldw	r2,-12(fp)
81138a64:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138a68:	e0bffe17 	ldw	r2,-8(fp)
81138a6c:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81138a70:	0001883a 	nop
81138a74:	e037883a 	mov	sp,fp
81138a78:	df000017 	ldw	fp,0(sp)
81138a7c:	dec00104 	addi	sp,sp,4
81138a80:	f800283a 	ret

81138a84 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81138a84:	defff804 	addi	sp,sp,-32
81138a88:	de00012e 	bgeu	sp,et,81138a90 <OSSchedUnlock+0xc>
81138a8c:	003b68fa 	trap	3
81138a90:	dfc00715 	stw	ra,28(sp)
81138a94:	df000615 	stw	fp,24(sp)
81138a98:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138a9c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81138aa0:	d0a09103 	ldbu	r2,-32188(gp)
81138aa4:	10803fcc 	andi	r2,r2,255
81138aa8:	10800058 	cmpnei	r2,r2,1
81138aac:	1000281e 	bne	r2,zero,81138b50 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138ab0:	0005303a 	rdctl	r2,status
81138ab4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138ab8:	e0ffff17 	ldw	r3,-4(fp)
81138abc:	00bfff84 	movi	r2,-2
81138ac0:	1884703a 	and	r2,r3,r2
81138ac4:	1001703a 	wrctl	status,r2
  
  return context;
81138ac8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81138acc:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81138ad0:	d0a08f03 	ldbu	r2,-32196(gp)
81138ad4:	10803fcc 	andi	r2,r2,255
81138ad8:	10001926 	beq	r2,zero,81138b40 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81138adc:	d0a08f03 	ldbu	r2,-32196(gp)
81138ae0:	10bfffc4 	addi	r2,r2,-1
81138ae4:	d0a08f05 	stb	r2,-32196(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81138ae8:	d0a08f03 	ldbu	r2,-32196(gp)
81138aec:	10803fcc 	andi	r2,r2,255
81138af0:	10000e1e 	bne	r2,zero,81138b2c <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81138af4:	d0a0a103 	ldbu	r2,-32124(gp)
81138af8:	10803fcc 	andi	r2,r2,255
81138afc:	1000061e 	bne	r2,zero,81138b18 <OSSchedUnlock+0x94>
81138b00:	e0bffa17 	ldw	r2,-24(fp)
81138b04:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138b08:	e0bffb17 	ldw	r2,-20(fp)
81138b0c:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81138b10:	11399cc0 	call	811399cc <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81138b14:	00000e06 	br	81138b50 <OSSchedUnlock+0xcc>
81138b18:	e0bffa17 	ldw	r2,-24(fp)
81138b1c:	e0bffc15 	stw	r2,-16(fp)
81138b20:	e0bffc17 	ldw	r2,-16(fp)
81138b24:	1001703a 	wrctl	status,r2
81138b28:	00000906 	br	81138b50 <OSSchedUnlock+0xcc>
81138b2c:	e0bffa17 	ldw	r2,-24(fp)
81138b30:	e0bffd15 	stw	r2,-12(fp)
81138b34:	e0bffd17 	ldw	r2,-12(fp)
81138b38:	1001703a 	wrctl	status,r2
81138b3c:	00000406 	br	81138b50 <OSSchedUnlock+0xcc>
81138b40:	e0bffa17 	ldw	r2,-24(fp)
81138b44:	e0bffe15 	stw	r2,-8(fp)
81138b48:	e0bffe17 	ldw	r2,-8(fp)
81138b4c:	1001703a 	wrctl	status,r2
81138b50:	0001883a 	nop
81138b54:	e037883a 	mov	sp,fp
81138b58:	dfc00117 	ldw	ra,4(sp)
81138b5c:	df000017 	ldw	fp,0(sp)
81138b60:	dec00204 	addi	sp,sp,8
81138b64:	f800283a 	ret

81138b68 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81138b68:	defffe04 	addi	sp,sp,-8
81138b6c:	de00012e 	bgeu	sp,et,81138b74 <OSStart+0xc>
81138b70:	003b68fa 	trap	3
81138b74:	dfc00115 	stw	ra,4(sp)
81138b78:	df000015 	stw	fp,0(sp)
81138b7c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81138b80:	d0a09103 	ldbu	r2,-32188(gp)
81138b84:	10803fcc 	andi	r2,r2,255
81138b88:	10000f1e 	bne	r2,zero,81138bc8 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81138b8c:	1139aa40 	call	81139aa4 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81138b90:	d0a09383 	ldbu	r2,-32178(gp)
81138b94:	d0a093c5 	stb	r2,-32177(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81138b98:	d0a09383 	ldbu	r2,-32178(gp)
81138b9c:	10c03fcc 	andi	r3,r2,255
81138ba0:	00a045f4 	movhi	r2,33047
81138ba4:	10b2f704 	addi	r2,r2,-13348
81138ba8:	18c7883a 	add	r3,r3,r3
81138bac:	18c7883a 	add	r3,r3,r3
81138bb0:	10c5883a 	add	r2,r2,r3
81138bb4:	10800017 	ldw	r2,0(r2)
81138bb8:	d0a09c15 	stw	r2,-32144(gp)
        OSTCBCur      = OSTCBHighRdy;
81138bbc:	d0a09c17 	ldw	r2,-32144(gp)
81138bc0:	d0a0a215 	stw	r2,-32120(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81138bc4:	114aa980 	call	8114aa98 <OSStartHighRdy>
    }
}
81138bc8:	0001883a 	nop
81138bcc:	e037883a 	mov	sp,fp
81138bd0:	dfc00117 	ldw	ra,4(sp)
81138bd4:	df000017 	ldw	fp,0(sp)
81138bd8:	dec00204 	addi	sp,sp,8
81138bdc:	f800283a 	ret

81138be0 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81138be0:	defff904 	addi	sp,sp,-28
81138be4:	de00012e 	bgeu	sp,et,81138bec <OSStatInit+0xc>
81138be8:	003b68fa 	trap	3
81138bec:	dfc00615 	stw	ra,24(sp)
81138bf0:	df000515 	stw	fp,20(sp)
81138bf4:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138bf8:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81138bfc:	01000084 	movi	r4,2
81138c00:	11407080 	call	81140708 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138c04:	0005303a 	rdctl	r2,status
81138c08:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138c0c:	e0fffc17 	ldw	r3,-16(fp)
81138c10:	00bfff84 	movi	r2,-2
81138c14:	1884703a 	and	r2,r3,r2
81138c18:	1001703a 	wrctl	status,r2
  
  return context;
81138c1c:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81138c20:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81138c24:	d0209215 	stw	zero,-32184(gp)
81138c28:	e0bffb17 	ldw	r2,-20(fp)
81138c2c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c30:	e0bffd17 	ldw	r2,-12(fp)
81138c34:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81138c38:	01001904 	movi	r4,100
81138c3c:	11407080 	call	81140708 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138c40:	0005303a 	rdctl	r2,status
81138c44:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138c48:	e0fffe17 	ldw	r3,-8(fp)
81138c4c:	00bfff84 	movi	r2,-2
81138c50:	1884703a 	and	r2,r3,r2
81138c54:	1001703a 	wrctl	status,r2
  
  return context;
81138c58:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81138c5c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81138c60:	d0a09217 	ldw	r2,-32184(gp)
81138c64:	d0a09815 	stw	r2,-32160(gp)
    OSStatRdy    = OS_TRUE;
81138c68:	00800044 	movi	r2,1
81138c6c:	d0a0a705 	stb	r2,-32100(gp)
81138c70:	e0bffb17 	ldw	r2,-20(fp)
81138c74:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c78:	e0bfff17 	ldw	r2,-4(fp)
81138c7c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81138c80:	0001883a 	nop
81138c84:	e037883a 	mov	sp,fp
81138c88:	dfc00117 	ldw	ra,4(sp)
81138c8c:	df000017 	ldw	fp,0(sp)
81138c90:	dec00204 	addi	sp,sp,8
81138c94:	f800283a 	ret

81138c98 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81138c98:	defff704 	addi	sp,sp,-36
81138c9c:	de00012e 	bgeu	sp,et,81138ca4 <OSTimeTick+0xc>
81138ca0:	003b68fa 	trap	3
81138ca4:	dfc00815 	stw	ra,32(sp)
81138ca8:	df000715 	stw	fp,28(sp)
81138cac:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81138cb0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81138cb4:	114ace80 	call	8114ace8 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138cb8:	0005303a 	rdctl	r2,status
81138cbc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138cc0:	e0fffd17 	ldw	r3,-12(fp)
81138cc4:	00bfff84 	movi	r2,-2
81138cc8:	1884703a 	and	r2,r3,r2
81138ccc:	1001703a 	wrctl	status,r2
  
  return context;
81138cd0:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81138cd4:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81138cd8:	d0a0a417 	ldw	r2,-32112(gp)
81138cdc:	10800044 	addi	r2,r2,1
81138ce0:	d0a0a415 	stw	r2,-32112(gp)
81138ce4:	e0bffb17 	ldw	r2,-20(fp)
81138ce8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138cec:	e0bfff17 	ldw	r2,-4(fp)
81138cf0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81138cf4:	d0a09103 	ldbu	r2,-32188(gp)
81138cf8:	10803fcc 	andi	r2,r2,255
81138cfc:	10800058 	cmpnei	r2,r2,1
81138d00:	10006a1e 	bne	r2,zero,81138eac <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81138d04:	d0a09503 	ldbu	r2,-32172(gp)
81138d08:	10803fcc 	andi	r2,r2,255
81138d0c:	10c00060 	cmpeqi	r3,r2,1
81138d10:	1800061e 	bne	r3,zero,81138d2c <OSTimeTick+0x94>
81138d14:	10c000a0 	cmpeqi	r3,r2,2
81138d18:	1800061e 	bne	r3,zero,81138d34 <OSTimeTick+0x9c>
81138d1c:	10000a1e 	bne	r2,zero,81138d48 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81138d20:	00800044 	movi	r2,1
81138d24:	e0bffa05 	stb	r2,-24(fp)
                 break;
81138d28:	00000b06 	br	81138d58 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81138d2c:	e03ffa05 	stb	zero,-24(fp)
                 break;
81138d30:	00000906 	br	81138d58 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81138d34:	00800044 	movi	r2,1
81138d38:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81138d3c:	00800044 	movi	r2,1
81138d40:	d0a09505 	stb	r2,-32172(gp)
                 break;
81138d44:	00000406 	br	81138d58 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81138d48:	00800044 	movi	r2,1
81138d4c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81138d50:	d0209505 	stb	zero,-32172(gp)
                 break;
81138d54:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81138d58:	e0bffa03 	ldbu	r2,-24(fp)
81138d5c:	10005226 	beq	r2,zero,81138ea8 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81138d60:	d0a09417 	ldw	r2,-32176(gp)
81138d64:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81138d68:	00004906 	br	81138e90 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d6c:	0005303a 	rdctl	r2,status
81138d70:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138d74:	e0fffc17 	ldw	r3,-16(fp)
81138d78:	00bfff84 	movi	r2,-2
81138d7c:	1884703a 	and	r2,r3,r2
81138d80:	1001703a 	wrctl	status,r2
  
  return context;
81138d84:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81138d88:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81138d8c:	e0bff917 	ldw	r2,-28(fp)
81138d90:	10800b8b 	ldhu	r2,46(r2)
81138d94:	10bfffcc 	andi	r2,r2,65535
81138d98:	10003626 	beq	r2,zero,81138e74 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81138d9c:	e0bff917 	ldw	r2,-28(fp)
81138da0:	10800b8b 	ldhu	r2,46(r2)
81138da4:	10bfffc4 	addi	r2,r2,-1
81138da8:	1007883a 	mov	r3,r2
81138dac:	e0bff917 	ldw	r2,-28(fp)
81138db0:	10c00b8d 	sth	r3,46(r2)
81138db4:	e0bff917 	ldw	r2,-28(fp)
81138db8:	10800b8b 	ldhu	r2,46(r2)
81138dbc:	10bfffcc 	andi	r2,r2,65535
81138dc0:	10002c1e 	bne	r2,zero,81138e74 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81138dc4:	e0bff917 	ldw	r2,-28(fp)
81138dc8:	10800c03 	ldbu	r2,48(r2)
81138dcc:	10803fcc 	andi	r2,r2,255
81138dd0:	10800dcc 	andi	r2,r2,55
81138dd4:	10000b26 	beq	r2,zero,81138e04 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81138dd8:	e0bff917 	ldw	r2,-28(fp)
81138ddc:	10c00c03 	ldbu	r3,48(r2)
81138de0:	00bff204 	movi	r2,-56
81138de4:	1884703a 	and	r2,r3,r2
81138de8:	1007883a 	mov	r3,r2
81138dec:	e0bff917 	ldw	r2,-28(fp)
81138df0:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81138df4:	e0bff917 	ldw	r2,-28(fp)
81138df8:	00c00044 	movi	r3,1
81138dfc:	10c00c45 	stb	r3,49(r2)
81138e00:	00000206 	br	81138e0c <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81138e04:	e0bff917 	ldw	r2,-28(fp)
81138e08:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81138e0c:	e0bff917 	ldw	r2,-28(fp)
81138e10:	10800c03 	ldbu	r2,48(r2)
81138e14:	10803fcc 	andi	r2,r2,255
81138e18:	1080020c 	andi	r2,r2,8
81138e1c:	1000151e 	bne	r2,zero,81138e74 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
81138e20:	e0bff917 	ldw	r2,-28(fp)
81138e24:	10c00d83 	ldbu	r3,54(r2)
81138e28:	d0a09e03 	ldbu	r2,-32136(gp)
81138e2c:	1884b03a 	or	r2,r3,r2
81138e30:	d0a09e05 	stb	r2,-32136(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81138e34:	e0bff917 	ldw	r2,-28(fp)
81138e38:	10800d03 	ldbu	r2,52(r2)
81138e3c:	10c03fcc 	andi	r3,r2,255
81138e40:	e0bff917 	ldw	r2,-28(fp)
81138e44:	10800d03 	ldbu	r2,52(r2)
81138e48:	11003fcc 	andi	r4,r2,255
81138e4c:	d0a09e44 	addi	r2,gp,-32135
81138e50:	2085883a 	add	r2,r4,r2
81138e54:	11000003 	ldbu	r4,0(r2)
81138e58:	e0bff917 	ldw	r2,-28(fp)
81138e5c:	10800d43 	ldbu	r2,53(r2)
81138e60:	2084b03a 	or	r2,r4,r2
81138e64:	1009883a 	mov	r4,r2
81138e68:	d0a09e44 	addi	r2,gp,-32135
81138e6c:	1885883a 	add	r2,r3,r2
81138e70:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81138e74:	e0bff917 	ldw	r2,-28(fp)
81138e78:	10800517 	ldw	r2,20(r2)
81138e7c:	e0bff915 	stw	r2,-28(fp)
81138e80:	e0bffb17 	ldw	r2,-20(fp)
81138e84:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138e88:	e0bffe17 	ldw	r2,-8(fp)
81138e8c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81138e90:	e0bff917 	ldw	r2,-28(fp)
81138e94:	10800c83 	ldbu	r2,50(r2)
81138e98:	10803fcc 	andi	r2,r2,255
81138e9c:	10800a98 	cmpnei	r2,r2,42
81138ea0:	103fb21e 	bne	r2,zero,81138d6c <__reset+0xfb118d6c>
81138ea4:	00000106 	br	81138eac <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81138ea8:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81138eac:	e037883a 	mov	sp,fp
81138eb0:	dfc00117 	ldw	ra,4(sp)
81138eb4:	df000017 	ldw	fp,0(sp)
81138eb8:	dec00204 	addi	sp,sp,8
81138ebc:	f800283a 	ret

81138ec0 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
81138ec0:	deffff04 	addi	sp,sp,-4
81138ec4:	de00012e 	bgeu	sp,et,81138ecc <OSVersion+0xc>
81138ec8:	003b68fa 	trap	3
81138ecc:	df000015 	stw	fp,0(sp)
81138ed0:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81138ed4:	00804784 	movi	r2,286
}
81138ed8:	e037883a 	mov	sp,fp
81138edc:	df000017 	ldw	fp,0(sp)
81138ee0:	dec00104 	addi	sp,sp,4
81138ee4:	f800283a 	ret

81138ee8 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81138ee8:	deffff04 	addi	sp,sp,-4
81138eec:	de00012e 	bgeu	sp,et,81138ef4 <OS_Dummy+0xc>
81138ef0:	003b68fa 	trap	3
81138ef4:	df000015 	stw	fp,0(sp)
81138ef8:	d839883a 	mov	fp,sp
}
81138efc:	0001883a 	nop
81138f00:	e037883a 	mov	sp,fp
81138f04:	df000017 	ldw	fp,0(sp)
81138f08:	dec00104 	addi	sp,sp,4
81138f0c:	f800283a 	ret

81138f10 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
81138f10:	defff804 	addi	sp,sp,-32
81138f14:	de00012e 	bgeu	sp,et,81138f1c <OS_EventTaskRdy+0xc>
81138f18:	003b68fa 	trap	3
81138f1c:	dfc00715 	stw	ra,28(sp)
81138f20:	df000615 	stw	fp,24(sp)
81138f24:	df000604 	addi	fp,sp,24
81138f28:	e13ffc15 	stw	r4,-16(fp)
81138f2c:	e17ffd15 	stw	r5,-12(fp)
81138f30:	3007883a 	mov	r3,r6
81138f34:	3805883a 	mov	r2,r7
81138f38:	e0fffe05 	stb	r3,-8(fp)
81138f3c:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
81138f40:	e0bffc17 	ldw	r2,-16(fp)
81138f44:	10800283 	ldbu	r2,10(r2)
81138f48:	10c03fcc 	andi	r3,r2,255
81138f4c:	00a04574 	movhi	r2,33045
81138f50:	10837804 	addi	r2,r2,3552
81138f54:	10c5883a 	add	r2,r2,r3
81138f58:	10800003 	ldbu	r2,0(r2)
81138f5c:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
81138f60:	e0bffa03 	ldbu	r2,-24(fp)
81138f64:	e0fffc17 	ldw	r3,-16(fp)
81138f68:	1885883a 	add	r2,r3,r2
81138f6c:	108002c4 	addi	r2,r2,11
81138f70:	10800003 	ldbu	r2,0(r2)
81138f74:	10c03fcc 	andi	r3,r2,255
81138f78:	00a04574 	movhi	r2,33045
81138f7c:	10837804 	addi	r2,r2,3552
81138f80:	10c5883a 	add	r2,r2,r3
81138f84:	10800003 	ldbu	r2,0(r2)
81138f88:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81138f8c:	e0bffa03 	ldbu	r2,-24(fp)
81138f90:	100490fa 	slli	r2,r2,3
81138f94:	1007883a 	mov	r3,r2
81138f98:	e0bffa43 	ldbu	r2,-23(fp)
81138f9c:	1885883a 	add	r2,r3,r2
81138fa0:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81138fa4:	e0fffa83 	ldbu	r3,-22(fp)
81138fa8:	00a045f4 	movhi	r2,33047
81138fac:	10b2f704 	addi	r2,r2,-13348
81138fb0:	18c7883a 	add	r3,r3,r3
81138fb4:	18c7883a 	add	r3,r3,r3
81138fb8:	10c5883a 	add	r2,r2,r3
81138fbc:	10800017 	ldw	r2,0(r2)
81138fc0:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81138fc4:	e0bffb17 	ldw	r2,-20(fp)
81138fc8:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81138fcc:	e0bffb17 	ldw	r2,-20(fp)
81138fd0:	e0fffd17 	ldw	r3,-12(fp)
81138fd4:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81138fd8:	e0bffb17 	ldw	r2,-20(fp)
81138fdc:	10800c03 	ldbu	r2,48(r2)
81138fe0:	1007883a 	mov	r3,r2
81138fe4:	e0bffe03 	ldbu	r2,-8(fp)
81138fe8:	0084303a 	nor	r2,zero,r2
81138fec:	1884703a 	and	r2,r3,r2
81138ff0:	1007883a 	mov	r3,r2
81138ff4:	e0bffb17 	ldw	r2,-20(fp)
81138ff8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81138ffc:	e0bffb17 	ldw	r2,-20(fp)
81139000:	e0ffff03 	ldbu	r3,-4(fp)
81139004:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81139008:	e0bffb17 	ldw	r2,-20(fp)
8113900c:	10800c03 	ldbu	r2,48(r2)
81139010:	10803fcc 	andi	r2,r2,255
81139014:	1080020c 	andi	r2,r2,8
81139018:	1000111e 	bne	r2,zero,81139060 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8113901c:	e0bffb17 	ldw	r2,-20(fp)
81139020:	10c00d83 	ldbu	r3,54(r2)
81139024:	d0a09e03 	ldbu	r2,-32136(gp)
81139028:	1884b03a 	or	r2,r3,r2
8113902c:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
81139030:	e0fffa03 	ldbu	r3,-24(fp)
81139034:	e13ffa03 	ldbu	r4,-24(fp)
81139038:	d0a09e44 	addi	r2,gp,-32135
8113903c:	2085883a 	add	r2,r4,r2
81139040:	11000003 	ldbu	r4,0(r2)
81139044:	e0bffb17 	ldw	r2,-20(fp)
81139048:	10800d43 	ldbu	r2,53(r2)
8113904c:	2084b03a 	or	r2,r4,r2
81139050:	1009883a 	mov	r4,r2
81139054:	d0a09e44 	addi	r2,gp,-32135
81139058:	1885883a 	add	r2,r3,r2
8113905c:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
81139060:	e17ffc17 	ldw	r5,-16(fp)
81139064:	e13ffb17 	ldw	r4,-20(fp)
81139068:	11393200 	call	81139320 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8113906c:	e0bffb17 	ldw	r2,-20(fp)
81139070:	10800817 	ldw	r2,32(r2)
81139074:	10000826 	beq	r2,zero,81139098 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81139078:	e0bffb17 	ldw	r2,-20(fp)
8113907c:	10800817 	ldw	r2,32(r2)
81139080:	100b883a 	mov	r5,r2
81139084:	e13ffb17 	ldw	r4,-20(fp)
81139088:	11393e00 	call	811393e0 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8113908c:	e0bffb17 	ldw	r2,-20(fp)
81139090:	e0fffc17 	ldw	r3,-16(fp)
81139094:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81139098:	e0bffa83 	ldbu	r2,-22(fp)
}
8113909c:	e037883a 	mov	sp,fp
811390a0:	dfc00117 	ldw	ra,4(sp)
811390a4:	df000017 	ldw	fp,0(sp)
811390a8:	dec00204 	addi	sp,sp,8
811390ac:	f800283a 	ret

811390b0 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
811390b0:	defffd04 	addi	sp,sp,-12
811390b4:	de00012e 	bgeu	sp,et,811390bc <OS_EventTaskWait+0xc>
811390b8:	003b68fa 	trap	3
811390bc:	df000215 	stw	fp,8(sp)
811390c0:	df000204 	addi	fp,sp,8
811390c4:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
811390c8:	d0a0a217 	ldw	r2,-32120(gp)
811390cc:	e0ffff17 	ldw	r3,-4(fp)
811390d0:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
811390d4:	d0a0a217 	ldw	r2,-32120(gp)
811390d8:	10800d03 	ldbu	r2,52(r2)
811390dc:	10803fcc 	andi	r2,r2,255
811390e0:	d0e0a217 	ldw	r3,-32120(gp)
811390e4:	18c00d03 	ldbu	r3,52(r3)
811390e8:	18c03fcc 	andi	r3,r3,255
811390ec:	e13fff17 	ldw	r4,-4(fp)
811390f0:	20c7883a 	add	r3,r4,r3
811390f4:	18c002c4 	addi	r3,r3,11
811390f8:	19000003 	ldbu	r4,0(r3)
811390fc:	d0e0a217 	ldw	r3,-32120(gp)
81139100:	18c00d43 	ldbu	r3,53(r3)
81139104:	20c6b03a 	or	r3,r4,r3
81139108:	1809883a 	mov	r4,r3
8113910c:	e0ffff17 	ldw	r3,-4(fp)
81139110:	1885883a 	add	r2,r3,r2
81139114:	108002c4 	addi	r2,r2,11
81139118:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8113911c:	e0bfff17 	ldw	r2,-4(fp)
81139120:	10c00283 	ldbu	r3,10(r2)
81139124:	d0a0a217 	ldw	r2,-32120(gp)
81139128:	10800d83 	ldbu	r2,54(r2)
8113912c:	1884b03a 	or	r2,r3,r2
81139130:	1007883a 	mov	r3,r2
81139134:	e0bfff17 	ldw	r2,-4(fp)
81139138:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113913c:	d0a0a217 	ldw	r2,-32120(gp)
81139140:	10800d03 	ldbu	r2,52(r2)
81139144:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81139148:	e0fffe03 	ldbu	r3,-8(fp)
8113914c:	e13ffe03 	ldbu	r4,-8(fp)
81139150:	d0a09e44 	addi	r2,gp,-32135
81139154:	2085883a 	add	r2,r4,r2
81139158:	10800003 	ldbu	r2,0(r2)
8113915c:	1009883a 	mov	r4,r2
81139160:	d0a0a217 	ldw	r2,-32120(gp)
81139164:	10800d43 	ldbu	r2,53(r2)
81139168:	0084303a 	nor	r2,zero,r2
8113916c:	2084703a 	and	r2,r4,r2
81139170:	1009883a 	mov	r4,r2
81139174:	d0a09e44 	addi	r2,gp,-32135
81139178:	1885883a 	add	r2,r3,r2
8113917c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81139180:	e0fffe03 	ldbu	r3,-8(fp)
81139184:	d0a09e44 	addi	r2,gp,-32135
81139188:	1885883a 	add	r2,r3,r2
8113918c:	10800003 	ldbu	r2,0(r2)
81139190:	10803fcc 	andi	r2,r2,255
81139194:	1000071e 	bne	r2,zero,811391b4 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81139198:	d0a0a217 	ldw	r2,-32120(gp)
8113919c:	10800d83 	ldbu	r2,54(r2)
811391a0:	0084303a 	nor	r2,zero,r2
811391a4:	1007883a 	mov	r3,r2
811391a8:	d0a09e03 	ldbu	r2,-32136(gp)
811391ac:	1884703a 	and	r2,r3,r2
811391b0:	d0a09e05 	stb	r2,-32136(gp)
    }
}
811391b4:	0001883a 	nop
811391b8:	e037883a 	mov	sp,fp
811391bc:	df000017 	ldw	fp,0(sp)
811391c0:	dec00104 	addi	sp,sp,4
811391c4:	f800283a 	ret

811391c8 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
811391c8:	defffb04 	addi	sp,sp,-20
811391cc:	de00012e 	bgeu	sp,et,811391d4 <OS_EventTaskWaitMulti+0xc>
811391d0:	003b68fa 	trap	3
811391d4:	df000415 	stw	fp,16(sp)
811391d8:	df000404 	addi	fp,sp,16
811391dc:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
811391e0:	d0a0a217 	ldw	r2,-32120(gp)
811391e4:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
811391e8:	d0a0a217 	ldw	r2,-32120(gp)
811391ec:	e0ffff17 	ldw	r3,-4(fp)
811391f0:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
811391f4:	e0bfff17 	ldw	r2,-4(fp)
811391f8:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
811391fc:	e0bffc17 	ldw	r2,-16(fp)
81139200:	10800017 	ldw	r2,0(r2)
81139204:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81139208:	00002006 	br	8113928c <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8113920c:	d0a0a217 	ldw	r2,-32120(gp)
81139210:	10800d03 	ldbu	r2,52(r2)
81139214:	10803fcc 	andi	r2,r2,255
81139218:	d0e0a217 	ldw	r3,-32120(gp)
8113921c:	18c00d03 	ldbu	r3,52(r3)
81139220:	18c03fcc 	andi	r3,r3,255
81139224:	e13ffd17 	ldw	r4,-12(fp)
81139228:	20c7883a 	add	r3,r4,r3
8113922c:	18c002c4 	addi	r3,r3,11
81139230:	19000003 	ldbu	r4,0(r3)
81139234:	d0e0a217 	ldw	r3,-32120(gp)
81139238:	18c00d43 	ldbu	r3,53(r3)
8113923c:	20c6b03a 	or	r3,r4,r3
81139240:	1809883a 	mov	r4,r3
81139244:	e0fffd17 	ldw	r3,-12(fp)
81139248:	1885883a 	add	r2,r3,r2
8113924c:	108002c4 	addi	r2,r2,11
81139250:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81139254:	e0bffd17 	ldw	r2,-12(fp)
81139258:	10c00283 	ldbu	r3,10(r2)
8113925c:	d0a0a217 	ldw	r2,-32120(gp)
81139260:	10800d83 	ldbu	r2,54(r2)
81139264:	1884b03a 	or	r2,r3,r2
81139268:	1007883a 	mov	r3,r2
8113926c:	e0bffd17 	ldw	r2,-12(fp)
81139270:	10c00285 	stb	r3,10(r2)
        pevents++;
81139274:	e0bffc17 	ldw	r2,-16(fp)
81139278:	10800104 	addi	r2,r2,4
8113927c:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
81139280:	e0bffc17 	ldw	r2,-16(fp)
81139284:	10800017 	ldw	r2,0(r2)
81139288:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113928c:	e0bffd17 	ldw	r2,-12(fp)
81139290:	103fde1e 	bne	r2,zero,8113920c <__reset+0xfb11920c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81139294:	d0a0a217 	ldw	r2,-32120(gp)
81139298:	10800d03 	ldbu	r2,52(r2)
8113929c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
811392a0:	e0fffe03 	ldbu	r3,-8(fp)
811392a4:	e13ffe03 	ldbu	r4,-8(fp)
811392a8:	d0a09e44 	addi	r2,gp,-32135
811392ac:	2085883a 	add	r2,r4,r2
811392b0:	10800003 	ldbu	r2,0(r2)
811392b4:	1009883a 	mov	r4,r2
811392b8:	d0a0a217 	ldw	r2,-32120(gp)
811392bc:	10800d43 	ldbu	r2,53(r2)
811392c0:	0084303a 	nor	r2,zero,r2
811392c4:	2084703a 	and	r2,r4,r2
811392c8:	1009883a 	mov	r4,r2
811392cc:	d0a09e44 	addi	r2,gp,-32135
811392d0:	1885883a 	add	r2,r3,r2
811392d4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811392d8:	e0fffe03 	ldbu	r3,-8(fp)
811392dc:	d0a09e44 	addi	r2,gp,-32135
811392e0:	1885883a 	add	r2,r3,r2
811392e4:	10800003 	ldbu	r2,0(r2)
811392e8:	10803fcc 	andi	r2,r2,255
811392ec:	1000071e 	bne	r2,zero,8113930c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
811392f0:	d0a0a217 	ldw	r2,-32120(gp)
811392f4:	10800d83 	ldbu	r2,54(r2)
811392f8:	0084303a 	nor	r2,zero,r2
811392fc:	1007883a 	mov	r3,r2
81139300:	d0a09e03 	ldbu	r2,-32136(gp)
81139304:	1884703a 	and	r2,r3,r2
81139308:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113930c:	0001883a 	nop
81139310:	e037883a 	mov	sp,fp
81139314:	df000017 	ldw	fp,0(sp)
81139318:	dec00104 	addi	sp,sp,4
8113931c:	f800283a 	ret

81139320 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
81139320:	defffc04 	addi	sp,sp,-16
81139324:	de00012e 	bgeu	sp,et,8113932c <OS_EventTaskRemove+0xc>
81139328:	003b68fa 	trap	3
8113932c:	df000315 	stw	fp,12(sp)
81139330:	df000304 	addi	fp,sp,12
81139334:	e13ffe15 	stw	r4,-8(fp)
81139338:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
8113933c:	e0bffe17 	ldw	r2,-8(fp)
81139340:	10800d03 	ldbu	r2,52(r2)
81139344:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
81139348:	e0bffd03 	ldbu	r2,-12(fp)
8113934c:	e0fffd03 	ldbu	r3,-12(fp)
81139350:	e13fff17 	ldw	r4,-4(fp)
81139354:	20c7883a 	add	r3,r4,r3
81139358:	18c002c4 	addi	r3,r3,11
8113935c:	18c00003 	ldbu	r3,0(r3)
81139360:	1809883a 	mov	r4,r3
81139364:	e0fffe17 	ldw	r3,-8(fp)
81139368:	18c00d43 	ldbu	r3,53(r3)
8113936c:	00c6303a 	nor	r3,zero,r3
81139370:	20c6703a 	and	r3,r4,r3
81139374:	1809883a 	mov	r4,r3
81139378:	e0ffff17 	ldw	r3,-4(fp)
8113937c:	1885883a 	add	r2,r3,r2
81139380:	108002c4 	addi	r2,r2,11
81139384:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81139388:	e0bffd03 	ldbu	r2,-12(fp)
8113938c:	e0ffff17 	ldw	r3,-4(fp)
81139390:	1885883a 	add	r2,r3,r2
81139394:	108002c4 	addi	r2,r2,11
81139398:	10800003 	ldbu	r2,0(r2)
8113939c:	10803fcc 	andi	r2,r2,255
811393a0:	10000a1e 	bne	r2,zero,811393cc <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
811393a4:	e0bfff17 	ldw	r2,-4(fp)
811393a8:	10800283 	ldbu	r2,10(r2)
811393ac:	1007883a 	mov	r3,r2
811393b0:	e0bffe17 	ldw	r2,-8(fp)
811393b4:	10800d83 	ldbu	r2,54(r2)
811393b8:	0084303a 	nor	r2,zero,r2
811393bc:	1884703a 	and	r2,r3,r2
811393c0:	1007883a 	mov	r3,r2
811393c4:	e0bfff17 	ldw	r2,-4(fp)
811393c8:	10c00285 	stb	r3,10(r2)
    }
}
811393cc:	0001883a 	nop
811393d0:	e037883a 	mov	sp,fp
811393d4:	df000017 	ldw	fp,0(sp)
811393d8:	dec00104 	addi	sp,sp,4
811393dc:	f800283a 	ret

811393e0 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
811393e0:	defffa04 	addi	sp,sp,-24
811393e4:	de00012e 	bgeu	sp,et,811393ec <OS_EventTaskRemoveMulti+0xc>
811393e8:	003b68fa 	trap	3
811393ec:	df000515 	stw	fp,20(sp)
811393f0:	df000504 	addi	fp,sp,20
811393f4:	e13ffe15 	stw	r4,-8(fp)
811393f8:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
811393fc:	e0bffe17 	ldw	r2,-8(fp)
81139400:	10800d03 	ldbu	r2,52(r2)
81139404:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
81139408:	e0bffe17 	ldw	r2,-8(fp)
8113940c:	10800d83 	ldbu	r2,54(r2)
81139410:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
81139414:	e0bffe17 	ldw	r2,-8(fp)
81139418:	10800d43 	ldbu	r2,53(r2)
8113941c:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
81139420:	e0bfff17 	ldw	r2,-4(fp)
81139424:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
81139428:	e0bffb17 	ldw	r2,-20(fp)
8113942c:	10800017 	ldw	r2,0(r2)
81139430:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81139434:	00002506 	br	811394cc <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
81139438:	e0bffd03 	ldbu	r2,-12(fp)
8113943c:	e0fffd03 	ldbu	r3,-12(fp)
81139440:	e13ffc17 	ldw	r4,-16(fp)
81139444:	20c7883a 	add	r3,r4,r3
81139448:	18c002c4 	addi	r3,r3,11
8113944c:	18c00003 	ldbu	r3,0(r3)
81139450:	1809883a 	mov	r4,r3
81139454:	e0fffd83 	ldbu	r3,-10(fp)
81139458:	00c6303a 	nor	r3,zero,r3
8113945c:	20c6703a 	and	r3,r4,r3
81139460:	1809883a 	mov	r4,r3
81139464:	e0fffc17 	ldw	r3,-16(fp)
81139468:	1885883a 	add	r2,r3,r2
8113946c:	108002c4 	addi	r2,r2,11
81139470:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
81139474:	e0bffd03 	ldbu	r2,-12(fp)
81139478:	e0fffc17 	ldw	r3,-16(fp)
8113947c:	1885883a 	add	r2,r3,r2
81139480:	108002c4 	addi	r2,r2,11
81139484:	10800003 	ldbu	r2,0(r2)
81139488:	10803fcc 	andi	r2,r2,255
8113948c:	1000091e 	bne	r2,zero,811394b4 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
81139490:	e0bffc17 	ldw	r2,-16(fp)
81139494:	10800283 	ldbu	r2,10(r2)
81139498:	1007883a 	mov	r3,r2
8113949c:	e0bffd43 	ldbu	r2,-11(fp)
811394a0:	0084303a 	nor	r2,zero,r2
811394a4:	1884703a 	and	r2,r3,r2
811394a8:	1007883a 	mov	r3,r2
811394ac:	e0bffc17 	ldw	r2,-16(fp)
811394b0:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
811394b4:	e0bffb17 	ldw	r2,-20(fp)
811394b8:	10800104 	addi	r2,r2,4
811394bc:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
811394c0:	e0bffb17 	ldw	r2,-20(fp)
811394c4:	10800017 	ldw	r2,0(r2)
811394c8:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811394cc:	e0bffc17 	ldw	r2,-16(fp)
811394d0:	103fd91e 	bne	r2,zero,81139438 <__reset+0xfb119438>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
811394d4:	0001883a 	nop
811394d8:	e037883a 	mov	sp,fp
811394dc:	df000017 	ldw	fp,0(sp)
811394e0:	dec00104 	addi	sp,sp,4
811394e4:	f800283a 	ret

811394e8 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
811394e8:	defffc04 	addi	sp,sp,-16
811394ec:	de00012e 	bgeu	sp,et,811394f4 <OS_EventWaitListInit+0xc>
811394f0:	003b68fa 	trap	3
811394f4:	df000315 	stw	fp,12(sp)
811394f8:	df000304 	addi	fp,sp,12
811394fc:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
81139500:	e0bfff17 	ldw	r2,-4(fp)
81139504:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
81139508:	e0bfff17 	ldw	r2,-4(fp)
8113950c:	108002c4 	addi	r2,r2,11
81139510:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139514:	e03ffe05 	stb	zero,-8(fp)
81139518:	00000706 	br	81139538 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
8113951c:	e0bffd17 	ldw	r2,-12(fp)
81139520:	10c00044 	addi	r3,r2,1
81139524:	e0fffd15 	stw	r3,-12(fp)
81139528:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113952c:	e0bffe03 	ldbu	r2,-8(fp)
81139530:	10800044 	addi	r2,r2,1
81139534:	e0bffe05 	stb	r2,-8(fp)
81139538:	e0bffe03 	ldbu	r2,-8(fp)
8113953c:	108001b0 	cmpltui	r2,r2,6
81139540:	103ff61e 	bne	r2,zero,8113951c <__reset+0xfb11951c>
        *ptbl++ = 0;
    }
}
81139544:	0001883a 	nop
81139548:	e037883a 	mov	sp,fp
8113954c:	df000017 	ldw	fp,0(sp)
81139550:	dec00104 	addi	sp,sp,4
81139554:	f800283a 	ret

81139558 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
81139558:	defffb04 	addi	sp,sp,-20
8113955c:	de00012e 	bgeu	sp,et,81139564 <OS_InitEventList+0xc>
81139560:	003b68fa 	trap	3
81139564:	dfc00415 	stw	ra,16(sp)
81139568:	df000315 	stw	fp,12(sp)
8113956c:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
81139570:	01434004 	movi	r5,3328
81139574:	012045f4 	movhi	r4,33047
81139578:	212b4904 	addi	r4,r4,-21212
8113957c:	11399000 	call	81139900 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
81139580:	00a045f4 	movhi	r2,33047
81139584:	10ab4904 	addi	r2,r2,-21212
81139588:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8113958c:	00a045f4 	movhi	r2,33047
81139590:	10ab5604 	addi	r2,r2,-21160
81139594:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81139598:	e03ffd0d 	sth	zero,-12(fp)
8113959c:	00001306 	br	811395ec <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
811395a0:	e0bffe17 	ldw	r2,-8(fp)
811395a4:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
811395a8:	e0bffe17 	ldw	r2,-8(fp)
811395ac:	e0ffff17 	ldw	r3,-4(fp)
811395b0:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
811395b4:	e0bffe17 	ldw	r2,-8(fp)
811395b8:	00c00fc4 	movi	r3,63
811395bc:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
811395c0:	e0bffe17 	ldw	r2,-8(fp)
811395c4:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
811395c8:	e0bffe17 	ldw	r2,-8(fp)
811395cc:	10800d04 	addi	r2,r2,52
811395d0:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
811395d4:	e0bfff17 	ldw	r2,-4(fp)
811395d8:	10800d04 	addi	r2,r2,52
811395dc:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
811395e0:	e0bffd0b 	ldhu	r2,-12(fp)
811395e4:	10800044 	addi	r2,r2,1
811395e8:	e0bffd0d 	sth	r2,-12(fp)
811395ec:	e0bffd0b 	ldhu	r2,-12(fp)
811395f0:	10800ff0 	cmpltui	r2,r2,63
811395f4:	103fea1e 	bne	r2,zero,811395a0 <__reset+0xfb1195a0>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
811395f8:	e0bffe17 	ldw	r2,-8(fp)
811395fc:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
81139600:	e0bffe17 	ldw	r2,-8(fp)
81139604:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
81139608:	e0bffe17 	ldw	r2,-8(fp)
8113960c:	00c00fc4 	movi	r3,63
81139610:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
81139614:	e0bffe17 	ldw	r2,-8(fp)
81139618:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
8113961c:	00a045f4 	movhi	r2,33047
81139620:	10ab4904 	addi	r2,r2,-21212
81139624:	d0a0a015 	stw	r2,-32128(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
81139628:	0001883a 	nop
8113962c:	e037883a 	mov	sp,fp
81139630:	dfc00117 	ldw	ra,4(sp)
81139634:	df000017 	ldw	fp,0(sp)
81139638:	dec00204 	addi	sp,sp,8
8113963c:	f800283a 	ret

81139640 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
81139640:	deffff04 	addi	sp,sp,-4
81139644:	de00012e 	bgeu	sp,et,8113964c <OS_InitMisc+0xc>
81139648:	003b68fa 	trap	3
8113964c:	df000015 	stw	fp,0(sp)
81139650:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
81139654:	d020a415 	stw	zero,-32112(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
81139658:	d020a105 	stb	zero,-32124(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8113965c:	d0208f05 	stb	zero,-32196(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
81139660:	d0209a45 	stb	zero,-32151(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81139664:	d0209105 	stb	zero,-32188(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81139668:	d0209615 	stw	zero,-32168(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8113966c:	d0209215 	stw	zero,-32184(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
81139670:	d020a815 	stw	zero,-32096(gp)
    OSIdleCtrMax  = 0L;
81139674:	d0209815 	stw	zero,-32160(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81139678:	d020a705 	stb	zero,-32100(gp)
#endif
}
8113967c:	0001883a 	nop
81139680:	e037883a 	mov	sp,fp
81139684:	df000017 	ldw	fp,0(sp)
81139688:	dec00104 	addi	sp,sp,4
8113968c:	f800283a 	ret

81139690 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
81139690:	defffd04 	addi	sp,sp,-12
81139694:	de00012e 	bgeu	sp,et,8113969c <OS_InitRdyList+0xc>
81139698:	003b68fa 	trap	3
8113969c:	df000215 	stw	fp,8(sp)
811396a0:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
811396a4:	d0209e05 	stb	zero,-32136(gp)
    prdytbl       = &OSRdyTbl[0];
811396a8:	d0a09e44 	addi	r2,gp,-32135
811396ac:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811396b0:	e03ffe05 	stb	zero,-8(fp)
811396b4:	00000706 	br	811396d4 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
811396b8:	e0bfff17 	ldw	r2,-4(fp)
811396bc:	10c00044 	addi	r3,r2,1
811396c0:	e0ffff15 	stw	r3,-4(fp)
811396c4:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811396c8:	e0bffe03 	ldbu	r2,-8(fp)
811396cc:	10800044 	addi	r2,r2,1
811396d0:	e0bffe05 	stb	r2,-8(fp)
811396d4:	e0bffe03 	ldbu	r2,-8(fp)
811396d8:	108001b0 	cmpltui	r2,r2,6
811396dc:	103ff61e 	bne	r2,zero,811396b8 <__reset+0xfb1196b8>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
811396e0:	d02093c5 	stb	zero,-32177(gp)
    OSPrioHighRdy = 0;
811396e4:	d0209385 	stb	zero,-32178(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
811396e8:	d0209c15 	stw	zero,-32144(gp)
    OSTCBCur      = (OS_TCB *)0;
811396ec:	d020a215 	stw	zero,-32120(gp)
}
811396f0:	0001883a 	nop
811396f4:	e037883a 	mov	sp,fp
811396f8:	df000017 	ldw	fp,0(sp)
811396fc:	dec00104 	addi	sp,sp,4
81139700:	f800283a 	ret

81139704 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
81139704:	defff804 	addi	sp,sp,-32
81139708:	de00012e 	bgeu	sp,et,81139710 <OS_InitTaskIdle+0xc>
8113970c:	003b68fa 	trap	3
81139710:	dfc00715 	stw	ra,28(sp)
81139714:	df000615 	stw	fp,24(sp)
81139718:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
8113971c:	008000c4 	movi	r2,3
81139720:	d8800415 	stw	r2,16(sp)
81139724:	d8000315 	stw	zero,12(sp)
81139728:	00810004 	movi	r2,1024
8113972c:	d8800215 	stw	r2,8(sp)
81139730:	00a045f4 	movhi	r2,33047
81139734:	10a74904 	addi	r2,r2,-25308
81139738:	d8800115 	stw	r2,4(sp)
8113973c:	00bfffd4 	movui	r2,65535
81139740:	d8800015 	stw	r2,0(sp)
81139744:	01c00a84 	movi	r7,42
81139748:	01a045f4 	movhi	r6,33047
8113974c:	31ab4804 	addi	r6,r6,-21216
81139750:	000b883a 	mov	r5,zero
81139754:	01204534 	movhi	r4,33044
81139758:	2126fe04 	addi	r4,r4,-25608
8113975c:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
81139760:	e1bfff04 	addi	r6,fp,-4
81139764:	01604574 	movhi	r5,33045
81139768:	2943b804 	addi	r5,r5,3808
8113976c:	01000a84 	movi	r4,42
81139770:	113fe180 	call	8113fe18 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
81139774:	0001883a 	nop
81139778:	e037883a 	mov	sp,fp
8113977c:	dfc00117 	ldw	ra,4(sp)
81139780:	df000017 	ldw	fp,0(sp)
81139784:	dec00204 	addi	sp,sp,8
81139788:	f800283a 	ret

8113978c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8113978c:	defff804 	addi	sp,sp,-32
81139790:	de00012e 	bgeu	sp,et,81139798 <OS_InitTaskStat+0xc>
81139794:	003b68fa 	trap	3
81139798:	dfc00715 	stw	ra,28(sp)
8113979c:	df000615 	stw	fp,24(sp)
811397a0:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
811397a4:	008000c4 	movi	r2,3
811397a8:	d8800415 	stw	r2,16(sp)
811397ac:	d8000315 	stw	zero,12(sp)
811397b0:	00810004 	movi	r2,1024
811397b4:	d8800215 	stw	r2,8(sp)
811397b8:	00a045f4 	movhi	r2,33047
811397bc:	10a08904 	addi	r2,r2,-32220
811397c0:	d8800115 	stw	r2,4(sp)
811397c4:	00bfff94 	movui	r2,65534
811397c8:	d8800015 	stw	r2,0(sp)
811397cc:	01c00a44 	movi	r7,41
811397d0:	01a045f4 	movhi	r6,33047
811397d4:	31a48804 	addi	r6,r6,-28128
811397d8:	000b883a 	mov	r5,zero
811397dc:	01204534 	movhi	r4,33044
811397e0:	21271704 	addi	r4,r4,-25508
811397e4:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
811397e8:	e1bfff04 	addi	r6,fp,-4
811397ec:	01604574 	movhi	r5,33045
811397f0:	2943bc04 	addi	r5,r5,3824
811397f4:	01000a44 	movi	r4,41
811397f8:	113fe180 	call	8113fe18 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
811397fc:	0001883a 	nop
81139800:	e037883a 	mov	sp,fp
81139804:	dfc00117 	ldw	ra,4(sp)
81139808:	df000017 	ldw	fp,0(sp)
8113980c:	dec00204 	addi	sp,sp,8
81139810:	f800283a 	ret

81139814 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81139814:	defffb04 	addi	sp,sp,-20
81139818:	de00012e 	bgeu	sp,et,81139820 <OS_InitTCBList+0xc>
8113981c:	003b68fa 	trap	3
81139820:	dfc00415 	stw	ra,16(sp)
81139824:	df000315 	stw	fp,12(sp)
81139828:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
8113982c:	01446e04 	movi	r5,4536
81139830:	012045f4 	movhi	r4,33047
81139834:	212e8904 	addi	r4,r4,-17884
81139838:	11399000 	call	81139900 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
8113983c:	01402b04 	movi	r5,172
81139840:	012045f4 	movhi	r4,33047
81139844:	2132f704 	addi	r4,r4,-13348
81139848:	11399000 	call	81139900 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
8113984c:	00a045f4 	movhi	r2,33047
81139850:	10ae8904 	addi	r2,r2,-17884
81139854:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81139858:	00a045f4 	movhi	r2,33047
8113985c:	10aea404 	addi	r2,r2,-17776
81139860:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81139864:	e03ffd05 	stb	zero,-12(fp)
81139868:	00001106 	br	811398b0 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
8113986c:	e0bffe17 	ldw	r2,-8(fp)
81139870:	e0ffff17 	ldw	r3,-4(fp)
81139874:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81139878:	e0bffe17 	ldw	r2,-8(fp)
8113987c:	00c00fc4 	movi	r3,63
81139880:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81139884:	e0bffe17 	ldw	r2,-8(fp)
81139888:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
8113988c:	e0bffe17 	ldw	r2,-8(fp)
81139890:	10801b04 	addi	r2,r2,108
81139894:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81139898:	e0bfff17 	ldw	r2,-4(fp)
8113989c:	10801b04 	addi	r2,r2,108
811398a0:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
811398a4:	e0bffd03 	ldbu	r2,-12(fp)
811398a8:	10800044 	addi	r2,r2,1
811398ac:	e0bffd05 	stb	r2,-12(fp)
811398b0:	e0bffd03 	ldbu	r2,-12(fp)
811398b4:	10800a70 	cmpltui	r2,r2,41
811398b8:	103fec1e 	bne	r2,zero,8113986c <__reset+0xfb11986c>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
811398bc:	e0bffe17 	ldw	r2,-8(fp)
811398c0:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
811398c4:	e0bffe17 	ldw	r2,-8(fp)
811398c8:	00c00fc4 	movi	r3,63
811398cc:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
811398d0:	e0bffe17 	ldw	r2,-8(fp)
811398d4:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
811398d8:	d0209415 	stw	zero,-32176(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
811398dc:	00a045f4 	movhi	r2,33047
811398e0:	10ae8904 	addi	r2,r2,-17884
811398e4:	d0a09915 	stw	r2,-32156(gp)
}
811398e8:	0001883a 	nop
811398ec:	e037883a 	mov	sp,fp
811398f0:	dfc00117 	ldw	ra,4(sp)
811398f4:	df000017 	ldw	fp,0(sp)
811398f8:	dec00204 	addi	sp,sp,8
811398fc:	f800283a 	ret

81139900 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81139900:	defffd04 	addi	sp,sp,-12
81139904:	de00012e 	bgeu	sp,et,8113990c <OS_MemClr+0xc>
81139908:	003b68fa 	trap	3
8113990c:	df000215 	stw	fp,8(sp)
81139910:	df000204 	addi	fp,sp,8
81139914:	e13ffe15 	stw	r4,-8(fp)
81139918:	2805883a 	mov	r2,r5
8113991c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81139920:	00000706 	br	81139940 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81139924:	e0bffe17 	ldw	r2,-8(fp)
81139928:	10c00044 	addi	r3,r2,1
8113992c:	e0fffe15 	stw	r3,-8(fp)
81139930:	10000005 	stb	zero,0(r2)
        size--;
81139934:	e0bfff0b 	ldhu	r2,-4(fp)
81139938:	10bfffc4 	addi	r2,r2,-1
8113993c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81139940:	e0bfff0b 	ldhu	r2,-4(fp)
81139944:	103ff71e 	bne	r2,zero,81139924 <__reset+0xfb119924>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81139948:	0001883a 	nop
8113994c:	e037883a 	mov	sp,fp
81139950:	df000017 	ldw	fp,0(sp)
81139954:	dec00104 	addi	sp,sp,4
81139958:	f800283a 	ret

8113995c <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
8113995c:	defffc04 	addi	sp,sp,-16
81139960:	de00012e 	bgeu	sp,et,81139968 <OS_MemCopy+0xc>
81139964:	003b68fa 	trap	3
81139968:	df000315 	stw	fp,12(sp)
8113996c:	df000304 	addi	fp,sp,12
81139970:	e13ffd15 	stw	r4,-12(fp)
81139974:	e17ffe15 	stw	r5,-8(fp)
81139978:	3005883a 	mov	r2,r6
8113997c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81139980:	00000b06 	br	811399b0 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81139984:	e0bffd17 	ldw	r2,-12(fp)
81139988:	10c00044 	addi	r3,r2,1
8113998c:	e0fffd15 	stw	r3,-12(fp)
81139990:	e0fffe17 	ldw	r3,-8(fp)
81139994:	19000044 	addi	r4,r3,1
81139998:	e13ffe15 	stw	r4,-8(fp)
8113999c:	18c00003 	ldbu	r3,0(r3)
811399a0:	10c00005 	stb	r3,0(r2)
        size--;
811399a4:	e0bfff0b 	ldhu	r2,-4(fp)
811399a8:	10bfffc4 	addi	r2,r2,-1
811399ac:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
811399b0:	e0bfff0b 	ldhu	r2,-4(fp)
811399b4:	103ff31e 	bne	r2,zero,81139984 <__reset+0xfb119984>
        *pdest++ = *psrc++;
        size--;
    }
}
811399b8:	0001883a 	nop
811399bc:	e037883a 	mov	sp,fp
811399c0:	df000017 	ldw	fp,0(sp)
811399c4:	dec00104 	addi	sp,sp,4
811399c8:	f800283a 	ret

811399cc <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
811399cc:	defffb04 	addi	sp,sp,-20
811399d0:	de00012e 	bgeu	sp,et,811399d8 <OS_Sched+0xc>
811399d4:	003b68fa 	trap	3
811399d8:	dfc00415 	stw	ra,16(sp)
811399dc:	df000315 	stw	fp,12(sp)
811399e0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811399e4:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811399e8:	0005303a 	rdctl	r2,status
811399ec:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811399f0:	e0ffff17 	ldw	r3,-4(fp)
811399f4:	00bfff84 	movi	r2,-2
811399f8:	1884703a 	and	r2,r3,r2
811399fc:	1001703a 	wrctl	status,r2
  
  return context;
81139a00:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81139a04:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81139a08:	d0a0a103 	ldbu	r2,-32124(gp)
81139a0c:	10803fcc 	andi	r2,r2,255
81139a10:	10001a1e 	bne	r2,zero,81139a7c <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81139a14:	d0a08f03 	ldbu	r2,-32196(gp)
81139a18:	10803fcc 	andi	r2,r2,255
81139a1c:	1000171e 	bne	r2,zero,81139a7c <OS_Sched+0xb0>
            OS_SchedNew();
81139a20:	1139aa40 	call	81139aa4 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81139a24:	d0e09383 	ldbu	r3,-32178(gp)
81139a28:	d0a093c3 	ldbu	r2,-32177(gp)
81139a2c:	18c03fcc 	andi	r3,r3,255
81139a30:	10803fcc 	andi	r2,r2,255
81139a34:	18801126 	beq	r3,r2,81139a7c <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81139a38:	d0a09383 	ldbu	r2,-32178(gp)
81139a3c:	10c03fcc 	andi	r3,r2,255
81139a40:	00a045f4 	movhi	r2,33047
81139a44:	10b2f704 	addi	r2,r2,-13348
81139a48:	18c7883a 	add	r3,r3,r3
81139a4c:	18c7883a 	add	r3,r3,r3
81139a50:	10c5883a 	add	r2,r2,r3
81139a54:	10800017 	ldw	r2,0(r2)
81139a58:	d0a09c15 	stw	r2,-32144(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
81139a5c:	d0a09c17 	ldw	r2,-32144(gp)
81139a60:	10c00e17 	ldw	r3,56(r2)
81139a64:	18c00044 	addi	r3,r3,1
81139a68:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
81139a6c:	d0a09617 	ldw	r2,-32168(gp)
81139a70:	10800044 	addi	r2,r2,1
81139a74:	d0a09615 	stw	r2,-32168(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81139a78:	114a9fc0 	call	8114a9fc <OSCtxSw>
81139a7c:	e0bffd17 	ldw	r2,-12(fp)
81139a80:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139a84:	e0bffe17 	ldw	r2,-8(fp)
81139a88:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81139a8c:	0001883a 	nop
81139a90:	e037883a 	mov	sp,fp
81139a94:	dfc00117 	ldw	ra,4(sp)
81139a98:	df000017 	ldw	fp,0(sp)
81139a9c:	dec00204 	addi	sp,sp,8
81139aa0:	f800283a 	ret

81139aa4 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81139aa4:	defffe04 	addi	sp,sp,-8
81139aa8:	de00012e 	bgeu	sp,et,81139ab0 <OS_SchedNew+0xc>
81139aac:	003b68fa 	trap	3
81139ab0:	df000115 	stw	fp,4(sp)
81139ab4:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
81139ab8:	d0a09e03 	ldbu	r2,-32136(gp)
81139abc:	10c03fcc 	andi	r3,r2,255
81139ac0:	00a04574 	movhi	r2,33045
81139ac4:	10837804 	addi	r2,r2,3552
81139ac8:	10c5883a 	add	r2,r2,r3
81139acc:	10800003 	ldbu	r2,0(r2)
81139ad0:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81139ad4:	e0bfff03 	ldbu	r2,-4(fp)
81139ad8:	100490fa 	slli	r2,r2,3
81139adc:	1009883a 	mov	r4,r2
81139ae0:	e0ffff03 	ldbu	r3,-4(fp)
81139ae4:	d0a09e44 	addi	r2,gp,-32135
81139ae8:	1885883a 	add	r2,r3,r2
81139aec:	10800003 	ldbu	r2,0(r2)
81139af0:	10c03fcc 	andi	r3,r2,255
81139af4:	00a04574 	movhi	r2,33045
81139af8:	10837804 	addi	r2,r2,3552
81139afc:	10c5883a 	add	r2,r2,r3
81139b00:	10800003 	ldbu	r2,0(r2)
81139b04:	2085883a 	add	r2,r4,r2
81139b08:	d0a09385 	stb	r2,-32178(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81139b0c:	0001883a 	nop
81139b10:	e037883a 	mov	sp,fp
81139b14:	df000017 	ldw	fp,0(sp)
81139b18:	dec00104 	addi	sp,sp,4
81139b1c:	f800283a 	ret

81139b20 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81139b20:	defffc04 	addi	sp,sp,-16
81139b24:	de00012e 	bgeu	sp,et,81139b2c <OS_StrCopy+0xc>
81139b28:	003b68fa 	trap	3
81139b2c:	df000315 	stw	fp,12(sp)
81139b30:	df000304 	addi	fp,sp,12
81139b34:	e13ffe15 	stw	r4,-8(fp)
81139b38:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81139b3c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81139b40:	00000b06 	br	81139b70 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81139b44:	e0bffe17 	ldw	r2,-8(fp)
81139b48:	10c00044 	addi	r3,r2,1
81139b4c:	e0fffe15 	stw	r3,-8(fp)
81139b50:	e0ffff17 	ldw	r3,-4(fp)
81139b54:	19000044 	addi	r4,r3,1
81139b58:	e13fff15 	stw	r4,-4(fp)
81139b5c:	18c00003 	ldbu	r3,0(r3)
81139b60:	10c00005 	stb	r3,0(r2)
        len++;
81139b64:	e0bffd03 	ldbu	r2,-12(fp)
81139b68:	10800044 	addi	r2,r2,1
81139b6c:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81139b70:	e0bfff17 	ldw	r2,-4(fp)
81139b74:	10800003 	ldbu	r2,0(r2)
81139b78:	10803fcc 	andi	r2,r2,255
81139b7c:	103ff11e 	bne	r2,zero,81139b44 <__reset+0xfb119b44>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
81139b80:	e0bffe17 	ldw	r2,-8(fp)
81139b84:	10000005 	stb	zero,0(r2)
    return (len);
81139b88:	e0bffd03 	ldbu	r2,-12(fp)
}
81139b8c:	e037883a 	mov	sp,fp
81139b90:	df000017 	ldw	fp,0(sp)
81139b94:	dec00104 	addi	sp,sp,4
81139b98:	f800283a 	ret

81139b9c <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81139b9c:	defffd04 	addi	sp,sp,-12
81139ba0:	de00012e 	bgeu	sp,et,81139ba8 <OS_StrLen+0xc>
81139ba4:	003b68fa 	trap	3
81139ba8:	df000215 	stw	fp,8(sp)
81139bac:	df000204 	addi	fp,sp,8
81139bb0:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81139bb4:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81139bb8:	00000606 	br	81139bd4 <OS_StrLen+0x38>
        psrc++;
81139bbc:	e0bfff17 	ldw	r2,-4(fp)
81139bc0:	10800044 	addi	r2,r2,1
81139bc4:	e0bfff15 	stw	r2,-4(fp)
        len++;
81139bc8:	e0bffe03 	ldbu	r2,-8(fp)
81139bcc:	10800044 	addi	r2,r2,1
81139bd0:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81139bd4:	e0bfff17 	ldw	r2,-4(fp)
81139bd8:	10800003 	ldbu	r2,0(r2)
81139bdc:	10803fcc 	andi	r2,r2,255
81139be0:	103ff61e 	bne	r2,zero,81139bbc <__reset+0xfb119bbc>
        psrc++;
        len++;
    }
    return (len);
81139be4:	e0bffe03 	ldbu	r2,-8(fp)
}
81139be8:	e037883a 	mov	sp,fp
81139bec:	df000017 	ldw	fp,0(sp)
81139bf0:	dec00104 	addi	sp,sp,4
81139bf4:	f800283a 	ret

81139bf8 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81139bf8:	defffa04 	addi	sp,sp,-24
81139bfc:	de00012e 	bgeu	sp,et,81139c04 <OS_TaskIdle+0xc>
81139c00:	003b68fa 	trap	3
81139c04:	dfc00515 	stw	ra,20(sp)
81139c08:	df000415 	stw	fp,16(sp)
81139c0c:	df000404 	addi	fp,sp,16
81139c10:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139c14:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139c18:	0005303a 	rdctl	r2,status
81139c1c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139c20:	e0fffd17 	ldw	r3,-12(fp)
81139c24:	00bfff84 	movi	r2,-2
81139c28:	1884703a 	and	r2,r3,r2
81139c2c:	1001703a 	wrctl	status,r2
  
  return context;
81139c30:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81139c34:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81139c38:	d0a09217 	ldw	r2,-32184(gp)
81139c3c:	10800044 	addi	r2,r2,1
81139c40:	d0a09215 	stw	r2,-32184(gp)
81139c44:	e0bffc17 	ldw	r2,-16(fp)
81139c48:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139c4c:	e0bffe17 	ldw	r2,-8(fp)
81139c50:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81139c54:	114ad900 	call	8114ad90 <OSTaskIdleHook>
    }
81139c58:	003fef06 	br	81139c18 <__reset+0xfb119c18>

81139c5c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
81139c5c:	defff804 	addi	sp,sp,-32
81139c60:	de00012e 	bgeu	sp,et,81139c68 <OS_TaskStat+0xc>
81139c64:	003b68fa 	trap	3
81139c68:	dfc00715 	stw	ra,28(sp)
81139c6c:	df000615 	stw	fp,24(sp)
81139c70:	dc400515 	stw	r17,20(sp)
81139c74:	dc000415 	stw	r16,16(sp)
81139c78:	df000604 	addi	fp,sp,24
81139c7c:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139c80:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81139c84:	00000206 	br	81139c90 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81139c88:	01003204 	movi	r4,200
81139c8c:	11407080 	call	81140708 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81139c90:	d0a0a703 	ldbu	r2,-32100(gp)
81139c94:	10803fcc 	andi	r2,r2,255
81139c98:	103ffb26 	beq	r2,zero,81139c88 <__reset+0xfb119c88>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81139c9c:	d0e09817 	ldw	r3,-32160(gp)
81139ca0:	00947b34 	movhi	r2,20972
81139ca4:	10a147c4 	addi	r2,r2,-31457
81139ca8:	1888383a 	mulxuu	r4,r3,r2
81139cac:	1885383a 	mul	r2,r3,r2
81139cb0:	1021883a 	mov	r16,r2
81139cb4:	2023883a 	mov	r17,r4
81139cb8:	8804d17a 	srli	r2,r17,5
81139cbc:	d0a09815 	stw	r2,-32160(gp)
    if (OSIdleCtrMax == 0L) {
81139cc0:	d0a09817 	ldw	r2,-32160(gp)
81139cc4:	1000031e 	bne	r2,zero,81139cd4 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81139cc8:	d0209a05 	stb	zero,-32152(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81139ccc:	01003fc4 	movi	r4,255
81139cd0:	11403780 	call	81140378 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139cd4:	0005303a 	rdctl	r2,status
81139cd8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139cdc:	e0fffb17 	ldw	r3,-20(fp)
81139ce0:	00bfff84 	movi	r2,-2
81139ce4:	1884703a 	and	r2,r3,r2
81139ce8:	1001703a 	wrctl	status,r2
  
  return context;
81139cec:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81139cf0:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81139cf4:	d0a09217 	ldw	r2,-32184(gp)
81139cf8:	d0a0a815 	stw	r2,-32096(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81139cfc:	d0209215 	stw	zero,-32184(gp)
81139d00:	e0bffa17 	ldw	r2,-24(fp)
81139d04:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139d08:	e0bffc17 	ldw	r2,-16(fp)
81139d0c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81139d10:	d0e0a817 	ldw	r3,-32096(gp)
81139d14:	d0a09817 	ldw	r2,-32160(gp)
81139d18:	1885203a 	divu	r2,r3,r2
81139d1c:	1007883a 	mov	r3,r2
81139d20:	00801904 	movi	r2,100
81139d24:	10c5c83a 	sub	r2,r2,r3
81139d28:	d0a09a05 	stb	r2,-32152(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81139d2c:	114acc00 	call	8114acc0 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81139d30:	1139d400 	call	81139d40 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81139d34:	01001904 	movi	r4,100
81139d38:	11407080 	call	81140708 <OSTimeDly>
    }
81139d3c:	003fe506 	br	81139cd4 <__reset+0xfb119cd4>

81139d40 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81139d40:	defffa04 	addi	sp,sp,-24
81139d44:	de00012e 	bgeu	sp,et,81139d4c <OS_TaskStatStkChk+0xc>
81139d48:	003b68fa 	trap	3
81139d4c:	dfc00515 	stw	ra,20(sp)
81139d50:	df000415 	stw	fp,16(sp)
81139d54:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81139d58:	e03ffc05 	stb	zero,-16(fp)
81139d5c:	00002406 	br	81139df0 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
81139d60:	e0bffc03 	ldbu	r2,-16(fp)
81139d64:	e0fffe04 	addi	r3,fp,-8
81139d68:	180b883a 	mov	r5,r3
81139d6c:	1009883a 	mov	r4,r2
81139d70:	11401b00 	call	811401b0 <OSTaskStkChk>
81139d74:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
81139d78:	e0bffc43 	ldbu	r2,-15(fp)
81139d7c:	1000191e 	bne	r2,zero,81139de4 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
81139d80:	e0fffc03 	ldbu	r3,-16(fp)
81139d84:	00a045f4 	movhi	r2,33047
81139d88:	10b2f704 	addi	r2,r2,-13348
81139d8c:	18c7883a 	add	r3,r3,r3
81139d90:	18c7883a 	add	r3,r3,r3
81139d94:	10c5883a 	add	r2,r2,r3
81139d98:	10800017 	ldw	r2,0(r2)
81139d9c:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
81139da0:	e0bffd17 	ldw	r2,-12(fp)
81139da4:	10000f26 	beq	r2,zero,81139de4 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81139da8:	e0bffd17 	ldw	r2,-12(fp)
81139dac:	10800060 	cmpeqi	r2,r2,1
81139db0:	10000c1e 	bne	r2,zero,81139de4 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
81139db4:	e0bffd17 	ldw	r2,-12(fp)
81139db8:	10c00217 	ldw	r3,8(r2)
81139dbc:	e0bffd17 	ldw	r2,-12(fp)
81139dc0:	10800317 	ldw	r2,12(r2)
81139dc4:	1085883a 	add	r2,r2,r2
81139dc8:	1085883a 	add	r2,r2,r2
81139dcc:	1887883a 	add	r3,r3,r2
81139dd0:	e0bffd17 	ldw	r2,-12(fp)
81139dd4:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81139dd8:	e0ffff17 	ldw	r3,-4(fp)
81139ddc:	e0bffd17 	ldw	r2,-12(fp)
81139de0:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81139de4:	e0bffc03 	ldbu	r2,-16(fp)
81139de8:	10800044 	addi	r2,r2,1
81139dec:	e0bffc05 	stb	r2,-16(fp)
81139df0:	e0bffc03 	ldbu	r2,-16(fp)
81139df4:	10800af0 	cmpltui	r2,r2,43
81139df8:	103fd91e 	bne	r2,zero,81139d60 <__reset+0xfb119d60>
#endif
                }
            }
        }
    }
}
81139dfc:	0001883a 	nop
81139e00:	e037883a 	mov	sp,fp
81139e04:	dfc00117 	ldw	ra,4(sp)
81139e08:	df000017 	ldw	fp,0(sp)
81139e0c:	dec00204 	addi	sp,sp,8
81139e10:	f800283a 	ret

81139e14 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81139e14:	defff204 	addi	sp,sp,-56
81139e18:	de00012e 	bgeu	sp,et,81139e20 <OS_TCBInit+0xc>
81139e1c:	003b68fa 	trap	3
81139e20:	dfc00d15 	stw	ra,52(sp)
81139e24:	df000c15 	stw	fp,48(sp)
81139e28:	df000c04 	addi	fp,sp,48
81139e2c:	e17ffc15 	stw	r5,-16(fp)
81139e30:	e1bffd15 	stw	r6,-12(fp)
81139e34:	3807883a 	mov	r3,r7
81139e38:	e0800417 	ldw	r2,16(fp)
81139e3c:	e13ffb05 	stb	r4,-20(fp)
81139e40:	e0fffe0d 	sth	r3,-8(fp)
81139e44:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139e48:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139e4c:	0005303a 	rdctl	r2,status
81139e50:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139e54:	e0fffa17 	ldw	r3,-24(fp)
81139e58:	00bfff84 	movi	r2,-2
81139e5c:	1884703a 	and	r2,r3,r2
81139e60:	1001703a 	wrctl	status,r2
  
  return context;
81139e64:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
81139e68:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
81139e6c:	d0a09917 	ldw	r2,-32156(gp)
81139e70:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
81139e74:	e0bff617 	ldw	r2,-40(fp)
81139e78:	10009326 	beq	r2,zero,8113a0c8 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
81139e7c:	e0bff617 	ldw	r2,-40(fp)
81139e80:	10800517 	ldw	r2,20(r2)
81139e84:	d0a09915 	stw	r2,-32156(gp)
81139e88:	e0bff417 	ldw	r2,-48(fp)
81139e8c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139e90:	e0bff817 	ldw	r2,-32(fp)
81139e94:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81139e98:	e0bff617 	ldw	r2,-40(fp)
81139e9c:	e0fffc17 	ldw	r3,-16(fp)
81139ea0:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81139ea4:	e0bff617 	ldw	r2,-40(fp)
81139ea8:	e0fffb03 	ldbu	r3,-20(fp)
81139eac:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
81139eb0:	e0bff617 	ldw	r2,-40(fp)
81139eb4:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81139eb8:	e0bff617 	ldw	r2,-40(fp)
81139ebc:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
81139ec0:	e0bff617 	ldw	r2,-40(fp)
81139ec4:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81139ec8:	e0bff617 	ldw	r2,-40(fp)
81139ecc:	e0c00317 	ldw	r3,12(fp)
81139ed0:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81139ed4:	e0bff617 	ldw	r2,-40(fp)
81139ed8:	e0c00217 	ldw	r3,8(fp)
81139edc:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
81139ee0:	e0bff617 	ldw	r2,-40(fp)
81139ee4:	e0fffd17 	ldw	r3,-12(fp)
81139ee8:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81139eec:	e0bff617 	ldw	r2,-40(fp)
81139ef0:	e0ffff0b 	ldhu	r3,-4(fp)
81139ef4:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81139ef8:	e0bff617 	ldw	r2,-40(fp)
81139efc:	e0fffe0b 	ldhu	r3,-8(fp)
81139f00:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
81139f04:	e0bff617 	ldw	r2,-40(fp)
81139f08:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81139f0c:	e0bffb03 	ldbu	r2,-20(fp)
81139f10:	1004d0fa 	srli	r2,r2,3
81139f14:	1007883a 	mov	r3,r2
81139f18:	e0bff617 	ldw	r2,-40(fp)
81139f1c:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
81139f20:	e0bffb03 	ldbu	r2,-20(fp)
81139f24:	108001cc 	andi	r2,r2,7
81139f28:	1007883a 	mov	r3,r2
81139f2c:	e0bff617 	ldw	r2,-40(fp)
81139f30:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
81139f34:	e0bff617 	ldw	r2,-40(fp)
81139f38:	10800d03 	ldbu	r2,52(r2)
81139f3c:	10803fcc 	andi	r2,r2,255
81139f40:	00c00044 	movi	r3,1
81139f44:	1884983a 	sll	r2,r3,r2
81139f48:	1007883a 	mov	r3,r2
81139f4c:	e0bff617 	ldw	r2,-40(fp)
81139f50:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
81139f54:	e0bff617 	ldw	r2,-40(fp)
81139f58:	10800cc3 	ldbu	r2,51(r2)
81139f5c:	10803fcc 	andi	r2,r2,255
81139f60:	00c00044 	movi	r3,1
81139f64:	1884983a 	sll	r2,r3,r2
81139f68:	1007883a 	mov	r3,r2
81139f6c:	e0bff617 	ldw	r2,-40(fp)
81139f70:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
81139f74:	e0bff617 	ldw	r2,-40(fp)
81139f78:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
81139f7c:	e0bff617 	ldw	r2,-40(fp)
81139f80:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81139f84:	e0bff617 	ldw	r2,-40(fp)
81139f88:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81139f8c:	e0bff617 	ldw	r2,-40(fp)
81139f90:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81139f94:	e0bff617 	ldw	r2,-40(fp)
81139f98:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81139f9c:	e0bff617 	ldw	r2,-40(fp)
81139fa0:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81139fa4:	e0bff617 	ldw	r2,-40(fp)
81139fa8:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81139fac:	e0bff617 	ldw	r2,-40(fp)
81139fb0:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81139fb4:	e0bff617 	ldw	r2,-40(fp)
81139fb8:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81139fbc:	e0bff617 	ldw	r2,-40(fp)
81139fc0:	00c00fc4 	movi	r3,63
81139fc4:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81139fc8:	e0bff617 	ldw	r2,-40(fp)
81139fcc:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
81139fd0:	e13ff617 	ldw	r4,-40(fp)
81139fd4:	114adb80 	call	8114adb8 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81139fd8:	e13ff617 	ldw	r4,-40(fp)
81139fdc:	114ac400 	call	8114ac40 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139fe0:	0005303a 	rdctl	r2,status
81139fe4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139fe8:	e0fff517 	ldw	r3,-44(fp)
81139fec:	00bfff84 	movi	r2,-2
81139ff0:	1884703a 	and	r2,r3,r2
81139ff4:	1001703a 	wrctl	status,r2
  
  return context;
81139ff8:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81139ffc:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113a000:	e0fffb03 	ldbu	r3,-20(fp)
8113a004:	00a045f4 	movhi	r2,33047
8113a008:	10b2f704 	addi	r2,r2,-13348
8113a00c:	18c7883a 	add	r3,r3,r3
8113a010:	18c7883a 	add	r3,r3,r3
8113a014:	10c5883a 	add	r2,r2,r3
8113a018:	e0fff617 	ldw	r3,-40(fp)
8113a01c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113a020:	d0e09417 	ldw	r3,-32176(gp)
8113a024:	e0bff617 	ldw	r2,-40(fp)
8113a028:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
8113a02c:	e0bff617 	ldw	r2,-40(fp)
8113a030:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8113a034:	d0a09417 	ldw	r2,-32176(gp)
8113a038:	10000326 	beq	r2,zero,8113a048 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
8113a03c:	d0a09417 	ldw	r2,-32176(gp)
8113a040:	e0fff617 	ldw	r3,-40(fp)
8113a044:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
8113a048:	e0bff617 	ldw	r2,-40(fp)
8113a04c:	d0a09415 	stw	r2,-32176(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8113a050:	e0bff617 	ldw	r2,-40(fp)
8113a054:	10c00d83 	ldbu	r3,54(r2)
8113a058:	d0a09e03 	ldbu	r2,-32136(gp)
8113a05c:	1884b03a 	or	r2,r3,r2
8113a060:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113a064:	e0bff617 	ldw	r2,-40(fp)
8113a068:	10800d03 	ldbu	r2,52(r2)
8113a06c:	10c03fcc 	andi	r3,r2,255
8113a070:	e0bff617 	ldw	r2,-40(fp)
8113a074:	10800d03 	ldbu	r2,52(r2)
8113a078:	11003fcc 	andi	r4,r2,255
8113a07c:	d0a09e44 	addi	r2,gp,-32135
8113a080:	2085883a 	add	r2,r4,r2
8113a084:	11000003 	ldbu	r4,0(r2)
8113a088:	e0bff617 	ldw	r2,-40(fp)
8113a08c:	10800d43 	ldbu	r2,53(r2)
8113a090:	2084b03a 	or	r2,r4,r2
8113a094:	1009883a 	mov	r4,r2
8113a098:	d0a09e44 	addi	r2,gp,-32135
8113a09c:	1885883a 	add	r2,r3,r2
8113a0a0:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8113a0a4:	d0a09a43 	ldbu	r2,-32151(gp)
8113a0a8:	10800044 	addi	r2,r2,1
8113a0ac:	d0a09a45 	stb	r2,-32151(gp)
8113a0b0:	e0bff417 	ldw	r2,-48(fp)
8113a0b4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a0b8:	e0bff717 	ldw	r2,-36(fp)
8113a0bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113a0c0:	0005883a 	mov	r2,zero
8113a0c4:	00000506 	br	8113a0dc <OS_TCBInit+0x2c8>
8113a0c8:	e0bff417 	ldw	r2,-48(fp)
8113a0cc:	e0bff915 	stw	r2,-28(fp)
8113a0d0:	e0bff917 	ldw	r2,-28(fp)
8113a0d4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
8113a0d8:	00801084 	movi	r2,66
}
8113a0dc:	e037883a 	mov	sp,fp
8113a0e0:	dfc00117 	ldw	ra,4(sp)
8113a0e4:	df000017 	ldw	fp,0(sp)
8113a0e8:	dec00204 	addi	sp,sp,8
8113a0ec:	f800283a 	ret

8113a0f0 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8113a0f0:	defffe04 	addi	sp,sp,-8
8113a0f4:	de00012e 	bgeu	sp,et,8113a0fc <OSDebugInit+0xc>
8113a0f8:	003b68fa 	trap	3
8113a0fc:	df000115 	stw	fp,4(sp)
8113a100:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8113a104:	d0a01804 	addi	r2,gp,-32672
8113a108:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8113a10c:	d0a01904 	addi	r2,gp,-32668
8113a110:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8113a114:	d0a01a84 	addi	r2,gp,-32662
8113a118:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8113a11c:	d0a01b04 	addi	r2,gp,-32660
8113a120:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8113a124:	d0a01a04 	addi	r2,gp,-32664
8113a128:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
8113a12c:	d0a01b84 	addi	r2,gp,-32658
8113a130:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8113a134:	d0a01c04 	addi	r2,gp,-32656
8113a138:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
8113a13c:	d0a01c84 	addi	r2,gp,-32654
8113a140:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8113a144:	d0a01d04 	addi	r2,gp,-32652
8113a148:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8113a14c:	d0a01d84 	addi	r2,gp,-32650
8113a150:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
8113a154:	d0a01e04 	addi	r2,gp,-32648
8113a158:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8113a15c:	d0a01e84 	addi	r2,gp,-32646
8113a160:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
8113a164:	d0a01f04 	addi	r2,gp,-32644
8113a168:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8113a16c:	d0a01f84 	addi	r2,gp,-32642
8113a170:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
8113a174:	d0a02004 	addi	r2,gp,-32640
8113a178:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8113a17c:	d0a02084 	addi	r2,gp,-32638
8113a180:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
8113a184:	d0a02104 	addi	r2,gp,-32636
8113a188:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8113a18c:	d0a02184 	addi	r2,gp,-32634
8113a190:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8113a194:	d0a02204 	addi	r2,gp,-32632
8113a198:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8113a19c:	d0a02284 	addi	r2,gp,-32630
8113a1a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8113a1a4:	d0a02304 	addi	r2,gp,-32628
8113a1a8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8113a1ac:	d0a02384 	addi	r2,gp,-32626
8113a1b0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8113a1b4:	d0a02404 	addi	r2,gp,-32624
8113a1b8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8113a1bc:	d0a02484 	addi	r2,gp,-32622
8113a1c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8113a1c4:	d0a02504 	addi	r2,gp,-32620
8113a1c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8113a1cc:	d0a02584 	addi	r2,gp,-32618
8113a1d0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8113a1d4:	d0a02604 	addi	r2,gp,-32616
8113a1d8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8113a1dc:	d0a02684 	addi	r2,gp,-32614
8113a1e0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8113a1e4:	d0a02704 	addi	r2,gp,-32612
8113a1e8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8113a1ec:	d0a02784 	addi	r2,gp,-32610
8113a1f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8113a1f4:	d0a02804 	addi	r2,gp,-32608
8113a1f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8113a1fc:	d0a02884 	addi	r2,gp,-32606
8113a200:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8113a204:	d0a02904 	addi	r2,gp,-32604
8113a208:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8113a20c:	d0a02984 	addi	r2,gp,-32602
8113a210:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8113a214:	d0a02a04 	addi	r2,gp,-32600
8113a218:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8113a21c:	d0a02a84 	addi	r2,gp,-32598
8113a220:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8113a224:	d0a02b04 	addi	r2,gp,-32596
8113a228:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
8113a22c:	d0a02b84 	addi	r2,gp,-32594
8113a230:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8113a234:	d0a02c04 	addi	r2,gp,-32592
8113a238:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
8113a23c:	d0a02c84 	addi	r2,gp,-32590
8113a240:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8113a244:	d0a02d04 	addi	r2,gp,-32588
8113a248:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8113a24c:	d0a02d84 	addi	r2,gp,-32586
8113a250:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
8113a254:	d0a02e04 	addi	r2,gp,-32584
8113a258:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8113a25c:	d0a02e84 	addi	r2,gp,-32582
8113a260:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
8113a264:	00a045b4 	movhi	r2,33046
8113a268:	109d1504 	addi	r2,r2,29780
8113a26c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8113a270:	00a045b4 	movhi	r2,33046
8113a274:	109b0104 	addi	r2,r2,27652
8113a278:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8113a27c:	d0a02f84 	addi	r2,gp,-32578
8113a280:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
8113a284:	d0a03004 	addi	r2,gp,-32576
8113a288:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8113a28c:	d0a03084 	addi	r2,gp,-32574
8113a290:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8113a294:	d0a03104 	addi	r2,gp,-32572
8113a298:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8113a29c:	d0a03184 	addi	r2,gp,-32570
8113a2a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8113a2a4:	d0a03204 	addi	r2,gp,-32568
8113a2a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8113a2ac:	d0a03284 	addi	r2,gp,-32566
8113a2b0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8113a2b4:	d0a03304 	addi	r2,gp,-32564
8113a2b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8113a2bc:	d0a03384 	addi	r2,gp,-32562
8113a2c0:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8113a2c4:	d0a02f04 	addi	r2,gp,-32580
8113a2c8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8113a2cc:	d0a03404 	addi	r2,gp,-32560
8113a2d0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8113a2d4:	0001883a 	nop
8113a2d8:	e037883a 	mov	sp,fp
8113a2dc:	df000017 	ldw	fp,0(sp)
8113a2e0:	dec00104 	addi	sp,sp,4
8113a2e4:	f800283a 	ret

8113a2e8 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
8113a2e8:	defff204 	addi	sp,sp,-56
8113a2ec:	de00012e 	bgeu	sp,et,8113a2f4 <OSFlagAccept+0xc>
8113a2f0:	003b68fa 	trap	3
8113a2f4:	df000d15 	stw	fp,52(sp)
8113a2f8:	df000d04 	addi	fp,sp,52
8113a2fc:	e13ffc15 	stw	r4,-16(fp)
8113a300:	2807883a 	mov	r3,r5
8113a304:	3005883a 	mov	r2,r6
8113a308:	e1ffff15 	stw	r7,-4(fp)
8113a30c:	e0fffd0d 	sth	r3,-12(fp)
8113a310:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113a314:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a318:	e0bfff17 	ldw	r2,-4(fp)
8113a31c:	1000021e 	bne	r2,zero,8113a328 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113a320:	0005883a 	mov	r2,zero
8113a324:	0000b006 	br	8113a5e8 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113a328:	e0bffc17 	ldw	r2,-16(fp)
8113a32c:	1000051e 	bne	r2,zero,8113a344 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a330:	e0bfff17 	ldw	r2,-4(fp)
8113a334:	00c01b84 	movi	r3,110
8113a338:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a33c:	0005883a 	mov	r2,zero
8113a340:	0000a906 	br	8113a5e8 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113a344:	e0bffc17 	ldw	r2,-16(fp)
8113a348:	10800003 	ldbu	r2,0(r2)
8113a34c:	10803fcc 	andi	r2,r2,255
8113a350:	10800160 	cmpeqi	r2,r2,5
8113a354:	1000051e 	bne	r2,zero,8113a36c <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
8113a358:	e0bfff17 	ldw	r2,-4(fp)
8113a35c:	00c00044 	movi	r3,1
8113a360:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a364:	0005883a 	mov	r2,zero
8113a368:	00009f06 	br	8113a5e8 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113a36c:	e0fffe03 	ldbu	r3,-8(fp)
8113a370:	00bfe004 	movi	r2,-128
8113a374:	1884703a 	and	r2,r3,r2
8113a378:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8113a37c:	e0bff503 	ldbu	r2,-44(fp)
8113a380:	10000626 	beq	r2,zero,8113a39c <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
8113a384:	e0bffe03 	ldbu	r2,-8(fp)
8113a388:	10801fcc 	andi	r2,r2,127
8113a38c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113a390:	00800044 	movi	r2,1
8113a394:	e0bff385 	stb	r2,-50(fp)
8113a398:	00000106 	br	8113a3a0 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8113a39c:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113a3a0:	e0bfff17 	ldw	r2,-4(fp)
8113a3a4:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a3a8:	0005303a 	rdctl	r2,status
8113a3ac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a3b0:	e0fffb17 	ldw	r3,-20(fp)
8113a3b4:	00bfff84 	movi	r2,-2
8113a3b8:	1884703a 	and	r2,r3,r2
8113a3bc:	1001703a 	wrctl	status,r2
  
  return context;
8113a3c0:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113a3c4:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
8113a3c8:	e0bffe03 	ldbu	r2,-8(fp)
8113a3cc:	10c00060 	cmpeqi	r3,r2,1
8113a3d0:	18005f1e 	bne	r3,zero,8113a550 <OSFlagAccept+0x268>
8113a3d4:	10c00088 	cmpgei	r3,r2,2
8113a3d8:	1800021e 	bne	r3,zero,8113a3e4 <OSFlagAccept+0xfc>
8113a3dc:	10003f26 	beq	r2,zero,8113a4dc <OSFlagAccept+0x1f4>
8113a3e0:	00007706 	br	8113a5c0 <OSFlagAccept+0x2d8>
8113a3e4:	10c000a0 	cmpeqi	r3,r2,2
8113a3e8:	1800031e 	bne	r3,zero,8113a3f8 <OSFlagAccept+0x110>
8113a3ec:	108000e0 	cmpeqi	r2,r2,3
8113a3f0:	10001e1e 	bne	r2,zero,8113a46c <OSFlagAccept+0x184>
8113a3f4:	00007206 	br	8113a5c0 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113a3f8:	e0bffc17 	ldw	r2,-16(fp)
8113a3fc:	10c0020b 	ldhu	r3,8(r2)
8113a400:	e0bffd0b 	ldhu	r2,-12(fp)
8113a404:	1884703a 	and	r2,r3,r2
8113a408:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a40c:	e0fff30b 	ldhu	r3,-52(fp)
8113a410:	e0bffd0b 	ldhu	r2,-12(fp)
8113a414:	18800d1e 	bne	r3,r2,8113a44c <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a418:	e0bff383 	ldbu	r2,-50(fp)
8113a41c:	10800058 	cmpnei	r2,r2,1
8113a420:	10000d1e 	bne	r2,zero,8113a458 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113a424:	e0bffc17 	ldw	r2,-16(fp)
8113a428:	1080020b 	ldhu	r2,8(r2)
8113a42c:	1007883a 	mov	r3,r2
8113a430:	e0bff30b 	ldhu	r2,-52(fp)
8113a434:	0084303a 	nor	r2,zero,r2
8113a438:	1884703a 	and	r2,r3,r2
8113a43c:	1007883a 	mov	r3,r2
8113a440:	e0bffc17 	ldw	r2,-16(fp)
8113a444:	10c0020d 	sth	r3,8(r2)
8113a448:	00000306 	br	8113a458 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a44c:	e0bfff17 	ldw	r2,-4(fp)
8113a450:	00c01c04 	movi	r3,112
8113a454:	10c00005 	stb	r3,0(r2)
8113a458:	e0bff417 	ldw	r2,-48(fp)
8113a45c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a460:	e0bff617 	ldw	r2,-40(fp)
8113a464:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a468:	00005e06 	br	8113a5e4 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113a46c:	e0bffc17 	ldw	r2,-16(fp)
8113a470:	10c0020b 	ldhu	r3,8(r2)
8113a474:	e0bffd0b 	ldhu	r2,-12(fp)
8113a478:	1884703a 	and	r2,r3,r2
8113a47c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113a480:	e0bff30b 	ldhu	r2,-52(fp)
8113a484:	10000d26 	beq	r2,zero,8113a4bc <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a488:	e0bff383 	ldbu	r2,-50(fp)
8113a48c:	10800058 	cmpnei	r2,r2,1
8113a490:	10000d1e 	bne	r2,zero,8113a4c8 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113a494:	e0bffc17 	ldw	r2,-16(fp)
8113a498:	1080020b 	ldhu	r2,8(r2)
8113a49c:	1007883a 	mov	r3,r2
8113a4a0:	e0bff30b 	ldhu	r2,-52(fp)
8113a4a4:	0084303a 	nor	r2,zero,r2
8113a4a8:	1884703a 	and	r2,r3,r2
8113a4ac:	1007883a 	mov	r3,r2
8113a4b0:	e0bffc17 	ldw	r2,-16(fp)
8113a4b4:	10c0020d 	sth	r3,8(r2)
8113a4b8:	00000306 	br	8113a4c8 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a4bc:	e0bfff17 	ldw	r2,-4(fp)
8113a4c0:	00c01c04 	movi	r3,112
8113a4c4:	10c00005 	stb	r3,0(r2)
8113a4c8:	e0bff417 	ldw	r2,-48(fp)
8113a4cc:	e0bff715 	stw	r2,-36(fp)
8113a4d0:	e0bff717 	ldw	r2,-36(fp)
8113a4d4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a4d8:	00004206 	br	8113a5e4 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113a4dc:	e0bffc17 	ldw	r2,-16(fp)
8113a4e0:	1080020b 	ldhu	r2,8(r2)
8113a4e4:	0084303a 	nor	r2,zero,r2
8113a4e8:	1007883a 	mov	r3,r2
8113a4ec:	e0bffd0b 	ldhu	r2,-12(fp)
8113a4f0:	1884703a 	and	r2,r3,r2
8113a4f4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a4f8:	e0fff30b 	ldhu	r3,-52(fp)
8113a4fc:	e0bffd0b 	ldhu	r2,-12(fp)
8113a500:	18800b1e 	bne	r3,r2,8113a530 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a504:	e0bff383 	ldbu	r2,-50(fp)
8113a508:	10800058 	cmpnei	r2,r2,1
8113a50c:	10000b1e 	bne	r2,zero,8113a53c <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113a510:	e0bffc17 	ldw	r2,-16(fp)
8113a514:	10c0020b 	ldhu	r3,8(r2)
8113a518:	e0bff30b 	ldhu	r2,-52(fp)
8113a51c:	1884b03a 	or	r2,r3,r2
8113a520:	1007883a 	mov	r3,r2
8113a524:	e0bffc17 	ldw	r2,-16(fp)
8113a528:	10c0020d 	sth	r3,8(r2)
8113a52c:	00000306 	br	8113a53c <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a530:	e0bfff17 	ldw	r2,-4(fp)
8113a534:	00c01c04 	movi	r3,112
8113a538:	10c00005 	stb	r3,0(r2)
8113a53c:	e0bff417 	ldw	r2,-48(fp)
8113a540:	e0bff815 	stw	r2,-32(fp)
8113a544:	e0bff817 	ldw	r2,-32(fp)
8113a548:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a54c:	00002506 	br	8113a5e4 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113a550:	e0bffc17 	ldw	r2,-16(fp)
8113a554:	1080020b 	ldhu	r2,8(r2)
8113a558:	0084303a 	nor	r2,zero,r2
8113a55c:	1007883a 	mov	r3,r2
8113a560:	e0bffd0b 	ldhu	r2,-12(fp)
8113a564:	1884703a 	and	r2,r3,r2
8113a568:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113a56c:	e0bff30b 	ldhu	r2,-52(fp)
8113a570:	10000b26 	beq	r2,zero,8113a5a0 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a574:	e0bff383 	ldbu	r2,-50(fp)
8113a578:	10800058 	cmpnei	r2,r2,1
8113a57c:	10000b1e 	bne	r2,zero,8113a5ac <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113a580:	e0bffc17 	ldw	r2,-16(fp)
8113a584:	10c0020b 	ldhu	r3,8(r2)
8113a588:	e0bff30b 	ldhu	r2,-52(fp)
8113a58c:	1884b03a 	or	r2,r3,r2
8113a590:	1007883a 	mov	r3,r2
8113a594:	e0bffc17 	ldw	r2,-16(fp)
8113a598:	10c0020d 	sth	r3,8(r2)
8113a59c:	00000306 	br	8113a5ac <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113a5a0:	e0bfff17 	ldw	r2,-4(fp)
8113a5a4:	00c01c04 	movi	r3,112
8113a5a8:	10c00005 	stb	r3,0(r2)
8113a5ac:	e0bff417 	ldw	r2,-48(fp)
8113a5b0:	e0bff915 	stw	r2,-28(fp)
8113a5b4:	e0bff917 	ldw	r2,-28(fp)
8113a5b8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113a5bc:	00000906 	br	8113a5e4 <OSFlagAccept+0x2fc>
8113a5c0:	e0bff417 	ldw	r2,-48(fp)
8113a5c4:	e0bffa15 	stw	r2,-24(fp)
8113a5c8:	e0bffa17 	ldw	r2,-24(fp)
8113a5cc:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113a5d0:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8113a5d4:	e0bfff17 	ldw	r2,-4(fp)
8113a5d8:	00c01bc4 	movi	r3,111
8113a5dc:	10c00005 	stb	r3,0(r2)
             break;
8113a5e0:	0001883a 	nop
    }
    return (flags_rdy);
8113a5e4:	e0bff30b 	ldhu	r2,-52(fp)
}
8113a5e8:	e037883a 	mov	sp,fp
8113a5ec:	df000017 	ldw	fp,0(sp)
8113a5f0:	dec00104 	addi	sp,sp,4
8113a5f4:	f800283a 	ret

8113a5f8 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
8113a5f8:	defff804 	addi	sp,sp,-32
8113a5fc:	de00012e 	bgeu	sp,et,8113a604 <OSFlagCreate+0xc>
8113a600:	003b68fa 	trap	3
8113a604:	df000715 	stw	fp,28(sp)
8113a608:	df000704 	addi	fp,sp,28
8113a60c:	2005883a 	mov	r2,r4
8113a610:	e17fff15 	stw	r5,-4(fp)
8113a614:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
8113a618:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
8113a61c:	e0bfff17 	ldw	r2,-4(fp)
8113a620:	1000021e 	bne	r2,zero,8113a62c <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8113a624:	0005883a 	mov	r2,zero
8113a628:	00003306 	br	8113a6f8 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
8113a62c:	d0a0a103 	ldbu	r2,-32124(gp)
8113a630:	10803fcc 	andi	r2,r2,255
8113a634:	10000526 	beq	r2,zero,8113a64c <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
8113a638:	e0bfff17 	ldw	r2,-4(fp)
8113a63c:	00c00404 	movi	r3,16
8113a640:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
8113a644:	0005883a 	mov	r2,zero
8113a648:	00002b06 	br	8113a6f8 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a64c:	0005303a 	rdctl	r2,status
8113a650:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a654:	e0fffd17 	ldw	r3,-12(fp)
8113a658:	00bfff84 	movi	r2,-2
8113a65c:	1884703a 	and	r2,r3,r2
8113a660:	1001703a 	wrctl	status,r2
  
  return context;
8113a664:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a668:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113a66c:	d0a0a617 	ldw	r2,-32104(gp)
8113a670:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
8113a674:	e0bffb17 	ldw	r2,-20(fp)
8113a678:	10001726 	beq	r2,zero,8113a6d8 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113a67c:	d0a0a617 	ldw	r2,-32104(gp)
8113a680:	10800117 	ldw	r2,4(r2)
8113a684:	d0a0a615 	stw	r2,-32104(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
8113a688:	e0bffb17 	ldw	r2,-20(fp)
8113a68c:	00c00144 	movi	r3,5
8113a690:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8113a694:	e0bffb17 	ldw	r2,-20(fp)
8113a698:	e0fffe0b 	ldhu	r3,-8(fp)
8113a69c:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113a6a0:	e0bffb17 	ldw	r2,-20(fp)
8113a6a4:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
8113a6a8:	e0bffb17 	ldw	r2,-20(fp)
8113a6ac:	00c00fc4 	movi	r3,63
8113a6b0:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113a6b4:	e0bffb17 	ldw	r2,-20(fp)
8113a6b8:	100002c5 	stb	zero,11(r2)
8113a6bc:	e0bff917 	ldw	r2,-28(fp)
8113a6c0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a6c4:	e0bffa17 	ldw	r2,-24(fp)
8113a6c8:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8113a6cc:	e0bfff17 	ldw	r2,-4(fp)
8113a6d0:	10000005 	stb	zero,0(r2)
8113a6d4:	00000706 	br	8113a6f4 <OSFlagCreate+0xfc>
8113a6d8:	e0bff917 	ldw	r2,-28(fp)
8113a6dc:	e0bffc15 	stw	r2,-16(fp)
8113a6e0:	e0bffc17 	ldw	r2,-16(fp)
8113a6e4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
8113a6e8:	e0bfff17 	ldw	r2,-4(fp)
8113a6ec:	00c01c84 	movi	r3,114
8113a6f0:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8113a6f4:	e0bffb17 	ldw	r2,-20(fp)
}
8113a6f8:	e037883a 	mov	sp,fp
8113a6fc:	df000017 	ldw	fp,0(sp)
8113a700:	dec00104 	addi	sp,sp,4
8113a704:	f800283a 	ret

8113a708 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
8113a708:	defff204 	addi	sp,sp,-56
8113a70c:	de00012e 	bgeu	sp,et,8113a714 <OSFlagDel+0xc>
8113a710:	003b68fa 	trap	3
8113a714:	dfc00d15 	stw	ra,52(sp)
8113a718:	df000c15 	stw	fp,48(sp)
8113a71c:	df000c04 	addi	fp,sp,48
8113a720:	e13ffd15 	stw	r4,-12(fp)
8113a724:	2805883a 	mov	r2,r5
8113a728:	e1bfff15 	stw	r6,-4(fp)
8113a72c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113a730:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a734:	e0bfff17 	ldw	r2,-4(fp)
8113a738:	1000021e 	bne	r2,zero,8113a744 <OSFlagDel+0x3c>
        return (pgrp);
8113a73c:	e0bffd17 	ldw	r2,-12(fp)
8113a740:	00008006 	br	8113a944 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113a744:	e0bffd17 	ldw	r2,-12(fp)
8113a748:	1000051e 	bne	r2,zero,8113a760 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a74c:	e0bfff17 	ldw	r2,-4(fp)
8113a750:	00c01b84 	movi	r3,110
8113a754:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113a758:	e0bffd17 	ldw	r2,-12(fp)
8113a75c:	00007906 	br	8113a944 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a760:	d0a0a103 	ldbu	r2,-32124(gp)
8113a764:	10803fcc 	andi	r2,r2,255
8113a768:	10000526 	beq	r2,zero,8113a780 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113a76c:	e0bfff17 	ldw	r2,-4(fp)
8113a770:	00c003c4 	movi	r3,15
8113a774:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113a778:	e0bffd17 	ldw	r2,-12(fp)
8113a77c:	00007106 	br	8113a944 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8113a780:	e0bffd17 	ldw	r2,-12(fp)
8113a784:	10800003 	ldbu	r2,0(r2)
8113a788:	10803fcc 	andi	r2,r2,255
8113a78c:	10800160 	cmpeqi	r2,r2,5
8113a790:	1000051e 	bne	r2,zero,8113a7a8 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
8113a794:	e0bfff17 	ldw	r2,-4(fp)
8113a798:	00c00044 	movi	r3,1
8113a79c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113a7a0:	e0bffd17 	ldw	r2,-12(fp)
8113a7a4:	00006706 	br	8113a944 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a7a8:	0005303a 	rdctl	r2,status
8113a7ac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a7b0:	e0fffc17 	ldw	r3,-16(fp)
8113a7b4:	00bfff84 	movi	r2,-2
8113a7b8:	1884703a 	and	r2,r3,r2
8113a7bc:	1001703a 	wrctl	status,r2
  
  return context;
8113a7c0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a7c4:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
8113a7c8:	e0bffd17 	ldw	r2,-12(fp)
8113a7cc:	10800117 	ldw	r2,4(r2)
8113a7d0:	10000326 	beq	r2,zero,8113a7e0 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113a7d4:	00800044 	movi	r2,1
8113a7d8:	e0bff405 	stb	r2,-48(fp)
8113a7dc:	00000106 	br	8113a7e4 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113a7e0:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113a7e4:	e0bffe03 	ldbu	r2,-8(fp)
8113a7e8:	10000326 	beq	r2,zero,8113a7f8 <OSFlagDel+0xf0>
8113a7ec:	10800060 	cmpeqi	r2,r2,1
8113a7f0:	1000231e 	bne	r2,zero,8113a880 <OSFlagDel+0x178>
8113a7f4:	00004806 	br	8113a918 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
8113a7f8:	e0bff403 	ldbu	r2,-48(fp)
8113a7fc:	1000161e 	bne	r2,zero,8113a858 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
8113a800:	e0bffd17 	ldw	r2,-12(fp)
8113a804:	00c00fc4 	movi	r3,63
8113a808:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113a80c:	e0bffd17 	ldw	r2,-12(fp)
8113a810:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113a814:	e0bffd17 	ldw	r2,-12(fp)
8113a818:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
8113a81c:	d0e0a617 	ldw	r3,-32104(gp)
8113a820:	e0bffd17 	ldw	r2,-12(fp)
8113a824:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113a828:	e0bffd17 	ldw	r2,-12(fp)
8113a82c:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8113a830:	e0bffd17 	ldw	r2,-12(fp)
8113a834:	d0a0a615 	stw	r2,-32104(gp)
8113a838:	e0bff717 	ldw	r2,-36(fp)
8113a83c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a840:	e0bff817 	ldw	r2,-32(fp)
8113a844:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
8113a848:	e0bfff17 	ldw	r2,-4(fp)
8113a84c:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8113a850:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
8113a854:	00003a06 	br	8113a940 <OSFlagDel+0x238>
8113a858:	e0bff717 	ldw	r2,-36(fp)
8113a85c:	e0bff915 	stw	r2,-28(fp)
8113a860:	e0bff917 	ldw	r2,-28(fp)
8113a864:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
8113a868:	e0bfff17 	ldw	r2,-4(fp)
8113a86c:	00c01244 	movi	r3,73
8113a870:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
8113a874:	e0bffd17 	ldw	r2,-12(fp)
8113a878:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113a87c:	00003006 	br	8113a940 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113a880:	e0bffd17 	ldw	r2,-12(fp)
8113a884:	10800117 	ldw	r2,4(r2)
8113a888:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113a88c:	00000606 	br	8113a8a8 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113a890:	000b883a 	mov	r5,zero
8113a894:	e13ff517 	ldw	r4,-44(fp)
8113a898:	113b8bc0 	call	8113b8bc <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113a89c:	e0bff517 	ldw	r2,-44(fp)
8113a8a0:	10800017 	ldw	r2,0(r2)
8113a8a4:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
8113a8a8:	e0bff517 	ldw	r2,-44(fp)
8113a8ac:	103ff81e 	bne	r2,zero,8113a890 <__reset+0xfb11a890>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
8113a8b0:	e0bffd17 	ldw	r2,-12(fp)
8113a8b4:	00c00fc4 	movi	r3,63
8113a8b8:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113a8bc:	e0bffd17 	ldw	r2,-12(fp)
8113a8c0:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113a8c4:	e0bffd17 	ldw	r2,-12(fp)
8113a8c8:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
8113a8cc:	d0e0a617 	ldw	r3,-32104(gp)
8113a8d0:	e0bffd17 	ldw	r2,-12(fp)
8113a8d4:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
8113a8d8:	e0bffd17 	ldw	r2,-12(fp)
8113a8dc:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
8113a8e0:	e0bffd17 	ldw	r2,-12(fp)
8113a8e4:	d0a0a615 	stw	r2,-32104(gp)
8113a8e8:	e0bff717 	ldw	r2,-36(fp)
8113a8ec:	e0bffa15 	stw	r2,-24(fp)
8113a8f0:	e0bffa17 	ldw	r2,-24(fp)
8113a8f4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113a8f8:	e0bff403 	ldbu	r2,-48(fp)
8113a8fc:	10800058 	cmpnei	r2,r2,1
8113a900:	1000011e 	bne	r2,zero,8113a908 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113a904:	11399cc0 	call	811399cc <OS_Sched>
             }
             *perr = OS_ERR_NONE;
8113a908:	e0bfff17 	ldw	r2,-4(fp)
8113a90c:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113a910:	e03ff615 	stw	zero,-40(fp)
             break;
8113a914:	00000a06 	br	8113a940 <OSFlagDel+0x238>
8113a918:	e0bff717 	ldw	r2,-36(fp)
8113a91c:	e0bffb15 	stw	r2,-20(fp)
8113a920:	e0bffb17 	ldw	r2,-20(fp)
8113a924:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
8113a928:	e0bfff17 	ldw	r2,-4(fp)
8113a92c:	00c001c4 	movi	r3,7
8113a930:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
8113a934:	e0bffd17 	ldw	r2,-12(fp)
8113a938:	e0bff615 	stw	r2,-40(fp)
             break;
8113a93c:	0001883a 	nop
    }
    return (pgrp_return);
8113a940:	e0bff617 	ldw	r2,-40(fp)
}
8113a944:	e037883a 	mov	sp,fp
8113a948:	dfc00117 	ldw	ra,4(sp)
8113a94c:	df000017 	ldw	fp,0(sp)
8113a950:	dec00204 	addi	sp,sp,8
8113a954:	f800283a 	ret

8113a958 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113a958:	defff604 	addi	sp,sp,-40
8113a95c:	de00012e 	bgeu	sp,et,8113a964 <OSFlagNameGet+0xc>
8113a960:	003b68fa 	trap	3
8113a964:	dfc00915 	stw	ra,36(sp)
8113a968:	df000815 	stw	fp,32(sp)
8113a96c:	df000804 	addi	fp,sp,32
8113a970:	e13ffd15 	stw	r4,-12(fp)
8113a974:	e17ffe15 	stw	r5,-8(fp)
8113a978:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a97c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a980:	e0bfff17 	ldw	r2,-4(fp)
8113a984:	1000021e 	bne	r2,zero,8113a990 <OSFlagNameGet+0x38>
        return (0);
8113a988:	0005883a 	mov	r2,zero
8113a98c:	00003906 	br	8113aa74 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113a990:	e0bffd17 	ldw	r2,-12(fp)
8113a994:	1000051e 	bne	r2,zero,8113a9ac <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a998:	e0bfff17 	ldw	r2,-4(fp)
8113a99c:	00c01b84 	movi	r3,110
8113a9a0:	10c00005 	stb	r3,0(r2)
        return (0);
8113a9a4:	0005883a 	mov	r2,zero
8113a9a8:	00003206 	br	8113aa74 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113a9ac:	e0bffe17 	ldw	r2,-8(fp)
8113a9b0:	1000051e 	bne	r2,zero,8113a9c8 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113a9b4:	e0bfff17 	ldw	r2,-4(fp)
8113a9b8:	00c00304 	movi	r3,12
8113a9bc:	10c00005 	stb	r3,0(r2)
        return (0);
8113a9c0:	0005883a 	mov	r2,zero
8113a9c4:	00002b06 	br	8113aa74 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a9c8:	d0a0a103 	ldbu	r2,-32124(gp)
8113a9cc:	10803fcc 	andi	r2,r2,255
8113a9d0:	10000526 	beq	r2,zero,8113a9e8 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113a9d4:	e0bfff17 	ldw	r2,-4(fp)
8113a9d8:	00c00444 	movi	r3,17
8113a9dc:	10c00005 	stb	r3,0(r2)
        return (0);
8113a9e0:	0005883a 	mov	r2,zero
8113a9e4:	00002306 	br	8113aa74 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a9e8:	0005303a 	rdctl	r2,status
8113a9ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a9f0:	e0fffc17 	ldw	r3,-16(fp)
8113a9f4:	00bfff84 	movi	r2,-2
8113a9f8:	1884703a 	and	r2,r3,r2
8113a9fc:	1001703a 	wrctl	status,r2
  
  return context;
8113aa00:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113aa04:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113aa08:	e0bffd17 	ldw	r2,-12(fp)
8113aa0c:	10800003 	ldbu	r2,0(r2)
8113aa10:	10803fcc 	andi	r2,r2,255
8113aa14:	10800160 	cmpeqi	r2,r2,5
8113aa18:	1000091e 	bne	r2,zero,8113aa40 <OSFlagNameGet+0xe8>
8113aa1c:	e0bff817 	ldw	r2,-32(fp)
8113aa20:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aa24:	e0bff917 	ldw	r2,-28(fp)
8113aa28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113aa2c:	e0bfff17 	ldw	r2,-4(fp)
8113aa30:	00c00044 	movi	r3,1
8113aa34:	10c00005 	stb	r3,0(r2)
        return (0);
8113aa38:	0005883a 	mov	r2,zero
8113aa3c:	00000d06 	br	8113aa74 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8113aa40:	e0bffd17 	ldw	r2,-12(fp)
8113aa44:	10800284 	addi	r2,r2,10
8113aa48:	100b883a 	mov	r5,r2
8113aa4c:	e13ffe17 	ldw	r4,-8(fp)
8113aa50:	1139b200 	call	81139b20 <OS_StrCopy>
8113aa54:	e0bffb05 	stb	r2,-20(fp)
8113aa58:	e0bff817 	ldw	r2,-32(fp)
8113aa5c:	e0bffa15 	stw	r2,-24(fp)
8113aa60:	e0bffa17 	ldw	r2,-24(fp)
8113aa64:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113aa68:	e0bfff17 	ldw	r2,-4(fp)
8113aa6c:	10000005 	stb	zero,0(r2)
    return (len);
8113aa70:	e0bffb03 	ldbu	r2,-20(fp)
}
8113aa74:	e037883a 	mov	sp,fp
8113aa78:	dfc00117 	ldw	ra,4(sp)
8113aa7c:	df000017 	ldw	fp,0(sp)
8113aa80:	dec00204 	addi	sp,sp,8
8113aa84:	f800283a 	ret

8113aa88 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
8113aa88:	defff504 	addi	sp,sp,-44
8113aa8c:	de00012e 	bgeu	sp,et,8113aa94 <OSFlagNameSet+0xc>
8113aa90:	003b68fa 	trap	3
8113aa94:	dfc00a15 	stw	ra,40(sp)
8113aa98:	df000915 	stw	fp,36(sp)
8113aa9c:	df000904 	addi	fp,sp,36
8113aaa0:	e13ffd15 	stw	r4,-12(fp)
8113aaa4:	e17ffe15 	stw	r5,-8(fp)
8113aaa8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113aaac:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113aab0:	e0bfff17 	ldw	r2,-4(fp)
8113aab4:	10004326 	beq	r2,zero,8113abc4 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113aab8:	e0bffd17 	ldw	r2,-12(fp)
8113aabc:	1000041e 	bne	r2,zero,8113aad0 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113aac0:	e0bfff17 	ldw	r2,-4(fp)
8113aac4:	00c01b84 	movi	r3,110
8113aac8:	10c00005 	stb	r3,0(r2)
        return;
8113aacc:	00003e06 	br	8113abc8 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113aad0:	e0bffe17 	ldw	r2,-8(fp)
8113aad4:	1000041e 	bne	r2,zero,8113aae8 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113aad8:	e0bfff17 	ldw	r2,-4(fp)
8113aadc:	00c00304 	movi	r3,12
8113aae0:	10c00005 	stb	r3,0(r2)
        return;
8113aae4:	00003806 	br	8113abc8 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113aae8:	d0a0a103 	ldbu	r2,-32124(gp)
8113aaec:	10803fcc 	andi	r2,r2,255
8113aaf0:	10000426 	beq	r2,zero,8113ab04 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113aaf4:	e0bfff17 	ldw	r2,-4(fp)
8113aaf8:	00c00484 	movi	r3,18
8113aafc:	10c00005 	stb	r3,0(r2)
        return;
8113ab00:	00003106 	br	8113abc8 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ab04:	0005303a 	rdctl	r2,status
8113ab08:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ab0c:	e0fffc17 	ldw	r3,-16(fp)
8113ab10:	00bfff84 	movi	r2,-2
8113ab14:	1884703a 	and	r2,r3,r2
8113ab18:	1001703a 	wrctl	status,r2
  
  return context;
8113ab1c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ab20:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
8113ab24:	e0bffd17 	ldw	r2,-12(fp)
8113ab28:	10800003 	ldbu	r2,0(r2)
8113ab2c:	10803fcc 	andi	r2,r2,255
8113ab30:	10800160 	cmpeqi	r2,r2,5
8113ab34:	1000081e 	bne	r2,zero,8113ab58 <OSFlagNameSet+0xd0>
8113ab38:	e0bff717 	ldw	r2,-36(fp)
8113ab3c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ab40:	e0bff817 	ldw	r2,-32(fp)
8113ab44:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
8113ab48:	e0bfff17 	ldw	r2,-4(fp)
8113ab4c:	00c00044 	movi	r3,1
8113ab50:	10c00005 	stb	r3,0(r2)
        return;
8113ab54:	00001c06 	br	8113abc8 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113ab58:	e13ffe17 	ldw	r4,-8(fp)
8113ab5c:	1139b9c0 	call	81139b9c <OS_StrLen>
8113ab60:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
8113ab64:	e0bffa03 	ldbu	r2,-24(fp)
8113ab68:	10800830 	cmpltui	r2,r2,32
8113ab6c:	1000081e 	bne	r2,zero,8113ab90 <OSFlagNameSet+0x108>
8113ab70:	e0bff717 	ldw	r2,-36(fp)
8113ab74:	e0bff915 	stw	r2,-28(fp)
8113ab78:	e0bff917 	ldw	r2,-28(fp)
8113ab7c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8113ab80:	e0bfff17 	ldw	r2,-4(fp)
8113ab84:	00c01cc4 	movi	r3,115
8113ab88:	10c00005 	stb	r3,0(r2)
        return;
8113ab8c:	00000e06 	br	8113abc8 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113ab90:	e0bffd17 	ldw	r2,-12(fp)
8113ab94:	10800284 	addi	r2,r2,10
8113ab98:	e17ffe17 	ldw	r5,-8(fp)
8113ab9c:	1009883a 	mov	r4,r2
8113aba0:	1139b200 	call	81139b20 <OS_StrCopy>
8113aba4:	e0bff717 	ldw	r2,-36(fp)
8113aba8:	e0bffb15 	stw	r2,-20(fp)
8113abac:	e0bffb17 	ldw	r2,-20(fp)
8113abb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113abb4:	e0bfff17 	ldw	r2,-4(fp)
8113abb8:	10000005 	stb	zero,0(r2)
    return;
8113abbc:	0001883a 	nop
8113abc0:	00000106 	br	8113abc8 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113abc4:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8113abc8:	e037883a 	mov	sp,fp
8113abcc:	dfc00117 	ldw	ra,4(sp)
8113abd0:	df000017 	ldw	fp,0(sp)
8113abd4:	dec00204 	addi	sp,sp,8
8113abd8:	f800283a 	ret

8113abdc <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8113abdc:	deffe104 	addi	sp,sp,-124
8113abe0:	de00012e 	bgeu	sp,et,8113abe8 <OSFlagPend+0xc>
8113abe4:	003b68fa 	trap	3
8113abe8:	dfc01e15 	stw	ra,120(sp)
8113abec:	df001d15 	stw	fp,116(sp)
8113abf0:	df001d04 	addi	fp,sp,116
8113abf4:	e13ffc15 	stw	r4,-16(fp)
8113abf8:	2809883a 	mov	r4,r5
8113abfc:	3007883a 	mov	r3,r6
8113ac00:	3805883a 	mov	r2,r7
8113ac04:	e13ffd0d 	sth	r4,-12(fp)
8113ac08:	e0fffe05 	stb	r3,-8(fp)
8113ac0c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113ac10:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113ac14:	e0800217 	ldw	r2,8(fp)
8113ac18:	1000021e 	bne	r2,zero,8113ac24 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113ac1c:	0005883a 	mov	r2,zero
8113ac20:	00015906 	br	8113b188 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113ac24:	e0bffc17 	ldw	r2,-16(fp)
8113ac28:	1000051e 	bne	r2,zero,8113ac40 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113ac2c:	e0800217 	ldw	r2,8(fp)
8113ac30:	00c01b84 	movi	r3,110
8113ac34:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113ac38:	0005883a 	mov	r2,zero
8113ac3c:	00015206 	br	8113b188 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113ac40:	d0a0a103 	ldbu	r2,-32124(gp)
8113ac44:	10803fcc 	andi	r2,r2,255
8113ac48:	10000526 	beq	r2,zero,8113ac60 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113ac4c:	e0800217 	ldw	r2,8(fp)
8113ac50:	00c00084 	movi	r3,2
8113ac54:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113ac58:	0005883a 	mov	r2,zero
8113ac5c:	00014a06 	br	8113b188 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113ac60:	d0a08f03 	ldbu	r2,-32196(gp)
8113ac64:	10803fcc 	andi	r2,r2,255
8113ac68:	10000526 	beq	r2,zero,8113ac80 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113ac6c:	e0800217 	ldw	r2,8(fp)
8113ac70:	00c00344 	movi	r3,13
8113ac74:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113ac78:	0005883a 	mov	r2,zero
8113ac7c:	00014206 	br	8113b188 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113ac80:	e0bffc17 	ldw	r2,-16(fp)
8113ac84:	10800003 	ldbu	r2,0(r2)
8113ac88:	10803fcc 	andi	r2,r2,255
8113ac8c:	10800160 	cmpeqi	r2,r2,5
8113ac90:	1000051e 	bne	r2,zero,8113aca8 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8113ac94:	e0800217 	ldw	r2,8(fp)
8113ac98:	00c00044 	movi	r3,1
8113ac9c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113aca0:	0005883a 	mov	r2,zero
8113aca4:	00013806 	br	8113b188 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113aca8:	e0fffe03 	ldbu	r3,-8(fp)
8113acac:	00bfe004 	movi	r2,-128
8113acb0:	1884703a 	and	r2,r3,r2
8113acb4:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8113acb8:	e0bfe603 	ldbu	r2,-104(fp)
8113acbc:	10000626 	beq	r2,zero,8113acd8 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113acc0:	e0bffe03 	ldbu	r2,-8(fp)
8113acc4:	10801fcc 	andi	r2,r2,127
8113acc8:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113accc:	00800044 	movi	r2,1
8113acd0:	e0bfe405 	stb	r2,-112(fp)
8113acd4:	00000106 	br	8113acdc <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8113acd8:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113acdc:	0005303a 	rdctl	r2,status
8113ace0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ace4:	e0fff617 	ldw	r3,-40(fp)
8113ace8:	00bfff84 	movi	r2,-2
8113acec:	1884703a 	and	r2,r3,r2
8113acf0:	1001703a 	wrctl	status,r2
  
  return context;
8113acf4:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113acf8:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8113acfc:	e0bffe03 	ldbu	r2,-8(fp)
8113ad00:	10c00060 	cmpeqi	r3,r2,1
8113ad04:	1800921e 	bne	r3,zero,8113af50 <OSFlagPend+0x374>
8113ad08:	10c00088 	cmpgei	r3,r2,2
8113ad0c:	1800021e 	bne	r3,zero,8113ad18 <OSFlagPend+0x13c>
8113ad10:	10006126 	beq	r2,zero,8113ae98 <OSFlagPend+0x2bc>
8113ad14:	0000bb06 	br	8113b004 <OSFlagPend+0x428>
8113ad18:	10c000a0 	cmpeqi	r3,r2,2
8113ad1c:	1800031e 	bne	r3,zero,8113ad2c <OSFlagPend+0x150>
8113ad20:	108000e0 	cmpeqi	r2,r2,3
8113ad24:	10002f1e 	bne	r2,zero,8113ade4 <OSFlagPend+0x208>
8113ad28:	0000b606 	br	8113b004 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113ad2c:	e0bffc17 	ldw	r2,-16(fp)
8113ad30:	10c0020b 	ldhu	r3,8(r2)
8113ad34:	e0bffd0b 	ldhu	r2,-12(fp)
8113ad38:	1884703a 	and	r2,r3,r2
8113ad3c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113ad40:	e0ffe80b 	ldhu	r3,-96(fp)
8113ad44:	e0bffd0b 	ldhu	r2,-12(fp)
8113ad48:	1880171e 	bne	r3,r2,8113ada8 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113ad4c:	e0bfe403 	ldbu	r2,-112(fp)
8113ad50:	10800058 	cmpnei	r2,r2,1
8113ad54:	1000091e 	bne	r2,zero,8113ad7c <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113ad58:	e0bffc17 	ldw	r2,-16(fp)
8113ad5c:	1080020b 	ldhu	r2,8(r2)
8113ad60:	1007883a 	mov	r3,r2
8113ad64:	e0bfe80b 	ldhu	r2,-96(fp)
8113ad68:	0084303a 	nor	r2,zero,r2
8113ad6c:	1884703a 	and	r2,r3,r2
8113ad70:	1007883a 	mov	r3,r2
8113ad74:	e0bffc17 	ldw	r2,-16(fp)
8113ad78:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113ad7c:	d0a0a217 	ldw	r2,-32120(gp)
8113ad80:	e0ffe80b 	ldhu	r3,-96(fp)
8113ad84:	10c00b0d 	sth	r3,44(r2)
8113ad88:	e0bfe517 	ldw	r2,-108(fp)
8113ad8c:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ad90:	e0bfe717 	ldw	r2,-100(fp)
8113ad94:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113ad98:	e0800217 	ldw	r2,8(fp)
8113ad9c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113ada0:	e0bfe80b 	ldhu	r2,-96(fp)
8113ada4:	0000f806 	br	8113b188 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113ada8:	e13ffd0b 	ldhu	r4,-12(fp)
8113adac:	e17ffe03 	ldbu	r5,-8(fp)
8113adb0:	e0bfff0b 	ldhu	r2,-4(fp)
8113adb4:	e0fff704 	addi	r3,fp,-36
8113adb8:	d8800015 	stw	r2,0(sp)
8113adbc:	280f883a 	mov	r7,r5
8113adc0:	200d883a 	mov	r6,r4
8113adc4:	180b883a 	mov	r5,r3
8113adc8:	e13ffc17 	ldw	r4,-16(fp)
8113adcc:	113b66c0 	call	8113b66c <OS_FlagBlock>
8113add0:	e0bfe517 	ldw	r2,-108(fp)
8113add4:	e0bfe915 	stw	r2,-92(fp)
8113add8:	e0bfe917 	ldw	r2,-92(fp)
8113addc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113ade0:	00009206 	br	8113b02c <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113ade4:	e0bffc17 	ldw	r2,-16(fp)
8113ade8:	10c0020b 	ldhu	r3,8(r2)
8113adec:	e0bffd0b 	ldhu	r2,-12(fp)
8113adf0:	1884703a 	and	r2,r3,r2
8113adf4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113adf8:	e0bfe80b 	ldhu	r2,-96(fp)
8113adfc:	10001726 	beq	r2,zero,8113ae5c <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113ae00:	e0bfe403 	ldbu	r2,-112(fp)
8113ae04:	10800058 	cmpnei	r2,r2,1
8113ae08:	1000091e 	bne	r2,zero,8113ae30 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113ae0c:	e0bffc17 	ldw	r2,-16(fp)
8113ae10:	1080020b 	ldhu	r2,8(r2)
8113ae14:	1007883a 	mov	r3,r2
8113ae18:	e0bfe80b 	ldhu	r2,-96(fp)
8113ae1c:	0084303a 	nor	r2,zero,r2
8113ae20:	1884703a 	and	r2,r3,r2
8113ae24:	1007883a 	mov	r3,r2
8113ae28:	e0bffc17 	ldw	r2,-16(fp)
8113ae2c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113ae30:	d0a0a217 	ldw	r2,-32120(gp)
8113ae34:	e0ffe80b 	ldhu	r3,-96(fp)
8113ae38:	10c00b0d 	sth	r3,44(r2)
8113ae3c:	e0bfe517 	ldw	r2,-108(fp)
8113ae40:	e0bfea15 	stw	r2,-88(fp)
8113ae44:	e0bfea17 	ldw	r2,-88(fp)
8113ae48:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113ae4c:	e0800217 	ldw	r2,8(fp)
8113ae50:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113ae54:	e0bfe80b 	ldhu	r2,-96(fp)
8113ae58:	0000cb06 	br	8113b188 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113ae5c:	e13ffd0b 	ldhu	r4,-12(fp)
8113ae60:	e17ffe03 	ldbu	r5,-8(fp)
8113ae64:	e0bfff0b 	ldhu	r2,-4(fp)
8113ae68:	e0fff704 	addi	r3,fp,-36
8113ae6c:	d8800015 	stw	r2,0(sp)
8113ae70:	280f883a 	mov	r7,r5
8113ae74:	200d883a 	mov	r6,r4
8113ae78:	180b883a 	mov	r5,r3
8113ae7c:	e13ffc17 	ldw	r4,-16(fp)
8113ae80:	113b66c0 	call	8113b66c <OS_FlagBlock>
8113ae84:	e0bfe517 	ldw	r2,-108(fp)
8113ae88:	e0bfeb15 	stw	r2,-84(fp)
8113ae8c:	e0bfeb17 	ldw	r2,-84(fp)
8113ae90:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113ae94:	00006506 	br	8113b02c <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113ae98:	e0bffc17 	ldw	r2,-16(fp)
8113ae9c:	1080020b 	ldhu	r2,8(r2)
8113aea0:	0084303a 	nor	r2,zero,r2
8113aea4:	1007883a 	mov	r3,r2
8113aea8:	e0bffd0b 	ldhu	r2,-12(fp)
8113aeac:	1884703a 	and	r2,r3,r2
8113aeb0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113aeb4:	e0ffe80b 	ldhu	r3,-96(fp)
8113aeb8:	e0bffd0b 	ldhu	r2,-12(fp)
8113aebc:	1880151e 	bne	r3,r2,8113af14 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113aec0:	e0bfe403 	ldbu	r2,-112(fp)
8113aec4:	10800058 	cmpnei	r2,r2,1
8113aec8:	1000071e 	bne	r2,zero,8113aee8 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113aecc:	e0bffc17 	ldw	r2,-16(fp)
8113aed0:	10c0020b 	ldhu	r3,8(r2)
8113aed4:	e0bfe80b 	ldhu	r2,-96(fp)
8113aed8:	1884b03a 	or	r2,r3,r2
8113aedc:	1007883a 	mov	r3,r2
8113aee0:	e0bffc17 	ldw	r2,-16(fp)
8113aee4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113aee8:	d0a0a217 	ldw	r2,-32120(gp)
8113aeec:	e0ffe80b 	ldhu	r3,-96(fp)
8113aef0:	10c00b0d 	sth	r3,44(r2)
8113aef4:	e0bfe517 	ldw	r2,-108(fp)
8113aef8:	e0bfec15 	stw	r2,-80(fp)
8113aefc:	e0bfec17 	ldw	r2,-80(fp)
8113af00:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113af04:	e0800217 	ldw	r2,8(fp)
8113af08:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113af0c:	e0bfe80b 	ldhu	r2,-96(fp)
8113af10:	00009d06 	br	8113b188 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113af14:	e13ffd0b 	ldhu	r4,-12(fp)
8113af18:	e17ffe03 	ldbu	r5,-8(fp)
8113af1c:	e0bfff0b 	ldhu	r2,-4(fp)
8113af20:	e0fff704 	addi	r3,fp,-36
8113af24:	d8800015 	stw	r2,0(sp)
8113af28:	280f883a 	mov	r7,r5
8113af2c:	200d883a 	mov	r6,r4
8113af30:	180b883a 	mov	r5,r3
8113af34:	e13ffc17 	ldw	r4,-16(fp)
8113af38:	113b66c0 	call	8113b66c <OS_FlagBlock>
8113af3c:	e0bfe517 	ldw	r2,-108(fp)
8113af40:	e0bfed15 	stw	r2,-76(fp)
8113af44:	e0bfed17 	ldw	r2,-76(fp)
8113af48:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113af4c:	00003706 	br	8113b02c <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113af50:	e0bffc17 	ldw	r2,-16(fp)
8113af54:	1080020b 	ldhu	r2,8(r2)
8113af58:	0084303a 	nor	r2,zero,r2
8113af5c:	1007883a 	mov	r3,r2
8113af60:	e0bffd0b 	ldhu	r2,-12(fp)
8113af64:	1884703a 	and	r2,r3,r2
8113af68:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113af6c:	e0bfe80b 	ldhu	r2,-96(fp)
8113af70:	10001526 	beq	r2,zero,8113afc8 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113af74:	e0bfe403 	ldbu	r2,-112(fp)
8113af78:	10800058 	cmpnei	r2,r2,1
8113af7c:	1000071e 	bne	r2,zero,8113af9c <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113af80:	e0bffc17 	ldw	r2,-16(fp)
8113af84:	10c0020b 	ldhu	r3,8(r2)
8113af88:	e0bfe80b 	ldhu	r2,-96(fp)
8113af8c:	1884b03a 	or	r2,r3,r2
8113af90:	1007883a 	mov	r3,r2
8113af94:	e0bffc17 	ldw	r2,-16(fp)
8113af98:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113af9c:	d0a0a217 	ldw	r2,-32120(gp)
8113afa0:	e0ffe80b 	ldhu	r3,-96(fp)
8113afa4:	10c00b0d 	sth	r3,44(r2)
8113afa8:	e0bfe517 	ldw	r2,-108(fp)
8113afac:	e0bfee15 	stw	r2,-72(fp)
8113afb0:	e0bfee17 	ldw	r2,-72(fp)
8113afb4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113afb8:	e0800217 	ldw	r2,8(fp)
8113afbc:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113afc0:	e0bfe80b 	ldhu	r2,-96(fp)
8113afc4:	00007006 	br	8113b188 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113afc8:	e13ffd0b 	ldhu	r4,-12(fp)
8113afcc:	e17ffe03 	ldbu	r5,-8(fp)
8113afd0:	e0bfff0b 	ldhu	r2,-4(fp)
8113afd4:	e0fff704 	addi	r3,fp,-36
8113afd8:	d8800015 	stw	r2,0(sp)
8113afdc:	280f883a 	mov	r7,r5
8113afe0:	200d883a 	mov	r6,r4
8113afe4:	180b883a 	mov	r5,r3
8113afe8:	e13ffc17 	ldw	r4,-16(fp)
8113afec:	113b66c0 	call	8113b66c <OS_FlagBlock>
8113aff0:	e0bfe517 	ldw	r2,-108(fp)
8113aff4:	e0bfef15 	stw	r2,-68(fp)
8113aff8:	e0bfef17 	ldw	r2,-68(fp)
8113affc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113b000:	00000a06 	br	8113b02c <OSFlagPend+0x450>
8113b004:	e0bfe517 	ldw	r2,-108(fp)
8113b008:	e0bff015 	stw	r2,-64(fp)
8113b00c:	e0bff017 	ldw	r2,-64(fp)
8113b010:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113b014:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8113b018:	e0800217 	ldw	r2,8(fp)
8113b01c:	00c01bc4 	movi	r3,111
8113b020:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113b024:	e0bfe80b 	ldhu	r2,-96(fp)
8113b028:	00005706 	br	8113b188 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8113b02c:	11399cc0 	call	811399cc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b030:	0005303a 	rdctl	r2,status
8113b034:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b038:	e0fff117 	ldw	r3,-60(fp)
8113b03c:	00bfff84 	movi	r2,-2
8113b040:	1884703a 	and	r2,r3,r2
8113b044:	1001703a 	wrctl	status,r2
  
  return context;
8113b048:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113b04c:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113b050:	d0a0a217 	ldw	r2,-32120(gp)
8113b054:	10800c43 	ldbu	r2,49(r2)
8113b058:	10803fcc 	andi	r2,r2,255
8113b05c:	10001c26 	beq	r2,zero,8113b0d0 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113b060:	d0a0a217 	ldw	r2,-32120(gp)
8113b064:	10800c43 	ldbu	r2,49(r2)
8113b068:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113b06c:	d0a0a217 	ldw	r2,-32120(gp)
8113b070:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8113b074:	e0bff704 	addi	r2,fp,-36
8113b078:	1009883a 	mov	r4,r2
8113b07c:	113b9b80 	call	8113b9b8 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113b080:	d0a0a217 	ldw	r2,-32120(gp)
8113b084:	10000c05 	stb	zero,48(r2)
8113b088:	e0bfe517 	ldw	r2,-108(fp)
8113b08c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b090:	e0bff217 	ldw	r2,-56(fp)
8113b094:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8113b098:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113b09c:	e0bff303 	ldbu	r2,-52(fp)
8113b0a0:	108000a0 	cmpeqi	r2,r2,2
8113b0a4:	10000426 	beq	r2,zero,8113b0b8 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8113b0a8:	e0800217 	ldw	r2,8(fp)
8113b0ac:	00c00384 	movi	r3,14
8113b0b0:	10c00005 	stb	r3,0(r2)
                 break;
8113b0b4:	00000406 	br	8113b0c8 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8113b0b8:	e0800217 	ldw	r2,8(fp)
8113b0bc:	00c00284 	movi	r3,10
8113b0c0:	10c00005 	stb	r3,0(r2)
                 break;
8113b0c4:	0001883a 	nop
        }
        return (flags_rdy);
8113b0c8:	e0bfe80b 	ldhu	r2,-96(fp)
8113b0cc:	00002e06 	br	8113b188 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113b0d0:	d0a0a217 	ldw	r2,-32120(gp)
8113b0d4:	10800b0b 	ldhu	r2,44(r2)
8113b0d8:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113b0dc:	e0bfe403 	ldbu	r2,-112(fp)
8113b0e0:	10800058 	cmpnei	r2,r2,1
8113b0e4:	1000211e 	bne	r2,zero,8113b16c <OSFlagPend+0x590>
        switch (wait_type) {
8113b0e8:	e0bffe03 	ldbu	r2,-8(fp)
8113b0ec:	10001616 	blt	r2,zero,8113b148 <OSFlagPend+0x56c>
8113b0f0:	10c00090 	cmplti	r3,r2,2
8113b0f4:	18000c1e 	bne	r3,zero,8113b128 <OSFlagPend+0x54c>
8113b0f8:	10800108 	cmpgei	r2,r2,4
8113b0fc:	1000121e 	bne	r2,zero,8113b148 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113b100:	e0bffc17 	ldw	r2,-16(fp)
8113b104:	1080020b 	ldhu	r2,8(r2)
8113b108:	1007883a 	mov	r3,r2
8113b10c:	e0bfe80b 	ldhu	r2,-96(fp)
8113b110:	0084303a 	nor	r2,zero,r2
8113b114:	1884703a 	and	r2,r3,r2
8113b118:	1007883a 	mov	r3,r2
8113b11c:	e0bffc17 	ldw	r2,-16(fp)
8113b120:	10c0020d 	sth	r3,8(r2)
                 break;
8113b124:	00001106 	br	8113b16c <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113b128:	e0bffc17 	ldw	r2,-16(fp)
8113b12c:	10c0020b 	ldhu	r3,8(r2)
8113b130:	e0bfe80b 	ldhu	r2,-96(fp)
8113b134:	1884b03a 	or	r2,r3,r2
8113b138:	1007883a 	mov	r3,r2
8113b13c:	e0bffc17 	ldw	r2,-16(fp)
8113b140:	10c0020d 	sth	r3,8(r2)
                 break;
8113b144:	00000906 	br	8113b16c <OSFlagPend+0x590>
8113b148:	e0bfe517 	ldw	r2,-108(fp)
8113b14c:	e0bff415 	stw	r2,-48(fp)
8113b150:	e0bff417 	ldw	r2,-48(fp)
8113b154:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113b158:	e0800217 	ldw	r2,8(fp)
8113b15c:	00c01bc4 	movi	r3,111
8113b160:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113b164:	0005883a 	mov	r2,zero
8113b168:	00000706 	br	8113b188 <OSFlagPend+0x5ac>
8113b16c:	e0bfe517 	ldw	r2,-108(fp)
8113b170:	e0bff515 	stw	r2,-44(fp)
8113b174:	e0bff517 	ldw	r2,-44(fp)
8113b178:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113b17c:	e0800217 	ldw	r2,8(fp)
8113b180:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8113b184:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113b188:	e037883a 	mov	sp,fp
8113b18c:	dfc00117 	ldw	ra,4(sp)
8113b190:	df000017 	ldw	fp,0(sp)
8113b194:	dec00204 	addi	sp,sp,8
8113b198:	f800283a 	ret

8113b19c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113b19c:	defffb04 	addi	sp,sp,-20
8113b1a0:	de00012e 	bgeu	sp,et,8113b1a8 <OSFlagPendGetFlagsRdy+0xc>
8113b1a4:	003b68fa 	trap	3
8113b1a8:	df000415 	stw	fp,16(sp)
8113b1ac:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113b1b0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b1b4:	0005303a 	rdctl	r2,status
8113b1b8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b1bc:	e0fffe17 	ldw	r3,-8(fp)
8113b1c0:	00bfff84 	movi	r2,-2
8113b1c4:	1884703a 	and	r2,r3,r2
8113b1c8:	1001703a 	wrctl	status,r2
  
  return context;
8113b1cc:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113b1d0:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113b1d4:	d0a0a217 	ldw	r2,-32120(gp)
8113b1d8:	10800b0b 	ldhu	r2,44(r2)
8113b1dc:	e0bffd0d 	sth	r2,-12(fp)
8113b1e0:	e0bffc17 	ldw	r2,-16(fp)
8113b1e4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b1e8:	e0bfff17 	ldw	r2,-4(fp)
8113b1ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113b1f0:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113b1f4:	e037883a 	mov	sp,fp
8113b1f8:	df000017 	ldw	fp,0(sp)
8113b1fc:	dec00104 	addi	sp,sp,4
8113b200:	f800283a 	ret

8113b204 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113b204:	deffef04 	addi	sp,sp,-68
8113b208:	de00012e 	bgeu	sp,et,8113b210 <OSFlagPost+0xc>
8113b20c:	003b68fa 	trap	3
8113b210:	dfc01015 	stw	ra,64(sp)
8113b214:	df000f15 	stw	fp,60(sp)
8113b218:	df000f04 	addi	fp,sp,60
8113b21c:	e13ffc15 	stw	r4,-16(fp)
8113b220:	2807883a 	mov	r3,r5
8113b224:	3005883a 	mov	r2,r6
8113b228:	e1ffff15 	stw	r7,-4(fp)
8113b22c:	e0fffd0d 	sth	r3,-12(fp)
8113b230:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8113b234:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113b238:	e0bfff17 	ldw	r2,-4(fp)
8113b23c:	1000021e 	bne	r2,zero,8113b248 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113b240:	0005883a 	mov	r2,zero
8113b244:	0000d106 	br	8113b58c <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113b248:	e0bffc17 	ldw	r2,-16(fp)
8113b24c:	1000051e 	bne	r2,zero,8113b264 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113b250:	e0bfff17 	ldw	r2,-4(fp)
8113b254:	00c01b84 	movi	r3,110
8113b258:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b25c:	0005883a 	mov	r2,zero
8113b260:	0000ca06 	br	8113b58c <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8113b264:	e0bffc17 	ldw	r2,-16(fp)
8113b268:	10800003 	ldbu	r2,0(r2)
8113b26c:	10803fcc 	andi	r2,r2,255
8113b270:	10800160 	cmpeqi	r2,r2,5
8113b274:	1000051e 	bne	r2,zero,8113b28c <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113b278:	e0bfff17 	ldw	r2,-4(fp)
8113b27c:	00c00044 	movi	r3,1
8113b280:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b284:	0005883a 	mov	r2,zero
8113b288:	0000c006 	br	8113b58c <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b28c:	0005303a 	rdctl	r2,status
8113b290:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b294:	e0fffb17 	ldw	r3,-20(fp)
8113b298:	00bfff84 	movi	r2,-2
8113b29c:	1884703a 	and	r2,r3,r2
8113b2a0:	1001703a 	wrctl	status,r2
  
  return context;
8113b2a4:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113b2a8:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113b2ac:	e0bffe03 	ldbu	r2,-8(fp)
8113b2b0:	10000326 	beq	r2,zero,8113b2c0 <OSFlagPost+0xbc>
8113b2b4:	10800060 	cmpeqi	r2,r2,1
8113b2b8:	10000b1e 	bne	r2,zero,8113b2e8 <OSFlagPost+0xe4>
8113b2bc:	00001206 	br	8113b308 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113b2c0:	e0bffc17 	ldw	r2,-16(fp)
8113b2c4:	1080020b 	ldhu	r2,8(r2)
8113b2c8:	1007883a 	mov	r3,r2
8113b2cc:	e0bffd0b 	ldhu	r2,-12(fp)
8113b2d0:	0084303a 	nor	r2,zero,r2
8113b2d4:	1884703a 	and	r2,r3,r2
8113b2d8:	1007883a 	mov	r3,r2
8113b2dc:	e0bffc17 	ldw	r2,-16(fp)
8113b2e0:	10c0020d 	sth	r3,8(r2)
             break;
8113b2e4:	00001106 	br	8113b32c <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113b2e8:	e0bffc17 	ldw	r2,-16(fp)
8113b2ec:	10c0020b 	ldhu	r3,8(r2)
8113b2f0:	e0bffd0b 	ldhu	r2,-12(fp)
8113b2f4:	1884b03a 	or	r2,r3,r2
8113b2f8:	1007883a 	mov	r3,r2
8113b2fc:	e0bffc17 	ldw	r2,-16(fp)
8113b300:	10c0020d 	sth	r3,8(r2)
             break;
8113b304:	00000906 	br	8113b32c <OSFlagPost+0x128>
8113b308:	e0bff317 	ldw	r2,-52(fp)
8113b30c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b310:	e0bff417 	ldw	r2,-48(fp)
8113b314:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113b318:	e0bfff17 	ldw	r2,-4(fp)
8113b31c:	00c01c44 	movi	r3,113
8113b320:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113b324:	0005883a 	mov	r2,zero
8113b328:	00009806 	br	8113b58c <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8113b32c:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113b330:	e0bffc17 	ldw	r2,-16(fp)
8113b334:	10800117 	ldw	r2,4(r2)
8113b338:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113b33c:	00007706 	br	8113b51c <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113b340:	e0bff117 	ldw	r2,-60(fp)
8113b344:	10800483 	ldbu	r2,18(r2)
8113b348:	10803fcc 	andi	r2,r2,255
8113b34c:	10c00060 	cmpeqi	r3,r2,1
8113b350:	18004a1e 	bne	r3,zero,8113b47c <OSFlagPost+0x278>
8113b354:	10c00088 	cmpgei	r3,r2,2
8113b358:	1800021e 	bne	r3,zero,8113b364 <OSFlagPost+0x160>
8113b35c:	10002f26 	beq	r2,zero,8113b41c <OSFlagPost+0x218>
8113b360:	00005b06 	br	8113b4d0 <OSFlagPost+0x2cc>
8113b364:	10c000a0 	cmpeqi	r3,r2,2
8113b368:	1800031e 	bne	r3,zero,8113b378 <OSFlagPost+0x174>
8113b36c:	108000e0 	cmpeqi	r2,r2,3
8113b370:	1000171e 	bne	r2,zero,8113b3d0 <OSFlagPost+0x1cc>
8113b374:	00005606 	br	8113b4d0 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b378:	e0bffc17 	ldw	r2,-16(fp)
8113b37c:	10c0020b 	ldhu	r3,8(r2)
8113b380:	e0bff117 	ldw	r2,-60(fp)
8113b384:	1080040b 	ldhu	r2,16(r2)
8113b388:	1884703a 	and	r2,r3,r2
8113b38c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113b390:	e0bff117 	ldw	r2,-60(fp)
8113b394:	1080040b 	ldhu	r2,16(r2)
8113b398:	10ffffcc 	andi	r3,r2,65535
8113b39c:	e0bff60b 	ldhu	r2,-40(fp)
8113b3a0:	1880541e 	bne	r3,r2,8113b4f4 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b3a4:	e0bff60b 	ldhu	r2,-40(fp)
8113b3a8:	100b883a 	mov	r5,r2
8113b3ac:	e13ff117 	ldw	r4,-60(fp)
8113b3b0:	113b8bc0 	call	8113b8bc <OS_FlagTaskRdy>
8113b3b4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b3b8:	e0bff683 	ldbu	r2,-38(fp)
8113b3bc:	10800058 	cmpnei	r2,r2,1
8113b3c0:	10004c1e 	bne	r2,zero,8113b4f4 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b3c4:	00800044 	movi	r2,1
8113b3c8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b3cc:	00004906 	br	8113b4f4 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b3d0:	e0bffc17 	ldw	r2,-16(fp)
8113b3d4:	10c0020b 	ldhu	r3,8(r2)
8113b3d8:	e0bff117 	ldw	r2,-60(fp)
8113b3dc:	1080040b 	ldhu	r2,16(r2)
8113b3e0:	1884703a 	and	r2,r3,r2
8113b3e4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113b3e8:	e0bff60b 	ldhu	r2,-40(fp)
8113b3ec:	10004326 	beq	r2,zero,8113b4fc <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b3f0:	e0bff60b 	ldhu	r2,-40(fp)
8113b3f4:	100b883a 	mov	r5,r2
8113b3f8:	e13ff117 	ldw	r4,-60(fp)
8113b3fc:	113b8bc0 	call	8113b8bc <OS_FlagTaskRdy>
8113b400:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b404:	e0bff683 	ldbu	r2,-38(fp)
8113b408:	10800058 	cmpnei	r2,r2,1
8113b40c:	10003b1e 	bne	r2,zero,8113b4fc <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b410:	00800044 	movi	r2,1
8113b414:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b418:	00003806 	br	8113b4fc <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b41c:	e0bffc17 	ldw	r2,-16(fp)
8113b420:	1080020b 	ldhu	r2,8(r2)
8113b424:	0084303a 	nor	r2,zero,r2
8113b428:	1007883a 	mov	r3,r2
8113b42c:	e0bff117 	ldw	r2,-60(fp)
8113b430:	1080040b 	ldhu	r2,16(r2)
8113b434:	1884703a 	and	r2,r3,r2
8113b438:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113b43c:	e0bff117 	ldw	r2,-60(fp)
8113b440:	1080040b 	ldhu	r2,16(r2)
8113b444:	10ffffcc 	andi	r3,r2,65535
8113b448:	e0bff60b 	ldhu	r2,-40(fp)
8113b44c:	18802d1e 	bne	r3,r2,8113b504 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b450:	e0bff60b 	ldhu	r2,-40(fp)
8113b454:	100b883a 	mov	r5,r2
8113b458:	e13ff117 	ldw	r4,-60(fp)
8113b45c:	113b8bc0 	call	8113b8bc <OS_FlagTaskRdy>
8113b460:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b464:	e0bff683 	ldbu	r2,-38(fp)
8113b468:	10800058 	cmpnei	r2,r2,1
8113b46c:	1000251e 	bne	r2,zero,8113b504 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b470:	00800044 	movi	r2,1
8113b474:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b478:	00002206 	br	8113b504 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113b47c:	e0bffc17 	ldw	r2,-16(fp)
8113b480:	1080020b 	ldhu	r2,8(r2)
8113b484:	0084303a 	nor	r2,zero,r2
8113b488:	1007883a 	mov	r3,r2
8113b48c:	e0bff117 	ldw	r2,-60(fp)
8113b490:	1080040b 	ldhu	r2,16(r2)
8113b494:	1884703a 	and	r2,r3,r2
8113b498:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113b49c:	e0bff60b 	ldhu	r2,-40(fp)
8113b4a0:	10001a26 	beq	r2,zero,8113b50c <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113b4a4:	e0bff60b 	ldhu	r2,-40(fp)
8113b4a8:	100b883a 	mov	r5,r2
8113b4ac:	e13ff117 	ldw	r4,-60(fp)
8113b4b0:	113b8bc0 	call	8113b8bc <OS_FlagTaskRdy>
8113b4b4:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113b4b8:	e0bff683 	ldbu	r2,-38(fp)
8113b4bc:	10800058 	cmpnei	r2,r2,1
8113b4c0:	1000121e 	bne	r2,zero,8113b50c <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113b4c4:	00800044 	movi	r2,1
8113b4c8:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113b4cc:	00000f06 	br	8113b50c <OSFlagPost+0x308>
8113b4d0:	e0bff317 	ldw	r2,-52(fp)
8113b4d4:	e0bff515 	stw	r2,-44(fp)
8113b4d8:	e0bff517 	ldw	r2,-44(fp)
8113b4dc:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113b4e0:	e0bfff17 	ldw	r2,-4(fp)
8113b4e4:	00c01bc4 	movi	r3,111
8113b4e8:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113b4ec:	0005883a 	mov	r2,zero
8113b4f0:	00002606 	br	8113b58c <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b4f4:	0001883a 	nop
8113b4f8:	00000506 	br	8113b510 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b4fc:	0001883a 	nop
8113b500:	00000306 	br	8113b510 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b504:	0001883a 	nop
8113b508:	00000106 	br	8113b510 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113b50c:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113b510:	e0bff117 	ldw	r2,-60(fp)
8113b514:	10800017 	ldw	r2,0(r2)
8113b518:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113b51c:	e0bff117 	ldw	r2,-60(fp)
8113b520:	103f871e 	bne	r2,zero,8113b340 <__reset+0xfb11b340>
8113b524:	e0bff317 	ldw	r2,-52(fp)
8113b528:	e0bff715 	stw	r2,-36(fp)
8113b52c:	e0bff717 	ldw	r2,-36(fp)
8113b530:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8113b534:	e0bff203 	ldbu	r2,-56(fp)
8113b538:	10800058 	cmpnei	r2,r2,1
8113b53c:	1000011e 	bne	r2,zero,8113b544 <OSFlagPost+0x340>
        OS_Sched();
8113b540:	11399cc0 	call	811399cc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b544:	0005303a 	rdctl	r2,status
8113b548:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b54c:	e0fffa17 	ldw	r3,-24(fp)
8113b550:	00bfff84 	movi	r2,-2
8113b554:	1884703a 	and	r2,r3,r2
8113b558:	1001703a 	wrctl	status,r2
  
  return context;
8113b55c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113b560:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8113b564:	e0bffc17 	ldw	r2,-16(fp)
8113b568:	1080020b 	ldhu	r2,8(r2)
8113b56c:	e0bff90d 	sth	r2,-28(fp)
8113b570:	e0bff317 	ldw	r2,-52(fp)
8113b574:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b578:	e0bff817 	ldw	r2,-32(fp)
8113b57c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113b580:	e0bfff17 	ldw	r2,-4(fp)
8113b584:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113b588:	e0bff90b 	ldhu	r2,-28(fp)
}
8113b58c:	e037883a 	mov	sp,fp
8113b590:	dfc00117 	ldw	ra,4(sp)
8113b594:	df000017 	ldw	fp,0(sp)
8113b598:	dec00204 	addi	sp,sp,8
8113b59c:	f800283a 	ret

8113b5a0 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113b5a0:	defff904 	addi	sp,sp,-28
8113b5a4:	de00012e 	bgeu	sp,et,8113b5ac <OSFlagQuery+0xc>
8113b5a8:	003b68fa 	trap	3
8113b5ac:	df000615 	stw	fp,24(sp)
8113b5b0:	df000604 	addi	fp,sp,24
8113b5b4:	e13ffe15 	stw	r4,-8(fp)
8113b5b8:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113b5bc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113b5c0:	e0bfff17 	ldw	r2,-4(fp)
8113b5c4:	1000021e 	bne	r2,zero,8113b5d0 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113b5c8:	0005883a 	mov	r2,zero
8113b5cc:	00002306 	br	8113b65c <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113b5d0:	e0bffe17 	ldw	r2,-8(fp)
8113b5d4:	1000051e 	bne	r2,zero,8113b5ec <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113b5d8:	e0bfff17 	ldw	r2,-4(fp)
8113b5dc:	00c01b84 	movi	r3,110
8113b5e0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b5e4:	0005883a 	mov	r2,zero
8113b5e8:	00001c06 	br	8113b65c <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8113b5ec:	e0bffe17 	ldw	r2,-8(fp)
8113b5f0:	10800003 	ldbu	r2,0(r2)
8113b5f4:	10803fcc 	andi	r2,r2,255
8113b5f8:	10800160 	cmpeqi	r2,r2,5
8113b5fc:	1000051e 	bne	r2,zero,8113b614 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113b600:	e0bfff17 	ldw	r2,-4(fp)
8113b604:	00c00044 	movi	r3,1
8113b608:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113b60c:	0005883a 	mov	r2,zero
8113b610:	00001206 	br	8113b65c <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b614:	0005303a 	rdctl	r2,status
8113b618:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b61c:	e0fffc17 	ldw	r3,-16(fp)
8113b620:	00bfff84 	movi	r2,-2
8113b624:	1884703a 	and	r2,r3,r2
8113b628:	1001703a 	wrctl	status,r2
  
  return context;
8113b62c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b630:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8113b634:	e0bffe17 	ldw	r2,-8(fp)
8113b638:	1080020b 	ldhu	r2,8(r2)
8113b63c:	e0bffb0d 	sth	r2,-20(fp)
8113b640:	e0bffa17 	ldw	r2,-24(fp)
8113b644:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b648:	e0bffd17 	ldw	r2,-12(fp)
8113b64c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b650:	e0bfff17 	ldw	r2,-4(fp)
8113b654:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113b658:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113b65c:	e037883a 	mov	sp,fp
8113b660:	df000017 	ldw	fp,0(sp)
8113b664:	dec00104 	addi	sp,sp,4
8113b668:	f800283a 	ret

8113b66c <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113b66c:	defff804 	addi	sp,sp,-32
8113b670:	de00012e 	bgeu	sp,et,8113b678 <OS_FlagBlock+0xc>
8113b674:	003b68fa 	trap	3
8113b678:	df000715 	stw	fp,28(sp)
8113b67c:	df000704 	addi	fp,sp,28
8113b680:	e13ffb15 	stw	r4,-20(fp)
8113b684:	e17ffc15 	stw	r5,-16(fp)
8113b688:	3009883a 	mov	r4,r6
8113b68c:	3807883a 	mov	r3,r7
8113b690:	e0800117 	ldw	r2,4(fp)
8113b694:	e13ffd0d 	sth	r4,-12(fp)
8113b698:	e0fffe05 	stb	r3,-8(fp)
8113b69c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113b6a0:	d0a0a217 	ldw	r2,-32120(gp)
8113b6a4:	d0e0a217 	ldw	r3,-32120(gp)
8113b6a8:	18c00c03 	ldbu	r3,48(r3)
8113b6ac:	18c00814 	ori	r3,r3,32
8113b6b0:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113b6b4:	d0a0a217 	ldw	r2,-32120(gp)
8113b6b8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113b6bc:	d0a0a217 	ldw	r2,-32120(gp)
8113b6c0:	e0ffff0b 	ldhu	r3,-4(fp)
8113b6c4:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113b6c8:	d0a0a217 	ldw	r2,-32120(gp)
8113b6cc:	e0fffc17 	ldw	r3,-16(fp)
8113b6d0:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113b6d4:	e0bffc17 	ldw	r2,-16(fp)
8113b6d8:	e0fffd0b 	ldhu	r3,-12(fp)
8113b6dc:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113b6e0:	e0bffc17 	ldw	r2,-16(fp)
8113b6e4:	e0fffe03 	ldbu	r3,-8(fp)
8113b6e8:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8113b6ec:	d0e0a217 	ldw	r3,-32120(gp)
8113b6f0:	e0bffc17 	ldw	r2,-16(fp)
8113b6f4:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113b6f8:	e0bffb17 	ldw	r2,-20(fp)
8113b6fc:	10c00117 	ldw	r3,4(r2)
8113b700:	e0bffc17 	ldw	r2,-16(fp)
8113b704:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113b708:	e0bffc17 	ldw	r2,-16(fp)
8113b70c:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113b710:	e0bffc17 	ldw	r2,-16(fp)
8113b714:	e0fffb17 	ldw	r3,-20(fp)
8113b718:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113b71c:	e0bffb17 	ldw	r2,-20(fp)
8113b720:	10800117 	ldw	r2,4(r2)
8113b724:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113b728:	e0bff917 	ldw	r2,-28(fp)
8113b72c:	10000326 	beq	r2,zero,8113b73c <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113b730:	e0bff917 	ldw	r2,-28(fp)
8113b734:	e0fffc17 	ldw	r3,-16(fp)
8113b738:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113b73c:	e0bffb17 	ldw	r2,-20(fp)
8113b740:	e0fffc17 	ldw	r3,-16(fp)
8113b744:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113b748:	d0a0a217 	ldw	r2,-32120(gp)
8113b74c:	10800d03 	ldbu	r2,52(r2)
8113b750:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113b754:	e0fffa03 	ldbu	r3,-24(fp)
8113b758:	e13ffa03 	ldbu	r4,-24(fp)
8113b75c:	d0a09e44 	addi	r2,gp,-32135
8113b760:	2085883a 	add	r2,r4,r2
8113b764:	10800003 	ldbu	r2,0(r2)
8113b768:	1009883a 	mov	r4,r2
8113b76c:	d0a0a217 	ldw	r2,-32120(gp)
8113b770:	10800d43 	ldbu	r2,53(r2)
8113b774:	0084303a 	nor	r2,zero,r2
8113b778:	2084703a 	and	r2,r4,r2
8113b77c:	1009883a 	mov	r4,r2
8113b780:	d0a09e44 	addi	r2,gp,-32135
8113b784:	1885883a 	add	r2,r3,r2
8113b788:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113b78c:	e0fffa03 	ldbu	r3,-24(fp)
8113b790:	d0a09e44 	addi	r2,gp,-32135
8113b794:	1885883a 	add	r2,r3,r2
8113b798:	10800003 	ldbu	r2,0(r2)
8113b79c:	10803fcc 	andi	r2,r2,255
8113b7a0:	1000071e 	bne	r2,zero,8113b7c0 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113b7a4:	d0a0a217 	ldw	r2,-32120(gp)
8113b7a8:	10800d83 	ldbu	r2,54(r2)
8113b7ac:	0084303a 	nor	r2,zero,r2
8113b7b0:	1007883a 	mov	r3,r2
8113b7b4:	d0a09e03 	ldbu	r2,-32136(gp)
8113b7b8:	1884703a 	and	r2,r3,r2
8113b7bc:	d0a09e05 	stb	r2,-32136(gp)
    }
}
8113b7c0:	0001883a 	nop
8113b7c4:	e037883a 	mov	sp,fp
8113b7c8:	df000017 	ldw	fp,0(sp)
8113b7cc:	dec00104 	addi	sp,sp,4
8113b7d0:	f800283a 	ret

8113b7d4 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8113b7d4:	defffb04 	addi	sp,sp,-20
8113b7d8:	de00012e 	bgeu	sp,et,8113b7e0 <OS_FlagInit+0xc>
8113b7dc:	003b68fa 	trap	3
8113b7e0:	dfc00415 	stw	ra,16(sp)
8113b7e4:	df000315 	stw	fp,12(sp)
8113b7e8:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8113b7ec:	01421004 	movi	r5,2112
8113b7f0:	012045b4 	movhi	r4,33046
8113b7f4:	211b0504 	addi	r4,r4,27668
8113b7f8:	11399000 	call	81139900 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8113b7fc:	00a045b4 	movhi	r2,33046
8113b800:	109b0504 	addi	r2,r2,27668
8113b804:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113b808:	00a045b4 	movhi	r2,33046
8113b80c:	109b1004 	addi	r2,r2,27712
8113b810:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113b814:	e03ffd0d 	sth	zero,-12(fp)
8113b818:	00001306 	br	8113b868 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113b81c:	e0bffe17 	ldw	r2,-8(fp)
8113b820:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8113b824:	e0bffe17 	ldw	r2,-8(fp)
8113b828:	e0ffff17 	ldw	r3,-4(fp)
8113b82c:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113b830:	e0bffe17 	ldw	r2,-8(fp)
8113b834:	00c00fc4 	movi	r3,63
8113b838:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113b83c:	e0bffe17 	ldw	r2,-8(fp)
8113b840:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8113b844:	e0bffe17 	ldw	r2,-8(fp)
8113b848:	10800b04 	addi	r2,r2,44
8113b84c:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113b850:	e0bfff17 	ldw	r2,-4(fp)
8113b854:	10800b04 	addi	r2,r2,44
8113b858:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113b85c:	e0bffd0b 	ldhu	r2,-12(fp)
8113b860:	10800044 	addi	r2,r2,1
8113b864:	e0bffd0d 	sth	r2,-12(fp)
8113b868:	e0bffd0b 	ldhu	r2,-12(fp)
8113b86c:	10800bf0 	cmpltui	r2,r2,47
8113b870:	103fea1e 	bne	r2,zero,8113b81c <__reset+0xfb11b81c>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113b874:	e0bffe17 	ldw	r2,-8(fp)
8113b878:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113b87c:	e0bffe17 	ldw	r2,-8(fp)
8113b880:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8113b884:	e0bffe17 	ldw	r2,-8(fp)
8113b888:	00c00fc4 	movi	r3,63
8113b88c:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113b890:	e0bffe17 	ldw	r2,-8(fp)
8113b894:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113b898:	00a045b4 	movhi	r2,33046
8113b89c:	109b0504 	addi	r2,r2,27668
8113b8a0:	d0a0a615 	stw	r2,-32104(gp)
#endif
}
8113b8a4:	0001883a 	nop
8113b8a8:	e037883a 	mov	sp,fp
8113b8ac:	dfc00117 	ldw	ra,4(sp)
8113b8b0:	df000017 	ldw	fp,0(sp)
8113b8b4:	dec00204 	addi	sp,sp,8
8113b8b8:	f800283a 	ret

8113b8bc <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8113b8bc:	defffa04 	addi	sp,sp,-24
8113b8c0:	de00012e 	bgeu	sp,et,8113b8c8 <OS_FlagTaskRdy+0xc>
8113b8c4:	003b68fa 	trap	3
8113b8c8:	dfc00515 	stw	ra,20(sp)
8113b8cc:	df000415 	stw	fp,16(sp)
8113b8d0:	df000404 	addi	fp,sp,16
8113b8d4:	e13ffe15 	stw	r4,-8(fp)
8113b8d8:	2805883a 	mov	r2,r5
8113b8dc:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113b8e0:	e0bffe17 	ldw	r2,-8(fp)
8113b8e4:	10800217 	ldw	r2,8(r2)
8113b8e8:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8113b8ec:	e0bffd17 	ldw	r2,-12(fp)
8113b8f0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8113b8f4:	e0bffd17 	ldw	r2,-12(fp)
8113b8f8:	e0ffff0b 	ldhu	r3,-4(fp)
8113b8fc:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113b900:	e0bffd17 	ldw	r2,-12(fp)
8113b904:	10c00c03 	ldbu	r3,48(r2)
8113b908:	00bff7c4 	movi	r2,-33
8113b90c:	1884703a 	and	r2,r3,r2
8113b910:	1007883a 	mov	r3,r2
8113b914:	e0bffd17 	ldw	r2,-12(fp)
8113b918:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113b91c:	e0bffd17 	ldw	r2,-12(fp)
8113b920:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8113b924:	e0bffd17 	ldw	r2,-12(fp)
8113b928:	10800c03 	ldbu	r2,48(r2)
8113b92c:	10803fcc 	andi	r2,r2,255
8113b930:	1000181e 	bne	r2,zero,8113b994 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8113b934:	e0bffd17 	ldw	r2,-12(fp)
8113b938:	10c00d83 	ldbu	r3,54(r2)
8113b93c:	d0a09e03 	ldbu	r2,-32136(gp)
8113b940:	1884b03a 	or	r2,r3,r2
8113b944:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113b948:	e0bffd17 	ldw	r2,-12(fp)
8113b94c:	10800d03 	ldbu	r2,52(r2)
8113b950:	10c03fcc 	andi	r3,r2,255
8113b954:	e0bffd17 	ldw	r2,-12(fp)
8113b958:	10800d03 	ldbu	r2,52(r2)
8113b95c:	11003fcc 	andi	r4,r2,255
8113b960:	d0a09e44 	addi	r2,gp,-32135
8113b964:	2085883a 	add	r2,r4,r2
8113b968:	11000003 	ldbu	r4,0(r2)
8113b96c:	e0bffd17 	ldw	r2,-12(fp)
8113b970:	10800d43 	ldbu	r2,53(r2)
8113b974:	2084b03a 	or	r2,r4,r2
8113b978:	1009883a 	mov	r4,r2
8113b97c:	d0a09e44 	addi	r2,gp,-32135
8113b980:	1885883a 	add	r2,r3,r2
8113b984:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113b988:	00800044 	movi	r2,1
8113b98c:	e0bffc05 	stb	r2,-16(fp)
8113b990:	00000106 	br	8113b998 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8113b994:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113b998:	e13ffe17 	ldw	r4,-8(fp)
8113b99c:	113b9b80 	call	8113b9b8 <OS_FlagUnlink>
    return (sched);
8113b9a0:	e0bffc03 	ldbu	r2,-16(fp)
}
8113b9a4:	e037883a 	mov	sp,fp
8113b9a8:	dfc00117 	ldw	ra,4(sp)
8113b9ac:	df000017 	ldw	fp,0(sp)
8113b9b0:	dec00204 	addi	sp,sp,8
8113b9b4:	f800283a 	ret

8113b9b8 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113b9b8:	defffa04 	addi	sp,sp,-24
8113b9bc:	de00012e 	bgeu	sp,et,8113b9c4 <OS_FlagUnlink+0xc>
8113b9c0:	003b68fa 	trap	3
8113b9c4:	df000515 	stw	fp,20(sp)
8113b9c8:	df000504 	addi	fp,sp,20
8113b9cc:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113b9d0:	e0bfff17 	ldw	r2,-4(fp)
8113b9d4:	10800117 	ldw	r2,4(r2)
8113b9d8:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113b9dc:	e0bfff17 	ldw	r2,-4(fp)
8113b9e0:	10800017 	ldw	r2,0(r2)
8113b9e4:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113b9e8:	e0bffb17 	ldw	r2,-20(fp)
8113b9ec:	10000b1e 	bne	r2,zero,8113ba1c <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113b9f0:	e0bfff17 	ldw	r2,-4(fp)
8113b9f4:	10800317 	ldw	r2,12(r2)
8113b9f8:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8113b9fc:	e0bffd17 	ldw	r2,-12(fp)
8113ba00:	e0fffc17 	ldw	r3,-16(fp)
8113ba04:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113ba08:	e0bffc17 	ldw	r2,-16(fp)
8113ba0c:	10000b26 	beq	r2,zero,8113ba3c <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113ba10:	e0bffc17 	ldw	r2,-16(fp)
8113ba14:	10000115 	stw	zero,4(r2)
8113ba18:	00000806 	br	8113ba3c <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113ba1c:	e0bffb17 	ldw	r2,-20(fp)
8113ba20:	e0fffc17 	ldw	r3,-16(fp)
8113ba24:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113ba28:	e0bffc17 	ldw	r2,-16(fp)
8113ba2c:	10000326 	beq	r2,zero,8113ba3c <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113ba30:	e0bffc17 	ldw	r2,-16(fp)
8113ba34:	e0fffb17 	ldw	r3,-20(fp)
8113ba38:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113ba3c:	e0bfff17 	ldw	r2,-4(fp)
8113ba40:	10800217 	ldw	r2,8(r2)
8113ba44:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113ba48:	e0bffe17 	ldw	r2,-8(fp)
8113ba4c:	10000a15 	stw	zero,40(r2)
#endif
}
8113ba50:	0001883a 	nop
8113ba54:	e037883a 	mov	sp,fp
8113ba58:	df000017 	ldw	fp,0(sp)
8113ba5c:	dec00104 	addi	sp,sp,4
8113ba60:	f800283a 	ret

8113ba64 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8113ba64:	defff404 	addi	sp,sp,-48
8113ba68:	de00012e 	bgeu	sp,et,8113ba70 <OSMemCreate+0xc>
8113ba6c:	003b68fa 	trap	3
8113ba70:	df000b15 	stw	fp,44(sp)
8113ba74:	df000b04 	addi	fp,sp,44
8113ba78:	e13ffc15 	stw	r4,-16(fp)
8113ba7c:	e17ffd15 	stw	r5,-12(fp)
8113ba80:	e1bffe15 	stw	r6,-8(fp)
8113ba84:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ba88:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113ba8c:	e0bfff17 	ldw	r2,-4(fp)
8113ba90:	1000021e 	bne	r2,zero,8113ba9c <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8113ba94:	0005883a 	mov	r2,zero
8113ba98:	00006506 	br	8113bc30 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113ba9c:	e0bffc17 	ldw	r2,-16(fp)
8113baa0:	1000051e 	bne	r2,zero,8113bab8 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113baa4:	e0bfff17 	ldw	r2,-4(fp)
8113baa8:	00c01884 	movi	r3,98
8113baac:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113bab0:	0005883a 	mov	r2,zero
8113bab4:	00005e06 	br	8113bc30 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113bab8:	e0bffc17 	ldw	r2,-16(fp)
8113babc:	108000cc 	andi	r2,r2,3
8113bac0:	10000526 	beq	r2,zero,8113bad8 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113bac4:	e0bfff17 	ldw	r2,-4(fp)
8113bac8:	00c01884 	movi	r3,98
8113bacc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113bad0:	0005883a 	mov	r2,zero
8113bad4:	00005606 	br	8113bc30 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113bad8:	e0bffd17 	ldw	r2,-12(fp)
8113badc:	108000a8 	cmpgeui	r2,r2,2
8113bae0:	1000051e 	bne	r2,zero,8113baf8 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8113bae4:	e0bfff17 	ldw	r2,-4(fp)
8113bae8:	00c016c4 	movi	r3,91
8113baec:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113baf0:	0005883a 	mov	r2,zero
8113baf4:	00004e06 	br	8113bc30 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113baf8:	e0bffe17 	ldw	r2,-8(fp)
8113bafc:	10800128 	cmpgeui	r2,r2,4
8113bb00:	1000051e 	bne	r2,zero,8113bb18 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8113bb04:	e0bfff17 	ldw	r2,-4(fp)
8113bb08:	00c01704 	movi	r3,92
8113bb0c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113bb10:	0005883a 	mov	r2,zero
8113bb14:	00004606 	br	8113bc30 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bb18:	0005303a 	rdctl	r2,status
8113bb1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bb20:	e0fffb17 	ldw	r3,-20(fp)
8113bb24:	00bfff84 	movi	r2,-2
8113bb28:	1884703a 	and	r2,r3,r2
8113bb2c:	1001703a 	wrctl	status,r2
  
  return context;
8113bb30:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bb34:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8113bb38:	d0a09b17 	ldw	r2,-32148(gp)
8113bb3c:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113bb40:	d0a09b17 	ldw	r2,-32148(gp)
8113bb44:	10000326 	beq	r2,zero,8113bb54 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8113bb48:	d0a09b17 	ldw	r2,-32148(gp)
8113bb4c:	10800117 	ldw	r2,4(r2)
8113bb50:	d0a09b15 	stw	r2,-32148(gp)
8113bb54:	e0bff817 	ldw	r2,-32(fp)
8113bb58:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bb5c:	e0bff917 	ldw	r2,-28(fp)
8113bb60:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8113bb64:	e0bffa17 	ldw	r2,-24(fp)
8113bb68:	1000051e 	bne	r2,zero,8113bb80 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113bb6c:	e0bfff17 	ldw	r2,-4(fp)
8113bb70:	00c01684 	movi	r3,90
8113bb74:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113bb78:	0005883a 	mov	r2,zero
8113bb7c:	00002c06 	br	8113bc30 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113bb80:	e0bffc17 	ldw	r2,-16(fp)
8113bb84:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8113bb88:	e0fffc17 	ldw	r3,-16(fp)
8113bb8c:	e0bffe17 	ldw	r2,-8(fp)
8113bb90:	1885883a 	add	r2,r3,r2
8113bb94:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8113bb98:	e03ff715 	stw	zero,-36(fp)
8113bb9c:	00000c06 	br	8113bbd0 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113bba0:	e0bff617 	ldw	r2,-40(fp)
8113bba4:	e0fff517 	ldw	r3,-44(fp)
8113bba8:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113bbac:	e0bff517 	ldw	r2,-44(fp)
8113bbb0:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8113bbb4:	e0fff517 	ldw	r3,-44(fp)
8113bbb8:	e0bffe17 	ldw	r2,-8(fp)
8113bbbc:	1885883a 	add	r2,r3,r2
8113bbc0:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8113bbc4:	e0bff717 	ldw	r2,-36(fp)
8113bbc8:	10800044 	addi	r2,r2,1
8113bbcc:	e0bff715 	stw	r2,-36(fp)
8113bbd0:	e0bffd17 	ldw	r2,-12(fp)
8113bbd4:	10bfffc4 	addi	r2,r2,-1
8113bbd8:	e0fff717 	ldw	r3,-36(fp)
8113bbdc:	18bff036 	bltu	r3,r2,8113bba0 <__reset+0xfb11bba0>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113bbe0:	e0bff617 	ldw	r2,-40(fp)
8113bbe4:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8113bbe8:	e0bffa17 	ldw	r2,-24(fp)
8113bbec:	e0fffc17 	ldw	r3,-16(fp)
8113bbf0:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8113bbf4:	e0bffa17 	ldw	r2,-24(fp)
8113bbf8:	e0fffc17 	ldw	r3,-16(fp)
8113bbfc:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113bc00:	e0bffa17 	ldw	r2,-24(fp)
8113bc04:	e0fffd17 	ldw	r3,-12(fp)
8113bc08:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8113bc0c:	e0bffa17 	ldw	r2,-24(fp)
8113bc10:	e0fffd17 	ldw	r3,-12(fp)
8113bc14:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8113bc18:	e0bffa17 	ldw	r2,-24(fp)
8113bc1c:	e0fffe17 	ldw	r3,-8(fp)
8113bc20:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8113bc24:	e0bfff17 	ldw	r2,-4(fp)
8113bc28:	10000005 	stb	zero,0(r2)
    return (pmem);
8113bc2c:	e0bffa17 	ldw	r2,-24(fp)
}
8113bc30:	e037883a 	mov	sp,fp
8113bc34:	df000017 	ldw	fp,0(sp)
8113bc38:	dec00104 	addi	sp,sp,4
8113bc3c:	f800283a 	ret

8113bc40 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113bc40:	defff804 	addi	sp,sp,-32
8113bc44:	de00012e 	bgeu	sp,et,8113bc4c <OSMemGet+0xc>
8113bc48:	003b68fa 	trap	3
8113bc4c:	df000715 	stw	fp,28(sp)
8113bc50:	df000704 	addi	fp,sp,28
8113bc54:	e13ffe15 	stw	r4,-8(fp)
8113bc58:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113bc5c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113bc60:	e0bfff17 	ldw	r2,-4(fp)
8113bc64:	1000021e 	bne	r2,zero,8113bc70 <OSMemGet+0x30>
        return ((void *)0);
8113bc68:	0005883a 	mov	r2,zero
8113bc6c:	00002e06 	br	8113bd28 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113bc70:	e0bffe17 	ldw	r2,-8(fp)
8113bc74:	1000051e 	bne	r2,zero,8113bc8c <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113bc78:	e0bfff17 	ldw	r2,-4(fp)
8113bc7c:	00c01804 	movi	r3,96
8113bc80:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113bc84:	0005883a 	mov	r2,zero
8113bc88:	00002706 	br	8113bd28 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bc8c:	0005303a 	rdctl	r2,status
8113bc90:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bc94:	e0fffd17 	ldw	r3,-12(fp)
8113bc98:	00bfff84 	movi	r2,-2
8113bc9c:	1884703a 	and	r2,r3,r2
8113bca0:	1001703a 	wrctl	status,r2
  
  return context;
8113bca4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bca8:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113bcac:	e0bffe17 	ldw	r2,-8(fp)
8113bcb0:	10800417 	ldw	r2,16(r2)
8113bcb4:	10001426 	beq	r2,zero,8113bd08 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8113bcb8:	e0bffe17 	ldw	r2,-8(fp)
8113bcbc:	10800117 	ldw	r2,4(r2)
8113bcc0:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8113bcc4:	e0bffb17 	ldw	r2,-20(fp)
8113bcc8:	10c00017 	ldw	r3,0(r2)
8113bccc:	e0bffe17 	ldw	r2,-8(fp)
8113bcd0:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8113bcd4:	e0bffe17 	ldw	r2,-8(fp)
8113bcd8:	10800417 	ldw	r2,16(r2)
8113bcdc:	10ffffc4 	addi	r3,r2,-1
8113bce0:	e0bffe17 	ldw	r2,-8(fp)
8113bce4:	10c00415 	stw	r3,16(r2)
8113bce8:	e0bff917 	ldw	r2,-28(fp)
8113bcec:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bcf0:	e0bffa17 	ldw	r2,-24(fp)
8113bcf4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8113bcf8:	e0bfff17 	ldw	r2,-4(fp)
8113bcfc:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113bd00:	e0bffb17 	ldw	r2,-20(fp)
8113bd04:	00000806 	br	8113bd28 <OSMemGet+0xe8>
8113bd08:	e0bff917 	ldw	r2,-28(fp)
8113bd0c:	e0bffc15 	stw	r2,-16(fp)
8113bd10:	e0bffc17 	ldw	r2,-16(fp)
8113bd14:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8113bd18:	e0bfff17 	ldw	r2,-4(fp)
8113bd1c:	00c01744 	movi	r3,93
8113bd20:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8113bd24:	0005883a 	mov	r2,zero
}
8113bd28:	e037883a 	mov	sp,fp
8113bd2c:	df000017 	ldw	fp,0(sp)
8113bd30:	dec00104 	addi	sp,sp,4
8113bd34:	f800283a 	ret

8113bd38 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113bd38:	defff704 	addi	sp,sp,-36
8113bd3c:	de00012e 	bgeu	sp,et,8113bd44 <OSMemNameGet+0xc>
8113bd40:	003b68fa 	trap	3
8113bd44:	dfc00815 	stw	ra,32(sp)
8113bd48:	df000715 	stw	fp,28(sp)
8113bd4c:	df000704 	addi	fp,sp,28
8113bd50:	e13ffd15 	stw	r4,-12(fp)
8113bd54:	e17ffe15 	stw	r5,-8(fp)
8113bd58:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bd5c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113bd60:	e0bfff17 	ldw	r2,-4(fp)
8113bd64:	1000021e 	bne	r2,zero,8113bd70 <OSMemNameGet+0x38>
        return (0);
8113bd68:	0005883a 	mov	r2,zero
8113bd6c:	00002b06 	br	8113be1c <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113bd70:	e0bffd17 	ldw	r2,-12(fp)
8113bd74:	1000051e 	bne	r2,zero,8113bd8c <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113bd78:	e0bfff17 	ldw	r2,-4(fp)
8113bd7c:	00c01804 	movi	r3,96
8113bd80:	10c00005 	stb	r3,0(r2)
        return (0);
8113bd84:	0005883a 	mov	r2,zero
8113bd88:	00002406 	br	8113be1c <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113bd8c:	e0bffe17 	ldw	r2,-8(fp)
8113bd90:	1000051e 	bne	r2,zero,8113bda8 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113bd94:	e0bfff17 	ldw	r2,-4(fp)
8113bd98:	00c00304 	movi	r3,12
8113bd9c:	10c00005 	stb	r3,0(r2)
        return (0);
8113bda0:	0005883a 	mov	r2,zero
8113bda4:	00001d06 	br	8113be1c <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113bda8:	d0a0a103 	ldbu	r2,-32124(gp)
8113bdac:	10803fcc 	andi	r2,r2,255
8113bdb0:	10000526 	beq	r2,zero,8113bdc8 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113bdb4:	e0bfff17 	ldw	r2,-4(fp)
8113bdb8:	00c00444 	movi	r3,17
8113bdbc:	10c00005 	stb	r3,0(r2)
        return (0);
8113bdc0:	0005883a 	mov	r2,zero
8113bdc4:	00001506 	br	8113be1c <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bdc8:	0005303a 	rdctl	r2,status
8113bdcc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bdd0:	e0fffb17 	ldw	r3,-20(fp)
8113bdd4:	00bfff84 	movi	r2,-2
8113bdd8:	1884703a 	and	r2,r3,r2
8113bddc:	1001703a 	wrctl	status,r2
  
  return context;
8113bde0:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113bde4:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113bde8:	e0bffd17 	ldw	r2,-12(fp)
8113bdec:	10800504 	addi	r2,r2,20
8113bdf0:	100b883a 	mov	r5,r2
8113bdf4:	e13ffe17 	ldw	r4,-8(fp)
8113bdf8:	1139b200 	call	81139b20 <OS_StrCopy>
8113bdfc:	e0bffa05 	stb	r2,-24(fp)
8113be00:	e0bff917 	ldw	r2,-28(fp)
8113be04:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113be08:	e0bffc17 	ldw	r2,-16(fp)
8113be0c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113be10:	e0bfff17 	ldw	r2,-4(fp)
8113be14:	10000005 	stb	zero,0(r2)
    return (len);
8113be18:	e0bffa03 	ldbu	r2,-24(fp)
}
8113be1c:	e037883a 	mov	sp,fp
8113be20:	dfc00117 	ldw	ra,4(sp)
8113be24:	df000017 	ldw	fp,0(sp)
8113be28:	dec00204 	addi	sp,sp,8
8113be2c:	f800283a 	ret

8113be30 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113be30:	defff604 	addi	sp,sp,-40
8113be34:	de00012e 	bgeu	sp,et,8113be3c <OSMemNameSet+0xc>
8113be38:	003b68fa 	trap	3
8113be3c:	dfc00915 	stw	ra,36(sp)
8113be40:	df000815 	stw	fp,32(sp)
8113be44:	df000804 	addi	fp,sp,32
8113be48:	e13ffd15 	stw	r4,-12(fp)
8113be4c:	e17ffe15 	stw	r5,-8(fp)
8113be50:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113be54:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113be58:	e0bfff17 	ldw	r2,-4(fp)
8113be5c:	10003526 	beq	r2,zero,8113bf34 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113be60:	e0bffd17 	ldw	r2,-12(fp)
8113be64:	1000041e 	bne	r2,zero,8113be78 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113be68:	e0bfff17 	ldw	r2,-4(fp)
8113be6c:	00c01804 	movi	r3,96
8113be70:	10c00005 	stb	r3,0(r2)
        return;
8113be74:	00003006 	br	8113bf38 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113be78:	e0bffe17 	ldw	r2,-8(fp)
8113be7c:	1000041e 	bne	r2,zero,8113be90 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113be80:	e0bfff17 	ldw	r2,-4(fp)
8113be84:	00c00304 	movi	r3,12
8113be88:	10c00005 	stb	r3,0(r2)
        return;
8113be8c:	00002a06 	br	8113bf38 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113be90:	d0a0a103 	ldbu	r2,-32124(gp)
8113be94:	10803fcc 	andi	r2,r2,255
8113be98:	10000426 	beq	r2,zero,8113beac <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113be9c:	e0bfff17 	ldw	r2,-4(fp)
8113bea0:	00c00484 	movi	r3,18
8113bea4:	10c00005 	stb	r3,0(r2)
        return;
8113bea8:	00002306 	br	8113bf38 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113beac:	0005303a 	rdctl	r2,status
8113beb0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113beb4:	e0fffc17 	ldw	r3,-16(fp)
8113beb8:	00bfff84 	movi	r2,-2
8113bebc:	1884703a 	and	r2,r3,r2
8113bec0:	1001703a 	wrctl	status,r2
  
  return context;
8113bec4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bec8:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113becc:	e13ffe17 	ldw	r4,-8(fp)
8113bed0:	1139b9c0 	call	81139b9c <OS_StrLen>
8113bed4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113bed8:	e0bffa03 	ldbu	r2,-24(fp)
8113bedc:	10800830 	cmpltui	r2,r2,32
8113bee0:	1000081e 	bne	r2,zero,8113bf04 <OSMemNameSet+0xd4>
8113bee4:	e0bff817 	ldw	r2,-32(fp)
8113bee8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113beec:	e0bff917 	ldw	r2,-28(fp)
8113bef0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113bef4:	e0bfff17 	ldw	r2,-4(fp)
8113bef8:	00c018c4 	movi	r3,99
8113befc:	10c00005 	stb	r3,0(r2)
        return;
8113bf00:	00000d06 	br	8113bf38 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113bf04:	e0bffd17 	ldw	r2,-12(fp)
8113bf08:	10800504 	addi	r2,r2,20
8113bf0c:	e17ffe17 	ldw	r5,-8(fp)
8113bf10:	1009883a 	mov	r4,r2
8113bf14:	1139b200 	call	81139b20 <OS_StrCopy>
8113bf18:	e0bff817 	ldw	r2,-32(fp)
8113bf1c:	e0bffb15 	stw	r2,-20(fp)
8113bf20:	e0bffb17 	ldw	r2,-20(fp)
8113bf24:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113bf28:	e0bfff17 	ldw	r2,-4(fp)
8113bf2c:	10000005 	stb	zero,0(r2)
8113bf30:	00000106 	br	8113bf38 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113bf34:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113bf38:	e037883a 	mov	sp,fp
8113bf3c:	dfc00117 	ldw	ra,4(sp)
8113bf40:	df000017 	ldw	fp,0(sp)
8113bf44:	dec00204 	addi	sp,sp,8
8113bf48:	f800283a 	ret

8113bf4c <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113bf4c:	defff904 	addi	sp,sp,-28
8113bf50:	de00012e 	bgeu	sp,et,8113bf58 <OSMemPut+0xc>
8113bf54:	003b68fa 	trap	3
8113bf58:	df000615 	stw	fp,24(sp)
8113bf5c:	df000604 	addi	fp,sp,24
8113bf60:	e13ffe15 	stw	r4,-8(fp)
8113bf64:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bf68:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113bf6c:	e0bffe17 	ldw	r2,-8(fp)
8113bf70:	1000021e 	bne	r2,zero,8113bf7c <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113bf74:	00801804 	movi	r2,96
8113bf78:	00002806 	br	8113c01c <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113bf7c:	e0bfff17 	ldw	r2,-4(fp)
8113bf80:	1000021e 	bne	r2,zero,8113bf8c <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113bf84:	008017c4 	movi	r2,95
8113bf88:	00002406 	br	8113c01c <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bf8c:	0005303a 	rdctl	r2,status
8113bf90:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bf94:	e0fffd17 	ldw	r3,-12(fp)
8113bf98:	00bfff84 	movi	r2,-2
8113bf9c:	1884703a 	and	r2,r3,r2
8113bfa0:	1001703a 	wrctl	status,r2
  
  return context;
8113bfa4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bfa8:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113bfac:	e0bffe17 	ldw	r2,-8(fp)
8113bfb0:	10c00417 	ldw	r3,16(r2)
8113bfb4:	e0bffe17 	ldw	r2,-8(fp)
8113bfb8:	10800317 	ldw	r2,12(r2)
8113bfbc:	18800636 	bltu	r3,r2,8113bfd8 <OSMemPut+0x8c>
8113bfc0:	e0bffa17 	ldw	r2,-24(fp)
8113bfc4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bfc8:	e0bffb17 	ldw	r2,-20(fp)
8113bfcc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113bfd0:	00801784 	movi	r2,94
8113bfd4:	00001106 	br	8113c01c <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113bfd8:	e0bffe17 	ldw	r2,-8(fp)
8113bfdc:	10c00117 	ldw	r3,4(r2)
8113bfe0:	e0bfff17 	ldw	r2,-4(fp)
8113bfe4:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113bfe8:	e0bffe17 	ldw	r2,-8(fp)
8113bfec:	e0ffff17 	ldw	r3,-4(fp)
8113bff0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113bff4:	e0bffe17 	ldw	r2,-8(fp)
8113bff8:	10800417 	ldw	r2,16(r2)
8113bffc:	10c00044 	addi	r3,r2,1
8113c000:	e0bffe17 	ldw	r2,-8(fp)
8113c004:	10c00415 	stw	r3,16(r2)
8113c008:	e0bffa17 	ldw	r2,-24(fp)
8113c00c:	e0bffc15 	stw	r2,-16(fp)
8113c010:	e0bffc17 	ldw	r2,-16(fp)
8113c014:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113c018:	0005883a 	mov	r2,zero
}
8113c01c:	e037883a 	mov	sp,fp
8113c020:	df000017 	ldw	fp,0(sp)
8113c024:	dec00104 	addi	sp,sp,4
8113c028:	f800283a 	ret

8113c02c <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113c02c:	defffa04 	addi	sp,sp,-24
8113c030:	de00012e 	bgeu	sp,et,8113c038 <OSMemQuery+0xc>
8113c034:	003b68fa 	trap	3
8113c038:	df000515 	stw	fp,20(sp)
8113c03c:	df000504 	addi	fp,sp,20
8113c040:	e13ffe15 	stw	r4,-8(fp)
8113c044:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c048:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113c04c:	e0bffe17 	ldw	r2,-8(fp)
8113c050:	1000021e 	bne	r2,zero,8113c05c <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113c054:	00801804 	movi	r2,96
8113c058:	00002c06 	br	8113c10c <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113c05c:	e0bfff17 	ldw	r2,-4(fp)
8113c060:	1000021e 	bne	r2,zero,8113c06c <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113c064:	00801844 	movi	r2,97
8113c068:	00002806 	br	8113c10c <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c06c:	0005303a 	rdctl	r2,status
8113c070:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c074:	e0fffc17 	ldw	r3,-16(fp)
8113c078:	00bfff84 	movi	r2,-2
8113c07c:	1884703a 	and	r2,r3,r2
8113c080:	1001703a 	wrctl	status,r2
  
  return context;
8113c084:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113c088:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113c08c:	e0bffe17 	ldw	r2,-8(fp)
8113c090:	10c00017 	ldw	r3,0(r2)
8113c094:	e0bfff17 	ldw	r2,-4(fp)
8113c098:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113c09c:	e0bffe17 	ldw	r2,-8(fp)
8113c0a0:	10c00117 	ldw	r3,4(r2)
8113c0a4:	e0bfff17 	ldw	r2,-4(fp)
8113c0a8:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113c0ac:	e0bffe17 	ldw	r2,-8(fp)
8113c0b0:	10c00217 	ldw	r3,8(r2)
8113c0b4:	e0bfff17 	ldw	r2,-4(fp)
8113c0b8:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113c0bc:	e0bffe17 	ldw	r2,-8(fp)
8113c0c0:	10c00317 	ldw	r3,12(r2)
8113c0c4:	e0bfff17 	ldw	r2,-4(fp)
8113c0c8:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113c0cc:	e0bffe17 	ldw	r2,-8(fp)
8113c0d0:	10c00417 	ldw	r3,16(r2)
8113c0d4:	e0bfff17 	ldw	r2,-4(fp)
8113c0d8:	10c00415 	stw	r3,16(r2)
8113c0dc:	e0bffb17 	ldw	r2,-20(fp)
8113c0e0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c0e4:	e0bffd17 	ldw	r2,-12(fp)
8113c0e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113c0ec:	e0bfff17 	ldw	r2,-4(fp)
8113c0f0:	10c00317 	ldw	r3,12(r2)
8113c0f4:	e0bfff17 	ldw	r2,-4(fp)
8113c0f8:	10800417 	ldw	r2,16(r2)
8113c0fc:	1887c83a 	sub	r3,r3,r2
8113c100:	e0bfff17 	ldw	r2,-4(fp)
8113c104:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113c108:	0005883a 	mov	r2,zero
}
8113c10c:	e037883a 	mov	sp,fp
8113c110:	df000017 	ldw	fp,0(sp)
8113c114:	dec00104 	addi	sp,sp,4
8113c118:	f800283a 	ret

8113c11c <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113c11c:	defffc04 	addi	sp,sp,-16
8113c120:	de00012e 	bgeu	sp,et,8113c128 <OS_MemInit+0xc>
8113c124:	003b68fa 	trap	3
8113c128:	dfc00315 	stw	ra,12(sp)
8113c12c:	df000215 	stw	fp,8(sp)
8113c130:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113c134:	01430c04 	movi	r5,3120
8113c138:	012045b4 	movhi	r4,33046
8113c13c:	211d7d04 	addi	r4,r4,30196
8113c140:	11399000 	call	81139900 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113c144:	00a045b4 	movhi	r2,33046
8113c148:	109d7d04 	addi	r2,r2,30196
8113c14c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113c150:	e03fff0d 	sth	zero,-4(fp)
8113c154:	00001306 	br	8113c1a4 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113c158:	e0bfff0b 	ldhu	r2,-4(fp)
8113c15c:	10800044 	addi	r2,r2,1
8113c160:	10c00d24 	muli	r3,r2,52
8113c164:	00a045b4 	movhi	r2,33046
8113c168:	109d7d04 	addi	r2,r2,30196
8113c16c:	1887883a 	add	r3,r3,r2
8113c170:	e0bffe17 	ldw	r2,-8(fp)
8113c174:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113c178:	e0bffe17 	ldw	r2,-8(fp)
8113c17c:	00c00fc4 	movi	r3,63
8113c180:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113c184:	e0bffe17 	ldw	r2,-8(fp)
8113c188:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113c18c:	e0bffe17 	ldw	r2,-8(fp)
8113c190:	10800d04 	addi	r2,r2,52
8113c194:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113c198:	e0bfff0b 	ldhu	r2,-4(fp)
8113c19c:	10800044 	addi	r2,r2,1
8113c1a0:	e0bfff0d 	sth	r2,-4(fp)
8113c1a4:	e0bfff0b 	ldhu	r2,-4(fp)
8113c1a8:	10800ef0 	cmpltui	r2,r2,59
8113c1ac:	103fea1e 	bne	r2,zero,8113c158 <__reset+0xfb11c158>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113c1b0:	e0bffe17 	ldw	r2,-8(fp)
8113c1b4:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113c1b8:	e0bffe17 	ldw	r2,-8(fp)
8113c1bc:	00c00fc4 	movi	r3,63
8113c1c0:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113c1c4:	e0bffe17 	ldw	r2,-8(fp)
8113c1c8:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113c1cc:	00a045b4 	movhi	r2,33046
8113c1d0:	109d7d04 	addi	r2,r2,30196
8113c1d4:	d0a09b15 	stw	r2,-32148(gp)
#endif
}
8113c1d8:	0001883a 	nop
8113c1dc:	e037883a 	mov	sp,fp
8113c1e0:	dfc00117 	ldw	ra,4(sp)
8113c1e4:	df000017 	ldw	fp,0(sp)
8113c1e8:	dec00204 	addi	sp,sp,8
8113c1ec:	f800283a 	ret

8113c1f0 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113c1f0:	defff704 	addi	sp,sp,-36
8113c1f4:	de00012e 	bgeu	sp,et,8113c1fc <OSMutexAccept+0xc>
8113c1f8:	003b68fa 	trap	3
8113c1fc:	df000815 	stw	fp,32(sp)
8113c200:	df000804 	addi	fp,sp,32
8113c204:	e13ffe15 	stw	r4,-8(fp)
8113c208:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113c20c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113c210:	e0bfff17 	ldw	r2,-4(fp)
8113c214:	1000021e 	bne	r2,zero,8113c220 <OSMutexAccept+0x30>
        return (OS_FALSE);
8113c218:	0005883a 	mov	r2,zero
8113c21c:	00005b06 	br	8113c38c <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113c220:	e0bffe17 	ldw	r2,-8(fp)
8113c224:	1000051e 	bne	r2,zero,8113c23c <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113c228:	e0bfff17 	ldw	r2,-4(fp)
8113c22c:	00c00104 	movi	r3,4
8113c230:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c234:	0005883a 	mov	r2,zero
8113c238:	00005406 	br	8113c38c <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113c23c:	e0bffe17 	ldw	r2,-8(fp)
8113c240:	10800003 	ldbu	r2,0(r2)
8113c244:	10803fcc 	andi	r2,r2,255
8113c248:	10800120 	cmpeqi	r2,r2,4
8113c24c:	1000051e 	bne	r2,zero,8113c264 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113c250:	e0bfff17 	ldw	r2,-4(fp)
8113c254:	00c00044 	movi	r3,1
8113c258:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c25c:	0005883a 	mov	r2,zero
8113c260:	00004a06 	br	8113c38c <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113c264:	d0a0a103 	ldbu	r2,-32124(gp)
8113c268:	10803fcc 	andi	r2,r2,255
8113c26c:	10000526 	beq	r2,zero,8113c284 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113c270:	e0bfff17 	ldw	r2,-4(fp)
8113c274:	00c00084 	movi	r3,2
8113c278:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c27c:	0005883a 	mov	r2,zero
8113c280:	00004206 	br	8113c38c <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c284:	0005303a 	rdctl	r2,status
8113c288:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c28c:	e0fffd17 	ldw	r3,-12(fp)
8113c290:	00bfff84 	movi	r2,-2
8113c294:	1884703a 	and	r2,r3,r2
8113c298:	1001703a 	wrctl	status,r2
  
  return context;
8113c29c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113c2a0:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113c2a4:	e0bffe17 	ldw	r2,-8(fp)
8113c2a8:	1080020b 	ldhu	r2,8(r2)
8113c2ac:	10bfffcc 	andi	r2,r2,65535
8113c2b0:	1004d23a 	srli	r2,r2,8
8113c2b4:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113c2b8:	e0bffe17 	ldw	r2,-8(fp)
8113c2bc:	1080020b 	ldhu	r2,8(r2)
8113c2c0:	10bfffcc 	andi	r2,r2,65535
8113c2c4:	10803fcc 	andi	r2,r2,255
8113c2c8:	10803fd8 	cmpnei	r2,r2,255
8113c2cc:	1000281e 	bne	r2,zero,8113c370 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113c2d0:	e0bffe17 	ldw	r2,-8(fp)
8113c2d4:	10c0020b 	ldhu	r3,8(r2)
8113c2d8:	00bfc004 	movi	r2,-256
8113c2dc:	1884703a 	and	r2,r3,r2
8113c2e0:	1007883a 	mov	r3,r2
8113c2e4:	e0bffe17 	ldw	r2,-8(fp)
8113c2e8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113c2ec:	e0bffe17 	ldw	r2,-8(fp)
8113c2f0:	10c0020b 	ldhu	r3,8(r2)
8113c2f4:	d0a0a217 	ldw	r2,-32120(gp)
8113c2f8:	10800c83 	ldbu	r2,50(r2)
8113c2fc:	10803fcc 	andi	r2,r2,255
8113c300:	1884b03a 	or	r2,r3,r2
8113c304:	1007883a 	mov	r3,r2
8113c308:	e0bffe17 	ldw	r2,-8(fp)
8113c30c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113c310:	d0e0a217 	ldw	r3,-32120(gp)
8113c314:	e0bffe17 	ldw	r2,-8(fp)
8113c318:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113c31c:	d0a0a217 	ldw	r2,-32120(gp)
8113c320:	10800c83 	ldbu	r2,50(r2)
8113c324:	10803fcc 	andi	r2,r2,255
8113c328:	e0fffa03 	ldbu	r3,-24(fp)
8113c32c:	18800836 	bltu	r3,r2,8113c350 <OSMutexAccept+0x160>
8113c330:	e0bff817 	ldw	r2,-32(fp)
8113c334:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c338:	e0bff917 	ldw	r2,-28(fp)
8113c33c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113c340:	e0bfff17 	ldw	r2,-4(fp)
8113c344:	00c01e04 	movi	r3,120
8113c348:	10c00005 	stb	r3,0(r2)
8113c34c:	00000606 	br	8113c368 <OSMutexAccept+0x178>
8113c350:	e0bff817 	ldw	r2,-32(fp)
8113c354:	e0bffb15 	stw	r2,-20(fp)
8113c358:	e0bffb17 	ldw	r2,-20(fp)
8113c35c:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113c360:	e0bfff17 	ldw	r2,-4(fp)
8113c364:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113c368:	00800044 	movi	r2,1
8113c36c:	00000706 	br	8113c38c <OSMutexAccept+0x19c>
8113c370:	e0bff817 	ldw	r2,-32(fp)
8113c374:	e0bffc15 	stw	r2,-16(fp)
8113c378:	e0bffc17 	ldw	r2,-16(fp)
8113c37c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c380:	e0bfff17 	ldw	r2,-4(fp)
8113c384:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113c388:	0005883a 	mov	r2,zero
}
8113c38c:	e037883a 	mov	sp,fp
8113c390:	df000017 	ldw	fp,0(sp)
8113c394:	dec00104 	addi	sp,sp,4
8113c398:	f800283a 	ret

8113c39c <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113c39c:	defff604 	addi	sp,sp,-40
8113c3a0:	de00012e 	bgeu	sp,et,8113c3a8 <OSMutexCreate+0xc>
8113c3a4:	003b68fa 	trap	3
8113c3a8:	dfc00915 	stw	ra,36(sp)
8113c3ac:	df000815 	stw	fp,32(sp)
8113c3b0:	df000804 	addi	fp,sp,32
8113c3b4:	2005883a 	mov	r2,r4
8113c3b8:	e17fff15 	stw	r5,-4(fp)
8113c3bc:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c3c0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c3c4:	e0bfff17 	ldw	r2,-4(fp)
8113c3c8:	1000021e 	bne	r2,zero,8113c3d4 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113c3cc:	0005883a 	mov	r2,zero
8113c3d0:	00006106 	br	8113c558 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113c3d4:	e0bffe03 	ldbu	r2,-8(fp)
8113c3d8:	10800ab0 	cmpltui	r2,r2,42
8113c3dc:	1000051e 	bne	r2,zero,8113c3f4 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113c3e0:	e0bfff17 	ldw	r2,-4(fp)
8113c3e4:	00c00a84 	movi	r3,42
8113c3e8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c3ec:	0005883a 	mov	r2,zero
8113c3f0:	00005906 	br	8113c558 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c3f4:	d0a0a103 	ldbu	r2,-32124(gp)
8113c3f8:	10803fcc 	andi	r2,r2,255
8113c3fc:	10000526 	beq	r2,zero,8113c414 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113c400:	e0bfff17 	ldw	r2,-4(fp)
8113c404:	00c00404 	movi	r3,16
8113c408:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c40c:	0005883a 	mov	r2,zero
8113c410:	00005106 	br	8113c558 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c414:	0005303a 	rdctl	r2,status
8113c418:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c41c:	e0fffd17 	ldw	r3,-12(fp)
8113c420:	00bfff84 	movi	r2,-2
8113c424:	1884703a 	and	r2,r3,r2
8113c428:	1001703a 	wrctl	status,r2
  
  return context;
8113c42c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c430:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113c434:	e0fffe03 	ldbu	r3,-8(fp)
8113c438:	00a045f4 	movhi	r2,33047
8113c43c:	10b2f704 	addi	r2,r2,-13348
8113c440:	18c7883a 	add	r3,r3,r3
8113c444:	18c7883a 	add	r3,r3,r3
8113c448:	10c5883a 	add	r2,r2,r3
8113c44c:	10800017 	ldw	r2,0(r2)
8113c450:	10000926 	beq	r2,zero,8113c478 <OSMutexCreate+0xdc>
8113c454:	e0bff817 	ldw	r2,-32(fp)
8113c458:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c45c:	e0bff917 	ldw	r2,-28(fp)
8113c460:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113c464:	e0bfff17 	ldw	r2,-4(fp)
8113c468:	00c00a04 	movi	r3,40
8113c46c:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113c470:	0005883a 	mov	r2,zero
8113c474:	00003806 	br	8113c558 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113c478:	e0fffe03 	ldbu	r3,-8(fp)
8113c47c:	00a045f4 	movhi	r2,33047
8113c480:	10b2f704 	addi	r2,r2,-13348
8113c484:	18c7883a 	add	r3,r3,r3
8113c488:	18c7883a 	add	r3,r3,r3
8113c48c:	10c5883a 	add	r2,r2,r3
8113c490:	00c00044 	movi	r3,1
8113c494:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113c498:	d0a0a017 	ldw	r2,-32128(gp)
8113c49c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113c4a0:	e0bffb17 	ldw	r2,-20(fp)
8113c4a4:	1000101e 	bne	r2,zero,8113c4e8 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113c4a8:	e0fffe03 	ldbu	r3,-8(fp)
8113c4ac:	00a045f4 	movhi	r2,33047
8113c4b0:	10b2f704 	addi	r2,r2,-13348
8113c4b4:	18c7883a 	add	r3,r3,r3
8113c4b8:	18c7883a 	add	r3,r3,r3
8113c4bc:	10c5883a 	add	r2,r2,r3
8113c4c0:	10000015 	stw	zero,0(r2)
8113c4c4:	e0bff817 	ldw	r2,-32(fp)
8113c4c8:	e0bffa15 	stw	r2,-24(fp)
8113c4cc:	e0bffa17 	ldw	r2,-24(fp)
8113c4d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113c4d4:	e0bfff17 	ldw	r2,-4(fp)
8113c4d8:	00c00104 	movi	r3,4
8113c4dc:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c4e0:	e0bffb17 	ldw	r2,-20(fp)
8113c4e4:	00001c06 	br	8113c558 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113c4e8:	d0a0a017 	ldw	r2,-32128(gp)
8113c4ec:	10800117 	ldw	r2,4(r2)
8113c4f0:	d0a0a015 	stw	r2,-32128(gp)
8113c4f4:	e0bff817 	ldw	r2,-32(fp)
8113c4f8:	e0bffc15 	stw	r2,-16(fp)
8113c4fc:	e0bffc17 	ldw	r2,-16(fp)
8113c500:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113c504:	e0bffb17 	ldw	r2,-20(fp)
8113c508:	00c00104 	movi	r3,4
8113c50c:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113c510:	e0bffe03 	ldbu	r2,-8(fp)
8113c514:	1004923a 	slli	r2,r2,8
8113c518:	10803fd4 	ori	r2,r2,255
8113c51c:	1007883a 	mov	r3,r2
8113c520:	e0bffb17 	ldw	r2,-20(fp)
8113c524:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113c528:	e0bffb17 	ldw	r2,-20(fp)
8113c52c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113c530:	e0bffb17 	ldw	r2,-20(fp)
8113c534:	00c00fc4 	movi	r3,63
8113c538:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113c53c:	e0bffb17 	ldw	r2,-20(fp)
8113c540:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113c544:	e13ffb17 	ldw	r4,-20(fp)
8113c548:	11394e80 	call	811394e8 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113c54c:	e0bfff17 	ldw	r2,-4(fp)
8113c550:	10000005 	stb	zero,0(r2)
    return (pevent);
8113c554:	e0bffb17 	ldw	r2,-20(fp)
}
8113c558:	e037883a 	mov	sp,fp
8113c55c:	dfc00117 	ldw	ra,4(sp)
8113c560:	df000017 	ldw	fp,0(sp)
8113c564:	dec00204 	addi	sp,sp,8
8113c568:	f800283a 	ret

8113c56c <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113c56c:	defff004 	addi	sp,sp,-64
8113c570:	de00012e 	bgeu	sp,et,8113c578 <OSMutexDel+0xc>
8113c574:	003b68fa 	trap	3
8113c578:	dfc00f15 	stw	ra,60(sp)
8113c57c:	df000e15 	stw	fp,56(sp)
8113c580:	df000e04 	addi	fp,sp,56
8113c584:	e13ffd15 	stw	r4,-12(fp)
8113c588:	2805883a 	mov	r2,r5
8113c58c:	e1bfff15 	stw	r6,-4(fp)
8113c590:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c594:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c598:	e0bfff17 	ldw	r2,-4(fp)
8113c59c:	1000021e 	bne	r2,zero,8113c5a8 <OSMutexDel+0x3c>
        return (pevent);
8113c5a0:	e0bffd17 	ldw	r2,-12(fp)
8113c5a4:	0000ad06 	br	8113c85c <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113c5a8:	e0bffd17 	ldw	r2,-12(fp)
8113c5ac:	1000051e 	bne	r2,zero,8113c5c4 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113c5b0:	e0bfff17 	ldw	r2,-4(fp)
8113c5b4:	00c00104 	movi	r3,4
8113c5b8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c5bc:	e0bffd17 	ldw	r2,-12(fp)
8113c5c0:	0000a606 	br	8113c85c <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113c5c4:	e0bffd17 	ldw	r2,-12(fp)
8113c5c8:	10800003 	ldbu	r2,0(r2)
8113c5cc:	10803fcc 	andi	r2,r2,255
8113c5d0:	10800120 	cmpeqi	r2,r2,4
8113c5d4:	1000051e 	bne	r2,zero,8113c5ec <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113c5d8:	e0bfff17 	ldw	r2,-4(fp)
8113c5dc:	00c00044 	movi	r3,1
8113c5e0:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c5e4:	e0bffd17 	ldw	r2,-12(fp)
8113c5e8:	00009c06 	br	8113c85c <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c5ec:	d0a0a103 	ldbu	r2,-32124(gp)
8113c5f0:	10803fcc 	andi	r2,r2,255
8113c5f4:	10000526 	beq	r2,zero,8113c60c <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113c5f8:	e0bfff17 	ldw	r2,-4(fp)
8113c5fc:	00c003c4 	movi	r3,15
8113c600:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c604:	e0bffd17 	ldw	r2,-12(fp)
8113c608:	00009406 	br	8113c85c <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c60c:	0005303a 	rdctl	r2,status
8113c610:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c614:	e0fffc17 	ldw	r3,-16(fp)
8113c618:	00bfff84 	movi	r2,-2
8113c61c:	1884703a 	and	r2,r3,r2
8113c620:	1001703a 	wrctl	status,r2
  
  return context;
8113c624:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c628:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113c62c:	e0bffd17 	ldw	r2,-12(fp)
8113c630:	10800283 	ldbu	r2,10(r2)
8113c634:	10803fcc 	andi	r2,r2,255
8113c638:	10000326 	beq	r2,zero,8113c648 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113c63c:	00800044 	movi	r2,1
8113c640:	e0bff205 	stb	r2,-56(fp)
8113c644:	00000106 	br	8113c64c <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113c648:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113c64c:	e0bffe03 	ldbu	r2,-8(fp)
8113c650:	10000326 	beq	r2,zero,8113c660 <OSMutexDel+0xf4>
8113c654:	10800060 	cmpeqi	r2,r2,1
8113c658:	10002f1e 	bne	r2,zero,8113c718 <OSMutexDel+0x1ac>
8113c65c:	00007406 	br	8113c830 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113c660:	e0bff203 	ldbu	r2,-56(fp)
8113c664:	1000221e 	bne	r2,zero,8113c6f0 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113c668:	e0bffd17 	ldw	r2,-12(fp)
8113c66c:	00c00fc4 	movi	r3,63
8113c670:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113c674:	e0bffd17 	ldw	r2,-12(fp)
8113c678:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113c67c:	e0bffd17 	ldw	r2,-12(fp)
8113c680:	1080020b 	ldhu	r2,8(r2)
8113c684:	10bfffcc 	andi	r2,r2,65535
8113c688:	1004d23a 	srli	r2,r2,8
8113c68c:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113c690:	e0fff603 	ldbu	r3,-40(fp)
8113c694:	00a045f4 	movhi	r2,33047
8113c698:	10b2f704 	addi	r2,r2,-13348
8113c69c:	18c7883a 	add	r3,r3,r3
8113c6a0:	18c7883a 	add	r3,r3,r3
8113c6a4:	10c5883a 	add	r2,r2,r3
8113c6a8:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113c6ac:	e0bffd17 	ldw	r2,-12(fp)
8113c6b0:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113c6b4:	d0e0a017 	ldw	r3,-32128(gp)
8113c6b8:	e0bffd17 	ldw	r2,-12(fp)
8113c6bc:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113c6c0:	e0bffd17 	ldw	r2,-12(fp)
8113c6c4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113c6c8:	e0bffd17 	ldw	r2,-12(fp)
8113c6cc:	d0a0a015 	stw	r2,-32128(gp)
8113c6d0:	e0bff417 	ldw	r2,-48(fp)
8113c6d4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c6d8:	e0bff517 	ldw	r2,-44(fp)
8113c6dc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113c6e0:	e0bfff17 	ldw	r2,-4(fp)
8113c6e4:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113c6e8:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113c6ec:	00005a06 	br	8113c858 <OSMutexDel+0x2ec>
8113c6f0:	e0bff417 	ldw	r2,-48(fp)
8113c6f4:	e0bff715 	stw	r2,-36(fp)
8113c6f8:	e0bff717 	ldw	r2,-36(fp)
8113c6fc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113c700:	e0bfff17 	ldw	r2,-4(fp)
8113c704:	00c01244 	movi	r3,73
8113c708:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113c70c:	e0bffd17 	ldw	r2,-12(fp)
8113c710:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113c714:	00005006 	br	8113c858 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113c718:	e0bffd17 	ldw	r2,-12(fp)
8113c71c:	1080020b 	ldhu	r2,8(r2)
8113c720:	10bfffcc 	andi	r2,r2,65535
8113c724:	1004d23a 	srli	r2,r2,8
8113c728:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113c72c:	e0bffd17 	ldw	r2,-12(fp)
8113c730:	1080020b 	ldhu	r2,8(r2)
8113c734:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113c738:	e0bffd17 	ldw	r2,-12(fp)
8113c73c:	10800117 	ldw	r2,4(r2)
8113c740:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113c744:	e0bffa17 	ldw	r2,-24(fp)
8113c748:	10000f26 	beq	r2,zero,8113c788 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113c74c:	e0bffa17 	ldw	r2,-24(fp)
8113c750:	10800c83 	ldbu	r2,50(r2)
8113c754:	10c03fcc 	andi	r3,r2,255
8113c758:	e0bff603 	ldbu	r2,-40(fp)
8113c75c:	18800a1e 	bne	r3,r2,8113c788 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113c760:	e0bff903 	ldbu	r2,-28(fp)
8113c764:	100b883a 	mov	r5,r2
8113c768:	e13ffa17 	ldw	r4,-24(fp)
8113c76c:	113d1a80 	call	8113d1a8 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113c770:	00000506 	br	8113c788 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113c774:	000f883a 	mov	r7,zero
8113c778:	01800404 	movi	r6,16
8113c77c:	000b883a 	mov	r5,zero
8113c780:	e13ffd17 	ldw	r4,-12(fp)
8113c784:	1138f100 	call	81138f10 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113c788:	e0bffd17 	ldw	r2,-12(fp)
8113c78c:	10800283 	ldbu	r2,10(r2)
8113c790:	10803fcc 	andi	r2,r2,255
8113c794:	103ff71e 	bne	r2,zero,8113c774 <__reset+0xfb11c774>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113c798:	e0bffd17 	ldw	r2,-12(fp)
8113c79c:	00c00fc4 	movi	r3,63
8113c7a0:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113c7a4:	e0bffd17 	ldw	r2,-12(fp)
8113c7a8:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113c7ac:	e0bffd17 	ldw	r2,-12(fp)
8113c7b0:	1080020b 	ldhu	r2,8(r2)
8113c7b4:	10bfffcc 	andi	r2,r2,65535
8113c7b8:	1004d23a 	srli	r2,r2,8
8113c7bc:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113c7c0:	e0fff603 	ldbu	r3,-40(fp)
8113c7c4:	00a045f4 	movhi	r2,33047
8113c7c8:	10b2f704 	addi	r2,r2,-13348
8113c7cc:	18c7883a 	add	r3,r3,r3
8113c7d0:	18c7883a 	add	r3,r3,r3
8113c7d4:	10c5883a 	add	r2,r2,r3
8113c7d8:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113c7dc:	e0bffd17 	ldw	r2,-12(fp)
8113c7e0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113c7e4:	d0e0a017 	ldw	r3,-32128(gp)
8113c7e8:	e0bffd17 	ldw	r2,-12(fp)
8113c7ec:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113c7f0:	e0bffd17 	ldw	r2,-12(fp)
8113c7f4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113c7f8:	e0bffd17 	ldw	r2,-12(fp)
8113c7fc:	d0a0a015 	stw	r2,-32128(gp)
8113c800:	e0bff417 	ldw	r2,-48(fp)
8113c804:	e0bff815 	stw	r2,-32(fp)
8113c808:	e0bff817 	ldw	r2,-32(fp)
8113c80c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113c810:	e0bff203 	ldbu	r2,-56(fp)
8113c814:	10800058 	cmpnei	r2,r2,1
8113c818:	1000011e 	bne	r2,zero,8113c820 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113c81c:	11399cc0 	call	811399cc <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113c820:	e0bfff17 	ldw	r2,-4(fp)
8113c824:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113c828:	e03ff315 	stw	zero,-52(fp)
             break;
8113c82c:	00000a06 	br	8113c858 <OSMutexDel+0x2ec>
8113c830:	e0bff417 	ldw	r2,-48(fp)
8113c834:	e0bffb15 	stw	r2,-20(fp)
8113c838:	e0bffb17 	ldw	r2,-20(fp)
8113c83c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113c840:	e0bfff17 	ldw	r2,-4(fp)
8113c844:	00c001c4 	movi	r3,7
8113c848:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113c84c:	e0bffd17 	ldw	r2,-12(fp)
8113c850:	e0bff315 	stw	r2,-52(fp)
             break;
8113c854:	0001883a 	nop
    }
    return (pevent_return);
8113c858:	e0bff317 	ldw	r2,-52(fp)
}
8113c85c:	e037883a 	mov	sp,fp
8113c860:	dfc00117 	ldw	ra,4(sp)
8113c864:	df000017 	ldw	fp,0(sp)
8113c868:	dec00204 	addi	sp,sp,8
8113c86c:	f800283a 	ret

8113c870 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113c870:	deffee04 	addi	sp,sp,-72
8113c874:	de00012e 	bgeu	sp,et,8113c87c <OSMutexPend+0xc>
8113c878:	003b68fa 	trap	3
8113c87c:	dfc01115 	stw	ra,68(sp)
8113c880:	df001015 	stw	fp,64(sp)
8113c884:	df001004 	addi	fp,sp,64
8113c888:	e13ffd15 	stw	r4,-12(fp)
8113c88c:	2805883a 	mov	r2,r5
8113c890:	e1bfff15 	stw	r6,-4(fp)
8113c894:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c898:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c89c:	e0bfff17 	ldw	r2,-4(fp)
8113c8a0:	10015626 	beq	r2,zero,8113cdfc <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113c8a4:	e0bffd17 	ldw	r2,-12(fp)
8113c8a8:	1000041e 	bne	r2,zero,8113c8bc <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113c8ac:	e0bfff17 	ldw	r2,-4(fp)
8113c8b0:	00c00104 	movi	r3,4
8113c8b4:	10c00005 	stb	r3,0(r2)
        return;
8113c8b8:	00015106 	br	8113ce00 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113c8bc:	e0bffd17 	ldw	r2,-12(fp)
8113c8c0:	10800003 	ldbu	r2,0(r2)
8113c8c4:	10803fcc 	andi	r2,r2,255
8113c8c8:	10800120 	cmpeqi	r2,r2,4
8113c8cc:	1000041e 	bne	r2,zero,8113c8e0 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113c8d0:	e0bfff17 	ldw	r2,-4(fp)
8113c8d4:	00c00044 	movi	r3,1
8113c8d8:	10c00005 	stb	r3,0(r2)
        return;
8113c8dc:	00014806 	br	8113ce00 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c8e0:	d0a0a103 	ldbu	r2,-32124(gp)
8113c8e4:	10803fcc 	andi	r2,r2,255
8113c8e8:	10000426 	beq	r2,zero,8113c8fc <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113c8ec:	e0bfff17 	ldw	r2,-4(fp)
8113c8f0:	00c00084 	movi	r3,2
8113c8f4:	10c00005 	stb	r3,0(r2)
        return;
8113c8f8:	00014106 	br	8113ce00 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113c8fc:	d0a08f03 	ldbu	r2,-32196(gp)
8113c900:	10803fcc 	andi	r2,r2,255
8113c904:	10000426 	beq	r2,zero,8113c918 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113c908:	e0bfff17 	ldw	r2,-4(fp)
8113c90c:	00c00344 	movi	r3,13
8113c910:	10c00005 	stb	r3,0(r2)
        return;
8113c914:	00013a06 	br	8113ce00 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c918:	0005303a 	rdctl	r2,status
8113c91c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c920:	e0fffc17 	ldw	r3,-16(fp)
8113c924:	00bfff84 	movi	r2,-2
8113c928:	1884703a 	and	r2,r3,r2
8113c92c:	1001703a 	wrctl	status,r2
  
  return context;
8113c930:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113c934:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113c938:	e0bffd17 	ldw	r2,-12(fp)
8113c93c:	1080020b 	ldhu	r2,8(r2)
8113c940:	10bfffcc 	andi	r2,r2,65535
8113c944:	1004d23a 	srli	r2,r2,8
8113c948:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113c94c:	e0bffd17 	ldw	r2,-12(fp)
8113c950:	1080020b 	ldhu	r2,8(r2)
8113c954:	10803fcc 	andi	r2,r2,255
8113c958:	10803fd8 	cmpnei	r2,r2,255
8113c95c:	1000271e 	bne	r2,zero,8113c9fc <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113c960:	e0bffd17 	ldw	r2,-12(fp)
8113c964:	10c0020b 	ldhu	r3,8(r2)
8113c968:	00bfc004 	movi	r2,-256
8113c96c:	1884703a 	and	r2,r3,r2
8113c970:	1007883a 	mov	r3,r2
8113c974:	e0bffd17 	ldw	r2,-12(fp)
8113c978:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113c97c:	e0bffd17 	ldw	r2,-12(fp)
8113c980:	10c0020b 	ldhu	r3,8(r2)
8113c984:	d0a0a217 	ldw	r2,-32120(gp)
8113c988:	10800c83 	ldbu	r2,50(r2)
8113c98c:	10803fcc 	andi	r2,r2,255
8113c990:	1884b03a 	or	r2,r3,r2
8113c994:	1007883a 	mov	r3,r2
8113c998:	e0bffd17 	ldw	r2,-12(fp)
8113c99c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113c9a0:	d0e0a217 	ldw	r3,-32120(gp)
8113c9a4:	e0bffd17 	ldw	r2,-12(fp)
8113c9a8:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113c9ac:	d0a0a217 	ldw	r2,-32120(gp)
8113c9b0:	10800c83 	ldbu	r2,50(r2)
8113c9b4:	10803fcc 	andi	r2,r2,255
8113c9b8:	e0fff303 	ldbu	r3,-52(fp)
8113c9bc:	18800836 	bltu	r3,r2,8113c9e0 <OSMutexPend+0x170>
8113c9c0:	e0bff117 	ldw	r2,-60(fp)
8113c9c4:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c9c8:	e0bff217 	ldw	r2,-56(fp)
8113c9cc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113c9d0:	e0bfff17 	ldw	r2,-4(fp)
8113c9d4:	00c01e04 	movi	r3,120
8113c9d8:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113c9dc:	00010806 	br	8113ce00 <OSMutexPend+0x590>
8113c9e0:	e0bff117 	ldw	r2,-60(fp)
8113c9e4:	e0bff415 	stw	r2,-48(fp)
8113c9e8:	e0bff417 	ldw	r2,-48(fp)
8113c9ec:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113c9f0:	e0bfff17 	ldw	r2,-4(fp)
8113c9f4:	10000005 	stb	zero,0(r2)
        }
        return;
8113c9f8:	00010106 	br	8113ce00 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113c9fc:	e0bffd17 	ldw	r2,-12(fp)
8113ca00:	1080020b 	ldhu	r2,8(r2)
8113ca04:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113ca08:	e0bffd17 	ldw	r2,-12(fp)
8113ca0c:	10800117 	ldw	r2,4(r2)
8113ca10:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113ca14:	e0bff717 	ldw	r2,-36(fp)
8113ca18:	10800c83 	ldbu	r2,50(r2)
8113ca1c:	10803fcc 	andi	r2,r2,255
8113ca20:	e0fff303 	ldbu	r3,-52(fp)
8113ca24:	1880b92e 	bgeu	r3,r2,8113cd0c <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113ca28:	d0a0a217 	ldw	r2,-32120(gp)
8113ca2c:	10800c83 	ldbu	r2,50(r2)
8113ca30:	10c03fcc 	andi	r3,r2,255
8113ca34:	e0bff603 	ldbu	r2,-40(fp)
8113ca38:	1880b42e 	bgeu	r3,r2,8113cd0c <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113ca3c:	e0bff717 	ldw	r2,-36(fp)
8113ca40:	10800d03 	ldbu	r2,52(r2)
8113ca44:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113ca48:	e0fff803 	ldbu	r3,-32(fp)
8113ca4c:	d0a09e44 	addi	r2,gp,-32135
8113ca50:	1885883a 	add	r2,r3,r2
8113ca54:	10c00003 	ldbu	r3,0(r2)
8113ca58:	e0bff717 	ldw	r2,-36(fp)
8113ca5c:	10800d43 	ldbu	r2,53(r2)
8113ca60:	1884703a 	and	r2,r3,r2
8113ca64:	10803fcc 	andi	r2,r2,255
8113ca68:	10001e26 	beq	r2,zero,8113cae4 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113ca6c:	e0fff803 	ldbu	r3,-32(fp)
8113ca70:	e13ff803 	ldbu	r4,-32(fp)
8113ca74:	d0a09e44 	addi	r2,gp,-32135
8113ca78:	2085883a 	add	r2,r4,r2
8113ca7c:	10800003 	ldbu	r2,0(r2)
8113ca80:	1009883a 	mov	r4,r2
8113ca84:	e0bff717 	ldw	r2,-36(fp)
8113ca88:	10800d43 	ldbu	r2,53(r2)
8113ca8c:	0084303a 	nor	r2,zero,r2
8113ca90:	2084703a 	and	r2,r4,r2
8113ca94:	1009883a 	mov	r4,r2
8113ca98:	d0a09e44 	addi	r2,gp,-32135
8113ca9c:	1885883a 	add	r2,r3,r2
8113caa0:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113caa4:	e0fff803 	ldbu	r3,-32(fp)
8113caa8:	d0a09e44 	addi	r2,gp,-32135
8113caac:	1885883a 	add	r2,r3,r2
8113cab0:	10800003 	ldbu	r2,0(r2)
8113cab4:	10803fcc 	andi	r2,r2,255
8113cab8:	1000071e 	bne	r2,zero,8113cad8 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113cabc:	e0bff717 	ldw	r2,-36(fp)
8113cac0:	10800d83 	ldbu	r2,54(r2)
8113cac4:	0084303a 	nor	r2,zero,r2
8113cac8:	1007883a 	mov	r3,r2
8113cacc:	d0a09e03 	ldbu	r2,-32136(gp)
8113cad0:	1884703a 	and	r2,r3,r2
8113cad4:	d0a09e05 	stb	r2,-32136(gp)
                }
                rdy = OS_TRUE;
8113cad8:	00800044 	movi	r2,1
8113cadc:	e0bff005 	stb	r2,-64(fp)
8113cae0:	00002a06 	br	8113cb8c <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113cae4:	e0bff717 	ldw	r2,-36(fp)
8113cae8:	10800717 	ldw	r2,28(r2)
8113caec:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113caf0:	e0bff917 	ldw	r2,-28(fp)
8113caf4:	10002426 	beq	r2,zero,8113cb88 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113caf8:	e0bff717 	ldw	r2,-36(fp)
8113cafc:	10800d03 	ldbu	r2,52(r2)
8113cb00:	10803fcc 	andi	r2,r2,255
8113cb04:	e0fff717 	ldw	r3,-36(fp)
8113cb08:	18c00d03 	ldbu	r3,52(r3)
8113cb0c:	18c03fcc 	andi	r3,r3,255
8113cb10:	e13ff917 	ldw	r4,-28(fp)
8113cb14:	20c7883a 	add	r3,r4,r3
8113cb18:	18c002c4 	addi	r3,r3,11
8113cb1c:	18c00003 	ldbu	r3,0(r3)
8113cb20:	1809883a 	mov	r4,r3
8113cb24:	e0fff717 	ldw	r3,-36(fp)
8113cb28:	18c00d43 	ldbu	r3,53(r3)
8113cb2c:	00c6303a 	nor	r3,zero,r3
8113cb30:	20c6703a 	and	r3,r4,r3
8113cb34:	1809883a 	mov	r4,r3
8113cb38:	e0fff917 	ldw	r3,-28(fp)
8113cb3c:	1887883a 	add	r3,r3,r2
8113cb40:	18c002c4 	addi	r3,r3,11
8113cb44:	19000005 	stb	r4,0(r3)
8113cb48:	e0fff917 	ldw	r3,-28(fp)
8113cb4c:	1885883a 	add	r2,r3,r2
8113cb50:	108002c4 	addi	r2,r2,11
8113cb54:	10800003 	ldbu	r2,0(r2)
8113cb58:	10803fcc 	andi	r2,r2,255
8113cb5c:	10000a1e 	bne	r2,zero,8113cb88 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113cb60:	e0bff917 	ldw	r2,-28(fp)
8113cb64:	10800283 	ldbu	r2,10(r2)
8113cb68:	1007883a 	mov	r3,r2
8113cb6c:	e0bff717 	ldw	r2,-36(fp)
8113cb70:	10800d83 	ldbu	r2,54(r2)
8113cb74:	0084303a 	nor	r2,zero,r2
8113cb78:	1884703a 	and	r2,r3,r2
8113cb7c:	1007883a 	mov	r3,r2
8113cb80:	e0bff917 	ldw	r2,-28(fp)
8113cb84:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113cb88:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113cb8c:	e0bff717 	ldw	r2,-36(fp)
8113cb90:	e0fff303 	ldbu	r3,-52(fp)
8113cb94:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113cb98:	e0bff717 	ldw	r2,-36(fp)
8113cb9c:	10800c83 	ldbu	r2,50(r2)
8113cba0:	10803fcc 	andi	r2,r2,255
8113cba4:	1004d0fa 	srli	r2,r2,3
8113cba8:	1007883a 	mov	r3,r2
8113cbac:	e0bff717 	ldw	r2,-36(fp)
8113cbb0:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113cbb4:	e0bff717 	ldw	r2,-36(fp)
8113cbb8:	10800c83 	ldbu	r2,50(r2)
8113cbbc:	108001cc 	andi	r2,r2,7
8113cbc0:	1007883a 	mov	r3,r2
8113cbc4:	e0bff717 	ldw	r2,-36(fp)
8113cbc8:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113cbcc:	e0bff717 	ldw	r2,-36(fp)
8113cbd0:	10800d03 	ldbu	r2,52(r2)
8113cbd4:	10803fcc 	andi	r2,r2,255
8113cbd8:	00c00044 	movi	r3,1
8113cbdc:	1884983a 	sll	r2,r3,r2
8113cbe0:	1007883a 	mov	r3,r2
8113cbe4:	e0bff717 	ldw	r2,-36(fp)
8113cbe8:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113cbec:	e0bff717 	ldw	r2,-36(fp)
8113cbf0:	10800cc3 	ldbu	r2,51(r2)
8113cbf4:	10803fcc 	andi	r2,r2,255
8113cbf8:	00c00044 	movi	r3,1
8113cbfc:	1884983a 	sll	r2,r3,r2
8113cc00:	1007883a 	mov	r3,r2
8113cc04:	e0bff717 	ldw	r2,-36(fp)
8113cc08:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113cc0c:	e0bff003 	ldbu	r2,-64(fp)
8113cc10:	10800058 	cmpnei	r2,r2,1
8113cc14:	1000161e 	bne	r2,zero,8113cc70 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113cc18:	e0bff717 	ldw	r2,-36(fp)
8113cc1c:	10c00d83 	ldbu	r3,54(r2)
8113cc20:	d0a09e03 	ldbu	r2,-32136(gp)
8113cc24:	1884b03a 	or	r2,r3,r2
8113cc28:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113cc2c:	e0bff717 	ldw	r2,-36(fp)
8113cc30:	10800d03 	ldbu	r2,52(r2)
8113cc34:	10c03fcc 	andi	r3,r2,255
8113cc38:	e0bff717 	ldw	r2,-36(fp)
8113cc3c:	10800d03 	ldbu	r2,52(r2)
8113cc40:	11003fcc 	andi	r4,r2,255
8113cc44:	d0a09e44 	addi	r2,gp,-32135
8113cc48:	2085883a 	add	r2,r4,r2
8113cc4c:	11000003 	ldbu	r4,0(r2)
8113cc50:	e0bff717 	ldw	r2,-36(fp)
8113cc54:	10800d43 	ldbu	r2,53(r2)
8113cc58:	2084b03a 	or	r2,r4,r2
8113cc5c:	1009883a 	mov	r4,r2
8113cc60:	d0a09e44 	addi	r2,gp,-32135
8113cc64:	1885883a 	add	r2,r3,r2
8113cc68:	11000005 	stb	r4,0(r2)
8113cc6c:	00001f06 	br	8113ccec <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113cc70:	e0bff717 	ldw	r2,-36(fp)
8113cc74:	10800717 	ldw	r2,28(r2)
8113cc78:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113cc7c:	e0bff917 	ldw	r2,-28(fp)
8113cc80:	10001a26 	beq	r2,zero,8113ccec <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113cc84:	e0bff917 	ldw	r2,-28(fp)
8113cc88:	10c00283 	ldbu	r3,10(r2)
8113cc8c:	e0bff717 	ldw	r2,-36(fp)
8113cc90:	10800d83 	ldbu	r2,54(r2)
8113cc94:	1884b03a 	or	r2,r3,r2
8113cc98:	1007883a 	mov	r3,r2
8113cc9c:	e0bff917 	ldw	r2,-28(fp)
8113cca0:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113cca4:	e0bff717 	ldw	r2,-36(fp)
8113cca8:	10800d03 	ldbu	r2,52(r2)
8113ccac:	10803fcc 	andi	r2,r2,255
8113ccb0:	e0fff717 	ldw	r3,-36(fp)
8113ccb4:	18c00d03 	ldbu	r3,52(r3)
8113ccb8:	18c03fcc 	andi	r3,r3,255
8113ccbc:	e13ff917 	ldw	r4,-28(fp)
8113ccc0:	20c7883a 	add	r3,r4,r3
8113ccc4:	18c002c4 	addi	r3,r3,11
8113ccc8:	19000003 	ldbu	r4,0(r3)
8113cccc:	e0fff717 	ldw	r3,-36(fp)
8113ccd0:	18c00d43 	ldbu	r3,53(r3)
8113ccd4:	20c6b03a 	or	r3,r4,r3
8113ccd8:	1809883a 	mov	r4,r3
8113ccdc:	e0fff917 	ldw	r3,-28(fp)
8113cce0:	1885883a 	add	r2,r3,r2
8113cce4:	108002c4 	addi	r2,r2,11
8113cce8:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113ccec:	e0fff303 	ldbu	r3,-52(fp)
8113ccf0:	00a045f4 	movhi	r2,33047
8113ccf4:	10b2f704 	addi	r2,r2,-13348
8113ccf8:	18c7883a 	add	r3,r3,r3
8113ccfc:	18c7883a 	add	r3,r3,r3
8113cd00:	10c5883a 	add	r2,r2,r3
8113cd04:	e0fff717 	ldw	r3,-36(fp)
8113cd08:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113cd0c:	d0a0a217 	ldw	r2,-32120(gp)
8113cd10:	d0e0a217 	ldw	r3,-32120(gp)
8113cd14:	18c00c03 	ldbu	r3,48(r3)
8113cd18:	18c00414 	ori	r3,r3,16
8113cd1c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113cd20:	d0a0a217 	ldw	r2,-32120(gp)
8113cd24:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113cd28:	d0a0a217 	ldw	r2,-32120(gp)
8113cd2c:	e0fffe0b 	ldhu	r3,-8(fp)
8113cd30:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113cd34:	e13ffd17 	ldw	r4,-12(fp)
8113cd38:	11390b00 	call	811390b0 <OS_EventTaskWait>
8113cd3c:	e0bff117 	ldw	r2,-60(fp)
8113cd40:	e0bffb15 	stw	r2,-20(fp)
8113cd44:	e0bffb17 	ldw	r2,-20(fp)
8113cd48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113cd4c:	11399cc0 	call	811399cc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cd50:	0005303a 	rdctl	r2,status
8113cd54:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cd58:	e0fff517 	ldw	r3,-44(fp)
8113cd5c:	00bfff84 	movi	r2,-2
8113cd60:	1884703a 	and	r2,r3,r2
8113cd64:	1001703a 	wrctl	status,r2
  
  return context;
8113cd68:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113cd6c:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113cd70:	d0a0a217 	ldw	r2,-32120(gp)
8113cd74:	10800c43 	ldbu	r2,49(r2)
8113cd78:	10803fcc 	andi	r2,r2,255
8113cd7c:	10000326 	beq	r2,zero,8113cd8c <OSMutexPend+0x51c>
8113cd80:	108000a0 	cmpeqi	r2,r2,2
8113cd84:	1000041e 	bne	r2,zero,8113cd98 <OSMutexPend+0x528>
8113cd88:	00000706 	br	8113cda8 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113cd8c:	e0bfff17 	ldw	r2,-4(fp)
8113cd90:	10000005 	stb	zero,0(r2)
             break;
8113cd94:	00000c06 	br	8113cdc8 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113cd98:	e0bfff17 	ldw	r2,-4(fp)
8113cd9c:	00c00384 	movi	r3,14
8113cda0:	10c00005 	stb	r3,0(r2)
             break;
8113cda4:	00000806 	br	8113cdc8 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113cda8:	d0a0a217 	ldw	r2,-32120(gp)
8113cdac:	e17ffd17 	ldw	r5,-12(fp)
8113cdb0:	1009883a 	mov	r4,r2
8113cdb4:	11393200 	call	81139320 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113cdb8:	e0bfff17 	ldw	r2,-4(fp)
8113cdbc:	00c00284 	movi	r3,10
8113cdc0:	10c00005 	stb	r3,0(r2)
             break;
8113cdc4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113cdc8:	d0a0a217 	ldw	r2,-32120(gp)
8113cdcc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113cdd0:	d0a0a217 	ldw	r2,-32120(gp)
8113cdd4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113cdd8:	d0a0a217 	ldw	r2,-32120(gp)
8113cddc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113cde0:	d0a0a217 	ldw	r2,-32120(gp)
8113cde4:	10000815 	stw	zero,32(r2)
8113cde8:	e0bff117 	ldw	r2,-60(fp)
8113cdec:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cdf0:	e0bffa17 	ldw	r2,-24(fp)
8113cdf4:	1001703a 	wrctl	status,r2
8113cdf8:	00000106 	br	8113ce00 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113cdfc:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113ce00:	e037883a 	mov	sp,fp
8113ce04:	dfc00117 	ldw	ra,4(sp)
8113ce08:	df000017 	ldw	fp,0(sp)
8113ce0c:	dec00204 	addi	sp,sp,8
8113ce10:	f800283a 	ret

8113ce14 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113ce14:	defff604 	addi	sp,sp,-40
8113ce18:	de00012e 	bgeu	sp,et,8113ce20 <OSMutexPost+0xc>
8113ce1c:	003b68fa 	trap	3
8113ce20:	dfc00915 	stw	ra,36(sp)
8113ce24:	df000815 	stw	fp,32(sp)
8113ce28:	df000804 	addi	fp,sp,32
8113ce2c:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ce30:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113ce34:	d0a0a103 	ldbu	r2,-32124(gp)
8113ce38:	10803fcc 	andi	r2,r2,255
8113ce3c:	10000226 	beq	r2,zero,8113ce48 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113ce40:	00800144 	movi	r2,5
8113ce44:	00007606 	br	8113d020 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ce48:	e0bfff17 	ldw	r2,-4(fp)
8113ce4c:	1000021e 	bne	r2,zero,8113ce58 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113ce50:	00800104 	movi	r2,4
8113ce54:	00007206 	br	8113d020 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113ce58:	e0bfff17 	ldw	r2,-4(fp)
8113ce5c:	10800003 	ldbu	r2,0(r2)
8113ce60:	10803fcc 	andi	r2,r2,255
8113ce64:	10800120 	cmpeqi	r2,r2,4
8113ce68:	1000021e 	bne	r2,zero,8113ce74 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113ce6c:	00800044 	movi	r2,1
8113ce70:	00006b06 	br	8113d020 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ce74:	0005303a 	rdctl	r2,status
8113ce78:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ce7c:	e0fffe17 	ldw	r3,-8(fp)
8113ce80:	00bfff84 	movi	r2,-2
8113ce84:	1884703a 	and	r2,r3,r2
8113ce88:	1001703a 	wrctl	status,r2
  
  return context;
8113ce8c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113ce90:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113ce94:	e0bfff17 	ldw	r2,-4(fp)
8113ce98:	1080020b 	ldhu	r2,8(r2)
8113ce9c:	10bfffcc 	andi	r2,r2,65535
8113cea0:	1004d23a 	srli	r2,r2,8
8113cea4:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113cea8:	e0bfff17 	ldw	r2,-4(fp)
8113ceac:	1080020b 	ldhu	r2,8(r2)
8113ceb0:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113ceb4:	e0bfff17 	ldw	r2,-4(fp)
8113ceb8:	10c00117 	ldw	r3,4(r2)
8113cebc:	d0a0a217 	ldw	r2,-32120(gp)
8113cec0:	18800626 	beq	r3,r2,8113cedc <OSMutexPost+0xc8>
8113cec4:	e0bff817 	ldw	r2,-32(fp)
8113cec8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cecc:	e0bff917 	ldw	r2,-28(fp)
8113ced0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113ced4:	00801904 	movi	r2,100
8113ced8:	00005106 	br	8113d020 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113cedc:	d0a0a217 	ldw	r2,-32120(gp)
8113cee0:	10800c83 	ldbu	r2,50(r2)
8113cee4:	10c03fcc 	andi	r3,r2,255
8113cee8:	e0bffa03 	ldbu	r2,-24(fp)
8113ceec:	1880051e 	bne	r3,r2,8113cf04 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113cef0:	d0a0a217 	ldw	r2,-32120(gp)
8113cef4:	e0fffa43 	ldbu	r3,-23(fp)
8113cef8:	180b883a 	mov	r5,r3
8113cefc:	1009883a 	mov	r4,r2
8113cf00:	113d1a80 	call	8113d1a8 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113cf04:	e0fffa03 	ldbu	r3,-24(fp)
8113cf08:	00a045f4 	movhi	r2,33047
8113cf0c:	10b2f704 	addi	r2,r2,-13348
8113cf10:	18c7883a 	add	r3,r3,r3
8113cf14:	18c7883a 	add	r3,r3,r3
8113cf18:	10c5883a 	add	r2,r2,r3
8113cf1c:	00c00044 	movi	r3,1
8113cf20:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113cf24:	e0bfff17 	ldw	r2,-4(fp)
8113cf28:	10800283 	ldbu	r2,10(r2)
8113cf2c:	10803fcc 	andi	r2,r2,255
8113cf30:	10002e26 	beq	r2,zero,8113cfec <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113cf34:	000f883a 	mov	r7,zero
8113cf38:	01800404 	movi	r6,16
8113cf3c:	000b883a 	mov	r5,zero
8113cf40:	e13fff17 	ldw	r4,-4(fp)
8113cf44:	1138f100 	call	81138f10 <OS_EventTaskRdy>
8113cf48:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113cf4c:	e0bfff17 	ldw	r2,-4(fp)
8113cf50:	10c0020b 	ldhu	r3,8(r2)
8113cf54:	00bfc004 	movi	r2,-256
8113cf58:	1884703a 	and	r2,r3,r2
8113cf5c:	1007883a 	mov	r3,r2
8113cf60:	e0bfff17 	ldw	r2,-4(fp)
8113cf64:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113cf68:	e0bfff17 	ldw	r2,-4(fp)
8113cf6c:	10c0020b 	ldhu	r3,8(r2)
8113cf70:	e0bffa43 	ldbu	r2,-23(fp)
8113cf74:	1884b03a 	or	r2,r3,r2
8113cf78:	1007883a 	mov	r3,r2
8113cf7c:	e0bfff17 	ldw	r2,-4(fp)
8113cf80:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113cf84:	e0fffa43 	ldbu	r3,-23(fp)
8113cf88:	00a045f4 	movhi	r2,33047
8113cf8c:	10b2f704 	addi	r2,r2,-13348
8113cf90:	18c7883a 	add	r3,r3,r3
8113cf94:	18c7883a 	add	r3,r3,r3
8113cf98:	10c5883a 	add	r2,r2,r3
8113cf9c:	10c00017 	ldw	r3,0(r2)
8113cfa0:	e0bfff17 	ldw	r2,-4(fp)
8113cfa4:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113cfa8:	e0bffa43 	ldbu	r2,-23(fp)
8113cfac:	e0fffa03 	ldbu	r3,-24(fp)
8113cfb0:	18800736 	bltu	r3,r2,8113cfd0 <OSMutexPost+0x1bc>
8113cfb4:	e0bff817 	ldw	r2,-32(fp)
8113cfb8:	e0bffb15 	stw	r2,-20(fp)
8113cfbc:	e0bffb17 	ldw	r2,-20(fp)
8113cfc0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113cfc4:	11399cc0 	call	811399cc <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113cfc8:	00801e04 	movi	r2,120
8113cfcc:	00001406 	br	8113d020 <OSMutexPost+0x20c>
8113cfd0:	e0bff817 	ldw	r2,-32(fp)
8113cfd4:	e0bffc15 	stw	r2,-16(fp)
8113cfd8:	e0bffc17 	ldw	r2,-16(fp)
8113cfdc:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113cfe0:	11399cc0 	call	811399cc <OS_Sched>
            return (OS_ERR_NONE);
8113cfe4:	0005883a 	mov	r2,zero
8113cfe8:	00000d06 	br	8113d020 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113cfec:	e0bfff17 	ldw	r2,-4(fp)
8113cff0:	1080020b 	ldhu	r2,8(r2)
8113cff4:	10803fd4 	ori	r2,r2,255
8113cff8:	1007883a 	mov	r3,r2
8113cffc:	e0bfff17 	ldw	r2,-4(fp)
8113d000:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113d004:	e0bfff17 	ldw	r2,-4(fp)
8113d008:	10000115 	stw	zero,4(r2)
8113d00c:	e0bff817 	ldw	r2,-32(fp)
8113d010:	e0bffd15 	stw	r2,-12(fp)
8113d014:	e0bffd17 	ldw	r2,-12(fp)
8113d018:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d01c:	0005883a 	mov	r2,zero
}
8113d020:	e037883a 	mov	sp,fp
8113d024:	dfc00117 	ldw	ra,4(sp)
8113d028:	df000017 	ldw	fp,0(sp)
8113d02c:	dec00204 	addi	sp,sp,8
8113d030:	f800283a 	ret

8113d034 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113d034:	defff704 	addi	sp,sp,-36
8113d038:	de00012e 	bgeu	sp,et,8113d040 <OSMutexQuery+0xc>
8113d03c:	003b68fa 	trap	3
8113d040:	df000815 	stw	fp,32(sp)
8113d044:	df000804 	addi	fp,sp,32
8113d048:	e13ffe15 	stw	r4,-8(fp)
8113d04c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d050:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113d054:	d0a0a103 	ldbu	r2,-32124(gp)
8113d058:	10803fcc 	andi	r2,r2,255
8113d05c:	10000226 	beq	r2,zero,8113d068 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113d060:	00800184 	movi	r2,6
8113d064:	00004c06 	br	8113d198 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113d068:	e0bffe17 	ldw	r2,-8(fp)
8113d06c:	1000021e 	bne	r2,zero,8113d078 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113d070:	00800104 	movi	r2,4
8113d074:	00004806 	br	8113d198 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113d078:	e0bfff17 	ldw	r2,-4(fp)
8113d07c:	1000021e 	bne	r2,zero,8113d088 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113d080:	00800244 	movi	r2,9
8113d084:	00004406 	br	8113d198 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113d088:	e0bffe17 	ldw	r2,-8(fp)
8113d08c:	10800003 	ldbu	r2,0(r2)
8113d090:	10803fcc 	andi	r2,r2,255
8113d094:	10800120 	cmpeqi	r2,r2,4
8113d098:	1000021e 	bne	r2,zero,8113d0a4 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113d09c:	00800044 	movi	r2,1
8113d0a0:	00003d06 	br	8113d198 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d0a4:	0005303a 	rdctl	r2,status
8113d0a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d0ac:	e0fffd17 	ldw	r3,-12(fp)
8113d0b0:	00bfff84 	movi	r2,-2
8113d0b4:	1884703a 	and	r2,r3,r2
8113d0b8:	1001703a 	wrctl	status,r2
  
  return context;
8113d0bc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d0c0:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113d0c4:	e0bffe17 	ldw	r2,-8(fp)
8113d0c8:	1080020b 	ldhu	r2,8(r2)
8113d0cc:	10bfffcc 	andi	r2,r2,65535
8113d0d0:	1004d23a 	srli	r2,r2,8
8113d0d4:	1007883a 	mov	r3,r2
8113d0d8:	e0bfff17 	ldw	r2,-4(fp)
8113d0dc:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113d0e0:	e0bffe17 	ldw	r2,-8(fp)
8113d0e4:	1080020b 	ldhu	r2,8(r2)
8113d0e8:	1007883a 	mov	r3,r2
8113d0ec:	e0bfff17 	ldw	r2,-4(fp)
8113d0f0:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113d0f4:	e0bfff17 	ldw	r2,-4(fp)
8113d0f8:	10800203 	ldbu	r2,8(r2)
8113d0fc:	10803fcc 	andi	r2,r2,255
8113d100:	10803fd8 	cmpnei	r2,r2,255
8113d104:	1000041e 	bne	r2,zero,8113d118 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113d108:	e0bfff17 	ldw	r2,-4(fp)
8113d10c:	00c00044 	movi	r3,1
8113d110:	10c001c5 	stb	r3,7(r2)
8113d114:	00000206 	br	8113d120 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113d118:	e0bfff17 	ldw	r2,-4(fp)
8113d11c:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113d120:	e0bffe17 	ldw	r2,-8(fp)
8113d124:	10c00283 	ldbu	r3,10(r2)
8113d128:	e0bfff17 	ldw	r2,-4(fp)
8113d12c:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113d130:	e0bffe17 	ldw	r2,-8(fp)
8113d134:	108002c4 	addi	r2,r2,11
8113d138:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113d13c:	e0bfff17 	ldw	r2,-4(fp)
8113d140:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113d144:	e03ff805 	stb	zero,-32(fp)
8113d148:	00000b06 	br	8113d178 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113d14c:	e0bffa17 	ldw	r2,-24(fp)
8113d150:	10c00044 	addi	r3,r2,1
8113d154:	e0fffa15 	stw	r3,-24(fp)
8113d158:	e0fff917 	ldw	r3,-28(fp)
8113d15c:	19000044 	addi	r4,r3,1
8113d160:	e13ff915 	stw	r4,-28(fp)
8113d164:	18c00003 	ldbu	r3,0(r3)
8113d168:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113d16c:	e0bff803 	ldbu	r2,-32(fp)
8113d170:	10800044 	addi	r2,r2,1
8113d174:	e0bff805 	stb	r2,-32(fp)
8113d178:	e0bff803 	ldbu	r2,-32(fp)
8113d17c:	108001b0 	cmpltui	r2,r2,6
8113d180:	103ff21e 	bne	r2,zero,8113d14c <__reset+0xfb11d14c>
8113d184:	e0bffb17 	ldw	r2,-20(fp)
8113d188:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d18c:	e0bffc17 	ldw	r2,-16(fp)
8113d190:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d194:	0005883a 	mov	r2,zero
}
8113d198:	e037883a 	mov	sp,fp
8113d19c:	df000017 	ldw	fp,0(sp)
8113d1a0:	dec00104 	addi	sp,sp,4
8113d1a4:	f800283a 	ret

8113d1a8 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113d1a8:	defffc04 	addi	sp,sp,-16
8113d1ac:	de00012e 	bgeu	sp,et,8113d1b4 <OSMutex_RdyAtPrio+0xc>
8113d1b0:	003b68fa 	trap	3
8113d1b4:	df000315 	stw	fp,12(sp)
8113d1b8:	df000304 	addi	fp,sp,12
8113d1bc:	e13ffe15 	stw	r4,-8(fp)
8113d1c0:	2805883a 	mov	r2,r5
8113d1c4:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113d1c8:	e0bffe17 	ldw	r2,-8(fp)
8113d1cc:	10800d03 	ldbu	r2,52(r2)
8113d1d0:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113d1d4:	e0fffd03 	ldbu	r3,-12(fp)
8113d1d8:	e13ffd03 	ldbu	r4,-12(fp)
8113d1dc:	d0a09e44 	addi	r2,gp,-32135
8113d1e0:	2085883a 	add	r2,r4,r2
8113d1e4:	10800003 	ldbu	r2,0(r2)
8113d1e8:	1009883a 	mov	r4,r2
8113d1ec:	e0bffe17 	ldw	r2,-8(fp)
8113d1f0:	10800d43 	ldbu	r2,53(r2)
8113d1f4:	0084303a 	nor	r2,zero,r2
8113d1f8:	2084703a 	and	r2,r4,r2
8113d1fc:	1009883a 	mov	r4,r2
8113d200:	d0a09e44 	addi	r2,gp,-32135
8113d204:	1885883a 	add	r2,r3,r2
8113d208:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113d20c:	e0fffd03 	ldbu	r3,-12(fp)
8113d210:	d0a09e44 	addi	r2,gp,-32135
8113d214:	1885883a 	add	r2,r3,r2
8113d218:	10800003 	ldbu	r2,0(r2)
8113d21c:	10803fcc 	andi	r2,r2,255
8113d220:	1000071e 	bne	r2,zero,8113d240 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113d224:	e0bffe17 	ldw	r2,-8(fp)
8113d228:	10800d83 	ldbu	r2,54(r2)
8113d22c:	0084303a 	nor	r2,zero,r2
8113d230:	1007883a 	mov	r3,r2
8113d234:	d0a09e03 	ldbu	r2,-32136(gp)
8113d238:	1884703a 	and	r2,r3,r2
8113d23c:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113d240:	e0bffe17 	ldw	r2,-8(fp)
8113d244:	e0ffff03 	ldbu	r3,-4(fp)
8113d248:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113d24c:	e0bfff03 	ldbu	r2,-4(fp)
8113d250:	1004d0fa 	srli	r2,r2,3
8113d254:	108001cc 	andi	r2,r2,7
8113d258:	1007883a 	mov	r3,r2
8113d25c:	e0bffe17 	ldw	r2,-8(fp)
8113d260:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113d264:	e0bfff03 	ldbu	r2,-4(fp)
8113d268:	108001cc 	andi	r2,r2,7
8113d26c:	1007883a 	mov	r3,r2
8113d270:	e0bffe17 	ldw	r2,-8(fp)
8113d274:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113d278:	e0bffe17 	ldw	r2,-8(fp)
8113d27c:	10800d03 	ldbu	r2,52(r2)
8113d280:	10803fcc 	andi	r2,r2,255
8113d284:	00c00044 	movi	r3,1
8113d288:	1884983a 	sll	r2,r3,r2
8113d28c:	1007883a 	mov	r3,r2
8113d290:	e0bffe17 	ldw	r2,-8(fp)
8113d294:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113d298:	e0bffe17 	ldw	r2,-8(fp)
8113d29c:	10800cc3 	ldbu	r2,51(r2)
8113d2a0:	10803fcc 	andi	r2,r2,255
8113d2a4:	00c00044 	movi	r3,1
8113d2a8:	1884983a 	sll	r2,r3,r2
8113d2ac:	1007883a 	mov	r3,r2
8113d2b0:	e0bffe17 	ldw	r2,-8(fp)
8113d2b4:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113d2b8:	e0bffe17 	ldw	r2,-8(fp)
8113d2bc:	10c00d83 	ldbu	r3,54(r2)
8113d2c0:	d0a09e03 	ldbu	r2,-32136(gp)
8113d2c4:	1884b03a 	or	r2,r3,r2
8113d2c8:	d0a09e05 	stb	r2,-32136(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113d2cc:	e0bffe17 	ldw	r2,-8(fp)
8113d2d0:	10800d03 	ldbu	r2,52(r2)
8113d2d4:	10c03fcc 	andi	r3,r2,255
8113d2d8:	e0bffe17 	ldw	r2,-8(fp)
8113d2dc:	10800d03 	ldbu	r2,52(r2)
8113d2e0:	11003fcc 	andi	r4,r2,255
8113d2e4:	d0a09e44 	addi	r2,gp,-32135
8113d2e8:	2085883a 	add	r2,r4,r2
8113d2ec:	11000003 	ldbu	r4,0(r2)
8113d2f0:	e0bffe17 	ldw	r2,-8(fp)
8113d2f4:	10800d43 	ldbu	r2,53(r2)
8113d2f8:	2084b03a 	or	r2,r4,r2
8113d2fc:	1009883a 	mov	r4,r2
8113d300:	d0a09e44 	addi	r2,gp,-32135
8113d304:	1885883a 	add	r2,r3,r2
8113d308:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113d30c:	e0ffff03 	ldbu	r3,-4(fp)
8113d310:	00a045f4 	movhi	r2,33047
8113d314:	10b2f704 	addi	r2,r2,-13348
8113d318:	18c7883a 	add	r3,r3,r3
8113d31c:	18c7883a 	add	r3,r3,r3
8113d320:	10c5883a 	add	r2,r2,r3
8113d324:	e0fffe17 	ldw	r3,-8(fp)
8113d328:	10c00015 	stw	r3,0(r2)
}
8113d32c:	0001883a 	nop
8113d330:	e037883a 	mov	sp,fp
8113d334:	df000017 	ldw	fp,0(sp)
8113d338:	dec00104 	addi	sp,sp,4
8113d33c:	f800283a 	ret

8113d340 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113d340:	defff804 	addi	sp,sp,-32
8113d344:	de00012e 	bgeu	sp,et,8113d34c <OSQAccept+0xc>
8113d348:	003b68fa 	trap	3
8113d34c:	df000715 	stw	fp,28(sp)
8113d350:	df000704 	addi	fp,sp,28
8113d354:	e13ffe15 	stw	r4,-8(fp)
8113d358:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d35c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113d360:	e0bfff17 	ldw	r2,-4(fp)
8113d364:	1000021e 	bne	r2,zero,8113d370 <OSQAccept+0x30>
        return ((void *)0);
8113d368:	0005883a 	mov	r2,zero
8113d36c:	00004206 	br	8113d478 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113d370:	e0bffe17 	ldw	r2,-8(fp)
8113d374:	1000051e 	bne	r2,zero,8113d38c <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113d378:	e0bfff17 	ldw	r2,-4(fp)
8113d37c:	00c00104 	movi	r3,4
8113d380:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d384:	0005883a 	mov	r2,zero
8113d388:	00003b06 	br	8113d478 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113d38c:	e0bffe17 	ldw	r2,-8(fp)
8113d390:	10800003 	ldbu	r2,0(r2)
8113d394:	10803fcc 	andi	r2,r2,255
8113d398:	108000a0 	cmpeqi	r2,r2,2
8113d39c:	1000051e 	bne	r2,zero,8113d3b4 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113d3a0:	e0bfff17 	ldw	r2,-4(fp)
8113d3a4:	00c00044 	movi	r3,1
8113d3a8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d3ac:	0005883a 	mov	r2,zero
8113d3b0:	00003106 	br	8113d478 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d3b4:	0005303a 	rdctl	r2,status
8113d3b8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d3bc:	e0fffd17 	ldw	r3,-12(fp)
8113d3c0:	00bfff84 	movi	r2,-2
8113d3c4:	1884703a 	and	r2,r3,r2
8113d3c8:	1001703a 	wrctl	status,r2
  
  return context;
8113d3cc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d3d0:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113d3d4:	e0bffe17 	ldw	r2,-8(fp)
8113d3d8:	10800117 	ldw	r2,4(r2)
8113d3dc:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113d3e0:	e0bffc17 	ldw	r2,-16(fp)
8113d3e4:	1080058b 	ldhu	r2,22(r2)
8113d3e8:	10bfffcc 	andi	r2,r2,65535
8113d3ec:	10001926 	beq	r2,zero,8113d454 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113d3f0:	e0bffc17 	ldw	r2,-16(fp)
8113d3f4:	10800417 	ldw	r2,16(r2)
8113d3f8:	11000104 	addi	r4,r2,4
8113d3fc:	e0fffc17 	ldw	r3,-16(fp)
8113d400:	19000415 	stw	r4,16(r3)
8113d404:	10800017 	ldw	r2,0(r2)
8113d408:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113d40c:	e0bffc17 	ldw	r2,-16(fp)
8113d410:	1080058b 	ldhu	r2,22(r2)
8113d414:	10bfffc4 	addi	r2,r2,-1
8113d418:	1007883a 	mov	r3,r2
8113d41c:	e0bffc17 	ldw	r2,-16(fp)
8113d420:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113d424:	e0bffc17 	ldw	r2,-16(fp)
8113d428:	10c00417 	ldw	r3,16(r2)
8113d42c:	e0bffc17 	ldw	r2,-16(fp)
8113d430:	10800217 	ldw	r2,8(r2)
8113d434:	1880041e 	bne	r3,r2,8113d448 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113d438:	e0bffc17 	ldw	r2,-16(fp)
8113d43c:	10c00117 	ldw	r3,4(r2)
8113d440:	e0bffc17 	ldw	r2,-16(fp)
8113d444:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113d448:	e0bfff17 	ldw	r2,-4(fp)
8113d44c:	10000005 	stb	zero,0(r2)
8113d450:	00000406 	br	8113d464 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113d454:	e0bfff17 	ldw	r2,-4(fp)
8113d458:	00c007c4 	movi	r3,31
8113d45c:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113d460:	e03ff915 	stw	zero,-28(fp)
8113d464:	e0bffa17 	ldw	r2,-24(fp)
8113d468:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d46c:	e0bffb17 	ldw	r2,-20(fp)
8113d470:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113d474:	e0bff917 	ldw	r2,-28(fp)
}
8113d478:	e037883a 	mov	sp,fp
8113d47c:	df000017 	ldw	fp,0(sp)
8113d480:	dec00104 	addi	sp,sp,4
8113d484:	f800283a 	ret

8113d488 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113d488:	defff404 	addi	sp,sp,-48
8113d48c:	de00012e 	bgeu	sp,et,8113d494 <OSQCreate+0xc>
8113d490:	003b68fa 	trap	3
8113d494:	dfc00b15 	stw	ra,44(sp)
8113d498:	df000a15 	stw	fp,40(sp)
8113d49c:	df000a04 	addi	fp,sp,40
8113d4a0:	e13ffe15 	stw	r4,-8(fp)
8113d4a4:	2805883a 	mov	r2,r5
8113d4a8:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d4ac:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113d4b0:	d0a0a103 	ldbu	r2,-32124(gp)
8113d4b4:	10803fcc 	andi	r2,r2,255
8113d4b8:	10000226 	beq	r2,zero,8113d4c4 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113d4bc:	0005883a 	mov	r2,zero
8113d4c0:	00005906 	br	8113d628 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d4c4:	0005303a 	rdctl	r2,status
8113d4c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d4cc:	e0fffd17 	ldw	r3,-12(fp)
8113d4d0:	00bfff84 	movi	r2,-2
8113d4d4:	1884703a 	and	r2,r3,r2
8113d4d8:	1001703a 	wrctl	status,r2
  
  return context;
8113d4dc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d4e0:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113d4e4:	d0a0a017 	ldw	r2,-32128(gp)
8113d4e8:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113d4ec:	d0a0a017 	ldw	r2,-32128(gp)
8113d4f0:	10000326 	beq	r2,zero,8113d500 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113d4f4:	d0a0a017 	ldw	r2,-32128(gp)
8113d4f8:	10800117 	ldw	r2,4(r2)
8113d4fc:	d0a0a015 	stw	r2,-32128(gp)
8113d500:	e0bff717 	ldw	r2,-36(fp)
8113d504:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d508:	e0bff817 	ldw	r2,-32(fp)
8113d50c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113d510:	e0bff617 	ldw	r2,-40(fp)
8113d514:	10004326 	beq	r2,zero,8113d624 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d518:	0005303a 	rdctl	r2,status
8113d51c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d520:	e0fff917 	ldw	r3,-28(fp)
8113d524:	00bfff84 	movi	r2,-2
8113d528:	1884703a 	and	r2,r3,r2
8113d52c:	1001703a 	wrctl	status,r2
  
  return context;
8113d530:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113d534:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113d538:	d0a09d17 	ldw	r2,-32140(gp)
8113d53c:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113d540:	e0bffb17 	ldw	r2,-20(fp)
8113d544:	10002d26 	beq	r2,zero,8113d5fc <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113d548:	d0a09d17 	ldw	r2,-32140(gp)
8113d54c:	10800017 	ldw	r2,0(r2)
8113d550:	d0a09d15 	stw	r2,-32140(gp)
8113d554:	e0bff717 	ldw	r2,-36(fp)
8113d558:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d55c:	e0bffa17 	ldw	r2,-24(fp)
8113d560:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113d564:	e0bffb17 	ldw	r2,-20(fp)
8113d568:	e0fffe17 	ldw	r3,-8(fp)
8113d56c:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113d570:	e0bfff0b 	ldhu	r2,-4(fp)
8113d574:	1085883a 	add	r2,r2,r2
8113d578:	1085883a 	add	r2,r2,r2
8113d57c:	1007883a 	mov	r3,r2
8113d580:	e0bffe17 	ldw	r2,-8(fp)
8113d584:	10c7883a 	add	r3,r2,r3
8113d588:	e0bffb17 	ldw	r2,-20(fp)
8113d58c:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113d590:	e0bffb17 	ldw	r2,-20(fp)
8113d594:	e0fffe17 	ldw	r3,-8(fp)
8113d598:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113d59c:	e0bffb17 	ldw	r2,-20(fp)
8113d5a0:	e0fffe17 	ldw	r3,-8(fp)
8113d5a4:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113d5a8:	e0bffb17 	ldw	r2,-20(fp)
8113d5ac:	e0ffff0b 	ldhu	r3,-4(fp)
8113d5b0:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113d5b4:	e0bffb17 	ldw	r2,-20(fp)
8113d5b8:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113d5bc:	e0bff617 	ldw	r2,-40(fp)
8113d5c0:	00c00084 	movi	r3,2
8113d5c4:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113d5c8:	e0bff617 	ldw	r2,-40(fp)
8113d5cc:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113d5d0:	e0bff617 	ldw	r2,-40(fp)
8113d5d4:	e0fffb17 	ldw	r3,-20(fp)
8113d5d8:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113d5dc:	e0bff617 	ldw	r2,-40(fp)
8113d5e0:	00c00fc4 	movi	r3,63
8113d5e4:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113d5e8:	e0bff617 	ldw	r2,-40(fp)
8113d5ec:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113d5f0:	e13ff617 	ldw	r4,-40(fp)
8113d5f4:	11394e80 	call	811394e8 <OS_EventWaitListInit>
8113d5f8:	00000a06 	br	8113d624 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113d5fc:	d0e0a017 	ldw	r3,-32128(gp)
8113d600:	e0bff617 	ldw	r2,-40(fp)
8113d604:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113d608:	e0bff617 	ldw	r2,-40(fp)
8113d60c:	d0a0a015 	stw	r2,-32128(gp)
8113d610:	e0bff717 	ldw	r2,-36(fp)
8113d614:	e0bffc15 	stw	r2,-16(fp)
8113d618:	e0bffc17 	ldw	r2,-16(fp)
8113d61c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113d620:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113d624:	e0bff617 	ldw	r2,-40(fp)
}
8113d628:	e037883a 	mov	sp,fp
8113d62c:	dfc00117 	ldw	ra,4(sp)
8113d630:	df000017 	ldw	fp,0(sp)
8113d634:	dec00204 	addi	sp,sp,8
8113d638:	f800283a 	ret

8113d63c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113d63c:	defff204 	addi	sp,sp,-56
8113d640:	de00012e 	bgeu	sp,et,8113d648 <OSQDel+0xc>
8113d644:	003b68fa 	trap	3
8113d648:	dfc00d15 	stw	ra,52(sp)
8113d64c:	df000c15 	stw	fp,48(sp)
8113d650:	df000c04 	addi	fp,sp,48
8113d654:	e13ffd15 	stw	r4,-12(fp)
8113d658:	2805883a 	mov	r2,r5
8113d65c:	e1bfff15 	stw	r6,-4(fp)
8113d660:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113d664:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113d668:	e0bfff17 	ldw	r2,-4(fp)
8113d66c:	1000021e 	bne	r2,zero,8113d678 <OSQDel+0x3c>
        return (pevent);
8113d670:	e0bffd17 	ldw	r2,-12(fp)
8113d674:	00008e06 	br	8113d8b0 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113d678:	e0bffd17 	ldw	r2,-12(fp)
8113d67c:	1000051e 	bne	r2,zero,8113d694 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113d680:	e0bfff17 	ldw	r2,-4(fp)
8113d684:	00c00104 	movi	r3,4
8113d688:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d68c:	e0bffd17 	ldw	r2,-12(fp)
8113d690:	00008706 	br	8113d8b0 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113d694:	e0bffd17 	ldw	r2,-12(fp)
8113d698:	10800003 	ldbu	r2,0(r2)
8113d69c:	10803fcc 	andi	r2,r2,255
8113d6a0:	108000a0 	cmpeqi	r2,r2,2
8113d6a4:	1000051e 	bne	r2,zero,8113d6bc <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113d6a8:	e0bfff17 	ldw	r2,-4(fp)
8113d6ac:	00c00044 	movi	r3,1
8113d6b0:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d6b4:	e0bffd17 	ldw	r2,-12(fp)
8113d6b8:	00007d06 	br	8113d8b0 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113d6bc:	d0a0a103 	ldbu	r2,-32124(gp)
8113d6c0:	10803fcc 	andi	r2,r2,255
8113d6c4:	10000526 	beq	r2,zero,8113d6dc <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113d6c8:	e0bfff17 	ldw	r2,-4(fp)
8113d6cc:	00c003c4 	movi	r3,15
8113d6d0:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113d6d4:	e0bffd17 	ldw	r2,-12(fp)
8113d6d8:	00007506 	br	8113d8b0 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d6dc:	0005303a 	rdctl	r2,status
8113d6e0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d6e4:	e0fffc17 	ldw	r3,-16(fp)
8113d6e8:	00bfff84 	movi	r2,-2
8113d6ec:	1884703a 	and	r2,r3,r2
8113d6f0:	1001703a 	wrctl	status,r2
  
  return context;
8113d6f4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d6f8:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113d6fc:	e0bffd17 	ldw	r2,-12(fp)
8113d700:	10800283 	ldbu	r2,10(r2)
8113d704:	10803fcc 	andi	r2,r2,255
8113d708:	10000326 	beq	r2,zero,8113d718 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113d70c:	00800044 	movi	r2,1
8113d710:	e0bff405 	stb	r2,-48(fp)
8113d714:	00000106 	br	8113d71c <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113d718:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113d71c:	e0bffe03 	ldbu	r2,-8(fp)
8113d720:	10000326 	beq	r2,zero,8113d730 <OSQDel+0xf4>
8113d724:	10800060 	cmpeqi	r2,r2,1
8113d728:	1000301e 	bne	r2,zero,8113d7ec <OSQDel+0x1b0>
8113d72c:	00005506 	br	8113d884 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113d730:	e0bff403 	ldbu	r2,-48(fp)
8113d734:	10001e1e 	bne	r2,zero,8113d7b0 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113d738:	e0bffd17 	ldw	r2,-12(fp)
8113d73c:	00c00fc4 	movi	r3,63
8113d740:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113d744:	e0bffd17 	ldw	r2,-12(fp)
8113d748:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113d74c:	e0bffd17 	ldw	r2,-12(fp)
8113d750:	10800117 	ldw	r2,4(r2)
8113d754:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113d758:	d0e09d17 	ldw	r3,-32140(gp)
8113d75c:	e0bff817 	ldw	r2,-32(fp)
8113d760:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113d764:	e0bff817 	ldw	r2,-32(fp)
8113d768:	d0a09d15 	stw	r2,-32140(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113d76c:	e0bffd17 	ldw	r2,-12(fp)
8113d770:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113d774:	d0e0a017 	ldw	r3,-32128(gp)
8113d778:	e0bffd17 	ldw	r2,-12(fp)
8113d77c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113d780:	e0bffd17 	ldw	r2,-12(fp)
8113d784:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113d788:	e0bffd17 	ldw	r2,-12(fp)
8113d78c:	d0a0a015 	stw	r2,-32128(gp)
8113d790:	e0bff617 	ldw	r2,-40(fp)
8113d794:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d798:	e0bff717 	ldw	r2,-36(fp)
8113d79c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113d7a0:	e0bfff17 	ldw	r2,-4(fp)
8113d7a4:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113d7a8:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113d7ac:	00003f06 	br	8113d8ac <OSQDel+0x270>
8113d7b0:	e0bff617 	ldw	r2,-40(fp)
8113d7b4:	e0bff915 	stw	r2,-28(fp)
8113d7b8:	e0bff917 	ldw	r2,-28(fp)
8113d7bc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113d7c0:	e0bfff17 	ldw	r2,-4(fp)
8113d7c4:	00c01244 	movi	r3,73
8113d7c8:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113d7cc:	e0bffd17 	ldw	r2,-12(fp)
8113d7d0:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113d7d4:	00003506 	br	8113d8ac <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113d7d8:	000f883a 	mov	r7,zero
8113d7dc:	01800104 	movi	r6,4
8113d7e0:	000b883a 	mov	r5,zero
8113d7e4:	e13ffd17 	ldw	r4,-12(fp)
8113d7e8:	1138f100 	call	81138f10 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113d7ec:	e0bffd17 	ldw	r2,-12(fp)
8113d7f0:	10800283 	ldbu	r2,10(r2)
8113d7f4:	10803fcc 	andi	r2,r2,255
8113d7f8:	103ff71e 	bne	r2,zero,8113d7d8 <__reset+0xfb11d7d8>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113d7fc:	e0bffd17 	ldw	r2,-12(fp)
8113d800:	00c00fc4 	movi	r3,63
8113d804:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113d808:	e0bffd17 	ldw	r2,-12(fp)
8113d80c:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113d810:	e0bffd17 	ldw	r2,-12(fp)
8113d814:	10800117 	ldw	r2,4(r2)
8113d818:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113d81c:	d0e09d17 	ldw	r3,-32140(gp)
8113d820:	e0bff817 	ldw	r2,-32(fp)
8113d824:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113d828:	e0bff817 	ldw	r2,-32(fp)
8113d82c:	d0a09d15 	stw	r2,-32140(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113d830:	e0bffd17 	ldw	r2,-12(fp)
8113d834:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113d838:	d0e0a017 	ldw	r3,-32128(gp)
8113d83c:	e0bffd17 	ldw	r2,-12(fp)
8113d840:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113d844:	e0bffd17 	ldw	r2,-12(fp)
8113d848:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113d84c:	e0bffd17 	ldw	r2,-12(fp)
8113d850:	d0a0a015 	stw	r2,-32128(gp)
8113d854:	e0bff617 	ldw	r2,-40(fp)
8113d858:	e0bffa15 	stw	r2,-24(fp)
8113d85c:	e0bffa17 	ldw	r2,-24(fp)
8113d860:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113d864:	e0bff403 	ldbu	r2,-48(fp)
8113d868:	10800058 	cmpnei	r2,r2,1
8113d86c:	1000011e 	bne	r2,zero,8113d874 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113d870:	11399cc0 	call	811399cc <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113d874:	e0bfff17 	ldw	r2,-4(fp)
8113d878:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113d87c:	e03ff515 	stw	zero,-44(fp)
             break;
8113d880:	00000a06 	br	8113d8ac <OSQDel+0x270>
8113d884:	e0bff617 	ldw	r2,-40(fp)
8113d888:	e0bffb15 	stw	r2,-20(fp)
8113d88c:	e0bffb17 	ldw	r2,-20(fp)
8113d890:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113d894:	e0bfff17 	ldw	r2,-4(fp)
8113d898:	00c001c4 	movi	r3,7
8113d89c:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113d8a0:	e0bffd17 	ldw	r2,-12(fp)
8113d8a4:	e0bff515 	stw	r2,-44(fp)
             break;
8113d8a8:	0001883a 	nop
    }
    return (pevent_return);
8113d8ac:	e0bff517 	ldw	r2,-44(fp)
}
8113d8b0:	e037883a 	mov	sp,fp
8113d8b4:	dfc00117 	ldw	ra,4(sp)
8113d8b8:	df000017 	ldw	fp,0(sp)
8113d8bc:	dec00204 	addi	sp,sp,8
8113d8c0:	f800283a 	ret

8113d8c4 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113d8c4:	defffa04 	addi	sp,sp,-24
8113d8c8:	de00012e 	bgeu	sp,et,8113d8d0 <OSQFlush+0xc>
8113d8cc:	003b68fa 	trap	3
8113d8d0:	df000515 	stw	fp,20(sp)
8113d8d4:	df000504 	addi	fp,sp,20
8113d8d8:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d8dc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113d8e0:	e0bfff17 	ldw	r2,-4(fp)
8113d8e4:	1000021e 	bne	r2,zero,8113d8f0 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113d8e8:	00800104 	movi	r2,4
8113d8ec:	00002106 	br	8113d974 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113d8f0:	e0bfff17 	ldw	r2,-4(fp)
8113d8f4:	10800003 	ldbu	r2,0(r2)
8113d8f8:	10803fcc 	andi	r2,r2,255
8113d8fc:	108000a0 	cmpeqi	r2,r2,2
8113d900:	1000021e 	bne	r2,zero,8113d90c <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113d904:	00800044 	movi	r2,1
8113d908:	00001a06 	br	8113d974 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d90c:	0005303a 	rdctl	r2,status
8113d910:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d914:	e0fffd17 	ldw	r3,-12(fp)
8113d918:	00bfff84 	movi	r2,-2
8113d91c:	1884703a 	and	r2,r3,r2
8113d920:	1001703a 	wrctl	status,r2
  
  return context;
8113d924:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d928:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113d92c:	e0bfff17 	ldw	r2,-4(fp)
8113d930:	10800117 	ldw	r2,4(r2)
8113d934:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113d938:	e0bffc17 	ldw	r2,-16(fp)
8113d93c:	10c00117 	ldw	r3,4(r2)
8113d940:	e0bffc17 	ldw	r2,-16(fp)
8113d944:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113d948:	e0bffc17 	ldw	r2,-16(fp)
8113d94c:	10c00117 	ldw	r3,4(r2)
8113d950:	e0bffc17 	ldw	r2,-16(fp)
8113d954:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113d958:	e0bffc17 	ldw	r2,-16(fp)
8113d95c:	1000058d 	sth	zero,22(r2)
8113d960:	e0bffb17 	ldw	r2,-20(fp)
8113d964:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d968:	e0bffe17 	ldw	r2,-8(fp)
8113d96c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d970:	0005883a 	mov	r2,zero
}
8113d974:	e037883a 	mov	sp,fp
8113d978:	df000017 	ldw	fp,0(sp)
8113d97c:	dec00104 	addi	sp,sp,4
8113d980:	f800283a 	ret

8113d984 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113d984:	defff304 	addi	sp,sp,-52
8113d988:	de00012e 	bgeu	sp,et,8113d990 <OSQPend+0xc>
8113d98c:	003b68fa 	trap	3
8113d990:	dfc00c15 	stw	ra,48(sp)
8113d994:	df000b15 	stw	fp,44(sp)
8113d998:	df000b04 	addi	fp,sp,44
8113d99c:	e13ffd15 	stw	r4,-12(fp)
8113d9a0:	2805883a 	mov	r2,r5
8113d9a4:	e1bfff15 	stw	r6,-4(fp)
8113d9a8:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113d9ac:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113d9b0:	e0bfff17 	ldw	r2,-4(fp)
8113d9b4:	1000021e 	bne	r2,zero,8113d9c0 <OSQPend+0x3c>
        return ((void *)0);
8113d9b8:	0005883a 	mov	r2,zero
8113d9bc:	00009106 	br	8113dc04 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113d9c0:	e0bffd17 	ldw	r2,-12(fp)
8113d9c4:	1000051e 	bne	r2,zero,8113d9dc <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113d9c8:	e0bfff17 	ldw	r2,-4(fp)
8113d9cc:	00c00104 	movi	r3,4
8113d9d0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d9d4:	0005883a 	mov	r2,zero
8113d9d8:	00008a06 	br	8113dc04 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113d9dc:	e0bffd17 	ldw	r2,-12(fp)
8113d9e0:	10800003 	ldbu	r2,0(r2)
8113d9e4:	10803fcc 	andi	r2,r2,255
8113d9e8:	108000a0 	cmpeqi	r2,r2,2
8113d9ec:	1000051e 	bne	r2,zero,8113da04 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113d9f0:	e0bfff17 	ldw	r2,-4(fp)
8113d9f4:	00c00044 	movi	r3,1
8113d9f8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113d9fc:	0005883a 	mov	r2,zero
8113da00:	00008006 	br	8113dc04 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113da04:	d0a0a103 	ldbu	r2,-32124(gp)
8113da08:	10803fcc 	andi	r2,r2,255
8113da0c:	10000526 	beq	r2,zero,8113da24 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113da10:	e0bfff17 	ldw	r2,-4(fp)
8113da14:	00c00084 	movi	r3,2
8113da18:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113da1c:	0005883a 	mov	r2,zero
8113da20:	00007806 	br	8113dc04 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113da24:	d0a08f03 	ldbu	r2,-32196(gp)
8113da28:	10803fcc 	andi	r2,r2,255
8113da2c:	10000526 	beq	r2,zero,8113da44 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113da30:	e0bfff17 	ldw	r2,-4(fp)
8113da34:	00c00344 	movi	r3,13
8113da38:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113da3c:	0005883a 	mov	r2,zero
8113da40:	00007006 	br	8113dc04 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113da44:	0005303a 	rdctl	r2,status
8113da48:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113da4c:	e0fffc17 	ldw	r3,-16(fp)
8113da50:	00bfff84 	movi	r2,-2
8113da54:	1884703a 	and	r2,r3,r2
8113da58:	1001703a 	wrctl	status,r2
  
  return context;
8113da5c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113da60:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113da64:	e0bffd17 	ldw	r2,-12(fp)
8113da68:	10800117 	ldw	r2,4(r2)
8113da6c:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113da70:	e0bff817 	ldw	r2,-32(fp)
8113da74:	1080058b 	ldhu	r2,22(r2)
8113da78:	10bfffcc 	andi	r2,r2,65535
8113da7c:	10001e26 	beq	r2,zero,8113daf8 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113da80:	e0bff817 	ldw	r2,-32(fp)
8113da84:	10800417 	ldw	r2,16(r2)
8113da88:	11000104 	addi	r4,r2,4
8113da8c:	e0fff817 	ldw	r3,-32(fp)
8113da90:	19000415 	stw	r4,16(r3)
8113da94:	10800017 	ldw	r2,0(r2)
8113da98:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113da9c:	e0bff817 	ldw	r2,-32(fp)
8113daa0:	1080058b 	ldhu	r2,22(r2)
8113daa4:	10bfffc4 	addi	r2,r2,-1
8113daa8:	1007883a 	mov	r3,r2
8113daac:	e0bff817 	ldw	r2,-32(fp)
8113dab0:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113dab4:	e0bff817 	ldw	r2,-32(fp)
8113dab8:	10c00417 	ldw	r3,16(r2)
8113dabc:	e0bff817 	ldw	r2,-32(fp)
8113dac0:	10800217 	ldw	r2,8(r2)
8113dac4:	1880041e 	bne	r3,r2,8113dad8 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113dac8:	e0bff817 	ldw	r2,-32(fp)
8113dacc:	10c00117 	ldw	r3,4(r2)
8113dad0:	e0bff817 	ldw	r2,-32(fp)
8113dad4:	10c00415 	stw	r3,16(r2)
8113dad8:	e0bff617 	ldw	r2,-40(fp)
8113dadc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dae0:	e0bff717 	ldw	r2,-36(fp)
8113dae4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113dae8:	e0bfff17 	ldw	r2,-4(fp)
8113daec:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113daf0:	e0bff517 	ldw	r2,-44(fp)
8113daf4:	00004306 	br	8113dc04 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113daf8:	d0a0a217 	ldw	r2,-32120(gp)
8113dafc:	d0e0a217 	ldw	r3,-32120(gp)
8113db00:	18c00c03 	ldbu	r3,48(r3)
8113db04:	18c00114 	ori	r3,r3,4
8113db08:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113db0c:	d0a0a217 	ldw	r2,-32120(gp)
8113db10:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113db14:	d0a0a217 	ldw	r2,-32120(gp)
8113db18:	e0fffe0b 	ldhu	r3,-8(fp)
8113db1c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113db20:	e13ffd17 	ldw	r4,-12(fp)
8113db24:	11390b00 	call	811390b0 <OS_EventTaskWait>
8113db28:	e0bff617 	ldw	r2,-40(fp)
8113db2c:	e0bffb15 	stw	r2,-20(fp)
8113db30:	e0bffb17 	ldw	r2,-20(fp)
8113db34:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113db38:	11399cc0 	call	811399cc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113db3c:	0005303a 	rdctl	r2,status
8113db40:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113db44:	e0fff917 	ldw	r3,-28(fp)
8113db48:	00bfff84 	movi	r2,-2
8113db4c:	1884703a 	and	r2,r3,r2
8113db50:	1001703a 	wrctl	status,r2
  
  return context;
8113db54:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113db58:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113db5c:	d0a0a217 	ldw	r2,-32120(gp)
8113db60:	10800c43 	ldbu	r2,49(r2)
8113db64:	10803fcc 	andi	r2,r2,255
8113db68:	10000326 	beq	r2,zero,8113db78 <OSQPend+0x1f4>
8113db6c:	108000a0 	cmpeqi	r2,r2,2
8113db70:	1000071e 	bne	r2,zero,8113db90 <OSQPend+0x20c>
8113db74:	00000b06 	br	8113dba4 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113db78:	d0a0a217 	ldw	r2,-32120(gp)
8113db7c:	10800917 	ldw	r2,36(r2)
8113db80:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113db84:	e0bfff17 	ldw	r2,-4(fp)
8113db88:	10000005 	stb	zero,0(r2)
             break;
8113db8c:	00000e06 	br	8113dbc8 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113db90:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113db94:	e0bfff17 	ldw	r2,-4(fp)
8113db98:	00c00384 	movi	r3,14
8113db9c:	10c00005 	stb	r3,0(r2)
             break;
8113dba0:	00000906 	br	8113dbc8 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113dba4:	d0a0a217 	ldw	r2,-32120(gp)
8113dba8:	e17ffd17 	ldw	r5,-12(fp)
8113dbac:	1009883a 	mov	r4,r2
8113dbb0:	11393200 	call	81139320 <OS_EventTaskRemove>
             pmsg = (void *)0;
8113dbb4:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113dbb8:	e0bfff17 	ldw	r2,-4(fp)
8113dbbc:	00c00284 	movi	r3,10
8113dbc0:	10c00005 	stb	r3,0(r2)
             break;
8113dbc4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113dbc8:	d0a0a217 	ldw	r2,-32120(gp)
8113dbcc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113dbd0:	d0a0a217 	ldw	r2,-32120(gp)
8113dbd4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113dbd8:	d0a0a217 	ldw	r2,-32120(gp)
8113dbdc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113dbe0:	d0a0a217 	ldw	r2,-32120(gp)
8113dbe4:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113dbe8:	d0a0a217 	ldw	r2,-32120(gp)
8113dbec:	10000915 	stw	zero,36(r2)
8113dbf0:	e0bff617 	ldw	r2,-40(fp)
8113dbf4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dbf8:	e0bffa17 	ldw	r2,-24(fp)
8113dbfc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113dc00:	e0bff517 	ldw	r2,-44(fp)
}
8113dc04:	e037883a 	mov	sp,fp
8113dc08:	dfc00117 	ldw	ra,4(sp)
8113dc0c:	df000017 	ldw	fp,0(sp)
8113dc10:	dec00204 	addi	sp,sp,8
8113dc14:	f800283a 	ret

8113dc18 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113dc18:	defff604 	addi	sp,sp,-40
8113dc1c:	de00012e 	bgeu	sp,et,8113dc24 <OSQPendAbort+0xc>
8113dc20:	003b68fa 	trap	3
8113dc24:	dfc00915 	stw	ra,36(sp)
8113dc28:	df000815 	stw	fp,32(sp)
8113dc2c:	df000804 	addi	fp,sp,32
8113dc30:	e13ffd15 	stw	r4,-12(fp)
8113dc34:	2805883a 	mov	r2,r5
8113dc38:	e1bfff15 	stw	r6,-4(fp)
8113dc3c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113dc40:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113dc44:	e0bfff17 	ldw	r2,-4(fp)
8113dc48:	1000021e 	bne	r2,zero,8113dc54 <OSQPendAbort+0x3c>
        return (0);
8113dc4c:	0005883a 	mov	r2,zero
8113dc50:	00004906 	br	8113dd78 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113dc54:	e0bffd17 	ldw	r2,-12(fp)
8113dc58:	1000051e 	bne	r2,zero,8113dc70 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113dc5c:	e0bfff17 	ldw	r2,-4(fp)
8113dc60:	00c00104 	movi	r3,4
8113dc64:	10c00005 	stb	r3,0(r2)
        return (0);
8113dc68:	0005883a 	mov	r2,zero
8113dc6c:	00004206 	br	8113dd78 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113dc70:	e0bffd17 	ldw	r2,-12(fp)
8113dc74:	10800003 	ldbu	r2,0(r2)
8113dc78:	10803fcc 	andi	r2,r2,255
8113dc7c:	108000a0 	cmpeqi	r2,r2,2
8113dc80:	1000051e 	bne	r2,zero,8113dc98 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113dc84:	e0bfff17 	ldw	r2,-4(fp)
8113dc88:	00c00044 	movi	r3,1
8113dc8c:	10c00005 	stb	r3,0(r2)
        return (0);
8113dc90:	0005883a 	mov	r2,zero
8113dc94:	00003806 	br	8113dd78 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dc98:	0005303a 	rdctl	r2,status
8113dc9c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dca0:	e0fffc17 	ldw	r3,-16(fp)
8113dca4:	00bfff84 	movi	r2,-2
8113dca8:	1884703a 	and	r2,r3,r2
8113dcac:	1001703a 	wrctl	status,r2
  
  return context;
8113dcb0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113dcb4:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113dcb8:	e0bffd17 	ldw	r2,-12(fp)
8113dcbc:	10800283 	ldbu	r2,10(r2)
8113dcc0:	10803fcc 	andi	r2,r2,255
8113dcc4:	10002526 	beq	r2,zero,8113dd5c <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113dcc8:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113dccc:	e0bffe03 	ldbu	r2,-8(fp)
8113dcd0:	10800060 	cmpeqi	r2,r2,1
8113dcd4:	10000e26 	beq	r2,zero,8113dd10 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113dcd8:	00000806 	br	8113dcfc <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113dcdc:	01c00084 	movi	r7,2
8113dce0:	01800104 	movi	r6,4
8113dce4:	000b883a 	mov	r5,zero
8113dce8:	e13ffd17 	ldw	r4,-12(fp)
8113dcec:	1138f100 	call	81138f10 <OS_EventTaskRdy>
                     nbr_tasks++;
8113dcf0:	e0bff803 	ldbu	r2,-32(fp)
8113dcf4:	10800044 	addi	r2,r2,1
8113dcf8:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113dcfc:	e0bffd17 	ldw	r2,-12(fp)
8113dd00:	10800283 	ldbu	r2,10(r2)
8113dd04:	10803fcc 	andi	r2,r2,255
8113dd08:	103ff41e 	bne	r2,zero,8113dcdc <__reset+0xfb11dcdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113dd0c:	00000906 	br	8113dd34 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113dd10:	01c00084 	movi	r7,2
8113dd14:	01800104 	movi	r6,4
8113dd18:	000b883a 	mov	r5,zero
8113dd1c:	e13ffd17 	ldw	r4,-12(fp)
8113dd20:	1138f100 	call	81138f10 <OS_EventTaskRdy>
                 nbr_tasks++;
8113dd24:	e0bff803 	ldbu	r2,-32(fp)
8113dd28:	10800044 	addi	r2,r2,1
8113dd2c:	e0bff805 	stb	r2,-32(fp)
                 break;
8113dd30:	0001883a 	nop
8113dd34:	e0bff917 	ldw	r2,-28(fp)
8113dd38:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dd3c:	e0bffa17 	ldw	r2,-24(fp)
8113dd40:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113dd44:	11399cc0 	call	811399cc <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113dd48:	e0bfff17 	ldw	r2,-4(fp)
8113dd4c:	00c00384 	movi	r3,14
8113dd50:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113dd54:	e0bff803 	ldbu	r2,-32(fp)
8113dd58:	00000706 	br	8113dd78 <OSQPendAbort+0x160>
8113dd5c:	e0bff917 	ldw	r2,-28(fp)
8113dd60:	e0bffb15 	stw	r2,-20(fp)
8113dd64:	e0bffb17 	ldw	r2,-20(fp)
8113dd68:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113dd6c:	e0bfff17 	ldw	r2,-4(fp)
8113dd70:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113dd74:	0005883a 	mov	r2,zero
}
8113dd78:	e037883a 	mov	sp,fp
8113dd7c:	dfc00117 	ldw	ra,4(sp)
8113dd80:	df000017 	ldw	fp,0(sp)
8113dd84:	dec00204 	addi	sp,sp,8
8113dd88:	f800283a 	ret

8113dd8c <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113dd8c:	defff604 	addi	sp,sp,-40
8113dd90:	de00012e 	bgeu	sp,et,8113dd98 <OSQPost+0xc>
8113dd94:	003b68fa 	trap	3
8113dd98:	dfc00915 	stw	ra,36(sp)
8113dd9c:	df000815 	stw	fp,32(sp)
8113dda0:	df000804 	addi	fp,sp,32
8113dda4:	e13ffe15 	stw	r4,-8(fp)
8113dda8:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113ddac:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113ddb0:	e0bffe17 	ldw	r2,-8(fp)
8113ddb4:	1000021e 	bne	r2,zero,8113ddc0 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113ddb8:	00800104 	movi	r2,4
8113ddbc:	00004a06 	br	8113dee8 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113ddc0:	e0bffe17 	ldw	r2,-8(fp)
8113ddc4:	10800003 	ldbu	r2,0(r2)
8113ddc8:	10803fcc 	andi	r2,r2,255
8113ddcc:	108000a0 	cmpeqi	r2,r2,2
8113ddd0:	1000021e 	bne	r2,zero,8113dddc <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113ddd4:	00800044 	movi	r2,1
8113ddd8:	00004306 	br	8113dee8 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dddc:	0005303a 	rdctl	r2,status
8113dde0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dde4:	e0fffd17 	ldw	r3,-12(fp)
8113dde8:	00bfff84 	movi	r2,-2
8113ddec:	1884703a 	and	r2,r3,r2
8113ddf0:	1001703a 	wrctl	status,r2
  
  return context;
8113ddf4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113ddf8:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113ddfc:	e0bffe17 	ldw	r2,-8(fp)
8113de00:	10800283 	ldbu	r2,10(r2)
8113de04:	10803fcc 	andi	r2,r2,255
8113de08:	10000c26 	beq	r2,zero,8113de3c <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113de0c:	000f883a 	mov	r7,zero
8113de10:	01800104 	movi	r6,4
8113de14:	e17fff17 	ldw	r5,-4(fp)
8113de18:	e13ffe17 	ldw	r4,-8(fp)
8113de1c:	1138f100 	call	81138f10 <OS_EventTaskRdy>
8113de20:	e0bff817 	ldw	r2,-32(fp)
8113de24:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113de28:	e0bff917 	ldw	r2,-28(fp)
8113de2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113de30:	11399cc0 	call	811399cc <OS_Sched>
        return (OS_ERR_NONE);
8113de34:	0005883a 	mov	r2,zero
8113de38:	00002b06 	br	8113dee8 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113de3c:	e0bffe17 	ldw	r2,-8(fp)
8113de40:	10800117 	ldw	r2,4(r2)
8113de44:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113de48:	e0bffb17 	ldw	r2,-20(fp)
8113de4c:	10c0058b 	ldhu	r3,22(r2)
8113de50:	e0bffb17 	ldw	r2,-20(fp)
8113de54:	1080050b 	ldhu	r2,20(r2)
8113de58:	18ffffcc 	andi	r3,r3,65535
8113de5c:	10bfffcc 	andi	r2,r2,65535
8113de60:	18800636 	bltu	r3,r2,8113de7c <OSQPost+0xf0>
8113de64:	e0bff817 	ldw	r2,-32(fp)
8113de68:	e0bffa15 	stw	r2,-24(fp)
8113de6c:	e0bffa17 	ldw	r2,-24(fp)
8113de70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113de74:	00800784 	movi	r2,30
8113de78:	00001b06 	br	8113dee8 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113de7c:	e0bffb17 	ldw	r2,-20(fp)
8113de80:	10800317 	ldw	r2,12(r2)
8113de84:	11000104 	addi	r4,r2,4
8113de88:	e0fffb17 	ldw	r3,-20(fp)
8113de8c:	19000315 	stw	r4,12(r3)
8113de90:	e0ffff17 	ldw	r3,-4(fp)
8113de94:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113de98:	e0bffb17 	ldw	r2,-20(fp)
8113de9c:	1080058b 	ldhu	r2,22(r2)
8113dea0:	10800044 	addi	r2,r2,1
8113dea4:	1007883a 	mov	r3,r2
8113dea8:	e0bffb17 	ldw	r2,-20(fp)
8113deac:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113deb0:	e0bffb17 	ldw	r2,-20(fp)
8113deb4:	10c00317 	ldw	r3,12(r2)
8113deb8:	e0bffb17 	ldw	r2,-20(fp)
8113debc:	10800217 	ldw	r2,8(r2)
8113dec0:	1880041e 	bne	r3,r2,8113ded4 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113dec4:	e0bffb17 	ldw	r2,-20(fp)
8113dec8:	10c00117 	ldw	r3,4(r2)
8113decc:	e0bffb17 	ldw	r2,-20(fp)
8113ded0:	10c00315 	stw	r3,12(r2)
8113ded4:	e0bff817 	ldw	r2,-32(fp)
8113ded8:	e0bffc15 	stw	r2,-16(fp)
8113dedc:	e0bffc17 	ldw	r2,-16(fp)
8113dee0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113dee4:	0005883a 	mov	r2,zero
}
8113dee8:	e037883a 	mov	sp,fp
8113deec:	dfc00117 	ldw	ra,4(sp)
8113def0:	df000017 	ldw	fp,0(sp)
8113def4:	dec00204 	addi	sp,sp,8
8113def8:	f800283a 	ret

8113defc <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113defc:	defff604 	addi	sp,sp,-40
8113df00:	de00012e 	bgeu	sp,et,8113df08 <OSQPostFront+0xc>
8113df04:	003b68fa 	trap	3
8113df08:	dfc00915 	stw	ra,36(sp)
8113df0c:	df000815 	stw	fp,32(sp)
8113df10:	df000804 	addi	fp,sp,32
8113df14:	e13ffe15 	stw	r4,-8(fp)
8113df18:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113df1c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113df20:	e0bffe17 	ldw	r2,-8(fp)
8113df24:	1000021e 	bne	r2,zero,8113df30 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113df28:	00800104 	movi	r2,4
8113df2c:	00004c06 	br	8113e060 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113df30:	e0bffe17 	ldw	r2,-8(fp)
8113df34:	10800003 	ldbu	r2,0(r2)
8113df38:	10803fcc 	andi	r2,r2,255
8113df3c:	108000a0 	cmpeqi	r2,r2,2
8113df40:	1000021e 	bne	r2,zero,8113df4c <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113df44:	00800044 	movi	r2,1
8113df48:	00004506 	br	8113e060 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113df4c:	0005303a 	rdctl	r2,status
8113df50:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113df54:	e0fffd17 	ldw	r3,-12(fp)
8113df58:	00bfff84 	movi	r2,-2
8113df5c:	1884703a 	and	r2,r3,r2
8113df60:	1001703a 	wrctl	status,r2
  
  return context;
8113df64:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113df68:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113df6c:	e0bffe17 	ldw	r2,-8(fp)
8113df70:	10800283 	ldbu	r2,10(r2)
8113df74:	10803fcc 	andi	r2,r2,255
8113df78:	10000c26 	beq	r2,zero,8113dfac <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113df7c:	000f883a 	mov	r7,zero
8113df80:	01800104 	movi	r6,4
8113df84:	e17fff17 	ldw	r5,-4(fp)
8113df88:	e13ffe17 	ldw	r4,-8(fp)
8113df8c:	1138f100 	call	81138f10 <OS_EventTaskRdy>
8113df90:	e0bff817 	ldw	r2,-32(fp)
8113df94:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113df98:	e0bff917 	ldw	r2,-28(fp)
8113df9c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113dfa0:	11399cc0 	call	811399cc <OS_Sched>
        return (OS_ERR_NONE);
8113dfa4:	0005883a 	mov	r2,zero
8113dfa8:	00002d06 	br	8113e060 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113dfac:	e0bffe17 	ldw	r2,-8(fp)
8113dfb0:	10800117 	ldw	r2,4(r2)
8113dfb4:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113dfb8:	e0bffb17 	ldw	r2,-20(fp)
8113dfbc:	10c0058b 	ldhu	r3,22(r2)
8113dfc0:	e0bffb17 	ldw	r2,-20(fp)
8113dfc4:	1080050b 	ldhu	r2,20(r2)
8113dfc8:	18ffffcc 	andi	r3,r3,65535
8113dfcc:	10bfffcc 	andi	r2,r2,65535
8113dfd0:	18800636 	bltu	r3,r2,8113dfec <OSQPostFront+0xf0>
8113dfd4:	e0bff817 	ldw	r2,-32(fp)
8113dfd8:	e0bffa15 	stw	r2,-24(fp)
8113dfdc:	e0bffa17 	ldw	r2,-24(fp)
8113dfe0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113dfe4:	00800784 	movi	r2,30
8113dfe8:	00001d06 	br	8113e060 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113dfec:	e0bffb17 	ldw	r2,-20(fp)
8113dff0:	10c00417 	ldw	r3,16(r2)
8113dff4:	e0bffb17 	ldw	r2,-20(fp)
8113dff8:	10800117 	ldw	r2,4(r2)
8113dffc:	1880041e 	bne	r3,r2,8113e010 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113e000:	e0bffb17 	ldw	r2,-20(fp)
8113e004:	10c00217 	ldw	r3,8(r2)
8113e008:	e0bffb17 	ldw	r2,-20(fp)
8113e00c:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113e010:	e0bffb17 	ldw	r2,-20(fp)
8113e014:	10800417 	ldw	r2,16(r2)
8113e018:	10ffff04 	addi	r3,r2,-4
8113e01c:	e0bffb17 	ldw	r2,-20(fp)
8113e020:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113e024:	e0bffb17 	ldw	r2,-20(fp)
8113e028:	10800417 	ldw	r2,16(r2)
8113e02c:	e0ffff17 	ldw	r3,-4(fp)
8113e030:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113e034:	e0bffb17 	ldw	r2,-20(fp)
8113e038:	1080058b 	ldhu	r2,22(r2)
8113e03c:	10800044 	addi	r2,r2,1
8113e040:	1007883a 	mov	r3,r2
8113e044:	e0bffb17 	ldw	r2,-20(fp)
8113e048:	10c0058d 	sth	r3,22(r2)
8113e04c:	e0bff817 	ldw	r2,-32(fp)
8113e050:	e0bffc15 	stw	r2,-16(fp)
8113e054:	e0bffc17 	ldw	r2,-16(fp)
8113e058:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e05c:	0005883a 	mov	r2,zero
}
8113e060:	e037883a 	mov	sp,fp
8113e064:	dfc00117 	ldw	ra,4(sp)
8113e068:	df000017 	ldw	fp,0(sp)
8113e06c:	dec00204 	addi	sp,sp,8
8113e070:	f800283a 	ret

8113e074 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113e074:	defff504 	addi	sp,sp,-44
8113e078:	de00012e 	bgeu	sp,et,8113e080 <OSQPostOpt+0xc>
8113e07c:	003b68fa 	trap	3
8113e080:	dfc00a15 	stw	ra,40(sp)
8113e084:	df000915 	stw	fp,36(sp)
8113e088:	df000904 	addi	fp,sp,36
8113e08c:	e13ffd15 	stw	r4,-12(fp)
8113e090:	e17ffe15 	stw	r5,-8(fp)
8113e094:	3005883a 	mov	r2,r6
8113e098:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e09c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e0a0:	e0bffd17 	ldw	r2,-12(fp)
8113e0a4:	1000021e 	bne	r2,zero,8113e0b0 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113e0a8:	00800104 	movi	r2,4
8113e0ac:	00007106 	br	8113e274 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113e0b0:	e0bffd17 	ldw	r2,-12(fp)
8113e0b4:	10800003 	ldbu	r2,0(r2)
8113e0b8:	10803fcc 	andi	r2,r2,255
8113e0bc:	108000a0 	cmpeqi	r2,r2,2
8113e0c0:	1000021e 	bne	r2,zero,8113e0cc <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113e0c4:	00800044 	movi	r2,1
8113e0c8:	00006a06 	br	8113e274 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e0cc:	0005303a 	rdctl	r2,status
8113e0d0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e0d4:	e0fffc17 	ldw	r3,-16(fp)
8113e0d8:	00bfff84 	movi	r2,-2
8113e0dc:	1884703a 	and	r2,r3,r2
8113e0e0:	1001703a 	wrctl	status,r2
  
  return context;
8113e0e4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e0e8:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113e0ec:	e0bffd17 	ldw	r2,-12(fp)
8113e0f0:	10800283 	ldbu	r2,10(r2)
8113e0f4:	10803fcc 	andi	r2,r2,255
8113e0f8:	10001d26 	beq	r2,zero,8113e170 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113e0fc:	e0bfff03 	ldbu	r2,-4(fp)
8113e100:	1080004c 	andi	r2,r2,1
8113e104:	10000b26 	beq	r2,zero,8113e134 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113e108:	00000506 	br	8113e120 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113e10c:	000f883a 	mov	r7,zero
8113e110:	01800104 	movi	r6,4
8113e114:	e17ffe17 	ldw	r5,-8(fp)
8113e118:	e13ffd17 	ldw	r4,-12(fp)
8113e11c:	1138f100 	call	81138f10 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113e120:	e0bffd17 	ldw	r2,-12(fp)
8113e124:	10800283 	ldbu	r2,10(r2)
8113e128:	10803fcc 	andi	r2,r2,255
8113e12c:	103ff71e 	bne	r2,zero,8113e10c <__reset+0xfb11e10c>
8113e130:	00000506 	br	8113e148 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113e134:	000f883a 	mov	r7,zero
8113e138:	01800104 	movi	r6,4
8113e13c:	e17ffe17 	ldw	r5,-8(fp)
8113e140:	e13ffd17 	ldw	r4,-12(fp)
8113e144:	1138f100 	call	81138f10 <OS_EventTaskRdy>
8113e148:	e0bff717 	ldw	r2,-36(fp)
8113e14c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e150:	e0bff817 	ldw	r2,-32(fp)
8113e154:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113e158:	e0bfff03 	ldbu	r2,-4(fp)
8113e15c:	1080010c 	andi	r2,r2,4
8113e160:	1000011e 	bne	r2,zero,8113e168 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113e164:	11399cc0 	call	811399cc <OS_Sched>
        }
        return (OS_ERR_NONE);
8113e168:	0005883a 	mov	r2,zero
8113e16c:	00004106 	br	8113e274 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113e170:	e0bffd17 	ldw	r2,-12(fp)
8113e174:	10800117 	ldw	r2,4(r2)
8113e178:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113e17c:	e0bffa17 	ldw	r2,-24(fp)
8113e180:	10c0058b 	ldhu	r3,22(r2)
8113e184:	e0bffa17 	ldw	r2,-24(fp)
8113e188:	1080050b 	ldhu	r2,20(r2)
8113e18c:	18ffffcc 	andi	r3,r3,65535
8113e190:	10bfffcc 	andi	r2,r2,65535
8113e194:	18800636 	bltu	r3,r2,8113e1b0 <OSQPostOpt+0x13c>
8113e198:	e0bff717 	ldw	r2,-36(fp)
8113e19c:	e0bff915 	stw	r2,-28(fp)
8113e1a0:	e0bff917 	ldw	r2,-28(fp)
8113e1a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113e1a8:	00800784 	movi	r2,30
8113e1ac:	00003106 	br	8113e274 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113e1b0:	e0bfff03 	ldbu	r2,-4(fp)
8113e1b4:	1080008c 	andi	r2,r2,2
8113e1b8:	10001326 	beq	r2,zero,8113e208 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113e1bc:	e0bffa17 	ldw	r2,-24(fp)
8113e1c0:	10c00417 	ldw	r3,16(r2)
8113e1c4:	e0bffa17 	ldw	r2,-24(fp)
8113e1c8:	10800117 	ldw	r2,4(r2)
8113e1cc:	1880041e 	bne	r3,r2,8113e1e0 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113e1d0:	e0bffa17 	ldw	r2,-24(fp)
8113e1d4:	10c00217 	ldw	r3,8(r2)
8113e1d8:	e0bffa17 	ldw	r2,-24(fp)
8113e1dc:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113e1e0:	e0bffa17 	ldw	r2,-24(fp)
8113e1e4:	10800417 	ldw	r2,16(r2)
8113e1e8:	10ffff04 	addi	r3,r2,-4
8113e1ec:	e0bffa17 	ldw	r2,-24(fp)
8113e1f0:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113e1f4:	e0bffa17 	ldw	r2,-24(fp)
8113e1f8:	10800417 	ldw	r2,16(r2)
8113e1fc:	e0fffe17 	ldw	r3,-8(fp)
8113e200:	10c00015 	stw	r3,0(r2)
8113e204:	00001006 	br	8113e248 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113e208:	e0bffa17 	ldw	r2,-24(fp)
8113e20c:	10800317 	ldw	r2,12(r2)
8113e210:	11000104 	addi	r4,r2,4
8113e214:	e0fffa17 	ldw	r3,-24(fp)
8113e218:	19000315 	stw	r4,12(r3)
8113e21c:	e0fffe17 	ldw	r3,-8(fp)
8113e220:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113e224:	e0bffa17 	ldw	r2,-24(fp)
8113e228:	10c00317 	ldw	r3,12(r2)
8113e22c:	e0bffa17 	ldw	r2,-24(fp)
8113e230:	10800217 	ldw	r2,8(r2)
8113e234:	1880041e 	bne	r3,r2,8113e248 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113e238:	e0bffa17 	ldw	r2,-24(fp)
8113e23c:	10c00117 	ldw	r3,4(r2)
8113e240:	e0bffa17 	ldw	r2,-24(fp)
8113e244:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113e248:	e0bffa17 	ldw	r2,-24(fp)
8113e24c:	1080058b 	ldhu	r2,22(r2)
8113e250:	10800044 	addi	r2,r2,1
8113e254:	1007883a 	mov	r3,r2
8113e258:	e0bffa17 	ldw	r2,-24(fp)
8113e25c:	10c0058d 	sth	r3,22(r2)
8113e260:	e0bff717 	ldw	r2,-36(fp)
8113e264:	e0bffb15 	stw	r2,-20(fp)
8113e268:	e0bffb17 	ldw	r2,-20(fp)
8113e26c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e270:	0005883a 	mov	r2,zero
}
8113e274:	e037883a 	mov	sp,fp
8113e278:	dfc00117 	ldw	ra,4(sp)
8113e27c:	df000017 	ldw	fp,0(sp)
8113e280:	dec00204 	addi	sp,sp,8
8113e284:	f800283a 	ret

8113e288 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113e288:	defff604 	addi	sp,sp,-40
8113e28c:	de00012e 	bgeu	sp,et,8113e294 <OSQQuery+0xc>
8113e290:	003b68fa 	trap	3
8113e294:	df000915 	stw	fp,36(sp)
8113e298:	df000904 	addi	fp,sp,36
8113e29c:	e13ffe15 	stw	r4,-8(fp)
8113e2a0:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113e2a4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113e2a8:	e0bffe17 	ldw	r2,-8(fp)
8113e2ac:	1000021e 	bne	r2,zero,8113e2b8 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113e2b0:	00800104 	movi	r2,4
8113e2b4:	00004906 	br	8113e3dc <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113e2b8:	e0bfff17 	ldw	r2,-4(fp)
8113e2bc:	1000021e 	bne	r2,zero,8113e2c8 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113e2c0:	00800244 	movi	r2,9
8113e2c4:	00004506 	br	8113e3dc <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113e2c8:	e0bffe17 	ldw	r2,-8(fp)
8113e2cc:	10800003 	ldbu	r2,0(r2)
8113e2d0:	10803fcc 	andi	r2,r2,255
8113e2d4:	108000a0 	cmpeqi	r2,r2,2
8113e2d8:	1000021e 	bne	r2,zero,8113e2e4 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113e2dc:	00800044 	movi	r2,1
8113e2e0:	00003e06 	br	8113e3dc <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e2e4:	0005303a 	rdctl	r2,status
8113e2e8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e2ec:	e0fffd17 	ldw	r3,-12(fp)
8113e2f0:	00bfff84 	movi	r2,-2
8113e2f4:	1884703a 	and	r2,r3,r2
8113e2f8:	1001703a 	wrctl	status,r2
  
  return context;
8113e2fc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e300:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113e304:	e0bffe17 	ldw	r2,-8(fp)
8113e308:	10c00283 	ldbu	r3,10(r2)
8113e30c:	e0bfff17 	ldw	r2,-4(fp)
8113e310:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113e314:	e0bffe17 	ldw	r2,-8(fp)
8113e318:	108002c4 	addi	r2,r2,11
8113e31c:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113e320:	e0bfff17 	ldw	r2,-4(fp)
8113e324:	10800204 	addi	r2,r2,8
8113e328:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e32c:	e03ff705 	stb	zero,-36(fp)
8113e330:	00000b06 	br	8113e360 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113e334:	e0bff917 	ldw	r2,-28(fp)
8113e338:	10c00044 	addi	r3,r2,1
8113e33c:	e0fff915 	stw	r3,-28(fp)
8113e340:	e0fff817 	ldw	r3,-32(fp)
8113e344:	19000044 	addi	r4,r3,1
8113e348:	e13ff815 	stw	r4,-32(fp)
8113e34c:	18c00003 	ldbu	r3,0(r3)
8113e350:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e354:	e0bff703 	ldbu	r2,-36(fp)
8113e358:	10800044 	addi	r2,r2,1
8113e35c:	e0bff705 	stb	r2,-36(fp)
8113e360:	e0bff703 	ldbu	r2,-36(fp)
8113e364:	108001b0 	cmpltui	r2,r2,6
8113e368:	103ff21e 	bne	r2,zero,8113e334 <__reset+0xfb11e334>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113e36c:	e0bffe17 	ldw	r2,-8(fp)
8113e370:	10800117 	ldw	r2,4(r2)
8113e374:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113e378:	e0bffc17 	ldw	r2,-16(fp)
8113e37c:	1080058b 	ldhu	r2,22(r2)
8113e380:	10bfffcc 	andi	r2,r2,65535
8113e384:	10000626 	beq	r2,zero,8113e3a0 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113e388:	e0bffc17 	ldw	r2,-16(fp)
8113e38c:	10800417 	ldw	r2,16(r2)
8113e390:	10c00017 	ldw	r3,0(r2)
8113e394:	e0bfff17 	ldw	r2,-4(fp)
8113e398:	10c00015 	stw	r3,0(r2)
8113e39c:	00000206 	br	8113e3a8 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113e3a0:	e0bfff17 	ldw	r2,-4(fp)
8113e3a4:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113e3a8:	e0bffc17 	ldw	r2,-16(fp)
8113e3ac:	10c0058b 	ldhu	r3,22(r2)
8113e3b0:	e0bfff17 	ldw	r2,-4(fp)
8113e3b4:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113e3b8:	e0bffc17 	ldw	r2,-16(fp)
8113e3bc:	10c0050b 	ldhu	r3,20(r2)
8113e3c0:	e0bfff17 	ldw	r2,-4(fp)
8113e3c4:	10c0018d 	sth	r3,6(r2)
8113e3c8:	e0bffa17 	ldw	r2,-24(fp)
8113e3cc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e3d0:	e0bffb17 	ldw	r2,-20(fp)
8113e3d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e3d8:	0005883a 	mov	r2,zero
}
8113e3dc:	e037883a 	mov	sp,fp
8113e3e0:	df000017 	ldw	fp,0(sp)
8113e3e4:	dec00104 	addi	sp,sp,4
8113e3e8:	f800283a 	ret

8113e3ec <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113e3ec:	defffb04 	addi	sp,sp,-20
8113e3f0:	de00012e 	bgeu	sp,et,8113e3f8 <OS_QInit+0xc>
8113e3f4:	003b68fa 	trap	3
8113e3f8:	dfc00415 	stw	ra,16(sp)
8113e3fc:	df000315 	stw	fp,12(sp)
8113e400:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113e404:	0140c004 	movi	r5,768
8113e408:	012045f4 	movhi	r4,33047
8113e40c:	21248904 	addi	r4,r4,-28124
8113e410:	11399000 	call	81139900 <OS_MemClr>
    pq1 = &OSQTbl[0];
8113e414:	00a045f4 	movhi	r2,33047
8113e418:	10a48904 	addi	r2,r2,-28124
8113e41c:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113e420:	00a045f4 	movhi	r2,33047
8113e424:	10a48f04 	addi	r2,r2,-28100
8113e428:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113e42c:	e03ffd0d 	sth	zero,-12(fp)
8113e430:	00000c06 	br	8113e464 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113e434:	e0bffe17 	ldw	r2,-8(fp)
8113e438:	e0ffff17 	ldw	r3,-4(fp)
8113e43c:	10c00015 	stw	r3,0(r2)
        pq1++;
8113e440:	e0bffe17 	ldw	r2,-8(fp)
8113e444:	10800604 	addi	r2,r2,24
8113e448:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113e44c:	e0bfff17 	ldw	r2,-4(fp)
8113e450:	10800604 	addi	r2,r2,24
8113e454:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113e458:	e0bffd0b 	ldhu	r2,-12(fp)
8113e45c:	10800044 	addi	r2,r2,1
8113e460:	e0bffd0d 	sth	r2,-12(fp)
8113e464:	e0bffd0b 	ldhu	r2,-12(fp)
8113e468:	108007f0 	cmpltui	r2,r2,31
8113e46c:	103ff11e 	bne	r2,zero,8113e434 <__reset+0xfb11e434>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113e470:	e0bffe17 	ldw	r2,-8(fp)
8113e474:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113e478:	00a045f4 	movhi	r2,33047
8113e47c:	10a48904 	addi	r2,r2,-28124
8113e480:	d0a09d15 	stw	r2,-32140(gp)
#endif
}
8113e484:	0001883a 	nop
8113e488:	e037883a 	mov	sp,fp
8113e48c:	dfc00117 	ldw	ra,4(sp)
8113e490:	df000017 	ldw	fp,0(sp)
8113e494:	dec00204 	addi	sp,sp,8
8113e498:	f800283a 	ret

8113e49c <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113e49c:	defffa04 	addi	sp,sp,-24
8113e4a0:	de00012e 	bgeu	sp,et,8113e4a8 <OSSemAccept+0xc>
8113e4a4:	003b68fa 	trap	3
8113e4a8:	df000515 	stw	fp,20(sp)
8113e4ac:	df000504 	addi	fp,sp,20
8113e4b0:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e4b4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e4b8:	e0bfff17 	ldw	r2,-4(fp)
8113e4bc:	1000021e 	bne	r2,zero,8113e4c8 <OSSemAccept+0x2c>
        return (0);
8113e4c0:	0005883a 	mov	r2,zero
8113e4c4:	00001f06 	br	8113e544 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e4c8:	e0bfff17 	ldw	r2,-4(fp)
8113e4cc:	10800003 	ldbu	r2,0(r2)
8113e4d0:	10803fcc 	andi	r2,r2,255
8113e4d4:	108000e0 	cmpeqi	r2,r2,3
8113e4d8:	1000021e 	bne	r2,zero,8113e4e4 <OSSemAccept+0x48>
        return (0);
8113e4dc:	0005883a 	mov	r2,zero
8113e4e0:	00001806 	br	8113e544 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e4e4:	0005303a 	rdctl	r2,status
8113e4e8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e4ec:	e0fffe17 	ldw	r3,-8(fp)
8113e4f0:	00bfff84 	movi	r2,-2
8113e4f4:	1884703a 	and	r2,r3,r2
8113e4f8:	1001703a 	wrctl	status,r2
  
  return context;
8113e4fc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e500:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113e504:	e0bfff17 	ldw	r2,-4(fp)
8113e508:	1080020b 	ldhu	r2,8(r2)
8113e50c:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113e510:	e0bffd0b 	ldhu	r2,-12(fp)
8113e514:	10000626 	beq	r2,zero,8113e530 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113e518:	e0bfff17 	ldw	r2,-4(fp)
8113e51c:	1080020b 	ldhu	r2,8(r2)
8113e520:	10bfffc4 	addi	r2,r2,-1
8113e524:	1007883a 	mov	r3,r2
8113e528:	e0bfff17 	ldw	r2,-4(fp)
8113e52c:	10c0020d 	sth	r3,8(r2)
8113e530:	e0bffb17 	ldw	r2,-20(fp)
8113e534:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e538:	e0bffc17 	ldw	r2,-16(fp)
8113e53c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113e540:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113e544:	e037883a 	mov	sp,fp
8113e548:	df000017 	ldw	fp,0(sp)
8113e54c:	dec00104 	addi	sp,sp,4
8113e550:	f800283a 	ret

8113e554 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113e554:	defff904 	addi	sp,sp,-28
8113e558:	de00012e 	bgeu	sp,et,8113e560 <OSSemCreate+0xc>
8113e55c:	003b68fa 	trap	3
8113e560:	dfc00615 	stw	ra,24(sp)
8113e564:	df000515 	stw	fp,20(sp)
8113e568:	df000504 	addi	fp,sp,20
8113e56c:	2005883a 	mov	r2,r4
8113e570:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e574:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e578:	d0a0a103 	ldbu	r2,-32124(gp)
8113e57c:	10803fcc 	andi	r2,r2,255
8113e580:	10000226 	beq	r2,zero,8113e58c <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113e584:	0005883a 	mov	r2,zero
8113e588:	00002506 	br	8113e620 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e58c:	0005303a 	rdctl	r2,status
8113e590:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e594:	e0fffe17 	ldw	r3,-8(fp)
8113e598:	00bfff84 	movi	r2,-2
8113e59c:	1884703a 	and	r2,r3,r2
8113e5a0:	1001703a 	wrctl	status,r2
  
  return context;
8113e5a4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e5a8:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113e5ac:	d0a0a017 	ldw	r2,-32128(gp)
8113e5b0:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113e5b4:	d0a0a017 	ldw	r2,-32128(gp)
8113e5b8:	10000326 	beq	r2,zero,8113e5c8 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113e5bc:	d0a0a017 	ldw	r2,-32128(gp)
8113e5c0:	10800117 	ldw	r2,4(r2)
8113e5c4:	d0a0a015 	stw	r2,-32128(gp)
8113e5c8:	e0bffb17 	ldw	r2,-20(fp)
8113e5cc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e5d0:	e0bffc17 	ldw	r2,-16(fp)
8113e5d4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113e5d8:	e0bffd17 	ldw	r2,-12(fp)
8113e5dc:	10000f26 	beq	r2,zero,8113e61c <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113e5e0:	e0bffd17 	ldw	r2,-12(fp)
8113e5e4:	00c000c4 	movi	r3,3
8113e5e8:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113e5ec:	e0bffd17 	ldw	r2,-12(fp)
8113e5f0:	e0ffff0b 	ldhu	r3,-4(fp)
8113e5f4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113e5f8:	e0bffd17 	ldw	r2,-12(fp)
8113e5fc:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113e600:	e0bffd17 	ldw	r2,-12(fp)
8113e604:	00c00fc4 	movi	r3,63
8113e608:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113e60c:	e0bffd17 	ldw	r2,-12(fp)
8113e610:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113e614:	e13ffd17 	ldw	r4,-12(fp)
8113e618:	11394e80 	call	811394e8 <OS_EventWaitListInit>
    }
    return (pevent);
8113e61c:	e0bffd17 	ldw	r2,-12(fp)
}
8113e620:	e037883a 	mov	sp,fp
8113e624:	dfc00117 	ldw	ra,4(sp)
8113e628:	df000017 	ldw	fp,0(sp)
8113e62c:	dec00204 	addi	sp,sp,8
8113e630:	f800283a 	ret

8113e634 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113e634:	defff304 	addi	sp,sp,-52
8113e638:	de00012e 	bgeu	sp,et,8113e640 <OSSemDel+0xc>
8113e63c:	003b68fa 	trap	3
8113e640:	dfc00c15 	stw	ra,48(sp)
8113e644:	df000b15 	stw	fp,44(sp)
8113e648:	df000b04 	addi	fp,sp,44
8113e64c:	e13ffd15 	stw	r4,-12(fp)
8113e650:	2805883a 	mov	r2,r5
8113e654:	e1bfff15 	stw	r6,-4(fp)
8113e658:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e65c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113e660:	e0bfff17 	ldw	r2,-4(fp)
8113e664:	1000021e 	bne	r2,zero,8113e670 <OSSemDel+0x3c>
        return (pevent);
8113e668:	e0bffd17 	ldw	r2,-12(fp)
8113e66c:	00007e06 	br	8113e868 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e670:	e0bffd17 	ldw	r2,-12(fp)
8113e674:	1000051e 	bne	r2,zero,8113e68c <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113e678:	e0bfff17 	ldw	r2,-4(fp)
8113e67c:	00c00104 	movi	r3,4
8113e680:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e684:	e0bffd17 	ldw	r2,-12(fp)
8113e688:	00007706 	br	8113e868 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113e68c:	e0bffd17 	ldw	r2,-12(fp)
8113e690:	10800003 	ldbu	r2,0(r2)
8113e694:	10803fcc 	andi	r2,r2,255
8113e698:	108000e0 	cmpeqi	r2,r2,3
8113e69c:	1000051e 	bne	r2,zero,8113e6b4 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113e6a0:	e0bfff17 	ldw	r2,-4(fp)
8113e6a4:	00c00044 	movi	r3,1
8113e6a8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e6ac:	e0bffd17 	ldw	r2,-12(fp)
8113e6b0:	00006d06 	br	8113e868 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113e6b4:	d0a0a103 	ldbu	r2,-32124(gp)
8113e6b8:	10803fcc 	andi	r2,r2,255
8113e6bc:	10000526 	beq	r2,zero,8113e6d4 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113e6c0:	e0bfff17 	ldw	r2,-4(fp)
8113e6c4:	00c003c4 	movi	r3,15
8113e6c8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113e6cc:	e0bffd17 	ldw	r2,-12(fp)
8113e6d0:	00006506 	br	8113e868 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e6d4:	0005303a 	rdctl	r2,status
8113e6d8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e6dc:	e0fffc17 	ldw	r3,-16(fp)
8113e6e0:	00bfff84 	movi	r2,-2
8113e6e4:	1884703a 	and	r2,r3,r2
8113e6e8:	1001703a 	wrctl	status,r2
  
  return context;
8113e6ec:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e6f0:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113e6f4:	e0bffd17 	ldw	r2,-12(fp)
8113e6f8:	10800283 	ldbu	r2,10(r2)
8113e6fc:	10803fcc 	andi	r2,r2,255
8113e700:	10000326 	beq	r2,zero,8113e710 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113e704:	00800044 	movi	r2,1
8113e708:	e0bff505 	stb	r2,-44(fp)
8113e70c:	00000106 	br	8113e714 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113e710:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113e714:	e0bffe03 	ldbu	r2,-8(fp)
8113e718:	10000326 	beq	r2,zero,8113e728 <OSSemDel+0xf4>
8113e71c:	10800060 	cmpeqi	r2,r2,1
8113e720:	1000281e 	bne	r2,zero,8113e7c4 <OSSemDel+0x190>
8113e724:	00004506 	br	8113e83c <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113e728:	e0bff503 	ldbu	r2,-44(fp)
8113e72c:	1000161e 	bne	r2,zero,8113e788 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113e730:	e0bffd17 	ldw	r2,-12(fp)
8113e734:	00c00fc4 	movi	r3,63
8113e738:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113e73c:	e0bffd17 	ldw	r2,-12(fp)
8113e740:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113e744:	e0bffd17 	ldw	r2,-12(fp)
8113e748:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113e74c:	d0e0a017 	ldw	r3,-32128(gp)
8113e750:	e0bffd17 	ldw	r2,-12(fp)
8113e754:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113e758:	e0bffd17 	ldw	r2,-12(fp)
8113e75c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113e760:	e0bffd17 	ldw	r2,-12(fp)
8113e764:	d0a0a015 	stw	r2,-32128(gp)
8113e768:	e0bff717 	ldw	r2,-36(fp)
8113e76c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e770:	e0bff817 	ldw	r2,-32(fp)
8113e774:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113e778:	e0bfff17 	ldw	r2,-4(fp)
8113e77c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113e780:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113e784:	00003706 	br	8113e864 <OSSemDel+0x230>
8113e788:	e0bff717 	ldw	r2,-36(fp)
8113e78c:	e0bff915 	stw	r2,-28(fp)
8113e790:	e0bff917 	ldw	r2,-28(fp)
8113e794:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113e798:	e0bfff17 	ldw	r2,-4(fp)
8113e79c:	00c01244 	movi	r3,73
8113e7a0:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113e7a4:	e0bffd17 	ldw	r2,-12(fp)
8113e7a8:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113e7ac:	00002d06 	br	8113e864 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113e7b0:	000f883a 	mov	r7,zero
8113e7b4:	01800044 	movi	r6,1
8113e7b8:	000b883a 	mov	r5,zero
8113e7bc:	e13ffd17 	ldw	r4,-12(fp)
8113e7c0:	1138f100 	call	81138f10 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113e7c4:	e0bffd17 	ldw	r2,-12(fp)
8113e7c8:	10800283 	ldbu	r2,10(r2)
8113e7cc:	10803fcc 	andi	r2,r2,255
8113e7d0:	103ff71e 	bne	r2,zero,8113e7b0 <__reset+0xfb11e7b0>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113e7d4:	e0bffd17 	ldw	r2,-12(fp)
8113e7d8:	00c00fc4 	movi	r3,63
8113e7dc:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113e7e0:	e0bffd17 	ldw	r2,-12(fp)
8113e7e4:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113e7e8:	e0bffd17 	ldw	r2,-12(fp)
8113e7ec:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113e7f0:	d0e0a017 	ldw	r3,-32128(gp)
8113e7f4:	e0bffd17 	ldw	r2,-12(fp)
8113e7f8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113e7fc:	e0bffd17 	ldw	r2,-12(fp)
8113e800:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113e804:	e0bffd17 	ldw	r2,-12(fp)
8113e808:	d0a0a015 	stw	r2,-32128(gp)
8113e80c:	e0bff717 	ldw	r2,-36(fp)
8113e810:	e0bffa15 	stw	r2,-24(fp)
8113e814:	e0bffa17 	ldw	r2,-24(fp)
8113e818:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113e81c:	e0bff503 	ldbu	r2,-44(fp)
8113e820:	10800058 	cmpnei	r2,r2,1
8113e824:	1000011e 	bne	r2,zero,8113e82c <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113e828:	11399cc0 	call	811399cc <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113e82c:	e0bfff17 	ldw	r2,-4(fp)
8113e830:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113e834:	e03ff615 	stw	zero,-40(fp)
             break;
8113e838:	00000a06 	br	8113e864 <OSSemDel+0x230>
8113e83c:	e0bff717 	ldw	r2,-36(fp)
8113e840:	e0bffb15 	stw	r2,-20(fp)
8113e844:	e0bffb17 	ldw	r2,-20(fp)
8113e848:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113e84c:	e0bfff17 	ldw	r2,-4(fp)
8113e850:	00c001c4 	movi	r3,7
8113e854:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113e858:	e0bffd17 	ldw	r2,-12(fp)
8113e85c:	e0bff615 	stw	r2,-40(fp)
             break;
8113e860:	0001883a 	nop
    }
    return (pevent_return);
8113e864:	e0bff617 	ldw	r2,-40(fp)
}
8113e868:	e037883a 	mov	sp,fp
8113e86c:	dfc00117 	ldw	ra,4(sp)
8113e870:	df000017 	ldw	fp,0(sp)
8113e874:	dec00204 	addi	sp,sp,8
8113e878:	f800283a 	ret

8113e87c <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113e87c:	defff504 	addi	sp,sp,-44
8113e880:	de00012e 	bgeu	sp,et,8113e888 <OSSemPend+0xc>
8113e884:	003b68fa 	trap	3
8113e888:	dfc00a15 	stw	ra,40(sp)
8113e88c:	df000915 	stw	fp,36(sp)
8113e890:	df000904 	addi	fp,sp,36
8113e894:	e13ffd15 	stw	r4,-12(fp)
8113e898:	2805883a 	mov	r2,r5
8113e89c:	e1bfff15 	stw	r6,-4(fp)
8113e8a0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e8a4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113e8a8:	e0bfff17 	ldw	r2,-4(fp)
8113e8ac:	10007226 	beq	r2,zero,8113ea78 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e8b0:	e0bffd17 	ldw	r2,-12(fp)
8113e8b4:	1000041e 	bne	r2,zero,8113e8c8 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113e8b8:	e0bfff17 	ldw	r2,-4(fp)
8113e8bc:	00c00104 	movi	r3,4
8113e8c0:	10c00005 	stb	r3,0(r2)
        return;
8113e8c4:	00006d06 	br	8113ea7c <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e8c8:	e0bffd17 	ldw	r2,-12(fp)
8113e8cc:	10800003 	ldbu	r2,0(r2)
8113e8d0:	10803fcc 	andi	r2,r2,255
8113e8d4:	108000e0 	cmpeqi	r2,r2,3
8113e8d8:	1000041e 	bne	r2,zero,8113e8ec <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113e8dc:	e0bfff17 	ldw	r2,-4(fp)
8113e8e0:	00c00044 	movi	r3,1
8113e8e4:	10c00005 	stb	r3,0(r2)
        return;
8113e8e8:	00006406 	br	8113ea7c <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113e8ec:	d0a0a103 	ldbu	r2,-32124(gp)
8113e8f0:	10803fcc 	andi	r2,r2,255
8113e8f4:	10000426 	beq	r2,zero,8113e908 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113e8f8:	e0bfff17 	ldw	r2,-4(fp)
8113e8fc:	00c00084 	movi	r3,2
8113e900:	10c00005 	stb	r3,0(r2)
        return;
8113e904:	00005d06 	br	8113ea7c <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113e908:	d0a08f03 	ldbu	r2,-32196(gp)
8113e90c:	10803fcc 	andi	r2,r2,255
8113e910:	10000426 	beq	r2,zero,8113e924 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113e914:	e0bfff17 	ldw	r2,-4(fp)
8113e918:	00c00344 	movi	r3,13
8113e91c:	10c00005 	stb	r3,0(r2)
        return;
8113e920:	00005606 	br	8113ea7c <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e924:	0005303a 	rdctl	r2,status
8113e928:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e92c:	e0fffc17 	ldw	r3,-16(fp)
8113e930:	00bfff84 	movi	r2,-2
8113e934:	1884703a 	and	r2,r3,r2
8113e938:	1001703a 	wrctl	status,r2
  
  return context;
8113e93c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e940:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113e944:	e0bffd17 	ldw	r2,-12(fp)
8113e948:	1080020b 	ldhu	r2,8(r2)
8113e94c:	10bfffcc 	andi	r2,r2,65535
8113e950:	10000d26 	beq	r2,zero,8113e988 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113e954:	e0bffd17 	ldw	r2,-12(fp)
8113e958:	1080020b 	ldhu	r2,8(r2)
8113e95c:	10bfffc4 	addi	r2,r2,-1
8113e960:	1007883a 	mov	r3,r2
8113e964:	e0bffd17 	ldw	r2,-12(fp)
8113e968:	10c0020d 	sth	r3,8(r2)
8113e96c:	e0bff717 	ldw	r2,-36(fp)
8113e970:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e974:	e0bff817 	ldw	r2,-32(fp)
8113e978:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113e97c:	e0bfff17 	ldw	r2,-4(fp)
8113e980:	10000005 	stb	zero,0(r2)
        return;
8113e984:	00003d06 	br	8113ea7c <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113e988:	d0a0a217 	ldw	r2,-32120(gp)
8113e98c:	d0e0a217 	ldw	r3,-32120(gp)
8113e990:	18c00c03 	ldbu	r3,48(r3)
8113e994:	18c00054 	ori	r3,r3,1
8113e998:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113e99c:	d0a0a217 	ldw	r2,-32120(gp)
8113e9a0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113e9a4:	d0a0a217 	ldw	r2,-32120(gp)
8113e9a8:	e0fffe0b 	ldhu	r3,-8(fp)
8113e9ac:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113e9b0:	e13ffd17 	ldw	r4,-12(fp)
8113e9b4:	11390b00 	call	811390b0 <OS_EventTaskWait>
8113e9b8:	e0bff717 	ldw	r2,-36(fp)
8113e9bc:	e0bffb15 	stw	r2,-20(fp)
8113e9c0:	e0bffb17 	ldw	r2,-20(fp)
8113e9c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113e9c8:	11399cc0 	call	811399cc <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e9cc:	0005303a 	rdctl	r2,status
8113e9d0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e9d4:	e0fff917 	ldw	r3,-28(fp)
8113e9d8:	00bfff84 	movi	r2,-2
8113e9dc:	1884703a 	and	r2,r3,r2
8113e9e0:	1001703a 	wrctl	status,r2
  
  return context;
8113e9e4:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113e9e8:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113e9ec:	d0a0a217 	ldw	r2,-32120(gp)
8113e9f0:	10800c43 	ldbu	r2,49(r2)
8113e9f4:	10803fcc 	andi	r2,r2,255
8113e9f8:	10000326 	beq	r2,zero,8113ea08 <OSSemPend+0x18c>
8113e9fc:	108000a0 	cmpeqi	r2,r2,2
8113ea00:	1000041e 	bne	r2,zero,8113ea14 <OSSemPend+0x198>
8113ea04:	00000706 	br	8113ea24 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113ea08:	e0bfff17 	ldw	r2,-4(fp)
8113ea0c:	10000005 	stb	zero,0(r2)
             break;
8113ea10:	00000c06 	br	8113ea44 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113ea14:	e0bfff17 	ldw	r2,-4(fp)
8113ea18:	00c00384 	movi	r3,14
8113ea1c:	10c00005 	stb	r3,0(r2)
             break;
8113ea20:	00000806 	br	8113ea44 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113ea24:	d0a0a217 	ldw	r2,-32120(gp)
8113ea28:	e17ffd17 	ldw	r5,-12(fp)
8113ea2c:	1009883a 	mov	r4,r2
8113ea30:	11393200 	call	81139320 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113ea34:	e0bfff17 	ldw	r2,-4(fp)
8113ea38:	00c00284 	movi	r3,10
8113ea3c:	10c00005 	stb	r3,0(r2)
             break;
8113ea40:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113ea44:	d0a0a217 	ldw	r2,-32120(gp)
8113ea48:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113ea4c:	d0a0a217 	ldw	r2,-32120(gp)
8113ea50:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113ea54:	d0a0a217 	ldw	r2,-32120(gp)
8113ea58:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113ea5c:	d0a0a217 	ldw	r2,-32120(gp)
8113ea60:	10000815 	stw	zero,32(r2)
8113ea64:	e0bff717 	ldw	r2,-36(fp)
8113ea68:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ea6c:	e0bffa17 	ldw	r2,-24(fp)
8113ea70:	1001703a 	wrctl	status,r2
8113ea74:	00000106 	br	8113ea7c <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113ea78:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113ea7c:	e037883a 	mov	sp,fp
8113ea80:	dfc00117 	ldw	ra,4(sp)
8113ea84:	df000017 	ldw	fp,0(sp)
8113ea88:	dec00204 	addi	sp,sp,8
8113ea8c:	f800283a 	ret

8113ea90 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113ea90:	defff604 	addi	sp,sp,-40
8113ea94:	de00012e 	bgeu	sp,et,8113ea9c <OSSemPendAbort+0xc>
8113ea98:	003b68fa 	trap	3
8113ea9c:	dfc00915 	stw	ra,36(sp)
8113eaa0:	df000815 	stw	fp,32(sp)
8113eaa4:	df000804 	addi	fp,sp,32
8113eaa8:	e13ffd15 	stw	r4,-12(fp)
8113eaac:	2805883a 	mov	r2,r5
8113eab0:	e1bfff15 	stw	r6,-4(fp)
8113eab4:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113eab8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113eabc:	e0bfff17 	ldw	r2,-4(fp)
8113eac0:	1000021e 	bne	r2,zero,8113eacc <OSSemPendAbort+0x3c>
        return (0);
8113eac4:	0005883a 	mov	r2,zero
8113eac8:	00004906 	br	8113ebf0 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113eacc:	e0bffd17 	ldw	r2,-12(fp)
8113ead0:	1000051e 	bne	r2,zero,8113eae8 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ead4:	e0bfff17 	ldw	r2,-4(fp)
8113ead8:	00c00104 	movi	r3,4
8113eadc:	10c00005 	stb	r3,0(r2)
        return (0);
8113eae0:	0005883a 	mov	r2,zero
8113eae4:	00004206 	br	8113ebf0 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113eae8:	e0bffd17 	ldw	r2,-12(fp)
8113eaec:	10800003 	ldbu	r2,0(r2)
8113eaf0:	10803fcc 	andi	r2,r2,255
8113eaf4:	108000e0 	cmpeqi	r2,r2,3
8113eaf8:	1000051e 	bne	r2,zero,8113eb10 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113eafc:	e0bfff17 	ldw	r2,-4(fp)
8113eb00:	00c00044 	movi	r3,1
8113eb04:	10c00005 	stb	r3,0(r2)
        return (0);
8113eb08:	0005883a 	mov	r2,zero
8113eb0c:	00003806 	br	8113ebf0 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113eb10:	0005303a 	rdctl	r2,status
8113eb14:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113eb18:	e0fffc17 	ldw	r3,-16(fp)
8113eb1c:	00bfff84 	movi	r2,-2
8113eb20:	1884703a 	and	r2,r3,r2
8113eb24:	1001703a 	wrctl	status,r2
  
  return context;
8113eb28:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113eb2c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113eb30:	e0bffd17 	ldw	r2,-12(fp)
8113eb34:	10800283 	ldbu	r2,10(r2)
8113eb38:	10803fcc 	andi	r2,r2,255
8113eb3c:	10002526 	beq	r2,zero,8113ebd4 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113eb40:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113eb44:	e0bffe03 	ldbu	r2,-8(fp)
8113eb48:	10800060 	cmpeqi	r2,r2,1
8113eb4c:	10000e26 	beq	r2,zero,8113eb88 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113eb50:	00000806 	br	8113eb74 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113eb54:	01c00084 	movi	r7,2
8113eb58:	01800044 	movi	r6,1
8113eb5c:	000b883a 	mov	r5,zero
8113eb60:	e13ffd17 	ldw	r4,-12(fp)
8113eb64:	1138f100 	call	81138f10 <OS_EventTaskRdy>
                     nbr_tasks++;
8113eb68:	e0bff803 	ldbu	r2,-32(fp)
8113eb6c:	10800044 	addi	r2,r2,1
8113eb70:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113eb74:	e0bffd17 	ldw	r2,-12(fp)
8113eb78:	10800283 	ldbu	r2,10(r2)
8113eb7c:	10803fcc 	andi	r2,r2,255
8113eb80:	103ff41e 	bne	r2,zero,8113eb54 <__reset+0xfb11eb54>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113eb84:	00000906 	br	8113ebac <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113eb88:	01c00084 	movi	r7,2
8113eb8c:	01800044 	movi	r6,1
8113eb90:	000b883a 	mov	r5,zero
8113eb94:	e13ffd17 	ldw	r4,-12(fp)
8113eb98:	1138f100 	call	81138f10 <OS_EventTaskRdy>
                 nbr_tasks++;
8113eb9c:	e0bff803 	ldbu	r2,-32(fp)
8113eba0:	10800044 	addi	r2,r2,1
8113eba4:	e0bff805 	stb	r2,-32(fp)
                 break;
8113eba8:	0001883a 	nop
8113ebac:	e0bff917 	ldw	r2,-28(fp)
8113ebb0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ebb4:	e0bffa17 	ldw	r2,-24(fp)
8113ebb8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113ebbc:	11399cc0 	call	811399cc <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113ebc0:	e0bfff17 	ldw	r2,-4(fp)
8113ebc4:	00c00384 	movi	r3,14
8113ebc8:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113ebcc:	e0bff803 	ldbu	r2,-32(fp)
8113ebd0:	00000706 	br	8113ebf0 <OSSemPendAbort+0x160>
8113ebd4:	e0bff917 	ldw	r2,-28(fp)
8113ebd8:	e0bffb15 	stw	r2,-20(fp)
8113ebdc:	e0bffb17 	ldw	r2,-20(fp)
8113ebe0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ebe4:	e0bfff17 	ldw	r2,-4(fp)
8113ebe8:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8113ebec:	0005883a 	mov	r2,zero
}
8113ebf0:	e037883a 	mov	sp,fp
8113ebf4:	dfc00117 	ldw	ra,4(sp)
8113ebf8:	df000017 	ldw	fp,0(sp)
8113ebfc:	dec00204 	addi	sp,sp,8
8113ec00:	f800283a 	ret

8113ec04 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8113ec04:	defff804 	addi	sp,sp,-32
8113ec08:	de00012e 	bgeu	sp,et,8113ec10 <OSSemPost+0xc>
8113ec0c:	003b68fa 	trap	3
8113ec10:	dfc00715 	stw	ra,28(sp)
8113ec14:	df000615 	stw	fp,24(sp)
8113ec18:	df000604 	addi	fp,sp,24
8113ec1c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ec20:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ec24:	e0bfff17 	ldw	r2,-4(fp)
8113ec28:	1000021e 	bne	r2,zero,8113ec34 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113ec2c:	00800104 	movi	r2,4
8113ec30:	00003506 	br	8113ed08 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113ec34:	e0bfff17 	ldw	r2,-4(fp)
8113ec38:	10800003 	ldbu	r2,0(r2)
8113ec3c:	10803fcc 	andi	r2,r2,255
8113ec40:	108000e0 	cmpeqi	r2,r2,3
8113ec44:	1000021e 	bne	r2,zero,8113ec50 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8113ec48:	00800044 	movi	r2,1
8113ec4c:	00002e06 	br	8113ed08 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec50:	0005303a 	rdctl	r2,status
8113ec54:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ec58:	e0fffe17 	ldw	r3,-8(fp)
8113ec5c:	00bfff84 	movi	r2,-2
8113ec60:	1884703a 	and	r2,r3,r2
8113ec64:	1001703a 	wrctl	status,r2
  
  return context;
8113ec68:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113ec6c:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113ec70:	e0bfff17 	ldw	r2,-4(fp)
8113ec74:	10800283 	ldbu	r2,10(r2)
8113ec78:	10803fcc 	andi	r2,r2,255
8113ec7c:	10000c26 	beq	r2,zero,8113ecb0 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113ec80:	000f883a 	mov	r7,zero
8113ec84:	01800044 	movi	r6,1
8113ec88:	000b883a 	mov	r5,zero
8113ec8c:	e13fff17 	ldw	r4,-4(fp)
8113ec90:	1138f100 	call	81138f10 <OS_EventTaskRdy>
8113ec94:	e0bffa17 	ldw	r2,-24(fp)
8113ec98:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ec9c:	e0bffb17 	ldw	r2,-20(fp)
8113eca0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113eca4:	11399cc0 	call	811399cc <OS_Sched>
        return (OS_ERR_NONE);
8113eca8:	0005883a 	mov	r2,zero
8113ecac:	00001606 	br	8113ed08 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113ecb0:	e0bfff17 	ldw	r2,-4(fp)
8113ecb4:	1080020b 	ldhu	r2,8(r2)
8113ecb8:	10ffffcc 	andi	r3,r2,65535
8113ecbc:	00bfffd4 	movui	r2,65535
8113ecc0:	18800c26 	beq	r3,r2,8113ecf4 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8113ecc4:	e0bfff17 	ldw	r2,-4(fp)
8113ecc8:	1080020b 	ldhu	r2,8(r2)
8113eccc:	10800044 	addi	r2,r2,1
8113ecd0:	1007883a 	mov	r3,r2
8113ecd4:	e0bfff17 	ldw	r2,-4(fp)
8113ecd8:	10c0020d 	sth	r3,8(r2)
8113ecdc:	e0bffa17 	ldw	r2,-24(fp)
8113ece0:	e0bffc15 	stw	r2,-16(fp)
8113ece4:	e0bffc17 	ldw	r2,-16(fp)
8113ece8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113ecec:	0005883a 	mov	r2,zero
8113ecf0:	00000506 	br	8113ed08 <OSSemPost+0x104>
8113ecf4:	e0bffa17 	ldw	r2,-24(fp)
8113ecf8:	e0bffd15 	stw	r2,-12(fp)
8113ecfc:	e0bffd17 	ldw	r2,-12(fp)
8113ed00:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113ed04:	00800c84 	movi	r2,50
}
8113ed08:	e037883a 	mov	sp,fp
8113ed0c:	dfc00117 	ldw	ra,4(sp)
8113ed10:	df000017 	ldw	fp,0(sp)
8113ed14:	dec00204 	addi	sp,sp,8
8113ed18:	f800283a 	ret

8113ed1c <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113ed1c:	defff704 	addi	sp,sp,-36
8113ed20:	de00012e 	bgeu	sp,et,8113ed28 <OSSemQuery+0xc>
8113ed24:	003b68fa 	trap	3
8113ed28:	df000815 	stw	fp,32(sp)
8113ed2c:	df000804 	addi	fp,sp,32
8113ed30:	e13ffe15 	stw	r4,-8(fp)
8113ed34:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113ed38:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113ed3c:	e0bffe17 	ldw	r2,-8(fp)
8113ed40:	1000021e 	bne	r2,zero,8113ed4c <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113ed44:	00800104 	movi	r2,4
8113ed48:	00003606 	br	8113ee24 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113ed4c:	e0bfff17 	ldw	r2,-4(fp)
8113ed50:	1000021e 	bne	r2,zero,8113ed5c <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113ed54:	00800244 	movi	r2,9
8113ed58:	00003206 	br	8113ee24 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113ed5c:	e0bffe17 	ldw	r2,-8(fp)
8113ed60:	10800003 	ldbu	r2,0(r2)
8113ed64:	10803fcc 	andi	r2,r2,255
8113ed68:	108000e0 	cmpeqi	r2,r2,3
8113ed6c:	1000021e 	bne	r2,zero,8113ed78 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113ed70:	00800044 	movi	r2,1
8113ed74:	00002b06 	br	8113ee24 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ed78:	0005303a 	rdctl	r2,status
8113ed7c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ed80:	e0fffd17 	ldw	r3,-12(fp)
8113ed84:	00bfff84 	movi	r2,-2
8113ed88:	1884703a 	and	r2,r3,r2
8113ed8c:	1001703a 	wrctl	status,r2
  
  return context;
8113ed90:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113ed94:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113ed98:	e0bffe17 	ldw	r2,-8(fp)
8113ed9c:	10c00283 	ldbu	r3,10(r2)
8113eda0:	e0bfff17 	ldw	r2,-4(fp)
8113eda4:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113eda8:	e0bffe17 	ldw	r2,-8(fp)
8113edac:	108002c4 	addi	r2,r2,11
8113edb0:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113edb4:	e0bfff17 	ldw	r2,-4(fp)
8113edb8:	10800084 	addi	r2,r2,2
8113edbc:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113edc0:	e03ffa05 	stb	zero,-24(fp)
8113edc4:	00000b06 	br	8113edf4 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113edc8:	e0bff917 	ldw	r2,-28(fp)
8113edcc:	10c00044 	addi	r3,r2,1
8113edd0:	e0fff915 	stw	r3,-28(fp)
8113edd4:	e0fff817 	ldw	r3,-32(fp)
8113edd8:	19000044 	addi	r4,r3,1
8113eddc:	e13ff815 	stw	r4,-32(fp)
8113ede0:	18c00003 	ldbu	r3,0(r3)
8113ede4:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113ede8:	e0bffa03 	ldbu	r2,-24(fp)
8113edec:	10800044 	addi	r2,r2,1
8113edf0:	e0bffa05 	stb	r2,-24(fp)
8113edf4:	e0bffa03 	ldbu	r2,-24(fp)
8113edf8:	108001b0 	cmpltui	r2,r2,6
8113edfc:	103ff21e 	bne	r2,zero,8113edc8 <__reset+0xfb11edc8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113ee00:	e0bffe17 	ldw	r2,-8(fp)
8113ee04:	10c0020b 	ldhu	r3,8(r2)
8113ee08:	e0bfff17 	ldw	r2,-4(fp)
8113ee0c:	10c0000d 	sth	r3,0(r2)
8113ee10:	e0bffb17 	ldw	r2,-20(fp)
8113ee14:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ee18:	e0bffc17 	ldw	r2,-16(fp)
8113ee1c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113ee20:	0005883a 	mov	r2,zero
}
8113ee24:	e037883a 	mov	sp,fp
8113ee28:	df000017 	ldw	fp,0(sp)
8113ee2c:	dec00104 	addi	sp,sp,4
8113ee30:	f800283a 	ret

8113ee34 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113ee34:	defff904 	addi	sp,sp,-28
8113ee38:	de00012e 	bgeu	sp,et,8113ee40 <OSSemSet+0xc>
8113ee3c:	003b68fa 	trap	3
8113ee40:	df000615 	stw	fp,24(sp)
8113ee44:	df000604 	addi	fp,sp,24
8113ee48:	e13ffd15 	stw	r4,-12(fp)
8113ee4c:	2805883a 	mov	r2,r5
8113ee50:	e1bfff15 	stw	r6,-4(fp)
8113ee54:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ee58:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113ee5c:	e0bfff17 	ldw	r2,-4(fp)
8113ee60:	10003126 	beq	r2,zero,8113ef28 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ee64:	e0bffd17 	ldw	r2,-12(fp)
8113ee68:	1000041e 	bne	r2,zero,8113ee7c <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113ee6c:	e0bfff17 	ldw	r2,-4(fp)
8113ee70:	00c00104 	movi	r3,4
8113ee74:	10c00005 	stb	r3,0(r2)
        return;
8113ee78:	00002c06 	br	8113ef2c <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113ee7c:	e0bffd17 	ldw	r2,-12(fp)
8113ee80:	10800003 	ldbu	r2,0(r2)
8113ee84:	10803fcc 	andi	r2,r2,255
8113ee88:	108000e0 	cmpeqi	r2,r2,3
8113ee8c:	1000041e 	bne	r2,zero,8113eea0 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113ee90:	e0bfff17 	ldw	r2,-4(fp)
8113ee94:	00c00044 	movi	r3,1
8113ee98:	10c00005 	stb	r3,0(r2)
        return;
8113ee9c:	00002306 	br	8113ef2c <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113eea0:	0005303a 	rdctl	r2,status
8113eea4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113eea8:	e0fffc17 	ldw	r3,-16(fp)
8113eeac:	00bfff84 	movi	r2,-2
8113eeb0:	1884703a 	and	r2,r3,r2
8113eeb4:	1001703a 	wrctl	status,r2
  
  return context;
8113eeb8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113eebc:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113eec0:	e0bfff17 	ldw	r2,-4(fp)
8113eec4:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113eec8:	e0bffd17 	ldw	r2,-12(fp)
8113eecc:	1080020b 	ldhu	r2,8(r2)
8113eed0:	10bfffcc 	andi	r2,r2,65535
8113eed4:	10000426 	beq	r2,zero,8113eee8 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113eed8:	e0bffd17 	ldw	r2,-12(fp)
8113eedc:	e0fffe0b 	ldhu	r3,-8(fp)
8113eee0:	10c0020d 	sth	r3,8(r2)
8113eee4:	00000b06 	br	8113ef14 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113eee8:	e0bffd17 	ldw	r2,-12(fp)
8113eeec:	10800283 	ldbu	r2,10(r2)
8113eef0:	10803fcc 	andi	r2,r2,255
8113eef4:	1000041e 	bne	r2,zero,8113ef08 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113eef8:	e0bffd17 	ldw	r2,-12(fp)
8113eefc:	e0fffe0b 	ldhu	r3,-8(fp)
8113ef00:	10c0020d 	sth	r3,8(r2)
8113ef04:	00000306 	br	8113ef14 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113ef08:	e0bfff17 	ldw	r2,-4(fp)
8113ef0c:	00c01244 	movi	r3,73
8113ef10:	10c00005 	stb	r3,0(r2)
8113ef14:	e0bffa17 	ldw	r2,-24(fp)
8113ef18:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ef1c:	e0bffb17 	ldw	r2,-20(fp)
8113ef20:	1001703a 	wrctl	status,r2
8113ef24:	00000106 	br	8113ef2c <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113ef28:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113ef2c:	e037883a 	mov	sp,fp
8113ef30:	df000017 	ldw	fp,0(sp)
8113ef34:	dec00104 	addi	sp,sp,4
8113ef38:	f800283a 	ret

8113ef3c <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113ef3c:	defff104 	addi	sp,sp,-60
8113ef40:	de00012e 	bgeu	sp,et,8113ef48 <OSTaskChangePrio+0xc>
8113ef44:	003b68fa 	trap	3
8113ef48:	dfc00e15 	stw	ra,56(sp)
8113ef4c:	df000d15 	stw	fp,52(sp)
8113ef50:	df000d04 	addi	fp,sp,52
8113ef54:	2007883a 	mov	r3,r4
8113ef58:	2805883a 	mov	r2,r5
8113ef5c:	e0fffe05 	stb	r3,-8(fp)
8113ef60:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113ef64:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113ef68:	e0bffe03 	ldbu	r2,-8(fp)
8113ef6c:	10800ab0 	cmpltui	r2,r2,42
8113ef70:	1000051e 	bne	r2,zero,8113ef88 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113ef74:	e0bffe03 	ldbu	r2,-8(fp)
8113ef78:	10803fe0 	cmpeqi	r2,r2,255
8113ef7c:	1000021e 	bne	r2,zero,8113ef88 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113ef80:	00800a84 	movi	r2,42
8113ef84:	00012606 	br	8113f420 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113ef88:	e0bfff03 	ldbu	r2,-4(fp)
8113ef8c:	10800ab0 	cmpltui	r2,r2,42
8113ef90:	1000021e 	bne	r2,zero,8113ef9c <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113ef94:	00800a84 	movi	r2,42
8113ef98:	00012106 	br	8113f420 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ef9c:	0005303a 	rdctl	r2,status
8113efa0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113efa4:	e0fffd17 	ldw	r3,-12(fp)
8113efa8:	00bfff84 	movi	r2,-2
8113efac:	1884703a 	and	r2,r3,r2
8113efb0:	1001703a 	wrctl	status,r2
  
  return context;
8113efb4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113efb8:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113efbc:	e0ffff03 	ldbu	r3,-4(fp)
8113efc0:	00a045f4 	movhi	r2,33047
8113efc4:	10b2f704 	addi	r2,r2,-13348
8113efc8:	18c7883a 	add	r3,r3,r3
8113efcc:	18c7883a 	add	r3,r3,r3
8113efd0:	10c5883a 	add	r2,r2,r3
8113efd4:	10800017 	ldw	r2,0(r2)
8113efd8:	10000626 	beq	r2,zero,8113eff4 <OSTaskChangePrio+0xb8>
8113efdc:	e0bff517 	ldw	r2,-44(fp)
8113efe0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113efe4:	e0bff617 	ldw	r2,-40(fp)
8113efe8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113efec:	00800a04 	movi	r2,40
8113eff0:	00010b06 	br	8113f420 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113eff4:	e0bffe03 	ldbu	r2,-8(fp)
8113eff8:	10803fd8 	cmpnei	r2,r2,255
8113effc:	1000031e 	bne	r2,zero,8113f00c <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113f000:	d0a0a217 	ldw	r2,-32120(gp)
8113f004:	10800c83 	ldbu	r2,50(r2)
8113f008:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113f00c:	e0fffe03 	ldbu	r3,-8(fp)
8113f010:	00a045f4 	movhi	r2,33047
8113f014:	10b2f704 	addi	r2,r2,-13348
8113f018:	18c7883a 	add	r3,r3,r3
8113f01c:	18c7883a 	add	r3,r3,r3
8113f020:	10c5883a 	add	r2,r2,r3
8113f024:	10800017 	ldw	r2,0(r2)
8113f028:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113f02c:	e0bff817 	ldw	r2,-32(fp)
8113f030:	1000061e 	bne	r2,zero,8113f04c <OSTaskChangePrio+0x110>
8113f034:	e0bff517 	ldw	r2,-44(fp)
8113f038:	e0bff715 	stw	r2,-36(fp)
8113f03c:	e0bff717 	ldw	r2,-36(fp)
8113f040:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113f044:	00800a44 	movi	r2,41
8113f048:	0000f506 	br	8113f420 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113f04c:	e0bff817 	ldw	r2,-32(fp)
8113f050:	10800058 	cmpnei	r2,r2,1
8113f054:	1000061e 	bne	r2,zero,8113f070 <OSTaskChangePrio+0x134>
8113f058:	e0bff517 	ldw	r2,-44(fp)
8113f05c:	e0bff915 	stw	r2,-28(fp)
8113f060:	e0bff917 	ldw	r2,-28(fp)
8113f064:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113f068:	008010c4 	movi	r2,67
8113f06c:	0000ec06 	br	8113f420 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113f070:	e0bfff03 	ldbu	r2,-4(fp)
8113f074:	1004d0fa 	srli	r2,r2,3
8113f078:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113f07c:	e0bfff03 	ldbu	r2,-4(fp)
8113f080:	108001cc 	andi	r2,r2,7
8113f084:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113f088:	e0bffb03 	ldbu	r2,-20(fp)
8113f08c:	00c00044 	movi	r3,1
8113f090:	1884983a 	sll	r2,r3,r2
8113f094:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113f098:	e0bffb43 	ldbu	r2,-19(fp)
8113f09c:	00c00044 	movi	r3,1
8113f0a0:	1884983a 	sll	r2,r3,r2
8113f0a4:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113f0a8:	e0fffe03 	ldbu	r3,-8(fp)
8113f0ac:	00a045f4 	movhi	r2,33047
8113f0b0:	10b2f704 	addi	r2,r2,-13348
8113f0b4:	18c7883a 	add	r3,r3,r3
8113f0b8:	18c7883a 	add	r3,r3,r3
8113f0bc:	10c5883a 	add	r2,r2,r3
8113f0c0:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113f0c4:	e0ffff03 	ldbu	r3,-4(fp)
8113f0c8:	00a045f4 	movhi	r2,33047
8113f0cc:	10b2f704 	addi	r2,r2,-13348
8113f0d0:	18c7883a 	add	r3,r3,r3
8113f0d4:	18c7883a 	add	r3,r3,r3
8113f0d8:	10c5883a 	add	r2,r2,r3
8113f0dc:	e0fff817 	ldw	r3,-32(fp)
8113f0e0:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113f0e4:	e0bff817 	ldw	r2,-32(fp)
8113f0e8:	10800d03 	ldbu	r2,52(r2)
8113f0ec:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113f0f0:	e0bff817 	ldw	r2,-32(fp)
8113f0f4:	10800d83 	ldbu	r2,54(r2)
8113f0f8:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113f0fc:	e0bff817 	ldw	r2,-32(fp)
8113f100:	10800d43 	ldbu	r2,53(r2)
8113f104:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113f108:	e0fffc03 	ldbu	r3,-16(fp)
8113f10c:	d0a09e44 	addi	r2,gp,-32135
8113f110:	1885883a 	add	r2,r3,r2
8113f114:	10c00003 	ldbu	r3,0(r2)
8113f118:	e0bffc83 	ldbu	r2,-14(fp)
8113f11c:	1884703a 	and	r2,r3,r2
8113f120:	10803fcc 	andi	r2,r2,255
8113f124:	10002826 	beq	r2,zero,8113f1c8 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113f128:	e0fffc03 	ldbu	r3,-16(fp)
8113f12c:	e13ffc03 	ldbu	r4,-16(fp)
8113f130:	d0a09e44 	addi	r2,gp,-32135
8113f134:	2085883a 	add	r2,r4,r2
8113f138:	10800003 	ldbu	r2,0(r2)
8113f13c:	1009883a 	mov	r4,r2
8113f140:	e0bffc83 	ldbu	r2,-14(fp)
8113f144:	0084303a 	nor	r2,zero,r2
8113f148:	2084703a 	and	r2,r4,r2
8113f14c:	1009883a 	mov	r4,r2
8113f150:	d0a09e44 	addi	r2,gp,-32135
8113f154:	1885883a 	add	r2,r3,r2
8113f158:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113f15c:	e0fffc03 	ldbu	r3,-16(fp)
8113f160:	d0a09e44 	addi	r2,gp,-32135
8113f164:	1885883a 	add	r2,r3,r2
8113f168:	10800003 	ldbu	r2,0(r2)
8113f16c:	10803fcc 	andi	r2,r2,255
8113f170:	1000061e 	bne	r2,zero,8113f18c <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113f174:	e0bffc43 	ldbu	r2,-15(fp)
8113f178:	0084303a 	nor	r2,zero,r2
8113f17c:	1007883a 	mov	r3,r2
8113f180:	d0a09e03 	ldbu	r2,-32136(gp)
8113f184:	1884703a 	and	r2,r3,r2
8113f188:	d0a09e05 	stb	r2,-32136(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113f18c:	d0e09e03 	ldbu	r3,-32136(gp)
8113f190:	e0bffb83 	ldbu	r2,-18(fp)
8113f194:	1884b03a 	or	r2,r3,r2
8113f198:	d0a09e05 	stb	r2,-32136(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113f19c:	e0fffb03 	ldbu	r3,-20(fp)
8113f1a0:	e13ffb03 	ldbu	r4,-20(fp)
8113f1a4:	d0a09e44 	addi	r2,gp,-32135
8113f1a8:	2085883a 	add	r2,r4,r2
8113f1ac:	11000003 	ldbu	r4,0(r2)
8113f1b0:	e0bffbc3 	ldbu	r2,-17(fp)
8113f1b4:	2084b03a 	or	r2,r4,r2
8113f1b8:	1009883a 	mov	r4,r2
8113f1bc:	d0a09e44 	addi	r2,gp,-32135
8113f1c0:	1885883a 	add	r2,r3,r2
8113f1c4:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113f1c8:	e0bff817 	ldw	r2,-32(fp)
8113f1cc:	10800717 	ldw	r2,28(r2)
8113f1d0:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113f1d4:	e0bff317 	ldw	r2,-52(fp)
8113f1d8:	10003326 	beq	r2,zero,8113f2a8 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113f1dc:	e0bffc03 	ldbu	r2,-16(fp)
8113f1e0:	e0fffc03 	ldbu	r3,-16(fp)
8113f1e4:	e13ff317 	ldw	r4,-52(fp)
8113f1e8:	20c7883a 	add	r3,r4,r3
8113f1ec:	18c002c4 	addi	r3,r3,11
8113f1f0:	18c00003 	ldbu	r3,0(r3)
8113f1f4:	1809883a 	mov	r4,r3
8113f1f8:	e0fffc83 	ldbu	r3,-14(fp)
8113f1fc:	00c6303a 	nor	r3,zero,r3
8113f200:	20c6703a 	and	r3,r4,r3
8113f204:	1809883a 	mov	r4,r3
8113f208:	e0fff317 	ldw	r3,-52(fp)
8113f20c:	1885883a 	add	r2,r3,r2
8113f210:	108002c4 	addi	r2,r2,11
8113f214:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113f218:	e0bffc03 	ldbu	r2,-16(fp)
8113f21c:	e0fff317 	ldw	r3,-52(fp)
8113f220:	1885883a 	add	r2,r3,r2
8113f224:	108002c4 	addi	r2,r2,11
8113f228:	10800003 	ldbu	r2,0(r2)
8113f22c:	10803fcc 	andi	r2,r2,255
8113f230:	1000091e 	bne	r2,zero,8113f258 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113f234:	e0bff317 	ldw	r2,-52(fp)
8113f238:	10800283 	ldbu	r2,10(r2)
8113f23c:	1007883a 	mov	r3,r2
8113f240:	e0bffc43 	ldbu	r2,-15(fp)
8113f244:	0084303a 	nor	r2,zero,r2
8113f248:	1884703a 	and	r2,r3,r2
8113f24c:	1007883a 	mov	r3,r2
8113f250:	e0bff317 	ldw	r2,-52(fp)
8113f254:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113f258:	e0bff317 	ldw	r2,-52(fp)
8113f25c:	10c00283 	ldbu	r3,10(r2)
8113f260:	e0bffb83 	ldbu	r2,-18(fp)
8113f264:	1884b03a 	or	r2,r3,r2
8113f268:	1007883a 	mov	r3,r2
8113f26c:	e0bff317 	ldw	r2,-52(fp)
8113f270:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113f274:	e0bffb03 	ldbu	r2,-20(fp)
8113f278:	e0fffb03 	ldbu	r3,-20(fp)
8113f27c:	e13ff317 	ldw	r4,-52(fp)
8113f280:	20c7883a 	add	r3,r4,r3
8113f284:	18c002c4 	addi	r3,r3,11
8113f288:	19000003 	ldbu	r4,0(r3)
8113f28c:	e0fffbc3 	ldbu	r3,-17(fp)
8113f290:	20c6b03a 	or	r3,r4,r3
8113f294:	1809883a 	mov	r4,r3
8113f298:	e0fff317 	ldw	r3,-52(fp)
8113f29c:	1885883a 	add	r2,r3,r2
8113f2a0:	108002c4 	addi	r2,r2,11
8113f2a4:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113f2a8:	e0bff817 	ldw	r2,-32(fp)
8113f2ac:	10800817 	ldw	r2,32(r2)
8113f2b0:	10004226 	beq	r2,zero,8113f3bc <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113f2b4:	e0bff817 	ldw	r2,-32(fp)
8113f2b8:	10800817 	ldw	r2,32(r2)
8113f2bc:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113f2c0:	e0bff417 	ldw	r2,-48(fp)
8113f2c4:	10800017 	ldw	r2,0(r2)
8113f2c8:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113f2cc:	00003906 	br	8113f3b4 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113f2d0:	e0bffc03 	ldbu	r2,-16(fp)
8113f2d4:	e0fffc03 	ldbu	r3,-16(fp)
8113f2d8:	e13ff317 	ldw	r4,-52(fp)
8113f2dc:	20c7883a 	add	r3,r4,r3
8113f2e0:	18c002c4 	addi	r3,r3,11
8113f2e4:	18c00003 	ldbu	r3,0(r3)
8113f2e8:	1809883a 	mov	r4,r3
8113f2ec:	e0fffc83 	ldbu	r3,-14(fp)
8113f2f0:	00c6303a 	nor	r3,zero,r3
8113f2f4:	20c6703a 	and	r3,r4,r3
8113f2f8:	1809883a 	mov	r4,r3
8113f2fc:	e0fff317 	ldw	r3,-52(fp)
8113f300:	1885883a 	add	r2,r3,r2
8113f304:	108002c4 	addi	r2,r2,11
8113f308:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113f30c:	e0bffc03 	ldbu	r2,-16(fp)
8113f310:	e0fff317 	ldw	r3,-52(fp)
8113f314:	1885883a 	add	r2,r3,r2
8113f318:	108002c4 	addi	r2,r2,11
8113f31c:	10800003 	ldbu	r2,0(r2)
8113f320:	10803fcc 	andi	r2,r2,255
8113f324:	1000091e 	bne	r2,zero,8113f34c <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113f328:	e0bff317 	ldw	r2,-52(fp)
8113f32c:	10800283 	ldbu	r2,10(r2)
8113f330:	1007883a 	mov	r3,r2
8113f334:	e0bffc43 	ldbu	r2,-15(fp)
8113f338:	0084303a 	nor	r2,zero,r2
8113f33c:	1884703a 	and	r2,r3,r2
8113f340:	1007883a 	mov	r3,r2
8113f344:	e0bff317 	ldw	r2,-52(fp)
8113f348:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113f34c:	e0bff317 	ldw	r2,-52(fp)
8113f350:	10c00283 	ldbu	r3,10(r2)
8113f354:	e0bffb83 	ldbu	r2,-18(fp)
8113f358:	1884b03a 	or	r2,r3,r2
8113f35c:	1007883a 	mov	r3,r2
8113f360:	e0bff317 	ldw	r2,-52(fp)
8113f364:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113f368:	e0bffb03 	ldbu	r2,-20(fp)
8113f36c:	e0fffb03 	ldbu	r3,-20(fp)
8113f370:	e13ff317 	ldw	r4,-52(fp)
8113f374:	20c7883a 	add	r3,r4,r3
8113f378:	18c002c4 	addi	r3,r3,11
8113f37c:	19000003 	ldbu	r4,0(r3)
8113f380:	e0fffbc3 	ldbu	r3,-17(fp)
8113f384:	20c6b03a 	or	r3,r4,r3
8113f388:	1809883a 	mov	r4,r3
8113f38c:	e0fff317 	ldw	r3,-52(fp)
8113f390:	1885883a 	add	r2,r3,r2
8113f394:	108002c4 	addi	r2,r2,11
8113f398:	11000005 	stb	r4,0(r2)
            pevents++;
8113f39c:	e0bff417 	ldw	r2,-48(fp)
8113f3a0:	10800104 	addi	r2,r2,4
8113f3a4:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113f3a8:	e0bff417 	ldw	r2,-48(fp)
8113f3ac:	10800017 	ldw	r2,0(r2)
8113f3b0:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113f3b4:	e0bff317 	ldw	r2,-52(fp)
8113f3b8:	103fc51e 	bne	r2,zero,8113f2d0 <__reset+0xfb11f2d0>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113f3bc:	e0bff817 	ldw	r2,-32(fp)
8113f3c0:	e0ffff03 	ldbu	r3,-4(fp)
8113f3c4:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113f3c8:	e0bff817 	ldw	r2,-32(fp)
8113f3cc:	e0fffb03 	ldbu	r3,-20(fp)
8113f3d0:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113f3d4:	e0bff817 	ldw	r2,-32(fp)
8113f3d8:	e0fffb43 	ldbu	r3,-19(fp)
8113f3dc:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113f3e0:	e0bff817 	ldw	r2,-32(fp)
8113f3e4:	e0fffb83 	ldbu	r3,-18(fp)
8113f3e8:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113f3ec:	e0bff817 	ldw	r2,-32(fp)
8113f3f0:	e0fffbc3 	ldbu	r3,-17(fp)
8113f3f4:	10c00d45 	stb	r3,53(r2)
8113f3f8:	e0bff517 	ldw	r2,-44(fp)
8113f3fc:	e0bffa15 	stw	r2,-24(fp)
8113f400:	e0bffa17 	ldw	r2,-24(fp)
8113f404:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113f408:	d0a09103 	ldbu	r2,-32188(gp)
8113f40c:	10803fcc 	andi	r2,r2,255
8113f410:	10800058 	cmpnei	r2,r2,1
8113f414:	1000011e 	bne	r2,zero,8113f41c <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113f418:	11399cc0 	call	811399cc <OS_Sched>
    }
    return (OS_ERR_NONE);
8113f41c:	0005883a 	mov	r2,zero
}
8113f420:	e037883a 	mov	sp,fp
8113f424:	dfc00117 	ldw	ra,4(sp)
8113f428:	df000017 	ldw	fp,0(sp)
8113f42c:	dec00204 	addi	sp,sp,8
8113f430:	f800283a 	ret

8113f434 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8113f434:	deffee04 	addi	sp,sp,-72
8113f438:	de00012e 	bgeu	sp,et,8113f440 <OSTaskCreate+0xc>
8113f43c:	003b68fa 	trap	3
8113f440:	dfc01115 	stw	ra,68(sp)
8113f444:	df001015 	stw	fp,64(sp)
8113f448:	df001004 	addi	fp,sp,64
8113f44c:	e13ffc15 	stw	r4,-16(fp)
8113f450:	e17ffd15 	stw	r5,-12(fp)
8113f454:	e1bffe15 	stw	r6,-8(fp)
8113f458:	3805883a 	mov	r2,r7
8113f45c:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113f460:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113f464:	e0bfff03 	ldbu	r2,-4(fp)
8113f468:	10800af0 	cmpltui	r2,r2,43
8113f46c:	1000021e 	bne	r2,zero,8113f478 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113f470:	00800a84 	movi	r2,42
8113f474:	00005706 	br	8113f5d4 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f478:	0005303a 	rdctl	r2,status
8113f47c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f480:	e0fffb17 	ldw	r3,-20(fp)
8113f484:	00bfff84 	movi	r2,-2
8113f488:	1884703a 	and	r2,r3,r2
8113f48c:	1001703a 	wrctl	status,r2
  
  return context;
8113f490:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f494:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113f498:	d0a0a103 	ldbu	r2,-32124(gp)
8113f49c:	10803fcc 	andi	r2,r2,255
8113f4a0:	10000626 	beq	r2,zero,8113f4bc <OSTaskCreate+0x88>
8113f4a4:	e0bff317 	ldw	r2,-52(fp)
8113f4a8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f4ac:	e0bff417 	ldw	r2,-48(fp)
8113f4b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113f4b4:	00800f04 	movi	r2,60
8113f4b8:	00004606 	br	8113f5d4 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113f4bc:	e0ffff03 	ldbu	r3,-4(fp)
8113f4c0:	00a045f4 	movhi	r2,33047
8113f4c4:	10b2f704 	addi	r2,r2,-13348
8113f4c8:	18c7883a 	add	r3,r3,r3
8113f4cc:	18c7883a 	add	r3,r3,r3
8113f4d0:	10c5883a 	add	r2,r2,r3
8113f4d4:	10800017 	ldw	r2,0(r2)
8113f4d8:	1000391e 	bne	r2,zero,8113f5c0 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113f4dc:	e0ffff03 	ldbu	r3,-4(fp)
8113f4e0:	00a045f4 	movhi	r2,33047
8113f4e4:	10b2f704 	addi	r2,r2,-13348
8113f4e8:	18c7883a 	add	r3,r3,r3
8113f4ec:	18c7883a 	add	r3,r3,r3
8113f4f0:	10c5883a 	add	r2,r2,r3
8113f4f4:	00c00044 	movi	r3,1
8113f4f8:	10c00015 	stw	r3,0(r2)
8113f4fc:	e0bff317 	ldw	r2,-52(fp)
8113f500:	e0bff515 	stw	r2,-44(fp)
8113f504:	e0bff517 	ldw	r2,-44(fp)
8113f508:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8113f50c:	000f883a 	mov	r7,zero
8113f510:	e1bffe17 	ldw	r6,-8(fp)
8113f514:	e17ffd17 	ldw	r5,-12(fp)
8113f518:	e13ffc17 	ldw	r4,-16(fp)
8113f51c:	114aadc0 	call	8114aadc <OSTaskStkInit>
8113f520:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8113f524:	e0bfff03 	ldbu	r2,-4(fp)
8113f528:	d8000215 	stw	zero,8(sp)
8113f52c:	d8000115 	stw	zero,4(sp)
8113f530:	d8000015 	stw	zero,0(sp)
8113f534:	000f883a 	mov	r7,zero
8113f538:	000d883a 	mov	r6,zero
8113f53c:	e17ff717 	ldw	r5,-36(fp)
8113f540:	1009883a 	mov	r4,r2
8113f544:	1139e140 	call	81139e14 <OS_TCBInit>
8113f548:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8113f54c:	e0bff803 	ldbu	r2,-32(fp)
8113f550:	1000061e 	bne	r2,zero,8113f56c <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8113f554:	d0a09103 	ldbu	r2,-32188(gp)
8113f558:	10803fcc 	andi	r2,r2,255
8113f55c:	10800058 	cmpnei	r2,r2,1
8113f560:	1000151e 	bne	r2,zero,8113f5b8 <OSTaskCreate+0x184>
                OS_Sched();
8113f564:	11399cc0 	call	811399cc <OS_Sched>
8113f568:	00001306 	br	8113f5b8 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f56c:	0005303a 	rdctl	r2,status
8113f570:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f574:	e0fffa17 	ldw	r3,-24(fp)
8113f578:	00bfff84 	movi	r2,-2
8113f57c:	1884703a 	and	r2,r3,r2
8113f580:	1001703a 	wrctl	status,r2
  
  return context;
8113f584:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113f588:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8113f58c:	e0ffff03 	ldbu	r3,-4(fp)
8113f590:	00a045f4 	movhi	r2,33047
8113f594:	10b2f704 	addi	r2,r2,-13348
8113f598:	18c7883a 	add	r3,r3,r3
8113f59c:	18c7883a 	add	r3,r3,r3
8113f5a0:	10c5883a 	add	r2,r2,r3
8113f5a4:	10000015 	stw	zero,0(r2)
8113f5a8:	e0bff317 	ldw	r2,-52(fp)
8113f5ac:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f5b0:	e0bff617 	ldw	r2,-40(fp)
8113f5b4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113f5b8:	e0bff803 	ldbu	r2,-32(fp)
8113f5bc:	00000506 	br	8113f5d4 <OSTaskCreate+0x1a0>
8113f5c0:	e0bff317 	ldw	r2,-52(fp)
8113f5c4:	e0bff915 	stw	r2,-28(fp)
8113f5c8:	e0bff917 	ldw	r2,-28(fp)
8113f5cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113f5d0:	00800a04 	movi	r2,40
}
8113f5d4:	e037883a 	mov	sp,fp
8113f5d8:	dfc00117 	ldw	ra,4(sp)
8113f5dc:	df000017 	ldw	fp,0(sp)
8113f5e0:	dec00204 	addi	sp,sp,8
8113f5e4:	f800283a 	ret

8113f5e8 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113f5e8:	deffec04 	addi	sp,sp,-80
8113f5ec:	de00012e 	bgeu	sp,et,8113f5f4 <OSTaskCreateExt+0xc>
8113f5f0:	003b68fa 	trap	3
8113f5f4:	dfc01315 	stw	ra,76(sp)
8113f5f8:	df001215 	stw	fp,72(sp)
8113f5fc:	df001204 	addi	fp,sp,72
8113f600:	e13ffa15 	stw	r4,-24(fp)
8113f604:	e17ffb15 	stw	r5,-20(fp)
8113f608:	e1bffc15 	stw	r6,-16(fp)
8113f60c:	3809883a 	mov	r4,r7
8113f610:	e0c00217 	ldw	r3,8(fp)
8113f614:	e0800617 	ldw	r2,24(fp)
8113f618:	e13ffd05 	stb	r4,-12(fp)
8113f61c:	e0fffe0d 	sth	r3,-8(fp)
8113f620:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113f624:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113f628:	e0bffd03 	ldbu	r2,-12(fp)
8113f62c:	10800af0 	cmpltui	r2,r2,43
8113f630:	1000021e 	bne	r2,zero,8113f63c <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113f634:	00800a84 	movi	r2,42
8113f638:	00006106 	br	8113f7c0 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f63c:	0005303a 	rdctl	r2,status
8113f640:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f644:	e0fff917 	ldw	r3,-28(fp)
8113f648:	00bfff84 	movi	r2,-2
8113f64c:	1884703a 	and	r2,r3,r2
8113f650:	1001703a 	wrctl	status,r2
  
  return context;
8113f654:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f658:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113f65c:	d0a0a103 	ldbu	r2,-32124(gp)
8113f660:	10803fcc 	andi	r2,r2,255
8113f664:	10000626 	beq	r2,zero,8113f680 <OSTaskCreateExt+0x98>
8113f668:	e0bff117 	ldw	r2,-60(fp)
8113f66c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f670:	e0bff217 	ldw	r2,-56(fp)
8113f674:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113f678:	00800f04 	movi	r2,60
8113f67c:	00005006 	br	8113f7c0 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113f680:	e0fffd03 	ldbu	r3,-12(fp)
8113f684:	00a045f4 	movhi	r2,33047
8113f688:	10b2f704 	addi	r2,r2,-13348
8113f68c:	18c7883a 	add	r3,r3,r3
8113f690:	18c7883a 	add	r3,r3,r3
8113f694:	10c5883a 	add	r2,r2,r3
8113f698:	10800017 	ldw	r2,0(r2)
8113f69c:	1000431e 	bne	r2,zero,8113f7ac <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113f6a0:	e0fffd03 	ldbu	r3,-12(fp)
8113f6a4:	00a045f4 	movhi	r2,33047
8113f6a8:	10b2f704 	addi	r2,r2,-13348
8113f6ac:	18c7883a 	add	r3,r3,r3
8113f6b0:	18c7883a 	add	r3,r3,r3
8113f6b4:	10c5883a 	add	r2,r2,r3
8113f6b8:	00c00044 	movi	r3,1
8113f6bc:	10c00015 	stw	r3,0(r2)
8113f6c0:	e0bff117 	ldw	r2,-60(fp)
8113f6c4:	e0bff315 	stw	r2,-52(fp)
8113f6c8:	e0bff317 	ldw	r2,-52(fp)
8113f6cc:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113f6d0:	e0bfff0b 	ldhu	r2,-4(fp)
8113f6d4:	100d883a 	mov	r6,r2
8113f6d8:	e1400417 	ldw	r5,16(fp)
8113f6dc:	e1000317 	ldw	r4,12(fp)
8113f6e0:	11406900 	call	81140690 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113f6e4:	e0bfff0b 	ldhu	r2,-4(fp)
8113f6e8:	100f883a 	mov	r7,r2
8113f6ec:	e1bffc17 	ldw	r6,-16(fp)
8113f6f0:	e17ffb17 	ldw	r5,-20(fp)
8113f6f4:	e13ffa17 	ldw	r4,-24(fp)
8113f6f8:	114aadc0 	call	8114aadc <OSTaskStkInit>
8113f6fc:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113f700:	e0fffd03 	ldbu	r3,-12(fp)
8113f704:	e13ffe0b 	ldhu	r4,-8(fp)
8113f708:	e0bfff0b 	ldhu	r2,-4(fp)
8113f70c:	d8800215 	stw	r2,8(sp)
8113f710:	e0800517 	ldw	r2,20(fp)
8113f714:	d8800115 	stw	r2,4(sp)
8113f718:	e0800417 	ldw	r2,16(fp)
8113f71c:	d8800015 	stw	r2,0(sp)
8113f720:	200f883a 	mov	r7,r4
8113f724:	e1800317 	ldw	r6,12(fp)
8113f728:	e17ff517 	ldw	r5,-44(fp)
8113f72c:	1809883a 	mov	r4,r3
8113f730:	1139e140 	call	81139e14 <OS_TCBInit>
8113f734:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113f738:	e0bff603 	ldbu	r2,-40(fp)
8113f73c:	1000061e 	bne	r2,zero,8113f758 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113f740:	d0a09103 	ldbu	r2,-32188(gp)
8113f744:	10803fcc 	andi	r2,r2,255
8113f748:	10800058 	cmpnei	r2,r2,1
8113f74c:	1000151e 	bne	r2,zero,8113f7a4 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113f750:	11399cc0 	call	811399cc <OS_Sched>
8113f754:	00001306 	br	8113f7a4 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f758:	0005303a 	rdctl	r2,status
8113f75c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f760:	e0fff817 	ldw	r3,-32(fp)
8113f764:	00bfff84 	movi	r2,-2
8113f768:	1884703a 	and	r2,r3,r2
8113f76c:	1001703a 	wrctl	status,r2
  
  return context;
8113f770:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113f774:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113f778:	e0fffd03 	ldbu	r3,-12(fp)
8113f77c:	00a045f4 	movhi	r2,33047
8113f780:	10b2f704 	addi	r2,r2,-13348
8113f784:	18c7883a 	add	r3,r3,r3
8113f788:	18c7883a 	add	r3,r3,r3
8113f78c:	10c5883a 	add	r2,r2,r3
8113f790:	10000015 	stw	zero,0(r2)
8113f794:	e0bff117 	ldw	r2,-60(fp)
8113f798:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f79c:	e0bff417 	ldw	r2,-48(fp)
8113f7a0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113f7a4:	e0bff603 	ldbu	r2,-40(fp)
8113f7a8:	00000506 	br	8113f7c0 <OSTaskCreateExt+0x1d8>
8113f7ac:	e0bff117 	ldw	r2,-60(fp)
8113f7b0:	e0bff715 	stw	r2,-36(fp)
8113f7b4:	e0bff717 	ldw	r2,-36(fp)
8113f7b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113f7bc:	00800a04 	movi	r2,40
}
8113f7c0:	e037883a 	mov	sp,fp
8113f7c4:	dfc00117 	ldw	ra,4(sp)
8113f7c8:	df000017 	ldw	fp,0(sp)
8113f7cc:	dec00204 	addi	sp,sp,8
8113f7d0:	f800283a 	ret

8113f7d4 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113f7d4:	defff404 	addi	sp,sp,-48
8113f7d8:	de00012e 	bgeu	sp,et,8113f7e0 <OSTaskDel+0xc>
8113f7dc:	003b68fa 	trap	3
8113f7e0:	dfc00b15 	stw	ra,44(sp)
8113f7e4:	df000a15 	stw	fp,40(sp)
8113f7e8:	df000a04 	addi	fp,sp,40
8113f7ec:	2005883a 	mov	r2,r4
8113f7f0:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113f7f4:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113f7f8:	d0a0a103 	ldbu	r2,-32124(gp)
8113f7fc:	10803fcc 	andi	r2,r2,255
8113f800:	10000226 	beq	r2,zero,8113f80c <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113f804:	00801004 	movi	r2,64
8113f808:	0000c006 	br	8113fb0c <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113f80c:	e0bfff03 	ldbu	r2,-4(fp)
8113f810:	10800a98 	cmpnei	r2,r2,42
8113f814:	1000021e 	bne	r2,zero,8113f820 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113f818:	00800f84 	movi	r2,62
8113f81c:	0000bb06 	br	8113fb0c <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113f820:	e0bfff03 	ldbu	r2,-4(fp)
8113f824:	10800ab0 	cmpltui	r2,r2,42
8113f828:	1000051e 	bne	r2,zero,8113f840 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113f82c:	e0bfff03 	ldbu	r2,-4(fp)
8113f830:	10803fe0 	cmpeqi	r2,r2,255
8113f834:	1000021e 	bne	r2,zero,8113f840 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113f838:	00800a84 	movi	r2,42
8113f83c:	0000b306 	br	8113fb0c <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f840:	0005303a 	rdctl	r2,status
8113f844:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f848:	e0fffe17 	ldw	r3,-8(fp)
8113f84c:	00bfff84 	movi	r2,-2
8113f850:	1884703a 	and	r2,r3,r2
8113f854:	1001703a 	wrctl	status,r2
  
  return context;
8113f858:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113f85c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113f860:	e0bfff03 	ldbu	r2,-4(fp)
8113f864:	10803fd8 	cmpnei	r2,r2,255
8113f868:	1000031e 	bne	r2,zero,8113f878 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113f86c:	d0a0a217 	ldw	r2,-32120(gp)
8113f870:	10800c83 	ldbu	r2,50(r2)
8113f874:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113f878:	e0ffff03 	ldbu	r3,-4(fp)
8113f87c:	00a045f4 	movhi	r2,33047
8113f880:	10b2f704 	addi	r2,r2,-13348
8113f884:	18c7883a 	add	r3,r3,r3
8113f888:	18c7883a 	add	r3,r3,r3
8113f88c:	10c5883a 	add	r2,r2,r3
8113f890:	10800017 	ldw	r2,0(r2)
8113f894:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113f898:	e0bff817 	ldw	r2,-32(fp)
8113f89c:	1000061e 	bne	r2,zero,8113f8b8 <OSTaskDel+0xe4>
8113f8a0:	e0bff617 	ldw	r2,-40(fp)
8113f8a4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f8a8:	e0bff717 	ldw	r2,-36(fp)
8113f8ac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113f8b0:	008010c4 	movi	r2,67
8113f8b4:	00009506 	br	8113fb0c <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113f8b8:	e0bff817 	ldw	r2,-32(fp)
8113f8bc:	10800058 	cmpnei	r2,r2,1
8113f8c0:	1000061e 	bne	r2,zero,8113f8dc <OSTaskDel+0x108>
8113f8c4:	e0bff617 	ldw	r2,-40(fp)
8113f8c8:	e0bff915 	stw	r2,-28(fp)
8113f8cc:	e0bff917 	ldw	r2,-28(fp)
8113f8d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113f8d4:	00800f44 	movi	r2,61
8113f8d8:	00008c06 	br	8113fb0c <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113f8dc:	e0bff817 	ldw	r2,-32(fp)
8113f8e0:	10800d03 	ldbu	r2,52(r2)
8113f8e4:	10c03fcc 	andi	r3,r2,255
8113f8e8:	e0bff817 	ldw	r2,-32(fp)
8113f8ec:	10800d03 	ldbu	r2,52(r2)
8113f8f0:	11003fcc 	andi	r4,r2,255
8113f8f4:	d0a09e44 	addi	r2,gp,-32135
8113f8f8:	2085883a 	add	r2,r4,r2
8113f8fc:	10800003 	ldbu	r2,0(r2)
8113f900:	1009883a 	mov	r4,r2
8113f904:	e0bff817 	ldw	r2,-32(fp)
8113f908:	10800d43 	ldbu	r2,53(r2)
8113f90c:	0084303a 	nor	r2,zero,r2
8113f910:	2084703a 	and	r2,r4,r2
8113f914:	1009883a 	mov	r4,r2
8113f918:	d0a09e44 	addi	r2,gp,-32135
8113f91c:	1885883a 	add	r2,r3,r2
8113f920:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113f924:	e0bff817 	ldw	r2,-32(fp)
8113f928:	10800d03 	ldbu	r2,52(r2)
8113f92c:	10c03fcc 	andi	r3,r2,255
8113f930:	d0a09e44 	addi	r2,gp,-32135
8113f934:	1885883a 	add	r2,r3,r2
8113f938:	10800003 	ldbu	r2,0(r2)
8113f93c:	10803fcc 	andi	r2,r2,255
8113f940:	1000071e 	bne	r2,zero,8113f960 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113f944:	e0bff817 	ldw	r2,-32(fp)
8113f948:	10800d83 	ldbu	r2,54(r2)
8113f94c:	0084303a 	nor	r2,zero,r2
8113f950:	1007883a 	mov	r3,r2
8113f954:	d0a09e03 	ldbu	r2,-32136(gp)
8113f958:	1884703a 	and	r2,r3,r2
8113f95c:	d0a09e05 	stb	r2,-32136(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113f960:	e0bff817 	ldw	r2,-32(fp)
8113f964:	10800717 	ldw	r2,28(r2)
8113f968:	10000526 	beq	r2,zero,8113f980 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113f96c:	e0bff817 	ldw	r2,-32(fp)
8113f970:	10800717 	ldw	r2,28(r2)
8113f974:	100b883a 	mov	r5,r2
8113f978:	e13ff817 	ldw	r4,-32(fp)
8113f97c:	11393200 	call	81139320 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113f980:	e0bff817 	ldw	r2,-32(fp)
8113f984:	10800817 	ldw	r2,32(r2)
8113f988:	10000526 	beq	r2,zero,8113f9a0 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113f98c:	e0bff817 	ldw	r2,-32(fp)
8113f990:	10800817 	ldw	r2,32(r2)
8113f994:	100b883a 	mov	r5,r2
8113f998:	e13ff817 	ldw	r4,-32(fp)
8113f99c:	11393e00 	call	811393e0 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113f9a0:	e0bff817 	ldw	r2,-32(fp)
8113f9a4:	10800a17 	ldw	r2,40(r2)
8113f9a8:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113f9ac:	e0bffb17 	ldw	r2,-20(fp)
8113f9b0:	10000226 	beq	r2,zero,8113f9bc <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113f9b4:	e13ffb17 	ldw	r4,-20(fp)
8113f9b8:	113b9b80 	call	8113b9b8 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113f9bc:	e0bff817 	ldw	r2,-32(fp)
8113f9c0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113f9c4:	e0bff817 	ldw	r2,-32(fp)
8113f9c8:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113f9cc:	e0bff817 	ldw	r2,-32(fp)
8113f9d0:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113f9d4:	d0a08f03 	ldbu	r2,-32196(gp)
8113f9d8:	10803fcc 	andi	r2,r2,255
8113f9dc:	10803fe0 	cmpeqi	r2,r2,255
8113f9e0:	1000031e 	bne	r2,zero,8113f9f0 <OSTaskDel+0x21c>
        OSLockNesting++;
8113f9e4:	d0a08f03 	ldbu	r2,-32196(gp)
8113f9e8:	10800044 	addi	r2,r2,1
8113f9ec:	d0a08f05 	stb	r2,-32196(gp)
8113f9f0:	e0bff617 	ldw	r2,-40(fp)
8113f9f4:	e0bffd15 	stw	r2,-12(fp)
8113f9f8:	e0bffd17 	ldw	r2,-12(fp)
8113f9fc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113fa00:	1138ee80 	call	81138ee8 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fa04:	0005303a 	rdctl	r2,status
8113fa08:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fa0c:	e0fffa17 	ldw	r3,-24(fp)
8113fa10:	00bfff84 	movi	r2,-2
8113fa14:	1884703a 	and	r2,r3,r2
8113fa18:	1001703a 	wrctl	status,r2
  
  return context;
8113fa1c:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113fa20:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113fa24:	d0a08f03 	ldbu	r2,-32196(gp)
8113fa28:	10803fcc 	andi	r2,r2,255
8113fa2c:	10000326 	beq	r2,zero,8113fa3c <OSTaskDel+0x268>
        OSLockNesting--;
8113fa30:	d0a08f03 	ldbu	r2,-32196(gp)
8113fa34:	10bfffc4 	addi	r2,r2,-1
8113fa38:	d0a08f05 	stb	r2,-32196(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113fa3c:	e13ff817 	ldw	r4,-32(fp)
8113fa40:	114ac6c0 	call	8114ac6c <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113fa44:	d0a09a43 	ldbu	r2,-32151(gp)
8113fa48:	10bfffc4 	addi	r2,r2,-1
8113fa4c:	d0a09a45 	stb	r2,-32151(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113fa50:	e0ffff03 	ldbu	r3,-4(fp)
8113fa54:	00a045f4 	movhi	r2,33047
8113fa58:	10b2f704 	addi	r2,r2,-13348
8113fa5c:	18c7883a 	add	r3,r3,r3
8113fa60:	18c7883a 	add	r3,r3,r3
8113fa64:	10c5883a 	add	r2,r2,r3
8113fa68:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113fa6c:	e0bff817 	ldw	r2,-32(fp)
8113fa70:	10800617 	ldw	r2,24(r2)
8113fa74:	1000071e 	bne	r2,zero,8113fa94 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113fa78:	e0bff817 	ldw	r2,-32(fp)
8113fa7c:	10800517 	ldw	r2,20(r2)
8113fa80:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113fa84:	e0bff817 	ldw	r2,-32(fp)
8113fa88:	10800517 	ldw	r2,20(r2)
8113fa8c:	d0a09415 	stw	r2,-32176(gp)
8113fa90:	00000a06 	br	8113fabc <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113fa94:	e0bff817 	ldw	r2,-32(fp)
8113fa98:	10800617 	ldw	r2,24(r2)
8113fa9c:	e0fff817 	ldw	r3,-32(fp)
8113faa0:	18c00517 	ldw	r3,20(r3)
8113faa4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113faa8:	e0bff817 	ldw	r2,-32(fp)
8113faac:	10800517 	ldw	r2,20(r2)
8113fab0:	e0fff817 	ldw	r3,-32(fp)
8113fab4:	18c00617 	ldw	r3,24(r3)
8113fab8:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113fabc:	d0e09917 	ldw	r3,-32156(gp)
8113fac0:	e0bff817 	ldw	r2,-32(fp)
8113fac4:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113fac8:	e0bff817 	ldw	r2,-32(fp)
8113facc:	d0a09915 	stw	r2,-32156(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113fad0:	e0bff817 	ldw	r2,-32(fp)
8113fad4:	00c00fc4 	movi	r3,63
8113fad8:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113fadc:	e0bff817 	ldw	r2,-32(fp)
8113fae0:	10001345 	stb	zero,77(r2)
8113fae4:	e0bff617 	ldw	r2,-40(fp)
8113fae8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113faec:	e0bffc17 	ldw	r2,-16(fp)
8113faf0:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113faf4:	d0a09103 	ldbu	r2,-32188(gp)
8113faf8:	10803fcc 	andi	r2,r2,255
8113fafc:	10800058 	cmpnei	r2,r2,1
8113fb00:	1000011e 	bne	r2,zero,8113fb08 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113fb04:	11399cc0 	call	811399cc <OS_Sched>
    }
    return (OS_ERR_NONE);
8113fb08:	0005883a 	mov	r2,zero
}
8113fb0c:	e037883a 	mov	sp,fp
8113fb10:	dfc00117 	ldw	ra,4(sp)
8113fb14:	df000017 	ldw	fp,0(sp)
8113fb18:	dec00204 	addi	sp,sp,8
8113fb1c:	f800283a 	ret

8113fb20 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113fb20:	defff504 	addi	sp,sp,-44
8113fb24:	de00012e 	bgeu	sp,et,8113fb2c <OSTaskDelReq+0xc>
8113fb28:	003b68fa 	trap	3
8113fb2c:	df000a15 	stw	fp,40(sp)
8113fb30:	df000a04 	addi	fp,sp,40
8113fb34:	2005883a 	mov	r2,r4
8113fb38:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113fb3c:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113fb40:	e0bfff03 	ldbu	r2,-4(fp)
8113fb44:	10800a98 	cmpnei	r2,r2,42
8113fb48:	1000021e 	bne	r2,zero,8113fb54 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113fb4c:	00800f84 	movi	r2,62
8113fb50:	00004506 	br	8113fc68 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113fb54:	e0bfff03 	ldbu	r2,-4(fp)
8113fb58:	10800ab0 	cmpltui	r2,r2,42
8113fb5c:	1000051e 	bne	r2,zero,8113fb74 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113fb60:	e0bfff03 	ldbu	r2,-4(fp)
8113fb64:	10803fe0 	cmpeqi	r2,r2,255
8113fb68:	1000021e 	bne	r2,zero,8113fb74 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113fb6c:	00800a84 	movi	r2,42
8113fb70:	00003d06 	br	8113fc68 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113fb74:	e0bfff03 	ldbu	r2,-4(fp)
8113fb78:	10803fd8 	cmpnei	r2,r2,255
8113fb7c:	1000111e 	bne	r2,zero,8113fbc4 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fb80:	0005303a 	rdctl	r2,status
8113fb84:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fb88:	e0fff917 	ldw	r3,-28(fp)
8113fb8c:	00bfff84 	movi	r2,-2
8113fb90:	1884703a 	and	r2,r3,r2
8113fb94:	1001703a 	wrctl	status,r2
  
  return context;
8113fb98:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113fb9c:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113fba0:	d0a0a217 	ldw	r2,-32120(gp)
8113fba4:	10800dc3 	ldbu	r2,55(r2)
8113fba8:	e0bff805 	stb	r2,-32(fp)
8113fbac:	e0bff617 	ldw	r2,-40(fp)
8113fbb0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fbb4:	e0bffe17 	ldw	r2,-8(fp)
8113fbb8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113fbbc:	e0bff803 	ldbu	r2,-32(fp)
8113fbc0:	00002906 	br	8113fc68 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fbc4:	0005303a 	rdctl	r2,status
8113fbc8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fbcc:	e0fff717 	ldw	r3,-36(fp)
8113fbd0:	00bfff84 	movi	r2,-2
8113fbd4:	1884703a 	and	r2,r3,r2
8113fbd8:	1001703a 	wrctl	status,r2
  
  return context;
8113fbdc:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113fbe0:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113fbe4:	e0ffff03 	ldbu	r3,-4(fp)
8113fbe8:	00a045f4 	movhi	r2,33047
8113fbec:	10b2f704 	addi	r2,r2,-13348
8113fbf0:	18c7883a 	add	r3,r3,r3
8113fbf4:	18c7883a 	add	r3,r3,r3
8113fbf8:	10c5883a 	add	r2,r2,r3
8113fbfc:	10800017 	ldw	r2,0(r2)
8113fc00:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113fc04:	e0bffb17 	ldw	r2,-20(fp)
8113fc08:	1000061e 	bne	r2,zero,8113fc24 <OSTaskDelReq+0x104>
8113fc0c:	e0bff617 	ldw	r2,-40(fp)
8113fc10:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fc14:	e0bffa17 	ldw	r2,-24(fp)
8113fc18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113fc1c:	008010c4 	movi	r2,67
8113fc20:	00001106 	br	8113fc68 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113fc24:	e0bffb17 	ldw	r2,-20(fp)
8113fc28:	10800058 	cmpnei	r2,r2,1
8113fc2c:	1000061e 	bne	r2,zero,8113fc48 <OSTaskDelReq+0x128>
8113fc30:	e0bff617 	ldw	r2,-40(fp)
8113fc34:	e0bffc15 	stw	r2,-16(fp)
8113fc38:	e0bffc17 	ldw	r2,-16(fp)
8113fc3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113fc40:	00800f44 	movi	r2,61
8113fc44:	00000806 	br	8113fc68 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113fc48:	e0bffb17 	ldw	r2,-20(fp)
8113fc4c:	00c00fc4 	movi	r3,63
8113fc50:	10c00dc5 	stb	r3,55(r2)
8113fc54:	e0bff617 	ldw	r2,-40(fp)
8113fc58:	e0bffd15 	stw	r2,-12(fp)
8113fc5c:	e0bffd17 	ldw	r2,-12(fp)
8113fc60:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113fc64:	0005883a 	mov	r2,zero
}
8113fc68:	e037883a 	mov	sp,fp
8113fc6c:	df000017 	ldw	fp,0(sp)
8113fc70:	dec00104 	addi	sp,sp,4
8113fc74:	f800283a 	ret

8113fc78 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113fc78:	defff404 	addi	sp,sp,-48
8113fc7c:	de00012e 	bgeu	sp,et,8113fc84 <OSTaskNameGet+0xc>
8113fc80:	003b68fa 	trap	3
8113fc84:	dfc00b15 	stw	ra,44(sp)
8113fc88:	df000a15 	stw	fp,40(sp)
8113fc8c:	df000a04 	addi	fp,sp,40
8113fc90:	2005883a 	mov	r2,r4
8113fc94:	e17ffe15 	stw	r5,-8(fp)
8113fc98:	e1bfff15 	stw	r6,-4(fp)
8113fc9c:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113fca0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113fca4:	e0bfff17 	ldw	r2,-4(fp)
8113fca8:	1000021e 	bne	r2,zero,8113fcb4 <OSTaskNameGet+0x3c>
        return (0);
8113fcac:	0005883a 	mov	r2,zero
8113fcb0:	00005406 	br	8113fe04 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113fcb4:	e0bffd03 	ldbu	r2,-12(fp)
8113fcb8:	10800af0 	cmpltui	r2,r2,43
8113fcbc:	1000081e 	bne	r2,zero,8113fce0 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113fcc0:	e0bffd03 	ldbu	r2,-12(fp)
8113fcc4:	10803fe0 	cmpeqi	r2,r2,255
8113fcc8:	1000051e 	bne	r2,zero,8113fce0 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113fccc:	e0bfff17 	ldw	r2,-4(fp)
8113fcd0:	00c00a84 	movi	r3,42
8113fcd4:	10c00005 	stb	r3,0(r2)
            return (0);
8113fcd8:	0005883a 	mov	r2,zero
8113fcdc:	00004906 	br	8113fe04 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113fce0:	e0bffe17 	ldw	r2,-8(fp)
8113fce4:	1000051e 	bne	r2,zero,8113fcfc <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113fce8:	e0bfff17 	ldw	r2,-4(fp)
8113fcec:	00c00304 	movi	r3,12
8113fcf0:	10c00005 	stb	r3,0(r2)
        return (0);
8113fcf4:	0005883a 	mov	r2,zero
8113fcf8:	00004206 	br	8113fe04 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113fcfc:	d0a0a103 	ldbu	r2,-32124(gp)
8113fd00:	10803fcc 	andi	r2,r2,255
8113fd04:	10000526 	beq	r2,zero,8113fd1c <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113fd08:	e0bfff17 	ldw	r2,-4(fp)
8113fd0c:	00c00444 	movi	r3,17
8113fd10:	10c00005 	stb	r3,0(r2)
        return (0);
8113fd14:	0005883a 	mov	r2,zero
8113fd18:	00003a06 	br	8113fe04 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fd1c:	0005303a 	rdctl	r2,status
8113fd20:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fd24:	e0fffc17 	ldw	r3,-16(fp)
8113fd28:	00bfff84 	movi	r2,-2
8113fd2c:	1884703a 	and	r2,r3,r2
8113fd30:	1001703a 	wrctl	status,r2
  
  return context;
8113fd34:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fd38:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113fd3c:	e0bffd03 	ldbu	r2,-12(fp)
8113fd40:	10803fd8 	cmpnei	r2,r2,255
8113fd44:	1000031e 	bne	r2,zero,8113fd54 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113fd48:	d0a0a217 	ldw	r2,-32120(gp)
8113fd4c:	10800c83 	ldbu	r2,50(r2)
8113fd50:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113fd54:	e0fffd03 	ldbu	r3,-12(fp)
8113fd58:	00a045f4 	movhi	r2,33047
8113fd5c:	10b2f704 	addi	r2,r2,-13348
8113fd60:	18c7883a 	add	r3,r3,r3
8113fd64:	18c7883a 	add	r3,r3,r3
8113fd68:	10c5883a 	add	r2,r2,r3
8113fd6c:	10800017 	ldw	r2,0(r2)
8113fd70:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113fd74:	e0bff817 	ldw	r2,-32(fp)
8113fd78:	1000091e 	bne	r2,zero,8113fda0 <OSTaskNameGet+0x128>
8113fd7c:	e0bff617 	ldw	r2,-40(fp)
8113fd80:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fd84:	e0bff717 	ldw	r2,-36(fp)
8113fd88:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113fd8c:	e0bfff17 	ldw	r2,-4(fp)
8113fd90:	00c010c4 	movi	r3,67
8113fd94:	10c00005 	stb	r3,0(r2)
        return (0);
8113fd98:	0005883a 	mov	r2,zero
8113fd9c:	00001906 	br	8113fe04 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113fda0:	e0bff817 	ldw	r2,-32(fp)
8113fda4:	10800058 	cmpnei	r2,r2,1
8113fda8:	1000091e 	bne	r2,zero,8113fdd0 <OSTaskNameGet+0x158>
8113fdac:	e0bff617 	ldw	r2,-40(fp)
8113fdb0:	e0bff915 	stw	r2,-28(fp)
8113fdb4:	e0bff917 	ldw	r2,-28(fp)
8113fdb8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113fdbc:	e0bfff17 	ldw	r2,-4(fp)
8113fdc0:	00c010c4 	movi	r3,67
8113fdc4:	10c00005 	stb	r3,0(r2)
        return (0);
8113fdc8:	0005883a 	mov	r2,zero
8113fdcc:	00000d06 	br	8113fe04 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113fdd0:	e0bff817 	ldw	r2,-32(fp)
8113fdd4:	10801304 	addi	r2,r2,76
8113fdd8:	100b883a 	mov	r5,r2
8113fddc:	e13ffe17 	ldw	r4,-8(fp)
8113fde0:	1139b200 	call	81139b20 <OS_StrCopy>
8113fde4:	e0bffb05 	stb	r2,-20(fp)
8113fde8:	e0bff617 	ldw	r2,-40(fp)
8113fdec:	e0bffa15 	stw	r2,-24(fp)
8113fdf0:	e0bffa17 	ldw	r2,-24(fp)
8113fdf4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113fdf8:	e0bfff17 	ldw	r2,-4(fp)
8113fdfc:	10000005 	stb	zero,0(r2)
    return (len);
8113fe00:	e0bffb03 	ldbu	r2,-20(fp)
}
8113fe04:	e037883a 	mov	sp,fp
8113fe08:	dfc00117 	ldw	ra,4(sp)
8113fe0c:	df000017 	ldw	fp,0(sp)
8113fe10:	dec00204 	addi	sp,sp,8
8113fe14:	f800283a 	ret

8113fe18 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113fe18:	defff304 	addi	sp,sp,-52
8113fe1c:	de00012e 	bgeu	sp,et,8113fe24 <OSTaskNameSet+0xc>
8113fe20:	003b68fa 	trap	3
8113fe24:	dfc00c15 	stw	ra,48(sp)
8113fe28:	df000b15 	stw	fp,44(sp)
8113fe2c:	df000b04 	addi	fp,sp,44
8113fe30:	2005883a 	mov	r2,r4
8113fe34:	e17ffe15 	stw	r5,-8(fp)
8113fe38:	e1bfff15 	stw	r6,-4(fp)
8113fe3c:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113fe40:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113fe44:	e0bfff17 	ldw	r2,-4(fp)
8113fe48:	10005c26 	beq	r2,zero,8113ffbc <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113fe4c:	e0bffd03 	ldbu	r2,-12(fp)
8113fe50:	10800af0 	cmpltui	r2,r2,43
8113fe54:	1000071e 	bne	r2,zero,8113fe74 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113fe58:	e0bffd03 	ldbu	r2,-12(fp)
8113fe5c:	10803fe0 	cmpeqi	r2,r2,255
8113fe60:	1000041e 	bne	r2,zero,8113fe74 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113fe64:	e0bfff17 	ldw	r2,-4(fp)
8113fe68:	00c00a84 	movi	r3,42
8113fe6c:	10c00005 	stb	r3,0(r2)
            return;
8113fe70:	00005306 	br	8113ffc0 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113fe74:	e0bffe17 	ldw	r2,-8(fp)
8113fe78:	1000041e 	bne	r2,zero,8113fe8c <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113fe7c:	e0bfff17 	ldw	r2,-4(fp)
8113fe80:	00c00304 	movi	r3,12
8113fe84:	10c00005 	stb	r3,0(r2)
        return;
8113fe88:	00004d06 	br	8113ffc0 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113fe8c:	d0a0a103 	ldbu	r2,-32124(gp)
8113fe90:	10803fcc 	andi	r2,r2,255
8113fe94:	10000426 	beq	r2,zero,8113fea8 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113fe98:	e0bfff17 	ldw	r2,-4(fp)
8113fe9c:	00c00484 	movi	r3,18
8113fea0:	10c00005 	stb	r3,0(r2)
        return;
8113fea4:	00004606 	br	8113ffc0 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fea8:	0005303a 	rdctl	r2,status
8113feac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113feb0:	e0fffc17 	ldw	r3,-16(fp)
8113feb4:	00bfff84 	movi	r2,-2
8113feb8:	1884703a 	and	r2,r3,r2
8113febc:	1001703a 	wrctl	status,r2
  
  return context;
8113fec0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113fec4:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113fec8:	e0bffd03 	ldbu	r2,-12(fp)
8113fecc:	10803fd8 	cmpnei	r2,r2,255
8113fed0:	1000031e 	bne	r2,zero,8113fee0 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113fed4:	d0a0a217 	ldw	r2,-32120(gp)
8113fed8:	10800c83 	ldbu	r2,50(r2)
8113fedc:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113fee0:	e0fffd03 	ldbu	r3,-12(fp)
8113fee4:	00a045f4 	movhi	r2,33047
8113fee8:	10b2f704 	addi	r2,r2,-13348
8113feec:	18c7883a 	add	r3,r3,r3
8113fef0:	18c7883a 	add	r3,r3,r3
8113fef4:	10c5883a 	add	r2,r2,r3
8113fef8:	10800017 	ldw	r2,0(r2)
8113fefc:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113ff00:	e0bff717 	ldw	r2,-36(fp)
8113ff04:	1000081e 	bne	r2,zero,8113ff28 <OSTaskNameSet+0x110>
8113ff08:	e0bff517 	ldw	r2,-44(fp)
8113ff0c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ff10:	e0bff617 	ldw	r2,-40(fp)
8113ff14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113ff18:	e0bfff17 	ldw	r2,-4(fp)
8113ff1c:	00c010c4 	movi	r3,67
8113ff20:	10c00005 	stb	r3,0(r2)
        return;
8113ff24:	00002606 	br	8113ffc0 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113ff28:	e0bff717 	ldw	r2,-36(fp)
8113ff2c:	10800058 	cmpnei	r2,r2,1
8113ff30:	1000081e 	bne	r2,zero,8113ff54 <OSTaskNameSet+0x13c>
8113ff34:	e0bff517 	ldw	r2,-44(fp)
8113ff38:	e0bff815 	stw	r2,-32(fp)
8113ff3c:	e0bff817 	ldw	r2,-32(fp)
8113ff40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113ff44:	e0bfff17 	ldw	r2,-4(fp)
8113ff48:	00c010c4 	movi	r3,67
8113ff4c:	10c00005 	stb	r3,0(r2)
        return;
8113ff50:	00001b06 	br	8113ffc0 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113ff54:	e13ffe17 	ldw	r4,-8(fp)
8113ff58:	1139b9c0 	call	81139b9c <OS_StrLen>
8113ff5c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113ff60:	e0bffa03 	ldbu	r2,-24(fp)
8113ff64:	10800830 	cmpltui	r2,r2,32
8113ff68:	1000081e 	bne	r2,zero,8113ff8c <OSTaskNameSet+0x174>
8113ff6c:	e0bff517 	ldw	r2,-44(fp)
8113ff70:	e0bff915 	stw	r2,-28(fp)
8113ff74:	e0bff917 	ldw	r2,-28(fp)
8113ff78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113ff7c:	e0bfff17 	ldw	r2,-4(fp)
8113ff80:	00c01044 	movi	r3,65
8113ff84:	10c00005 	stb	r3,0(r2)
        return;
8113ff88:	00000d06 	br	8113ffc0 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113ff8c:	e0bff717 	ldw	r2,-36(fp)
8113ff90:	10801304 	addi	r2,r2,76
8113ff94:	e17ffe17 	ldw	r5,-8(fp)
8113ff98:	1009883a 	mov	r4,r2
8113ff9c:	1139b200 	call	81139b20 <OS_StrCopy>
8113ffa0:	e0bff517 	ldw	r2,-44(fp)
8113ffa4:	e0bffb15 	stw	r2,-20(fp)
8113ffa8:	e0bffb17 	ldw	r2,-20(fp)
8113ffac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ffb0:	e0bfff17 	ldw	r2,-4(fp)
8113ffb4:	10000005 	stb	zero,0(r2)
8113ffb8:	00000106 	br	8113ffc0 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113ffbc:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113ffc0:	e037883a 	mov	sp,fp
8113ffc4:	dfc00117 	ldw	ra,4(sp)
8113ffc8:	df000017 	ldw	fp,0(sp)
8113ffcc:	dec00204 	addi	sp,sp,8
8113ffd0:	f800283a 	ret

8113ffd4 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113ffd4:	defff404 	addi	sp,sp,-48
8113ffd8:	de00012e 	bgeu	sp,et,8113ffe0 <OSTaskResume+0xc>
8113ffdc:	003b68fa 	trap	3
8113ffe0:	dfc00b15 	stw	ra,44(sp)
8113ffe4:	df000a15 	stw	fp,40(sp)
8113ffe8:	df000a04 	addi	fp,sp,40
8113ffec:	2005883a 	mov	r2,r4
8113fff0:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113fff4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113fff8:	e0bfff03 	ldbu	r2,-4(fp)
8113fffc:	10800ab0 	cmpltui	r2,r2,42
81140000:	1000021e 	bne	r2,zero,8114000c <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81140004:	00800a84 	movi	r2,42
81140008:	00006406 	br	8114019c <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114000c:	0005303a 	rdctl	r2,status
81140010:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140014:	e0fffe17 	ldw	r3,-8(fp)
81140018:	00bfff84 	movi	r2,-2
8114001c:	1884703a 	and	r2,r3,r2
81140020:	1001703a 	wrctl	status,r2
  
  return context;
81140024:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81140028:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8114002c:	e0ffff03 	ldbu	r3,-4(fp)
81140030:	00a045f4 	movhi	r2,33047
81140034:	10b2f704 	addi	r2,r2,-13348
81140038:	18c7883a 	add	r3,r3,r3
8114003c:	18c7883a 	add	r3,r3,r3
81140040:	10c5883a 	add	r2,r2,r3
81140044:	10800017 	ldw	r2,0(r2)
81140048:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8114004c:	e0bff817 	ldw	r2,-32(fp)
81140050:	1000061e 	bne	r2,zero,8114006c <OSTaskResume+0x98>
81140054:	e0bff617 	ldw	r2,-40(fp)
81140058:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114005c:	e0bff717 	ldw	r2,-36(fp)
81140060:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
81140064:	00801184 	movi	r2,70
81140068:	00004c06 	br	8114019c <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8114006c:	e0bff817 	ldw	r2,-32(fp)
81140070:	10800058 	cmpnei	r2,r2,1
81140074:	1000061e 	bne	r2,zero,81140090 <OSTaskResume+0xbc>
81140078:	e0bff617 	ldw	r2,-40(fp)
8114007c:	e0bff915 	stw	r2,-28(fp)
81140080:	e0bff917 	ldw	r2,-28(fp)
81140084:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140088:	008010c4 	movi	r2,67
8114008c:	00004306 	br	8114019c <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
81140090:	e0bff817 	ldw	r2,-32(fp)
81140094:	10800c03 	ldbu	r2,48(r2)
81140098:	10803fcc 	andi	r2,r2,255
8114009c:	1080020c 	andi	r2,r2,8
811400a0:	10003926 	beq	r2,zero,81140188 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
811400a4:	e0bff817 	ldw	r2,-32(fp)
811400a8:	10c00c03 	ldbu	r3,48(r2)
811400ac:	00bffdc4 	movi	r2,-9
811400b0:	1884703a 	and	r2,r3,r2
811400b4:	1007883a 	mov	r3,r2
811400b8:	e0bff817 	ldw	r2,-32(fp)
811400bc:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
811400c0:	e0bff817 	ldw	r2,-32(fp)
811400c4:	10800c03 	ldbu	r2,48(r2)
811400c8:	10803fcc 	andi	r2,r2,255
811400cc:	1000281e 	bne	r2,zero,81140170 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
811400d0:	e0bff817 	ldw	r2,-32(fp)
811400d4:	10800b8b 	ldhu	r2,46(r2)
811400d8:	10bfffcc 	andi	r2,r2,65535
811400dc:	10001f1e 	bne	r2,zero,8114015c <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
811400e0:	e0bff817 	ldw	r2,-32(fp)
811400e4:	10c00d83 	ldbu	r3,54(r2)
811400e8:	d0a09e03 	ldbu	r2,-32136(gp)
811400ec:	1884b03a 	or	r2,r3,r2
811400f0:	d0a09e05 	stb	r2,-32136(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811400f4:	e0bff817 	ldw	r2,-32(fp)
811400f8:	10800d03 	ldbu	r2,52(r2)
811400fc:	10c03fcc 	andi	r3,r2,255
81140100:	e0bff817 	ldw	r2,-32(fp)
81140104:	10800d03 	ldbu	r2,52(r2)
81140108:	11003fcc 	andi	r4,r2,255
8114010c:	d0a09e44 	addi	r2,gp,-32135
81140110:	2085883a 	add	r2,r4,r2
81140114:	11000003 	ldbu	r4,0(r2)
81140118:	e0bff817 	ldw	r2,-32(fp)
8114011c:	10800d43 	ldbu	r2,53(r2)
81140120:	2084b03a 	or	r2,r4,r2
81140124:	1009883a 	mov	r4,r2
81140128:	d0a09e44 	addi	r2,gp,-32135
8114012c:	1885883a 	add	r2,r3,r2
81140130:	11000005 	stb	r4,0(r2)
81140134:	e0bff617 	ldw	r2,-40(fp)
81140138:	e0bffa15 	stw	r2,-24(fp)
8114013c:	e0bffa17 	ldw	r2,-24(fp)
81140140:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
81140144:	d0a09103 	ldbu	r2,-32188(gp)
81140148:	10803fcc 	andi	r2,r2,255
8114014c:	10800058 	cmpnei	r2,r2,1
81140150:	10000b1e 	bne	r2,zero,81140180 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
81140154:	11399cc0 	call	811399cc <OS_Sched>
81140158:	00000906 	br	81140180 <OSTaskResume+0x1ac>
8114015c:	e0bff617 	ldw	r2,-40(fp)
81140160:	e0bffb15 	stw	r2,-20(fp)
81140164:	e0bffb17 	ldw	r2,-20(fp)
81140168:	1001703a 	wrctl	status,r2
8114016c:	00000406 	br	81140180 <OSTaskResume+0x1ac>
81140170:	e0bff617 	ldw	r2,-40(fp)
81140174:	e0bffc15 	stw	r2,-16(fp)
81140178:	e0bffc17 	ldw	r2,-16(fp)
8114017c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
81140180:	0005883a 	mov	r2,zero
81140184:	00000506 	br	8114019c <OSTaskResume+0x1c8>
81140188:	e0bff617 	ldw	r2,-40(fp)
8114018c:	e0bffd15 	stw	r2,-12(fp)
81140190:	e0bffd17 	ldw	r2,-12(fp)
81140194:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81140198:	00801104 	movi	r2,68
}
8114019c:	e037883a 	mov	sp,fp
811401a0:	dfc00117 	ldw	ra,4(sp)
811401a4:	df000017 	ldw	fp,0(sp)
811401a8:	dec00204 	addi	sp,sp,8
811401ac:	f800283a 	ret

811401b0 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
811401b0:	defff304 	addi	sp,sp,-52
811401b4:	de00012e 	bgeu	sp,et,811401bc <OSTaskStkChk+0xc>
811401b8:	003b68fa 	trap	3
811401bc:	df000c15 	stw	fp,48(sp)
811401c0:	df000c04 	addi	fp,sp,48
811401c4:	2005883a 	mov	r2,r4
811401c8:	e17fff15 	stw	r5,-4(fp)
811401cc:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811401d0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
811401d4:	e0bffe03 	ldbu	r2,-8(fp)
811401d8:	10800af0 	cmpltui	r2,r2,43
811401dc:	1000051e 	bne	r2,zero,811401f4 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
811401e0:	e0bffe03 	ldbu	r2,-8(fp)
811401e4:	10803fe0 	cmpeqi	r2,r2,255
811401e8:	1000021e 	bne	r2,zero,811401f4 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
811401ec:	00800a84 	movi	r2,42
811401f0:	00005d06 	br	81140368 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
811401f4:	e0bfff17 	ldw	r2,-4(fp)
811401f8:	1000021e 	bne	r2,zero,81140204 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
811401fc:	00800244 	movi	r2,9
81140200:	00005906 	br	81140368 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
81140204:	e0bfff17 	ldw	r2,-4(fp)
81140208:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8114020c:	e0bfff17 	ldw	r2,-4(fp)
81140210:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140214:	0005303a 	rdctl	r2,status
81140218:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114021c:	e0fffd17 	ldw	r3,-12(fp)
81140220:	00bfff84 	movi	r2,-2
81140224:	1884703a 	and	r2,r3,r2
81140228:	1001703a 	wrctl	status,r2
  
  return context;
8114022c:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
81140230:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
81140234:	e0bffe03 	ldbu	r2,-8(fp)
81140238:	10803fd8 	cmpnei	r2,r2,255
8114023c:	1000031e 	bne	r2,zero,8114024c <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
81140240:	d0a0a217 	ldw	r2,-32120(gp)
81140244:	10800c83 	ldbu	r2,50(r2)
81140248:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8114024c:	e0fffe03 	ldbu	r3,-8(fp)
81140250:	00a045f4 	movhi	r2,33047
81140254:	10b2f704 	addi	r2,r2,-13348
81140258:	18c7883a 	add	r3,r3,r3
8114025c:	18c7883a 	add	r3,r3,r3
81140260:	10c5883a 	add	r2,r2,r3
81140264:	10800017 	ldw	r2,0(r2)
81140268:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8114026c:	e0bff817 	ldw	r2,-32(fp)
81140270:	1000061e 	bne	r2,zero,8114028c <OSTaskStkChk+0xdc>
81140274:	e0bff617 	ldw	r2,-40(fp)
81140278:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114027c:	e0bff717 	ldw	r2,-36(fp)
81140280:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140284:	008010c4 	movi	r2,67
81140288:	00003706 	br	81140368 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8114028c:	e0bff817 	ldw	r2,-32(fp)
81140290:	10800058 	cmpnei	r2,r2,1
81140294:	1000061e 	bne	r2,zero,811402b0 <OSTaskStkChk+0x100>
81140298:	e0bff617 	ldw	r2,-40(fp)
8114029c:	e0bff915 	stw	r2,-28(fp)
811402a0:	e0bff917 	ldw	r2,-28(fp)
811402a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811402a8:	008010c4 	movi	r2,67
811402ac:	00002e06 	br	81140368 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
811402b0:	e0bff817 	ldw	r2,-32(fp)
811402b4:	1080040b 	ldhu	r2,16(r2)
811402b8:	10bfffcc 	andi	r2,r2,65535
811402bc:	1080004c 	andi	r2,r2,1
811402c0:	1000061e 	bne	r2,zero,811402dc <OSTaskStkChk+0x12c>
811402c4:	e0bff617 	ldw	r2,-40(fp)
811402c8:	e0bffa15 	stw	r2,-24(fp)
811402cc:	e0bffa17 	ldw	r2,-24(fp)
811402d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
811402d4:	00801144 	movi	r2,69
811402d8:	00002306 	br	81140368 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
811402dc:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
811402e0:	e0bff817 	ldw	r2,-32(fp)
811402e4:	10800317 	ldw	r2,12(r2)
811402e8:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
811402ec:	e0bff817 	ldw	r2,-32(fp)
811402f0:	10800217 	ldw	r2,8(r2)
811402f4:	e0bff415 	stw	r2,-48(fp)
811402f8:	e0bff617 	ldw	r2,-40(fp)
811402fc:	e0bffb15 	stw	r2,-20(fp)
81140300:	e0bffb17 	ldw	r2,-20(fp)
81140304:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81140308:	00000306 	br	81140318 <OSTaskStkChk+0x168>
        nfree++;
8114030c:	e0bff517 	ldw	r2,-44(fp)
81140310:	10800044 	addi	r2,r2,1
81140314:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81140318:	e0bff417 	ldw	r2,-48(fp)
8114031c:	10c00104 	addi	r3,r2,4
81140320:	e0fff415 	stw	r3,-48(fp)
81140324:	10800017 	ldw	r2,0(r2)
81140328:	103ff826 	beq	r2,zero,8114030c <__reset+0xfb12030c>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8114032c:	e0bff517 	ldw	r2,-44(fp)
81140330:	1085883a 	add	r2,r2,r2
81140334:	1085883a 	add	r2,r2,r2
81140338:	1007883a 	mov	r3,r2
8114033c:	e0bfff17 	ldw	r2,-4(fp)
81140340:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
81140344:	e0fffc17 	ldw	r3,-16(fp)
81140348:	e0bff517 	ldw	r2,-44(fp)
8114034c:	1885c83a 	sub	r2,r3,r2
81140350:	1085883a 	add	r2,r2,r2
81140354:	1085883a 	add	r2,r2,r2
81140358:	1007883a 	mov	r3,r2
8114035c:	e0bfff17 	ldw	r2,-4(fp)
81140360:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
81140364:	0005883a 	mov	r2,zero
}
81140368:	e037883a 	mov	sp,fp
8114036c:	df000017 	ldw	fp,0(sp)
81140370:	dec00104 	addi	sp,sp,4
81140374:	f800283a 	ret

81140378 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
81140378:	defff504 	addi	sp,sp,-44
8114037c:	de00012e 	bgeu	sp,et,81140384 <OSTaskSuspend+0xc>
81140380:	003b68fa 	trap	3
81140384:	dfc00a15 	stw	ra,40(sp)
81140388:	df000915 	stw	fp,36(sp)
8114038c:	df000904 	addi	fp,sp,36
81140390:	2005883a 	mov	r2,r4
81140394:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140398:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8114039c:	e0bfff03 	ldbu	r2,-4(fp)
811403a0:	10800a98 	cmpnei	r2,r2,42
811403a4:	1000021e 	bne	r2,zero,811403b0 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
811403a8:	008011c4 	movi	r2,71
811403ac:	00006806 	br	81140550 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
811403b0:	e0bfff03 	ldbu	r2,-4(fp)
811403b4:	10800ab0 	cmpltui	r2,r2,42
811403b8:	1000051e 	bne	r2,zero,811403d0 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
811403bc:	e0bfff03 	ldbu	r2,-4(fp)
811403c0:	10803fe0 	cmpeqi	r2,r2,255
811403c4:	1000021e 	bne	r2,zero,811403d0 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
811403c8:	00800a84 	movi	r2,42
811403cc:	00006006 	br	81140550 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811403d0:	0005303a 	rdctl	r2,status
811403d4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811403d8:	e0fffe17 	ldw	r3,-8(fp)
811403dc:	00bfff84 	movi	r2,-2
811403e0:	1884703a 	and	r2,r3,r2
811403e4:	1001703a 	wrctl	status,r2
  
  return context;
811403e8:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
811403ec:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
811403f0:	e0bfff03 	ldbu	r2,-4(fp)
811403f4:	10803fd8 	cmpnei	r2,r2,255
811403f8:	1000061e 	bne	r2,zero,81140414 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811403fc:	d0a0a217 	ldw	r2,-32120(gp)
81140400:	10800c83 	ldbu	r2,50(r2)
81140404:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
81140408:	00800044 	movi	r2,1
8114040c:	e0bff705 	stb	r2,-36(fp)
81140410:	00000906 	br	81140438 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
81140414:	d0a0a217 	ldw	r2,-32120(gp)
81140418:	10800c83 	ldbu	r2,50(r2)
8114041c:	10c03fcc 	andi	r3,r2,255
81140420:	e0bfff03 	ldbu	r2,-4(fp)
81140424:	1880031e 	bne	r3,r2,81140434 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
81140428:	00800044 	movi	r2,1
8114042c:	e0bff705 	stb	r2,-36(fp)
81140430:	00000106 	br	81140438 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
81140434:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81140438:	e0ffff03 	ldbu	r3,-4(fp)
8114043c:	00a045f4 	movhi	r2,33047
81140440:	10b2f704 	addi	r2,r2,-13348
81140444:	18c7883a 	add	r3,r3,r3
81140448:	18c7883a 	add	r3,r3,r3
8114044c:	10c5883a 	add	r2,r2,r3
81140450:	10800017 	ldw	r2,0(r2)
81140454:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
81140458:	e0bffa17 	ldw	r2,-24(fp)
8114045c:	1000061e 	bne	r2,zero,81140478 <OSTaskSuspend+0x100>
81140460:	e0bff817 	ldw	r2,-32(fp)
81140464:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140468:	e0bff917 	ldw	r2,-28(fp)
8114046c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
81140470:	00801204 	movi	r2,72
81140474:	00003606 	br	81140550 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
81140478:	e0bffa17 	ldw	r2,-24(fp)
8114047c:	10800058 	cmpnei	r2,r2,1
81140480:	1000061e 	bne	r2,zero,8114049c <OSTaskSuspend+0x124>
81140484:	e0bff817 	ldw	r2,-32(fp)
81140488:	e0bffb15 	stw	r2,-20(fp)
8114048c:	e0bffb17 	ldw	r2,-20(fp)
81140490:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140494:	008010c4 	movi	r2,67
81140498:	00002d06 	br	81140550 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8114049c:	e0bffa17 	ldw	r2,-24(fp)
811404a0:	10800d03 	ldbu	r2,52(r2)
811404a4:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
811404a8:	e0fffd03 	ldbu	r3,-12(fp)
811404ac:	e13ffd03 	ldbu	r4,-12(fp)
811404b0:	d0a09e44 	addi	r2,gp,-32135
811404b4:	2085883a 	add	r2,r4,r2
811404b8:	10800003 	ldbu	r2,0(r2)
811404bc:	1009883a 	mov	r4,r2
811404c0:	e0bffa17 	ldw	r2,-24(fp)
811404c4:	10800d43 	ldbu	r2,53(r2)
811404c8:	0084303a 	nor	r2,zero,r2
811404cc:	2084703a 	and	r2,r4,r2
811404d0:	1009883a 	mov	r4,r2
811404d4:	d0a09e44 	addi	r2,gp,-32135
811404d8:	1885883a 	add	r2,r3,r2
811404dc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811404e0:	e0fffd03 	ldbu	r3,-12(fp)
811404e4:	d0a09e44 	addi	r2,gp,-32135
811404e8:	1885883a 	add	r2,r3,r2
811404ec:	10800003 	ldbu	r2,0(r2)
811404f0:	10803fcc 	andi	r2,r2,255
811404f4:	1000071e 	bne	r2,zero,81140514 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
811404f8:	e0bffa17 	ldw	r2,-24(fp)
811404fc:	10800d83 	ldbu	r2,54(r2)
81140500:	0084303a 	nor	r2,zero,r2
81140504:	1007883a 	mov	r3,r2
81140508:	d0a09e03 	ldbu	r2,-32136(gp)
8114050c:	1884703a 	and	r2,r3,r2
81140510:	d0a09e05 	stb	r2,-32136(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
81140514:	e0bffa17 	ldw	r2,-24(fp)
81140518:	10800c03 	ldbu	r2,48(r2)
8114051c:	10800214 	ori	r2,r2,8
81140520:	1007883a 	mov	r3,r2
81140524:	e0bffa17 	ldw	r2,-24(fp)
81140528:	10c00c05 	stb	r3,48(r2)
8114052c:	e0bff817 	ldw	r2,-32(fp)
81140530:	e0bffc15 	stw	r2,-16(fp)
81140534:	e0bffc17 	ldw	r2,-16(fp)
81140538:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8114053c:	e0bff703 	ldbu	r2,-36(fp)
81140540:	10800058 	cmpnei	r2,r2,1
81140544:	1000011e 	bne	r2,zero,8114054c <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
81140548:	11399cc0 	call	811399cc <OS_Sched>
    }
    return (OS_ERR_NONE);
8114054c:	0005883a 	mov	r2,zero
}
81140550:	e037883a 	mov	sp,fp
81140554:	dfc00117 	ldw	ra,4(sp)
81140558:	df000017 	ldw	fp,0(sp)
8114055c:	dec00204 	addi	sp,sp,8
81140560:	f800283a 	ret

81140564 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
81140564:	defff604 	addi	sp,sp,-40
81140568:	de00012e 	bgeu	sp,et,81140570 <OSTaskQuery+0xc>
8114056c:	003b68fa 	trap	3
81140570:	dfc00915 	stw	ra,36(sp)
81140574:	df000815 	stw	fp,32(sp)
81140578:	df000804 	addi	fp,sp,32
8114057c:	2005883a 	mov	r2,r4
81140580:	e17fff15 	stw	r5,-4(fp)
81140584:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140588:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8114058c:	e0bffe03 	ldbu	r2,-8(fp)
81140590:	10800af0 	cmpltui	r2,r2,43
81140594:	1000051e 	bne	r2,zero,811405ac <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81140598:	e0bffe03 	ldbu	r2,-8(fp)
8114059c:	10803fe0 	cmpeqi	r2,r2,255
811405a0:	1000021e 	bne	r2,zero,811405ac <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
811405a4:	00800a84 	movi	r2,42
811405a8:	00003406 	br	8114067c <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
811405ac:	e0bfff17 	ldw	r2,-4(fp)
811405b0:	1000021e 	bne	r2,zero,811405bc <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
811405b4:	00800244 	movi	r2,9
811405b8:	00003006 	br	8114067c <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811405bc:	0005303a 	rdctl	r2,status
811405c0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811405c4:	e0fffd17 	ldw	r3,-12(fp)
811405c8:	00bfff84 	movi	r2,-2
811405cc:	1884703a 	and	r2,r3,r2
811405d0:	1001703a 	wrctl	status,r2
  
  return context;
811405d4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811405d8:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
811405dc:	e0bffe03 	ldbu	r2,-8(fp)
811405e0:	10803fd8 	cmpnei	r2,r2,255
811405e4:	1000031e 	bne	r2,zero,811405f4 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
811405e8:	d0a0a217 	ldw	r2,-32120(gp)
811405ec:	10800c83 	ldbu	r2,50(r2)
811405f0:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811405f4:	e0fffe03 	ldbu	r3,-8(fp)
811405f8:	00a045f4 	movhi	r2,33047
811405fc:	10b2f704 	addi	r2,r2,-13348
81140600:	18c7883a 	add	r3,r3,r3
81140604:	18c7883a 	add	r3,r3,r3
81140608:	10c5883a 	add	r2,r2,r3
8114060c:	10800017 	ldw	r2,0(r2)
81140610:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
81140614:	e0bffa17 	ldw	r2,-24(fp)
81140618:	1000061e 	bne	r2,zero,81140634 <OSTaskQuery+0xd0>
8114061c:	e0bff817 	ldw	r2,-32(fp)
81140620:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140624:	e0bff917 	ldw	r2,-28(fp)
81140628:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8114062c:	00800a44 	movi	r2,41
81140630:	00001206 	br	8114067c <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
81140634:	e0bffa17 	ldw	r2,-24(fp)
81140638:	10800058 	cmpnei	r2,r2,1
8114063c:	1000061e 	bne	r2,zero,81140658 <OSTaskQuery+0xf4>
81140640:	e0bff817 	ldw	r2,-32(fp)
81140644:	e0bffb15 	stw	r2,-20(fp)
81140648:	e0bffb17 	ldw	r2,-20(fp)
8114064c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81140650:	008010c4 	movi	r2,67
81140654:	00000906 	br	8114067c <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
81140658:	01801b04 	movi	r6,108
8114065c:	e17ffa17 	ldw	r5,-24(fp)
81140660:	e13fff17 	ldw	r4,-4(fp)
81140664:	113995c0 	call	8113995c <OS_MemCopy>
81140668:	e0bff817 	ldw	r2,-32(fp)
8114066c:	e0bffc15 	stw	r2,-16(fp)
81140670:	e0bffc17 	ldw	r2,-16(fp)
81140674:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81140678:	0005883a 	mov	r2,zero
}
8114067c:	e037883a 	mov	sp,fp
81140680:	dfc00117 	ldw	ra,4(sp)
81140684:	df000017 	ldw	fp,0(sp)
81140688:	dec00204 	addi	sp,sp,8
8114068c:	f800283a 	ret

81140690 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
81140690:	defffc04 	addi	sp,sp,-16
81140694:	de00012e 	bgeu	sp,et,8114069c <OS_TaskStkClr+0xc>
81140698:	003b68fa 	trap	3
8114069c:	df000315 	stw	fp,12(sp)
811406a0:	df000304 	addi	fp,sp,12
811406a4:	e13ffd15 	stw	r4,-12(fp)
811406a8:	e17ffe15 	stw	r5,-8(fp)
811406ac:	3005883a 	mov	r2,r6
811406b0:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
811406b4:	e0bfff0b 	ldhu	r2,-4(fp)
811406b8:	1080004c 	andi	r2,r2,1
811406bc:	10000d26 	beq	r2,zero,811406f4 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
811406c0:	e0bfff0b 	ldhu	r2,-4(fp)
811406c4:	1080008c 	andi	r2,r2,2
811406c8:	10000a26 	beq	r2,zero,811406f4 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811406cc:	00000706 	br	811406ec <OS_TaskStkClr+0x5c>
                size--;
811406d0:	e0bffe17 	ldw	r2,-8(fp)
811406d4:	10bfffc4 	addi	r2,r2,-1
811406d8:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
811406dc:	e0bffd17 	ldw	r2,-12(fp)
811406e0:	10c00104 	addi	r3,r2,4
811406e4:	e0fffd15 	stw	r3,-12(fp)
811406e8:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811406ec:	e0bffe17 	ldw	r2,-8(fp)
811406f0:	103ff71e 	bne	r2,zero,811406d0 <__reset+0xfb1206d0>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
811406f4:	0001883a 	nop
811406f8:	e037883a 	mov	sp,fp
811406fc:	df000017 	ldw	fp,0(sp)
81140700:	dec00104 	addi	sp,sp,4
81140704:	f800283a 	ret

81140708 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
81140708:	defff904 	addi	sp,sp,-28
8114070c:	de00012e 	bgeu	sp,et,81140714 <OSTimeDly+0xc>
81140710:	003b68fa 	trap	3
81140714:	dfc00615 	stw	ra,24(sp)
81140718:	df000515 	stw	fp,20(sp)
8114071c:	df000504 	addi	fp,sp,20
81140720:	2005883a 	mov	r2,r4
81140724:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140728:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8114072c:	d0a0a103 	ldbu	r2,-32124(gp)
81140730:	10803fcc 	andi	r2,r2,255
81140734:	1000311e 	bne	r2,zero,811407fc <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
81140738:	e0bfff0b 	ldhu	r2,-4(fp)
8114073c:	10003026 	beq	r2,zero,81140800 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140740:	0005303a 	rdctl	r2,status
81140744:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140748:	e0fffe17 	ldw	r3,-8(fp)
8114074c:	00bfff84 	movi	r2,-2
81140750:	1884703a 	and	r2,r3,r2
81140754:	1001703a 	wrctl	status,r2
  
  return context;
81140758:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8114075c:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
81140760:	d0a0a217 	ldw	r2,-32120(gp)
81140764:	10800d03 	ldbu	r2,52(r2)
81140768:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8114076c:	e0fffd03 	ldbu	r3,-12(fp)
81140770:	e13ffd03 	ldbu	r4,-12(fp)
81140774:	d0a09e44 	addi	r2,gp,-32135
81140778:	2085883a 	add	r2,r4,r2
8114077c:	10800003 	ldbu	r2,0(r2)
81140780:	1009883a 	mov	r4,r2
81140784:	d0a0a217 	ldw	r2,-32120(gp)
81140788:	10800d43 	ldbu	r2,53(r2)
8114078c:	0084303a 	nor	r2,zero,r2
81140790:	2084703a 	and	r2,r4,r2
81140794:	1009883a 	mov	r4,r2
81140798:	d0a09e44 	addi	r2,gp,-32135
8114079c:	1885883a 	add	r2,r3,r2
811407a0:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
811407a4:	e0fffd03 	ldbu	r3,-12(fp)
811407a8:	d0a09e44 	addi	r2,gp,-32135
811407ac:	1885883a 	add	r2,r3,r2
811407b0:	10800003 	ldbu	r2,0(r2)
811407b4:	10803fcc 	andi	r2,r2,255
811407b8:	1000071e 	bne	r2,zero,811407d8 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
811407bc:	d0a0a217 	ldw	r2,-32120(gp)
811407c0:	10800d83 	ldbu	r2,54(r2)
811407c4:	0084303a 	nor	r2,zero,r2
811407c8:	1007883a 	mov	r3,r2
811407cc:	d0a09e03 	ldbu	r2,-32136(gp)
811407d0:	1884703a 	and	r2,r3,r2
811407d4:	d0a09e05 	stb	r2,-32136(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
811407d8:	d0a0a217 	ldw	r2,-32120(gp)
811407dc:	e0ffff0b 	ldhu	r3,-4(fp)
811407e0:	10c00b8d 	sth	r3,46(r2)
811407e4:	e0bffb17 	ldw	r2,-20(fp)
811407e8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811407ec:	e0bffc17 	ldw	r2,-16(fp)
811407f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
811407f4:	11399cc0 	call	811399cc <OS_Sched>
811407f8:	00000106 	br	81140800 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
811407fc:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
81140800:	e037883a 	mov	sp,fp
81140804:	dfc00117 	ldw	ra,4(sp)
81140808:	df000017 	ldw	fp,0(sp)
8114080c:	dec00204 	addi	sp,sp,8
81140810:	f800283a 	ret

81140814 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81140814:	defff804 	addi	sp,sp,-32
81140818:	de00012e 	bgeu	sp,et,81140820 <OSTimeDlyHMSM+0xc>
8114081c:	003b68fa 	trap	3
81140820:	dfc00715 	stw	ra,28(sp)
81140824:	df000615 	stw	fp,24(sp)
81140828:	df000604 	addi	fp,sp,24
8114082c:	2015883a 	mov	r10,r4
81140830:	2809883a 	mov	r4,r5
81140834:	3007883a 	mov	r3,r6
81140838:	3805883a 	mov	r2,r7
8114083c:	e2bffc05 	stb	r10,-16(fp)
81140840:	e13ffd05 	stb	r4,-12(fp)
81140844:	e0fffe05 	stb	r3,-8(fp)
81140848:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8114084c:	d0a0a103 	ldbu	r2,-32124(gp)
81140850:	10803fcc 	andi	r2,r2,255
81140854:	10000226 	beq	r2,zero,81140860 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81140858:	00801544 	movi	r2,85
8114085c:	00004106 	br	81140964 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
81140860:	e0bffc03 	ldbu	r2,-16(fp)
81140864:	1000081e 	bne	r2,zero,81140888 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81140868:	e0bffd03 	ldbu	r2,-12(fp)
8114086c:	1000061e 	bne	r2,zero,81140888 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
81140870:	e0bffe03 	ldbu	r2,-8(fp)
81140874:	1000041e 	bne	r2,zero,81140888 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81140878:	e0bfff0b 	ldhu	r2,-4(fp)
8114087c:	1000021e 	bne	r2,zero,81140888 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
81140880:	00801504 	movi	r2,84
81140884:	00003706 	br	81140964 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81140888:	e0bffd03 	ldbu	r2,-12(fp)
8114088c:	10800f30 	cmpltui	r2,r2,60
81140890:	1000021e 	bne	r2,zero,8114089c <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81140894:	00801444 	movi	r2,81
81140898:	00003206 	br	81140964 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8114089c:	e0bffe03 	ldbu	r2,-8(fp)
811408a0:	10800f30 	cmpltui	r2,r2,60
811408a4:	1000021e 	bne	r2,zero,811408b0 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
811408a8:	00801484 	movi	r2,82
811408ac:	00002d06 	br	81140964 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
811408b0:	e0bfff0b 	ldhu	r2,-4(fp)
811408b4:	1080fa30 	cmpltui	r2,r2,1000
811408b8:	1000021e 	bne	r2,zero,811408c4 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
811408bc:	008014c4 	movi	r2,83
811408c0:	00002806 	br	81140964 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
811408c4:	e0bffc03 	ldbu	r2,-16(fp)
811408c8:	10c38424 	muli	r3,r2,3600
811408cc:	e0bffd03 	ldbu	r2,-12(fp)
811408d0:	10800f24 	muli	r2,r2,60
811408d4:	1887883a 	add	r3,r3,r2
811408d8:	e0bffe03 	ldbu	r2,-8(fp)
811408dc:	1885883a 	add	r2,r3,r2
811408e0:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
811408e4:	e0bfff0b 	ldhu	r2,-4(fp)
811408e8:	10c0fa24 	muli	r3,r2,1000
811408ec:	008418b4 	movhi	r2,4194
811408f0:	109374c4 	addi	r2,r2,19923
811408f4:	188a383a 	mulxuu	r5,r3,r2
811408f8:	1885383a 	mul	r2,r3,r2
811408fc:	1011883a 	mov	r8,r2
81140900:	2813883a 	mov	r9,r5
81140904:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81140908:	2085883a 	add	r2,r4,r2
8114090c:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
81140910:	e0bffb17 	ldw	r2,-20(fp)
81140914:	1004d43a 	srli	r2,r2,16
81140918:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8114091c:	e0bffb17 	ldw	r2,-20(fp)
81140920:	10bfffcc 	andi	r2,r2,65535
81140924:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81140928:	e0bffb17 	ldw	r2,-20(fp)
8114092c:	10bfffcc 	andi	r2,r2,65535
81140930:	1009883a 	mov	r4,r2
81140934:	11407080 	call	81140708 <OSTimeDly>
    while (loops > 0) {
81140938:	00000706 	br	81140958 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8114093c:	01200014 	movui	r4,32768
81140940:	11407080 	call	81140708 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81140944:	01200014 	movui	r4,32768
81140948:	11407080 	call	81140708 <OSTimeDly>
        loops--;
8114094c:	e0bffa0b 	ldhu	r2,-24(fp)
81140950:	10bfffc4 	addi	r2,r2,-1
81140954:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81140958:	e0bffa0b 	ldhu	r2,-24(fp)
8114095c:	103ff71e 	bne	r2,zero,8114093c <__reset+0xfb12093c>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
81140960:	0005883a 	mov	r2,zero
}
81140964:	e037883a 	mov	sp,fp
81140968:	dfc00117 	ldw	ra,4(sp)
8114096c:	df000017 	ldw	fp,0(sp)
81140970:	dec00204 	addi	sp,sp,8
81140974:	f800283a 	ret

81140978 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81140978:	defff504 	addi	sp,sp,-44
8114097c:	de00012e 	bgeu	sp,et,81140984 <OSTimeDlyResume+0xc>
81140980:	003b68fa 	trap	3
81140984:	dfc00a15 	stw	ra,40(sp)
81140988:	df000915 	stw	fp,36(sp)
8114098c:	df000904 	addi	fp,sp,36
81140990:	2005883a 	mov	r2,r4
81140994:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81140998:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8114099c:	e0bfff03 	ldbu	r2,-4(fp)
811409a0:	10800ab0 	cmpltui	r2,r2,42
811409a4:	1000021e 	bne	r2,zero,811409b0 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
811409a8:	00800a84 	movi	r2,42
811409ac:	00006406 	br	81140b40 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811409b0:	0005303a 	rdctl	r2,status
811409b4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811409b8:	e0fffe17 	ldw	r3,-8(fp)
811409bc:	00bfff84 	movi	r2,-2
811409c0:	1884703a 	and	r2,r3,r2
811409c4:	1001703a 	wrctl	status,r2
  
  return context;
811409c8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811409cc:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
811409d0:	e0ffff03 	ldbu	r3,-4(fp)
811409d4:	00a045f4 	movhi	r2,33047
811409d8:	10b2f704 	addi	r2,r2,-13348
811409dc:	18c7883a 	add	r3,r3,r3
811409e0:	18c7883a 	add	r3,r3,r3
811409e4:	10c5883a 	add	r2,r2,r3
811409e8:	10800017 	ldw	r2,0(r2)
811409ec:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
811409f0:	e0bff917 	ldw	r2,-28(fp)
811409f4:	1000061e 	bne	r2,zero,81140a10 <OSTimeDlyResume+0x98>
811409f8:	e0bff717 	ldw	r2,-36(fp)
811409fc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140a00:	e0bff817 	ldw	r2,-32(fp)
81140a04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81140a08:	008010c4 	movi	r2,67
81140a0c:	00004c06 	br	81140b40 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81140a10:	e0bff917 	ldw	r2,-28(fp)
81140a14:	10800058 	cmpnei	r2,r2,1
81140a18:	1000061e 	bne	r2,zero,81140a34 <OSTimeDlyResume+0xbc>
81140a1c:	e0bff717 	ldw	r2,-36(fp)
81140a20:	e0bffa15 	stw	r2,-24(fp)
81140a24:	e0bffa17 	ldw	r2,-24(fp)
81140a28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81140a2c:	008010c4 	movi	r2,67
81140a30:	00004306 	br	81140b40 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81140a34:	e0bff917 	ldw	r2,-28(fp)
81140a38:	10800b8b 	ldhu	r2,46(r2)
81140a3c:	10bfffcc 	andi	r2,r2,65535
81140a40:	1000061e 	bne	r2,zero,81140a5c <OSTimeDlyResume+0xe4>
81140a44:	e0bff717 	ldw	r2,-36(fp)
81140a48:	e0bffb15 	stw	r2,-20(fp)
81140a4c:	e0bffb17 	ldw	r2,-20(fp)
81140a50:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81140a54:	00801404 	movi	r2,80
81140a58:	00003906 	br	81140b40 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
81140a5c:	e0bff917 	ldw	r2,-28(fp)
81140a60:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81140a64:	e0bff917 	ldw	r2,-28(fp)
81140a68:	10800c03 	ldbu	r2,48(r2)
81140a6c:	10803fcc 	andi	r2,r2,255
81140a70:	10800dcc 	andi	r2,r2,55
81140a74:	10000b26 	beq	r2,zero,81140aa4 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81140a78:	e0bff917 	ldw	r2,-28(fp)
81140a7c:	10c00c03 	ldbu	r3,48(r2)
81140a80:	00bff204 	movi	r2,-56
81140a84:	1884703a 	and	r2,r3,r2
81140a88:	1007883a 	mov	r3,r2
81140a8c:	e0bff917 	ldw	r2,-28(fp)
81140a90:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
81140a94:	e0bff917 	ldw	r2,-28(fp)
81140a98:	00c00044 	movi	r3,1
81140a9c:	10c00c45 	stb	r3,49(r2)
81140aa0:	00000206 	br	81140aac <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
81140aa4:	e0bff917 	ldw	r2,-28(fp)
81140aa8:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
81140aac:	e0bff917 	ldw	r2,-28(fp)
81140ab0:	10800c03 	ldbu	r2,48(r2)
81140ab4:	10803fcc 	andi	r2,r2,255
81140ab8:	1080020c 	andi	r2,r2,8
81140abc:	10001b1e 	bne	r2,zero,81140b2c <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
81140ac0:	e0bff917 	ldw	r2,-28(fp)
81140ac4:	10c00d83 	ldbu	r3,54(r2)
81140ac8:	d0a09e03 	ldbu	r2,-32136(gp)
81140acc:	1884b03a 	or	r2,r3,r2
81140ad0:	d0a09e05 	stb	r2,-32136(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81140ad4:	e0bff917 	ldw	r2,-28(fp)
81140ad8:	10800d03 	ldbu	r2,52(r2)
81140adc:	10c03fcc 	andi	r3,r2,255
81140ae0:	e0bff917 	ldw	r2,-28(fp)
81140ae4:	10800d03 	ldbu	r2,52(r2)
81140ae8:	11003fcc 	andi	r4,r2,255
81140aec:	d0a09e44 	addi	r2,gp,-32135
81140af0:	2085883a 	add	r2,r4,r2
81140af4:	11000003 	ldbu	r4,0(r2)
81140af8:	e0bff917 	ldw	r2,-28(fp)
81140afc:	10800d43 	ldbu	r2,53(r2)
81140b00:	2084b03a 	or	r2,r4,r2
81140b04:	1009883a 	mov	r4,r2
81140b08:	d0a09e44 	addi	r2,gp,-32135
81140b0c:	1885883a 	add	r2,r3,r2
81140b10:	11000005 	stb	r4,0(r2)
81140b14:	e0bff717 	ldw	r2,-36(fp)
81140b18:	e0bffc15 	stw	r2,-16(fp)
81140b1c:	e0bffc17 	ldw	r2,-16(fp)
81140b20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81140b24:	11399cc0 	call	811399cc <OS_Sched>
81140b28:	00000406 	br	81140b3c <OSTimeDlyResume+0x1c4>
81140b2c:	e0bff717 	ldw	r2,-36(fp)
81140b30:	e0bffd15 	stw	r2,-12(fp)
81140b34:	e0bffd17 	ldw	r2,-12(fp)
81140b38:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
81140b3c:	0005883a 	mov	r2,zero
}
81140b40:	e037883a 	mov	sp,fp
81140b44:	dfc00117 	ldw	ra,4(sp)
81140b48:	df000017 	ldw	fp,0(sp)
81140b4c:	dec00204 	addi	sp,sp,8
81140b50:	f800283a 	ret

81140b54 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81140b54:	defffb04 	addi	sp,sp,-20
81140b58:	de00012e 	bgeu	sp,et,81140b60 <OSTimeGet+0xc>
81140b5c:	003b68fa 	trap	3
81140b60:	df000415 	stw	fp,16(sp)
81140b64:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140b68:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140b6c:	0005303a 	rdctl	r2,status
81140b70:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140b74:	e0fffe17 	ldw	r3,-8(fp)
81140b78:	00bfff84 	movi	r2,-2
81140b7c:	1884703a 	and	r2,r3,r2
81140b80:	1001703a 	wrctl	status,r2
  
  return context;
81140b84:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81140b88:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
81140b8c:	d0a0a417 	ldw	r2,-32112(gp)
81140b90:	e0bffd15 	stw	r2,-12(fp)
81140b94:	e0bffc17 	ldw	r2,-16(fp)
81140b98:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140b9c:	e0bfff17 	ldw	r2,-4(fp)
81140ba0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
81140ba4:	e0bffd17 	ldw	r2,-12(fp)
}
81140ba8:	e037883a 	mov	sp,fp
81140bac:	df000017 	ldw	fp,0(sp)
81140bb0:	dec00104 	addi	sp,sp,4
81140bb4:	f800283a 	ret

81140bb8 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81140bb8:	defffb04 	addi	sp,sp,-20
81140bbc:	de00012e 	bgeu	sp,et,81140bc4 <OSTimeSet+0xc>
81140bc0:	003b68fa 	trap	3
81140bc4:	df000415 	stw	fp,16(sp)
81140bc8:	df000404 	addi	fp,sp,16
81140bcc:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140bd0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140bd4:	0005303a 	rdctl	r2,status
81140bd8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140bdc:	e0fffd17 	ldw	r3,-12(fp)
81140be0:	00bfff84 	movi	r2,-2
81140be4:	1884703a 	and	r2,r3,r2
81140be8:	1001703a 	wrctl	status,r2
  
  return context;
81140bec:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81140bf0:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
81140bf4:	e0bfff17 	ldw	r2,-4(fp)
81140bf8:	d0a0a415 	stw	r2,-32112(gp)
81140bfc:	e0bffc17 	ldw	r2,-16(fp)
81140c00:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140c04:	e0bffe17 	ldw	r2,-8(fp)
81140c08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81140c0c:	0001883a 	nop
81140c10:	e037883a 	mov	sp,fp
81140c14:	df000017 	ldw	fp,0(sp)
81140c18:	dec00104 	addi	sp,sp,4
81140c1c:	f800283a 	ret

81140c20 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81140c20:	defff804 	addi	sp,sp,-32
81140c24:	de00012e 	bgeu	sp,et,81140c2c <OSTmrCreate+0xc>
81140c28:	003b68fa 	trap	3
81140c2c:	dfc00715 	stw	ra,28(sp)
81140c30:	df000615 	stw	fp,24(sp)
81140c34:	df000604 	addi	fp,sp,24
81140c38:	e13ffc15 	stw	r4,-16(fp)
81140c3c:	e17ffd15 	stw	r5,-12(fp)
81140c40:	3005883a 	mov	r2,r6
81140c44:	e1ffff15 	stw	r7,-4(fp)
81140c48:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81140c4c:	e0800417 	ldw	r2,16(fp)
81140c50:	1000021e 	bne	r2,zero,81140c5c <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81140c54:	0005883a 	mov	r2,zero
81140c58:	00005d06 	br	81140dd0 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
81140c5c:	e0bffe03 	ldbu	r2,-8(fp)
81140c60:	10c00060 	cmpeqi	r3,r2,1
81140c64:	1800091e 	bne	r3,zero,81140c8c <OSTmrCreate+0x6c>
81140c68:	108000a0 	cmpeqi	r2,r2,2
81140c6c:	10000e26 	beq	r2,zero,81140ca8 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
81140c70:	e0bffd17 	ldw	r2,-12(fp)
81140c74:	1000111e 	bne	r2,zero,81140cbc <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
81140c78:	e0800417 	ldw	r2,16(fp)
81140c7c:	00ffe0c4 	movi	r3,-125
81140c80:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81140c84:	0005883a 	mov	r2,zero
81140c88:	00005106 	br	81140dd0 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
81140c8c:	e0bffc17 	ldw	r2,-16(fp)
81140c90:	10000c1e 	bne	r2,zero,81140cc4 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
81140c94:	e0800417 	ldw	r2,16(fp)
81140c98:	00ffe084 	movi	r3,-126
81140c9c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81140ca0:	0005883a 	mov	r2,zero
81140ca4:	00004a06 	br	81140dd0 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
81140ca8:	e0800417 	ldw	r2,16(fp)
81140cac:	00ffe104 	movi	r3,-124
81140cb0:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
81140cb4:	0005883a 	mov	r2,zero
81140cb8:	00004506 	br	81140dd0 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81140cbc:	0001883a 	nop
81140cc0:	00000106 	br	81140cc8 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
81140cc4:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81140cc8:	d0a0a103 	ldbu	r2,-32124(gp)
81140ccc:	10803fcc 	andi	r2,r2,255
81140cd0:	10000526 	beq	r2,zero,81140ce8 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
81140cd4:	e0800417 	ldw	r2,16(fp)
81140cd8:	00ffe2c4 	movi	r3,-117
81140cdc:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81140ce0:	0005883a 	mov	r2,zero
81140ce4:	00003a06 	br	81140dd0 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81140ce8:	1141bd80 	call	81141bd8 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81140cec:	11416780 	call	81141678 <OSTmr_Alloc>
81140cf0:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
81140cf4:	e0bffa17 	ldw	r2,-24(fp)
81140cf8:	1000061e 	bne	r2,zero,81140d14 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81140cfc:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81140d00:	e0800417 	ldw	r2,16(fp)
81140d04:	00ffe184 	movi	r3,-122
81140d08:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81140d0c:	0005883a 	mov	r2,zero
81140d10:	00002f06 	br	81140dd0 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81140d14:	e0bffa17 	ldw	r2,-24(fp)
81140d18:	00c00044 	movi	r3,1
81140d1c:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81140d20:	e0bffa17 	ldw	r2,-24(fp)
81140d24:	e0fffc17 	ldw	r3,-16(fp)
81140d28:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81140d2c:	e0bffa17 	ldw	r2,-24(fp)
81140d30:	e0fffd17 	ldw	r3,-12(fp)
81140d34:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81140d38:	e0bffa17 	ldw	r2,-24(fp)
81140d3c:	e0fffe03 	ldbu	r3,-8(fp)
81140d40:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81140d44:	e0bffa17 	ldw	r2,-24(fp)
81140d48:	e0ffff17 	ldw	r3,-4(fp)
81140d4c:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81140d50:	e0bffa17 	ldw	r2,-24(fp)
81140d54:	e0c00217 	ldw	r3,8(fp)
81140d58:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81140d5c:	e0800317 	ldw	r2,12(fp)
81140d60:	10001726 	beq	r2,zero,81140dc0 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
81140d64:	e1000317 	ldw	r4,12(fp)
81140d68:	1139b9c0 	call	81139b9c <OS_StrLen>
81140d6c:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
81140d70:	e0bffb03 	ldbu	r2,-20(fp)
81140d74:	10800428 	cmpgeui	r2,r2,16
81140d78:	1000061e 	bne	r2,zero,81140d94 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
81140d7c:	e0bffa17 	ldw	r2,-24(fp)
81140d80:	10800804 	addi	r2,r2,32
81140d84:	e1400317 	ldw	r5,12(fp)
81140d88:	1009883a 	mov	r4,r2
81140d8c:	1139b200 	call	81139b20 <OS_StrCopy>
81140d90:	00000b06 	br	81140dc0 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
81140d94:	e0bffa17 	ldw	r2,-24(fp)
81140d98:	00c008c4 	movi	r3,35
81140d9c:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
81140da0:	e0bffa17 	ldw	r2,-24(fp)
81140da4:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81140da8:	e0800417 	ldw	r2,16(fp)
81140dac:	00ffe304 	movi	r3,-116
81140db0:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
81140db4:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
            return (ptmr);
81140db8:	e0bffa17 	ldw	r2,-24(fp)
81140dbc:	00000406 	br	81140dd0 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81140dc0:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81140dc4:	e0800417 	ldw	r2,16(fp)
81140dc8:	10000005 	stb	zero,0(r2)
    return (ptmr);
81140dcc:	e0bffa17 	ldw	r2,-24(fp)
}
81140dd0:	e037883a 	mov	sp,fp
81140dd4:	dfc00117 	ldw	ra,4(sp)
81140dd8:	df000017 	ldw	fp,0(sp)
81140ddc:	dec00204 	addi	sp,sp,8
81140de0:	f800283a 	ret

81140de4 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81140de4:	defffc04 	addi	sp,sp,-16
81140de8:	de00012e 	bgeu	sp,et,81140df0 <OSTmrDel+0xc>
81140dec:	003b68fa 	trap	3
81140df0:	dfc00315 	stw	ra,12(sp)
81140df4:	df000215 	stw	fp,8(sp)
81140df8:	df000204 	addi	fp,sp,8
81140dfc:	e13ffe15 	stw	r4,-8(fp)
81140e00:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81140e04:	e0bfff17 	ldw	r2,-4(fp)
81140e08:	1000021e 	bne	r2,zero,81140e14 <OSTmrDel+0x30>
        return (OS_FALSE);
81140e0c:	0005883a 	mov	r2,zero
81140e10:	00003f06 	br	81140f10 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81140e14:	e0bffe17 	ldw	r2,-8(fp)
81140e18:	1000051e 	bne	r2,zero,81140e30 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81140e1c:	e0bfff17 	ldw	r2,-4(fp)
81140e20:	00ffe284 	movi	r3,-118
81140e24:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140e28:	0005883a 	mov	r2,zero
81140e2c:	00003806 	br	81140f10 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81140e30:	e0bffe17 	ldw	r2,-8(fp)
81140e34:	10800003 	ldbu	r2,0(r2)
81140e38:	10803fcc 	andi	r2,r2,255
81140e3c:	10801920 	cmpeqi	r2,r2,100
81140e40:	1000051e 	bne	r2,zero,81140e58 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81140e44:	e0bfff17 	ldw	r2,-4(fp)
81140e48:	00ffe244 	movi	r3,-119
81140e4c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140e50:	0005883a 	mov	r2,zero
81140e54:	00002e06 	br	81140f10 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81140e58:	d0a0a103 	ldbu	r2,-32124(gp)
81140e5c:	10803fcc 	andi	r2,r2,255
81140e60:	10000526 	beq	r2,zero,81140e78 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
81140e64:	e0bfff17 	ldw	r2,-4(fp)
81140e68:	00ffe2c4 	movi	r3,-117
81140e6c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140e70:	0005883a 	mov	r2,zero
81140e74:	00002606 	br	81140f10 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81140e78:	1141bd80 	call	81141bd8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81140e7c:	e0bffe17 	ldw	r2,-8(fp)
81140e80:	10800c43 	ldbu	r2,49(r2)
81140e84:	10803fcc 	andi	r2,r2,255
81140e88:	10c000c8 	cmpgei	r3,r2,3
81140e8c:	1800031e 	bne	r3,zero,81140e9c <OSTmrDel+0xb8>
81140e90:	00800d16 	blt	zero,r2,81140ec8 <OSTmrDel+0xe4>
81140e94:	10001326 	beq	r2,zero,81140ee4 <OSTmrDel+0x100>
81140e98:	00001806 	br	81140efc <OSTmrDel+0x118>
81140e9c:	108000e0 	cmpeqi	r2,r2,3
81140ea0:	10001626 	beq	r2,zero,81140efc <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
81140ea4:	e13ffe17 	ldw	r4,-8(fp)
81140ea8:	1141adc0 	call	81141adc <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81140eac:	e13ffe17 	ldw	r4,-8(fp)
81140eb0:	11416ec0 	call	811416ec <OSTmr_Free>
             OSTmr_Unlock();
81140eb4:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140eb8:	e0bfff17 	ldw	r2,-4(fp)
81140ebc:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81140ec0:	00800044 	movi	r2,1
81140ec4:	00001206 	br	81140f10 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81140ec8:	e13ffe17 	ldw	r4,-8(fp)
81140ecc:	11416ec0 	call	811416ec <OSTmr_Free>
             OSTmr_Unlock();
81140ed0:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140ed4:	e0bfff17 	ldw	r2,-4(fp)
81140ed8:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81140edc:	00800044 	movi	r2,1
81140ee0:	00000b06 	br	81140f10 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
81140ee4:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81140ee8:	e0bfff17 	ldw	r2,-4(fp)
81140eec:	00ffe1c4 	movi	r3,-121
81140ef0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140ef4:	0005883a 	mov	r2,zero
81140ef8:	00000506 	br	81140f10 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
81140efc:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140f00:	e0bfff17 	ldw	r2,-4(fp)
81140f04:	00ffe344 	movi	r3,-115
81140f08:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140f0c:	0005883a 	mov	r2,zero
    }
}
81140f10:	e037883a 	mov	sp,fp
81140f14:	dfc00117 	ldw	ra,4(sp)
81140f18:	df000017 	ldw	fp,0(sp)
81140f1c:	dec00204 	addi	sp,sp,8
81140f20:	f800283a 	ret

81140f24 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
81140f24:	defffa04 	addi	sp,sp,-24
81140f28:	de00012e 	bgeu	sp,et,81140f30 <OSTmrNameGet+0xc>
81140f2c:	003b68fa 	trap	3
81140f30:	dfc00515 	stw	ra,20(sp)
81140f34:	df000415 	stw	fp,16(sp)
81140f38:	df000404 	addi	fp,sp,16
81140f3c:	e13ffd15 	stw	r4,-12(fp)
81140f40:	e17ffe15 	stw	r5,-8(fp)
81140f44:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81140f48:	e0bfff17 	ldw	r2,-4(fp)
81140f4c:	1000021e 	bne	r2,zero,81140f58 <OSTmrNameGet+0x34>
        return (0);
81140f50:	0005883a 	mov	r2,zero
81140f54:	00003e06 	br	81141050 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
81140f58:	e0bffe17 	ldw	r2,-8(fp)
81140f5c:	1000051e 	bne	r2,zero,81140f74 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
81140f60:	e0bfff17 	ldw	r2,-4(fp)
81140f64:	00ffe204 	movi	r3,-120
81140f68:	10c00005 	stb	r3,0(r2)
        return (0);
81140f6c:	0005883a 	mov	r2,zero
81140f70:	00003706 	br	81141050 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81140f74:	e0bffd17 	ldw	r2,-12(fp)
81140f78:	1000051e 	bne	r2,zero,81140f90 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81140f7c:	e0bfff17 	ldw	r2,-4(fp)
81140f80:	00ffe284 	movi	r3,-118
81140f84:	10c00005 	stb	r3,0(r2)
        return (0);
81140f88:	0005883a 	mov	r2,zero
81140f8c:	00003006 	br	81141050 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81140f90:	e0bffd17 	ldw	r2,-12(fp)
81140f94:	10800003 	ldbu	r2,0(r2)
81140f98:	10803fcc 	andi	r2,r2,255
81140f9c:	10801920 	cmpeqi	r2,r2,100
81140fa0:	1000051e 	bne	r2,zero,81140fb8 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81140fa4:	e0bfff17 	ldw	r2,-4(fp)
81140fa8:	00ffe244 	movi	r3,-119
81140fac:	10c00005 	stb	r3,0(r2)
        return (0);
81140fb0:	0005883a 	mov	r2,zero
81140fb4:	00002606 	br	81141050 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81140fb8:	d0a0a103 	ldbu	r2,-32124(gp)
81140fbc:	10803fcc 	andi	r2,r2,255
81140fc0:	10000526 	beq	r2,zero,81140fd8 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
81140fc4:	e0bfff17 	ldw	r2,-4(fp)
81140fc8:	00c00444 	movi	r3,17
81140fcc:	10c00005 	stb	r3,0(r2)
        return (0);
81140fd0:	0005883a 	mov	r2,zero
81140fd4:	00001e06 	br	81141050 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81140fd8:	1141bd80 	call	81141bd8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81140fdc:	e0bffd17 	ldw	r2,-12(fp)
81140fe0:	10800c43 	ldbu	r2,49(r2)
81140fe4:	10803fcc 	andi	r2,r2,255
81140fe8:	10000e26 	beq	r2,zero,81141024 <OSTmrNameGet+0x100>
81140fec:	10001316 	blt	r2,zero,8114103c <OSTmrNameGet+0x118>
81140ff0:	10800108 	cmpgei	r2,r2,4
81140ff4:	1000111e 	bne	r2,zero,8114103c <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81140ff8:	e0bffd17 	ldw	r2,-12(fp)
81140ffc:	10800804 	addi	r2,r2,32
81141000:	100b883a 	mov	r5,r2
81141004:	e13ffe17 	ldw	r4,-8(fp)
81141008:	1139b200 	call	81139b20 <OS_StrCopy>
8114100c:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
81141010:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81141014:	e0bfff17 	ldw	r2,-4(fp)
81141018:	10000005 	stb	zero,0(r2)
             return (len);
8114101c:	e0bffc03 	ldbu	r2,-16(fp)
81141020:	00000b06 	br	81141050 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
81141024:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81141028:	e0bfff17 	ldw	r2,-4(fp)
8114102c:	00ffe1c4 	movi	r3,-121
81141030:	10c00005 	stb	r3,0(r2)
             return (0);
81141034:	0005883a 	mov	r2,zero
81141038:	00000506 	br	81141050 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8114103c:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81141040:	e0bfff17 	ldw	r2,-4(fp)
81141044:	00ffe344 	movi	r3,-115
81141048:	10c00005 	stb	r3,0(r2)
             return (0);
8114104c:	0005883a 	mov	r2,zero
    }
}
81141050:	e037883a 	mov	sp,fp
81141054:	dfc00117 	ldw	ra,4(sp)
81141058:	df000017 	ldw	fp,0(sp)
8114105c:	dec00204 	addi	sp,sp,8
81141060:	f800283a 	ret

81141064 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
81141064:	defffb04 	addi	sp,sp,-20
81141068:	de00012e 	bgeu	sp,et,81141070 <OSTmrRemainGet+0xc>
8114106c:	003b68fa 	trap	3
81141070:	dfc00415 	stw	ra,16(sp)
81141074:	df000315 	stw	fp,12(sp)
81141078:	df000304 	addi	fp,sp,12
8114107c:	e13ffe15 	stw	r4,-8(fp)
81141080:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81141084:	e0bfff17 	ldw	r2,-4(fp)
81141088:	1000021e 	bne	r2,zero,81141094 <OSTmrRemainGet+0x30>
        return (0);
8114108c:	0005883a 	mov	r2,zero
81141090:	00005d06 	br	81141208 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
81141094:	e0bffe17 	ldw	r2,-8(fp)
81141098:	1000051e 	bne	r2,zero,811410b0 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8114109c:	e0bfff17 	ldw	r2,-4(fp)
811410a0:	00ffe284 	movi	r3,-118
811410a4:	10c00005 	stb	r3,0(r2)
        return (0);
811410a8:	0005883a 	mov	r2,zero
811410ac:	00005606 	br	81141208 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
811410b0:	e0bffe17 	ldw	r2,-8(fp)
811410b4:	10800003 	ldbu	r2,0(r2)
811410b8:	10803fcc 	andi	r2,r2,255
811410bc:	10801920 	cmpeqi	r2,r2,100
811410c0:	1000051e 	bne	r2,zero,811410d8 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811410c4:	e0bfff17 	ldw	r2,-4(fp)
811410c8:	00ffe244 	movi	r3,-119
811410cc:	10c00005 	stb	r3,0(r2)
        return (0);
811410d0:	0005883a 	mov	r2,zero
811410d4:	00004c06 	br	81141208 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
811410d8:	d0a0a103 	ldbu	r2,-32124(gp)
811410dc:	10803fcc 	andi	r2,r2,255
811410e0:	10000526 	beq	r2,zero,811410f8 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
811410e4:	e0bfff17 	ldw	r2,-4(fp)
811410e8:	00ffe2c4 	movi	r3,-117
811410ec:	10c00005 	stb	r3,0(r2)
        return (0);
811410f0:	0005883a 	mov	r2,zero
811410f4:	00004406 	br	81141208 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
811410f8:	1141bd80 	call	81141bd8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811410fc:	e0bffe17 	ldw	r2,-8(fp)
81141100:	10800c43 	ldbu	r2,49(r2)
81141104:	10803fcc 	andi	r2,r2,255
81141108:	10c00060 	cmpeqi	r3,r2,1
8114110c:	1800121e 	bne	r3,zero,81141158 <OSTmrRemainGet+0xf4>
81141110:	10c00088 	cmpgei	r3,r2,2
81141114:	1800021e 	bne	r3,zero,81141120 <OSTmrRemainGet+0xbc>
81141118:	10003026 	beq	r2,zero,811411dc <OSTmrRemainGet+0x178>
8114111c:	00003506 	br	811411f4 <OSTmrRemainGet+0x190>
81141120:	10c000a0 	cmpeqi	r3,r2,2
81141124:	1800281e 	bne	r3,zero,811411c8 <OSTmrRemainGet+0x164>
81141128:	108000e0 	cmpeqi	r2,r2,3
8114112c:	10003126 	beq	r2,zero,811411f4 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
81141130:	e0bffe17 	ldw	r2,-8(fp)
81141134:	10c00517 	ldw	r3,20(r2)
81141138:	d0a0a317 	ldw	r2,-32116(gp)
8114113c:	1885c83a 	sub	r2,r3,r2
81141140:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
81141144:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81141148:	e0bfff17 	ldw	r2,-4(fp)
8114114c:	10000005 	stb	zero,0(r2)
             return (remain);
81141150:	e0bffd17 	ldw	r2,-12(fp)
81141154:	00002c06 	br	81141208 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
81141158:	e0bffe17 	ldw	r2,-8(fp)
8114115c:	10800c03 	ldbu	r2,48(r2)
81141160:	10803fcc 	andi	r2,r2,255
81141164:	108000a0 	cmpeqi	r2,r2,2
81141168:	10000e26 	beq	r2,zero,811411a4 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8114116c:	e0bffe17 	ldw	r2,-8(fp)
81141170:	10800617 	ldw	r2,24(r2)
81141174:	1000041e 	bne	r2,zero,81141188 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81141178:	e0bffe17 	ldw	r2,-8(fp)
8114117c:	10800717 	ldw	r2,28(r2)
81141180:	e0bffd15 	stw	r2,-12(fp)
81141184:	00000306 	br	81141194 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81141188:	e0bffe17 	ldw	r2,-8(fp)
8114118c:	10800617 	ldw	r2,24(r2)
81141190:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
81141194:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81141198:	e0bfff17 	ldw	r2,-4(fp)
8114119c:	10000005 	stb	zero,0(r2)
                      break;
811411a0:	00000706 	br	811411c0 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
811411a4:	e0bffe17 	ldw	r2,-8(fp)
811411a8:	10800617 	ldw	r2,24(r2)
811411ac:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
811411b0:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
811411b4:	e0bfff17 	ldw	r2,-4(fp)
811411b8:	10000005 	stb	zero,0(r2)
                      break;
811411bc:	0001883a 	nop
             }
             return (remain);
811411c0:	e0bffd17 	ldw	r2,-12(fp)
811411c4:	00001006 	br	81141208 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
811411c8:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811411cc:	e0bfff17 	ldw	r2,-4(fp)
811411d0:	10000005 	stb	zero,0(r2)
             return (0);
811411d4:	0005883a 	mov	r2,zero
811411d8:	00000b06 	br	81141208 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
811411dc:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811411e0:	e0bfff17 	ldw	r2,-4(fp)
811411e4:	00ffe1c4 	movi	r3,-121
811411e8:	10c00005 	stb	r3,0(r2)
             return (0);
811411ec:	0005883a 	mov	r2,zero
811411f0:	00000506 	br	81141208 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
811411f4:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
811411f8:	e0bfff17 	ldw	r2,-4(fp)
811411fc:	00ffe344 	movi	r3,-115
81141200:	10c00005 	stb	r3,0(r2)
             return (0);
81141204:	0005883a 	mov	r2,zero
    }
}
81141208:	e037883a 	mov	sp,fp
8114120c:	dfc00117 	ldw	ra,4(sp)
81141210:	df000017 	ldw	fp,0(sp)
81141214:	dec00204 	addi	sp,sp,8
81141218:	f800283a 	ret

8114121c <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8114121c:	defffb04 	addi	sp,sp,-20
81141220:	de00012e 	bgeu	sp,et,81141228 <OSTmrStateGet+0xc>
81141224:	003b68fa 	trap	3
81141228:	dfc00415 	stw	ra,16(sp)
8114122c:	df000315 	stw	fp,12(sp)
81141230:	df000304 	addi	fp,sp,12
81141234:	e13ffe15 	stw	r4,-8(fp)
81141238:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8114123c:	e0bfff17 	ldw	r2,-4(fp)
81141240:	1000021e 	bne	r2,zero,8114124c <OSTmrStateGet+0x30>
        return (0);
81141244:	0005883a 	mov	r2,zero
81141248:	00002a06 	br	811412f4 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8114124c:	e0bffe17 	ldw	r2,-8(fp)
81141250:	1000051e 	bne	r2,zero,81141268 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81141254:	e0bfff17 	ldw	r2,-4(fp)
81141258:	00ffe284 	movi	r3,-118
8114125c:	10c00005 	stb	r3,0(r2)
        return (0);
81141260:	0005883a 	mov	r2,zero
81141264:	00002306 	br	811412f4 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81141268:	e0bffe17 	ldw	r2,-8(fp)
8114126c:	10800003 	ldbu	r2,0(r2)
81141270:	10803fcc 	andi	r2,r2,255
81141274:	10801920 	cmpeqi	r2,r2,100
81141278:	1000051e 	bne	r2,zero,81141290 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114127c:	e0bfff17 	ldw	r2,-4(fp)
81141280:	00ffe244 	movi	r3,-119
81141284:	10c00005 	stb	r3,0(r2)
        return (0);
81141288:	0005883a 	mov	r2,zero
8114128c:	00001906 	br	811412f4 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81141290:	d0a0a103 	ldbu	r2,-32124(gp)
81141294:	10803fcc 	andi	r2,r2,255
81141298:	10000526 	beq	r2,zero,811412b0 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8114129c:	e0bfff17 	ldw	r2,-4(fp)
811412a0:	00ffe2c4 	movi	r3,-117
811412a4:	10c00005 	stb	r3,0(r2)
        return (0);
811412a8:	0005883a 	mov	r2,zero
811412ac:	00001106 	br	811412f4 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
811412b0:	1141bd80 	call	81141bd8 <OSTmr_Lock>
    state = ptmr->OSTmrState;
811412b4:	e0bffe17 	ldw	r2,-8(fp)
811412b8:	10800c43 	ldbu	r2,49(r2)
811412bc:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
811412c0:	e0bffd03 	ldbu	r2,-12(fp)
811412c4:	1005883a 	mov	r2,r2
811412c8:	10800128 	cmpgeui	r2,r2,4
811412cc:	1000031e 	bne	r2,zero,811412dc <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
811412d0:	e0bfff17 	ldw	r2,-4(fp)
811412d4:	10000005 	stb	zero,0(r2)
             break;
811412d8:	00000406 	br	811412ec <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
811412dc:	e0bfff17 	ldw	r2,-4(fp)
811412e0:	00ffe344 	movi	r3,-115
811412e4:	10c00005 	stb	r3,0(r2)
             break;
811412e8:	0001883a 	nop
    }
    OSTmr_Unlock();
811412ec:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
    return (state);
811412f0:	e0bffd03 	ldbu	r2,-12(fp)
}
811412f4:	e037883a 	mov	sp,fp
811412f8:	dfc00117 	ldw	ra,4(sp)
811412fc:	df000017 	ldw	fp,0(sp)
81141300:	dec00204 	addi	sp,sp,8
81141304:	f800283a 	ret

81141308 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
81141308:	defffc04 	addi	sp,sp,-16
8114130c:	de00012e 	bgeu	sp,et,81141314 <OSTmrStart+0xc>
81141310:	003b68fa 	trap	3
81141314:	dfc00315 	stw	ra,12(sp)
81141318:	df000215 	stw	fp,8(sp)
8114131c:	df000204 	addi	fp,sp,8
81141320:	e13ffe15 	stw	r4,-8(fp)
81141324:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81141328:	e0bfff17 	ldw	r2,-4(fp)
8114132c:	1000021e 	bne	r2,zero,81141338 <OSTmrStart+0x30>
        return (OS_FALSE);
81141330:	0005883a 	mov	r2,zero
81141334:	00004106 	br	8114143c <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
81141338:	e0bffe17 	ldw	r2,-8(fp)
8114133c:	1000051e 	bne	r2,zero,81141354 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81141340:	e0bfff17 	ldw	r2,-4(fp)
81141344:	00ffe284 	movi	r3,-118
81141348:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8114134c:	0005883a 	mov	r2,zero
81141350:	00003a06 	br	8114143c <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81141354:	e0bffe17 	ldw	r2,-8(fp)
81141358:	10800003 	ldbu	r2,0(r2)
8114135c:	10803fcc 	andi	r2,r2,255
81141360:	10801920 	cmpeqi	r2,r2,100
81141364:	1000051e 	bne	r2,zero,8114137c <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81141368:	e0bfff17 	ldw	r2,-4(fp)
8114136c:	00ffe244 	movi	r3,-119
81141370:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81141374:	0005883a 	mov	r2,zero
81141378:	00003006 	br	8114143c <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8114137c:	d0a0a103 	ldbu	r2,-32124(gp)
81141380:	10803fcc 	andi	r2,r2,255
81141384:	10000526 	beq	r2,zero,8114139c <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
81141388:	e0bfff17 	ldw	r2,-4(fp)
8114138c:	00ffe2c4 	movi	r3,-117
81141390:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81141394:	0005883a 	mov	r2,zero
81141398:	00002806 	br	8114143c <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8114139c:	1141bd80 	call	81141bd8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811413a0:	e0bffe17 	ldw	r2,-8(fp)
811413a4:	10800c43 	ldbu	r2,49(r2)
811413a8:	10803fcc 	andi	r2,r2,255
811413ac:	10c000c8 	cmpgei	r3,r2,3
811413b0:	1800031e 	bne	r3,zero,811413c0 <OSTmrStart+0xb8>
811413b4:	00800e16 	blt	zero,r2,811413f0 <OSTmrStart+0xe8>
811413b8:	10001526 	beq	r2,zero,81141410 <OSTmrStart+0x108>
811413bc:	00001a06 	br	81141428 <OSTmrStart+0x120>
811413c0:	108000e0 	cmpeqi	r2,r2,3
811413c4:	10001826 	beq	r2,zero,81141428 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
811413c8:	e13ffe17 	ldw	r4,-8(fp)
811413cc:	1141adc0 	call	81141adc <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
811413d0:	000b883a 	mov	r5,zero
811413d4:	e13ffe17 	ldw	r4,-8(fp)
811413d8:	114198c0 	call	8114198c <OSTmr_Link>
             OSTmr_Unlock();
811413dc:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
811413e0:	e0bfff17 	ldw	r2,-4(fp)
811413e4:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
811413e8:	00800044 	movi	r2,1
811413ec:	00001306 	br	8114143c <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
811413f0:	000b883a 	mov	r5,zero
811413f4:	e13ffe17 	ldw	r4,-8(fp)
811413f8:	114198c0 	call	8114198c <OSTmr_Link>
             OSTmr_Unlock();
811413fc:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81141400:	e0bfff17 	ldw	r2,-4(fp)
81141404:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81141408:	00800044 	movi	r2,1
8114140c:	00000b06 	br	8114143c <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
81141410:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81141414:	e0bfff17 	ldw	r2,-4(fp)
81141418:	00ffe1c4 	movi	r3,-121
8114141c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81141420:	0005883a 	mov	r2,zero
81141424:	00000506 	br	8114143c <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
81141428:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8114142c:	e0bfff17 	ldw	r2,-4(fp)
81141430:	00ffe344 	movi	r3,-115
81141434:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81141438:	0005883a 	mov	r2,zero
    }
}
8114143c:	e037883a 	mov	sp,fp
81141440:	dfc00117 	ldw	ra,4(sp)
81141444:	df000017 	ldw	fp,0(sp)
81141448:	dec00204 	addi	sp,sp,8
8114144c:	f800283a 	ret

81141450 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
81141450:	defff904 	addi	sp,sp,-28
81141454:	de00012e 	bgeu	sp,et,8114145c <OSTmrStop+0xc>
81141458:	003b68fa 	trap	3
8114145c:	dfc00615 	stw	ra,24(sp)
81141460:	df000515 	stw	fp,20(sp)
81141464:	df000504 	addi	fp,sp,20
81141468:	e13ffc15 	stw	r4,-16(fp)
8114146c:	2805883a 	mov	r2,r5
81141470:	e1bffe15 	stw	r6,-8(fp)
81141474:	e1ffff15 	stw	r7,-4(fp)
81141478:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8114147c:	e0bfff17 	ldw	r2,-4(fp)
81141480:	1000021e 	bne	r2,zero,8114148c <OSTmrStop+0x3c>
        return (OS_FALSE);
81141484:	0005883a 	mov	r2,zero
81141488:	00006606 	br	81141624 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8114148c:	e0bffc17 	ldw	r2,-16(fp)
81141490:	1000051e 	bne	r2,zero,811414a8 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
81141494:	e0bfff17 	ldw	r2,-4(fp)
81141498:	00ffe284 	movi	r3,-118
8114149c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811414a0:	0005883a 	mov	r2,zero
811414a4:	00005f06 	br	81141624 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
811414a8:	e0bffc17 	ldw	r2,-16(fp)
811414ac:	10800003 	ldbu	r2,0(r2)
811414b0:	10803fcc 	andi	r2,r2,255
811414b4:	10801920 	cmpeqi	r2,r2,100
811414b8:	1000051e 	bne	r2,zero,811414d0 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811414bc:	e0bfff17 	ldw	r2,-4(fp)
811414c0:	00ffe244 	movi	r3,-119
811414c4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811414c8:	0005883a 	mov	r2,zero
811414cc:	00005506 	br	81141624 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
811414d0:	d0a0a103 	ldbu	r2,-32124(gp)
811414d4:	10803fcc 	andi	r2,r2,255
811414d8:	10000526 	beq	r2,zero,811414f0 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
811414dc:	e0bfff17 	ldw	r2,-4(fp)
811414e0:	00ffe2c4 	movi	r3,-117
811414e4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811414e8:	0005883a 	mov	r2,zero
811414ec:	00004d06 	br	81141624 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
811414f0:	1141bd80 	call	81141bd8 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811414f4:	e0bffc17 	ldw	r2,-16(fp)
811414f8:	10800c43 	ldbu	r2,49(r2)
811414fc:	10803fcc 	andi	r2,r2,255
81141500:	10c000c8 	cmpgei	r3,r2,3
81141504:	1800031e 	bne	r3,zero,81141514 <OSTmrStop+0xc4>
81141508:	00803516 	blt	zero,r2,811415e0 <OSTmrStop+0x190>
8114150c:	10003a26 	beq	r2,zero,811415f8 <OSTmrStop+0x1a8>
81141510:	00003f06 	br	81141610 <OSTmrStop+0x1c0>
81141514:	108000e0 	cmpeqi	r2,r2,3
81141518:	10003d26 	beq	r2,zero,81141610 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8114151c:	e13ffc17 	ldw	r4,-16(fp)
81141520:	1141adc0 	call	81141adc <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
81141524:	e0bfff17 	ldw	r2,-4(fp)
81141528:	10000005 	stb	zero,0(r2)
             switch (opt) {
8114152c:	e0bffd03 	ldbu	r2,-12(fp)
81141530:	10c000e0 	cmpeqi	r3,r2,3
81141534:	1800041e 	bne	r3,zero,81141548 <OSTmrStop+0xf8>
81141538:	10c00120 	cmpeqi	r3,r2,4
8114153c:	1800121e 	bne	r3,zero,81141588 <OSTmrStop+0x138>
81141540:	10002326 	beq	r2,zero,811415d0 <OSTmrStop+0x180>
81141544:	00001e06 	br	811415c0 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81141548:	e0bffc17 	ldw	r2,-16(fp)
8114154c:	10800117 	ldw	r2,4(r2)
81141550:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81141554:	e0bffb17 	ldw	r2,-20(fp)
81141558:	10000726 	beq	r2,zero,81141578 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8114155c:	e0bffc17 	ldw	r2,-16(fp)
81141560:	10c00217 	ldw	r3,8(r2)
81141564:	e0bffb17 	ldw	r2,-20(fp)
81141568:	180b883a 	mov	r5,r3
8114156c:	e13ffc17 	ldw	r4,-16(fp)
81141570:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81141574:	00001706 	br	811415d4 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81141578:	e0bfff17 	ldw	r2,-4(fp)
8114157c:	00ffe3c4 	movi	r3,-113
81141580:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81141584:	00001306 	br	811415d4 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
81141588:	e0bffc17 	ldw	r2,-16(fp)
8114158c:	10800117 	ldw	r2,4(r2)
81141590:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
81141594:	e0bffb17 	ldw	r2,-20(fp)
81141598:	10000526 	beq	r2,zero,811415b0 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8114159c:	e0bffb17 	ldw	r2,-20(fp)
811415a0:	e17ffe17 	ldw	r5,-8(fp)
811415a4:	e13ffc17 	ldw	r4,-16(fp)
811415a8:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
811415ac:	00000906 	br	811415d4 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
811415b0:	e0bfff17 	ldw	r2,-4(fp)
811415b4:	00ffe3c4 	movi	r3,-113
811415b8:	10c00005 	stb	r3,0(r2)
                      }
                      break;
811415bc:	00000506 	br	811415d4 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
811415c0:	e0bfff17 	ldw	r2,-4(fp)
811415c4:	00ffe104 	movi	r3,-124
811415c8:	10c00005 	stb	r3,0(r2)
                     break;
811415cc:	00000106 	br	811415d4 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
811415d0:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
811415d4:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             return (OS_TRUE);
811415d8:	00800044 	movi	r2,1
811415dc:	00001106 	br	81141624 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
811415e0:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
811415e4:	e0bfff17 	ldw	r2,-4(fp)
811415e8:	00ffe384 	movi	r3,-114
811415ec:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
811415f0:	00800044 	movi	r2,1
811415f4:	00000b06 	br	81141624 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
811415f8:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
811415fc:	e0bfff17 	ldw	r2,-4(fp)
81141600:	00ffe1c4 	movi	r3,-121
81141604:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81141608:	0005883a 	mov	r2,zero
8114160c:	00000506 	br	81141624 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
81141610:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81141614:	e0bfff17 	ldw	r2,-4(fp)
81141618:	00ffe344 	movi	r3,-115
8114161c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81141620:	0005883a 	mov	r2,zero
    }
}
81141624:	e037883a 	mov	sp,fp
81141628:	dfc00117 	ldw	ra,4(sp)
8114162c:	df000017 	ldw	fp,0(sp)
81141630:	dec00204 	addi	sp,sp,8
81141634:	f800283a 	ret

81141638 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
81141638:	defffd04 	addi	sp,sp,-12
8114163c:	de00012e 	bgeu	sp,et,81141644 <OSTmrSignal+0xc>
81141640:	003b68fa 	trap	3
81141644:	dfc00215 	stw	ra,8(sp)
81141648:	df000115 	stw	fp,4(sp)
8114164c:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
81141650:	d0a09017 	ldw	r2,-32192(gp)
81141654:	1009883a 	mov	r4,r2
81141658:	113ec040 	call	8113ec04 <OSSemPost>
8114165c:	e0bfff05 	stb	r2,-4(fp)
    return (err);
81141660:	e0bfff03 	ldbu	r2,-4(fp)
}
81141664:	e037883a 	mov	sp,fp
81141668:	dfc00117 	ldw	ra,4(sp)
8114166c:	df000017 	ldw	fp,0(sp)
81141670:	dec00204 	addi	sp,sp,8
81141674:	f800283a 	ret

81141678 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81141678:	defffe04 	addi	sp,sp,-8
8114167c:	de00012e 	bgeu	sp,et,81141684 <OSTmr_Alloc+0xc>
81141680:	003b68fa 	trap	3
81141684:	df000115 	stw	fp,4(sp)
81141688:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8114168c:	d0a08e17 	ldw	r2,-32200(gp)
81141690:	1000021e 	bne	r2,zero,8114169c <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
81141694:	0005883a 	mov	r2,zero
81141698:	00001006 	br	811416dc <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8114169c:	d0a08e17 	ldw	r2,-32200(gp)
811416a0:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
811416a4:	e0bfff17 	ldw	r2,-4(fp)
811416a8:	10800317 	ldw	r2,12(r2)
811416ac:	d0a08e15 	stw	r2,-32200(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
811416b0:	e0bfff17 	ldw	r2,-4(fp)
811416b4:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
811416b8:	e0bfff17 	ldw	r2,-4(fp)
811416bc:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
811416c0:	d0a0930b 	ldhu	r2,-32180(gp)
811416c4:	10800044 	addi	r2,r2,1
811416c8:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree--;
811416cc:	d0a0970b 	ldhu	r2,-32164(gp)
811416d0:	10bfffc4 	addi	r2,r2,-1
811416d4:	d0a0970d 	sth	r2,-32164(gp)
    return (ptmr);
811416d8:	e0bfff17 	ldw	r2,-4(fp)
}
811416dc:	e037883a 	mov	sp,fp
811416e0:	df000017 	ldw	fp,0(sp)
811416e4:	dec00104 	addi	sp,sp,4
811416e8:	f800283a 	ret

811416ec <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
811416ec:	defffe04 	addi	sp,sp,-8
811416f0:	de00012e 	bgeu	sp,et,811416f8 <OSTmr_Free+0xc>
811416f4:	003b68fa 	trap	3
811416f8:	df000115 	stw	fp,4(sp)
811416fc:	df000104 	addi	fp,sp,4
81141700:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
81141704:	e0bfff17 	ldw	r2,-4(fp)
81141708:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8114170c:	e0bfff17 	ldw	r2,-4(fp)
81141710:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
81141714:	e0bfff17 	ldw	r2,-4(fp)
81141718:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8114171c:	e0bfff17 	ldw	r2,-4(fp)
81141720:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
81141724:	e0bfff17 	ldw	r2,-4(fp)
81141728:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8114172c:	e0bfff17 	ldw	r2,-4(fp)
81141730:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
81141734:	e0bfff17 	ldw	r2,-4(fp)
81141738:	00c00fc4 	movi	r3,63
8114173c:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
81141740:	e0bfff17 	ldw	r2,-4(fp)
81141744:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
81141748:	e0bfff17 	ldw	r2,-4(fp)
8114174c:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
81141750:	d0e08e17 	ldw	r3,-32200(gp)
81141754:	e0bfff17 	ldw	r2,-4(fp)
81141758:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8114175c:	e0bfff17 	ldw	r2,-4(fp)
81141760:	d0a08e15 	stw	r2,-32200(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81141764:	d0a0930b 	ldhu	r2,-32180(gp)
81141768:	10bfffc4 	addi	r2,r2,-1
8114176c:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFree++;
81141770:	d0a0970b 	ldhu	r2,-32164(gp)
81141774:	10800044 	addi	r2,r2,1
81141778:	d0a0970d 	sth	r2,-32164(gp)
}
8114177c:	0001883a 	nop
81141780:	e037883a 	mov	sp,fp
81141784:	df000017 	ldw	fp,0(sp)
81141788:	dec00104 	addi	sp,sp,4
8114178c:	f800283a 	ret

81141790 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
81141790:	defffa04 	addi	sp,sp,-24
81141794:	de00012e 	bgeu	sp,et,8114179c <OSTmr_Init+0xc>
81141798:	003b68fa 	trap	3
8114179c:	dfc00515 	stw	ra,20(sp)
811417a0:	df000415 	stw	fp,16(sp)
811417a4:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
811417a8:	01406804 	movi	r5,416
811417ac:	012045b4 	movhi	r4,33046
811417b0:	211d1504 	addi	r4,r4,29780
811417b4:	11399000 	call	81139900 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
811417b8:	01400404 	movi	r5,16
811417bc:	012045b4 	movhi	r4,33046
811417c0:	211b0104 	addi	r4,r4,27652
811417c4:	11399000 	call	81139900 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
811417c8:	00a045b4 	movhi	r2,33046
811417cc:	109d1504 	addi	r2,r2,29780
811417d0:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
811417d4:	00a045b4 	movhi	r2,33046
811417d8:	109d2204 	addi	r2,r2,29832
811417dc:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
811417e0:	e03ffc0d 	sth	zero,-16(fp)
811417e4:	00001606 	br	81141840 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
811417e8:	e0bffd17 	ldw	r2,-12(fp)
811417ec:	00c01904 	movi	r3,100
811417f0:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
811417f4:	e0bffd17 	ldw	r2,-12(fp)
811417f8:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
811417fc:	e0bffd17 	ldw	r2,-12(fp)
81141800:	e0fffe17 	ldw	r3,-8(fp)
81141804:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
81141808:	e0bffd17 	ldw	r2,-12(fp)
8114180c:	00c00fc4 	movi	r3,63
81141810:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81141814:	e0bffd17 	ldw	r2,-12(fp)
81141818:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8114181c:	e0bffd17 	ldw	r2,-12(fp)
81141820:	10800d04 	addi	r2,r2,52
81141824:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81141828:	e0bffe17 	ldw	r2,-8(fp)
8114182c:	10800d04 	addi	r2,r2,52
81141830:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81141834:	e0bffc0b 	ldhu	r2,-16(fp)
81141838:	10800044 	addi	r2,r2,1
8114183c:	e0bffc0d 	sth	r2,-16(fp)
81141840:	e0bffc0b 	ldhu	r2,-16(fp)
81141844:	108001f0 	cmpltui	r2,r2,7
81141848:	103fe71e 	bne	r2,zero,811417e8 <__reset+0xfb1217e8>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8114184c:	e0bffd17 	ldw	r2,-12(fp)
81141850:	00c01904 	movi	r3,100
81141854:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81141858:	e0bffd17 	ldw	r2,-12(fp)
8114185c:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81141860:	e0bffd17 	ldw	r2,-12(fp)
81141864:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81141868:	e0bffd17 	ldw	r2,-12(fp)
8114186c:	00c00fc4 	movi	r3,63
81141870:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81141874:	e0bffd17 	ldw	r2,-12(fp)
81141878:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8114187c:	d020a315 	stw	zero,-32116(gp)
    OSTmrUsed           = 0;
81141880:	d020930d 	sth	zero,-32180(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81141884:	00800204 	movi	r2,8
81141888:	d0a0970d 	sth	r2,-32164(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8114188c:	00a045b4 	movhi	r2,33046
81141890:	109d1504 	addi	r2,r2,29780
81141894:	d0a08e15 	stw	r2,-32200(gp)
    OSTmrSem            = OSSemCreate(1);
81141898:	01000044 	movi	r4,1
8114189c:	113e5540 	call	8113e554 <OSSemCreate>
811418a0:	d0a0a515 	stw	r2,-32108(gp)
    OSTmrSemSignal      = OSSemCreate(0);
811418a4:	0009883a 	mov	r4,zero
811418a8:	113e5540 	call	8113e554 <OSSemCreate>
811418ac:	d0a09015 	stw	r2,-32192(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
811418b0:	d0a0a517 	ldw	r2,-32108(gp)
811418b4:	e0ffff04 	addi	r3,fp,-4
811418b8:	180d883a 	mov	r6,r3
811418bc:	01604574 	movhi	r5,33045
811418c0:	2943c004 	addi	r5,r5,3840
811418c4:	1009883a 	mov	r4,r2
811418c8:	113815c0 	call	8113815c <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
811418cc:	d0a09017 	ldw	r2,-32192(gp)
811418d0:	e0ffff04 	addi	r3,fp,-4
811418d4:	180d883a 	mov	r6,r3
811418d8:	01604574 	movhi	r5,33045
811418dc:	2943c504 	addi	r5,r5,3860
811418e0:	1009883a 	mov	r4,r2
811418e4:	113815c0 	call	8113815c <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
811418e8:	11419040 	call	81141904 <OSTmr_InitTask>
}
811418ec:	0001883a 	nop
811418f0:	e037883a 	mov	sp,fp
811418f4:	dfc00117 	ldw	ra,4(sp)
811418f8:	df000017 	ldw	fp,0(sp)
811418fc:	dec00204 	addi	sp,sp,8
81141900:	f800283a 	ret

81141904 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81141904:	defff804 	addi	sp,sp,-32
81141908:	de00012e 	bgeu	sp,et,81141910 <OSTmr_InitTask+0xc>
8114190c:	003b68fa 	trap	3
81141910:	dfc00715 	stw	ra,28(sp)
81141914:	df000615 	stw	fp,24(sp)
81141918:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8114191c:	008000c4 	movi	r2,3
81141920:	d8800415 	stw	r2,16(sp)
81141924:	d8000315 	stw	zero,12(sp)
81141928:	00808004 	movi	r2,512
8114192c:	d8800215 	stw	r2,8(sp)
81141930:	00a045f4 	movhi	r2,33047
81141934:	10a54904 	addi	r2,r2,-27356
81141938:	d8800115 	stw	r2,4(sp)
8114193c:	00bfff54 	movui	r2,65533
81141940:	d8800015 	stw	r2,0(sp)
81141944:	01c00744 	movi	r7,29
81141948:	01a045f4 	movhi	r6,33047
8114194c:	31a74804 	addi	r6,r6,-25312
81141950:	000b883a 	mov	r5,zero
81141954:	01204534 	movhi	r4,33044
81141958:	21071604 	addi	r4,r4,7256
8114195c:	113f5e80 	call	8113f5e8 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81141960:	e1bfff04 	addi	r6,fp,-4
81141964:	01604574 	movhi	r5,33045
81141968:	2943ca04 	addi	r5,r5,3880
8114196c:	01000744 	movi	r4,29
81141970:	113fe180 	call	8113fe18 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81141974:	0001883a 	nop
81141978:	e037883a 	mov	sp,fp
8114197c:	dfc00117 	ldw	ra,4(sp)
81141980:	df000017 	ldw	fp,0(sp)
81141984:	dec00204 	addi	sp,sp,8
81141988:	f800283a 	ret

8114198c <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8114198c:	defffa04 	addi	sp,sp,-24
81141990:	de00012e 	bgeu	sp,et,81141998 <OSTmr_Link+0xc>
81141994:	003b68fa 	trap	3
81141998:	df000515 	stw	fp,20(sp)
8114199c:	df000504 	addi	fp,sp,20
811419a0:	e13ffe15 	stw	r4,-8(fp)
811419a4:	2805883a 	mov	r2,r5
811419a8:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
811419ac:	e0bffe17 	ldw	r2,-8(fp)
811419b0:	00c000c4 	movi	r3,3
811419b4:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
811419b8:	e0bfff03 	ldbu	r2,-4(fp)
811419bc:	10800058 	cmpnei	r2,r2,1
811419c0:	1000071e 	bne	r2,zero,811419e0 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
811419c4:	e0bffe17 	ldw	r2,-8(fp)
811419c8:	10c00717 	ldw	r3,28(r2)
811419cc:	d0a0a317 	ldw	r2,-32116(gp)
811419d0:	1887883a 	add	r3,r3,r2
811419d4:	e0bffe17 	ldw	r2,-8(fp)
811419d8:	10c00515 	stw	r3,20(r2)
811419dc:	00001006 	br	81141a20 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
811419e0:	e0bffe17 	ldw	r2,-8(fp)
811419e4:	10800617 	ldw	r2,24(r2)
811419e8:	1000071e 	bne	r2,zero,81141a08 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
811419ec:	e0bffe17 	ldw	r2,-8(fp)
811419f0:	10c00717 	ldw	r3,28(r2)
811419f4:	d0a0a317 	ldw	r2,-32116(gp)
811419f8:	1887883a 	add	r3,r3,r2
811419fc:	e0bffe17 	ldw	r2,-8(fp)
81141a00:	10c00515 	stw	r3,20(r2)
81141a04:	00000606 	br	81141a20 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81141a08:	e0bffe17 	ldw	r2,-8(fp)
81141a0c:	10c00617 	ldw	r3,24(r2)
81141a10:	d0a0a317 	ldw	r2,-32116(gp)
81141a14:	1887883a 	add	r3,r3,r2
81141a18:	e0bffe17 	ldw	r2,-8(fp)
81141a1c:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81141a20:	e0bffe17 	ldw	r2,-8(fp)
81141a24:	10800517 	ldw	r2,20(r2)
81141a28:	1080004c 	andi	r2,r2,1
81141a2c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81141a30:	e0bffb0b 	ldhu	r2,-20(fp)
81141a34:	100690fa 	slli	r3,r2,3
81141a38:	00a045b4 	movhi	r2,33046
81141a3c:	109b0104 	addi	r2,r2,27652
81141a40:	1885883a 	add	r2,r3,r2
81141a44:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81141a48:	e0bffc17 	ldw	r2,-16(fp)
81141a4c:	10800017 	ldw	r2,0(r2)
81141a50:	1000091e 	bne	r2,zero,81141a78 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81141a54:	e0bffc17 	ldw	r2,-16(fp)
81141a58:	e0fffe17 	ldw	r3,-8(fp)
81141a5c:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81141a60:	e0bffe17 	ldw	r2,-8(fp)
81141a64:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81141a68:	e0bffc17 	ldw	r2,-16(fp)
81141a6c:	00c00044 	movi	r3,1
81141a70:	10c0010d 	sth	r3,4(r2)
81141a74:	00001206 	br	81141ac0 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81141a78:	e0bffc17 	ldw	r2,-16(fp)
81141a7c:	10800017 	ldw	r2,0(r2)
81141a80:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
81141a84:	e0bffc17 	ldw	r2,-16(fp)
81141a88:	e0fffe17 	ldw	r3,-8(fp)
81141a8c:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81141a90:	e0bffe17 	ldw	r2,-8(fp)
81141a94:	e0fffd17 	ldw	r3,-12(fp)
81141a98:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
81141a9c:	e0bffd17 	ldw	r2,-12(fp)
81141aa0:	e0fffe17 	ldw	r3,-8(fp)
81141aa4:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81141aa8:	e0bffc17 	ldw	r2,-16(fp)
81141aac:	1080010b 	ldhu	r2,4(r2)
81141ab0:	10800044 	addi	r2,r2,1
81141ab4:	1007883a 	mov	r3,r2
81141ab8:	e0bffc17 	ldw	r2,-16(fp)
81141abc:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81141ac0:	e0bffe17 	ldw	r2,-8(fp)
81141ac4:	10000415 	stw	zero,16(r2)
}
81141ac8:	0001883a 	nop
81141acc:	e037883a 	mov	sp,fp
81141ad0:	df000017 	ldw	fp,0(sp)
81141ad4:	dec00104 	addi	sp,sp,4
81141ad8:	f800283a 	ret

81141adc <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
81141adc:	defffa04 	addi	sp,sp,-24
81141ae0:	de00012e 	bgeu	sp,et,81141ae8 <OSTmr_Unlink+0xc>
81141ae4:	003b68fa 	trap	3
81141ae8:	df000515 	stw	fp,20(sp)
81141aec:	df000504 	addi	fp,sp,20
81141af0:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81141af4:	e0bfff17 	ldw	r2,-4(fp)
81141af8:	10800517 	ldw	r2,20(r2)
81141afc:	1080004c 	andi	r2,r2,1
81141b00:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81141b04:	e0bffb0b 	ldhu	r2,-20(fp)
81141b08:	100690fa 	slli	r3,r2,3
81141b0c:	00a045b4 	movhi	r2,33046
81141b10:	109b0104 	addi	r2,r2,27652
81141b14:	1885883a 	add	r2,r3,r2
81141b18:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
81141b1c:	e0bffc17 	ldw	r2,-16(fp)
81141b20:	10c00017 	ldw	r3,0(r2)
81141b24:	e0bfff17 	ldw	r2,-4(fp)
81141b28:	18800b1e 	bne	r3,r2,81141b58 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
81141b2c:	e0bfff17 	ldw	r2,-4(fp)
81141b30:	10800317 	ldw	r2,12(r2)
81141b34:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81141b38:	e0bffc17 	ldw	r2,-16(fp)
81141b3c:	e0fffd17 	ldw	r3,-12(fp)
81141b40:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81141b44:	e0bffd17 	ldw	r2,-12(fp)
81141b48:	10001126 	beq	r2,zero,81141b90 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81141b4c:	e0bffd17 	ldw	r2,-12(fp)
81141b50:	10000415 	stw	zero,16(r2)
81141b54:	00000e06 	br	81141b90 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81141b58:	e0bfff17 	ldw	r2,-4(fp)
81141b5c:	10800417 	ldw	r2,16(r2)
81141b60:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
81141b64:	e0bfff17 	ldw	r2,-4(fp)
81141b68:	10800317 	ldw	r2,12(r2)
81141b6c:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
81141b70:	e0bffd17 	ldw	r2,-12(fp)
81141b74:	e0fffe17 	ldw	r3,-8(fp)
81141b78:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
81141b7c:	e0bffe17 	ldw	r2,-8(fp)
81141b80:	10000326 	beq	r2,zero,81141b90 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
81141b84:	e0bffe17 	ldw	r2,-8(fp)
81141b88:	e0fffd17 	ldw	r3,-12(fp)
81141b8c:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
81141b90:	e0bfff17 	ldw	r2,-4(fp)
81141b94:	00c00044 	movi	r3,1
81141b98:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
81141b9c:	e0bfff17 	ldw	r2,-4(fp)
81141ba0:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
81141ba4:	e0bfff17 	ldw	r2,-4(fp)
81141ba8:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
81141bac:	e0bffc17 	ldw	r2,-16(fp)
81141bb0:	1080010b 	ldhu	r2,4(r2)
81141bb4:	10bfffc4 	addi	r2,r2,-1
81141bb8:	1007883a 	mov	r3,r2
81141bbc:	e0bffc17 	ldw	r2,-16(fp)
81141bc0:	10c0010d 	sth	r3,4(r2)
}
81141bc4:	0001883a 	nop
81141bc8:	e037883a 	mov	sp,fp
81141bcc:	df000017 	ldw	fp,0(sp)
81141bd0:	dec00104 	addi	sp,sp,4
81141bd4:	f800283a 	ret

81141bd8 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81141bd8:	defffd04 	addi	sp,sp,-12
81141bdc:	de00012e 	bgeu	sp,et,81141be4 <OSTmr_Lock+0xc>
81141be0:	003b68fa 	trap	3
81141be4:	dfc00215 	stw	ra,8(sp)
81141be8:	df000115 	stw	fp,4(sp)
81141bec:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81141bf0:	d0a0a517 	ldw	r2,-32108(gp)
81141bf4:	e1bfff04 	addi	r6,fp,-4
81141bf8:	000b883a 	mov	r5,zero
81141bfc:	1009883a 	mov	r4,r2
81141c00:	113e87c0 	call	8113e87c <OSSemPend>
    (void)err;
}
81141c04:	0001883a 	nop
81141c08:	e037883a 	mov	sp,fp
81141c0c:	dfc00117 	ldw	ra,4(sp)
81141c10:	df000017 	ldw	fp,0(sp)
81141c14:	dec00204 	addi	sp,sp,8
81141c18:	f800283a 	ret

81141c1c <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
81141c1c:	defffe04 	addi	sp,sp,-8
81141c20:	de00012e 	bgeu	sp,et,81141c28 <OSTmr_Unlock+0xc>
81141c24:	003b68fa 	trap	3
81141c28:	dfc00115 	stw	ra,4(sp)
81141c2c:	df000015 	stw	fp,0(sp)
81141c30:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
81141c34:	d0a0a517 	ldw	r2,-32108(gp)
81141c38:	1009883a 	mov	r4,r2
81141c3c:	113ec040 	call	8113ec04 <OSSemPost>
}
81141c40:	0001883a 	nop
81141c44:	e037883a 	mov	sp,fp
81141c48:	dfc00117 	ldw	ra,4(sp)
81141c4c:	df000017 	ldw	fp,0(sp)
81141c50:	dec00204 	addi	sp,sp,8
81141c54:	f800283a 	ret

81141c58 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
81141c58:	defff704 	addi	sp,sp,-36
81141c5c:	de00012e 	bgeu	sp,et,81141c64 <OSTmr_Task+0xc>
81141c60:	003b68fa 	trap	3
81141c64:	dfc00815 	stw	ra,32(sp)
81141c68:	df000715 	stw	fp,28(sp)
81141c6c:	df000704 	addi	fp,sp,28
81141c70:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
81141c74:	d0a09017 	ldw	r2,-32192(gp)
81141c78:	e0fffe04 	addi	r3,fp,-8
81141c7c:	180d883a 	mov	r6,r3
81141c80:	000b883a 	mov	r5,zero
81141c84:	1009883a 	mov	r4,r2
81141c88:	113e87c0 	call	8113e87c <OSSemPend>
        OSTmr_Lock();
81141c8c:	1141bd80 	call	81141bd8 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
81141c90:	d0a0a317 	ldw	r2,-32116(gp)
81141c94:	10800044 	addi	r2,r2,1
81141c98:	d0a0a315 	stw	r2,-32116(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
81141c9c:	d0a0a317 	ldw	r2,-32116(gp)
81141ca0:	1080004c 	andi	r2,r2,1
81141ca4:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
81141ca8:	e0bffa0b 	ldhu	r2,-24(fp)
81141cac:	100690fa 	slli	r3,r2,3
81141cb0:	00a045b4 	movhi	r2,33046
81141cb4:	109b0104 	addi	r2,r2,27652
81141cb8:	1885883a 	add	r2,r3,r2
81141cbc:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81141cc0:	e0bffb17 	ldw	r2,-20(fp)
81141cc4:	10800017 	ldw	r2,0(r2)
81141cc8:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81141ccc:	00002206 	br	81141d58 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81141cd0:	e0bff917 	ldw	r2,-28(fp)
81141cd4:	10800317 	ldw	r2,12(r2)
81141cd8:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81141cdc:	e0bff917 	ldw	r2,-28(fp)
81141ce0:	10c00517 	ldw	r3,20(r2)
81141ce4:	d0a0a317 	ldw	r2,-32116(gp)
81141ce8:	1880191e 	bne	r3,r2,81141d50 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81141cec:	e0bff917 	ldw	r2,-28(fp)
81141cf0:	10800117 	ldw	r2,4(r2)
81141cf4:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81141cf8:	e0bffd17 	ldw	r2,-12(fp)
81141cfc:	10000626 	beq	r2,zero,81141d18 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81141d00:	e0bff917 	ldw	r2,-28(fp)
81141d04:	10c00217 	ldw	r3,8(r2)
81141d08:	e0bffd17 	ldw	r2,-12(fp)
81141d0c:	180b883a 	mov	r5,r3
81141d10:	e13ff917 	ldw	r4,-28(fp)
81141d14:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81141d18:	e13ff917 	ldw	r4,-28(fp)
81141d1c:	1141adc0 	call	81141adc <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81141d20:	e0bff917 	ldw	r2,-28(fp)
81141d24:	10800c03 	ldbu	r2,48(r2)
81141d28:	10803fcc 	andi	r2,r2,255
81141d2c:	10800098 	cmpnei	r2,r2,2
81141d30:	1000041e 	bne	r2,zero,81141d44 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
81141d34:	01400044 	movi	r5,1
81141d38:	e13ff917 	ldw	r4,-28(fp)
81141d3c:	114198c0 	call	8114198c <OSTmr_Link>
81141d40:	00000306 	br	81141d50 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
81141d44:	e0bff917 	ldw	r2,-28(fp)
81141d48:	00c00084 	movi	r3,2
81141d4c:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
81141d50:	e0bffc17 	ldw	r2,-16(fp)
81141d54:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
81141d58:	e0bff917 	ldw	r2,-28(fp)
81141d5c:	103fdc1e 	bne	r2,zero,81141cd0 <__reset+0xfb121cd0>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
81141d60:	1141c1c0 	call	81141c1c <OSTmr_Unlock>
    }
81141d64:	003fc306 	br	81141c74 <__reset+0xfb121c74>

81141d68 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81141d68:	defffd04 	addi	sp,sp,-12
81141d6c:	de00012e 	bgeu	sp,et,81141d74 <alt_dev_reg+0xc>
81141d70:	003b68fa 	trap	3
81141d74:	dfc00215 	stw	ra,8(sp)
81141d78:	df000115 	stw	fp,4(sp)
81141d7c:	df000104 	addi	fp,sp,4
81141d80:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
81141d84:	d1600d04 	addi	r5,gp,-32716
81141d88:	e13fff17 	ldw	r4,-4(fp)
81141d8c:	114a0080 	call	8114a008 <alt_dev_llist_insert>
}
81141d90:	e037883a 	mov	sp,fp
81141d94:	dfc00117 	ldw	ra,4(sp)
81141d98:	df000017 	ldw	fp,0(sp)
81141d9c:	dec00204 	addi	sp,sp,8
81141da0:	f800283a 	ret

81141da4 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
81141da4:	defffd04 	addi	sp,sp,-12
81141da8:	de00012e 	bgeu	sp,et,81141db0 <alt_irq_init+0xc>
81141dac:	003b68fa 	trap	3
81141db0:	dfc00215 	stw	ra,8(sp)
81141db4:	df000115 	stw	fp,4(sp)
81141db8:	df000104 	addi	fp,sp,4
81141dbc:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81141dc0:	114a9d00 	call	8114a9d0 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81141dc4:	00800044 	movi	r2,1
81141dc8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81141dcc:	0001883a 	nop
81141dd0:	e037883a 	mov	sp,fp
81141dd4:	dfc00117 	ldw	ra,4(sp)
81141dd8:	df000017 	ldw	fp,0(sp)
81141ddc:	dec00204 	addi	sp,sp,8
81141de0:	f800283a 	ret

81141de4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81141de4:	defffe04 	addi	sp,sp,-8
81141de8:	de00012e 	bgeu	sp,et,81141df0 <alt_sys_init+0xc>
81141dec:	003b68fa 	trap	3
81141df0:	dfc00115 	stw	ra,4(sp)
81141df4:	df000015 	stw	fp,0(sp)
81141df8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
81141dfc:	01c0fa04 	movi	r7,1000
81141e00:	01800304 	movi	r6,12
81141e04:	000b883a 	mov	r5,zero
81141e08:	01200034 	movhi	r4,32768
81141e0c:	21022004 	addi	r4,r4,2176
81141e10:	114713c0 	call	8114713c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
81141e14:	018002c4 	movi	r6,11
81141e18:	000b883a 	mov	r5,zero
81141e1c:	01204574 	movhi	r4,33045
81141e20:	21076604 	addi	r4,r4,7576
81141e24:	11464280 	call	81146428 <altera_avalon_jtag_uart_init>
81141e28:	01204574 	movhi	r4,33045
81141e2c:	21075c04 	addi	r4,r4,7536
81141e30:	1141d680 	call	81141d68 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
81141e34:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
81141e38:	018003c4 	movi	r6,15
81141e3c:	000b883a 	mov	r5,zero
81141e40:	01204574 	movhi	r4,33045
81141e44:	210b8104 	addi	r4,r4,11780
81141e48:	11472e80 	call	811472e8 <altera_avalon_uart_init>
81141e4c:	01204574 	movhi	r4,33045
81141e50:	210b7704 	addi	r4,r4,11740
81141e54:	1141d680 	call	81141d68 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
81141e58:	00a04574 	movhi	r2,33045
81141e5c:	108bab04 	addi	r2,r2,11948
81141e60:	10c00717 	ldw	r3,28(r2)
81141e64:	00a04574 	movhi	r2,33045
81141e68:	108bab04 	addi	r2,r2,11948
81141e6c:	10800817 	ldw	r2,32(r2)
81141e70:	100d883a 	mov	r6,r2
81141e74:	180b883a 	mov	r5,r3
81141e78:	01204574 	movhi	r4,33045
81141e7c:	210bab04 	addi	r4,r4,11948
81141e80:	1149b700 	call	81149b70 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
81141e84:	00a04574 	movhi	r2,33045
81141e88:	108bc404 	addi	r2,r2,12048
81141e8c:	10c00717 	ldw	r3,28(r2)
81141e90:	00a04574 	movhi	r2,33045
81141e94:	108bc404 	addi	r2,r2,12048
81141e98:	10800817 	ldw	r2,32(r2)
81141e9c:	100d883a 	mov	r6,r2
81141ea0:	180b883a 	mov	r5,r3
81141ea4:	01204574 	movhi	r4,33045
81141ea8:	210bc404 	addi	r4,r4,12048
81141eac:	1149b700 	call	81149b70 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81141eb0:	01204574 	movhi	r4,33045
81141eb4:	210bdd04 	addi	r4,r4,12148
81141eb8:	1141d680 	call	81141d68 <alt_dev_reg>
}
81141ebc:	0001883a 	nop
81141ec0:	e037883a 	mov	sp,fp
81141ec4:	dfc00117 	ldw	ra,4(sp)
81141ec8:	df000017 	ldw	fp,0(sp)
81141ecc:	dec00204 	addi	sp,sp,8
81141ed0:	f800283a 	ret

81141ed4 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
81141ed4:	defffa04 	addi	sp,sp,-24
81141ed8:	de00012e 	bgeu	sp,et,81141ee0 <Write_Sector_Data+0xc>
81141edc:	003b68fa 	trap	3
81141ee0:	dfc00515 	stw	ra,20(sp)
81141ee4:	df000415 	stw	fp,16(sp)
81141ee8:	df000404 	addi	fp,sp,16
81141eec:	e13ffe15 	stw	r4,-8(fp)
81141ef0:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81141ef4:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81141ef8:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
81141efc:	10001e26 	beq	r2,zero,81141f78 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
81141f00:	00803fc4 	movi	r2,255
81141f04:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81141f08:	d0a0af17 	ldw	r2,-32068(gp)
81141f0c:	e13ffe17 	ldw	r4,-8(fp)
81141f10:	e0ffff17 	ldw	r3,-4(fp)
81141f14:	20c7883a 	add	r3,r4,r3
81141f18:	1806927a 	slli	r3,r3,9
81141f1c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
81141f20:	d0a0ae17 	ldw	r2,-32072(gp)
81141f24:	00c00604 	movi	r3,24
81141f28:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81141f2c:	d0a0ab17 	ldw	r2,-32084(gp)
81141f30:	1080002b 	ldhuio	r2,0(r2)
81141f34:	10bfffcc 	andi	r2,r2,65535
81141f38:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
81141f3c:	e0bffd0b 	ldhu	r2,-12(fp)
81141f40:	10bfffcc 	andi	r2,r2,65535
81141f44:	1080010c 	andi	r2,r2,4
81141f48:	103ff81e 	bne	r2,zero,81141f2c <__reset+0xfb121f2c>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
81141f4c:	e0bffd0b 	ldhu	r2,-12(fp)
81141f50:	10bfffcc 	andi	r2,r2,65535
81141f54:	1080040c 	andi	r2,r2,16
81141f58:	1000071e 	bne	r2,zero,81141f78 <Write_Sector_Data+0xa4>
        {
            result = true;
81141f5c:	00800044 	movi	r2,1
81141f60:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81141f64:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
81141f68:	e0fffe17 	ldw	r3,-8(fp)
81141f6c:	e0bfff17 	ldw	r2,-4(fp)
81141f70:	1885883a 	add	r2,r3,r2
81141f74:	d0a0b515 	stw	r2,-32044(gp)
        }
    }
    return result;
81141f78:	e0bffc17 	ldw	r2,-16(fp)
}
81141f7c:	e037883a 	mov	sp,fp
81141f80:	dfc00117 	ldw	ra,4(sp)
81141f84:	df000017 	ldw	fp,0(sp)
81141f88:	dec00204 	addi	sp,sp,8
81141f8c:	f800283a 	ret

81141f90 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
81141f90:	defffd04 	addi	sp,sp,-12
81141f94:	de00012e 	bgeu	sp,et,81141f9c <Save_Modified_Sector+0xc>
81141f98:	003b68fa 	trap	3
81141f9c:	dfc00215 	stw	ra,8(sp)
81141fa0:	df000115 	stw	fp,4(sp)
81141fa4:	df000104 	addi	fp,sp,4
    bool result = true;
81141fa8:	00800044 	movi	r2,1
81141fac:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81141fb0:	d0a0b417 	ldw	r2,-32048(gp)
81141fb4:	10000526 	beq	r2,zero,81141fcc <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81141fb8:	d0a0b517 	ldw	r2,-32044(gp)
81141fbc:	000b883a 	mov	r5,zero
81141fc0:	1009883a 	mov	r4,r2
81141fc4:	1141ed40 	call	81141ed4 <Write_Sector_Data>
81141fc8:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81141fcc:	e0bfff17 	ldw	r2,-4(fp)
}
81141fd0:	e037883a 	mov	sp,fp
81141fd4:	dfc00117 	ldw	ra,4(sp)
81141fd8:	df000017 	ldw	fp,0(sp)
81141fdc:	dec00204 	addi	sp,sp,8
81141fe0:	f800283a 	ret

81141fe4 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
81141fe4:	defffa04 	addi	sp,sp,-24
81141fe8:	de00012e 	bgeu	sp,et,81141ff0 <Read_Sector_Data+0xc>
81141fec:	003b68fa 	trap	3
81141ff0:	dfc00515 	stw	ra,20(sp)
81141ff4:	df000415 	stw	fp,16(sp)
81141ff8:	df000404 	addi	fp,sp,16
81141ffc:	e13ffe15 	stw	r4,-8(fp)
81142000:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
81142004:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
81142008:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
8114200c:	10002726 	beq	r2,zero,811420ac <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
81142010:	00803fc4 	movi	r2,255
81142014:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
81142018:	d0a0b417 	ldw	r2,-32048(gp)
8114201c:	10000726 	beq	r2,zero,8114203c <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
81142020:	d0a0b517 	ldw	r2,-32044(gp)
81142024:	000b883a 	mov	r5,zero
81142028:	1009883a 	mov	r4,r2
8114202c:	1141ed40 	call	81141ed4 <Write_Sector_Data>
81142030:	1000021e 	bne	r2,zero,8114203c <Read_Sector_Data+0x58>
            {
                return false;
81142034:	0005883a 	mov	r2,zero
81142038:	00001d06 	br	811420b0 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8114203c:	d0a0af17 	ldw	r2,-32068(gp)
81142040:	e13ffe17 	ldw	r4,-8(fp)
81142044:	e0ffff17 	ldw	r3,-4(fp)
81142048:	20c7883a 	add	r3,r4,r3
8114204c:	1806927a 	slli	r3,r3,9
81142050:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
81142054:	d0a0ae17 	ldw	r2,-32072(gp)
81142058:	00c00444 	movi	r3,17
8114205c:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81142060:	d0a0ab17 	ldw	r2,-32084(gp)
81142064:	1080002b 	ldhuio	r2,0(r2)
81142068:	10bfffcc 	andi	r2,r2,65535
8114206c:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
81142070:	e0bffd0b 	ldhu	r2,-12(fp)
81142074:	10bfffcc 	andi	r2,r2,65535
81142078:	1080010c 	andi	r2,r2,4
8114207c:	103ff81e 	bne	r2,zero,81142060 <__reset+0xfb122060>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
81142080:	e0bffd0b 	ldhu	r2,-12(fp)
81142084:	10bfffcc 	andi	r2,r2,65535
81142088:	1080040c 	andi	r2,r2,16
8114208c:	1000071e 	bne	r2,zero,811420ac <Read_Sector_Data+0xc8>
		{
			result = true;
81142090:	00800044 	movi	r2,1
81142094:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81142098:	d020b415 	stw	zero,-32048(gp)
            current_sector_index = sector_index+partition_offset;
8114209c:	e0fffe17 	ldw	r3,-8(fp)
811420a0:	e0bfff17 	ldw	r2,-4(fp)
811420a4:	1885883a 	add	r2,r3,r2
811420a8:	d0a0b515 	stw	r2,-32044(gp)
		}
	}
	return result;
811420ac:	e0bffc17 	ldw	r2,-16(fp)
}
811420b0:	e037883a 	mov	sp,fp
811420b4:	dfc00117 	ldw	ra,4(sp)
811420b8:	df000017 	ldw	fp,0(sp)
811420bc:	dec00204 	addi	sp,sp,8
811420c0:	f800283a 	ret

811420c4 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
811420c4:	defffb04 	addi	sp,sp,-20
811420c8:	de00012e 	bgeu	sp,et,811420d0 <get_cluster_flag+0xc>
811420cc:	003b68fa 	trap	3
811420d0:	dfc00415 	stw	ra,16(sp)
811420d4:	df000315 	stw	fp,12(sp)
811420d8:	df000304 	addi	fp,sp,12
811420dc:	e13ffe15 	stw	r4,-8(fp)
811420e0:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
811420e4:	e0bffe17 	ldw	r2,-8(fp)
811420e8:	1004d23a 	srli	r2,r2,8
811420ec:	d0e0b117 	ldw	r3,-32060(gp)
811420f0:	10c5883a 	add	r2,r2,r3
811420f4:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
811420f8:	00a045f4 	movhi	r2,33047
811420fc:	10b32704 	addi	r2,r2,-13156
81142100:	10801117 	ldw	r2,68(r2)
81142104:	e0fffd17 	ldw	r3,-12(fp)
81142108:	1885883a 	add	r2,r3,r2
8114210c:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
81142110:	d0a0b517 	ldw	r2,-32044(gp)
81142114:	e0fffd17 	ldw	r3,-12(fp)
81142118:	18800726 	beq	r3,r2,81142138 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8114211c:	e0bffd17 	ldw	r2,-12(fp)
81142120:	000b883a 	mov	r5,zero
81142124:	1009883a 	mov	r4,r2
81142128:	1141fe40 	call	81141fe4 <Read_Sector_Data>
8114212c:	1000021e 	bne	r2,zero,81142138 <get_cluster_flag+0x74>
        {
            return false;
81142130:	0005883a 	mov	r2,zero
81142134:	00000d06 	br	8114216c <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
81142138:	e0bffe17 	ldw	r2,-8(fp)
8114213c:	10803fcc 	andi	r2,r2,255
81142140:	1085883a 	add	r2,r2,r2
81142144:	1007883a 	mov	r3,r2
81142148:	d0a0b317 	ldw	r2,-32052(gp)
8114214c:	10800a17 	ldw	r2,40(r2)
81142150:	1885883a 	add	r2,r3,r2
81142154:	1080002b 	ldhuio	r2,0(r2)
81142158:	10bfffcc 	andi	r2,r2,65535
8114215c:	1007883a 	mov	r3,r2
81142160:	e0bfff17 	ldw	r2,-4(fp)
81142164:	10c0000d 	sth	r3,0(r2)
    return true;
81142168:	00800044 	movi	r2,1
}
8114216c:	e037883a 	mov	sp,fp
81142170:	dfc00117 	ldw	ra,4(sp)
81142174:	df000017 	ldw	fp,0(sp)
81142178:	dec00204 	addi	sp,sp,8
8114217c:	f800283a 	ret

81142180 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
81142180:	defffa04 	addi	sp,sp,-24
81142184:	de00012e 	bgeu	sp,et,8114218c <mark_cluster+0xc>
81142188:	003b68fa 	trap	3
8114218c:	dfc00515 	stw	ra,20(sp)
81142190:	df000415 	stw	fp,16(sp)
81142194:	df000404 	addi	fp,sp,16
81142198:	e13ffd15 	stw	r4,-12(fp)
8114219c:	2805883a 	mov	r2,r5
811421a0:	e1bfff15 	stw	r6,-4(fp)
811421a4:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
811421a8:	e0bffd17 	ldw	r2,-12(fp)
811421ac:	1004d23a 	srli	r2,r2,8
811421b0:	d0e0b117 	ldw	r3,-32060(gp)
811421b4:	10c5883a 	add	r2,r2,r3
811421b8:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
811421bc:	e0bfff17 	ldw	r2,-4(fp)
811421c0:	10000726 	beq	r2,zero,811421e0 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
811421c4:	00a045f4 	movhi	r2,33047
811421c8:	10b32704 	addi	r2,r2,-13156
811421cc:	10801117 	ldw	r2,68(r2)
811421d0:	e0fffc17 	ldw	r3,-16(fp)
811421d4:	1885883a 	add	r2,r3,r2
811421d8:	e0bffc15 	stw	r2,-16(fp)
811421dc:	00000606 	br	811421f8 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
811421e0:	00a045f4 	movhi	r2,33047
811421e4:	10b32704 	addi	r2,r2,-13156
811421e8:	10801217 	ldw	r2,72(r2)
811421ec:	e0fffc17 	ldw	r3,-16(fp)
811421f0:	1885883a 	add	r2,r3,r2
811421f4:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
811421f8:	d0a0b517 	ldw	r2,-32044(gp)
811421fc:	e0fffc17 	ldw	r3,-16(fp)
81142200:	18800726 	beq	r3,r2,81142220 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81142204:	e0bffc17 	ldw	r2,-16(fp)
81142208:	000b883a 	mov	r5,zero
8114220c:	1009883a 	mov	r4,r2
81142210:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81142214:	1000021e 	bne	r2,zero,81142220 <mark_cluster+0xa0>
        {
            return false;
81142218:	0005883a 	mov	r2,zero
8114221c:	00000d06 	br	81142254 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
81142220:	e0bffd17 	ldw	r2,-12(fp)
81142224:	10803fcc 	andi	r2,r2,255
81142228:	1085883a 	add	r2,r2,r2
8114222c:	1007883a 	mov	r3,r2
81142230:	d0a0b317 	ldw	r2,-32052(gp)
81142234:	10800a17 	ldw	r2,40(r2)
81142238:	1885883a 	add	r2,r3,r2
8114223c:	1007883a 	mov	r3,r2
81142240:	e0bffe0f 	ldh	r2,-8(fp)
81142244:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
81142248:	00800044 	movi	r2,1
8114224c:	d0a0b415 	stw	r2,-32048(gp)
    return true;
81142250:	00800044 	movi	r2,1
}
81142254:	e037883a 	mov	sp,fp
81142258:	dfc00117 	ldw	ra,4(sp)
8114225c:	df000017 	ldw	fp,0(sp)
81142260:	dec00204 	addi	sp,sp,8
81142264:	f800283a 	ret

81142268 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81142268:	defff704 	addi	sp,sp,-36
8114226c:	de00012e 	bgeu	sp,et,81142274 <Check_for_Master_Boot_Record+0xc>
81142270:	003b68fa 	trap	3
81142274:	dfc00815 	stw	ra,32(sp)
81142278:	df000715 	stw	fp,28(sp)
8114227c:	df000704 	addi	fp,sp,28
	bool result = false;
81142280:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
81142284:	000b883a 	mov	r5,zero
81142288:	0009883a 	mov	r4,zero
8114228c:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81142290:	10005a26 	beq	r2,zero,811423fc <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
81142294:	d0a0b317 	ldw	r2,-32052(gp)
81142298:	10800a17 	ldw	r2,40(r2)
8114229c:	10807f84 	addi	r2,r2,510
811422a0:	1080002b 	ldhuio	r2,0(r2)
811422a4:	10bfffcc 	andi	r2,r2,65535
811422a8:	10bfffcc 	andi	r2,r2,65535
811422ac:	10a0001c 	xori	r2,r2,32768
811422b0:	10a00004 	addi	r2,r2,-32768
811422b4:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
811422b8:	e0bffb17 	ldw	r2,-20(fp)
811422bc:	10ffffcc 	andi	r3,r2,65535
811422c0:	00aa9554 	movui	r2,43605
811422c4:	18804d1e 	bne	r3,r2,811423fc <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
811422c8:	e03ffa15 	stw	zero,-24(fp)
811422cc:	00004806 	br	811423f0 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
811422d0:	e0bffa17 	ldw	r2,-24(fp)
811422d4:	1004913a 	slli	r2,r2,4
811422d8:	10806f84 	addi	r2,r2,446
811422dc:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
811422e0:	d0a0b317 	ldw	r2,-32052(gp)
811422e4:	10c00a17 	ldw	r3,40(r2)
811422e8:	e0bffc17 	ldw	r2,-16(fp)
811422ec:	1885883a 	add	r2,r3,r2
811422f0:	10800104 	addi	r2,r2,4
811422f4:	10800023 	ldbuio	r2,0(r2)
811422f8:	10803fcc 	andi	r2,r2,255
811422fc:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
81142300:	e0bffd07 	ldb	r2,-12(fp)
81142304:	10800060 	cmpeqi	r2,r2,1
81142308:	1000091e 	bne	r2,zero,81142330 <Check_for_Master_Boot_Record+0xc8>
8114230c:	e0bffd07 	ldb	r2,-12(fp)
81142310:	10800120 	cmpeqi	r2,r2,4
81142314:	1000061e 	bne	r2,zero,81142330 <Check_for_Master_Boot_Record+0xc8>
81142318:	e0bffd07 	ldb	r2,-12(fp)
8114231c:	108001a0 	cmpeqi	r2,r2,6
81142320:	1000031e 	bne	r2,zero,81142330 <Check_for_Master_Boot_Record+0xc8>
81142324:	e0bffd07 	ldb	r2,-12(fp)
81142328:	10800398 	cmpnei	r2,r2,14
8114232c:	10002d1e 	bne	r2,zero,811423e4 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
81142330:	d0a0b317 	ldw	r2,-32052(gp)
81142334:	10c00a17 	ldw	r3,40(r2)
81142338:	e0bffc17 	ldw	r2,-16(fp)
8114233c:	1885883a 	add	r2,r3,r2
81142340:	10800284 	addi	r2,r2,10
81142344:	1080002b 	ldhuio	r2,0(r2)
81142348:	10bfffcc 	andi	r2,r2,65535
8114234c:	1006943a 	slli	r3,r2,16
81142350:	d0a0b317 	ldw	r2,-32052(gp)
81142354:	11000a17 	ldw	r4,40(r2)
81142358:	e0bffc17 	ldw	r2,-16(fp)
8114235c:	2085883a 	add	r2,r4,r2
81142360:	10800204 	addi	r2,r2,8
81142364:	1080002b 	ldhuio	r2,0(r2)
81142368:	10bfffcc 	andi	r2,r2,65535
8114236c:	10bfffcc 	andi	r2,r2,65535
81142370:	1884b03a 	or	r2,r3,r2
81142374:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81142378:	d0a0b317 	ldw	r2,-32052(gp)
8114237c:	10c00a17 	ldw	r3,40(r2)
81142380:	e0bffc17 	ldw	r2,-16(fp)
81142384:	1885883a 	add	r2,r3,r2
81142388:	10800384 	addi	r2,r2,14
8114238c:	1080002b 	ldhuio	r2,0(r2)
81142390:	10bfffcc 	andi	r2,r2,65535
81142394:	1006943a 	slli	r3,r2,16
81142398:	d0a0b317 	ldw	r2,-32052(gp)
8114239c:	11000a17 	ldw	r4,40(r2)
811423a0:	e0bffc17 	ldw	r2,-16(fp)
811423a4:	2085883a 	add	r2,r4,r2
811423a8:	10800304 	addi	r2,r2,12
811423ac:	1080002b 	ldhuio	r2,0(r2)
811423b0:	10bfffcc 	andi	r2,r2,65535
811423b4:	10bfffcc 	andi	r2,r2,65535
811423b8:	1884b03a 	or	r2,r3,r2
811423bc:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
811423c0:	e0bfff17 	ldw	r2,-4(fp)
811423c4:	0080070e 	bge	zero,r2,811423e4 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
811423c8:	00800044 	movi	r2,1
811423cc:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
811423d0:	e0bfff17 	ldw	r2,-4(fp)
811423d4:	d0a0b215 	stw	r2,-32056(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
811423d8:	e0bffe17 	ldw	r2,-8(fp)
811423dc:	d0a0b115 	stw	r2,-32060(gp)
						break;
811423e0:	00000606 	br	811423fc <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
811423e4:	e0bffa17 	ldw	r2,-24(fp)
811423e8:	10800044 	addi	r2,r2,1
811423ec:	e0bffa15 	stw	r2,-24(fp)
811423f0:	e0bffa17 	ldw	r2,-24(fp)
811423f4:	10800110 	cmplti	r2,r2,4
811423f8:	103fb51e 	bne	r2,zero,811422d0 <__reset+0xfb1222d0>
				}
			}
		}
	}

	return result;
811423fc:	e0bff917 	ldw	r2,-28(fp)
}
81142400:	e037883a 	mov	sp,fp
81142404:	dfc00117 	ldw	ra,4(sp)
81142408:	df000017 	ldw	fp,0(sp)
8114240c:	dec00204 	addi	sp,sp,8
81142410:	f800283a 	ret

81142414 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
81142414:	defff804 	addi	sp,sp,-32
81142418:	de00012e 	bgeu	sp,et,81142420 <Read_File_Record_At_Offset+0xc>
8114241c:	003b68fa 	trap	3
81142420:	dfc00715 	stw	ra,28(sp)
81142424:	df000615 	stw	fp,24(sp)
81142428:	df000604 	addi	fp,sp,24
8114242c:	e13ffc15 	stw	r4,-16(fp)
81142430:	e17ffd15 	stw	r5,-12(fp)
81142434:	e1bffe15 	stw	r6,-8(fp)
81142438:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8114243c:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81142440:	e0bffc17 	ldw	r2,-16(fp)
81142444:	108007cc 	andi	r2,r2,31
81142448:	10008d1e 	bne	r2,zero,81142680 <Read_File_Record_At_Offset+0x26c>
8114244c:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
81142450:	10008b26 	beq	r2,zero,81142680 <Read_File_Record_At_Offset+0x26c>
81142454:	d0a0aa17 	ldw	r2,-32088(gp)
81142458:	10008926 	beq	r2,zero,81142680 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8114245c:	e03ffb15 	stw	zero,-20(fp)
81142460:	00001106 	br	811424a8 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
81142464:	e0fffc17 	ldw	r3,-16(fp)
81142468:	e0bffb17 	ldw	r2,-20(fp)
8114246c:	1885883a 	add	r2,r3,r2
81142470:	1007883a 	mov	r3,r2
81142474:	d0a0b317 	ldw	r2,-32052(gp)
81142478:	10800a17 	ldw	r2,40(r2)
8114247c:	1885883a 	add	r2,r3,r2
81142480:	10800023 	ldbuio	r2,0(r2)
81142484:	10803fcc 	andi	r2,r2,255
81142488:	1009883a 	mov	r4,r2
8114248c:	e0fffd17 	ldw	r3,-12(fp)
81142490:	e0bffb17 	ldw	r2,-20(fp)
81142494:	1885883a 	add	r2,r3,r2
81142498:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8114249c:	e0bffb17 	ldw	r2,-20(fp)
811424a0:	10800044 	addi	r2,r2,1
811424a4:	e0bffb15 	stw	r2,-20(fp)
811424a8:	e0bffb17 	ldw	r2,-20(fp)
811424ac:	10800210 	cmplti	r2,r2,8
811424b0:	103fec1e 	bne	r2,zero,81142464 <__reset+0xfb122464>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
811424b4:	e03ffb15 	stw	zero,-20(fp)
811424b8:	00001306 	br	81142508 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
811424bc:	e0fffc17 	ldw	r3,-16(fp)
811424c0:	e0bffb17 	ldw	r2,-20(fp)
811424c4:	1885883a 	add	r2,r3,r2
811424c8:	1007883a 	mov	r3,r2
811424cc:	d0a0b317 	ldw	r2,-32052(gp)
811424d0:	10800a17 	ldw	r2,40(r2)
811424d4:	1885883a 	add	r2,r3,r2
811424d8:	10800204 	addi	r2,r2,8
811424dc:	10800023 	ldbuio	r2,0(r2)
811424e0:	10803fcc 	andi	r2,r2,255
811424e4:	1009883a 	mov	r4,r2
811424e8:	e0fffd17 	ldw	r3,-12(fp)
811424ec:	e0bffb17 	ldw	r2,-20(fp)
811424f0:	1885883a 	add	r2,r3,r2
811424f4:	10800204 	addi	r2,r2,8
811424f8:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
811424fc:	e0bffb17 	ldw	r2,-20(fp)
81142500:	10800044 	addi	r2,r2,1
81142504:	e0bffb15 	stw	r2,-20(fp)
81142508:	e0bffb17 	ldw	r2,-20(fp)
8114250c:	108000d0 	cmplti	r2,r2,3
81142510:	103fea1e 	bne	r2,zero,811424bc <__reset+0xfb1224bc>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
81142514:	d0a0b317 	ldw	r2,-32052(gp)
81142518:	10c00a17 	ldw	r3,40(r2)
8114251c:	e0bffc17 	ldw	r2,-16(fp)
81142520:	1885883a 	add	r2,r3,r2
81142524:	108002c4 	addi	r2,r2,11
81142528:	10800023 	ldbuio	r2,0(r2)
8114252c:	10803fcc 	andi	r2,r2,255
81142530:	1007883a 	mov	r3,r2
81142534:	e0bffd17 	ldw	r2,-12(fp)
81142538:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8114253c:	d0a0b317 	ldw	r2,-32052(gp)
81142540:	10c00a17 	ldw	r3,40(r2)
81142544:	e0bffc17 	ldw	r2,-16(fp)
81142548:	1885883a 	add	r2,r3,r2
8114254c:	10800384 	addi	r2,r2,14
81142550:	1080002b 	ldhuio	r2,0(r2)
81142554:	10bfffcc 	andi	r2,r2,65535
81142558:	1007883a 	mov	r3,r2
8114255c:	e0bffd17 	ldw	r2,-12(fp)
81142560:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
81142564:	d0a0b317 	ldw	r2,-32052(gp)
81142568:	10c00a17 	ldw	r3,40(r2)
8114256c:	e0bffc17 	ldw	r2,-16(fp)
81142570:	1885883a 	add	r2,r3,r2
81142574:	10800404 	addi	r2,r2,16
81142578:	1080002b 	ldhuio	r2,0(r2)
8114257c:	10bfffcc 	andi	r2,r2,65535
81142580:	1007883a 	mov	r3,r2
81142584:	e0bffd17 	ldw	r2,-12(fp)
81142588:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8114258c:	d0a0b317 	ldw	r2,-32052(gp)
81142590:	10c00a17 	ldw	r3,40(r2)
81142594:	e0bffc17 	ldw	r2,-16(fp)
81142598:	1885883a 	add	r2,r3,r2
8114259c:	10800484 	addi	r2,r2,18
811425a0:	1080002b 	ldhuio	r2,0(r2)
811425a4:	10bfffcc 	andi	r2,r2,65535
811425a8:	1007883a 	mov	r3,r2
811425ac:	e0bffd17 	ldw	r2,-12(fp)
811425b0:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
811425b4:	d0a0b317 	ldw	r2,-32052(gp)
811425b8:	10c00a17 	ldw	r3,40(r2)
811425bc:	e0bffc17 	ldw	r2,-16(fp)
811425c0:	1885883a 	add	r2,r3,r2
811425c4:	10800584 	addi	r2,r2,22
811425c8:	1080002b 	ldhuio	r2,0(r2)
811425cc:	10bfffcc 	andi	r2,r2,65535
811425d0:	1007883a 	mov	r3,r2
811425d4:	e0bffd17 	ldw	r2,-12(fp)
811425d8:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
811425dc:	d0a0b317 	ldw	r2,-32052(gp)
811425e0:	10c00a17 	ldw	r3,40(r2)
811425e4:	e0bffc17 	ldw	r2,-16(fp)
811425e8:	1885883a 	add	r2,r3,r2
811425ec:	10800604 	addi	r2,r2,24
811425f0:	1080002b 	ldhuio	r2,0(r2)
811425f4:	10bfffcc 	andi	r2,r2,65535
811425f8:	1007883a 	mov	r3,r2
811425fc:	e0bffd17 	ldw	r2,-12(fp)
81142600:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
81142604:	d0a0b317 	ldw	r2,-32052(gp)
81142608:	10c00a17 	ldw	r3,40(r2)
8114260c:	e0bffc17 	ldw	r2,-16(fp)
81142610:	1885883a 	add	r2,r3,r2
81142614:	10800684 	addi	r2,r2,26
81142618:	1080002b 	ldhuio	r2,0(r2)
8114261c:	10bfffcc 	andi	r2,r2,65535
81142620:	1007883a 	mov	r3,r2
81142624:	e0bffd17 	ldw	r2,-12(fp)
81142628:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8114262c:	d0a0b317 	ldw	r2,-32052(gp)
81142630:	10c00a17 	ldw	r3,40(r2)
81142634:	e0bffc17 	ldw	r2,-16(fp)
81142638:	1885883a 	add	r2,r3,r2
8114263c:	10800704 	addi	r2,r2,28
81142640:	10800037 	ldwio	r2,0(r2)
81142644:	1007883a 	mov	r3,r2
81142648:	e0bffd17 	ldw	r2,-12(fp)
8114264c:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
81142650:	e0bffd17 	ldw	r2,-12(fp)
81142654:	e0fffe17 	ldw	r3,-8(fp)
81142658:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8114265c:	e0bffd17 	ldw	r2,-12(fp)
81142660:	e0ffff17 	ldw	r3,-4(fp)
81142664:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81142668:	e0bffc17 	ldw	r2,-16(fp)
8114266c:	1007883a 	mov	r3,r2
81142670:	e0bffd17 	ldw	r2,-12(fp)
81142674:	10c00c0d 	sth	r3,48(r2)
		result = true;
81142678:	00800044 	movi	r2,1
8114267c:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
81142680:	e0bffa17 	ldw	r2,-24(fp)
}
81142684:	e037883a 	mov	sp,fp
81142688:	dfc00117 	ldw	ra,4(sp)
8114268c:	df000017 	ldw	fp,0(sp)
81142690:	dec00204 	addi	sp,sp,8
81142694:	f800283a 	ret

81142698 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81142698:	defff904 	addi	sp,sp,-28
8114269c:	de00012e 	bgeu	sp,et,811426a4 <Write_File_Record_At_Offset+0xc>
811426a0:	003b68fa 	trap	3
811426a4:	dfc00615 	stw	ra,24(sp)
811426a8:	df000515 	stw	fp,20(sp)
811426ac:	df000504 	addi	fp,sp,20
811426b0:	e13ffe15 	stw	r4,-8(fp)
811426b4:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
811426b8:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811426bc:	e0bffe17 	ldw	r2,-8(fp)
811426c0:	108007cc 	andi	r2,r2,31
811426c4:	1000931e 	bne	r2,zero,81142914 <Write_File_Record_At_Offset+0x27c>
811426c8:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
811426cc:	10009126 	beq	r2,zero,81142914 <Write_File_Record_At_Offset+0x27c>
811426d0:	d0a0aa17 	ldw	r2,-32088(gp)
811426d4:	10008f26 	beq	r2,zero,81142914 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
811426d8:	e03ffc15 	stw	zero,-16(fp)
811426dc:	00001f06 	br	8114275c <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
811426e0:	e0bffc17 	ldw	r2,-16(fp)
811426e4:	10800044 	addi	r2,r2,1
811426e8:	e0ffff17 	ldw	r3,-4(fp)
811426ec:	1885883a 	add	r2,r3,r2
811426f0:	10800003 	ldbu	r2,0(r2)
811426f4:	10803fcc 	andi	r2,r2,255
811426f8:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
811426fc:	e0bffd0f 	ldh	r2,-12(fp)
81142700:	1004923a 	slli	r2,r2,8
81142704:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
81142708:	e0ffff17 	ldw	r3,-4(fp)
8114270c:	e0bffc17 	ldw	r2,-16(fp)
81142710:	1885883a 	add	r2,r3,r2
81142714:	10800003 	ldbu	r2,0(r2)
81142718:	10c03fcc 	andi	r3,r2,255
8114271c:	e0bffd0b 	ldhu	r2,-12(fp)
81142720:	1884b03a 	or	r2,r3,r2
81142724:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
81142728:	e0fffe17 	ldw	r3,-8(fp)
8114272c:	e0bffc17 	ldw	r2,-16(fp)
81142730:	1885883a 	add	r2,r3,r2
81142734:	1007883a 	mov	r3,r2
81142738:	d0a0b317 	ldw	r2,-32052(gp)
8114273c:	10800a17 	ldw	r2,40(r2)
81142740:	1885883a 	add	r2,r3,r2
81142744:	1007883a 	mov	r3,r2
81142748:	e0bffd0f 	ldh	r2,-12(fp)
8114274c:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81142750:	e0bffc17 	ldw	r2,-16(fp)
81142754:	10800084 	addi	r2,r2,2
81142758:	e0bffc15 	stw	r2,-16(fp)
8114275c:	e0bffc17 	ldw	r2,-16(fp)
81142760:	10800210 	cmplti	r2,r2,8
81142764:	103fde1e 	bne	r2,zero,811426e0 <__reset+0xfb1226e0>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81142768:	e03ffc15 	stw	zero,-16(fp)
8114276c:	00001306 	br	811427bc <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81142770:	e0fffe17 	ldw	r3,-8(fp)
81142774:	e0bffc17 	ldw	r2,-16(fp)
81142778:	1885883a 	add	r2,r3,r2
8114277c:	1007883a 	mov	r3,r2
81142780:	d0a0b317 	ldw	r2,-32052(gp)
81142784:	10800a17 	ldw	r2,40(r2)
81142788:	1885883a 	add	r2,r3,r2
8114278c:	10800204 	addi	r2,r2,8
81142790:	1009883a 	mov	r4,r2
81142794:	e0ffff17 	ldw	r3,-4(fp)
81142798:	e0bffc17 	ldw	r2,-16(fp)
8114279c:	1885883a 	add	r2,r3,r2
811427a0:	10800204 	addi	r2,r2,8
811427a4:	10800003 	ldbu	r2,0(r2)
811427a8:	10803fcc 	andi	r2,r2,255
811427ac:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
811427b0:	e0bffc17 	ldw	r2,-16(fp)
811427b4:	10800044 	addi	r2,r2,1
811427b8:	e0bffc15 	stw	r2,-16(fp)
811427bc:	e0bffc17 	ldw	r2,-16(fp)
811427c0:	108000d0 	cmplti	r2,r2,3
811427c4:	103fea1e 	bne	r2,zero,81142770 <__reset+0xfb122770>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
811427c8:	d0a0b317 	ldw	r2,-32052(gp)
811427cc:	10c00a17 	ldw	r3,40(r2)
811427d0:	e0bffe17 	ldw	r2,-8(fp)
811427d4:	1885883a 	add	r2,r3,r2
811427d8:	108002c4 	addi	r2,r2,11
811427dc:	1007883a 	mov	r3,r2
811427e0:	e0bfff17 	ldw	r2,-4(fp)
811427e4:	108002c3 	ldbu	r2,11(r2)
811427e8:	10803fcc 	andi	r2,r2,255
811427ec:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
811427f0:	d0a0b317 	ldw	r2,-32052(gp)
811427f4:	10c00a17 	ldw	r3,40(r2)
811427f8:	e0bffe17 	ldw	r2,-8(fp)
811427fc:	1885883a 	add	r2,r3,r2
81142800:	10800384 	addi	r2,r2,14
81142804:	1007883a 	mov	r3,r2
81142808:	e0bfff17 	ldw	r2,-4(fp)
8114280c:	1080030b 	ldhu	r2,12(r2)
81142810:	10bfffcc 	andi	r2,r2,65535
81142814:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81142818:	d0a0b317 	ldw	r2,-32052(gp)
8114281c:	10c00a17 	ldw	r3,40(r2)
81142820:	e0bffe17 	ldw	r2,-8(fp)
81142824:	1885883a 	add	r2,r3,r2
81142828:	10800404 	addi	r2,r2,16
8114282c:	1007883a 	mov	r3,r2
81142830:	e0bfff17 	ldw	r2,-4(fp)
81142834:	1080038b 	ldhu	r2,14(r2)
81142838:	10bfffcc 	andi	r2,r2,65535
8114283c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81142840:	d0a0b317 	ldw	r2,-32052(gp)
81142844:	10c00a17 	ldw	r3,40(r2)
81142848:	e0bffe17 	ldw	r2,-8(fp)
8114284c:	1885883a 	add	r2,r3,r2
81142850:	10800484 	addi	r2,r2,18
81142854:	1007883a 	mov	r3,r2
81142858:	e0bfff17 	ldw	r2,-4(fp)
8114285c:	1080040b 	ldhu	r2,16(r2)
81142860:	10bfffcc 	andi	r2,r2,65535
81142864:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81142868:	d0a0b317 	ldw	r2,-32052(gp)
8114286c:	10c00a17 	ldw	r3,40(r2)
81142870:	e0bffe17 	ldw	r2,-8(fp)
81142874:	1885883a 	add	r2,r3,r2
81142878:	10800584 	addi	r2,r2,22
8114287c:	1007883a 	mov	r3,r2
81142880:	e0bfff17 	ldw	r2,-4(fp)
81142884:	1080048b 	ldhu	r2,18(r2)
81142888:	10bfffcc 	andi	r2,r2,65535
8114288c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81142890:	d0a0b317 	ldw	r2,-32052(gp)
81142894:	10c00a17 	ldw	r3,40(r2)
81142898:	e0bffe17 	ldw	r2,-8(fp)
8114289c:	1885883a 	add	r2,r3,r2
811428a0:	10800604 	addi	r2,r2,24
811428a4:	1007883a 	mov	r3,r2
811428a8:	e0bfff17 	ldw	r2,-4(fp)
811428ac:	1080050b 	ldhu	r2,20(r2)
811428b0:	10bfffcc 	andi	r2,r2,65535
811428b4:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
811428b8:	d0a0b317 	ldw	r2,-32052(gp)
811428bc:	10c00a17 	ldw	r3,40(r2)
811428c0:	e0bffe17 	ldw	r2,-8(fp)
811428c4:	1885883a 	add	r2,r3,r2
811428c8:	10800684 	addi	r2,r2,26
811428cc:	1007883a 	mov	r3,r2
811428d0:	e0bfff17 	ldw	r2,-4(fp)
811428d4:	1080058b 	ldhu	r2,22(r2)
811428d8:	10bfffcc 	andi	r2,r2,65535
811428dc:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
811428e0:	d0a0b317 	ldw	r2,-32052(gp)
811428e4:	10c00a17 	ldw	r3,40(r2)
811428e8:	e0bffe17 	ldw	r2,-8(fp)
811428ec:	1885883a 	add	r2,r3,r2
811428f0:	10800704 	addi	r2,r2,28
811428f4:	1007883a 	mov	r3,r2
811428f8:	e0bfff17 	ldw	r2,-4(fp)
811428fc:	10800617 	ldw	r2,24(r2)
81142900:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81142904:	00800044 	movi	r2,1
81142908:	d0a0b415 	stw	r2,-32048(gp)
        result = true;
8114290c:	00800044 	movi	r2,1
81142910:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81142914:	e0bffb17 	ldw	r2,-20(fp)
}
81142918:	e037883a 	mov	sp,fp
8114291c:	dfc00117 	ldw	ra,4(sp)
81142920:	df000017 	ldw	fp,0(sp)
81142924:	dec00204 	addi	sp,sp,8
81142928:	f800283a 	ret

8114292c <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8114292c:	defff904 	addi	sp,sp,-28
81142930:	de00012e 	bgeu	sp,et,81142938 <Check_for_DOS_FAT+0xc>
81142934:	003b68fa 	trap	3
81142938:	dfc00615 	stw	ra,24(sp)
8114293c:	df000515 	stw	fp,20(sp)
81142940:	df000504 	addi	fp,sp,20
81142944:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81142948:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8114294c:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81142950:	e17fff17 	ldw	r5,-4(fp)
81142954:	0009883a 	mov	r4,zero
81142958:	1141fe40 	call	81141fe4 <Read_Sector_Data>
8114295c:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81142960:	d0a0b317 	ldw	r2,-32052(gp)
81142964:	10800a17 	ldw	r2,40(r2)
81142968:	10807f84 	addi	r2,r2,510
8114296c:	1080002b 	ldhuio	r2,0(r2)
81142970:	10bfffcc 	andi	r2,r2,65535
81142974:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81142978:	e0bffe0f 	ldh	r2,-8(fp)
8114297c:	10ffffcc 	andi	r3,r2,65535
81142980:	00aa9554 	movui	r2,43605
81142984:	1881841e 	bne	r3,r2,81142f98 <Check_for_DOS_FAT+0x66c>
81142988:	e0bffb17 	ldw	r2,-20(fp)
8114298c:	10018226 	beq	r2,zero,81142f98 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81142990:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81142994:	d0a0b317 	ldw	r2,-32052(gp)
81142998:	10800a17 	ldw	r2,40(r2)
8114299c:	10800023 	ldbuio	r2,0(r2)
811429a0:	10803fcc 	andi	r2,r2,255
811429a4:	1007883a 	mov	r3,r2
811429a8:	00a045f4 	movhi	r2,33047
811429ac:	10b32704 	addi	r2,r2,-13156
811429b0:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
811429b4:	d0a0b317 	ldw	r2,-32052(gp)
811429b8:	10800a17 	ldw	r2,40(r2)
811429bc:	10800044 	addi	r2,r2,1
811429c0:	10800023 	ldbuio	r2,0(r2)
811429c4:	10803fcc 	andi	r2,r2,255
811429c8:	1007883a 	mov	r3,r2
811429cc:	00a045f4 	movhi	r2,33047
811429d0:	10b32704 	addi	r2,r2,-13156
811429d4:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
811429d8:	d0a0b317 	ldw	r2,-32052(gp)
811429dc:	10800a17 	ldw	r2,40(r2)
811429e0:	10800084 	addi	r2,r2,2
811429e4:	10800023 	ldbuio	r2,0(r2)
811429e8:	10803fcc 	andi	r2,r2,255
811429ec:	1007883a 	mov	r3,r2
811429f0:	00a045f4 	movhi	r2,33047
811429f4:	10b32704 	addi	r2,r2,-13156
811429f8:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
811429fc:	e03ffc15 	stw	zero,-16(fp)
81142a00:	00001106 	br	81142a48 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81142a04:	d0a0b317 	ldw	r2,-32052(gp)
81142a08:	10c00a17 	ldw	r3,40(r2)
81142a0c:	e0bffc17 	ldw	r2,-16(fp)
81142a10:	1885883a 	add	r2,r3,r2
81142a14:	108000c4 	addi	r2,r2,3
81142a18:	10800023 	ldbuio	r2,0(r2)
81142a1c:	10803fcc 	andi	r2,r2,255
81142a20:	1009883a 	mov	r4,r2
81142a24:	00a045f4 	movhi	r2,33047
81142a28:	10b32704 	addi	r2,r2,-13156
81142a2c:	e0fffc17 	ldw	r3,-16(fp)
81142a30:	10c5883a 	add	r2,r2,r3
81142a34:	108000c4 	addi	r2,r2,3
81142a38:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81142a3c:	e0bffc17 	ldw	r2,-16(fp)
81142a40:	10800044 	addi	r2,r2,1
81142a44:	e0bffc15 	stw	r2,-16(fp)
81142a48:	e0bffc17 	ldw	r2,-16(fp)
81142a4c:	10800210 	cmplti	r2,r2,8
81142a50:	103fec1e 	bne	r2,zero,81142a04 <__reset+0xfb122a04>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81142a54:	d0a0b317 	ldw	r2,-32052(gp)
81142a58:	10800a17 	ldw	r2,40(r2)
81142a5c:	10800304 	addi	r2,r2,12
81142a60:	10800023 	ldbuio	r2,0(r2)
81142a64:	10803fcc 	andi	r2,r2,255
81142a68:	1004923a 	slli	r2,r2,8
81142a6c:	1007883a 	mov	r3,r2
81142a70:	d0a0b317 	ldw	r2,-32052(gp)
81142a74:	10800a17 	ldw	r2,40(r2)
81142a78:	108002c4 	addi	r2,r2,11
81142a7c:	10800023 	ldbuio	r2,0(r2)
81142a80:	10803fcc 	andi	r2,r2,255
81142a84:	10803fcc 	andi	r2,r2,255
81142a88:	1080201c 	xori	r2,r2,128
81142a8c:	10bfe004 	addi	r2,r2,-128
81142a90:	1884b03a 	or	r2,r3,r2
81142a94:	1007883a 	mov	r3,r2
81142a98:	00a045f4 	movhi	r2,33047
81142a9c:	10b32704 	addi	r2,r2,-13156
81142aa0:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81142aa4:	d0a0b317 	ldw	r2,-32052(gp)
81142aa8:	10800a17 	ldw	r2,40(r2)
81142aac:	10800344 	addi	r2,r2,13
81142ab0:	10800023 	ldbuio	r2,0(r2)
81142ab4:	10803fcc 	andi	r2,r2,255
81142ab8:	1007883a 	mov	r3,r2
81142abc:	00a045f4 	movhi	r2,33047
81142ac0:	10b32704 	addi	r2,r2,-13156
81142ac4:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81142ac8:	d0a0b317 	ldw	r2,-32052(gp)
81142acc:	10800a17 	ldw	r2,40(r2)
81142ad0:	10800384 	addi	r2,r2,14
81142ad4:	1080002b 	ldhuio	r2,0(r2)
81142ad8:	10bfffcc 	andi	r2,r2,65535
81142adc:	1007883a 	mov	r3,r2
81142ae0:	00a045f4 	movhi	r2,33047
81142ae4:	10b32704 	addi	r2,r2,-13156
81142ae8:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
81142aec:	d0a0b317 	ldw	r2,-32052(gp)
81142af0:	10800a17 	ldw	r2,40(r2)
81142af4:	10800404 	addi	r2,r2,16
81142af8:	10800023 	ldbuio	r2,0(r2)
81142afc:	10803fcc 	andi	r2,r2,255
81142b00:	1007883a 	mov	r3,r2
81142b04:	00a045f4 	movhi	r2,33047
81142b08:	10b32704 	addi	r2,r2,-13156
81142b0c:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81142b10:	d0a0b317 	ldw	r2,-32052(gp)
81142b14:	10800a17 	ldw	r2,40(r2)
81142b18:	10800484 	addi	r2,r2,18
81142b1c:	10800023 	ldbuio	r2,0(r2)
81142b20:	10803fcc 	andi	r2,r2,255
81142b24:	1004923a 	slli	r2,r2,8
81142b28:	1007883a 	mov	r3,r2
81142b2c:	d0a0b317 	ldw	r2,-32052(gp)
81142b30:	10800a17 	ldw	r2,40(r2)
81142b34:	10800444 	addi	r2,r2,17
81142b38:	10800023 	ldbuio	r2,0(r2)
81142b3c:	10803fcc 	andi	r2,r2,255
81142b40:	10803fcc 	andi	r2,r2,255
81142b44:	1884b03a 	or	r2,r3,r2
81142b48:	1007883a 	mov	r3,r2
81142b4c:	00a045f4 	movhi	r2,33047
81142b50:	10b32704 	addi	r2,r2,-13156
81142b54:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81142b58:	d0a0b317 	ldw	r2,-32052(gp)
81142b5c:	10800a17 	ldw	r2,40(r2)
81142b60:	10800504 	addi	r2,r2,20
81142b64:	10800023 	ldbuio	r2,0(r2)
81142b68:	10803fcc 	andi	r2,r2,255
81142b6c:	1004923a 	slli	r2,r2,8
81142b70:	1007883a 	mov	r3,r2
81142b74:	d0a0b317 	ldw	r2,-32052(gp)
81142b78:	10800a17 	ldw	r2,40(r2)
81142b7c:	108004c4 	addi	r2,r2,19
81142b80:	10800023 	ldbuio	r2,0(r2)
81142b84:	10803fcc 	andi	r2,r2,255
81142b88:	10803fcc 	andi	r2,r2,255
81142b8c:	1884b03a 	or	r2,r3,r2
81142b90:	1007883a 	mov	r3,r2
81142b94:	00a045f4 	movhi	r2,33047
81142b98:	10b32704 	addi	r2,r2,-13156
81142b9c:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81142ba0:	d0a0b317 	ldw	r2,-32052(gp)
81142ba4:	10800a17 	ldw	r2,40(r2)
81142ba8:	10800544 	addi	r2,r2,21
81142bac:	10800023 	ldbuio	r2,0(r2)
81142bb0:	10803fcc 	andi	r2,r2,255
81142bb4:	1007883a 	mov	r3,r2
81142bb8:	00a045f4 	movhi	r2,33047
81142bbc:	10b32704 	addi	r2,r2,-13156
81142bc0:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81142bc4:	d0a0b317 	ldw	r2,-32052(gp)
81142bc8:	10800a17 	ldw	r2,40(r2)
81142bcc:	10800584 	addi	r2,r2,22
81142bd0:	1080002b 	ldhuio	r2,0(r2)
81142bd4:	10bfffcc 	andi	r2,r2,65535
81142bd8:	1007883a 	mov	r3,r2
81142bdc:	00a045f4 	movhi	r2,33047
81142be0:	10b32704 	addi	r2,r2,-13156
81142be4:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81142be8:	d0a0b317 	ldw	r2,-32052(gp)
81142bec:	10800a17 	ldw	r2,40(r2)
81142bf0:	10800604 	addi	r2,r2,24
81142bf4:	1080002b 	ldhuio	r2,0(r2)
81142bf8:	10bfffcc 	andi	r2,r2,65535
81142bfc:	1007883a 	mov	r3,r2
81142c00:	00a045f4 	movhi	r2,33047
81142c04:	10b32704 	addi	r2,r2,-13156
81142c08:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81142c0c:	d0a0b317 	ldw	r2,-32052(gp)
81142c10:	10800a17 	ldw	r2,40(r2)
81142c14:	10800684 	addi	r2,r2,26
81142c18:	1080002b 	ldhuio	r2,0(r2)
81142c1c:	10bfffcc 	andi	r2,r2,65535
81142c20:	1007883a 	mov	r3,r2
81142c24:	00a045f4 	movhi	r2,33047
81142c28:	10b32704 	addi	r2,r2,-13156
81142c2c:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81142c30:	d0a0b317 	ldw	r2,-32052(gp)
81142c34:	10800a17 	ldw	r2,40(r2)
81142c38:	10800704 	addi	r2,r2,28
81142c3c:	10800037 	ldwio	r2,0(r2)
81142c40:	1007883a 	mov	r3,r2
81142c44:	00a045f4 	movhi	r2,33047
81142c48:	10b32704 	addi	r2,r2,-13156
81142c4c:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81142c50:	d0a0b317 	ldw	r2,-32052(gp)
81142c54:	10800a17 	ldw	r2,40(r2)
81142c58:	10800804 	addi	r2,r2,32
81142c5c:	10800037 	ldwio	r2,0(r2)
81142c60:	1007883a 	mov	r3,r2
81142c64:	00a045f4 	movhi	r2,33047
81142c68:	10b32704 	addi	r2,r2,-13156
81142c6c:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
81142c70:	d0a0b317 	ldw	r2,-32052(gp)
81142c74:	10800a17 	ldw	r2,40(r2)
81142c78:	10800904 	addi	r2,r2,36
81142c7c:	10800023 	ldbuio	r2,0(r2)
81142c80:	10803fcc 	andi	r2,r2,255
81142c84:	1007883a 	mov	r3,r2
81142c88:	00a045f4 	movhi	r2,33047
81142c8c:	10b32704 	addi	r2,r2,-13156
81142c90:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
81142c94:	d0a0b317 	ldw	r2,-32052(gp)
81142c98:	10800a17 	ldw	r2,40(r2)
81142c9c:	10800944 	addi	r2,r2,37
81142ca0:	10800023 	ldbuio	r2,0(r2)
81142ca4:	10803fcc 	andi	r2,r2,255
81142ca8:	1007883a 	mov	r3,r2
81142cac:	00a045f4 	movhi	r2,33047
81142cb0:	10b32704 	addi	r2,r2,-13156
81142cb4:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81142cb8:	d0a0b317 	ldw	r2,-32052(gp)
81142cbc:	10800a17 	ldw	r2,40(r2)
81142cc0:	10800984 	addi	r2,r2,38
81142cc4:	10800023 	ldbuio	r2,0(r2)
81142cc8:	10803fcc 	andi	r2,r2,255
81142ccc:	1007883a 	mov	r3,r2
81142cd0:	00a045f4 	movhi	r2,33047
81142cd4:	10b32704 	addi	r2,r2,-13156
81142cd8:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81142cdc:	00a045f4 	movhi	r2,33047
81142ce0:	10b32704 	addi	r2,r2,-13156
81142ce4:	1080040b 	ldhu	r2,16(r2)
81142ce8:	10ffffcc 	andi	r3,r2,65535
81142cec:	00a045f4 	movhi	r2,33047
81142cf0:	10b32704 	addi	r2,r2,-13156
81142cf4:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81142cf8:	00a045f4 	movhi	r2,33047
81142cfc:	10b32704 	addi	r2,r2,-13156
81142d00:	10c01117 	ldw	r3,68(r2)
81142d04:	00a045f4 	movhi	r2,33047
81142d08:	10b32704 	addi	r2,r2,-13156
81142d0c:	1080068b 	ldhu	r2,26(r2)
81142d10:	10bfffcc 	andi	r2,r2,65535
81142d14:	1887883a 	add	r3,r3,r2
81142d18:	00a045f4 	movhi	r2,33047
81142d1c:	10b32704 	addi	r2,r2,-13156
81142d20:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81142d24:	00a045f4 	movhi	r2,33047
81142d28:	10b32704 	addi	r2,r2,-13156
81142d2c:	10c01217 	ldw	r3,72(r2)
81142d30:	00a045f4 	movhi	r2,33047
81142d34:	10b32704 	addi	r2,r2,-13156
81142d38:	1080068b 	ldhu	r2,26(r2)
81142d3c:	10bfffcc 	andi	r2,r2,65535
81142d40:	1887883a 	add	r3,r3,r2
81142d44:	00a045f4 	movhi	r2,33047
81142d48:	10b32704 	addi	r2,r2,-13156
81142d4c:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81142d50:	00a045f4 	movhi	r2,33047
81142d54:	10b32704 	addi	r2,r2,-13156
81142d58:	10c01317 	ldw	r3,76(r2)
81142d5c:	00a045f4 	movhi	r2,33047
81142d60:	10b32704 	addi	r2,r2,-13156
81142d64:	1080050b 	ldhu	r2,20(r2)
81142d68:	10bfffcc 	andi	r2,r2,65535
81142d6c:	1008917a 	slli	r4,r2,5
81142d70:	00a045f4 	movhi	r2,33047
81142d74:	10b32704 	addi	r2,r2,-13156
81142d78:	1080030b 	ldhu	r2,12(r2)
81142d7c:	10bfffcc 	andi	r2,r2,65535
81142d80:	2085283a 	div	r2,r4,r2
81142d84:	1887883a 	add	r3,r3,r2
81142d88:	00a045f4 	movhi	r2,33047
81142d8c:	10b32704 	addi	r2,r2,-13156
81142d90:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
81142d94:	00a045f4 	movhi	r2,33047
81142d98:	10b32704 	addi	r2,r2,-13156
81142d9c:	1080058b 	ldhu	r2,22(r2)
81142da0:	10bfffcc 	andi	r2,r2,65535
81142da4:	10000b26 	beq	r2,zero,81142dd4 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81142da8:	00a045f4 	movhi	r2,33047
81142dac:	10b32704 	addi	r2,r2,-13156
81142db0:	1080058b 	ldhu	r2,22(r2)
81142db4:	10ffffcc 	andi	r3,r2,65535
81142db8:	00a045f4 	movhi	r2,33047
81142dbc:	10b32704 	addi	r2,r2,-13156
81142dc0:	10800383 	ldbu	r2,14(r2)
81142dc4:	10803fcc 	andi	r2,r2,255
81142dc8:	1885283a 	div	r2,r3,r2
81142dcc:	e0bffd15 	stw	r2,-12(fp)
81142dd0:	00000906 	br	81142df8 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81142dd4:	00a045f4 	movhi	r2,33047
81142dd8:	10b32704 	addi	r2,r2,-13156
81142ddc:	10c00917 	ldw	r3,36(r2)
81142de0:	00a045f4 	movhi	r2,33047
81142de4:	10b32704 	addi	r2,r2,-13156
81142de8:	10800383 	ldbu	r2,14(r2)
81142dec:	10803fcc 	andi	r2,r2,255
81142df0:	1885203a 	divu	r2,r3,r2
81142df4:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81142df8:	e0bffd17 	ldw	r2,-12(fp)
81142dfc:	1083fdc8 	cmpgei	r2,r2,4087
81142e00:	1000051e 	bne	r2,zero,81142e18 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
81142e04:	00a045f4 	movhi	r2,33047
81142e08:	10b32704 	addi	r2,r2,-13156
81142e0c:	00c00304 	movi	r3,12
81142e10:	10c01085 	stb	r3,66(r2)
81142e14:	00000c06 	br	81142e48 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
81142e18:	e0bffd17 	ldw	r2,-12(fp)
81142e1c:	00fffb54 	movui	r3,65517
81142e20:	18800516 	blt	r3,r2,81142e38 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
81142e24:	00a045f4 	movhi	r2,33047
81142e28:	10b32704 	addi	r2,r2,-13156
81142e2c:	00c00404 	movi	r3,16
81142e30:	10c01085 	stb	r3,66(r2)
81142e34:	00000406 	br	81142e48 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
81142e38:	00a045f4 	movhi	r2,33047
81142e3c:	10b32704 	addi	r2,r2,-13156
81142e40:	00c00804 	movi	r3,32
81142e44:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
81142e48:	e03ffc15 	stw	zero,-16(fp)
81142e4c:	00001106 	br	81142e94 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
81142e50:	d0a0b317 	ldw	r2,-32052(gp)
81142e54:	10c00a17 	ldw	r3,40(r2)
81142e58:	e0bffc17 	ldw	r2,-16(fp)
81142e5c:	1885883a 	add	r2,r3,r2
81142e60:	108009c4 	addi	r2,r2,39
81142e64:	10800023 	ldbuio	r2,0(r2)
81142e68:	10803fcc 	andi	r2,r2,255
81142e6c:	1009883a 	mov	r4,r2
81142e70:	00a045f4 	movhi	r2,33047
81142e74:	10b32704 	addi	r2,r2,-13156
81142e78:	e0fffc17 	ldw	r3,-16(fp)
81142e7c:	10c5883a 	add	r2,r2,r3
81142e80:	10800ac4 	addi	r2,r2,43
81142e84:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81142e88:	e0bffc17 	ldw	r2,-16(fp)
81142e8c:	10800044 	addi	r2,r2,1
81142e90:	e0bffc15 	stw	r2,-16(fp)
81142e94:	e0bffc17 	ldw	r2,-16(fp)
81142e98:	10800110 	cmplti	r2,r2,4
81142e9c:	103fec1e 	bne	r2,zero,81142e50 <__reset+0xfb122e50>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81142ea0:	e03ffc15 	stw	zero,-16(fp)
81142ea4:	00001106 	br	81142eec <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81142ea8:	d0a0b317 	ldw	r2,-32052(gp)
81142eac:	10c00a17 	ldw	r3,40(r2)
81142eb0:	e0bffc17 	ldw	r2,-16(fp)
81142eb4:	1885883a 	add	r2,r3,r2
81142eb8:	10800ac4 	addi	r2,r2,43
81142ebc:	10800023 	ldbuio	r2,0(r2)
81142ec0:	10803fcc 	andi	r2,r2,255
81142ec4:	1009883a 	mov	r4,r2
81142ec8:	00a045f4 	movhi	r2,33047
81142ecc:	10b32704 	addi	r2,r2,-13156
81142ed0:	e0fffc17 	ldw	r3,-16(fp)
81142ed4:	10c5883a 	add	r2,r2,r3
81142ed8:	10800bc4 	addi	r2,r2,47
81142edc:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81142ee0:	e0bffc17 	ldw	r2,-16(fp)
81142ee4:	10800044 	addi	r2,r2,1
81142ee8:	e0bffc15 	stw	r2,-16(fp)
81142eec:	e0bffc17 	ldw	r2,-16(fp)
81142ef0:	108002d0 	cmplti	r2,r2,11
81142ef4:	103fec1e 	bne	r2,zero,81142ea8 <__reset+0xfb122ea8>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81142ef8:	e03ffc15 	stw	zero,-16(fp)
81142efc:	00001106 	br	81142f44 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
81142f00:	d0a0b317 	ldw	r2,-32052(gp)
81142f04:	10c00a17 	ldw	r3,40(r2)
81142f08:	e0bffc17 	ldw	r2,-16(fp)
81142f0c:	1885883a 	add	r2,r3,r2
81142f10:	10800d84 	addi	r2,r2,54
81142f14:	10800023 	ldbuio	r2,0(r2)
81142f18:	10803fcc 	andi	r2,r2,255
81142f1c:	1009883a 	mov	r4,r2
81142f20:	00a045f4 	movhi	r2,33047
81142f24:	10b32704 	addi	r2,r2,-13156
81142f28:	e0fffc17 	ldw	r3,-16(fp)
81142f2c:	10c5883a 	add	r2,r2,r3
81142f30:	10800e84 	addi	r2,r2,58
81142f34:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81142f38:	e0bffc17 	ldw	r2,-16(fp)
81142f3c:	10800044 	addi	r2,r2,1
81142f40:	e0bffc15 	stw	r2,-16(fp)
81142f44:	e0bffc17 	ldw	r2,-16(fp)
81142f48:	10800210 	cmplti	r2,r2,8
81142f4c:	103fec1e 	bne	r2,zero,81142f00 <__reset+0xfb122f00>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81142f50:	e03ffc15 	stw	zero,-16(fp)
81142f54:	00000a06 	br	81142f80 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
81142f58:	00a045f4 	movhi	r2,33047
81142f5c:	10b33c04 	addi	r2,r2,-13072
81142f60:	e0fffc17 	ldw	r3,-16(fp)
81142f64:	180691ba 	slli	r3,r3,6
81142f68:	10c5883a 	add	r2,r2,r3
81142f6c:	10800f04 	addi	r2,r2,60
81142f70:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81142f74:	e0bffc17 	ldw	r2,-16(fp)
81142f78:	10800044 	addi	r2,r2,1
81142f7c:	e0bffc15 	stw	r2,-16(fp)
81142f80:	e0bffc17 	ldw	r2,-16(fp)
81142f84:	10800510 	cmplti	r2,r2,20
81142f88:	103ff31e 	bne	r2,zero,81142f58 <__reset+0xfb122f58>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81142f8c:	00800044 	movi	r2,1
81142f90:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
81142f94:	00000106 	br	81142f9c <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81142f98:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81142f9c:	e0bffb17 	ldw	r2,-20(fp)
}
81142fa0:	e037883a 	mov	sp,fp
81142fa4:	dfc00117 	ldw	ra,4(sp)
81142fa8:	df000017 	ldw	fp,0(sp)
81142fac:	dec00204 	addi	sp,sp,8
81142fb0:	f800283a 	ret

81142fb4 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
81142fb4:	defffc04 	addi	sp,sp,-16
81142fb8:	de00012e 	bgeu	sp,et,81142fc0 <Look_for_FAT16+0xc>
81142fbc:	003b68fa 	trap	3
81142fc0:	dfc00315 	stw	ra,12(sp)
81142fc4:	df000215 	stw	fp,8(sp)
81142fc8:	df000204 	addi	fp,sp,8
	bool result = false;
81142fcc:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81142fd0:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
81142fd4:	10002e26 	beq	r2,zero,81143090 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81142fd8:	d0a0ad17 	ldw	r2,-32076(gp)
81142fdc:	1080000b 	ldhu	r2,0(r2)
81142fe0:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
81142fe4:	d020b115 	stw	zero,-32060(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81142fe8:	d020b215 	stw	zero,-32056(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
81142fec:	e0bfff0f 	ldh	r2,-4(fp)
81142ff0:	10002716 	blt	r2,zero,81143090 <Look_for_FAT16+0xdc>
81142ff4:	e0bfff0b 	ldhu	r2,-4(fp)
81142ff8:	10bfffcc 	andi	r2,r2,65535
81142ffc:	1083000c 	andi	r2,r2,3072
81143000:	10830020 	cmpeqi	r2,r2,3072
81143004:	1000221e 	bne	r2,zero,81143090 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
81143008:	e0bfff0b 	ldhu	r2,-4(fp)
8114300c:	10bfffcc 	andi	r2,r2,65535
81143010:	1083000c 	andi	r2,r2,3072
81143014:	10810018 	cmpnei	r2,r2,1024
81143018:	1000031e 	bne	r2,zero,81143028 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8114301c:	0009883a 	mov	r4,zero
81143020:	114292c0 	call	8114292c <Check_for_DOS_FAT>
81143024:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
81143028:	e0bfff0b 	ldhu	r2,-4(fp)
8114302c:	10bfffcc 	andi	r2,r2,65535
81143030:	1083000c 	andi	r2,r2,3072
81143034:	1000061e 	bne	r2,zero,81143050 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
81143038:	11422680 	call	81142268 <Check_for_Master_Boot_Record>
8114303c:	10000426 	beq	r2,zero,81143050 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
81143040:	d0a0b117 	ldw	r2,-32060(gp)
81143044:	1009883a 	mov	r4,r2
81143048:	114292c0 	call	8114292c <Check_for_DOS_FAT>
8114304c:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
81143050:	e0bffe17 	ldw	r2,-8(fp)
81143054:	10800058 	cmpnei	r2,r2,1
81143058:	10000d1e 	bne	r2,zero,81143090 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8114305c:	00a045f4 	movhi	r2,33047
81143060:	10b32704 	addi	r2,r2,-13156
81143064:	10801083 	ldbu	r2,66(r2)
81143068:	10803fcc 	andi	r2,r2,255
8114306c:	10800420 	cmpeqi	r2,r2,16
81143070:	1000021e 	bne	r2,zero,8114307c <Look_for_FAT16+0xc8>
				{
					result = false;
81143074:	e03ffe15 	stw	zero,-8(fp)
81143078:	00000506 	br	81143090 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8114307c:	00a045f4 	movhi	r2,33047
81143080:	10b32704 	addi	r2,r2,-13156
81143084:	1080058b 	ldhu	r2,22(r2)
81143088:	10bfffcc 	andi	r2,r2,65535
8114308c:	d0a0b215 	stw	r2,-32056(gp)
				}
			}
		}
	}
	return result;
81143090:	e0bffe17 	ldw	r2,-8(fp)
}
81143094:	e037883a 	mov	sp,fp
81143098:	dfc00117 	ldw	ra,4(sp)
8114309c:	df000017 	ldw	fp,0(sp)
811430a0:	dec00204 	addi	sp,sp,8
811430a4:	f800283a 	ret

811430a8 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
811430a8:	defffb04 	addi	sp,sp,-20
811430ac:	de00012e 	bgeu	sp,et,811430b4 <filename_to_upper_case+0xc>
811430b0:	003b68fa 	trap	3
811430b4:	dfc00415 	stw	ra,16(sp)
811430b8:	df000315 	stw	fp,12(sp)
811430bc:	df000304 	addi	fp,sp,12
811430c0:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
811430c4:	e13fff17 	ldw	r4,-4(fp)
811430c8:	1122ee80 	call	81122ee8 <strlen>
811430cc:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
811430d0:	e03ffd15 	stw	zero,-12(fp)
811430d4:	00001e06 	br	81143150 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
811430d8:	e0bffd17 	ldw	r2,-12(fp)
811430dc:	e0ffff17 	ldw	r3,-4(fp)
811430e0:	1885883a 	add	r2,r3,r2
811430e4:	10800003 	ldbu	r2,0(r2)
811430e8:	10803fcc 	andi	r2,r2,255
811430ec:	1080201c 	xori	r2,r2,128
811430f0:	10bfe004 	addi	r2,r2,-128
811430f4:	10801850 	cmplti	r2,r2,97
811430f8:	1000121e 	bne	r2,zero,81143144 <filename_to_upper_case+0x9c>
811430fc:	e0bffd17 	ldw	r2,-12(fp)
81143100:	e0ffff17 	ldw	r3,-4(fp)
81143104:	1885883a 	add	r2,r3,r2
81143108:	10800003 	ldbu	r2,0(r2)
8114310c:	10803fcc 	andi	r2,r2,255
81143110:	1080201c 	xori	r2,r2,128
81143114:	10bfe004 	addi	r2,r2,-128
81143118:	10801ec8 	cmpgei	r2,r2,123
8114311c:	1000091e 	bne	r2,zero,81143144 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
81143120:	e0bffd17 	ldw	r2,-12(fp)
81143124:	e0ffff17 	ldw	r3,-4(fp)
81143128:	1885883a 	add	r2,r3,r2
8114312c:	e0fffd17 	ldw	r3,-12(fp)
81143130:	e13fff17 	ldw	r4,-4(fp)
81143134:	20c7883a 	add	r3,r4,r3
81143138:	18c00003 	ldbu	r3,0(r3)
8114313c:	18fff804 	addi	r3,r3,-32
81143140:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
81143144:	e0bffd17 	ldw	r2,-12(fp)
81143148:	10800044 	addi	r2,r2,1
8114314c:	e0bffd15 	stw	r2,-12(fp)
81143150:	e0fffd17 	ldw	r3,-12(fp)
81143154:	e0bffe17 	ldw	r2,-8(fp)
81143158:	18bfdf16 	blt	r3,r2,811430d8 <__reset+0xfb1230d8>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8114315c:	0001883a 	nop
81143160:	e037883a 	mov	sp,fp
81143164:	dfc00117 	ldw	ra,4(sp)
81143168:	df000017 	ldw	fp,0(sp)
8114316c:	dec00204 	addi	sp,sp,8
81143170:	f800283a 	ret

81143174 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
81143174:	defff804 	addi	sp,sp,-32
81143178:	de00012e 	bgeu	sp,et,81143180 <check_file_name_for_FAT16_compliance+0xc>
8114317c:	003b68fa 	trap	3
81143180:	dfc00715 	stw	ra,28(sp)
81143184:	df000615 	stw	fp,24(sp)
81143188:	df000604 	addi	fp,sp,24
8114318c:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
81143190:	e13fff17 	ldw	r4,-4(fp)
81143194:	1122ee80 	call	81122ee8 <strlen>
81143198:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8114319c:	00bfffc4 	movi	r2,-1
811431a0:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
811431a4:	00bfffc4 	movi	r2,-1
811431a8:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
811431ac:	00800044 	movi	r2,1
811431b0:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
811431b4:	e03ffa15 	stw	zero,-24(fp)
811431b8:	00006d06 	br	81143370 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
811431bc:	e0bffa17 	ldw	r2,-24(fp)
811431c0:	e0ffff17 	ldw	r3,-4(fp)
811431c4:	1885883a 	add	r2,r3,r2
811431c8:	10800003 	ldbu	r2,0(r2)
811431cc:	10803fcc 	andi	r2,r2,255
811431d0:	1080201c 	xori	r2,r2,128
811431d4:	10bfe004 	addi	r2,r2,-128
811431d8:	10800820 	cmpeqi	r2,r2,32
811431dc:	10003e1e 	bne	r2,zero,811432d8 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811431e0:	e0bffa17 	ldw	r2,-24(fp)
811431e4:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
811431e8:	e0bffb17 	ldw	r2,-20(fp)
811431ec:	1880121e 	bne	r3,r2,81143238 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811431f0:	e0bffa17 	ldw	r2,-24(fp)
811431f4:	e0ffff17 	ldw	r3,-4(fp)
811431f8:	1885883a 	add	r2,r3,r2
811431fc:	10800003 	ldbu	r2,0(r2)
81143200:	10803fcc 	andi	r2,r2,255
81143204:	1080201c 	xori	r2,r2,128
81143208:	10bfe004 	addi	r2,r2,-128
8114320c:	10801720 	cmpeqi	r2,r2,92
81143210:	1000311e 	bne	r2,zero,811432d8 <check_file_name_for_FAT16_compliance+0x164>
81143214:	e0bffa17 	ldw	r2,-24(fp)
81143218:	e0ffff17 	ldw	r3,-4(fp)
8114321c:	1885883a 	add	r2,r3,r2
81143220:	10800003 	ldbu	r2,0(r2)
81143224:	10803fcc 	andi	r2,r2,255
81143228:	1080201c 	xori	r2,r2,128
8114322c:	10bfe004 	addi	r2,r2,-128
81143230:	10800be0 	cmpeqi	r2,r2,47
81143234:	1000281e 	bne	r2,zero,811432d8 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81143238:	e0fffa17 	ldw	r3,-24(fp)
8114323c:	e0bffc17 	ldw	r2,-16(fp)
81143240:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81143244:	10800258 	cmpnei	r2,r2,9
81143248:	1000091e 	bne	r2,zero,81143270 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8114324c:	e0bffa17 	ldw	r2,-24(fp)
81143250:	e0ffff17 	ldw	r3,-4(fp)
81143254:	1885883a 	add	r2,r3,r2
81143258:	10800003 	ldbu	r2,0(r2)
8114325c:	10803fcc 	andi	r2,r2,255
81143260:	1080201c 	xori	r2,r2,128
81143264:	10bfe004 	addi	r2,r2,-128
81143268:	10800b98 	cmpnei	r2,r2,46
8114326c:	10001a1e 	bne	r2,zero,811432d8 <check_file_name_for_FAT16_compliance+0x164>
81143270:	e0fffb17 	ldw	r3,-20(fp)
81143274:	e0bffc17 	ldw	r2,-16(fp)
81143278:	18801926 	beq	r3,r2,811432e0 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8114327c:	e0fffa17 	ldw	r3,-24(fp)
81143280:	e0bffc17 	ldw	r2,-16(fp)
81143284:	1885c83a 	sub	r2,r3,r2
81143288:	10800110 	cmplti	r2,r2,4
8114328c:	1000141e 	bne	r2,zero,811432e0 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81143290:	e0bffa17 	ldw	r2,-24(fp)
81143294:	e0ffff17 	ldw	r3,-4(fp)
81143298:	1885883a 	add	r2,r3,r2
8114329c:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
811432a0:	10803fcc 	andi	r2,r2,255
811432a4:	1080201c 	xori	r2,r2,128
811432a8:	10bfe004 	addi	r2,r2,-128
811432ac:	10801720 	cmpeqi	r2,r2,92
811432b0:	10000b1e 	bne	r2,zero,811432e0 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
811432b4:	e0bffa17 	ldw	r2,-24(fp)
811432b8:	e0ffff17 	ldw	r3,-4(fp)
811432bc:	1885883a 	add	r2,r3,r2
811432c0:	10800003 	ldbu	r2,0(r2)
811432c4:	10803fcc 	andi	r2,r2,255
811432c8:	1080201c 	xori	r2,r2,128
811432cc:	10bfe004 	addi	r2,r2,-128
811432d0:	10800be0 	cmpeqi	r2,r2,47
811432d4:	1000021e 	bne	r2,zero,811432e0 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
811432d8:	e03ffd15 	stw	zero,-12(fp)
            break;
811432dc:	00002706 	br	8114337c <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
811432e0:	e0bffa17 	ldw	r2,-24(fp)
811432e4:	e0ffff17 	ldw	r3,-4(fp)
811432e8:	1885883a 	add	r2,r3,r2
811432ec:	10800003 	ldbu	r2,0(r2)
811432f0:	10803fcc 	andi	r2,r2,255
811432f4:	1080201c 	xori	r2,r2,128
811432f8:	10bfe004 	addi	r2,r2,-128
811432fc:	10801720 	cmpeqi	r2,r2,92
81143300:	1000091e 	bne	r2,zero,81143328 <check_file_name_for_FAT16_compliance+0x1b4>
81143304:	e0bffa17 	ldw	r2,-24(fp)
81143308:	e0ffff17 	ldw	r3,-4(fp)
8114330c:	1885883a 	add	r2,r3,r2
81143310:	10800003 	ldbu	r2,0(r2)
81143314:	10803fcc 	andi	r2,r2,255
81143318:	1080201c 	xori	r2,r2,128
8114331c:	10bfe004 	addi	r2,r2,-128
81143320:	10800bd8 	cmpnei	r2,r2,47
81143324:	1000041e 	bne	r2,zero,81143338 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
81143328:	e0bffa17 	ldw	r2,-24(fp)
8114332c:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
81143330:	e0bffa17 	ldw	r2,-24(fp)
81143334:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
81143338:	e0bffa17 	ldw	r2,-24(fp)
8114333c:	e0ffff17 	ldw	r3,-4(fp)
81143340:	1885883a 	add	r2,r3,r2
81143344:	10800003 	ldbu	r2,0(r2)
81143348:	10803fcc 	andi	r2,r2,255
8114334c:	1080201c 	xori	r2,r2,128
81143350:	10bfe004 	addi	r2,r2,-128
81143354:	10800b98 	cmpnei	r2,r2,46
81143358:	1000021e 	bne	r2,zero,81143364 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8114335c:	e0bffa17 	ldw	r2,-24(fp)
81143360:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
81143364:	e0bffa17 	ldw	r2,-24(fp)
81143368:	10800044 	addi	r2,r2,1
8114336c:	e0bffa15 	stw	r2,-24(fp)
81143370:	e0fffa17 	ldw	r3,-24(fp)
81143374:	e0bffe17 	ldw	r2,-8(fp)
81143378:	18bf9016 	blt	r3,r2,811431bc <__reset+0xfb1231bc>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8114337c:	e0bffe17 	ldw	r2,-8(fp)
81143380:	10bfffc4 	addi	r2,r2,-1
81143384:	e0ffff17 	ldw	r3,-4(fp)
81143388:	1885883a 	add	r2,r3,r2
8114338c:	10800003 	ldbu	r2,0(r2)
81143390:	10803fcc 	andi	r2,r2,255
81143394:	1080201c 	xori	r2,r2,128
81143398:	10bfe004 	addi	r2,r2,-128
8114339c:	10801720 	cmpeqi	r2,r2,92
811433a0:	10000a1e 	bne	r2,zero,811433cc <check_file_name_for_FAT16_compliance+0x258>
811433a4:	e0bffe17 	ldw	r2,-8(fp)
811433a8:	10bfffc4 	addi	r2,r2,-1
811433ac:	e0ffff17 	ldw	r3,-4(fp)
811433b0:	1885883a 	add	r2,r3,r2
811433b4:	10800003 	ldbu	r2,0(r2)
811433b8:	10803fcc 	andi	r2,r2,255
811433bc:	1080201c 	xori	r2,r2,128
811433c0:	10bfe004 	addi	r2,r2,-128
811433c4:	10800bd8 	cmpnei	r2,r2,47
811433c8:	1000011e 	bne	r2,zero,811433d0 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
811433cc:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
811433d0:	e0bffd17 	ldw	r2,-12(fp)
}
811433d4:	e037883a 	mov	sp,fp
811433d8:	dfc00117 	ldw	ra,4(sp)
811433dc:	df000017 	ldw	fp,0(sp)
811433e0:	dec00204 	addi	sp,sp,8
811433e4:	f800283a 	ret

811433e8 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
811433e8:	defffb04 	addi	sp,sp,-20
811433ec:	de00012e 	bgeu	sp,et,811433f4 <get_dir_divider_location+0xc>
811433f0:	003b68fa 	trap	3
811433f4:	dfc00415 	stw	ra,16(sp)
811433f8:	df000315 	stw	fp,12(sp)
811433fc:	df000304 	addi	fp,sp,12
81143400:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
81143404:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
81143408:	e13fff17 	ldw	r4,-4(fp)
8114340c:	1122ee80 	call	81122ee8 <strlen>
81143410:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
81143414:	e03ffd15 	stw	zero,-12(fp)
81143418:	00001506 	br	81143470 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8114341c:	e0bffd17 	ldw	r2,-12(fp)
81143420:	e0ffff17 	ldw	r3,-4(fp)
81143424:	1885883a 	add	r2,r3,r2
81143428:	10800003 	ldbu	r2,0(r2)
8114342c:	10803fcc 	andi	r2,r2,255
81143430:	1080201c 	xori	r2,r2,128
81143434:	10bfe004 	addi	r2,r2,-128
81143438:	10801720 	cmpeqi	r2,r2,92
8114343c:	10000f1e 	bne	r2,zero,8114347c <get_dir_divider_location+0x94>
81143440:	e0bffd17 	ldw	r2,-12(fp)
81143444:	e0ffff17 	ldw	r3,-4(fp)
81143448:	1885883a 	add	r2,r3,r2
8114344c:	10800003 	ldbu	r2,0(r2)
81143450:	10803fcc 	andi	r2,r2,255
81143454:	1080201c 	xori	r2,r2,128
81143458:	10bfe004 	addi	r2,r2,-128
8114345c:	10800be0 	cmpeqi	r2,r2,47
81143460:	1000061e 	bne	r2,zero,8114347c <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
81143464:	e0bffd17 	ldw	r2,-12(fp)
81143468:	10800044 	addi	r2,r2,1
8114346c:	e0bffd15 	stw	r2,-12(fp)
81143470:	e0fffd17 	ldw	r3,-12(fp)
81143474:	e0bffe17 	ldw	r2,-8(fp)
81143478:	18bfe816 	blt	r3,r2,8114341c <__reset+0xfb12341c>
        {
            break;
        }
    }
    
    if (index == length)
8114347c:	e0fffd17 	ldw	r3,-12(fp)
81143480:	e0bffe17 	ldw	r2,-8(fp)
81143484:	1880021e 	bne	r3,r2,81143490 <get_dir_divider_location+0xa8>
    {
        index = -1;
81143488:	00bfffc4 	movi	r2,-1
8114348c:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
81143490:	e0bffd17 	ldw	r2,-12(fp)
}
81143494:	e037883a 	mov	sp,fp
81143498:	dfc00117 	ldw	ra,4(sp)
8114349c:	df000017 	ldw	fp,0(sp)
811434a0:	dec00204 	addi	sp,sp,8
811434a4:	f800283a 	ret

811434a8 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
811434a8:	defffa04 	addi	sp,sp,-24
811434ac:	de00012e 	bgeu	sp,et,811434b4 <match_file_record_to_name_ext+0xc>
811434b0:	003b68fa 	trap	3
811434b4:	df000515 	stw	fp,20(sp)
811434b8:	df000504 	addi	fp,sp,20
811434bc:	e13ffd15 	stw	r4,-12(fp)
811434c0:	e17ffe15 	stw	r5,-8(fp)
811434c4:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
811434c8:	00800044 	movi	r2,1
811434cc:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
811434d0:	e03ffc15 	stw	zero,-16(fp)
811434d4:	00004606 	br	811435f0 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
811434d8:	e0fffd17 	ldw	r3,-12(fp)
811434dc:	e0bffc17 	ldw	r2,-16(fp)
811434e0:	1885883a 	add	r2,r3,r2
811434e4:	10800003 	ldbu	r2,0(r2)
811434e8:	10803fcc 	andi	r2,r2,255
811434ec:	10801870 	cmpltui	r2,r2,97
811434f0:	1000101e 	bne	r2,zero,81143534 <match_file_record_to_name_ext+0x8c>
811434f4:	e0fffd17 	ldw	r3,-12(fp)
811434f8:	e0bffc17 	ldw	r2,-16(fp)
811434fc:	1885883a 	add	r2,r3,r2
81143500:	10800003 	ldbu	r2,0(r2)
81143504:	10803fcc 	andi	r2,r2,255
81143508:	10801ee8 	cmpgeui	r2,r2,123
8114350c:	1000091e 	bne	r2,zero,81143534 <match_file_record_to_name_ext+0x8c>
81143510:	e0fffd17 	ldw	r3,-12(fp)
81143514:	e0bffc17 	ldw	r2,-16(fp)
81143518:	1885883a 	add	r2,r3,r2
8114351c:	10800003 	ldbu	r2,0(r2)
81143520:	10bff804 	addi	r2,r2,-32
81143524:	10c03fcc 	andi	r3,r2,255
81143528:	18c0201c 	xori	r3,r3,128
8114352c:	18ffe004 	addi	r3,r3,-128
81143530:	00000706 	br	81143550 <match_file_record_to_name_ext+0xa8>
81143534:	e0fffd17 	ldw	r3,-12(fp)
81143538:	e0bffc17 	ldw	r2,-16(fp)
8114353c:	1885883a 	add	r2,r3,r2
81143540:	10800003 	ldbu	r2,0(r2)
81143544:	10c03fcc 	andi	r3,r2,255
81143548:	18c0201c 	xori	r3,r3,128
8114354c:	18ffe004 	addi	r3,r3,-128
81143550:	e0bffc17 	ldw	r2,-16(fp)
81143554:	e13ffe17 	ldw	r4,-8(fp)
81143558:	2085883a 	add	r2,r4,r2
8114355c:	10800003 	ldbu	r2,0(r2)
81143560:	10803fcc 	andi	r2,r2,255
81143564:	1080201c 	xori	r2,r2,128
81143568:	10bfe004 	addi	r2,r2,-128
8114356c:	10801850 	cmplti	r2,r2,97
81143570:	1000121e 	bne	r2,zero,811435bc <match_file_record_to_name_ext+0x114>
81143574:	e0bffc17 	ldw	r2,-16(fp)
81143578:	e13ffe17 	ldw	r4,-8(fp)
8114357c:	2085883a 	add	r2,r4,r2
81143580:	10800003 	ldbu	r2,0(r2)
81143584:	10803fcc 	andi	r2,r2,255
81143588:	1080201c 	xori	r2,r2,128
8114358c:	10bfe004 	addi	r2,r2,-128
81143590:	10801ec8 	cmpgei	r2,r2,123
81143594:	1000091e 	bne	r2,zero,811435bc <match_file_record_to_name_ext+0x114>
81143598:	e0bffc17 	ldw	r2,-16(fp)
8114359c:	e13ffe17 	ldw	r4,-8(fp)
811435a0:	2085883a 	add	r2,r4,r2
811435a4:	10800003 	ldbu	r2,0(r2)
811435a8:	10bff804 	addi	r2,r2,-32
811435ac:	10803fcc 	andi	r2,r2,255
811435b0:	1080201c 	xori	r2,r2,128
811435b4:	10bfe004 	addi	r2,r2,-128
811435b8:	00000706 	br	811435d8 <match_file_record_to_name_ext+0x130>
811435bc:	e0bffc17 	ldw	r2,-16(fp)
811435c0:	e13ffe17 	ldw	r4,-8(fp)
811435c4:	2085883a 	add	r2,r4,r2
811435c8:	10800003 	ldbu	r2,0(r2)
811435cc:	10803fcc 	andi	r2,r2,255
811435d0:	1080201c 	xori	r2,r2,128
811435d4:	10bfe004 	addi	r2,r2,-128
811435d8:	18800226 	beq	r3,r2,811435e4 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
811435dc:	e03ffb15 	stw	zero,-20(fp)
			break;
811435e0:	00000606 	br	811435fc <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
811435e4:	e0bffc17 	ldw	r2,-16(fp)
811435e8:	10800044 	addi	r2,r2,1
811435ec:	e0bffc15 	stw	r2,-16(fp)
811435f0:	e0bffc17 	ldw	r2,-16(fp)
811435f4:	10800210 	cmplti	r2,r2,8
811435f8:	103fb71e 	bne	r2,zero,811434d8 <__reset+0xfb1234d8>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
811435fc:	e03ffc15 	stw	zero,-16(fp)
81143600:	00004a06 	br	8114372c <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
81143604:	e0fffd17 	ldw	r3,-12(fp)
81143608:	e0bffc17 	ldw	r2,-16(fp)
8114360c:	1885883a 	add	r2,r3,r2
81143610:	10800204 	addi	r2,r2,8
81143614:	10800003 	ldbu	r2,0(r2)
81143618:	10803fcc 	andi	r2,r2,255
8114361c:	10801870 	cmpltui	r2,r2,97
81143620:	1000121e 	bne	r2,zero,8114366c <match_file_record_to_name_ext+0x1c4>
81143624:	e0fffd17 	ldw	r3,-12(fp)
81143628:	e0bffc17 	ldw	r2,-16(fp)
8114362c:	1885883a 	add	r2,r3,r2
81143630:	10800204 	addi	r2,r2,8
81143634:	10800003 	ldbu	r2,0(r2)
81143638:	10803fcc 	andi	r2,r2,255
8114363c:	10801ee8 	cmpgeui	r2,r2,123
81143640:	10000a1e 	bne	r2,zero,8114366c <match_file_record_to_name_ext+0x1c4>
81143644:	e0fffd17 	ldw	r3,-12(fp)
81143648:	e0bffc17 	ldw	r2,-16(fp)
8114364c:	1885883a 	add	r2,r3,r2
81143650:	10800204 	addi	r2,r2,8
81143654:	10800003 	ldbu	r2,0(r2)
81143658:	10bff804 	addi	r2,r2,-32
8114365c:	10c03fcc 	andi	r3,r2,255
81143660:	18c0201c 	xori	r3,r3,128
81143664:	18ffe004 	addi	r3,r3,-128
81143668:	00000806 	br	8114368c <match_file_record_to_name_ext+0x1e4>
8114366c:	e0fffd17 	ldw	r3,-12(fp)
81143670:	e0bffc17 	ldw	r2,-16(fp)
81143674:	1885883a 	add	r2,r3,r2
81143678:	10800204 	addi	r2,r2,8
8114367c:	10800003 	ldbu	r2,0(r2)
81143680:	10c03fcc 	andi	r3,r2,255
81143684:	18c0201c 	xori	r3,r3,128
81143688:	18ffe004 	addi	r3,r3,-128
8114368c:	e0bffc17 	ldw	r2,-16(fp)
81143690:	e13fff17 	ldw	r4,-4(fp)
81143694:	2085883a 	add	r2,r4,r2
81143698:	10800003 	ldbu	r2,0(r2)
8114369c:	10803fcc 	andi	r2,r2,255
811436a0:	1080201c 	xori	r2,r2,128
811436a4:	10bfe004 	addi	r2,r2,-128
811436a8:	10801850 	cmplti	r2,r2,97
811436ac:	1000121e 	bne	r2,zero,811436f8 <match_file_record_to_name_ext+0x250>
811436b0:	e0bffc17 	ldw	r2,-16(fp)
811436b4:	e13fff17 	ldw	r4,-4(fp)
811436b8:	2085883a 	add	r2,r4,r2
811436bc:	10800003 	ldbu	r2,0(r2)
811436c0:	10803fcc 	andi	r2,r2,255
811436c4:	1080201c 	xori	r2,r2,128
811436c8:	10bfe004 	addi	r2,r2,-128
811436cc:	10801ec8 	cmpgei	r2,r2,123
811436d0:	1000091e 	bne	r2,zero,811436f8 <match_file_record_to_name_ext+0x250>
811436d4:	e0bffc17 	ldw	r2,-16(fp)
811436d8:	e13fff17 	ldw	r4,-4(fp)
811436dc:	2085883a 	add	r2,r4,r2
811436e0:	10800003 	ldbu	r2,0(r2)
811436e4:	10bff804 	addi	r2,r2,-32
811436e8:	10803fcc 	andi	r2,r2,255
811436ec:	1080201c 	xori	r2,r2,128
811436f0:	10bfe004 	addi	r2,r2,-128
811436f4:	00000706 	br	81143714 <match_file_record_to_name_ext+0x26c>
811436f8:	e0bffc17 	ldw	r2,-16(fp)
811436fc:	e13fff17 	ldw	r4,-4(fp)
81143700:	2085883a 	add	r2,r4,r2
81143704:	10800003 	ldbu	r2,0(r2)
81143708:	10803fcc 	andi	r2,r2,255
8114370c:	1080201c 	xori	r2,r2,128
81143710:	10bfe004 	addi	r2,r2,-128
81143714:	18800226 	beq	r3,r2,81143720 <match_file_record_to_name_ext+0x278>
        {
            match = false;
81143718:	e03ffb15 	stw	zero,-20(fp)
			break;
8114371c:	00000606 	br	81143738 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81143720:	e0bffc17 	ldw	r2,-16(fp)
81143724:	10800044 	addi	r2,r2,1
81143728:	e0bffc15 	stw	r2,-16(fp)
8114372c:	e0bffc17 	ldw	r2,-16(fp)
81143730:	108000d0 	cmplti	r2,r2,3
81143734:	103fb31e 	bne	r2,zero,81143604 <__reset+0xfb123604>
        {
            match = false;
			break;
        }
    }
	return match;
81143738:	e0bffb17 	ldw	r2,-20(fp)
}
8114373c:	e037883a 	mov	sp,fp
81143740:	df000017 	ldw	fp,0(sp)
81143744:	dec00104 	addi	sp,sp,4
81143748:	f800283a 	ret

8114374c <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8114374c:	deffe704 	addi	sp,sp,-100
81143750:	de00012e 	bgeu	sp,et,81143758 <get_home_directory_cluster_for_file+0xc>
81143754:	003b68fa 	trap	3
81143758:	dfc01815 	stw	ra,96(sp)
8114375c:	df001715 	stw	fp,92(sp)
81143760:	df001704 	addi	fp,sp,92
81143764:	e13ffd15 	stw	r4,-12(fp)
81143768:	e17ffe15 	stw	r5,-8(fp)
8114376c:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81143770:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81143774:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81143778:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8114377c:	e13ffd17 	ldw	r4,-12(fp)
81143780:	11433e80 	call	811433e8 <get_dir_divider_location>
81143784:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81143788:	00012f06 	br	81143c48 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8114378c:	00800804 	movi	r2,32
81143790:	e0bff905 	stb	r2,-28(fp)
81143794:	00800804 	movi	r2,32
81143798:	e0bff945 	stb	r2,-27(fp)
8114379c:	00800804 	movi	r2,32
811437a0:	e0bff985 	stb	r2,-26(fp)
811437a4:	00800804 	movi	r2,32
811437a8:	e0bff9c5 	stb	r2,-25(fp)
811437ac:	00800804 	movi	r2,32
811437b0:	e0bffa05 	stb	r2,-24(fp)
811437b4:	00800804 	movi	r2,32
811437b8:	e0bffa45 	stb	r2,-23(fp)
811437bc:	00800804 	movi	r2,32
811437c0:	e0bffa85 	stb	r2,-22(fp)
811437c4:	00800804 	movi	r2,32
811437c8:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
811437cc:	00800804 	movi	r2,32
811437d0:	e0bffb05 	stb	r2,-20(fp)
811437d4:	00800804 	movi	r2,32
811437d8:	e0bffb45 	stb	r2,-19(fp)
811437dc:	00800804 	movi	r2,32
811437e0:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
811437e4:	00bfffc4 	movi	r2,-1
811437e8:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
811437ec:	e0bfea17 	ldw	r2,-88(fp)
811437f0:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
811437f4:	e03fec15 	stw	zero,-80(fp)
811437f8:	00002d06 	br	811438b0 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
811437fc:	e0ffec17 	ldw	r3,-80(fp)
81143800:	e0bfed17 	ldw	r2,-76(fp)
81143804:	1885883a 	add	r2,r3,r2
81143808:	1007883a 	mov	r3,r2
8114380c:	e0bffd17 	ldw	r2,-12(fp)
81143810:	10c5883a 	add	r2,r2,r3
81143814:	10800003 	ldbu	r2,0(r2)
81143818:	10803fcc 	andi	r2,r2,255
8114381c:	1080201c 	xori	r2,r2,128
81143820:	10bfe004 	addi	r2,r2,-128
81143824:	10800b98 	cmpnei	r2,r2,46
81143828:	1000031e 	bne	r2,zero,81143838 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8114382c:	e0bfec17 	ldw	r2,-80(fp)
81143830:	e0bfee15 	stw	r2,-72(fp)
81143834:	00001b06 	br	811438a4 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81143838:	e0bfee17 	ldw	r2,-72(fp)
8114383c:	10000c0e 	bge	r2,zero,81143870 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81143840:	e0ffec17 	ldw	r3,-80(fp)
81143844:	e0bfed17 	ldw	r2,-76(fp)
81143848:	1885883a 	add	r2,r3,r2
8114384c:	1007883a 	mov	r3,r2
81143850:	e0bffd17 	ldw	r2,-12(fp)
81143854:	10c5883a 	add	r2,r2,r3
81143858:	10c00003 	ldbu	r3,0(r2)
8114385c:	e13ff904 	addi	r4,fp,-28
81143860:	e0bfec17 	ldw	r2,-80(fp)
81143864:	2085883a 	add	r2,r4,r2
81143868:	10c00005 	stb	r3,0(r2)
8114386c:	00000d06 	br	811438a4 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81143870:	e0ffec17 	ldw	r3,-80(fp)
81143874:	e0bfee17 	ldw	r2,-72(fp)
81143878:	1885c83a 	sub	r2,r3,r2
8114387c:	e13fec17 	ldw	r4,-80(fp)
81143880:	e0ffed17 	ldw	r3,-76(fp)
81143884:	20c7883a 	add	r3,r4,r3
81143888:	1809883a 	mov	r4,r3
8114388c:	e0fffd17 	ldw	r3,-12(fp)
81143890:	1907883a 	add	r3,r3,r4
81143894:	18c00003 	ldbu	r3,0(r3)
81143898:	e13ffb04 	addi	r4,fp,-20
8114389c:	2085883a 	add	r2,r4,r2
811438a0:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
811438a4:	e0bfec17 	ldw	r2,-80(fp)
811438a8:	10800044 	addi	r2,r2,1
811438ac:	e0bfec15 	stw	r2,-80(fp)
811438b0:	e0ffec17 	ldw	r3,-80(fp)
811438b4:	e0bfeb17 	ldw	r2,-84(fp)
811438b8:	18bfd016 	blt	r3,r2,811437fc <__reset+0xfb1237fc>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
811438bc:	e0bfea17 	ldw	r2,-88(fp)
811438c0:	10005c1e 	bne	r2,zero,81143a34 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811438c4:	00a045f4 	movhi	r2,33047
811438c8:	10b32704 	addi	r2,r2,-13156
811438cc:	1080050b 	ldhu	r2,20(r2)
811438d0:	10bfffcc 	andi	r2,r2,65535
811438d4:	1006917a 	slli	r3,r2,5
811438d8:	00a045f4 	movhi	r2,33047
811438dc:	10b32704 	addi	r2,r2,-13156
811438e0:	1080030b 	ldhu	r2,12(r2)
811438e4:	10bfffcc 	andi	r2,r2,65535
811438e8:	1885283a 	div	r2,r3,r2
811438ec:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811438f0:	e03ff015 	stw	zero,-64(fp)
811438f4:	00003b06 	br	811439e4 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
811438f8:	00a045f4 	movhi	r2,33047
811438fc:	10b32704 	addi	r2,r2,-13156
81143900:	10c01317 	ldw	r3,76(r2)
81143904:	e0bff017 	ldw	r2,-64(fp)
81143908:	1885883a 	add	r2,r3,r2
8114390c:	1007883a 	mov	r3,r2
81143910:	d0a0b117 	ldw	r2,-32060(gp)
81143914:	100b883a 	mov	r5,r2
81143918:	1809883a 	mov	r4,r3
8114391c:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81143920:	10003426 	beq	r2,zero,811439f4 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81143924:	e03ff115 	stw	zero,-60(fp)
81143928:	00002506 	br	811439c0 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8114392c:	e0bff117 	ldw	r2,-60(fp)
81143930:	1004917a 	slli	r2,r2,5
81143934:	e0fff017 	ldw	r3,-64(fp)
81143938:	180f883a 	mov	r7,r3
8114393c:	000d883a 	mov	r6,zero
81143940:	e17fff17 	ldw	r5,-4(fp)
81143944:	1009883a 	mov	r4,r2
81143948:	11424140 	call	81142414 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8114394c:	e0bfff17 	ldw	r2,-4(fp)
81143950:	10800003 	ldbu	r2,0(r2)
81143954:	10803fcc 	andi	r2,r2,255
81143958:	10803960 	cmpeqi	r2,r2,229
8114395c:	1000151e 	bne	r2,zero,811439b4 <get_home_directory_cluster_for_file+0x268>
81143960:	e0bfff17 	ldw	r2,-4(fp)
81143964:	10800003 	ldbu	r2,0(r2)
81143968:	10803fcc 	andi	r2,r2,255
8114396c:	10001126 	beq	r2,zero,811439b4 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81143970:	e0fffb04 	addi	r3,fp,-20
81143974:	e0bff904 	addi	r2,fp,-28
81143978:	180d883a 	mov	r6,r3
8114397c:	100b883a 	mov	r5,r2
81143980:	e13fff17 	ldw	r4,-4(fp)
81143984:	11434a80 	call	811434a8 <match_file_record_to_name_ext>
81143988:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8114398c:	e0bff817 	ldw	r2,-32(fp)
81143990:	10000826 	beq	r2,zero,811439b4 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81143994:	e0bfff17 	ldw	r2,-4(fp)
81143998:	1080058b 	ldhu	r2,22(r2)
8114399c:	10bfffcc 	andi	r2,r2,65535
811439a0:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
811439a4:	e0bfff17 	ldw	r2,-4(fp)
811439a8:	00c00044 	movi	r3,1
811439ac:	10c00a15 	stw	r3,40(r2)
                                break;
811439b0:	00000606 	br	811439cc <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811439b4:	e0bff117 	ldw	r2,-60(fp)
811439b8:	10800044 	addi	r2,r2,1
811439bc:	e0bff115 	stw	r2,-60(fp)
811439c0:	e0bff117 	ldw	r2,-60(fp)
811439c4:	10800410 	cmplti	r2,r2,16
811439c8:	103fd81e 	bne	r2,zero,8114392c <__reset+0xfb12392c>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
811439cc:	e0ffef17 	ldw	r3,-68(fp)
811439d0:	e0bfea17 	ldw	r2,-88(fp)
811439d4:	1880091e 	bne	r3,r2,811439fc <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811439d8:	e0bff017 	ldw	r2,-64(fp)
811439dc:	10800044 	addi	r2,r2,1
811439e0:	e0bff015 	stw	r2,-64(fp)
811439e4:	e0fff017 	ldw	r3,-64(fp)
811439e8:	e0bff717 	ldw	r2,-36(fp)
811439ec:	18bfc216 	blt	r3,r2,811438f8 <__reset+0xfb1238f8>
811439f0:	00000306 	br	81143a00 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
811439f4:	0001883a 	nop
811439f8:	00000106 	br	81143a00 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
811439fc:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81143a00:	e0ffef17 	ldw	r3,-68(fp)
81143a04:	e0bfea17 	ldw	r2,-88(fp)
81143a08:	18800826 	beq	r3,r2,81143a2c <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81143a0c:	e0bfef17 	ldw	r2,-68(fp)
81143a10:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81143a14:	e0ffed17 	ldw	r3,-76(fp)
81143a18:	e0bfeb17 	ldw	r2,-84(fp)
81143a1c:	1885883a 	add	r2,r3,r2
81143a20:	10800044 	addi	r2,r2,1
81143a24:	e0bfed15 	stw	r2,-76(fp)
81143a28:	00007d06 	br	81143c20 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81143a2c:	0005883a 	mov	r2,zero
81143a30:	00009106 	br	81143c78 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81143a34:	e0bfea17 	ldw	r2,-88(fp)
81143a38:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81143a3c:	e0bff417 	ldw	r2,-48(fp)
81143a40:	10ffff84 	addi	r3,r2,-2
81143a44:	00a045f4 	movhi	r2,33047
81143a48:	10b32704 	addi	r2,r2,-13156
81143a4c:	10800383 	ldbu	r2,14(r2)
81143a50:	10803fcc 	andi	r2,r2,255
81143a54:	1885383a 	mul	r2,r3,r2
81143a58:	1007883a 	mov	r3,r2
81143a5c:	00a045f4 	movhi	r2,33047
81143a60:	10b32704 	addi	r2,r2,-13156
81143a64:	10801417 	ldw	r2,80(r2)
81143a68:	1885883a 	add	r2,r3,r2
81143a6c:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143a70:	e03ff215 	stw	zero,-56(fp)
81143a74:	00003606 	br	81143b50 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81143a78:	e0fff217 	ldw	r3,-56(fp)
81143a7c:	e0bff517 	ldw	r2,-44(fp)
81143a80:	1885883a 	add	r2,r3,r2
81143a84:	d0e0b117 	ldw	r3,-32060(gp)
81143a88:	180b883a 	mov	r5,r3
81143a8c:	1009883a 	mov	r4,r2
81143a90:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81143a94:	10003526 	beq	r2,zero,81143b6c <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81143a98:	e03ff315 	stw	zero,-52(fp)
81143a9c:	00002306 	br	81143b2c <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81143aa0:	e0bff317 	ldw	r2,-52(fp)
81143aa4:	1004917a 	slli	r2,r2,5
81143aa8:	e0fff417 	ldw	r3,-48(fp)
81143aac:	e13ff217 	ldw	r4,-56(fp)
81143ab0:	200f883a 	mov	r7,r4
81143ab4:	180d883a 	mov	r6,r3
81143ab8:	e17fff17 	ldw	r5,-4(fp)
81143abc:	1009883a 	mov	r4,r2
81143ac0:	11424140 	call	81142414 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143ac4:	e0bfff17 	ldw	r2,-4(fp)
81143ac8:	10800003 	ldbu	r2,0(r2)
81143acc:	10803fcc 	andi	r2,r2,255
81143ad0:	10803960 	cmpeqi	r2,r2,229
81143ad4:	1000121e 	bne	r2,zero,81143b20 <get_home_directory_cluster_for_file+0x3d4>
81143ad8:	e0bfff17 	ldw	r2,-4(fp)
81143adc:	10800003 	ldbu	r2,0(r2)
81143ae0:	10803fcc 	andi	r2,r2,255
81143ae4:	10000e26 	beq	r2,zero,81143b20 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81143ae8:	e0fffb04 	addi	r3,fp,-20
81143aec:	e0bff904 	addi	r2,fp,-28
81143af0:	180d883a 	mov	r6,r3
81143af4:	100b883a 	mov	r5,r2
81143af8:	e13fff17 	ldw	r4,-4(fp)
81143afc:	11434a80 	call	811434a8 <match_file_record_to_name_ext>
81143b00:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81143b04:	e0bff617 	ldw	r2,-40(fp)
81143b08:	10000526 	beq	r2,zero,81143b20 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81143b0c:	e0bfff17 	ldw	r2,-4(fp)
81143b10:	1080058b 	ldhu	r2,22(r2)
81143b14:	10bfffcc 	andi	r2,r2,65535
81143b18:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81143b1c:	00000606 	br	81143b38 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81143b20:	e0bff317 	ldw	r2,-52(fp)
81143b24:	10800044 	addi	r2,r2,1
81143b28:	e0bff315 	stw	r2,-52(fp)
81143b2c:	e0bff317 	ldw	r2,-52(fp)
81143b30:	10800410 	cmplti	r2,r2,16
81143b34:	103fda1e 	bne	r2,zero,81143aa0 <__reset+0xfb123aa0>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81143b38:	e0ffef17 	ldw	r3,-68(fp)
81143b3c:	e0bfea17 	ldw	r2,-88(fp)
81143b40:	18800c1e 	bne	r3,r2,81143b74 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143b44:	e0bff217 	ldw	r2,-56(fp)
81143b48:	10800044 	addi	r2,r2,1
81143b4c:	e0bff215 	stw	r2,-56(fp)
81143b50:	00a045f4 	movhi	r2,33047
81143b54:	10b32704 	addi	r2,r2,-13156
81143b58:	10800383 	ldbu	r2,14(r2)
81143b5c:	10803fcc 	andi	r2,r2,255
81143b60:	e0fff217 	ldw	r3,-56(fp)
81143b64:	18bfc416 	blt	r3,r2,81143a78 <__reset+0xfb123a78>
81143b68:	00000306 	br	81143b78 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81143b6c:	0001883a 	nop
81143b70:	00000106 	br	81143b78 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
81143b74:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81143b78:	e0ffef17 	ldw	r3,-68(fp)
81143b7c:	e0bfea17 	ldw	r2,-88(fp)
81143b80:	1880141e 	bne	r3,r2,81143bd4 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
81143b84:	e0bfef17 	ldw	r2,-68(fp)
81143b88:	e0fffc04 	addi	r3,fp,-16
81143b8c:	180b883a 	mov	r5,r3
81143b90:	1009883a 	mov	r4,r2
81143b94:	11420c40 	call	811420c4 <get_cluster_flag>
81143b98:	10000c26 	beq	r2,zero,81143bcc <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81143b9c:	e0bffc0b 	ldhu	r2,-16(fp)
81143ba0:	10bfffcc 	andi	r2,r2,65535
81143ba4:	10fffe0c 	andi	r3,r2,65528
81143ba8:	00bffe14 	movui	r2,65528
81143bac:	1880021e 	bne	r3,r2,81143bb8 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81143bb0:	0005883a 	mov	r2,zero
81143bb4:	00003006 	br	81143c78 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81143bb8:	e0bffc0b 	ldhu	r2,-16(fp)
81143bbc:	10bfffcc 	andi	r2,r2,65535
81143bc0:	10bffe0c 	andi	r2,r2,65528
81143bc4:	e0bfef15 	stw	r2,-68(fp)
81143bc8:	00000206 	br	81143bd4 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81143bcc:	0005883a 	mov	r2,zero
81143bd0:	00002906 	br	81143c78 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81143bd4:	e0bff417 	ldw	r2,-48(fp)
81143bd8:	00fffdd4 	movui	r3,65527
81143bdc:	18800316 	blt	r3,r2,81143bec <get_home_directory_cluster_for_file+0x4a0>
81143be0:	e0ffef17 	ldw	r3,-68(fp)
81143be4:	e0bfea17 	ldw	r2,-88(fp)
81143be8:	18bf9426 	beq	r3,r2,81143a3c <__reset+0xfb123a3c>
            if (new_cluster != home_dir_cluster)
81143bec:	e0ffef17 	ldw	r3,-68(fp)
81143bf0:	e0bfea17 	ldw	r2,-88(fp)
81143bf4:	18800826 	beq	r3,r2,81143c18 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81143bf8:	e0bfef17 	ldw	r2,-68(fp)
81143bfc:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81143c00:	e0ffed17 	ldw	r3,-76(fp)
81143c04:	e0bfeb17 	ldw	r2,-84(fp)
81143c08:	1885883a 	add	r2,r3,r2
81143c0c:	10800044 	addi	r2,r2,1
81143c10:	e0bfed15 	stw	r2,-76(fp)
81143c14:	00000206 	br	81143c20 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81143c18:	0005883a 	mov	r2,zero
81143c1c:	00001606 	br	81143c78 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81143c20:	e0bfed17 	ldw	r2,-76(fp)
81143c24:	e0fffd17 	ldw	r3,-12(fp)
81143c28:	1885883a 	add	r2,r3,r2
81143c2c:	1009883a 	mov	r4,r2
81143c30:	11433e80 	call	811433e8 <get_dir_divider_location>
81143c34:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81143c38:	e0bfeb17 	ldw	r2,-84(fp)
81143c3c:	1000020e 	bge	r2,zero,81143c48 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81143c40:	00800044 	movi	r2,1
81143c44:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81143c48:	e0bfeb17 	ldw	r2,-84(fp)
81143c4c:	00becf16 	blt	zero,r2,8114378c <__reset+0xfb12378c>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81143c50:	e0bffe17 	ldw	r2,-8(fp)
81143c54:	e0ffea17 	ldw	r3,-88(fp)
81143c58:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81143c5c:	e0bfea17 	ldw	r2,-88(fp)
81143c60:	1000041e 	bne	r2,zero,81143c74 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81143c64:	e0bfff17 	ldw	r2,-4(fp)
81143c68:	10000a15 	stw	zero,40(r2)
		result = true;
81143c6c:	00800044 	movi	r2,1
81143c70:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
81143c74:	e0bfe917 	ldw	r2,-92(fp)
}
81143c78:	e037883a 	mov	sp,fp
81143c7c:	dfc00117 	ldw	ra,4(sp)
81143c80:	df000017 	ldw	fp,0(sp)
81143c84:	dec00204 	addi	sp,sp,8
81143c88:	f800283a 	ret

81143c8c <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81143c8c:	deffe804 	addi	sp,sp,-96
81143c90:	de00012e 	bgeu	sp,et,81143c98 <find_file_in_directory+0xc>
81143c94:	003b68fa 	trap	3
81143c98:	dfc01715 	stw	ra,92(sp)
81143c9c:	df001615 	stw	fp,88(sp)
81143ca0:	df001604 	addi	fp,sp,88
81143ca4:	e13ffd15 	stw	r4,-12(fp)
81143ca8:	e17ffe15 	stw	r5,-8(fp)
81143cac:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81143cb0:	e13ffe17 	ldw	r4,-8(fp)
81143cb4:	11433e80 	call	811433e8 <get_dir_divider_location>
81143cb8:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81143cbc:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81143cc0:	00800804 	movi	r2,32
81143cc4:	e0bff905 	stb	r2,-28(fp)
81143cc8:	00800804 	movi	r2,32
81143ccc:	e0bff945 	stb	r2,-27(fp)
81143cd0:	00800804 	movi	r2,32
81143cd4:	e0bff985 	stb	r2,-26(fp)
81143cd8:	00800804 	movi	r2,32
81143cdc:	e0bff9c5 	stb	r2,-25(fp)
81143ce0:	00800804 	movi	r2,32
81143ce4:	e0bffa05 	stb	r2,-24(fp)
81143ce8:	00800804 	movi	r2,32
81143cec:	e0bffa45 	stb	r2,-23(fp)
81143cf0:	00800804 	movi	r2,32
81143cf4:	e0bffa85 	stb	r2,-22(fp)
81143cf8:	00800804 	movi	r2,32
81143cfc:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81143d00:	00800804 	movi	r2,32
81143d04:	e0bffb05 	stb	r2,-20(fp)
81143d08:	00800804 	movi	r2,32
81143d0c:	e0bffb45 	stb	r2,-19(fp)
81143d10:	00800804 	movi	r2,32
81143d14:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81143d18:	00bfffc4 	movi	r2,-1
81143d1c:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81143d20:	e0bffd17 	ldw	r2,-12(fp)
81143d24:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81143d28:	e13ffe17 	ldw	r4,-8(fp)
81143d2c:	1122ee80 	call	81122ee8 <strlen>
81143d30:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81143d34:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81143d38:	00000b06 	br	81143d68 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81143d3c:	e0ffeb17 	ldw	r3,-84(fp)
81143d40:	e0bfea17 	ldw	r2,-88(fp)
81143d44:	1885883a 	add	r2,r3,r2
81143d48:	10800044 	addi	r2,r2,1
81143d4c:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81143d50:	e0bfeb17 	ldw	r2,-84(fp)
81143d54:	e0fffe17 	ldw	r3,-8(fp)
81143d58:	1885883a 	add	r2,r3,r2
81143d5c:	1009883a 	mov	r4,r2
81143d60:	11433e80 	call	811433e8 <get_dir_divider_location>
81143d64:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81143d68:	e0bfea17 	ldw	r2,-88(fp)
81143d6c:	00bff316 	blt	zero,r2,81143d3c <__reset+0xfb123d3c>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81143d70:	e0bfeb17 	ldw	r2,-84(fp)
81143d74:	e0bfee15 	stw	r2,-72(fp)
81143d78:	00002706 	br	81143e18 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
81143d7c:	e0bfee17 	ldw	r2,-72(fp)
81143d80:	e0fffe17 	ldw	r3,-8(fp)
81143d84:	1885883a 	add	r2,r3,r2
81143d88:	10800003 	ldbu	r2,0(r2)
81143d8c:	10803fcc 	andi	r2,r2,255
81143d90:	1080201c 	xori	r2,r2,128
81143d94:	10bfe004 	addi	r2,r2,-128
81143d98:	10800b98 	cmpnei	r2,r2,46
81143d9c:	1000031e 	bne	r2,zero,81143dac <find_file_in_directory+0x120>
        {
            ext_index = index;
81143da0:	e0bfee17 	ldw	r2,-72(fp)
81143da4:	e0bfec15 	stw	r2,-80(fp)
81143da8:	00001806 	br	81143e0c <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81143dac:	e0bfec17 	ldw	r2,-80(fp)
81143db0:	10000b0e 	bge	r2,zero,81143de0 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81143db4:	e0ffee17 	ldw	r3,-72(fp)
81143db8:	e0bfeb17 	ldw	r2,-84(fp)
81143dbc:	1885c83a 	sub	r2,r3,r2
81143dc0:	e0ffee17 	ldw	r3,-72(fp)
81143dc4:	e13ffe17 	ldw	r4,-8(fp)
81143dc8:	20c7883a 	add	r3,r4,r3
81143dcc:	18c00003 	ldbu	r3,0(r3)
81143dd0:	e13ff904 	addi	r4,fp,-28
81143dd4:	2085883a 	add	r2,r4,r2
81143dd8:	10c00005 	stb	r3,0(r2)
81143ddc:	00000b06 	br	81143e0c <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81143de0:	e0ffee17 	ldw	r3,-72(fp)
81143de4:	e0bfec17 	ldw	r2,-80(fp)
81143de8:	1885c83a 	sub	r2,r3,r2
81143dec:	10bfffc4 	addi	r2,r2,-1
81143df0:	e0ffee17 	ldw	r3,-72(fp)
81143df4:	e13ffe17 	ldw	r4,-8(fp)
81143df8:	20c7883a 	add	r3,r4,r3
81143dfc:	18c00003 	ldbu	r3,0(r3)
81143e00:	e13ffb04 	addi	r4,fp,-20
81143e04:	2085883a 	add	r2,r4,r2
81143e08:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81143e0c:	e0bfee17 	ldw	r2,-72(fp)
81143e10:	10800044 	addi	r2,r2,1
81143e14:	e0bfee15 	stw	r2,-72(fp)
81143e18:	e0ffee17 	ldw	r3,-72(fp)
81143e1c:	e0bff417 	ldw	r2,-48(fp)
81143e20:	18bfd616 	blt	r3,r2,81143d7c <__reset+0xfb123d7c>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
81143e24:	e0bffd17 	ldw	r2,-12(fp)
81143e28:	1000461e 	bne	r2,zero,81143f44 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81143e2c:	00a045f4 	movhi	r2,33047
81143e30:	10b32704 	addi	r2,r2,-13156
81143e34:	1080050b 	ldhu	r2,20(r2)
81143e38:	10bfffcc 	andi	r2,r2,65535
81143e3c:	1006917a 	slli	r3,r2,5
81143e40:	00a045f4 	movhi	r2,33047
81143e44:	10b32704 	addi	r2,r2,-13156
81143e48:	1080030b 	ldhu	r2,12(r2)
81143e4c:	10bfffcc 	andi	r2,r2,65535
81143e50:	1885283a 	div	r2,r3,r2
81143e54:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143e58:	e03ff015 	stw	zero,-64(fp)
81143e5c:	00003506 	br	81143f34 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81143e60:	00a045f4 	movhi	r2,33047
81143e64:	10b32704 	addi	r2,r2,-13156
81143e68:	10c01317 	ldw	r3,76(r2)
81143e6c:	e0bff017 	ldw	r2,-64(fp)
81143e70:	1885883a 	add	r2,r3,r2
81143e74:	1007883a 	mov	r3,r2
81143e78:	d0a0b117 	ldw	r2,-32060(gp)
81143e7c:	100b883a 	mov	r5,r2
81143e80:	1809883a 	mov	r4,r3
81143e84:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81143e88:	10009626 	beq	r2,zero,811440e4 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81143e8c:	e03ff115 	stw	zero,-60(fp)
81143e90:	00002006 	br	81143f14 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81143e94:	e0bff117 	ldw	r2,-60(fp)
81143e98:	1004917a 	slli	r2,r2,5
81143e9c:	e0fff017 	ldw	r3,-64(fp)
81143ea0:	180f883a 	mov	r7,r3
81143ea4:	000d883a 	mov	r6,zero
81143ea8:	e17fff17 	ldw	r5,-4(fp)
81143eac:	1009883a 	mov	r4,r2
81143eb0:	11424140 	call	81142414 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143eb4:	e0bfff17 	ldw	r2,-4(fp)
81143eb8:	10800003 	ldbu	r2,0(r2)
81143ebc:	10803fcc 	andi	r2,r2,255
81143ec0:	10803960 	cmpeqi	r2,r2,229
81143ec4:	1000101e 	bne	r2,zero,81143f08 <find_file_in_directory+0x27c>
81143ec8:	e0bfff17 	ldw	r2,-4(fp)
81143ecc:	10800003 	ldbu	r2,0(r2)
81143ed0:	10803fcc 	andi	r2,r2,255
81143ed4:	10000c26 	beq	r2,zero,81143f08 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81143ed8:	e0fffb04 	addi	r3,fp,-20
81143edc:	e0bff904 	addi	r2,fp,-28
81143ee0:	180d883a 	mov	r6,r3
81143ee4:	100b883a 	mov	r5,r2
81143ee8:	e13fff17 	ldw	r4,-4(fp)
81143eec:	11434a80 	call	811434a8 <match_file_record_to_name_ext>
81143ef0:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81143ef4:	e0bff817 	ldw	r2,-32(fp)
81143ef8:	10000326 	beq	r2,zero,81143f08 <find_file_in_directory+0x27c>
                        {
                            result = true;
81143efc:	00800044 	movi	r2,1
81143f00:	e0bfef15 	stw	r2,-68(fp)
                            break;
81143f04:	00000606 	br	81143f20 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81143f08:	e0bff117 	ldw	r2,-60(fp)
81143f0c:	10800044 	addi	r2,r2,1
81143f10:	e0bff115 	stw	r2,-60(fp)
81143f14:	e0bff117 	ldw	r2,-60(fp)
81143f18:	10800410 	cmplti	r2,r2,16
81143f1c:	103fdd1e 	bne	r2,zero,81143e94 <__reset+0xfb123e94>
            }
            else
            {
                break;
            }
            if (result)
81143f20:	e0bfef17 	ldw	r2,-68(fp)
81143f24:	1000711e 	bne	r2,zero,811440ec <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143f28:	e0bff017 	ldw	r2,-64(fp)
81143f2c:	10800044 	addi	r2,r2,1
81143f30:	e0bff015 	stw	r2,-64(fp)
81143f34:	e0fff017 	ldw	r3,-64(fp)
81143f38:	e0bff717 	ldw	r2,-36(fp)
81143f3c:	18bfc816 	blt	r3,r2,81143e60 <__reset+0xfb123e60>
81143f40:	00006b06 	br	811440f0 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81143f44:	e0bfed17 	ldw	r2,-76(fp)
81143f48:	10ffff84 	addi	r3,r2,-2
81143f4c:	00a045f4 	movhi	r2,33047
81143f50:	10b32704 	addi	r2,r2,-13156
81143f54:	10800383 	ldbu	r2,14(r2)
81143f58:	10803fcc 	andi	r2,r2,255
81143f5c:	1885383a 	mul	r2,r3,r2
81143f60:	1007883a 	mov	r3,r2
81143f64:	00a045f4 	movhi	r2,33047
81143f68:	10b32704 	addi	r2,r2,-13156
81143f6c:	10801417 	ldw	r2,80(r2)
81143f70:	1885883a 	add	r2,r3,r2
81143f74:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143f78:	e03ff215 	stw	zero,-56(fp)
81143f7c:	00003306 	br	8114404c <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81143f80:	e0fff217 	ldw	r3,-56(fp)
81143f84:	e0bff517 	ldw	r2,-44(fp)
81143f88:	1885883a 	add	r2,r3,r2
81143f8c:	d0e0b117 	ldw	r3,-32060(gp)
81143f90:	180b883a 	mov	r5,r3
81143f94:	1009883a 	mov	r4,r2
81143f98:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81143f9c:	10003226 	beq	r2,zero,81144068 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81143fa0:	e03ff315 	stw	zero,-52(fp)
81143fa4:	00002106 	br	8114402c <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81143fa8:	e0bff317 	ldw	r2,-52(fp)
81143fac:	1004917a 	slli	r2,r2,5
81143fb0:	e0ffed17 	ldw	r3,-76(fp)
81143fb4:	e13ff217 	ldw	r4,-56(fp)
81143fb8:	200f883a 	mov	r7,r4
81143fbc:	180d883a 	mov	r6,r3
81143fc0:	e17fff17 	ldw	r5,-4(fp)
81143fc4:	1009883a 	mov	r4,r2
81143fc8:	11424140 	call	81142414 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143fcc:	e0bfff17 	ldw	r2,-4(fp)
81143fd0:	10800003 	ldbu	r2,0(r2)
81143fd4:	10803fcc 	andi	r2,r2,255
81143fd8:	10803960 	cmpeqi	r2,r2,229
81143fdc:	1000101e 	bne	r2,zero,81144020 <find_file_in_directory+0x394>
81143fe0:	e0bfff17 	ldw	r2,-4(fp)
81143fe4:	10800003 	ldbu	r2,0(r2)
81143fe8:	10803fcc 	andi	r2,r2,255
81143fec:	10000c26 	beq	r2,zero,81144020 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81143ff0:	e0fffb04 	addi	r3,fp,-20
81143ff4:	e0bff904 	addi	r2,fp,-28
81143ff8:	180d883a 	mov	r6,r3
81143ffc:	100b883a 	mov	r5,r2
81144000:	e13fff17 	ldw	r4,-4(fp)
81144004:	11434a80 	call	811434a8 <match_file_record_to_name_ext>
81144008:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8114400c:	e0bff617 	ldw	r2,-40(fp)
81144010:	10000326 	beq	r2,zero,81144020 <find_file_in_directory+0x394>
                            {                               
                                result = true;
81144014:	00800044 	movi	r2,1
81144018:	e0bfef15 	stw	r2,-68(fp)
                                break;
8114401c:	00000606 	br	81144038 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81144020:	e0bff317 	ldw	r2,-52(fp)
81144024:	10800044 	addi	r2,r2,1
81144028:	e0bff315 	stw	r2,-52(fp)
8114402c:	e0bff317 	ldw	r2,-52(fp)
81144030:	10800410 	cmplti	r2,r2,16
81144034:	103fdc1e 	bne	r2,zero,81143fa8 <__reset+0xfb123fa8>
                }
                else
                {
                    break;
                }
                if (result)
81144038:	e0bfef17 	ldw	r2,-68(fp)
8114403c:	10000c1e 	bne	r2,zero,81144070 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81144040:	e0bff217 	ldw	r2,-56(fp)
81144044:	10800044 	addi	r2,r2,1
81144048:	e0bff215 	stw	r2,-56(fp)
8114404c:	00a045f4 	movhi	r2,33047
81144050:	10b32704 	addi	r2,r2,-13156
81144054:	10800383 	ldbu	r2,14(r2)
81144058:	10803fcc 	andi	r2,r2,255
8114405c:	e0fff217 	ldw	r3,-56(fp)
81144060:	18bfc716 	blt	r3,r2,81143f80 <__reset+0xfb123f80>
81144064:	00000306 	br	81144074 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81144068:	0001883a 	nop
8114406c:	00000106 	br	81144074 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
81144070:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81144074:	e0bfef17 	ldw	r2,-68(fp)
81144078:	1000141e 	bne	r2,zero,811440cc <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8114407c:	e0bfed17 	ldw	r2,-76(fp)
81144080:	e0fffc04 	addi	r3,fp,-16
81144084:	180b883a 	mov	r5,r3
81144088:	1009883a 	mov	r4,r2
8114408c:	11420c40 	call	811420c4 <get_cluster_flag>
81144090:	10000c26 	beq	r2,zero,811440c4 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81144094:	e0bffc0b 	ldhu	r2,-16(fp)
81144098:	10bfffcc 	andi	r2,r2,65535
8114409c:	10fffe0c 	andi	r3,r2,65528
811440a0:	00bffe14 	movui	r2,65528
811440a4:	1880021e 	bne	r3,r2,811440b0 <find_file_in_directory+0x424>
					{
						return false;
811440a8:	0005883a 	mov	r2,zero
811440ac:	00001106 	br	811440f4 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
811440b0:	e0bffc0b 	ldhu	r2,-16(fp)
811440b4:	10bfffcc 	andi	r2,r2,65535
811440b8:	10bffe0c 	andi	r2,r2,65528
811440bc:	e0bfed15 	stw	r2,-76(fp)
811440c0:	00000206 	br	811440cc <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
811440c4:	0005883a 	mov	r2,zero
811440c8:	00000a06 	br	811440f4 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
811440cc:	e0bfed17 	ldw	r2,-76(fp)
811440d0:	00fffdd4 	movui	r3,65527
811440d4:	18800616 	blt	r3,r2,811440f0 <find_file_in_directory+0x464>
811440d8:	e0bfef17 	ldw	r2,-68(fp)
811440dc:	103f9926 	beq	r2,zero,81143f44 <__reset+0xfb123f44>
811440e0:	00000306 	br	811440f0 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
811440e4:	0001883a 	nop
811440e8:	00000106 	br	811440f0 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
811440ec:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
811440f0:	e0bfef17 	ldw	r2,-68(fp)
}
811440f4:	e037883a 	mov	sp,fp
811440f8:	dfc00117 	ldw	ra,4(sp)
811440fc:	df000017 	ldw	fp,0(sp)
81144100:	dec00204 	addi	sp,sp,8
81144104:	f800283a 	ret

81144108 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81144108:	defff504 	addi	sp,sp,-44
8114410c:	de00012e 	bgeu	sp,et,81144114 <find_first_empty_cluster+0xc>
81144110:	003b68fa 	trap	3
81144114:	dfc00a15 	stw	ra,40(sp)
81144118:	df000915 	stw	fp,36(sp)
8114411c:	df000904 	addi	fp,sp,36
81144120:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
81144124:	00a045f4 	movhi	r2,33047
81144128:	10b32704 	addi	r2,r2,-13156
8114412c:	10801117 	ldw	r2,68(r2)
81144130:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
81144134:	00800084 	movi	r2,2
81144138:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8114413c:	00bfffc4 	movi	r2,-1
81144140:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
81144144:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
81144148:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8114414c:	00a045f4 	movhi	r2,33047
81144150:	10b32704 	addi	r2,r2,-13156
81144154:	10801417 	ldw	r2,80(r2)
81144158:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8114415c:	00a045f4 	movhi	r2,33047
81144160:	10b32704 	addi	r2,r2,-13156
81144164:	1080058b 	ldhu	r2,22(r2)
81144168:	10bfffcc 	andi	r2,r2,65535
8114416c:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
81144170:	00a045f4 	movhi	r2,33047
81144174:	10b32704 	addi	r2,r2,-13156
81144178:	10800917 	ldw	r2,36(r2)
8114417c:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
81144180:	e0bffd17 	ldw	r2,-12(fp)
81144184:	e0fffe17 	ldw	r3,-8(fp)
81144188:	18800b2e 	bgeu	r3,r2,811441b8 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8114418c:	e0fffd17 	ldw	r3,-12(fp)
81144190:	e0bffc17 	ldw	r2,-16(fp)
81144194:	1887c83a 	sub	r3,r3,r2
81144198:	00a045f4 	movhi	r2,33047
8114419c:	10b32704 	addi	r2,r2,-13156
811441a0:	10800383 	ldbu	r2,14(r2)
811441a4:	10803fcc 	andi	r2,r2,255
811441a8:	1885203a 	divu	r2,r3,r2
811441ac:	10800044 	addi	r2,r2,1
811441b0:	e0bffb15 	stw	r2,-20(fp)
811441b4:	00002a06 	br	81144260 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
811441b8:	e0fffe17 	ldw	r3,-8(fp)
811441bc:	e0bffc17 	ldw	r2,-16(fp)
811441c0:	1887c83a 	sub	r3,r3,r2
811441c4:	00a045f4 	movhi	r2,33047
811441c8:	10b32704 	addi	r2,r2,-13156
811441cc:	10800383 	ldbu	r2,14(r2)
811441d0:	10803fcc 	andi	r2,r2,255
811441d4:	1885203a 	divu	r2,r3,r2
811441d8:	10800044 	addi	r2,r2,1
811441dc:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811441e0:	00001f06 	br	81144260 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
811441e4:	e0bff717 	ldw	r2,-36(fp)
811441e8:	d0e0b117 	ldw	r3,-32060(gp)
811441ec:	180b883a 	mov	r5,r3
811441f0:	1009883a 	mov	r4,r2
811441f4:	1141fe40 	call	81141fe4 <Read_Sector_Data>
811441f8:	10001426 	beq	r2,zero,8114424c <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
811441fc:	e0bff817 	ldw	r2,-32(fp)
81144200:	10803fcc 	andi	r2,r2,255
81144204:	1085883a 	add	r2,r2,r2
81144208:	1007883a 	mov	r3,r2
8114420c:	d0a0b317 	ldw	r2,-32052(gp)
81144210:	10800a17 	ldw	r2,40(r2)
81144214:	1885883a 	add	r2,r3,r2
81144218:	1080002b 	ldhuio	r2,0(r2)
8114421c:	10bfffcc 	andi	r2,r2,65535
81144220:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
81144224:	e0bff90f 	ldh	r2,-28(fp)
81144228:	10000726 	beq	r2,zero,81144248 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8114422c:	e0bff817 	ldw	r2,-32(fp)
81144230:	10800044 	addi	r2,r2,1
81144234:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
81144238:	e0bff817 	ldw	r2,-32(fp)
8114423c:	10803fcc 	andi	r2,r2,255
81144240:	103fee1e 	bne	r2,zero,811441fc <__reset+0xfb1241fc>
81144244:	00000106 	br	8114424c <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
81144248:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8114424c:	e0bff90f 	ldh	r2,-28(fp)
81144250:	10000926 	beq	r2,zero,81144278 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
81144254:	e0bff717 	ldw	r2,-36(fp)
81144258:	10800044 	addi	r2,r2,1
8114425c:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81144260:	00a045f4 	movhi	r2,33047
81144264:	10b32704 	addi	r2,r2,-13156
81144268:	10c01217 	ldw	r3,72(r2)
8114426c:	e0bff717 	ldw	r2,-36(fp)
81144270:	18bfdc1e 	bne	r3,r2,811441e4 <__reset+0xfb1241e4>
81144274:	00000106 	br	8114427c <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81144278:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8114427c:	e0bff90f 	ldh	r2,-28(fp)
81144280:	1000081e 	bne	r2,zero,811442a4 <find_first_empty_cluster+0x19c>
81144284:	e0bff90f 	ldh	r2,-28(fp)
81144288:	e0fffb17 	ldw	r3,-20(fp)
8114428c:	18800536 	bltu	r3,r2,811442a4 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
81144290:	e0bfff17 	ldw	r2,-4(fp)
81144294:	e0fff817 	ldw	r3,-32(fp)
81144298:	10c00015 	stw	r3,0(r2)
		result = true;
8114429c:	00800044 	movi	r2,1
811442a0:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
811442a4:	e0bffa17 	ldw	r2,-24(fp)
}
811442a8:	e037883a 	mov	sp,fp
811442ac:	dfc00117 	ldw	ra,4(sp)
811442b0:	df000017 	ldw	fp,0(sp)
811442b4:	dec00204 	addi	sp,sp,8
811442b8:	f800283a 	ret

811442bc <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
811442bc:	defff604 	addi	sp,sp,-40
811442c0:	de00012e 	bgeu	sp,et,811442c8 <find_first_empty_record_in_a_subdirectory+0xc>
811442c4:	003b68fa 	trap	3
811442c8:	dfc00915 	stw	ra,36(sp)
811442cc:	df000815 	stw	fp,32(sp)
811442d0:	df000804 	addi	fp,sp,32
811442d4:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
811442d8:	00bfffc4 	movi	r2,-1
811442dc:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
811442e0:	e0bfff17 	ldw	r2,-4(fp)
811442e4:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811442e8:	e0bff917 	ldw	r2,-28(fp)
811442ec:	10ffff84 	addi	r3,r2,-2
811442f0:	00a045f4 	movhi	r2,33047
811442f4:	10b32704 	addi	r2,r2,-13156
811442f8:	10800383 	ldbu	r2,14(r2)
811442fc:	10803fcc 	andi	r2,r2,255
81144300:	1885383a 	mul	r2,r3,r2
81144304:	1007883a 	mov	r3,r2
81144308:	00a045f4 	movhi	r2,33047
8114430c:	10b32704 	addi	r2,r2,-13156
81144310:	10801417 	ldw	r2,80(r2)
81144314:	1885883a 	add	r2,r3,r2
81144318:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114431c:	e03ffa15 	stw	zero,-24(fp)
81144320:	00002c06 	br	811443d4 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81144324:	e0fffa17 	ldw	r3,-24(fp)
81144328:	e0bffc17 	ldw	r2,-16(fp)
8114432c:	1885883a 	add	r2,r3,r2
81144330:	d0e0b117 	ldw	r3,-32060(gp)
81144334:	180b883a 	mov	r5,r3
81144338:	1009883a 	mov	r4,r2
8114433c:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81144340:	10002b26 	beq	r2,zero,811443f0 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81144344:	e03ffb15 	stw	zero,-20(fp)
81144348:	00001c06 	br	811443bc <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8114434c:	e0bffb17 	ldw	r2,-20(fp)
81144350:	1004917a 	slli	r2,r2,5
81144354:	1007883a 	mov	r3,r2
81144358:	d0a0b317 	ldw	r2,-32052(gp)
8114435c:	10800a17 	ldw	r2,40(r2)
81144360:	1885883a 	add	r2,r3,r2
81144364:	10800023 	ldbuio	r2,0(r2)
81144368:	10803fcc 	andi	r2,r2,255
8114436c:	10803fcc 	andi	r2,r2,255
81144370:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
81144374:	e0bffd0b 	ldhu	r2,-12(fp)
81144378:	10803960 	cmpeqi	r2,r2,229
8114437c:	1000021e 	bne	r2,zero,81144388 <find_first_empty_record_in_a_subdirectory+0xcc>
81144380:	e0bffd0b 	ldhu	r2,-12(fp)
81144384:	10000a1e 	bne	r2,zero,811443b0 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81144388:	e0bffa17 	ldw	r2,-24(fp)
8114438c:	1006913a 	slli	r3,r2,4
81144390:	e0bffb17 	ldw	r2,-20(fp)
81144394:	1885883a 	add	r2,r3,r2
81144398:	1006943a 	slli	r3,r2,16
8114439c:	e0bff917 	ldw	r2,-28(fp)
811443a0:	1884b03a 	or	r2,r3,r2
811443a4:	e0bff815 	stw	r2,-32(fp)
                        return result;
811443a8:	e0bff817 	ldw	r2,-32(fp)
811443ac:	00005306 	br	811444fc <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811443b0:	e0bffb17 	ldw	r2,-20(fp)
811443b4:	10800044 	addi	r2,r2,1
811443b8:	e0bffb15 	stw	r2,-20(fp)
811443bc:	e0bffb17 	ldw	r2,-20(fp)
811443c0:	10800410 	cmplti	r2,r2,16
811443c4:	103fe11e 	bne	r2,zero,8114434c <__reset+0xfb12434c>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811443c8:	e0bffa17 	ldw	r2,-24(fp)
811443cc:	10800044 	addi	r2,r2,1
811443d0:	e0bffa15 	stw	r2,-24(fp)
811443d4:	00a045f4 	movhi	r2,33047
811443d8:	10b32704 	addi	r2,r2,-13156
811443dc:	10800383 	ldbu	r2,14(r2)
811443e0:	10803fcc 	andi	r2,r2,255
811443e4:	e0fffa17 	ldw	r3,-24(fp)
811443e8:	18bfce16 	blt	r3,r2,81144324 <__reset+0xfb124324>
811443ec:	00000106 	br	811443f4 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
811443f0:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
811443f4:	e0bff817 	ldw	r2,-32(fp)
811443f8:	1000390e 	bge	r2,zero,811444e0 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
811443fc:	e0bff917 	ldw	r2,-28(fp)
81144400:	e0fffd84 	addi	r3,fp,-10
81144404:	180b883a 	mov	r5,r3
81144408:	1009883a 	mov	r4,r2
8114440c:	11420c40 	call	811420c4 <get_cluster_flag>
81144410:	10003126 	beq	r2,zero,811444d8 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81144414:	e0bffd8b 	ldhu	r2,-10(fp)
81144418:	10bfffcc 	andi	r2,r2,65535
8114441c:	10fffe0c 	andi	r3,r2,65528
81144420:	00bffe14 	movui	r2,65528
81144424:	18802e1e 	bne	r3,r2,811444e0 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
81144428:	e0bffe04 	addi	r2,fp,-8
8114442c:	1009883a 	mov	r4,r2
81144430:	11441080 	call	81144108 <find_first_empty_cluster>
81144434:	10002326 	beq	r2,zero,811444c4 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81144438:	e0bff917 	ldw	r2,-28(fp)
8114443c:	e0fffe17 	ldw	r3,-8(fp)
81144440:	18ffffcc 	andi	r3,r3,65535
81144444:	18e0001c 	xori	r3,r3,32768
81144448:	18e00004 	addi	r3,r3,-32768
8114444c:	01800044 	movi	r6,1
81144450:	180b883a 	mov	r5,r3
81144454:	1009883a 	mov	r4,r2
81144458:	11421800 	call	81142180 <mark_cluster>
8114445c:	10001926 	beq	r2,zero,811444c4 <find_first_empty_record_in_a_subdirectory+0x208>
81144460:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81144464:	01800044 	movi	r6,1
81144468:	017fffc4 	movi	r5,-1
8114446c:	1009883a 	mov	r4,r2
81144470:	11421800 	call	81142180 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81144474:	10001326 	beq	r2,zero,811444c4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81144478:	e0bff917 	ldw	r2,-28(fp)
8114447c:	e0fffe17 	ldw	r3,-8(fp)
81144480:	18ffffcc 	andi	r3,r3,65535
81144484:	18e0001c 	xori	r3,r3,32768
81144488:	18e00004 	addi	r3,r3,-32768
8114448c:	000d883a 	mov	r6,zero
81144490:	180b883a 	mov	r5,r3
81144494:	1009883a 	mov	r4,r2
81144498:	11421800 	call	81142180 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8114449c:	10000926 	beq	r2,zero,811444c4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811444a0:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
811444a4:	000d883a 	mov	r6,zero
811444a8:	017fffc4 	movi	r5,-1
811444ac:	1009883a 	mov	r4,r2
811444b0:	11421800 	call	81142180 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811444b4:	10000326 	beq	r2,zero,811444c4 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
811444b8:	1141f900 	call	81141f90 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
811444bc:	e0bffe17 	ldw	r2,-8(fp)
811444c0:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
811444c4:	e0bffd8b 	ldhu	r2,-10(fp)
811444c8:	10bfffcc 	andi	r2,r2,65535
811444cc:	10bffe0c 	andi	r2,r2,65528
811444d0:	e0bff915 	stw	r2,-28(fp)
811444d4:	00000206 	br	811444e0 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
811444d8:	00bfffc4 	movi	r2,-1
811444dc:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
811444e0:	e0bff917 	ldw	r2,-28(fp)
811444e4:	00fffdd4 	movui	r3,65527
811444e8:	18800316 	blt	r3,r2,811444f8 <find_first_empty_record_in_a_subdirectory+0x23c>
811444ec:	e0bff817 	ldw	r2,-32(fp)
811444f0:	10bfffe0 	cmpeqi	r2,r2,-1
811444f4:	103f7c1e 	bne	r2,zero,811442e8 <__reset+0xfb1242e8>
    return result; 
811444f8:	e0bff817 	ldw	r2,-32(fp)
}
811444fc:	e037883a 	mov	sp,fp
81144500:	dfc00117 	ldw	ra,4(sp)
81144504:	df000017 	ldw	fp,0(sp)
81144508:	dec00204 	addi	sp,sp,8
8114450c:	f800283a 	ret

81144510 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
81144510:	defff904 	addi	sp,sp,-28
81144514:	de00012e 	bgeu	sp,et,8114451c <find_first_empty_record_in_root_directory+0xc>
81144518:	003b68fa 	trap	3
8114451c:	dfc00615 	stw	ra,24(sp)
81144520:	df000515 	stw	fp,20(sp)
81144524:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81144528:	00a045f4 	movhi	r2,33047
8114452c:	10b32704 	addi	r2,r2,-13156
81144530:	1080050b 	ldhu	r2,20(r2)
81144534:	10bfffcc 	andi	r2,r2,65535
81144538:	1006917a 	slli	r3,r2,5
8114453c:	00a045f4 	movhi	r2,33047
81144540:	10b32704 	addi	r2,r2,-13156
81144544:	1080030b 	ldhu	r2,12(r2)
81144548:	10bfffcc 	andi	r2,r2,65535
8114454c:	1885283a 	div	r2,r3,r2
81144550:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
81144554:	00bfffc4 	movi	r2,-1
81144558:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8114455c:	e03ffb15 	stw	zero,-20(fp)
81144560:	00002d06 	br	81144618 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81144564:	00a045f4 	movhi	r2,33047
81144568:	10b32704 	addi	r2,r2,-13156
8114456c:	10c01317 	ldw	r3,76(r2)
81144570:	e0bffb17 	ldw	r2,-20(fp)
81144574:	1885883a 	add	r2,r3,r2
81144578:	1007883a 	mov	r3,r2
8114457c:	d0a0b117 	ldw	r2,-32060(gp)
81144580:	100b883a 	mov	r5,r2
81144584:	1809883a 	mov	r4,r3
81144588:	1141fe40 	call	81141fe4 <Read_Sector_Data>
8114458c:	10002626 	beq	r2,zero,81144628 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81144590:	e03ffc15 	stw	zero,-16(fp)
81144594:	00001a06 	br	81144600 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81144598:	e0bffc17 	ldw	r2,-16(fp)
8114459c:	1004917a 	slli	r2,r2,5
811445a0:	1007883a 	mov	r3,r2
811445a4:	d0a0b317 	ldw	r2,-32052(gp)
811445a8:	10800a17 	ldw	r2,40(r2)
811445ac:	1885883a 	add	r2,r3,r2
811445b0:	10800023 	ldbuio	r2,0(r2)
811445b4:	10803fcc 	andi	r2,r2,255
811445b8:	10803fcc 	andi	r2,r2,255
811445bc:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
811445c0:	e0bfff0b 	ldhu	r2,-4(fp)
811445c4:	10803960 	cmpeqi	r2,r2,229
811445c8:	1000021e 	bne	r2,zero,811445d4 <find_first_empty_record_in_root_directory+0xc4>
811445cc:	e0bfff0b 	ldhu	r2,-4(fp)
811445d0:	1000081e 	bne	r2,zero,811445f4 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
811445d4:	e0bffb17 	ldw	r2,-20(fp)
811445d8:	1006913a 	slli	r3,r2,4
811445dc:	e0bffc17 	ldw	r2,-16(fp)
811445e0:	1885883a 	add	r2,r3,r2
811445e4:	1004943a 	slli	r2,r2,16
811445e8:	e0bffe15 	stw	r2,-8(fp)
                    return result;
811445ec:	e0bffe17 	ldw	r2,-8(fp)
811445f0:	00000f06 	br	81144630 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
811445f4:	e0bffc17 	ldw	r2,-16(fp)
811445f8:	10800044 	addi	r2,r2,1
811445fc:	e0bffc15 	stw	r2,-16(fp)
81144600:	e0bffc17 	ldw	r2,-16(fp)
81144604:	10800410 	cmplti	r2,r2,16
81144608:	103fe31e 	bne	r2,zero,81144598 <__reset+0xfb124598>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8114460c:	e0bffb17 	ldw	r2,-20(fp)
81144610:	10800044 	addi	r2,r2,1
81144614:	e0bffb15 	stw	r2,-20(fp)
81144618:	e0fffb17 	ldw	r3,-20(fp)
8114461c:	e0bffd17 	ldw	r2,-12(fp)
81144620:	18bfd016 	blt	r3,r2,81144564 <__reset+0xfb124564>
81144624:	00000106 	br	8114462c <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
81144628:	0001883a 	nop
        }
    }
    return result;
8114462c:	e0bffe17 	ldw	r2,-8(fp)
}
81144630:	e037883a 	mov	sp,fp
81144634:	dfc00117 	ldw	ra,4(sp)
81144638:	df000017 	ldw	fp,0(sp)
8114463c:	dec00204 	addi	sp,sp,8
81144640:	f800283a 	ret

81144644 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
81144644:	defffa04 	addi	sp,sp,-24
81144648:	de00012e 	bgeu	sp,et,81144650 <convert_filename_to_name_extension+0xc>
8114464c:	003b68fa 	trap	3
81144650:	df000515 	stw	fp,20(sp)
81144654:	df000504 	addi	fp,sp,20
81144658:	e13ffd15 	stw	r4,-12(fp)
8114465c:	e17ffe15 	stw	r5,-8(fp)
81144660:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81144664:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81144668:	e03ffb15 	stw	zero,-20(fp)
8114466c:	00002506 	br	81144704 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
81144670:	e0bffc17 	ldw	r2,-16(fp)
81144674:	e0fffd17 	ldw	r3,-12(fp)
81144678:	1885883a 	add	r2,r3,r2
8114467c:	10800003 	ldbu	r2,0(r2)
81144680:	10803fcc 	andi	r2,r2,255
81144684:	1080201c 	xori	r2,r2,128
81144688:	10bfe004 	addi	r2,r2,-128
8114468c:	10800ba0 	cmpeqi	r2,r2,46
81144690:	1000141e 	bne	r2,zero,811446e4 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81144694:	e0bffb17 	ldw	r2,-20(fp)
81144698:	e0fffe17 	ldw	r3,-8(fp)
8114469c:	1885883a 	add	r2,r3,r2
811446a0:	e0fffc17 	ldw	r3,-16(fp)
811446a4:	e13ffd17 	ldw	r4,-12(fp)
811446a8:	20c7883a 	add	r3,r4,r3
811446ac:	18c00003 	ldbu	r3,0(r3)
811446b0:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
811446b4:	e0bffc17 	ldw	r2,-16(fp)
811446b8:	e0fffd17 	ldw	r3,-12(fp)
811446bc:	1885883a 	add	r2,r3,r2
811446c0:	10800003 	ldbu	r2,0(r2)
811446c4:	10803fcc 	andi	r2,r2,255
811446c8:	1080201c 	xori	r2,r2,128
811446cc:	10bfe004 	addi	r2,r2,-128
811446d0:	10000926 	beq	r2,zero,811446f8 <convert_filename_to_name_extension+0xb4>
811446d4:	e0bffc17 	ldw	r2,-16(fp)
811446d8:	10800044 	addi	r2,r2,1
811446dc:	e0bffc15 	stw	r2,-16(fp)
811446e0:	00000506 	br	811446f8 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
811446e4:	e0bffb17 	ldw	r2,-20(fp)
811446e8:	e0fffe17 	ldw	r3,-8(fp)
811446ec:	1885883a 	add	r2,r3,r2
811446f0:	00c00804 	movi	r3,32
811446f4:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
811446f8:	e0bffb17 	ldw	r2,-20(fp)
811446fc:	10800044 	addi	r2,r2,1
81144700:	e0bffb15 	stw	r2,-20(fp)
81144704:	e0bffb17 	ldw	r2,-20(fp)
81144708:	10800210 	cmplti	r2,r2,8
8114470c:	103fd81e 	bne	r2,zero,81144670 <__reset+0xfb124670>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
81144710:	e0bffc17 	ldw	r2,-16(fp)
81144714:	e0fffd17 	ldw	r3,-12(fp)
81144718:	1885883a 	add	r2,r3,r2
8114471c:	10800003 	ldbu	r2,0(r2)
81144720:	10803fcc 	andi	r2,r2,255
81144724:	1080201c 	xori	r2,r2,128
81144728:	10bfe004 	addi	r2,r2,-128
8114472c:	10800b98 	cmpnei	r2,r2,46
81144730:	1000031e 	bne	r2,zero,81144740 <convert_filename_to_name_extension+0xfc>
81144734:	e0bffc17 	ldw	r2,-16(fp)
81144738:	10800044 	addi	r2,r2,1
8114473c:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
81144740:	e03ffb15 	stw	zero,-20(fp)
81144744:	00001c06 	br	811447b8 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
81144748:	e0bffc17 	ldw	r2,-16(fp)
8114474c:	e0fffd17 	ldw	r3,-12(fp)
81144750:	1885883a 	add	r2,r3,r2
81144754:	10800003 	ldbu	r2,0(r2)
81144758:	10803fcc 	andi	r2,r2,255
8114475c:	1080201c 	xori	r2,r2,128
81144760:	10bfe004 	addi	r2,r2,-128
81144764:	10000c26 	beq	r2,zero,81144798 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81144768:	e0bffb17 	ldw	r2,-20(fp)
8114476c:	e0ffff17 	ldw	r3,-4(fp)
81144770:	1885883a 	add	r2,r3,r2
81144774:	e0fffc17 	ldw	r3,-16(fp)
81144778:	e13ffd17 	ldw	r4,-12(fp)
8114477c:	20c7883a 	add	r3,r4,r3
81144780:	18c00003 	ldbu	r3,0(r3)
81144784:	10c00005 	stb	r3,0(r2)
            local++;
81144788:	e0bffc17 	ldw	r2,-16(fp)
8114478c:	10800044 	addi	r2,r2,1
81144790:	e0bffc15 	stw	r2,-16(fp)
81144794:	00000506 	br	811447ac <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81144798:	e0bffb17 	ldw	r2,-20(fp)
8114479c:	e0ffff17 	ldw	r3,-4(fp)
811447a0:	1885883a 	add	r2,r3,r2
811447a4:	00c00804 	movi	r3,32
811447a8:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
811447ac:	e0bffb17 	ldw	r2,-20(fp)
811447b0:	10800044 	addi	r2,r2,1
811447b4:	e0bffb15 	stw	r2,-20(fp)
811447b8:	e0bffb17 	ldw	r2,-20(fp)
811447bc:	108000d0 	cmplti	r2,r2,3
811447c0:	103fe11e 	bne	r2,zero,81144748 <__reset+0xfb124748>
        {
            extension[counter] = ' ';
        }
    }

}
811447c4:	0001883a 	nop
811447c8:	e037883a 	mov	sp,fp
811447cc:	df000017 	ldw	fp,0(sp)
811447d0:	dec00104 	addi	sp,sp,4
811447d4:	f800283a 	ret

811447d8 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
811447d8:	defff504 	addi	sp,sp,-44
811447dc:	de00012e 	bgeu	sp,et,811447e4 <create_file+0xc>
811447e0:	003b68fa 	trap	3
811447e4:	dfc00a15 	stw	ra,40(sp)
811447e8:	df000915 	stw	fp,36(sp)
811447ec:	df000904 	addi	fp,sp,36
811447f0:	e13ffd15 	stw	r4,-12(fp)
811447f4:	e17ffe15 	stw	r5,-8(fp)
811447f8:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
811447fc:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81144800:	e0bffc04 	addi	r2,fp,-16
81144804:	1009883a 	mov	r4,r2
81144808:	11441080 	call	81144108 <find_first_empty_cluster>
8114480c:	1000a026 	beq	r2,zero,81144a90 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81144810:	e0bfff17 	ldw	r2,-4(fp)
81144814:	10800a17 	ldw	r2,40(r2)
81144818:	1000031e 	bne	r2,zero,81144828 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
8114481c:	11445100 	call	81144510 <find_first_empty_record_in_root_directory>
81144820:	e0bff815 	stw	r2,-32(fp)
81144824:	00000606 	br	81144840 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81144828:	e0bfff17 	ldw	r2,-4(fp)
8114482c:	1080058b 	ldhu	r2,22(r2)
81144830:	10bfffcc 	andi	r2,r2,65535
81144834:	1009883a 	mov	r4,r2
81144838:	11442bc0 	call	811442bc <find_first_empty_record_in_a_subdirectory>
8114483c:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81144840:	e0bff817 	ldw	r2,-32(fp)
81144844:	10009216 	blt	r2,zero,81144a90 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81144848:	e13ffd17 	ldw	r4,-12(fp)
8114484c:	11433e80 	call	811433e8 <get_dir_divider_location>
81144850:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81144854:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81144858:	00000b06 	br	81144888 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8114485c:	e0fffa17 	ldw	r3,-24(fp)
81144860:	e0bff917 	ldw	r2,-28(fp)
81144864:	1885883a 	add	r2,r3,r2
81144868:	10800044 	addi	r2,r2,1
8114486c:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81144870:	e0bffa17 	ldw	r2,-24(fp)
81144874:	e0fffd17 	ldw	r3,-12(fp)
81144878:	1885883a 	add	r2,r3,r2
8114487c:	1009883a 	mov	r4,r2
81144880:	11433e80 	call	811433e8 <get_dir_divider_location>
81144884:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81144888:	e0bff917 	ldw	r2,-28(fp)
8114488c:	00bff316 	blt	zero,r2,8114485c <__reset+0xfb12485c>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81144890:	e0bffa17 	ldw	r2,-24(fp)
81144894:	e0fffd17 	ldw	r3,-12(fp)
81144898:	1887883a 	add	r3,r3,r2
8114489c:	e13ffe17 	ldw	r4,-8(fp)
811448a0:	e0bffe17 	ldw	r2,-8(fp)
811448a4:	10800204 	addi	r2,r2,8
811448a8:	100d883a 	mov	r6,r2
811448ac:	200b883a 	mov	r5,r4
811448b0:	1809883a 	mov	r4,r3
811448b4:	11446440 	call	81144644 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
811448b8:	e0bffe17 	ldw	r2,-8(fp)
811448bc:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
811448c0:	e0bffe17 	ldw	r2,-8(fp)
811448c4:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
811448c8:	e0bffe17 	ldw	r2,-8(fp)
811448cc:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
811448d0:	e0bffe17 	ldw	r2,-8(fp)
811448d4:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
811448d8:	e0bffe17 	ldw	r2,-8(fp)
811448dc:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
811448e0:	e0bffe17 	ldw	r2,-8(fp)
811448e4:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
811448e8:	e0bffc17 	ldw	r2,-16(fp)
811448ec:	1007883a 	mov	r3,r2
811448f0:	e0bffe17 	ldw	r2,-8(fp)
811448f4:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
811448f8:	e0bffe17 	ldw	r2,-8(fp)
811448fc:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81144900:	e0fffc17 	ldw	r3,-16(fp)
81144904:	e0bffe17 	ldw	r2,-8(fp)
81144908:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
8114490c:	e0bffe17 	ldw	r2,-8(fp)
81144910:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81144914:	e0bffe17 	ldw	r2,-8(fp)
81144918:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
8114491c:	e0bff817 	ldw	r2,-32(fp)
81144920:	10ffffcc 	andi	r3,r2,65535
81144924:	e0bffe17 	ldw	r2,-8(fp)
81144928:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8114492c:	e0bff817 	ldw	r2,-32(fp)
81144930:	1004d43a 	srli	r2,r2,16
81144934:	1000010e 	bge	r2,zero,8114493c <create_file+0x164>
81144938:	108003c4 	addi	r2,r2,15
8114493c:	1005d13a 	srai	r2,r2,4
81144940:	1007883a 	mov	r3,r2
81144944:	e0bffe17 	ldw	r2,-8(fp)
81144948:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8114494c:	e0bff817 	ldw	r2,-32(fp)
81144950:	1004d43a 	srli	r2,r2,16
81144954:	1007883a 	mov	r3,r2
81144958:	00a00034 	movhi	r2,32768
8114495c:	108003c4 	addi	r2,r2,15
81144960:	1884703a 	and	r2,r3,r2
81144964:	1000040e 	bge	r2,zero,81144978 <create_file+0x1a0>
81144968:	10bfffc4 	addi	r2,r2,-1
8114496c:	00fffc04 	movi	r3,-16
81144970:	10c4b03a 	or	r2,r2,r3
81144974:	10800044 	addi	r2,r2,1
81144978:	1004917a 	slli	r2,r2,5
8114497c:	1007883a 	mov	r3,r2
81144980:	e0bffe17 	ldw	r2,-8(fp)
81144984:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81144988:	e0bfff17 	ldw	r2,-4(fp)
8114498c:	1080058b 	ldhu	r2,22(r2)
81144990:	10ffffcc 	andi	r3,r2,65535
81144994:	e0bffe17 	ldw	r2,-8(fp)
81144998:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
8114499c:	e0bffe17 	ldw	r2,-8(fp)
811449a0:	00c00044 	movi	r3,1
811449a4:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
811449a8:	e0bffe17 	ldw	r2,-8(fp)
811449ac:	00c00044 	movi	r3,1
811449b0:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
811449b4:	e0bffe17 	ldw	r2,-8(fp)
811449b8:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
811449bc:	1000071e 	bne	r2,zero,811449dc <create_file+0x204>
811449c0:	00a045f4 	movhi	r2,33047
811449c4:	10b32704 	addi	r2,r2,-13156
811449c8:	10c01317 	ldw	r3,76(r2)
811449cc:	e0bffe17 	ldw	r2,-8(fp)
811449d0:	10800b17 	ldw	r2,44(r2)
811449d4:	1885883a 	add	r2,r3,r2
811449d8:	00000f06 	br	81144a18 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
811449dc:	00a045f4 	movhi	r2,33047
811449e0:	10b32704 	addi	r2,r2,-13156
811449e4:	10c01417 	ldw	r3,80(r2)
811449e8:	e0bffe17 	ldw	r2,-8(fp)
811449ec:	10800a17 	ldw	r2,40(r2)
811449f0:	113fff84 	addi	r4,r2,-2
811449f4:	00a045f4 	movhi	r2,33047
811449f8:	10b32704 	addi	r2,r2,-13156
811449fc:	10800383 	ldbu	r2,14(r2)
81144a00:	10803fcc 	andi	r2,r2,255
81144a04:	2085383a 	mul	r2,r4,r2
81144a08:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81144a0c:	e0bffe17 	ldw	r2,-8(fp)
81144a10:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81144a14:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81144a18:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81144a1c:	e0bffb17 	ldw	r2,-20(fp)
81144a20:	d0e0b117 	ldw	r3,-32060(gp)
81144a24:	180b883a 	mov	r5,r3
81144a28:	1009883a 	mov	r4,r2
81144a2c:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81144a30:	10001726 	beq	r2,zero,81144a90 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81144a34:	e0bffe17 	ldw	r2,-8(fp)
81144a38:	10800c0b 	ldhu	r2,48(r2)
81144a3c:	10bfffcc 	andi	r2,r2,65535
81144a40:	10a0001c 	xori	r2,r2,32768
81144a44:	10a00004 	addi	r2,r2,-32768
81144a48:	e17ffe17 	ldw	r5,-8(fp)
81144a4c:	1009883a 	mov	r4,r2
81144a50:	11426980 	call	81142698 <Write_File_Record_At_Offset>
81144a54:	10000e26 	beq	r2,zero,81144a90 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81144a58:	1141f900 	call	81141f90 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81144a5c:	e0bffc17 	ldw	r2,-16(fp)
81144a60:	01800044 	movi	r6,1
81144a64:	017fffc4 	movi	r5,-1
81144a68:	1009883a 	mov	r4,r2
81144a6c:	11421800 	call	81142180 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81144a70:	e0bffc17 	ldw	r2,-16(fp)
81144a74:	000d883a 	mov	r6,zero
81144a78:	017fffc4 	movi	r5,-1
81144a7c:	1009883a 	mov	r4,r2
81144a80:	11421800 	call	81142180 <mark_cluster>
81144a84:	10000226 	beq	r2,zero,81144a90 <create_file+0x2b8>
                    {
                        result = true;
81144a88:	00800044 	movi	r2,1
81144a8c:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81144a90:	e0bff717 	ldw	r2,-36(fp)
}
81144a94:	e037883a 	mov	sp,fp
81144a98:	dfc00117 	ldw	ra,4(sp)
81144a9c:	df000017 	ldw	fp,0(sp)
81144aa0:	dec00204 	addi	sp,sp,8
81144aa4:	f800283a 	ret

81144aa8 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81144aa8:	defffb04 	addi	sp,sp,-20
81144aac:	de00012e 	bgeu	sp,et,81144ab4 <copy_file_record_name_to_string+0xc>
81144ab0:	003b68fa 	trap	3
81144ab4:	df000415 	stw	fp,16(sp)
81144ab8:	df000404 	addi	fp,sp,16
81144abc:	e13ffe15 	stw	r4,-8(fp)
81144ac0:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81144ac4:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81144ac8:	e03ffc15 	stw	zero,-16(fp)
81144acc:	00001506 	br	81144b24 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81144ad0:	e0fffe17 	ldw	r3,-8(fp)
81144ad4:	e0bffc17 	ldw	r2,-16(fp)
81144ad8:	1885883a 	add	r2,r3,r2
81144adc:	10800003 	ldbu	r2,0(r2)
81144ae0:	10803fcc 	andi	r2,r2,255
81144ae4:	10800820 	cmpeqi	r2,r2,32
81144ae8:	10000b1e 	bne	r2,zero,81144b18 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81144aec:	e0bffd17 	ldw	r2,-12(fp)
81144af0:	e0ffff17 	ldw	r3,-4(fp)
81144af4:	1885883a 	add	r2,r3,r2
81144af8:	e13ffe17 	ldw	r4,-8(fp)
81144afc:	e0fffc17 	ldw	r3,-16(fp)
81144b00:	20c7883a 	add	r3,r4,r3
81144b04:	18c00003 	ldbu	r3,0(r3)
81144b08:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81144b0c:	e0bffd17 	ldw	r2,-12(fp)
81144b10:	10800044 	addi	r2,r2,1
81144b14:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81144b18:	e0bffc17 	ldw	r2,-16(fp)
81144b1c:	10800044 	addi	r2,r2,1
81144b20:	e0bffc15 	stw	r2,-16(fp)
81144b24:	e0bffc17 	ldw	r2,-16(fp)
81144b28:	10800210 	cmplti	r2,r2,8
81144b2c:	103fe81e 	bne	r2,zero,81144ad0 <__reset+0xfb124ad0>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81144b30:	e0bffe17 	ldw	r2,-8(fp)
81144b34:	10800203 	ldbu	r2,8(r2)
81144b38:	10803fcc 	andi	r2,r2,255
81144b3c:	10800820 	cmpeqi	r2,r2,32
81144b40:	1000241e 	bne	r2,zero,81144bd4 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81144b44:	e0bffd17 	ldw	r2,-12(fp)
81144b48:	e0ffff17 	ldw	r3,-4(fp)
81144b4c:	1885883a 	add	r2,r3,r2
81144b50:	00c00b84 	movi	r3,46
81144b54:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81144b58:	e0bffd17 	ldw	r2,-12(fp)
81144b5c:	10800044 	addi	r2,r2,1
81144b60:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81144b64:	e03ffc15 	stw	zero,-16(fp)
81144b68:	00001706 	br	81144bc8 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81144b6c:	e0fffe17 	ldw	r3,-8(fp)
81144b70:	e0bffc17 	ldw	r2,-16(fp)
81144b74:	1885883a 	add	r2,r3,r2
81144b78:	10800204 	addi	r2,r2,8
81144b7c:	10800003 	ldbu	r2,0(r2)
81144b80:	10803fcc 	andi	r2,r2,255
81144b84:	10800820 	cmpeqi	r2,r2,32
81144b88:	10000c1e 	bne	r2,zero,81144bbc <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81144b8c:	e0bffd17 	ldw	r2,-12(fp)
81144b90:	e0ffff17 	ldw	r3,-4(fp)
81144b94:	1885883a 	add	r2,r3,r2
81144b98:	e13ffe17 	ldw	r4,-8(fp)
81144b9c:	e0fffc17 	ldw	r3,-16(fp)
81144ba0:	20c7883a 	add	r3,r4,r3
81144ba4:	18c00204 	addi	r3,r3,8
81144ba8:	18c00003 	ldbu	r3,0(r3)
81144bac:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81144bb0:	e0bffd17 	ldw	r2,-12(fp)
81144bb4:	10800044 	addi	r2,r2,1
81144bb8:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81144bbc:	e0bffc17 	ldw	r2,-16(fp)
81144bc0:	10800044 	addi	r2,r2,1
81144bc4:	e0bffc15 	stw	r2,-16(fp)
81144bc8:	e0bffc17 	ldw	r2,-16(fp)
81144bcc:	108000d0 	cmplti	r2,r2,3
81144bd0:	103fe61e 	bne	r2,zero,81144b6c <__reset+0xfb124b6c>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81144bd4:	e0bffd17 	ldw	r2,-12(fp)
81144bd8:	e0ffff17 	ldw	r3,-4(fp)
81144bdc:	1885883a 	add	r2,r3,r2
81144be0:	10000005 	stb	zero,0(r2)
}
81144be4:	0001883a 	nop
81144be8:	e037883a 	mov	sp,fp
81144bec:	df000017 	ldw	fp,0(sp)
81144bf0:	dec00104 	addi	sp,sp,4
81144bf4:	f800283a 	ret

81144bf8 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81144bf8:	defffc04 	addi	sp,sp,-16
81144bfc:	de00012e 	bgeu	sp,et,81144c04 <alt_up_sd_card_open_dev+0xc>
81144c00:	003b68fa 	trap	3
81144c04:	dfc00315 	stw	ra,12(sp)
81144c08:	df000215 	stw	fp,8(sp)
81144c0c:	df000204 	addi	fp,sp,8
81144c10:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81144c14:	d1600d04 	addi	r5,gp,-32716
81144c18:	e13fff17 	ldw	r4,-4(fp)
81144c1c:	114a0b40 	call	8114a0b4 <alt_find_dev>
81144c20:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81144c24:	e0bffe17 	ldw	r2,-8(fp)
81144c28:	10001e26 	beq	r2,zero,81144ca4 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81144c2c:	e0bffe17 	ldw	r2,-8(fp)
81144c30:	10800a17 	ldw	r2,40(r2)
81144c34:	10808d04 	addi	r2,r2,564
81144c38:	d0a0ab15 	stw	r2,-32084(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81144c3c:	e0bffe17 	ldw	r2,-8(fp)
81144c40:	10800a17 	ldw	r2,40(r2)
81144c44:	10808904 	addi	r2,r2,548
81144c48:	d0a0ac15 	stw	r2,-32080(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81144c4c:	e0bffe17 	ldw	r2,-8(fp)
81144c50:	10800a17 	ldw	r2,40(r2)
81144c54:	10808404 	addi	r2,r2,528
81144c58:	d0a0ad15 	stw	r2,-32076(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81144c5c:	e0bffe17 	ldw	r2,-8(fp)
81144c60:	10800a17 	ldw	r2,40(r2)
81144c64:	10808c04 	addi	r2,r2,560
81144c68:	d0a0ae15 	stw	r2,-32072(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81144c6c:	e0bffe17 	ldw	r2,-8(fp)
81144c70:	10800a17 	ldw	r2,40(r2)
81144c74:	10808b04 	addi	r2,r2,556
81144c78:	d0a0af15 	stw	r2,-32068(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81144c7c:	e0bffe17 	ldw	r2,-8(fp)
81144c80:	10800a17 	ldw	r2,40(r2)
81144c84:	d0a0b015 	stw	r2,-32064(gp)
		device_pointer = dev;
81144c88:	e0bffe17 	ldw	r2,-8(fp)
81144c8c:	d0a0b315 	stw	r2,-32052(gp)
		initialized = false;
81144c90:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81144c94:	d020aa15 	stw	zero,-32088(gp)
		search_data.valid = false;
81144c98:	00a045f4 	movhi	r2,33047
81144c9c:	10b32204 	addi	r2,r2,-13176
81144ca0:	10000415 	stw	zero,16(r2)
	}
	return dev;
81144ca4:	e0bffe17 	ldw	r2,-8(fp)
}
81144ca8:	e037883a 	mov	sp,fp
81144cac:	dfc00117 	ldw	ra,4(sp)
81144cb0:	df000017 	ldw	fp,0(sp)
81144cb4:	dec00204 	addi	sp,sp,8
81144cb8:	f800283a 	ret

81144cbc <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81144cbc:	defffd04 	addi	sp,sp,-12
81144cc0:	de00012e 	bgeu	sp,et,81144cc8 <alt_up_sd_card_is_Present+0xc>
81144cc4:	003b68fa 	trap	3
81144cc8:	df000215 	stw	fp,8(sp)
81144ccc:	df000204 	addi	fp,sp,8
    bool result = false;
81144cd0:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81144cd4:	d0a0b317 	ldw	r2,-32052(gp)
81144cd8:	10000826 	beq	r2,zero,81144cfc <alt_up_sd_card_is_Present+0x40>
81144cdc:	d0a0ab17 	ldw	r2,-32084(gp)
81144ce0:	1080002b 	ldhuio	r2,0(r2)
81144ce4:	10bfffcc 	andi	r2,r2,65535
81144ce8:	1080008c 	andi	r2,r2,2
81144cec:	10000326 	beq	r2,zero,81144cfc <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81144cf0:	00800044 	movi	r2,1
81144cf4:	e0bffe15 	stw	r2,-8(fp)
81144cf8:	00001e06 	br	81144d74 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81144cfc:	d0a0a917 	ldw	r2,-32092(gp)
81144d00:	10800058 	cmpnei	r2,r2,1
81144d04:	10001b1e 	bne	r2,zero,81144d74 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81144d08:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
81144d0c:	00a045f4 	movhi	r2,33047
81144d10:	10b32204 	addi	r2,r2,-13176
81144d14:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81144d18:	d020aa15 	stw	zero,-32088(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81144d1c:	e03fff15 	stw	zero,-4(fp)
81144d20:	00001106 	br	81144d68 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81144d24:	00a045f4 	movhi	r2,33047
81144d28:	10b33c04 	addi	r2,r2,-13072
81144d2c:	e0ffff17 	ldw	r3,-4(fp)
81144d30:	180691ba 	slli	r3,r3,6
81144d34:	10c5883a 	add	r2,r2,r3
81144d38:	10800f04 	addi	r2,r2,60
81144d3c:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81144d40:	00a045f4 	movhi	r2,33047
81144d44:	10b33c04 	addi	r2,r2,-13072
81144d48:	e0ffff17 	ldw	r3,-4(fp)
81144d4c:	180691ba 	slli	r3,r3,6
81144d50:	10c5883a 	add	r2,r2,r3
81144d54:	10800e04 	addi	r2,r2,56
81144d58:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81144d5c:	e0bfff17 	ldw	r2,-4(fp)
81144d60:	10800044 	addi	r2,r2,1
81144d64:	e0bfff15 	stw	r2,-4(fp)
81144d68:	e0bfff17 	ldw	r2,-4(fp)
81144d6c:	10800510 	cmplti	r2,r2,20
81144d70:	103fec1e 	bne	r2,zero,81144d24 <__reset+0xfb124d24>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81144d74:	e0bffe17 	ldw	r2,-8(fp)
}
81144d78:	e037883a 	mov	sp,fp
81144d7c:	df000017 	ldw	fp,0(sp)
81144d80:	dec00104 	addi	sp,sp,4
81144d84:	f800283a 	ret

81144d88 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81144d88:	defffd04 	addi	sp,sp,-12
81144d8c:	de00012e 	bgeu	sp,et,81144d94 <alt_up_sd_card_is_FAT16+0xc>
81144d90:	003b68fa 	trap	3
81144d94:	dfc00215 	stw	ra,8(sp)
81144d98:	df000115 	stw	fp,4(sp)
81144d9c:	df000104 	addi	fp,sp,4
	bool result = false;
81144da0:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81144da4:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
81144da8:	10000c26 	beq	r2,zero,81144ddc <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81144dac:	d0a0a917 	ldw	r2,-32092(gp)
81144db0:	1000071e 	bne	r2,zero,81144dd0 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81144db4:	1142fb40 	call	81142fb4 <Look_for_FAT16>
81144db8:	d0a0aa15 	stw	r2,-32088(gp)
			initialized = is_sd_card_formated_as_FAT16;
81144dbc:	d0a0aa17 	ldw	r2,-32088(gp)
81144dc0:	d0a0a915 	stw	r2,-32092(gp)
			search_data.valid = false;
81144dc4:	00a045f4 	movhi	r2,33047
81144dc8:	10b32204 	addi	r2,r2,-13176
81144dcc:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81144dd0:	d0a0aa17 	ldw	r2,-32088(gp)
81144dd4:	e0bfff15 	stw	r2,-4(fp)
81144dd8:	00000206 	br	81144de4 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81144ddc:	d020a915 	stw	zero,-32092(gp)
		is_sd_card_formated_as_FAT16 = false;
81144de0:	d020aa15 	stw	zero,-32088(gp)
	}

	return result;
81144de4:	e0bfff17 	ldw	r2,-4(fp)
}
81144de8:	e037883a 	mov	sp,fp
81144dec:	dfc00117 	ldw	ra,4(sp)
81144df0:	df000017 	ldw	fp,0(sp)
81144df4:	dec00204 	addi	sp,sp,8
81144df8:	f800283a 	ret

81144dfc <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81144dfc:	deffea04 	addi	sp,sp,-88
81144e00:	de00012e 	bgeu	sp,et,81144e08 <alt_up_sd_card_find_first+0xc>
81144e04:	003b68fa 	trap	3
81144e08:	dfc01515 	stw	ra,84(sp)
81144e0c:	df001415 	stw	fp,80(sp)
81144e10:	df001404 	addi	fp,sp,80
81144e14:	e13ffe15 	stw	r4,-8(fp)
81144e18:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81144e1c:	00800084 	movi	r2,2
81144e20:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81144e24:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
81144e28:	10002426 	beq	r2,zero,81144ebc <alt_up_sd_card_find_first+0xc0>
81144e2c:	d0a0aa17 	ldw	r2,-32088(gp)
81144e30:	10002226 	beq	r2,zero,81144ebc <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
81144e34:	e0ffee04 	addi	r3,fp,-72
81144e38:	e0bfed04 	addi	r2,fp,-76
81144e3c:	180d883a 	mov	r6,r3
81144e40:	100b883a 	mov	r5,r2
81144e44:	e13ffe17 	ldw	r4,-8(fp)
81144e48:	114374c0 	call	8114374c <get_home_directory_cluster_for_file>
81144e4c:	10001926 	beq	r2,zero,81144eb4 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
81144e50:	e0bfed17 	ldw	r2,-76(fp)
81144e54:	1007883a 	mov	r3,r2
81144e58:	00a045f4 	movhi	r2,33047
81144e5c:	10b32204 	addi	r2,r2,-13176
81144e60:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
81144e64:	e0bfed17 	ldw	r2,-76(fp)
81144e68:	1007883a 	mov	r3,r2
81144e6c:	00a045f4 	movhi	r2,33047
81144e70:	10b32204 	addi	r2,r2,-13176
81144e74:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81144e78:	00a045f4 	movhi	r2,33047
81144e7c:	10b32204 	addi	r2,r2,-13176
81144e80:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81144e84:	00a045f4 	movhi	r2,33047
81144e88:	10b32204 	addi	r2,r2,-13176
81144e8c:	00ffffc4 	movi	r3,-1
81144e90:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81144e94:	00a045f4 	movhi	r2,33047
81144e98:	10b32204 	addi	r2,r2,-13176
81144e9c:	00c00044 	movi	r3,1
81144ea0:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81144ea4:	e13fff17 	ldw	r4,-4(fp)
81144ea8:	1144ed40 	call	81144ed4 <alt_up_sd_card_find_next>
81144eac:	e0bfec0d 	sth	r2,-80(fp)
81144eb0:	00000206 	br	81144ebc <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81144eb4:	00800044 	movi	r2,1
81144eb8:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81144ebc:	e0bfec0b 	ldhu	r2,-80(fp)
}
81144ec0:	e037883a 	mov	sp,fp
81144ec4:	dfc00117 	ldw	ra,4(sp)
81144ec8:	df000017 	ldw	fp,0(sp)
81144ecc:	dec00204 	addi	sp,sp,8
81144ed0:	f800283a 	ret

81144ed4 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81144ed4:	deffe404 	addi	sp,sp,-112
81144ed8:	de00012e 	bgeu	sp,et,81144ee0 <alt_up_sd_card_find_next+0xc>
81144edc:	003b68fa 	trap	3
81144ee0:	dfc01b15 	stw	ra,108(sp)
81144ee4:	df001a15 	stw	fp,104(sp)
81144ee8:	df001a04 	addi	fp,sp,104
81144eec:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81144ef0:	00800084 	movi	r2,2
81144ef4:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81144ef8:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
81144efc:	1000df26 	beq	r2,zero,8114527c <alt_up_sd_card_find_next+0x3a8>
81144f00:	d0a0aa17 	ldw	r2,-32088(gp)
81144f04:	1000dd26 	beq	r2,zero,8114527c <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81144f08:	00a045f4 	movhi	r2,33047
81144f0c:	10b32204 	addi	r2,r2,-13176
81144f10:	10800417 	ldw	r2,16(r2)
81144f14:	1000d726 	beq	r2,zero,81145274 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81144f18:	00a045f4 	movhi	r2,33047
81144f1c:	10b32204 	addi	r2,r2,-13176
81144f20:	10800117 	ldw	r2,4(r2)
81144f24:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81144f28:	e0bfe717 	ldw	r2,-100(fp)
81144f2c:	1000561e 	bne	r2,zero,81145088 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81144f30:	00a045f4 	movhi	r2,33047
81144f34:	10b32704 	addi	r2,r2,-13156
81144f38:	1080050b 	ldhu	r2,20(r2)
81144f3c:	10bfffcc 	andi	r2,r2,65535
81144f40:	1006917a 	slli	r3,r2,5
81144f44:	00a045f4 	movhi	r2,33047
81144f48:	10b32704 	addi	r2,r2,-13156
81144f4c:	1080030b 	ldhu	r2,12(r2)
81144f50:	10bfffcc 	andi	r2,r2,65535
81144f54:	1885283a 	div	r2,r3,r2
81144f58:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
81144f5c:	00a045f4 	movhi	r2,33047
81144f60:	10b32204 	addi	r2,r2,-13176
81144f64:	10800217 	ldw	r2,8(r2)
81144f68:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81144f6c:	00a045f4 	movhi	r2,33047
81144f70:	10b32204 	addi	r2,r2,-13176
81144f74:	1080030b 	ldhu	r2,12(r2)
81144f78:	10bfffcc 	andi	r2,r2,65535
81144f7c:	10a0001c 	xori	r2,r2,32768
81144f80:	10a00004 	addi	r2,r2,-32768
81144f84:	10800044 	addi	r2,r2,1
81144f88:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81144f8c:	00003606 	br	81145068 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81144f90:	00a045f4 	movhi	r2,33047
81144f94:	10b32704 	addi	r2,r2,-13156
81144f98:	10c01317 	ldw	r3,76(r2)
81144f9c:	e0bfe817 	ldw	r2,-96(fp)
81144fa0:	1885883a 	add	r2,r3,r2
81144fa4:	1007883a 	mov	r3,r2
81144fa8:	d0a0b117 	ldw	r2,-32060(gp)
81144fac:	100b883a 	mov	r5,r2
81144fb0:	1809883a 	mov	r4,r3
81144fb4:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81144fb8:	10002f26 	beq	r2,zero,81145078 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81144fbc:	00002306 	br	8114504c <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81144fc0:	e0bfe917 	ldw	r2,-92(fp)
81144fc4:	1004917a 	slli	r2,r2,5
81144fc8:	e13fe817 	ldw	r4,-96(fp)
81144fcc:	e0ffef04 	addi	r3,fp,-68
81144fd0:	200f883a 	mov	r7,r4
81144fd4:	000d883a 	mov	r6,zero
81144fd8:	180b883a 	mov	r5,r3
81144fdc:	1009883a 	mov	r4,r2
81144fe0:	11424140 	call	81142414 <Read_File_Record_At_Offset>
81144fe4:	10001626 	beq	r2,zero,81145040 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81144fe8:	e0bfef03 	ldbu	r2,-68(fp)
81144fec:	10803fcc 	andi	r2,r2,255
81144ff0:	10001326 	beq	r2,zero,81145040 <alt_up_sd_card_find_next+0x16c>
81144ff4:	e0bfef03 	ldbu	r2,-68(fp)
81144ff8:	10803fcc 	andi	r2,r2,255
81144ffc:	10803960 	cmpeqi	r2,r2,229
81145000:	10000f1e 	bne	r2,zero,81145040 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
81145004:	e0bfe917 	ldw	r2,-92(fp)
81145008:	1007883a 	mov	r3,r2
8114500c:	00a045f4 	movhi	r2,33047
81145010:	10b32204 	addi	r2,r2,-13176
81145014:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81145018:	e0ffe817 	ldw	r3,-96(fp)
8114501c:	00a045f4 	movhi	r2,33047
81145020:	10b32204 	addi	r2,r2,-13176
81145024:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81145028:	e0bfef04 	addi	r2,fp,-68
8114502c:	e17fff17 	ldw	r5,-4(fp)
81145030:	1009883a 	mov	r4,r2
81145034:	1144aa80 	call	81144aa8 <copy_file_record_name_to_string>
									return 0;
81145038:	0005883a 	mov	r2,zero
8114503c:	00009006 	br	81145280 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81145040:	e0bfe917 	ldw	r2,-92(fp)
81145044:	10800044 	addi	r2,r2,1
81145048:	e0bfe915 	stw	r2,-92(fp)
8114504c:	e0bfe917 	ldw	r2,-92(fp)
81145050:	10800410 	cmplti	r2,r2,16
81145054:	103fda1e 	bne	r2,zero,81144fc0 <__reset+0xfb124fc0>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
81145058:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8114505c:	e0bfe817 	ldw	r2,-96(fp)
81145060:	10800044 	addi	r2,r2,1
81145064:	e0bfe815 	stw	r2,-96(fp)
81145068:	e0ffe817 	ldw	r3,-96(fp)
8114506c:	e0bfec17 	ldw	r2,-80(fp)
81145070:	18bfc716 	blt	r3,r2,81144f90 <__reset+0xfb124f90>
81145074:	00000106 	br	8114507c <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81145078:	0001883a 	nop
					}
				}
				result = -1;
8114507c:	00bfffc4 	movi	r2,-1
81145080:	e0bfe60d 	sth	r2,-104(fp)
81145084:	00007d06 	br	8114527c <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81145088:	00a045f4 	movhi	r2,33047
8114508c:	10b32204 	addi	r2,r2,-13176
81145090:	1080030b 	ldhu	r2,12(r2)
81145094:	10bfffcc 	andi	r2,r2,65535
81145098:	10a0001c 	xori	r2,r2,32768
8114509c:	10a00004 	addi	r2,r2,-32768
811450a0:	10800044 	addi	r2,r2,1
811450a4:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811450a8:	e0bfe717 	ldw	r2,-100(fp)
811450ac:	10ffff84 	addi	r3,r2,-2
811450b0:	00a045f4 	movhi	r2,33047
811450b4:	10b32704 	addi	r2,r2,-13156
811450b8:	10800383 	ldbu	r2,14(r2)
811450bc:	10803fcc 	andi	r2,r2,255
811450c0:	1885383a 	mul	r2,r3,r2
811450c4:	1007883a 	mov	r3,r2
811450c8:	00a045f4 	movhi	r2,33047
811450cc:	10b32704 	addi	r2,r2,-13156
811450d0:	10801417 	ldw	r2,80(r2)
811450d4:	1885883a 	add	r2,r3,r2
811450d8:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
811450dc:	00a045f4 	movhi	r2,33047
811450e0:	10b32204 	addi	r2,r2,-13176
811450e4:	10800217 	ldw	r2,8(r2)
811450e8:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811450ec:	00003806 	br	811451d0 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811450f0:	e0ffeb17 	ldw	r3,-84(fp)
811450f4:	e0bfed17 	ldw	r2,-76(fp)
811450f8:	1885883a 	add	r2,r3,r2
811450fc:	d0e0b117 	ldw	r3,-32060(gp)
81145100:	180b883a 	mov	r5,r3
81145104:	1009883a 	mov	r4,r2
81145108:	1141fe40 	call	81141fe4 <Read_Sector_Data>
8114510c:	10003726 	beq	r2,zero,811451ec <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81145110:	00002806 	br	811451b4 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
81145114:	e0bfea17 	ldw	r2,-88(fp)
81145118:	1004917a 	slli	r2,r2,5
8114511c:	e13fe717 	ldw	r4,-100(fp)
81145120:	e17feb17 	ldw	r5,-84(fp)
81145124:	e0ffef04 	addi	r3,fp,-68
81145128:	280f883a 	mov	r7,r5
8114512c:	200d883a 	mov	r6,r4
81145130:	180b883a 	mov	r5,r3
81145134:	1009883a 	mov	r4,r2
81145138:	11424140 	call	81142414 <Read_File_Record_At_Offset>
8114513c:	10001a26 	beq	r2,zero,811451a8 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81145140:	e0bfef03 	ldbu	r2,-68(fp)
81145144:	10803fcc 	andi	r2,r2,255
81145148:	10001726 	beq	r2,zero,811451a8 <alt_up_sd_card_find_next+0x2d4>
8114514c:	e0bfef03 	ldbu	r2,-68(fp)
81145150:	10803fcc 	andi	r2,r2,255
81145154:	10803960 	cmpeqi	r2,r2,229
81145158:	1000131e 	bne	r2,zero,811451a8 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
8114515c:	e0ffe717 	ldw	r3,-100(fp)
81145160:	00a045f4 	movhi	r2,33047
81145164:	10b32204 	addi	r2,r2,-13176
81145168:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
8114516c:	e0bfea17 	ldw	r2,-88(fp)
81145170:	1007883a 	mov	r3,r2
81145174:	00a045f4 	movhi	r2,33047
81145178:	10b32204 	addi	r2,r2,-13176
8114517c:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
81145180:	e0ffeb17 	ldw	r3,-84(fp)
81145184:	00a045f4 	movhi	r2,33047
81145188:	10b32204 	addi	r2,r2,-13176
8114518c:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81145190:	e0bfef04 	addi	r2,fp,-68
81145194:	e17fff17 	ldw	r5,-4(fp)
81145198:	1009883a 	mov	r4,r2
8114519c:	1144aa80 	call	81144aa8 <copy_file_record_name_to_string>
										return 0;
811451a0:	0005883a 	mov	r2,zero
811451a4:	00003606 	br	81145280 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
811451a8:	e0bfea17 	ldw	r2,-88(fp)
811451ac:	10800044 	addi	r2,r2,1
811451b0:	e0bfea15 	stw	r2,-88(fp)
811451b4:	e0bfea17 	ldw	r2,-88(fp)
811451b8:	10800410 	cmplti	r2,r2,16
811451bc:	103fd51e 	bne	r2,zero,81145114 <__reset+0xfb125114>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
811451c0:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811451c4:	e0bfeb17 	ldw	r2,-84(fp)
811451c8:	10800044 	addi	r2,r2,1
811451cc:	e0bfeb15 	stw	r2,-84(fp)
811451d0:	00a045f4 	movhi	r2,33047
811451d4:	10b32704 	addi	r2,r2,-13156
811451d8:	10800383 	ldbu	r2,14(r2)
811451dc:	10803fcc 	andi	r2,r2,255
811451e0:	e0ffeb17 	ldw	r3,-84(fp)
811451e4:	18bfc216 	blt	r3,r2,811450f0 <__reset+0xfb1250f0>
811451e8:	00000106 	br	811451f0 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
811451ec:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
811451f0:	00a045f4 	movhi	r2,33047
811451f4:	10b32704 	addi	r2,r2,-13156
811451f8:	10800383 	ldbu	r2,14(r2)
811451fc:	10803fcc 	andi	r2,r2,255
81145200:	e0ffeb17 	ldw	r3,-84(fp)
81145204:	18801716 	blt	r3,r2,81145264 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81145208:	e0bfe717 	ldw	r2,-100(fp)
8114520c:	e0ffee04 	addi	r3,fp,-72
81145210:	180b883a 	mov	r5,r3
81145214:	1009883a 	mov	r4,r2
81145218:	11420c40 	call	811420c4 <get_cluster_flag>
8114521c:	10000f26 	beq	r2,zero,8114525c <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81145220:	e0bfee0b 	ldhu	r2,-72(fp)
81145224:	10bfffcc 	andi	r2,r2,65535
81145228:	10fffe0c 	andi	r3,r2,65528
8114522c:	00bffe14 	movui	r2,65528
81145230:	1880051e 	bne	r3,r2,81145248 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
81145234:	00bfffc4 	movi	r2,-1
81145238:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
8114523c:	00a045f4 	movhi	r2,33047
81145240:	10b32204 	addi	r2,r2,-13176
81145244:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81145248:	e0bfee0b 	ldhu	r2,-72(fp)
8114524c:	10bfffcc 	andi	r2,r2,65535
81145250:	10bffe0c 	andi	r2,r2,65528
81145254:	e0bfe715 	stw	r2,-100(fp)
81145258:	00000206 	br	81145264 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
8114525c:	00bfffc4 	movi	r2,-1
81145260:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
81145264:	e0bfe717 	ldw	r2,-100(fp)
81145268:	00fffdd4 	movui	r3,65527
8114526c:	18bf8e0e 	bge	r3,r2,811450a8 <__reset+0xfb1250a8>
81145270:	00000206 	br	8114527c <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81145274:	008000c4 	movi	r2,3
81145278:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
8114527c:	e0bfe60b 	ldhu	r2,-104(fp)
}
81145280:	e037883a 	mov	sp,fp
81145284:	dfc00117 	ldw	ra,4(sp)
81145288:	df000017 	ldw	fp,0(sp)
8114528c:	dec00204 	addi	sp,sp,8
81145290:	f800283a 	ret

81145294 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81145294:	deffe904 	addi	sp,sp,-92
81145298:	de00012e 	bgeu	sp,et,811452a0 <alt_up_sd_card_fopen+0xc>
8114529c:	003b68fa 	trap	3
811452a0:	dfc01615 	stw	ra,88(sp)
811452a4:	df001515 	stw	fp,84(sp)
811452a8:	df001504 	addi	fp,sp,84
811452ac:	e13ffe15 	stw	r4,-8(fp)
811452b0:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
811452b4:	00bfffc4 	movi	r2,-1
811452b8:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811452bc:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
811452c0:	1000cf26 	beq	r2,zero,81145600 <alt_up_sd_card_fopen+0x36c>
811452c4:	d0a0aa17 	ldw	r2,-32088(gp)
811452c8:	1000cd26 	beq	r2,zero,81145600 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
811452cc:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
811452d0:	e13ffe17 	ldw	r4,-8(fp)
811452d4:	11430a80 	call	811430a8 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
811452d8:	e13ffe17 	ldw	r4,-8(fp)
811452dc:	11431740 	call	81143174 <check_file_name_for_FAT16_compliance>
811452e0:	1000c726 	beq	r2,zero,81145600 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
811452e4:	e0ffee04 	addi	r3,fp,-72
811452e8:	e0bfed04 	addi	r2,fp,-76
811452ec:	180d883a 	mov	r6,r3
811452f0:	100b883a 	mov	r5,r2
811452f4:	e13ffe17 	ldw	r4,-8(fp)
811452f8:	114374c0 	call	8114374c <get_home_directory_cluster_for_file>
811452fc:	1000021e 	bne	r2,zero,81145308 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81145300:	e0bfeb0b 	ldhu	r2,-84(fp)
81145304:	0000bf06 	br	81145604 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81145308:	e03fec15 	stw	zero,-80(fp)
8114530c:	00000e06 	br	81145348 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
81145310:	00a045f4 	movhi	r2,33047
81145314:	10b33c04 	addi	r2,r2,-13072
81145318:	e0ffec17 	ldw	r3,-80(fp)
8114531c:	180691ba 	slli	r3,r3,6
81145320:	10c5883a 	add	r2,r2,r3
81145324:	10800f04 	addi	r2,r2,60
81145328:	10800017 	ldw	r2,0(r2)
8114532c:	1000031e 	bne	r2,zero,8114533c <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
81145330:	e0bfec17 	ldw	r2,-80(fp)
81145334:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
81145338:	00000606 	br	81145354 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8114533c:	e0bfec17 	ldw	r2,-80(fp)
81145340:	10800044 	addi	r2,r2,1
81145344:	e0bfec15 	stw	r2,-80(fp)
81145348:	e0bfec17 	ldw	r2,-80(fp)
8114534c:	10800510 	cmplti	r2,r2,20
81145350:	103fef1e 	bne	r2,zero,81145310 <__reset+0xfb125310>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
81145354:	e0bfeb0f 	ldh	r2,-84(fp)
81145358:	1000a916 	blt	r2,zero,81145600 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
8114535c:	e0bfed17 	ldw	r2,-76(fp)
81145360:	1009883a 	mov	r4,r2
81145364:	e0bfeb0f 	ldh	r2,-84(fp)
81145368:	100691ba 	slli	r3,r2,6
8114536c:	00a045f4 	movhi	r2,33047
81145370:	10b33c04 	addi	r2,r2,-13072
81145374:	1885883a 	add	r2,r3,r2
81145378:	100d883a 	mov	r6,r2
8114537c:	e17ffe17 	ldw	r5,-8(fp)
81145380:	1143c8c0 	call	81143c8c <find_file_in_directory>
81145384:	10007b26 	beq	r2,zero,81145574 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81145388:	e0bfff17 	ldw	r2,-4(fp)
8114538c:	10000226 	beq	r2,zero,81145398 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
81145390:	00bfffc4 	movi	r2,-1
81145394:	00009b06 	br	81145604 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81145398:	e13feb0f 	ldh	r4,-84(fp)
8114539c:	e0ffeb0f 	ldh	r3,-84(fp)
811453a0:	00a045f4 	movhi	r2,33047
811453a4:	10b33c04 	addi	r2,r2,-13072
811453a8:	180691ba 	slli	r3,r3,6
811453ac:	10c5883a 	add	r2,r2,r3
811453b0:	10800584 	addi	r2,r2,22
811453b4:	1080000b 	ldhu	r2,0(r2)
811453b8:	10ffffcc 	andi	r3,r2,65535
811453bc:	00a045f4 	movhi	r2,33047
811453c0:	10b33c04 	addi	r2,r2,-13072
811453c4:	200891ba 	slli	r4,r4,6
811453c8:	1105883a 	add	r2,r2,r4
811453cc:	10800704 	addi	r2,r2,28
811453d0:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
811453d4:	e0ffeb0f 	ldh	r3,-84(fp)
811453d8:	00a045f4 	movhi	r2,33047
811453dc:	10b33c04 	addi	r2,r2,-13072
811453e0:	180691ba 	slli	r3,r3,6
811453e4:	10c5883a 	add	r2,r2,r3
811453e8:	10800804 	addi	r2,r2,32
811453ec:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
811453f0:	e0ffeb0f 	ldh	r3,-84(fp)
811453f4:	00a045f4 	movhi	r2,33047
811453f8:	10b33c04 	addi	r2,r2,-13072
811453fc:	180691ba 	slli	r3,r3,6
81145400:	10c5883a 	add	r2,r2,r3
81145404:	10800904 	addi	r2,r2,36
81145408:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
8114540c:	e0ffeb0f 	ldh	r3,-84(fp)
81145410:	00a045f4 	movhi	r2,33047
81145414:	10b33c04 	addi	r2,r2,-13072
81145418:	180691ba 	slli	r3,r3,6
8114541c:	10c5883a 	add	r2,r2,r3
81145420:	10800f04 	addi	r2,r2,60
81145424:	00c00044 	movi	r3,1
81145428:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
8114542c:	e0ffeb0f 	ldh	r3,-84(fp)
81145430:	00a045f4 	movhi	r2,33047
81145434:	10b33c04 	addi	r2,r2,-13072
81145438:	180691ba 	slli	r3,r3,6
8114543c:	10c5883a 	add	r2,r2,r3
81145440:	10800e04 	addi	r2,r2,56
81145444:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81145448:	e03fec15 	stw	zero,-80(fp)
8114544c:	00004506 	br	81145564 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
81145450:	e0ffeb0f 	ldh	r3,-84(fp)
81145454:	e0bfec17 	ldw	r2,-80(fp)
81145458:	18803f26 	beq	r3,r2,81145558 <alt_up_sd_card_fopen+0x2c4>
8114545c:	00a045f4 	movhi	r2,33047
81145460:	10b33c04 	addi	r2,r2,-13072
81145464:	e0ffec17 	ldw	r3,-80(fp)
81145468:	180691ba 	slli	r3,r3,6
8114546c:	10c5883a 	add	r2,r2,r3
81145470:	10800f04 	addi	r2,r2,60
81145474:	10800017 	ldw	r2,0(r2)
81145478:	10800058 	cmpnei	r2,r2,1
8114547c:	1000361e 	bne	r2,zero,81145558 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81145480:	e0ffeb0f 	ldh	r3,-84(fp)
81145484:	00a045f4 	movhi	r2,33047
81145488:	10b33c04 	addi	r2,r2,-13072
8114548c:	180691ba 	slli	r3,r3,6
81145490:	10c5883a 	add	r2,r2,r3
81145494:	10800a04 	addi	r2,r2,40
81145498:	10c00017 	ldw	r3,0(r2)
8114549c:	00a045f4 	movhi	r2,33047
811454a0:	10b33c04 	addi	r2,r2,-13072
811454a4:	e13fec17 	ldw	r4,-80(fp)
811454a8:	200891ba 	slli	r4,r4,6
811454ac:	1105883a 	add	r2,r2,r4
811454b0:	10800a04 	addi	r2,r2,40
811454b4:	10800017 	ldw	r2,0(r2)
811454b8:	1880271e 	bne	r3,r2,81145558 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
811454bc:	e0ffeb0f 	ldh	r3,-84(fp)
811454c0:	00a045f4 	movhi	r2,33047
811454c4:	10b33c04 	addi	r2,r2,-13072
811454c8:	180691ba 	slli	r3,r3,6
811454cc:	10c5883a 	add	r2,r2,r3
811454d0:	10800b04 	addi	r2,r2,44
811454d4:	10c00017 	ldw	r3,0(r2)
811454d8:	00a045f4 	movhi	r2,33047
811454dc:	10b33c04 	addi	r2,r2,-13072
811454e0:	e13fec17 	ldw	r4,-80(fp)
811454e4:	200891ba 	slli	r4,r4,6
811454e8:	1105883a 	add	r2,r2,r4
811454ec:	10800b04 	addi	r2,r2,44
811454f0:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811454f4:	1880181e 	bne	r3,r2,81145558 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
811454f8:	e0ffeb0f 	ldh	r3,-84(fp)
811454fc:	00a045f4 	movhi	r2,33047
81145500:	10b33c04 	addi	r2,r2,-13072
81145504:	180691ba 	slli	r3,r3,6
81145508:	10c5883a 	add	r2,r2,r3
8114550c:	10800c04 	addi	r2,r2,48
81145510:	1100000b 	ldhu	r4,0(r2)
81145514:	00a045f4 	movhi	r2,33047
81145518:	10b33c04 	addi	r2,r2,-13072
8114551c:	e0ffec17 	ldw	r3,-80(fp)
81145520:	180691ba 	slli	r3,r3,6
81145524:	10c5883a 	add	r2,r2,r3
81145528:	10800c04 	addi	r2,r2,48
8114552c:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81145530:	20ffffcc 	andi	r3,r4,65535
81145534:	18e0001c 	xori	r3,r3,32768
81145538:	18e00004 	addi	r3,r3,-32768
8114553c:	10bfffcc 	andi	r2,r2,65535
81145540:	10a0001c 	xori	r2,r2,32768
81145544:	10a00004 	addi	r2,r2,-32768
81145548:	1880031e 	bne	r3,r2,81145558 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
8114554c:	00bfff84 	movi	r2,-2
81145550:	e0bfeb0d 	sth	r2,-84(fp)
								break;
81145554:	00002a06 	br	81145600 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81145558:	e0bfec17 	ldw	r2,-80(fp)
8114555c:	10800044 	addi	r2,r2,1
81145560:	e0bfec15 	stw	r2,-80(fp)
81145564:	e0bfec17 	ldw	r2,-80(fp)
81145568:	10800510 	cmplti	r2,r2,20
8114556c:	103fb81e 	bne	r2,zero,81145450 <__reset+0xfb125450>
81145570:	00002306 	br	81145600 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81145574:	e0bfff17 	ldw	r2,-4(fp)
81145578:	10001f26 	beq	r2,zero,811455f8 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
8114557c:	e0bfeb0f 	ldh	r2,-84(fp)
81145580:	100691ba 	slli	r3,r2,6
81145584:	00a045f4 	movhi	r2,33047
81145588:	10b33c04 	addi	r2,r2,-13072
8114558c:	1885883a 	add	r2,r3,r2
81145590:	e0ffee04 	addi	r3,fp,-72
81145594:	180d883a 	mov	r6,r3
81145598:	100b883a 	mov	r5,r2
8114559c:	e13ffe17 	ldw	r4,-8(fp)
811455a0:	11447d80 	call	811447d8 <create_file>
811455a4:	10001126 	beq	r2,zero,811455ec <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
811455a8:	e0ffeb0f 	ldh	r3,-84(fp)
811455ac:	00a045f4 	movhi	r2,33047
811455b0:	10b33c04 	addi	r2,r2,-13072
811455b4:	180691ba 	slli	r3,r3,6
811455b8:	10c5883a 	add	r2,r2,r3
811455bc:	10800f04 	addi	r2,r2,60
811455c0:	00c00044 	movi	r3,1
811455c4:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
811455c8:	e0ffeb0f 	ldh	r3,-84(fp)
811455cc:	00a045f4 	movhi	r2,33047
811455d0:	10b33c04 	addi	r2,r2,-13072
811455d4:	180691ba 	slli	r3,r3,6
811455d8:	10c5883a 	add	r2,r2,r3
811455dc:	10800e04 	addi	r2,r2,56
811455e0:	00c00044 	movi	r3,1
811455e4:	10c00015 	stw	r3,0(r2)
811455e8:	00000506 	br	81145600 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
811455ec:	00bfffc4 	movi	r2,-1
811455f0:	e0bfeb0d 	sth	r2,-84(fp)
811455f4:	00000206 	br	81145600 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
811455f8:	00bfffc4 	movi	r2,-1
811455fc:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81145600:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81145604:	e037883a 	mov	sp,fp
81145608:	dfc00117 	ldw	ra,4(sp)
8114560c:	df000017 	ldw	fp,0(sp)
81145610:	dec00204 	addi	sp,sp,8
81145614:	f800283a 	ret

81145618 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81145618:	defffd04 	addi	sp,sp,-12
8114561c:	de00012e 	bgeu	sp,et,81145624 <alt_up_sd_card_set_attributes+0xc>
81145620:	003b68fa 	trap	3
81145624:	df000215 	stw	fp,8(sp)
81145628:	df000204 	addi	fp,sp,8
8114562c:	2007883a 	mov	r3,r4
81145630:	2805883a 	mov	r2,r5
81145634:	e0fffe0d 	sth	r3,-8(fp)
81145638:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8114563c:	e0bffe0f 	ldh	r2,-8(fp)
81145640:	10001416 	blt	r2,zero,81145694 <alt_up_sd_card_set_attributes+0x7c>
81145644:	e0bffe0f 	ldh	r2,-8(fp)
81145648:	10800508 	cmpgei	r2,r2,20
8114564c:	1000111e 	bne	r2,zero,81145694 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81145650:	e0fffe0f 	ldh	r3,-8(fp)
81145654:	00a045f4 	movhi	r2,33047
81145658:	10b33c04 	addi	r2,r2,-13072
8114565c:	180691ba 	slli	r3,r3,6
81145660:	10c5883a 	add	r2,r2,r3
81145664:	10800f04 	addi	r2,r2,60
81145668:	10800017 	ldw	r2,0(r2)
8114566c:	10000926 	beq	r2,zero,81145694 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
81145670:	e0fffe0f 	ldh	r3,-8(fp)
81145674:	e0bfff0b 	ldhu	r2,-4(fp)
81145678:	1009883a 	mov	r4,r2
8114567c:	00a045f4 	movhi	r2,33047
81145680:	10b33c04 	addi	r2,r2,-13072
81145684:	180691ba 	slli	r3,r3,6
81145688:	10c5883a 	add	r2,r2,r3
8114568c:	108002c4 	addi	r2,r2,11
81145690:	11000005 	stb	r4,0(r2)
        }
    }
}
81145694:	0001883a 	nop
81145698:	e037883a 	mov	sp,fp
8114569c:	df000017 	ldw	fp,0(sp)
811456a0:	dec00104 	addi	sp,sp,4
811456a4:	f800283a 	ret

811456a8 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
811456a8:	defffd04 	addi	sp,sp,-12
811456ac:	de00012e 	bgeu	sp,et,811456b4 <alt_up_sd_card_get_attributes+0xc>
811456b0:	003b68fa 	trap	3
811456b4:	df000215 	stw	fp,8(sp)
811456b8:	df000204 	addi	fp,sp,8
811456bc:	2005883a 	mov	r2,r4
811456c0:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
811456c4:	00bfffc4 	movi	r2,-1
811456c8:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811456cc:	e0bfff0f 	ldh	r2,-4(fp)
811456d0:	10001416 	blt	r2,zero,81145724 <alt_up_sd_card_get_attributes+0x7c>
811456d4:	e0bfff0f 	ldh	r2,-4(fp)
811456d8:	10800508 	cmpgei	r2,r2,20
811456dc:	1000111e 	bne	r2,zero,81145724 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
811456e0:	e0ffff0f 	ldh	r3,-4(fp)
811456e4:	00a045f4 	movhi	r2,33047
811456e8:	10b33c04 	addi	r2,r2,-13072
811456ec:	180691ba 	slli	r3,r3,6
811456f0:	10c5883a 	add	r2,r2,r3
811456f4:	10800f04 	addi	r2,r2,60
811456f8:	10800017 	ldw	r2,0(r2)
811456fc:	10000926 	beq	r2,zero,81145724 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81145700:	e0ffff0f 	ldh	r3,-4(fp)
81145704:	00a045f4 	movhi	r2,33047
81145708:	10b33c04 	addi	r2,r2,-13072
8114570c:	180691ba 	slli	r3,r3,6
81145710:	10c5883a 	add	r2,r2,r3
81145714:	108002c4 	addi	r2,r2,11
81145718:	10800003 	ldbu	r2,0(r2)
8114571c:	10803fcc 	andi	r2,r2,255
81145720:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81145724:	e0bffe0b 	ldhu	r2,-8(fp)
}
81145728:	e037883a 	mov	sp,fp
8114572c:	df000017 	ldw	fp,0(sp)
81145730:	dec00104 	addi	sp,sp,4
81145734:	f800283a 	ret

81145738 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
81145738:	defffa04 	addi	sp,sp,-24
8114573c:	de00012e 	bgeu	sp,et,81145744 <alt_up_sd_card_read+0xc>
81145740:	003b68fa 	trap	3
81145744:	dfc00515 	stw	ra,20(sp)
81145748:	df000415 	stw	fp,16(sp)
8114574c:	df000404 	addi	fp,sp,16
81145750:	2005883a 	mov	r2,r4
81145754:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
81145758:	00bfffc4 	movi	r2,-1
8114575c:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81145760:	e0bfff0f 	ldh	r2,-4(fp)
81145764:	1000ce16 	blt	r2,zero,81145aa0 <alt_up_sd_card_read+0x368>
81145768:	e0bfff0f 	ldh	r2,-4(fp)
8114576c:	10800508 	cmpgei	r2,r2,20
81145770:	1000cb1e 	bne	r2,zero,81145aa0 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81145774:	e0ffff0f 	ldh	r3,-4(fp)
81145778:	00a045f4 	movhi	r2,33047
8114577c:	10b33c04 	addi	r2,r2,-13072
81145780:	180691ba 	slli	r3,r3,6
81145784:	10c5883a 	add	r2,r2,r3
81145788:	10800f04 	addi	r2,r2,60
8114578c:	10800017 	ldw	r2,0(r2)
81145790:	1000c326 	beq	r2,zero,81145aa0 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81145794:	e0ffff0f 	ldh	r3,-4(fp)
81145798:	00a045f4 	movhi	r2,33047
8114579c:	10b33c04 	addi	r2,r2,-13072
811457a0:	180691ba 	slli	r3,r3,6
811457a4:	10c5883a 	add	r2,r2,r3
811457a8:	10800904 	addi	r2,r2,36
811457ac:	10c00017 	ldw	r3,0(r2)
811457b0:	e13fff0f 	ldh	r4,-4(fp)
811457b4:	00a045f4 	movhi	r2,33047
811457b8:	10b33c04 	addi	r2,r2,-13072
811457bc:	200891ba 	slli	r4,r4,6
811457c0:	1105883a 	add	r2,r2,r4
811457c4:	10800604 	addi	r2,r2,24
811457c8:	10800017 	ldw	r2,0(r2)
811457cc:	1880b42e 	bgeu	r3,r2,81145aa0 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811457d0:	00a045f4 	movhi	r2,33047
811457d4:	10b32704 	addi	r2,r2,-13156
811457d8:	10c01417 	ldw	r3,80(r2)
811457dc:	e13fff0f 	ldh	r4,-4(fp)
811457e0:	00a045f4 	movhi	r2,33047
811457e4:	10b33c04 	addi	r2,r2,-13072
811457e8:	200891ba 	slli	r4,r4,6
811457ec:	1105883a 	add	r2,r2,r4
811457f0:	10800704 	addi	r2,r2,28
811457f4:	10800017 	ldw	r2,0(r2)
811457f8:	113fff84 	addi	r4,r2,-2
811457fc:	00a045f4 	movhi	r2,33047
81145800:	10b32704 	addi	r2,r2,-13156
81145804:	10800383 	ldbu	r2,14(r2)
81145808:	10803fcc 	andi	r2,r2,255
8114580c:	2085383a 	mul	r2,r4,r2
81145810:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81145814:	e13fff0f 	ldh	r4,-4(fp)
81145818:	00a045f4 	movhi	r2,33047
8114581c:	10b33c04 	addi	r2,r2,-13072
81145820:	200891ba 	slli	r4,r4,6
81145824:	1105883a 	add	r2,r2,r4
81145828:	10800804 	addi	r2,r2,32
8114582c:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145830:	1885883a 	add	r2,r3,r2
81145834:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81145838:	e0ffff0f 	ldh	r3,-4(fp)
8114583c:	00a045f4 	movhi	r2,33047
81145840:	10b33c04 	addi	r2,r2,-13072
81145844:	180691ba 	slli	r3,r3,6
81145848:	10c5883a 	add	r2,r2,r3
8114584c:	10800904 	addi	r2,r2,36
81145850:	10800017 	ldw	r2,0(r2)
81145854:	10006826 	beq	r2,zero,811459f8 <alt_up_sd_card_read+0x2c0>
81145858:	e0ffff0f 	ldh	r3,-4(fp)
8114585c:	00a045f4 	movhi	r2,33047
81145860:	10b33c04 	addi	r2,r2,-13072
81145864:	180691ba 	slli	r3,r3,6
81145868:	10c5883a 	add	r2,r2,r3
8114586c:	10800904 	addi	r2,r2,36
81145870:	10800017 	ldw	r2,0(r2)
81145874:	10807fcc 	andi	r2,r2,511
81145878:	10005f1e 	bne	r2,zero,811459f8 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8114587c:	e0ffff0f 	ldh	r3,-4(fp)
81145880:	00a045f4 	movhi	r2,33047
81145884:	10b33c04 	addi	r2,r2,-13072
81145888:	180691ba 	slli	r3,r3,6
8114588c:	10c5883a 	add	r2,r2,r3
81145890:	10800804 	addi	r2,r2,32
81145894:	10c00017 	ldw	r3,0(r2)
81145898:	00a045f4 	movhi	r2,33047
8114589c:	10b32704 	addi	r2,r2,-13156
811458a0:	10800383 	ldbu	r2,14(r2)
811458a4:	10803fcc 	andi	r2,r2,255
811458a8:	10bfffc4 	addi	r2,r2,-1
811458ac:	1880401e 	bne	r3,r2,811459b0 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
811458b0:	e0ffff0f 	ldh	r3,-4(fp)
811458b4:	00a045f4 	movhi	r2,33047
811458b8:	10b33c04 	addi	r2,r2,-13072
811458bc:	180691ba 	slli	r3,r3,6
811458c0:	10c5883a 	add	r2,r2,r3
811458c4:	10800704 	addi	r2,r2,28
811458c8:	10800017 	ldw	r2,0(r2)
811458cc:	e0fffe04 	addi	r3,fp,-8
811458d0:	180b883a 	mov	r5,r3
811458d4:	1009883a 	mov	r4,r2
811458d8:	11420c40 	call	811420c4 <get_cluster_flag>
811458dc:	10003226 	beq	r2,zero,811459a8 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
811458e0:	e0bffe0b 	ldhu	r2,-8(fp)
811458e4:	10bfffcc 	andi	r2,r2,65535
811458e8:	10fffe0c 	andi	r3,r2,65528
811458ec:	00bffe14 	movui	r2,65528
811458f0:	1880021e 	bne	r3,r2,811458fc <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
811458f4:	00bfffc4 	movi	r2,-1
811458f8:	00006a06 	br	81145aa4 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
811458fc:	e13fff0f 	ldh	r4,-4(fp)
81145900:	e0bffe0b 	ldhu	r2,-8(fp)
81145904:	10ffffcc 	andi	r3,r2,65535
81145908:	00a045f4 	movhi	r2,33047
8114590c:	10b33c04 	addi	r2,r2,-13072
81145910:	200891ba 	slli	r4,r4,6
81145914:	1105883a 	add	r2,r2,r4
81145918:	10800704 	addi	r2,r2,28
8114591c:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81145920:	e0ffff0f 	ldh	r3,-4(fp)
81145924:	00a045f4 	movhi	r2,33047
81145928:	10b33c04 	addi	r2,r2,-13072
8114592c:	180691ba 	slli	r3,r3,6
81145930:	10c5883a 	add	r2,r2,r3
81145934:	10800804 	addi	r2,r2,32
81145938:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114593c:	00a045f4 	movhi	r2,33047
81145940:	10b32704 	addi	r2,r2,-13156
81145944:	10c01417 	ldw	r3,80(r2)
81145948:	e13fff0f 	ldh	r4,-4(fp)
8114594c:	00a045f4 	movhi	r2,33047
81145950:	10b33c04 	addi	r2,r2,-13072
81145954:	200891ba 	slli	r4,r4,6
81145958:	1105883a 	add	r2,r2,r4
8114595c:	10800704 	addi	r2,r2,28
81145960:	10800017 	ldw	r2,0(r2)
81145964:	113fff84 	addi	r4,r2,-2
81145968:	00a045f4 	movhi	r2,33047
8114596c:	10b32704 	addi	r2,r2,-13156
81145970:	10800383 	ldbu	r2,14(r2)
81145974:	10803fcc 	andi	r2,r2,255
81145978:	2085383a 	mul	r2,r4,r2
8114597c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81145980:	e13fff0f 	ldh	r4,-4(fp)
81145984:	00a045f4 	movhi	r2,33047
81145988:	10b33c04 	addi	r2,r2,-13072
8114598c:	200891ba 	slli	r4,r4,6
81145990:	1105883a 	add	r2,r2,r4
81145994:	10800804 	addi	r2,r2,32
81145998:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114599c:	1885883a 	add	r2,r3,r2
811459a0:	e0bffd15 	stw	r2,-12(fp)
811459a4:	00001406 	br	811459f8 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
811459a8:	00bfff84 	movi	r2,-2
811459ac:	00003d06 	br	81145aa4 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
811459b0:	e13fff0f 	ldh	r4,-4(fp)
811459b4:	e0ffff0f 	ldh	r3,-4(fp)
811459b8:	00a045f4 	movhi	r2,33047
811459bc:	10b33c04 	addi	r2,r2,-13072
811459c0:	180691ba 	slli	r3,r3,6
811459c4:	10c5883a 	add	r2,r2,r3
811459c8:	10800804 	addi	r2,r2,32
811459cc:	10800017 	ldw	r2,0(r2)
811459d0:	10c00044 	addi	r3,r2,1
811459d4:	00a045f4 	movhi	r2,33047
811459d8:	10b33c04 	addi	r2,r2,-13072
811459dc:	200891ba 	slli	r4,r4,6
811459e0:	1105883a 	add	r2,r2,r4
811459e4:	10800804 	addi	r2,r2,32
811459e8:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
811459ec:	e0bffd17 	ldw	r2,-12(fp)
811459f0:	10800044 	addi	r2,r2,1
811459f4:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
811459f8:	d0e0b117 	ldw	r3,-32060(gp)
811459fc:	e0bffd17 	ldw	r2,-12(fp)
81145a00:	1885883a 	add	r2,r3,r2
81145a04:	1007883a 	mov	r3,r2
81145a08:	d0a0b517 	ldw	r2,-32044(gp)
81145a0c:	18800726 	beq	r3,r2,81145a2c <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81145a10:	d0a0b117 	ldw	r2,-32060(gp)
81145a14:	100b883a 	mov	r5,r2
81145a18:	e13ffd17 	ldw	r4,-12(fp)
81145a1c:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81145a20:	1000021e 	bne	r2,zero,81145a2c <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81145a24:	00bfff84 	movi	r2,-2
81145a28:	00001e06 	br	81145aa4 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81145a2c:	d0e0b017 	ldw	r3,-32064(gp)
81145a30:	e13fff0f 	ldh	r4,-4(fp)
81145a34:	00a045f4 	movhi	r2,33047
81145a38:	10b33c04 	addi	r2,r2,-13072
81145a3c:	200891ba 	slli	r4,r4,6
81145a40:	1105883a 	add	r2,r2,r4
81145a44:	10800904 	addi	r2,r2,36
81145a48:	10800017 	ldw	r2,0(r2)
81145a4c:	10807fcc 	andi	r2,r2,511
81145a50:	1885883a 	add	r2,r3,r2
81145a54:	10800023 	ldbuio	r2,0(r2)
81145a58:	10803fcc 	andi	r2,r2,255
81145a5c:	10803fcc 	andi	r2,r2,255
81145a60:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81145a64:	e13fff0f 	ldh	r4,-4(fp)
81145a68:	e0ffff0f 	ldh	r3,-4(fp)
81145a6c:	00a045f4 	movhi	r2,33047
81145a70:	10b33c04 	addi	r2,r2,-13072
81145a74:	180691ba 	slli	r3,r3,6
81145a78:	10c5883a 	add	r2,r2,r3
81145a7c:	10800904 	addi	r2,r2,36
81145a80:	10800017 	ldw	r2,0(r2)
81145a84:	10c00044 	addi	r3,r2,1
81145a88:	00a045f4 	movhi	r2,33047
81145a8c:	10b33c04 	addi	r2,r2,-13072
81145a90:	200891ba 	slli	r4,r4,6
81145a94:	1105883a 	add	r2,r2,r4
81145a98:	10800904 	addi	r2,r2,36
81145a9c:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81145aa0:	e0bffc0b 	ldhu	r2,-16(fp)
}
81145aa4:	e037883a 	mov	sp,fp
81145aa8:	dfc00117 	ldw	ra,4(sp)
81145aac:	df000017 	ldw	fp,0(sp)
81145ab0:	dec00204 	addi	sp,sp,8
81145ab4:	f800283a 	ret

81145ab8 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81145ab8:	defff804 	addi	sp,sp,-32
81145abc:	de00012e 	bgeu	sp,et,81145ac4 <alt_up_sd_card_write+0xc>
81145ac0:	003b68fa 	trap	3
81145ac4:	dfc00715 	stw	ra,28(sp)
81145ac8:	df000615 	stw	fp,24(sp)
81145acc:	df000604 	addi	fp,sp,24
81145ad0:	2007883a 	mov	r3,r4
81145ad4:	2805883a 	mov	r2,r5
81145ad8:	e0fffe0d 	sth	r3,-8(fp)
81145adc:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81145ae0:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81145ae4:	e0bffe0f 	ldh	r2,-8(fp)
81145ae8:	10017716 	blt	r2,zero,811460c8 <alt_up_sd_card_write+0x610>
81145aec:	e0bffe0f 	ldh	r2,-8(fp)
81145af0:	10800508 	cmpgei	r2,r2,20
81145af4:	1001741e 	bne	r2,zero,811460c8 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81145af8:	e0fffe0f 	ldh	r3,-8(fp)
81145afc:	00a045f4 	movhi	r2,33047
81145b00:	10b33c04 	addi	r2,r2,-13072
81145b04:	180691ba 	slli	r3,r3,6
81145b08:	10c5883a 	add	r2,r2,r3
81145b0c:	10800f04 	addi	r2,r2,60
81145b10:	10800017 	ldw	r2,0(r2)
81145b14:	10016c26 	beq	r2,zero,811460c8 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145b18:	00a045f4 	movhi	r2,33047
81145b1c:	10b32704 	addi	r2,r2,-13156
81145b20:	10c01417 	ldw	r3,80(r2)
81145b24:	e13ffe0f 	ldh	r4,-8(fp)
81145b28:	00a045f4 	movhi	r2,33047
81145b2c:	10b33c04 	addi	r2,r2,-13072
81145b30:	200891ba 	slli	r4,r4,6
81145b34:	1105883a 	add	r2,r2,r4
81145b38:	10800704 	addi	r2,r2,28
81145b3c:	10800017 	ldw	r2,0(r2)
81145b40:	113fff84 	addi	r4,r2,-2
81145b44:	00a045f4 	movhi	r2,33047
81145b48:	10b32704 	addi	r2,r2,-13156
81145b4c:	10800383 	ldbu	r2,14(r2)
81145b50:	10803fcc 	andi	r2,r2,255
81145b54:	2085383a 	mul	r2,r4,r2
81145b58:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81145b5c:	e13ffe0f 	ldh	r4,-8(fp)
81145b60:	00a045f4 	movhi	r2,33047
81145b64:	10b33c04 	addi	r2,r2,-13072
81145b68:	200891ba 	slli	r4,r4,6
81145b6c:	1105883a 	add	r2,r2,r4
81145b70:	10800804 	addi	r2,r2,32
81145b74:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145b78:	1885883a 	add	r2,r3,r2
81145b7c:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81145b80:	e0fffe0f 	ldh	r3,-8(fp)
81145b84:	00a045f4 	movhi	r2,33047
81145b88:	10b33c04 	addi	r2,r2,-13072
81145b8c:	180691ba 	slli	r3,r3,6
81145b90:	10c5883a 	add	r2,r2,r3
81145b94:	10800904 	addi	r2,r2,36
81145b98:	10c00017 	ldw	r3,0(r2)
81145b9c:	00a045f4 	movhi	r2,33047
81145ba0:	10b32704 	addi	r2,r2,-13156
81145ba4:	1080030b 	ldhu	r2,12(r2)
81145ba8:	10bfffcc 	andi	r2,r2,65535
81145bac:	1889203a 	divu	r4,r3,r2
81145bb0:	2085383a 	mul	r2,r4,r2
81145bb4:	1885c83a 	sub	r2,r3,r2
81145bb8:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81145bbc:	e0fffe0f 	ldh	r3,-8(fp)
81145bc0:	00a045f4 	movhi	r2,33047
81145bc4:	10b33c04 	addi	r2,r2,-13072
81145bc8:	180691ba 	slli	r3,r3,6
81145bcc:	10c5883a 	add	r2,r2,r3
81145bd0:	10800904 	addi	r2,r2,36
81145bd4:	10c00017 	ldw	r3,0(r2)
81145bd8:	e13ffe0f 	ldh	r4,-8(fp)
81145bdc:	00a045f4 	movhi	r2,33047
81145be0:	10b33c04 	addi	r2,r2,-13072
81145be4:	200891ba 	slli	r4,r4,6
81145be8:	1105883a 	add	r2,r2,r4
81145bec:	10800604 	addi	r2,r2,24
81145bf0:	10800017 	ldw	r2,0(r2)
81145bf4:	1880672e 	bgeu	r3,r2,81145d94 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81145bf8:	e0fffe0f 	ldh	r3,-8(fp)
81145bfc:	00a045f4 	movhi	r2,33047
81145c00:	10b33c04 	addi	r2,r2,-13072
81145c04:	180691ba 	slli	r3,r3,6
81145c08:	10c5883a 	add	r2,r2,r3
81145c0c:	10800904 	addi	r2,r2,36
81145c10:	10800017 	ldw	r2,0(r2)
81145c14:	1000e126 	beq	r2,zero,81145f9c <alt_up_sd_card_write+0x4e4>
81145c18:	e0bffc0f 	ldh	r2,-16(fp)
81145c1c:	1000df1e 	bne	r2,zero,81145f9c <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81145c20:	e0fffe0f 	ldh	r3,-8(fp)
81145c24:	00a045f4 	movhi	r2,33047
81145c28:	10b33c04 	addi	r2,r2,-13072
81145c2c:	180691ba 	slli	r3,r3,6
81145c30:	10c5883a 	add	r2,r2,r3
81145c34:	10800804 	addi	r2,r2,32
81145c38:	10c00017 	ldw	r3,0(r2)
81145c3c:	00a045f4 	movhi	r2,33047
81145c40:	10b32704 	addi	r2,r2,-13156
81145c44:	10800383 	ldbu	r2,14(r2)
81145c48:	10803fcc 	andi	r2,r2,255
81145c4c:	10bfffc4 	addi	r2,r2,-1
81145c50:	18803d1e 	bne	r3,r2,81145d48 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81145c54:	e0fffe0f 	ldh	r3,-8(fp)
81145c58:	00a045f4 	movhi	r2,33047
81145c5c:	10b33c04 	addi	r2,r2,-13072
81145c60:	180691ba 	slli	r3,r3,6
81145c64:	10c5883a 	add	r2,r2,r3
81145c68:	10800704 	addi	r2,r2,28
81145c6c:	10800017 	ldw	r2,0(r2)
81145c70:	e0fffc84 	addi	r3,fp,-14
81145c74:	180b883a 	mov	r5,r3
81145c78:	1009883a 	mov	r4,r2
81145c7c:	11420c40 	call	811420c4 <get_cluster_flag>
81145c80:	10002f26 	beq	r2,zero,81145d40 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81145c84:	e0bffc8b 	ldhu	r2,-14(fp)
81145c88:	10bfffcc 	andi	r2,r2,65535
81145c8c:	10bffe28 	cmpgeui	r2,r2,65528
81145c90:	1000c21e 	bne	r2,zero,81145f9c <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81145c94:	e13ffe0f 	ldh	r4,-8(fp)
81145c98:	e0bffc8b 	ldhu	r2,-14(fp)
81145c9c:	10ffffcc 	andi	r3,r2,65535
81145ca0:	00a045f4 	movhi	r2,33047
81145ca4:	10b33c04 	addi	r2,r2,-13072
81145ca8:	200891ba 	slli	r4,r4,6
81145cac:	1105883a 	add	r2,r2,r4
81145cb0:	10800704 	addi	r2,r2,28
81145cb4:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81145cb8:	e0fffe0f 	ldh	r3,-8(fp)
81145cbc:	00a045f4 	movhi	r2,33047
81145cc0:	10b33c04 	addi	r2,r2,-13072
81145cc4:	180691ba 	slli	r3,r3,6
81145cc8:	10c5883a 	add	r2,r2,r3
81145ccc:	10800804 	addi	r2,r2,32
81145cd0:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145cd4:	00a045f4 	movhi	r2,33047
81145cd8:	10b32704 	addi	r2,r2,-13156
81145cdc:	10c01417 	ldw	r3,80(r2)
81145ce0:	e13ffe0f 	ldh	r4,-8(fp)
81145ce4:	00a045f4 	movhi	r2,33047
81145ce8:	10b33c04 	addi	r2,r2,-13072
81145cec:	200891ba 	slli	r4,r4,6
81145cf0:	1105883a 	add	r2,r2,r4
81145cf4:	10800704 	addi	r2,r2,28
81145cf8:	10800017 	ldw	r2,0(r2)
81145cfc:	113fff84 	addi	r4,r2,-2
81145d00:	00a045f4 	movhi	r2,33047
81145d04:	10b32704 	addi	r2,r2,-13156
81145d08:	10800383 	ldbu	r2,14(r2)
81145d0c:	10803fcc 	andi	r2,r2,255
81145d10:	2085383a 	mul	r2,r4,r2
81145d14:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81145d18:	e13ffe0f 	ldh	r4,-8(fp)
81145d1c:	00a045f4 	movhi	r2,33047
81145d20:	10b33c04 	addi	r2,r2,-13072
81145d24:	200891ba 	slli	r4,r4,6
81145d28:	1105883a 	add	r2,r2,r4
81145d2c:	10800804 	addi	r2,r2,32
81145d30:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145d34:	1885883a 	add	r2,r3,r2
81145d38:	e0bffb15 	stw	r2,-20(fp)
81145d3c:	00009706 	br	81145f9c <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81145d40:	0005883a 	mov	r2,zero
81145d44:	0000e106 	br	811460cc <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81145d48:	e13ffe0f 	ldh	r4,-8(fp)
81145d4c:	e0fffe0f 	ldh	r3,-8(fp)
81145d50:	00a045f4 	movhi	r2,33047
81145d54:	10b33c04 	addi	r2,r2,-13072
81145d58:	180691ba 	slli	r3,r3,6
81145d5c:	10c5883a 	add	r2,r2,r3
81145d60:	10800804 	addi	r2,r2,32
81145d64:	10800017 	ldw	r2,0(r2)
81145d68:	10c00044 	addi	r3,r2,1
81145d6c:	00a045f4 	movhi	r2,33047
81145d70:	10b33c04 	addi	r2,r2,-13072
81145d74:	200891ba 	slli	r4,r4,6
81145d78:	1105883a 	add	r2,r2,r4
81145d7c:	10800804 	addi	r2,r2,32
81145d80:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81145d84:	e0bffb17 	ldw	r2,-20(fp)
81145d88:	10800044 	addi	r2,r2,1
81145d8c:	e0bffb15 	stw	r2,-20(fp)
81145d90:	00008206 	br	81145f9c <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81145d94:	e0fffe0f 	ldh	r3,-8(fp)
81145d98:	00a045f4 	movhi	r2,33047
81145d9c:	10b33c04 	addi	r2,r2,-13072
81145da0:	180691ba 	slli	r3,r3,6
81145da4:	10c5883a 	add	r2,r2,r3
81145da8:	10800904 	addi	r2,r2,36
81145dac:	10800017 	ldw	r2,0(r2)
81145db0:	10007a26 	beq	r2,zero,81145f9c <alt_up_sd_card_write+0x4e4>
81145db4:	e0bffc0f 	ldh	r2,-16(fp)
81145db8:	1000781e 	bne	r2,zero,81145f9c <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81145dbc:	e0fffe0f 	ldh	r3,-8(fp)
81145dc0:	00a045f4 	movhi	r2,33047
81145dc4:	10b33c04 	addi	r2,r2,-13072
81145dc8:	180691ba 	slli	r3,r3,6
81145dcc:	10c5883a 	add	r2,r2,r3
81145dd0:	10800804 	addi	r2,r2,32
81145dd4:	10c00017 	ldw	r3,0(r2)
81145dd8:	00a045f4 	movhi	r2,33047
81145ddc:	10b32704 	addi	r2,r2,-13156
81145de0:	10800383 	ldbu	r2,14(r2)
81145de4:	10803fcc 	andi	r2,r2,255
81145de8:	10bfffc4 	addi	r2,r2,-1
81145dec:	18803e1e 	bne	r3,r2,81145ee8 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81145df0:	e0bffd04 	addi	r2,fp,-12
81145df4:	1009883a 	mov	r4,r2
81145df8:	11441080 	call	81144108 <find_first_empty_cluster>
81145dfc:	10003826 	beq	r2,zero,81145ee0 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81145e00:	e0fffe0f 	ldh	r3,-8(fp)
81145e04:	00a045f4 	movhi	r2,33047
81145e08:	10b33c04 	addi	r2,r2,-13072
81145e0c:	180691ba 	slli	r3,r3,6
81145e10:	10c5883a 	add	r2,r2,r3
81145e14:	10800704 	addi	r2,r2,28
81145e18:	10800017 	ldw	r2,0(r2)
81145e1c:	e0fffd17 	ldw	r3,-12(fp)
81145e20:	18ffffcc 	andi	r3,r3,65535
81145e24:	18e0001c 	xori	r3,r3,32768
81145e28:	18e00004 	addi	r3,r3,-32768
81145e2c:	01800044 	movi	r6,1
81145e30:	180b883a 	mov	r5,r3
81145e34:	1009883a 	mov	r4,r2
81145e38:	11421800 	call	81142180 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
81145e3c:	e0bffd17 	ldw	r2,-12(fp)
81145e40:	01800044 	movi	r6,1
81145e44:	017fffc4 	movi	r5,-1
81145e48:	1009883a 	mov	r4,r2
81145e4c:	11421800 	call	81142180 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
81145e50:	e0fffe0f 	ldh	r3,-8(fp)
81145e54:	00a045f4 	movhi	r2,33047
81145e58:	10b33c04 	addi	r2,r2,-13072
81145e5c:	180691ba 	slli	r3,r3,6
81145e60:	10c5883a 	add	r2,r2,r3
81145e64:	10800704 	addi	r2,r2,28
81145e68:	10800017 	ldw	r2,0(r2)
81145e6c:	e0fffd17 	ldw	r3,-12(fp)
81145e70:	18ffffcc 	andi	r3,r3,65535
81145e74:	18e0001c 	xori	r3,r3,32768
81145e78:	18e00004 	addi	r3,r3,-32768
81145e7c:	000d883a 	mov	r6,zero
81145e80:	180b883a 	mov	r5,r3
81145e84:	1009883a 	mov	r4,r2
81145e88:	11421800 	call	81142180 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81145e8c:	e0bffd17 	ldw	r2,-12(fp)
81145e90:	000d883a 	mov	r6,zero
81145e94:	017fffc4 	movi	r5,-1
81145e98:	1009883a 	mov	r4,r2
81145e9c:	11421800 	call	81142180 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
81145ea0:	e13ffe0f 	ldh	r4,-8(fp)
81145ea4:	e0fffd17 	ldw	r3,-12(fp)
81145ea8:	00a045f4 	movhi	r2,33047
81145eac:	10b33c04 	addi	r2,r2,-13072
81145eb0:	200891ba 	slli	r4,r4,6
81145eb4:	1105883a 	add	r2,r2,r4
81145eb8:	10800704 	addi	r2,r2,28
81145ebc:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81145ec0:	e0fffe0f 	ldh	r3,-8(fp)
81145ec4:	00a045f4 	movhi	r2,33047
81145ec8:	10b33c04 	addi	r2,r2,-13072
81145ecc:	180691ba 	slli	r3,r3,6
81145ed0:	10c5883a 	add	r2,r2,r3
81145ed4:	10800804 	addi	r2,r2,32
81145ed8:	10000015 	stw	zero,0(r2)
81145edc:	00001506 	br	81145f34 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81145ee0:	0005883a 	mov	r2,zero
81145ee4:	00007906 	br	811460cc <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81145ee8:	e13ffe0f 	ldh	r4,-8(fp)
81145eec:	e0fffe0f 	ldh	r3,-8(fp)
81145ef0:	00a045f4 	movhi	r2,33047
81145ef4:	10b33c04 	addi	r2,r2,-13072
81145ef8:	180691ba 	slli	r3,r3,6
81145efc:	10c5883a 	add	r2,r2,r3
81145f00:	10800904 	addi	r2,r2,36
81145f04:	10c00017 	ldw	r3,0(r2)
81145f08:	00a045f4 	movhi	r2,33047
81145f0c:	10b32704 	addi	r2,r2,-13156
81145f10:	1080030b 	ldhu	r2,12(r2)
81145f14:	10bfffcc 	andi	r2,r2,65535
81145f18:	1887203a 	divu	r3,r3,r2
81145f1c:	00a045f4 	movhi	r2,33047
81145f20:	10b33c04 	addi	r2,r2,-13072
81145f24:	200891ba 	slli	r4,r4,6
81145f28:	1105883a 	add	r2,r2,r4
81145f2c:	10800804 	addi	r2,r2,32
81145f30:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145f34:	00a045f4 	movhi	r2,33047
81145f38:	10b32704 	addi	r2,r2,-13156
81145f3c:	10c01417 	ldw	r3,80(r2)
81145f40:	e13ffe0f 	ldh	r4,-8(fp)
81145f44:	00a045f4 	movhi	r2,33047
81145f48:	10b33c04 	addi	r2,r2,-13072
81145f4c:	200891ba 	slli	r4,r4,6
81145f50:	1105883a 	add	r2,r2,r4
81145f54:	10800704 	addi	r2,r2,28
81145f58:	10800017 	ldw	r2,0(r2)
81145f5c:	113fff84 	addi	r4,r2,-2
81145f60:	00a045f4 	movhi	r2,33047
81145f64:	10b32704 	addi	r2,r2,-13156
81145f68:	10800383 	ldbu	r2,14(r2)
81145f6c:	10803fcc 	andi	r2,r2,255
81145f70:	2085383a 	mul	r2,r4,r2
81145f74:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81145f78:	e13ffe0f 	ldh	r4,-8(fp)
81145f7c:	00a045f4 	movhi	r2,33047
81145f80:	10b33c04 	addi	r2,r2,-13072
81145f84:	200891ba 	slli	r4,r4,6
81145f88:	1105883a 	add	r2,r2,r4
81145f8c:	10800804 	addi	r2,r2,32
81145f90:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81145f94:	1885883a 	add	r2,r3,r2
81145f98:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81145f9c:	d0e0b117 	ldw	r3,-32060(gp)
81145fa0:	e0bffb17 	ldw	r2,-20(fp)
81145fa4:	1885883a 	add	r2,r3,r2
81145fa8:	1007883a 	mov	r3,r2
81145fac:	d0a0b517 	ldw	r2,-32044(gp)
81145fb0:	18800726 	beq	r3,r2,81145fd0 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81145fb4:	d0a0b117 	ldw	r2,-32060(gp)
81145fb8:	100b883a 	mov	r5,r2
81145fbc:	e13ffb17 	ldw	r4,-20(fp)
81145fc0:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81145fc4:	1000021e 	bne	r2,zero,81145fd0 <alt_up_sd_card_write+0x518>
                {
					return false;
81145fc8:	0005883a 	mov	r2,zero
81145fcc:	00003f06 	br	811460cc <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81145fd0:	d0e0b017 	ldw	r3,-32064(gp)
81145fd4:	e0bffc0f 	ldh	r2,-16(fp)
81145fd8:	1885883a 	add	r2,r3,r2
81145fdc:	e0ffff07 	ldb	r3,-4(fp)
81145fe0:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81145fe4:	e13ffe0f 	ldh	r4,-8(fp)
81145fe8:	e0fffe0f 	ldh	r3,-8(fp)
81145fec:	00a045f4 	movhi	r2,33047
81145ff0:	10b33c04 	addi	r2,r2,-13072
81145ff4:	180691ba 	slli	r3,r3,6
81145ff8:	10c5883a 	add	r2,r2,r3
81145ffc:	10800904 	addi	r2,r2,36
81146000:	10800017 	ldw	r2,0(r2)
81146004:	10c00044 	addi	r3,r2,1
81146008:	00a045f4 	movhi	r2,33047
8114600c:	10b33c04 	addi	r2,r2,-13072
81146010:	200891ba 	slli	r4,r4,6
81146014:	1105883a 	add	r2,r2,r4
81146018:	10800904 	addi	r2,r2,36
8114601c:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81146020:	e0fffe0f 	ldh	r3,-8(fp)
81146024:	00a045f4 	movhi	r2,33047
81146028:	10b33c04 	addi	r2,r2,-13072
8114602c:	180691ba 	slli	r3,r3,6
81146030:	10c5883a 	add	r2,r2,r3
81146034:	10800904 	addi	r2,r2,36
81146038:	10c00017 	ldw	r3,0(r2)
8114603c:	e13ffe0f 	ldh	r4,-8(fp)
81146040:	00a045f4 	movhi	r2,33047
81146044:	10b33c04 	addi	r2,r2,-13072
81146048:	200891ba 	slli	r4,r4,6
8114604c:	1105883a 	add	r2,r2,r4
81146050:	10800604 	addi	r2,r2,24
81146054:	10800017 	ldw	r2,0(r2)
81146058:	18801736 	bltu	r3,r2,811460b8 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
8114605c:	e13ffe0f 	ldh	r4,-8(fp)
81146060:	e0fffe0f 	ldh	r3,-8(fp)
81146064:	00a045f4 	movhi	r2,33047
81146068:	10b33c04 	addi	r2,r2,-13072
8114606c:	180691ba 	slli	r3,r3,6
81146070:	10c5883a 	add	r2,r2,r3
81146074:	10800604 	addi	r2,r2,24
81146078:	10800017 	ldw	r2,0(r2)
8114607c:	10c00044 	addi	r3,r2,1
81146080:	00a045f4 	movhi	r2,33047
81146084:	10b33c04 	addi	r2,r2,-13072
81146088:	200891ba 	slli	r4,r4,6
8114608c:	1105883a 	add	r2,r2,r4
81146090:	10800604 	addi	r2,r2,24
81146094:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81146098:	e0fffe0f 	ldh	r3,-8(fp)
8114609c:	00a045f4 	movhi	r2,33047
811460a0:	10b33c04 	addi	r2,r2,-13072
811460a4:	180691ba 	slli	r3,r3,6
811460a8:	10c5883a 	add	r2,r2,r3
811460ac:	10800e04 	addi	r2,r2,56
811460b0:	00c00044 	movi	r3,1
811460b4:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
811460b8:	00800044 	movi	r2,1
811460bc:	d0a0b415 	stw	r2,-32048(gp)
			result = true;
811460c0:	00800044 	movi	r2,1
811460c4:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
811460c8:	e0bffa17 	ldw	r2,-24(fp)
}
811460cc:	e037883a 	mov	sp,fp
811460d0:	dfc00117 	ldw	ra,4(sp)
811460d4:	df000017 	ldw	fp,0(sp)
811460d8:	dec00204 	addi	sp,sp,8
811460dc:	f800283a 	ret

811460e0 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
811460e0:	defffb04 	addi	sp,sp,-20
811460e4:	de00012e 	bgeu	sp,et,811460ec <alt_up_sd_card_fclose+0xc>
811460e8:	003b68fa 	trap	3
811460ec:	dfc00415 	stw	ra,16(sp)
811460f0:	df000315 	stw	fp,12(sp)
811460f4:	df000304 	addi	fp,sp,12
811460f8:	2005883a 	mov	r2,r4
811460fc:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81146100:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81146104:	1144cbc0 	call	81144cbc <alt_up_sd_card_is_Present>
81146108:	10006026 	beq	r2,zero,8114628c <alt_up_sd_card_fclose+0x1ac>
8114610c:	d0a0aa17 	ldw	r2,-32088(gp)
81146110:	10005e26 	beq	r2,zero,8114628c <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81146114:	e0ffff0f 	ldh	r3,-4(fp)
81146118:	00a045f4 	movhi	r2,33047
8114611c:	10b33c04 	addi	r2,r2,-13072
81146120:	180691ba 	slli	r3,r3,6
81146124:	10c5883a 	add	r2,r2,r3
81146128:	10800f04 	addi	r2,r2,60
8114612c:	10800017 	ldw	r2,0(r2)
81146130:	10005626 	beq	r2,zero,8114628c <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81146134:	e0ffff0f 	ldh	r3,-4(fp)
81146138:	00a045f4 	movhi	r2,33047
8114613c:	10b33c04 	addi	r2,r2,-13072
81146140:	180691ba 	slli	r3,r3,6
81146144:	10c5883a 	add	r2,r2,r3
81146148:	10800e04 	addi	r2,r2,56
8114614c:	10800017 	ldw	r2,0(r2)
81146150:	10004526 	beq	r2,zero,81146268 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
81146154:	e0ffff0f 	ldh	r3,-4(fp)
81146158:	00a045f4 	movhi	r2,33047
8114615c:	10b33c04 	addi	r2,r2,-13072
81146160:	180691ba 	slli	r3,r3,6
81146164:	10c5883a 	add	r2,r2,r3
81146168:	10800b04 	addi	r2,r2,44
8114616c:	10800017 	ldw	r2,0(r2)
81146170:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81146174:	e0ffff0f 	ldh	r3,-4(fp)
81146178:	00a045f4 	movhi	r2,33047
8114617c:	10b33c04 	addi	r2,r2,-13072
81146180:	180691ba 	slli	r3,r3,6
81146184:	10c5883a 	add	r2,r2,r3
81146188:	10800a04 	addi	r2,r2,40
8114618c:	10800017 	ldw	r2,0(r2)
81146190:	1000071e 	bne	r2,zero,811461b0 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81146194:	00a045f4 	movhi	r2,33047
81146198:	10b32704 	addi	r2,r2,-13156
8114619c:	10801317 	ldw	r2,76(r2)
811461a0:	e0fffe17 	ldw	r3,-8(fp)
811461a4:	1885883a 	add	r2,r3,r2
811461a8:	e0bffe15 	stw	r2,-8(fp)
811461ac:	00001406 	br	81146200 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
811461b0:	00a045f4 	movhi	r2,33047
811461b4:	10b32704 	addi	r2,r2,-13156
811461b8:	10c01417 	ldw	r3,80(r2)
811461bc:	e0bffe17 	ldw	r2,-8(fp)
811461c0:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
811461c4:	e13fff0f 	ldh	r4,-4(fp)
811461c8:	00a045f4 	movhi	r2,33047
811461cc:	10b33c04 	addi	r2,r2,-13072
811461d0:	200891ba 	slli	r4,r4,6
811461d4:	1105883a 	add	r2,r2,r4
811461d8:	10800a04 	addi	r2,r2,40
811461dc:	10800017 	ldw	r2,0(r2)
811461e0:	113fff84 	addi	r4,r2,-2
811461e4:	00a045f4 	movhi	r2,33047
811461e8:	10b32704 	addi	r2,r2,-13156
811461ec:	10800383 	ldbu	r2,14(r2)
811461f0:	10803fcc 	andi	r2,r2,255
811461f4:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
811461f8:	1885883a 	add	r2,r3,r2
811461fc:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81146200:	e0bffe17 	ldw	r2,-8(fp)
81146204:	d0e0b117 	ldw	r3,-32060(gp)
81146208:	180b883a 	mov	r5,r3
8114620c:	1009883a 	mov	r4,r2
81146210:	1141fe40 	call	81141fe4 <Read_Sector_Data>
81146214:	10001426 	beq	r2,zero,81146268 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81146218:	e0ffff0f 	ldh	r3,-4(fp)
8114621c:	00a045f4 	movhi	r2,33047
81146220:	10b33c04 	addi	r2,r2,-13072
81146224:	180691ba 	slli	r3,r3,6
81146228:	10c5883a 	add	r2,r2,r3
8114622c:	10800c04 	addi	r2,r2,48
81146230:	1080000b 	ldhu	r2,0(r2)
81146234:	113fffcc 	andi	r4,r2,65535
81146238:	2120001c 	xori	r4,r4,32768
8114623c:	21200004 	addi	r4,r4,-32768
81146240:	e0bfff0f 	ldh	r2,-4(fp)
81146244:	100691ba 	slli	r3,r2,6
81146248:	00a045f4 	movhi	r2,33047
8114624c:	10b33c04 	addi	r2,r2,-13072
81146250:	1885883a 	add	r2,r3,r2
81146254:	100b883a 	mov	r5,r2
81146258:	11426980 	call	81142698 <Write_File_Record_At_Offset>
8114625c:	10000226 	beq	r2,zero,81146268 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
81146260:	1141f900 	call	81141f90 <Save_Modified_Sector>
81146264:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81146268:	e0ffff0f 	ldh	r3,-4(fp)
8114626c:	00a045f4 	movhi	r2,33047
81146270:	10b33c04 	addi	r2,r2,-13072
81146274:	180691ba 	slli	r3,r3,6
81146278:	10c5883a 	add	r2,r2,r3
8114627c:	10800f04 	addi	r2,r2,60
81146280:	10000015 	stw	zero,0(r2)
			result = true;
81146284:	00800044 	movi	r2,1
81146288:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
8114628c:	e0bffd17 	ldw	r2,-12(fp)
}
81146290:	e037883a 	mov	sp,fp
81146294:	dfc00117 	ldw	ra,4(sp)
81146298:	df000017 	ldw	fp,0(sp)
8114629c:	dec00204 	addi	sp,sp,8
811462a0:	f800283a 	ret

811462a4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
811462a4:	defffa04 	addi	sp,sp,-24
811462a8:	de00012e 	bgeu	sp,et,811462b0 <altera_avalon_jtag_uart_read_fd+0xc>
811462ac:	003b68fa 	trap	3
811462b0:	dfc00515 	stw	ra,20(sp)
811462b4:	df000415 	stw	fp,16(sp)
811462b8:	df000404 	addi	fp,sp,16
811462bc:	e13ffd15 	stw	r4,-12(fp)
811462c0:	e17ffe15 	stw	r5,-8(fp)
811462c4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811462c8:	e0bffd17 	ldw	r2,-12(fp)
811462cc:	10800017 	ldw	r2,0(r2)
811462d0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
811462d4:	e0bffc17 	ldw	r2,-16(fp)
811462d8:	10c00a04 	addi	r3,r2,40
811462dc:	e0bffd17 	ldw	r2,-12(fp)
811462e0:	10800217 	ldw	r2,8(r2)
811462e4:	100f883a 	mov	r7,r2
811462e8:	e1bfff17 	ldw	r6,-4(fp)
811462ec:	e17ffe17 	ldw	r5,-8(fp)
811462f0:	1809883a 	mov	r4,r3
811462f4:	1146b280 	call	81146b28 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
811462f8:	e037883a 	mov	sp,fp
811462fc:	dfc00117 	ldw	ra,4(sp)
81146300:	df000017 	ldw	fp,0(sp)
81146304:	dec00204 	addi	sp,sp,8
81146308:	f800283a 	ret

8114630c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8114630c:	defffa04 	addi	sp,sp,-24
81146310:	de00012e 	bgeu	sp,et,81146318 <altera_avalon_jtag_uart_write_fd+0xc>
81146314:	003b68fa 	trap	3
81146318:	dfc00515 	stw	ra,20(sp)
8114631c:	df000415 	stw	fp,16(sp)
81146320:	df000404 	addi	fp,sp,16
81146324:	e13ffd15 	stw	r4,-12(fp)
81146328:	e17ffe15 	stw	r5,-8(fp)
8114632c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81146330:	e0bffd17 	ldw	r2,-12(fp)
81146334:	10800017 	ldw	r2,0(r2)
81146338:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
8114633c:	e0bffc17 	ldw	r2,-16(fp)
81146340:	10c00a04 	addi	r3,r2,40
81146344:	e0bffd17 	ldw	r2,-12(fp)
81146348:	10800217 	ldw	r2,8(r2)
8114634c:	100f883a 	mov	r7,r2
81146350:	e1bfff17 	ldw	r6,-4(fp)
81146354:	e17ffe17 	ldw	r5,-8(fp)
81146358:	1809883a 	mov	r4,r3
8114635c:	1146dec0 	call	81146dec <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
81146360:	e037883a 	mov	sp,fp
81146364:	dfc00117 	ldw	ra,4(sp)
81146368:	df000017 	ldw	fp,0(sp)
8114636c:	dec00204 	addi	sp,sp,8
81146370:	f800283a 	ret

81146374 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81146374:	defffc04 	addi	sp,sp,-16
81146378:	de00012e 	bgeu	sp,et,81146380 <altera_avalon_jtag_uart_close_fd+0xc>
8114637c:	003b68fa 	trap	3
81146380:	dfc00315 	stw	ra,12(sp)
81146384:	df000215 	stw	fp,8(sp)
81146388:	df000204 	addi	fp,sp,8
8114638c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81146390:	e0bfff17 	ldw	r2,-4(fp)
81146394:	10800017 	ldw	r2,0(r2)
81146398:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
8114639c:	e0bffe17 	ldw	r2,-8(fp)
811463a0:	10c00a04 	addi	r3,r2,40
811463a4:	e0bfff17 	ldw	r2,-4(fp)
811463a8:	10800217 	ldw	r2,8(r2)
811463ac:	100b883a 	mov	r5,r2
811463b0:	1809883a 	mov	r4,r3
811463b4:	11469c00 	call	811469c0 <altera_avalon_jtag_uart_close>
}
811463b8:	e037883a 	mov	sp,fp
811463bc:	dfc00117 	ldw	ra,4(sp)
811463c0:	df000017 	ldw	fp,0(sp)
811463c4:	dec00204 	addi	sp,sp,8
811463c8:	f800283a 	ret

811463cc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
811463cc:	defffa04 	addi	sp,sp,-24
811463d0:	de00012e 	bgeu	sp,et,811463d8 <altera_avalon_jtag_uart_ioctl_fd+0xc>
811463d4:	003b68fa 	trap	3
811463d8:	dfc00515 	stw	ra,20(sp)
811463dc:	df000415 	stw	fp,16(sp)
811463e0:	df000404 	addi	fp,sp,16
811463e4:	e13ffd15 	stw	r4,-12(fp)
811463e8:	e17ffe15 	stw	r5,-8(fp)
811463ec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
811463f0:	e0bffd17 	ldw	r2,-12(fp)
811463f4:	10800017 	ldw	r2,0(r2)
811463f8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
811463fc:	e0bffc17 	ldw	r2,-16(fp)
81146400:	10800a04 	addi	r2,r2,40
81146404:	e1bfff17 	ldw	r6,-4(fp)
81146408:	e17ffe17 	ldw	r5,-8(fp)
8114640c:	1009883a 	mov	r4,r2
81146410:	1146a300 	call	81146a30 <altera_avalon_jtag_uart_ioctl>
}
81146414:	e037883a 	mov	sp,fp
81146418:	dfc00117 	ldw	ra,4(sp)
8114641c:	df000017 	ldw	fp,0(sp)
81146420:	dec00204 	addi	sp,sp,8
81146424:	f800283a 	ret

81146428 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81146428:	deffef04 	addi	sp,sp,-68
8114642c:	de00012e 	bgeu	sp,et,81146434 <altera_avalon_jtag_uart_init+0xc>
81146430:	003b68fa 	trap	3
81146434:	dfc01015 	stw	ra,64(sp)
81146438:	df000f15 	stw	fp,60(sp)
8114643c:	dc400e15 	stw	r17,56(sp)
81146440:	dc000d15 	stw	r16,52(sp)
81146444:	df000f04 	addi	fp,sp,60
81146448:	e13ff715 	stw	r4,-36(fp)
8114644c:	e17ff815 	stw	r5,-32(fp)
81146450:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
81146454:	e0bff717 	ldw	r2,-36(fp)
81146458:	10800c04 	addi	r2,r2,48
8114645c:	e0bff215 	stw	r2,-56(fp)
81146460:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81146464:	e0bff60b 	ldhu	r2,-40(fp)
81146468:	e0fff684 	addi	r3,fp,-38
8114646c:	180b883a 	mov	r5,r3
81146470:	1009883a 	mov	r4,r2
81146474:	113a5f80 	call	8113a5f8 <OSFlagCreate>
81146478:	1007883a 	mov	r3,r2
8114647c:	e0bff217 	ldw	r2,-56(fp)
81146480:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81146484:	e0bff717 	ldw	r2,-36(fp)
81146488:	10800a04 	addi	r2,r2,40
8114648c:	e0bff315 	stw	r2,-52(fp)
81146490:	00800044 	movi	r2,1
81146494:	e0bff58d 	sth	r2,-42(fp)
81146498:	e0bff58b 	ldhu	r2,-42(fp)
8114649c:	1009883a 	mov	r4,r2
811464a0:	113e5540 	call	8113e554 <OSSemCreate>
811464a4:	1007883a 	mov	r3,r2
811464a8:	e0bff317 	ldw	r2,-52(fp)
811464ac:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
811464b0:	e0bff717 	ldw	r2,-36(fp)
811464b4:	10800b04 	addi	r2,r2,44
811464b8:	e0bff415 	stw	r2,-48(fp)
811464bc:	00800044 	movi	r2,1
811464c0:	e0bff50d 	sth	r2,-44(fp)
811464c4:	e0bff50b 	ldhu	r2,-44(fp)
811464c8:	1009883a 	mov	r4,r2
811464cc:	113e5540 	call	8113e554 <OSSemCreate>
811464d0:	1007883a 	mov	r3,r2
811464d4:	e0bff417 	ldw	r2,-48(fp)
811464d8:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811464dc:	e0bff717 	ldw	r2,-36(fp)
811464e0:	00c00044 	movi	r3,1
811464e4:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
811464e8:	e0bff717 	ldw	r2,-36(fp)
811464ec:	10800017 	ldw	r2,0(r2)
811464f0:	10800104 	addi	r2,r2,4
811464f4:	1007883a 	mov	r3,r2
811464f8:	e0bff717 	ldw	r2,-36(fp)
811464fc:	10800817 	ldw	r2,32(r2)
81146500:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81146504:	e0bff817 	ldw	r2,-32(fp)
81146508:	e0fff917 	ldw	r3,-28(fp)
8114650c:	d8000015 	stw	zero,0(sp)
81146510:	e1fff717 	ldw	r7,-36(fp)
81146514:	01a04534 	movhi	r6,33044
81146518:	31997e04 	addi	r6,r6,26104
8114651c:	180b883a 	mov	r5,r3
81146520:	1009883a 	mov	r4,r2
81146524:	114a3400 	call	8114a340 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81146528:	e0bff717 	ldw	r2,-36(fp)
8114652c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81146530:	e0bff717 	ldw	r2,-36(fp)
81146534:	10800204 	addi	r2,r2,8
81146538:	d0e08817 	ldw	r3,-32224(gp)
8114653c:	e1fff717 	ldw	r7,-36(fp)
81146540:	01a04534 	movhi	r6,33044
81146544:	319a2d04 	addi	r6,r6,26804
81146548:	180b883a 	mov	r5,r3
8114654c:	1009883a 	mov	r4,r2
81146550:	1149e900 	call	81149e90 <alt_alarm_start>
81146554:	1000040e 	bge	r2,zero,81146568 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
81146558:	e0fff717 	ldw	r3,-36(fp)
8114655c:	00a00034 	movhi	r2,32768
81146560:	10bfffc4 	addi	r2,r2,-1
81146564:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81146568:	d0a08183 	ldbu	r2,-32250(gp)
8114656c:	10803fcc 	andi	r2,r2,255
81146570:	10800058 	cmpnei	r2,r2,1
81146574:	10000f1e 	bne	r2,zero,811465b4 <altera_avalon_jtag_uart_init+0x18c>
81146578:	d0e08817 	ldw	r3,-32224(gp)
8114657c:	00b33374 	movhi	r2,52429
81146580:	10b33344 	addi	r2,r2,-13107
81146584:	1888383a 	mulxuu	r4,r3,r2
81146588:	1885383a 	mul	r2,r3,r2
8114658c:	1021883a 	mov	r16,r2
81146590:	2023883a 	mov	r17,r4
81146594:	8804d0fa 	srli	r2,r17,3
81146598:	e1fff717 	ldw	r7,-36(fp)
8114659c:	01a044f4 	movhi	r6,33043
811465a0:	319b4a04 	addi	r6,r6,27944
811465a4:	100b883a 	mov	r5,r2
811465a8:	012045b4 	movhi	r4,33046
811465ac:	211afb04 	addi	r4,r4,27628
811465b0:	1149e900 	call	81149e90 <alt_alarm_start>
811465b4:	d0a08203 	ldbu	r2,-32248(gp)
811465b8:	10803fcc 	andi	r2,r2,255
811465bc:	10800058 	cmpnei	r2,r2,1
811465c0:	1000051e 	bne	r2,zero,811465d8 <altera_avalon_jtag_uart_init+0x1b0>
811465c4:	e0bff717 	ldw	r2,-36(fp)
811465c8:	10800017 	ldw	r2,0(r2)
811465cc:	100b883a 	mov	r5,r2
811465d0:	e13ff717 	ldw	r4,-36(fp)
811465d4:	1136ec00 	call	81136ec0 <alt_log_jtag_uart_startup_info>
}
811465d8:	0001883a 	nop
811465dc:	e6fffe04 	addi	sp,fp,-8
811465e0:	dfc00317 	ldw	ra,12(sp)
811465e4:	df000217 	ldw	fp,8(sp)
811465e8:	dc400117 	ldw	r17,4(sp)
811465ec:	dc000017 	ldw	r16,0(sp)
811465f0:	dec00404 	addi	sp,sp,16
811465f4:	f800283a 	ret

811465f8 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
811465f8:	defff204 	addi	sp,sp,-56
811465fc:	de00012e 	bgeu	sp,et,81146604 <altera_avalon_jtag_uart_irq+0xc>
81146600:	003b68fa 	trap	3
81146604:	dfc00d15 	stw	ra,52(sp)
81146608:	df000c15 	stw	fp,48(sp)
8114660c:	df000c04 	addi	fp,sp,48
81146610:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81146614:	e0bfff17 	ldw	r2,-4(fp)
81146618:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
8114661c:	e0bff617 	ldw	r2,-40(fp)
81146620:	10800017 	ldw	r2,0(r2)
81146624:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81146628:	e0bff717 	ldw	r2,-36(fp)
8114662c:	e17ff617 	ldw	r5,-40(fp)
81146630:	1009883a 	mov	r4,r2
81146634:	1136f140 	call	81136f14 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81146638:	e0bff717 	ldw	r2,-36(fp)
8114663c:	10800104 	addi	r2,r2,4
81146640:	10800037 	ldwio	r2,0(r2)
81146644:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81146648:	e0bff817 	ldw	r2,-32(fp)
8114664c:	1080c00c 	andi	r2,r2,768
81146650:	10009126 	beq	r2,zero,81146898 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81146654:	e0bff817 	ldw	r2,-32(fp)
81146658:	1080400c 	andi	r2,r2,256
8114665c:	10004726 	beq	r2,zero,8114677c <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
81146660:	00800074 	movhi	r2,1
81146664:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146668:	e0bff617 	ldw	r2,-40(fp)
8114666c:	10800d17 	ldw	r2,52(r2)
81146670:	10800044 	addi	r2,r2,1
81146674:	1081ffcc 	andi	r2,r2,2047
81146678:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
8114667c:	e0bff617 	ldw	r2,-40(fp)
81146680:	10c00e17 	ldw	r3,56(r2)
81146684:	e0bff917 	ldw	r2,-28(fp)
81146688:	18802726 	beq	r3,r2,81146728 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
8114668c:	e0bff717 	ldw	r2,-36(fp)
81146690:	10800037 	ldwio	r2,0(r2)
81146694:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81146698:	e0bff417 	ldw	r2,-48(fp)
8114669c:	10a0000c 	andi	r2,r2,32768
811466a0:	10002326 	beq	r2,zero,81146730 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
811466a4:	e0bff617 	ldw	r2,-40(fp)
811466a8:	10800d17 	ldw	r2,52(r2)
811466ac:	e0fff417 	ldw	r3,-48(fp)
811466b0:	1809883a 	mov	r4,r3
811466b4:	e0fff617 	ldw	r3,-40(fp)
811466b8:	1885883a 	add	r2,r3,r2
811466bc:	10801104 	addi	r2,r2,68
811466c0:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811466c4:	e0bff617 	ldw	r2,-40(fp)
811466c8:	10800d17 	ldw	r2,52(r2)
811466cc:	10800044 	addi	r2,r2,1
811466d0:	10c1ffcc 	andi	r3,r2,2047
811466d4:	e0bff617 	ldw	r2,-40(fp)
811466d8:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
811466dc:	e0bff617 	ldw	r2,-40(fp)
811466e0:	10800c17 	ldw	r2,48(r2)
811466e4:	e0bffb15 	stw	r2,-20(fp)
811466e8:	00800044 	movi	r2,1
811466ec:	e0bffc0d 	sth	r2,-16(fp)
811466f0:	00800044 	movi	r2,1
811466f4:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811466f8:	d0a09103 	ldbu	r2,-32188(gp)
811466fc:	10803fcc 	andi	r2,r2,255
81146700:	103fd926 	beq	r2,zero,81146668 <__reset+0xfb126668>
  {
    OSFlagPost (group, flags, opt, &err);
81146704:	e0bffc0b 	ldhu	r2,-16(fp)
81146708:	e0fffc83 	ldbu	r3,-14(fp)
8114670c:	e13ffdc4 	addi	r4,fp,-9
81146710:	200f883a 	mov	r7,r4
81146714:	180d883a 	mov	r6,r3
81146718:	100b883a 	mov	r5,r2
8114671c:	e13ffb17 	ldw	r4,-20(fp)
81146720:	113b2040 	call	8113b204 <OSFlagPost>
      }
81146724:	003fd006 	br	81146668 <__reset+0xfb126668>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81146728:	0001883a 	nop
8114672c:	00000106 	br	81146734 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
81146730:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81146734:	e0bff417 	ldw	r2,-48(fp)
81146738:	10bfffec 	andhi	r2,r2,65535
8114673c:	10000f26 	beq	r2,zero,8114677c <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81146740:	e0bff617 	ldw	r2,-40(fp)
81146744:	10c00817 	ldw	r3,32(r2)
81146748:	00bfff84 	movi	r2,-2
8114674c:	1886703a 	and	r3,r3,r2
81146750:	e0bff617 	ldw	r2,-40(fp)
81146754:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
81146758:	e0bff717 	ldw	r2,-36(fp)
8114675c:	10800104 	addi	r2,r2,4
81146760:	1007883a 	mov	r3,r2
81146764:	e0bff617 	ldw	r2,-40(fp)
81146768:	10800817 	ldw	r2,32(r2)
8114676c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81146770:	e0bff717 	ldw	r2,-36(fp)
81146774:	10800104 	addi	r2,r2,4
81146778:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
8114677c:	e0bff817 	ldw	r2,-32(fp)
81146780:	1080800c 	andi	r2,r2,512
81146784:	103fac26 	beq	r2,zero,81146638 <__reset+0xfb126638>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81146788:	e0bff817 	ldw	r2,-32(fp)
8114678c:	1004d43a 	srli	r2,r2,16
81146790:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81146794:	00002606 	br	81146830 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81146798:	e0bff717 	ldw	r2,-36(fp)
8114679c:	e0fff617 	ldw	r3,-40(fp)
811467a0:	18c01017 	ldw	r3,64(r3)
811467a4:	e13ff617 	ldw	r4,-40(fp)
811467a8:	20c7883a 	add	r3,r4,r3
811467ac:	18c21104 	addi	r3,r3,2116
811467b0:	18c00003 	ldbu	r3,0(r3)
811467b4:	18c03fcc 	andi	r3,r3,255
811467b8:	18c0201c 	xori	r3,r3,128
811467bc:	18ffe004 	addi	r3,r3,-128
811467c0:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811467c4:	e0bff617 	ldw	r2,-40(fp)
811467c8:	10801017 	ldw	r2,64(r2)
811467cc:	10800044 	addi	r2,r2,1
811467d0:	10c1ffcc 	andi	r3,r2,2047
811467d4:	e0bff617 	ldw	r2,-40(fp)
811467d8:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
811467dc:	e0bff617 	ldw	r2,-40(fp)
811467e0:	10800c17 	ldw	r2,48(r2)
811467e4:	e0bffa15 	stw	r2,-24(fp)
811467e8:	00800084 	movi	r2,2
811467ec:	e0bffd0d 	sth	r2,-12(fp)
811467f0:	00800044 	movi	r2,1
811467f4:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811467f8:	d0a09103 	ldbu	r2,-32188(gp)
811467fc:	10803fcc 	andi	r2,r2,255
81146800:	10000826 	beq	r2,zero,81146824 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81146804:	e0bffd0b 	ldhu	r2,-12(fp)
81146808:	e0fffd83 	ldbu	r3,-10(fp)
8114680c:	e13ffe04 	addi	r4,fp,-8
81146810:	200f883a 	mov	r7,r4
81146814:	180d883a 	mov	r6,r3
81146818:	100b883a 	mov	r5,r2
8114681c:	e13ffa17 	ldw	r4,-24(fp)
81146820:	113b2040 	call	8113b204 <OSFlagPost>

        space--;
81146824:	e0bff517 	ldw	r2,-44(fp)
81146828:	10bfffc4 	addi	r2,r2,-1
8114682c:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81146830:	e0bff517 	ldw	r2,-44(fp)
81146834:	10000526 	beq	r2,zero,8114684c <altera_avalon_jtag_uart_irq+0x254>
81146838:	e0bff617 	ldw	r2,-40(fp)
8114683c:	10c01017 	ldw	r3,64(r2)
81146840:	e0bff617 	ldw	r2,-40(fp)
81146844:	10800f17 	ldw	r2,60(r2)
81146848:	18bfd31e 	bne	r3,r2,81146798 <__reset+0xfb126798>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
8114684c:	e0bff517 	ldw	r2,-44(fp)
81146850:	103f7926 	beq	r2,zero,81146638 <__reset+0xfb126638>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81146854:	e0bff617 	ldw	r2,-40(fp)
81146858:	10c00817 	ldw	r3,32(r2)
8114685c:	00bfff44 	movi	r2,-3
81146860:	1886703a 	and	r3,r3,r2
81146864:	e0bff617 	ldw	r2,-40(fp)
81146868:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8114686c:	e0bff617 	ldw	r2,-40(fp)
81146870:	10800017 	ldw	r2,0(r2)
81146874:	10800104 	addi	r2,r2,4
81146878:	1007883a 	mov	r3,r2
8114687c:	e0bff617 	ldw	r2,-40(fp)
81146880:	10800817 	ldw	r2,32(r2)
81146884:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81146888:	e0bff717 	ldw	r2,-36(fp)
8114688c:	10800104 	addi	r2,r2,4
81146890:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81146894:	003f6806 	br	81146638 <__reset+0xfb126638>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81146898:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
8114689c:	0001883a 	nop
811468a0:	e037883a 	mov	sp,fp
811468a4:	dfc00117 	ldw	ra,4(sp)
811468a8:	df000017 	ldw	fp,0(sp)
811468ac:	dec00204 	addi	sp,sp,8
811468b0:	f800283a 	ret

811468b4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
811468b4:	defff904 	addi	sp,sp,-28
811468b8:	de00012e 	bgeu	sp,et,811468c0 <altera_avalon_jtag_uart_timeout+0xc>
811468bc:	003b68fa 	trap	3
811468c0:	dfc00615 	stw	ra,24(sp)
811468c4:	df000515 	stw	fp,20(sp)
811468c8:	df000504 	addi	fp,sp,20
811468cc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
811468d0:	e0bfff17 	ldw	r2,-4(fp)
811468d4:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
811468d8:	e0bffb17 	ldw	r2,-20(fp)
811468dc:	10800017 	ldw	r2,0(r2)
811468e0:	10800104 	addi	r2,r2,4
811468e4:	10800037 	ldwio	r2,0(r2)
811468e8:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
811468ec:	e0bffc17 	ldw	r2,-16(fp)
811468f0:	1081000c 	andi	r2,r2,1024
811468f4:	10000b26 	beq	r2,zero,81146924 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
811468f8:	e0bffb17 	ldw	r2,-20(fp)
811468fc:	10800017 	ldw	r2,0(r2)
81146900:	10800104 	addi	r2,r2,4
81146904:	1007883a 	mov	r3,r2
81146908:	e0bffb17 	ldw	r2,-20(fp)
8114690c:	10800817 	ldw	r2,32(r2)
81146910:	10810014 	ori	r2,r2,1024
81146914:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81146918:	e0bffb17 	ldw	r2,-20(fp)
8114691c:	10000915 	stw	zero,36(r2)
81146920:	00002106 	br	811469a8 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81146924:	e0bffb17 	ldw	r2,-20(fp)
81146928:	10c00917 	ldw	r3,36(r2)
8114692c:	00a00034 	movhi	r2,32768
81146930:	10bfff04 	addi	r2,r2,-4
81146934:	10c01c36 	bltu	r2,r3,811469a8 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81146938:	e0bffb17 	ldw	r2,-20(fp)
8114693c:	10800917 	ldw	r2,36(r2)
81146940:	10c00044 	addi	r3,r2,1
81146944:	e0bffb17 	ldw	r2,-20(fp)
81146948:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
8114694c:	e0bffb17 	ldw	r2,-20(fp)
81146950:	10c00917 	ldw	r3,36(r2)
81146954:	e0bffb17 	ldw	r2,-20(fp)
81146958:	10800117 	ldw	r2,4(r2)
8114695c:	18801236 	bltu	r3,r2,811469a8 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81146960:	e0bffb17 	ldw	r2,-20(fp)
81146964:	10800c17 	ldw	r2,48(r2)
81146968:	e0bffd15 	stw	r2,-12(fp)
8114696c:	00800104 	movi	r2,4
81146970:	e0bffe0d 	sth	r2,-8(fp)
81146974:	00800044 	movi	r2,1
81146978:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114697c:	d0a09103 	ldbu	r2,-32188(gp)
81146980:	10803fcc 	andi	r2,r2,255
81146984:	10000826 	beq	r2,zero,811469a8 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81146988:	e0bffe0b 	ldhu	r2,-8(fp)
8114698c:	e0fffe83 	ldbu	r3,-6(fp)
81146990:	e13ffec4 	addi	r4,fp,-5
81146994:	200f883a 	mov	r7,r4
81146998:	180d883a 	mov	r6,r3
8114699c:	100b883a 	mov	r5,r2
811469a0:	e13ffd17 	ldw	r4,-12(fp)
811469a4:	113b2040 	call	8113b204 <OSFlagPost>
811469a8:	d0a08817 	ldw	r2,-32224(gp)
    }
  }

  return alt_ticks_per_second();
}
811469ac:	e037883a 	mov	sp,fp
811469b0:	dfc00117 	ldw	ra,4(sp)
811469b4:	df000017 	ldw	fp,0(sp)
811469b8:	dec00204 	addi	sp,sp,8
811469bc:	f800283a 	ret

811469c0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
811469c0:	defffd04 	addi	sp,sp,-12
811469c4:	de00012e 	bgeu	sp,et,811469cc <altera_avalon_jtag_uart_close+0xc>
811469c8:	003b68fa 	trap	3
811469cc:	df000215 	stw	fp,8(sp)
811469d0:	df000204 	addi	fp,sp,8
811469d4:	e13ffe15 	stw	r4,-8(fp)
811469d8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
811469dc:	00000506 	br	811469f4 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
811469e0:	e0bfff17 	ldw	r2,-4(fp)
811469e4:	1090000c 	andi	r2,r2,16384
811469e8:	10000226 	beq	r2,zero,811469f4 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
811469ec:	00bffd44 	movi	r2,-11
811469f0:	00000b06 	br	81146a20 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
811469f4:	e0bffe17 	ldw	r2,-8(fp)
811469f8:	10c01017 	ldw	r3,64(r2)
811469fc:	e0bffe17 	ldw	r2,-8(fp)
81146a00:	10800f17 	ldw	r2,60(r2)
81146a04:	18800526 	beq	r3,r2,81146a1c <altera_avalon_jtag_uart_close+0x5c>
81146a08:	e0bffe17 	ldw	r2,-8(fp)
81146a0c:	10c00917 	ldw	r3,36(r2)
81146a10:	e0bffe17 	ldw	r2,-8(fp)
81146a14:	10800117 	ldw	r2,4(r2)
81146a18:	18bff136 	bltu	r3,r2,811469e0 <__reset+0xfb1269e0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81146a1c:	0005883a 	mov	r2,zero
}
81146a20:	e037883a 	mov	sp,fp
81146a24:	df000017 	ldw	fp,0(sp)
81146a28:	dec00104 	addi	sp,sp,4
81146a2c:	f800283a 	ret

81146a30 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81146a30:	defffa04 	addi	sp,sp,-24
81146a34:	de00012e 	bgeu	sp,et,81146a3c <altera_avalon_jtag_uart_ioctl+0xc>
81146a38:	003b68fa 	trap	3
81146a3c:	df000515 	stw	fp,20(sp)
81146a40:	df000504 	addi	fp,sp,20
81146a44:	e13ffd15 	stw	r4,-12(fp)
81146a48:	e17ffe15 	stw	r5,-8(fp)
81146a4c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81146a50:	00bff9c4 	movi	r2,-25
81146a54:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81146a58:	e0bffe17 	ldw	r2,-8(fp)
81146a5c:	10da8060 	cmpeqi	r3,r2,27137
81146a60:	1800031e 	bne	r3,zero,81146a70 <altera_avalon_jtag_uart_ioctl+0x40>
81146a64:	109a80a0 	cmpeqi	r2,r2,27138
81146a68:	1000181e 	bne	r2,zero,81146acc <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81146a6c:	00002906 	br	81146b14 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81146a70:	e0bffd17 	ldw	r2,-12(fp)
81146a74:	10c00117 	ldw	r3,4(r2)
81146a78:	00a00034 	movhi	r2,32768
81146a7c:	10bfffc4 	addi	r2,r2,-1
81146a80:	18802126 	beq	r3,r2,81146b08 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81146a84:	e0bfff17 	ldw	r2,-4(fp)
81146a88:	10800017 	ldw	r2,0(r2)
81146a8c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81146a90:	e0bffc17 	ldw	r2,-16(fp)
81146a94:	10800090 	cmplti	r2,r2,2
81146a98:	1000061e 	bne	r2,zero,81146ab4 <altera_avalon_jtag_uart_ioctl+0x84>
81146a9c:	e0fffc17 	ldw	r3,-16(fp)
81146aa0:	00a00034 	movhi	r2,32768
81146aa4:	10bfffc4 	addi	r2,r2,-1
81146aa8:	18800226 	beq	r3,r2,81146ab4 <altera_avalon_jtag_uart_ioctl+0x84>
81146aac:	e0bffc17 	ldw	r2,-16(fp)
81146ab0:	00000206 	br	81146abc <altera_avalon_jtag_uart_ioctl+0x8c>
81146ab4:	00a00034 	movhi	r2,32768
81146ab8:	10bfff84 	addi	r2,r2,-2
81146abc:	e0fffd17 	ldw	r3,-12(fp)
81146ac0:	18800115 	stw	r2,4(r3)
      rc = 0;
81146ac4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81146ac8:	00000f06 	br	81146b08 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81146acc:	e0bffd17 	ldw	r2,-12(fp)
81146ad0:	10c00117 	ldw	r3,4(r2)
81146ad4:	00a00034 	movhi	r2,32768
81146ad8:	10bfffc4 	addi	r2,r2,-1
81146adc:	18800c26 	beq	r3,r2,81146b10 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81146ae0:	e0bffd17 	ldw	r2,-12(fp)
81146ae4:	10c00917 	ldw	r3,36(r2)
81146ae8:	e0bffd17 	ldw	r2,-12(fp)
81146aec:	10800117 	ldw	r2,4(r2)
81146af0:	1885803a 	cmpltu	r2,r3,r2
81146af4:	10c03fcc 	andi	r3,r2,255
81146af8:	e0bfff17 	ldw	r2,-4(fp)
81146afc:	10c00015 	stw	r3,0(r2)
      rc = 0;
81146b00:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81146b04:	00000206 	br	81146b10 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81146b08:	0001883a 	nop
81146b0c:	00000106 	br	81146b14 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81146b10:	0001883a 	nop

  default:
    break;
  }

  return rc;
81146b14:	e0bffb17 	ldw	r2,-20(fp)
}
81146b18:	e037883a 	mov	sp,fp
81146b1c:	df000017 	ldw	fp,0(sp)
81146b20:	dec00104 	addi	sp,sp,4
81146b24:	f800283a 	ret

81146b28 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81146b28:	deffed04 	addi	sp,sp,-76
81146b2c:	de00012e 	bgeu	sp,et,81146b34 <altera_avalon_jtag_uart_read+0xc>
81146b30:	003b68fa 	trap	3
81146b34:	dfc01215 	stw	ra,72(sp)
81146b38:	df001115 	stw	fp,68(sp)
81146b3c:	df001104 	addi	fp,sp,68
81146b40:	e13ffc15 	stw	r4,-16(fp)
81146b44:	e17ffd15 	stw	r5,-12(fp)
81146b48:	e1bffe15 	stw	r6,-8(fp)
81146b4c:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81146b50:	e0bffd17 	ldw	r2,-12(fp)
81146b54:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81146b58:	e0bffc17 	ldw	r2,-16(fp)
81146b5c:	10800a17 	ldw	r2,40(r2)
81146b60:	e0bff815 	stw	r2,-32(fp)
81146b64:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81146b68:	e0bff90b 	ldhu	r2,-28(fp)
81146b6c:	e0fffb04 	addi	r3,fp,-20
81146b70:	180d883a 	mov	r6,r3
81146b74:	100b883a 	mov	r5,r2
81146b78:	e13ff817 	ldw	r4,-32(fp)
81146b7c:	113e87c0 	call	8113e87c <OSSemPend>

  while (space > 0)
81146b80:	00006106 	br	81146d08 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81146b84:	e0bffc17 	ldw	r2,-16(fp)
81146b88:	10800d17 	ldw	r2,52(r2)
81146b8c:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81146b90:	e0bffc17 	ldw	r2,-16(fp)
81146b94:	10800e17 	ldw	r2,56(r2)
81146b98:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81146b9c:	e0fff317 	ldw	r3,-52(fp)
81146ba0:	e0bff417 	ldw	r2,-48(fp)
81146ba4:	18800536 	bltu	r3,r2,81146bbc <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81146ba8:	e0fff317 	ldw	r3,-52(fp)
81146bac:	e0bff417 	ldw	r2,-48(fp)
81146bb0:	1885c83a 	sub	r2,r3,r2
81146bb4:	e0bff115 	stw	r2,-60(fp)
81146bb8:	00000406 	br	81146bcc <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81146bbc:	00c20004 	movi	r3,2048
81146bc0:	e0bff417 	ldw	r2,-48(fp)
81146bc4:	1885c83a 	sub	r2,r3,r2
81146bc8:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81146bcc:	e0bff117 	ldw	r2,-60(fp)
81146bd0:	10001e26 	beq	r2,zero,81146c4c <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81146bd4:	e0fffe17 	ldw	r3,-8(fp)
81146bd8:	e0bff117 	ldw	r2,-60(fp)
81146bdc:	1880022e 	bgeu	r3,r2,81146be8 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81146be0:	e0bffe17 	ldw	r2,-8(fp)
81146be4:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81146be8:	e0bffc17 	ldw	r2,-16(fp)
81146bec:	10c01104 	addi	r3,r2,68
81146bf0:	e0bff417 	ldw	r2,-48(fp)
81146bf4:	1885883a 	add	r2,r3,r2
81146bf8:	e1bff117 	ldw	r6,-60(fp)
81146bfc:	100b883a 	mov	r5,r2
81146c00:	e13ff017 	ldw	r4,-64(fp)
81146c04:	11223f40 	call	811223f4 <memcpy>
      ptr   += n;
81146c08:	e0fff017 	ldw	r3,-64(fp)
81146c0c:	e0bff117 	ldw	r2,-60(fp)
81146c10:	1885883a 	add	r2,r3,r2
81146c14:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81146c18:	e0fffe17 	ldw	r3,-8(fp)
81146c1c:	e0bff117 	ldw	r2,-60(fp)
81146c20:	1885c83a 	sub	r2,r3,r2
81146c24:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146c28:	e0fff417 	ldw	r3,-48(fp)
81146c2c:	e0bff117 	ldw	r2,-60(fp)
81146c30:	1885883a 	add	r2,r3,r2
81146c34:	10c1ffcc 	andi	r3,r2,2047
81146c38:	e0bffc17 	ldw	r2,-16(fp)
81146c3c:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81146c40:	e0bffe17 	ldw	r2,-8(fp)
81146c44:	00bfcf16 	blt	zero,r2,81146b84 <__reset+0xfb126b84>
81146c48:	00000106 	br	81146c50 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81146c4c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81146c50:	e0fff017 	ldw	r3,-64(fp)
81146c54:	e0bffd17 	ldw	r2,-12(fp)
81146c58:	18802e1e 	bne	r3,r2,81146d14 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81146c5c:	e0bfff17 	ldw	r2,-4(fp)
81146c60:	1090000c 	andi	r2,r2,16384
81146c64:	10002d1e 	bne	r2,zero,81146d1c <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81146c68:	d0a09103 	ldbu	r2,-32188(gp)
81146c6c:	10803fcc 	andi	r2,r2,255
81146c70:	10800058 	cmpnei	r2,r2,1
81146c74:	1000161e 	bne	r2,zero,81146cd0 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81146c78:	e0bffc17 	ldw	r2,-16(fp)
81146c7c:	10800c17 	ldw	r2,48(r2)
81146c80:	e0bff215 	stw	r2,-56(fp)
81146c84:	00800144 	movi	r2,5
81146c88:	e0bff98d 	sth	r2,-26(fp)
81146c8c:	00bfe0c4 	movi	r2,-125
81146c90:	e0bffa05 	stb	r2,-24(fp)
81146c94:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81146c98:	d0a09103 	ldbu	r2,-32188(gp)
81146c9c:	10803fcc 	andi	r2,r2,255
81146ca0:	10001526 	beq	r2,zero,81146cf8 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81146ca4:	e0fff98b 	ldhu	r3,-26(fp)
81146ca8:	e13ffa03 	ldbu	r4,-24(fp)
81146cac:	e17ffa8b 	ldhu	r5,-22(fp)
81146cb0:	e0bffb44 	addi	r2,fp,-19
81146cb4:	d8800015 	stw	r2,0(sp)
81146cb8:	280f883a 	mov	r7,r5
81146cbc:	200d883a 	mov	r6,r4
81146cc0:	180b883a 	mov	r5,r3
81146cc4:	e13ff217 	ldw	r4,-56(fp)
81146cc8:	113abdc0 	call	8113abdc <OSFlagPend>
81146ccc:	00000a06 	br	81146cf8 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81146cd0:	0001883a 	nop
81146cd4:	e0bffc17 	ldw	r2,-16(fp)
81146cd8:	10c00d17 	ldw	r3,52(r2)
81146cdc:	e0bff317 	ldw	r2,-52(fp)
81146ce0:	1880051e 	bne	r3,r2,81146cf8 <altera_avalon_jtag_uart_read+0x1d0>
81146ce4:	e0bffc17 	ldw	r2,-16(fp)
81146ce8:	10c00917 	ldw	r3,36(r2)
81146cec:	e0bffc17 	ldw	r2,-16(fp)
81146cf0:	10800117 	ldw	r2,4(r2)
81146cf4:	18bff736 	bltu	r3,r2,81146cd4 <__reset+0xfb126cd4>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81146cf8:	e0bffc17 	ldw	r2,-16(fp)
81146cfc:	10c00d17 	ldw	r3,52(r2)
81146d00:	e0bff317 	ldw	r2,-52(fp)
81146d04:	18800726 	beq	r3,r2,81146d24 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81146d08:	e0bffe17 	ldw	r2,-8(fp)
81146d0c:	00bf9d16 	blt	zero,r2,81146b84 <__reset+0xfb126b84>
81146d10:	00000506 	br	81146d28 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81146d14:	0001883a 	nop
81146d18:	00000306 	br	81146d28 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81146d1c:	0001883a 	nop
81146d20:	00000106 	br	81146d28 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81146d24:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81146d28:	e0bffc17 	ldw	r2,-16(fp)
81146d2c:	10800a17 	ldw	r2,40(r2)
81146d30:	1009883a 	mov	r4,r2
81146d34:	113ec040 	call	8113ec04 <OSSemPost>

  if (ptr != buffer)
81146d38:	e0fff017 	ldw	r3,-64(fp)
81146d3c:	e0bffd17 	ldw	r2,-12(fp)
81146d40:	18801826 	beq	r3,r2,81146da4 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146d44:	0005303a 	rdctl	r2,status
81146d48:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146d4c:	e0fff717 	ldw	r3,-36(fp)
81146d50:	00bfff84 	movi	r2,-2
81146d54:	1884703a 	and	r2,r3,r2
81146d58:	1001703a 	wrctl	status,r2
  
  return context;
81146d5c:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81146d60:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81146d64:	e0bffc17 	ldw	r2,-16(fp)
81146d68:	10800817 	ldw	r2,32(r2)
81146d6c:	10c00054 	ori	r3,r2,1
81146d70:	e0bffc17 	ldw	r2,-16(fp)
81146d74:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81146d78:	e0bffc17 	ldw	r2,-16(fp)
81146d7c:	10800017 	ldw	r2,0(r2)
81146d80:	10800104 	addi	r2,r2,4
81146d84:	1007883a 	mov	r3,r2
81146d88:	e0bffc17 	ldw	r2,-16(fp)
81146d8c:	10800817 	ldw	r2,32(r2)
81146d90:	18800035 	stwio	r2,0(r3)
81146d94:	e0bff617 	ldw	r2,-40(fp)
81146d98:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146d9c:	e0bff517 	ldw	r2,-44(fp)
81146da0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81146da4:	e0fff017 	ldw	r3,-64(fp)
81146da8:	e0bffd17 	ldw	r2,-12(fp)
81146dac:	18800426 	beq	r3,r2,81146dc0 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81146db0:	e0fff017 	ldw	r3,-64(fp)
81146db4:	e0bffd17 	ldw	r2,-12(fp)
81146db8:	1885c83a 	sub	r2,r3,r2
81146dbc:	00000606 	br	81146dd8 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81146dc0:	e0bfff17 	ldw	r2,-4(fp)
81146dc4:	1090000c 	andi	r2,r2,16384
81146dc8:	10000226 	beq	r2,zero,81146dd4 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81146dcc:	00bffd44 	movi	r2,-11
81146dd0:	00000106 	br	81146dd8 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81146dd4:	00bffec4 	movi	r2,-5
}
81146dd8:	e037883a 	mov	sp,fp
81146ddc:	dfc00117 	ldw	ra,4(sp)
81146de0:	df000017 	ldw	fp,0(sp)
81146de4:	dec00204 	addi	sp,sp,8
81146de8:	f800283a 	ret

81146dec <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81146dec:	deffed04 	addi	sp,sp,-76
81146df0:	de00012e 	bgeu	sp,et,81146df8 <altera_avalon_jtag_uart_write+0xc>
81146df4:	003b68fa 	trap	3
81146df8:	dfc01215 	stw	ra,72(sp)
81146dfc:	df001115 	stw	fp,68(sp)
81146e00:	df001104 	addi	fp,sp,68
81146e04:	e13ffc15 	stw	r4,-16(fp)
81146e08:	e17ffd15 	stw	r5,-12(fp)
81146e0c:	e1bffe15 	stw	r6,-8(fp)
81146e10:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81146e14:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81146e18:	e0bffd17 	ldw	r2,-12(fp)
81146e1c:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81146e20:	e0bffc17 	ldw	r2,-16(fp)
81146e24:	10800b17 	ldw	r2,44(r2)
81146e28:	e0bff815 	stw	r2,-32(fp)
81146e2c:	e03ff90d 	sth	zero,-28(fp)
81146e30:	e0bff90b 	ldhu	r2,-28(fp)
81146e34:	e0fffb44 	addi	r3,fp,-19
81146e38:	180d883a 	mov	r6,r3
81146e3c:	100b883a 	mov	r5,r2
81146e40:	e13ff817 	ldw	r4,-32(fp)
81146e44:	113e87c0 	call	8113e87c <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81146e48:	00003706 	br	81146f28 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81146e4c:	e0bffc17 	ldw	r2,-16(fp)
81146e50:	10800f17 	ldw	r2,60(r2)
81146e54:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81146e58:	e0bffc17 	ldw	r2,-16(fp)
81146e5c:	10801017 	ldw	r2,64(r2)
81146e60:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81146e64:	e0fff417 	ldw	r3,-48(fp)
81146e68:	e0bff017 	ldw	r2,-64(fp)
81146e6c:	1880062e 	bgeu	r3,r2,81146e88 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81146e70:	e0fff017 	ldw	r3,-64(fp)
81146e74:	e0bff417 	ldw	r2,-48(fp)
81146e78:	1885c83a 	sub	r2,r3,r2
81146e7c:	10bfffc4 	addi	r2,r2,-1
81146e80:	e0bff115 	stw	r2,-60(fp)
81146e84:	00000b06 	br	81146eb4 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81146e88:	e0bff017 	ldw	r2,-64(fp)
81146e8c:	10000526 	beq	r2,zero,81146ea4 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81146e90:	00c20004 	movi	r3,2048
81146e94:	e0bff417 	ldw	r2,-48(fp)
81146e98:	1885c83a 	sub	r2,r3,r2
81146e9c:	e0bff115 	stw	r2,-60(fp)
81146ea0:	00000406 	br	81146eb4 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81146ea4:	00c1ffc4 	movi	r3,2047
81146ea8:	e0bff417 	ldw	r2,-48(fp)
81146eac:	1885c83a 	sub	r2,r3,r2
81146eb0:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81146eb4:	e0bff117 	ldw	r2,-60(fp)
81146eb8:	10001e26 	beq	r2,zero,81146f34 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81146ebc:	e0fffe17 	ldw	r3,-8(fp)
81146ec0:	e0bff117 	ldw	r2,-60(fp)
81146ec4:	1880022e 	bgeu	r3,r2,81146ed0 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81146ec8:	e0bffe17 	ldw	r2,-8(fp)
81146ecc:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81146ed0:	e0bffc17 	ldw	r2,-16(fp)
81146ed4:	10c21104 	addi	r3,r2,2116
81146ed8:	e0bff417 	ldw	r2,-48(fp)
81146edc:	1885883a 	add	r2,r3,r2
81146ee0:	e1bff117 	ldw	r6,-60(fp)
81146ee4:	e17ffd17 	ldw	r5,-12(fp)
81146ee8:	1009883a 	mov	r4,r2
81146eec:	11223f40 	call	811223f4 <memcpy>
      ptr   += n;
81146ef0:	e0fffd17 	ldw	r3,-12(fp)
81146ef4:	e0bff117 	ldw	r2,-60(fp)
81146ef8:	1885883a 	add	r2,r3,r2
81146efc:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81146f00:	e0fffe17 	ldw	r3,-8(fp)
81146f04:	e0bff117 	ldw	r2,-60(fp)
81146f08:	1885c83a 	sub	r2,r3,r2
81146f0c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146f10:	e0fff417 	ldw	r3,-48(fp)
81146f14:	e0bff117 	ldw	r2,-60(fp)
81146f18:	1885883a 	add	r2,r3,r2
81146f1c:	10c1ffcc 	andi	r3,r2,2047
81146f20:	e0bffc17 	ldw	r2,-16(fp)
81146f24:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81146f28:	e0bffe17 	ldw	r2,-8(fp)
81146f2c:	00bfc716 	blt	zero,r2,81146e4c <__reset+0xfb126e4c>
81146f30:	00000106 	br	81146f38 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
81146f34:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146f38:	0005303a 	rdctl	r2,status
81146f3c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146f40:	e0fff717 	ldw	r3,-36(fp)
81146f44:	00bfff84 	movi	r2,-2
81146f48:	1884703a 	and	r2,r3,r2
81146f4c:	1001703a 	wrctl	status,r2
  
  return context;
81146f50:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
81146f54:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81146f58:	e0bffc17 	ldw	r2,-16(fp)
81146f5c:	10800817 	ldw	r2,32(r2)
81146f60:	10c00094 	ori	r3,r2,2
81146f64:	e0bffc17 	ldw	r2,-16(fp)
81146f68:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81146f6c:	e0bffc17 	ldw	r2,-16(fp)
81146f70:	10800017 	ldw	r2,0(r2)
81146f74:	10800104 	addi	r2,r2,4
81146f78:	1007883a 	mov	r3,r2
81146f7c:	e0bffc17 	ldw	r2,-16(fp)
81146f80:	10800817 	ldw	r2,32(r2)
81146f84:	18800035 	stwio	r2,0(r3)
81146f88:	e0bff617 	ldw	r2,-40(fp)
81146f8c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146f90:	e0bff317 	ldw	r2,-52(fp)
81146f94:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81146f98:	e0bffe17 	ldw	r2,-8(fp)
81146f9c:	00802a0e 	bge	zero,r2,81147048 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
81146fa0:	e0bfff17 	ldw	r2,-4(fp)
81146fa4:	1090000c 	andi	r2,r2,16384
81146fa8:	10002a1e 	bne	r2,zero,81147054 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81146fac:	d0a09103 	ldbu	r2,-32188(gp)
81146fb0:	10803fcc 	andi	r2,r2,255
81146fb4:	10800058 	cmpnei	r2,r2,1
81146fb8:	1000161e 	bne	r2,zero,81147014 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81146fbc:	e0bffc17 	ldw	r2,-16(fp)
81146fc0:	10800c17 	ldw	r2,48(r2)
81146fc4:	e0bff515 	stw	r2,-44(fp)
81146fc8:	00800184 	movi	r2,6
81146fcc:	e0bff98d 	sth	r2,-26(fp)
81146fd0:	00bfe0c4 	movi	r2,-125
81146fd4:	e0bffa05 	stb	r2,-24(fp)
81146fd8:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81146fdc:	d0a09103 	ldbu	r2,-32188(gp)
81146fe0:	10803fcc 	andi	r2,r2,255
81146fe4:	10001526 	beq	r2,zero,8114703c <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81146fe8:	e0fff98b 	ldhu	r3,-26(fp)
81146fec:	e13ffa03 	ldbu	r4,-24(fp)
81146ff0:	e17ffa8b 	ldhu	r5,-22(fp)
81146ff4:	e0bffb04 	addi	r2,fp,-20
81146ff8:	d8800015 	stw	r2,0(sp)
81146ffc:	280f883a 	mov	r7,r5
81147000:	200d883a 	mov	r6,r4
81147004:	180b883a 	mov	r5,r3
81147008:	e13ff517 	ldw	r4,-44(fp)
8114700c:	113abdc0 	call	8113abdc <OSFlagPend>
81147010:	00000a06 	br	8114703c <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81147014:	0001883a 	nop
81147018:	e0bffc17 	ldw	r2,-16(fp)
8114701c:	10c01017 	ldw	r3,64(r2)
81147020:	e0bff017 	ldw	r2,-64(fp)
81147024:	1880051e 	bne	r3,r2,8114703c <altera_avalon_jtag_uart_write+0x250>
81147028:	e0bffc17 	ldw	r2,-16(fp)
8114702c:	10c00917 	ldw	r3,36(r2)
81147030:	e0bffc17 	ldw	r2,-16(fp)
81147034:	10800117 	ldw	r2,4(r2)
81147038:	18bff736 	bltu	r3,r2,81147018 <__reset+0xfb127018>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
8114703c:	e0bffc17 	ldw	r2,-16(fp)
81147040:	10800917 	ldw	r2,36(r2)
81147044:	1000051e 	bne	r2,zero,8114705c <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81147048:	e0bffe17 	ldw	r2,-8(fp)
8114704c:	00bfb616 	blt	zero,r2,81146f28 <__reset+0xfb126f28>
81147050:	00000306 	br	81147060 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
81147054:	0001883a 	nop
81147058:	00000106 	br	81147060 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
8114705c:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
81147060:	e0bffc17 	ldw	r2,-16(fp)
81147064:	10800b17 	ldw	r2,44(r2)
81147068:	1009883a 	mov	r4,r2
8114706c:	113ec040 	call	8113ec04 <OSSemPost>

  if (ptr != start)
81147070:	e0fffd17 	ldw	r3,-12(fp)
81147074:	e0bff217 	ldw	r2,-56(fp)
81147078:	18800426 	beq	r3,r2,8114708c <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
8114707c:	e0fffd17 	ldw	r3,-12(fp)
81147080:	e0bff217 	ldw	r2,-56(fp)
81147084:	1885c83a 	sub	r2,r3,r2
81147088:	00000606 	br	811470a4 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
8114708c:	e0bfff17 	ldw	r2,-4(fp)
81147090:	1090000c 	andi	r2,r2,16384
81147094:	10000226 	beq	r2,zero,811470a0 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81147098:	00bffd44 	movi	r2,-11
8114709c:	00000106 	br	811470a4 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
811470a0:	00bffec4 	movi	r2,-5
}
811470a4:	e037883a 	mov	sp,fp
811470a8:	dfc00117 	ldw	ra,4(sp)
811470ac:	df000017 	ldw	fp,0(sp)
811470b0:	dec00204 	addi	sp,sp,8
811470b4:	f800283a 	ret

811470b8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
811470b8:	defffa04 	addi	sp,sp,-24
811470bc:	de00012e 	bgeu	sp,et,811470c4 <alt_avalon_timer_sc_irq+0xc>
811470c0:	003b68fa 	trap	3
811470c4:	dfc00515 	stw	ra,20(sp)
811470c8:	df000415 	stw	fp,16(sp)
811470cc:	df000404 	addi	fp,sp,16
811470d0:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
811470d4:	0007883a 	mov	r3,zero
811470d8:	e0bfff17 	ldw	r2,-4(fp)
811470dc:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
811470e0:	e0bfff17 	ldw	r2,-4(fp)
811470e4:	10800104 	addi	r2,r2,4
811470e8:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
811470ec:	11370b80 	call	811370b8 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811470f0:	0005303a 	rdctl	r2,status
811470f4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811470f8:	e0fffd17 	ldw	r3,-12(fp)
811470fc:	00bfff84 	movi	r2,-2
81147100:	1884703a 	and	r2,r3,r2
81147104:	1001703a 	wrctl	status,r2
  
  return context;
81147108:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
8114710c:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81147110:	11379680 	call	81137968 <alt_tick>
81147114:	e0bffc17 	ldw	r2,-16(fp)
81147118:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114711c:	e0bffe17 	ldw	r2,-8(fp)
81147120:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
81147124:	0001883a 	nop
81147128:	e037883a 	mov	sp,fp
8114712c:	dfc00117 	ldw	ra,4(sp)
81147130:	df000017 	ldw	fp,0(sp)
81147134:	dec00204 	addi	sp,sp,8
81147138:	f800283a 	ret

8114713c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
8114713c:	defff804 	addi	sp,sp,-32
81147140:	de00012e 	bgeu	sp,et,81147148 <alt_avalon_timer_sc_init+0xc>
81147144:	003b68fa 	trap	3
81147148:	dfc00715 	stw	ra,28(sp)
8114714c:	df000615 	stw	fp,24(sp)
81147150:	df000604 	addi	fp,sp,24
81147154:	e13ffc15 	stw	r4,-16(fp)
81147158:	e17ffd15 	stw	r5,-12(fp)
8114715c:	e1bffe15 	stw	r6,-8(fp)
81147160:	e1ffff15 	stw	r7,-4(fp)
81147164:	e0bfff17 	ldw	r2,-4(fp)
81147168:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
8114716c:	d0a08817 	ldw	r2,-32224(gp)
81147170:	1000021e 	bne	r2,zero,8114717c <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81147174:	e0bffb17 	ldw	r2,-20(fp)
81147178:	d0a08815 	stw	r2,-32224(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
8114717c:	e0bffc17 	ldw	r2,-16(fp)
81147180:	10800104 	addi	r2,r2,4
81147184:	00c001c4 	movi	r3,7
81147188:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
8114718c:	d8000015 	stw	zero,0(sp)
81147190:	e1fffc17 	ldw	r7,-16(fp)
81147194:	01a04534 	movhi	r6,33044
81147198:	319c2e04 	addi	r6,r6,28856
8114719c:	e17ffe17 	ldw	r5,-8(fp)
811471a0:	e13ffd17 	ldw	r4,-12(fp)
811471a4:	114a3400 	call	8114a340 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
811471a8:	0001883a 	nop
811471ac:	e037883a 	mov	sp,fp
811471b0:	dfc00117 	ldw	ra,4(sp)
811471b4:	df000017 	ldw	fp,0(sp)
811471b8:	dec00204 	addi	sp,sp,8
811471bc:	f800283a 	ret

811471c0 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
811471c0:	defffa04 	addi	sp,sp,-24
811471c4:	de00012e 	bgeu	sp,et,811471cc <altera_avalon_uart_read_fd+0xc>
811471c8:	003b68fa 	trap	3
811471cc:	dfc00515 	stw	ra,20(sp)
811471d0:	df000415 	stw	fp,16(sp)
811471d4:	df000404 	addi	fp,sp,16
811471d8:	e13ffd15 	stw	r4,-12(fp)
811471dc:	e17ffe15 	stw	r5,-8(fp)
811471e0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811471e4:	e0bffd17 	ldw	r2,-12(fp)
811471e8:	10800017 	ldw	r2,0(r2)
811471ec:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
811471f0:	e0bffc17 	ldw	r2,-16(fp)
811471f4:	10c00a04 	addi	r3,r2,40
811471f8:	e0bffd17 	ldw	r2,-12(fp)
811471fc:	10800217 	ldw	r2,8(r2)
81147200:	100f883a 	mov	r7,r2
81147204:	e1bfff17 	ldw	r6,-4(fp)
81147208:	e17ffe17 	ldw	r5,-8(fp)
8114720c:	1809883a 	mov	r4,r3
81147210:	11478800 	call	81147880 <altera_avalon_uart_read>
      fd->fd_flags);
}
81147214:	e037883a 	mov	sp,fp
81147218:	dfc00117 	ldw	ra,4(sp)
8114721c:	df000017 	ldw	fp,0(sp)
81147220:	dec00204 	addi	sp,sp,8
81147224:	f800283a 	ret

81147228 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81147228:	defffa04 	addi	sp,sp,-24
8114722c:	de00012e 	bgeu	sp,et,81147234 <altera_avalon_uart_write_fd+0xc>
81147230:	003b68fa 	trap	3
81147234:	dfc00515 	stw	ra,20(sp)
81147238:	df000415 	stw	fp,16(sp)
8114723c:	df000404 	addi	fp,sp,16
81147240:	e13ffd15 	stw	r4,-12(fp)
81147244:	e17ffe15 	stw	r5,-8(fp)
81147248:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114724c:	e0bffd17 	ldw	r2,-12(fp)
81147250:	10800017 	ldw	r2,0(r2)
81147254:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
81147258:	e0bffc17 	ldw	r2,-16(fp)
8114725c:	10c00a04 	addi	r3,r2,40
81147260:	e0bffd17 	ldw	r2,-12(fp)
81147264:	10800217 	ldw	r2,8(r2)
81147268:	100f883a 	mov	r7,r2
8114726c:	e1bfff17 	ldw	r6,-4(fp)
81147270:	e17ffe17 	ldw	r5,-8(fp)
81147274:	1809883a 	mov	r4,r3
81147278:	1147b340 	call	81147b34 <altera_avalon_uart_write>
      fd->fd_flags);
}
8114727c:	e037883a 	mov	sp,fp
81147280:	dfc00117 	ldw	ra,4(sp)
81147284:	df000017 	ldw	fp,0(sp)
81147288:	dec00204 	addi	sp,sp,8
8114728c:	f800283a 	ret

81147290 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81147290:	defffc04 	addi	sp,sp,-16
81147294:	de00012e 	bgeu	sp,et,8114729c <altera_avalon_uart_close_fd+0xc>
81147298:	003b68fa 	trap	3
8114729c:	dfc00315 	stw	ra,12(sp)
811472a0:	df000215 	stw	fp,8(sp)
811472a4:	df000204 	addi	fp,sp,8
811472a8:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811472ac:	e0bfff17 	ldw	r2,-4(fp)
811472b0:	10800017 	ldw	r2,0(r2)
811472b4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
811472b8:	e0bffe17 	ldw	r2,-8(fp)
811472bc:	10c00a04 	addi	r3,r2,40
811472c0:	e0bfff17 	ldw	r2,-4(fp)
811472c4:	10800217 	ldw	r2,8(r2)
811472c8:	100b883a 	mov	r5,r2
811472cc:	1809883a 	mov	r4,r3
811472d0:	11477e00 	call	811477e0 <altera_avalon_uart_close>
}
811472d4:	e037883a 	mov	sp,fp
811472d8:	dfc00117 	ldw	ra,4(sp)
811472dc:	df000017 	ldw	fp,0(sp)
811472e0:	dec00204 	addi	sp,sp,8
811472e4:	f800283a 	ret

811472e8 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
811472e8:	defff304 	addi	sp,sp,-52
811472ec:	de00012e 	bgeu	sp,et,811472f4 <altera_avalon_uart_init+0xc>
811472f0:	003b68fa 	trap	3
811472f4:	dfc00c15 	stw	ra,48(sp)
811472f8:	df000b15 	stw	fp,44(sp)
811472fc:	df000b04 	addi	fp,sp,44
81147300:	e13ffd15 	stw	r4,-12(fp)
81147304:	e17ffe15 	stw	r5,-8(fp)
81147308:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
8114730c:	e0bffd17 	ldw	r2,-12(fp)
81147310:	10800017 	ldw	r2,0(r2)
81147314:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81147318:	e0bffd17 	ldw	r2,-12(fp)
8114731c:	10800704 	addi	r2,r2,28
81147320:	e0bffa15 	stw	r2,-24(fp)
81147324:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81147328:	e0bffb0b 	ldhu	r2,-20(fp)
8114732c:	e0fffc84 	addi	r3,fp,-14
81147330:	180b883a 	mov	r5,r3
81147334:	1009883a 	mov	r4,r2
81147338:	113a5f80 	call	8113a5f8 <OSFlagCreate>
8114733c:	1007883a 	mov	r3,r2
81147340:	e0bffa17 	ldw	r2,-24(fp)
81147344:	10c00015 	stw	r3,0(r2)
  return err;
81147348:	e0bffc83 	ldbu	r2,-14(fp)
8114734c:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81147350:	1000241e 	bne	r2,zero,811473e4 <altera_avalon_uart_init+0xfc>
81147354:	e0bffd17 	ldw	r2,-12(fp)
81147358:	10800804 	addi	r2,r2,32
8114735c:	e0bff715 	stw	r2,-36(fp)
81147360:	00800044 	movi	r2,1
81147364:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81147368:	e0bffb8b 	ldhu	r2,-18(fp)
8114736c:	1009883a 	mov	r4,r2
81147370:	113e5540 	call	8113e554 <OSSemCreate>
81147374:	1007883a 	mov	r3,r2
81147378:	e0bff717 	ldw	r2,-36(fp)
8114737c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81147380:	e0bff717 	ldw	r2,-36(fp)
81147384:	10800017 	ldw	r2,0(r2)
81147388:	10000226 	beq	r2,zero,81147394 <altera_avalon_uart_init+0xac>
8114738c:	0005883a 	mov	r2,zero
81147390:	00000106 	br	81147398 <altera_avalon_uart_init+0xb0>
81147394:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81147398:	1000121e 	bne	r2,zero,811473e4 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
8114739c:	e0bffd17 	ldw	r2,-12(fp)
811473a0:	10800904 	addi	r2,r2,36
811473a4:	e0bff815 	stw	r2,-32(fp)
811473a8:	00800044 	movi	r2,1
811473ac:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811473b0:	e0bffc0b 	ldhu	r2,-16(fp)
811473b4:	1009883a 	mov	r4,r2
811473b8:	113e5540 	call	8113e554 <OSSemCreate>
811473bc:	1007883a 	mov	r3,r2
811473c0:	e0bff817 	ldw	r2,-32(fp)
811473c4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811473c8:	e0bff817 	ldw	r2,-32(fp)
811473cc:	10800017 	ldw	r2,0(r2)
811473d0:	10000226 	beq	r2,zero,811473dc <altera_avalon_uart_init+0xf4>
811473d4:	0005883a 	mov	r2,zero
811473d8:	00000106 	br	811473e0 <altera_avalon_uart_init+0xf8>
811473dc:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811473e0:	10000226 	beq	r2,zero,811473ec <altera_avalon_uart_init+0x104>
811473e4:	00800044 	movi	r2,1
811473e8:	00000106 	br	811473f0 <altera_avalon_uart_init+0x108>
811473ec:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811473f0:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
811473f4:	e0bff917 	ldw	r2,-28(fp)
811473f8:	10000f1e 	bne	r2,zero,81147438 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
811473fc:	e0bffd17 	ldw	r2,-12(fp)
81147400:	00c32004 	movi	r3,3200
81147404:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81147408:	e0bff617 	ldw	r2,-40(fp)
8114740c:	10800304 	addi	r2,r2,12
81147410:	e0fffd17 	ldw	r3,-12(fp)
81147414:	18c00117 	ldw	r3,4(r3)
81147418:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
8114741c:	d8000015 	stw	zero,0(sp)
81147420:	e1fffd17 	ldw	r7,-12(fp)
81147424:	01a04534 	movhi	r6,33044
81147428:	319d1404 	addi	r6,r6,29776
8114742c:	e17fff17 	ldw	r5,-4(fp)
81147430:	e13ffe17 	ldw	r4,-8(fp)
81147434:	114a3400 	call	8114a340 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81147438:	0001883a 	nop
8114743c:	e037883a 	mov	sp,fp
81147440:	dfc00117 	ldw	ra,4(sp)
81147444:	df000017 	ldw	fp,0(sp)
81147448:	dec00204 	addi	sp,sp,8
8114744c:	f800283a 	ret

81147450 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
81147450:	defffa04 	addi	sp,sp,-24
81147454:	de00012e 	bgeu	sp,et,8114745c <altera_avalon_uart_irq+0xc>
81147458:	003b68fa 	trap	3
8114745c:	dfc00515 	stw	ra,20(sp)
81147460:	df000415 	stw	fp,16(sp)
81147464:	df000404 	addi	fp,sp,16
81147468:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
8114746c:	e0bfff17 	ldw	r2,-4(fp)
81147470:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81147474:	e0bffc17 	ldw	r2,-16(fp)
81147478:	10800017 	ldw	r2,0(r2)
8114747c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
81147480:	e0bffd17 	ldw	r2,-12(fp)
81147484:	10800204 	addi	r2,r2,8
81147488:	10800037 	ldwio	r2,0(r2)
8114748c:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
81147490:	e0bffd17 	ldw	r2,-12(fp)
81147494:	10800204 	addi	r2,r2,8
81147498:	0007883a 	mov	r3,zero
8114749c:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
811474a0:	e0bffd17 	ldw	r2,-12(fp)
811474a4:	10800204 	addi	r2,r2,8
811474a8:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
811474ac:	e0bffe17 	ldw	r2,-8(fp)
811474b0:	1080200c 	andi	r2,r2,128
811474b4:	10000326 	beq	r2,zero,811474c4 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
811474b8:	e17ffe17 	ldw	r5,-8(fp)
811474bc:	e13ffc17 	ldw	r4,-16(fp)
811474c0:	11474f40 	call	811474f4 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
811474c4:	e0bffe17 	ldw	r2,-8(fp)
811474c8:	1081100c 	andi	r2,r2,1088
811474cc:	10000326 	beq	r2,zero,811474dc <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
811474d0:	e17ffe17 	ldw	r5,-8(fp)
811474d4:	e13ffc17 	ldw	r4,-16(fp)
811474d8:	11476340 	call	81147634 <altera_avalon_uart_txirq>
  }
  

}
811474dc:	0001883a 	nop
811474e0:	e037883a 	mov	sp,fp
811474e4:	dfc00117 	ldw	ra,4(sp)
811474e8:	df000017 	ldw	fp,0(sp)
811474ec:	dec00204 	addi	sp,sp,8
811474f0:	f800283a 	ret

811474f4 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
811474f4:	defff904 	addi	sp,sp,-28
811474f8:	de00012e 	bgeu	sp,et,81147500 <altera_avalon_uart_rxirq+0xc>
811474fc:	003b68fa 	trap	3
81147500:	dfc00615 	stw	ra,24(sp)
81147504:	df000515 	stw	fp,20(sp)
81147508:	df000504 	addi	fp,sp,20
8114750c:	e13ffe15 	stw	r4,-8(fp)
81147510:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81147514:	e0bfff17 	ldw	r2,-4(fp)
81147518:	108000cc 	andi	r2,r2,3
8114751c:	10003f1e 	bne	r2,zero,8114761c <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81147520:	e0bffe17 	ldw	r2,-8(fp)
81147524:	10c00317 	ldw	r3,12(r2)
81147528:	e0bffe17 	ldw	r2,-8(fp)
8114752c:	10800217 	ldw	r2,8(r2)
81147530:	1880121e 	bne	r3,r2,8114757c <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81147534:	e0bffe17 	ldw	r2,-8(fp)
81147538:	10800717 	ldw	r2,28(r2)
8114753c:	e0bffc15 	stw	r2,-16(fp)
81147540:	00800044 	movi	r2,1
81147544:	e0bffd0d 	sth	r2,-12(fp)
81147548:	00800044 	movi	r2,1
8114754c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81147550:	d0a09103 	ldbu	r2,-32188(gp)
81147554:	10803fcc 	andi	r2,r2,255
81147558:	10000826 	beq	r2,zero,8114757c <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
8114755c:	e0bffd0b 	ldhu	r2,-12(fp)
81147560:	e0fffd83 	ldbu	r3,-10(fp)
81147564:	e13ffdc4 	addi	r4,fp,-9
81147568:	200f883a 	mov	r7,r4
8114756c:	180d883a 	mov	r6,r3
81147570:	100b883a 	mov	r5,r2
81147574:	e13ffc17 	ldw	r4,-16(fp)
81147578:	113b2040 	call	8113b204 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8114757c:	e0bffe17 	ldw	r2,-8(fp)
81147580:	10800317 	ldw	r2,12(r2)
81147584:	10800044 	addi	r2,r2,1
81147588:	10800fcc 	andi	r2,r2,63
8114758c:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81147590:	e0bffe17 	ldw	r2,-8(fp)
81147594:	10800317 	ldw	r2,12(r2)
81147598:	e0fffe17 	ldw	r3,-8(fp)
8114759c:	18c00017 	ldw	r3,0(r3)
811475a0:	18c00037 	ldwio	r3,0(r3)
811475a4:	1809883a 	mov	r4,r3
811475a8:	e0fffe17 	ldw	r3,-8(fp)
811475ac:	1885883a 	add	r2,r3,r2
811475b0:	10800a04 	addi	r2,r2,40
811475b4:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
811475b8:	e0bffe17 	ldw	r2,-8(fp)
811475bc:	e0fffb17 	ldw	r3,-20(fp)
811475c0:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811475c4:	e0bffe17 	ldw	r2,-8(fp)
811475c8:	10800317 	ldw	r2,12(r2)
811475cc:	10800044 	addi	r2,r2,1
811475d0:	10800fcc 	andi	r2,r2,63
811475d4:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
811475d8:	e0bffe17 	ldw	r2,-8(fp)
811475dc:	10c00217 	ldw	r3,8(r2)
811475e0:	e0bffb17 	ldw	r2,-20(fp)
811475e4:	18800e1e 	bne	r3,r2,81147620 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811475e8:	e0bffe17 	ldw	r2,-8(fp)
811475ec:	10c00117 	ldw	r3,4(r2)
811475f0:	00bfdfc4 	movi	r2,-129
811475f4:	1886703a 	and	r3,r3,r2
811475f8:	e0bffe17 	ldw	r2,-8(fp)
811475fc:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81147600:	e0bffe17 	ldw	r2,-8(fp)
81147604:	10800017 	ldw	r2,0(r2)
81147608:	10800304 	addi	r2,r2,12
8114760c:	e0fffe17 	ldw	r3,-8(fp)
81147610:	18c00117 	ldw	r3,4(r3)
81147614:	10c00035 	stwio	r3,0(r2)
81147618:	00000106 	br	81147620 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
8114761c:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81147620:	e037883a 	mov	sp,fp
81147624:	dfc00117 	ldw	ra,4(sp)
81147628:	df000017 	ldw	fp,0(sp)
8114762c:	dec00204 	addi	sp,sp,8
81147630:	f800283a 	ret

81147634 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81147634:	defffa04 	addi	sp,sp,-24
81147638:	de00012e 	bgeu	sp,et,81147640 <altera_avalon_uart_txirq+0xc>
8114763c:	003b68fa 	trap	3
81147640:	dfc00515 	stw	ra,20(sp)
81147644:	df000415 	stw	fp,16(sp)
81147648:	df000404 	addi	fp,sp,16
8114764c:	e13ffe15 	stw	r4,-8(fp)
81147650:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81147654:	e0bffe17 	ldw	r2,-8(fp)
81147658:	10c00417 	ldw	r3,16(r2)
8114765c:	e0bffe17 	ldw	r2,-8(fp)
81147660:	10800517 	ldw	r2,20(r2)
81147664:	18804726 	beq	r3,r2,81147784 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81147668:	e0bffe17 	ldw	r2,-8(fp)
8114766c:	10800617 	ldw	r2,24(r2)
81147670:	1080008c 	andi	r2,r2,2
81147674:	10000326 	beq	r2,zero,81147684 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81147678:	e0bfff17 	ldw	r2,-4(fp)
8114767c:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81147680:	10003226 	beq	r2,zero,8114774c <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81147684:	e0bffe17 	ldw	r2,-8(fp)
81147688:	10c00417 	ldw	r3,16(r2)
8114768c:	e0bffe17 	ldw	r2,-8(fp)
81147690:	10800517 	ldw	r2,20(r2)
81147694:	10800044 	addi	r2,r2,1
81147698:	10800fcc 	andi	r2,r2,63
8114769c:	1880121e 	bne	r3,r2,811476e8 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
811476a0:	e0bffe17 	ldw	r2,-8(fp)
811476a4:	10800717 	ldw	r2,28(r2)
811476a8:	e0bffc15 	stw	r2,-16(fp)
811476ac:	00800084 	movi	r2,2
811476b0:	e0bffd0d 	sth	r2,-12(fp)
811476b4:	00800044 	movi	r2,1
811476b8:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811476bc:	d0a09103 	ldbu	r2,-32188(gp)
811476c0:	10803fcc 	andi	r2,r2,255
811476c4:	10000826 	beq	r2,zero,811476e8 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
811476c8:	e0bffd0b 	ldhu	r2,-12(fp)
811476cc:	e0fffd83 	ldbu	r3,-10(fp)
811476d0:	e13ffdc4 	addi	r4,fp,-9
811476d4:	200f883a 	mov	r7,r4
811476d8:	180d883a 	mov	r6,r3
811476dc:	100b883a 	mov	r5,r2
811476e0:	e13ffc17 	ldw	r4,-16(fp)
811476e4:	113b2040 	call	8113b204 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
811476e8:	e0bffe17 	ldw	r2,-8(fp)
811476ec:	10800017 	ldw	r2,0(r2)
811476f0:	10800104 	addi	r2,r2,4
811476f4:	e0fffe17 	ldw	r3,-8(fp)
811476f8:	18c00417 	ldw	r3,16(r3)
811476fc:	e13ffe17 	ldw	r4,-8(fp)
81147700:	20c7883a 	add	r3,r4,r3
81147704:	18c01a04 	addi	r3,r3,104
81147708:	18c00003 	ldbu	r3,0(r3)
8114770c:	18c03fcc 	andi	r3,r3,255
81147710:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81147714:	e0bffe17 	ldw	r2,-8(fp)
81147718:	10800417 	ldw	r2,16(r2)
8114771c:	10800044 	addi	r2,r2,1
81147720:	e0fffe17 	ldw	r3,-8(fp)
81147724:	18800415 	stw	r2,16(r3)
81147728:	10c00fcc 	andi	r3,r2,63
8114772c:	e0bffe17 	ldw	r2,-8(fp)
81147730:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81147734:	e0bffe17 	ldw	r2,-8(fp)
81147738:	10800117 	ldw	r2,4(r2)
8114773c:	10c01014 	ori	r3,r2,64
81147740:	e0bffe17 	ldw	r2,-8(fp)
81147744:	10c00115 	stw	r3,4(r2)
81147748:	00000e06 	br	81147784 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
8114774c:	e0bffe17 	ldw	r2,-8(fp)
81147750:	10800017 	ldw	r2,0(r2)
81147754:	10800204 	addi	r2,r2,8
81147758:	10800037 	ldwio	r2,0(r2)
8114775c:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81147760:	e0bfff17 	ldw	r2,-4(fp)
81147764:	1082000c 	andi	r2,r2,2048
81147768:	1000061e 	bne	r2,zero,81147784 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
8114776c:	e0bffe17 	ldw	r2,-8(fp)
81147770:	10c00117 	ldw	r3,4(r2)
81147774:	00bfefc4 	movi	r2,-65
81147778:	1886703a 	and	r3,r3,r2
8114777c:	e0bffe17 	ldw	r2,-8(fp)
81147780:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81147784:	e0bffe17 	ldw	r2,-8(fp)
81147788:	10c00417 	ldw	r3,16(r2)
8114778c:	e0bffe17 	ldw	r2,-8(fp)
81147790:	10800517 	ldw	r2,20(r2)
81147794:	1880061e 	bne	r3,r2,811477b0 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147798:	e0bffe17 	ldw	r2,-8(fp)
8114779c:	10c00117 	ldw	r3,4(r2)
811477a0:	00beefc4 	movi	r2,-1089
811477a4:	1886703a 	and	r3,r3,r2
811477a8:	e0bffe17 	ldw	r2,-8(fp)
811477ac:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811477b0:	e0bffe17 	ldw	r2,-8(fp)
811477b4:	10800017 	ldw	r2,0(r2)
811477b8:	10800304 	addi	r2,r2,12
811477bc:	e0fffe17 	ldw	r3,-8(fp)
811477c0:	18c00117 	ldw	r3,4(r3)
811477c4:	10c00035 	stwio	r3,0(r2)
}
811477c8:	0001883a 	nop
811477cc:	e037883a 	mov	sp,fp
811477d0:	dfc00117 	ldw	ra,4(sp)
811477d4:	df000017 	ldw	fp,0(sp)
811477d8:	dec00204 	addi	sp,sp,8
811477dc:	f800283a 	ret

811477e0 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
811477e0:	defffd04 	addi	sp,sp,-12
811477e4:	de00012e 	bgeu	sp,et,811477ec <altera_avalon_uart_close+0xc>
811477e8:	003b68fa 	trap	3
811477ec:	df000215 	stw	fp,8(sp)
811477f0:	df000204 	addi	fp,sp,8
811477f4:	e13ffe15 	stw	r4,-8(fp)
811477f8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
811477fc:	00000506 	br	81147814 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81147800:	e0bfff17 	ldw	r2,-4(fp)
81147804:	1090000c 	andi	r2,r2,16384
81147808:	10000226 	beq	r2,zero,81147814 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
8114780c:	00bffd44 	movi	r2,-11
81147810:	00000606 	br	8114782c <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81147814:	e0bffe17 	ldw	r2,-8(fp)
81147818:	10c00417 	ldw	r3,16(r2)
8114781c:	e0bffe17 	ldw	r2,-8(fp)
81147820:	10800517 	ldw	r2,20(r2)
81147824:	18bff61e 	bne	r3,r2,81147800 <__reset+0xfb127800>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81147828:	0005883a 	mov	r2,zero
}
8114782c:	e037883a 	mov	sp,fp
81147830:	df000017 	ldw	fp,0(sp)
81147834:	dec00104 	addi	sp,sp,4
81147838:	f800283a 	ret

8114783c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114783c:	defffe04 	addi	sp,sp,-8
81147840:	de00012e 	bgeu	sp,et,81147848 <alt_get_errno+0xc>
81147844:	003b68fa 	trap	3
81147848:	dfc00115 	stw	ra,4(sp)
8114784c:	df000015 	stw	fp,0(sp)
81147850:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81147854:	d0a01017 	ldw	r2,-32704(gp)
81147858:	10000326 	beq	r2,zero,81147868 <alt_get_errno+0x2c>
8114785c:	d0a01017 	ldw	r2,-32704(gp)
81147860:	103ee83a 	callr	r2
81147864:	00000106 	br	8114786c <alt_get_errno+0x30>
81147868:	d0a07804 	addi	r2,gp,-32288
}
8114786c:	e037883a 	mov	sp,fp
81147870:	dfc00117 	ldw	ra,4(sp)
81147874:	df000017 	ldw	fp,0(sp)
81147878:	dec00204 	addi	sp,sp,8
8114787c:	f800283a 	ret

81147880 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81147880:	deffec04 	addi	sp,sp,-80
81147884:	de00012e 	bgeu	sp,et,8114788c <altera_avalon_uart_read+0xc>
81147888:	003b68fa 	trap	3
8114788c:	dfc01315 	stw	ra,76(sp)
81147890:	df001215 	stw	fp,72(sp)
81147894:	df001204 	addi	fp,sp,72
81147898:	e13ffc15 	stw	r4,-16(fp)
8114789c:	e17ffd15 	stw	r5,-12(fp)
811478a0:	e1bffe15 	stw	r6,-8(fp)
811478a4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
811478a8:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
811478ac:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
811478b0:	e0bfff17 	ldw	r2,-4(fp)
811478b4:	1090000c 	andi	r2,r2,16384
811478b8:	1005003a 	cmpeq	r2,r2,zero
811478bc:	10803fcc 	andi	r2,r2,255
811478c0:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
811478c4:	e0bffc17 	ldw	r2,-16(fp)
811478c8:	10800817 	ldw	r2,32(r2)
811478cc:	e0bff815 	stw	r2,-32(fp)
811478d0:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811478d4:	e0bff90b 	ldhu	r2,-28(fp)
811478d8:	e0fffb44 	addi	r3,fp,-19
811478dc:	180d883a 	mov	r6,r3
811478e0:	100b883a 	mov	r5,r2
811478e4:	e13ff817 	ldw	r4,-32(fp)
811478e8:	113e87c0 	call	8113e87c <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
811478ec:	00001306 	br	8114793c <altera_avalon_uart_read+0xbc>
    {
      count++;
811478f0:	e0bff017 	ldw	r2,-64(fp)
811478f4:	10800044 	addi	r2,r2,1
811478f8:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
811478fc:	e0bffd17 	ldw	r2,-12(fp)
81147900:	10c00044 	addi	r3,r2,1
81147904:	e0fffd15 	stw	r3,-12(fp)
81147908:	e0fffc17 	ldw	r3,-16(fp)
8114790c:	18c00217 	ldw	r3,8(r3)
81147910:	e13ffc17 	ldw	r4,-16(fp)
81147914:	20c7883a 	add	r3,r4,r3
81147918:	18c00a04 	addi	r3,r3,40
8114791c:	18c00003 	ldbu	r3,0(r3)
81147920:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81147924:	e0bffc17 	ldw	r2,-16(fp)
81147928:	10800217 	ldw	r2,8(r2)
8114792c:	10800044 	addi	r2,r2,1
81147930:	10c00fcc 	andi	r3,r2,63
81147934:	e0bffc17 	ldw	r2,-16(fp)
81147938:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
8114793c:	e0fff017 	ldw	r3,-64(fp)
81147940:	e0bffe17 	ldw	r2,-8(fp)
81147944:	1880050e 	bge	r3,r2,8114795c <altera_avalon_uart_read+0xdc>
81147948:	e0bffc17 	ldw	r2,-16(fp)
8114794c:	10c00217 	ldw	r3,8(r2)
81147950:	e0bffc17 	ldw	r2,-16(fp)
81147954:	10800317 	ldw	r2,12(r2)
81147958:	18bfe51e 	bne	r3,r2,811478f0 <__reset+0xfb1278f0>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
8114795c:	e0bff017 	ldw	r2,-64(fp)
81147960:	10003a1e 	bne	r2,zero,81147a4c <altera_avalon_uart_read+0x1cc>
81147964:	e0bffc17 	ldw	r2,-16(fp)
81147968:	10c00217 	ldw	r3,8(r2)
8114796c:	e0bffc17 	ldw	r2,-16(fp)
81147970:	10800317 	ldw	r2,12(r2)
81147974:	1880351e 	bne	r3,r2,81147a4c <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81147978:	e0bff117 	ldw	r2,-60(fp)
8114797c:	1000071e 	bne	r2,zero,8114799c <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81147980:	114783c0 	call	8114783c <alt_get_errno>
81147984:	1007883a 	mov	r3,r2
81147988:	008002c4 	movi	r2,11
8114798c:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81147990:	00800044 	movi	r2,1
81147994:	e0bfef05 	stb	r2,-68(fp)
        break;
81147998:	00003006 	br	81147a5c <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114799c:	0005303a 	rdctl	r2,status
811479a0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811479a4:	e0fff517 	ldw	r3,-44(fp)
811479a8:	00bfff84 	movi	r2,-2
811479ac:	1884703a 	and	r2,r3,r2
811479b0:	1001703a 	wrctl	status,r2
  
  return context;
811479b4:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
811479b8:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811479bc:	e0bffc17 	ldw	r2,-16(fp)
811479c0:	10800117 	ldw	r2,4(r2)
811479c4:	10c02014 	ori	r3,r2,128
811479c8:	e0bffc17 	ldw	r2,-16(fp)
811479cc:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811479d0:	e0bffc17 	ldw	r2,-16(fp)
811479d4:	10800017 	ldw	r2,0(r2)
811479d8:	10800304 	addi	r2,r2,12
811479dc:	e0fffc17 	ldw	r3,-16(fp)
811479e0:	18c00117 	ldw	r3,4(r3)
811479e4:	10c00035 	stwio	r3,0(r2)
811479e8:	e0bff417 	ldw	r2,-48(fp)
811479ec:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811479f0:	e0bff617 	ldw	r2,-40(fp)
811479f4:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
811479f8:	e0bffc17 	ldw	r2,-16(fp)
811479fc:	10800717 	ldw	r2,28(r2)
81147a00:	e0bff215 	stw	r2,-56(fp)
81147a04:	00800044 	movi	r2,1
81147a08:	e0bff98d 	sth	r2,-26(fp)
81147a0c:	00bfe0c4 	movi	r2,-125
81147a10:	e0bffa05 	stb	r2,-24(fp)
81147a14:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81147a18:	d0a09103 	ldbu	r2,-32188(gp)
81147a1c:	10803fcc 	andi	r2,r2,255
81147a20:	10000a26 	beq	r2,zero,81147a4c <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81147a24:	e0fff98b 	ldhu	r3,-26(fp)
81147a28:	e13ffa03 	ldbu	r4,-24(fp)
81147a2c:	e17ffa8b 	ldhu	r5,-22(fp)
81147a30:	e0bffb04 	addi	r2,fp,-20
81147a34:	d8800015 	stw	r2,0(sp)
81147a38:	280f883a 	mov	r7,r5
81147a3c:	200d883a 	mov	r6,r4
81147a40:	180b883a 	mov	r5,r3
81147a44:	e13ff217 	ldw	r4,-56(fp)
81147a48:	113abdc0 	call	8113abdc <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81147a4c:	e0bff017 	ldw	r2,-64(fp)
81147a50:	1000021e 	bne	r2,zero,81147a5c <altera_avalon_uart_read+0x1dc>
81147a54:	e0bffe17 	ldw	r2,-8(fp)
81147a58:	103fb81e 	bne	r2,zero,8114793c <__reset+0xfb12793c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81147a5c:	e0bffc17 	ldw	r2,-16(fp)
81147a60:	10800817 	ldw	r2,32(r2)
81147a64:	1009883a 	mov	r4,r2
81147a68:	113ec040 	call	8113ec04 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147a6c:	0005303a 	rdctl	r2,status
81147a70:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147a74:	e0fff717 	ldw	r3,-36(fp)
81147a78:	00bfff84 	movi	r2,-2
81147a7c:	1884703a 	and	r2,r3,r2
81147a80:	1001703a 	wrctl	status,r2
  
  return context;
81147a84:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81147a88:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81147a8c:	e0bffc17 	ldw	r2,-16(fp)
81147a90:	10800117 	ldw	r2,4(r2)
81147a94:	10c02014 	ori	r3,r2,128
81147a98:	e0bffc17 	ldw	r2,-16(fp)
81147a9c:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147aa0:	e0bffc17 	ldw	r2,-16(fp)
81147aa4:	10800017 	ldw	r2,0(r2)
81147aa8:	10800304 	addi	r2,r2,12
81147aac:	e0fffc17 	ldw	r3,-16(fp)
81147ab0:	18c00117 	ldw	r3,4(r3)
81147ab4:	10c00035 	stwio	r3,0(r2)
81147ab8:	e0bff417 	ldw	r2,-48(fp)
81147abc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147ac0:	e0bff317 	ldw	r2,-52(fp)
81147ac4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81147ac8:	e0bfef03 	ldbu	r2,-68(fp)
81147acc:	10000226 	beq	r2,zero,81147ad8 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81147ad0:	00bffd44 	movi	r2,-11
81147ad4:	00000106 	br	81147adc <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81147ad8:	e0bff017 	ldw	r2,-64(fp)
  }
}
81147adc:	e037883a 	mov	sp,fp
81147ae0:	dfc00117 	ldw	ra,4(sp)
81147ae4:	df000017 	ldw	fp,0(sp)
81147ae8:	dec00204 	addi	sp,sp,8
81147aec:	f800283a 	ret

81147af0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81147af0:	defffe04 	addi	sp,sp,-8
81147af4:	de00012e 	bgeu	sp,et,81147afc <alt_get_errno+0xc>
81147af8:	003b68fa 	trap	3
81147afc:	dfc00115 	stw	ra,4(sp)
81147b00:	df000015 	stw	fp,0(sp)
81147b04:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81147b08:	d0a01017 	ldw	r2,-32704(gp)
81147b0c:	10000326 	beq	r2,zero,81147b1c <alt_get_errno+0x2c>
81147b10:	d0a01017 	ldw	r2,-32704(gp)
81147b14:	103ee83a 	callr	r2
81147b18:	00000106 	br	81147b20 <alt_get_errno+0x30>
81147b1c:	d0a07804 	addi	r2,gp,-32288
}
81147b20:	e037883a 	mov	sp,fp
81147b24:	dfc00117 	ldw	ra,4(sp)
81147b28:	df000017 	ldw	fp,0(sp)
81147b2c:	dec00204 	addi	sp,sp,8
81147b30:	f800283a 	ret

81147b34 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81147b34:	deffec04 	addi	sp,sp,-80
81147b38:	de00012e 	bgeu	sp,et,81147b40 <altera_avalon_uart_write+0xc>
81147b3c:	003b68fa 	trap	3
81147b40:	dfc01315 	stw	ra,76(sp)
81147b44:	df001215 	stw	fp,72(sp)
81147b48:	df001204 	addi	fp,sp,72
81147b4c:	e13ffc15 	stw	r4,-16(fp)
81147b50:	e17ffd15 	stw	r5,-12(fp)
81147b54:	e1bffe15 	stw	r6,-8(fp)
81147b58:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81147b5c:	e0bffe17 	ldw	r2,-8(fp)
81147b60:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81147b64:	e0bfff17 	ldw	r2,-4(fp)
81147b68:	1090000c 	andi	r2,r2,16384
81147b6c:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81147b70:	e0bffc17 	ldw	r2,-16(fp)
81147b74:	10800917 	ldw	r2,36(r2)
81147b78:	e0bff815 	stw	r2,-32(fp)
81147b7c:	e03ff90d 	sth	zero,-28(fp)
81147b80:	e0bff90b 	ldhu	r2,-28(fp)
81147b84:	e0fffb44 	addi	r3,fp,-19
81147b88:	180d883a 	mov	r6,r3
81147b8c:	100b883a 	mov	r5,r2
81147b90:	e13ff817 	ldw	r4,-32(fp)
81147b94:	113e87c0 	call	8113e87c <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81147b98:	00005106 	br	81147ce0 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81147b9c:	e0bffc17 	ldw	r2,-16(fp)
81147ba0:	10800517 	ldw	r2,20(r2)
81147ba4:	10800044 	addi	r2,r2,1
81147ba8:	10800fcc 	andi	r2,r2,63
81147bac:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81147bb0:	e0bffc17 	ldw	r2,-16(fp)
81147bb4:	10c00417 	ldw	r3,16(r2)
81147bb8:	e0bff217 	ldw	r2,-56(fp)
81147bbc:	1880371e 	bne	r3,r2,81147c9c <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81147bc0:	e0bff017 	ldw	r2,-64(fp)
81147bc4:	10000526 	beq	r2,zero,81147bdc <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81147bc8:	1147af00 	call	81147af0 <alt_get_errno>
81147bcc:	1007883a 	mov	r3,r2
81147bd0:	008002c4 	movi	r2,11
81147bd4:	18800015 	stw	r2,0(r3)
        break;
81147bd8:	00004306 	br	81147ce8 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147bdc:	0005303a 	rdctl	r2,status
81147be0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147be4:	e0fff517 	ldw	r3,-44(fp)
81147be8:	00bfff84 	movi	r2,-2
81147bec:	1884703a 	and	r2,r3,r2
81147bf0:	1001703a 	wrctl	status,r2
  
  return context;
81147bf4:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81147bf8:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147bfc:	e0bffc17 	ldw	r2,-16(fp)
81147c00:	10800117 	ldw	r2,4(r2)
81147c04:	10c11014 	ori	r3,r2,1088
81147c08:	e0bffc17 	ldw	r2,-16(fp)
81147c0c:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147c10:	e0bffc17 	ldw	r2,-16(fp)
81147c14:	10800017 	ldw	r2,0(r2)
81147c18:	10800304 	addi	r2,r2,12
81147c1c:	e0fffc17 	ldw	r3,-16(fp)
81147c20:	18c00117 	ldw	r3,4(r3)
81147c24:	10c00035 	stwio	r3,0(r2)
81147c28:	e0bff417 	ldw	r2,-48(fp)
81147c2c:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147c30:	e0bff117 	ldw	r2,-60(fp)
81147c34:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81147c38:	e0bffc17 	ldw	r2,-16(fp)
81147c3c:	10800717 	ldw	r2,28(r2)
81147c40:	e0bff315 	stw	r2,-52(fp)
81147c44:	00800084 	movi	r2,2
81147c48:	e0bff98d 	sth	r2,-26(fp)
81147c4c:	00bfe0c4 	movi	r2,-125
81147c50:	e0bffa05 	stb	r2,-24(fp)
81147c54:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81147c58:	d0a09103 	ldbu	r2,-32188(gp)
81147c5c:	10803fcc 	andi	r2,r2,255
81147c60:	10000a26 	beq	r2,zero,81147c8c <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81147c64:	e0fff98b 	ldhu	r3,-26(fp)
81147c68:	e13ffa03 	ldbu	r4,-24(fp)
81147c6c:	e17ffa8b 	ldhu	r5,-22(fp)
81147c70:	e0bffb04 	addi	r2,fp,-20
81147c74:	d8800015 	stw	r2,0(sp)
81147c78:	280f883a 	mov	r7,r5
81147c7c:	200d883a 	mov	r6,r4
81147c80:	180b883a 	mov	r5,r3
81147c84:	e13ff317 	ldw	r4,-52(fp)
81147c88:	113abdc0 	call	8113abdc <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81147c8c:	e0bffc17 	ldw	r2,-16(fp)
81147c90:	10c00417 	ldw	r3,16(r2)
81147c94:	e0bff217 	ldw	r2,-56(fp)
81147c98:	18bfe726 	beq	r3,r2,81147c38 <__reset+0xfb127c38>
      }
    }

    count--;
81147c9c:	e0bfef17 	ldw	r2,-68(fp)
81147ca0:	10bfffc4 	addi	r2,r2,-1
81147ca4:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81147ca8:	e0bffc17 	ldw	r2,-16(fp)
81147cac:	10c00517 	ldw	r3,20(r2)
81147cb0:	e0bffd17 	ldw	r2,-12(fp)
81147cb4:	11000044 	addi	r4,r2,1
81147cb8:	e13ffd15 	stw	r4,-12(fp)
81147cbc:	10800003 	ldbu	r2,0(r2)
81147cc0:	1009883a 	mov	r4,r2
81147cc4:	e0bffc17 	ldw	r2,-16(fp)
81147cc8:	10c5883a 	add	r2,r2,r3
81147ccc:	10801a04 	addi	r2,r2,104
81147cd0:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81147cd4:	e0bffc17 	ldw	r2,-16(fp)
81147cd8:	e0fff217 	ldw	r3,-56(fp)
81147cdc:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81147ce0:	e0bfef17 	ldw	r2,-68(fp)
81147ce4:	103fad1e 	bne	r2,zero,81147b9c <__reset+0xfb127b9c>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81147ce8:	e0bffc17 	ldw	r2,-16(fp)
81147cec:	10800917 	ldw	r2,36(r2)
81147cf0:	1009883a 	mov	r4,r2
81147cf4:	113ec040 	call	8113ec04 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147cf8:	0005303a 	rdctl	r2,status
81147cfc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147d00:	e0fff717 	ldw	r3,-36(fp)
81147d04:	00bfff84 	movi	r2,-2
81147d08:	1884703a 	and	r2,r3,r2
81147d0c:	1001703a 	wrctl	status,r2
  
  return context;
81147d10:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81147d14:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147d18:	e0bffc17 	ldw	r2,-16(fp)
81147d1c:	10800117 	ldw	r2,4(r2)
81147d20:	10c11014 	ori	r3,r2,1088
81147d24:	e0bffc17 	ldw	r2,-16(fp)
81147d28:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147d2c:	e0bffc17 	ldw	r2,-16(fp)
81147d30:	10800017 	ldw	r2,0(r2)
81147d34:	10800304 	addi	r2,r2,12
81147d38:	e0fffc17 	ldw	r3,-16(fp)
81147d3c:	18c00117 	ldw	r3,4(r3)
81147d40:	10c00035 	stwio	r3,0(r2)
81147d44:	e0bff417 	ldw	r2,-48(fp)
81147d48:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147d4c:	e0bff617 	ldw	r2,-40(fp)
81147d50:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81147d54:	e0fffe17 	ldw	r3,-8(fp)
81147d58:	e0bfef17 	ldw	r2,-68(fp)
81147d5c:	1885c83a 	sub	r2,r3,r2
}
81147d60:	e037883a 	mov	sp,fp
81147d64:	dfc00117 	ldw	ra,4(sp)
81147d68:	df000017 	ldw	fp,0(sp)
81147d6c:	dec00204 	addi	sp,sp,8
81147d70:	f800283a 	ret

81147d74 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81147d74:	defffe04 	addi	sp,sp,-8
81147d78:	de00012e 	bgeu	sp,et,81147d80 <alt_get_errno+0xc>
81147d7c:	003b68fa 	trap	3
81147d80:	dfc00115 	stw	ra,4(sp)
81147d84:	df000015 	stw	fp,0(sp)
81147d88:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81147d8c:	d0a01017 	ldw	r2,-32704(gp)
81147d90:	10000326 	beq	r2,zero,81147da0 <alt_get_errno+0x2c>
81147d94:	d0a01017 	ldw	r2,-32704(gp)
81147d98:	103ee83a 	callr	r2
81147d9c:	00000106 	br	81147da4 <alt_get_errno+0x30>
81147da0:	d0a07804 	addi	r2,gp,-32288
}
81147da4:	e037883a 	mov	sp,fp
81147da8:	dfc00117 	ldw	ra,4(sp)
81147dac:	df000017 	ldw	fp,0(sp)
81147db0:	dec00204 	addi	sp,sp,8
81147db4:	f800283a 	ret

81147db8 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81147db8:	defffc04 	addi	sp,sp,-16
81147dbc:	de00012e 	bgeu	sp,et,81147dc4 <alt_msgdma_write_standard_descriptor+0xc>
81147dc0:	003b68fa 	trap	3
81147dc4:	df000315 	stw	fp,12(sp)
81147dc8:	df000304 	addi	fp,sp,12
81147dcc:	e13ffd15 	stw	r4,-12(fp)
81147dd0:	e17ffe15 	stw	r5,-8(fp)
81147dd4:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81147dd8:	e0bffd17 	ldw	r2,-12(fp)
81147ddc:	10800037 	ldwio	r2,0(r2)
81147de0:	1080010c 	andi	r2,r2,4
81147de4:	10000226 	beq	r2,zero,81147df0 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81147de8:	00bff904 	movi	r2,-28
81147dec:	00001506 	br	81147e44 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81147df0:	e0bfff17 	ldw	r2,-4(fp)
81147df4:	10800017 	ldw	r2,0(r2)
81147df8:	1007883a 	mov	r3,r2
81147dfc:	e0bffe17 	ldw	r2,-8(fp)
81147e00:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81147e04:	e0bffe17 	ldw	r2,-8(fp)
81147e08:	10800104 	addi	r2,r2,4
81147e0c:	e0ffff17 	ldw	r3,-4(fp)
81147e10:	18c00117 	ldw	r3,4(r3)
81147e14:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81147e18:	e0bffe17 	ldw	r2,-8(fp)
81147e1c:	10800204 	addi	r2,r2,8
81147e20:	e0ffff17 	ldw	r3,-4(fp)
81147e24:	18c00217 	ldw	r3,8(r3)
81147e28:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81147e2c:	e0bffe17 	ldw	r2,-8(fp)
81147e30:	10800304 	addi	r2,r2,12
81147e34:	e0ffff17 	ldw	r3,-4(fp)
81147e38:	18c00317 	ldw	r3,12(r3)
81147e3c:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81147e40:	0005883a 	mov	r2,zero
}
81147e44:	e037883a 	mov	sp,fp
81147e48:	df000017 	ldw	fp,0(sp)
81147e4c:	dec00104 	addi	sp,sp,4
81147e50:	f800283a 	ret

81147e54 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81147e54:	defffc04 	addi	sp,sp,-16
81147e58:	de00012e 	bgeu	sp,et,81147e60 <alt_msgdma_write_extended_descriptor+0xc>
81147e5c:	003b68fa 	trap	3
81147e60:	df000315 	stw	fp,12(sp)
81147e64:	df000304 	addi	fp,sp,12
81147e68:	e13ffd15 	stw	r4,-12(fp)
81147e6c:	e17ffe15 	stw	r5,-8(fp)
81147e70:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81147e74:	e0bffd17 	ldw	r2,-12(fp)
81147e78:	10800037 	ldwio	r2,0(r2)
81147e7c:	1080010c 	andi	r2,r2,4
81147e80:	10000226 	beq	r2,zero,81147e8c <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81147e84:	00bff904 	movi	r2,-28
81147e88:	00003b06 	br	81147f78 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81147e8c:	e0bfff17 	ldw	r2,-4(fp)
81147e90:	10800017 	ldw	r2,0(r2)
81147e94:	1007883a 	mov	r3,r2
81147e98:	e0bffe17 	ldw	r2,-8(fp)
81147e9c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81147ea0:	e0bffe17 	ldw	r2,-8(fp)
81147ea4:	10800104 	addi	r2,r2,4
81147ea8:	e0ffff17 	ldw	r3,-4(fp)
81147eac:	18c00117 	ldw	r3,4(r3)
81147eb0:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81147eb4:	e0bffe17 	ldw	r2,-8(fp)
81147eb8:	10800204 	addi	r2,r2,8
81147ebc:	e0ffff17 	ldw	r3,-4(fp)
81147ec0:	18c00217 	ldw	r3,8(r3)
81147ec4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81147ec8:	e0bffe17 	ldw	r2,-8(fp)
81147ecc:	10800304 	addi	r2,r2,12
81147ed0:	e0ffff17 	ldw	r3,-4(fp)
81147ed4:	18c0030b 	ldhu	r3,12(r3)
81147ed8:	18ffffcc 	andi	r3,r3,65535
81147edc:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81147ee0:	e0bffe17 	ldw	r2,-8(fp)
81147ee4:	10800384 	addi	r2,r2,14
81147ee8:	e0ffff17 	ldw	r3,-4(fp)
81147eec:	18c00383 	ldbu	r3,14(r3)
81147ef0:	18c03fcc 	andi	r3,r3,255
81147ef4:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81147ef8:	e0bffe17 	ldw	r2,-8(fp)
81147efc:	108003c4 	addi	r2,r2,15
81147f00:	e0ffff17 	ldw	r3,-4(fp)
81147f04:	18c003c3 	ldbu	r3,15(r3)
81147f08:	18c03fcc 	andi	r3,r3,255
81147f0c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81147f10:	e0bffe17 	ldw	r2,-8(fp)
81147f14:	10800404 	addi	r2,r2,16
81147f18:	e0ffff17 	ldw	r3,-4(fp)
81147f1c:	18c0040b 	ldhu	r3,16(r3)
81147f20:	18ffffcc 	andi	r3,r3,65535
81147f24:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81147f28:	e0bffe17 	ldw	r2,-8(fp)
81147f2c:	10800484 	addi	r2,r2,18
81147f30:	e0ffff17 	ldw	r3,-4(fp)
81147f34:	18c0048b 	ldhu	r3,18(r3)
81147f38:	18ffffcc 	andi	r3,r3,65535
81147f3c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81147f40:	e0bffe17 	ldw	r2,-8(fp)
81147f44:	10800504 	addi	r2,r2,20
81147f48:	0007883a 	mov	r3,zero
81147f4c:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
81147f50:	e0bffe17 	ldw	r2,-8(fp)
81147f54:	10800604 	addi	r2,r2,24
81147f58:	0007883a 	mov	r3,zero
81147f5c:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
81147f60:	e0bffe17 	ldw	r2,-8(fp)
81147f64:	10800704 	addi	r2,r2,28
81147f68:	e0ffff17 	ldw	r3,-4(fp)
81147f6c:	18c00717 	ldw	r3,28(r3)
81147f70:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
81147f74:	0005883a 	mov	r2,zero
}
81147f78:	e037883a 	mov	sp,fp
81147f7c:	df000017 	ldw	fp,0(sp)
81147f80:	dec00104 	addi	sp,sp,4
81147f84:	f800283a 	ret

81147f88 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81147f88:	defff804 	addi	sp,sp,-32
81147f8c:	de00012e 	bgeu	sp,et,81147f94 <alt_msgdma_irq+0xc>
81147f90:	003b68fa 	trap	3
81147f94:	dfc00715 	stw	ra,28(sp)
81147f98:	df000615 	stw	fp,24(sp)
81147f9c:	df000604 	addi	fp,sp,24
81147fa0:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81147fa4:	e0bfff17 	ldw	r2,-4(fp)
81147fa8:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81147fac:	e0bffa17 	ldw	r2,-24(fp)
81147fb0:	10801783 	ldbu	r2,94(r2)
81147fb4:	10803fcc 	andi	r2,r2,255
81147fb8:	10001126 	beq	r2,zero,81148000 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81147fbc:	e0bffa17 	ldw	r2,-24(fp)
81147fc0:	10800617 	ldw	r2,24(r2)
81147fc4:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81147fc8:	1007883a 	mov	r3,r2
81147fcc:	00bffdc4 	movi	r2,-9
81147fd0:	1884703a 	and	r2,r3,r2
81147fd4:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81147fd8:	e0bffa17 	ldw	r2,-24(fp)
81147fdc:	10800617 	ldw	r2,24(r2)
81147fe0:	e0fffb17 	ldw	r3,-20(fp)
81147fe4:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81147fe8:	e0bffa17 	ldw	r2,-24(fp)
81147fec:	10800617 	ldw	r2,24(r2)
81147ff0:	10800404 	addi	r2,r2,16
81147ff4:	00c00044 	movi	r3,1
81147ff8:	10c00035 	stwio	r3,0(r2)
81147ffc:	00001106 	br	81148044 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81148000:	e0bffa17 	ldw	r2,-24(fp)
81148004:	10800317 	ldw	r2,12(r2)
81148008:	10800104 	addi	r2,r2,4
8114800c:	10800037 	ldwio	r2,0(r2)
81148010:	1007883a 	mov	r3,r2
81148014:	00bffbc4 	movi	r2,-17
81148018:	1884703a 	and	r2,r3,r2
8114801c:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81148020:	e0bffa17 	ldw	r2,-24(fp)
81148024:	10800317 	ldw	r2,12(r2)
81148028:	10800104 	addi	r2,r2,4
8114802c:	e0fffb17 	ldw	r3,-20(fp)
81148030:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81148034:	e0bffa17 	ldw	r2,-24(fp)
81148038:	10800317 	ldw	r2,12(r2)
8114803c:	00c08004 	movi	r3,512
81148040:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
81148044:	e0bffa17 	ldw	r2,-24(fp)
81148048:	10800b17 	ldw	r2,44(r2)
8114804c:	10001226 	beq	r2,zero,81148098 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148050:	0005303a 	rdctl	r2,status
81148054:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148058:	e0fffd17 	ldw	r3,-12(fp)
8114805c:	00bfff84 	movi	r2,-2
81148060:	1884703a 	and	r2,r3,r2
81148064:	1001703a 	wrctl	status,r2
  
  return context;
81148068:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
8114806c:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
81148070:	e0bffa17 	ldw	r2,-24(fp)
81148074:	10800b17 	ldw	r2,44(r2)
81148078:	e0fffa17 	ldw	r3,-24(fp)
8114807c:	18c00c17 	ldw	r3,48(r3)
81148080:	1809883a 	mov	r4,r3
81148084:	103ee83a 	callr	r2
81148088:	e0bffc17 	ldw	r2,-16(fp)
8114808c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148090:	e0bffe17 	ldw	r2,-8(fp)
81148094:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81148098:	e0bffa17 	ldw	r2,-24(fp)
8114809c:	10801783 	ldbu	r2,94(r2)
811480a0:	10803fcc 	andi	r2,r2,255
811480a4:	10000a26 	beq	r2,zero,811480d0 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
811480a8:	e0bffa17 	ldw	r2,-24(fp)
811480ac:	10800617 	ldw	r2,24(r2)
811480b0:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
811480b4:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
811480b8:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
811480bc:	e0bffa17 	ldw	r2,-24(fp)
811480c0:	10800617 	ldw	r2,24(r2)
811480c4:	e0fffb17 	ldw	r3,-20(fp)
811480c8:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
811480cc:	00000c06 	br	81148100 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
811480d0:	e0bffa17 	ldw	r2,-24(fp)
811480d4:	10800317 	ldw	r2,12(r2)
811480d8:	10800104 	addi	r2,r2,4
811480dc:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
811480e0:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
811480e4:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
811480e8:	e0bffa17 	ldw	r2,-24(fp)
811480ec:	10800317 	ldw	r2,12(r2)
811480f0:	10800104 	addi	r2,r2,4
811480f4:	e0fffb17 	ldw	r3,-20(fp)
811480f8:	10c00035 	stwio	r3,0(r2)
    }

    return;
811480fc:	0001883a 	nop
}
81148100:	e037883a 	mov	sp,fp
81148104:	dfc00117 	ldw	ra,4(sp)
81148108:	df000017 	ldw	fp,0(sp)
8114810c:	dec00204 	addi	sp,sp,8
81148110:	f800283a 	ret

81148114 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148114:	defffb04 	addi	sp,sp,-20
81148118:	de00012e 	bgeu	sp,et,81148120 <alt_msgdma_construct_standard_descriptor+0xc>
8114811c:	003b68fa 	trap	3
81148120:	df000415 	stw	fp,16(sp)
81148124:	df000404 	addi	fp,sp,16
81148128:	e13ffc15 	stw	r4,-16(fp)
8114812c:	e17ffd15 	stw	r5,-12(fp)
81148130:	e1bffe15 	stw	r6,-8(fp)
81148134:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81148138:	e0bffc17 	ldw	r2,-16(fp)
8114813c:	10c01217 	ldw	r3,72(r2)
81148140:	e0800117 	ldw	r2,4(fp)
81148144:	18800436 	bltu	r3,r2,81148158 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81148148:	e0bffc17 	ldw	r2,-16(fp)
8114814c:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81148150:	10803fcc 	andi	r2,r2,255
81148154:	10000226 	beq	r2,zero,81148160 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81148158:	00bffa84 	movi	r2,-22
8114815c:	00000e06 	br	81148198 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
81148160:	e0bffd17 	ldw	r2,-12(fp)
81148164:	e0fffe17 	ldw	r3,-8(fp)
81148168:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8114816c:	e0bffd17 	ldw	r2,-12(fp)
81148170:	e0ffff17 	ldw	r3,-4(fp)
81148174:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148178:	e0bffd17 	ldw	r2,-12(fp)
8114817c:	e0c00117 	ldw	r3,4(fp)
81148180:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81148184:	e0800217 	ldw	r2,8(fp)
81148188:	10e00034 	orhi	r3,r2,32768
8114818c:	e0bffd17 	ldw	r2,-12(fp)
81148190:	10c00315 	stw	r3,12(r2)
    
    return 0;
81148194:	0005883a 	mov	r2,zero
}
81148198:	e037883a 	mov	sp,fp
8114819c:	df000017 	ldw	fp,0(sp)
811481a0:	dec00104 	addi	sp,sp,4
811481a4:	f800283a 	ret

811481a8 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
811481a8:	defff604 	addi	sp,sp,-40
811481ac:	de00012e 	bgeu	sp,et,811481b4 <alt_msgdma_construct_extended_descriptor+0xc>
811481b0:	003b68fa 	trap	3
811481b4:	df000915 	stw	fp,36(sp)
811481b8:	df000904 	addi	fp,sp,36
811481bc:	e13ff715 	stw	r4,-36(fp)
811481c0:	e17ff815 	stw	r5,-32(fp)
811481c4:	e1bff915 	stw	r6,-28(fp)
811481c8:	e1fffa15 	stw	r7,-24(fp)
811481cc:	e1800317 	ldw	r6,12(fp)
811481d0:	e1400417 	ldw	r5,16(fp)
811481d4:	e1000517 	ldw	r4,20(fp)
811481d8:	e0c00617 	ldw	r3,24(fp)
811481dc:	e0800717 	ldw	r2,28(fp)
811481e0:	e1bffb0d 	sth	r6,-20(fp)
811481e4:	e17ffc05 	stb	r5,-16(fp)
811481e8:	e13ffd05 	stb	r4,-12(fp)
811481ec:	e0fffe0d 	sth	r3,-8(fp)
811481f0:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
811481f4:	e0bff717 	ldw	r2,-36(fp)
811481f8:	10c01217 	ldw	r3,72(r2)
811481fc:	e0800117 	ldw	r2,4(fp)
81148200:	18801936 	bltu	r3,r2,81148268 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81148204:	e13ff717 	ldw	r4,-36(fp)
81148208:	20801317 	ldw	r2,76(r4)
8114820c:	20c01417 	ldw	r3,80(r4)
81148210:	e13ffe0b 	ldhu	r4,-8(fp)
81148214:	213fffcc 	andi	r4,r4,65535
81148218:	2015883a 	mov	r10,r4
8114821c:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81148220:	1ac01136 	bltu	r3,r11,81148268 <alt_msgdma_construct_extended_descriptor+0xc0>
81148224:	58c0011e 	bne	r11,r3,8114822c <alt_msgdma_construct_extended_descriptor+0x84>
81148228:	12800f36 	bltu	r2,r10,81148268 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114822c:	e13ff717 	ldw	r4,-36(fp)
81148230:	20801317 	ldw	r2,76(r4)
81148234:	20c01417 	ldw	r3,80(r4)
81148238:	e13fff0b 	ldhu	r4,-4(fp)
8114823c:	213fffcc 	andi	r4,r4,65535
81148240:	2011883a 	mov	r8,r4
81148244:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81148248:	1a400736 	bltu	r3,r9,81148268 <alt_msgdma_construct_extended_descriptor+0xc0>
8114824c:	48c0011e 	bne	r9,r3,81148254 <alt_msgdma_construct_extended_descriptor+0xac>
81148250:	12000536 	bltu	r2,r8,81148268 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81148254:	e0bff717 	ldw	r2,-36(fp)
81148258:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8114825c:	10803fcc 	andi	r2,r2,255
81148260:	10800060 	cmpeqi	r2,r2,1
81148264:	1000021e 	bne	r2,zero,81148270 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81148268:	00bffa84 	movi	r2,-22
8114826c:	00002106 	br	811482f4 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
81148270:	e0bff817 	ldw	r2,-32(fp)
81148274:	e0fff917 	ldw	r3,-28(fp)
81148278:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
8114827c:	e0bff817 	ldw	r2,-32(fp)
81148280:	e0fffa17 	ldw	r3,-24(fp)
81148284:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148288:	e0bff817 	ldw	r2,-32(fp)
8114828c:	e0c00117 	ldw	r3,4(fp)
81148290:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81148294:	e0bff817 	ldw	r2,-32(fp)
81148298:	e0fffb0b 	ldhu	r3,-20(fp)
8114829c:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
811482a0:	e0bff817 	ldw	r2,-32(fp)
811482a4:	e0fffc03 	ldbu	r3,-16(fp)
811482a8:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
811482ac:	e0bff817 	ldw	r2,-32(fp)
811482b0:	e0fffd03 	ldbu	r3,-12(fp)
811482b4:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
811482b8:	e0bff817 	ldw	r2,-32(fp)
811482bc:	e0fffe0b 	ldhu	r3,-8(fp)
811482c0:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
811482c4:	e0bff817 	ldw	r2,-32(fp)
811482c8:	e0ffff0b 	ldhu	r3,-4(fp)
811482cc:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
811482d0:	e0bff817 	ldw	r2,-32(fp)
811482d4:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
811482d8:	e0bff817 	ldw	r2,-32(fp)
811482dc:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811482e0:	e0800217 	ldw	r2,8(fp)
811482e4:	10e00034 	orhi	r3,r2,32768
811482e8:	e0bff817 	ldw	r2,-32(fp)
811482ec:	10c00715 	stw	r3,28(r2)

  return 0 ;
811482f0:	0005883a 	mov	r2,zero

}
811482f4:	e037883a 	mov	sp,fp
811482f8:	df000017 	ldw	fp,0(sp)
811482fc:	dec00104 	addi	sp,sp,4
81148300:	f800283a 	ret

81148304 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81148304:	deffee04 	addi	sp,sp,-72
81148308:	de00012e 	bgeu	sp,et,81148310 <alt_msgdma_descriptor_async_transfer+0xc>
8114830c:	003b68fa 	trap	3
81148310:	dfc01115 	stw	ra,68(sp)
81148314:	df001015 	stw	fp,64(sp)
81148318:	df001004 	addi	fp,sp,64
8114831c:	e13ffd15 	stw	r4,-12(fp)
81148320:	e17ffe15 	stw	r5,-8(fp)
81148324:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81148328:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
8114832c:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
81148330:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81148334:	e0bffd17 	ldw	r2,-12(fp)
81148338:	10800317 	ldw	r2,12(r2)
8114833c:	10800204 	addi	r2,r2,8
81148340:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81148344:	10bfffcc 	andi	r2,r2,65535
81148348:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114834c:	e0bffd17 	ldw	r2,-12(fp)
81148350:	10800317 	ldw	r2,12(r2)
81148354:	10800204 	addi	r2,r2,8
81148358:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114835c:	1004d43a 	srli	r2,r2,16
81148360:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81148364:	e0bffd17 	ldw	r2,-12(fp)
81148368:	10800917 	ldw	r2,36(r2)
8114836c:	e0fff417 	ldw	r3,-48(fp)
81148370:	1880042e 	bgeu	r3,r2,81148384 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81148374:	e0bffd17 	ldw	r2,-12(fp)
81148378:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114837c:	e0fff317 	ldw	r3,-52(fp)
81148380:	18800236 	bltu	r3,r2,8114838c <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
81148384:	00bff904 	movi	r2,-28
81148388:	0000a906 	br	81148630 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
8114838c:	e0bffd17 	ldw	r2,-12(fp)
81148390:	10801817 	ldw	r2,96(r2)
81148394:	e0bff615 	stw	r2,-40(fp)
81148398:	e03ffc0d 	sth	zero,-16(fp)
8114839c:	e0bffc0b 	ldhu	r2,-16(fp)
811483a0:	e0fffc84 	addi	r3,fp,-14
811483a4:	180d883a 	mov	r6,r3
811483a8:	100b883a 	mov	r5,r2
811483ac:	e13ff617 	ldw	r4,-40(fp)
811483b0:	113e87c0 	call	8113e87c <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811483b4:	00800804 	movi	r2,32
811483b8:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811483bc:	0005303a 	rdctl	r2,status
811483c0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811483c4:	e0fff717 	ldw	r3,-36(fp)
811483c8:	00bfff84 	movi	r2,-2
811483cc:	1884703a 	and	r2,r3,r2
811483d0:	1001703a 	wrctl	status,r2
  
  return context;
811483d4:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811483d8:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811483dc:	e0bffd17 	ldw	r2,-12(fp)
811483e0:	10800317 	ldw	r2,12(r2)
811483e4:	10800104 	addi	r2,r2,4
811483e8:	e0fff117 	ldw	r3,-60(fp)
811483ec:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
811483f0:	e0bffd17 	ldw	r2,-12(fp)
811483f4:	10800317 	ldw	r2,12(r2)
811483f8:	e0fffd17 	ldw	r3,-12(fp)
811483fc:	18c00317 	ldw	r3,12(r3)
81148400:	18c00037 	ldwio	r3,0(r3)
81148404:	10c00035 	stwio	r3,0(r2)
81148408:	e0bff217 	ldw	r2,-56(fp)
8114840c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148410:	e0bffb17 	ldw	r2,-20(fp)
81148414:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81148418:	e0bffe17 	ldw	r2,-8(fp)
8114841c:	10001e26 	beq	r2,zero,81148498 <alt_msgdma_descriptor_async_transfer+0x194>
81148420:	e0bfff17 	ldw	r2,-4(fp)
81148424:	10001c1e 	bne	r2,zero,81148498 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81148428:	00001106 	br	81148470 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114842c:	01000044 	movi	r4,1
81148430:	11360040 	call	81136004 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148434:	e0bff00b 	ldhu	r2,-64(fp)
81148438:	1084e230 	cmpltui	r2,r2,5000
8114843c:	1000091e 	bne	r2,zero,81148464 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
81148440:	01204574 	movhi	r4,33045
81148444:	2103f204 	addi	r4,r4,4040
81148448:	114a7580 	call	8114a758 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114844c:	e0bffd17 	ldw	r2,-12(fp)
81148450:	10801817 	ldw	r2,96(r2)
81148454:	1009883a 	mov	r4,r2
81148458:	113ec040 	call	8113ec04 <OSSemPost>
				
                return -ETIME;
8114845c:	00bff084 	movi	r2,-62
81148460:	00007306 	br	81148630 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81148464:	e0bff00b 	ldhu	r2,-64(fp)
81148468:	10800044 	addi	r2,r2,1
8114846c:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81148470:	e0bffd17 	ldw	r2,-12(fp)
81148474:	10c00317 	ldw	r3,12(r2)
81148478:	e0bffd17 	ldw	r2,-12(fp)
8114847c:	10800417 	ldw	r2,16(r2)
81148480:	e1bffe17 	ldw	r6,-8(fp)
81148484:	100b883a 	mov	r5,r2
81148488:	1809883a 	mov	r4,r3
8114848c:	1147db80 	call	81147db8 <alt_msgdma_write_standard_descriptor>
81148490:	103fe61e 	bne	r2,zero,8114842c <__reset+0xfb12842c>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81148494:	00002706 	br	81148534 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81148498:	e0bffe17 	ldw	r2,-8(fp)
8114849c:	10001f1e 	bne	r2,zero,8114851c <alt_msgdma_descriptor_async_transfer+0x218>
811484a0:	e0bfff17 	ldw	r2,-4(fp)
811484a4:	10001d26 	beq	r2,zero,8114851c <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
811484a8:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811484ac:	00001106 	br	811484f4 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811484b0:	01000044 	movi	r4,1
811484b4:	11360040 	call	81136004 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811484b8:	e0bff00b 	ldhu	r2,-64(fp)
811484bc:	1084e230 	cmpltui	r2,r2,5000
811484c0:	1000091e 	bne	r2,zero,811484e8 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
811484c4:	01204574 	movhi	r4,33045
811484c8:	21040804 	addi	r4,r4,4128
811484cc:	114a7580 	call	8114a758 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811484d0:	e0bffd17 	ldw	r2,-12(fp)
811484d4:	10801817 	ldw	r2,96(r2)
811484d8:	1009883a 	mov	r4,r2
811484dc:	113ec040 	call	8113ec04 <OSSemPost>
				
                return -ETIME;
811484e0:	00bff084 	movi	r2,-62
811484e4:	00005206 	br	81148630 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811484e8:	e0bff00b 	ldhu	r2,-64(fp)
811484ec:	10800044 	addi	r2,r2,1
811484f0:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811484f4:	e0bffd17 	ldw	r2,-12(fp)
811484f8:	10c00317 	ldw	r3,12(r2)
811484fc:	e0bffd17 	ldw	r2,-12(fp)
81148500:	10800417 	ldw	r2,16(r2)
81148504:	e1bfff17 	ldw	r6,-4(fp)
81148508:	100b883a 	mov	r5,r2
8114850c:	1809883a 	mov	r4,r3
81148510:	1147e540 	call	81147e54 <alt_msgdma_write_extended_descriptor>
81148514:	103fe61e 	bne	r2,zero,811484b0 <__reset+0xfb1284b0>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81148518:	00000606 	br	81148534 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
8114851c:	e0bffd17 	ldw	r2,-12(fp)
81148520:	10801817 	ldw	r2,96(r2)
81148524:	1009883a 	mov	r4,r2
81148528:	113ec040 	call	8113ec04 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
8114852c:	00bfffc4 	movi	r2,-1
81148530:	00003f06 	br	81148630 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
81148534:	e0bffd17 	ldw	r2,-12(fp)
81148538:	10800b17 	ldw	r2,44(r2)
8114853c:	10001c26 	beq	r2,zero,811485b0 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81148540:	e0bffd17 	ldw	r2,-12(fp)
81148544:	10c00d17 	ldw	r3,52(r2)
81148548:	e0bff117 	ldw	r2,-60(fp)
8114854c:	1884b03a 	or	r2,r3,r2
81148550:	10800514 	ori	r2,r2,20
81148554:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81148558:	e0fff117 	ldw	r3,-60(fp)
8114855c:	00bff7c4 	movi	r2,-33
81148560:	1884703a 	and	r2,r3,r2
81148564:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148568:	0005303a 	rdctl	r2,status
8114856c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148570:	e0fff917 	ldw	r3,-28(fp)
81148574:	00bfff84 	movi	r2,-2
81148578:	1884703a 	and	r2,r3,r2
8114857c:	1001703a 	wrctl	status,r2
  
  return context;
81148580:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81148584:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81148588:	e0bffd17 	ldw	r2,-12(fp)
8114858c:	10800317 	ldw	r2,12(r2)
81148590:	10800104 	addi	r2,r2,4
81148594:	e0fff117 	ldw	r3,-60(fp)
81148598:	10c00035 	stwio	r3,0(r2)
8114859c:	e0bff217 	ldw	r2,-56(fp)
811485a0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811485a4:	e0bff517 	ldw	r2,-44(fp)
811485a8:	1001703a 	wrctl	status,r2
811485ac:	00001b06 	br	8114861c <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
811485b0:	e0bffd17 	ldw	r2,-12(fp)
811485b4:	10c00d17 	ldw	r3,52(r2)
811485b8:	e0bff117 	ldw	r2,-60(fp)
811485bc:	1884b03a 	or	r2,r3,r2
811485c0:	10800114 	ori	r2,r2,4
811485c4:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
811485c8:	e0fff117 	ldw	r3,-60(fp)
811485cc:	00bff3c4 	movi	r2,-49
811485d0:	1884703a 	and	r2,r3,r2
811485d4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811485d8:	0005303a 	rdctl	r2,status
811485dc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811485e0:	e0fffa17 	ldw	r3,-24(fp)
811485e4:	00bfff84 	movi	r2,-2
811485e8:	1884703a 	and	r2,r3,r2
811485ec:	1001703a 	wrctl	status,r2
  
  return context;
811485f0:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
811485f4:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811485f8:	e0bffd17 	ldw	r2,-12(fp)
811485fc:	10800317 	ldw	r2,12(r2)
81148600:	10800104 	addi	r2,r2,4
81148604:	e0fff117 	ldw	r3,-60(fp)
81148608:	10c00035 	stwio	r3,0(r2)
8114860c:	e0bff217 	ldw	r2,-56(fp)
81148610:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148614:	e0bff817 	ldw	r2,-32(fp)
81148618:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
8114861c:	e0bffd17 	ldw	r2,-12(fp)
81148620:	10801817 	ldw	r2,96(r2)
81148624:	1009883a 	mov	r4,r2
81148628:	113ec040 	call	8113ec04 <OSSemPost>
    
    return 0;
8114862c:	0005883a 	mov	r2,zero
}
81148630:	e037883a 	mov	sp,fp
81148634:	dfc00117 	ldw	ra,4(sp)
81148638:	df000017 	ldw	fp,0(sp)
8114863c:	dec00204 	addi	sp,sp,8
81148640:	f800283a 	ret

81148644 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81148644:	deffee04 	addi	sp,sp,-72
81148648:	de00012e 	bgeu	sp,et,81148650 <alt_msgdma_descriptor_sync_transfer+0xc>
8114864c:	003b68fa 	trap	3
81148650:	dfc01115 	stw	ra,68(sp)
81148654:	df001015 	stw	fp,64(sp)
81148658:	df001004 	addi	fp,sp,64
8114865c:	e13ffd15 	stw	r4,-12(fp)
81148660:	e17ffe15 	stw	r5,-8(fp)
81148664:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81148668:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
8114866c:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
81148670:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81148674:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81148678:	e0bffd17 	ldw	r2,-12(fp)
8114867c:	10800317 	ldw	r2,12(r2)
81148680:	10800204 	addi	r2,r2,8
81148684:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81148688:	10bfffcc 	andi	r2,r2,65535
8114868c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81148690:	e0bffd17 	ldw	r2,-12(fp)
81148694:	10800317 	ldw	r2,12(r2)
81148698:	10800204 	addi	r2,r2,8
8114869c:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811486a0:	1004d43a 	srli	r2,r2,16
811486a4:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
811486a8:	00807804 	movi	r2,480
811486ac:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811486b0:	00001906 	br	81148718 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
811486b4:	01000044 	movi	r4,1
811486b8:	11360040 	call	81136004 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811486bc:	e0bff10b 	ldhu	r2,-60(fp)
811486c0:	1084e230 	cmpltui	r2,r2,5000
811486c4:	1000051e 	bne	r2,zero,811486dc <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
811486c8:	01204574 	movhi	r4,33045
811486cc:	21041e04 	addi	r4,r4,4216
811486d0:	114a7580 	call	8114a758 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
811486d4:	00bff084 	movi	r2,-62
811486d8:	0000d706 	br	81148a38 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
811486dc:	e0bff10b 	ldhu	r2,-60(fp)
811486e0:	10800044 	addi	r2,r2,1
811486e4:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811486e8:	e0bffd17 	ldw	r2,-12(fp)
811486ec:	10800317 	ldw	r2,12(r2)
811486f0:	10800204 	addi	r2,r2,8
811486f4:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
811486f8:	10bfffcc 	andi	r2,r2,65535
811486fc:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81148700:	e0bffd17 	ldw	r2,-12(fp)
81148704:	10800317 	ldw	r2,12(r2)
81148708:	10800204 	addi	r2,r2,8
8114870c:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81148710:	1004d43a 	srli	r2,r2,16
81148714:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81148718:	e0bffd17 	ldw	r2,-12(fp)
8114871c:	10800917 	ldw	r2,36(r2)
81148720:	e0fff317 	ldw	r3,-52(fp)
81148724:	18bfe32e 	bgeu	r3,r2,811486b4 <__reset+0xfb1286b4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81148728:	e0bffd17 	ldw	r2,-12(fp)
8114872c:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81148730:	e0fff217 	ldw	r3,-56(fp)
81148734:	18bfdf2e 	bgeu	r3,r2,811486b4 <__reset+0xfb1286b4>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81148738:	e0bffd17 	ldw	r2,-12(fp)
8114873c:	10801817 	ldw	r2,96(r2)
81148740:	e0bff815 	stw	r2,-32(fp)
81148744:	e03ffc0d 	sth	zero,-16(fp)
81148748:	e0bffc0b 	ldhu	r2,-16(fp)
8114874c:	e0fffc84 	addi	r3,fp,-14
81148750:	180d883a 	mov	r6,r3
81148754:	100b883a 	mov	r5,r2
81148758:	e13ff817 	ldw	r4,-32(fp)
8114875c:	113e87c0 	call	8113e87c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148760:	0005303a 	rdctl	r2,status
81148764:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148768:	e0fffb17 	ldw	r3,-20(fp)
8114876c:	00bfff84 	movi	r2,-2
81148770:	1884703a 	and	r2,r3,r2
81148774:	1001703a 	wrctl	status,r2
  
  return context;
81148778:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
8114877c:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81148780:	e0bffd17 	ldw	r2,-12(fp)
81148784:	10800317 	ldw	r2,12(r2)
81148788:	10800104 	addi	r2,r2,4
8114878c:	00c00804 	movi	r3,32
81148790:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81148794:	e0bffd17 	ldw	r2,-12(fp)
81148798:	10800317 	ldw	r2,12(r2)
8114879c:	e0fffd17 	ldw	r3,-12(fp)
811487a0:	18c00317 	ldw	r3,12(r3)
811487a4:	18c00037 	ldwio	r3,0(r3)
811487a8:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
811487ac:	e0bffe17 	ldw	r2,-8(fp)
811487b0:	10001f26 	beq	r2,zero,81148830 <alt_msgdma_descriptor_sync_transfer+0x1ec>
811487b4:	e0bfff17 	ldw	r2,-4(fp)
811487b8:	10001d1e 	bne	r2,zero,81148830 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
811487bc:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811487c0:	00001106 	br	81148808 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
811487c4:	01000044 	movi	r4,1
811487c8:	11360040 	call	81136004 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811487cc:	e0bff10b 	ldhu	r2,-60(fp)
811487d0:	1084e230 	cmpltui	r2,r2,5000
811487d4:	1000091e 	bne	r2,zero,811487fc <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
811487d8:	01204574 	movhi	r4,33045
811487dc:	21043204 	addi	r4,r4,4296
811487e0:	114a7580 	call	8114a758 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811487e4:	e0bffd17 	ldw	r2,-12(fp)
811487e8:	10801817 	ldw	r2,96(r2)
811487ec:	1009883a 	mov	r4,r2
811487f0:	113ec040 	call	8113ec04 <OSSemPost>
				
                return -ETIME;
811487f4:	00bff084 	movi	r2,-62
811487f8:	00008f06 	br	81148a38 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
811487fc:	e0bff10b 	ldhu	r2,-60(fp)
81148800:	10800044 	addi	r2,r2,1
81148804:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81148808:	e0bffd17 	ldw	r2,-12(fp)
8114880c:	10c00317 	ldw	r3,12(r2)
81148810:	e0bffd17 	ldw	r2,-12(fp)
81148814:	10800417 	ldw	r2,16(r2)
81148818:	e1bffe17 	ldw	r6,-8(fp)
8114881c:	100b883a 	mov	r5,r2
81148820:	1809883a 	mov	r4,r3
81148824:	1147db80 	call	81147db8 <alt_msgdma_write_standard_descriptor>
81148828:	103fe61e 	bne	r2,zero,811487c4 <__reset+0xfb1287c4>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
8114882c:	00002706 	br	811488cc <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81148830:	e0bffe17 	ldw	r2,-8(fp)
81148834:	10001f1e 	bne	r2,zero,811488b4 <alt_msgdma_descriptor_sync_transfer+0x270>
81148838:	e0bfff17 	ldw	r2,-4(fp)
8114883c:	10001d26 	beq	r2,zero,811488b4 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81148840:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81148844:	00001106 	br	8114888c <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81148848:	01000044 	movi	r4,1
8114884c:	11360040 	call	81136004 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148850:	e0bff10b 	ldhu	r2,-60(fp)
81148854:	1084e230 	cmpltui	r2,r2,5000
81148858:	1000091e 	bne	r2,zero,81148880 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
8114885c:	01204574 	movhi	r4,33045
81148860:	21044304 	addi	r4,r4,4364
81148864:	114a7580 	call	8114a758 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81148868:	e0bffd17 	ldw	r2,-12(fp)
8114886c:	10801817 	ldw	r2,96(r2)
81148870:	1009883a 	mov	r4,r2
81148874:	113ec040 	call	8113ec04 <OSSemPost>
				
                return -ETIME;
81148878:	00bff084 	movi	r2,-62
8114887c:	00006e06 	br	81148a38 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
81148880:	e0bff10b 	ldhu	r2,-60(fp)
81148884:	10800044 	addi	r2,r2,1
81148888:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114888c:	e0bffd17 	ldw	r2,-12(fp)
81148890:	10c00317 	ldw	r3,12(r2)
81148894:	e0bffd17 	ldw	r2,-12(fp)
81148898:	10800417 	ldw	r2,16(r2)
8114889c:	e1bfff17 	ldw	r6,-4(fp)
811488a0:	100b883a 	mov	r5,r2
811488a4:	1809883a 	mov	r4,r3
811488a8:	1147e540 	call	81147e54 <alt_msgdma_write_extended_descriptor>
811488ac:	103fe61e 	bne	r2,zero,81148848 <__reset+0xfb128848>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811488b0:	00000606 	br	811488cc <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811488b4:	e0bffd17 	ldw	r2,-12(fp)
811488b8:	10801817 	ldw	r2,96(r2)
811488bc:	1009883a 	mov	r4,r2
811488c0:	113ec040 	call	8113ec04 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
811488c4:	00bfffc4 	movi	r2,-1
811488c8:	00005b06 	br	81148a38 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811488cc:	e0bffd17 	ldw	r2,-12(fp)
811488d0:	10800317 	ldw	r2,12(r2)
811488d4:	10800104 	addi	r2,r2,4
811488d8:	e0fffd17 	ldw	r3,-12(fp)
811488dc:	19000d17 	ldw	r4,52(r3)
811488e0:	00fff2c4 	movi	r3,-53
811488e4:	20c6703a 	and	r3,r4,r3
811488e8:	18c00114 	ori	r3,r3,4
811488ec:	10c00035 	stwio	r3,0(r2)
811488f0:	e0bff517 	ldw	r2,-44(fp)
811488f4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811488f8:	e0bff717 	ldw	r2,-36(fp)
811488fc:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81148900:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81148904:	e0bffd17 	ldw	r2,-12(fp)
81148908:	10800317 	ldw	r2,12(r2)
8114890c:	10800037 	ldwio	r2,0(r2)
81148910:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81148914:	00001506 	br	8114896c <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81148918:	01000044 	movi	r4,1
8114891c:	11360040 	call	81136004 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81148920:	e0bff10b 	ldhu	r2,-60(fp)
81148924:	1084e230 	cmpltui	r2,r2,5000
81148928:	1000091e 	bne	r2,zero,81148950 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
8114892c:	01204574 	movhi	r4,33045
81148930:	21045404 	addi	r4,r4,4432
81148934:	114a7580 	call	8114a758 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81148938:	e0bffd17 	ldw	r2,-12(fp)
8114893c:	10801817 	ldw	r2,96(r2)
81148940:	1009883a 	mov	r4,r2
81148944:	113ec040 	call	8113ec04 <OSSemPost>
			
            return -ETIME;
81148948:	00bff084 	movi	r2,-62
8114894c:	00003a06 	br	81148a38 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81148950:	e0bff10b 	ldhu	r2,-60(fp)
81148954:	10800044 	addi	r2,r2,1
81148958:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8114895c:	e0bffd17 	ldw	r2,-12(fp)
81148960:	10800317 	ldw	r2,12(r2)
81148964:	10800037 	ldwio	r2,0(r2)
81148968:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
8114896c:	e0fff017 	ldw	r3,-64(fp)
81148970:	e0bff617 	ldw	r2,-40(fp)
81148974:	1884703a 	and	r2,r3,r2
81148978:	1000031e 	bne	r2,zero,81148988 <alt_msgdma_descriptor_sync_transfer+0x344>
8114897c:	e0bff017 	ldw	r2,-64(fp)
81148980:	1080004c 	andi	r2,r2,1
81148984:	103fe41e 	bne	r2,zero,81148918 <__reset+0xfb128918>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81148988:	e0fff017 	ldw	r3,-64(fp)
8114898c:	e0bff617 	ldw	r2,-40(fp)
81148990:	1884703a 	and	r2,r3,r2
81148994:	10000626 	beq	r2,zero,811489b0 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81148998:	e0bffd17 	ldw	r2,-12(fp)
8114899c:	10801817 	ldw	r2,96(r2)
811489a0:	1009883a 	mov	r4,r2
811489a4:	113ec040 	call	8113ec04 <OSSemPost>
		
        return error;
811489a8:	e0bff617 	ldw	r2,-40(fp)
811489ac:	00002206 	br	81148a38 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
811489b0:	e0bffd17 	ldw	r2,-12(fp)
811489b4:	10800317 	ldw	r2,12(r2)
811489b8:	10800104 	addi	r2,r2,4
811489bc:	10800037 	ldwio	r2,0(r2)
811489c0:	10800814 	ori	r2,r2,32
811489c4:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811489c8:	0005303a 	rdctl	r2,status
811489cc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811489d0:	e0fffa17 	ldw	r3,-24(fp)
811489d4:	00bfff84 	movi	r2,-2
811489d8:	1884703a 	and	r2,r3,r2
811489dc:	1001703a 	wrctl	status,r2
  
  return context;
811489e0:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
811489e4:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811489e8:	e0bffd17 	ldw	r2,-12(fp)
811489ec:	10800317 	ldw	r2,12(r2)
811489f0:	10800104 	addi	r2,r2,4
811489f4:	e0fff417 	ldw	r3,-48(fp)
811489f8:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
811489fc:	e0bffd17 	ldw	r2,-12(fp)
81148a00:	10800317 	ldw	r2,12(r2)
81148a04:	e0fffd17 	ldw	r3,-12(fp)
81148a08:	18c00317 	ldw	r3,12(r3)
81148a0c:	18c00037 	ldwio	r3,0(r3)
81148a10:	10c00035 	stwio	r3,0(r2)
81148a14:	e0bff517 	ldw	r2,-44(fp)
81148a18:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148a1c:	e0bff917 	ldw	r2,-28(fp)
81148a20:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81148a24:	e0bffd17 	ldw	r2,-12(fp)
81148a28:	10801817 	ldw	r2,96(r2)
81148a2c:	1009883a 	mov	r4,r2
81148a30:	113ec040 	call	8113ec04 <OSSemPost>
    
    return 0;
81148a34:	0005883a 	mov	r2,zero

}
81148a38:	e037883a 	mov	sp,fp
81148a3c:	dfc00117 	ldw	ra,4(sp)
81148a40:	df000017 	ldw	fp,0(sp)
81148a44:	dec00204 	addi	sp,sp,8
81148a48:	f800283a 	ret

81148a4c <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81148a4c:	defff804 	addi	sp,sp,-32
81148a50:	de00012e 	bgeu	sp,et,81148a58 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81148a54:	003b68fa 	trap	3
81148a58:	dfc00715 	stw	ra,28(sp)
81148a5c:	df000615 	stw	fp,24(sp)
81148a60:	df000604 	addi	fp,sp,24
81148a64:	e13ffc15 	stw	r4,-16(fp)
81148a68:	e17ffd15 	stw	r5,-12(fp)
81148a6c:	e1bffe15 	stw	r6,-8(fp)
81148a70:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81148a74:	e0800217 	ldw	r2,8(fp)
81148a78:	d8800115 	stw	r2,4(sp)
81148a7c:	e0bfff17 	ldw	r2,-4(fp)
81148a80:	d8800015 	stw	r2,0(sp)
81148a84:	e1fffe17 	ldw	r7,-8(fp)
81148a88:	000d883a 	mov	r6,zero
81148a8c:	e17ffd17 	ldw	r5,-12(fp)
81148a90:	e13ffc17 	ldw	r4,-16(fp)
81148a94:	11481140 	call	81148114 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81148a98:	e037883a 	mov	sp,fp
81148a9c:	dfc00117 	ldw	ra,4(sp)
81148aa0:	df000017 	ldw	fp,0(sp)
81148aa4:	dec00204 	addi	sp,sp,8
81148aa8:	f800283a 	ret

81148aac <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81148aac:	defff804 	addi	sp,sp,-32
81148ab0:	de00012e 	bgeu	sp,et,81148ab8 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81148ab4:	003b68fa 	trap	3
81148ab8:	dfc00715 	stw	ra,28(sp)
81148abc:	df000615 	stw	fp,24(sp)
81148ac0:	df000604 	addi	fp,sp,24
81148ac4:	e13ffc15 	stw	r4,-16(fp)
81148ac8:	e17ffd15 	stw	r5,-12(fp)
81148acc:	e1bffe15 	stw	r6,-8(fp)
81148ad0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81148ad4:	e0800217 	ldw	r2,8(fp)
81148ad8:	d8800115 	stw	r2,4(sp)
81148adc:	e0bfff17 	ldw	r2,-4(fp)
81148ae0:	d8800015 	stw	r2,0(sp)
81148ae4:	000f883a 	mov	r7,zero
81148ae8:	e1bffe17 	ldw	r6,-8(fp)
81148aec:	e17ffd17 	ldw	r5,-12(fp)
81148af0:	e13ffc17 	ldw	r4,-16(fp)
81148af4:	11481140 	call	81148114 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81148af8:	e037883a 	mov	sp,fp
81148afc:	dfc00117 	ldw	ra,4(sp)
81148b00:	df000017 	ldw	fp,0(sp)
81148b04:	dec00204 	addi	sp,sp,8
81148b08:	f800283a 	ret

81148b0c <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148b0c:	defff804 	addi	sp,sp,-32
81148b10:	de00012e 	bgeu	sp,et,81148b18 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81148b14:	003b68fa 	trap	3
81148b18:	dfc00715 	stw	ra,28(sp)
81148b1c:	df000615 	stw	fp,24(sp)
81148b20:	df000604 	addi	fp,sp,24
81148b24:	e13ffc15 	stw	r4,-16(fp)
81148b28:	e17ffd15 	stw	r5,-12(fp)
81148b2c:	e1bffe15 	stw	r6,-8(fp)
81148b30:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81148b34:	e0800317 	ldw	r2,12(fp)
81148b38:	d8800115 	stw	r2,4(sp)
81148b3c:	e0800217 	ldw	r2,8(fp)
81148b40:	d8800015 	stw	r2,0(sp)
81148b44:	e1ffff17 	ldw	r7,-4(fp)
81148b48:	e1bffe17 	ldw	r6,-8(fp)
81148b4c:	e17ffd17 	ldw	r5,-12(fp)
81148b50:	e13ffc17 	ldw	r4,-16(fp)
81148b54:	11481140 	call	81148114 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81148b58:	e037883a 	mov	sp,fp
81148b5c:	dfc00117 	ldw	ra,4(sp)
81148b60:	df000017 	ldw	fp,0(sp)
81148b64:	dec00204 	addi	sp,sp,8
81148b68:	f800283a 	ret

81148b6c <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81148b6c:	defff004 	addi	sp,sp,-64
81148b70:	de00012e 	bgeu	sp,et,81148b78 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81148b74:	003b68fa 	trap	3
81148b78:	dfc00f15 	stw	ra,60(sp)
81148b7c:	df000e15 	stw	fp,56(sp)
81148b80:	df000e04 	addi	fp,sp,56
81148b84:	e13ff915 	stw	r4,-28(fp)
81148b88:	e17ffa15 	stw	r5,-24(fp)
81148b8c:	e1bffb15 	stw	r6,-20(fp)
81148b90:	e1fffc15 	stw	r7,-16(fp)
81148b94:	e1000317 	ldw	r4,12(fp)
81148b98:	e0c00417 	ldw	r3,16(fp)
81148b9c:	e0800517 	ldw	r2,20(fp)
81148ba0:	e13ffd0d 	sth	r4,-12(fp)
81148ba4:	e0fffe05 	stb	r3,-8(fp)
81148ba8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81148bac:	e0bffd0b 	ldhu	r2,-12(fp)
81148bb0:	e0fffe03 	ldbu	r3,-8(fp)
81148bb4:	e13fff0b 	ldhu	r4,-4(fp)
81148bb8:	d9000615 	stw	r4,24(sp)
81148bbc:	d8000515 	stw	zero,20(sp)
81148bc0:	d8c00415 	stw	r3,16(sp)
81148bc4:	d8000315 	stw	zero,12(sp)
81148bc8:	d8800215 	stw	r2,8(sp)
81148bcc:	e0800217 	ldw	r2,8(fp)
81148bd0:	d8800115 	stw	r2,4(sp)
81148bd4:	e0bffc17 	ldw	r2,-16(fp)
81148bd8:	d8800015 	stw	r2,0(sp)
81148bdc:	e1fffb17 	ldw	r7,-20(fp)
81148be0:	000d883a 	mov	r6,zero
81148be4:	e17ffa17 	ldw	r5,-24(fp)
81148be8:	e13ff917 	ldw	r4,-28(fp)
81148bec:	11481a80 	call	811481a8 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81148bf0:	e037883a 	mov	sp,fp
81148bf4:	dfc00117 	ldw	ra,4(sp)
81148bf8:	df000017 	ldw	fp,0(sp)
81148bfc:	dec00204 	addi	sp,sp,8
81148c00:	f800283a 	ret

81148c04 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81148c04:	defff004 	addi	sp,sp,-64
81148c08:	de00012e 	bgeu	sp,et,81148c10 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81148c0c:	003b68fa 	trap	3
81148c10:	dfc00f15 	stw	ra,60(sp)
81148c14:	df000e15 	stw	fp,56(sp)
81148c18:	df000e04 	addi	fp,sp,56
81148c1c:	e13ff915 	stw	r4,-28(fp)
81148c20:	e17ffa15 	stw	r5,-24(fp)
81148c24:	e1bffb15 	stw	r6,-20(fp)
81148c28:	e1fffc15 	stw	r7,-16(fp)
81148c2c:	e1000317 	ldw	r4,12(fp)
81148c30:	e0c00417 	ldw	r3,16(fp)
81148c34:	e0800517 	ldw	r2,20(fp)
81148c38:	e13ffd0d 	sth	r4,-12(fp)
81148c3c:	e0fffe05 	stb	r3,-8(fp)
81148c40:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81148c44:	e0bffd0b 	ldhu	r2,-12(fp)
81148c48:	e0fffe03 	ldbu	r3,-8(fp)
81148c4c:	e13fff0b 	ldhu	r4,-4(fp)
81148c50:	d8000615 	stw	zero,24(sp)
81148c54:	d9000515 	stw	r4,20(sp)
81148c58:	d8000415 	stw	zero,16(sp)
81148c5c:	d8c00315 	stw	r3,12(sp)
81148c60:	d8800215 	stw	r2,8(sp)
81148c64:	e0800217 	ldw	r2,8(fp)
81148c68:	d8800115 	stw	r2,4(sp)
81148c6c:	e0bffc17 	ldw	r2,-16(fp)
81148c70:	d8800015 	stw	r2,0(sp)
81148c74:	000f883a 	mov	r7,zero
81148c78:	e1bffb17 	ldw	r6,-20(fp)
81148c7c:	e17ffa17 	ldw	r5,-24(fp)
81148c80:	e13ff917 	ldw	r4,-28(fp)
81148c84:	11481a80 	call	811481a8 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81148c88:	e037883a 	mov	sp,fp
81148c8c:	dfc00117 	ldw	ra,4(sp)
81148c90:	df000017 	ldw	fp,0(sp)
81148c94:	dec00204 	addi	sp,sp,8
81148c98:	f800283a 	ret

81148c9c <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81148c9c:	deffee04 	addi	sp,sp,-72
81148ca0:	de00012e 	bgeu	sp,et,81148ca8 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81148ca4:	003b68fa 	trap	3
81148ca8:	dfc01115 	stw	ra,68(sp)
81148cac:	df001015 	stw	fp,64(sp)
81148cb0:	df001004 	addi	fp,sp,64
81148cb4:	e13ff715 	stw	r4,-36(fp)
81148cb8:	e17ff815 	stw	r5,-32(fp)
81148cbc:	e1bff915 	stw	r6,-28(fp)
81148cc0:	e1fffa15 	stw	r7,-24(fp)
81148cc4:	e1800417 	ldw	r6,16(fp)
81148cc8:	e1400517 	ldw	r5,20(fp)
81148ccc:	e1000617 	ldw	r4,24(fp)
81148cd0:	e0c00717 	ldw	r3,28(fp)
81148cd4:	e0800817 	ldw	r2,32(fp)
81148cd8:	e1bffb0d 	sth	r6,-20(fp)
81148cdc:	e17ffc05 	stb	r5,-16(fp)
81148ce0:	e13ffd05 	stb	r4,-12(fp)
81148ce4:	e0fffe0d 	sth	r3,-8(fp)
81148ce8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81148cec:	e0bffb0b 	ldhu	r2,-20(fp)
81148cf0:	e0fffc03 	ldbu	r3,-16(fp)
81148cf4:	e13ffd03 	ldbu	r4,-12(fp)
81148cf8:	e17ffe0b 	ldhu	r5,-8(fp)
81148cfc:	e1bfff0b 	ldhu	r6,-4(fp)
81148d00:	d9800615 	stw	r6,24(sp)
81148d04:	d9400515 	stw	r5,20(sp)
81148d08:	d9000415 	stw	r4,16(sp)
81148d0c:	d8c00315 	stw	r3,12(sp)
81148d10:	d8800215 	stw	r2,8(sp)
81148d14:	e0800317 	ldw	r2,12(fp)
81148d18:	d8800115 	stw	r2,4(sp)
81148d1c:	e0800217 	ldw	r2,8(fp)
81148d20:	d8800015 	stw	r2,0(sp)
81148d24:	e1fffa17 	ldw	r7,-24(fp)
81148d28:	e1bff917 	ldw	r6,-28(fp)
81148d2c:	e17ff817 	ldw	r5,-32(fp)
81148d30:	e13ff717 	ldw	r4,-36(fp)
81148d34:	11481a80 	call	811481a8 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81148d38:	e037883a 	mov	sp,fp
81148d3c:	dfc00117 	ldw	ra,4(sp)
81148d40:	df000017 	ldw	fp,0(sp)
81148d44:	dec00204 	addi	sp,sp,8
81148d48:	f800283a 	ret

81148d4c <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148d4c:	defffb04 	addi	sp,sp,-20
81148d50:	de00012e 	bgeu	sp,et,81148d58 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81148d54:	003b68fa 	trap	3
81148d58:	df000415 	stw	fp,16(sp)
81148d5c:	df000404 	addi	fp,sp,16
81148d60:	e13ffc15 	stw	r4,-16(fp)
81148d64:	e17ffd15 	stw	r5,-12(fp)
81148d68:	e1bffe15 	stw	r6,-8(fp)
81148d6c:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81148d70:	e0bffc17 	ldw	r2,-16(fp)
81148d74:	10c01217 	ldw	r3,72(r2)
81148d78:	e0800117 	ldw	r2,4(fp)
81148d7c:	18800436 	bltu	r3,r2,81148d90 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
81148d80:	e0bffc17 	ldw	r2,-16(fp)
81148d84:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81148d88:	10803fcc 	andi	r2,r2,255
81148d8c:	10000226 	beq	r2,zero,81148d98 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81148d90:	00bffa84 	movi	r2,-22
81148d94:	00001406 	br	81148de8 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81148d98:	e0bffd17 	ldw	r2,-12(fp)
81148d9c:	e0fffe17 	ldw	r3,-8(fp)
81148da0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81148da4:	e0bffd17 	ldw	r2,-12(fp)
81148da8:	e0ffff17 	ldw	r3,-4(fp)
81148dac:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148db0:	e0bffd17 	ldw	r2,-12(fp)
81148db4:	e0c00117 	ldw	r3,4(fp)
81148db8:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81148dbc:	e0fffd17 	ldw	r3,-12(fp)
81148dc0:	e0bffd17 	ldw	r2,-12(fp)
81148dc4:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81148dc8:	e0c00217 	ldw	r3,8(fp)
81148dcc:	00900034 	movhi	r2,16384
81148dd0:	10bfffc4 	addi	r2,r2,-1
81148dd4:	1884703a 	and	r2,r3,r2
81148dd8:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81148ddc:	e0bffd17 	ldw	r2,-12(fp)
81148de0:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81148de4:	0005883a 	mov	r2,zero
}
81148de8:	e037883a 	mov	sp,fp
81148dec:	df000017 	ldw	fp,0(sp)
81148df0:	dec00104 	addi	sp,sp,4
81148df4:	f800283a 	ret

81148df8 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81148df8:	defff404 	addi	sp,sp,-48
81148dfc:	de00012e 	bgeu	sp,et,81148e04 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81148e00:	003b68fa 	trap	3
81148e04:	df000b15 	stw	fp,44(sp)
81148e08:	df000b04 	addi	fp,sp,44
81148e0c:	e13ff715 	stw	r4,-36(fp)
81148e10:	e17ff815 	stw	r5,-32(fp)
81148e14:	e1bff915 	stw	r6,-28(fp)
81148e18:	e1fffa15 	stw	r7,-24(fp)
81148e1c:	e1800517 	ldw	r6,20(fp)
81148e20:	e1400617 	ldw	r5,24(fp)
81148e24:	e1000717 	ldw	r4,28(fp)
81148e28:	e0c00817 	ldw	r3,32(fp)
81148e2c:	e0800917 	ldw	r2,36(fp)
81148e30:	e1bffb0d 	sth	r6,-20(fp)
81148e34:	e17ffc05 	stb	r5,-16(fp)
81148e38:	e13ffd05 	stb	r4,-12(fp)
81148e3c:	e0fffe0d 	sth	r3,-8(fp)
81148e40:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81148e44:	e0bff717 	ldw	r2,-36(fp)
81148e48:	10c01217 	ldw	r3,72(r2)
81148e4c:	e0800317 	ldw	r2,12(fp)
81148e50:	18801936 	bltu	r3,r2,81148eb8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81148e54:	e13ff717 	ldw	r4,-36(fp)
81148e58:	20801317 	ldw	r2,76(r4)
81148e5c:	20c01417 	ldw	r3,80(r4)
81148e60:	e13ffe0b 	ldhu	r4,-8(fp)
81148e64:	213fffcc 	andi	r4,r4,65535
81148e68:	2015883a 	mov	r10,r4
81148e6c:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81148e70:	1ac01136 	bltu	r3,r11,81148eb8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81148e74:	58c0011e 	bne	r11,r3,81148e7c <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81148e78:	12800f36 	bltu	r2,r10,81148eb8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81148e7c:	e13ff717 	ldw	r4,-36(fp)
81148e80:	20801317 	ldw	r2,76(r4)
81148e84:	20c01417 	ldw	r3,80(r4)
81148e88:	e13fff0b 	ldhu	r4,-4(fp)
81148e8c:	213fffcc 	andi	r4,r4,65535
81148e90:	2011883a 	mov	r8,r4
81148e94:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81148e98:	1a400736 	bltu	r3,r9,81148eb8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81148e9c:	48c0011e 	bne	r9,r3,81148ea4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
81148ea0:	12000536 	bltu	r2,r8,81148eb8 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81148ea4:	e0bff717 	ldw	r2,-36(fp)
81148ea8:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81148eac:	10803fcc 	andi	r2,r2,255
81148eb0:	10800060 	cmpeqi	r2,r2,1
81148eb4:	1000021e 	bne	r2,zero,81148ec0 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81148eb8:	00bffa84 	movi	r2,-22
81148ebc:	00003106 	br	81148f84 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
81148ec0:	e0bff817 	ldw	r2,-32(fp)
81148ec4:	e0fff917 	ldw	r3,-28(fp)
81148ec8:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81148ecc:	e0bff817 	ldw	r2,-32(fp)
81148ed0:	e0fffa17 	ldw	r3,-24(fp)
81148ed4:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81148ed8:	e0bff817 	ldw	r2,-32(fp)
81148edc:	e0c00117 	ldw	r3,4(fp)
81148ee0:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81148ee4:	e0bff817 	ldw	r2,-32(fp)
81148ee8:	e0c00217 	ldw	r3,8(fp)
81148eec:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148ef0:	e0bff817 	ldw	r2,-32(fp)
81148ef4:	e0c00317 	ldw	r3,12(fp)
81148ef8:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81148efc:	e0bff817 	ldw	r2,-32(fp)
81148f00:	e0fffb0b 	ldhu	r3,-20(fp)
81148f04:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81148f08:	e0bff817 	ldw	r2,-32(fp)
81148f0c:	e0fffc03 	ldbu	r3,-16(fp)
81148f10:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
81148f14:	e0bff817 	ldw	r2,-32(fp)
81148f18:	e0fffd03 	ldbu	r3,-12(fp)
81148f1c:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
81148f20:	e0bff817 	ldw	r2,-32(fp)
81148f24:	e0fffe0b 	ldhu	r3,-8(fp)
81148f28:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
81148f2c:	e0bff817 	ldw	r2,-32(fp)
81148f30:	e0ffff0b 	ldhu	r3,-4(fp)
81148f34:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
81148f38:	e0bff817 	ldw	r2,-32(fp)
81148f3c:	1019883a 	mov	r12,r2
81148f40:	001b883a 	mov	r13,zero
81148f44:	e33ff515 	stw	r12,-44(fp)
81148f48:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
81148f4c:	e0fff517 	ldw	r3,-44(fp)
81148f50:	e0bff817 	ldw	r2,-32(fp)
81148f54:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
81148f58:	e0fff617 	ldw	r3,-40(fp)
81148f5c:	e0bff817 	ldw	r2,-32(fp)
81148f60:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81148f64:	e0c00417 	ldw	r3,16(fp)
81148f68:	00900034 	movhi	r2,16384
81148f6c:	10bfffc4 	addi	r2,r2,-1
81148f70:	1884703a 	and	r2,r3,r2
81148f74:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
81148f78:	e0bff817 	ldw	r2,-32(fp)
81148f7c:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
81148f80:	0005883a 	mov	r2,zero
}
81148f84:	e037883a 	mov	sp,fp
81148f88:	df000017 	ldw	fp,0(sp)
81148f8c:	dec00104 	addi	sp,sp,4
81148f90:	f800283a 	ret

81148f94 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
81148f94:	defff804 	addi	sp,sp,-32
81148f98:	de00012e 	bgeu	sp,et,81148fa0 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81148f9c:	003b68fa 	trap	3
81148fa0:	dfc00715 	stw	ra,28(sp)
81148fa4:	df000615 	stw	fp,24(sp)
81148fa8:	df000604 	addi	fp,sp,24
81148fac:	e13ffc15 	stw	r4,-16(fp)
81148fb0:	e17ffd15 	stw	r5,-12(fp)
81148fb4:	e1bffe15 	stw	r6,-8(fp)
81148fb8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81148fbc:	e0800317 	ldw	r2,12(fp)
81148fc0:	d8800115 	stw	r2,4(sp)
81148fc4:	e0800217 	ldw	r2,8(fp)
81148fc8:	d8800015 	stw	r2,0(sp)
81148fcc:	e1ffff17 	ldw	r7,-4(fp)
81148fd0:	e1bffe17 	ldw	r6,-8(fp)
81148fd4:	e17ffd17 	ldw	r5,-12(fp)
81148fd8:	e13ffc17 	ldw	r4,-16(fp)
81148fdc:	1148d4c0 	call	81148d4c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81148fe0:	e037883a 	mov	sp,fp
81148fe4:	dfc00117 	ldw	ra,4(sp)
81148fe8:	df000017 	ldw	fp,0(sp)
81148fec:	dec00204 	addi	sp,sp,8
81148ff0:	f800283a 	ret

81148ff4 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81148ff4:	defff804 	addi	sp,sp,-32
81148ff8:	de00012e 	bgeu	sp,et,81149000 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81148ffc:	003b68fa 	trap	3
81149000:	dfc00715 	stw	ra,28(sp)
81149004:	df000615 	stw	fp,24(sp)
81149008:	df000604 	addi	fp,sp,24
8114900c:	e13ffc15 	stw	r4,-16(fp)
81149010:	e17ffd15 	stw	r5,-12(fp)
81149014:	e1bffe15 	stw	r6,-8(fp)
81149018:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114901c:	e0800217 	ldw	r2,8(fp)
81149020:	d8800115 	stw	r2,4(sp)
81149024:	e0bfff17 	ldw	r2,-4(fp)
81149028:	d8800015 	stw	r2,0(sp)
8114902c:	e1fffe17 	ldw	r7,-8(fp)
81149030:	000d883a 	mov	r6,zero
81149034:	e17ffd17 	ldw	r5,-12(fp)
81149038:	e13ffc17 	ldw	r4,-16(fp)
8114903c:	1148d4c0 	call	81148d4c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
81149040:	e037883a 	mov	sp,fp
81149044:	dfc00117 	ldw	ra,4(sp)
81149048:	df000017 	ldw	fp,0(sp)
8114904c:	dec00204 	addi	sp,sp,8
81149050:	f800283a 	ret

81149054 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
81149054:	defff804 	addi	sp,sp,-32
81149058:	de00012e 	bgeu	sp,et,81149060 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
8114905c:	003b68fa 	trap	3
81149060:	dfc00715 	stw	ra,28(sp)
81149064:	df000615 	stw	fp,24(sp)
81149068:	df000604 	addi	fp,sp,24
8114906c:	e13ffc15 	stw	r4,-16(fp)
81149070:	e17ffd15 	stw	r5,-12(fp)
81149074:	e1bffe15 	stw	r6,-8(fp)
81149078:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8114907c:	e0800217 	ldw	r2,8(fp)
81149080:	d8800115 	stw	r2,4(sp)
81149084:	e0bfff17 	ldw	r2,-4(fp)
81149088:	d8800015 	stw	r2,0(sp)
8114908c:	000f883a 	mov	r7,zero
81149090:	e1bffe17 	ldw	r6,-8(fp)
81149094:	e17ffd17 	ldw	r5,-12(fp)
81149098:	e13ffc17 	ldw	r4,-16(fp)
8114909c:	1148d4c0 	call	81148d4c <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
811490a0:	e037883a 	mov	sp,fp
811490a4:	dfc00117 	ldw	ra,4(sp)
811490a8:	df000017 	ldw	fp,0(sp)
811490ac:	dec00204 	addi	sp,sp,8
811490b0:	f800283a 	ret

811490b4 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
811490b4:	deffee04 	addi	sp,sp,-72
811490b8:	de00012e 	bgeu	sp,et,811490c0 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
811490bc:	003b68fa 	trap	3
811490c0:	dfc01115 	stw	ra,68(sp)
811490c4:	df001015 	stw	fp,64(sp)
811490c8:	df001004 	addi	fp,sp,64
811490cc:	e13ff915 	stw	r4,-28(fp)
811490d0:	e17ffa15 	stw	r5,-24(fp)
811490d4:	e1bffb15 	stw	r6,-20(fp)
811490d8:	e1fffc15 	stw	r7,-16(fp)
811490dc:	e1000417 	ldw	r4,16(fp)
811490e0:	e0c00517 	ldw	r3,20(fp)
811490e4:	e0800617 	ldw	r2,24(fp)
811490e8:	e13ffd0d 	sth	r4,-12(fp)
811490ec:	e0fffe05 	stb	r3,-8(fp)
811490f0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
811490f4:	e0bffd0b 	ldhu	r2,-12(fp)
811490f8:	e0fffe03 	ldbu	r3,-8(fp)
811490fc:	e13fff0b 	ldhu	r4,-4(fp)
81149100:	d9000815 	stw	r4,32(sp)
81149104:	d8000715 	stw	zero,28(sp)
81149108:	d8c00615 	stw	r3,24(sp)
8114910c:	d8000515 	stw	zero,20(sp)
81149110:	d8800415 	stw	r2,16(sp)
81149114:	e0800317 	ldw	r2,12(fp)
81149118:	d8800315 	stw	r2,12(sp)
8114911c:	e0800217 	ldw	r2,8(fp)
81149120:	d8800215 	stw	r2,8(sp)
81149124:	e0bffc17 	ldw	r2,-16(fp)
81149128:	d8800115 	stw	r2,4(sp)
8114912c:	e0bffb17 	ldw	r2,-20(fp)
81149130:	d8800015 	stw	r2,0(sp)
81149134:	000f883a 	mov	r7,zero
81149138:	000d883a 	mov	r6,zero
8114913c:	e17ffa17 	ldw	r5,-24(fp)
81149140:	e13ff917 	ldw	r4,-28(fp)
81149144:	1148df80 	call	81148df8 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
81149148:	e037883a 	mov	sp,fp
8114914c:	dfc00117 	ldw	ra,4(sp)
81149150:	df000017 	ldw	fp,0(sp)
81149154:	dec00204 	addi	sp,sp,8
81149158:	f800283a 	ret

8114915c <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114915c:	deffee04 	addi	sp,sp,-72
81149160:	de00012e 	bgeu	sp,et,81149168 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81149164:	003b68fa 	trap	3
81149168:	dfc01115 	stw	ra,68(sp)
8114916c:	df001015 	stw	fp,64(sp)
81149170:	df001004 	addi	fp,sp,64
81149174:	e13ff915 	stw	r4,-28(fp)
81149178:	e17ffa15 	stw	r5,-24(fp)
8114917c:	e1bffb15 	stw	r6,-20(fp)
81149180:	e1fffc15 	stw	r7,-16(fp)
81149184:	e1000417 	ldw	r4,16(fp)
81149188:	e0c00517 	ldw	r3,20(fp)
8114918c:	e0800617 	ldw	r2,24(fp)
81149190:	e13ffd0d 	sth	r4,-12(fp)
81149194:	e0fffe05 	stb	r3,-8(fp)
81149198:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114919c:	e0bffd0b 	ldhu	r2,-12(fp)
811491a0:	e0fffe03 	ldbu	r3,-8(fp)
811491a4:	e13fff0b 	ldhu	r4,-4(fp)
811491a8:	d8000815 	stw	zero,32(sp)
811491ac:	d9000715 	stw	r4,28(sp)
811491b0:	d8000615 	stw	zero,24(sp)
811491b4:	d8c00515 	stw	r3,20(sp)
811491b8:	d8800415 	stw	r2,16(sp)
811491bc:	e0800317 	ldw	r2,12(fp)
811491c0:	d8800315 	stw	r2,12(sp)
811491c4:	e0800217 	ldw	r2,8(fp)
811491c8:	d8800215 	stw	r2,8(sp)
811491cc:	d8000115 	stw	zero,4(sp)
811491d0:	d8000015 	stw	zero,0(sp)
811491d4:	e1fffc17 	ldw	r7,-16(fp)
811491d8:	e1bffb17 	ldw	r6,-20(fp)
811491dc:	e17ffa17 	ldw	r5,-24(fp)
811491e0:	e13ff917 	ldw	r4,-28(fp)
811491e4:	1148df80 	call	81148df8 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
811491e8:	e037883a 	mov	sp,fp
811491ec:	dfc00117 	ldw	ra,4(sp)
811491f0:	df000017 	ldw	fp,0(sp)
811491f4:	dec00204 	addi	sp,sp,8
811491f8:	f800283a 	ret

811491fc <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
811491fc:	deffec04 	addi	sp,sp,-80
81149200:	de00012e 	bgeu	sp,et,81149208 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
81149204:	003b68fa 	trap	3
81149208:	dfc01315 	stw	ra,76(sp)
8114920c:	df001215 	stw	fp,72(sp)
81149210:	df001204 	addi	fp,sp,72
81149214:	e13ff715 	stw	r4,-36(fp)
81149218:	e17ff815 	stw	r5,-32(fp)
8114921c:	e1bff915 	stw	r6,-28(fp)
81149220:	e1fffa15 	stw	r7,-24(fp)
81149224:	e1800617 	ldw	r6,24(fp)
81149228:	e1400717 	ldw	r5,28(fp)
8114922c:	e1000817 	ldw	r4,32(fp)
81149230:	e0c00917 	ldw	r3,36(fp)
81149234:	e0800a17 	ldw	r2,40(fp)
81149238:	e1bffb0d 	sth	r6,-20(fp)
8114923c:	e17ffc05 	stb	r5,-16(fp)
81149240:	e13ffd05 	stb	r4,-12(fp)
81149244:	e0fffe0d 	sth	r3,-8(fp)
81149248:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8114924c:	e0bffb0b 	ldhu	r2,-20(fp)
81149250:	e0fffc03 	ldbu	r3,-16(fp)
81149254:	e13ffd03 	ldbu	r4,-12(fp)
81149258:	e17ffe0b 	ldhu	r5,-8(fp)
8114925c:	e1bfff0b 	ldhu	r6,-4(fp)
81149260:	d9800815 	stw	r6,32(sp)
81149264:	d9400715 	stw	r5,28(sp)
81149268:	d9000615 	stw	r4,24(sp)
8114926c:	d8c00515 	stw	r3,20(sp)
81149270:	d8800415 	stw	r2,16(sp)
81149274:	e0800517 	ldw	r2,20(fp)
81149278:	d8800315 	stw	r2,12(sp)
8114927c:	e0800417 	ldw	r2,16(fp)
81149280:	d8800215 	stw	r2,8(sp)
81149284:	e0800317 	ldw	r2,12(fp)
81149288:	d8800115 	stw	r2,4(sp)
8114928c:	e0800217 	ldw	r2,8(fp)
81149290:	d8800015 	stw	r2,0(sp)
81149294:	e1fffa17 	ldw	r7,-24(fp)
81149298:	e1bff917 	ldw	r6,-28(fp)
8114929c:	e17ff817 	ldw	r5,-32(fp)
811492a0:	e13ff717 	ldw	r4,-36(fp)
811492a4:	1148df80 	call	81148df8 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
811492a8:	e037883a 	mov	sp,fp
811492ac:	dfc00117 	ldw	ra,4(sp)
811492b0:	df000017 	ldw	fp,0(sp)
811492b4:	dec00204 	addi	sp,sp,8
811492b8:	f800283a 	ret

811492bc <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
811492bc:	defffc04 	addi	sp,sp,-16
811492c0:	de00012e 	bgeu	sp,et,811492c8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
811492c4:	003b68fa 	trap	3
811492c8:	df000315 	stw	fp,12(sp)
811492cc:	df000304 	addi	fp,sp,12
811492d0:	e13ffe15 	stw	r4,-8(fp)
811492d4:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
811492d8:	e0bfff17 	ldw	r2,-4(fp)
811492dc:	1000021e 	bne	r2,zero,811492e8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
811492e0:	00bffa84 	movi	r2,-22
811492e4:	00002f06 	br	811493a4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
811492e8:	e0bfff17 	ldw	r2,-4(fp)
811492ec:	10c00317 	ldw	r3,12(r2)
811492f0:	e0bfff17 	ldw	r2,-4(fp)
811492f4:	18800226 	beq	r3,r2,81149300 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
811492f8:	00bffa84 	movi	r2,-22
811492fc:	00002906 	br	811493a4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81149300:	e0bffe17 	ldw	r2,-8(fp)
81149304:	10800017 	ldw	r2,0(r2)
81149308:	1000051e 	bne	r2,zero,81149320 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8114930c:	e0bffe17 	ldw	r2,-8(fp)
81149310:	e0ffff17 	ldw	r3,-4(fp)
81149314:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81149318:	0005883a 	mov	r2,zero
8114931c:	00002106 	br	811493a4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
81149320:	e0bffe17 	ldw	r2,-8(fp)
81149324:	10c00017 	ldw	r3,0(r2)
81149328:	e0bfff17 	ldw	r2,-4(fp)
8114932c:	1880021e 	bne	r3,r2,81149338 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81149330:	00bffa84 	movi	r2,-22
81149334:	00001b06 	br	811493a4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81149338:	e0bffe17 	ldw	r2,-8(fp)
8114933c:	10800017 	ldw	r2,0(r2)
81149340:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81149344:	00000906 	br	8114936c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
81149348:	e0bffd17 	ldw	r2,-12(fp)
8114934c:	10c00317 	ldw	r3,12(r2)
81149350:	e0bfff17 	ldw	r2,-4(fp)
81149354:	1880021e 	bne	r3,r2,81149360 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81149358:	00bffa84 	movi	r2,-22
8114935c:	00001106 	br	811493a4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81149360:	e0bffd17 	ldw	r2,-12(fp)
81149364:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
81149368:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114936c:	e0bffd17 	ldw	r2,-12(fp)
81149370:	10800317 	ldw	r2,12(r2)
81149374:	e0fffe17 	ldw	r3,-8(fp)
81149378:	18c00017 	ldw	r3,0(r3)
8114937c:	10fff21e 	bne	r2,r3,81149348 <__reset+0xfb129348>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
81149380:	e0ffff17 	ldw	r3,-4(fp)
81149384:	e0bffd17 	ldw	r2,-12(fp)
81149388:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
8114938c:	e0bffe17 	ldw	r2,-8(fp)
81149390:	10800017 	ldw	r2,0(r2)
81149394:	1007883a 	mov	r3,r2
81149398:	e0bfff17 	ldw	r2,-4(fp)
8114939c:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
811493a0:	0005883a 	mov	r2,zero
}
811493a4:	e037883a 	mov	sp,fp
811493a8:	df000017 	ldw	fp,0(sp)
811493ac:	dec00104 	addi	sp,sp,4
811493b0:	f800283a 	ret

811493b4 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
811493b4:	defff804 	addi	sp,sp,-32
811493b8:	de00012e 	bgeu	sp,et,811493c0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
811493bc:	003b68fa 	trap	3
811493c0:	df000715 	stw	fp,28(sp)
811493c4:	df000704 	addi	fp,sp,28
811493c8:	e13ffe15 	stw	r4,-8(fp)
811493cc:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
811493d0:	e13fff17 	ldw	r4,-4(fp)
811493d4:	2000021e 	bne	r4,zero,811493e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
811493d8:	00bffa84 	movi	r2,-22
811493dc:	00005906 	br	81149544 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
811493e0:	e13fff17 	ldw	r4,-4(fp)
811493e4:	2015883a 	mov	r10,r4
811493e8:	0017883a 	mov	r11,zero
811493ec:	e2bffc15 	stw	r10,-16(fp)
811493f0:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
811493f4:	e13fff17 	ldw	r4,-4(fp)
811493f8:	21400317 	ldw	r5,12(r4)
811493fc:	e13ffc17 	ldw	r4,-16(fp)
81149400:	29000626 	beq	r5,r4,8114941c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
81149404:	e13fff17 	ldw	r4,-4(fp)
81149408:	21400b17 	ldw	r5,44(r4)
8114940c:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81149410:	29000226 	beq	r5,r4,8114941c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81149414:	00bffa84 	movi	r2,-22
81149418:	00004a06 	br	81149544 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
8114941c:	e13ffe17 	ldw	r4,-8(fp)
81149420:	21000017 	ldw	r4,0(r4)
81149424:	2000051e 	bne	r4,zero,8114943c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
81149428:	e0bffe17 	ldw	r2,-8(fp)
8114942c:	e0ffff17 	ldw	r3,-4(fp)
81149430:	10c00015 	stw	r3,0(r2)
		return 0;
81149434:	0005883a 	mov	r2,zero
81149438:	00004206 	br	81149544 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
8114943c:	e13ffe17 	ldw	r4,-8(fp)
81149440:	21400017 	ldw	r5,0(r4)
81149444:	e13fff17 	ldw	r4,-4(fp)
81149448:	2900021e 	bne	r5,r4,81149454 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114944c:	00bffa84 	movi	r2,-22
81149450:	00003c06 	br	81149544 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81149454:	e13ffe17 	ldw	r4,-8(fp)
81149458:	21000017 	ldw	r4,0(r4)
8114945c:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
81149460:	e13ffe17 	ldw	r4,-8(fp)
81149464:	21000017 	ldw	r4,0(r4)
81149468:	2011883a 	mov	r8,r4
8114946c:	0013883a 	mov	r9,zero
81149470:	e23ffa15 	stw	r8,-24(fp)
81149474:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81149478:	00001806 	br	811494dc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
8114947c:	e13fff17 	ldw	r4,-4(fp)
81149480:	200d883a 	mov	r6,r4
81149484:	000f883a 	mov	r7,zero
81149488:	e1bffc15 	stw	r6,-16(fp)
8114948c:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
81149490:	e13ff917 	ldw	r4,-28(fp)
81149494:	21400317 	ldw	r5,12(r4)
81149498:	e13ffc17 	ldw	r4,-16(fp)
8114949c:	2900061e 	bne	r5,r4,811494b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
811494a0:	e13ff917 	ldw	r4,-28(fp)
811494a4:	21400b17 	ldw	r5,44(r4)
811494a8:	e13ffd17 	ldw	r4,-12(fp)
811494ac:	2900021e 	bne	r5,r4,811494b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811494b0:	00bffa84 	movi	r2,-22
811494b4:	00002306 	br	81149544 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811494b8:	e13ff917 	ldw	r4,-28(fp)
811494bc:	21000317 	ldw	r4,12(r4)
811494c0:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
811494c4:	e13ff917 	ldw	r4,-28(fp)
811494c8:	21000b17 	ldw	r4,44(r4)
811494cc:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
811494d0:	e13ffc17 	ldw	r4,-16(fp)
811494d4:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
811494d8:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811494dc:	e13ff917 	ldw	r4,-28(fp)
811494e0:	21400317 	ldw	r5,12(r4)
811494e4:	e13ffa17 	ldw	r4,-24(fp)
811494e8:	29000426 	beq	r5,r4,811494fc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
811494ec:	e13ff917 	ldw	r4,-28(fp)
811494f0:	21400b17 	ldw	r5,44(r4)
811494f4:	e13ffb17 	ldw	r4,-20(fp)
811494f8:	293fe01e 	bne	r5,r4,8114947c <__reset+0xfb12947c>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
811494fc:	e13fff17 	ldw	r4,-4(fp)
81149500:	2005883a 	mov	r2,r4
81149504:	0007883a 	mov	r3,zero
81149508:	e0bffc15 	stw	r2,-16(fp)
8114950c:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
81149510:	e0fffc17 	ldw	r3,-16(fp)
81149514:	e0bff917 	ldw	r2,-28(fp)
81149518:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
8114951c:	e0fffd17 	ldw	r3,-12(fp)
81149520:	e0bff917 	ldw	r2,-28(fp)
81149524:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
81149528:	e0fffa17 	ldw	r3,-24(fp)
8114952c:	e0bfff17 	ldw	r2,-4(fp)
81149530:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
81149534:	e0fffb17 	ldw	r3,-20(fp)
81149538:	e0bfff17 	ldw	r2,-4(fp)
8114953c:	10c00b15 	stw	r3,44(r2)
	return 0;
81149540:	0005883a 	mov	r2,zero
}
81149544:	e037883a 	mov	sp,fp
81149548:	df000017 	ldw	fp,0(sp)
8114954c:	dec00104 	addi	sp,sp,4
81149550:	f800283a 	ret

81149554 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
81149554:	defffc04 	addi	sp,sp,-16
81149558:	de00012e 	bgeu	sp,et,81149560 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
8114955c:	003b68fa 	trap	3
81149560:	df000315 	stw	fp,12(sp)
81149564:	df000304 	addi	fp,sp,12
81149568:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114956c:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
81149570:	e0bfff17 	ldw	r2,-4(fp)
81149574:	1000021e 	bne	r2,zero,81149580 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81149578:	00bffa84 	movi	r2,-22
8114957c:	00001906 	br	811495e4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81149580:	e0bfff17 	ldw	r2,-4(fp)
81149584:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81149588:	00000a06 	br	811495b4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
8114958c:	e0bffd17 	ldw	r2,-12(fp)
81149590:	10800717 	ldw	r2,28(r2)
81149594:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81149598:	e0bffe17 	ldw	r2,-8(fp)
8114959c:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811495a0:	e0bffd17 	ldw	r2,-12(fp)
811495a4:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811495a8:	e0bffd17 	ldw	r2,-12(fp)
811495ac:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
811495b0:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811495b4:	e0bffd17 	ldw	r2,-12(fp)
811495b8:	10c00317 	ldw	r3,12(r2)
811495bc:	e0bfff17 	ldw	r2,-4(fp)
811495c0:	18bff21e 	bne	r3,r2,8114958c <__reset+0xfb12958c>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
811495c4:	e0bffd17 	ldw	r2,-12(fp)
811495c8:	10800717 	ldw	r2,28(r2)
811495cc:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811495d0:	e0bffe17 	ldw	r2,-8(fp)
811495d4:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811495d8:	e0bffd17 	ldw	r2,-12(fp)
811495dc:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
811495e0:	0005883a 	mov	r2,zero
}
811495e4:	e037883a 	mov	sp,fp
811495e8:	df000017 	ldw	fp,0(sp)
811495ec:	dec00104 	addi	sp,sp,4
811495f0:	f800283a 	ret

811495f4 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
811495f4:	defff804 	addi	sp,sp,-32
811495f8:	de00012e 	bgeu	sp,et,81149600 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
811495fc:	003b68fa 	trap	3
81149600:	df000715 	stw	fp,28(sp)
81149604:	df000704 	addi	fp,sp,28
81149608:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
8114960c:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
81149610:	e13fff17 	ldw	r4,-4(fp)
81149614:	2000021e 	bne	r4,zero,81149620 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81149618:	00bffa84 	movi	r2,-22
8114961c:	00002806 	br	811496c0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81149620:	e13fff17 	ldw	r4,-4(fp)
81149624:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
81149628:	e13fff17 	ldw	r4,-4(fp)
8114962c:	2005883a 	mov	r2,r4
81149630:	0007883a 	mov	r3,zero
81149634:	e0bffb15 	stw	r2,-20(fp)
81149638:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114963c:	00001006 	br	81149680 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
81149640:	e0bff917 	ldw	r2,-28(fp)
81149644:	10800f17 	ldw	r2,60(r2)
81149648:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114964c:	e0bffa17 	ldw	r2,-24(fp)
81149650:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81149654:	e0bff917 	ldw	r2,-28(fp)
81149658:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
8114965c:	e0bff917 	ldw	r2,-28(fp)
81149660:	10800317 	ldw	r2,12(r2)
81149664:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81149668:	e0bff917 	ldw	r2,-28(fp)
8114966c:	10800b17 	ldw	r2,44(r2)
81149670:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81149674:	e0bffd17 	ldw	r2,-12(fp)
81149678:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
8114967c:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81149680:	e0bff917 	ldw	r2,-28(fp)
81149684:	10c00317 	ldw	r3,12(r2)
81149688:	e0bffb17 	ldw	r2,-20(fp)
8114968c:	18800426 	beq	r3,r2,811496a0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81149690:	e0bff917 	ldw	r2,-28(fp)
81149694:	10c00b17 	ldw	r3,44(r2)
81149698:	e0bffc17 	ldw	r2,-16(fp)
8114969c:	18bfe81e 	bne	r3,r2,81149640 <__reset+0xfb129640>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
811496a0:	e0bff917 	ldw	r2,-28(fp)
811496a4:	10800f17 	ldw	r2,60(r2)
811496a8:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811496ac:	e0bffa17 	ldw	r2,-24(fp)
811496b0:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811496b4:	e0bff917 	ldw	r2,-28(fp)
811496b8:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
811496bc:	0005883a 	mov	r2,zero
}
811496c0:	e037883a 	mov	sp,fp
811496c4:	df000017 	ldw	fp,0(sp)
811496c8:	dec00104 	addi	sp,sp,4
811496cc:	f800283a 	ret

811496d0 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
811496d0:	deffeb04 	addi	sp,sp,-84
811496d4:	de00012e 	bgeu	sp,et,811496dc <alt_msgdma_start_prefetcher_with_list_addr+0xc>
811496d8:	003b68fa 	trap	3
811496dc:	dfc01415 	stw	ra,80(sp)
811496e0:	df001315 	stw	fp,76(sp)
811496e4:	df001304 	addi	fp,sp,76
811496e8:	e13ffb15 	stw	r4,-20(fp)
811496ec:	e17ffc15 	stw	r5,-16(fp)
811496f0:	e1bffd15 	stw	r6,-12(fp)
811496f4:	3807883a 	mov	r3,r7
811496f8:	e0800217 	ldw	r2,8(fp)
811496fc:	e0fffe05 	stb	r3,-8(fp)
81149700:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
81149704:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
81149708:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
8114970c:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
81149710:	e0bffc17 	ldw	r2,-16(fp)
81149714:	e0bff815 	stw	r2,-32(fp)
81149718:	e0bffd17 	ldw	r2,-12(fp)
8114971c:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
81149720:	e0bffb17 	ldw	r2,-20(fp)
81149724:	10801817 	ldw	r2,96(r2)
81149728:	e0bff615 	stw	r2,-40(fp)
8114972c:	e03ff70d 	sth	zero,-36(fp)
81149730:	e0bff70b 	ldhu	r2,-36(fp)
81149734:	e0fffa04 	addi	r3,fp,-24
81149738:	180d883a 	mov	r6,r3
8114973c:	100b883a 	mov	r5,r2
81149740:	e13ff617 	ldw	r4,-40(fp)
81149744:	113e87c0 	call	8113e87c <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
81149748:	e0bffb17 	ldw	r2,-20(fp)
8114974c:	10800617 	ldw	r2,24(r2)
81149750:	10800037 	ldwio	r2,0(r2)
81149754:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
81149758:	e0bfed17 	ldw	r2,-76(fp)
8114975c:	1080004c 	andi	r2,r2,1
81149760:	10000626 	beq	r2,zero,8114977c <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
81149764:	e0bffb17 	ldw	r2,-20(fp)
81149768:	10801817 	ldw	r2,96(r2)
8114976c:	1009883a 	mov	r4,r2
81149770:	113ec040 	call	8113ec04 <OSSemPost>
		return -EBUSY;
81149774:	00bffc04 	movi	r2,-16
81149778:	00009606 	br	811499d4 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114977c:	00800804 	movi	r2,32
81149780:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149784:	0005303a 	rdctl	r2,status
81149788:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114978c:	e0fff217 	ldw	r3,-56(fp)
81149790:	00bfff84 	movi	r2,-2
81149794:	1884703a 	and	r2,r3,r2
81149798:	1001703a 	wrctl	status,r2
  
  return context;
8114979c:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811497a0:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811497a4:	e0bffb17 	ldw	r2,-20(fp)
811497a8:	10800317 	ldw	r2,12(r2)
811497ac:	10800104 	addi	r2,r2,4
811497b0:	e0ffee17 	ldw	r3,-72(fp)
811497b4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
811497b8:	e0bffb17 	ldw	r2,-20(fp)
811497bc:	10800317 	ldw	r2,12(r2)
811497c0:	e0fffb17 	ldw	r3,-20(fp)
811497c4:	18c00317 	ldw	r3,12(r3)
811497c8:	18c00037 	ldwio	r3,0(r3)
811497cc:	10c00035 	stwio	r3,0(r2)
811497d0:	e0bfef17 	ldw	r2,-68(fp)
811497d4:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811497d8:	e0bff017 	ldw	r2,-64(fp)
811497dc:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
811497e0:	e0bffb17 	ldw	r2,-20(fp)
811497e4:	10800b17 	ldw	r2,44(r2)
811497e8:	10002326 	beq	r2,zero,81149878 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
811497ec:	e0bffb17 	ldw	r2,-20(fp)
811497f0:	10c00d17 	ldw	r3,52(r2)
811497f4:	e0bfee17 	ldw	r2,-72(fp)
811497f8:	1884b03a 	or	r2,r3,r2
811497fc:	10800514 	ori	r2,r2,20
81149800:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81149804:	e0ffee17 	ldw	r3,-72(fp)
81149808:	00bff7c4 	movi	r2,-33
8114980c:	1884703a 	and	r2,r3,r2
81149810:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81149814:	e0bfed17 	ldw	r2,-76(fp)
81149818:	10800214 	ori	r2,r2,8
8114981c:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149820:	0005303a 	rdctl	r2,status
81149824:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149828:	e0fff417 	ldw	r3,-48(fp)
8114982c:	00bfff84 	movi	r2,-2
81149830:	1884703a 	and	r2,r3,r2
81149834:	1001703a 	wrctl	status,r2
  
  return context;
81149838:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
8114983c:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81149840:	e0bffb17 	ldw	r2,-20(fp)
81149844:	10800317 	ldw	r2,12(r2)
81149848:	10800104 	addi	r2,r2,4
8114984c:	e0ffee17 	ldw	r3,-72(fp)
81149850:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81149854:	e0bffb17 	ldw	r2,-20(fp)
81149858:	10800617 	ldw	r2,24(r2)
8114985c:	e0ffed17 	ldw	r3,-76(fp)
81149860:	10c00035 	stwio	r3,0(r2)
81149864:	e0bfef17 	ldw	r2,-68(fp)
81149868:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114986c:	e0bff117 	ldw	r2,-60(fp)
81149870:	1001703a 	wrctl	status,r2
81149874:	00002306 	br	81149904 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
81149878:	e0bffb17 	ldw	r2,-20(fp)
8114987c:	10c00d17 	ldw	r3,52(r2)
81149880:	e0bfee17 	ldw	r2,-72(fp)
81149884:	1884b03a 	or	r2,r3,r2
81149888:	10800114 	ori	r2,r2,4
8114988c:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
81149890:	e0ffee17 	ldw	r3,-72(fp)
81149894:	00bff3c4 	movi	r2,-49
81149898:	1884703a 	and	r2,r3,r2
8114989c:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
811498a0:	e0ffed17 	ldw	r3,-76(fp)
811498a4:	00bffdc4 	movi	r2,-9
811498a8:	1884703a 	and	r2,r3,r2
811498ac:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811498b0:	0005303a 	rdctl	r2,status
811498b4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811498b8:	e0fff517 	ldw	r3,-44(fp)
811498bc:	00bfff84 	movi	r2,-2
811498c0:	1884703a 	and	r2,r3,r2
811498c4:	1001703a 	wrctl	status,r2
  
  return context;
811498c8:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
811498cc:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811498d0:	e0bffb17 	ldw	r2,-20(fp)
811498d4:	10800317 	ldw	r2,12(r2)
811498d8:	10800104 	addi	r2,r2,4
811498dc:	e0ffee17 	ldw	r3,-72(fp)
811498e0:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811498e4:	e0bffb17 	ldw	r2,-20(fp)
811498e8:	10800617 	ldw	r2,24(r2)
811498ec:	e0ffed17 	ldw	r3,-76(fp)
811498f0:	10c00035 	stwio	r3,0(r2)
811498f4:	e0bfef17 	ldw	r2,-68(fp)
811498f8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811498fc:	e0bff317 	ldw	r2,-52(fp)
81149900:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81149904:	e0bffb17 	ldw	r2,-20(fp)
81149908:	10800617 	ldw	r2,24(r2)
8114990c:	10800104 	addi	r2,r2,4
81149910:	e0fff817 	ldw	r3,-32(fp)
81149914:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81149918:	e0bffb17 	ldw	r2,-20(fp)
8114991c:	10800617 	ldw	r2,24(r2)
81149920:	10800204 	addi	r2,r2,8
81149924:	e0fff917 	ldw	r3,-28(fp)
81149928:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
8114992c:	e0bffe03 	ldbu	r2,-8(fp)
81149930:	10000426 	beq	r2,zero,81149944 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81149934:	e0bfed17 	ldw	r2,-76(fp)
81149938:	10800414 	ori	r2,r2,16
8114993c:	e0bfed15 	stw	r2,-76(fp)
81149940:	00000406 	br	81149954 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81149944:	e0ffed17 	ldw	r3,-76(fp)
81149948:	00bffbc4 	movi	r2,-17
8114994c:	1884703a 	and	r2,r3,r2
81149950:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81149954:	e0bfff03 	ldbu	r2,-4(fp)
81149958:	10000e26 	beq	r2,zero,81149994 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
8114995c:	e0bfed17 	ldw	r2,-76(fp)
81149960:	10800094 	ori	r2,r2,2
81149964:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81149968:	e0bffb17 	ldw	r2,-20(fp)
8114996c:	10800617 	ldw	r2,24(r2)
81149970:	10800304 	addi	r2,r2,12
81149974:	10800037 	ldwio	r2,0(r2)
81149978:	10000a1e 	bne	r2,zero,811499a4 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
8114997c:	e0bffb17 	ldw	r2,-20(fp)
81149980:	10800617 	ldw	r2,24(r2)
81149984:	10800304 	addi	r2,r2,12
81149988:	00c03fc4 	movi	r3,255
8114998c:	10c00035 	stwio	r3,0(r2)
81149990:	00000406 	br	811499a4 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81149994:	e0ffed17 	ldw	r3,-76(fp)
81149998:	00bfff44 	movi	r2,-3
8114999c:	1884703a 	and	r2,r3,r2
811499a0:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
811499a4:	e0bfed17 	ldw	r2,-76(fp)
811499a8:	10800054 	ori	r2,r2,1
811499ac:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811499b0:	e0bffb17 	ldw	r2,-20(fp)
811499b4:	10800617 	ldw	r2,24(r2)
811499b8:	e0ffed17 	ldw	r3,-76(fp)
811499bc:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
811499c0:	e0bffb17 	ldw	r2,-20(fp)
811499c4:	10801817 	ldw	r2,96(r2)
811499c8:	1009883a 	mov	r4,r2
811499cc:	113ec040 	call	8113ec04 <OSSemPost>
	 
	 return 0;
811499d0:	0005883a 	mov	r2,zero
}
811499d4:	e037883a 	mov	sp,fp
811499d8:	dfc00117 	ldw	ra,4(sp)
811499dc:	df000017 	ldw	fp,0(sp)
811499e0:	dec00204 	addi	sp,sp,8
811499e4:	f800283a 	ret

811499e8 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
811499e8:	defff704 	addi	sp,sp,-36
811499ec:	de00012e 	bgeu	sp,et,811499f4 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
811499f0:	003b68fa 	trap	3
811499f4:	dfc00815 	stw	ra,32(sp)
811499f8:	df000715 	stw	fp,28(sp)
811499fc:	dc400615 	stw	r17,24(sp)
81149a00:	dc000515 	stw	r16,20(sp)
81149a04:	df000704 	addi	fp,sp,28
81149a08:	e13ffa15 	stw	r4,-24(fp)
81149a0c:	e17ffb15 	stw	r5,-20(fp)
81149a10:	3007883a 	mov	r3,r6
81149a14:	3805883a 	mov	r2,r7
81149a18:	e0fffc05 	stb	r3,-16(fp)
81149a1c:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81149a20:	e13ffb17 	ldw	r4,-20(fp)
81149a24:	11495540 	call	81149554 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81149a28:	10000226 	beq	r2,zero,81149a34 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81149a2c:	00bffa84 	movi	r2,-22
81149a30:	00000b06 	br	81149a60 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81149a34:	e0bffb17 	ldw	r2,-20(fp)
81149a38:	1021883a 	mov	r16,r2
81149a3c:	0023883a 	mov	r17,zero
81149a40:	e0fffc03 	ldbu	r3,-16(fp)
81149a44:	e0bffd03 	ldbu	r2,-12(fp)
81149a48:	d8800015 	stw	r2,0(sp)
81149a4c:	180f883a 	mov	r7,r3
81149a50:	800b883a 	mov	r5,r16
81149a54:	880d883a 	mov	r6,r17
81149a58:	e13ffa17 	ldw	r4,-24(fp)
81149a5c:	11496d00 	call	811496d0 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81149a60:	e6fffe04 	addi	sp,fp,-8
81149a64:	dfc00317 	ldw	ra,12(sp)
81149a68:	df000217 	ldw	fp,8(sp)
81149a6c:	dc400117 	ldw	r17,4(sp)
81149a70:	dc000017 	ldw	r16,0(sp)
81149a74:	dec00404 	addi	sp,sp,16
81149a78:	f800283a 	ret

81149a7c <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81149a7c:	defff704 	addi	sp,sp,-36
81149a80:	de00012e 	bgeu	sp,et,81149a88 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81149a84:	003b68fa 	trap	3
81149a88:	dfc00815 	stw	ra,32(sp)
81149a8c:	df000715 	stw	fp,28(sp)
81149a90:	dc400615 	stw	r17,24(sp)
81149a94:	dc000515 	stw	r16,20(sp)
81149a98:	df000704 	addi	fp,sp,28
81149a9c:	e13ffa15 	stw	r4,-24(fp)
81149aa0:	e17ffb15 	stw	r5,-20(fp)
81149aa4:	3007883a 	mov	r3,r6
81149aa8:	3805883a 	mov	r2,r7
81149aac:	e0fffc05 	stb	r3,-16(fp)
81149ab0:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81149ab4:	e13ffb17 	ldw	r4,-20(fp)
81149ab8:	11495f40 	call	811495f4 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81149abc:	10000226 	beq	r2,zero,81149ac8 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81149ac0:	00bffa84 	movi	r2,-22
81149ac4:	00000b06 	br	81149af4 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81149ac8:	e0bffb17 	ldw	r2,-20(fp)
81149acc:	1021883a 	mov	r16,r2
81149ad0:	0023883a 	mov	r17,zero
81149ad4:	e0fffc03 	ldbu	r3,-16(fp)
81149ad8:	e0bffd03 	ldbu	r2,-12(fp)
81149adc:	d8800015 	stw	r2,0(sp)
81149ae0:	180f883a 	mov	r7,r3
81149ae4:	800b883a 	mov	r5,r16
81149ae8:	880d883a 	mov	r6,r17
81149aec:	e13ffa17 	ldw	r4,-24(fp)
81149af0:	11496d00 	call	811496d0 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81149af4:	e6fffe04 	addi	sp,fp,-8
81149af8:	dfc00317 	ldw	ra,12(sp)
81149afc:	df000217 	ldw	fp,8(sp)
81149b00:	dc400117 	ldw	r17,4(sp)
81149b04:	dc000017 	ldw	r16,0(sp)
81149b08:	dec00404 	addi	sp,sp,16
81149b0c:	f800283a 	ret

81149b10 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81149b10:	defffc04 	addi	sp,sp,-16
81149b14:	de00012e 	bgeu	sp,et,81149b1c <alt_msgdma_open+0xc>
81149b18:	003b68fa 	trap	3
81149b1c:	dfc00315 	stw	ra,12(sp)
81149b20:	df000215 	stw	fp,8(sp)
81149b24:	df000204 	addi	fp,sp,8
81149b28:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81149b2c:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
81149b30:	d1603504 	addi	r5,gp,-32556
81149b34:	e13fff17 	ldw	r4,-4(fp)
81149b38:	114a0b40 	call	8114a0b4 <alt_find_dev>
81149b3c:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
81149b40:	e0bffe17 	ldw	r2,-8(fp)
81149b44:	1000041e 	bne	r2,zero,81149b58 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81149b48:	1147d740 	call	81147d74 <alt_get_errno>
81149b4c:	1007883a 	mov	r3,r2
81149b50:	008004c4 	movi	r2,19
81149b54:	18800015 	stw	r2,0(r3)
    }

    return dev;
81149b58:	e0bffe17 	ldw	r2,-8(fp)
}
81149b5c:	e037883a 	mov	sp,fp
81149b60:	dfc00117 	ldw	ra,4(sp)
81149b64:	df000017 	ldw	fp,0(sp)
81149b68:	dec00204 	addi	sp,sp,8
81149b6c:	f800283a 	ret

81149b70 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
81149b70:	defff604 	addi	sp,sp,-40
81149b74:	de00012e 	bgeu	sp,et,81149b7c <alt_msgdma_init+0xc>
81149b78:	003b68fa 	trap	3
81149b7c:	dfc00915 	stw	ra,36(sp)
81149b80:	df000815 	stw	fp,32(sp)
81149b84:	df000804 	addi	fp,sp,32
81149b88:	e13ffd15 	stw	r4,-12(fp)
81149b8c:	e17ffe15 	stw	r5,-8(fp)
81149b90:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81149b94:	e0bffd17 	ldw	r2,-12(fp)
81149b98:	10801783 	ldbu	r2,94(r2)
81149b9c:	10803fcc 	andi	r2,r2,255
81149ba0:	10000b26 	beq	r2,zero,81149bd0 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81149ba4:	e0bffd17 	ldw	r2,-12(fp)
81149ba8:	10800617 	ldw	r2,24(r2)
81149bac:	00c00104 	movi	r3,4
81149bb0:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
81149bb4:	0001883a 	nop
81149bb8:	e0bffd17 	ldw	r2,-12(fp)
81149bbc:	10800617 	ldw	r2,24(r2)
81149bc0:	10800037 	ldwio	r2,0(r2)
81149bc4:	1080010c 	andi	r2,r2,4
81149bc8:	1005d0ba 	srai	r2,r2,2
81149bcc:	103ffa1e 	bne	r2,zero,81149bb8 <__reset+0xfb129bb8>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81149bd0:	e0bffd17 	ldw	r2,-12(fp)
81149bd4:	10800317 	ldw	r2,12(r2)
81149bd8:	10800104 	addi	r2,r2,4
81149bdc:	00c00084 	movi	r3,2
81149be0:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81149be4:	0001883a 	nop
81149be8:	e0bffd17 	ldw	r2,-12(fp)
81149bec:	10800317 	ldw	r2,12(r2)
81149bf0:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81149bf4:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81149bf8:	103ffb1e 	bne	r2,zero,81149be8 <__reset+0xfb129be8>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81149bfc:	e0bffd17 	ldw	r2,-12(fp)
81149c00:	10800317 	ldw	r2,12(r2)
81149c04:	10800104 	addi	r2,r2,4
81149c08:	10800037 	ldwio	r2,0(r2)
81149c0c:	1007883a 	mov	r3,r2
81149c10:	00bffbc4 	movi	r2,-17
81149c14:	1884703a 	and	r2,r3,r2
81149c18:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81149c1c:	e0bff917 	ldw	r2,-28(fp)
81149c20:	10800814 	ori	r2,r2,32
81149c24:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81149c28:	e0bffd17 	ldw	r2,-12(fp)
81149c2c:	10800317 	ldw	r2,12(r2)
81149c30:	10800104 	addi	r2,r2,4
81149c34:	e0fff917 	ldw	r3,-28(fp)
81149c38:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81149c3c:	e0bffd17 	ldw	r2,-12(fp)
81149c40:	10800317 	ldw	r2,12(r2)
81149c44:	e0fffd17 	ldw	r3,-12(fp)
81149c48:	18c00317 	ldw	r3,12(r3)
81149c4c:	18c00037 	ldwio	r3,0(r3)
81149c50:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81149c54:	e0bffd17 	ldw	r2,-12(fp)
81149c58:	10801783 	ldbu	r2,94(r2)
81149c5c:	10803fcc 	andi	r2,r2,255
81149c60:	10000826 	beq	r2,zero,81149c84 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
81149c64:	e0bffd17 	ldw	r2,-12(fp)
81149c68:	10800617 	ldw	r2,24(r2)
81149c6c:	10800404 	addi	r2,r2,16
81149c70:	e0fffd17 	ldw	r3,-12(fp)
81149c74:	18c00617 	ldw	r3,24(r3)
81149c78:	18c00404 	addi	r3,r3,16
81149c7c:	18c00037 	ldwio	r3,0(r3)
81149c80:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81149c84:	d1603504 	addi	r5,gp,-32556
81149c88:	e13ffd17 	ldw	r4,-12(fp)
81149c8c:	114a0080 	call	8114a008 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
81149c90:	e0bffd17 	ldw	r2,-12(fp)
81149c94:	10801804 	addi	r2,r2,96
81149c98:	e0bffb15 	stw	r2,-20(fp)
81149c9c:	00800044 	movi	r2,1
81149ca0:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81149ca4:	e0bffc0b 	ldhu	r2,-16(fp)
81149ca8:	1009883a 	mov	r4,r2
81149cac:	113e5540 	call	8113e554 <OSSemCreate>
81149cb0:	1007883a 	mov	r3,r2
81149cb4:	e0bffb17 	ldw	r2,-20(fp)
81149cb8:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81149cbc:	e0bffb17 	ldw	r2,-20(fp)
81149cc0:	10800017 	ldw	r2,0(r2)
81149cc4:	10000226 	beq	r2,zero,81149cd0 <alt_msgdma_init+0x160>
81149cc8:	0005883a 	mov	r2,zero
81149ccc:	00000106 	br	81149cd4 <alt_msgdma_init+0x164>
81149cd0:	00bfffc4 	movi	r2,-1
81149cd4:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81149cd8:	e0bffa17 	ldw	r2,-24(fp)
81149cdc:	1000081e 	bne	r2,zero,81149d00 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81149ce0:	d8000015 	stw	zero,0(sp)
81149ce4:	e1fffd17 	ldw	r7,-12(fp)
81149ce8:	01a04534 	movhi	r6,33044
81149cec:	319fe204 	addi	r6,r6,32648
81149cf0:	e17fff17 	ldw	r5,-4(fp)
81149cf4:	e13ffe17 	ldw	r4,-8(fp)
81149cf8:	114a3400 	call	8114a340 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81149cfc:	00000406 	br	81149d10 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81149d00:	01204574 	movhi	r4,33045
81149d04:	21046604 	addi	r4,r4,4504
81149d08:	114a7580 	call	8114a758 <alt_printf>
    }
    
    return;
81149d0c:	0001883a 	nop

}
81149d10:	e037883a 	mov	sp,fp
81149d14:	dfc00117 	ldw	ra,4(sp)
81149d18:	df000017 	ldw	fp,0(sp)
81149d1c:	dec00204 	addi	sp,sp,8
81149d20:	f800283a 	ret

81149d24 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81149d24:	defffb04 	addi	sp,sp,-20
81149d28:	de00012e 	bgeu	sp,et,81149d30 <alt_msgdma_register_callback+0xc>
81149d2c:	003b68fa 	trap	3
81149d30:	df000415 	stw	fp,16(sp)
81149d34:	df000404 	addi	fp,sp,16
81149d38:	e13ffc15 	stw	r4,-16(fp)
81149d3c:	e17ffd15 	stw	r5,-12(fp)
81149d40:	e1bffe15 	stw	r6,-8(fp)
81149d44:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81149d48:	e0bffc17 	ldw	r2,-16(fp)
81149d4c:	e0fffd17 	ldw	r3,-12(fp)
81149d50:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81149d54:	e0bffc17 	ldw	r2,-16(fp)
81149d58:	e0ffff17 	ldw	r3,-4(fp)
81149d5c:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81149d60:	e0bffc17 	ldw	r2,-16(fp)
81149d64:	e0fffe17 	ldw	r3,-8(fp)
81149d68:	10c00d15 	stw	r3,52(r2)

    return ;
81149d6c:	0001883a 	nop
}
81149d70:	e037883a 	mov	sp,fp
81149d74:	df000017 	ldw	fp,0(sp)
81149d78:	dec00104 	addi	sp,sp,4
81149d7c:	f800283a 	ret

81149d80 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81149d80:	defffc04 	addi	sp,sp,-16
81149d84:	de00012e 	bgeu	sp,et,81149d8c <alt_msgdma_standard_descriptor_async_transfer+0xc>
81149d88:	003b68fa 	trap	3
81149d8c:	dfc00315 	stw	ra,12(sp)
81149d90:	df000215 	stw	fp,8(sp)
81149d94:	df000204 	addi	fp,sp,8
81149d98:	e13ffe15 	stw	r4,-8(fp)
81149d9c:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
81149da0:	000d883a 	mov	r6,zero
81149da4:	e17fff17 	ldw	r5,-4(fp)
81149da8:	e13ffe17 	ldw	r4,-8(fp)
81149dac:	11483040 	call	81148304 <alt_msgdma_descriptor_async_transfer>

}
81149db0:	e037883a 	mov	sp,fp
81149db4:	dfc00117 	ldw	ra,4(sp)
81149db8:	df000017 	ldw	fp,0(sp)
81149dbc:	dec00204 	addi	sp,sp,8
81149dc0:	f800283a 	ret

81149dc4 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81149dc4:	defffc04 	addi	sp,sp,-16
81149dc8:	de00012e 	bgeu	sp,et,81149dd0 <alt_msgdma_extended_descriptor_async_transfer+0xc>
81149dcc:	003b68fa 	trap	3
81149dd0:	dfc00315 	stw	ra,12(sp)
81149dd4:	df000215 	stw	fp,8(sp)
81149dd8:	df000204 	addi	fp,sp,8
81149ddc:	e13ffe15 	stw	r4,-8(fp)
81149de0:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81149de4:	e1bfff17 	ldw	r6,-4(fp)
81149de8:	000b883a 	mov	r5,zero
81149dec:	e13ffe17 	ldw	r4,-8(fp)
81149df0:	11483040 	call	81148304 <alt_msgdma_descriptor_async_transfer>
}
81149df4:	e037883a 	mov	sp,fp
81149df8:	dfc00117 	ldw	ra,4(sp)
81149dfc:	df000017 	ldw	fp,0(sp)
81149e00:	dec00204 	addi	sp,sp,8
81149e04:	f800283a 	ret

81149e08 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81149e08:	defffc04 	addi	sp,sp,-16
81149e0c:	de00012e 	bgeu	sp,et,81149e14 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
81149e10:	003b68fa 	trap	3
81149e14:	dfc00315 	stw	ra,12(sp)
81149e18:	df000215 	stw	fp,8(sp)
81149e1c:	df000204 	addi	fp,sp,8
81149e20:	e13ffe15 	stw	r4,-8(fp)
81149e24:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
81149e28:	000d883a 	mov	r6,zero
81149e2c:	e17fff17 	ldw	r5,-4(fp)
81149e30:	e13ffe17 	ldw	r4,-8(fp)
81149e34:	11486440 	call	81148644 <alt_msgdma_descriptor_sync_transfer>
}
81149e38:	e037883a 	mov	sp,fp
81149e3c:	dfc00117 	ldw	ra,4(sp)
81149e40:	df000017 	ldw	fp,0(sp)
81149e44:	dec00204 	addi	sp,sp,8
81149e48:	f800283a 	ret

81149e4c <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81149e4c:	defffc04 	addi	sp,sp,-16
81149e50:	de00012e 	bgeu	sp,et,81149e58 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
81149e54:	003b68fa 	trap	3
81149e58:	dfc00315 	stw	ra,12(sp)
81149e5c:	df000215 	stw	fp,8(sp)
81149e60:	df000204 	addi	fp,sp,8
81149e64:	e13ffe15 	stw	r4,-8(fp)
81149e68:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
81149e6c:	e1bfff17 	ldw	r6,-4(fp)
81149e70:	000b883a 	mov	r5,zero
81149e74:	e13ffe17 	ldw	r4,-8(fp)
81149e78:	11486440 	call	81148644 <alt_msgdma_descriptor_sync_transfer>
}
81149e7c:	e037883a 	mov	sp,fp
81149e80:	dfc00117 	ldw	ra,4(sp)
81149e84:	df000017 	ldw	fp,0(sp)
81149e88:	dec00204 	addi	sp,sp,8
81149e8c:	f800283a 	ret

81149e90 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
81149e90:	defff504 	addi	sp,sp,-44
81149e94:	de00012e 	bgeu	sp,et,81149e9c <alt_alarm_start+0xc>
81149e98:	003b68fa 	trap	3
81149e9c:	df000a15 	stw	fp,40(sp)
81149ea0:	df000a04 	addi	fp,sp,40
81149ea4:	e13ffc15 	stw	r4,-16(fp)
81149ea8:	e17ffd15 	stw	r5,-12(fp)
81149eac:	e1bffe15 	stw	r6,-8(fp)
81149eb0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
81149eb4:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81149eb8:	d0a08817 	ldw	r2,-32224(gp)
  
  if (alt_ticks_per_second ())
81149ebc:	10003c26 	beq	r2,zero,81149fb0 <alt_alarm_start+0x120>
  {
    if (alarm)
81149ec0:	e0bffc17 	ldw	r2,-16(fp)
81149ec4:	10003826 	beq	r2,zero,81149fa8 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81149ec8:	e0bffc17 	ldw	r2,-16(fp)
81149ecc:	e0fffe17 	ldw	r3,-8(fp)
81149ed0:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
81149ed4:	e0bffc17 	ldw	r2,-16(fp)
81149ed8:	e0ffff17 	ldw	r3,-4(fp)
81149edc:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149ee0:	0005303a 	rdctl	r2,status
81149ee4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149ee8:	e0fff917 	ldw	r3,-28(fp)
81149eec:	00bfff84 	movi	r2,-2
81149ef0:	1884703a 	and	r2,r3,r2
81149ef4:	1001703a 	wrctl	status,r2
  
  return context;
81149ef8:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81149efc:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81149f00:	d0a08917 	ldw	r2,-32220(gp)
      
      current_nticks = alt_nticks();
81149f04:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81149f08:	e0fffd17 	ldw	r3,-12(fp)
81149f0c:	e0bff617 	ldw	r2,-40(fp)
81149f10:	1885883a 	add	r2,r3,r2
81149f14:	10c00044 	addi	r3,r2,1
81149f18:	e0bffc17 	ldw	r2,-16(fp)
81149f1c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
81149f20:	e0bffc17 	ldw	r2,-16(fp)
81149f24:	10c00217 	ldw	r3,8(r2)
81149f28:	e0bff617 	ldw	r2,-40(fp)
81149f2c:	1880042e 	bgeu	r3,r2,81149f40 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
81149f30:	e0bffc17 	ldw	r2,-16(fp)
81149f34:	00c00044 	movi	r3,1
81149f38:	10c00405 	stb	r3,16(r2)
81149f3c:	00000206 	br	81149f48 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
81149f40:	e0bffc17 	ldw	r2,-16(fp)
81149f44:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
81149f48:	e0bffc17 	ldw	r2,-16(fp)
81149f4c:	d0e01404 	addi	r3,gp,-32688
81149f50:	e0fffa15 	stw	r3,-24(fp)
81149f54:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81149f58:	e0bffb17 	ldw	r2,-20(fp)
81149f5c:	e0fffa17 	ldw	r3,-24(fp)
81149f60:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81149f64:	e0bffa17 	ldw	r2,-24(fp)
81149f68:	10c00017 	ldw	r3,0(r2)
81149f6c:	e0bffb17 	ldw	r2,-20(fp)
81149f70:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81149f74:	e0bffa17 	ldw	r2,-24(fp)
81149f78:	10800017 	ldw	r2,0(r2)
81149f7c:	e0fffb17 	ldw	r3,-20(fp)
81149f80:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81149f84:	e0bffa17 	ldw	r2,-24(fp)
81149f88:	e0fffb17 	ldw	r3,-20(fp)
81149f8c:	10c00015 	stw	r3,0(r2)
81149f90:	e0bff817 	ldw	r2,-32(fp)
81149f94:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149f98:	e0bff717 	ldw	r2,-36(fp)
81149f9c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
81149fa0:	0005883a 	mov	r2,zero
81149fa4:	00000306 	br	81149fb4 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81149fa8:	00bffa84 	movi	r2,-22
81149fac:	00000106 	br	81149fb4 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
81149fb0:	00bfde84 	movi	r2,-134
  }
}
81149fb4:	e037883a 	mov	sp,fp
81149fb8:	df000017 	ldw	fp,0(sp)
81149fbc:	dec00104 	addi	sp,sp,4
81149fc0:	f800283a 	ret

81149fc4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81149fc4:	defffe04 	addi	sp,sp,-8
81149fc8:	de00012e 	bgeu	sp,et,81149fd0 <alt_get_errno+0xc>
81149fcc:	003b68fa 	trap	3
81149fd0:	dfc00115 	stw	ra,4(sp)
81149fd4:	df000015 	stw	fp,0(sp)
81149fd8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149fdc:	d0a01017 	ldw	r2,-32704(gp)
81149fe0:	10000326 	beq	r2,zero,81149ff0 <alt_get_errno+0x2c>
81149fe4:	d0a01017 	ldw	r2,-32704(gp)
81149fe8:	103ee83a 	callr	r2
81149fec:	00000106 	br	81149ff4 <alt_get_errno+0x30>
81149ff0:	d0a07804 	addi	r2,gp,-32288
}
81149ff4:	e037883a 	mov	sp,fp
81149ff8:	dfc00117 	ldw	ra,4(sp)
81149ffc:	df000017 	ldw	fp,0(sp)
8114a000:	dec00204 	addi	sp,sp,8
8114a004:	f800283a 	ret

8114a008 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
8114a008:	defffa04 	addi	sp,sp,-24
8114a00c:	de00012e 	bgeu	sp,et,8114a014 <alt_dev_llist_insert+0xc>
8114a010:	003b68fa 	trap	3
8114a014:	dfc00515 	stw	ra,20(sp)
8114a018:	df000415 	stw	fp,16(sp)
8114a01c:	df000404 	addi	fp,sp,16
8114a020:	e13ffe15 	stw	r4,-8(fp)
8114a024:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
8114a028:	e0bffe17 	ldw	r2,-8(fp)
8114a02c:	10000326 	beq	r2,zero,8114a03c <alt_dev_llist_insert+0x34>
8114a030:	e0bffe17 	ldw	r2,-8(fp)
8114a034:	10800217 	ldw	r2,8(r2)
8114a038:	1000061e 	bne	r2,zero,8114a054 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
8114a03c:	1149fc40 	call	81149fc4 <alt_get_errno>
8114a040:	1007883a 	mov	r3,r2
8114a044:	00800584 	movi	r2,22
8114a048:	18800015 	stw	r2,0(r3)
    return -EINVAL;
8114a04c:	00bffa84 	movi	r2,-22
8114a050:	00001306 	br	8114a0a0 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8114a054:	e0bffe17 	ldw	r2,-8(fp)
8114a058:	e0ffff17 	ldw	r3,-4(fp)
8114a05c:	e0fffc15 	stw	r3,-16(fp)
8114a060:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
8114a064:	e0bffd17 	ldw	r2,-12(fp)
8114a068:	e0fffc17 	ldw	r3,-16(fp)
8114a06c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114a070:	e0bffc17 	ldw	r2,-16(fp)
8114a074:	10c00017 	ldw	r3,0(r2)
8114a078:	e0bffd17 	ldw	r2,-12(fp)
8114a07c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114a080:	e0bffc17 	ldw	r2,-16(fp)
8114a084:	10800017 	ldw	r2,0(r2)
8114a088:	e0fffd17 	ldw	r3,-12(fp)
8114a08c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114a090:	e0bffc17 	ldw	r2,-16(fp)
8114a094:	e0fffd17 	ldw	r3,-12(fp)
8114a098:	10c00015 	stw	r3,0(r2)

  return 0;  
8114a09c:	0005883a 	mov	r2,zero
}
8114a0a0:	e037883a 	mov	sp,fp
8114a0a4:	dfc00117 	ldw	ra,4(sp)
8114a0a8:	df000017 	ldw	fp,0(sp)
8114a0ac:	dec00204 	addi	sp,sp,8
8114a0b0:	f800283a 	ret

8114a0b4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114a0b4:	defffa04 	addi	sp,sp,-24
8114a0b8:	de00012e 	bgeu	sp,et,8114a0c0 <alt_find_dev+0xc>
8114a0bc:	003b68fa 	trap	3
8114a0c0:	dfc00515 	stw	ra,20(sp)
8114a0c4:	df000415 	stw	fp,16(sp)
8114a0c8:	df000404 	addi	fp,sp,16
8114a0cc:	e13ffe15 	stw	r4,-8(fp)
8114a0d0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114a0d4:	e0bfff17 	ldw	r2,-4(fp)
8114a0d8:	10800017 	ldw	r2,0(r2)
8114a0dc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8114a0e0:	e13ffe17 	ldw	r4,-8(fp)
8114a0e4:	1122ee80 	call	81122ee8 <strlen>
8114a0e8:	10800044 	addi	r2,r2,1
8114a0ec:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114a0f0:	00000d06 	br	8114a128 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114a0f4:	e0bffc17 	ldw	r2,-16(fp)
8114a0f8:	10800217 	ldw	r2,8(r2)
8114a0fc:	e0fffd17 	ldw	r3,-12(fp)
8114a100:	180d883a 	mov	r6,r3
8114a104:	e17ffe17 	ldw	r5,-8(fp)
8114a108:	1009883a 	mov	r4,r2
8114a10c:	114aec80 	call	8114aec8 <memcmp>
8114a110:	1000021e 	bne	r2,zero,8114a11c <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114a114:	e0bffc17 	ldw	r2,-16(fp)
8114a118:	00000706 	br	8114a138 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8114a11c:	e0bffc17 	ldw	r2,-16(fp)
8114a120:	10800017 	ldw	r2,0(r2)
8114a124:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114a128:	e0fffc17 	ldw	r3,-16(fp)
8114a12c:	e0bfff17 	ldw	r2,-4(fp)
8114a130:	18bff01e 	bne	r3,r2,8114a0f4 <__reset+0xfb12a0f4>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8114a134:	0005883a 	mov	r2,zero
}
8114a138:	e037883a 	mov	sp,fp
8114a13c:	dfc00117 	ldw	ra,4(sp)
8114a140:	df000017 	ldw	fp,0(sp)
8114a144:	dec00204 	addi	sp,sp,8
8114a148:	f800283a 	ret

8114a14c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
8114a14c:	defffb04 	addi	sp,sp,-20
8114a150:	de00012e 	bgeu	sp,et,8114a158 <alt_find_file+0xc>
8114a154:	003b68fa 	trap	3
8114a158:	dfc00415 	stw	ra,16(sp)
8114a15c:	df000315 	stw	fp,12(sp)
8114a160:	df000304 	addi	fp,sp,12
8114a164:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
8114a168:	d0a00b17 	ldw	r2,-32724(gp)
8114a16c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114a170:	00003106 	br	8114a238 <alt_find_file+0xec>
  {
    len = strlen(next->name);
8114a174:	e0bffd17 	ldw	r2,-12(fp)
8114a178:	10800217 	ldw	r2,8(r2)
8114a17c:	1009883a 	mov	r4,r2
8114a180:	1122ee80 	call	81122ee8 <strlen>
8114a184:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
8114a188:	e0bffd17 	ldw	r2,-12(fp)
8114a18c:	10c00217 	ldw	r3,8(r2)
8114a190:	e0bffe17 	ldw	r2,-8(fp)
8114a194:	10bfffc4 	addi	r2,r2,-1
8114a198:	1885883a 	add	r2,r3,r2
8114a19c:	10800003 	ldbu	r2,0(r2)
8114a1a0:	10803fcc 	andi	r2,r2,255
8114a1a4:	1080201c 	xori	r2,r2,128
8114a1a8:	10bfe004 	addi	r2,r2,-128
8114a1ac:	10800bd8 	cmpnei	r2,r2,47
8114a1b0:	1000031e 	bne	r2,zero,8114a1c0 <alt_find_file+0x74>
    {
      len -= 1;
8114a1b4:	e0bffe17 	ldw	r2,-8(fp)
8114a1b8:	10bfffc4 	addi	r2,r2,-1
8114a1bc:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114a1c0:	e0bffe17 	ldw	r2,-8(fp)
8114a1c4:	e0ffff17 	ldw	r3,-4(fp)
8114a1c8:	1885883a 	add	r2,r3,r2
8114a1cc:	10800003 	ldbu	r2,0(r2)
8114a1d0:	10803fcc 	andi	r2,r2,255
8114a1d4:	1080201c 	xori	r2,r2,128
8114a1d8:	10bfe004 	addi	r2,r2,-128
8114a1dc:	10800be0 	cmpeqi	r2,r2,47
8114a1e0:	1000081e 	bne	r2,zero,8114a204 <alt_find_file+0xb8>
8114a1e4:	e0bffe17 	ldw	r2,-8(fp)
8114a1e8:	e0ffff17 	ldw	r3,-4(fp)
8114a1ec:	1885883a 	add	r2,r3,r2
8114a1f0:	10800003 	ldbu	r2,0(r2)
8114a1f4:	10803fcc 	andi	r2,r2,255
8114a1f8:	1080201c 	xori	r2,r2,128
8114a1fc:	10bfe004 	addi	r2,r2,-128
8114a200:	10000a1e 	bne	r2,zero,8114a22c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114a204:	e0bffd17 	ldw	r2,-12(fp)
8114a208:	10800217 	ldw	r2,8(r2)
8114a20c:	e0fffe17 	ldw	r3,-8(fp)
8114a210:	180d883a 	mov	r6,r3
8114a214:	e17fff17 	ldw	r5,-4(fp)
8114a218:	1009883a 	mov	r4,r2
8114a21c:	114aec80 	call	8114aec8 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114a220:	1000021e 	bne	r2,zero,8114a22c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114a224:	e0bffd17 	ldw	r2,-12(fp)
8114a228:	00000706 	br	8114a248 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
8114a22c:	e0bffd17 	ldw	r2,-12(fp)
8114a230:	10800017 	ldw	r2,0(r2)
8114a234:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114a238:	e0fffd17 	ldw	r3,-12(fp)
8114a23c:	d0a00b04 	addi	r2,gp,-32724
8114a240:	18bfcc1e 	bne	r3,r2,8114a174 <__reset+0xfb12a174>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114a244:	0005883a 	mov	r2,zero
}
8114a248:	e037883a 	mov	sp,fp
8114a24c:	dfc00117 	ldw	ra,4(sp)
8114a250:	df000017 	ldw	fp,0(sp)
8114a254:	dec00204 	addi	sp,sp,8
8114a258:	f800283a 	ret

8114a25c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
8114a25c:	defff904 	addi	sp,sp,-28
8114a260:	de00012e 	bgeu	sp,et,8114a268 <alt_get_fd+0xc>
8114a264:	003b68fa 	trap	3
8114a268:	dfc00615 	stw	ra,24(sp)
8114a26c:	df000515 	stw	fp,20(sp)
8114a270:	df000504 	addi	fp,sp,20
8114a274:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
8114a278:	00bffa04 	movi	r2,-24
8114a27c:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8114a280:	d0a07f17 	ldw	r2,-32260(gp)
8114a284:	e0bffd15 	stw	r2,-12(fp)
8114a288:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8114a28c:	e0bffe0b 	ldhu	r2,-8(fp)
8114a290:	e0fffe84 	addi	r3,fp,-6
8114a294:	180d883a 	mov	r6,r3
8114a298:	100b883a 	mov	r5,r2
8114a29c:	e13ffd17 	ldw	r4,-12(fp)
8114a2a0:	113e87c0 	call	8113e87c <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114a2a4:	e03ffb15 	stw	zero,-20(fp)
8114a2a8:	00001906 	br	8114a310 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8114a2ac:	00a04574 	movhi	r2,33045
8114a2b0:	1086d504 	addi	r2,r2,6996
8114a2b4:	e0fffb17 	ldw	r3,-20(fp)
8114a2b8:	18c00324 	muli	r3,r3,12
8114a2bc:	10c5883a 	add	r2,r2,r3
8114a2c0:	10800017 	ldw	r2,0(r2)
8114a2c4:	10000f1e 	bne	r2,zero,8114a304 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
8114a2c8:	00a04574 	movhi	r2,33045
8114a2cc:	1086d504 	addi	r2,r2,6996
8114a2d0:	e0fffb17 	ldw	r3,-20(fp)
8114a2d4:	18c00324 	muli	r3,r3,12
8114a2d8:	10c5883a 	add	r2,r2,r3
8114a2dc:	e0ffff17 	ldw	r3,-4(fp)
8114a2e0:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114a2e4:	d0e00f17 	ldw	r3,-32708(gp)
8114a2e8:	e0bffb17 	ldw	r2,-20(fp)
8114a2ec:	1880020e 	bge	r3,r2,8114a2f8 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8114a2f0:	e0bffb17 	ldw	r2,-20(fp)
8114a2f4:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
8114a2f8:	e0bffb17 	ldw	r2,-20(fp)
8114a2fc:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8114a300:	00000606 	br	8114a31c <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114a304:	e0bffb17 	ldw	r2,-20(fp)
8114a308:	10800044 	addi	r2,r2,1
8114a30c:	e0bffb15 	stw	r2,-20(fp)
8114a310:	e0bffb17 	ldw	r2,-20(fp)
8114a314:	10800810 	cmplti	r2,r2,32
8114a318:	103fe41e 	bne	r2,zero,8114a2ac <__reset+0xfb12a2ac>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
8114a31c:	d0a07f17 	ldw	r2,-32260(gp)
8114a320:	1009883a 	mov	r4,r2
8114a324:	113ec040 	call	8113ec04 <OSSemPost>

  return rc;
8114a328:	e0bffc17 	ldw	r2,-16(fp)
}
8114a32c:	e037883a 	mov	sp,fp
8114a330:	dfc00117 	ldw	ra,4(sp)
8114a334:	df000017 	ldw	fp,0(sp)
8114a338:	dec00204 	addi	sp,sp,8
8114a33c:	f800283a 	ret

8114a340 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114a340:	defff904 	addi	sp,sp,-28
8114a344:	de00012e 	bgeu	sp,et,8114a34c <alt_ic_isr_register+0xc>
8114a348:	003b68fa 	trap	3
8114a34c:	dfc00615 	stw	ra,24(sp)
8114a350:	df000515 	stw	fp,20(sp)
8114a354:	df000504 	addi	fp,sp,20
8114a358:	e13ffc15 	stw	r4,-16(fp)
8114a35c:	e17ffd15 	stw	r5,-12(fp)
8114a360:	e1bffe15 	stw	r6,-8(fp)
8114a364:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
8114a368:	e0800217 	ldw	r2,8(fp)
8114a36c:	d8800015 	stw	r2,0(sp)
8114a370:	e1ffff17 	ldw	r7,-4(fp)
8114a374:	e1bffe17 	ldw	r6,-8(fp)
8114a378:	e17ffd17 	ldw	r5,-12(fp)
8114a37c:	e13ffc17 	ldw	r4,-16(fp)
8114a380:	114a5100 	call	8114a510 <alt_iic_isr_register>
}  
8114a384:	e037883a 	mov	sp,fp
8114a388:	dfc00117 	ldw	ra,4(sp)
8114a38c:	df000017 	ldw	fp,0(sp)
8114a390:	dec00204 	addi	sp,sp,8
8114a394:	f800283a 	ret

8114a398 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
8114a398:	defff904 	addi	sp,sp,-28
8114a39c:	de00012e 	bgeu	sp,et,8114a3a4 <alt_ic_irq_enable+0xc>
8114a3a0:	003b68fa 	trap	3
8114a3a4:	df000615 	stw	fp,24(sp)
8114a3a8:	df000604 	addi	fp,sp,24
8114a3ac:	e13ffe15 	stw	r4,-8(fp)
8114a3b0:	e17fff15 	stw	r5,-4(fp)
8114a3b4:	e0bfff17 	ldw	r2,-4(fp)
8114a3b8:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a3bc:	0005303a 	rdctl	r2,status
8114a3c0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a3c4:	e0fffb17 	ldw	r3,-20(fp)
8114a3c8:	00bfff84 	movi	r2,-2
8114a3cc:	1884703a 	and	r2,r3,r2
8114a3d0:	1001703a 	wrctl	status,r2
  
  return context;
8114a3d4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114a3d8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
8114a3dc:	00c00044 	movi	r3,1
8114a3e0:	e0bffa17 	ldw	r2,-24(fp)
8114a3e4:	1884983a 	sll	r2,r3,r2
8114a3e8:	1007883a 	mov	r3,r2
8114a3ec:	d0a08017 	ldw	r2,-32256(gp)
8114a3f0:	1884b03a 	or	r2,r3,r2
8114a3f4:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114a3f8:	d0a08017 	ldw	r2,-32256(gp)
8114a3fc:	100170fa 	wrctl	ienable,r2
8114a400:	e0bffc17 	ldw	r2,-16(fp)
8114a404:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a408:	e0bffd17 	ldw	r2,-12(fp)
8114a40c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114a410:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114a414:	0001883a 	nop
}
8114a418:	e037883a 	mov	sp,fp
8114a41c:	df000017 	ldw	fp,0(sp)
8114a420:	dec00104 	addi	sp,sp,4
8114a424:	f800283a 	ret

8114a428 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
8114a428:	defff904 	addi	sp,sp,-28
8114a42c:	de00012e 	bgeu	sp,et,8114a434 <alt_ic_irq_disable+0xc>
8114a430:	003b68fa 	trap	3
8114a434:	df000615 	stw	fp,24(sp)
8114a438:	df000604 	addi	fp,sp,24
8114a43c:	e13ffe15 	stw	r4,-8(fp)
8114a440:	e17fff15 	stw	r5,-4(fp)
8114a444:	e0bfff17 	ldw	r2,-4(fp)
8114a448:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a44c:	0005303a 	rdctl	r2,status
8114a450:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a454:	e0fffb17 	ldw	r3,-20(fp)
8114a458:	00bfff84 	movi	r2,-2
8114a45c:	1884703a 	and	r2,r3,r2
8114a460:	1001703a 	wrctl	status,r2
  
  return context;
8114a464:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8114a468:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
8114a46c:	00c00044 	movi	r3,1
8114a470:	e0bffa17 	ldw	r2,-24(fp)
8114a474:	1884983a 	sll	r2,r3,r2
8114a478:	0084303a 	nor	r2,zero,r2
8114a47c:	1007883a 	mov	r3,r2
8114a480:	d0a08017 	ldw	r2,-32256(gp)
8114a484:	1884703a 	and	r2,r3,r2
8114a488:	d0a08015 	stw	r2,-32256(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8114a48c:	d0a08017 	ldw	r2,-32256(gp)
8114a490:	100170fa 	wrctl	ienable,r2
8114a494:	e0bffc17 	ldw	r2,-16(fp)
8114a498:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a49c:	e0bffd17 	ldw	r2,-12(fp)
8114a4a0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114a4a4:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
8114a4a8:	0001883a 	nop
}
8114a4ac:	e037883a 	mov	sp,fp
8114a4b0:	df000017 	ldw	fp,0(sp)
8114a4b4:	dec00104 	addi	sp,sp,4
8114a4b8:	f800283a 	ret

8114a4bc <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
8114a4bc:	defffc04 	addi	sp,sp,-16
8114a4c0:	de00012e 	bgeu	sp,et,8114a4c8 <alt_ic_irq_enabled+0xc>
8114a4c4:	003b68fa 	trap	3
8114a4c8:	df000315 	stw	fp,12(sp)
8114a4cc:	df000304 	addi	fp,sp,12
8114a4d0:	e13ffe15 	stw	r4,-8(fp)
8114a4d4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
8114a4d8:	000530fa 	rdctl	r2,ienable
8114a4dc:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8114a4e0:	00c00044 	movi	r3,1
8114a4e4:	e0bfff17 	ldw	r2,-4(fp)
8114a4e8:	1884983a 	sll	r2,r3,r2
8114a4ec:	1007883a 	mov	r3,r2
8114a4f0:	e0bffd17 	ldw	r2,-12(fp)
8114a4f4:	1884703a 	and	r2,r3,r2
8114a4f8:	1004c03a 	cmpne	r2,r2,zero
8114a4fc:	10803fcc 	andi	r2,r2,255
}
8114a500:	e037883a 	mov	sp,fp
8114a504:	df000017 	ldw	fp,0(sp)
8114a508:	dec00104 	addi	sp,sp,4
8114a50c:	f800283a 	ret

8114a510 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114a510:	defff504 	addi	sp,sp,-44
8114a514:	de00012e 	bgeu	sp,et,8114a51c <alt_iic_isr_register+0xc>
8114a518:	003b68fa 	trap	3
8114a51c:	dfc00a15 	stw	ra,40(sp)
8114a520:	df000915 	stw	fp,36(sp)
8114a524:	df000904 	addi	fp,sp,36
8114a528:	e13ffc15 	stw	r4,-16(fp)
8114a52c:	e17ffd15 	stw	r5,-12(fp)
8114a530:	e1bffe15 	stw	r6,-8(fp)
8114a534:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
8114a538:	00bffa84 	movi	r2,-22
8114a53c:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8114a540:	e0bffd17 	ldw	r2,-12(fp)
8114a544:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8114a548:	e0bff817 	ldw	r2,-32(fp)
8114a54c:	10800808 	cmpgei	r2,r2,32
8114a550:	1000271e 	bne	r2,zero,8114a5f0 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114a554:	0005303a 	rdctl	r2,status
8114a558:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114a55c:	e0fffb17 	ldw	r3,-20(fp)
8114a560:	00bfff84 	movi	r2,-2
8114a564:	1884703a 	and	r2,r3,r2
8114a568:	1001703a 	wrctl	status,r2
  
  return context;
8114a56c:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114a570:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114a574:	00a045f4 	movhi	r2,33047
8114a578:	10b47c04 	addi	r2,r2,-11792
8114a57c:	e0fff817 	ldw	r3,-32(fp)
8114a580:	180690fa 	slli	r3,r3,3
8114a584:	10c5883a 	add	r2,r2,r3
8114a588:	e0fffe17 	ldw	r3,-8(fp)
8114a58c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114a590:	00a045f4 	movhi	r2,33047
8114a594:	10b47c04 	addi	r2,r2,-11792
8114a598:	e0fff817 	ldw	r3,-32(fp)
8114a59c:	180690fa 	slli	r3,r3,3
8114a5a0:	10c5883a 	add	r2,r2,r3
8114a5a4:	10800104 	addi	r2,r2,4
8114a5a8:	e0ffff17 	ldw	r3,-4(fp)
8114a5ac:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8114a5b0:	e0bffe17 	ldw	r2,-8(fp)
8114a5b4:	10000526 	beq	r2,zero,8114a5cc <alt_iic_isr_register+0xbc>
8114a5b8:	e0bff817 	ldw	r2,-32(fp)
8114a5bc:	100b883a 	mov	r5,r2
8114a5c0:	e13ffc17 	ldw	r4,-16(fp)
8114a5c4:	114a3980 	call	8114a398 <alt_ic_irq_enable>
8114a5c8:	00000406 	br	8114a5dc <alt_iic_isr_register+0xcc>
8114a5cc:	e0bff817 	ldw	r2,-32(fp)
8114a5d0:	100b883a 	mov	r5,r2
8114a5d4:	e13ffc17 	ldw	r4,-16(fp)
8114a5d8:	114a4280 	call	8114a428 <alt_ic_irq_disable>
8114a5dc:	e0bff715 	stw	r2,-36(fp)
8114a5e0:	e0bffa17 	ldw	r2,-24(fp)
8114a5e4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114a5e8:	e0bff917 	ldw	r2,-28(fp)
8114a5ec:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114a5f0:	e0bff717 	ldw	r2,-36(fp)
}
8114a5f4:	e037883a 	mov	sp,fp
8114a5f8:	dfc00117 	ldw	ra,4(sp)
8114a5fc:	df000017 	ldw	fp,0(sp)
8114a600:	dec00204 	addi	sp,sp,8
8114a604:	f800283a 	ret

8114a608 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
8114a608:	defff904 	addi	sp,sp,-28
8114a60c:	de00012e 	bgeu	sp,et,8114a614 <alt_open_fd+0xc>
8114a610:	003b68fa 	trap	3
8114a614:	dfc00615 	stw	ra,24(sp)
8114a618:	df000515 	stw	fp,20(sp)
8114a61c:	df000504 	addi	fp,sp,20
8114a620:	e13ffc15 	stw	r4,-16(fp)
8114a624:	e17ffd15 	stw	r5,-12(fp)
8114a628:	e1bffe15 	stw	r6,-8(fp)
8114a62c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114a630:	e1bfff17 	ldw	r6,-4(fp)
8114a634:	e17ffe17 	ldw	r5,-8(fp)
8114a638:	e13ffd17 	ldw	r4,-12(fp)
8114a63c:	11374b80 	call	811374b8 <open>
8114a640:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114a644:	e0bffb17 	ldw	r2,-20(fp)
8114a648:	10001c16 	blt	r2,zero,8114a6bc <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
8114a64c:	00a04574 	movhi	r2,33045
8114a650:	1086d504 	addi	r2,r2,6996
8114a654:	e0fffb17 	ldw	r3,-20(fp)
8114a658:	18c00324 	muli	r3,r3,12
8114a65c:	10c5883a 	add	r2,r2,r3
8114a660:	10c00017 	ldw	r3,0(r2)
8114a664:	e0bffc17 	ldw	r2,-16(fp)
8114a668:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
8114a66c:	00a04574 	movhi	r2,33045
8114a670:	1086d504 	addi	r2,r2,6996
8114a674:	e0fffb17 	ldw	r3,-20(fp)
8114a678:	18c00324 	muli	r3,r3,12
8114a67c:	10c5883a 	add	r2,r2,r3
8114a680:	10800104 	addi	r2,r2,4
8114a684:	10c00017 	ldw	r3,0(r2)
8114a688:	e0bffc17 	ldw	r2,-16(fp)
8114a68c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114a690:	00a04574 	movhi	r2,33045
8114a694:	1086d504 	addi	r2,r2,6996
8114a698:	e0fffb17 	ldw	r3,-20(fp)
8114a69c:	18c00324 	muli	r3,r3,12
8114a6a0:	10c5883a 	add	r2,r2,r3
8114a6a4:	10800204 	addi	r2,r2,8
8114a6a8:	10c00017 	ldw	r3,0(r2)
8114a6ac:	e0bffc17 	ldw	r2,-16(fp)
8114a6b0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114a6b4:	e13ffb17 	ldw	r4,-20(fp)
8114a6b8:	113775c0 	call	8113775c <alt_release_fd>
  }
} 
8114a6bc:	0001883a 	nop
8114a6c0:	e037883a 	mov	sp,fp
8114a6c4:	dfc00117 	ldw	ra,4(sp)
8114a6c8:	df000017 	ldw	fp,0(sp)
8114a6cc:	dec00204 	addi	sp,sp,8
8114a6d0:	f800283a 	ret

8114a6d4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114a6d4:	defffb04 	addi	sp,sp,-20
8114a6d8:	de00012e 	bgeu	sp,et,8114a6e0 <alt_io_redirect+0xc>
8114a6dc:	003b68fa 	trap	3
8114a6e0:	dfc00415 	stw	ra,16(sp)
8114a6e4:	df000315 	stw	fp,12(sp)
8114a6e8:	df000304 	addi	fp,sp,12
8114a6ec:	e13ffd15 	stw	r4,-12(fp)
8114a6f0:	e17ffe15 	stw	r5,-8(fp)
8114a6f4:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
8114a6f8:	01c07fc4 	movi	r7,511
8114a6fc:	01800044 	movi	r6,1
8114a700:	e17ffd17 	ldw	r5,-12(fp)
8114a704:	01204574 	movhi	r4,33045
8114a708:	2106d804 	addi	r4,r4,7008
8114a70c:	114a6080 	call	8114a608 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114a710:	01c07fc4 	movi	r7,511
8114a714:	000d883a 	mov	r6,zero
8114a718:	e17ffe17 	ldw	r5,-8(fp)
8114a71c:	01204574 	movhi	r4,33045
8114a720:	2106d504 	addi	r4,r4,6996
8114a724:	114a6080 	call	8114a608 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
8114a728:	01c07fc4 	movi	r7,511
8114a72c:	01800044 	movi	r6,1
8114a730:	e17fff17 	ldw	r5,-4(fp)
8114a734:	01204574 	movhi	r4,33045
8114a738:	2106db04 	addi	r4,r4,7020
8114a73c:	114a6080 	call	8114a608 <alt_open_fd>
}  
8114a740:	0001883a 	nop
8114a744:	e037883a 	mov	sp,fp
8114a748:	dfc00117 	ldw	ra,4(sp)
8114a74c:	df000017 	ldw	fp,0(sp)
8114a750:	dec00204 	addi	sp,sp,8
8114a754:	f800283a 	ret

8114a758 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
8114a758:	defff204 	addi	sp,sp,-56
8114a75c:	de00012e 	bgeu	sp,et,8114a764 <alt_printf+0xc>
8114a760:	003b68fa 	trap	3
8114a764:	dfc00a15 	stw	ra,40(sp)
8114a768:	df000915 	stw	fp,36(sp)
8114a76c:	df000904 	addi	fp,sp,36
8114a770:	e13fff15 	stw	r4,-4(fp)
8114a774:	e1400215 	stw	r5,8(fp)
8114a778:	e1800315 	stw	r6,12(fp)
8114a77c:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8114a780:	e0800204 	addi	r2,fp,8
8114a784:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
8114a788:	e0bfff17 	ldw	r2,-4(fp)
8114a78c:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114a790:	00006f06 	br	8114a950 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
8114a794:	e0bff807 	ldb	r2,-32(fp)
8114a798:	10800960 	cmpeqi	r2,r2,37
8114a79c:	1000041e 	bne	r2,zero,8114a7b0 <alt_printf+0x58>
        {
            alt_putchar(c);
8114a7a0:	e0bff807 	ldb	r2,-32(fp)
8114a7a4:	1009883a 	mov	r4,r2
8114a7a8:	114a98c0 	call	8114a98c <alt_putchar>
8114a7ac:	00006806 	br	8114a950 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
8114a7b0:	e0bff717 	ldw	r2,-36(fp)
8114a7b4:	10c00044 	addi	r3,r2,1
8114a7b8:	e0fff715 	stw	r3,-36(fp)
8114a7bc:	10800003 	ldbu	r2,0(r2)
8114a7c0:	e0bff805 	stb	r2,-32(fp)
8114a7c4:	e0bff807 	ldb	r2,-32(fp)
8114a7c8:	10006926 	beq	r2,zero,8114a970 <alt_printf+0x218>
            {
                if (c == '%')
8114a7cc:	e0bff807 	ldb	r2,-32(fp)
8114a7d0:	10800958 	cmpnei	r2,r2,37
8114a7d4:	1000041e 	bne	r2,zero,8114a7e8 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114a7d8:	e0bff807 	ldb	r2,-32(fp)
8114a7dc:	1009883a 	mov	r4,r2
8114a7e0:	114a98c0 	call	8114a98c <alt_putchar>
8114a7e4:	00005a06 	br	8114a950 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114a7e8:	e0bff807 	ldb	r2,-32(fp)
8114a7ec:	108018d8 	cmpnei	r2,r2,99
8114a7f0:	1000081e 	bne	r2,zero,8114a814 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8114a7f4:	e0bffe17 	ldw	r2,-8(fp)
8114a7f8:	10c00104 	addi	r3,r2,4
8114a7fc:	e0fffe15 	stw	r3,-8(fp)
8114a800:	10800017 	ldw	r2,0(r2)
8114a804:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114a808:	e13ffd17 	ldw	r4,-12(fp)
8114a80c:	114a98c0 	call	8114a98c <alt_putchar>
8114a810:	00004f06 	br	8114a950 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8114a814:	e0bff807 	ldb	r2,-32(fp)
8114a818:	10801e18 	cmpnei	r2,r2,120
8114a81c:	1000341e 	bne	r2,zero,8114a8f0 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114a820:	e0bffe17 	ldw	r2,-8(fp)
8114a824:	10c00104 	addi	r3,r2,4
8114a828:	e0fffe15 	stw	r3,-8(fp)
8114a82c:	10800017 	ldw	r2,0(r2)
8114a830:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8114a834:	e0bffb17 	ldw	r2,-20(fp)
8114a838:	1000031e 	bne	r2,zero,8114a848 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
8114a83c:	01000c04 	movi	r4,48
8114a840:	114a98c0 	call	8114a98c <alt_putchar>
                        continue;
8114a844:	00004206 	br	8114a950 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
8114a848:	00800704 	movi	r2,28
8114a84c:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114a850:	00000306 	br	8114a860 <alt_printf+0x108>
                        digit_shift -= 4;
8114a854:	e0bff917 	ldw	r2,-28(fp)
8114a858:	10bfff04 	addi	r2,r2,-4
8114a85c:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114a860:	00c003c4 	movi	r3,15
8114a864:	e0bff917 	ldw	r2,-28(fp)
8114a868:	1884983a 	sll	r2,r3,r2
8114a86c:	1007883a 	mov	r3,r2
8114a870:	e0bffb17 	ldw	r2,-20(fp)
8114a874:	1884703a 	and	r2,r3,r2
8114a878:	103ff626 	beq	r2,zero,8114a854 <__reset+0xfb12a854>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114a87c:	00001906 	br	8114a8e4 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8114a880:	00c003c4 	movi	r3,15
8114a884:	e0bff917 	ldw	r2,-28(fp)
8114a888:	1884983a 	sll	r2,r3,r2
8114a88c:	1007883a 	mov	r3,r2
8114a890:	e0bffb17 	ldw	r2,-20(fp)
8114a894:	1886703a 	and	r3,r3,r2
8114a898:	e0bff917 	ldw	r2,-28(fp)
8114a89c:	1884d83a 	srl	r2,r3,r2
8114a8a0:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
8114a8a4:	e0bffc17 	ldw	r2,-16(fp)
8114a8a8:	108002a8 	cmpgeui	r2,r2,10
8114a8ac:	1000041e 	bne	r2,zero,8114a8c0 <alt_printf+0x168>
                            c = '0' + digit;
8114a8b0:	e0bffc17 	ldw	r2,-16(fp)
8114a8b4:	10800c04 	addi	r2,r2,48
8114a8b8:	e0bff805 	stb	r2,-32(fp)
8114a8bc:	00000306 	br	8114a8cc <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
8114a8c0:	e0bffc17 	ldw	r2,-16(fp)
8114a8c4:	108015c4 	addi	r2,r2,87
8114a8c8:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
8114a8cc:	e0bff807 	ldb	r2,-32(fp)
8114a8d0:	1009883a 	mov	r4,r2
8114a8d4:	114a98c0 	call	8114a98c <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114a8d8:	e0bff917 	ldw	r2,-28(fp)
8114a8dc:	10bfff04 	addi	r2,r2,-4
8114a8e0:	e0bff915 	stw	r2,-28(fp)
8114a8e4:	e0bff917 	ldw	r2,-28(fp)
8114a8e8:	103fe50e 	bge	r2,zero,8114a880 <__reset+0xfb12a880>
8114a8ec:	00001806 	br	8114a950 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
8114a8f0:	e0bff807 	ldb	r2,-32(fp)
8114a8f4:	10801cd8 	cmpnei	r2,r2,115
8114a8f8:	1000151e 	bne	r2,zero,8114a950 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
8114a8fc:	e0bffe17 	ldw	r2,-8(fp)
8114a900:	10c00104 	addi	r3,r2,4
8114a904:	e0fffe15 	stw	r3,-8(fp)
8114a908:	10800017 	ldw	r2,0(r2)
8114a90c:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114a910:	00000906 	br	8114a938 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8114a914:	e0bffa17 	ldw	r2,-24(fp)
8114a918:	10c00044 	addi	r3,r2,1
8114a91c:	e0fffa15 	stw	r3,-24(fp)
8114a920:	10800003 	ldbu	r2,0(r2)
8114a924:	10803fcc 	andi	r2,r2,255
8114a928:	1080201c 	xori	r2,r2,128
8114a92c:	10bfe004 	addi	r2,r2,-128
8114a930:	1009883a 	mov	r4,r2
8114a934:	114a98c0 	call	8114a98c <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
8114a938:	e0bffa17 	ldw	r2,-24(fp)
8114a93c:	10800003 	ldbu	r2,0(r2)
8114a940:	10803fcc 	andi	r2,r2,255
8114a944:	1080201c 	xori	r2,r2,128
8114a948:	10bfe004 	addi	r2,r2,-128
8114a94c:	103ff11e 	bne	r2,zero,8114a914 <__reset+0xfb12a914>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114a950:	e0bff717 	ldw	r2,-36(fp)
8114a954:	10c00044 	addi	r3,r2,1
8114a958:	e0fff715 	stw	r3,-36(fp)
8114a95c:	10800003 	ldbu	r2,0(r2)
8114a960:	e0bff805 	stb	r2,-32(fp)
8114a964:	e0bff807 	ldb	r2,-32(fp)
8114a968:	103f8a1e 	bne	r2,zero,8114a794 <__reset+0xfb12a794>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114a96c:	00000106 	br	8114a974 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8114a970:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8114a974:	0001883a 	nop
8114a978:	e037883a 	mov	sp,fp
8114a97c:	dfc00117 	ldw	ra,4(sp)
8114a980:	df000017 	ldw	fp,0(sp)
8114a984:	dec00504 	addi	sp,sp,20
8114a988:	f800283a 	ret

8114a98c <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
8114a98c:	defffd04 	addi	sp,sp,-12
8114a990:	de00012e 	bgeu	sp,et,8114a998 <alt_putchar+0xc>
8114a994:	003b68fa 	trap	3
8114a998:	dfc00215 	stw	ra,8(sp)
8114a99c:	df000115 	stw	fp,4(sp)
8114a9a0:	df000104 	addi	fp,sp,4
8114a9a4:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114a9a8:	d0a00517 	ldw	r2,-32748(gp)
8114a9ac:	10800217 	ldw	r2,8(r2)
8114a9b0:	100b883a 	mov	r5,r2
8114a9b4:	e13fff17 	ldw	r4,-4(fp)
8114a9b8:	11227f80 	call	811227f8 <putc>
#endif
#endif
}
8114a9bc:	e037883a 	mov	sp,fp
8114a9c0:	dfc00117 	ldw	ra,4(sp)
8114a9c4:	df000017 	ldw	fp,0(sp)
8114a9c8:	dec00204 	addi	sp,sp,8
8114a9cc:	f800283a 	ret

8114a9d0 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
8114a9d0:	deffff04 	addi	sp,sp,-4
8114a9d4:	de00012e 	bgeu	sp,et,8114a9dc <altera_nios2_gen2_irq_init+0xc>
8114a9d8:	003b68fa 	trap	3
8114a9dc:	df000015 	stw	fp,0(sp)
8114a9e0:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
8114a9e4:	000170fa 	wrctl	ienable,zero
}
8114a9e8:	0001883a 	nop
8114a9ec:	e037883a 	mov	sp,fp
8114a9f0:	df000017 	ldw	fp,0(sp)
8114a9f4:	dec00104 	addi	sp,sp,4
8114a9f8:	f800283a 	ret

8114a9fc <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
8114a9fc:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
8114aa00:	de002436 	bltu	sp,et,8114aa94 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
8114aa04:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114aa08:	d120a217 	ldw	r4,-32120(gp)

      stw ra,  0(sp)
8114aa0c:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
8114aa10:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8114aa14:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114aa18:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
8114aa1c:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
8114aa20:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8114aa24:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114aa28:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
8114aa2c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
8114aa30:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8114aa34:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
8114aa38:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114aa3c:	114ac980 	call	8114ac98 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
8114aa40:	d1209c17 	ldw	r4,-32144(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8114aa44:	d1609387 	ldb	r5,-32178(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
8114aa48:	d120a215 	stw	r4,-32120(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
8114aa4c:	d16093c5 	stb	r5,-32177(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
8114aa50:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8114aa54:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
8114aa58:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
8114aa5c:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
8114aa60:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8114aa64:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
8114aa68:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
8114aa6c:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
8114aa70:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8114aa74:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
8114aa78:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
8114aa7c:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
8114aa80:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8114aa84:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
8114aa88:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
8114aa8c:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
8114aa90:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8114aa94:	003da0fa 	break	3

8114aa98 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114aa98:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
8114aa9c:	047fff84 	movi	r17,-2
      and   r18, r18, r17
8114aaa0:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8114aaa4:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114aaa8:	114ac980 	call	8114ac98 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
8114aaac:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
8114aab0:	d4a09105 	stb	r18,-32188(gp)

      /*
       * start execution of the new task.
       */

      br 9b
8114aab4:	003fe206 	br	8114aa40 <__reset+0xfb12aa40>

8114aab8 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114aab8:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
8114aabc:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
8114aac0:	10800054 	ori	r2,r2,1
      wrctl status, r2
8114aac4:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114aac8:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
8114aacc:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
8114aad0:	dec00204 	addi	sp,sp,8

      callr r2
8114aad4:	103ee83a 	callr	r2

      nop
8114aad8:	0001883a 	nop

8114aadc <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
8114aadc:	defff704 	addi	sp,sp,-36
8114aae0:	de00012e 	bgeu	sp,et,8114aae8 <OSTaskStkInit+0xc>
8114aae4:	003b68fa 	trap	3
8114aae8:	dfc00815 	stw	ra,32(sp)
8114aaec:	df000715 	stw	fp,28(sp)
8114aaf0:	df000704 	addi	fp,sp,28
8114aaf4:	e13ffc15 	stw	r4,-16(fp)
8114aaf8:	e17ffd15 	stw	r5,-12(fp)
8114aafc:	e1bffe15 	stw	r6,-8(fp)
8114ab00:	3805883a 	mov	r2,r7
8114ab04:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114ab08:	e0fffe17 	ldw	r3,-8(fp)
8114ab0c:	00bfff04 	movi	r2,-4
8114ab10:	1884703a 	and	r2,r3,r2
8114ab14:	10bef704 	addi	r2,r2,-1060
8114ab18:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
8114ab1c:	01810904 	movi	r6,1060
8114ab20:	000b883a 	mov	r5,zero
8114ab24:	e13ff917 	ldw	r4,-28(fp)
8114ab28:	11225440 	call	81122544 <memset>
8114ab2c:	e0bff917 	ldw	r2,-28(fp)
8114ab30:	10c0bb04 	addi	r3,r2,748
8114ab34:	e0bff917 	ldw	r2,-28(fp)
8114ab38:	10c00115 	stw	r3,4(r2)
8114ab3c:	e0bff917 	ldw	r2,-28(fp)
8114ab40:	10c0d504 	addi	r3,r2,852
8114ab44:	e0bff917 	ldw	r2,-28(fp)
8114ab48:	10c00215 	stw	r3,8(r2)
8114ab4c:	e0bff917 	ldw	r2,-28(fp)
8114ab50:	10c0ef04 	addi	r3,r2,956
8114ab54:	e0bff917 	ldw	r2,-28(fp)
8114ab58:	10c00315 	stw	r3,12(r2)
8114ab5c:	e0fff917 	ldw	r3,-28(fp)
8114ab60:	00a04574 	movhi	r2,33045
8114ab64:	10846e04 	addi	r2,r2,4536
8114ab68:	18800d15 	stw	r2,52(r3)
8114ab6c:	e0bff917 	ldw	r2,-28(fp)
8114ab70:	00c00044 	movi	r3,1
8114ab74:	10c02915 	stw	r3,164(r2)
8114ab78:	10002a15 	stw	zero,168(r2)
8114ab7c:	e0bff917 	ldw	r2,-28(fp)
8114ab80:	00ccc384 	movi	r3,13070
8114ab84:	10c02b0d 	sth	r3,172(r2)
8114ab88:	e0bff917 	ldw	r2,-28(fp)
8114ab8c:	00eaf344 	movi	r3,-21555
8114ab90:	10c02b8d 	sth	r3,174(r2)
8114ab94:	e0bff917 	ldw	r2,-28(fp)
8114ab98:	00c48d04 	movi	r3,4660
8114ab9c:	10c02c0d 	sth	r3,176(r2)
8114aba0:	e0bff917 	ldw	r2,-28(fp)
8114aba4:	00f99b44 	movi	r3,-6547
8114aba8:	10c02c8d 	sth	r3,178(r2)
8114abac:	e0bff917 	ldw	r2,-28(fp)
8114abb0:	00f7bb04 	movi	r3,-8468
8114abb4:	10c02d0d 	sth	r3,180(r2)
8114abb8:	e0bff917 	ldw	r2,-28(fp)
8114abbc:	00c00144 	movi	r3,5
8114abc0:	10c02d8d 	sth	r3,182(r2)
8114abc4:	e0bff917 	ldw	r2,-28(fp)
8114abc8:	00c002c4 	movi	r3,11
8114abcc:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114abd0:	e0bff917 	ldw	r2,-28(fp)
8114abd4:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114abd8:	e0bffa17 	ldw	r2,-24(fp)
8114abdc:	10bff304 	addi	r2,r2,-52
8114abe0:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8114abe4:	e0bffb17 	ldw	r2,-20(fp)
8114abe8:	10800c04 	addi	r2,r2,48
8114abec:	e0fffc17 	ldw	r3,-16(fp)
8114abf0:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8114abf4:	e0bffb17 	ldw	r2,-20(fp)
8114abf8:	10800b04 	addi	r2,r2,44
8114abfc:	e0fffd17 	ldw	r3,-12(fp)
8114ac00:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8114ac04:	e0bffb17 	ldw	r2,-20(fp)
8114ac08:	10800a04 	addi	r2,r2,40
8114ac0c:	e0fff917 	ldw	r3,-28(fp)
8114ac10:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8114ac14:	00a04574 	movhi	r2,33045
8114ac18:	10aaae04 	addi	r2,r2,-21832
8114ac1c:	10c00104 	addi	r3,r2,4
8114ac20:	e0bffb17 	ldw	r2,-20(fp)
8114ac24:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114ac28:	e0bffb17 	ldw	r2,-20(fp)
}
8114ac2c:	e037883a 	mov	sp,fp
8114ac30:	dfc00117 	ldw	ra,4(sp)
8114ac34:	df000017 	ldw	fp,0(sp)
8114ac38:	dec00204 	addi	sp,sp,8
8114ac3c:	f800283a 	ret

8114ac40 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114ac40:	defffe04 	addi	sp,sp,-8
8114ac44:	de00012e 	bgeu	sp,et,8114ac4c <OSTaskCreateHook+0xc>
8114ac48:	003b68fa 	trap	3
8114ac4c:	df000115 	stw	fp,4(sp)
8114ac50:	df000104 	addi	fp,sp,4
8114ac54:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8114ac58:	0001883a 	nop
8114ac5c:	e037883a 	mov	sp,fp
8114ac60:	df000017 	ldw	fp,0(sp)
8114ac64:	dec00104 	addi	sp,sp,4
8114ac68:	f800283a 	ret

8114ac6c <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8114ac6c:	defffe04 	addi	sp,sp,-8
8114ac70:	de00012e 	bgeu	sp,et,8114ac78 <OSTaskDelHook+0xc>
8114ac74:	003b68fa 	trap	3
8114ac78:	df000115 	stw	fp,4(sp)
8114ac7c:	df000104 	addi	fp,sp,4
8114ac80:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8114ac84:	0001883a 	nop
8114ac88:	e037883a 	mov	sp,fp
8114ac8c:	df000017 	ldw	fp,0(sp)
8114ac90:	dec00104 	addi	sp,sp,4
8114ac94:	f800283a 	ret

8114ac98 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8114ac98:	deffff04 	addi	sp,sp,-4
8114ac9c:	de00012e 	bgeu	sp,et,8114aca4 <OSTaskSwHook+0xc>
8114aca0:	003b68fa 	trap	3
8114aca4:	df000015 	stw	fp,0(sp)
8114aca8:	d839883a 	mov	fp,sp
}
8114acac:	0001883a 	nop
8114acb0:	e037883a 	mov	sp,fp
8114acb4:	df000017 	ldw	fp,0(sp)
8114acb8:	dec00104 	addi	sp,sp,4
8114acbc:	f800283a 	ret

8114acc0 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114acc0:	deffff04 	addi	sp,sp,-4
8114acc4:	de00012e 	bgeu	sp,et,8114accc <OSTaskStatHook+0xc>
8114acc8:	003b68fa 	trap	3
8114accc:	df000015 	stw	fp,0(sp)
8114acd0:	d839883a 	mov	fp,sp
}
8114acd4:	0001883a 	nop
8114acd8:	e037883a 	mov	sp,fp
8114acdc:	df000017 	ldw	fp,0(sp)
8114ace0:	dec00104 	addi	sp,sp,4
8114ace4:	f800283a 	ret

8114ace8 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8114ace8:	defffe04 	addi	sp,sp,-8
8114acec:	de00012e 	bgeu	sp,et,8114acf4 <OSTimeTickHook+0xc>
8114acf0:	003b68fa 	trap	3
8114acf4:	dfc00115 	stw	ra,4(sp)
8114acf8:	df000015 	stw	fp,0(sp)
8114acfc:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114ad00:	d0a0b60b 	ldhu	r2,-32040(gp)
8114ad04:	10800044 	addi	r2,r2,1
8114ad08:	d0a0b60d 	sth	r2,-32040(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8114ad0c:	d0a0b60b 	ldhu	r2,-32040(gp)
8114ad10:	10bfffcc 	andi	r2,r2,65535
8114ad14:	10807d30 	cmpltui	r2,r2,500
8114ad18:	1000021e 	bne	r2,zero,8114ad24 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8114ad1c:	d020b60d 	sth	zero,-32040(gp)
        OSTmrSignal();
8114ad20:	11416380 	call	81141638 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8114ad24:	0001883a 	nop
8114ad28:	e037883a 	mov	sp,fp
8114ad2c:	dfc00117 	ldw	ra,4(sp)
8114ad30:	df000017 	ldw	fp,0(sp)
8114ad34:	dec00204 	addi	sp,sp,8
8114ad38:	f800283a 	ret

8114ad3c <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8114ad3c:	deffff04 	addi	sp,sp,-4
8114ad40:	de00012e 	bgeu	sp,et,8114ad48 <OSInitHookBegin+0xc>
8114ad44:	003b68fa 	trap	3
8114ad48:	df000015 	stw	fp,0(sp)
8114ad4c:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114ad50:	d020b60d 	sth	zero,-32040(gp)
#endif
}
8114ad54:	0001883a 	nop
8114ad58:	e037883a 	mov	sp,fp
8114ad5c:	df000017 	ldw	fp,0(sp)
8114ad60:	dec00104 	addi	sp,sp,4
8114ad64:	f800283a 	ret

8114ad68 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8114ad68:	deffff04 	addi	sp,sp,-4
8114ad6c:	de00012e 	bgeu	sp,et,8114ad74 <OSInitHookEnd+0xc>
8114ad70:	003b68fa 	trap	3
8114ad74:	df000015 	stw	fp,0(sp)
8114ad78:	d839883a 	mov	fp,sp
}
8114ad7c:	0001883a 	nop
8114ad80:	e037883a 	mov	sp,fp
8114ad84:	df000017 	ldw	fp,0(sp)
8114ad88:	dec00104 	addi	sp,sp,4
8114ad8c:	f800283a 	ret

8114ad90 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114ad90:	deffff04 	addi	sp,sp,-4
8114ad94:	de00012e 	bgeu	sp,et,8114ad9c <OSTaskIdleHook+0xc>
8114ad98:	003b68fa 	trap	3
8114ad9c:	df000015 	stw	fp,0(sp)
8114ada0:	d839883a 	mov	fp,sp
}
8114ada4:	0001883a 	nop
8114ada8:	e037883a 	mov	sp,fp
8114adac:	df000017 	ldw	fp,0(sp)
8114adb0:	dec00104 	addi	sp,sp,4
8114adb4:	f800283a 	ret

8114adb8 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8114adb8:	defffe04 	addi	sp,sp,-8
8114adbc:	de00012e 	bgeu	sp,et,8114adc4 <OSTCBInitHook+0xc>
8114adc0:	003b68fa 	trap	3
8114adc4:	df000115 	stw	fp,4(sp)
8114adc8:	df000104 	addi	fp,sp,4
8114adcc:	e13fff15 	stw	r4,-4(fp)
}
8114add0:	0001883a 	nop
8114add4:	e037883a 	mov	sp,fp
8114add8:	df000017 	ldw	fp,0(sp)
8114addc:	dec00104 	addi	sp,sp,4
8114ade0:	f800283a 	ret

8114ade4 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114ade4:	defffe04 	addi	sp,sp,-8
8114ade8:	de00012e 	bgeu	sp,et,8114adf0 <alt_exception_cause_generated_bad_addr+0xc>
8114adec:	003b68fa 	trap	3
8114adf0:	df000115 	stw	fp,4(sp)
8114adf4:	df000104 	addi	fp,sp,4
8114adf8:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8114adfc:	e0bfff17 	ldw	r2,-4(fp)
8114ae00:	10bffe84 	addi	r2,r2,-6
8114ae04:	10c00428 	cmpgeui	r3,r2,16
8114ae08:	18001a1e 	bne	r3,zero,8114ae74 <alt_exception_cause_generated_bad_addr+0x90>
8114ae0c:	100690ba 	slli	r3,r2,2
8114ae10:	00a04574 	movhi	r2,33045
8114ae14:	10ab8904 	addi	r2,r2,-20956
8114ae18:	1885883a 	add	r2,r3,r2
8114ae1c:	10800017 	ldw	r2,0(r2)
8114ae20:	1000683a 	jmp	r2
8114ae24:	8114ae64 	muli	r4,r16,21177
8114ae28:	8114ae64 	muli	r4,r16,21177
8114ae2c:	8114ae74 	orhi	r4,r16,21177
8114ae30:	8114ae74 	orhi	r4,r16,21177
8114ae34:	8114ae74 	orhi	r4,r16,21177
8114ae38:	8114ae64 	muli	r4,r16,21177
8114ae3c:	8114ae6c 	andhi	r4,r16,21177
8114ae40:	8114ae74 	orhi	r4,r16,21177
8114ae44:	8114ae64 	muli	r4,r16,21177
8114ae48:	8114ae64 	muli	r4,r16,21177
8114ae4c:	8114ae74 	orhi	r4,r16,21177
8114ae50:	8114ae64 	muli	r4,r16,21177
8114ae54:	8114ae6c 	andhi	r4,r16,21177
8114ae58:	8114ae74 	orhi	r4,r16,21177
8114ae5c:	8114ae74 	orhi	r4,r16,21177
8114ae60:	8114ae64 	muli	r4,r16,21177
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114ae64:	00800044 	movi	r2,1
8114ae68:	00000306 	br	8114ae78 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8114ae6c:	0005883a 	mov	r2,zero
8114ae70:	00000106 	br	8114ae78 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114ae74:	0005883a 	mov	r2,zero
  }
}
8114ae78:	e037883a 	mov	sp,fp
8114ae7c:	df000017 	ldw	fp,0(sp)
8114ae80:	dec00104 	addi	sp,sp,4
8114ae84:	f800283a 	ret

8114ae88 <exit>:
8114ae88:	defffe04 	addi	sp,sp,-8
8114ae8c:	000b883a 	mov	r5,zero
8114ae90:	de00012e 	bgeu	sp,et,8114ae98 <exit+0x10>
8114ae94:	003b68fa 	trap	3
8114ae98:	dc000015 	stw	r16,0(sp)
8114ae9c:	dfc00115 	stw	ra,4(sp)
8114aea0:	2021883a 	mov	r16,r4
8114aea4:	114b0300 	call	8114b030 <__call_exitprocs>
8114aea8:	00a04574 	movhi	r2,33045
8114aeac:	108bec04 	addi	r2,r2,12208
8114aeb0:	11000017 	ldw	r4,0(r2)
8114aeb4:	20800f17 	ldw	r2,60(r4)
8114aeb8:	10000126 	beq	r2,zero,8114aec0 <exit+0x38>
8114aebc:	103ee83a 	callr	r2
8114aec0:	8009883a 	mov	r4,r16
8114aec4:	114b1b80 	call	8114b1b8 <_exit>

8114aec8 <memcmp>:
8114aec8:	01c000c4 	movi	r7,3
8114aecc:	3980192e 	bgeu	r7,r6,8114af34 <memcmp+0x6c>
8114aed0:	2144b03a 	or	r2,r4,r5
8114aed4:	11c4703a 	and	r2,r2,r7
8114aed8:	10000f26 	beq	r2,zero,8114af18 <memcmp+0x50>
8114aedc:	20800003 	ldbu	r2,0(r4)
8114aee0:	28c00003 	ldbu	r3,0(r5)
8114aee4:	10c0151e 	bne	r2,r3,8114af3c <memcmp+0x74>
8114aee8:	31bfff84 	addi	r6,r6,-2
8114aeec:	01ffffc4 	movi	r7,-1
8114aef0:	00000406 	br	8114af04 <memcmp+0x3c>
8114aef4:	20800003 	ldbu	r2,0(r4)
8114aef8:	28c00003 	ldbu	r3,0(r5)
8114aefc:	31bfffc4 	addi	r6,r6,-1
8114af00:	10c00e1e 	bne	r2,r3,8114af3c <memcmp+0x74>
8114af04:	21000044 	addi	r4,r4,1
8114af08:	29400044 	addi	r5,r5,1
8114af0c:	31fff91e 	bne	r6,r7,8114aef4 <__reset+0xfb12aef4>
8114af10:	0005883a 	mov	r2,zero
8114af14:	f800283a 	ret
8114af18:	20c00017 	ldw	r3,0(r4)
8114af1c:	28800017 	ldw	r2,0(r5)
8114af20:	18bfee1e 	bne	r3,r2,8114aedc <__reset+0xfb12aedc>
8114af24:	31bfff04 	addi	r6,r6,-4
8114af28:	21000104 	addi	r4,r4,4
8114af2c:	29400104 	addi	r5,r5,4
8114af30:	39bff936 	bltu	r7,r6,8114af18 <__reset+0xfb12af18>
8114af34:	303fe91e 	bne	r6,zero,8114aedc <__reset+0xfb12aedc>
8114af38:	003ff506 	br	8114af10 <__reset+0xfb12af10>
8114af3c:	10c5c83a 	sub	r2,r2,r3
8114af40:	f800283a 	ret

8114af44 <strncpy>:
8114af44:	2906b03a 	or	r3,r5,r4
8114af48:	18c000cc 	andi	r3,r3,3
8114af4c:	2005883a 	mov	r2,r4
8114af50:	18002c1e 	bne	r3,zero,8114b004 <strncpy+0xc0>
8114af54:	010000c4 	movi	r4,3
8114af58:	21802a2e 	bgeu	r4,r6,8114b004 <strncpy+0xc0>
8114af5c:	033fbff4 	movhi	r12,65279
8114af60:	02e02074 	movhi	r11,32897
8114af64:	633fbfc4 	addi	r12,r12,-257
8114af68:	5ae02004 	addi	r11,r11,-32640
8114af6c:	100f883a 	mov	r7,r2
8114af70:	2a000017 	ldw	r8,0(r5)
8114af74:	3815883a 	mov	r10,r7
8114af78:	4313883a 	add	r9,r8,r12
8114af7c:	0206303a 	nor	r3,zero,r8
8114af80:	48c6703a 	and	r3,r9,r3
8114af84:	1ac6703a 	and	r3,r3,r11
8114af88:	1800261e 	bne	r3,zero,8114b024 <strncpy+0xe0>
8114af8c:	39c00104 	addi	r7,r7,4
8114af90:	52000015 	stw	r8,0(r10)
8114af94:	31bfff04 	addi	r6,r6,-4
8114af98:	3811883a 	mov	r8,r7
8114af9c:	29400104 	addi	r5,r5,4
8114afa0:	21bff336 	bltu	r4,r6,8114af70 <__reset+0xfb12af70>
8114afa4:	30001e26 	beq	r6,zero,8114b020 <strncpy+0xdc>
8114afa8:	29c00003 	ldbu	r7,0(r5)
8114afac:	31bfffc4 	addi	r6,r6,-1
8114afb0:	40c00044 	addi	r3,r8,1
8114afb4:	41c00005 	stb	r7,0(r8)
8114afb8:	39c03fcc 	andi	r7,r7,255
8114afbc:	39c0201c 	xori	r7,r7,128
8114afc0:	39ffe004 	addi	r7,r7,-128
8114afc4:	29400044 	addi	r5,r5,1
8114afc8:	38001026 	beq	r7,zero,8114b00c <strncpy+0xc8>
8114afcc:	1811883a 	mov	r8,r3
8114afd0:	00000906 	br	8114aff8 <strncpy+0xb4>
8114afd4:	29c00003 	ldbu	r7,0(r5)
8114afd8:	31bfffc4 	addi	r6,r6,-1
8114afdc:	29400044 	addi	r5,r5,1
8114afe0:	41c00005 	stb	r7,0(r8)
8114afe4:	39c03fcc 	andi	r7,r7,255
8114afe8:	39c0201c 	xori	r7,r7,128
8114afec:	39ffe004 	addi	r7,r7,-128
8114aff0:	1811883a 	mov	r8,r3
8114aff4:	38000526 	beq	r7,zero,8114b00c <strncpy+0xc8>
8114aff8:	18c00044 	addi	r3,r3,1
8114affc:	303ff51e 	bne	r6,zero,8114afd4 <__reset+0xfb12afd4>
8114b000:	f800283a 	ret
8114b004:	1011883a 	mov	r8,r2
8114b008:	003fe606 	br	8114afa4 <__reset+0xfb12afa4>
8114b00c:	30000726 	beq	r6,zero,8114b02c <strncpy+0xe8>
8114b010:	198d883a 	add	r6,r3,r6
8114b014:	18000005 	stb	zero,0(r3)
8114b018:	18c00044 	addi	r3,r3,1
8114b01c:	19bffd1e 	bne	r3,r6,8114b014 <__reset+0xfb12b014>
8114b020:	f800283a 	ret
8114b024:	3811883a 	mov	r8,r7
8114b028:	003fdf06 	br	8114afa8 <__reset+0xfb12afa8>
8114b02c:	f800283a 	ret

8114b030 <__call_exitprocs>:
8114b030:	defff504 	addi	sp,sp,-44
8114b034:	de00012e 	bgeu	sp,et,8114b03c <__call_exitprocs+0xc>
8114b038:	003b68fa 	trap	3
8114b03c:	df000915 	stw	fp,36(sp)
8114b040:	dd400615 	stw	r21,24(sp)
8114b044:	dc800315 	stw	r18,12(sp)
8114b048:	dfc00a15 	stw	ra,40(sp)
8114b04c:	ddc00815 	stw	r23,32(sp)
8114b050:	dd800715 	stw	r22,28(sp)
8114b054:	dd000515 	stw	r20,20(sp)
8114b058:	dcc00415 	stw	r19,16(sp)
8114b05c:	dc400215 	stw	r17,8(sp)
8114b060:	dc000115 	stw	r16,4(sp)
8114b064:	d9000015 	stw	r4,0(sp)
8114b068:	2839883a 	mov	fp,r5
8114b06c:	04800044 	movi	r18,1
8114b070:	057fffc4 	movi	r21,-1
8114b074:	00a04574 	movhi	r2,33045
8114b078:	108bec04 	addi	r2,r2,12208
8114b07c:	12000017 	ldw	r8,0(r2)
8114b080:	45005217 	ldw	r20,328(r8)
8114b084:	44c05204 	addi	r19,r8,328
8114b088:	a0001c26 	beq	r20,zero,8114b0fc <__call_exitprocs+0xcc>
8114b08c:	a0800117 	ldw	r2,4(r20)
8114b090:	15ffffc4 	addi	r23,r2,-1
8114b094:	b8000d16 	blt	r23,zero,8114b0cc <__call_exitprocs+0x9c>
8114b098:	14000044 	addi	r16,r2,1
8114b09c:	8421883a 	add	r16,r16,r16
8114b0a0:	8421883a 	add	r16,r16,r16
8114b0a4:	84402004 	addi	r17,r16,128
8114b0a8:	a463883a 	add	r17,r20,r17
8114b0ac:	a421883a 	add	r16,r20,r16
8114b0b0:	e0001e26 	beq	fp,zero,8114b12c <__call_exitprocs+0xfc>
8114b0b4:	80804017 	ldw	r2,256(r16)
8114b0b8:	e0801c26 	beq	fp,r2,8114b12c <__call_exitprocs+0xfc>
8114b0bc:	bdffffc4 	addi	r23,r23,-1
8114b0c0:	843fff04 	addi	r16,r16,-4
8114b0c4:	8c7fff04 	addi	r17,r17,-4
8114b0c8:	bd7ff91e 	bne	r23,r21,8114b0b0 <__reset+0xfb12b0b0>
8114b0cc:	00800034 	movhi	r2,0
8114b0d0:	10800004 	addi	r2,r2,0
8114b0d4:	10000926 	beq	r2,zero,8114b0fc <__call_exitprocs+0xcc>
8114b0d8:	a0800117 	ldw	r2,4(r20)
8114b0dc:	1000301e 	bne	r2,zero,8114b1a0 <__call_exitprocs+0x170>
8114b0e0:	a0800017 	ldw	r2,0(r20)
8114b0e4:	10003226 	beq	r2,zero,8114b1b0 <__call_exitprocs+0x180>
8114b0e8:	a009883a 	mov	r4,r20
8114b0ec:	98800015 	stw	r2,0(r19)
8114b0f0:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114b0f4:	9d000017 	ldw	r20,0(r19)
8114b0f8:	a03fe41e 	bne	r20,zero,8114b08c <__reset+0xfb12b08c>
8114b0fc:	dfc00a17 	ldw	ra,40(sp)
8114b100:	df000917 	ldw	fp,36(sp)
8114b104:	ddc00817 	ldw	r23,32(sp)
8114b108:	dd800717 	ldw	r22,28(sp)
8114b10c:	dd400617 	ldw	r21,24(sp)
8114b110:	dd000517 	ldw	r20,20(sp)
8114b114:	dcc00417 	ldw	r19,16(sp)
8114b118:	dc800317 	ldw	r18,12(sp)
8114b11c:	dc400217 	ldw	r17,8(sp)
8114b120:	dc000117 	ldw	r16,4(sp)
8114b124:	dec00b04 	addi	sp,sp,44
8114b128:	f800283a 	ret
8114b12c:	a0800117 	ldw	r2,4(r20)
8114b130:	80c00017 	ldw	r3,0(r16)
8114b134:	10bfffc4 	addi	r2,r2,-1
8114b138:	15c01426 	beq	r2,r23,8114b18c <__call_exitprocs+0x15c>
8114b13c:	80000015 	stw	zero,0(r16)
8114b140:	183fde26 	beq	r3,zero,8114b0bc <__reset+0xfb12b0bc>
8114b144:	95c8983a 	sll	r4,r18,r23
8114b148:	a0806217 	ldw	r2,392(r20)
8114b14c:	a5800117 	ldw	r22,4(r20)
8114b150:	2084703a 	and	r2,r4,r2
8114b154:	10000b26 	beq	r2,zero,8114b184 <__call_exitprocs+0x154>
8114b158:	a0806317 	ldw	r2,396(r20)
8114b15c:	2088703a 	and	r4,r4,r2
8114b160:	20000c1e 	bne	r4,zero,8114b194 <__call_exitprocs+0x164>
8114b164:	89400017 	ldw	r5,0(r17)
8114b168:	d9000017 	ldw	r4,0(sp)
8114b16c:	183ee83a 	callr	r3
8114b170:	a0800117 	ldw	r2,4(r20)
8114b174:	15bfbf1e 	bne	r2,r22,8114b074 <__reset+0xfb12b074>
8114b178:	98800017 	ldw	r2,0(r19)
8114b17c:	153fcf26 	beq	r2,r20,8114b0bc <__reset+0xfb12b0bc>
8114b180:	003fbc06 	br	8114b074 <__reset+0xfb12b074>
8114b184:	183ee83a 	callr	r3
8114b188:	003ff906 	br	8114b170 <__reset+0xfb12b170>
8114b18c:	a5c00115 	stw	r23,4(r20)
8114b190:	003feb06 	br	8114b140 <__reset+0xfb12b140>
8114b194:	89000017 	ldw	r4,0(r17)
8114b198:	183ee83a 	callr	r3
8114b19c:	003ff406 	br	8114b170 <__reset+0xfb12b170>
8114b1a0:	a0800017 	ldw	r2,0(r20)
8114b1a4:	a027883a 	mov	r19,r20
8114b1a8:	1029883a 	mov	r20,r2
8114b1ac:	003fb606 	br	8114b088 <__reset+0xfb12b088>
8114b1b0:	0005883a 	mov	r2,zero
8114b1b4:	003ffb06 	br	8114b1a4 <__reset+0xfb12b1a4>

8114b1b8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114b1b8:	defffc04 	addi	sp,sp,-16
8114b1bc:	de00012e 	bgeu	sp,et,8114b1c4 <_exit+0xc>
8114b1c0:	003b68fa 	trap	3
8114b1c4:	dfc00315 	stw	ra,12(sp)
8114b1c8:	df000215 	stw	fp,8(sp)
8114b1cc:	df000204 	addi	fp,sp,8
8114b1d0:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114b1d4:	d0a01217 	ldw	r2,-32696(gp)
8114b1d8:	10800058 	cmpnei	r2,r2,1
8114b1dc:	1000031e 	bne	r2,zero,8114b1ec <_exit+0x34>
8114b1e0:	01204574 	movhi	r4,33045
8114b1e4:	21046f04 	addi	r4,r4,4540
8114b1e8:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8114b1ec:	d0a01217 	ldw	r2,-32696(gp)
8114b1f0:	10800058 	cmpnei	r2,r2,1
8114b1f4:	1000041e 	bne	r2,zero,8114b208 <_exit+0x50>
8114b1f8:	e17fff17 	ldw	r5,-4(fp)
8114b1fc:	01204574 	movhi	r4,33045
8114b200:	21047a04 	addi	r4,r4,4584
8114b204:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114b208:	d0a01217 	ldw	r2,-32696(gp)
8114b20c:	10800058 	cmpnei	r2,r2,1
8114b210:	1000031e 	bne	r2,zero,8114b220 <_exit+0x68>
8114b214:	01204574 	movhi	r4,33045
8114b218:	21048504 	addi	r4,r4,4628
8114b21c:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
  ALT_OS_STOP();
8114b220:	d0209105 	stb	zero,-32188(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114b224:	d0a01217 	ldw	r2,-32696(gp)
8114b228:	10800058 	cmpnei	r2,r2,1
8114b22c:	1000031e 	bne	r2,zero,8114b23c <_exit+0x84>
8114b230:	01204574 	movhi	r4,33045
8114b234:	21048f04 	addi	r4,r4,4668
8114b238:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
8114b23c:	e0bfff17 	ldw	r2,-4(fp)
8114b240:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114b244:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8114b248:	10000226 	beq	r2,zero,8114b254 <_exit+0x9c>
    ALT_SIM_FAIL();
8114b24c:	002af070 	cmpltui	zero,zero,43969
8114b250:	00000106 	br	8114b258 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114b254:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8114b258:	d0a01217 	ldw	r2,-32696(gp)
8114b25c:	10800058 	cmpnei	r2,r2,1
8114b260:	1000031e 	bne	r2,zero,8114b270 <_exit+0xb8>
8114b264:	01204574 	movhi	r4,33045
8114b268:	21049904 	addi	r4,r4,4708
8114b26c:	1136cc80 	call	81136cc8 <alt_log_printf_proc>
  while (1);
8114b270:	003fff06 	br	8114b270 <__reset+0xfb12b270>
