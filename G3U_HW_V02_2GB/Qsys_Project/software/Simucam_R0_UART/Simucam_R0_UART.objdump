
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8010025c

Program Header:
    LOAD off    0x00001020 vaddr 0x80100020 paddr 0x80100020 align 2**12
         filesz 0x0004a2c0 memsz 0x00065020 flags rwx
    LOAD off    0x0004c000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  0004c000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  80100020  80100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00046bdc  8010025c  8010025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000016b8  80146e38  80146e38  00047e38  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df0  801484f0  801484f0  000494f0  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001ad60  8014a2e0  8014a2e0  0004b2e0  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  80165040  80165040  0004c000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  0004c000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0004c000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001bb0  00000000  00000000  0004c028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000616e8  00000000  00000000  0004dbd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00013905  00000000  00000000  000af2c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001f454  00000000  00000000  000c2bc5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000098e0  00000000  00000000  000e201c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000ccb5  00000000  00000000  000eb8fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0002027b  00000000  00000000  000f85b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0011882c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00001ec0  00000000  00000000  00118870  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00126d7d  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  00126d83  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00126d8f  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00126d90  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00126d91  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00126d95  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00126d99  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000004  00000000  00000000  00126d9d  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  00126da1  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  00126dab  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  00126db5  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  00126dc6  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00250905  00000000  00000000  00126e05  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
80100020 l    d  .exceptions	00000000 .exceptions
8010025c l    d  .text	00000000 .text
80146e38 l    d  .rodata	00000000 .rodata
801484f0 l    d  .rwdata	00000000 .rwdata
8014a2e0 l    d  .bss	00000000 .bss
80165040 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
80100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
80102bf8 l     F .text	00000050 uliCommReadReg
80102ba4 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
8010353c l     F .text	00000050 uliDpktReadReg
801034e8 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
8014a308 l     O .bss	00000004 viCh1HoldContext
8014a30c l     O .bss	00000004 viCh2HoldContext
8014a310 l     O .bss	00000004 viCh3HoldContext
8014a314 l     O .bss	00000004 viCh4HoldContext
8014a318 l     O .bss	00000004 viCh5HoldContext
8014a31c l     O .bss	00000004 viCh6HoldContext
8014a320 l     O .bss	00000004 viCh7HoldContext
8014a324 l     O .bss	00000004 viCh8HoldContext
80107284 l     F .text	00000054 vFeebWriteReg
801072d8 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
8014a328 l     O .bss	00000004 viCh1HoldContext
8014a32c l     O .bss	00000004 viCh2HoldContext
8014a330 l     O .bss	00000004 viCh3HoldContext
8014a334 l     O .bss	00000004 viCh4HoldContext
8014a338 l     O .bss	00000004 viCh5HoldContext
8014a33c l     O .bss	00000004 viCh6HoldContext
8014a340 l     O .bss	00000004 viCh7HoldContext
8014a344 l     O .bss	00000004 viCh8HoldContext
8010a6b4 l     F .text	00000054 vRmapWriteReg
8010a758 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8010b0ec l     F .text	00000050 uliSpwcReadReg
8010b098 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8014a20d l     O .rwdata	00000001 ucIoValue
8010b2ec l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8010bbdc l     F .text	0000013c msgdma_write_extended_descriptor
8010bd18 l     F .text	00000164 msgdma_construct_extended_descriptor
8010be7c l     F .text	000002e0 msgdma_descriptor_async_transfer
8010c15c l     F .text	0000038c msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8010cc68 l     F .text	00000054 vRstcWriteReg
8010ccbc l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8014a34c l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
8014a354 l     O .bss	00000001 ucIterationSide
8014a358 l     O .bss	00000004 pxNFee.5777
8014a35c l     O .bss	00000004 incrementador.5782
8014a360 l     O .bss	00000004 tCodFeeTask.5780
00000000 l    df *ABS*	00000000 fee_task1.c
8014a364 l     O .bss	00000001 ucIterationSide
8014a368 l     O .bss	00000004 pxNFee.5779
8014a36c l     O .bss	00000004 incrementador.5784
8014a370 l     O .bss	00000004 tCodFeeTask.5782
00000000 l    df *ABS*	00000000 fee_task2.c
8014a374 l     O .bss	00000001 ucIterationSide
8014a378 l     O .bss	00000004 pxNFee.5779
8014a37c l     O .bss	00000004 incrementador.5784
8014a380 l     O .bss	00000004 tCodFeeTask.5782
00000000 l    df *ABS*	00000000 fee_task3.c
8014a384 l     O .bss	00000001 ucIterationSide
8014a388 l     O .bss	00000004 pxNFee.5779
8014a38c l     O .bss	00000004 incrementador.5784
8014a390 l     O .bss	00000004 tCodFeeTask.5782
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
8014a394 l     O .bss	00000004 xRAckLocal.5694
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
8014a398 l     O .bss	00000004 bDmaBack.5735
8014a39c l     O .bss	00000001 ucWhoGetDMA.5736
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8014a39e l     O .bss	00000004 xSAckLocal.5679
00000000 l    df *ABS*	00000000 parser_comm_task.c
8014a50c l     O .bss	0000004c PreParsedLocal.5732
8014a558 l     O .bss	00000054 xTcPusL.5731
00000000 l    df *ABS*	00000000 receiver_uart_task.c
8014a5ac l     O .bss	0000004c xPreParsedReader.5724
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8014a5f8 l     O .bss	00000054 xPusLocal.5977
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_bind_channel_FEEinst.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8014764e l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 atoll.c
00000000 l    df *ABS*	00000000 ctype_.c
8014797b l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoll.c
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
80147b42 l     O .rodata	00000010 zeroes.4389
80147b52 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfscanf.c
80147b6a l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 dtoa.c
80125a14 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 findfp.c
801272ac l     F .text	00000008 __fp_unlock
801272c0 l     F .text	000001a4 __sinit.part.1
80127464 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
801484f0 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
80148934 l     O .rwdata	00000020 lc_ctype_charset
80148914 l     O .rwdata	00000020 lc_message_charset
80148954 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
80147bac l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
8012a6e8 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8012acb8 l     F .text	0000006c sulp
80147cf4 l     O .rodata	00000014 fpi.2737
80147d08 l     O .rodata	00000028 tinytens
80147ce0 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
80147d40 l     O .rodata	00000010 blanks.4332
80147d30 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8012e6f0 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
80131a20 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
80131b64 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
80131b98 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
80131e1c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
80131f14 l       .text	00000000 tx_next_char
80131f3c l       .text	00000000 end_tx
80131f1c l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
80132a18 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_read.c
80132c94 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
8014a250 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
80133234 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
8014a25c l     O .rwdata	00000004 lockid
8014a454 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
8014a260 l     O .rwdata	00000004 lockid
8014a45c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
80134cc0 l     F .text	00000050 OS_InitMisc
80134d10 l     F .text	00000074 OS_InitRdyList
80134e94 l     F .text	000000ec OS_InitTCBList
80134bd8 l     F .text	000000e8 OS_InitEventList
80134d84 l     F .text	00000088 OS_InitTaskIdle
80134e0c l     F .text	00000088 OS_InitTaskStat
80135124 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
80136f3c l     F .text	000000fc OS_FlagTaskRdy
80136cec l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
80138828 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8013d258 l     F .text	00000044 OSTmr_Lock
8013ccf8 l     F .text	00000074 OSTmr_Alloc
8013d29c l     F .text	0000003c OSTmr_Unlock
8013d15c l     F .text	000000fc OSTmr_Unlink
8013cd6c l     F .text	000000a4 OSTmr_Free
8013d00c l     F .text	00000150 OSTmr_Link
8013cf84 l     F .text	00000088 OSTmr_InitTask
8013d2d8 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
8013d3e8 l     F .text	0000003c alt_dev_reg
80148fd8 l     O .rwdata	0000106c jtag_uart_0
8014a044 l     O .rwdata	000000d0 rs232_uart
8014a114 l     O .rwdata	00000064 dma_DDR_M1
8014a178 l     O .rwdata	00000064 dma_DDR_M2
8014a1dc l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
80141c78 l     F .text	000002bc altera_avalon_jtag_uart_irq
80141f34 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
80142738 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
80142ad0 l     F .text	000000a4 altera_avalon_uart_irq
80142b74 l     F .text	00000140 altera_avalon_uart_rxirq
80142cb4 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
80142ebc l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
80143170 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
801433f4 l     F .text	00000044 alt_get_errno
80143438 l     F .text	0000009c alt_msgdma_write_standard_descriptor
801434d4 l     F .text	00000134 alt_msgdma_write_extended_descriptor
80143608 l     F .text	0000018c alt_msgdma_irq
80143794 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
80143828 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
80143984 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
80143cc4 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
801443cc l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
80144478 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
80145644 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
80145a94 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
80145be4 l     F .text	00000044 alt_get_errno
80145c28 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
8014a504 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8014a508 g     O .bss	00000004 alt_instruction_exception_handler
801077fc g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
8014afd4 g     O .bss	00001000 vFeeTask0_stk
801064e0 g     F .text	00000094 bFeebGetCh2LeftFeeBusy
8011d14c g     F .text	00000028 vFailDeleteInitialization
8011bd0c g     F .text	00000f54 vLoadDebugConfs
8014a4d8 g     O .bss	00000004 aux_status_register
8014bfd4 g     O .bss	00001000 vInAckHandlerTask_stk
80145400 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
80107b38 g     F .text	00000054 uliRmapCh1WriteCmdAddress
8010d2c0 g     F .text	0000004c vSyncInitIrq
801183d4 g     F .text	00000284 vCheckRetransmission128
80129ffc g     F .text	0000007c _mprec_log10
8010d4c8 g     F .text	00000040 bSyncSetMbt
8011da38 g     F .text	00000030 vFailRequestDMAFromIRQ
8010b4d0 g     F .text	00000108 I2C_Read
8014a2ae g     O .rwdata	00000002 OSTaskNameSize
8014cfd4 g     O .bss	00000260 xBuffer64
8012a0f0 g     F .text	0000008c __any_on
8012f654 g     F .text	0000005c _isatty_r
80147bb8 g     O .rodata	00000028 __mprec_tinytens
80107ae4 g     F .text	00000054 bRmapCh8IrqFlagWriteCmd
80132b38 g     F .text	0000015c alt_main
80106850 g     F .text	00000094 bFeebGetCh5LeftFeeBusy
80105a10 g     F .text	00000078 bFeebGetRightBufferEmpty
801216dc g     F .text	000000c8 _puts_r
8014a464 g     O .bss	00000004 OSTmrFreeList
80164f40 g     O .bss	00000100 alt_irq
8012f28c g     F .text	00000068 _lseek_r
8011eb74 g     F .text	00000030 vChangeDefaultAutoResetSync
8013779c g     F .text	000000d4 OS_MemInit
8011da08 g     F .text	00000030 vFailRequestDMA
80105a88 g     F .text	00000094 bFeebGetCh1LeftBufferEmpty
8011b3f4 g     F .text	00000918 vLoadDefaultETHConf
80114be0 g     F .text	0000014c bCheckInAck64
8014d234 g     O .bss	00000150 xPus
8013c238 g     F .text	00000068 OSTimeSet
80117924 g     F .text	000000dc vPusType250run
8011d778 g     F .text	00000028 vCoudlNotCreateNFee2Task
8011d910 g     F .text	00000028 vCouldNotGetMutexMebPus
801316c4 g     F .text	00000088 .hidden __eqdf2
80117f78 g     F .text	00000088 vSendCmdQToDataCTRL
80101174 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8011ea60 g     F .text	00000034 vLoadDefaultSyncSource
8011ceb4 g     F .text	00000028 vFailCreateMutexDMA
8013d8e8 g     F .text	000001ac Check_for_Master_Boot_Record
8015e954 g     O .bss	00000010 OSTmrWheelTbl
80107be0 g     F .text	00000054 uliRmapCh3WriteCmdAddress
8014418c g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8014d384 g     O .bss	00000040 xFeeQueueTBL3
80133924 g     F .text	00000594 OSEventPendMulti
8014a3a8 g     O .bss	00000004 xNfeeSchedule
80165040 g       *ABS*	00000000 __alt_heap_start
80146338 g     F .text	0000002c OSTaskCreateHook
80141760 g     F .text	000001c4 alt_up_sd_card_fclose
8014a3ac g     O .bss	00000004 xSemCountBuffer64
801028e0 g     F .text	000001b0 bCommSetGlobalIrqEn
80108044 g     F .text	00000088 bRmapGetIrqControl
8014a349 g     O .bss	00000001 SspdConfigControl
8010d8e4 g     F .text	00000054 bSyncCtrReset
8014a286 g     O .rwdata	00000002 OSMboxEn
8010fff0 g     F .text	0000026c vQCmdFeeRMAPWaitingSync
8011f3d4 g     F .text	000000a4 aatoh
80133f1c g     F .text	00000054 OSIntEnter
80104488 g     F .text	000000b4 vFeebCh8IrqFlagClrBufferEmpty
8011d0fc g     F .text	00000028 vFailReceiverCreate
8014a3b0 g     O .bss	00000004 xQMaskDataCtrl
801038c8 g     F .text	00000204 vFeebCh2HandleIrq
8012ab70 g     F .text	00000064 __sseek
80127614 g     F .text	00000010 __sinit
8010c5a8 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
80146a94 g     F .text	00000148 __swbuf_r
80118bac g     F .text	00000510 bResourcesInitRTOS
8010abdc g     F .text	000000f4 bSpwcGetLinkError
8014a296 g     O .rwdata	00000002 OSQEn
8010f9fc g     F .text	0000035c vQCmdFeeRMAPinStandBy
801074f0 g     F .text	00000098 vRmapCh4HandleIrq
801283a4 g     F .text	00000084 _setlocale_r
8014a210 g     O .rwdata	00000004 LedsPainelControl
8012746c g     F .text	00000070 __sfmoreglue
8012e028 g     F .text	00000018 ungetc
80104d14 g     F .text	000000e0 bFeebCh1SetBufferSize
801335e0 g     F .text	000000d4 __malloc_unlock
80101470 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
801463b8 g     F .text	00000028 OSTaskStatHook
80117dd4 g     F .text	00000088 vSendCmdQToNFeeCTRL
8011ead0 g     F .text	00000030 vChangeDefaultSyncSource
8014a468 g     O .bss	00000001 OSLockNesting
8014a46c g     O .bss	00000004 OSTmrSemSignal
8011dcd8 g     F .text	000001d0 vNFeeStructureInit
8014a3b4 g     O .bss	00000004 xSemCommInit
80100ff8 g     F .text	00000080 uliXorshift32
8012ad24 g     F .text	00001600 _strtod_r
8014a3b8 g     O .bss	00000004 xSemCountSenderACK
8011f568 g     F .text	00000448 .hidden __divsf3
8014a4fc g     O .bss	00000004 current_sector_modified
8014a2d4 g     O .rwdata	00000002 OSDataSize
8014a470 g     O .bss	00000001 OSRunning
8010aebc g     F .text	000001dc bSpwcInitCh
80132800 g     F .text	00000064 alt_log_jtag_uart_isr_proc
8014d3c4 g     O .bss	00001000 senderTask_stk
80108b84 g     F .text	00000094 bRmapGetMemConfigStat
8014e3c4 g     O .bss	00000100 xNfeeScheduleTBL
80114a98 g     F .text	00000148 bCheckInAck128
80128fc4 g     F .text	0000015c memmove
80146434 g     F .text	0000002c OSInitHookBegin
8010dd80 g     F .text	00000074 bSyncCtrCh8OutEnable
801103c8 g     F .text	00000098 bEnableDbBuffer
8014a2cc g     O .rwdata	00000002 OSTmrSize
801275fc g     F .text	00000018 _cleanup
8011ef18 g     F .text	00000040 siCloseFile
801070a8 g     F .text	000001dc bFeebInitCh
80129120 g     F .text	000000b0 _Balloc
8011eb00 g     F .text	00000038 vLoadDefaultAutoResetSync
80108154 g     F .text	000000dc bRmapSetCodecConfig
8014033c g     F .text	000000cc alt_up_sd_card_is_Present
801440cc g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8014a2e8 g     O .bss	00000004 pxDmaM1Dev
8010120c g     F .text	000000a8 DMA_DISPATCHER_STOP
8013d610 g     F .text	00000054 Save_Modified_Sector
8014a474 g     O .bss	00000004 OSIdleCtr
8014a430 g     O .bss	00000001 alt_log_write_on_flag
8010b13c g     F .text	0000003c bEnableIsoDrivers
8011feac g     F .text	000000dc .hidden __gtdf2
801460c8 g     F .text	0000002c altera_nios2_gen2_irq_init
801461b0 g       .text	00000000 OSStartTsk
8010d63c g     F .text	00000070 bSyncSetNCycles
80135494 g     F .text	000002dc OS_TCBInit
80106978 g     F .text	00000094 bFeebGetCh6LeftFeeBusy
8014a433 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8011e6a4 g     F .text	000000bc vInitSimucamBasicHW
8014e4c4 g     O .bss	00001000 vTimeoutCheckerTask_stk
8010dc98 g     F .text	00000074 bSyncCtrCh6OutEnable
8010b84c g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
8014a4f4 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
8014a478 g     O .bss	00000002 OSTmrUsed
8014a3bc g     O .bss	00000004 xSemCountBuffer128
80101870 g     F .text	000000f8 TEMP_Read
80107f98 g     F .text	000000ac bRmapSetIrqControl
8010508c g     F .text	000000e0 bFeebCh5SetBufferSize
8014f4c4 g     O .bss	00001000 vDataControlTask_stk
80103cd0 g     F .text	00000204 vFeebCh4HandleIrq
8014a2d2 g     O .rwdata	00000002 OSTmrWheelTblSize
8011e348 g     F .text	0000002c cFeeSpwChannelDisable
8014a272 g     O .rwdata	00000002 OSEventSize
8014a47a g     O .bss	00000001 OSPrioHighRdy
8012f5f0 g     F .text	00000064 _fstat_r
80146364 g     F .text	0000002c OSTaskDelHook
8014a424 g     O .bss	00000004 errno
8010e074 g     F .text	0000003c uliSyncGetCtr
801259a4 g     F .text	0000001c __svfscanf
8012aae4 g     F .text	00000008 __seofread
80146190 g       .text	00000000 OSStartHighRdy
8011dc38 g     F .text	00000028 vEvtChangeFeeControllerMode
80115994 g     F .text	000000cc bSendCmdQToNFeeInst
801075f8 g     F .text	00000038 vRmapCh7HandleIrq
80104a24 g     F .text	000000fc vFeebCh6IrqFlagBufferEmpty
8013ac68 g     F .text	000001ec OSTaskCreateExt
8015e928 g     O .bss	00000011 alt_log_write_buf
80102eec g     F .text	00000158 bDpktGetPacketConfig
80107d80 g     F .text	00000050 uliRmapCh8WriteCmdAddress
8011d28c g     F .text	00000028 vFailGetCountSemaphorePreParsedBuffer
8012cb6c g     F .text	00001244 ___svfiprintf_internal_r
80116dc0 g     F .text	00000330 bPreParserV2
8013681c g     F .text	00000068 OSFlagPendGetFlagsRdy
8014a2b2 g     O .rwdata	00000002 OSTaskStatStkSize
80105c44 g     F .text	00000094 bFeebGetCh2RightBufferEmpty
80135968 g     F .text	00000310 OSFlagAccept
80138f44 g     F .text	000000c0 OSQFlush
8014aa74 g     O .bss	00000460 xRmap
801389c0 g     F .text	00000148 OSQAccept
8014a444 g     O .bss	00000004 alt_argv
80104638 g     F .text	000000fc vFeebCh2IrqFlagBufferEmpty
80152208 g       *ABS*	00000000 _gp
8011cf88 g     F .text	00000028 vFailSendPreAckReceiverSemaphore
801330f8 g     F .text	0000013c usleep
80140914 g     F .text	00000384 alt_up_sd_card_fopen
8011edfc g     F .text	00000030 bSDcardIsPresent
80105d6c g     F .text	00000094 bFeebGetCh3RightBufferEmpty
801170f0 g     F .text	000000d0 vSenderComTask
8014047c g     F .text	000000d8 alt_up_sd_card_find_first
8013aab4 g     F .text	000001b4 OSTaskCreate
8011d32c g     F .text	00000028 vFailSendNack
8014a4e8 g     O .bss	00000004 command_argument_register
8013a5bc g     F .text	000004f8 OSTaskChangePrio
80117578 g     F .text	00000090 vPusMebInTaskConfigMode
8011d64c g     F .text	0000002c vCouldNotSendTMPusCommand
8014a460 g     O .bss	00000004 alt_heapsem
8011e1e8 g     F .text	000000b0 vResetMemCCDFEE
80104c1c g     F .text	000000f8 vFeebCh8IrqFlagBufferEmpty
8010bae4 g     F .text	00000080 bSetBoardLeds
80135770 g     F .text	000001f8 OSDebugInit
8013ae54 g     F .text	0000034c OSTaskDel
8011ab48 g     F .text	00000864 vCHConfs
80137870 g     F .text	000001ac OSMutexAccept
801504c4 g     O .bss	00000a4c xSimMeb
8011e588 g     F .text	00000040 vSetTimeCode
80144c74 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
8014a3c0 g     O .bss	00000004 xSemCountPreParsed
80148dbc g     O .rwdata	00000180 alt_fd_list
80148f58 g     O .rwdata	0000001d alt_log_msg_alt_main
8015e964 g     O .bss	00000840 OSFlagTbl
80107880 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8011d028 g     F .text	00000028 vFailGetCountSemaphoreReceiverTask
80107c84 g     F .text	00000054 uliRmapCh5WriteCmdAddress
8011e9b8 g     F .text	0000003c vLoadDefaultRTValue
801349a0 g     F .text	000000c0 OS_EventTaskRemove
80150f10 g     O .bss	00001000 vFeeTask5_stk
8014a432 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
80106aa0 g     F .text	00000094 bFeebGetCh7LeftFeeBusy
8013fb90 g     F .text	00000134 find_first_empty_record_in_root_directory
80145734 g     F .text	00000098 alt_find_dev
80121464 g     F .text	00000150 memcpy
8012f028 g     F .text	00000264 __hexnan
80103320 g     F .text	000001c8 bDpktInitCh
80151f10 g     O .bss	00000160 xBuffer32
8014a29c g     O .rwdata	00000002 OSRdyTblSize
80104734 g     F .text	000000fc vFeebCh3IrqFlagBufferEmpty
8015f1a4 g     O .bss	000001a0 OSTmrTbl
801272b4 g     F .text	0000000c _cleanup_r
8012102c g     F .text	000000e4 .hidden __floatsidf
8011a770 g     F .text	000001a8 vSendPusTM64
8010d438 g     F .text	0000004c ucSyncStatusErrorCode
80117ee4 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8011e444 g     F .text	00000034 cFeeRMAPLogDisable
80115dec g     F .text	00000708 vParserCommTask
80145b60 g     F .text	00000084 alt_io_redirect
8011e3d8 g     F .text	00000034 cFeeRMAPEchoingDisable
8013174c g     F .text	000000f4 .hidden __ltdf2
8011d8c0 g     F .text	00000028 vFailSendPUStoMebTask
80107a8c g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
801055cc g     F .text	000000d8 bFeebSetIrqControl
8011d584 g     F .text	00000028 vCouldNotRetransmitB128TimeoutTask
8014a3c4 g     O .bss	00000004 xMutexReceivedACK
80101f0c g     F .text	000000c4 bSdmaInitM2Dma
8014a304 g     O .bss	00000004 EDpktMode
801450fc g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
80145444 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8010d98c g     F .text	00000054 bSyncCtrErrInj
801453a4 g     F .text	0000005c alt_msgdma_register_callback
8011e760 g     F .text	00000030 bLogWriteSDCard
8011d19c g     F .text	00000028 vFailSetCountSemaphorexBuffer64
80106a0c g     F .text	00000094 bFeebGetCh6RightFeeBusy
801217a4 g     F .text	00000014 puts
8011ef98 g     F .text	000001bc bInitSync
801466d0 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8010d164 g     F .text	00000130 vSyncHandleIrq
801336b4 g     F .text	00000128 OSEventNameGet
8010403c g     F .text	000000b8 vFeebCh2IrqFlagClrBufferEmpty
8014a280 g     O .rwdata	00000002 OSFlagMax
80128d50 g     F .text	000000e0 mbrtowc
80106204 g     F .text	00000094 bFeebGetCh7RightBufferEmpty
8013f788 g     F .text	000001b4 find_first_empty_cluster
80118000 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8010dc24 g     F .text	00000074 bSyncCtrCh5OutEnable
8014a350 g     O .bss	00000001 vucN
8012a8e0 g     F .text	00000074 __fpclassifyd
8010d398 g     F .text	00000054 bSyncStatusExtnIrq
801259c0 g     F .text	00000054 _vfscanf_r
80104928 g     F .text	000000fc vFeebCh5IrqFlagBufferEmpty
80137ef0 g     F .text	000005a4 OSMutexPend
80129f50 g     F .text	000000ac __ratio
80140278 g     F .text	000000c4 alt_up_sd_card_open_dev
8011d678 g     F .text	00000028 vWarnCouldNotgetMutexRetrans128
80133f70 g     F .text	00000100 OSIntExit
8010d508 g     F .text	00000040 bSyncSetBt
80113684 g     F .text	000010fc vFeeTask3
8011d938 g     F .text	00000028 vCouldNotCreateQueueMaskNfeeCtrl
8014a2ba g     O .rwdata	00000002 OSTCBSize
80106328 g     F .text	00000090 bFeebGetCh8RightBufferEmpty
80103f84 g     F .text	000000b8 vFeebCh1IrqFlagClrBufferEmpty
8014a47b g     O .bss	00000001 OSPrioCur
801421a8 g     F .text	000002c4 altera_avalon_jtag_uart_read
8014493c g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
80130268 g     F .text	00000064 .hidden __udivsi3
80131e60 g     F .text	000000ac isatty
8014a348 g     O .bss	00000001 LedsBoardControl
8014a2f0 g     O .bss	00000004 EFeebIrqEmptyBufferFlags
8014a3c8 g     O .bss	00000004 xSemCountReceivedACK
8014a2a0 g     O .rwdata	00000002 OSStkWidth
80128374 g     F .text	00000030 iswspace
80110e84 g     F .text	000000e0 uliReturnMaskG
80147c08 g     O .rodata	000000c8 __mprec_tens
8014a294 g     O .rwdata	00000002 OSPtrSize
8011da68 g     F .text	00000030 vFailSendRMAPFromIRQ
8011d818 g     F .text	00000028 vCoudlNotCreateNFeeControllerTask
80128428 g     F .text	0000000c __locale_charset
8010db3c g     F .text	00000074 bSyncCtrCh3OutEnable
80121c8c g     F .text	0000001c strtoll
80130458 g     F .text	000000c8 .hidden __lesf2
8014a274 g     O .rwdata	00000002 OSEventTblSize
8010453c g     F .text	000000fc vFeebCh1IrqFlagBufferEmpty
8011f4ec g     F .text	0000007c .hidden __fixunsdfsi
801460f4 g       .text	00000000 OSCtxSw
8010b5d8 g     F .text	00000160 I2C_MultipleRead
801329a4 g     F .text	00000074 alt_log_system_clock
8014a420 g     O .bss	00000004 __malloc_top_pad
8014a47c g     O .bss	00000004 OSTCBList
8013ccb8 g     F .text	00000040 OSTmrSignal
8014a428 g     O .bss	00000004 alt_fd_list_lock
8012c698 g     F .text	0000001c strtoul
8014a220 g     O .rwdata	00000004 __mb_cur_max
80128458 g     F .text	0000000c _localeconv_r
8012c6b4 g     F .text	000002e0 _strtoull_r
8010cbf8 g     F .text	00000070 vRstcHoldDeviceReset
80129544 g     F .text	00000044 __i2b
80127d18 g     F .text	000004c4 __sfvwrite_r
8013ea68 g     F .text	000000c0 get_dir_divider_location
80107734 g     F .text	00000040 vRmapCh4IrqFlagClrWriteCmd
8015f344 g     O .bss	00000c30 OSMemTbl
8014a480 g     O .bss	00000001 OSTickStepState
801325b4 g     F .text	00000060 alt_log_printf_proc
8010325c g     F .text	000000c4 bDpktGetPixelDelay
80152070 g     O .bss	00001800 vReceiverUartTask_stk
8012a954 g     F .text	0000005c _sbrk_r
8014a3cc g     O .bss	00000004 xSemTimeoutChecker
8013e728 g     F .text	000000cc filename_to_upper_case
8014a434 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
8014a298 g     O .rwdata	00000002 OSQMax
80140c98 g     F .text	00000090 alt_up_sd_card_set_attributes
80137bec g     F .text	00000304 OSMutexDel
8015ff74 g     O .bss	00001000 OSTaskStatStk
8011ee2c g     F .text	00000030 bSDcardFAT16Check
801373b8 g     F .text	000000f8 OSMemNameGet
8011ce84 g     F .text	00000030 vFailCreateMutexSResources
8013da94 g     F .text	00000284 Read_File_Record_At_Offset
80153870 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8014a278 g     O .rwdata	00000002 OSFlagEn
8012f4b8 g     F .text	00000068 _read_r
8014a2be g     O .rwdata	00000002 OSTimeTickHookEn
80137038 g     F .text	000000ac OS_FlagUnlink
8013940c g     F .text	00000170 OSQPost
80100e1c g     F .text	000001dc bDdr2MemoryRandomReadTest
8014a240 g     O .rwdata	00000004 alt_max_fd
8011d494 g     F .text	00000028 vFailTimeoutCheckerTaskCreate
80134fdc g     F .text	00000070 OS_MemCopy
8013504c g     F .text	000000d8 OS_Sched
8013f30c g     F .text	0000047c find_file_in_directory
8012e32c g     F .text	000000f8 _fclose_r
801372c0 g     F .text	000000f8 OSMemGet
8013b498 g     F .text	000001bc OSTaskNameSet
8012e6c0 g     F .text	00000030 fflush
8014a41c g     O .bss	00000004 __malloc_max_sbrked_mem
8014a484 g     O .bss	00000004 OSCtxSwCtr
8010516c g     F .text	000000e0 bFeebCh6SetBufferSize
80104b20 g     F .text	000000fc vFeebCh7IrqFlagBufferEmpty
801463e0 g     F .text	00000054 OSTimeTickHook
801538b0 g     O .bss	00001000 vOutAckHandlerTask_stk
80131c94 g     F .text	00000188 alt_irq_register
8014a282 g     O .rwdata	00000002 OSFlagNameSize
80121110 g     F .text	00000118 .hidden __extendsfdf2
80134a60 g     F .text	00000108 OS_EventTaskRemoveMulti
8011d6f8 g     F .text	00000030 vFailCreateNFEESyncQueue
80140408 g     F .text	00000074 alt_up_sd_card_is_FAT16
8010b368 g     F .text	00000088 I2C_TestAdress
80130520 g     F .text	000008b4 .hidden __adddf3
8015e93c g     O .bss	00000018 alt_log_jtag_uart_alarm_1
80130324 g     F .text	00000078 .hidden __nesf2
801076f0 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
80103638 g     F .text	0000008c usiLineTrDelayCalcPeriodNs
80134848 g     F .text	00000158 OS_EventTaskWaitMulti
80129ce8 g     F .text	00000114 __b2d
80144674 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
8014a29a g     O .rwdata	00000002 OSQSize
8012fc30 g     F .text	00000540 .hidden __umoddi3
80132a5c g     F .text	000000dc lseek
80139efc g     F .text	00000214 OSSemPend
8011d8e8 g     F .text	00000028 vCouldNotGetCmdQueueMeb
801082bc g     F .text	00000160 bRmapGetCodecStatus
8010acd0 g     F .text	000000d0 bSpwcGetLinkStatus
80106e7c g     F .text	00000088 bFeebGetWindowing
8014a218 g     O .rwdata	00000004 _global_impure_ptr
8010d118 g     F .text	0000004c bSSDisplayUpdate
80121458 g     F .text	0000000c _atoll_r
8013edcc g     F .text	00000540 get_home_directory_cluster_for_file
8012a17c g     F .text	0000056c _realloc_r
8014a284 g     O .rwdata	00000002 OSLowestPrio
80165040 g       *ABS*	00000000 __bss_end
8014599c g     F .text	000000f8 alt_iic_isr_register
801464b0 g     F .text	0000002c OSTCBInitHook
8014a2ca g     O .rwdata	00000002 OSTmrCfgTicksPerSec
80132fe8 g     F .text	00000110 alt_tick
80107dd0 g     F .text	000001c8 vRmapInitIrq
8011d000 g     F .text	00000028 vFailGetMutexSenderTask
8010cb18 g     F .text	0000006c vRstcSimucamReset
801104cc g     F .text	000000a4 bSendRequestNFeeCtrl
80147d50 g     O .rodata	00000100 __hexdig
801451f0 g     F .text	000001b4 alt_msgdma_init
8012f6b0 g     F .text	00000580 .hidden __udivdi3
80116ac8 g     F .text	0000017c setPreAckSenderFreePos
8014a26c g     O .rwdata	00000002 OSEventEn
80147be0 g     O .rodata	00000028 __mprec_bigtens
80129320 g     F .text	0000010c __s2b
8014a2c6 g     O .rwdata	00000002 OSTmrCfgNameSize
801548b0 g     O .bss	00000040 xFeeQueueTBL4
8010d5c8 g     F .text	00000074 bSyncSetPolarity
80118658 g     F .text	0000028c vCheckRetransmission64
80131840 g     F .text	000000b0 .hidden __floatunsidf
8014a438 g     O .bss	00000004 alt_system_clock_in_sec
801327ac g     F .text	00000054 alt_log_jtag_uart_startup_info
8011d264 g     F .text	00000028 vFailFoundBufferRetransmission
80129a20 g     F .text	00000060 __mcmp
8014a500 g     O .bss	00000004 current_sector_index
80142968 g     F .text	00000168 altera_avalon_uart_init
801454cc g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
80102454 g     F .text	0000048c bSdmaDmaM2Transfer
8011e5c8 g     F .text	00000034 vResetTimeCode
8011e31c g     F .text	0000002c cFeeSpwChannelEnable
80127634 g     F .text	00000018 __fp_lock_all
8011db48 g     F .text	00000028 vFailSendMsgDataCTRL
80145948 g     F .text	00000054 alt_ic_irq_enabled
8010b3f0 g     F .text	000000e0 I2C_Write
80107930 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
8014a488 g     O .bss	00000002 OSTmrFree
80136e54 g     F .text	000000e8 OS_FlagInit
80132f44 g     F .text	000000a4 alt_alarm_stop
80121c70 g     F .text	0000001c strtol
8014a431 g     O .bss	00000001 alt_log_sys_clk_on_flag
8013c464 g     F .text	00000140 OSTmrDel
8013d800 g     F .text	000000e8 mark_cluster
8014a2a8 g     O .rwdata	00000002 OSTaskIdleStkSize
8014a42c g     O .bss	00000004 alt_irq_active
80139b1c g     F .text	000000b8 OSSemAccept
80119564 g     F .text	00000204 vFillMemmoryPattern
801219ec g     F .text	00000044 strnlen
801375cc g     F .text	000000e0 OSMemPut
801370e4 g     F .text	000001dc OSMemCreate
8014a48c g     O .bss	00000004 OSIdleCtrMax
8011a918 g     F .text	000001a8 vSendPusTM128
80100104 g     F .exceptions	000000dc alt_irq_handler
80131ffc g     F .text	000005b8 alt_log_private_printf
80148d94 g     O .rwdata	00000028 alt_dev_null
80144284 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8010d588 g     F .text	00000040 bSyncSetOst
8014a2bc g     O .rwdata	00000002 OSTicksPerSec
80148f3c g     O .rwdata	00000019 alt_log_msg_bss
8013fcc4 g     F .text	00000194 convert_filename_to_name_extension
80108c18 g     F .text	000010cc bRmapSetRmapMemHKArea
80106ce8 g     F .text	000000e8 bFeebSetBufferSize
801171c0 g     F .text	0000025c vSimMebTask
8010b738 g     F .text	00000094 i2c_start
801460f4 g       .text	00000000 OSIntCtxSw
8011da98 g     F .text	00000030 vFailSendMsgSync
8010dbb0 g     F .text	00000074 bSyncCtrCh4OutEnable
80145068 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
80131b3c g     F .text	00000028 alt_dcache_flush_all
8012942c g     F .text	00000068 __hi0bits
80117a00 g     F .text	000000f0 vPusType251run
80107cd8 g     F .text	00000054 uliRmapCh6WriteCmdAddress
8011e9f4 g     F .text	0000003c vChangeRTValue
8014a4d4 g     O .bss	00000004 is_sd_card_formated_as_FAT16
80118268 g     F .text	0000016c vCheck
8011dc88 g     F .text	00000050 vNFeeNotInUse
80120fac g     F .text	00000080 .hidden __fixdfsi
80105cd8 g     F .text	00000094 bFeebGetCh3LeftBufferEmpty
80115a60 g     F .text	000000cc bSendCmdQToNFeeInst_Prio
8010532c g     F .text	000000d8 bFeebCh8SetBufferSize
80106f90 g     F .text	0000008c bFeebStopCh
8010e1a0 g     F .text	00000084 uliPerCalcPeriodMs
80115490 g     F .text	00000388 vNFeeControlTask
801548f0 g     O .bss	00001000 vInitialTask_stk
8014a3d0 g     O .bss	00000002 usiIdCMD
8010d890 g     F .text	00000054 bSyncCtrStart
8013f93c g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8012c324 g     F .text	00000018 strtod
8010701c g     F .text	0000008c bFeebClrCh
8014a490 g     O .bss	00000004 OSTCBFreeList
80107a34 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8013a110 g     F .text	00000174 OSSemPendAbort
8011d0a0 g     F .text	00000028 vFailGetMacRTC
80107c34 g     F .text	00000050 uliRmapCh4WriteCmdAddress
80100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8011d444 g     F .text	00000028 vFailCreateTimerRetransmisison
8011d23c g     F .text	00000028 vFailGetCountSemaphorexBuffer32
80119888 g     F .text	000002b8 bSendUART128v2
8011e828 g     F .text	000000ec vSimucamStructureInit
8014a238 g     O .rwdata	00000008 alt_dev_list
80133278 g     F .text	0000010c write
80146830 g     F .text	000000a8 _putc_r
80110570 g     F .text	000000a4 bSendRequestNFeeCtrl_Front
8014a4f8 g     O .bss	00000004 device_pointer
8014a2c0 g     O .rwdata	00000002 OSVersionNbr
80106bc8 g     F .text	00000090 bFeebGetCh8LeftFeeBusy
8013039c g     F .text	000000bc .hidden __gtsf2
8011dbc0 g     F .text	00000028 vFailFlushMEBQueue
801164f4 g     F .text	00000118 getPreParsedPacket
80110368 g     F .text	00000060 bEnableSPWChannel
80131bdc g     F .text	000000b8 fstat
8011e630 g     F .text	00000040 vChangeIdNFEEMaster
8011e40c g     F .text	00000038 cFeeRMAPLogEnable
8010135c g     F .text	00000114 DMA_SINGLE_TRANSFER
8011d4e4 g     F .text	00000028 vFailPostBlockingSemTimeoutTask
8011f254 g     F .text	00000058 _reg_write
8011e670 g     F .text	00000034 vChangeDefaultIdNFEEMaster
8013174c g     F .text	000000f4 .hidden __ledf2
80107588 g     F .text	00000038 vRmapCh5HandleIrq
8011025c g     F .text	00000054 bDisableRmapIRQ
801558f0 g     O .bss	00001000 vStackMonitor_stk
8011d624 g     F .text	00000028 vCouldNotSendLog
8013c6e4 g     F .text	000001b8 OSTmrRemainGet
8014a268 g     O .rwdata	00000004 OSEndiannessTest
8010cd0c g     F .text	00000058 v_spi_start
80129788 g     F .text	00000148 __pow5mult
80107b8c g     F .text	00000054 uliRmapCh2WriteCmdAddress
8011ce44 g     F .text	00000040 vCriticalErrorLedPanel
8014a414 g     O .bss	00000004 __nlocale_changed
801302cc g     F .text	00000058 .hidden __umodsi3
8010d9e0 g     F .text	00000074 bSyncCtrSyncOutEnable
8011ee5c g     F .text	00000080 bInitializeSDCard
8011d3cc g     F .text	00000028 vFailParserCommTaskCreate
8011d5fc g     F .text	00000028 vCouldNotSendReset
801217fc g     F .text	00000038 _scanf_r
8011d41c g     F .text	00000028 vFailOutAckHandlerTaskCreate
8014a27a g     O .rwdata	00000002 OSFlagGrpSize
80117608 g     F .text	000000d8 vPusType250conf
801568f0 g     O .bss	00000058 xInUseRetrans
8010d348 g     F .text	00000050 bSyncIrqFlagSync
801446d4 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8013c89c g     F .text	000000ec OSTmrStateGet
80165040 g       *ABS*	00000000 end
80103f00 g     F .text	0000002c vFeebCh6HandleIrq
8011d2dc g     F .text	00000028 vNoContentInPreParsedBuffer
8011660c g     F .text	00000168 bSendMessagePUStoMebTask
8011d6c8 g     F .text	00000030 vFailCreateNFEEQueue
80121440 g     F .text	0000000c _atoi_r
801431b4 g     F .text	00000240 altera_avalon_uart_write
80131f40 g     F .text	00000054 alt_log_txchar
801197f8 g     F .text	00000090 vCCDChangeValues
80141aa8 g     F .text	000001d0 altera_avalon_jtag_uart_init
801352dc g     F .text	000000e4 OS_TaskStat
801001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8011cf04 g     F .text	00000034 vFailTestCriticasParts
8010644c g     F .text	00000094 bFeebGetCh1RightFeeBusy
801e0000 g       *ABS*	00000000 __alt_stack_pointer
80100c30 g     F .text	000001ec bDdr2MemoryRandomWriteTest
801427bc g     F .text	00000084 alt_avalon_timer_sc_init
80106dd0 g     F .text	000000ac bFeebSetWindowing
801428a8 g     F .text	00000068 altera_avalon_uart_write_fd
801213d0 g     F .text	00000064 .hidden __clzsi2
80142910 g     F .text	00000058 altera_avalon_uart_close_fd
80156948 g     O .bss	00000040 xMebQTBL
8014246c g     F .text	000002cc altera_avalon_jtag_uart_write
8013ce10 g     F .text	00000174 OSTmr_Init
80156988 g     O .bss	00000348 xBuffer128
80127624 g     F .text	00000004 __sfp_lock_acquire
80101968 g     F .text	00000048 sense_log_temp
80128ee0 g     F .text	000000e4 memchr
80134f80 g     F .text	0000005c OS_MemClr
8015e8c8 g     O .bss	00000010 xDefaultsCH
801461d4 g     F .text	00000164 OSTaskStkInit
80121834 g     F .text	00000060 _sprintf_r
801088b0 g     F .text	000002d4 bRmapGetMemConfigArea
8014a3d2 g     O .bss	00000001 SemCount32
80127a00 g     F .text	00000318 _free_r
80145e50 g     F .text	00000234 alt_printf
8011a720 g     F .text	00000050 vTimeoutCheck
8011f304 g     F .text	0000005c _print_codec_status
80128434 g     F .text	00000010 __locale_mb_cur_max
80134590 g     F .text	000001a0 OS_EventTaskRdy
801080cc g     F .text	00000088 bRmapGetIrqFlags
801012b4 g     F .text	000000a8 DMA_DISPATCHER_RESET
80146bf4 g     F .text	00000188 __call_exitprocs
8010669c g     F .text	00000094 bFeebGetCh3RightFeeBusy
8011589c g     F .text	000000f8 vPerformActionNFCRunning
8014a494 g     O .bss	00000001 OSCPUUsage
8011d7c8 g     F .text	00000028 vCoudlNotCreateNFee4Task
8014a410 g     O .bss	00000004 __mlocale_changed
80115818 g     F .text	00000084 vPerformActionNFCConfig
8010d938 g     F .text	00000054 bSyncCtrOneShot
8014a224 g     O .rwdata	00000004 __malloc_sbrk_base
8010025c g     F .text	000000ac _start
8010e0b0 g     F .text	0000003c uliSyncReadStatus
8014a44c g     O .bss	00000004 _alt_tick_rate
80139004 g     F .text	00000294 OSQPend
80121ca8 g     F .text	000002e8 _strtoll_r
80156cd0 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8015e8d8 g     O .bss	00000034 xDefaults
8013bd88 g     F .text	0000010c OSTimeDly
80117894 g     F .text	00000090 vPusMebInTaskRunningMode
8010d30c g     F .text	0000003c vSyncIrqFlagClrSync
80106298 g     F .text	00000090 bFeebGetCh8LeftBufferEmpty
801298d0 g     F .text	00000150 __lshift
80115b2c g     F .text	000002c0 vOutAckHandlerTask
8014412c g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8014a450 g     O .bss	00000004 _alt_nticks
80132cd8 g     F .text	00000104 read
8013d464 g     F .text	000000f0 alt_sys_init
801076ac g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8012c994 g     F .text	000001d8 __ssprint_r
8011f1f4 g     F .text	00000060 bTestSimucamCriticalHW
80105844 g     F .text	00000154 bFeebGetBuffersStatus
8011cc60 g     F .text	000000a4 ucCrc8
801004c4 g     F .text	00000110 bDdr2EepromDump
8014a495 g     O .bss	00000001 OSTaskCtr
80131f0c g       .text	00000000 tx_log_str
8011741c g     F .text	0000015c vPusMebTask
8011a6d0 g     F .text	00000050 siPosStr
80117e5c g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
8012f520 g     F .text	000000d0 strncmp
8010e0ec g     F .text	0000005c bSyncWriteReg
801079dc g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
80106608 g     F .text	00000094 bFeebGetCh3LeftFeeBusy
80105e90 g     F .text	00000090 bFeebGetCh4RightBufferEmpty
8013be94 g     F .text	00000164 OSTimeDlyHMSM
80129588 g     F .text	00000200 __multiply
80142040 g     F .text	00000070 altera_avalon_jtag_uart_close
8010cedc g     F .text	00000058 v_spi_end
8011ef58 g     F .text	00000040 cGetNextChar
801469a8 g     F .text	000000ec strncpy
8014a64c g     O .bss	00000028 __malloc_current_mallinfo
8014a26e g     O .rwdata	00000002 OSEventMax
80130324 g     F .text	00000078 .hidden __eqsf2
80129dfc g     F .text	00000154 __d2b
8013a284 g     F .text	00000118 OSSemPost
801041ac g     F .text	000000b4 vFeebCh4IrqFlagClrBufferEmpty
8011ea30 g     F .text	00000030 vChangeDefaultRTValue
80106730 g     F .text	00000090 bFeebGetCh4LeftFeeBusy
80103f58 g     F .text	0000002c vFeebCh8HandleIrq
8014a4d0 g     O .bss	00000004 initialized
8011a580 g     F .text	00000100 vSendLog
80134104 g     F .text	000000e4 OSSchedUnlock
8011b3ac g     F .text	00000048 ucCheckAndApllySPWChannel
80106170 g     F .text	00000094 bFeebGetCh7LeftBufferEmpty
8010cf34 g     F .text	00000114 RTCC_SPI_R_MAC
8014a24c g     O .rwdata	00000004 alt_log_boot_on_flag
80141924 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8012c444 g     F .text	00000254 _strtoul_r
80156d10 g     O .bss	00000040 xFeeQueueTBL5
801465ec g     F .text	000000e4 alt_get_fd
8014a498 g     O .bss	00000004 OSMemFreeList
80134260 g     F .text	000000b8 OSStatInit
8011f1c0 g     F .text	00000034 bClearCounterSync
80101078 g     F .text	00000064 DMA_OPEN_DEVICE
801649d8 g     O .bss	00000014 search_data
8010a9c0 g     F .text	00000138 bSpwcSetLink
801318f0 g     F .text	00000130 alt_busy_sleep
80136c20 g     F .text	000000cc OSFlagQuery
8010da54 g     F .text	00000074 bSyncCtrCh1OutEnable
8014a2a4 g     O .rwdata	00000002 OSTaskCreateExtEn
8011f360 g     F .text	00000074 _split_codec_status
8012e204 g     F .text	0000005c _close_r
8011d304 g     F .text	00000028 vCouldNotSendEthConfUART
80114e78 g     F .text	00000618 vInitialTask
801326b4 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
80144614 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
801467b4 g     F .text	0000007c memcmp
80134568 g     F .text	00000028 OS_Dummy
801419f4 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
80165040 g       *ABS*	00000000 __alt_stack_base
8010524c g     F .text	000000e0 bFeebCh7SetBufferSize
80141a4c g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
80104260 g     F .text	000000b8 vFeebCh5IrqFlagClrBufferEmpty
80144734 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
80112588 g     F .text	000010fc vFeeTask2
8012e0a8 g     F .text	0000015c __swsetup_r
80160f74 g     O .bss	00000300 OSQTbl
8011d988 g     F .text	00000028 vCouldNotGetQueueMaskNfeeCtrl
8015e90c g     O .bss	0000001c xConfEth
80130dd4 g     F .text	000008f0 .hidden __divdf3
8011ea94 g     F .text	0000003c vChangeSyncSource
801274dc g     F .text	00000120 __sfp
801649ec g     O .bss	00000054 boot_sector_data
8011d960 g     F .text	00000028 vCouldNotCreateQueueMaskDataCtrl
8010ae30 g     F .text	0000008c bSpwcClearTimecode
801011c0 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8012a078 g     F .text	00000078 __copybits
8014898c g     O .rwdata	00000408 __malloc_av_
80127630 g     F .text	00000004 __sinit_lock_release
8014a2e0 g     O .bss	00000004 uliInitialState
8010b7cc g     F .text	00000080 i2c_stop
8011f478 g     F .text	00000040 Verif_Error
8011f4b8 g     F .text	00000034 toInt
8011cfb0 g     F .text	00000028 vFailSendPreAckSenderSemaphore
8014a49c g     O .bss	00000004 OSTCBHighRdy
8011ff88 g     F .text	00000720 .hidden __muldf3
8012aa88 g     F .text	0000005c __sread
80127898 g     F .text	0000003c fread
8014a4a0 g     O .bss	00000004 OSQFreeList
801464dc g     F .text	00000110 alt_find_file
80145688 g     F .text	000000ac alt_dev_llist_insert
801334b8 g     F .text	00000128 __malloc_lock
80132e48 g     F .text	000000fc sbrk
8011e298 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8011d214 g     F .text	00000028 vFailGetCountSemaphorexBuffer64
80121f90 g     F .text	000021e0 ___svfprintf_internal_r
8011aac0 g     F .text	00000088 vTMPusTestConnection
8014a3d4 g     O .bss	00000004 xMebQ
801337dc g     F .text	00000148 OSEventNameSet
8012e65c g     F .text	00000064 _fflush_r
8012e260 g     F .text	000000cc _calloc_r
8014a4a4 g     O .bss	00000001 OSRdyGrp
8011db20 g     F .text	00000028 vFailSendMsgFeeCTRL
8010d484 g     F .text	00000044 ucSyncStatusCycleNumber
80108230 g     F .text	0000008c bRmapGetCodecConfig
8013c988 g     F .text	00000148 OSTmrStart
80103ed4 g     F .text	0000002c vFeebCh5HandleIrq
801010dc g     F .text	0000004c DMA_CONFIG
8014a2e0 g       *ABS*	00000000 __bss_start
80104fb4 g     F .text	000000d8 bFeebCh4SetBufferSize
801215b4 g     F .text	00000128 memset
8011698c g     F .text	0000013c setPreParsedFreePos
8010f6a8 g     F .text	00000190 vQCmdFEEinStandBy
80145190 g     F .text	00000060 alt_msgdma_open
8011ebec g     F .text	00000210 pattern_createPattern
801193d0 g     F .text	00000194 main
8011d050 g     F .text	00000028 vFailGetMutexReceiverTask
80156d50 g     O .bss	00001000 vNFeeControlTask_stk
80107840 g     F .text	00000040 vRmapCh8IrqFlagClrWriteCmd
8011e94c g     F .text	0000003c vChangeEPValue
80107988 g     F .text	00000054 bRmapCh4IrqFlagWriteCmd
8014a448 g     O .bss	00000004 alt_envp
8011db70 g     F .text	00000028 vFailFlushQueue
8014a418 g     O .bss	00000004 __malloc_max_total_mem
80144a34 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8011cd04 g     F .text	0000005c ucCrc8wInit
8011d46c g     F .text	00000028 vCouldNotCheckBufferTimeOutFunction
8014198c g     F .text	00000068 altera_avalon_jtag_uart_write_fd
80101684 g     F .text	000001ec POWER_Read
8010b984 g     F .text	00000160 i2c_read
80146bdc g     F .text	00000018 __swbuf
80148048 g     O .rodata	00000100 OSUnMapTbl
80130458 g     F .text	000000c8 .hidden __ltsf2
80140d28 g     F .text	00000090 alt_up_sd_card_get_attributes
80127664 g     F .text	00000234 _fread_r
8011cfd8 g     F .text	00000028 vFailGetCountSemaphoreSenderTask
8010b178 g     F .text	0000003c bDisableIsoDrivers
8014a29e g     O .rwdata	00000002 OSSemEn
8013d554 g     F .text	000000bc Write_Sector_Data
80141138 g     F .text	00000628 alt_up_sd_card_write
80157d50 g     O .bss	00000010 xFeeQ
80105b1c g     F .text	00000094 bFeebGetCh1RightBufferEmpty
80136884 g     F .text	0000039c OSFlagPost
8012abd4 g     F .text	00000008 __sclose
8011d5ac g     F .text	00000028 vFailStartTimerRetransmission
801e0000 g       *ABS*	00000000 __alt_heap_limit
8012e424 g     F .text	00000014 fclose
80134730 g     F .text	00000118 OS_EventTaskWait
80105e00 g     F .text	00000090 bFeebGetCh4LeftBufferEmpty
8011d534 g     F .text	00000028 vCouldNotRetransmitB32TimeoutTask
80121a30 g     F .text	00000240 _strtol_r
80121228 g     F .text	000001a8 .hidden __truncdfsf2
80157d60 g     O .bss	00000040 xFeeQueueTBL2
80110da4 g     F .text	000000e0 uliReturnMaskR
801353c0 g     F .text	000000d4 OS_TaskStatStkChk
8013b1a0 g     F .text	00000158 OSTaskDelReq
80103044 g     F .text	000000c4 bDpktGetPacketHeader
80107328 g     F .text	00000098 vRmapCh1HandleIrq
80125c1c g     F .text	00001690 _dtoa_r
80144d50 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
80128488 g     F .text	00000814 _malloc_r
80137a1c g     F .text	000001d0 OSMutexCreate
8011d50c g     F .text	00000028 vFailCouldNotRetransmitTimeoutTask
80114d2c g     F .text	0000014c bCheckInAck32
8014a244 g     O .rwdata	00000004 alt_errno
8014487c g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
801341e8 g     F .text	00000078 OSStart
8010aaf8 g     F .text	000000e4 bSpwcGetLink
8010c630 g     F .text	000004e8 POWER_SPI_RW
8012ddb0 g     F .text	000000dc __submore
80132614 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
80133450 g     F .text	00000068 __env_unlock
8011d750 g     F .text	00000028 vCoudlNotCreateNFee1Task
801281dc g     F .text	000000cc _fwalk
801063b8 g     F .text	00000094 bFeebGetCh1LeftFeeBusy
8013b654 g     F .text	000001dc OSTaskResume
801376ac g     F .text	000000f0 OSMemQuery
8014a2b0 g     O .rwdata	00000002 OSTaskStatEn
80165040 g       *ABS*	00000000 __alt_stack_limit
8014a2f4 g     O .bss	00000004 ECommSpwCh
8011eb38 g     F .text	0000003c vChangeAutoResetSync
80128e7c g     F .text	00000064 _mbtowc_r
80114780 g     F .text	00000318 vInAckHandlerTaskV2
8014a28a g     O .rwdata	00000002 OSMemMax
8013957c g     F .text	00000178 OSQPostFront
801468d8 g     F .text	000000d0 putc
80130170 g     F .text	00000084 .hidden __divsi3
8014a4a5 g     O .bss	00000006 OSRdyTbl
8014a264 g     O .rwdata	00000002 OSDebugEn
80148fac g     O .rwdata	0000002a alt_log_msg_cache
801278d4 g     F .text	0000012c _malloc_trim_r
8010a4b0 g     F .text	00000204 bRmapInitCh
8014a404 g     O .bss	00000008 xSdHandle
8011f9b0 g     F .text	00000404 .hidden __mulsf3
8014a27c g     O .rwdata	00000002 OSFlagNodeSize
8014a2e4 g     O .bss	00000004 pnt_memory
8011eba4 g     F .text	00000048 vSyncReset
80110f64 g     F .text	00000528 vLoadCtemp
8010d548 g     F .text	00000040 bSyncSetPer
80100308 g     F .text	000001bc bDdr2EepromTest
8014a4dc g     O .bss	00000004 status_register
8014a2c4 g     O .rwdata	00000002 OSTmrCfgMax
8010dedc g     F .text	00000074 bSyncIrqFlagClrError
8011d354 g     F .text	00000028 vFailSetPreAckSenderBuffer
8012abdc g     F .text	000000dc strcmp
8014a4e4 g     O .bss	00000004 command_register
80138b08 g     F .text	000001b4 OSQCreate
8013b2f8 g     F .text	000001a0 OSTaskNameGet
80157da0 g     O .bss	00001000 vFeeTask4_stk
80158da0 g     O .bss	00000018 xReceivedACK
801396f4 g     F .text	00000214 OSQPostOpt
80134318 g     F .text	00000228 OSTimeTick
8014a2ac g     O .rwdata	00000002 OSTaskMax
80139bd4 g     F .text	000000e0 OSSemCreate
8014a2d0 g     O .rwdata	00000002 OSTmrWheelSize
8011d6a0 g     F .text	00000028 vFailCreateScheduleQueue
8011f2ac g     F .text	00000058 _reg_read
801386b4 g     F .text	00000174 OSMutexQuery
80110614 g     F .text	000000a4 bSendGiveBackNFeeCtrl
801316c4 g     F .text	00000088 .hidden __nedf2
8014a2a6 g     O .rwdata	00000002 OSTaskDelEn
8011e914 g     F .text	00000038 vLoadDefaultEPValue
80158db8 g     O .bss	00001000 vFeeTask1_stk
8010dd0c g     F .text	00000074 bSyncCtrCh7OutEnable
8013a39c g     F .text	00000118 OSSemQuery
80138cbc g     F .text	00000288 OSQDel
80139298 g     F .text	00000174 OSQPendAbort
8014a3d8 g     O .bss	00000004 xMutexPreParsed
8013d424 g     F .text	00000040 alt_irq_init
80132ddc g     F .text	0000006c alt_release_fd
8013d744 g     F .text	000000bc get_cluster_flag
8010df50 g     F .text	00000074 bSyncIrqFlagClrBlank
80145488 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8010d294 g     F .text	0000002c vSyncClearCounter
801106b8 g     F .text	00000394 bPrepareDoubleBuffer
80148f78 g     O .rwdata	00000031 alt_log_msg_stackpointer
80121894 g     F .text	00000074 sprintf
8014777a g     O .rodata	00000100 .hidden __clz_tab
8013dd18 g     F .text	00000294 Write_File_Record_At_Offset
80100658 g     F .text	00000360 bDdr2MemoryWriteTest
8011d078 g     F .text	00000028 vFailGetMutexTxUARTSenderTask
8014a40c g     O .bss	00000004 _PathLocale
8010e01c g     F .text	00000058 bSyncIrqFlagBlank
8010c4e8 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8013cad0 g     F .text	000001e8 OSTmrStop
8010a708 g     F .text	00000050 uliRmapReadReg
8011a680 g     F .text	00000050 usiGetIdCMD
8010e148 g     F .text	00000058 uliSyncReadReg
80106574 g     F .text	00000094 bFeebGetCh2RightFeeBusy
8012c33c g     F .text	00000108 strtof
80103acc g     F .text	00000204 vFeebCh3HandleIrq
8013039c g     F .text	000000bc .hidden __gesf2
80121908 g     F .text	0000004c strcspn
8012e040 g     F .text	00000068 _write_r
8010cb84 g     F .text	00000074 vRstcReleaseDeviceReset
8011d3f4 g     F .text	00000028 vFailInAckHandlerTaskCreate
80105f20 g     F .text	00000094 bFeebGetCh5LeftBufferEmpty
80134070 g     F .text	00000094 OSSchedLock
8011d7a0 g     F .text	00000028 vCoudlNotCreateNFee3Task
80128464 g     F .text	00000018 setlocale
801447dc g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
80161274 g     O .bss	00000800 OSTmrTaskStk
801217b8 g     F .text	00000044 scanf
8011d890 g     F .text	00000030 vFailCreateMutexSPUSQueueMeb
80135c78 g     F .text	00000110 OSFlagCreate
8013dfac g     F .text	00000688 Check_for_DOS_FAT
80118088 g     F .text	00000064 vMebInit
8013fe58 g     F .text	000002d0 create_file
8012aa80 g     F .text	00000008 nanf
8014a21c g     O .rwdata	00000004 _impure_ptr
8014a4e0 g     O .bss	00000004 CSD_register_w0
8014a440 g     O .bss	00000004 alt_argc
8011d1ec g     F .text	00000028 vFailGetCountSemaphorexBuffer128
8012e438 g     F .text	00000224 __sflush_r
80128c9c g     F .text	000000b4 _mbrtowc_r
8010ada0 g     F .text	00000090 bSpwcGetTimecode
80110c9c g     F .text	00000108 vWaitUntilBufferEmpty
80128450 g     F .text	00000008 __locale_cjk_lang
801019b0 g     F .text	000004a0 sense_log
8014a2f8 g     O .bss	00000004 ESdmaBufferSide
8014a276 g     O .rwdata	00000002 OSEventMultiEn
80159db8 g     O .bss	00001800 vParserCommTask_stk
8011e988 g     F .text	00000030 vChangeDefaultEPValue
801188e4 g     F .text	000002c8 vCheckRetransmission32
8013c2a0 g     F .text	000001c4 OSTmrCreate
8012a704 g     F .text	000001dc __srefill_r
8010b1b4 g     F .text	0000003c bEnableLvdsBoard
8014a3dc g     O .bss	00000004 xMutexBuffer32
801073c0 g     F .text	00000098 vRmapCh2HandleIrq
801067c0 g     F .text	00000090 bFeebGetCh4RightFeeBusy
80135d88 g     F .text	00000250 OSFlagDel
8014a4ac g     O .bss	00000004 OSEventFreeList
8010b22c g     F .text	000000c0 bSetPreEmphasys
8010f56c g     F .text	0000013c vQCmdFEEinConfig
80100020 g       .exceptions	00000000 alt_irq_entry
80128e30 g     F .text	0000004c __ascii_mbtowc
8010d818 g     F .text	00000078 bSyncCtrExtnIrq
80106048 g     F .text	00000094 bFeebGetCh6LeftBufferEmpty
80105bb0 g     F .text	00000094 bFeebGetCh2LeftBufferEmpty
80129c84 g     F .text	00000064 __ulp
8011e478 g     F .text	00000110 vNFeeControlInit
801180ec g     F .text	000000a4 vSwapMemmory
8013625c g     F .text	000005c0 OSFlagPend
8014a2c2 g     O .rwdata	00000002 OSTmrEn
8012764c g     F .text	00000018 __fp_unlock_all
8015b5b8 g     O .bss	00000010 xDma
801102b0 g     F .text	00000058 bEnableRmapIRQ
80119e00 g     F .text	000002c0 bSendUART32v2
80116c44 g     F .text	0000017c setPreAckReceiverFreePos
8010d7d8 g     F .text	00000040 bSyncErrInj
8014a230 g     O .rwdata	00000008 alt_fs_list
8015b5c8 g     O .bss	00001000 vSimMebTask_stk
8011d868 g     F .text	00000028 vCoudlNotCreateMebTask
8013e7f4 g     F .text	00000274 check_file_name_for_FAT16_compliance
8015c5c8 g     O .bss	00001000 vFeeTask3_stk
8013c5a4 g     F .text	00000140 OSTmrNameGet
8014a674 g     O .bss	00000400 xSZData
8010f838 g     F .text	000001c4 vQCmdFEEinFullPattern
801351a0 g     F .text	0000007c OS_StrCopy
8014a4ec g     O .bss	00000004 buffer_memory
8011d2b4 g     F .text	00000028 vFailGetxMutexPreParsedParserRxTask
8011e790 g     F .text	00000098 vLogWriteNUC
801060dc g     F .text	00000094 bFeebGetCh6RightBufferEmpty
8014a28c g     O .rwdata	00000002 OSMemNameSize
80101e50 g     F .text	000000bc bSdmaInitM1Dma
8010de68 g     F .text	00000074 bSyncIrqEnableBlank
80146460 g     F .text	00000028 OSInitHookEnd
8011dea8 g     F .text	00000340 vUpdateMemMapFEE
8011d3a4 g     F .text	00000028 vFailSetPreAckReceiverBuffer
8014a2b8 g     O .rwdata	00000002 OSTCBPrioTblMax
8012847c g     F .text	0000000c localeconv
8011d840 g     F .text	00000028 vCoudlNotCreateDataControllerTask
8014a3e0 g     O .bss	00000004 xTimerRetransmission
80116774 g     F .text	00000218 vReceiverUartTask
8014a43c g     O .bss	00000004 alt_log_sys_clk_count
8014a2b4 g     O .rwdata	00000002 OSTaskStatStkChkEn
80132864 g     F .text	00000140 alt_log_write
8015d5c8 g     O .bss	00001000 vFeeTask2_stk
8014a3e4 g     O .bss	00000004 xMutexBuffer128
801036c4 g     F .text	00000204 vFeebCh1HandleIrq
8011f154 g     F .text	0000003c bStartSync
80103f2c g     F .text	0000002c vFeebCh7HandleIrq
8011f190 g     F .text	00000030 bStopSync
8014a2fc g     O .bss	00000004 ECommBufferSide
801457cc g     F .text	00000058 alt_ic_isr_register
8014a288 g     O .rwdata	00000002 OSMemEn
80107458 g     F .text	00000098 vRmapCh3HandleIrq
8014a208 g     O .rwdata	00000004 alt_stack_limit_value
80117af0 g     F .text	000002e4 vPusType252run
8011daf8 g     F .text	00000028 vFailSendMsgMasterSyncMeb
8014a4f0 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8014a292 g     O .rwdata	00000002 OSMutexEn
8011d9b0 g     F .text	00000028 vCouldNotGetQueueMaskDataCtrl
8014a2e0 g       *ABS*	00000000 _edata
80142840 g     F .text	00000068 altera_avalon_uart_read_fd
8011e5fc g     F .text	00000034 vLoadDefaultIdNFEEMaster
8010358c g     F .text	000000ac usiAdcPxDelayCalcPeriodNs
80105fb4 g     F .text	00000094 bFeebGetCh5RightBufferEmpty
80165040 g       *ABS*	00000000 _end
80164a40 g     O .bss	00000500 active_files
8014a4b0 g     O .bss	00000001 OSIntNesting
8011d0c8 g     F .text	00000034 vFailInitialization
80110a4c g     F .text	00000128 vSetDoubleBufferRightSize
801005d4 g     F .text	00000084 bDdr2SwitchMemory
8011e374 g     F .text	0000002c cFeeRMAPDump
80104ed4 g     F .text	000000e0 bFeebCh3SetBufferSize
8014a3e8 g     O .bss	00000004 xSemCountBuffer32
8014a3ec g     O .bss	00000004 xQMaskFeeCtrl
8011e2c4 g     F .text	0000002c vFeeSpwRMAPChangeConfig
80125934 g     F .text	00000070 vfscanf
80140128 g     F .text	00000150 copy_file_record_name_to_string
801420b0 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8013bff8 g     F .text	000001dc OSTimeDlyResume
8013e634 g     F .text	000000f4 Look_for_FAT16
80110308 g     F .text	00000060 bDisableSPWChannel
80136108 g     F .text	00000154 OSFlagNameSet
80110460 g     F .text	0000006c bDisAndClrDbBuffer
8014a3f0 g     O .bss	00000004 xMutexBuffer64
8010841c g     F .text	00000160 bRmapGetCodecError
8013b830 g     F .text	000001c8 OSTaskStkChk
801458b4 g     F .text	00000094 alt_ic_irq_disable
80101fd0 g     F .text	00000484 bSdmaDmaM1Transfer
8014a28e g     O .rwdata	00000002 OSMemSize
80117710 g     F .text	00000184 vPusType252conf
8011d174 g     F .text	00000028 vFailSetCountSemaphorexBuffer32
8011148c g     F .text	000010fc vFeeTask1
8014a20c g     O .rwdata	00000001 ucFeebIrqEmptyBufferFlagsQtd
8012aaec g     F .text	00000084 __swrite
8014a228 g     O .rwdata	00000004 __malloc_trim_threshold
80128444 g     F .text	0000000c __locale_msgcharset
8015e5c8 g     O .bss	00000040 xFeeQueueTBL1
8014a4b4 g     O .bss	00000004 OSTCBCur
8011d55c g     F .text	00000028 vCouldNotRetransmitB64TimeoutTask
8010c5ec g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
80146774 g     F .text	00000040 exit
80138494 g     F .text	00000220 OSMutexPost
8010dfc4 g     F .text	00000058 bSyncIrqFlagError
801068e4 g     F .text	00000094 bFeebGetCh5RightFeeBusy
80140554 g     F .text	000003c0 alt_up_sd_card_find_next
8014a290 g     O .rwdata	00000002 OSMemTblSize
801282a8 g     F .text	000000cc _fwalk_reent
80144bd4 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8011fdb4 g     F .text	000000f8 .hidden __floatunsisf
80129a80 g     F .text	00000204 __mdiff
8011d728 g     F .text	00000028 vCoudlNotCreateNFee0Task
80105404 g     F .text	000001c8 vFeebInitIrq
80102c48 g     F .text	000002a4 bDpktSetPacketConfig
8011d124 g     F .text	00000028 vFailSenderCreate
801301f4 g     F .text	00000074 .hidden __modsi3
8011d7f0 g     F .text	00000028 vCoudlNotCreateNFee5Task
8010d724 g     F .text	0000003c uliSyncGetPer
801075c0 g     F .text	00000038 vRmapCh6HandleIrq
8014a3f4 g     O .bss	00000004 xMutexSenderACK
8011d4bc g     F .text	00000028 vFailGetBlockingSemTimeoutTask
8014a214 g     O .rwdata	00000004 __ctype_ptr__
8011d37c g     F .text	00000028 vFailSetPreParsedBuffer
8013d664 g     F .text	000000e0 Read_Sector_Data
801e0000 g       *ABS*	00000000 __alt_data_end
80100020 g     F .exceptions	00000000 alt_exception
80127628 g     F .text	00000004 __sfp_lock_release
801056a4 g     F .text	000000ac bFeebGetIrqControl
8011d5d4 g     F .text	00000028 vCouldNotSendTurnOff
80133eb8 g     F .text	00000064 OSInit
8010bb64 g     F .text	00000078 bSetPainelLeds
8014431c g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8014a4b8 g     O .bss	00000004 OSTmrTime
801009b8 g     F .text	00000278 bDdr2MemoryReadTest
8010857c g     F .text	00000334 bRmapSetMemConfigArea
8013bbe4 g     F .text	0000012c OSTaskQuery
8010ddf4 g     F .text	00000074 bSyncIrqEnableError
8014a3f8 g     O .bss	00000004 xMutexPus
80139a6c g     F .text	000000b0 OS_QInit
8012a9b0 g     F .text	000000d0 __sccl
80121434 g     F .text	0000000c atoi
80118190 g     F .text	00000088 vEnterConfigRoutine
8010e2a8 g     F .text	000010f0 vFeeTask
8013521c g     F .text	0000005c OS_StrLen
8011dbe8 g     F .text	00000028 vFailFlushNFEEQueue
8011cd60 g     F .text	000000e4 vDataControllerInit
801374b0 g     F .text	0000011c OSMemNameSet
8014787a g     O .rodata	00000101 _ctype_
8010d6e8 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8011d1c4 g     F .text	00000028 vFailSetCountSemaphorexBuffer128
8014a2aa g     O .rwdata	00000002 OSTaskProfileEn
8011dc10 g     F .text	00000028 vEvtChangeMebMode
801441ec g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8014a3fc g     O .bss	00000004 xTxUARTMutex
8014a4bc g     O .bss	00000004 OSTime
8014a22c g     O .rwdata	00000004 __mbtowc
80142e60 g     F .text	0000005c altera_avalon_uart_close
8010f398 g     F .text	000001d4 vQCmdFEEinWaitingSync
8014a4c0 g     O .bss	00000004 OSTmrSem
801176e0 g     F .text	00000030 vPusType251conf
80161a74 g     O .bss	00001000 OSTaskIdleStk
8014a3a4 g     O .bss	00000004 pdata
80146d7c g     F .text	000000bc _exit
80105998 g     F .text	00000078 bFeebGetLeftBufferEmpty
80145510 g     F .text	00000134 alt_alarm_start
80135fd8 g     F .text	00000130 OSFlagNameGet
8013c1d4 g     F .text	00000064 OSTimeGet
8014a300 g     O .bss	00000004 ESdmaChBufferId
80140db8 g     F .text	00000380 alt_up_sd_card_read
80107774 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8012f2f4 g     F .text	000001c4 __smakebuf_r
8014a400 g     O .bss	00000001 SemCount64
80119b40 g     F .text	000002c0 bSendUART64v2
80106b34 g     F .text	00000094 bFeebGetCh7RightFeeBusy
8011db98 g     F .text	00000028 vFailFlushQueueData
8014a2d8 g     O .rwdata	00000008 alt_msgdma_list
80121954 g     F .text	00000098 strlen
8010ce28 g     F .text	000000b4 uc_spi_get_byte
801077b8 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8011d9d8 g     F .text	00000030 vFailSendMsgAccessDMA
80146390 g     F .text	00000028 OSTaskSwHook
80145cf4 g     F .text	0000015c open
80109ce4 g     F .text	000007cc bRmapGetRmapMemHKArea
80162a74 g     O .bss	00000d00 OSEventTbl
8011e2f0 g     F .text	0000002c vFeeSpwRMAPChangeDefault
8011feac g     F .text	000000dc .hidden __gedf2
8011dac8 g     F .text	00000030 vFailSendMsgSyncRMAPTRIGGER
8015e608 g     O .bss	00000020 xSenderACK
80146084 g     F .text	00000044 alt_putchar
8012144c g     F .text	0000000c atoll
80163774 g     O .bss	000011b8 OSTCBTbl
8012e7f0 g     F .text	00000838 __gethex
80104830 g     F .text	000000f8 vFeebCh4IrqFlagBufferEmpty
8013a4b4 g     F .text	00000108 OSSemSet
80118218 g     F .text	00000050 vTimeoutCheckerTaskv2
8011e3a0 g     F .text	00000038 cFeeRMAPEchoingEnable
801190bc g     F .text	00000314 vVariablesInitialization
8010fd58 g     F .text	00000298 vQCmdFeeRMAPinFullPattern
80105750 g     F .text	000000f4 bFeebGetIrqFlags
8014a2ec g     O .bss	00000004 pxDmaM2Dev
8011cedc g     F .text	00000028 vFailCreateSemaphoreResources
8014a248 g     O .rwdata	00000004 alt_priority_mask
8010b1f0 g     F .text	0000003c bDisableLvdsBoard
80139cb4 g     F .text	00000248 OSSemDel
80104df4 g     F .text	000000e0 bFeebCh2SetBufferSize
8014a4c4 g     O .bss	00000004 OSFlagFreeList
8010cd64 g     F .text	000000c4 v_spi_send_byte
8010d048 g     F .text	000000d0 bSSDisplayConfig
80145824 g     F .text	00000090 alt_ic_irq_enable
8014a270 g     O .rwdata	00000002 OSEventNameSize
8014a4c8 g     O .bss	00000001 OSStatRdy
8010dac8 g     F .text	00000074 bSyncCtrCh2OutEnable
8016492c g     O .bss	000000ac OSTCBPrioTbl
80142f00 g     F .text	00000270 altera_avalon_uart_read
80133384 g     F .text	000000cc __env_lock
8014a2b6 g     O .rwdata	00000002 OSTaskSwHookEn
8014aed4 g     O .bss	00000100 cTemp
801040f4 g     F .text	000000b8 vFeebCh3IrqFlagClrBufferEmpty
801206a8 g     F .text	00000904 .hidden __subdf3
8015e628 g     O .bss	00000260 xPreParsed
8010d760 g     F .text	0000003c uliSyncGetOst
8014a401 g     O .bss	00000001 SemCount128
80107630 g     F .text	00000038 vRmapCh8HandleIrq
80104318 g     F .text	000000b8 vFeebCh6IrqFlagClrBufferEmpty
8011a0c0 g     F .text	00000290 vSendEthConf
80102a90 g     F .text	00000114 bCommInitCh
80129494 g     F .text	000000b0 __lo0bits
80124170 g     F .text	000017c4 __svfscanf_r
8014a254 g     O .rwdata	00000008 alt_alarm_list
8012de8c g     F .text	0000019c _ungetc_r
8014a27e g     O .rwdata	00000002 OSFlagWidth
80107668 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
80101128 g     F .text	0000004c DMA_BUSY
80106c58 g     F .text	00000090 bFeebGetCh8RightFeeBusy
80103108 g     F .text	00000154 bDpktSetPixelDelay
80119768 g     F .text	00000090 vCCDLoadDefaultValues
80131a64 g     F .text	000000d8 close
8010d79c g     F .text	0000003c uliSyncGetGeneral
8011dc60 g     F .text	00000028 vEvtChangeDataControllerMode
8014a458 g     O .bss	00000004 alt_envsem
80131f94 g     F .text	00000068 alt_log_repchar
8014a4cc g     O .bss	00000004 OSIdleCtrRun
80134540 g     F .text	00000028 OSVersion
8014a2c8 g     O .rwdata	00000002 OSTmrCfgWheelSize
8013bd10 g     F .text	00000078 OS_TaskStkClr
8011eedc g     F .text	0000003c siOpenFile
8010e224 g     F .text	00000084 vDataControlTask
8014a2a2 g     O .rwdata	00000002 OSTaskCreateEn
801078d8 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
80107d2c g     F .text	00000054 uliRmapCh7WriteCmdAddress
80106f04 g     F .text	0000008c bFeebStartCh
8011a350 g     F .text	00000118 vSendTurnOff
8011cf60 g     F .text	00000028 vFailSendPreParsedSemaphore
8013eb28 g     F .text	000002a4 match_file_record_to_name_ext
80110b74 g     F .text	00000128 vSetDoubleBufferLeftSize
80134b68 g     F .text	00000070 OS_EventWaitListInit
8015e888 g     O .bss	00000040 xFeeQueueTBL0
8011cf38 g     F .text	00000028 vFailSendxSemCommInit
80146488 g     F .text	00000028 OSTaskIdleHook
8011a468 g     F .text	00000118 vSendReset
8012762c g     F .text	00000004 __sinit_lock_acquire
801291f8 g     F .text	00000128 __multadd
801043d0 g     F .text	000000b8 vFeebCh7IrqFlagClrBufferEmpty
8010d3ec g     F .text	0000004c ucSyncStatusState
8013b9f8 g     F .text	000001ec OSTaskSuspend
801291d0 g     F .text	00000028 _Bfree
8010d6ac g     F .text	0000003c uliSyncGetMbt
80135278 g     F .text	00000064 OS_TaskIdle
8014a2ce g     O .rwdata	00000002 OSTmrTblSize
80139908 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

80100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
80100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
80100024:	de003636 	bltu	sp,et,80100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
80100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8010002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
80100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
80100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
80100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8010003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
80100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
80100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
80100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8010004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
80100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
80100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
80100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8010005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
80100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
80100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
80100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8010006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
80100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
80100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
80100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8010007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
80100080:	10000326 	beq	r2,zero,80100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
80100084:	20000226 	beq	r4,zero,80100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
80100088:	01001040 	call	80100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8010008c:	00000706 	br	801000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
80100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
80100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
80100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8010009c:	01001e00 	call	801001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
801000a0:	1000021e 	bne	r2,zero,801000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
801000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
801000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
801000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
801000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
801000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
801000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
801000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
801000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
801000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
801000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
801000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
801000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
801000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
801000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
801000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
801000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
801000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
801000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
801000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
801000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
801000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
801000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
801000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
80100100:	003da0fa 	break	3

80100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
80100104:	defff904 	addi	sp,sp,-28
80100108:	de00012e 	bgeu	sp,et,80100110 <alt_irq_handler+0xc>
8010010c:	003b68fa 	trap	3
80100110:	dfc00615 	stw	ra,24(sp)
80100114:	df000515 	stw	fp,20(sp)
80100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8010011c:	0133f1c0 	call	80133f1c <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
80100120:	0005313a 	rdctl	r2,ipending
80100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
80100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8010012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
80100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
80100134:	00800044 	movi	r2,1
80100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8010013c:	e0fffb17 	ldw	r3,-20(fp)
80100140:	e0bffc17 	ldw	r2,-16(fp)
80100144:	1884703a 	and	r2,r3,r2
80100148:	10001426 	beq	r2,zero,8010019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8010014c:	00a005b4 	movhi	r2,32790
80100150:	1093d004 	addi	r2,r2,20288
80100154:	e0fffd17 	ldw	r3,-12(fp)
80100158:	180690fa 	slli	r3,r3,3
8010015c:	10c5883a 	add	r2,r2,r3
80100160:	10c00017 	ldw	r3,0(r2)
80100164:	00a005b4 	movhi	r2,32790
80100168:	1093d004 	addi	r2,r2,20288
8010016c:	e13ffd17 	ldw	r4,-12(fp)
80100170:	200890fa 	slli	r4,r4,3
80100174:	1105883a 	add	r2,r2,r4
80100178:	10800104 	addi	r2,r2,4
8010017c:	10800017 	ldw	r2,0(r2)
80100180:	1009883a 	mov	r4,r2
80100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
80100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8010018c:	0005313a 	rdctl	r2,ipending
80100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
80100194:	e0bfff17 	ldw	r2,-4(fp)
80100198:	00000706 	br	801001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8010019c:	e0bffc17 	ldw	r2,-16(fp)
801001a0:	1085883a 	add	r2,r2,r2
801001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
801001a8:	e0bffd17 	ldw	r2,-12(fp)
801001ac:	10800044 	addi	r2,r2,1
801001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
801001b4:	003fe106 	br	8010013c <__reset+0xfa0e013c>

    active = alt_irq_pending ();
801001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
801001bc:	e0bffb17 	ldw	r2,-20(fp)
801001c0:	103fdb1e 	bne	r2,zero,80100130 <__reset+0xfa0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
801001c4:	0133f700 	call	80133f70 <OSIntExit>
}
801001c8:	0001883a 	nop
801001cc:	e037883a 	mov	sp,fp
801001d0:	dfc00117 	ldw	ra,4(sp)
801001d4:	df000017 	ldw	fp,0(sp)
801001d8:	dec00204 	addi	sp,sp,8
801001dc:	f800283a 	ret

801001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
801001e0:	defffb04 	addi	sp,sp,-20
801001e4:	de00012e 	bgeu	sp,et,801001ec <alt_instruction_exception_entry+0xc>
801001e8:	003b68fa 	trap	3
801001ec:	dfc00415 	stw	ra,16(sp)
801001f0:	df000315 	stw	fp,12(sp)
801001f4:	df000304 	addi	fp,sp,12
801001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
801001fc:	000531fa 	rdctl	r2,exception
80100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
80100204:	e0bffd17 	ldw	r2,-12(fp)
80100208:	10801f0c 	andi	r2,r2,124
8010020c:	1004d0ba 	srli	r2,r2,2
80100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
80100214:	0005333a 	rdctl	r2,badaddr
80100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8010021c:	d0a0c017 	ldw	r2,-32000(gp)
80100220:	10000726 	beq	r2,zero,80100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
80100224:	d0a0c017 	ldw	r2,-32000(gp)
80100228:	e0fffd17 	ldw	r3,-12(fp)
8010022c:	e1bffe17 	ldw	r6,-8(fp)
80100230:	e17fff17 	ldw	r5,-4(fp)
80100234:	1809883a 	mov	r4,r3
80100238:	103ee83a 	callr	r2
8010023c:	00000206 	br	80100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
80100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
80100244:	0005883a 	mov	r2,zero
}
80100248:	e037883a 	mov	sp,fp
8010024c:	dfc00117 	ldw	ra,4(sp)
80100250:	df000017 	ldw	fp,0(sp)
80100254:	dec00204 	addi	sp,sp,8
80100258:	f800283a 	ret

Disassembly of section .text:

8010025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8010025c:	01200574 	movhi	r4,32789
80100260:	21289304 	addi	r4,r4,-23988
80100264:	21400037 	ldwio	r5,0(r4)
80100268:	01400326 	beq	zero,r5,80100278 <_start+0x1c>
8010026c:	01200574 	movhi	r4,32789
80100270:	2123eb04 	addi	r4,r4,-28756
80100274:	0131f0c0 	call	80131f0c <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
80100278:	01200574 	movhi	r4,32789
8010027c:	21289304 	addi	r4,r4,-23988
80100280:	21400037 	ldwio	r5,0(r4)
80100284:	01400326 	beq	zero,r5,80100294 <_start+0x38>
80100288:	01200574 	movhi	r4,32789
8010028c:	2123de04 	addi	r4,r4,-28808
80100290:	0131f0c0 	call	80131f0c <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
80100294:	06e007b4 	movhi	sp,32798
    ori sp, sp, %lo(__alt_stack_pointer)
80100298:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
8010029c:	06a00574 	movhi	gp,32789
    ori gp, gp, %lo(_gp)
801002a0:	d6888214 	ori	gp,gp,8712
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
801002a4:	01200574 	movhi	r4,32789
801002a8:	21289304 	addi	r4,r4,-23988
801002ac:	21400037 	ldwio	r5,0(r4)
801002b0:	01400326 	beq	zero,r5,801002c0 <_start+0x64>
801002b4:	01200574 	movhi	r4,32789
801002b8:	2123cf04 	addi	r4,r4,-28868
801002bc:	0131f0c0 	call	80131f0c <tx_log_str>

    movhi r2, %hi(__bss_start)
801002c0:	00a00534 	movhi	r2,32788
    ori r2, r2, %lo(__bss_start)
801002c4:	10a8b814 	ori	r2,r2,41696

    movhi r3, %hi(__bss_end)
801002c8:	00e005b4 	movhi	r3,32790
    ori r3, r3, %lo(__bss_end)
801002cc:	18d41014 	ori	r3,r3,20544

    beq r2, r3, 1f
801002d0:	10c00326 	beq	r2,r3,801002e0 <_start+0x84>

0:
    stw zero, (r2)
801002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
801002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
801002dc:	10fffd36 	bltu	r2,r3,801002d4 <__reset+0xfa0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
801002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
801002e4:	01200574 	movhi	r4,32789
801002e8:	21289304 	addi	r4,r4,-23988
801002ec:	21400037 	ldwio	r5,0(r4)
801002f0:	01400326 	beq	zero,r5,80100300 <_start+0xa4>
801002f4:	01200574 	movhi	r4,32789
801002f8:	2123d604 	addi	r4,r4,-28840
801002fc:	0131f0c0 	call	80131f0c <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
80100300:	0132b380 	call	80132b38 <alt_main>

80100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
80100304:	003fff06 	br	80100304 <__reset+0xfa0e0304>

80100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
80100308:	defff604 	addi	sp,sp,-40
8010030c:	de00012e 	bgeu	sp,et,80100314 <bDdr2EepromTest+0xc>
80100310:	003b68fa 	trap	3
80100314:	dfc00915 	stw	ra,36(sp)
80100318:	df000815 	stw	fp,32(sp)
8010031c:	df000804 	addi	fp,sp,32
80100320:	2005883a 	mov	r2,r4
80100324:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
	debug(fp, cDebugBuffer);
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
80100328:	00bfe804 	movi	r2,-96
8010032c:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess = FALSE;
80100330:	e03ff915 	stw	zero,-28(fp)
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	switch (ucMemoryId) {
80100334:	e0bfff03 	ldbu	r2,-4(fp)
80100338:	10000326 	beq	r2,zero,80100348 <bDdr2EepromTest+0x40>
8010033c:	10800060 	cmpeqi	r2,r2,1
80100340:	10000a1e 	bne	r2,zero,8010036c <bDdr2EepromTest+0x64>
80100344:	00001206 	br	80100390 <bDdr2EepromTest+0x88>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
80100348:	00900034 	movhi	r2,16384
8010034c:	10827c04 	addi	r2,r2,2544
80100350:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
80100354:	00900034 	movhi	r2,16384
80100358:	10828004 	addi	r2,r2,2560
8010035c:	e0bffb15 	stw	r2,-20(fp)
		bSuccess = TRUE;
80100360:	00800044 	movi	r2,1
80100364:	e0bff915 	stw	r2,-28(fp)
		break;
80100368:	00000c06 	br	8010039c <bDdr2EepromTest+0x94>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
8010036c:	00900034 	movhi	r2,16384
80100370:	10825804 	addi	r2,r2,2400
80100374:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
80100378:	00900034 	movhi	r2,16384
8010037c:	10825c04 	addi	r2,r2,2416
80100380:	e0bffb15 	stw	r2,-20(fp)
		bSuccess = TRUE;
80100384:	00800044 	movi	r2,1
80100388:	e0bff915 	stw	r2,-28(fp)
		break;
8010038c:	00000306 	br	8010039c <bDdr2EepromTest+0x94>
	default:
		bSuccess = FALSE;
80100390:	e03ff915 	stw	zero,-28(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
80100394:	e0bff917 	ldw	r2,-28(fp)
80100398:	00004506 	br	801004b0 <bDdr2EepromTest+0x1a8>
	alt_u8 ucControlAddr, ucValue;
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
8010039c:	01138804 	movi	r4,20000
801003a0:	01330f80 	call	801330f8 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
801003a4:	e03ffc15 	stw	zero,-16(fp)
801003a8:	00001206 	br	801003f4 <bDdr2EepromTest+0xec>
		ucControlAddr = iI;
801003ac:	e0bffc17 	ldw	r2,-16(fp)
801003b0:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
801003b4:	e0bffd03 	ldbu	r2,-12(fp)
801003b8:	10c03fcc 	andi	r3,r2,255
801003bc:	18c0201c 	xori	r3,r3,128
801003c0:	18ffe004 	addi	r3,r3,-128
801003c4:	e13ffd43 	ldbu	r4,-11(fp)
801003c8:	e0bffe04 	addi	r2,fp,-8
801003cc:	d8800015 	stw	r2,0(sp)
801003d0:	200f883a 	mov	r7,r4
801003d4:	180d883a 	mov	r6,r3
801003d8:	e17ffb17 	ldw	r5,-20(fp)
801003dc:	e13ffa17 	ldw	r4,-24(fp)
801003e0:	010b4d00 	call	8010b4d0 <I2C_Read>
801003e4:	e0bff915 	stw	r2,-28(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
801003e8:	e0bffc17 	ldw	r2,-16(fp)
801003ec:	10800044 	addi	r2,r2,1
801003f0:	e0bffc15 	stw	r2,-16(fp)
801003f4:	e0bffc17 	ldw	r2,-16(fp)
801003f8:	10804008 	cmpgei	r2,r2,256
801003fc:	1000021e 	bne	r2,zero,80100408 <bDdr2EepromTest+0x100>
80100400:	e0bff917 	ldw	r2,-28(fp)
80100404:	103fe91e 	bne	r2,zero,801003ac <__reset+0xfa0e03ac>

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
	debug(fp, cDebugBuffer);
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
80100408:	00800484 	movi	r2,18
8010040c:	e0bffd85 	stb	r2,-10(fp)
80100410:	00bfe004 	movi	r2,-128
80100414:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
80100418:	01138804 	movi	r4,20000
8010041c:	01330f80 	call	801330f8 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
80100420:	e0bffd03 	ldbu	r2,-12(fp)
80100424:	10c03fcc 	andi	r3,r2,255
80100428:	18c0201c 	xori	r3,r3,128
8010042c:	18ffe004 	addi	r3,r3,-128
80100430:	e13ffdc3 	ldbu	r4,-9(fp)
80100434:	e0bffd83 	ldbu	r2,-10(fp)
80100438:	d8800015 	stw	r2,0(sp)
8010043c:	200f883a 	mov	r7,r4
80100440:	180d883a 	mov	r6,r3
80100444:	e17ffb17 	ldw	r5,-20(fp)
80100448:	e13ffa17 	ldw	r4,-24(fp)
8010044c:	010b3f00 	call	8010b3f0 <I2C_Write>
80100450:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
80100454:	e0bff917 	ldw	r2,-28(fp)
80100458:	10001426 	beq	r2,zero,801004ac <bDdr2EepromTest+0x1a4>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8010045c:	e0bffd03 	ldbu	r2,-12(fp)
80100460:	10c03fcc 	andi	r3,r2,255
80100464:	18c0201c 	xori	r3,r3,128
80100468:	18ffe004 	addi	r3,r3,-128
8010046c:	e13ffdc3 	ldbu	r4,-9(fp)
80100470:	e0bffe44 	addi	r2,fp,-7
80100474:	d8800015 	stw	r2,0(sp)
80100478:	200f883a 	mov	r7,r4
8010047c:	180d883a 	mov	r6,r3
80100480:	e17ffb17 	ldw	r5,-20(fp)
80100484:	e13ffa17 	ldw	r4,-24(fp)
80100488:	010b4d00 	call	8010b4d0 <I2C_Read>
8010048c:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
80100490:	e0bff917 	ldw	r2,-28(fp)
80100494:	10000526 	beq	r2,zero,801004ac <bDdr2EepromTest+0x1a4>
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
			debug(fp, cDebugBuffer);
#endif
		} else {
			if (ucReadData != ucWriteData) {
80100498:	e0bffe43 	ldbu	r2,-7(fp)
8010049c:	10c03fcc 	andi	r3,r2,255
801004a0:	e0bffd83 	ldbu	r2,-10(fp)
801004a4:	18800126 	beq	r3,r2,801004ac <bDdr2EepromTest+0x1a4>
				bSuccess = FALSE;
801004a8:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
801004ac:	e0bff917 	ldw	r2,-28(fp)
}
801004b0:	e037883a 	mov	sp,fp
801004b4:	dfc00117 	ldw	ra,4(sp)
801004b8:	df000017 	ldw	fp,0(sp)
801004bc:	dec00204 	addi	sp,sp,8
801004c0:	f800283a 	ret

801004c4 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
801004c4:	deffb704 	addi	sp,sp,-292
801004c8:	de00012e 	bgeu	sp,et,801004d0 <bDdr2EepromDump+0xc>
801004cc:	003b68fa 	trap	3
801004d0:	dfc04815 	stw	ra,288(sp)
801004d4:	df004715 	stw	fp,284(sp)
801004d8:	df004704 	addi	fp,sp,284
801004dc:	2005883a 	mov	r2,r4
801004e0:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
	debug(fp, cDebugBuffer);
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
801004e4:	00bfe804 	movi	r2,-96
801004e8:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess = FALSE;
801004ec:	e03fbe15 	stw	zero,-264(fp)
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	switch (ucMemoryId) {
801004f0:	e0bfff03 	ldbu	r2,-4(fp)
801004f4:	10000326 	beq	r2,zero,80100504 <bDdr2EepromDump+0x40>
801004f8:	10800060 	cmpeqi	r2,r2,1
801004fc:	10000a1e 	bne	r2,zero,80100528 <bDdr2EepromDump+0x64>
80100500:	00001206 	br	8010054c <bDdr2EepromDump+0x88>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
80100504:	00900034 	movhi	r2,16384
80100508:	10827c04 	addi	r2,r2,2544
8010050c:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
80100510:	00900034 	movhi	r2,16384
80100514:	10828004 	addi	r2,r2,2560
80100518:	e0bfbb15 	stw	r2,-276(fp)
		bSuccess = TRUE;
8010051c:	00800044 	movi	r2,1
80100520:	e0bfbe15 	stw	r2,-264(fp)
		break;
80100524:	00000c06 	br	80100558 <bDdr2EepromDump+0x94>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
80100528:	00900034 	movhi	r2,16384
8010052c:	10825804 	addi	r2,r2,2400
80100530:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
80100534:	00900034 	movhi	r2,16384
80100538:	10825c04 	addi	r2,r2,2416
8010053c:	e0bfbb15 	stw	r2,-276(fp)
		bSuccess = TRUE;
80100540:	00800044 	movi	r2,1
80100544:	e0bfbe15 	stw	r2,-264(fp)
		break;
80100548:	00000306 	br	80100558 <bDdr2EepromDump+0x94>
	default:
		bSuccess = FALSE;
8010054c:	e03fbe15 	stw	zero,-264(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
80100550:	e0bfbe17 	ldw	r2,-264(fp)
80100554:	00001a06 	br	801005c0 <bDdr2EepromDump+0xfc>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
80100558:	e0bfbd03 	ldbu	r2,-268(fp)
8010055c:	10c03fcc 	andi	r3,r2,255
80100560:	18c0201c 	xori	r3,r3,128
80100564:	18ffe004 	addi	r3,r3,-128
80100568:	e13fbf04 	addi	r4,fp,-260
8010056c:	00804004 	movi	r2,256
80100570:	d8800015 	stw	r2,0(sp)
80100574:	200f883a 	mov	r7,r4
80100578:	180d883a 	mov	r6,r3
8010057c:	e17fbb17 	ldw	r5,-276(fp)
80100580:	e13fba17 	ldw	r4,-280(fp)
80100584:	010b5d80 	call	8010b5d8 <I2C_MultipleRead>
80100588:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8010058c:	e0bfbe17 	ldw	r2,-264(fp)
80100590:	10000a26 	beq	r2,zero,801005bc <bDdr2EepromDump+0xf8>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
80100594:	e03fbc15 	stw	zero,-272(fp)
80100598:	00000306 	br	801005a8 <bDdr2EepromDump+0xe4>
8010059c:	e0bfbc17 	ldw	r2,-272(fp)
801005a0:	10800044 	addi	r2,r2,1
801005a4:	e0bfbc15 	stw	r2,-272(fp)
801005a8:	e0bfbc17 	ldw	r2,-272(fp)
801005ac:	10804008 	cmpgei	r2,r2,256
801005b0:	1000021e 	bne	r2,zero,801005bc <bDdr2EepromDump+0xf8>
801005b4:	e0bfbe17 	ldw	r2,-264(fp)
801005b8:	103ff81e 	bne	r2,zero,8010059c <__reset+0xfa0e059c>
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
801005bc:	e0bfbe17 	ldw	r2,-264(fp)
}
801005c0:	e037883a 	mov	sp,fp
801005c4:	dfc00117 	ldw	ra,4(sp)
801005c8:	df000017 	ldw	fp,0(sp)
801005cc:	dec00204 	addi	sp,sp,8
801005d0:	f800283a 	ret

801005d4 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
801005d4:	defffc04 	addi	sp,sp,-16
801005d8:	de00012e 	bgeu	sp,et,801005e0 <bDdr2SwitchMemory+0xc>
801005dc:	003b68fa 	trap	3
801005e0:	df000315 	stw	fp,12(sp)
801005e4:	df000304 	addi	fp,sp,12
801005e8:	2005883a 	mov	r2,r4
801005ec:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess = FALSE;
801005f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
801005f4:	00901034 	movhi	r2,16448
801005f8:	10842204 	addi	r2,r2,4232
801005fc:	e0bffe15 	stw	r2,-8(fp)

	switch (ucMemoryId) {
80100600:	e0bfff03 	ldbu	r2,-4(fp)
80100604:	10000326 	beq	r2,zero,80100614 <bDdr2SwitchMemory+0x40>
80100608:	10800060 	cmpeqi	r2,r2,1
8010060c:	1000061e 	bne	r2,zero,80100628 <bDdr2SwitchMemory+0x54>
80100610:	00000b06 	br	80100640 <bDdr2SwitchMemory+0x6c>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
80100614:	e0bffe17 	ldw	r2,-8(fp)
80100618:	10000015 	stw	zero,0(r2)
		bSuccess = TRUE;
8010061c:	00800044 	movi	r2,1
80100620:	e0bffd15 	stw	r2,-12(fp)
		break;
80100624:	00000706 	br	80100644 <bDdr2SwitchMemory+0x70>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
80100628:	e0bffe17 	ldw	r2,-8(fp)
8010062c:	00e00034 	movhi	r3,32768
80100630:	10c00015 	stw	r3,0(r2)
		bSuccess = TRUE;
80100634:	00800044 	movi	r2,1
80100638:	e0bffd15 	stw	r2,-12(fp)
		break;
8010063c:	00000106 	br	80100644 <bDdr2SwitchMemory+0x70>
	default:
		bSuccess = FALSE;
80100640:	e03ffd15 	stw	zero,-12(fp)
		debug(fp, cDebugBuffer)
		;
#endif
	}

	return bSuccess;
80100644:	e0bffd17 	ldw	r2,-12(fp)
}
80100648:	e037883a 	mov	sp,fp
8010064c:	df000017 	ldw	fp,0(sp)
80100650:	dec00104 	addi	sp,sp,4
80100654:	f800283a 	ret

80100658 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
80100658:	deffe304 	addi	sp,sp,-116
8010065c:	de00012e 	bgeu	sp,et,80100664 <bDdr2MemoryWriteTest+0xc>
80100660:	003b68fa 	trap	3
80100664:	dfc01c15 	stw	ra,112(sp)
80100668:	df001b15 	stw	fp,108(sp)
8010066c:	dc401a15 	stw	r17,104(sp)
80100670:	dc001915 	stw	r16,100(sp)
80100674:	df001b04 	addi	fp,sp,108
80100678:	2005883a 	mov	r2,r4
8010067c:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
	debug(fp, cDebugBuffer);
#endif
	bool bSuccess = FALSE;
80100680:	e03fe515 	stw	zero,-108(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
80100684:	e0bffd03 	ldbu	r2,-12(fp)
80100688:	10000326 	beq	r2,zero,80100698 <bDdr2MemoryWriteTest+0x40>
8010068c:	10800060 	cmpeqi	r2,r2,1
80100690:	10000a1e 	bne	r2,zero,801006bc <bDdr2MemoryWriteTest+0x64>
80100694:	00001206 	br	801006e0 <bDdr2MemoryWriteTest+0x88>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
80100698:	e0bffd03 	ldbu	r2,-12(fp)
8010069c:	1009883a 	mov	r4,r2
801006a0:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
801006a4:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
801006a8:	00a00034 	movhi	r2,32768
801006ac:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
801006b0:	00800044 	movi	r2,1
801006b4:	e0bfe515 	stw	r2,-108(fp)
		break;
801006b8:	00000c06 	br	801006ec <bDdr2MemoryWriteTest+0x94>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
801006bc:	e0bffd03 	ldbu	r2,-12(fp)
801006c0:	1009883a 	mov	r4,r2
801006c4:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
801006c8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
801006cc:	00a00034 	movhi	r2,32768
801006d0:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
801006d4:	00800044 	movi	r2,1
801006d8:	e0bfe515 	stw	r2,-108(fp)
		break;
801006dc:	00000306 	br	801006ec <bDdr2MemoryWriteTest+0x94>
	default:
		bSuccess = FALSE;
801006e0:	e03fe515 	stw	zero,-108(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
801006e4:	e0bfe517 	ldw	r2,-108(fp)
801006e8:	0000ac06 	br	8010099c <bDdr2MemoryWriteTest+0x344>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
801006ec:	00800104 	movi	r2,4
801006f0:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
801006f4:	e03fed15 	stw	zero,-76(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
801006f8:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
801006fc:	e03fe815 	stw	zero,-96(fp)
80100700:	00001506 	br	80100758 <bDdr2MemoryWriteTest+0x100>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
80100704:	e0ffe717 	ldw	r3,-100(fp)
80100708:	00b33374 	movhi	r2,52429
8010070c:	10b33344 	addi	r2,r2,-13107
80100710:	1888383a 	mulxuu	r4,r3,r2
80100714:	1885383a 	mul	r2,r3,r2
80100718:	1021883a 	mov	r16,r2
8010071c:	2023883a 	mov	r17,r4
80100720:	8804d0fa 	srli	r2,r17,3
80100724:	e0ffe817 	ldw	r3,-96(fp)
80100728:	18c00044 	addi	r3,r3,1
8010072c:	10c7383a 	mul	r3,r2,r3
80100730:	e0bfe817 	ldw	r2,-96(fp)
80100734:	1085883a 	add	r2,r2,r2
80100738:	1085883a 	add	r2,r2,r2
8010073c:	e13fe504 	addi	r4,fp,-108
80100740:	2085883a 	add	r2,r4,r2
80100744:	10800e04 	addi	r2,r2,56
80100748:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
8010074c:	e0bfe817 	ldw	r2,-96(fp)
80100750:	10800044 	addi	r2,r2,1
80100754:	e0bfe815 	stw	r2,-96(fp)
80100758:	e0bfe817 	ldw	r2,-96(fp)
8010075c:	10800290 	cmplti	r2,r2,10
80100760:	103fe81e 	bne	r2,zero,80100704 <__reset+0xfa0e0704>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
80100764:	d0a09217 	ldw	r2,-32184(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
80100768:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
8010076c:	00804004 	movi	r2,256
80100770:	e0bfeb15 	stw	r2,-84(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
80100774:	e03fe815 	stw	zero,-96(fp)
80100778:	00001e06 	br	801007f4 <bDdr2MemoryWriteTest+0x19c>
		if (iI == 0) {
8010077c:	e0bfe817 	ldw	r2,-96(fp)
80100780:	1000091e 	bne	r2,zero,801007a8 <bDdr2MemoryWriteTest+0x150>
			xSZData[iI] = uliInitValue;
80100784:	00a00574 	movhi	r2,32789
80100788:	10a99d04 	addi	r2,r2,-22924
8010078c:	e0ffe817 	ldw	r3,-96(fp)
80100790:	18c7883a 	add	r3,r3,r3
80100794:	18c7883a 	add	r3,r3,r3
80100798:	10c5883a 	add	r2,r2,r3
8010079c:	e0fff017 	ldw	r3,-64(fp)
801007a0:	10c00015 	stw	r3,0(r2)
801007a4:	00001006 	br	801007e8 <bDdr2MemoryWriteTest+0x190>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
801007a8:	e0bfe817 	ldw	r2,-96(fp)
801007ac:	10ffffc4 	addi	r3,r2,-1
801007b0:	00a00574 	movhi	r2,32789
801007b4:	10a99d04 	addi	r2,r2,-22924
801007b8:	18c7883a 	add	r3,r3,r3
801007bc:	18c7883a 	add	r3,r3,r3
801007c0:	10c5883a 	add	r2,r2,r3
801007c4:	10800017 	ldw	r2,0(r2)
801007c8:	11000364 	muli	r4,r2,13
801007cc:	00a00574 	movhi	r2,32789
801007d0:	10a99d04 	addi	r2,r2,-22924
801007d4:	e0ffe817 	ldw	r3,-96(fp)
801007d8:	18c7883a 	add	r3,r3,r3
801007dc:	18c7883a 	add	r3,r3,r3
801007e0:	10c5883a 	add	r2,r2,r3
801007e4:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
801007e8:	e0bfe817 	ldw	r2,-96(fp)
801007ec:	10800044 	addi	r2,r2,1
801007f0:	e0bfe815 	stw	r2,-96(fp)
801007f4:	e0ffe817 	ldw	r3,-96(fp)
801007f8:	e0bfeb17 	ldw	r2,-84(fp)
801007fc:	18bfdf16 	blt	r3,r2,8010077c <__reset+0xfa0e077c>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
80100800:	e0bfeb17 	ldw	r2,-84(fp)
80100804:	10ffffc4 	addi	r3,r2,-1
80100808:	00a00574 	movhi	r2,32789
8010080c:	10a99d04 	addi	r2,r2,-22924
80100810:	18c7883a 	add	r3,r3,r3
80100814:	18c7883a 	add	r3,r3,r3
80100818:	10c7883a 	add	r3,r2,r3
8010081c:	00aaaaf4 	movhi	r2,43691
80100820:	10aaaa84 	addi	r2,r2,-21846
80100824:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
80100828:	e0bfeb17 	ldw	r2,-84(fp)
8010082c:	10ffff84 	addi	r3,r2,-2
80100830:	00a00574 	movhi	r2,32789
80100834:	10a99d04 	addi	r2,r2,-22924
80100838:	18c7883a 	add	r3,r3,r3
8010083c:	18c7883a 	add	r3,r3,r3
80100840:	10c7883a 	add	r3,r2,r3
80100844:	00955574 	movhi	r2,21845
80100848:	10955544 	addi	r2,r2,21845
8010084c:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
80100850:	e0bfeb17 	ldw	r2,-84(fp)
80100854:	10ffff44 	addi	r3,r2,-3
80100858:	00a00574 	movhi	r2,32789
8010085c:	10a99d04 	addi	r2,r2,-22924
80100860:	18c7883a 	add	r3,r3,r3
80100864:	18c7883a 	add	r3,r3,r3
80100868:	10c5883a 	add	r2,r2,r3
8010086c:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
80100870:	e0bfeb17 	ldw	r2,-84(fp)
80100874:	10ffff04 	addi	r3,r2,-4
80100878:	00a00574 	movhi	r2,32789
8010087c:	10a99d04 	addi	r2,r2,-22924
80100880:	18c7883a 	add	r3,r3,r3
80100884:	18c7883a 	add	r3,r3,r3
80100888:	10c5883a 	add	r2,r2,r3
8010088c:	00ffffc4 	movi	r3,-1
80100890:	10c00015 	stw	r3,0(r2)
80100894:	d0a09217 	ldw	r2,-32184(gp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
	debug(fp, cDebugBuffer);
#endif
	iTimeStart = alt_nticks();
80100898:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
8010089c:	e0bfe617 	ldw	r2,-104(fp)
801008a0:	e0bfea15 	stw	r2,-88(fp)
	iNAccessLen = sizeof(xSZData);
801008a4:	00810004 	movi	r2,1024
801008a8:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
801008ac:	e0ffe917 	ldw	r3,-92(fp)
801008b0:	e0bfee17 	ldw	r2,-72(fp)
801008b4:	1885283a 	div	r2,r3,r2
801008b8:	e0bfeb15 	stw	r2,-84(fp)
	iNPos = 0;
801008bc:	e03fec15 	stw	zero,-80(fp)
	while (iNPos < uliByteLen) {
801008c0:	00002d06 	br	80100978 <bDdr2MemoryWriteTest+0x320>
		iNRemainedLen = uliByteLen - iNPos;
801008c4:	e0bfec17 	ldw	r2,-80(fp)
801008c8:	e0ffe717 	ldw	r3,-100(fp)
801008cc:	1885c83a 	sub	r2,r3,r2
801008d0:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
801008d4:	e0bfe917 	ldw	r2,-92(fp)
801008d8:	e0fff217 	ldw	r3,-56(fp)
801008dc:	1880060e 	bge	r3,r2,801008f8 <bDdr2MemoryWriteTest+0x2a0>
			iNAccessLen = iNRemainedLen;
801008e0:	e0bff217 	ldw	r2,-56(fp)
801008e4:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
801008e8:	e0ffe917 	ldw	r3,-92(fp)
801008ec:	e0bfee17 	ldw	r2,-72(fp)
801008f0:	1885283a 	div	r2,r3,r2
801008f4:	e0bfeb15 	stw	r2,-84(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
801008f8:	e0bfe917 	ldw	r2,-92(fp)
801008fc:	100d883a 	mov	r6,r2
80100900:	01600574 	movhi	r5,32789
80100904:	29699d04 	addi	r5,r5,-22924
80100908:	e13fea17 	ldw	r4,-88(fp)
8010090c:	01214640 	call	80121464 <memcpy>
		pxDes += iNItemNum;
80100910:	e0bfeb17 	ldw	r2,-84(fp)
80100914:	1085883a 	add	r2,r2,r2
80100918:	1085883a 	add	r2,r2,r2
8010091c:	1007883a 	mov	r3,r2
80100920:	e0bfea17 	ldw	r2,-88(fp)
80100924:	10c5883a 	add	r2,r2,r3
80100928:	e0bfea15 	stw	r2,-88(fp)
		iNPos += iNAccessLen;
8010092c:	e0ffec17 	ldw	r3,-80(fp)
80100930:	e0bfe917 	ldw	r2,-92(fp)
80100934:	1885883a 	add	r2,r3,r2
80100938:	e0bfec15 	stw	r2,-80(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
8010093c:	e0bfed17 	ldw	r2,-76(fp)
80100940:	10800288 	cmpgei	r2,r2,10
80100944:	10000c1e 	bne	r2,zero,80100978 <bDdr2MemoryWriteTest+0x320>
80100948:	e0bfed17 	ldw	r2,-76(fp)
8010094c:	1085883a 	add	r2,r2,r2
80100950:	1085883a 	add	r2,r2,r2
80100954:	e0ffe504 	addi	r3,fp,-108
80100958:	1885883a 	add	r2,r3,r2
8010095c:	10800e04 	addi	r2,r2,56
80100960:	10800017 	ldw	r2,0(r2)
80100964:	e0ffec17 	ldw	r3,-80(fp)
80100968:	18800336 	bltu	r3,r2,80100978 <bDdr2MemoryWriteTest+0x320>
			iNProgressIndex++;
8010096c:	e0bfed17 	ldw	r2,-76(fp)
80100970:	10800044 	addi	r2,r2,1
80100974:	e0bfed15 	stw	r2,-76(fp)
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
80100978:	e0ffec17 	ldw	r3,-80(fp)
8010097c:	e0bfe717 	ldw	r2,-100(fp)
80100980:	18bfd036 	bltu	r3,r2,801008c4 <__reset+0xfa0e08c4>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
80100984:	0131b3c0 	call	80131b3c <alt_dcache_flush_all>
80100988:	d0e09217 	ldw	r3,-32184(gp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
8010098c:	e0bff117 	ldw	r2,-60(fp)
80100990:	1885c83a 	sub	r2,r3,r2
80100994:	e0bfef15 	stw	r2,-68(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
80100998:	e0bfe517 	ldw	r2,-108(fp)
}
8010099c:	e6fffe04 	addi	sp,fp,-8
801009a0:	dfc00317 	ldw	ra,12(sp)
801009a4:	df000217 	ldw	fp,8(sp)
801009a8:	dc400117 	ldw	r17,4(sp)
801009ac:	dc000017 	ldw	r16,0(sp)
801009b0:	dec00404 	addi	sp,sp,16
801009b4:	f800283a 	ret

801009b8 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
801009b8:	deffe304 	addi	sp,sp,-116
801009bc:	de00012e 	bgeu	sp,et,801009c4 <bDdr2MemoryReadTest+0xc>
801009c0:	003b68fa 	trap	3
801009c4:	dfc01c15 	stw	ra,112(sp)
801009c8:	df001b15 	stw	fp,108(sp)
801009cc:	dc401a15 	stw	r17,104(sp)
801009d0:	dc001915 	stw	r16,100(sp)
801009d4:	df001b04 	addi	fp,sp,108
801009d8:	2005883a 	mov	r2,r4
801009dc:	e0bffd05 	stb	r2,-12(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
	debug(fp, cDebugBuffer);
#endif
	bool bSuccess = FALSE;
801009e0:	e03fe515 	stw	zero,-108(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
801009e4:	e0bffd03 	ldbu	r2,-12(fp)
801009e8:	10000326 	beq	r2,zero,801009f8 <bDdr2MemoryReadTest+0x40>
801009ec:	10800060 	cmpeqi	r2,r2,1
801009f0:	10000a1e 	bne	r2,zero,80100a1c <bDdr2MemoryReadTest+0x64>
801009f4:	00001206 	br	80100a40 <bDdr2MemoryReadTest+0x88>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
801009f8:	e0bffd03 	ldbu	r2,-12(fp)
801009fc:	1009883a 	mov	r4,r2
80100a00:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
80100a04:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
80100a08:	00a00034 	movhi	r2,32768
80100a0c:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
80100a10:	00800044 	movi	r2,1
80100a14:	e0bfe515 	stw	r2,-108(fp)
		break;
80100a18:	00000c06 	br	80100a4c <bDdr2MemoryReadTest+0x94>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
80100a1c:	e0bffd03 	ldbu	r2,-12(fp)
80100a20:	1009883a 	mov	r4,r2
80100a24:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
80100a28:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
80100a2c:	00a00034 	movhi	r2,32768
80100a30:	e0bfe715 	stw	r2,-100(fp)
		bSuccess = TRUE;
80100a34:	00800044 	movi	r2,1
80100a38:	e0bfe515 	stw	r2,-108(fp)
		break;
80100a3c:	00000306 	br	80100a4c <bDdr2MemoryReadTest+0x94>
	default:
		bSuccess = FALSE;
80100a40:	e03fe515 	stw	zero,-108(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
80100a44:	e0bfe517 	ldw	r2,-108(fp)
80100a48:	00007206 	br	80100c14 <bDdr2MemoryReadTest+0x25c>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
80100a4c:	00804004 	movi	r2,256
80100a50:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
80100a54:	00800104 	movi	r2,4
80100a58:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
80100a5c:	e0ffec17 	ldw	r3,-80(fp)
80100a60:	e0bfef17 	ldw	r2,-68(fp)
80100a64:	1885383a 	mul	r2,r3,r2
80100a68:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
80100a6c:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
80100a70:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
80100a74:	e03fe815 	stw	zero,-96(fp)
80100a78:	00001506 	br	80100ad0 <bDdr2MemoryReadTest+0x118>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
80100a7c:	e0ffe717 	ldw	r3,-100(fp)
80100a80:	00b33374 	movhi	r2,52429
80100a84:	10b33344 	addi	r2,r2,-13107
80100a88:	1888383a 	mulxuu	r4,r3,r2
80100a8c:	1885383a 	mul	r2,r3,r2
80100a90:	1021883a 	mov	r16,r2
80100a94:	2023883a 	mov	r17,r4
80100a98:	8804d0fa 	srli	r2,r17,3
80100a9c:	e0ffe817 	ldw	r3,-96(fp)
80100aa0:	18c00044 	addi	r3,r3,1
80100aa4:	10c7383a 	mul	r3,r2,r3
80100aa8:	e0bfe817 	ldw	r2,-96(fp)
80100aac:	1085883a 	add	r2,r2,r2
80100ab0:	1085883a 	add	r2,r2,r2
80100ab4:	e13fe504 	addi	r4,fp,-108
80100ab8:	2085883a 	add	r2,r4,r2
80100abc:	10800e04 	addi	r2,r2,56
80100ac0:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
80100ac4:	e0bfe817 	ldw	r2,-96(fp)
80100ac8:	10800044 	addi	r2,r2,1
80100acc:	e0bfe815 	stw	r2,-96(fp)
80100ad0:	e0bfe817 	ldw	r2,-96(fp)
80100ad4:	10800290 	cmplti	r2,r2,10
80100ad8:	103fe81e 	bne	r2,zero,80100a7c <__reset+0xfa0e0a7c>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
80100adc:	e03fee15 	stw	zero,-72(fp)
80100ae0:	d0a09217 	ldw	r2,-32184(gp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
	debug(fp, cDebugBuffer);
#endif
	iTimeStart = alt_nticks();
80100ae4:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
80100ae8:	e0bfe617 	ldw	r2,-104(fp)
80100aec:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
80100af0:	00810004 	movi	r2,1024
80100af4:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
80100af8:	e0ffe917 	ldw	r3,-92(fp)
80100afc:	e0bfef17 	ldw	r2,-68(fp)
80100b00:	1885283a 	div	r2,r3,r2
80100b04:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
80100b08:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
80100b0c:	00003706 	br	80100bec <bDdr2MemoryReadTest+0x234>
		iNRemainedLen = uliByteLen - iNPos;
80100b10:	e0bfed17 	ldw	r2,-76(fp)
80100b14:	e0ffe717 	ldw	r3,-100(fp)
80100b18:	1885c83a 	sub	r2,r3,r2
80100b1c:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
80100b20:	e0bfe917 	ldw	r2,-92(fp)
80100b24:	e0fff217 	ldw	r3,-56(fp)
80100b28:	1880060e 	bge	r3,r2,80100b44 <bDdr2MemoryReadTest+0x18c>
			iNAccessLen = iNRemainedLen;
80100b2c:	e0bff217 	ldw	r2,-56(fp)
80100b30:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
80100b34:	e0ffe917 	ldw	r3,-92(fp)
80100b38:	e0bfef17 	ldw	r2,-68(fp)
80100b3c:	1885283a 	div	r2,r3,r2
80100b40:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
80100b44:	00a00574 	movhi	r2,32789
80100b48:	10a99d04 	addi	r2,r2,-22924
80100b4c:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
80100b50:	e03fe815 	stw	zero,-96(fp)
80100b54:	00000d06 	br	80100b8c <bDdr2MemoryReadTest+0x1d4>
			if (*pxSrc++ != *pxDes++) {
80100b58:	e0bfeb17 	ldw	r2,-84(fp)
80100b5c:	10c00104 	addi	r3,r2,4
80100b60:	e0ffeb15 	stw	r3,-84(fp)
80100b64:	10c00017 	ldw	r3,0(r2)
80100b68:	e0bfea17 	ldw	r2,-88(fp)
80100b6c:	11000104 	addi	r4,r2,4
80100b70:	e13fea15 	stw	r4,-88(fp)
80100b74:	10800017 	ldw	r2,0(r2)
80100b78:	18800126 	beq	r3,r2,80100b80 <bDdr2MemoryReadTest+0x1c8>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
80100b7c:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
80100b80:	e0bfe817 	ldw	r2,-96(fp)
80100b84:	10800044 	addi	r2,r2,1
80100b88:	e0bfe815 	stw	r2,-96(fp)
80100b8c:	e0ffe817 	ldw	r3,-96(fp)
80100b90:	e0bfec17 	ldw	r2,-80(fp)
80100b94:	1880020e 	bge	r3,r2,80100ba0 <bDdr2MemoryReadTest+0x1e8>
80100b98:	e0bfe517 	ldw	r2,-108(fp)
80100b9c:	103fee1e 	bne	r2,zero,80100b58 <__reset+0xfa0e0b58>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
80100ba0:	e0ffed17 	ldw	r3,-76(fp)
80100ba4:	e0bfe917 	ldw	r2,-92(fp)
80100ba8:	1885883a 	add	r2,r3,r2
80100bac:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
80100bb0:	e0bfee17 	ldw	r2,-72(fp)
80100bb4:	10800288 	cmpgei	r2,r2,10
80100bb8:	10000c1e 	bne	r2,zero,80100bec <bDdr2MemoryReadTest+0x234>
80100bbc:	e0bfee17 	ldw	r2,-72(fp)
80100bc0:	1085883a 	add	r2,r2,r2
80100bc4:	1085883a 	add	r2,r2,r2
80100bc8:	e0ffe504 	addi	r3,fp,-108
80100bcc:	1885883a 	add	r2,r3,r2
80100bd0:	10800e04 	addi	r2,r2,56
80100bd4:	10800017 	ldw	r2,0(r2)
80100bd8:	e0ffed17 	ldw	r3,-76(fp)
80100bdc:	18800336 	bltu	r3,r2,80100bec <bDdr2MemoryReadTest+0x234>
			iNProgressIndex++;
80100be0:	e0bfee17 	ldw	r2,-72(fp)
80100be4:	10800044 	addi	r2,r2,1
80100be8:	e0bfee15 	stw	r2,-72(fp)

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
80100bec:	e0bfe517 	ldw	r2,-108(fp)
80100bf0:	10000326 	beq	r2,zero,80100c00 <bDdr2MemoryReadTest+0x248>
80100bf4:	e0ffed17 	ldw	r3,-76(fp)
80100bf8:	e0bfe717 	ldw	r2,-100(fp)
80100bfc:	18bfc436 	bltu	r3,r2,80100b10 <__reset+0xfa0e0b10>
80100c00:	d0e09217 	ldw	r3,-32184(gp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
80100c04:	e0bff117 	ldw	r2,-60(fp)
80100c08:	1885c83a 	sub	r2,r3,r2
80100c0c:	e0bff015 	stw	r2,-64(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
80100c10:	e0bfe517 	ldw	r2,-108(fp)
}
80100c14:	e6fffe04 	addi	sp,fp,-8
80100c18:	dfc00317 	ldw	ra,12(sp)
80100c1c:	df000217 	ldw	fp,8(sp)
80100c20:	dc400117 	ldw	r17,4(sp)
80100c24:	dc000017 	ldw	r16,0(sp)
80100c28:	dec00404 	addi	sp,sp,16
80100c2c:	f800283a 	ret

80100c30 <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
80100c30:	deffed04 	addi	sp,sp,-76
80100c34:	de00012e 	bgeu	sp,et,80100c3c <bDdr2MemoryRandomWriteTest+0xc>
80100c38:	003b68fa 	trap	3
80100c3c:	dfc01215 	stw	ra,72(sp)
80100c40:	df001115 	stw	fp,68(sp)
80100c44:	dcc01015 	stw	r19,64(sp)
80100c48:	dc800f15 	stw	r18,60(sp)
80100c4c:	dc400e15 	stw	r17,56(sp)
80100c50:	dc000d15 	stw	r16,52(sp)
80100c54:	df001104 	addi	fp,sp,68
80100c58:	2005883a 	mov	r2,r4
80100c5c:	e17ffa15 	stw	r5,-24(fp)
80100c60:	e1bffb15 	stw	r6,-20(fp)
80100c64:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
	debug(fp, cDebugBuffer);
#endif
	bool bSuccess = FALSE;
80100c68:	e03fef15 	stw	zero,-68(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
80100c6c:	e0bff903 	ldbu	r2,-28(fp)
80100c70:	10000326 	beq	r2,zero,80100c80 <bDdr2MemoryRandomWriteTest+0x50>
80100c74:	10800060 	cmpeqi	r2,r2,1
80100c78:	10000a1e 	bne	r2,zero,80100ca4 <bDdr2MemoryRandomWriteTest+0x74>
80100c7c:	00001206 	br	80100cc8 <bDdr2MemoryRandomWriteTest+0x98>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
80100c80:	e0bff903 	ldbu	r2,-28(fp)
80100c84:	1009883a 	mov	r4,r2
80100c88:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
80100c8c:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
80100c90:	00a00034 	movhi	r2,32768
80100c94:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
80100c98:	00800044 	movi	r2,1
80100c9c:	e0bfef15 	stw	r2,-68(fp)
		break;
80100ca0:	00000c06 	br	80100cd4 <bDdr2MemoryRandomWriteTest+0xa4>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
80100ca4:	e0bff903 	ldbu	r2,-28(fp)
80100ca8:	1009883a 	mov	r4,r2
80100cac:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
80100cb0:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
80100cb4:	00a00034 	movhi	r2,32768
80100cb8:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
80100cbc:	00800044 	movi	r2,1
80100cc0:	e0bfef15 	stw	r2,-68(fp)
		break;
80100cc4:	00000306 	br	80100cd4 <bDdr2MemoryRandomWriteTest+0xa4>
	default:
		bSuccess = FALSE;
80100cc8:	e03fef15 	stw	zero,-68(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
80100ccc:	e0bfef17 	ldw	r2,-68(fp)
80100cd0:	00004906 	br	80100df8 <bDdr2MemoryRandomWriteTest+0x1c8>
80100cd4:	d0a09217 	ldw	r2,-32184(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
80100cd8:	d0a03615 	stw	r2,-32552(gp)
	uliCurrentState = uliInitialState;
80100cdc:	d0a03617 	ldw	r2,-32552(gp)
80100ce0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
80100ce4:	e0fff017 	ldw	r3,-64(fp)
80100ce8:	e0bff117 	ldw	r2,-60(fp)
80100cec:	1885883a 	add	r2,r3,r2
80100cf0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
80100cf4:	e0fff117 	ldw	r3,-60(fp)
80100cf8:	00b33374 	movhi	r2,52429
80100cfc:	10b33344 	addi	r2,r2,-13107
80100d00:	1888383a 	mulxuu	r4,r3,r2
80100d04:	1885383a 	mul	r2,r3,r2
80100d08:	1025883a 	mov	r18,r2
80100d0c:	2027883a 	mov	r19,r4
80100d10:	9806d13a 	srli	r3,r19,4
80100d14:	e0bff017 	ldw	r2,-64(fp)
80100d18:	1885883a 	add	r2,r3,r2
80100d1c:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
80100d20:	00800144 	movi	r2,5
80100d24:	e0bff405 	stb	r2,-48(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
		debug(fp, cDebugBuffer);
#endif
	}
	int TimeStart, TimeElapsed = 0;
80100d28:	e03ff615 	stw	zero,-40(fp)
80100d2c:	d0a09217 	ldw	r2,-32184(gp)

	TimeStart = alt_nticks();
80100d30:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
80100d34:	e0bff017 	ldw	r2,-64(fp)
80100d38:	e0bff215 	stw	r2,-56(fp)
80100d3c:	00002006 	br	80100dc0 <bDdr2MemoryRandomWriteTest+0x190>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
80100d40:	e0bff804 	addi	r2,fp,-32
80100d44:	1009883a 	mov	r4,r2
80100d48:	0100ff80 	call	80100ff8 <uliXorshift32>
80100d4c:	1007883a 	mov	r3,r2
80100d50:	e0bff217 	ldw	r2,-56(fp)
80100d54:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
80100d58:	e0bffa17 	ldw	r2,-24(fp)
80100d5c:	10800060 	cmpeqi	r2,r2,1
80100d60:	1009883a 	mov	r4,r2
80100d64:	e0bff217 	ldw	r2,-56(fp)
80100d68:	e0fff317 	ldw	r3,-52(fp)
80100d6c:	1885803a 	cmpltu	r2,r3,r2
80100d70:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
80100d74:	10803fcc 	andi	r2,r2,255
80100d78:	10000e26 	beq	r2,zero,80100db4 <bDdr2MemoryRandomWriteTest+0x184>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
			debug(fp, cDebugBuffer);
#endif
			uliNextMilestone += uliByteLen / 20;
80100d7c:	e0fff117 	ldw	r3,-60(fp)
80100d80:	00b33374 	movhi	r2,52429
80100d84:	10b33344 	addi	r2,r2,-13107
80100d88:	1888383a 	mulxuu	r4,r3,r2
80100d8c:	1885383a 	mul	r2,r3,r2
80100d90:	1021883a 	mov	r16,r2
80100d94:	2023883a 	mov	r17,r4
80100d98:	8804d13a 	srli	r2,r17,4
80100d9c:	e0fff317 	ldw	r3,-52(fp)
80100da0:	1885883a 	add	r2,r3,r2
80100da4:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
80100da8:	e0bff403 	ldbu	r2,-48(fp)
80100dac:	10800144 	addi	r2,r2,5
80100db0:	e0bff405 	stb	r2,-48(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
80100db4:	e0bff217 	ldw	r2,-56(fp)
80100db8:	10800104 	addi	r2,r2,4
80100dbc:	e0bff215 	stw	r2,-56(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
80100dc0:	e0fff217 	ldw	r3,-56(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
80100dc4:	e0bff517 	ldw	r2,-44(fp)
80100dc8:	18bfdd36 	bltu	r3,r2,80100d40 <__reset+0xfa0e0d40>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
80100dcc:	0131b3c0 	call	80131b3c <alt_dcache_flush_all>
		sprintf(cDebugBuffer, "..100%%\n");
		debug(fp, cDebugBuffer);
#endif
	}

	if (bSuccess) {
80100dd0:	e0bfef17 	ldw	r2,-68(fp)
80100dd4:	10000726 	beq	r2,zero,80100df4 <bDdr2MemoryRandomWriteTest+0x1c4>
		if (bTime == TRUE) {
80100dd8:	e0bffb17 	ldw	r2,-20(fp)
80100ddc:	10800058 	cmpnei	r2,r2,1
80100de0:	1000041e 	bne	r2,zero,80100df4 <bDdr2MemoryRandomWriteTest+0x1c4>
80100de4:	d0e09217 	ldw	r3,-32184(gp)
			TimeElapsed = alt_nticks() - TimeStart;
80100de8:	e0bff717 	ldw	r2,-36(fp)
80100dec:	1885c83a 	sub	r2,r3,r2
80100df0:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
80100df4:	e0bfef17 	ldw	r2,-68(fp)
}
80100df8:	e6fffc04 	addi	sp,fp,-16
80100dfc:	dfc00517 	ldw	ra,20(sp)
80100e00:	df000417 	ldw	fp,16(sp)
80100e04:	dcc00317 	ldw	r19,12(sp)
80100e08:	dc800217 	ldw	r18,8(sp)
80100e0c:	dc400117 	ldw	r17,4(sp)
80100e10:	dc000017 	ldw	r16,0(sp)
80100e14:	dec00604 	addi	sp,sp,24
80100e18:	f800283a 	ret

80100e1c <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
80100e1c:	deffed04 	addi	sp,sp,-76
80100e20:	de00012e 	bgeu	sp,et,80100e28 <bDdr2MemoryRandomReadTest+0xc>
80100e24:	003b68fa 	trap	3
80100e28:	dfc01215 	stw	ra,72(sp)
80100e2c:	df001115 	stw	fp,68(sp)
80100e30:	dcc01015 	stw	r19,64(sp)
80100e34:	dc800f15 	stw	r18,60(sp)
80100e38:	dc400e15 	stw	r17,56(sp)
80100e3c:	dc000d15 	stw	r16,52(sp)
80100e40:	df001104 	addi	fp,sp,68
80100e44:	2005883a 	mov	r2,r4
80100e48:	e17ffa15 	stw	r5,-24(fp)
80100e4c:	e1bffb15 	stw	r6,-20(fp)
80100e50:	e0bff905 	stb	r2,-28(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
	debug(fp, cDebugBuffer);
#endif
	bool bSuccess = FALSE;
80100e54:	e03fef15 	stw	zero,-68(fp)
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	switch (ucMemoryId) {
80100e58:	e0bff903 	ldbu	r2,-28(fp)
80100e5c:	10000326 	beq	r2,zero,80100e6c <bDdr2MemoryRandomReadTest+0x50>
80100e60:	10800060 	cmpeqi	r2,r2,1
80100e64:	10000a1e 	bne	r2,zero,80100e90 <bDdr2MemoryRandomReadTest+0x74>
80100e68:	00001206 	br	80100eb4 <bDdr2MemoryRandomReadTest+0x98>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
80100e6c:	e0bff903 	ldbu	r2,-28(fp)
80100e70:	1009883a 	mov	r4,r2
80100e74:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
80100e78:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
80100e7c:	00a00034 	movhi	r2,32768
80100e80:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
80100e84:	00800044 	movi	r2,1
80100e88:	e0bfef15 	stw	r2,-68(fp)
		break;
80100e8c:	00000c06 	br	80100ec0 <bDdr2MemoryRandomReadTest+0xa4>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
80100e90:	e0bff903 	ldbu	r2,-28(fp)
80100e94:	1009883a 	mov	r4,r2
80100e98:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
80100e9c:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
80100ea0:	00a00034 	movhi	r2,32768
80100ea4:	e0bff115 	stw	r2,-60(fp)
		bSuccess = TRUE;
80100ea8:	00800044 	movi	r2,1
80100eac:	e0bfef15 	stw	r2,-68(fp)
		break;
80100eb0:	00000306 	br	80100ec0 <bDdr2MemoryRandomReadTest+0xa4>
	default:
		bSuccess = FALSE;
80100eb4:	e03fef15 	stw	zero,-68(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
80100eb8:	e0bfef17 	ldw	r2,-68(fp)
80100ebc:	00004506 	br	80100fd4 <bDdr2MemoryRandomReadTest+0x1b8>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
80100ec0:	d0a03617 	ldw	r2,-32552(gp)
80100ec4:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
80100ec8:	e0fff017 	ldw	r3,-64(fp)
80100ecc:	e0bff117 	ldw	r2,-60(fp)
80100ed0:	1885883a 	add	r2,r3,r2
80100ed4:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
80100ed8:	e0fff117 	ldw	r3,-60(fp)
80100edc:	00b33374 	movhi	r2,52429
80100ee0:	10b33344 	addi	r2,r2,-13107
80100ee4:	1888383a 	mulxuu	r4,r3,r2
80100ee8:	1885383a 	mul	r2,r3,r2
80100eec:	1025883a 	mov	r18,r2
80100ef0:	2027883a 	mov	r19,r4
80100ef4:	9806d13a 	srli	r3,r19,4
80100ef8:	e0bff017 	ldw	r2,-64(fp)
80100efc:	1885883a 	add	r2,r3,r2
80100f00:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
80100f04:	00800144 	movi	r2,5
80100f08:	e0bff405 	stb	r2,-48(fp)
		sprintf(cDebugBuffer, "00%%..");
		debug(fp, cDebugBuffer);
#endif
	}

	int TimeStart, TimeElapsed = 0;
80100f0c:	e03ff615 	stw	zero,-40(fp)
80100f10:	d0a09217 	ldw	r2,-32184(gp)

	TimeStart = alt_nticks();
80100f14:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
80100f18:	e0bff017 	ldw	r2,-64(fp)
80100f1c:	e0bff215 	stw	r2,-56(fp)
80100f20:	00001f06 	br	80100fa0 <bDdr2MemoryRandomReadTest+0x184>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
80100f24:	e0bff804 	addi	r2,fp,-32
80100f28:	1009883a 	mov	r4,r2
80100f2c:	0100ff80 	call	80100ff8 <uliXorshift32>
80100f30:	1007883a 	mov	r3,r2
80100f34:	e0bff217 	ldw	r2,-56(fp)
80100f38:	10800017 	ldw	r2,0(r2)
80100f3c:	18800126 	beq	r3,r2,80100f44 <bDdr2MemoryRandomReadTest+0x128>
			bSuccess = FALSE;
80100f40:	e03fef15 	stw	zero,-68(fp)
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
80100f44:	e0bffa17 	ldw	r2,-24(fp)
80100f48:	10800058 	cmpnei	r2,r2,1
80100f4c:	1000111e 	bne	r2,zero,80100f94 <bDdr2MemoryRandomReadTest+0x178>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
80100f50:	e0bff217 	ldw	r2,-56(fp)
80100f54:	e0fff317 	ldw	r3,-52(fp)
80100f58:	18800e2e 	bgeu	r3,r2,80100f94 <bDdr2MemoryRandomReadTest+0x178>
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
			debug(fp, cDebugBuffer);
#endif
			uliNextMilestone += uliByteLen / 20;
80100f5c:	e0fff117 	ldw	r3,-60(fp)
80100f60:	00b33374 	movhi	r2,52429
80100f64:	10b33344 	addi	r2,r2,-13107
80100f68:	1888383a 	mulxuu	r4,r3,r2
80100f6c:	1885383a 	mul	r2,r3,r2
80100f70:	1021883a 	mov	r16,r2
80100f74:	2023883a 	mov	r17,r4
80100f78:	8804d13a 	srli	r2,r17,4
80100f7c:	e0fff317 	ldw	r3,-52(fp)
80100f80:	1885883a 	add	r2,r3,r2
80100f84:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
80100f88:	e0bff403 	ldbu	r2,-48(fp)
80100f8c:	10800144 	addi	r2,r2,5
80100f90:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
80100f94:	e0bff217 	ldw	r2,-56(fp)
80100f98:	10800104 	addi	r2,r2,4
80100f9c:	e0bff215 	stw	r2,-56(fp)
80100fa0:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
80100fa4:	e0bff517 	ldw	r2,-44(fp)
80100fa8:	18bfde36 	bltu	r3,r2,80100f24 <__reset+0xfa0e0f24>
		sprintf(cDebugBuffer, "..100%%\n");
		debug(fp, cDebugBuffer);
#endif
	}

	if (bSuccess) {
80100fac:	e0bfef17 	ldw	r2,-68(fp)
80100fb0:	10000726 	beq	r2,zero,80100fd0 <bDdr2MemoryRandomReadTest+0x1b4>
		if (bTime == TRUE) {
80100fb4:	e0bffb17 	ldw	r2,-20(fp)
80100fb8:	10800058 	cmpnei	r2,r2,1
80100fbc:	1000041e 	bne	r2,zero,80100fd0 <bDdr2MemoryRandomReadTest+0x1b4>
80100fc0:	d0e09217 	ldw	r3,-32184(gp)
			TimeElapsed = alt_nticks() - TimeStart;
80100fc4:	e0bff717 	ldw	r2,-36(fp)
80100fc8:	1885c83a 	sub	r2,r3,r2
80100fcc:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
80100fd0:	e0bfef17 	ldw	r2,-68(fp)
}
80100fd4:	e6fffc04 	addi	sp,fp,-16
80100fd8:	dfc00517 	ldw	ra,20(sp)
80100fdc:	df000417 	ldw	fp,16(sp)
80100fe0:	dcc00317 	ldw	r19,12(sp)
80100fe4:	dc800217 	ldw	r18,8(sp)
80100fe8:	dc400117 	ldw	r17,4(sp)
80100fec:	dc000017 	ldw	r16,0(sp)
80100ff0:	dec00604 	addi	sp,sp,24
80100ff4:	f800283a 	ret

80100ff8 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
80100ff8:	defffd04 	addi	sp,sp,-12
80100ffc:	de00012e 	bgeu	sp,et,80101004 <uliXorshift32+0xc>
80101000:	003b68fa 	trap	3
80101004:	df000215 	stw	fp,8(sp)
80101008:	df000204 	addi	fp,sp,8
8010100c:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
80101010:	e0bfff17 	ldw	r2,-4(fp)
80101014:	10800017 	ldw	r2,0(r2)
80101018:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
8010101c:	e0bffe17 	ldw	r2,-8(fp)
80101020:	1004937a 	slli	r2,r2,13
80101024:	e0fffe17 	ldw	r3,-8(fp)
80101028:	1884f03a 	xor	r2,r3,r2
8010102c:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
80101030:	e0bffe17 	ldw	r2,-8(fp)
80101034:	1004d47a 	srli	r2,r2,17
80101038:	e0fffe17 	ldw	r3,-8(fp)
8010103c:	1884f03a 	xor	r2,r3,r2
80101040:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
80101044:	e0bffe17 	ldw	r2,-8(fp)
80101048:	1004917a 	slli	r2,r2,5
8010104c:	e0fffe17 	ldw	r3,-8(fp)
80101050:	1884f03a 	xor	r2,r3,r2
80101054:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
80101058:	e0bfff17 	ldw	r2,-4(fp)
8010105c:	e0fffe17 	ldw	r3,-8(fp)
80101060:	10c00015 	stw	r3,0(r2)

	return uliX;
80101064:	e0bffe17 	ldw	r2,-8(fp)
}
80101068:	e037883a 	mov	sp,fp
8010106c:	df000017 	ldw	fp,0(sp)
80101070:	dec00104 	addi	sp,sp,4
80101074:	f800283a 	ret

80101078 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
80101078:	defffb04 	addi	sp,sp,-20
8010107c:	de00012e 	bgeu	sp,et,80101084 <DMA_OPEN_DEVICE+0xc>
80101080:	003b68fa 	trap	3
80101084:	dfc00415 	stw	ra,16(sp)
80101088:	df000315 	stw	fp,12(sp)
8010108c:	df000304 	addi	fp,sp,12
80101090:	e13ffe15 	stw	r4,-8(fp)
80101094:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
80101098:	00800044 	movi	r2,1
8010109c:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
801010a0:	e13fff17 	ldw	r4,-4(fp)
801010a4:	01451900 	call	80145190 <alt_msgdma_open>
801010a8:	1007883a 	mov	r3,r2
801010ac:	e0bffe17 	ldw	r2,-8(fp)
801010b0:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
801010b4:	e0bffe17 	ldw	r2,-8(fp)
801010b8:	10800017 	ldw	r2,0(r2)
801010bc:	1000011e 	bne	r2,zero,801010c4 <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
801010c0:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
801010c4:	e0bffd17 	ldw	r2,-12(fp)
}
801010c8:	e037883a 	mov	sp,fp
801010cc:	dfc00117 	ldw	ra,4(sp)
801010d0:	df000017 	ldw	fp,0(sp)
801010d4:	dec00204 	addi	sp,sp,8
801010d8:	f800283a 	ret

801010dc <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
801010dc:	defffc04 	addi	sp,sp,-16
801010e0:	de00012e 	bgeu	sp,et,801010e8 <DMA_CONFIG+0xc>
801010e4:	003b68fa 	trap	3
801010e8:	df000315 	stw	fp,12(sp)
801010ec:	df000304 	addi	fp,sp,12
801010f0:	e13ffe15 	stw	r4,-8(fp)
801010f4:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
801010f8:	00800044 	movi	r2,1
801010fc:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
80101100:	e0bffe17 	ldw	r2,-8(fp)
80101104:	10800317 	ldw	r2,12(r2)
80101108:	10800104 	addi	r2,r2,4
8010110c:	e0ffff17 	ldw	r3,-4(fp)
80101110:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
80101114:	e0bffd17 	ldw	r2,-12(fp)
}
80101118:	e037883a 	mov	sp,fp
8010111c:	df000017 	ldw	fp,0(sp)
80101120:	dec00104 	addi	sp,sp,4
80101124:	f800283a 	ret

80101128 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
80101128:	defffd04 	addi	sp,sp,-12
8010112c:	de00012e 	bgeu	sp,et,80101134 <DMA_BUSY+0xc>
80101130:	003b68fa 	trap	3
80101134:	df000215 	stw	fp,8(sp)
80101138:	df000204 	addi	fp,sp,8
8010113c:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
80101140:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
80101144:	e0bfff17 	ldw	r2,-4(fp)
80101148:	10800317 	ldw	r2,12(r2)
8010114c:	10800037 	ldwio	r2,0(r2)
80101150:	1080004c 	andi	r2,r2,1
80101154:	10000226 	beq	r2,zero,80101160 <DMA_BUSY+0x38>
    bBusy = TRUE;
80101158:	00800044 	movi	r2,1
8010115c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
80101160:	e0bffe17 	ldw	r2,-8(fp)
}
80101164:	e037883a 	mov	sp,fp
80101168:	df000017 	ldw	fp,0(sp)
8010116c:	dec00104 	addi	sp,sp,4
80101170:	f800283a 	ret

80101174 <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
80101174:	defffd04 	addi	sp,sp,-12
80101178:	de00012e 	bgeu	sp,et,80101180 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
8010117c:	003b68fa 	trap	3
80101180:	df000215 	stw	fp,8(sp)
80101184:	df000204 	addi	fp,sp,8
80101188:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
8010118c:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
80101190:	e0bfff17 	ldw	r2,-4(fp)
80101194:	10800317 	ldw	r2,12(r2)
80101198:	10800037 	ldwio	r2,0(r2)
8010119c:	1080010c 	andi	r2,r2,4
801011a0:	10000226 	beq	r2,zero,801011ac <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
801011a4:	00800044 	movi	r2,1
801011a8:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
801011ac:	e0bffe17 	ldw	r2,-8(fp)
}
801011b0:	e037883a 	mov	sp,fp
801011b4:	df000017 	ldw	fp,0(sp)
801011b8:	dec00104 	addi	sp,sp,4
801011bc:	f800283a 	ret

801011c0 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
801011c0:	defffd04 	addi	sp,sp,-12
801011c4:	de00012e 	bgeu	sp,et,801011cc <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
801011c8:	003b68fa 	trap	3
801011cc:	df000215 	stw	fp,8(sp)
801011d0:	df000204 	addi	fp,sp,8
801011d4:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
801011d8:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
801011dc:	e0bfff17 	ldw	r2,-4(fp)
801011e0:	10800317 	ldw	r2,12(r2)
801011e4:	10800037 	ldwio	r2,0(r2)
801011e8:	1080008c 	andi	r2,r2,2
801011ec:	10000226 	beq	r2,zero,801011f8 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
801011f0:	00800044 	movi	r2,1
801011f4:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
801011f8:	e0bffe17 	ldw	r2,-8(fp)
}
801011fc:	e037883a 	mov	sp,fp
80101200:	df000017 	ldw	fp,0(sp)
80101204:	dec00104 	addi	sp,sp,4
80101208:	f800283a 	ret

8010120c <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
8010120c:	defffa04 	addi	sp,sp,-24
80101210:	de00012e 	bgeu	sp,et,80101218 <DMA_DISPATCHER_STOP+0xc>
80101214:	003b68fa 	trap	3
80101218:	dfc00515 	stw	ra,20(sp)
8010121c:	df000415 	stw	fp,16(sp)
80101220:	df000404 	addi	fp,sp,16
80101224:	e13ffd15 	stw	r4,-12(fp)
80101228:	e17ffe15 	stw	r5,-8(fp)
8010122c:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
80101230:	00800044 	movi	r2,1
80101234:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
80101238:	e0bffd17 	ldw	r2,-12(fp)
8010123c:	10800317 	ldw	r2,12(r2)
80101240:	10800104 	addi	r2,r2,4
80101244:	00c00044 	movi	r3,1
80101248:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
8010124c:	e0bffe17 	ldw	r2,-8(fp)
80101250:	10800058 	cmpnei	r2,r2,1
80101254:	10000f1e 	bne	r2,zero,80101294 <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
80101258:	00000806 	br	8010127c <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
8010125c:	e0bfff17 	ldw	r2,-4(fp)
80101260:	1000031e 	bne	r2,zero,80101270 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
80101264:	01000044 	movi	r4,1
80101268:	01330f80 	call	801330f8 <usleep>
8010126c:	00000306 	br	8010127c <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
80101270:	e0bfff17 	ldw	r2,-4(fp)
80101274:	1009883a 	mov	r4,r2
80101278:	01330f80 	call	801330f8 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
8010127c:	e0bffd17 	ldw	r2,-12(fp)
80101280:	10800317 	ldw	r2,12(r2)
80101284:	10800037 	ldwio	r2,0(r2)
80101288:	1080080c 	andi	r2,r2,32
8010128c:	103ff31e 	bne	r2,zero,8010125c <__reset+0xfa0e125c>
80101290:	00000206 	br	8010129c <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
80101294:	e0bffc17 	ldw	r2,-16(fp)
80101298:	00000106 	br	801012a0 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
8010129c:	e0bffc17 	ldw	r2,-16(fp)
}
801012a0:	e037883a 	mov	sp,fp
801012a4:	dfc00117 	ldw	ra,4(sp)
801012a8:	df000017 	ldw	fp,0(sp)
801012ac:	dec00204 	addi	sp,sp,8
801012b0:	f800283a 	ret

801012b4 <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
801012b4:	defffa04 	addi	sp,sp,-24
801012b8:	de00012e 	bgeu	sp,et,801012c0 <DMA_DISPATCHER_RESET+0xc>
801012bc:	003b68fa 	trap	3
801012c0:	dfc00515 	stw	ra,20(sp)
801012c4:	df000415 	stw	fp,16(sp)
801012c8:	df000404 	addi	fp,sp,16
801012cc:	e13ffd15 	stw	r4,-12(fp)
801012d0:	e17ffe15 	stw	r5,-8(fp)
801012d4:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
801012d8:	00800044 	movi	r2,1
801012dc:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
801012e0:	e0bffd17 	ldw	r2,-12(fp)
801012e4:	10800317 	ldw	r2,12(r2)
801012e8:	10800104 	addi	r2,r2,4
801012ec:	00c00084 	movi	r3,2
801012f0:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
801012f4:	e0bffe17 	ldw	r2,-8(fp)
801012f8:	10800058 	cmpnei	r2,r2,1
801012fc:	10000f1e 	bne	r2,zero,8010133c <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
80101300:	00000806 	br	80101324 <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
80101304:	e0bfff17 	ldw	r2,-4(fp)
80101308:	1000031e 	bne	r2,zero,80101318 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
8010130c:	01000044 	movi	r4,1
80101310:	01330f80 	call	801330f8 <usleep>
80101314:	00000306 	br	80101324 <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
80101318:	e0bfff17 	ldw	r2,-4(fp)
8010131c:	1009883a 	mov	r4,r2
80101320:	01330f80 	call	801330f8 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
80101324:	e0bffd17 	ldw	r2,-12(fp)
80101328:	10800317 	ldw	r2,12(r2)
8010132c:	10800037 	ldwio	r2,0(r2)
80101330:	1080100c 	andi	r2,r2,64
80101334:	103ff31e 	bne	r2,zero,80101304 <__reset+0xfa0e1304>
80101338:	00000206 	br	80101344 <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
8010133c:	e0bffc17 	ldw	r2,-16(fp)
80101340:	00000106 	br	80101348 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
80101344:	e0bffc17 	ldw	r2,-16(fp)
}
80101348:	e037883a 	mov	sp,fp
8010134c:	dfc00117 	ldw	ra,4(sp)
80101350:	df000017 	ldw	fp,0(sp)
80101354:	dec00204 	addi	sp,sp,8
80101358:	f800283a 	ret

8010135c <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
8010135c:	defff604 	addi	sp,sp,-40
80101360:	de00012e 	bgeu	sp,et,80101368 <DMA_SINGLE_TRANSFER+0xc>
80101364:	003b68fa 	trap	3
80101368:	dfc00915 	stw	ra,36(sp)
8010136c:	df000815 	stw	fp,32(sp)
80101370:	dc000715 	stw	r16,28(sp)
80101374:	df000804 	addi	fp,sp,32
80101378:	e13ffb15 	stw	r4,-20(fp)
8010137c:	e17ffc15 	stw	r5,-16(fp)
80101380:	e1bffd15 	stw	r6,-12(fp)
80101384:	e1fffe15 	stw	r7,-8(fp)
80101388:	defff804 	addi	sp,sp,-32
8010138c:	d8800204 	addi	r2,sp,8
80101390:	108003c4 	addi	r2,r2,15
80101394:	1004d13a 	srli	r2,r2,4
80101398:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
8010139c:	00800044 	movi	r2,1
801013a0:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
801013a4:	e0fffc17 	ldw	r3,-16(fp)
801013a8:	e13ffd17 	ldw	r4,-12(fp)
801013ac:	e0800217 	ldw	r2,8(fp)
801013b0:	d8800115 	stw	r2,4(sp)
801013b4:	e0bffe17 	ldw	r2,-8(fp)
801013b8:	d8800015 	stw	r2,0(sp)
801013bc:	200f883a 	mov	r7,r4
801013c0:	180d883a 	mov	r6,r3
801013c4:	800b883a 	mov	r5,r16
801013c8:	e13ffb17 	ldw	r4,-20(fp)
801013cc:	014418c0 	call	8014418c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
801013d0:	10000326 	beq	r2,zero,801013e0 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
801013d4:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
801013d8:	e0bffa17 	ldw	r2,-24(fp)
801013dc:	00001e06 	br	80101458 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
801013e0:	800b883a 	mov	r5,r16
801013e4:	e13ffb17 	ldw	r4,-20(fp)
801013e8:	01454000 	call	80145400 <alt_msgdma_standard_descriptor_async_transfer>
801013ec:	10000326 	beq	r2,zero,801013fc <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
801013f0:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
801013f4:	e0bffa17 	ldw	r2,-24(fp)
801013f8:	00001706 	br	80101458 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
801013fc:	e0bffa17 	ldw	r2,-24(fp)
80101400:	10800060 	cmpeqi	r2,r2,1
80101404:	1007883a 	mov	r3,r2
80101408:	e0800317 	ldw	r2,12(fp)
8010140c:	10800060 	cmpeqi	r2,r2,1
80101410:	1884703a 	and	r2,r3,r2
80101414:	10803fcc 	andi	r2,r2,255
80101418:	10000e26 	beq	r2,zero,80101454 <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
8010141c:	00000806 	br	80101440 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
80101420:	e0800417 	ldw	r2,16(fp)
80101424:	1000031e 	bne	r2,zero,80101434 <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
80101428:	0100fa04 	movi	r4,1000
8010142c:	01330f80 	call	801330f8 <usleep>
80101430:	00000306 	br	80101440 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
80101434:	e0800417 	ldw	r2,16(fp)
80101438:	1009883a 	mov	r4,r2
8010143c:	01330f80 	call	801330f8 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
80101440:	e0bffb17 	ldw	r2,-20(fp)
80101444:	10800317 	ldw	r2,12(r2)
80101448:	10800037 	ldwio	r2,0(r2)
8010144c:	1080004c 	andi	r2,r2,1
80101450:	103ff31e 	bne	r2,zero,80101420 <__reset+0xfa0e1420>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
80101454:	e0bffa17 	ldw	r2,-24(fp)
}
80101458:	e6ffff04 	addi	sp,fp,-4
8010145c:	dfc00217 	ldw	ra,8(sp)
80101460:	df000117 	ldw	fp,4(sp)
80101464:	dc000017 	ldw	r16,0(sp)
80101468:	dec00304 	addi	sp,sp,12
8010146c:	f800283a 	ret

80101470 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
80101470:	defff504 	addi	sp,sp,-44
80101474:	de00012e 	bgeu	sp,et,8010147c <DMA_MULTIPLE_TRANSFER+0xc>
80101478:	003b68fa 	trap	3
8010147c:	dfc00a15 	stw	ra,40(sp)
80101480:	df000915 	stw	fp,36(sp)
80101484:	dc000815 	stw	r16,32(sp)
80101488:	df000904 	addi	fp,sp,36
8010148c:	e13ffb15 	stw	r4,-20(fp)
80101490:	e17ffc15 	stw	r5,-16(fp)
80101494:	e1bffd15 	stw	r6,-12(fp)
80101498:	3805883a 	mov	r2,r7
8010149c:	e0bffe05 	stb	r2,-8(fp)
801014a0:	defff804 	addi	sp,sp,-32
801014a4:	d8800204 	addi	r2,sp,8
801014a8:	108003c4 	addi	r2,r2,15
801014ac:	1004d13a 	srli	r2,r2,4
801014b0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
801014b4:	00800044 	movi	r2,1
801014b8:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
801014bc:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
801014c0:	00002506 	br	80101558 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
801014c4:	e0bffa03 	ldbu	r2,-24(fp)
801014c8:	1085883a 	add	r2,r2,r2
801014cc:	1085883a 	add	r2,r2,r2
801014d0:	1007883a 	mov	r3,r2
801014d4:	e0bffc17 	ldw	r2,-16(fp)
801014d8:	10c5883a 	add	r2,r2,r3
801014dc:	10800017 	ldw	r2,0(r2)
801014e0:	1009883a 	mov	r4,r2
801014e4:	e0bffa03 	ldbu	r2,-24(fp)
801014e8:	1085883a 	add	r2,r2,r2
801014ec:	1085883a 	add	r2,r2,r2
801014f0:	1007883a 	mov	r3,r2
801014f4:	e0bffd17 	ldw	r2,-12(fp)
801014f8:	10c5883a 	add	r2,r2,r3
801014fc:	10800017 	ldw	r2,0(r2)
80101500:	1007883a 	mov	r3,r2
80101504:	e0800317 	ldw	r2,12(fp)
80101508:	10804034 	orhi	r2,r2,256
8010150c:	d8800115 	stw	r2,4(sp)
80101510:	e0800217 	ldw	r2,8(fp)
80101514:	d8800015 	stw	r2,0(sp)
80101518:	180f883a 	mov	r7,r3
8010151c:	200d883a 	mov	r6,r4
80101520:	800b883a 	mov	r5,r16
80101524:	e13ffb17 	ldw	r4,-20(fp)
80101528:	014418c0 	call	8014418c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
8010152c:	10000226 	beq	r2,zero,80101538 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
80101530:	e03ff915 	stw	zero,-28(fp)
80101534:	00000506 	br	8010154c <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
80101538:	800b883a 	mov	r5,r16
8010153c:	e13ffb17 	ldw	r4,-20(fp)
80101540:	01454000 	call	80145400 <alt_msgdma_standard_descriptor_async_transfer>
80101544:	10000126 	beq	r2,zero,8010154c <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
80101548:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
8010154c:	e0bffa03 	ldbu	r2,-24(fp)
80101550:	10800044 	addi	r2,r2,1
80101554:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
80101558:	e0bff917 	ldw	r2,-28(fp)
8010155c:	10800060 	cmpeqi	r2,r2,1
80101560:	1009883a 	mov	r4,r2
80101564:	e0fffa03 	ldbu	r3,-24(fp)
80101568:	e0bffe03 	ldbu	r2,-8(fp)
8010156c:	10bfffc4 	addi	r2,r2,-1
80101570:	1884803a 	cmplt	r2,r3,r2
80101574:	2084703a 	and	r2,r4,r2
80101578:	10803fcc 	andi	r2,r2,255
8010157c:	103fd11e 	bne	r2,zero,801014c4 <__reset+0xfa0e14c4>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
80101580:	e0bff917 	ldw	r2,-28(fp)
80101584:	10800058 	cmpnei	r2,r2,1
80101588:	1000211e 	bne	r2,zero,80101610 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
8010158c:	e0bffa03 	ldbu	r2,-24(fp)
80101590:	1085883a 	add	r2,r2,r2
80101594:	1085883a 	add	r2,r2,r2
80101598:	1007883a 	mov	r3,r2
8010159c:	e0bffc17 	ldw	r2,-16(fp)
801015a0:	10c5883a 	add	r2,r2,r3
801015a4:	10800017 	ldw	r2,0(r2)
801015a8:	1009883a 	mov	r4,r2
801015ac:	e0bffa03 	ldbu	r2,-24(fp)
801015b0:	1085883a 	add	r2,r2,r2
801015b4:	1085883a 	add	r2,r2,r2
801015b8:	1007883a 	mov	r3,r2
801015bc:	e0bffd17 	ldw	r2,-12(fp)
801015c0:	10c5883a 	add	r2,r2,r3
801015c4:	10800017 	ldw	r2,0(r2)
801015c8:	1007883a 	mov	r3,r2
801015cc:	e0800317 	ldw	r2,12(fp)
801015d0:	d8800115 	stw	r2,4(sp)
801015d4:	e0800217 	ldw	r2,8(fp)
801015d8:	d8800015 	stw	r2,0(sp)
801015dc:	180f883a 	mov	r7,r3
801015e0:	200d883a 	mov	r6,r4
801015e4:	800b883a 	mov	r5,r16
801015e8:	e13ffb17 	ldw	r4,-20(fp)
801015ec:	014418c0 	call	8014418c <alt_msgdma_construct_standard_mm_to_mm_descriptor>
801015f0:	10000226 	beq	r2,zero,801015fc <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
801015f4:	e03ff915 	stw	zero,-28(fp)
801015f8:	00000506 	br	80101610 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
801015fc:	800b883a 	mov	r5,r16
80101600:	e13ffb17 	ldw	r4,-20(fp)
80101604:	01454000 	call	80145400 <alt_msgdma_standard_descriptor_async_transfer>
80101608:	10000126 	beq	r2,zero,80101610 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
8010160c:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
80101610:	e0bff917 	ldw	r2,-28(fp)
80101614:	10800060 	cmpeqi	r2,r2,1
80101618:	1007883a 	mov	r3,r2
8010161c:	e0800417 	ldw	r2,16(fp)
80101620:	10800060 	cmpeqi	r2,r2,1
80101624:	1884703a 	and	r2,r3,r2
80101628:	10803fcc 	andi	r2,r2,255
8010162c:	10000e26 	beq	r2,zero,80101668 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
80101630:	00000806 	br	80101654 <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
80101634:	e0800517 	ldw	r2,20(fp)
80101638:	1000031e 	bne	r2,zero,80101648 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
8010163c:	0100fa04 	movi	r4,1000
80101640:	01330f80 	call	801330f8 <usleep>
80101644:	00000306 	br	80101654 <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
80101648:	e0800517 	ldw	r2,20(fp)
8010164c:	1009883a 	mov	r4,r2
80101650:	01330f80 	call	801330f8 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
80101654:	e0bffb17 	ldw	r2,-20(fp)
80101658:	10800317 	ldw	r2,12(r2)
8010165c:	10800037 	ldwio	r2,0(r2)
80101660:	1080004c 	andi	r2,r2,1
80101664:	103ff31e 	bne	r2,zero,80101634 <__reset+0xfa0e1634>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
80101668:	e0bff917 	ldw	r2,-28(fp)
}
8010166c:	e6ffff04 	addi	sp,fp,-4
80101670:	dfc00217 	ldw	ra,8(sp)
80101674:	df000117 	ldw	fp,4(sp)
80101678:	dc000017 	ldw	r16,0(sp)
8010167c:	dec00304 	addi	sp,sp,12
80101680:	f800283a 	ret

80101684 <POWER_Read>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
80101684:	deffef04 	addi	sp,sp,-68
80101688:	de00012e 	bgeu	sp,et,80101690 <POWER_Read+0xc>
8010168c:	003b68fa 	trap	3
80101690:	dfc01015 	stw	ra,64(sp)
80101694:	df000f15 	stw	fp,60(sp)
80101698:	df000f04 	addi	fp,sp,60
8010169c:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
801016a0:	00800044 	movi	r2,1
801016a4:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
801016a8:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
801016ac:	00800204 	movi	r2,8
801016b0:	e0bffc15 	stw	r2,-16(fp)
801016b4:	00800104 	movi	r2,4
801016b8:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
//	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL;
	const bool bEN = TRUE; // alwasy update next conversion channel
801016bc:	00800044 	movi	r2,1
801016c0:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
801016c4:	00800044 	movi	r2,1
801016c8:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
801016cc:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
801016d0:	e03ff515 	stw	zero,-44(fp)
801016d4:	00005b06 	br	80101844 <POWER_Read+0x1c0>
		NextChannel = 0;
801016d8:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
801016dc:	e0bff517 	ldw	r2,-44(fp)
801016e0:	10c03fcc 	andi	r3,r2,255
801016e4:	e13ffa03 	ldbu	r4,-24(fp)
801016e8:	e0bfff17 	ldw	r2,-4(fp)
801016ec:	d8800115 	stw	r2,4(sp)
801016f0:	e0bff917 	ldw	r2,-28(fp)
801016f4:	d8800015 	stw	r2,0(sp)
801016f8:	e1fff817 	ldw	r7,-32(fp)
801016fc:	e1bff717 	ldw	r6,-36(fp)
80101700:	200b883a 	mov	r5,r4
80101704:	1809883a 	mov	r4,r3
80101708:	010c6300 	call	8010c630 <POWER_SPI_RW>
8010170c:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
80101710:	e03ff415 	stw	zero,-48(fp)
80101714:	00003d06 	br	8010180c <POWER_Read+0x188>
			NextChannel = i + 1;
80101718:	e0bff417 	ldw	r2,-48(fp)
8010171c:	10800044 	addi	r2,r2,1
80101720:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
80101724:	e0bff517 	ldw	r2,-44(fp)
80101728:	10c03fcc 	andi	r3,r2,255
8010172c:	e13ffa03 	ldbu	r4,-24(fp)
80101730:	e0bffe04 	addi	r2,fp,-8
80101734:	d8800115 	stw	r2,4(sp)
80101738:	e0bff917 	ldw	r2,-28(fp)
8010173c:	d8800015 	stw	r2,0(sp)
80101740:	e1fff817 	ldw	r7,-32(fp)
80101744:	e1bff717 	ldw	r6,-36(fp)
80101748:	200b883a 	mov	r5,r4
8010174c:	1809883a 	mov	r4,r3
80101750:	010c6300 	call	8010c630 <POWER_SPI_RW>
80101754:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
80101758:	e0bff317 	ldw	r2,-52(fp)
8010175c:	10002826 	beq	r2,zero,80101800 <POWER_Read+0x17c>
				HEAD = (Value32 >> 30) & 0x03;
80101760:	e0bffe17 	ldw	r2,-8(fp)
80101764:	1004d7ba 	srli	r2,r2,30
80101768:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
8010176c:	e0bffe17 	ldw	r2,-8(fp)
80101770:	1004d07a 	srli	r2,r2,1
80101774:	108001cc 	andi	r2,r2,7
80101778:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
8010177c:	e0bffe17 	ldw	r2,-8(fp)
80101780:	1004d13a 	srli	r2,r2,4
80101784:	1080004c 	andi	r2,r2,1
80101788:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
8010178c:	e0bffe17 	ldw	r2,-8(fp)
80101790:	1004d17a 	srli	r2,r2,5
80101794:	1080004c 	andi	r2,r2,1
80101798:	e0bffb05 	stb	r2,-20(fp)
//				PARITY = Value32 & 0x01;
				if (HEAD != 0) {
8010179c:	e0bffa43 	ldbu	r2,-23(fp)
801017a0:	10000226 	beq	r2,zero,801017ac <POWER_Read+0x128>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
801017a4:	e03ff315 	stw	zero,-52(fp)
801017a8:	00000906 	br	801017d0 <POWER_Read+0x14c>
				} else if (Channel != i) {
801017ac:	e0fffa83 	ldbu	r3,-22(fp)
801017b0:	e0bff417 	ldw	r2,-48(fp)
801017b4:	18800226 	beq	r3,r2,801017c0 <POWER_Read+0x13c>
					sprintf(cDebugBuffer,
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
801017b8:	e03ff315 	stw	zero,-52(fp)
801017bc:	00000406 	br	801017d0 <POWER_Read+0x14c>
				} else if (SIGN ^ bSIGN) {
801017c0:	e0fffac3 	ldbu	r3,-21(fp)
801017c4:	e0bff817 	ldw	r2,-32(fp)
801017c8:	18800126 	beq	r3,r2,801017d0 <POWER_Read+0x14c>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
801017cc:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
801017d0:	e0bff317 	ldw	r2,-52(fp)
801017d4:	10000a26 	beq	r2,zero,80101800 <POWER_Read+0x17c>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
801017d8:	e0bff617 	ldw	r2,-40(fp)
801017dc:	10c00044 	addi	r3,r2,1
801017e0:	e0fff615 	stw	r3,-40(fp)
801017e4:	1085883a 	add	r2,r2,r2
801017e8:	1085883a 	add	r2,r2,r2
801017ec:	1007883a 	mov	r3,r2
801017f0:	e0bfff17 	ldw	r2,-4(fp)
801017f4:	10c5883a 	add	r2,r2,r3
801017f8:	e0fffe17 	ldw	r3,-8(fp)
801017fc:	10c00015 	stw	r3,0(r2)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
80101800:	e0bff417 	ldw	r2,-48(fp)
80101804:	10800044 	addi	r2,r2,1
80101808:	e0bff415 	stw	r2,-48(fp)
8010180c:	e0bff517 	ldw	r2,-44(fp)
80101810:	1085883a 	add	r2,r2,r2
80101814:	1085883a 	add	r2,r2,r2
80101818:	e0fff304 	addi	r3,fp,-52
8010181c:	1885883a 	add	r2,r3,r2
80101820:	10800904 	addi	r2,r2,36
80101824:	10800017 	ldw	r2,0(r2)
80101828:	e0fff417 	ldw	r3,-48(fp)
8010182c:	1880020e 	bge	r3,r2,80101838 <POWER_Read+0x1b4>
80101830:	e0bff317 	ldw	r2,-52(fp)
80101834:	103fb81e 	bne	r2,zero,80101718 <__reset+0xfa0e1718>
//	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
80101838:	e0bff517 	ldw	r2,-44(fp)
8010183c:	10800044 	addi	r2,r2,1
80101840:	e0bff515 	stw	r2,-44(fp)
80101844:	e0bff517 	ldw	r2,-44(fp)
80101848:	10800088 	cmpgei	r2,r2,2
8010184c:	1000021e 	bne	r2,zero,80101858 <POWER_Read+0x1d4>
80101850:	e0bff317 	ldw	r2,-52(fp)
80101854:	103fa01e 	bne	r2,zero,801016d8 <__reset+0xfa0e16d8>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
80101858:	e0bff317 	ldw	r2,-52(fp)
}
8010185c:	e037883a 	mov	sp,fp
80101860:	dfc00117 	ldw	ra,4(sp)
80101864:	df000017 	ldw	fp,0(sp)
80101868:	dec00204 	addi	sp,sp,8
8010186c:	f800283a 	ret

80101870 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
80101870:	defff904 	addi	sp,sp,-28
80101874:	de00012e 	bgeu	sp,et,8010187c <TEMP_Read+0xc>
80101878:	003b68fa 	trap	3
8010187c:	dfc00615 	stw	ra,24(sp)
80101880:	df000515 	stw	fp,20(sp)
80101884:	df000504 	addi	fp,sp,20
80101888:	e13ffe15 	stw	r4,-8(fp)
8010188c:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
80101890:	00800c04 	movi	r2,48
80101894:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
80101898:	e0bffd83 	ldbu	r2,-10(fp)
8010189c:	10c03fcc 	andi	r3,r2,255
801018a0:	18c0201c 	xori	r3,r3,128
801018a4:	18ffe004 	addi	r3,r3,-128
801018a8:	e0bffdc4 	addi	r2,fp,-9
801018ac:	d8800015 	stw	r2,0(sp)
801018b0:	000f883a 	mov	r7,zero
801018b4:	180d883a 	mov	r6,r3
801018b8:	01500034 	movhi	r5,16384
801018bc:	29426004 	addi	r5,r5,2432
801018c0:	01100034 	movhi	r4,16384
801018c4:	21026404 	addi	r4,r4,2448
801018c8:	010b4d00 	call	8010b4d0 <I2C_Read>
801018cc:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
801018d0:	e0bffc17 	ldw	r2,-16(fp)
801018d4:	10000226 	beq	r2,zero,801018e0 <TEMP_Read+0x70>
		BoardTemp = Data;
801018d8:	e0bffdc3 	ldbu	r2,-9(fp)
801018dc:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
801018e0:	e0bffc17 	ldw	r2,-16(fp)
801018e4:	10001226 	beq	r2,zero,80101930 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
801018e8:	e0bffd83 	ldbu	r2,-10(fp)
801018ec:	10c03fcc 	andi	r3,r2,255
801018f0:	18c0201c 	xori	r3,r3,128
801018f4:	18ffe004 	addi	r3,r3,-128
801018f8:	e0bffdc4 	addi	r2,fp,-9
801018fc:	d8800015 	stw	r2,0(sp)
80101900:	01c00044 	movi	r7,1
80101904:	180d883a 	mov	r6,r3
80101908:	01500034 	movhi	r5,16384
8010190c:	29426004 	addi	r5,r5,2432
80101910:	01100034 	movhi	r4,16384
80101914:	21026404 	addi	r4,r4,2448
80101918:	010b4d00 	call	8010b4d0 <I2C_Read>
8010191c:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
80101920:	e0bffc17 	ldw	r2,-16(fp)
80101924:	10000226 	beq	r2,zero,80101930 <TEMP_Read+0xc0>
			FpgaTemp = Data;
80101928:	e0bffdc3 	ldbu	r2,-9(fp)
8010192c:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
80101930:	e0bffc17 	ldw	r2,-16(fp)
80101934:	10000626 	beq	r2,zero,80101950 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
80101938:	e0bffe17 	ldw	r2,-8(fp)
8010193c:	e0fffd03 	ldbu	r3,-12(fp)
80101940:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
80101944:	e0bfff17 	ldw	r2,-4(fp)
80101948:	e0fffd43 	ldbu	r3,-11(fp)
8010194c:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
80101950:	e0bffc17 	ldw	r2,-16(fp)
}
80101954:	e037883a 	mov	sp,fp
80101958:	dfc00117 	ldw	ra,4(sp)
8010195c:	df000017 	ldw	fp,0(sp)
80101960:	dec00204 	addi	sp,sp,8
80101964:	f800283a 	ret

80101968 <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
80101968:	defffb04 	addi	sp,sp,-20
8010196c:	de00012e 	bgeu	sp,et,80101974 <sense_log_temp+0xc>
80101970:	003b68fa 	trap	3
80101974:	dfc00415 	stw	ra,16(sp)
80101978:	df000315 	stw	fp,12(sp)
8010197c:	df000304 	addi	fp,sp,12
80101980:	e13ffe15 	stw	r4,-8(fp)
80101984:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
80101988:	e17fff17 	ldw	r5,-4(fp)
8010198c:	e13ffe17 	ldw	r4,-8(fp)
80101990:	01018700 	call	80101870 <TEMP_Read>
80101994:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
80101998:	e0bffd17 	ldw	r2,-12(fp)
}
8010199c:	e037883a 	mov	sp,fp
801019a0:	dfc00117 	ldw	ra,4(sp)
801019a4:	df000017 	ldw	fp,0(sp)
801019a8:	dec00204 	addi	sp,sp,8
801019ac:	f800283a 	ret

801019b0 <sense_log>:

void sense_log(void) {
801019b0:	deff0e04 	addi	sp,sp,-968
801019b4:	de00012e 	bgeu	sp,et,801019bc <sense_log+0xc>
801019b8:	003b68fa 	trap	3
801019bc:	dfc0f115 	stw	ra,964(sp)
801019c0:	df00f015 	stw	fp,960(sp)
801019c4:	dc40ef15 	stw	r17,956(sp)
801019c8:	dc00ee15 	stw	r16,952(sp)
801019cc:	df00f004 	addi	fp,sp,960
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
801019d0:	00902834 	movhi	r2,16544
801019d4:	e0bf1215 	stw	r2,-952(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
801019d8:	008ed174 	movhi	r2,15173
801019dc:	10a6e984 	addi	r2,r2,-25690
801019e0:	e0bf2615 	stw	r2,-872(fp)
801019e4:	008ea0f4 	movhi	r2,14979
801019e8:	10849bc4 	addi	r2,r2,4719
801019ec:	e0bf2715 	stw	r2,-868(fp)
801019f0:	008ed174 	movhi	r2,15173
801019f4:	10a6e984 	addi	r2,r2,-25690
801019f8:	e0bf2815 	stw	r2,-864(fp)
801019fc:	008ed174 	movhi	r2,15173
80101a00:	10a6e984 	addi	r2,r2,-25690
80101a04:	e0bf2915 	stw	r2,-860(fp)
80101a08:	008ed174 	movhi	r2,15173
80101a0c:	10a6e984 	addi	r2,r2,-25690
80101a10:	e0bf2a15 	stw	r2,-856(fp)
80101a14:	008ed174 	movhi	r2,15173
80101a18:	10a6e984 	addi	r2,r2,-25690
80101a1c:	e0bf2b15 	stw	r2,-852(fp)
80101a20:	008ed174 	movhi	r2,15173
80101a24:	10a6e984 	addi	r2,r2,-25690
80101a28:	e0bf2c15 	stw	r2,-848(fp)
80101a2c:	008ed174 	movhi	r2,15173
80101a30:	10a6e984 	addi	r2,r2,-25690
80101a34:	e0bf2d15 	stw	r2,-844(fp)
80101a38:	008ed174 	movhi	r2,15173
80101a3c:	10a6e984 	addi	r2,r2,-25690
80101a40:	e0bf2e15 	stw	r2,-840(fp)
80101a44:	008ed174 	movhi	r2,15173
80101a48:	10a6e984 	addi	r2,r2,-25690
80101a4c:	e0bf2f15 	stw	r2,-836(fp)
80101a50:	008ed174 	movhi	r2,15173
80101a54:	10a6e984 	addi	r2,r2,-25690
80101a58:	e0bf3015 	stw	r2,-832(fp)
80101a5c:	008ed174 	movhi	r2,15173
80101a60:	10a6e984 	addi	r2,r2,-25690
80101a64:	e0bf3115 	stw	r2,-828(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
80101a68:	008fd9b4 	movhi	r2,16230
80101a6c:	10999984 	addi	r2,r2,26214
80101a70:	e0bf3215 	stw	r2,-824(fp)
80101a74:	008fd9b4 	movhi	r2,16230
80101a78:	10999984 	addi	r2,r2,26214
80101a7c:	e0bf3315 	stw	r2,-820(fp)
80101a80:	00901034 	movhi	r2,16448
80101a84:	e0bf3415 	stw	r2,-816(fp)
80101a88:	008fd9b4 	movhi	r2,16230
80101a8c:	10999984 	addi	r2,r2,26214
80101a90:	e0bf3515 	stw	r2,-812(fp)
80101a94:	008ff9b4 	movhi	r2,16358
80101a98:	10999984 	addi	r2,r2,26214
80101a9c:	e0bf3615 	stw	r2,-808(fp)
80101aa0:	00900834 	movhi	r2,16416
80101aa4:	e0bf3715 	stw	r2,-804(fp)
80101aa8:	008ff9b4 	movhi	r2,16358
80101aac:	10999984 	addi	r2,r2,26214
80101ab0:	e0bf3815 	stw	r2,-800(fp)
80101ab4:	00900834 	movhi	r2,16416
80101ab8:	e0bf3915 	stw	r2,-796(fp)
80101abc:	008fe374 	movhi	r2,16269
80101ac0:	10b33344 	addi	r2,r2,-13107
80101ac4:	e0bf3a15 	stw	r2,-792(fp)
80101ac8:	008fecf4 	movhi	r2,16307
80101acc:	108cccc4 	addi	r2,r2,13107
80101ad0:	e0bf3b15 	stw	r2,-788(fp)
80101ad4:	009014f4 	movhi	r2,16467
80101ad8:	108cccc4 	addi	r2,r2,13107
80101adc:	e0bf3c15 	stw	r2,-784(fp)
80101ae0:	00900834 	movhi	r2,16416
80101ae4:	e0bf3d15 	stw	r2,-780(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
80101ae8:	00a00534 	movhi	r2,32788
80101aec:	109b8e04 	addi	r2,r2,28216
80101af0:	e0ff3e04 	addi	r3,fp,-776
80101af4:	1009883a 	mov	r4,r2
80101af8:	0080c004 	movi	r2,768
80101afc:	100d883a 	mov	r6,r2
80101b00:	200b883a 	mov	r5,r4
80101b04:	1809883a 	mov	r4,r3
80101b08:	01214640 	call	80121464 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
80101b0c:	e0bf1a04 	addi	r2,fp,-920
80101b10:	1009883a 	mov	r4,r2
80101b14:	01016840 	call	80101684 <POWER_Read>
80101b18:	e0bf1315 	stw	r2,-948(fp)
	if (bSuccess) {
80101b1c:	e0bf1317 	ldw	r2,-948(fp)
80101b20:	1000c326 	beq	r2,zero,80101e30 <sense_log+0x480>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
80101b24:	e03f1015 	stw	zero,-960(fp)
80101b28:	0000bc06 	br	80101e1c <sense_log+0x46c>
			SIG = (szVol[i] >> 29) & 0x01;
80101b2c:	e0bf1017 	ldw	r2,-960(fp)
80101b30:	1085883a 	add	r2,r2,r2
80101b34:	1085883a 	add	r2,r2,r2
80101b38:	e0ff1004 	addi	r3,fp,-960
80101b3c:	1885883a 	add	r2,r3,r2
80101b40:	10800a04 	addi	r2,r2,40
80101b44:	10800017 	ldw	r2,0(r2)
80101b48:	1004d77a 	srli	r2,r2,29
80101b4c:	1080004c 	andi	r2,r2,1
80101b50:	e0bf1415 	stw	r2,-944(fp)
			MSB = (szVol[i] >> 28) & 0x01;
80101b54:	e0bf1017 	ldw	r2,-960(fp)
80101b58:	1085883a 	add	r2,r2,r2
80101b5c:	1085883a 	add	r2,r2,r2
80101b60:	e0ff1004 	addi	r3,fp,-960
80101b64:	1885883a 	add	r2,r3,r2
80101b68:	10800a04 	addi	r2,r2,40
80101b6c:	10800017 	ldw	r2,0(r2)
80101b70:	1004d73a 	srli	r2,r2,28
80101b74:	1080004c 	andi	r2,r2,1
80101b78:	e0bf1515 	stw	r2,-940(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
80101b7c:	e0bf1017 	ldw	r2,-960(fp)
80101b80:	1085883a 	add	r2,r2,r2
80101b84:	1085883a 	add	r2,r2,r2
80101b88:	e0ff1004 	addi	r3,fp,-960
80101b8c:	1885883a 	add	r2,r3,r2
80101b90:	10800a04 	addi	r2,r2,40
80101b94:	10800017 	ldw	r2,0(r2)
80101b98:	1006d1ba 	srli	r3,r2,6
80101b9c:	00801034 	movhi	r2,64
80101ba0:	10bfffc4 	addi	r2,r2,-1
80101ba4:	1884703a 	and	r2,r3,r2
80101ba8:	e0bf1615 	stw	r2,-936(fp)
			if (MSB == 0)
80101bac:	e0bf1517 	ldw	r2,-940(fp)
80101bb0:	1000091e 	bne	r2,zero,80101bd8 <sense_log+0x228>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
80101bb4:	e13f1617 	ldw	r4,-936(fp)
80101bb8:	011fdb40 	call	8011fdb4 <__floatunsisf>
80101bbc:	1007883a 	mov	r3,r2
80101bc0:	0152a034 	movhi	r5,19072
80101bc4:	1809883a 	mov	r4,r3
80101bc8:	011f5680 	call	8011f568 <__divsf3>
80101bcc:	1007883a 	mov	r3,r2
80101bd0:	e0ff1115 	stw	r3,-956(fp)
80101bd4:	00000106 	br	80101bdc <sense_log+0x22c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
80101bd8:	e03f1115 	stw	zero,-956(fp)
			if (SIG && MSB) {
80101bdc:	e0bf1417 	ldw	r2,-944(fp)
80101be0:	10000826 	beq	r2,zero,80101c04 <sense_log+0x254>
80101be4:	e0bf1517 	ldw	r2,-940(fp)
80101be8:	10000626 	beq	r2,zero,80101c04 <sense_log+0x254>
				fVol = fRef * 0.5;
80101bec:	014fc034 	movhi	r5,16128
80101bf0:	e13f1217 	ldw	r4,-952(fp)
80101bf4:	011f9b00 	call	8011f9b0 <__mulsf3>
80101bf8:	1007883a 	mov	r3,r2
80101bfc:	e0ff1715 	stw	r3,-932(fp)
80101c00:	00008306 	br	80101e10 <sense_log+0x460>
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
#endif
			} else if (SIG && !MSB) {
80101c04:	e0bf1417 	ldw	r2,-944(fp)
80101c08:	10003a26 	beq	r2,zero,80101cf4 <sense_log+0x344>
80101c0c:	e0bf1517 	ldw	r2,-940(fp)
80101c10:	1000381e 	bne	r2,zero,80101cf4 <sense_log+0x344>
				fVol = fRef * 0.5 * fVolDrop;
80101c14:	e13f1217 	ldw	r4,-952(fp)
80101c18:	01211100 	call	80121110 <__extendsfdf2>
80101c1c:	1011883a 	mov	r8,r2
80101c20:	1813883a 	mov	r9,r3
80101c24:	000d883a 	mov	r6,zero
80101c28:	01cff834 	movhi	r7,16352
80101c2c:	4009883a 	mov	r4,r8
80101c30:	480b883a 	mov	r5,r9
80101c34:	011ff880 	call	8011ff88 <__muldf3>
80101c38:	1009883a 	mov	r4,r2
80101c3c:	180b883a 	mov	r5,r3
80101c40:	2021883a 	mov	r16,r4
80101c44:	2823883a 	mov	r17,r5
80101c48:	e13f1117 	ldw	r4,-956(fp)
80101c4c:	01211100 	call	80121110 <__extendsfdf2>
80101c50:	1009883a 	mov	r4,r2
80101c54:	180b883a 	mov	r5,r3
80101c58:	200d883a 	mov	r6,r4
80101c5c:	280f883a 	mov	r7,r5
80101c60:	8009883a 	mov	r4,r16
80101c64:	880b883a 	mov	r5,r17
80101c68:	011ff880 	call	8011ff88 <__muldf3>
80101c6c:	1009883a 	mov	r4,r2
80101c70:	180b883a 	mov	r5,r3
80101c74:	2005883a 	mov	r2,r4
80101c78:	2807883a 	mov	r3,r5
80101c7c:	1009883a 	mov	r4,r2
80101c80:	180b883a 	mov	r5,r3
80101c84:	01212280 	call	80121228 <__truncdfsf2>
80101c88:	1007883a 	mov	r3,r2
80101c8c:	e0ff1715 	stw	r3,-932(fp)
				fCurrent = fVolDrop / szRes[i];
80101c90:	e0bf1017 	ldw	r2,-960(fp)
80101c94:	1085883a 	add	r2,r2,r2
80101c98:	1085883a 	add	r2,r2,r2
80101c9c:	e0ff1004 	addi	r3,fp,-960
80101ca0:	1885883a 	add	r2,r3,r2
80101ca4:	10801604 	addi	r2,r2,88
80101ca8:	10c00017 	ldw	r3,0(r2)
80101cac:	180b883a 	mov	r5,r3
80101cb0:	e13f1117 	ldw	r4,-956(fp)
80101cb4:	011f5680 	call	8011f568 <__divsf3>
80101cb8:	1007883a 	mov	r3,r2
80101cbc:	e0ff1815 	stw	r3,-928(fp)
				fPower = szRefVol[i] * fCurrent;
80101cc0:	e0bf1017 	ldw	r2,-960(fp)
80101cc4:	1085883a 	add	r2,r2,r2
80101cc8:	1085883a 	add	r2,r2,r2
80101ccc:	e0ff1004 	addi	r3,fp,-960
80101cd0:	1885883a 	add	r2,r3,r2
80101cd4:	10802204 	addi	r2,r2,136
80101cd8:	10c00017 	ldw	r3,0(r2)
80101cdc:	e17f1817 	ldw	r5,-928(fp)
80101ce0:	1809883a 	mov	r4,r3
80101ce4:	011f9b00 	call	8011f9b0 <__mulsf3>
80101ce8:	1007883a 	mov	r3,r2
80101cec:	e0ff1915 	stw	r3,-924(fp)
80101cf0:	00004706 	br	80101e10 <sense_log+0x460>
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && MSB) {
80101cf4:	e0bf1417 	ldw	r2,-944(fp)
80101cf8:	10003a1e 	bne	r2,zero,80101de4 <sense_log+0x434>
80101cfc:	e0bf1517 	ldw	r2,-940(fp)
80101d00:	10003826 	beq	r2,zero,80101de4 <sense_log+0x434>
				fVol = fRef * 0.5 * fVolDrop;
80101d04:	e13f1217 	ldw	r4,-952(fp)
80101d08:	01211100 	call	80121110 <__extendsfdf2>
80101d0c:	1011883a 	mov	r8,r2
80101d10:	1813883a 	mov	r9,r3
80101d14:	000d883a 	mov	r6,zero
80101d18:	01cff834 	movhi	r7,16352
80101d1c:	4009883a 	mov	r4,r8
80101d20:	480b883a 	mov	r5,r9
80101d24:	011ff880 	call	8011ff88 <__muldf3>
80101d28:	1009883a 	mov	r4,r2
80101d2c:	180b883a 	mov	r5,r3
80101d30:	2021883a 	mov	r16,r4
80101d34:	2823883a 	mov	r17,r5
80101d38:	e13f1117 	ldw	r4,-956(fp)
80101d3c:	01211100 	call	80121110 <__extendsfdf2>
80101d40:	1009883a 	mov	r4,r2
80101d44:	180b883a 	mov	r5,r3
80101d48:	200d883a 	mov	r6,r4
80101d4c:	280f883a 	mov	r7,r5
80101d50:	8009883a 	mov	r4,r16
80101d54:	880b883a 	mov	r5,r17
80101d58:	011ff880 	call	8011ff88 <__muldf3>
80101d5c:	1009883a 	mov	r4,r2
80101d60:	180b883a 	mov	r5,r3
80101d64:	2005883a 	mov	r2,r4
80101d68:	2807883a 	mov	r3,r5
80101d6c:	1009883a 	mov	r4,r2
80101d70:	180b883a 	mov	r5,r3
80101d74:	01212280 	call	80121228 <__truncdfsf2>
80101d78:	1007883a 	mov	r3,r2
80101d7c:	e0ff1715 	stw	r3,-932(fp)
				fCurrent = fVolDrop / szRes[i];
80101d80:	e0bf1017 	ldw	r2,-960(fp)
80101d84:	1085883a 	add	r2,r2,r2
80101d88:	1085883a 	add	r2,r2,r2
80101d8c:	e0ff1004 	addi	r3,fp,-960
80101d90:	1885883a 	add	r2,r3,r2
80101d94:	10801604 	addi	r2,r2,88
80101d98:	10c00017 	ldw	r3,0(r2)
80101d9c:	180b883a 	mov	r5,r3
80101da0:	e13f1117 	ldw	r4,-956(fp)
80101da4:	011f5680 	call	8011f568 <__divsf3>
80101da8:	1007883a 	mov	r3,r2
80101dac:	e0ff1815 	stw	r3,-928(fp)
				fPower = szRefVol[i] * fCurrent;
80101db0:	e0bf1017 	ldw	r2,-960(fp)
80101db4:	1085883a 	add	r2,r2,r2
80101db8:	1085883a 	add	r2,r2,r2
80101dbc:	e0ff1004 	addi	r3,fp,-960
80101dc0:	1885883a 	add	r2,r3,r2
80101dc4:	10802204 	addi	r2,r2,136
80101dc8:	10c00017 	ldw	r3,0(r2)
80101dcc:	e17f1817 	ldw	r5,-928(fp)
80101dd0:	1809883a 	mov	r4,r3
80101dd4:	011f9b00 	call	8011f9b0 <__mulsf3>
80101dd8:	1007883a 	mov	r3,r2
80101ddc:	e0ff1915 	stw	r3,-924(fp)
80101de0:	00000b06 	br	80101e10 <sense_log+0x460>
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
80101de4:	e0bf1417 	ldw	r2,-944(fp)
80101de8:	1000091e 	bne	r2,zero,80101e10 <sense_log+0x460>
80101dec:	e0bf1517 	ldw	r2,-940(fp)
80101df0:	1000071e 	bne	r2,zero,80101e10 <sense_log+0x460>
				fVol = -fRef * 0.5;
80101df4:	e0bf1217 	ldw	r2,-952(fp)
80101df8:	10a0003c 	xorhi	r2,r2,32768
80101dfc:	014fc034 	movhi	r5,16128
80101e00:	1009883a 	mov	r4,r2
80101e04:	011f9b00 	call	8011f9b0 <__mulsf3>
80101e08:	1007883a 	mov	r3,r2
80101e0c:	e0ff1715 	stw	r3,-932(fp)
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
80101e10:	e0bf1017 	ldw	r2,-960(fp)
80101e14:	10800044 	addi	r2,r2,1
80101e18:	e0bf1015 	stw	r2,-960(fp)
80101e1c:	e0bf1017 	ldw	r2,-960(fp)
80101e20:	10800308 	cmpgei	r2,r2,12
80101e24:	1000021e 	bne	r2,zero,80101e30 <sense_log+0x480>
80101e28:	e0bf1317 	ldw	r2,-948(fp)
80101e2c:	103f3f1e 	bne	r2,zero,80101b2c <__reset+0xfa0e1b2c>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
80101e30:	0001883a 	nop
80101e34:	e6fffe04 	addi	sp,fp,-8
80101e38:	dfc00317 	ldw	ra,12(sp)
80101e3c:	df000217 	ldw	fp,8(sp)
80101e40:	dc400117 	ldw	r17,4(sp)
80101e44:	dc000017 	ldw	r16,0(sp)
80101e48:	dec00404 	addi	sp,sp,16
80101e4c:	f800283a 	ret

80101e50 <bSdmaInitM1Dma>:
alt_msgdma_dev *pxDmaM1Dev = NULL;
alt_msgdma_dev *pxDmaM2Dev = NULL;
//! [data memory public global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
80101e50:	defffb04 	addi	sp,sp,-20
80101e54:	de00012e 	bgeu	sp,et,80101e5c <bSdmaInitM1Dma+0xc>
80101e58:	003b68fa 	trap	3
80101e5c:	dfc00415 	stw	ra,16(sp)
80101e60:	df000315 	stw	fp,12(sp)
80101e64:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
80101e68:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
80101e6c:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
80101e70:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
80101e74:	01200534 	movhi	r4,32788
80101e78:	211c4e04 	addi	r4,r4,28984
80101e7c:	01451900 	call	80145190 <alt_msgdma_open>
80101e80:	d0a03815 	stw	r2,-32544(gp)

	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
80101e84:	d0a03817 	ldw	r2,-32544(gp)
80101e88:	10001a26 	beq	r2,zero,80101ef4 <bSdmaInitM1Dma+0xa4>
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
80101e8c:	d0a03817 	ldw	r2,-32544(gp)
80101e90:	10800317 	ldw	r2,12(r2)
80101e94:	10800104 	addi	r2,r2,4
80101e98:	00c00084 	movi	r3,2
80101e9c:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
80101ea0:	00000b06 	br	80101ed0 <bSdmaInitM1Dma+0x80>
			usleep(1);
80101ea4:	01000044 	movi	r4,1
80101ea8:	01330f80 	call	801330f8 <usleep>
			usiCounter++;
80101eac:	e0bfff0b 	ldhu	r2,-4(fp)
80101eb0:	10800044 	addi	r2,r2,1
80101eb4:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
80101eb8:	e0bfff0b 	ldhu	r2,-4(fp)
80101ebc:	1084e230 	cmpltui	r2,r2,5000
80101ec0:	1000031e 	bne	r2,zero,80101ed0 <bSdmaInitM1Dma+0x80>
				bFailDispatcher = TRUE;
80101ec4:	00800044 	movi	r2,1
80101ec8:	e0bffe15 	stw	r2,-8(fp)
				break;
80101ecc:	00000506 	br	80101ee4 <bSdmaInitM1Dma+0x94>
	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
80101ed0:	d0a03817 	ldw	r2,-32544(gp)
80101ed4:	10800317 	ldw	r2,12(r2)
80101ed8:	10800037 	ldwio	r2,0(r2)
80101edc:	1080100c 	andi	r2,r2,64
80101ee0:	103ff01e 	bne	r2,zero,80101ea4 <__reset+0xfa0e1ea4>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
80101ee4:	e0bffe17 	ldw	r2,-8(fp)
80101ee8:	1000021e 	bne	r2,zero,80101ef4 <bSdmaInitM1Dma+0xa4>
			bStatus = TRUE;
80101eec:	00800044 	movi	r2,1
80101ef0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80101ef4:	e0bffd17 	ldw	r2,-12(fp)
}
80101ef8:	e037883a 	mov	sp,fp
80101efc:	dfc00117 	ldw	ra,4(sp)
80101f00:	df000017 	ldw	fp,0(sp)
80101f04:	dec00204 	addi	sp,sp,8
80101f08:	f800283a 	ret

80101f0c <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
80101f0c:	defffb04 	addi	sp,sp,-20
80101f10:	de00012e 	bgeu	sp,et,80101f18 <bSdmaInitM2Dma+0xc>
80101f14:	003b68fa 	trap	3
80101f18:	dfc00415 	stw	ra,16(sp)
80101f1c:	df000315 	stw	fp,12(sp)
80101f20:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
80101f24:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
80101f28:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
80101f2c:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
80101f30:	01200534 	movhi	r4,32788
80101f34:	211c5304 	addi	r4,r4,29004
80101f38:	01451900 	call	80145190 <alt_msgdma_open>
80101f3c:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
80101f40:	d0a03917 	ldw	r2,-32540(gp)
80101f44:	1000021e 	bne	r2,zero,80101f50 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
80101f48:	e03ffd15 	stw	zero,-12(fp)
80101f4c:	00001a06 	br	80101fb8 <bSdmaInitM2Dma+0xac>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
80101f50:	d0a03917 	ldw	r2,-32540(gp)
80101f54:	10800317 	ldw	r2,12(r2)
80101f58:	10800104 	addi	r2,r2,4
80101f5c:	00c00084 	movi	r3,2
80101f60:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
80101f64:	00000b06 	br	80101f94 <bSdmaInitM2Dma+0x88>
			usleep(1);
80101f68:	01000044 	movi	r4,1
80101f6c:	01330f80 	call	801330f8 <usleep>
			usiCounter++;
80101f70:	e0bfff0b 	ldhu	r2,-4(fp)
80101f74:	10800044 	addi	r2,r2,1
80101f78:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
80101f7c:	e0bfff0b 	ldhu	r2,-4(fp)
80101f80:	1084e230 	cmpltui	r2,r2,5000
80101f84:	1000031e 	bne	r2,zero,80101f94 <bSdmaInitM2Dma+0x88>
				bFailDispatcher = TRUE;
80101f88:	00800044 	movi	r2,1
80101f8c:	e0bffe15 	stw	r2,-8(fp)
				break;
80101f90:	00000506 	br	80101fa8 <bSdmaInitM2Dma+0x9c>
		bStatus = FALSE;
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
80101f94:	d0a03917 	ldw	r2,-32540(gp)
80101f98:	10800317 	ldw	r2,12(r2)
80101f9c:	10800037 	ldwio	r2,0(r2)
80101fa0:	1080100c 	andi	r2,r2,64
80101fa4:	103ff01e 	bne	r2,zero,80101f68 <__reset+0xfa0e1f68>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
80101fa8:	e0bffe17 	ldw	r2,-8(fp)
80101fac:	1000021e 	bne	r2,zero,80101fb8 <bSdmaInitM2Dma+0xac>
			bStatus = TRUE;
80101fb0:	00800044 	movi	r2,1
80101fb4:	e0bffd15 	stw	r2,-12(fp)
	}
	return bStatus;
80101fb8:	e0bffd17 	ldw	r2,-12(fp)
}
80101fbc:	e037883a 	mov	sp,fp
80101fc0:	dfc00117 	ldw	ra,4(sp)
80101fc4:	df000017 	ldw	fp,0(sp)
80101fc8:	dec00204 	addi	sp,sp,8
80101fcc:	f800283a 	ret

80101fd0 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
80101fd0:	deffe804 	addi	sp,sp,-96
80101fd4:	de00012e 	bgeu	sp,et,80101fdc <bSdmaDmaM1Transfer+0xc>
80101fd8:	003b68fa 	trap	3
80101fdc:	dfc01715 	stw	ra,92(sp)
80101fe0:	df001615 	stw	fp,88(sp)
80101fe4:	dc001515 	stw	r16,84(sp)
80101fe8:	df001604 	addi	fp,sp,88
80101fec:	e13ffb15 	stw	r4,-20(fp)
80101ff0:	2809883a 	mov	r4,r5
80101ff4:	3007883a 	mov	r3,r6
80101ff8:	3805883a 	mov	r2,r7
80101ffc:	e13ffc0d 	sth	r4,-16(fp)
80102000:	e0fffd05 	stb	r3,-12(fp)
80102004:	e0bffe05 	stb	r2,-8(fp)
80102008:	defff004 	addi	sp,sp,-64
8010200c:	d8800904 	addi	r2,sp,36
80102010:	108007c4 	addi	r2,r2,31
80102014:	1004d17a 	srli	r2,r2,5
80102018:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
8010201c:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
80102020:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
80102024:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
80102028:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
8010202c:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;

	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
80102030:	00800044 	movi	r2,1
80102034:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
80102038:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
8010203c:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
80102040:	e0bffe03 	ldbu	r2,-8(fp)
80102044:	10c00228 	cmpgeui	r3,r2,8
80102048:	1800c41e 	bne	r3,zero,8010235c <bSdmaDmaM1Transfer+0x38c>
8010204c:	100690ba 	slli	r3,r2,2
80102050:	00a00434 	movhi	r2,32784
80102054:	10881904 	addi	r2,r2,8292
80102058:	1885883a 	add	r2,r3,r2
8010205c:	10800017 	ldw	r2,0(r2)
80102060:	1000683a 	jmp	r2
80102064:	80102084 	addi	zero,r16,16514
80102068:	801020d8 	cmpnei	zero,r16,16515
8010206c:	80102134 	orhi	zero,r16,16516
80102070:	80102190 	cmplti	zero,r16,16518
80102074:	801021ec 	andhi	zero,r16,16519
80102078:	80102248 	cmpgei	zero,r16,16521
8010207c:	801022a4 	muli	zero,r16,16522
80102080:	80102300 	call	88010230 <__reset+0x1ff0230>
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
80102084:	e0bffd03 	ldbu	r2,-12(fp)
80102088:	10000826 	beq	r2,zero,801020ac <bSdmaDmaM1Transfer+0xdc>
8010208c:	10800060 	cmpeqi	r2,r2,1
80102090:	10000d26 	beq	r2,zero,801020c8 <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
80102094:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
80102098:	00800044 	movi	r2,1
8010209c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
801020a0:	0105b1c0 	call	80105b1c <bFeebGetCh1RightBufferEmpty>
801020a4:	e0bff615 	stw	r2,-40(fp)
			break;
801020a8:	00000a06 	br	801020d4 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
801020ac:	00800074 	movhi	r2,1
801020b0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
801020b4:	00800044 	movi	r2,1
801020b8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
801020bc:	0105a880 	call	80105a88 <bFeebGetCh1LeftBufferEmpty>
801020c0:	e0bff615 	stw	r2,-40(fp)
			break;
801020c4:	00000306 	br	801020d4 <bSdmaDmaM1Transfer+0x104>
		default:
			bChannelFlag = FALSE;
801020c8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
801020cc:	e03ff615 	stw	zero,-40(fp)
			break;
801020d0:	0001883a 	nop
		}
		break;
801020d4:	0000a306 	br	80102364 <bSdmaDmaM1Transfer+0x394>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
801020d8:	e0bffd03 	ldbu	r2,-12(fp)
801020dc:	10000926 	beq	r2,zero,80102104 <bSdmaDmaM1Transfer+0x134>
801020e0:	10800060 	cmpeqi	r2,r2,1
801020e4:	10000f26 	beq	r2,zero,80102124 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
801020e8:	00880004 	movi	r2,8192
801020ec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
801020f0:	00800044 	movi	r2,1
801020f4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
801020f8:	0105c440 	call	80105c44 <bFeebGetCh2RightBufferEmpty>
801020fc:	e0bff615 	stw	r2,-40(fp)
			break;
80102100:	00000b06 	br	80102130 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
80102104:	00800074 	movhi	r2,1
80102108:	10880004 	addi	r2,r2,8192
8010210c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
80102110:	00800044 	movi	r2,1
80102114:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
80102118:	0105bb00 	call	80105bb0 <bFeebGetCh2LeftBufferEmpty>
8010211c:	e0bff615 	stw	r2,-40(fp)
			break;
80102120:	00000306 	br	80102130 <bSdmaDmaM1Transfer+0x160>
		default:
			bChannelFlag = FALSE;
80102124:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
80102128:	e03ff615 	stw	zero,-40(fp)
			break;
8010212c:	0001883a 	nop
		}
		break;
80102130:	00008c06 	br	80102364 <bSdmaDmaM1Transfer+0x394>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
80102134:	e0bffd03 	ldbu	r2,-12(fp)
80102138:	10000926 	beq	r2,zero,80102160 <bSdmaDmaM1Transfer+0x190>
8010213c:	10800060 	cmpeqi	r2,r2,1
80102140:	10000f26 	beq	r2,zero,80102180 <bSdmaDmaM1Transfer+0x1b0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
80102144:	00900004 	movi	r2,16384
80102148:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
8010214c:	00800044 	movi	r2,1
80102150:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh3RightBufferEmpty();
80102154:	0105d6c0 	call	80105d6c <bFeebGetCh3RightBufferEmpty>
80102158:	e0bff615 	stw	r2,-40(fp)
			break;
8010215c:	00000b06 	br	8010218c <bSdmaDmaM1Transfer+0x1bc>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
80102160:	00800074 	movhi	r2,1
80102164:	10900004 	addi	r2,r2,16384
80102168:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
8010216c:	00800044 	movi	r2,1
80102170:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh3LeftBufferEmpty();
80102174:	0105cd80 	call	80105cd8 <bFeebGetCh3LeftBufferEmpty>
80102178:	e0bff615 	stw	r2,-40(fp)
			break;
8010217c:	00000306 	br	8010218c <bSdmaDmaM1Transfer+0x1bc>
		default:
			bChannelFlag = FALSE;
80102180:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
80102184:	e03ff615 	stw	zero,-40(fp)
			break;
80102188:	0001883a 	nop
		}
		break;
8010218c:	00007506 	br	80102364 <bSdmaDmaM1Transfer+0x394>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
80102190:	e0bffd03 	ldbu	r2,-12(fp)
80102194:	10000926 	beq	r2,zero,801021bc <bSdmaDmaM1Transfer+0x1ec>
80102198:	10800060 	cmpeqi	r2,r2,1
8010219c:	10000f26 	beq	r2,zero,801021dc <bSdmaDmaM1Transfer+0x20c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
801021a0:	00980004 	movi	r2,24576
801021a4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
801021a8:	00800044 	movi	r2,1
801021ac:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh4RightBufferEmpty();
801021b0:	0105e900 	call	80105e90 <bFeebGetCh4RightBufferEmpty>
801021b4:	e0bff615 	stw	r2,-40(fp)
			break;
801021b8:	00000b06 	br	801021e8 <bSdmaDmaM1Transfer+0x218>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
801021bc:	00800074 	movhi	r2,1
801021c0:	10980004 	addi	r2,r2,24576
801021c4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
801021c8:	00800044 	movi	r2,1
801021cc:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh4LeftBufferEmpty();
801021d0:	0105e000 	call	80105e00 <bFeebGetCh4LeftBufferEmpty>
801021d4:	e0bff615 	stw	r2,-40(fp)
			break;
801021d8:	00000306 	br	801021e8 <bSdmaDmaM1Transfer+0x218>
		default:
			bChannelFlag = FALSE;
801021dc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
801021e0:	e03ff615 	stw	zero,-40(fp)
			break;
801021e4:	0001883a 	nop
		}
		break;
801021e8:	00005e06 	br	80102364 <bSdmaDmaM1Transfer+0x394>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
801021ec:	e0bffd03 	ldbu	r2,-12(fp)
801021f0:	10000926 	beq	r2,zero,80102218 <bSdmaDmaM1Transfer+0x248>
801021f4:	10800060 	cmpeqi	r2,r2,1
801021f8:	10000f26 	beq	r2,zero,80102238 <bSdmaDmaM1Transfer+0x268>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
801021fc:	00a00014 	movui	r2,32768
80102200:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
80102204:	00800044 	movi	r2,1
80102208:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh5RightBufferEmpty();
8010220c:	0105fb40 	call	80105fb4 <bFeebGetCh5RightBufferEmpty>
80102210:	e0bff615 	stw	r2,-40(fp)
			break;
80102214:	00000b06 	br	80102244 <bSdmaDmaM1Transfer+0x274>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
80102218:	008000b4 	movhi	r2,2
8010221c:	10a00004 	addi	r2,r2,-32768
80102220:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
80102224:	00800044 	movi	r2,1
80102228:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh5LeftBufferEmpty();
8010222c:	0105f200 	call	80105f20 <bFeebGetCh5LeftBufferEmpty>
80102230:	e0bff615 	stw	r2,-40(fp)
			break;
80102234:	00000306 	br	80102244 <bSdmaDmaM1Transfer+0x274>
		default:
			bChannelFlag = FALSE;
80102238:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
8010223c:	e03ff615 	stw	zero,-40(fp)
			break;
80102240:	0001883a 	nop
		}
		break;
80102244:	00004706 	br	80102364 <bSdmaDmaM1Transfer+0x394>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
80102248:	e0bffd03 	ldbu	r2,-12(fp)
8010224c:	10000926 	beq	r2,zero,80102274 <bSdmaDmaM1Transfer+0x2a4>
80102250:	10800060 	cmpeqi	r2,r2,1
80102254:	10000f26 	beq	r2,zero,80102294 <bSdmaDmaM1Transfer+0x2c4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
80102258:	00a80014 	movui	r2,40960
8010225c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
80102260:	00800044 	movi	r2,1
80102264:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh6RightBufferEmpty();
80102268:	01060dc0 	call	801060dc <bFeebGetCh6RightBufferEmpty>
8010226c:	e0bff615 	stw	r2,-40(fp)
			break;
80102270:	00000b06 	br	801022a0 <bSdmaDmaM1Transfer+0x2d0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
80102274:	008000b4 	movhi	r2,2
80102278:	10a80004 	addi	r2,r2,-24576
8010227c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
80102280:	00800044 	movi	r2,1
80102284:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh6LeftBufferEmpty();
80102288:	01060480 	call	80106048 <bFeebGetCh6LeftBufferEmpty>
8010228c:	e0bff615 	stw	r2,-40(fp)
			break;
80102290:	00000306 	br	801022a0 <bSdmaDmaM1Transfer+0x2d0>
		default:
			bChannelFlag = FALSE;
80102294:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
80102298:	e03ff615 	stw	zero,-40(fp)
			break;
8010229c:	0001883a 	nop
		}
		break;
801022a0:	00003006 	br	80102364 <bSdmaDmaM1Transfer+0x394>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
801022a4:	e0bffd03 	ldbu	r2,-12(fp)
801022a8:	10000926 	beq	r2,zero,801022d0 <bSdmaDmaM1Transfer+0x300>
801022ac:	10800060 	cmpeqi	r2,r2,1
801022b0:	10000f26 	beq	r2,zero,801022f0 <bSdmaDmaM1Transfer+0x320>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
801022b4:	00b00014 	movui	r2,49152
801022b8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
801022bc:	00800044 	movi	r2,1
801022c0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh7RightBufferEmpty();
801022c4:	01062040 	call	80106204 <bFeebGetCh7RightBufferEmpty>
801022c8:	e0bff615 	stw	r2,-40(fp)
			break;
801022cc:	00000b06 	br	801022fc <bSdmaDmaM1Transfer+0x32c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
801022d0:	008000b4 	movhi	r2,2
801022d4:	10b00004 	addi	r2,r2,-16384
801022d8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
801022dc:	00800044 	movi	r2,1
801022e0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh7LeftBufferEmpty();
801022e4:	01061700 	call	80106170 <bFeebGetCh7LeftBufferEmpty>
801022e8:	e0bff615 	stw	r2,-40(fp)
			break;
801022ec:	00000306 	br	801022fc <bSdmaDmaM1Transfer+0x32c>
		default:
			bChannelFlag = FALSE;
801022f0:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
801022f4:	e03ff615 	stw	zero,-40(fp)
			break;
801022f8:	0001883a 	nop
		}
		break;
801022fc:	00001906 	br	80102364 <bSdmaDmaM1Transfer+0x394>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
80102300:	e0bffd03 	ldbu	r2,-12(fp)
80102304:	10000926 	beq	r2,zero,8010232c <bSdmaDmaM1Transfer+0x35c>
80102308:	10800060 	cmpeqi	r2,r2,1
8010230c:	10000f26 	beq	r2,zero,8010234c <bSdmaDmaM1Transfer+0x37c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
80102310:	00b80014 	movui	r2,57344
80102314:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
80102318:	00800044 	movi	r2,1
8010231c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh8RightBufferEmpty();
80102320:	01063280 	call	80106328 <bFeebGetCh8RightBufferEmpty>
80102324:	e0bff615 	stw	r2,-40(fp)
			break;
80102328:	00000b06 	br	80102358 <bSdmaDmaM1Transfer+0x388>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
8010232c:	008000b4 	movhi	r2,2
80102330:	10b80004 	addi	r2,r2,-8192
80102334:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
80102338:	00800044 	movi	r2,1
8010233c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh8LeftBufferEmpty();
80102340:	01062980 	call	80106298 <bFeebGetCh8LeftBufferEmpty>
80102344:	e0bff615 	stw	r2,-40(fp)
			break;
80102348:	00000306 	br	80102358 <bSdmaDmaM1Transfer+0x388>
		default:
			bChannelFlag = FALSE;
8010234c:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
80102350:	e03ff615 	stw	zero,-40(fp)
			break;
80102354:	0001883a 	nop
		}
		break;
80102358:	00000206 	br	80102364 <bSdmaDmaM1Transfer+0x394>
	default:
		bChannelFlag = FALSE;
8010235c:	e03ff715 	stw	zero,-36(fp)
		break;
80102360:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW	+ (alt_u32) uliDdrInitialAddr;
80102364:	e0bffb17 	ldw	r2,-20(fp)
80102368:	e0bff815 	stw	r2,-32(fp)
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
8010236c:	e03ff915 	stw	zero,-28(fp)

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
80102370:	e0bff717 	ldw	r2,-36(fp)
80102374:	10003026 	beq	r2,zero,80102438 <bSdmaDmaM1Transfer+0x468>
80102378:	e0bff617 	ldw	r2,-40(fp)
8010237c:	10002e26 	beq	r2,zero,80102438 <bSdmaDmaM1Transfer+0x468>
80102380:	e0bffc0b 	ldhu	r2,-16(fp)
80102384:	10800468 	cmpgeui	r2,r2,17
80102388:	10002b1e 	bne	r2,zero,80102438 <bSdmaDmaM1Transfer+0x468>

		if (pxDmaM1Dev != NULL) {
8010238c:	d0a03817 	ldw	r2,-32544(gp)
80102390:	10002926 	beq	r2,zero,80102438 <bSdmaDmaM1Transfer+0x468>
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
80102394:	00000206 	br	801023a0 <bSdmaDmaM1Transfer+0x3d0>
				alt_busy_sleep(1); /* delay 1us */
80102398:	01000044 	movi	r4,1
8010239c:	01318f00 	call	801318f0 <alt_busy_sleep>

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {

		if (pxDmaM1Dev != NULL) {
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
801023a0:	d0a03817 	ldw	r2,-32544(gp)
801023a4:	10800317 	ldw	r2,12(r2)
801023a8:	10800037 	ldwio	r2,0(r2)
801023ac:	1080010c 	andi	r2,r2,4
801023b0:	103ff91e 	bne	r2,zero,80102398 <__reset+0xfa0e2398>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if (0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
801023b4:	d2203817 	ldw	r8,-32544(gp)
801023b8:	e1bff817 	ldw	r6,-32(fp)
801023bc:	e1fff417 	ldw	r7,-48(fp)
801023c0:	e0bffc0b 	ldhu	r2,-16(fp)
801023c4:	10802224 	muli	r2,r2,136
801023c8:	e0fff917 	ldw	r3,-28(fp)
801023cc:	e13ff517 	ldw	r4,-44(fp)
801023d0:	01400044 	movi	r5,1
801023d4:	d9400815 	stw	r5,32(sp)
801023d8:	01400044 	movi	r5,1
801023dc:	d9400715 	stw	r5,28(sp)
801023e0:	01400044 	movi	r5,1
801023e4:	d9400615 	stw	r5,24(sp)
801023e8:	01400044 	movi	r5,1
801023ec:	d9400515 	stw	r5,20(sp)
801023f0:	01400044 	movi	r5,1
801023f4:	d9400415 	stw	r5,16(sp)
801023f8:	d9000315 	stw	r4,12(sp)
801023fc:	d8c00215 	stw	r3,8(sp)
80102400:	e0fffa17 	ldw	r3,-24(fp)
80102404:	d8c00115 	stw	r3,4(sp)
80102408:	d8800015 	stw	r2,0(sp)
8010240c:	800b883a 	mov	r5,r16
80102410:	4009883a 	mov	r4,r8
80102414:	010c4e80 	call	8010c4e8 <iMsgdmaConstructExtendedMmToMmDescriptor>
80102418:	1000071e 	bne	r2,zero,80102438 <bSdmaDmaM1Transfer+0x468>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)	) {
				/* Success = 0 */
				if (0 == iMsgdmaExtendedDescriptorAsyncTransfer(pxDmaM1Dev,	&xDmaExtendedDescriptor)) {
8010241c:	d0a03817 	ldw	r2,-32544(gp)
80102420:	800b883a 	mov	r5,r16
80102424:	1009883a 	mov	r4,r2
80102428:	010c5a80 	call	8010c5a8 <iMsgdmaExtendedDescriptorAsyncTransfer>
8010242c:	1000021e 	bne	r2,zero,80102438 <bSdmaDmaM1Transfer+0x468>
					bStatus = TRUE;
80102430:	00800044 	movi	r2,1
80102434:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
80102438:	e0bff317 	ldw	r2,-52(fp)
}
8010243c:	e6ffff04 	addi	sp,fp,-4
80102440:	dfc00217 	ldw	ra,8(sp)
80102444:	df000117 	ldw	fp,4(sp)
80102448:	dc000017 	ldw	r16,0(sp)
8010244c:	dec00304 	addi	sp,sp,12
80102450:	f800283a 	ret

80102454 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
80102454:	deffe804 	addi	sp,sp,-96
80102458:	de00012e 	bgeu	sp,et,80102460 <bSdmaDmaM2Transfer+0xc>
8010245c:	003b68fa 	trap	3
80102460:	dfc01715 	stw	ra,92(sp)
80102464:	df001615 	stw	fp,88(sp)
80102468:	dc001515 	stw	r16,84(sp)
8010246c:	df001604 	addi	fp,sp,88
80102470:	e13ffb15 	stw	r4,-20(fp)
80102474:	2809883a 	mov	r4,r5
80102478:	3007883a 	mov	r3,r6
8010247c:	3805883a 	mov	r2,r7
80102480:	e13ffc0d 	sth	r4,-16(fp)
80102484:	e0fffd05 	stb	r3,-12(fp)
80102488:	e0bffe05 	stb	r2,-8(fp)
8010248c:	defff004 	addi	sp,sp,-64
80102490:	d8800904 	addi	r2,sp,36
80102494:	108007c4 	addi	r2,r2,31
80102498:	1004d17a 	srli	r2,r2,5
8010249c:	1020917a 	slli	r16,r2,5
	bool bStatus;

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
801024a0:	e03ff415 	stw	zero,-48(fp)
	alt_u32 uliDestAddrHigh = 0;
801024a4:	e03ff515 	stw	zero,-44(fp)

	alt_u32 uliSrcAddrLow = 0;
801024a8:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
801024ac:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
801024b0:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;


	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
801024b4:	00800044 	movi	r2,1
801024b8:	e0bff715 	stw	r2,-36(fp)
	bStatus = FALSE;
801024bc:	e03ff315 	stw	zero,-52(fp)
	bBufferEmptyFlag = FALSE;
801024c0:	e03ff615 	stw	zero,-40(fp)
	switch (ucChBufferId) {
801024c4:	e0bffe03 	ldbu	r2,-8(fp)
801024c8:	10c00228 	cmpgeui	r3,r2,8
801024cc:	1800c41e 	bne	r3,zero,801027e0 <bSdmaDmaM2Transfer+0x38c>
801024d0:	100690ba 	slli	r3,r2,2
801024d4:	00a00434 	movhi	r2,32784
801024d8:	10893a04 	addi	r2,r2,9448
801024dc:	1885883a 	add	r2,r3,r2
801024e0:	10800017 	ldw	r2,0(r2)
801024e4:	1000683a 	jmp	r2
801024e8:	80102508 	cmpgei	zero,r16,16532
801024ec:	8010255c 	xori	zero,r16,16533
801024f0:	801025b8 	rdprs	zero,r16,16534
801024f4:	80102614 	ori	zero,r16,16536
801024f8:	80102670 	cmpltui	zero,r16,16537
801024fc:	801026cc 	andi	zero,r16,16539
80102500:	80102728 	cmpgeui	zero,r16,16540
80102504:	80102784 	addi	zero,r16,16542
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
80102508:	e0bffd03 	ldbu	r2,-12(fp)
8010250c:	10000826 	beq	r2,zero,80102530 <bSdmaDmaM2Transfer+0xdc>
80102510:	10800060 	cmpeqi	r2,r2,1
80102514:	10000d26 	beq	r2,zero,8010254c <bSdmaDmaM2Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
80102518:	e03ff415 	stw	zero,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
8010251c:	00800044 	movi	r2,1
80102520:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
80102524:	0105b1c0 	call	80105b1c <bFeebGetCh1RightBufferEmpty>
80102528:	e0bff615 	stw	r2,-40(fp)
			break;
8010252c:	00000a06 	br	80102558 <bSdmaDmaM2Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
80102530:	00800074 	movhi	r2,1
80102534:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
80102538:	00800044 	movi	r2,1
8010253c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
80102540:	0105a880 	call	80105a88 <bFeebGetCh1LeftBufferEmpty>
80102544:	e0bff615 	stw	r2,-40(fp)
			break;
80102548:	00000306 	br	80102558 <bSdmaDmaM2Transfer+0x104>
		default:
			bChannelFlag = FALSE;
8010254c:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
80102550:	e03ff615 	stw	zero,-40(fp)
			break;
80102554:	0001883a 	nop
		}
		break;
80102558:	0000a306 	br	801027e8 <bSdmaDmaM2Transfer+0x394>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
8010255c:	e0bffd03 	ldbu	r2,-12(fp)
80102560:	10000926 	beq	r2,zero,80102588 <bSdmaDmaM2Transfer+0x134>
80102564:	10800060 	cmpeqi	r2,r2,1
80102568:	10000f26 	beq	r2,zero,801025a8 <bSdmaDmaM2Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
8010256c:	00880004 	movi	r2,8192
80102570:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
80102574:	00800044 	movi	r2,1
80102578:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
8010257c:	0105c440 	call	80105c44 <bFeebGetCh2RightBufferEmpty>
80102580:	e0bff615 	stw	r2,-40(fp)
			break;
80102584:	00000b06 	br	801025b4 <bSdmaDmaM2Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
80102588:	00800074 	movhi	r2,1
8010258c:	10880004 	addi	r2,r2,8192
80102590:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
80102594:	00800044 	movi	r2,1
80102598:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
8010259c:	0105bb00 	call	80105bb0 <bFeebGetCh2LeftBufferEmpty>
801025a0:	e0bff615 	stw	r2,-40(fp)
			break;
801025a4:	00000306 	br	801025b4 <bSdmaDmaM2Transfer+0x160>
		default:
			bChannelFlag = FALSE;
801025a8:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
801025ac:	e03ff615 	stw	zero,-40(fp)
			break;
801025b0:	0001883a 	nop
		}
		break;
801025b4:	00008c06 	br	801027e8 <bSdmaDmaM2Transfer+0x394>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
801025b8:	e0bffd03 	ldbu	r2,-12(fp)
801025bc:	10000926 	beq	r2,zero,801025e4 <bSdmaDmaM2Transfer+0x190>
801025c0:	10800060 	cmpeqi	r2,r2,1
801025c4:	10000f26 	beq	r2,zero,80102604 <bSdmaDmaM2Transfer+0x1b0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
801025c8:	00900004 	movi	r2,16384
801025cc:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
801025d0:	00800044 	movi	r2,1
801025d4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh3RightBufferEmpty();
801025d8:	0105d6c0 	call	80105d6c <bFeebGetCh3RightBufferEmpty>
801025dc:	e0bff615 	stw	r2,-40(fp)
			break;
801025e0:	00000b06 	br	80102610 <bSdmaDmaM2Transfer+0x1bc>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
801025e4:	00800074 	movhi	r2,1
801025e8:	10900004 	addi	r2,r2,16384
801025ec:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
801025f0:	00800044 	movi	r2,1
801025f4:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh3LeftBufferEmpty();
801025f8:	0105cd80 	call	80105cd8 <bFeebGetCh3LeftBufferEmpty>
801025fc:	e0bff615 	stw	r2,-40(fp)
			break;
80102600:	00000306 	br	80102610 <bSdmaDmaM2Transfer+0x1bc>
		default:
			bChannelFlag = FALSE;
80102604:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
80102608:	e03ff615 	stw	zero,-40(fp)
			break;
8010260c:	0001883a 	nop
		}
		break;
80102610:	00007506 	br	801027e8 <bSdmaDmaM2Transfer+0x394>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
80102614:	e0bffd03 	ldbu	r2,-12(fp)
80102618:	10000926 	beq	r2,zero,80102640 <bSdmaDmaM2Transfer+0x1ec>
8010261c:	10800060 	cmpeqi	r2,r2,1
80102620:	10000f26 	beq	r2,zero,80102660 <bSdmaDmaM2Transfer+0x20c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
80102624:	00980004 	movi	r2,24576
80102628:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
8010262c:	00800044 	movi	r2,1
80102630:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh4RightBufferEmpty();
80102634:	0105e900 	call	80105e90 <bFeebGetCh4RightBufferEmpty>
80102638:	e0bff615 	stw	r2,-40(fp)
			break;
8010263c:	00000b06 	br	8010266c <bSdmaDmaM2Transfer+0x218>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
80102640:	00800074 	movhi	r2,1
80102644:	10980004 	addi	r2,r2,24576
80102648:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
8010264c:	00800044 	movi	r2,1
80102650:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh4LeftBufferEmpty();
80102654:	0105e000 	call	80105e00 <bFeebGetCh4LeftBufferEmpty>
80102658:	e0bff615 	stw	r2,-40(fp)
			break;
8010265c:	00000306 	br	8010266c <bSdmaDmaM2Transfer+0x218>
		default:
			bChannelFlag = FALSE;
80102660:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
80102664:	e03ff615 	stw	zero,-40(fp)
			break;
80102668:	0001883a 	nop
		}
		break;
8010266c:	00005e06 	br	801027e8 <bSdmaDmaM2Transfer+0x394>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
80102670:	e0bffd03 	ldbu	r2,-12(fp)
80102674:	10000926 	beq	r2,zero,8010269c <bSdmaDmaM2Transfer+0x248>
80102678:	10800060 	cmpeqi	r2,r2,1
8010267c:	10000f26 	beq	r2,zero,801026bc <bSdmaDmaM2Transfer+0x268>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
80102680:	00a00014 	movui	r2,32768
80102684:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
80102688:	00800044 	movi	r2,1
8010268c:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh5RightBufferEmpty();
80102690:	0105fb40 	call	80105fb4 <bFeebGetCh5RightBufferEmpty>
80102694:	e0bff615 	stw	r2,-40(fp)
			break;
80102698:	00000b06 	br	801026c8 <bSdmaDmaM2Transfer+0x274>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
8010269c:	008000b4 	movhi	r2,2
801026a0:	10a00004 	addi	r2,r2,-32768
801026a4:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
801026a8:	00800044 	movi	r2,1
801026ac:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh5LeftBufferEmpty();
801026b0:	0105f200 	call	80105f20 <bFeebGetCh5LeftBufferEmpty>
801026b4:	e0bff615 	stw	r2,-40(fp)
			break;
801026b8:	00000306 	br	801026c8 <bSdmaDmaM2Transfer+0x274>
		default:
			bChannelFlag = FALSE;
801026bc:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
801026c0:	e03ff615 	stw	zero,-40(fp)
			break;
801026c4:	0001883a 	nop
		}
		break;
801026c8:	00004706 	br	801027e8 <bSdmaDmaM2Transfer+0x394>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
801026cc:	e0bffd03 	ldbu	r2,-12(fp)
801026d0:	10000926 	beq	r2,zero,801026f8 <bSdmaDmaM2Transfer+0x2a4>
801026d4:	10800060 	cmpeqi	r2,r2,1
801026d8:	10000f26 	beq	r2,zero,80102718 <bSdmaDmaM2Transfer+0x2c4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
801026dc:	00a80014 	movui	r2,40960
801026e0:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
801026e4:	00800044 	movi	r2,1
801026e8:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh6RightBufferEmpty();
801026ec:	01060dc0 	call	801060dc <bFeebGetCh6RightBufferEmpty>
801026f0:	e0bff615 	stw	r2,-40(fp)
			break;
801026f4:	00000b06 	br	80102724 <bSdmaDmaM2Transfer+0x2d0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
801026f8:	008000b4 	movhi	r2,2
801026fc:	10a80004 	addi	r2,r2,-24576
80102700:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
80102704:	00800044 	movi	r2,1
80102708:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh6LeftBufferEmpty();
8010270c:	01060480 	call	80106048 <bFeebGetCh6LeftBufferEmpty>
80102710:	e0bff615 	stw	r2,-40(fp)
			break;
80102714:	00000306 	br	80102724 <bSdmaDmaM2Transfer+0x2d0>
		default:
			bChannelFlag = FALSE;
80102718:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
8010271c:	e03ff615 	stw	zero,-40(fp)
			break;
80102720:	0001883a 	nop
		}
		break;
80102724:	00003006 	br	801027e8 <bSdmaDmaM2Transfer+0x394>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
80102728:	e0bffd03 	ldbu	r2,-12(fp)
8010272c:	10000926 	beq	r2,zero,80102754 <bSdmaDmaM2Transfer+0x300>
80102730:	10800060 	cmpeqi	r2,r2,1
80102734:	10000f26 	beq	r2,zero,80102774 <bSdmaDmaM2Transfer+0x320>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
80102738:	00b00014 	movui	r2,49152
8010273c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
80102740:	00800044 	movi	r2,1
80102744:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh7RightBufferEmpty();
80102748:	01062040 	call	80106204 <bFeebGetCh7RightBufferEmpty>
8010274c:	e0bff615 	stw	r2,-40(fp)
			break;
80102750:	00000b06 	br	80102780 <bSdmaDmaM2Transfer+0x32c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
80102754:	008000b4 	movhi	r2,2
80102758:	10b00004 	addi	r2,r2,-16384
8010275c:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
80102760:	00800044 	movi	r2,1
80102764:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh7LeftBufferEmpty();
80102768:	01061700 	call	80106170 <bFeebGetCh7LeftBufferEmpty>
8010276c:	e0bff615 	stw	r2,-40(fp)
			break;
80102770:	00000306 	br	80102780 <bSdmaDmaM2Transfer+0x32c>
		default:
			bChannelFlag = FALSE;
80102774:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
80102778:	e03ff615 	stw	zero,-40(fp)
			break;
8010277c:	0001883a 	nop
		}
		break;
80102780:	00001906 	br	801027e8 <bSdmaDmaM2Transfer+0x394>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
80102784:	e0bffd03 	ldbu	r2,-12(fp)
80102788:	10000926 	beq	r2,zero,801027b0 <bSdmaDmaM2Transfer+0x35c>
8010278c:	10800060 	cmpeqi	r2,r2,1
80102790:	10000f26 	beq	r2,zero,801027d0 <bSdmaDmaM2Transfer+0x37c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
80102794:	00b80014 	movui	r2,57344
80102798:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
8010279c:	00800044 	movi	r2,1
801027a0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh8RightBufferEmpty();
801027a4:	01063280 	call	80106328 <bFeebGetCh8RightBufferEmpty>
801027a8:	e0bff615 	stw	r2,-40(fp)
			break;
801027ac:	00000b06 	br	801027dc <bSdmaDmaM2Transfer+0x388>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
801027b0:	008000b4 	movhi	r2,2
801027b4:	10b80004 	addi	r2,r2,-8192
801027b8:	e0bff415 	stw	r2,-48(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
801027bc:	00800044 	movi	r2,1
801027c0:	e0bff515 	stw	r2,-44(fp)
			bBufferEmptyFlag = bFeebGetCh8LeftBufferEmpty();
801027c4:	01062980 	call	80106298 <bFeebGetCh8LeftBufferEmpty>
801027c8:	e0bff615 	stw	r2,-40(fp)
			break;
801027cc:	00000306 	br	801027dc <bSdmaDmaM2Transfer+0x388>
		default:
			bChannelFlag = FALSE;
801027d0:	e03ff715 	stw	zero,-36(fp)
			bBufferEmptyFlag = FALSE;
801027d4:	e03ff615 	stw	zero,-40(fp)
			break;
801027d8:	0001883a 	nop
		}
		break;
801027dc:	00000206 	br	801027e8 <bSdmaDmaM2Transfer+0x394>
	default:
		bChannelFlag = FALSE;
801027e0:	e03ff715 	stw	zero,-36(fp)
		break;
801027e4:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
801027e8:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bChannelFlag = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
801027ec:	00a00034 	movhi	r2,32768
801027f0:	1885883a 	add	r2,r3,r2
801027f4:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
801027f8:	e03ff915 	stw	zero,-28(fp)

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
801027fc:	e0bff717 	ldw	r2,-36(fp)
80102800:	10003026 	beq	r2,zero,801028c4 <bSdmaDmaM2Transfer+0x470>
80102804:	e0bff617 	ldw	r2,-40(fp)
80102808:	10002e26 	beq	r2,zero,801028c4 <bSdmaDmaM2Transfer+0x470>
8010280c:	e0bffc0b 	ldhu	r2,-16(fp)
80102810:	10800468 	cmpgeui	r2,r2,17
80102814:	10002b1e 	bne	r2,zero,801028c4 <bSdmaDmaM2Transfer+0x470>
		if (pxDmaM2Dev != NULL) {
80102818:	d0a03917 	ldw	r2,-32540(gp)
8010281c:	10002926 	beq	r2,zero,801028c4 <bSdmaDmaM2Transfer+0x470>

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
80102820:	00000206 	br	8010282c <bSdmaDmaM2Transfer+0x3d8>
				alt_busy_sleep(1); /* delay 1us */
80102824:	01000044 	movi	r4,1
80102828:	01318f00 	call	801318f0 <alt_busy_sleep>
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= SDMA_MAX_BLOCKS)) {
		if (pxDmaM2Dev != NULL) {

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
8010282c:	d0a03917 	ldw	r2,-32540(gp)
80102830:	10800317 	ldw	r2,12(r2)
80102834:	10800037 	ldwio	r2,0(r2)
80102838:	1080010c 	andi	r2,r2,4
8010283c:	103ff91e 	bne	r2,zero,80102824 <__reset+0xfa0e2824>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if ( 0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
80102840:	d2203917 	ldw	r8,-32540(gp)
80102844:	e1bff817 	ldw	r6,-32(fp)
80102848:	e1fff417 	ldw	r7,-48(fp)
8010284c:	e0bffc0b 	ldhu	r2,-16(fp)
80102850:	10802224 	muli	r2,r2,136
80102854:	e0fff917 	ldw	r3,-28(fp)
80102858:	e13ff517 	ldw	r4,-44(fp)
8010285c:	01400044 	movi	r5,1
80102860:	d9400815 	stw	r5,32(sp)
80102864:	01400044 	movi	r5,1
80102868:	d9400715 	stw	r5,28(sp)
8010286c:	01400044 	movi	r5,1
80102870:	d9400615 	stw	r5,24(sp)
80102874:	01400044 	movi	r5,1
80102878:	d9400515 	stw	r5,20(sp)
8010287c:	01400044 	movi	r5,1
80102880:	d9400415 	stw	r5,16(sp)
80102884:	d9000315 	stw	r4,12(sp)
80102888:	d8c00215 	stw	r3,8(sp)
8010288c:	e0fffa17 	ldw	r3,-24(fp)
80102890:	d8c00115 	stw	r3,4(sp)
80102894:	d8800015 	stw	r2,0(sp)
80102898:	800b883a 	mov	r5,r16
8010289c:	4009883a 	mov	r4,r8
801028a0:	010c4e80 	call	8010c4e8 <iMsgdmaConstructExtendedMmToMmDescriptor>
801028a4:	1000071e 	bne	r2,zero,801028c4 <bSdmaDmaM2Transfer+0x470>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)) {
				/* Success = 0 */
				if ( 0 == iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
801028a8:	d0a03917 	ldw	r2,-32540(gp)
801028ac:	800b883a 	mov	r5,r16
801028b0:	1009883a 	mov	r4,r2
801028b4:	010c5ec0 	call	8010c5ec <iMsgdmaExtendedDescriptorSyncTransfer>
801028b8:	1000021e 	bne	r2,zero,801028c4 <bSdmaDmaM2Transfer+0x470>
						&xDmaExtendedDescriptor)) {
					bStatus = TRUE;
801028bc:	00800044 	movi	r2,1
801028c0:	e0bff315 	stw	r2,-52(fp)
				}
			}
		}
	}
	return bStatus;
801028c4:	e0bff317 	ldw	r2,-52(fp)
}
801028c8:	e6ffff04 	addi	sp,fp,-4
801028cc:	dfc00217 	ldw	ra,8(sp)
801028d0:	df000117 	ldw	fp,4(sp)
801028d4:	dc000017 	ldw	r16,0(sp)
801028d8:	dec00304 	addi	sp,sp,12
801028dc:	f800283a 	ret

801028e0 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
801028e0:	defff804 	addi	sp,sp,-32
801028e4:	de00012e 	bgeu	sp,et,801028ec <bCommSetGlobalIrqEn+0xc>
801028e8:	003b68fa 	trap	3
801028ec:	dfc00715 	stw	ra,28(sp)
801028f0:	df000615 	stw	fp,24(sp)
801028f4:	df000604 	addi	fp,sp,24
801028f8:	e13ffe15 	stw	r4,-8(fp)
801028fc:	2805883a 	mov	r2,r5
80102900:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80102904:	e03ffa15 	stw	zero,-24(fp)
	bool bValidCh = FALSE;
80102908:	e03ffb15 	stw	zero,-20(fp)
	volatile alt_u32 uliReg = 0;
8010290c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 *puliCommAddr = 0;
80102910:	e03ffc15 	stw	zero,-16(fp)

	switch (ucCommCh) {
80102914:	e0bfff03 	ldbu	r2,-4(fp)
80102918:	10c00228 	cmpgeui	r3,r2,8
8010291c:	18003c1e 	bne	r3,zero,80102a10 <bCommSetGlobalIrqEn+0x130>
80102920:	100690ba 	slli	r3,r2,2
80102924:	00a00434 	movhi	r2,32784
80102928:	108a4e04 	addi	r2,r2,10552
8010292c:	1885883a 	add	r2,r3,r2
80102930:	10800017 	ldw	r2,0(r2)
80102934:	1000683a 	jmp	r2
80102938:	80102958 	cmpnei	zero,r16,16549
8010293c:	80102970 	cmpltui	zero,r16,16549
80102940:	80102988 	cmpgei	zero,r16,16550
80102944:	801029a0 	cmpeqi	zero,r16,16550
80102948:	801029b4 	orhi	zero,r16,16550
8010294c:	801029cc 	andi	zero,r16,16551
80102950:	801029e4 	muli	zero,r16,16551
80102954:	801029fc 	xorhi	zero,r16,16551
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
80102958:	00901034 	movhi	r2,16448
8010295c:	10830004 	addi	r2,r2,3072
80102960:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
80102964:	00800044 	movi	r2,1
80102968:	e0bffb15 	stw	r2,-20(fp)
		break;
8010296c:	00002a06 	br	80102a18 <bCommSetGlobalIrqEn+0x138>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
80102970:	00901034 	movhi	r2,16448
80102974:	10820004 	addi	r2,r2,2048
80102978:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
8010297c:	00800044 	movi	r2,1
80102980:	e0bffb15 	stw	r2,-20(fp)
		break;
80102984:	00002406 	br	80102a18 <bCommSetGlobalIrqEn+0x138>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
80102988:	00901034 	movhi	r2,16448
8010298c:	10810004 	addi	r2,r2,1024
80102990:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
80102994:	00800044 	movi	r2,1
80102998:	e0bffb15 	stw	r2,-20(fp)
		break;
8010299c:	00001e06 	br	80102a18 <bCommSetGlobalIrqEn+0x138>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
801029a0:	00901034 	movhi	r2,16448
801029a4:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
801029a8:	00800044 	movi	r2,1
801029ac:	e0bffb15 	stw	r2,-20(fp)
		break;
801029b0:	00001906 	br	80102a18 <bCommSetGlobalIrqEn+0x138>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
801029b4:	00901034 	movhi	r2,16448
801029b8:	10830004 	addi	r2,r2,3072
801029bc:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
801029c0:	00800044 	movi	r2,1
801029c4:	e0bffb15 	stw	r2,-20(fp)
		break;
801029c8:	00001306 	br	80102a18 <bCommSetGlobalIrqEn+0x138>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
801029cc:	00901034 	movhi	r2,16448
801029d0:	10820004 	addi	r2,r2,2048
801029d4:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
801029d8:	00800044 	movi	r2,1
801029dc:	e0bffb15 	stw	r2,-20(fp)
		break;
801029e0:	00000d06 	br	80102a18 <bCommSetGlobalIrqEn+0x138>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
801029e4:	00901034 	movhi	r2,16448
801029e8:	10810004 	addi	r2,r2,1024
801029ec:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
801029f0:	00800044 	movi	r2,1
801029f4:	e0bffb15 	stw	r2,-20(fp)
		break;
801029f8:	00000706 	br	80102a18 <bCommSetGlobalIrqEn+0x138>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
801029fc:	00901034 	movhi	r2,16448
80102a00:	e0bffc15 	stw	r2,-16(fp)
		bValidCh = TRUE;
80102a04:	00800044 	movi	r2,1
80102a08:	e0bffb15 	stw	r2,-20(fp)
		break;
80102a0c:	00000206 	br	80102a18 <bCommSetGlobalIrqEn+0x138>
	default:
		bValidCh = FALSE;
80102a10:	e03ffb15 	stw	zero,-20(fp)
		break;
80102a14:	0001883a 	nop
	}

	if (bValidCh) {
80102a18:	e0bffb17 	ldw	r2,-20(fp)
80102a1c:	10001626 	beq	r2,zero,80102a78 <bCommSetGlobalIrqEn+0x198>
		uliReg = uliCommReadReg(puliCommAddr,
80102a20:	01400444 	movi	r5,17
80102a24:	e13ffc17 	ldw	r4,-16(fp)
80102a28:	0102bf80 	call	80102bf8 <uliCommReadReg>
80102a2c:	e0bffd15 	stw	r2,-12(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
80102a30:	e0bffe17 	ldw	r2,-8(fp)
80102a34:	10000426 	beq	r2,zero,80102a48 <bCommSetGlobalIrqEn+0x168>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
80102a38:	e0bffd17 	ldw	r2,-12(fp)
80102a3c:	10800074 	orhi	r2,r2,1
80102a40:	e0bffd15 	stw	r2,-12(fp)
80102a44:	00000506 	br	80102a5c <bCommSetGlobalIrqEn+0x17c>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
80102a48:	e0fffd17 	ldw	r3,-12(fp)
80102a4c:	00bffff4 	movhi	r2,65535
80102a50:	10bfffc4 	addi	r2,r2,-1
80102a54:	1884703a 	and	r2,r3,r2
80102a58:	e0bffd15 	stw	r2,-12(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
80102a5c:	e0bffd17 	ldw	r2,-12(fp)
80102a60:	100d883a 	mov	r6,r2
80102a64:	01400444 	movi	r5,17
80102a68:	e13ffc17 	ldw	r4,-16(fp)
80102a6c:	0102ba40 	call	80102ba4 <vCommWriteReg>

		bStatus = TRUE;
80102a70:	00800044 	movi	r2,1
80102a74:	e0bffa15 	stw	r2,-24(fp)
	}

	return bStatus;
80102a78:	e0bffa17 	ldw	r2,-24(fp)
}
80102a7c:	e037883a 	mov	sp,fp
80102a80:	dfc00117 	ldw	ra,4(sp)
80102a84:	df000017 	ldw	fp,0(sp)
80102a88:	dec00204 	addi	sp,sp,8
80102a8c:	f800283a 	ret

80102a90 <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
80102a90:	defffa04 	addi	sp,sp,-24
80102a94:	de00012e 	bgeu	sp,et,80102a9c <bCommInitCh+0xc>
80102a98:	003b68fa 	trap	3
80102a9c:	dfc00515 	stw	ra,20(sp)
80102aa0:	df000415 	stw	fp,16(sp)
80102aa4:	df000404 	addi	fp,sp,16
80102aa8:	e13ffe15 	stw	r4,-8(fp)
80102aac:	2805883a 	mov	r2,r5
80102ab0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80102ab4:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
80102ab8:	e03ffd15 	stw	zero,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
80102abc:	e0bffe17 	ldw	r2,-8(fp)
80102ac0:	10805c04 	addi	r2,r2,368
80102ac4:	e0ffff03 	ldbu	r3,-4(fp)
80102ac8:	180b883a 	mov	r5,r3
80102acc:	1009883a 	mov	r4,r2
80102ad0:	010aebc0 	call	8010aebc <bSpwcInitCh>
80102ad4:	1000021e 	bne	r2,zero,80102ae0 <bCommInitCh+0x50>
		bInitFail = TRUE;
80102ad8:	00800044 	movi	r2,1
80102adc:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!vFeebInitIrq(ucCommCh)) {
80102ae0:	e0bfff03 	ldbu	r2,-4(fp)
80102ae4:	1009883a 	mov	r4,r2
80102ae8:	01054040 	call	80105404 <vFeebInitIrq>
80102aec:	1000021e 	bne	r2,zero,80102af8 <bCommInitCh+0x68>
		bInitFail = TRUE;
80102af0:	00800044 	movi	r2,1
80102af4:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
80102af8:	e0bffe17 	ldw	r2,-8(fp)
80102afc:	10800904 	addi	r2,r2,36
80102b00:	e0ffff03 	ldbu	r3,-4(fp)
80102b04:	180b883a 	mov	r5,r3
80102b08:	1009883a 	mov	r4,r2
80102b0c:	01070a80 	call	801070a8 <bFeebInitCh>
80102b10:	1000021e 	bne	r2,zero,80102b1c <bCommInitCh+0x8c>
		bInitFail = TRUE;
80102b14:	00800044 	movi	r2,1
80102b18:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
80102b1c:	e0bffe17 	ldw	r2,-8(fp)
80102b20:	10801604 	addi	r2,r2,88
80102b24:	e0ffff03 	ldbu	r3,-4(fp)
80102b28:	180b883a 	mov	r5,r3
80102b2c:	1009883a 	mov	r4,r2
80102b30:	010a4b00 	call	8010a4b0 <bRmapInitCh>
80102b34:	1000021e 	bne	r2,zero,80102b40 <bCommInitCh+0xb0>
		bInitFail = TRUE;
80102b38:	00800044 	movi	r2,1
80102b3c:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!vRmapInitIrq(ucCommCh)) {
80102b40:	e0bfff03 	ldbu	r2,-4(fp)
80102b44:	1009883a 	mov	r4,r2
80102b48:	0107dd00 	call	80107dd0 <vRmapInitIrq>
80102b4c:	1000021e 	bne	r2,zero,80102b58 <bCommInitCh+0xc8>
		bInitFail = TRUE;
80102b50:	00800044 	movi	r2,1
80102b54:	e0bffd15 	stw	r2,-12(fp)
	}
	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
80102b58:	e0bffe17 	ldw	r2,-8(fp)
80102b5c:	10800104 	addi	r2,r2,4
80102b60:	e0ffff03 	ldbu	r3,-4(fp)
80102b64:	180b883a 	mov	r5,r3
80102b68:	1009883a 	mov	r4,r2
80102b6c:	01033200 	call	80103320 <bDpktInitCh>
80102b70:	1000021e 	bne	r2,zero,80102b7c <bCommInitCh+0xec>
		bInitFail = TRUE;
80102b74:	00800044 	movi	r2,1
80102b78:	e0bffd15 	stw	r2,-12(fp)
	}

	if (!bInitFail) {
80102b7c:	e0bffd17 	ldw	r2,-12(fp)
80102b80:	1000021e 	bne	r2,zero,80102b8c <bCommInitCh+0xfc>
		bStatus = TRUE;
80102b84:	00800044 	movi	r2,1
80102b88:	e0bffc15 	stw	r2,-16(fp)
	}

	return bStatus;
80102b8c:	e0bffc17 	ldw	r2,-16(fp)
}
80102b90:	e037883a 	mov	sp,fp
80102b94:	dfc00117 	ldw	ra,4(sp)
80102b98:	df000017 	ldw	fp,0(sp)
80102b9c:	dec00204 	addi	sp,sp,8
80102ba0:	f800283a 	ret

80102ba4 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
80102ba4:	defffc04 	addi	sp,sp,-16
80102ba8:	de00012e 	bgeu	sp,et,80102bb0 <vCommWriteReg+0xc>
80102bac:	003b68fa 	trap	3
80102bb0:	df000315 	stw	fp,12(sp)
80102bb4:	df000304 	addi	fp,sp,12
80102bb8:	e13ffd15 	stw	r4,-12(fp)
80102bbc:	e17ffe15 	stw	r5,-8(fp)
80102bc0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
80102bc4:	e0bffe17 	ldw	r2,-8(fp)
80102bc8:	1085883a 	add	r2,r2,r2
80102bcc:	1085883a 	add	r2,r2,r2
80102bd0:	1007883a 	mov	r3,r2
80102bd4:	e0bffd17 	ldw	r2,-12(fp)
80102bd8:	10c5883a 	add	r2,r2,r3
80102bdc:	e0ffff17 	ldw	r3,-4(fp)
80102be0:	10c00015 	stw	r3,0(r2)
}
80102be4:	0001883a 	nop
80102be8:	e037883a 	mov	sp,fp
80102bec:	df000017 	ldw	fp,0(sp)
80102bf0:	dec00104 	addi	sp,sp,4
80102bf4:	f800283a 	ret

80102bf8 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
80102bf8:	defffc04 	addi	sp,sp,-16
80102bfc:	de00012e 	bgeu	sp,et,80102c04 <uliCommReadReg+0xc>
80102c00:	003b68fa 	trap	3
80102c04:	df000315 	stw	fp,12(sp)
80102c08:	df000304 	addi	fp,sp,12
80102c0c:	e13ffe15 	stw	r4,-8(fp)
80102c10:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
80102c14:	e0bfff17 	ldw	r2,-4(fp)
80102c18:	1085883a 	add	r2,r2,r2
80102c1c:	1085883a 	add	r2,r2,r2
80102c20:	1007883a 	mov	r3,r2
80102c24:	e0bffe17 	ldw	r2,-8(fp)
80102c28:	10c5883a 	add	r2,r2,r3
80102c2c:	10800017 	ldw	r2,0(r2)
80102c30:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
80102c34:	e0bffd17 	ldw	r2,-12(fp)
}
80102c38:	e037883a 	mov	sp,fp
80102c3c:	df000017 	ldw	fp,0(sp)
80102c40:	dec00104 	addi	sp,sp,4
80102c44:	f800283a 	ret

80102c48 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
80102c48:	defffb04 	addi	sp,sp,-20
80102c4c:	de00012e 	bgeu	sp,et,80102c54 <bDpktSetPacketConfig+0xc>
80102c50:	003b68fa 	trap	3
80102c54:	dfc00415 	stw	ra,16(sp)
80102c58:	df000315 	stw	fp,12(sp)
80102c5c:	df000304 	addi	fp,sp,12
80102c60:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80102c64:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80102c68:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
80102c6c:	e0bfff17 	ldw	r2,-4(fp)
80102c70:	10009826 	beq	r2,zero,80102ed4 <bDpktSetPacketConfig+0x28c>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80102c74:	e0bfff17 	ldw	r2,-4(fp)
80102c78:	10800017 	ldw	r2,0(r2)
80102c7c:	01400204 	movi	r5,8
80102c80:	1009883a 	mov	r4,r2
80102c84:	010353c0 	call	8010353c <uliDpktReadReg>
80102c88:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
80102c8c:	e0bffe17 	ldw	r2,-8(fp)
80102c90:	10bfffec 	andhi	r2,r2,65535
80102c94:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
80102c98:	e0bfff17 	ldw	r2,-4(fp)
80102c9c:	1080010b 	ldhu	r2,4(r2)
80102ca0:	10ffffcc 	andi	r3,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
80102ca4:	e0bffe17 	ldw	r2,-8(fp)
80102ca8:	1884b03a 	or	r2,r3,r2
80102cac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
80102cb0:	e0bffe17 	ldw	r2,-8(fp)
80102cb4:	10bfffcc 	andi	r2,r2,65535
80102cb8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
80102cbc:	e0bfff17 	ldw	r2,-4(fp)
80102cc0:	1080018b 	ldhu	r2,6(r2)
80102cc4:	10bfffcc 	andi	r2,r2,65535
80102cc8:	1004943a 	slli	r2,r2,16
80102ccc:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
80102cd0:	e0bffe17 	ldw	r2,-8(fp)
80102cd4:	1884b03a 	or	r2,r3,r2
80102cd8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
80102cdc:	e0bfff17 	ldw	r2,-4(fp)
80102ce0:	10800017 	ldw	r2,0(r2)
80102ce4:	e0fffe17 	ldw	r3,-8(fp)
80102ce8:	180d883a 	mov	r6,r3
80102cec:	01400204 	movi	r5,8
80102cf0:	1009883a 	mov	r4,r2
80102cf4:	01034e80 	call	801034e8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80102cf8:	e0bfff17 	ldw	r2,-4(fp)
80102cfc:	10800017 	ldw	r2,0(r2)
80102d00:	01400244 	movi	r5,9
80102d04:	1009883a 	mov	r4,r2
80102d08:	010353c0 	call	8010353c <uliDpktReadReg>
80102d0c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
80102d10:	e0bffe17 	ldw	r2,-8(fp)
80102d14:	10bfffec 	andhi	r2,r2,65535
80102d18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
80102d1c:	e0bfff17 	ldw	r2,-4(fp)
80102d20:	1080020b 	ldhu	r2,8(r2)
80102d24:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
80102d28:	e0bffe17 	ldw	r2,-8(fp)
80102d2c:	1884b03a 	or	r2,r3,r2
80102d30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
80102d34:	e0bffe17 	ldw	r2,-8(fp)
80102d38:	10bfffcc 	andi	r2,r2,65535
80102d3c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
80102d40:	e0bfff17 	ldw	r2,-4(fp)
80102d44:	1080028b 	ldhu	r2,10(r2)
										<< 16));
80102d48:	10bfffcc 	andi	r2,r2,65535
80102d4c:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
80102d50:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
80102d54:	e0bffe17 	ldw	r2,-8(fp)
80102d58:	1884b03a 	or	r2,r3,r2
80102d5c:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
80102d60:	e0bfff17 	ldw	r2,-4(fp)
80102d64:	10800017 	ldw	r2,0(r2)
80102d68:	e0fffe17 	ldw	r3,-8(fp)
80102d6c:	180d883a 	mov	r6,r3
80102d70:	01400244 	movi	r5,9
80102d74:	1009883a 	mov	r4,r2
80102d78:	01034e80 	call	801034e8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80102d7c:	e0bfff17 	ldw	r2,-4(fp)
80102d80:	10800017 	ldw	r2,0(r2)
80102d84:	01400284 	movi	r5,10
80102d88:	1009883a 	mov	r4,r2
80102d8c:	010353c0 	call	8010353c <uliDpktReadReg>
80102d90:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
80102d94:	e0bffe17 	ldw	r2,-8(fp)
80102d98:	10bfffec 	andhi	r2,r2,65535
80102d9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
80102da0:	e0bfff17 	ldw	r2,-4(fp)
80102da4:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
80102da8:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
80102dac:	e0bffe17 	ldw	r2,-8(fp)
80102db0:	1884b03a 	or	r2,r3,r2
80102db4:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
80102db8:	e0bfff17 	ldw	r2,-4(fp)
80102dbc:	10800017 	ldw	r2,0(r2)
80102dc0:	e0fffe17 	ldw	r3,-8(fp)
80102dc4:	180d883a 	mov	r6,r3
80102dc8:	01400284 	movi	r5,10
80102dcc:	1009883a 	mov	r4,r2
80102dd0:	01034e80 	call	801034e8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80102dd4:	e0bfff17 	ldw	r2,-4(fp)
80102dd8:	10800017 	ldw	r2,0(r2)
80102ddc:	014002c4 	movi	r5,11
80102de0:	1009883a 	mov	r4,r2
80102de4:	010353c0 	call	8010353c <uliDpktReadReg>
80102de8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
80102dec:	e0fffe17 	ldw	r3,-8(fp)
80102df0:	00bfc004 	movi	r2,-256
80102df4:	1884703a 	and	r2,r3,r2
80102df8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
80102dfc:	e0bfff17 	ldw	r2,-4(fp)
80102e00:	10800383 	ldbu	r2,14(r2)
80102e04:	10c03fcc 	andi	r3,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
80102e08:	e0bffe17 	ldw	r2,-8(fp)
80102e0c:	1884b03a 	or	r2,r3,r2
80102e10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
80102e14:	e0fffe17 	ldw	r3,-8(fp)
80102e18:	00bffff4 	movhi	r2,65535
80102e1c:	10803fc4 	addi	r2,r2,255
80102e20:	1884703a 	and	r2,r3,r2
80102e24:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
80102e28:	e0bfff17 	ldw	r2,-4(fp)
80102e2c:	108003c3 	ldbu	r2,15(r2)
80102e30:	10803fcc 	andi	r2,r2,255
80102e34:	1004923a 	slli	r2,r2,8
80102e38:	10ffffcc 	andi	r3,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
80102e3c:	e0bffe17 	ldw	r2,-8(fp)
80102e40:	1884b03a 	or	r2,r3,r2
80102e44:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
80102e48:	e0fffe17 	ldw	r3,-8(fp)
80102e4c:	00bfc074 	movhi	r2,65281
80102e50:	10bfffc4 	addi	r2,r2,-1
80102e54:	1884703a 	and	r2,r3,r2
80102e58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
80102e5c:	e0bfff17 	ldw	r2,-4(fp)
80102e60:	10800403 	ldbu	r2,16(r2)
80102e64:	10803fcc 	andi	r2,r2,255
80102e68:	1004943a 	slli	r2,r2,16
80102e6c:	10c03fec 	andhi	r3,r2,255
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
80102e70:	e0bffe17 	ldw	r2,-8(fp)
80102e74:	1884b03a 	or	r2,r3,r2
80102e78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
		uliReg &= (~COMM_DATA_PKT_LOGICAL_ADDR_MSK);
80102e7c:	e0fffe17 	ldw	r3,-8(fp)
80102e80:	00804034 	movhi	r2,256
80102e84:	10bfffc4 	addi	r2,r2,-1
80102e88:	1884703a 	and	r2,r3,r2
80102e8c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LOGICAL_ADDR_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr << 24));
80102e90:	e0bfff17 	ldw	r2,-4(fp)
80102e94:	10800443 	ldbu	r2,17(r2)
80102e98:	10803fcc 	andi	r2,r2,255
80102e9c:	1004963a 	slli	r2,r2,24
80102ea0:	1007883a 	mov	r3,r2
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
		uliReg &= (~COMM_DATA_PKT_PROTOCOL_ID_MSK);
		uliReg |= (COMM_DATA_PKT_PROTOCOL_ID_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucProtocolId << 16));
		uliReg &= (~COMM_DATA_PKT_LOGICAL_ADDR_MSK);
		uliReg |= (COMM_DATA_PKT_LOGICAL_ADDR_MSK
80102ea4:	e0bffe17 	ldw	r2,-8(fp)
80102ea8:	1884b03a 	or	r2,r3,r2
80102eac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr << 24));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
80102eb0:	e0bfff17 	ldw	r2,-4(fp)
80102eb4:	10800017 	ldw	r2,0(r2)
80102eb8:	e0fffe17 	ldw	r3,-8(fp)
80102ebc:	180d883a 	mov	r6,r3
80102ec0:	014002c4 	movi	r5,11
80102ec4:	1009883a 	mov	r4,r2
80102ec8:	01034e80 	call	801034e8 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
80102ecc:	00800044 	movi	r2,1
80102ed0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80102ed4:	e0bffd17 	ldw	r2,-12(fp)
}
80102ed8:	e037883a 	mov	sp,fp
80102edc:	dfc00117 	ldw	ra,4(sp)
80102ee0:	df000017 	ldw	fp,0(sp)
80102ee4:	dec00204 	addi	sp,sp,8
80102ee8:	f800283a 	ret

80102eec <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
80102eec:	defffb04 	addi	sp,sp,-20
80102ef0:	de00012e 	bgeu	sp,et,80102ef8 <bDpktGetPacketConfig+0xc>
80102ef4:	003b68fa 	trap	3
80102ef8:	dfc00415 	stw	ra,16(sp)
80102efc:	df000315 	stw	fp,12(sp)
80102f00:	df000304 	addi	fp,sp,12
80102f04:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80102f08:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80102f0c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
80102f10:	e0bfff17 	ldw	r2,-4(fp)
80102f14:	10004526 	beq	r2,zero,8010302c <bDpktGetPacketConfig+0x140>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80102f18:	e0bfff17 	ldw	r2,-4(fp)
80102f1c:	10800017 	ldw	r2,0(r2)
80102f20:	01400204 	movi	r5,8
80102f24:	1009883a 	mov	r4,r2
80102f28:	010353c0 	call	8010353c <uliDpktReadReg>
80102f2c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
80102f30:	e0bffe17 	ldw	r2,-8(fp)
80102f34:	1007883a 	mov	r3,r2
80102f38:	e0bfff17 	ldw	r2,-4(fp)
80102f3c:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
80102f40:	e0bffe17 	ldw	r2,-8(fp)
80102f44:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
80102f48:	1007883a 	mov	r3,r2
80102f4c:	e0bfff17 	ldw	r2,-4(fp)
80102f50:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80102f54:	e0bfff17 	ldw	r2,-4(fp)
80102f58:	10800017 	ldw	r2,0(r2)
80102f5c:	01400244 	movi	r5,9
80102f60:	1009883a 	mov	r4,r2
80102f64:	010353c0 	call	8010353c <uliDpktReadReg>
80102f68:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
80102f6c:	e0bffe17 	ldw	r2,-8(fp)
80102f70:	1007883a 	mov	r3,r2
80102f74:	e0bfff17 	ldw	r2,-4(fp)
80102f78:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
80102f7c:	e0bffe17 	ldw	r2,-8(fp)
80102f80:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
80102f84:	1007883a 	mov	r3,r2
80102f88:	e0bfff17 	ldw	r2,-4(fp)
80102f8c:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80102f90:	e0bfff17 	ldw	r2,-4(fp)
80102f94:	10800017 	ldw	r2,0(r2)
80102f98:	01400284 	movi	r5,10
80102f9c:	1009883a 	mov	r4,r2
80102fa0:	010353c0 	call	8010353c <uliDpktReadReg>
80102fa4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
80102fa8:	e0bffe17 	ldw	r2,-8(fp)
80102fac:	1007883a 	mov	r3,r2
80102fb0:	e0bfff17 	ldw	r2,-4(fp)
80102fb4:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80102fb8:	e0bfff17 	ldw	r2,-4(fp)
80102fbc:	10800017 	ldw	r2,0(r2)
80102fc0:	014002c4 	movi	r5,11
80102fc4:	1009883a 	mov	r4,r2
80102fc8:	010353c0 	call	8010353c <uliDpktReadReg>
80102fcc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
80102fd0:	e0bffe17 	ldw	r2,-8(fp)
80102fd4:	1007883a 	mov	r3,r2
80102fd8:	e0bfff17 	ldw	r2,-4(fp)
80102fdc:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
80102fe0:	e0bffe17 	ldw	r2,-8(fp)
80102fe4:	10bfc00c 	andi	r2,r2,65280
80102fe8:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
80102fec:	1007883a 	mov	r3,r2
80102ff0:	e0bfff17 	ldw	r2,-4(fp)
80102ff4:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
80102ff8:	e0bffe17 	ldw	r2,-8(fp)
80102ffc:	10803fec 	andhi	r2,r2,255
80103000:	1004d43a 	srli	r2,r2,16

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
80103004:	1007883a 	mov	r3,r2
80103008:	e0bfff17 	ldw	r2,-4(fp)
8010300c:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
		pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr= (alt_u8)(
				(uliReg & COMM_DATA_PKT_LOGICAL_ADDR_MSK) >> 24);
80103010:	e0bffe17 	ldw	r2,-8(fp)
80103014:	1004d63a 	srli	r2,r2,24
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
		pxDpktCh->xDpktDataPacketConfig.ucProtocolId= (alt_u8)(
				(uliReg & COMM_DATA_PKT_PROTOCOL_ID_MSK) >> 16);
		pxDpktCh->xDpktDataPacketConfig.ucLogicalAddr= (alt_u8)(
80103018:	1007883a 	mov	r3,r2
8010301c:	e0bfff17 	ldw	r2,-4(fp)
80103020:	10c00445 	stb	r3,17(r2)
				(uliReg & COMM_DATA_PKT_LOGICAL_ADDR_MSK) >> 24);

		bStatus = TRUE;
80103024:	00800044 	movi	r2,1
80103028:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010302c:	e0bffd17 	ldw	r2,-12(fp)
}
80103030:	e037883a 	mov	sp,fp
80103034:	dfc00117 	ldw	ra,4(sp)
80103038:	df000017 	ldw	fp,0(sp)
8010303c:	dec00204 	addi	sp,sp,8
80103040:	f800283a 	ret

80103044 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
80103044:	defffb04 	addi	sp,sp,-20
80103048:	de00012e 	bgeu	sp,et,80103050 <bDpktGetPacketHeader+0xc>
8010304c:	003b68fa 	trap	3
80103050:	dfc00415 	stw	ra,16(sp)
80103054:	df000315 	stw	fp,12(sp)
80103058:	df000304 	addi	fp,sp,12
8010305c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80103060:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80103064:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
80103068:	e0bfff17 	ldw	r2,-4(fp)
8010306c:	10002026 	beq	r2,zero,801030f0 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80103070:	e0bfff17 	ldw	r2,-4(fp)
80103074:	10800017 	ldw	r2,0(r2)
80103078:	01400304 	movi	r5,12
8010307c:	1009883a 	mov	r4,r2
80103080:	010353c0 	call	8010353c <uliDpktReadReg>
80103084:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
80103088:	e0bffe17 	ldw	r2,-8(fp)
8010308c:	1007883a 	mov	r3,r2
80103090:	e0bfff17 	ldw	r2,-4(fp)
80103094:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
80103098:	e0bffe17 	ldw	r2,-8(fp)
8010309c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
801030a0:	1007883a 	mov	r3,r2
801030a4:	e0bfff17 	ldw	r2,-4(fp)
801030a8:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
801030ac:	e0bfff17 	ldw	r2,-4(fp)
801030b0:	10800017 	ldw	r2,0(r2)
801030b4:	01400344 	movi	r5,13
801030b8:	1009883a 	mov	r4,r2
801030bc:	010353c0 	call	8010353c <uliDpktReadReg>
801030c0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
801030c4:	e0bffe17 	ldw	r2,-8(fp)
801030c8:	1007883a 	mov	r3,r2
801030cc:	e0bfff17 	ldw	r2,-4(fp)
801030d0:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
801030d4:	e0bffe17 	ldw	r2,-8(fp)
801030d8:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
801030dc:	1007883a 	mov	r3,r2
801030e0:	e0bfff17 	ldw	r2,-4(fp)
801030e4:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
801030e8:	00800044 	movi	r2,1
801030ec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
801030f0:	e0bffd17 	ldw	r2,-12(fp)
}
801030f4:	e037883a 	mov	sp,fp
801030f8:	dfc00117 	ldw	ra,4(sp)
801030fc:	df000017 	ldw	fp,0(sp)
80103100:	dec00204 	addi	sp,sp,8
80103104:	f800283a 	ret

80103108 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
80103108:	defffb04 	addi	sp,sp,-20
8010310c:	de00012e 	bgeu	sp,et,80103114 <bDpktSetPixelDelay+0xc>
80103110:	003b68fa 	trap	3
80103114:	dfc00415 	stw	ra,16(sp)
80103118:	df000315 	stw	fp,12(sp)
8010311c:	df000304 	addi	fp,sp,12
80103120:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80103124:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80103128:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
8010312c:	e0bfff17 	ldw	r2,-4(fp)
80103130:	10004426 	beq	r2,zero,80103244 <bDpktSetPixelDelay+0x13c>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80103134:	e0bfff17 	ldw	r2,-4(fp)
80103138:	10800017 	ldw	r2,0(r2)
8010313c:	01400384 	movi	r5,14
80103140:	1009883a 	mov	r4,r2
80103144:	010353c0 	call	8010353c <uliDpktReadReg>
80103148:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
8010314c:	e0bffe17 	ldw	r2,-8(fp)
80103150:	10bfffec 	andhi	r2,r2,65535
80103154:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
80103158:	e0bfff17 	ldw	r2,-4(fp)
8010315c:	1080068b 	ldhu	r2,26(r2)
80103160:	10ffffcc 	andi	r3,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
80103164:	e0bffe17 	ldw	r2,-8(fp)
80103168:	1884b03a 	or	r2,r3,r2
8010316c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
80103170:	e0bfff17 	ldw	r2,-4(fp)
80103174:	10800017 	ldw	r2,0(r2)
80103178:	e0fffe17 	ldw	r3,-8(fp)
8010317c:	180d883a 	mov	r6,r3
80103180:	01400384 	movi	r5,14
80103184:	1009883a 	mov	r4,r2
80103188:	01034e80 	call	801034e8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8010318c:	e0bfff17 	ldw	r2,-4(fp)
80103190:	10800017 	ldw	r2,0(r2)
80103194:	014003c4 	movi	r5,15
80103198:	1009883a 	mov	r4,r2
8010319c:	010353c0 	call	8010353c <uliDpktReadReg>
801031a0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
801031a4:	e0bffe17 	ldw	r2,-8(fp)
801031a8:	10bfffec 	andhi	r2,r2,65535
801031ac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
801031b0:	e0bfff17 	ldw	r2,-4(fp)
801031b4:	1080070b 	ldhu	r2,28(r2)
801031b8:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
801031bc:	e0bffe17 	ldw	r2,-8(fp)
801031c0:	1884b03a 	or	r2,r3,r2
801031c4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
801031c8:	e0bfff17 	ldw	r2,-4(fp)
801031cc:	10800017 	ldw	r2,0(r2)
801031d0:	e0fffe17 	ldw	r3,-8(fp)
801031d4:	180d883a 	mov	r6,r3
801031d8:	014003c4 	movi	r5,15
801031dc:	1009883a 	mov	r4,r2
801031e0:	01034e80 	call	801034e8 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
801031e4:	e0bfff17 	ldw	r2,-4(fp)
801031e8:	10800017 	ldw	r2,0(r2)
801031ec:	01400404 	movi	r5,16
801031f0:	1009883a 	mov	r4,r2
801031f4:	010353c0 	call	8010353c <uliDpktReadReg>
801031f8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
801031fc:	e0bffe17 	ldw	r2,-8(fp)
80103200:	10bfffec 	andhi	r2,r2,65535
80103204:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
80103208:	e0bfff17 	ldw	r2,-4(fp)
8010320c:	1080078b 	ldhu	r2,30(r2)
80103210:	10ffffcc 	andi	r3,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
80103214:	e0bffe17 	ldw	r2,-8(fp)
80103218:	1884b03a 	or	r2,r3,r2
8010321c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
80103220:	e0bfff17 	ldw	r2,-4(fp)
80103224:	10800017 	ldw	r2,0(r2)
80103228:	e0fffe17 	ldw	r3,-8(fp)
8010322c:	180d883a 	mov	r6,r3
80103230:	01400404 	movi	r5,16
80103234:	1009883a 	mov	r4,r2
80103238:	01034e80 	call	801034e8 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
8010323c:	00800044 	movi	r2,1
80103240:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80103244:	e0bffd17 	ldw	r2,-12(fp)
}
80103248:	e037883a 	mov	sp,fp
8010324c:	dfc00117 	ldw	ra,4(sp)
80103250:	df000017 	ldw	fp,0(sp)
80103254:	dec00204 	addi	sp,sp,8
80103258:	f800283a 	ret

8010325c <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
8010325c:	defffb04 	addi	sp,sp,-20
80103260:	de00012e 	bgeu	sp,et,80103268 <bDpktGetPixelDelay+0xc>
80103264:	003b68fa 	trap	3
80103268:	dfc00415 	stw	ra,16(sp)
8010326c:	df000315 	stw	fp,12(sp)
80103270:	df000304 	addi	fp,sp,12
80103274:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80103278:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010327c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
80103280:	e0bfff17 	ldw	r2,-4(fp)
80103284:	10002026 	beq	r2,zero,80103308 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
80103288:	e0bfff17 	ldw	r2,-4(fp)
8010328c:	10800017 	ldw	r2,0(r2)
80103290:	01400384 	movi	r5,14
80103294:	1009883a 	mov	r4,r2
80103298:	010353c0 	call	8010353c <uliDpktReadReg>
8010329c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
801032a0:	e0bffe17 	ldw	r2,-8(fp)
801032a4:	1007883a 	mov	r3,r2
801032a8:	e0bfff17 	ldw	r2,-4(fp)
801032ac:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
801032b0:	e0bfff17 	ldw	r2,-4(fp)
801032b4:	10800017 	ldw	r2,0(r2)
801032b8:	014003c4 	movi	r5,15
801032bc:	1009883a 	mov	r4,r2
801032c0:	010353c0 	call	8010353c <uliDpktReadReg>
801032c4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
801032c8:	e0bffe17 	ldw	r2,-8(fp)
801032cc:	1007883a 	mov	r3,r2
801032d0:	e0bfff17 	ldw	r2,-4(fp)
801032d4:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
801032d8:	e0bfff17 	ldw	r2,-4(fp)
801032dc:	10800017 	ldw	r2,0(r2)
801032e0:	01400404 	movi	r5,16
801032e4:	1009883a 	mov	r4,r2
801032e8:	010353c0 	call	8010353c <uliDpktReadReg>
801032ec:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
801032f0:	e0bffe17 	ldw	r2,-8(fp)
801032f4:	1007883a 	mov	r3,r2
801032f8:	e0bfff17 	ldw	r2,-4(fp)
801032fc:	10c0078d 	sth	r3,30(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
80103300:	00800044 	movi	r2,1
80103304:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80103308:	e0bffd17 	ldw	r2,-12(fp)
}
8010330c:	e037883a 	mov	sp,fp
80103310:	dfc00117 	ldw	ra,4(sp)
80103314:	df000017 	ldw	fp,0(sp)
80103318:	dec00204 	addi	sp,sp,8
8010331c:	f800283a 	ret

80103320 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
80103320:	defff904 	addi	sp,sp,-28
80103324:	de00012e 	bgeu	sp,et,8010332c <bDpktInitCh+0xc>
80103328:	003b68fa 	trap	3
8010332c:	dfc00615 	stw	ra,24(sp)
80103330:	df000515 	stw	fp,20(sp)
80103334:	df000504 	addi	fp,sp,20
80103338:	e13ffe15 	stw	r4,-8(fp)
8010333c:	2805883a 	mov	r2,r5
80103340:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80103344:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
80103348:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
8010334c:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
80103350:	e0bffe17 	ldw	r2,-8(fp)
80103354:	10005e26 	beq	r2,zero,801034d0 <bDpktInitCh+0x1b0>

		switch (ucCommCh) {
80103358:	e0bfff03 	ldbu	r2,-4(fp)
8010335c:	10c00228 	cmpgeui	r3,r2,8
80103360:	1800441e 	bne	r3,zero,80103474 <bDpktInitCh+0x154>
80103364:	100690ba 	slli	r3,r2,2
80103368:	00a00434 	movhi	r2,32784
8010336c:	108cdf04 	addi	r2,r2,13180
80103370:	1885883a 	add	r2,r3,r2
80103374:	10800017 	ldw	r2,0(r2)
80103378:	1000683a 	jmp	r2
8010337c:	8010339c 	xori	zero,r16,16590
80103380:	801033b8 	rdprs	zero,r16,16590
80103384:	801033d4 	ori	zero,r16,16591
80103388:	801033f0 	cmpltui	zero,r16,16591
8010338c:	80103408 	cmpgei	zero,r16,16592
80103390:	80103424 	muli	zero,r16,16592
80103394:	80103440 	call	88010344 <__reset+0x1ff0344>
80103398:	8010345c 	xori	zero,r16,16593
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8010339c:	e0fffe17 	ldw	r3,-8(fp)
801033a0:	00901034 	movhi	r2,16448
801033a4:	10830004 	addi	r2,r2,3072
801033a8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
801033ac:	00800044 	movi	r2,1
801033b0:	e0bffc15 	stw	r2,-16(fp)
			break;
801033b4:	00003106 	br	8010347c <bDpktInitCh+0x15c>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
801033b8:	e0fffe17 	ldw	r3,-8(fp)
801033bc:	00901034 	movhi	r2,16448
801033c0:	10820004 	addi	r2,r2,2048
801033c4:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
801033c8:	00800044 	movi	r2,1
801033cc:	e0bffc15 	stw	r2,-16(fp)
			break;
801033d0:	00002a06 	br	8010347c <bDpktInitCh+0x15c>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
801033d4:	e0fffe17 	ldw	r3,-8(fp)
801033d8:	00901034 	movhi	r2,16448
801033dc:	10810004 	addi	r2,r2,1024
801033e0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
801033e4:	00800044 	movi	r2,1
801033e8:	e0bffc15 	stw	r2,-16(fp)
			break;
801033ec:	00002306 	br	8010347c <bDpktInitCh+0x15c>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
801033f0:	e0bffe17 	ldw	r2,-8(fp)
801033f4:	00d01034 	movhi	r3,16448
801033f8:	10c00015 	stw	r3,0(r2)
			bValidCh = TRUE;
801033fc:	00800044 	movi	r2,1
80103400:	e0bffc15 	stw	r2,-16(fp)
			break;
80103404:	00001d06 	br	8010347c <bDpktInitCh+0x15c>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
80103408:	e0fffe17 	ldw	r3,-8(fp)
8010340c:	00901034 	movhi	r2,16448
80103410:	10830004 	addi	r2,r2,3072
80103414:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
80103418:	00800044 	movi	r2,1
8010341c:	e0bffc15 	stw	r2,-16(fp)
			break;
80103420:	00001606 	br	8010347c <bDpktInitCh+0x15c>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
80103424:	e0fffe17 	ldw	r3,-8(fp)
80103428:	00901034 	movhi	r2,16448
8010342c:	10820004 	addi	r2,r2,2048
80103430:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
80103434:	00800044 	movi	r2,1
80103438:	e0bffc15 	stw	r2,-16(fp)
			break;
8010343c:	00000f06 	br	8010347c <bDpktInitCh+0x15c>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
80103440:	e0fffe17 	ldw	r3,-8(fp)
80103444:	00901034 	movhi	r2,16448
80103448:	10810004 	addi	r2,r2,1024
8010344c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
80103450:	00800044 	movi	r2,1
80103454:	e0bffc15 	stw	r2,-16(fp)
			break;
80103458:	00000806 	br	8010347c <bDpktInitCh+0x15c>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8010345c:	e0bffe17 	ldw	r2,-8(fp)
80103460:	00d01034 	movhi	r3,16448
80103464:	10c00015 	stw	r3,0(r2)
			bValidCh = TRUE;
80103468:	00800044 	movi	r2,1
8010346c:	e0bffc15 	stw	r2,-16(fp)
			break;
80103470:	00000206 	br	8010347c <bDpktInitCh+0x15c>
		default:
			bValidCh = FALSE;
80103474:	e03ffc15 	stw	zero,-16(fp)
			break;
80103478:	0001883a 	nop
		}

		if (bValidCh) {
8010347c:	e0bffc17 	ldw	r2,-16(fp)
80103480:	10001326 	beq	r2,zero,801034d0 <bDpktInitCh+0x1b0>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
80103484:	e13ffe17 	ldw	r4,-8(fp)
80103488:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
8010348c:	1000021e 	bne	r2,zero,80103498 <bDpktInitCh+0x178>
				bInitFail = TRUE;
80103490:	00800044 	movi	r2,1
80103494:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
80103498:	e13ffe17 	ldw	r4,-8(fp)
8010349c:	01030440 	call	80103044 <bDpktGetPacketHeader>
801034a0:	1000021e 	bne	r2,zero,801034ac <bDpktInitCh+0x18c>
				bInitFail = TRUE;
801034a4:	00800044 	movi	r2,1
801034a8:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
801034ac:	e13ffe17 	ldw	r4,-8(fp)
801034b0:	010325c0 	call	8010325c <bDpktGetPixelDelay>
801034b4:	1000021e 	bne	r2,zero,801034c0 <bDpktInitCh+0x1a0>
				bInitFail = TRUE;
801034b8:	00800044 	movi	r2,1
801034bc:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
801034c0:	e0bffd17 	ldw	r2,-12(fp)
801034c4:	1000021e 	bne	r2,zero,801034d0 <bDpktInitCh+0x1b0>
				bStatus = TRUE;
801034c8:	00800044 	movi	r2,1
801034cc:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
801034d0:	e0bffb17 	ldw	r2,-20(fp)
}
801034d4:	e037883a 	mov	sp,fp
801034d8:	dfc00117 	ldw	ra,4(sp)
801034dc:	df000017 	ldw	fp,0(sp)
801034e0:	dec00204 	addi	sp,sp,8
801034e4:	f800283a 	ret

801034e8 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
801034e8:	defffc04 	addi	sp,sp,-16
801034ec:	de00012e 	bgeu	sp,et,801034f4 <vDpktWriteReg+0xc>
801034f0:	003b68fa 	trap	3
801034f4:	df000315 	stw	fp,12(sp)
801034f8:	df000304 	addi	fp,sp,12
801034fc:	e13ffd15 	stw	r4,-12(fp)
80103500:	e17ffe15 	stw	r5,-8(fp)
80103504:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
80103508:	e0bffe17 	ldw	r2,-8(fp)
8010350c:	1085883a 	add	r2,r2,r2
80103510:	1085883a 	add	r2,r2,r2
80103514:	1007883a 	mov	r3,r2
80103518:	e0bffd17 	ldw	r2,-12(fp)
8010351c:	10c5883a 	add	r2,r2,r3
80103520:	e0ffff17 	ldw	r3,-4(fp)
80103524:	10c00015 	stw	r3,0(r2)
}
80103528:	0001883a 	nop
8010352c:	e037883a 	mov	sp,fp
80103530:	df000017 	ldw	fp,0(sp)
80103534:	dec00104 	addi	sp,sp,4
80103538:	f800283a 	ret

8010353c <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8010353c:	defffc04 	addi	sp,sp,-16
80103540:	de00012e 	bgeu	sp,et,80103548 <uliDpktReadReg+0xc>
80103544:	003b68fa 	trap	3
80103548:	df000315 	stw	fp,12(sp)
8010354c:	df000304 	addi	fp,sp,12
80103550:	e13ffe15 	stw	r4,-8(fp)
80103554:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
80103558:	e0bfff17 	ldw	r2,-4(fp)
8010355c:	1085883a 	add	r2,r2,r2
80103560:	1085883a 	add	r2,r2,r2
80103564:	1007883a 	mov	r3,r2
80103568:	e0bffe17 	ldw	r2,-8(fp)
8010356c:	10c5883a 	add	r2,r2,r3
80103570:	10800017 	ldw	r2,0(r2)
80103574:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
80103578:	e0bffd17 	ldw	r2,-12(fp)
}
8010357c:	e037883a 	mov	sp,fp
80103580:	df000017 	ldw	fp,0(sp)
80103584:	dec00104 	addi	sp,sp,4
80103588:	f800283a 	ret

8010358c <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
8010358c:	defffc04 	addi	sp,sp,-16
80103590:	de00012e 	bgeu	sp,et,80103598 <usiAdcPxDelayCalcPeriodNs+0xc>
80103594:	003b68fa 	trap	3
80103598:	dfc00315 	stw	ra,12(sp)
8010359c:	df000215 	stw	fp,8(sp)
801035a0:	df000204 	addi	fp,sp,8
801035a4:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
801035a8:	e13fff17 	ldw	r4,-4(fp)
801035ac:	011fdb40 	call	8011fdb4 <__floatunsisf>
801035b0:	1007883a 	mov	r3,r2
801035b4:	1809883a 	mov	r4,r3
801035b8:	01211100 	call	80121110 <__extendsfdf2>
801035bc:	1011883a 	mov	r8,r2
801035c0:	1813883a 	mov	r9,r3
801035c4:	01a666b4 	movhi	r6,39322
801035c8:	31a66684 	addi	r6,r6,-26214
801035cc:	01cfeeb4 	movhi	r7,16314
801035d0:	39e66644 	addi	r7,r7,-26215
801035d4:	4009883a 	mov	r4,r8
801035d8:	480b883a 	mov	r5,r9
801035dc:	011ff880 	call	8011ff88 <__muldf3>
801035e0:	1009883a 	mov	r4,r2
801035e4:	180b883a 	mov	r5,r3
801035e8:	2005883a 	mov	r2,r4
801035ec:	2807883a 	mov	r3,r5
801035f0:	1009883a 	mov	r4,r2
801035f4:	180b883a 	mov	r5,r3
801035f8:	011f4ec0 	call	8011f4ec <__fixunsdfsi>
801035fc:	e0bffe0d 	sth	r2,-8(fp)
	if (6 < usiAdcPxDelay) {
80103600:	e0bffe0b 	ldhu	r2,-8(fp)
80103604:	108001f0 	cmpltui	r2,r2,7
80103608:	1000041e 	bne	r2,zero,8010361c <usiAdcPxDelayCalcPeriodNs+0x90>
		usiAdcPxDelay -= 6;
8010360c:	e0bffe0b 	ldhu	r2,-8(fp)
80103610:	10bffe84 	addi	r2,r2,-6
80103614:	e0bffe0d 	sth	r2,-8(fp)
80103618:	00000106 	br	80103620 <usiAdcPxDelayCalcPeriodNs+0x94>
	} else {
		usiAdcPxDelay = 0;
8010361c:	e03ffe0d 	sth	zero,-8(fp)
	}

	return usiAdcPxDelay;
80103620:	e0bffe0b 	ldhu	r2,-8(fp)
}
80103624:	e037883a 	mov	sp,fp
80103628:	dfc00117 	ldw	ra,4(sp)
8010362c:	df000017 	ldw	fp,0(sp)
80103630:	dec00204 	addi	sp,sp,8
80103634:	f800283a 	ret

80103638 <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
80103638:	defffc04 	addi	sp,sp,-16
8010363c:	de00012e 	bgeu	sp,et,80103644 <usiLineTrDelayCalcPeriodNs+0xc>
80103640:	003b68fa 	trap	3
80103644:	dfc00315 	stw	ra,12(sp)
80103648:	df000215 	stw	fp,8(sp)
8010364c:	df000204 	addi	fp,sp,8
80103650:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
80103654:	e13fff17 	ldw	r4,-4(fp)
80103658:	011fdb40 	call	8011fdb4 <__floatunsisf>
8010365c:	1007883a 	mov	r3,r2
80103660:	1809883a 	mov	r4,r3
80103664:	01211100 	call	80121110 <__extendsfdf2>
80103668:	1011883a 	mov	r8,r2
8010366c:	1813883a 	mov	r9,r3
80103670:	0191ebb4 	movhi	r6,18350
80103674:	31851ec4 	addi	r6,r6,5243
80103678:	01cfe134 	movhi	r7,16260
8010367c:	39deb844 	addi	r7,r7,31457
80103680:	4009883a 	mov	r4,r8
80103684:	480b883a 	mov	r5,r9
80103688:	011ff880 	call	8011ff88 <__muldf3>
8010368c:	1009883a 	mov	r4,r2
80103690:	180b883a 	mov	r5,r3
80103694:	2005883a 	mov	r2,r4
80103698:	2807883a 	mov	r3,r5
8010369c:	1009883a 	mov	r4,r2
801036a0:	180b883a 	mov	r5,r3
801036a4:	011f4ec0 	call	8011f4ec <__fixunsdfsi>
801036a8:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
801036ac:	e0bffe0b 	ldhu	r2,-8(fp)
}
801036b0:	e037883a 	mov	sp,fp
801036b4:	dfc00117 	ldw	ra,4(sp)
801036b8:	df000017 	ldw	fp,0(sp)
801036bc:	dec00204 	addi	sp,sp,8
801036c0:	f800283a 	ret

801036c4 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
801036c4:	defff804 	addi	sp,sp,-32
801036c8:	de00012e 	bgeu	sp,et,801036d0 <vFeebCh1HandleIrq+0xc>
801036cc:	003b68fa 	trap	3
801036d0:	dfc00715 	stw	ra,28(sp)
801036d4:	df000615 	stw	fp,24(sp)
801036d8:	dc000515 	stw	r16,20(sp)
801036dc:	df000604 	addi	fp,sp,24
801036e0:	e13ffe15 	stw	r4,-8(fp)
801036e4:	d809883a 	mov	r4,sp
801036e8:	2021883a 	mov	r16,r4
	// App logic sequence...

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
801036ec:	01000404 	movi	r4,16
801036f0:	e13ffdc5 	stb	r4,-9(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
801036f4:	013fe004 	movi	r4,-128
801036f8:	e13ffd85 	stb	r4,-10(fp)
	uiCmdtoSend.ucByte[1] = 0;
801036fc:	e03ffd45 	stb	zero,-11(fp)
	//uiCmdtoSend.ucByte[0] = 0;
	uiCmdtoSend.ucByte[0] = xDefaultsCH.ucChannelToFEE[0];
80103700:	012005b4 	movhi	r4,32790
80103704:	213a3204 	addi	r4,r4,-5944
80103708:	21000003 	ldbu	r4,0(r4)
8010370c:	e13ffd05 	stb	r4,-12(fp)

	// Get Irq Buffer Empty Flags
	bool bIrqEmptyBufferFlags[ucFeebIrqEmptyBufferFlagsQtd];
80103710:	01000104 	movi	r4,4
80103714:	21003fcc 	andi	r4,r4,255
80103718:	213fffc4 	addi	r4,r4,-1
8010371c:	e13ffa15 	stw	r4,-24(fp)
80103720:	01000104 	movi	r4,4
80103724:	21003fcc 	andi	r4,r4,255
80103728:	2013883a 	mov	r9,r4
8010372c:	0015883a 	mov	r10,zero
80103730:	4808d6fa 	srli	r4,r9,27
80103734:	500c917a 	slli	r6,r10,5
80103738:	218cb03a 	or	r6,r4,r6
8010373c:	480a917a 	slli	r5,r9,5
80103740:	01000104 	movi	r4,4
80103744:	21003fcc 	andi	r4,r4,255
80103748:	200f883a 	mov	r7,r4
8010374c:	0011883a 	mov	r8,zero
80103750:	3808d6fa 	srli	r4,r7,27
80103754:	4006917a 	slli	r3,r8,5
80103758:	20c6b03a 	or	r3,r4,r3
8010375c:	3804917a 	slli	r2,r7,5
80103760:	00800104 	movi	r2,4
80103764:	10803fcc 	andi	r2,r2,255
80103768:	1085883a 	add	r2,r2,r2
8010376c:	1085883a 	add	r2,r2,r2
80103770:	108000c4 	addi	r2,r2,3
80103774:	108000c4 	addi	r2,r2,3
80103778:	1004d0ba 	srli	r2,r2,2
8010377c:	1085883a 	add	r2,r2,r2
80103780:	1085883a 	add	r2,r2,r2
80103784:	de07c83a 	sub	r3,sp,et
80103788:	1880012e 	bgeu	r3,r2,80103790 <vFeebCh1HandleIrq+0xcc>
8010378c:	003b68fa 	trap	3
80103790:	d8b7c83a 	sub	sp,sp,r2
80103794:	d805883a 	mov	r2,sp
80103798:	108000c4 	addi	r2,r2,3
8010379c:	1004d0ba 	srli	r2,r2,2
801037a0:	1085883a 	add	r2,r2,r2
801037a4:	1085883a 	add	r2,r2,r2
801037a8:	e0bffb15 	stw	r2,-20(fp)
	vFeebCh1IrqFlagBufferEmpty(bIrqEmptyBufferFlags);
801037ac:	e0bffb17 	ldw	r2,-20(fp)
801037b0:	1009883a 	mov	r4,r2
801037b4:	010453c0 	call	8010453c <vFeebCh1IrqFlagBufferEmpty>

	// Check Irq Buffer Empty Flags
	if (bIrqEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag]) {
801037b8:	e0bffb17 	ldw	r2,-20(fp)
801037bc:	10800017 	ldw	r2,0(r2)
801037c0:	10000c26 	beq	r2,zero,801037f4 <vFeebCh1HandleIrq+0x130>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
801037c4:	d0a06817 	ldw	r2,-32352(gp)
801037c8:	e0fffd17 	ldw	r3,-12(fp)
801037cc:	180b883a 	mov	r5,r3
801037d0:	1009883a 	mov	r4,r2
801037d4:	013940c0 	call	8013940c <OSQPost>
801037d8:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
801037dc:	e0bffc03 	ldbu	r2,-16(fp)
801037e0:	10000226 	beq	r2,zero,801037ec <vFeebCh1HandleIrq+0x128>
			vFailRequestDMAFromIRQ(0);
801037e4:	0009883a 	mov	r4,zero
801037e8:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh1IrqFlagClrBufferEmpty(eFeebIrqLeftEmptyBuffer0Flag);
801037ec:	0009883a 	mov	r4,zero
801037f0:	0103f840 	call	80103f84 <vFeebCh1IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag]) {
801037f4:	e0bffb17 	ldw	r2,-20(fp)
801037f8:	10800117 	ldw	r2,4(r2)
801037fc:	10000c26 	beq	r2,zero,80103830 <vFeebCh1HandleIrq+0x16c>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103800:	d0a06817 	ldw	r2,-32352(gp)
80103804:	e0fffd17 	ldw	r3,-12(fp)
80103808:	180b883a 	mov	r5,r3
8010380c:	1009883a 	mov	r4,r2
80103810:	013940c0 	call	8013940c <OSQPost>
80103814:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103818:	e0bffc03 	ldbu	r2,-16(fp)
8010381c:	10000226 	beq	r2,zero,80103828 <vFeebCh1HandleIrq+0x164>
			vFailRequestDMAFromIRQ(0);
80103820:	0009883a 	mov	r4,zero
80103824:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh1IrqFlagClrBufferEmpty(eFeebIrqLeftEmptyBuffer1Flag);
80103828:	01000044 	movi	r4,1
8010382c:	0103f840 	call	80103f84 <vFeebCh1IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag]) {
80103830:	e0bffb17 	ldw	r2,-20(fp)
80103834:	10800217 	ldw	r2,8(r2)
80103838:	10000c26 	beq	r2,zero,8010386c <vFeebCh1HandleIrq+0x1a8>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
8010383c:	d0a06817 	ldw	r2,-32352(gp)
80103840:	e0fffd17 	ldw	r3,-12(fp)
80103844:	180b883a 	mov	r5,r3
80103848:	1009883a 	mov	r4,r2
8010384c:	013940c0 	call	8013940c <OSQPost>
80103850:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103854:	e0bffc03 	ldbu	r2,-16(fp)
80103858:	10000226 	beq	r2,zero,80103864 <vFeebCh1HandleIrq+0x1a0>
			vFailRequestDMAFromIRQ(0);
8010385c:	0009883a 	mov	r4,zero
80103860:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh1IrqFlagClrBufferEmpty(eFeebIrqRightEmptyBuffer0Flag);
80103864:	01000084 	movi	r4,2
80103868:	0103f840 	call	80103f84 <vFeebCh1IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag]) {
8010386c:	e0bffb17 	ldw	r2,-20(fp)
80103870:	10800317 	ldw	r2,12(r2)
80103874:	10000c26 	beq	r2,zero,801038a8 <vFeebCh1HandleIrq+0x1e4>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103878:	d0a06817 	ldw	r2,-32352(gp)
8010387c:	e0fffd17 	ldw	r3,-12(fp)
80103880:	180b883a 	mov	r5,r3
80103884:	1009883a 	mov	r4,r2
80103888:	013940c0 	call	8013940c <OSQPost>
8010388c:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103890:	e0bffc03 	ldbu	r2,-16(fp)
80103894:	10000226 	beq	r2,zero,801038a0 <vFeebCh1HandleIrq+0x1dc>
			vFailRequestDMAFromIRQ(0);
80103898:	0009883a 	mov	r4,zero
8010389c:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh1IrqFlagClrBufferEmpty(eFeebIrqRightEmptyBuffer1Flag);
801038a0:	010000c4 	movi	r4,3
801038a4:	0103f840 	call	80103f84 <vFeebCh1IrqFlagClrBufferEmpty>
801038a8:	8037883a 	mov	sp,r16
	if (xDefaults.usiDebugLevel <= dlMinorMessage) {
		fprintf(fp, "IntF0\n");
	}
#endif

}
801038ac:	0001883a 	nop
801038b0:	e6ffff04 	addi	sp,fp,-4
801038b4:	dfc00217 	ldw	ra,8(sp)
801038b8:	df000117 	ldw	fp,4(sp)
801038bc:	dc000017 	ldw	r16,0(sp)
801038c0:	dec00304 	addi	sp,sp,12
801038c4:	f800283a 	ret

801038c8 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
801038c8:	defff804 	addi	sp,sp,-32
801038cc:	de00012e 	bgeu	sp,et,801038d4 <vFeebCh2HandleIrq+0xc>
801038d0:	003b68fa 	trap	3
801038d4:	dfc00715 	stw	ra,28(sp)
801038d8:	df000615 	stw	fp,24(sp)
801038dc:	dc000515 	stw	r16,20(sp)
801038e0:	df000604 	addi	fp,sp,24
801038e4:	e13ffe15 	stw	r4,-8(fp)
801038e8:	d809883a 	mov	r4,sp
801038ec:	2021883a 	mov	r16,r4
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
801038f0:	01000404 	movi	r4,16
801038f4:	e13ffdc5 	stb	r4,-9(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
801038f8:	013fe004 	movi	r4,-128
801038fc:	e13ffd85 	stb	r4,-10(fp)
	uiCmdtoSend.ucByte[1] = 0;
80103900:	e03ffd45 	stb	zero,-11(fp)
	//uiCmdtoSend.ucByte[0] = 1;
	uiCmdtoSend.ucByte[0] = xDefaultsCH.ucChannelToFEE[1];
80103904:	012005b4 	movhi	r4,32790
80103908:	213a3204 	addi	r4,r4,-5944
8010390c:	21000043 	ldbu	r4,1(r4)
80103910:	e13ffd05 	stb	r4,-12(fp)

	// Get Irq Buffer Empty Flags
	bool bIrqEmptyBufferFlags[ucFeebIrqEmptyBufferFlagsQtd];
80103914:	01000104 	movi	r4,4
80103918:	21003fcc 	andi	r4,r4,255
8010391c:	213fffc4 	addi	r4,r4,-1
80103920:	e13ffa15 	stw	r4,-24(fp)
80103924:	01000104 	movi	r4,4
80103928:	21003fcc 	andi	r4,r4,255
8010392c:	2013883a 	mov	r9,r4
80103930:	0015883a 	mov	r10,zero
80103934:	4808d6fa 	srli	r4,r9,27
80103938:	500c917a 	slli	r6,r10,5
8010393c:	218cb03a 	or	r6,r4,r6
80103940:	480a917a 	slli	r5,r9,5
80103944:	01000104 	movi	r4,4
80103948:	21003fcc 	andi	r4,r4,255
8010394c:	200f883a 	mov	r7,r4
80103950:	0011883a 	mov	r8,zero
80103954:	3808d6fa 	srli	r4,r7,27
80103958:	4006917a 	slli	r3,r8,5
8010395c:	20c6b03a 	or	r3,r4,r3
80103960:	3804917a 	slli	r2,r7,5
80103964:	00800104 	movi	r2,4
80103968:	10803fcc 	andi	r2,r2,255
8010396c:	1085883a 	add	r2,r2,r2
80103970:	1085883a 	add	r2,r2,r2
80103974:	108000c4 	addi	r2,r2,3
80103978:	108000c4 	addi	r2,r2,3
8010397c:	1004d0ba 	srli	r2,r2,2
80103980:	1085883a 	add	r2,r2,r2
80103984:	1085883a 	add	r2,r2,r2
80103988:	de07c83a 	sub	r3,sp,et
8010398c:	1880012e 	bgeu	r3,r2,80103994 <vFeebCh2HandleIrq+0xcc>
80103990:	003b68fa 	trap	3
80103994:	d8b7c83a 	sub	sp,sp,r2
80103998:	d805883a 	mov	r2,sp
8010399c:	108000c4 	addi	r2,r2,3
801039a0:	1004d0ba 	srli	r2,r2,2
801039a4:	1085883a 	add	r2,r2,r2
801039a8:	1085883a 	add	r2,r2,r2
801039ac:	e0bffb15 	stw	r2,-20(fp)
	vFeebCh2IrqFlagBufferEmpty(bIrqEmptyBufferFlags);
801039b0:	e0bffb17 	ldw	r2,-20(fp)
801039b4:	1009883a 	mov	r4,r2
801039b8:	01046380 	call	80104638 <vFeebCh2IrqFlagBufferEmpty>

	// Check Irq Buffer Empty Flags
	if (bIrqEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag]) {
801039bc:	e0bffb17 	ldw	r2,-20(fp)
801039c0:	10800017 	ldw	r2,0(r2)
801039c4:	10000c26 	beq	r2,zero,801039f8 <vFeebCh2HandleIrq+0x130>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
801039c8:	d0a06817 	ldw	r2,-32352(gp)
801039cc:	e0fffd17 	ldw	r3,-12(fp)
801039d0:	180b883a 	mov	r5,r3
801039d4:	1009883a 	mov	r4,r2
801039d8:	013940c0 	call	8013940c <OSQPost>
801039dc:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
801039e0:	e0bffc03 	ldbu	r2,-16(fp)
801039e4:	10000226 	beq	r2,zero,801039f0 <vFeebCh2HandleIrq+0x128>
			vFailRequestDMAFromIRQ(0);
801039e8:	0009883a 	mov	r4,zero
801039ec:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh2IrqFlagClrBufferEmpty(eFeebIrqLeftEmptyBuffer0Flag);
801039f0:	0009883a 	mov	r4,zero
801039f4:	010403c0 	call	8010403c <vFeebCh2IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag]) {
801039f8:	e0bffb17 	ldw	r2,-20(fp)
801039fc:	10800117 	ldw	r2,4(r2)
80103a00:	10000c26 	beq	r2,zero,80103a34 <vFeebCh2HandleIrq+0x16c>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103a04:	d0a06817 	ldw	r2,-32352(gp)
80103a08:	e0fffd17 	ldw	r3,-12(fp)
80103a0c:	180b883a 	mov	r5,r3
80103a10:	1009883a 	mov	r4,r2
80103a14:	013940c0 	call	8013940c <OSQPost>
80103a18:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103a1c:	e0bffc03 	ldbu	r2,-16(fp)
80103a20:	10000226 	beq	r2,zero,80103a2c <vFeebCh2HandleIrq+0x164>
			vFailRequestDMAFromIRQ(0);
80103a24:	0009883a 	mov	r4,zero
80103a28:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh2IrqFlagClrBufferEmpty(eFeebIrqLeftEmptyBuffer1Flag);
80103a2c:	01000044 	movi	r4,1
80103a30:	010403c0 	call	8010403c <vFeebCh2IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag]) {
80103a34:	e0bffb17 	ldw	r2,-20(fp)
80103a38:	10800217 	ldw	r2,8(r2)
80103a3c:	10000c26 	beq	r2,zero,80103a70 <vFeebCh2HandleIrq+0x1a8>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103a40:	d0a06817 	ldw	r2,-32352(gp)
80103a44:	e0fffd17 	ldw	r3,-12(fp)
80103a48:	180b883a 	mov	r5,r3
80103a4c:	1009883a 	mov	r4,r2
80103a50:	013940c0 	call	8013940c <OSQPost>
80103a54:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103a58:	e0bffc03 	ldbu	r2,-16(fp)
80103a5c:	10000226 	beq	r2,zero,80103a68 <vFeebCh2HandleIrq+0x1a0>
			vFailRequestDMAFromIRQ(1);
80103a60:	01000044 	movi	r4,1
80103a64:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh2IrqFlagClrBufferEmpty(eFeebIrqRightEmptyBuffer0Flag);
80103a68:	01000084 	movi	r4,2
80103a6c:	010403c0 	call	8010403c <vFeebCh2IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag]) {
80103a70:	e0bffb17 	ldw	r2,-20(fp)
80103a74:	10800317 	ldw	r2,12(r2)
80103a78:	10000c26 	beq	r2,zero,80103aac <vFeebCh2HandleIrq+0x1e4>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103a7c:	d0a06817 	ldw	r2,-32352(gp)
80103a80:	e0fffd17 	ldw	r3,-12(fp)
80103a84:	180b883a 	mov	r5,r3
80103a88:	1009883a 	mov	r4,r2
80103a8c:	013940c0 	call	8013940c <OSQPost>
80103a90:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103a94:	e0bffc03 	ldbu	r2,-16(fp)
80103a98:	10000226 	beq	r2,zero,80103aa4 <vFeebCh2HandleIrq+0x1dc>
			vFailRequestDMAFromIRQ(0);
80103a9c:	0009883a 	mov	r4,zero
80103aa0:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh2IrqFlagClrBufferEmpty(eFeebIrqRightEmptyBuffer1Flag);
80103aa4:	010000c4 	movi	r4,3
80103aa8:	010403c0 	call	8010403c <vFeebCh2IrqFlagClrBufferEmpty>
80103aac:	8037883a 	mov	sp,r16
	if (xDefaults.usiDebugLevel <= dlMinorMessage) {
		fprintf(fp, "IntF1\n");
	}
#endif

}
80103ab0:	0001883a 	nop
80103ab4:	e6ffff04 	addi	sp,fp,-4
80103ab8:	dfc00217 	ldw	ra,8(sp)
80103abc:	df000117 	ldw	fp,4(sp)
80103ac0:	dc000017 	ldw	r16,0(sp)
80103ac4:	dec00304 	addi	sp,sp,12
80103ac8:	f800283a 	ret

80103acc <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
80103acc:	defff804 	addi	sp,sp,-32
80103ad0:	de00012e 	bgeu	sp,et,80103ad8 <vFeebCh3HandleIrq+0xc>
80103ad4:	003b68fa 	trap	3
80103ad8:	dfc00715 	stw	ra,28(sp)
80103adc:	df000615 	stw	fp,24(sp)
80103ae0:	dc000515 	stw	r16,20(sp)
80103ae4:	df000604 	addi	fp,sp,24
80103ae8:	e13ffe15 	stw	r4,-8(fp)
80103aec:	d809883a 	mov	r4,sp
80103af0:	2021883a 	mov	r16,r4
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
80103af4:	01000404 	movi	r4,16
80103af8:	e13ffdc5 	stb	r4,-9(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
80103afc:	013fe004 	movi	r4,-128
80103b00:	e13ffd85 	stb	r4,-10(fp)
	uiCmdtoSend.ucByte[1] = 0;
80103b04:	e03ffd45 	stb	zero,-11(fp)
	//uiCmdtoSend.ucByte[0] = 2;
	uiCmdtoSend.ucByte[0] = xDefaultsCH.ucChannelToFEE[2];
80103b08:	012005b4 	movhi	r4,32790
80103b0c:	213a3204 	addi	r4,r4,-5944
80103b10:	21000083 	ldbu	r4,2(r4)
80103b14:	e13ffd05 	stb	r4,-12(fp)

	// Get Irq Buffer Empty Flags
	bool bIrqEmptyBufferFlags[ucFeebIrqEmptyBufferFlagsQtd];
80103b18:	01000104 	movi	r4,4
80103b1c:	21003fcc 	andi	r4,r4,255
80103b20:	213fffc4 	addi	r4,r4,-1
80103b24:	e13ffa15 	stw	r4,-24(fp)
80103b28:	01000104 	movi	r4,4
80103b2c:	21003fcc 	andi	r4,r4,255
80103b30:	2013883a 	mov	r9,r4
80103b34:	0015883a 	mov	r10,zero
80103b38:	4808d6fa 	srli	r4,r9,27
80103b3c:	500c917a 	slli	r6,r10,5
80103b40:	218cb03a 	or	r6,r4,r6
80103b44:	480a917a 	slli	r5,r9,5
80103b48:	01000104 	movi	r4,4
80103b4c:	21003fcc 	andi	r4,r4,255
80103b50:	200f883a 	mov	r7,r4
80103b54:	0011883a 	mov	r8,zero
80103b58:	3808d6fa 	srli	r4,r7,27
80103b5c:	4006917a 	slli	r3,r8,5
80103b60:	20c6b03a 	or	r3,r4,r3
80103b64:	3804917a 	slli	r2,r7,5
80103b68:	00800104 	movi	r2,4
80103b6c:	10803fcc 	andi	r2,r2,255
80103b70:	1085883a 	add	r2,r2,r2
80103b74:	1085883a 	add	r2,r2,r2
80103b78:	108000c4 	addi	r2,r2,3
80103b7c:	108000c4 	addi	r2,r2,3
80103b80:	1004d0ba 	srli	r2,r2,2
80103b84:	1085883a 	add	r2,r2,r2
80103b88:	1085883a 	add	r2,r2,r2
80103b8c:	de07c83a 	sub	r3,sp,et
80103b90:	1880012e 	bgeu	r3,r2,80103b98 <vFeebCh3HandleIrq+0xcc>
80103b94:	003b68fa 	trap	3
80103b98:	d8b7c83a 	sub	sp,sp,r2
80103b9c:	d805883a 	mov	r2,sp
80103ba0:	108000c4 	addi	r2,r2,3
80103ba4:	1004d0ba 	srli	r2,r2,2
80103ba8:	1085883a 	add	r2,r2,r2
80103bac:	1085883a 	add	r2,r2,r2
80103bb0:	e0bffb15 	stw	r2,-20(fp)
	vFeebCh3IrqFlagBufferEmpty(bIrqEmptyBufferFlags);
80103bb4:	e0bffb17 	ldw	r2,-20(fp)
80103bb8:	1009883a 	mov	r4,r2
80103bbc:	01047340 	call	80104734 <vFeebCh3IrqFlagBufferEmpty>

	// Check Irq Buffer Empty Flags
	if (bIrqEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag]) {
80103bc0:	e0bffb17 	ldw	r2,-20(fp)
80103bc4:	10800017 	ldw	r2,0(r2)
80103bc8:	10000c26 	beq	r2,zero,80103bfc <vFeebCh3HandleIrq+0x130>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103bcc:	d0a06817 	ldw	r2,-32352(gp)
80103bd0:	e0fffd17 	ldw	r3,-12(fp)
80103bd4:	180b883a 	mov	r5,r3
80103bd8:	1009883a 	mov	r4,r2
80103bdc:	013940c0 	call	8013940c <OSQPost>
80103be0:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103be4:	e0bffc03 	ldbu	r2,-16(fp)
80103be8:	10000226 	beq	r2,zero,80103bf4 <vFeebCh3HandleIrq+0x128>
			vFailRequestDMAFromIRQ(0);
80103bec:	0009883a 	mov	r4,zero
80103bf0:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh3IrqFlagClrBufferEmpty(eFeebIrqLeftEmptyBuffer0Flag);
80103bf4:	0009883a 	mov	r4,zero
80103bf8:	01040f40 	call	801040f4 <vFeebCh3IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag]) {
80103bfc:	e0bffb17 	ldw	r2,-20(fp)
80103c00:	10800117 	ldw	r2,4(r2)
80103c04:	10000c26 	beq	r2,zero,80103c38 <vFeebCh3HandleIrq+0x16c>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103c08:	d0a06817 	ldw	r2,-32352(gp)
80103c0c:	e0fffd17 	ldw	r3,-12(fp)
80103c10:	180b883a 	mov	r5,r3
80103c14:	1009883a 	mov	r4,r2
80103c18:	013940c0 	call	8013940c <OSQPost>
80103c1c:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103c20:	e0bffc03 	ldbu	r2,-16(fp)
80103c24:	10000226 	beq	r2,zero,80103c30 <vFeebCh3HandleIrq+0x164>
			vFailRequestDMAFromIRQ(0);
80103c28:	0009883a 	mov	r4,zero
80103c2c:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh3IrqFlagClrBufferEmpty(eFeebIrqLeftEmptyBuffer1Flag);
80103c30:	01000044 	movi	r4,1
80103c34:	01040f40 	call	801040f4 <vFeebCh3IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag]) {
80103c38:	e0bffb17 	ldw	r2,-20(fp)
80103c3c:	10800217 	ldw	r2,8(r2)
80103c40:	10000c26 	beq	r2,zero,80103c74 <vFeebCh3HandleIrq+0x1a8>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103c44:	d0a06817 	ldw	r2,-32352(gp)
80103c48:	e0fffd17 	ldw	r3,-12(fp)
80103c4c:	180b883a 	mov	r5,r3
80103c50:	1009883a 	mov	r4,r2
80103c54:	013940c0 	call	8013940c <OSQPost>
80103c58:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103c5c:	e0bffc03 	ldbu	r2,-16(fp)
80103c60:	10000226 	beq	r2,zero,80103c6c <vFeebCh3HandleIrq+0x1a0>
			vFailRequestDMAFromIRQ(1);
80103c64:	01000044 	movi	r4,1
80103c68:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh3IrqFlagClrBufferEmpty(eFeebIrqRightEmptyBuffer0Flag);
80103c6c:	01000084 	movi	r4,2
80103c70:	01040f40 	call	801040f4 <vFeebCh3IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag]) {
80103c74:	e0bffb17 	ldw	r2,-20(fp)
80103c78:	10800317 	ldw	r2,12(r2)
80103c7c:	10000c26 	beq	r2,zero,80103cb0 <vFeebCh3HandleIrq+0x1e4>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103c80:	d0a06817 	ldw	r2,-32352(gp)
80103c84:	e0fffd17 	ldw	r3,-12(fp)
80103c88:	180b883a 	mov	r5,r3
80103c8c:	1009883a 	mov	r4,r2
80103c90:	013940c0 	call	8013940c <OSQPost>
80103c94:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103c98:	e0bffc03 	ldbu	r2,-16(fp)
80103c9c:	10000226 	beq	r2,zero,80103ca8 <vFeebCh3HandleIrq+0x1dc>
			vFailRequestDMAFromIRQ(0);
80103ca0:	0009883a 	mov	r4,zero
80103ca4:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh3IrqFlagClrBufferEmpty(eFeebIrqRightEmptyBuffer1Flag);
80103ca8:	010000c4 	movi	r4,3
80103cac:	01040f40 	call	801040f4 <vFeebCh3IrqFlagClrBufferEmpty>
80103cb0:	8037883a 	mov	sp,r16
#if DEBUG_ON
	if (xDefaults.usiDebugLevel <= dlMinorMessage) {
		fprintf(fp, "IntF2\n");
	}
#endif
}
80103cb4:	0001883a 	nop
80103cb8:	e6ffff04 	addi	sp,fp,-4
80103cbc:	dfc00217 	ldw	ra,8(sp)
80103cc0:	df000117 	ldw	fp,4(sp)
80103cc4:	dc000017 	ldw	r16,0(sp)
80103cc8:	dec00304 	addi	sp,sp,12
80103ccc:	f800283a 	ret

80103cd0 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
80103cd0:	defff804 	addi	sp,sp,-32
80103cd4:	de00012e 	bgeu	sp,et,80103cdc <vFeebCh4HandleIrq+0xc>
80103cd8:	003b68fa 	trap	3
80103cdc:	dfc00715 	stw	ra,28(sp)
80103ce0:	df000615 	stw	fp,24(sp)
80103ce4:	dc000515 	stw	r16,20(sp)
80103ce8:	df000604 	addi	fp,sp,24
80103cec:	e13ffe15 	stw	r4,-8(fp)
80103cf0:	d809883a 	mov	r4,sp
80103cf4:	2021883a 	mov	r16,r4
	//volatile int* pviHoldContext = (volatile int*) pvContext;

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
80103cf8:	01000404 	movi	r4,16
80103cfc:	e13ffdc5 	stb	r4,-9(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
80103d00:	013fe004 	movi	r4,-128
80103d04:	e13ffd85 	stb	r4,-10(fp)
	uiCmdtoSend.ucByte[1] = 0;
80103d08:	e03ffd45 	stb	zero,-11(fp)
	//uiCmdtoSend.ucByte[0] = 3;
	uiCmdtoSend.ucByte[0] = xDefaultsCH.ucChannelToFEE[3];
80103d0c:	012005b4 	movhi	r4,32790
80103d10:	213a3204 	addi	r4,r4,-5944
80103d14:	210000c3 	ldbu	r4,3(r4)
80103d18:	e13ffd05 	stb	r4,-12(fp)

	// Get Irq Buffer Empty Flags
	bool bIrqEmptyBufferFlags[ucFeebIrqEmptyBufferFlagsQtd];
80103d1c:	01000104 	movi	r4,4
80103d20:	21003fcc 	andi	r4,r4,255
80103d24:	213fffc4 	addi	r4,r4,-1
80103d28:	e13ffa15 	stw	r4,-24(fp)
80103d2c:	01000104 	movi	r4,4
80103d30:	21003fcc 	andi	r4,r4,255
80103d34:	2013883a 	mov	r9,r4
80103d38:	0015883a 	mov	r10,zero
80103d3c:	4808d6fa 	srli	r4,r9,27
80103d40:	500c917a 	slli	r6,r10,5
80103d44:	218cb03a 	or	r6,r4,r6
80103d48:	480a917a 	slli	r5,r9,5
80103d4c:	01000104 	movi	r4,4
80103d50:	21003fcc 	andi	r4,r4,255
80103d54:	200f883a 	mov	r7,r4
80103d58:	0011883a 	mov	r8,zero
80103d5c:	3808d6fa 	srli	r4,r7,27
80103d60:	4006917a 	slli	r3,r8,5
80103d64:	20c6b03a 	or	r3,r4,r3
80103d68:	3804917a 	slli	r2,r7,5
80103d6c:	00800104 	movi	r2,4
80103d70:	10803fcc 	andi	r2,r2,255
80103d74:	1085883a 	add	r2,r2,r2
80103d78:	1085883a 	add	r2,r2,r2
80103d7c:	108000c4 	addi	r2,r2,3
80103d80:	108000c4 	addi	r2,r2,3
80103d84:	1004d0ba 	srli	r2,r2,2
80103d88:	1085883a 	add	r2,r2,r2
80103d8c:	1085883a 	add	r2,r2,r2
80103d90:	de07c83a 	sub	r3,sp,et
80103d94:	1880012e 	bgeu	r3,r2,80103d9c <vFeebCh4HandleIrq+0xcc>
80103d98:	003b68fa 	trap	3
80103d9c:	d8b7c83a 	sub	sp,sp,r2
80103da0:	d805883a 	mov	r2,sp
80103da4:	108000c4 	addi	r2,r2,3
80103da8:	1004d0ba 	srli	r2,r2,2
80103dac:	1085883a 	add	r2,r2,r2
80103db0:	1085883a 	add	r2,r2,r2
80103db4:	e0bffb15 	stw	r2,-20(fp)
	vFeebCh4IrqFlagBufferEmpty(bIrqEmptyBufferFlags);
80103db8:	e0bffb17 	ldw	r2,-20(fp)
80103dbc:	1009883a 	mov	r4,r2
80103dc0:	01048300 	call	80104830 <vFeebCh4IrqFlagBufferEmpty>

	// Check Irq Buffer Empty Flags
	if (bIrqEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag]) {
80103dc4:	e0bffb17 	ldw	r2,-20(fp)
80103dc8:	10800017 	ldw	r2,0(r2)
80103dcc:	10000c26 	beq	r2,zero,80103e00 <vFeebCh4HandleIrq+0x130>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103dd0:	d0a06817 	ldw	r2,-32352(gp)
80103dd4:	e0fffd17 	ldw	r3,-12(fp)
80103dd8:	180b883a 	mov	r5,r3
80103ddc:	1009883a 	mov	r4,r2
80103de0:	013940c0 	call	8013940c <OSQPost>
80103de4:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103de8:	e0bffc03 	ldbu	r2,-16(fp)
80103dec:	10000226 	beq	r2,zero,80103df8 <vFeebCh4HandleIrq+0x128>
			vFailRequestDMAFromIRQ(0);
80103df0:	0009883a 	mov	r4,zero
80103df4:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh4IrqFlagClrBufferEmpty(eFeebIrqLeftEmptyBuffer0Flag);
80103df8:	0009883a 	mov	r4,zero
80103dfc:	01041ac0 	call	801041ac <vFeebCh4IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag]) {
80103e00:	e0bffb17 	ldw	r2,-20(fp)
80103e04:	10800117 	ldw	r2,4(r2)
80103e08:	10000c26 	beq	r2,zero,80103e3c <vFeebCh4HandleIrq+0x16c>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103e0c:	d0a06817 	ldw	r2,-32352(gp)
80103e10:	e0fffd17 	ldw	r3,-12(fp)
80103e14:	180b883a 	mov	r5,r3
80103e18:	1009883a 	mov	r4,r2
80103e1c:	013940c0 	call	8013940c <OSQPost>
80103e20:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103e24:	e0bffc03 	ldbu	r2,-16(fp)
80103e28:	10000226 	beq	r2,zero,80103e34 <vFeebCh4HandleIrq+0x164>
			vFailRequestDMAFromIRQ(0);
80103e2c:	0009883a 	mov	r4,zero
80103e30:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh4IrqFlagClrBufferEmpty(eFeebIrqLeftEmptyBuffer1Flag);
80103e34:	01000044 	movi	r4,1
80103e38:	01041ac0 	call	801041ac <vFeebCh4IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag]) {
80103e3c:	e0bffb17 	ldw	r2,-20(fp)
80103e40:	10800217 	ldw	r2,8(r2)
80103e44:	10000c26 	beq	r2,zero,80103e78 <vFeebCh4HandleIrq+0x1a8>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103e48:	d0a06817 	ldw	r2,-32352(gp)
80103e4c:	e0fffd17 	ldw	r3,-12(fp)
80103e50:	180b883a 	mov	r5,r3
80103e54:	1009883a 	mov	r4,r2
80103e58:	013940c0 	call	8013940c <OSQPost>
80103e5c:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103e60:	e0bffc03 	ldbu	r2,-16(fp)
80103e64:	10000226 	beq	r2,zero,80103e70 <vFeebCh4HandleIrq+0x1a0>
			vFailRequestDMAFromIRQ(1);
80103e68:	01000044 	movi	r4,1
80103e6c:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh4IrqFlagClrBufferEmpty(eFeebIrqRightEmptyBuffer0Flag);
80103e70:	01000084 	movi	r4,2
80103e74:	01041ac0 	call	801041ac <vFeebCh4IrqFlagClrBufferEmpty>
	}
	if (bIrqEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag]) {
80103e78:	e0bffb17 	ldw	r2,-20(fp)
80103e7c:	10800317 	ldw	r2,12(r2)
80103e80:	10000c26 	beq	r2,zero,80103eb4 <vFeebCh4HandleIrq+0x1e4>

		/*Sync the Meb task and tell that has a PUS command waiting*/
		error_codel = OSQPost(xNfeeSchedule, (void *) uiCmdtoSend.ulWord);
80103e84:	d0a06817 	ldw	r2,-32352(gp)
80103e88:	e0fffd17 	ldw	r3,-12(fp)
80103e8c:	180b883a 	mov	r5,r3
80103e90:	1009883a 	mov	r4,r2
80103e94:	013940c0 	call	8013940c <OSQPost>
80103e98:	e0bffc05 	stb	r2,-16(fp)
		if (error_codel != OS_ERR_NONE) {
80103e9c:	e0bffc03 	ldbu	r2,-16(fp)
80103ea0:	10000226 	beq	r2,zero,80103eac <vFeebCh4HandleIrq+0x1dc>
			vFailRequestDMAFromIRQ(0);
80103ea4:	0009883a 	mov	r4,zero
80103ea8:	011da380 	call	8011da38 <vFailRequestDMAFromIRQ>
		}

		vFeebCh4IrqFlagClrBufferEmpty(eFeebIrqRightEmptyBuffer1Flag);
80103eac:	010000c4 	movi	r4,3
80103eb0:	01041ac0 	call	801041ac <vFeebCh4IrqFlagClrBufferEmpty>
80103eb4:	8037883a 	mov	sp,r16
#if DEBUG_ON
	if (xDefaults.usiDebugLevel <= dlMinorMessage) {
		fprintf(fp, "IntF3\n");
	}
#endif
}
80103eb8:	0001883a 	nop
80103ebc:	e6ffff04 	addi	sp,fp,-4
80103ec0:	dfc00217 	ldw	ra,8(sp)
80103ec4:	df000117 	ldw	fp,4(sp)
80103ec8:	dc000017 	ldw	r16,0(sp)
80103ecc:	dec00304 	addi	sp,sp,12
80103ed0:	f800283a 	ret

80103ed4 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
80103ed4:	defffe04 	addi	sp,sp,-8
80103ed8:	de00012e 	bgeu	sp,et,80103ee0 <vFeebCh5HandleIrq+0xc>
80103edc:	003b68fa 	trap	3
80103ee0:	df000115 	stw	fp,4(sp)
80103ee4:	df000104 	addi	fp,sp,4
80103ee8:	e13fff15 	stw	r4,-4(fp)
//	if (xDefaults.usiDebugLevel <= dlMinorMessage) {
//		fprintf(fp, "IntF4\n");
//	}
//#endif

}
80103eec:	0001883a 	nop
80103ef0:	e037883a 	mov	sp,fp
80103ef4:	df000017 	ldw	fp,0(sp)
80103ef8:	dec00104 	addi	sp,sp,4
80103efc:	f800283a 	ret

80103f00 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
80103f00:	defffe04 	addi	sp,sp,-8
80103f04:	de00012e 	bgeu	sp,et,80103f0c <vFeebCh6HandleIrq+0xc>
80103f08:	003b68fa 	trap	3
80103f0c:	df000115 	stw	fp,4(sp)
80103f10:	df000104 	addi	fp,sp,4
80103f14:	e13fff15 	stw	r4,-4(fp)
//	if (xDefaults.usiDebugLevel <= dlMinorMessage) {
//		fprintf(fp, "IntF5\n");
//	}
//#endif

}
80103f18:	0001883a 	nop
80103f1c:	e037883a 	mov	sp,fp
80103f20:	df000017 	ldw	fp,0(sp)
80103f24:	dec00104 	addi	sp,sp,4
80103f28:	f800283a 	ret

80103f2c <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
80103f2c:	defffe04 	addi	sp,sp,-8
80103f30:	de00012e 	bgeu	sp,et,80103f38 <vFeebCh7HandleIrq+0xc>
80103f34:	003b68fa 	trap	3
80103f38:	df000115 	stw	fp,4(sp)
80103f3c:	df000104 	addi	fp,sp,4
80103f40:	e13fff15 	stw	r4,-4(fp)
//	if (xDefaults.usiDebugLevel <= dlMinorMessage) {
//		fprintf(fp, "IntF6\n");
//	}
//#endif

}
80103f44:	0001883a 	nop
80103f48:	e037883a 	mov	sp,fp
80103f4c:	df000017 	ldw	fp,0(sp)
80103f50:	dec00104 	addi	sp,sp,4
80103f54:	f800283a 	ret

80103f58 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
80103f58:	defffe04 	addi	sp,sp,-8
80103f5c:	de00012e 	bgeu	sp,et,80103f64 <vFeebCh8HandleIrq+0xc>
80103f60:	003b68fa 	trap	3
80103f64:	df000115 	stw	fp,4(sp)
80103f68:	df000104 	addi	fp,sp,4
80103f6c:	e13fff15 	stw	r4,-4(fp)
//	if (xDefaults.usiDebugLevel <= dlMinorMessage) {
//		fprintf(fp, "IntF7\n");
//	}
//#endif

}
80103f70:	0001883a 	nop
80103f74:	e037883a 	mov	sp,fp
80103f78:	df000017 	ldw	fp,0(sp)
80103f7c:	dec00104 	addi	sp,sp,4
80103f80:	f800283a 	ret

80103f84 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(alt_u8 ucEmptyBufferFlag) {
80103f84:	defffc04 	addi	sp,sp,-16
80103f88:	de00012e 	bgeu	sp,et,80103f90 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
80103f8c:	003b68fa 	trap	3
80103f90:	dfc00315 	stw	ra,12(sp)
80103f94:	df000215 	stw	fp,8(sp)
80103f98:	df000204 	addi	fp,sp,8
80103f9c:	2005883a 	mov	r2,r4
80103fa0:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 uliEmptyFlagClearMask = 0;
80103fa4:	e03ffe15 	stw	zero,-8(fp)

	switch (ucEmptyBufferFlag) {
80103fa8:	e0bfff03 	ldbu	r2,-4(fp)
80103fac:	10c00060 	cmpeqi	r3,r2,1
80103fb0:	18000c1e 	bne	r3,zero,80103fe4 <vFeebCh1IrqFlagClrBufferEmpty+0x60>
80103fb4:	10c00088 	cmpgei	r3,r2,2
80103fb8:	1800021e 	bne	r3,zero,80103fc4 <vFeebCh1IrqFlagClrBufferEmpty+0x40>
80103fbc:	10000626 	beq	r2,zero,80103fd8 <vFeebCh1IrqFlagClrBufferEmpty+0x54>
80103fc0:	00001106 	br	80104008 <vFeebCh1IrqFlagClrBufferEmpty+0x84>
80103fc4:	10c000a0 	cmpeqi	r3,r2,2
80103fc8:	1800091e 	bne	r3,zero,80103ff0 <vFeebCh1IrqFlagClrBufferEmpty+0x6c>
80103fcc:	108000e0 	cmpeqi	r2,r2,3
80103fd0:	10000a1e 	bne	r2,zero,80103ffc <vFeebCh1IrqFlagClrBufferEmpty+0x78>
80103fd4:	00000c06 	br	80104008 <vFeebCh1IrqFlagClrBufferEmpty+0x84>
	case eFeebIrqLeftEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_0_E_FLG_CLR_MSK;
80103fd8:	00810004 	movi	r2,1024
80103fdc:	e0bffe15 	stw	r2,-8(fp)
		break;
80103fe0:	00000b06 	br	80104010 <vFeebCh1IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqLeftEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_1_E_FLG_CLR_MSK;
80103fe4:	00820004 	movi	r2,2048
80103fe8:	e0bffe15 	stw	r2,-8(fp)
		break;
80103fec:	00000806 	br	80104010 <vFeebCh1IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_0_E_FLG_CLR_MSK;
80103ff0:	00804004 	movi	r2,256
80103ff4:	e0bffe15 	stw	r2,-8(fp)
		break;
80103ff8:	00000506 	br	80104010 <vFeebCh1IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_1_E_FLG_CLR_MSK;
80103ffc:	00808004 	movi	r2,512
80104000:	e0bffe15 	stw	r2,-8(fp)
		break;
80104004:	00000206 	br	80104010 <vFeebCh1IrqFlagClrBufferEmpty+0x8c>
	default:
		uliEmptyFlagClearMask = 0;
80104008:	e03ffe15 	stw	zero,-8(fp)
		;
		break;
8010400c:	0001883a 	nop
	}

	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
80104010:	e1bffe17 	ldw	r6,-8(fp)
80104014:	014004c4 	movi	r5,19
80104018:	01101034 	movhi	r4,16448
8010401c:	21030004 	addi	r4,r4,3072
80104020:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_IRQ_FLAGS_CLR_REG_OFST, uliEmptyFlagClearMask);

}
80104024:	0001883a 	nop
80104028:	e037883a 	mov	sp,fp
8010402c:	dfc00117 	ldw	ra,4(sp)
80104030:	df000017 	ldw	fp,0(sp)
80104034:	dec00204 	addi	sp,sp,8
80104038:	f800283a 	ret

8010403c <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(alt_u8 ucEmptyBufferFlag) {
8010403c:	defffc04 	addi	sp,sp,-16
80104040:	de00012e 	bgeu	sp,et,80104048 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
80104044:	003b68fa 	trap	3
80104048:	dfc00315 	stw	ra,12(sp)
8010404c:	df000215 	stw	fp,8(sp)
80104050:	df000204 	addi	fp,sp,8
80104054:	2005883a 	mov	r2,r4
80104058:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 uliEmptyFlagClearMask = 0;
8010405c:	e03ffe15 	stw	zero,-8(fp)

	switch (ucEmptyBufferFlag) {
80104060:	e0bfff03 	ldbu	r2,-4(fp)
80104064:	10c00060 	cmpeqi	r3,r2,1
80104068:	18000c1e 	bne	r3,zero,8010409c <vFeebCh2IrqFlagClrBufferEmpty+0x60>
8010406c:	10c00088 	cmpgei	r3,r2,2
80104070:	1800021e 	bne	r3,zero,8010407c <vFeebCh2IrqFlagClrBufferEmpty+0x40>
80104074:	10000626 	beq	r2,zero,80104090 <vFeebCh2IrqFlagClrBufferEmpty+0x54>
80104078:	00001106 	br	801040c0 <vFeebCh2IrqFlagClrBufferEmpty+0x84>
8010407c:	10c000a0 	cmpeqi	r3,r2,2
80104080:	1800091e 	bne	r3,zero,801040a8 <vFeebCh2IrqFlagClrBufferEmpty+0x6c>
80104084:	108000e0 	cmpeqi	r2,r2,3
80104088:	10000a1e 	bne	r2,zero,801040b4 <vFeebCh2IrqFlagClrBufferEmpty+0x78>
8010408c:	00000c06 	br	801040c0 <vFeebCh2IrqFlagClrBufferEmpty+0x84>
	case eFeebIrqLeftEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_0_E_FLG_CLR_MSK;
80104090:	00810004 	movi	r2,1024
80104094:	e0bffe15 	stw	r2,-8(fp)
		break;
80104098:	00000b06 	br	801040c8 <vFeebCh2IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqLeftEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_1_E_FLG_CLR_MSK;
8010409c:	00820004 	movi	r2,2048
801040a0:	e0bffe15 	stw	r2,-8(fp)
		break;
801040a4:	00000806 	br	801040c8 <vFeebCh2IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_0_E_FLG_CLR_MSK;
801040a8:	00804004 	movi	r2,256
801040ac:	e0bffe15 	stw	r2,-8(fp)
		break;
801040b0:	00000506 	br	801040c8 <vFeebCh2IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_1_E_FLG_CLR_MSK;
801040b4:	00808004 	movi	r2,512
801040b8:	e0bffe15 	stw	r2,-8(fp)
		break;
801040bc:	00000206 	br	801040c8 <vFeebCh2IrqFlagClrBufferEmpty+0x8c>
	default:
		uliEmptyFlagClearMask = 0;
801040c0:	e03ffe15 	stw	zero,-8(fp)
		;
		break;
801040c4:	0001883a 	nop
	}

	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
801040c8:	e1bffe17 	ldw	r6,-8(fp)
801040cc:	014004c4 	movi	r5,19
801040d0:	01101034 	movhi	r4,16448
801040d4:	21020004 	addi	r4,r4,2048
801040d8:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_IRQ_FLAGS_CLR_REG_OFST, uliEmptyFlagClearMask);

}
801040dc:	0001883a 	nop
801040e0:	e037883a 	mov	sp,fp
801040e4:	dfc00117 	ldw	ra,4(sp)
801040e8:	df000017 	ldw	fp,0(sp)
801040ec:	dec00204 	addi	sp,sp,8
801040f0:	f800283a 	ret

801040f4 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(alt_u8 ucEmptyBufferFlag) {
801040f4:	defffc04 	addi	sp,sp,-16
801040f8:	de00012e 	bgeu	sp,et,80104100 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
801040fc:	003b68fa 	trap	3
80104100:	dfc00315 	stw	ra,12(sp)
80104104:	df000215 	stw	fp,8(sp)
80104108:	df000204 	addi	fp,sp,8
8010410c:	2005883a 	mov	r2,r4
80104110:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 uliEmptyFlagClearMask = 0;
80104114:	e03ffe15 	stw	zero,-8(fp)

	switch (ucEmptyBufferFlag) {
80104118:	e0bfff03 	ldbu	r2,-4(fp)
8010411c:	10c00060 	cmpeqi	r3,r2,1
80104120:	18000c1e 	bne	r3,zero,80104154 <vFeebCh3IrqFlagClrBufferEmpty+0x60>
80104124:	10c00088 	cmpgei	r3,r2,2
80104128:	1800021e 	bne	r3,zero,80104134 <vFeebCh3IrqFlagClrBufferEmpty+0x40>
8010412c:	10000626 	beq	r2,zero,80104148 <vFeebCh3IrqFlagClrBufferEmpty+0x54>
80104130:	00001106 	br	80104178 <vFeebCh3IrqFlagClrBufferEmpty+0x84>
80104134:	10c000a0 	cmpeqi	r3,r2,2
80104138:	1800091e 	bne	r3,zero,80104160 <vFeebCh3IrqFlagClrBufferEmpty+0x6c>
8010413c:	108000e0 	cmpeqi	r2,r2,3
80104140:	10000a1e 	bne	r2,zero,8010416c <vFeebCh3IrqFlagClrBufferEmpty+0x78>
80104144:	00000c06 	br	80104178 <vFeebCh3IrqFlagClrBufferEmpty+0x84>
	case eFeebIrqLeftEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_0_E_FLG_CLR_MSK;
80104148:	00810004 	movi	r2,1024
8010414c:	e0bffe15 	stw	r2,-8(fp)
		break;
80104150:	00000b06 	br	80104180 <vFeebCh3IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqLeftEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_1_E_FLG_CLR_MSK;
80104154:	00820004 	movi	r2,2048
80104158:	e0bffe15 	stw	r2,-8(fp)
		break;
8010415c:	00000806 	br	80104180 <vFeebCh3IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_0_E_FLG_CLR_MSK;
80104160:	00804004 	movi	r2,256
80104164:	e0bffe15 	stw	r2,-8(fp)
		break;
80104168:	00000506 	br	80104180 <vFeebCh3IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_1_E_FLG_CLR_MSK;
8010416c:	00808004 	movi	r2,512
80104170:	e0bffe15 	stw	r2,-8(fp)
		break;
80104174:	00000206 	br	80104180 <vFeebCh3IrqFlagClrBufferEmpty+0x8c>
	default:
		uliEmptyFlagClearMask = 0;
80104178:	e03ffe15 	stw	zero,-8(fp)
		;
		break;
8010417c:	0001883a 	nop
	}

	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
80104180:	e1bffe17 	ldw	r6,-8(fp)
80104184:	014004c4 	movi	r5,19
80104188:	01101034 	movhi	r4,16448
8010418c:	21010004 	addi	r4,r4,1024
80104190:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_IRQ_FLAGS_CLR_REG_OFST, uliEmptyFlagClearMask);

}
80104194:	0001883a 	nop
80104198:	e037883a 	mov	sp,fp
8010419c:	dfc00117 	ldw	ra,4(sp)
801041a0:	df000017 	ldw	fp,0(sp)
801041a4:	dec00204 	addi	sp,sp,8
801041a8:	f800283a 	ret

801041ac <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(alt_u8 ucEmptyBufferFlag) {
801041ac:	defffc04 	addi	sp,sp,-16
801041b0:	de00012e 	bgeu	sp,et,801041b8 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
801041b4:	003b68fa 	trap	3
801041b8:	dfc00315 	stw	ra,12(sp)
801041bc:	df000215 	stw	fp,8(sp)
801041c0:	df000204 	addi	fp,sp,8
801041c4:	2005883a 	mov	r2,r4
801041c8:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 uliEmptyFlagClearMask = 0;
801041cc:	e03ffe15 	stw	zero,-8(fp)

	switch (ucEmptyBufferFlag) {
801041d0:	e0bfff03 	ldbu	r2,-4(fp)
801041d4:	10c00060 	cmpeqi	r3,r2,1
801041d8:	18000c1e 	bne	r3,zero,8010420c <vFeebCh4IrqFlagClrBufferEmpty+0x60>
801041dc:	10c00088 	cmpgei	r3,r2,2
801041e0:	1800021e 	bne	r3,zero,801041ec <vFeebCh4IrqFlagClrBufferEmpty+0x40>
801041e4:	10000626 	beq	r2,zero,80104200 <vFeebCh4IrqFlagClrBufferEmpty+0x54>
801041e8:	00001106 	br	80104230 <vFeebCh4IrqFlagClrBufferEmpty+0x84>
801041ec:	10c000a0 	cmpeqi	r3,r2,2
801041f0:	1800091e 	bne	r3,zero,80104218 <vFeebCh4IrqFlagClrBufferEmpty+0x6c>
801041f4:	108000e0 	cmpeqi	r2,r2,3
801041f8:	10000a1e 	bne	r2,zero,80104224 <vFeebCh4IrqFlagClrBufferEmpty+0x78>
801041fc:	00000c06 	br	80104230 <vFeebCh4IrqFlagClrBufferEmpty+0x84>
	case eFeebIrqLeftEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_0_E_FLG_CLR_MSK;
80104200:	00810004 	movi	r2,1024
80104204:	e0bffe15 	stw	r2,-8(fp)
		break;
80104208:	00000b06 	br	80104238 <vFeebCh4IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqLeftEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_1_E_FLG_CLR_MSK;
8010420c:	00820004 	movi	r2,2048
80104210:	e0bffe15 	stw	r2,-8(fp)
		break;
80104214:	00000806 	br	80104238 <vFeebCh4IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_0_E_FLG_CLR_MSK;
80104218:	00804004 	movi	r2,256
8010421c:	e0bffe15 	stw	r2,-8(fp)
		break;
80104220:	00000506 	br	80104238 <vFeebCh4IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_1_E_FLG_CLR_MSK;
80104224:	00808004 	movi	r2,512
80104228:	e0bffe15 	stw	r2,-8(fp)
		break;
8010422c:	00000206 	br	80104238 <vFeebCh4IrqFlagClrBufferEmpty+0x8c>
	default:
		uliEmptyFlagClearMask = 0;
80104230:	e03ffe15 	stw	zero,-8(fp)
		;
		break;
80104234:	0001883a 	nop
	}

	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
80104238:	e1bffe17 	ldw	r6,-8(fp)
8010423c:	014004c4 	movi	r5,19
80104240:	01101034 	movhi	r4,16448
80104244:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_IRQ_FLAGS_CLR_REG_OFST, uliEmptyFlagClearMask);

}
80104248:	0001883a 	nop
8010424c:	e037883a 	mov	sp,fp
80104250:	dfc00117 	ldw	ra,4(sp)
80104254:	df000017 	ldw	fp,0(sp)
80104258:	dec00204 	addi	sp,sp,8
8010425c:	f800283a 	ret

80104260 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(alt_u8 ucEmptyBufferFlag) {
80104260:	defffc04 	addi	sp,sp,-16
80104264:	de00012e 	bgeu	sp,et,8010426c <vFeebCh5IrqFlagClrBufferEmpty+0xc>
80104268:	003b68fa 	trap	3
8010426c:	dfc00315 	stw	ra,12(sp)
80104270:	df000215 	stw	fp,8(sp)
80104274:	df000204 	addi	fp,sp,8
80104278:	2005883a 	mov	r2,r4
8010427c:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 uliEmptyFlagClearMask = 0;
80104280:	e03ffe15 	stw	zero,-8(fp)

	switch (ucEmptyBufferFlag) {
80104284:	e0bfff03 	ldbu	r2,-4(fp)
80104288:	10c00060 	cmpeqi	r3,r2,1
8010428c:	18000c1e 	bne	r3,zero,801042c0 <vFeebCh5IrqFlagClrBufferEmpty+0x60>
80104290:	10c00088 	cmpgei	r3,r2,2
80104294:	1800021e 	bne	r3,zero,801042a0 <vFeebCh5IrqFlagClrBufferEmpty+0x40>
80104298:	10000626 	beq	r2,zero,801042b4 <vFeebCh5IrqFlagClrBufferEmpty+0x54>
8010429c:	00001106 	br	801042e4 <vFeebCh5IrqFlagClrBufferEmpty+0x84>
801042a0:	10c000a0 	cmpeqi	r3,r2,2
801042a4:	1800091e 	bne	r3,zero,801042cc <vFeebCh5IrqFlagClrBufferEmpty+0x6c>
801042a8:	108000e0 	cmpeqi	r2,r2,3
801042ac:	10000a1e 	bne	r2,zero,801042d8 <vFeebCh5IrqFlagClrBufferEmpty+0x78>
801042b0:	00000c06 	br	801042e4 <vFeebCh5IrqFlagClrBufferEmpty+0x84>
	case eFeebIrqLeftEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_0_E_FLG_CLR_MSK;
801042b4:	00810004 	movi	r2,1024
801042b8:	e0bffe15 	stw	r2,-8(fp)
		break;
801042bc:	00000b06 	br	801042ec <vFeebCh5IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqLeftEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_1_E_FLG_CLR_MSK;
801042c0:	00820004 	movi	r2,2048
801042c4:	e0bffe15 	stw	r2,-8(fp)
		break;
801042c8:	00000806 	br	801042ec <vFeebCh5IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_0_E_FLG_CLR_MSK;
801042cc:	00804004 	movi	r2,256
801042d0:	e0bffe15 	stw	r2,-8(fp)
		break;
801042d4:	00000506 	br	801042ec <vFeebCh5IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_1_E_FLG_CLR_MSK;
801042d8:	00808004 	movi	r2,512
801042dc:	e0bffe15 	stw	r2,-8(fp)
		break;
801042e0:	00000206 	br	801042ec <vFeebCh5IrqFlagClrBufferEmpty+0x8c>
	default:
		uliEmptyFlagClearMask = 0;
801042e4:	e03ffe15 	stw	zero,-8(fp)
		;
		break;
801042e8:	0001883a 	nop
	}

	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
801042ec:	e1bffe17 	ldw	r6,-8(fp)
801042f0:	014004c4 	movi	r5,19
801042f4:	01101034 	movhi	r4,16448
801042f8:	21030004 	addi	r4,r4,3072
801042fc:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_IRQ_FLAGS_CLR_REG_OFST, uliEmptyFlagClearMask);

}
80104300:	0001883a 	nop
80104304:	e037883a 	mov	sp,fp
80104308:	dfc00117 	ldw	ra,4(sp)
8010430c:	df000017 	ldw	fp,0(sp)
80104310:	dec00204 	addi	sp,sp,8
80104314:	f800283a 	ret

80104318 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(alt_u8 ucEmptyBufferFlag) {
80104318:	defffc04 	addi	sp,sp,-16
8010431c:	de00012e 	bgeu	sp,et,80104324 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
80104320:	003b68fa 	trap	3
80104324:	dfc00315 	stw	ra,12(sp)
80104328:	df000215 	stw	fp,8(sp)
8010432c:	df000204 	addi	fp,sp,8
80104330:	2005883a 	mov	r2,r4
80104334:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 uliEmptyFlagClearMask = 0;
80104338:	e03ffe15 	stw	zero,-8(fp)

	switch (ucEmptyBufferFlag) {
8010433c:	e0bfff03 	ldbu	r2,-4(fp)
80104340:	10c00060 	cmpeqi	r3,r2,1
80104344:	18000c1e 	bne	r3,zero,80104378 <vFeebCh6IrqFlagClrBufferEmpty+0x60>
80104348:	10c00088 	cmpgei	r3,r2,2
8010434c:	1800021e 	bne	r3,zero,80104358 <vFeebCh6IrqFlagClrBufferEmpty+0x40>
80104350:	10000626 	beq	r2,zero,8010436c <vFeebCh6IrqFlagClrBufferEmpty+0x54>
80104354:	00001106 	br	8010439c <vFeebCh6IrqFlagClrBufferEmpty+0x84>
80104358:	10c000a0 	cmpeqi	r3,r2,2
8010435c:	1800091e 	bne	r3,zero,80104384 <vFeebCh6IrqFlagClrBufferEmpty+0x6c>
80104360:	108000e0 	cmpeqi	r2,r2,3
80104364:	10000a1e 	bne	r2,zero,80104390 <vFeebCh6IrqFlagClrBufferEmpty+0x78>
80104368:	00000c06 	br	8010439c <vFeebCh6IrqFlagClrBufferEmpty+0x84>
	case eFeebIrqLeftEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_0_E_FLG_CLR_MSK;
8010436c:	00810004 	movi	r2,1024
80104370:	e0bffe15 	stw	r2,-8(fp)
		break;
80104374:	00000b06 	br	801043a4 <vFeebCh6IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqLeftEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_1_E_FLG_CLR_MSK;
80104378:	00820004 	movi	r2,2048
8010437c:	e0bffe15 	stw	r2,-8(fp)
		break;
80104380:	00000806 	br	801043a4 <vFeebCh6IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_0_E_FLG_CLR_MSK;
80104384:	00804004 	movi	r2,256
80104388:	e0bffe15 	stw	r2,-8(fp)
		break;
8010438c:	00000506 	br	801043a4 <vFeebCh6IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_1_E_FLG_CLR_MSK;
80104390:	00808004 	movi	r2,512
80104394:	e0bffe15 	stw	r2,-8(fp)
		break;
80104398:	00000206 	br	801043a4 <vFeebCh6IrqFlagClrBufferEmpty+0x8c>
	default:
		uliEmptyFlagClearMask = 0;
8010439c:	e03ffe15 	stw	zero,-8(fp)
		;
		break;
801043a0:	0001883a 	nop
	}

	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
801043a4:	e1bffe17 	ldw	r6,-8(fp)
801043a8:	014004c4 	movi	r5,19
801043ac:	01101034 	movhi	r4,16448
801043b0:	21020004 	addi	r4,r4,2048
801043b4:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_IRQ_FLAGS_CLR_REG_OFST, uliEmptyFlagClearMask);

}
801043b8:	0001883a 	nop
801043bc:	e037883a 	mov	sp,fp
801043c0:	dfc00117 	ldw	ra,4(sp)
801043c4:	df000017 	ldw	fp,0(sp)
801043c8:	dec00204 	addi	sp,sp,8
801043cc:	f800283a 	ret

801043d0 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(alt_u8 ucEmptyBufferFlag) {
801043d0:	defffc04 	addi	sp,sp,-16
801043d4:	de00012e 	bgeu	sp,et,801043dc <vFeebCh7IrqFlagClrBufferEmpty+0xc>
801043d8:	003b68fa 	trap	3
801043dc:	dfc00315 	stw	ra,12(sp)
801043e0:	df000215 	stw	fp,8(sp)
801043e4:	df000204 	addi	fp,sp,8
801043e8:	2005883a 	mov	r2,r4
801043ec:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 uliEmptyFlagClearMask = 0;
801043f0:	e03ffe15 	stw	zero,-8(fp)

	switch (ucEmptyBufferFlag) {
801043f4:	e0bfff03 	ldbu	r2,-4(fp)
801043f8:	10c00060 	cmpeqi	r3,r2,1
801043fc:	18000c1e 	bne	r3,zero,80104430 <vFeebCh7IrqFlagClrBufferEmpty+0x60>
80104400:	10c00088 	cmpgei	r3,r2,2
80104404:	1800021e 	bne	r3,zero,80104410 <vFeebCh7IrqFlagClrBufferEmpty+0x40>
80104408:	10000626 	beq	r2,zero,80104424 <vFeebCh7IrqFlagClrBufferEmpty+0x54>
8010440c:	00001106 	br	80104454 <vFeebCh7IrqFlagClrBufferEmpty+0x84>
80104410:	10c000a0 	cmpeqi	r3,r2,2
80104414:	1800091e 	bne	r3,zero,8010443c <vFeebCh7IrqFlagClrBufferEmpty+0x6c>
80104418:	108000e0 	cmpeqi	r2,r2,3
8010441c:	10000a1e 	bne	r2,zero,80104448 <vFeebCh7IrqFlagClrBufferEmpty+0x78>
80104420:	00000c06 	br	80104454 <vFeebCh7IrqFlagClrBufferEmpty+0x84>
	case eFeebIrqLeftEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_0_E_FLG_CLR_MSK;
80104424:	00810004 	movi	r2,1024
80104428:	e0bffe15 	stw	r2,-8(fp)
		break;
8010442c:	00000b06 	br	8010445c <vFeebCh7IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqLeftEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_1_E_FLG_CLR_MSK;
80104430:	00820004 	movi	r2,2048
80104434:	e0bffe15 	stw	r2,-8(fp)
		break;
80104438:	00000806 	br	8010445c <vFeebCh7IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_0_E_FLG_CLR_MSK;
8010443c:	00804004 	movi	r2,256
80104440:	e0bffe15 	stw	r2,-8(fp)
		break;
80104444:	00000506 	br	8010445c <vFeebCh7IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_1_E_FLG_CLR_MSK;
80104448:	00808004 	movi	r2,512
8010444c:	e0bffe15 	stw	r2,-8(fp)
		break;
80104450:	00000206 	br	8010445c <vFeebCh7IrqFlagClrBufferEmpty+0x8c>
	default:
		uliEmptyFlagClearMask = 0;
80104454:	e03ffe15 	stw	zero,-8(fp)
		;
		break;
80104458:	0001883a 	nop
	}

	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8010445c:	e1bffe17 	ldw	r6,-8(fp)
80104460:	014004c4 	movi	r5,19
80104464:	01101034 	movhi	r4,16448
80104468:	21010004 	addi	r4,r4,1024
8010446c:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_IRQ_FLAGS_CLR_REG_OFST, uliEmptyFlagClearMask);

}
80104470:	0001883a 	nop
80104474:	e037883a 	mov	sp,fp
80104478:	dfc00117 	ldw	ra,4(sp)
8010447c:	df000017 	ldw	fp,0(sp)
80104480:	dec00204 	addi	sp,sp,8
80104484:	f800283a 	ret

80104488 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(alt_u8 ucEmptyBufferFlag) {
80104488:	defffc04 	addi	sp,sp,-16
8010448c:	de00012e 	bgeu	sp,et,80104494 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
80104490:	003b68fa 	trap	3
80104494:	dfc00315 	stw	ra,12(sp)
80104498:	df000215 	stw	fp,8(sp)
8010449c:	df000204 	addi	fp,sp,8
801044a0:	2005883a 	mov	r2,r4
801044a4:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 uliEmptyFlagClearMask = 0;
801044a8:	e03ffe15 	stw	zero,-8(fp)

	switch (ucEmptyBufferFlag) {
801044ac:	e0bfff03 	ldbu	r2,-4(fp)
801044b0:	10c00060 	cmpeqi	r3,r2,1
801044b4:	18000c1e 	bne	r3,zero,801044e8 <vFeebCh8IrqFlagClrBufferEmpty+0x60>
801044b8:	10c00088 	cmpgei	r3,r2,2
801044bc:	1800021e 	bne	r3,zero,801044c8 <vFeebCh8IrqFlagClrBufferEmpty+0x40>
801044c0:	10000626 	beq	r2,zero,801044dc <vFeebCh8IrqFlagClrBufferEmpty+0x54>
801044c4:	00001106 	br	8010450c <vFeebCh8IrqFlagClrBufferEmpty+0x84>
801044c8:	10c000a0 	cmpeqi	r3,r2,2
801044cc:	1800091e 	bne	r3,zero,801044f4 <vFeebCh8IrqFlagClrBufferEmpty+0x6c>
801044d0:	108000e0 	cmpeqi	r2,r2,3
801044d4:	10000a1e 	bne	r2,zero,80104500 <vFeebCh8IrqFlagClrBufferEmpty+0x78>
801044d8:	00000c06 	br	8010450c <vFeebCh8IrqFlagClrBufferEmpty+0x84>
	case eFeebIrqLeftEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_0_E_FLG_CLR_MSK;
801044dc:	00810004 	movi	r2,1024
801044e0:	e0bffe15 	stw	r2,-8(fp)
		break;
801044e4:	00000b06 	br	80104514 <vFeebCh8IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqLeftEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_L_BUFF_1_E_FLG_CLR_MSK;
801044e8:	00820004 	movi	r2,2048
801044ec:	e0bffe15 	stw	r2,-8(fp)
		break;
801044f0:	00000806 	br	80104514 <vFeebCh8IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer0Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_0_E_FLG_CLR_MSK;
801044f4:	00804004 	movi	r2,256
801044f8:	e0bffe15 	stw	r2,-8(fp)
		break;
801044fc:	00000506 	br	80104514 <vFeebCh8IrqFlagClrBufferEmpty+0x8c>
	case eFeebIrqRightEmptyBuffer1Flag:
		uliEmptyFlagClearMask = (alt_u32) COMM_IRQ_R_BUFF_1_E_FLG_CLR_MSK;
80104500:	00808004 	movi	r2,512
80104504:	e0bffe15 	stw	r2,-8(fp)
		break;
80104508:	00000206 	br	80104514 <vFeebCh8IrqFlagClrBufferEmpty+0x8c>
	default:
		uliEmptyFlagClearMask = 0;
8010450c:	e03ffe15 	stw	zero,-8(fp)
		;
		break;
80104510:	0001883a 	nop
	}

	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
80104514:	e1bffe17 	ldw	r6,-8(fp)
80104518:	014004c4 	movi	r5,19
8010451c:	01101034 	movhi	r4,16448
80104520:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_IRQ_FLAGS_CLR_REG_OFST, uliEmptyFlagClearMask);

}
80104524:	0001883a 	nop
80104528:	e037883a 	mov	sp,fp
8010452c:	dfc00117 	ldw	ra,4(sp)
80104530:	df000017 	ldw	fp,0(sp)
80104534:	dec00204 	addi	sp,sp,8
80104538:	f800283a 	ret

8010453c <vFeebCh1IrqFlagBufferEmpty>:

void vFeebCh1IrqFlagBufferEmpty(bool *pbChEmptyBufferFlags) {
8010453c:	defffc04 	addi	sp,sp,-16
80104540:	de00012e 	bgeu	sp,et,80104548 <vFeebCh1IrqFlagBufferEmpty+0xc>
80104544:	003b68fa 	trap	3
80104548:	dfc00315 	stw	ra,12(sp)
8010454c:	df000215 	stw	fp,8(sp)
80104550:	df000204 	addi	fp,sp,8
80104554:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliIrqFlagsReg = 0;
80104558:	e03ffe15 	stw	zero,-8(fp)

	if (pbChEmptyBufferFlags != NULL) {
8010455c:	e0bfff17 	ldw	r2,-4(fp)
80104560:	10002f26 	beq	r2,zero,80104620 <vFeebCh1IrqFlagBufferEmpty+0xe4>

		uliIrqFlagsReg = uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
80104564:	01400484 	movi	r5,18
80104568:	01101034 	movhi	r4,16448
8010456c:	21030004 	addi	r4,r4,3072
80104570:	01072d80 	call	801072d8 <uliFeebReadReg>
80104574:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80104578:	e0bffe17 	ldw	r2,-8(fp)
8010457c:	1081000c 	andi	r2,r2,1024
80104580:	10000426 	beq	r2,zero,80104594 <vFeebCh1IrqFlagBufferEmpty+0x58>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = TRUE;
80104584:	e0bfff17 	ldw	r2,-4(fp)
80104588:	00c00044 	movi	r3,1
8010458c:	10c00015 	stw	r3,0(r2)
80104590:	00000206 	br	8010459c <vFeebCh1IrqFlagBufferEmpty+0x60>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = FALSE;
80104594:	e0bfff17 	ldw	r2,-4(fp)
80104598:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
8010459c:	e0bffe17 	ldw	r2,-8(fp)
801045a0:	1082000c 	andi	r2,r2,2048
801045a4:	10000526 	beq	r2,zero,801045bc <vFeebCh1IrqFlagBufferEmpty+0x80>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = TRUE;
801045a8:	e0bfff17 	ldw	r2,-4(fp)
801045ac:	10800104 	addi	r2,r2,4
801045b0:	00c00044 	movi	r3,1
801045b4:	10c00015 	stw	r3,0(r2)
801045b8:	00000306 	br	801045c8 <vFeebCh1IrqFlagBufferEmpty+0x8c>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = FALSE;
801045bc:	e0bfff17 	ldw	r2,-4(fp)
801045c0:	10800104 	addi	r2,r2,4
801045c4:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
801045c8:	e0bffe17 	ldw	r2,-8(fp)
801045cc:	1080400c 	andi	r2,r2,256
801045d0:	10000526 	beq	r2,zero,801045e8 <vFeebCh1IrqFlagBufferEmpty+0xac>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = TRUE;
801045d4:	e0bfff17 	ldw	r2,-4(fp)
801045d8:	10800204 	addi	r2,r2,8
801045dc:	00c00044 	movi	r3,1
801045e0:	10c00015 	stw	r3,0(r2)
801045e4:	00000306 	br	801045f4 <vFeebCh1IrqFlagBufferEmpty+0xb8>
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
801045e8:	e0bfff17 	ldw	r2,-4(fp)
801045ec:	10800204 	addi	r2,r2,8
801045f0:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
801045f4:	e0bffe17 	ldw	r2,-8(fp)
801045f8:	1080800c 	andi	r2,r2,512
801045fc:	10000526 	beq	r2,zero,80104614 <vFeebCh1IrqFlagBufferEmpty+0xd8>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
80104600:	e0bfff17 	ldw	r2,-4(fp)
80104604:	10800304 	addi	r2,r2,12
80104608:	00c00044 	movi	r3,1
8010460c:	10c00015 	stw	r3,0(r2)
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
		}

	}
}
80104610:	00000306 	br	80104620 <vFeebCh1IrqFlagBufferEmpty+0xe4>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
80104614:	e0bfff17 	ldw	r2,-4(fp)
80104618:	10800304 	addi	r2,r2,12
8010461c:	10000015 	stw	zero,0(r2)
		}

	}
}
80104620:	0001883a 	nop
80104624:	e037883a 	mov	sp,fp
80104628:	dfc00117 	ldw	ra,4(sp)
8010462c:	df000017 	ldw	fp,0(sp)
80104630:	dec00204 	addi	sp,sp,8
80104634:	f800283a 	ret

80104638 <vFeebCh2IrqFlagBufferEmpty>:

void vFeebCh2IrqFlagBufferEmpty(bool *pbChEmptyBufferFlags) {
80104638:	defffc04 	addi	sp,sp,-16
8010463c:	de00012e 	bgeu	sp,et,80104644 <vFeebCh2IrqFlagBufferEmpty+0xc>
80104640:	003b68fa 	trap	3
80104644:	dfc00315 	stw	ra,12(sp)
80104648:	df000215 	stw	fp,8(sp)
8010464c:	df000204 	addi	fp,sp,8
80104650:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliIrqFlagsReg = 0;
80104654:	e03ffe15 	stw	zero,-8(fp)

	if (pbChEmptyBufferFlags != NULL) {
80104658:	e0bfff17 	ldw	r2,-4(fp)
8010465c:	10002f26 	beq	r2,zero,8010471c <vFeebCh2IrqFlagBufferEmpty+0xe4>

		uliIrqFlagsReg = uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
80104660:	01400484 	movi	r5,18
80104664:	01101034 	movhi	r4,16448
80104668:	21020004 	addi	r4,r4,2048
8010466c:	01072d80 	call	801072d8 <uliFeebReadReg>
80104670:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80104674:	e0bffe17 	ldw	r2,-8(fp)
80104678:	1081000c 	andi	r2,r2,1024
8010467c:	10000426 	beq	r2,zero,80104690 <vFeebCh2IrqFlagBufferEmpty+0x58>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = TRUE;
80104680:	e0bfff17 	ldw	r2,-4(fp)
80104684:	00c00044 	movi	r3,1
80104688:	10c00015 	stw	r3,0(r2)
8010468c:	00000206 	br	80104698 <vFeebCh2IrqFlagBufferEmpty+0x60>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = FALSE;
80104690:	e0bfff17 	ldw	r2,-4(fp)
80104694:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
80104698:	e0bffe17 	ldw	r2,-8(fp)
8010469c:	1082000c 	andi	r2,r2,2048
801046a0:	10000526 	beq	r2,zero,801046b8 <vFeebCh2IrqFlagBufferEmpty+0x80>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = TRUE;
801046a4:	e0bfff17 	ldw	r2,-4(fp)
801046a8:	10800104 	addi	r2,r2,4
801046ac:	00c00044 	movi	r3,1
801046b0:	10c00015 	stw	r3,0(r2)
801046b4:	00000306 	br	801046c4 <vFeebCh2IrqFlagBufferEmpty+0x8c>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = FALSE;
801046b8:	e0bfff17 	ldw	r2,-4(fp)
801046bc:	10800104 	addi	r2,r2,4
801046c0:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
801046c4:	e0bffe17 	ldw	r2,-8(fp)
801046c8:	1080400c 	andi	r2,r2,256
801046cc:	10000526 	beq	r2,zero,801046e4 <vFeebCh2IrqFlagBufferEmpty+0xac>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = TRUE;
801046d0:	e0bfff17 	ldw	r2,-4(fp)
801046d4:	10800204 	addi	r2,r2,8
801046d8:	00c00044 	movi	r3,1
801046dc:	10c00015 	stw	r3,0(r2)
801046e0:	00000306 	br	801046f0 <vFeebCh2IrqFlagBufferEmpty+0xb8>
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
801046e4:	e0bfff17 	ldw	r2,-4(fp)
801046e8:	10800204 	addi	r2,r2,8
801046ec:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
801046f0:	e0bffe17 	ldw	r2,-8(fp)
801046f4:	1080800c 	andi	r2,r2,512
801046f8:	10000526 	beq	r2,zero,80104710 <vFeebCh2IrqFlagBufferEmpty+0xd8>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
801046fc:	e0bfff17 	ldw	r2,-4(fp)
80104700:	10800304 	addi	r2,r2,12
80104704:	00c00044 	movi	r3,1
80104708:	10c00015 	stw	r3,0(r2)
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
		}

	}
}
8010470c:	00000306 	br	8010471c <vFeebCh2IrqFlagBufferEmpty+0xe4>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
80104710:	e0bfff17 	ldw	r2,-4(fp)
80104714:	10800304 	addi	r2,r2,12
80104718:	10000015 	stw	zero,0(r2)
		}

	}
}
8010471c:	0001883a 	nop
80104720:	e037883a 	mov	sp,fp
80104724:	dfc00117 	ldw	ra,4(sp)
80104728:	df000017 	ldw	fp,0(sp)
8010472c:	dec00204 	addi	sp,sp,8
80104730:	f800283a 	ret

80104734 <vFeebCh3IrqFlagBufferEmpty>:

void vFeebCh3IrqFlagBufferEmpty(bool *pbChEmptyBufferFlags) {
80104734:	defffc04 	addi	sp,sp,-16
80104738:	de00012e 	bgeu	sp,et,80104740 <vFeebCh3IrqFlagBufferEmpty+0xc>
8010473c:	003b68fa 	trap	3
80104740:	dfc00315 	stw	ra,12(sp)
80104744:	df000215 	stw	fp,8(sp)
80104748:	df000204 	addi	fp,sp,8
8010474c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliIrqFlagsReg = 0;
80104750:	e03ffe15 	stw	zero,-8(fp)

	if (pbChEmptyBufferFlags != NULL) {
80104754:	e0bfff17 	ldw	r2,-4(fp)
80104758:	10002f26 	beq	r2,zero,80104818 <vFeebCh3IrqFlagBufferEmpty+0xe4>

		uliIrqFlagsReg = uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8010475c:	01400484 	movi	r5,18
80104760:	01101034 	movhi	r4,16448
80104764:	21010004 	addi	r4,r4,1024
80104768:	01072d80 	call	801072d8 <uliFeebReadReg>
8010476c:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80104770:	e0bffe17 	ldw	r2,-8(fp)
80104774:	1081000c 	andi	r2,r2,1024
80104778:	10000426 	beq	r2,zero,8010478c <vFeebCh3IrqFlagBufferEmpty+0x58>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = TRUE;
8010477c:	e0bfff17 	ldw	r2,-4(fp)
80104780:	00c00044 	movi	r3,1
80104784:	10c00015 	stw	r3,0(r2)
80104788:	00000206 	br	80104794 <vFeebCh3IrqFlagBufferEmpty+0x60>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = FALSE;
8010478c:	e0bfff17 	ldw	r2,-4(fp)
80104790:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
80104794:	e0bffe17 	ldw	r2,-8(fp)
80104798:	1082000c 	andi	r2,r2,2048
8010479c:	10000526 	beq	r2,zero,801047b4 <vFeebCh3IrqFlagBufferEmpty+0x80>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = TRUE;
801047a0:	e0bfff17 	ldw	r2,-4(fp)
801047a4:	10800104 	addi	r2,r2,4
801047a8:	00c00044 	movi	r3,1
801047ac:	10c00015 	stw	r3,0(r2)
801047b0:	00000306 	br	801047c0 <vFeebCh3IrqFlagBufferEmpty+0x8c>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = FALSE;
801047b4:	e0bfff17 	ldw	r2,-4(fp)
801047b8:	10800104 	addi	r2,r2,4
801047bc:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
801047c0:	e0bffe17 	ldw	r2,-8(fp)
801047c4:	1080400c 	andi	r2,r2,256
801047c8:	10000526 	beq	r2,zero,801047e0 <vFeebCh3IrqFlagBufferEmpty+0xac>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = TRUE;
801047cc:	e0bfff17 	ldw	r2,-4(fp)
801047d0:	10800204 	addi	r2,r2,8
801047d4:	00c00044 	movi	r3,1
801047d8:	10c00015 	stw	r3,0(r2)
801047dc:	00000306 	br	801047ec <vFeebCh3IrqFlagBufferEmpty+0xb8>
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
801047e0:	e0bfff17 	ldw	r2,-4(fp)
801047e4:	10800204 	addi	r2,r2,8
801047e8:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
801047ec:	e0bffe17 	ldw	r2,-8(fp)
801047f0:	1080800c 	andi	r2,r2,512
801047f4:	10000526 	beq	r2,zero,8010480c <vFeebCh3IrqFlagBufferEmpty+0xd8>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
801047f8:	e0bfff17 	ldw	r2,-4(fp)
801047fc:	10800304 	addi	r2,r2,12
80104800:	00c00044 	movi	r3,1
80104804:	10c00015 	stw	r3,0(r2)
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
		}

	}
}
80104808:	00000306 	br	80104818 <vFeebCh3IrqFlagBufferEmpty+0xe4>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
8010480c:	e0bfff17 	ldw	r2,-4(fp)
80104810:	10800304 	addi	r2,r2,12
80104814:	10000015 	stw	zero,0(r2)
		}

	}
}
80104818:	0001883a 	nop
8010481c:	e037883a 	mov	sp,fp
80104820:	dfc00117 	ldw	ra,4(sp)
80104824:	df000017 	ldw	fp,0(sp)
80104828:	dec00204 	addi	sp,sp,8
8010482c:	f800283a 	ret

80104830 <vFeebCh4IrqFlagBufferEmpty>:

void vFeebCh4IrqFlagBufferEmpty(bool *pbChEmptyBufferFlags) {
80104830:	defffc04 	addi	sp,sp,-16
80104834:	de00012e 	bgeu	sp,et,8010483c <vFeebCh4IrqFlagBufferEmpty+0xc>
80104838:	003b68fa 	trap	3
8010483c:	dfc00315 	stw	ra,12(sp)
80104840:	df000215 	stw	fp,8(sp)
80104844:	df000204 	addi	fp,sp,8
80104848:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliIrqFlagsReg = 0;
8010484c:	e03ffe15 	stw	zero,-8(fp)

	if (pbChEmptyBufferFlags != NULL) {
80104850:	e0bfff17 	ldw	r2,-4(fp)
80104854:	10002e26 	beq	r2,zero,80104910 <vFeebCh4IrqFlagBufferEmpty+0xe0>

		uliIrqFlagsReg = uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
80104858:	01400484 	movi	r5,18
8010485c:	01101034 	movhi	r4,16448
80104860:	01072d80 	call	801072d8 <uliFeebReadReg>
80104864:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80104868:	e0bffe17 	ldw	r2,-8(fp)
8010486c:	1081000c 	andi	r2,r2,1024
80104870:	10000426 	beq	r2,zero,80104884 <vFeebCh4IrqFlagBufferEmpty+0x54>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = TRUE;
80104874:	e0bfff17 	ldw	r2,-4(fp)
80104878:	00c00044 	movi	r3,1
8010487c:	10c00015 	stw	r3,0(r2)
80104880:	00000206 	br	8010488c <vFeebCh4IrqFlagBufferEmpty+0x5c>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = FALSE;
80104884:	e0bfff17 	ldw	r2,-4(fp)
80104888:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
8010488c:	e0bffe17 	ldw	r2,-8(fp)
80104890:	1082000c 	andi	r2,r2,2048
80104894:	10000526 	beq	r2,zero,801048ac <vFeebCh4IrqFlagBufferEmpty+0x7c>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = TRUE;
80104898:	e0bfff17 	ldw	r2,-4(fp)
8010489c:	10800104 	addi	r2,r2,4
801048a0:	00c00044 	movi	r3,1
801048a4:	10c00015 	stw	r3,0(r2)
801048a8:	00000306 	br	801048b8 <vFeebCh4IrqFlagBufferEmpty+0x88>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = FALSE;
801048ac:	e0bfff17 	ldw	r2,-4(fp)
801048b0:	10800104 	addi	r2,r2,4
801048b4:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
801048b8:	e0bffe17 	ldw	r2,-8(fp)
801048bc:	1080400c 	andi	r2,r2,256
801048c0:	10000526 	beq	r2,zero,801048d8 <vFeebCh4IrqFlagBufferEmpty+0xa8>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = TRUE;
801048c4:	e0bfff17 	ldw	r2,-4(fp)
801048c8:	10800204 	addi	r2,r2,8
801048cc:	00c00044 	movi	r3,1
801048d0:	10c00015 	stw	r3,0(r2)
801048d4:	00000306 	br	801048e4 <vFeebCh4IrqFlagBufferEmpty+0xb4>
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
801048d8:	e0bfff17 	ldw	r2,-4(fp)
801048dc:	10800204 	addi	r2,r2,8
801048e0:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
801048e4:	e0bffe17 	ldw	r2,-8(fp)
801048e8:	1080800c 	andi	r2,r2,512
801048ec:	10000526 	beq	r2,zero,80104904 <vFeebCh4IrqFlagBufferEmpty+0xd4>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
801048f0:	e0bfff17 	ldw	r2,-4(fp)
801048f4:	10800304 	addi	r2,r2,12
801048f8:	00c00044 	movi	r3,1
801048fc:	10c00015 	stw	r3,0(r2)
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
		}

	}
}
80104900:	00000306 	br	80104910 <vFeebCh4IrqFlagBufferEmpty+0xe0>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
80104904:	e0bfff17 	ldw	r2,-4(fp)
80104908:	10800304 	addi	r2,r2,12
8010490c:	10000015 	stw	zero,0(r2)
		}

	}
}
80104910:	0001883a 	nop
80104914:	e037883a 	mov	sp,fp
80104918:	dfc00117 	ldw	ra,4(sp)
8010491c:	df000017 	ldw	fp,0(sp)
80104920:	dec00204 	addi	sp,sp,8
80104924:	f800283a 	ret

80104928 <vFeebCh5IrqFlagBufferEmpty>:

void vFeebCh5IrqFlagBufferEmpty(bool *pbChEmptyBufferFlags) {
80104928:	defffc04 	addi	sp,sp,-16
8010492c:	de00012e 	bgeu	sp,et,80104934 <vFeebCh5IrqFlagBufferEmpty+0xc>
80104930:	003b68fa 	trap	3
80104934:	dfc00315 	stw	ra,12(sp)
80104938:	df000215 	stw	fp,8(sp)
8010493c:	df000204 	addi	fp,sp,8
80104940:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliIrqFlagsReg = 0;
80104944:	e03ffe15 	stw	zero,-8(fp)

	if (pbChEmptyBufferFlags != NULL) {
80104948:	e0bfff17 	ldw	r2,-4(fp)
8010494c:	10002f26 	beq	r2,zero,80104a0c <vFeebCh5IrqFlagBufferEmpty+0xe4>

		uliIrqFlagsReg = uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
80104950:	01400484 	movi	r5,18
80104954:	01101034 	movhi	r4,16448
80104958:	21030004 	addi	r4,r4,3072
8010495c:	01072d80 	call	801072d8 <uliFeebReadReg>
80104960:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80104964:	e0bffe17 	ldw	r2,-8(fp)
80104968:	1081000c 	andi	r2,r2,1024
8010496c:	10000426 	beq	r2,zero,80104980 <vFeebCh5IrqFlagBufferEmpty+0x58>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = TRUE;
80104970:	e0bfff17 	ldw	r2,-4(fp)
80104974:	00c00044 	movi	r3,1
80104978:	10c00015 	stw	r3,0(r2)
8010497c:	00000206 	br	80104988 <vFeebCh5IrqFlagBufferEmpty+0x60>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = FALSE;
80104980:	e0bfff17 	ldw	r2,-4(fp)
80104984:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
80104988:	e0bffe17 	ldw	r2,-8(fp)
8010498c:	1082000c 	andi	r2,r2,2048
80104990:	10000526 	beq	r2,zero,801049a8 <vFeebCh5IrqFlagBufferEmpty+0x80>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = TRUE;
80104994:	e0bfff17 	ldw	r2,-4(fp)
80104998:	10800104 	addi	r2,r2,4
8010499c:	00c00044 	movi	r3,1
801049a0:	10c00015 	stw	r3,0(r2)
801049a4:	00000306 	br	801049b4 <vFeebCh5IrqFlagBufferEmpty+0x8c>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = FALSE;
801049a8:	e0bfff17 	ldw	r2,-4(fp)
801049ac:	10800104 	addi	r2,r2,4
801049b0:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
801049b4:	e0bffe17 	ldw	r2,-8(fp)
801049b8:	1080400c 	andi	r2,r2,256
801049bc:	10000526 	beq	r2,zero,801049d4 <vFeebCh5IrqFlagBufferEmpty+0xac>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = TRUE;
801049c0:	e0bfff17 	ldw	r2,-4(fp)
801049c4:	10800204 	addi	r2,r2,8
801049c8:	00c00044 	movi	r3,1
801049cc:	10c00015 	stw	r3,0(r2)
801049d0:	00000306 	br	801049e0 <vFeebCh5IrqFlagBufferEmpty+0xb8>
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
801049d4:	e0bfff17 	ldw	r2,-4(fp)
801049d8:	10800204 	addi	r2,r2,8
801049dc:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
801049e0:	e0bffe17 	ldw	r2,-8(fp)
801049e4:	1080800c 	andi	r2,r2,512
801049e8:	10000526 	beq	r2,zero,80104a00 <vFeebCh5IrqFlagBufferEmpty+0xd8>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
801049ec:	e0bfff17 	ldw	r2,-4(fp)
801049f0:	10800304 	addi	r2,r2,12
801049f4:	00c00044 	movi	r3,1
801049f8:	10c00015 	stw	r3,0(r2)
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
		}

	}
}
801049fc:	00000306 	br	80104a0c <vFeebCh5IrqFlagBufferEmpty+0xe4>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
80104a00:	e0bfff17 	ldw	r2,-4(fp)
80104a04:	10800304 	addi	r2,r2,12
80104a08:	10000015 	stw	zero,0(r2)
		}

	}
}
80104a0c:	0001883a 	nop
80104a10:	e037883a 	mov	sp,fp
80104a14:	dfc00117 	ldw	ra,4(sp)
80104a18:	df000017 	ldw	fp,0(sp)
80104a1c:	dec00204 	addi	sp,sp,8
80104a20:	f800283a 	ret

80104a24 <vFeebCh6IrqFlagBufferEmpty>:

void vFeebCh6IrqFlagBufferEmpty(bool *pbChEmptyBufferFlags) {
80104a24:	defffc04 	addi	sp,sp,-16
80104a28:	de00012e 	bgeu	sp,et,80104a30 <vFeebCh6IrqFlagBufferEmpty+0xc>
80104a2c:	003b68fa 	trap	3
80104a30:	dfc00315 	stw	ra,12(sp)
80104a34:	df000215 	stw	fp,8(sp)
80104a38:	df000204 	addi	fp,sp,8
80104a3c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliIrqFlagsReg = 0;
80104a40:	e03ffe15 	stw	zero,-8(fp)

	if (pbChEmptyBufferFlags != NULL) {
80104a44:	e0bfff17 	ldw	r2,-4(fp)
80104a48:	10002f26 	beq	r2,zero,80104b08 <vFeebCh6IrqFlagBufferEmpty+0xe4>

		uliIrqFlagsReg = uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
80104a4c:	01400484 	movi	r5,18
80104a50:	01101034 	movhi	r4,16448
80104a54:	21020004 	addi	r4,r4,2048
80104a58:	01072d80 	call	801072d8 <uliFeebReadReg>
80104a5c:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80104a60:	e0bffe17 	ldw	r2,-8(fp)
80104a64:	1081000c 	andi	r2,r2,1024
80104a68:	10000426 	beq	r2,zero,80104a7c <vFeebCh6IrqFlagBufferEmpty+0x58>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = TRUE;
80104a6c:	e0bfff17 	ldw	r2,-4(fp)
80104a70:	00c00044 	movi	r3,1
80104a74:	10c00015 	stw	r3,0(r2)
80104a78:	00000206 	br	80104a84 <vFeebCh6IrqFlagBufferEmpty+0x60>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = FALSE;
80104a7c:	e0bfff17 	ldw	r2,-4(fp)
80104a80:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
80104a84:	e0bffe17 	ldw	r2,-8(fp)
80104a88:	1082000c 	andi	r2,r2,2048
80104a8c:	10000526 	beq	r2,zero,80104aa4 <vFeebCh6IrqFlagBufferEmpty+0x80>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = TRUE;
80104a90:	e0bfff17 	ldw	r2,-4(fp)
80104a94:	10800104 	addi	r2,r2,4
80104a98:	00c00044 	movi	r3,1
80104a9c:	10c00015 	stw	r3,0(r2)
80104aa0:	00000306 	br	80104ab0 <vFeebCh6IrqFlagBufferEmpty+0x8c>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = FALSE;
80104aa4:	e0bfff17 	ldw	r2,-4(fp)
80104aa8:	10800104 	addi	r2,r2,4
80104aac:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
80104ab0:	e0bffe17 	ldw	r2,-8(fp)
80104ab4:	1080400c 	andi	r2,r2,256
80104ab8:	10000526 	beq	r2,zero,80104ad0 <vFeebCh6IrqFlagBufferEmpty+0xac>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = TRUE;
80104abc:	e0bfff17 	ldw	r2,-4(fp)
80104ac0:	10800204 	addi	r2,r2,8
80104ac4:	00c00044 	movi	r3,1
80104ac8:	10c00015 	stw	r3,0(r2)
80104acc:	00000306 	br	80104adc <vFeebCh6IrqFlagBufferEmpty+0xb8>
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
80104ad0:	e0bfff17 	ldw	r2,-4(fp)
80104ad4:	10800204 	addi	r2,r2,8
80104ad8:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
80104adc:	e0bffe17 	ldw	r2,-8(fp)
80104ae0:	1080800c 	andi	r2,r2,512
80104ae4:	10000526 	beq	r2,zero,80104afc <vFeebCh6IrqFlagBufferEmpty+0xd8>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
80104ae8:	e0bfff17 	ldw	r2,-4(fp)
80104aec:	10800304 	addi	r2,r2,12
80104af0:	00c00044 	movi	r3,1
80104af4:	10c00015 	stw	r3,0(r2)
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
		}

	}
}
80104af8:	00000306 	br	80104b08 <vFeebCh6IrqFlagBufferEmpty+0xe4>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
80104afc:	e0bfff17 	ldw	r2,-4(fp)
80104b00:	10800304 	addi	r2,r2,12
80104b04:	10000015 	stw	zero,0(r2)
		}

	}
}
80104b08:	0001883a 	nop
80104b0c:	e037883a 	mov	sp,fp
80104b10:	dfc00117 	ldw	ra,4(sp)
80104b14:	df000017 	ldw	fp,0(sp)
80104b18:	dec00204 	addi	sp,sp,8
80104b1c:	f800283a 	ret

80104b20 <vFeebCh7IrqFlagBufferEmpty>:

void vFeebCh7IrqFlagBufferEmpty(bool *pbChEmptyBufferFlags) {
80104b20:	defffc04 	addi	sp,sp,-16
80104b24:	de00012e 	bgeu	sp,et,80104b2c <vFeebCh7IrqFlagBufferEmpty+0xc>
80104b28:	003b68fa 	trap	3
80104b2c:	dfc00315 	stw	ra,12(sp)
80104b30:	df000215 	stw	fp,8(sp)
80104b34:	df000204 	addi	fp,sp,8
80104b38:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliIrqFlagsReg = 0;
80104b3c:	e03ffe15 	stw	zero,-8(fp)

	if (pbChEmptyBufferFlags != NULL) {
80104b40:	e0bfff17 	ldw	r2,-4(fp)
80104b44:	10002f26 	beq	r2,zero,80104c04 <vFeebCh7IrqFlagBufferEmpty+0xe4>

		uliIrqFlagsReg = uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
80104b48:	01400484 	movi	r5,18
80104b4c:	01101034 	movhi	r4,16448
80104b50:	21010004 	addi	r4,r4,1024
80104b54:	01072d80 	call	801072d8 <uliFeebReadReg>
80104b58:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80104b5c:	e0bffe17 	ldw	r2,-8(fp)
80104b60:	1081000c 	andi	r2,r2,1024
80104b64:	10000426 	beq	r2,zero,80104b78 <vFeebCh7IrqFlagBufferEmpty+0x58>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = TRUE;
80104b68:	e0bfff17 	ldw	r2,-4(fp)
80104b6c:	00c00044 	movi	r3,1
80104b70:	10c00015 	stw	r3,0(r2)
80104b74:	00000206 	br	80104b80 <vFeebCh7IrqFlagBufferEmpty+0x60>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = FALSE;
80104b78:	e0bfff17 	ldw	r2,-4(fp)
80104b7c:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
80104b80:	e0bffe17 	ldw	r2,-8(fp)
80104b84:	1082000c 	andi	r2,r2,2048
80104b88:	10000526 	beq	r2,zero,80104ba0 <vFeebCh7IrqFlagBufferEmpty+0x80>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = TRUE;
80104b8c:	e0bfff17 	ldw	r2,-4(fp)
80104b90:	10800104 	addi	r2,r2,4
80104b94:	00c00044 	movi	r3,1
80104b98:	10c00015 	stw	r3,0(r2)
80104b9c:	00000306 	br	80104bac <vFeebCh7IrqFlagBufferEmpty+0x8c>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = FALSE;
80104ba0:	e0bfff17 	ldw	r2,-4(fp)
80104ba4:	10800104 	addi	r2,r2,4
80104ba8:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
80104bac:	e0bffe17 	ldw	r2,-8(fp)
80104bb0:	1080400c 	andi	r2,r2,256
80104bb4:	10000526 	beq	r2,zero,80104bcc <vFeebCh7IrqFlagBufferEmpty+0xac>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = TRUE;
80104bb8:	e0bfff17 	ldw	r2,-4(fp)
80104bbc:	10800204 	addi	r2,r2,8
80104bc0:	00c00044 	movi	r3,1
80104bc4:	10c00015 	stw	r3,0(r2)
80104bc8:	00000306 	br	80104bd8 <vFeebCh7IrqFlagBufferEmpty+0xb8>
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
80104bcc:	e0bfff17 	ldw	r2,-4(fp)
80104bd0:	10800204 	addi	r2,r2,8
80104bd4:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
80104bd8:	e0bffe17 	ldw	r2,-8(fp)
80104bdc:	1080800c 	andi	r2,r2,512
80104be0:	10000526 	beq	r2,zero,80104bf8 <vFeebCh7IrqFlagBufferEmpty+0xd8>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
80104be4:	e0bfff17 	ldw	r2,-4(fp)
80104be8:	10800304 	addi	r2,r2,12
80104bec:	00c00044 	movi	r3,1
80104bf0:	10c00015 	stw	r3,0(r2)
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
		}

	}
}
80104bf4:	00000306 	br	80104c04 <vFeebCh7IrqFlagBufferEmpty+0xe4>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
80104bf8:	e0bfff17 	ldw	r2,-4(fp)
80104bfc:	10800304 	addi	r2,r2,12
80104c00:	10000015 	stw	zero,0(r2)
		}

	}
}
80104c04:	0001883a 	nop
80104c08:	e037883a 	mov	sp,fp
80104c0c:	dfc00117 	ldw	ra,4(sp)
80104c10:	df000017 	ldw	fp,0(sp)
80104c14:	dec00204 	addi	sp,sp,8
80104c18:	f800283a 	ret

80104c1c <vFeebCh8IrqFlagBufferEmpty>:

void vFeebCh8IrqFlagBufferEmpty(bool *pbChEmptyBufferFlags) {
80104c1c:	defffc04 	addi	sp,sp,-16
80104c20:	de00012e 	bgeu	sp,et,80104c28 <vFeebCh8IrqFlagBufferEmpty+0xc>
80104c24:	003b68fa 	trap	3
80104c28:	dfc00315 	stw	ra,12(sp)
80104c2c:	df000215 	stw	fp,8(sp)
80104c30:	df000204 	addi	fp,sp,8
80104c34:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliIrqFlagsReg = 0;
80104c38:	e03ffe15 	stw	zero,-8(fp)

	if (pbChEmptyBufferFlags != NULL) {
80104c3c:	e0bfff17 	ldw	r2,-4(fp)
80104c40:	10002e26 	beq	r2,zero,80104cfc <vFeebCh8IrqFlagBufferEmpty+0xe0>

		uliIrqFlagsReg = uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
80104c44:	01400484 	movi	r5,18
80104c48:	01101034 	movhi	r4,16448
80104c4c:	01072d80 	call	801072d8 <uliFeebReadReg>
80104c50:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80104c54:	e0bffe17 	ldw	r2,-8(fp)
80104c58:	1081000c 	andi	r2,r2,1024
80104c5c:	10000426 	beq	r2,zero,80104c70 <vFeebCh8IrqFlagBufferEmpty+0x54>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = TRUE;
80104c60:	e0bfff17 	ldw	r2,-4(fp)
80104c64:	00c00044 	movi	r3,1
80104c68:	10c00015 	stw	r3,0(r2)
80104c6c:	00000206 	br	80104c78 <vFeebCh8IrqFlagBufferEmpty+0x5c>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer0Flag] = FALSE;
80104c70:	e0bfff17 	ldw	r2,-4(fp)
80104c74:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
80104c78:	e0bffe17 	ldw	r2,-8(fp)
80104c7c:	1082000c 	andi	r2,r2,2048
80104c80:	10000526 	beq	r2,zero,80104c98 <vFeebCh8IrqFlagBufferEmpty+0x7c>
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = TRUE;
80104c84:	e0bfff17 	ldw	r2,-4(fp)
80104c88:	10800104 	addi	r2,r2,4
80104c8c:	00c00044 	movi	r3,1
80104c90:	10c00015 	stw	r3,0(r2)
80104c94:	00000306 	br	80104ca4 <vFeebCh8IrqFlagBufferEmpty+0x88>
		} else {
			pbChEmptyBufferFlags[eFeebIrqLeftEmptyBuffer1Flag] = FALSE;
80104c98:	e0bfff17 	ldw	r2,-4(fp)
80104c9c:	10800104 	addi	r2,r2,4
80104ca0:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
80104ca4:	e0bffe17 	ldw	r2,-8(fp)
80104ca8:	1080400c 	andi	r2,r2,256
80104cac:	10000526 	beq	r2,zero,80104cc4 <vFeebCh8IrqFlagBufferEmpty+0xa8>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = TRUE;
80104cb0:	e0bfff17 	ldw	r2,-4(fp)
80104cb4:	10800204 	addi	r2,r2,8
80104cb8:	00c00044 	movi	r3,1
80104cbc:	10c00015 	stw	r3,0(r2)
80104cc0:	00000306 	br	80104cd0 <vFeebCh8IrqFlagBufferEmpty+0xb4>
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
80104cc4:	e0bfff17 	ldw	r2,-4(fp)
80104cc8:	10800204 	addi	r2,r2,8
80104ccc:	10000015 	stw	zero,0(r2)
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
80104cd0:	e0bffe17 	ldw	r2,-8(fp)
80104cd4:	1080800c 	andi	r2,r2,512
80104cd8:	10000526 	beq	r2,zero,80104cf0 <vFeebCh8IrqFlagBufferEmpty+0xd4>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
80104cdc:	e0bfff17 	ldw	r2,-4(fp)
80104ce0:	10800304 	addi	r2,r2,12
80104ce4:	00c00044 	movi	r3,1
80104ce8:	10c00015 	stw	r3,0(r2)
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
		}

	}
}
80104cec:	00000306 	br	80104cfc <vFeebCh8IrqFlagBufferEmpty+0xe0>
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer0Flag] = FALSE;
		}
		if (uliIrqFlagsReg & (alt_u32) COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = TRUE;
		} else {
			pbChEmptyBufferFlags[eFeebIrqRightEmptyBuffer1Flag] = FALSE;
80104cf0:	e0bfff17 	ldw	r2,-4(fp)
80104cf4:	10800304 	addi	r2,r2,12
80104cf8:	10000015 	stw	zero,0(r2)
		}

	}
}
80104cfc:	0001883a 	nop
80104d00:	e037883a 	mov	sp,fp
80104d04:	dfc00117 	ldw	ra,4(sp)
80104d08:	df000017 	ldw	fp,0(sp)
80104d0c:	dec00204 	addi	sp,sp,8
80104d10:	f800283a 	ret

80104d14 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
80104d14:	defffa04 	addi	sp,sp,-24
80104d18:	de00012e 	bgeu	sp,et,80104d20 <bFeebCh1SetBufferSize+0xc>
80104d1c:	003b68fa 	trap	3
80104d20:	dfc00515 	stw	ra,20(sp)
80104d24:	df000415 	stw	fp,16(sp)
80104d28:	df000404 	addi	fp,sp,16
80104d2c:	2007883a 	mov	r3,r4
80104d30:	2805883a 	mov	r2,r5
80104d34:	e0fffe05 	stb	r3,-8(fp)
80104d38:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80104d3c:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
80104d40:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
80104d44:	e0bffe03 	ldbu	r2,-8(fp)
80104d48:	10002426 	beq	r2,zero,80104ddc <bFeebCh1SetBufferSize+0xc8>
80104d4c:	e0bffe03 	ldbu	r2,-8(fp)
80104d50:	10800468 	cmpgeui	r2,r2,17
80104d54:	1000211e 	bne	r2,zero,80104ddc <bFeebCh1SetBufferSize+0xc8>
		switch (ucBufferSide) {
80104d58:	e0bfff03 	ldbu	r2,-4(fp)
80104d5c:	10000326 	beq	r2,zero,80104d6c <bFeebCh1SetBufferSize+0x58>
80104d60:	10800060 	cmpeqi	r2,r2,1
80104d64:	10000e1e 	bne	r2,zero,80104da0 <bFeebCh1SetBufferSize+0x8c>
80104d68:	00001a06 	br	80104dd4 <bFeebCh1SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80104d6c:	e0bffe03 	ldbu	r2,-8(fp)
80104d70:	10bfffc4 	addi	r2,r2,-1
80104d74:	108003cc 	andi	r2,r2,15
80104d78:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
80104d7c:	e0bffd17 	ldw	r2,-12(fp)
80104d80:	100d883a 	mov	r6,r2
80104d84:	01400544 	movi	r5,21
80104d88:	01101034 	movhi	r4,16448
80104d8c:	21030004 	addi	r4,r4,3072
80104d90:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80104d94:	00800044 	movi	r2,1
80104d98:	e0bffc15 	stw	r2,-16(fp)
			break;
80104d9c:	00000f06 	br	80104ddc <bFeebCh1SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80104da0:	e0bffe03 	ldbu	r2,-8(fp)
80104da4:	10bfffc4 	addi	r2,r2,-1
80104da8:	108003cc 	andi	r2,r2,15
80104dac:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
80104db0:	e0bffd17 	ldw	r2,-12(fp)
80104db4:	100d883a 	mov	r6,r2
80104db8:	01400504 	movi	r5,20
80104dbc:	01101034 	movhi	r4,16448
80104dc0:	21030004 	addi	r4,r4,3072
80104dc4:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80104dc8:	00800044 	movi	r2,1
80104dcc:	e0bffc15 	stw	r2,-16(fp)
			break;
80104dd0:	00000206 	br	80104ddc <bFeebCh1SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
80104dd4:	e03ffc15 	stw	zero,-16(fp)
			break;
80104dd8:	0001883a 	nop
		}
	}

	return bStatus;
80104ddc:	e0bffc17 	ldw	r2,-16(fp)
}
80104de0:	e037883a 	mov	sp,fp
80104de4:	dfc00117 	ldw	ra,4(sp)
80104de8:	df000017 	ldw	fp,0(sp)
80104dec:	dec00204 	addi	sp,sp,8
80104df0:	f800283a 	ret

80104df4 <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
80104df4:	defffa04 	addi	sp,sp,-24
80104df8:	de00012e 	bgeu	sp,et,80104e00 <bFeebCh2SetBufferSize+0xc>
80104dfc:	003b68fa 	trap	3
80104e00:	dfc00515 	stw	ra,20(sp)
80104e04:	df000415 	stw	fp,16(sp)
80104e08:	df000404 	addi	fp,sp,16
80104e0c:	2007883a 	mov	r3,r4
80104e10:	2805883a 	mov	r2,r5
80104e14:	e0fffe05 	stb	r3,-8(fp)
80104e18:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80104e1c:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
80104e20:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
80104e24:	e0bffe03 	ldbu	r2,-8(fp)
80104e28:	10002426 	beq	r2,zero,80104ebc <bFeebCh2SetBufferSize+0xc8>
80104e2c:	e0bffe03 	ldbu	r2,-8(fp)
80104e30:	10800468 	cmpgeui	r2,r2,17
80104e34:	1000211e 	bne	r2,zero,80104ebc <bFeebCh2SetBufferSize+0xc8>
		switch (ucBufferSide) {
80104e38:	e0bfff03 	ldbu	r2,-4(fp)
80104e3c:	10000326 	beq	r2,zero,80104e4c <bFeebCh2SetBufferSize+0x58>
80104e40:	10800060 	cmpeqi	r2,r2,1
80104e44:	10000e1e 	bne	r2,zero,80104e80 <bFeebCh2SetBufferSize+0x8c>
80104e48:	00001a06 	br	80104eb4 <bFeebCh2SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80104e4c:	e0bffe03 	ldbu	r2,-8(fp)
80104e50:	10bfffc4 	addi	r2,r2,-1
80104e54:	108003cc 	andi	r2,r2,15
80104e58:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
80104e5c:	e0bffd17 	ldw	r2,-12(fp)
80104e60:	100d883a 	mov	r6,r2
80104e64:	01400544 	movi	r5,21
80104e68:	01101034 	movhi	r4,16448
80104e6c:	21020004 	addi	r4,r4,2048
80104e70:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80104e74:	00800044 	movi	r2,1
80104e78:	e0bffc15 	stw	r2,-16(fp)
			break;
80104e7c:	00000f06 	br	80104ebc <bFeebCh2SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80104e80:	e0bffe03 	ldbu	r2,-8(fp)
80104e84:	10bfffc4 	addi	r2,r2,-1
80104e88:	108003cc 	andi	r2,r2,15
80104e8c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
80104e90:	e0bffd17 	ldw	r2,-12(fp)
80104e94:	100d883a 	mov	r6,r2
80104e98:	01400504 	movi	r5,20
80104e9c:	01101034 	movhi	r4,16448
80104ea0:	21020004 	addi	r4,r4,2048
80104ea4:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80104ea8:	00800044 	movi	r2,1
80104eac:	e0bffc15 	stw	r2,-16(fp)
			break;
80104eb0:	00000206 	br	80104ebc <bFeebCh2SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
80104eb4:	e03ffc15 	stw	zero,-16(fp)
			break;
80104eb8:	0001883a 	nop
		}
	}

	return bStatus;
80104ebc:	e0bffc17 	ldw	r2,-16(fp)
}
80104ec0:	e037883a 	mov	sp,fp
80104ec4:	dfc00117 	ldw	ra,4(sp)
80104ec8:	df000017 	ldw	fp,0(sp)
80104ecc:	dec00204 	addi	sp,sp,8
80104ed0:	f800283a 	ret

80104ed4 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
80104ed4:	defffa04 	addi	sp,sp,-24
80104ed8:	de00012e 	bgeu	sp,et,80104ee0 <bFeebCh3SetBufferSize+0xc>
80104edc:	003b68fa 	trap	3
80104ee0:	dfc00515 	stw	ra,20(sp)
80104ee4:	df000415 	stw	fp,16(sp)
80104ee8:	df000404 	addi	fp,sp,16
80104eec:	2007883a 	mov	r3,r4
80104ef0:	2805883a 	mov	r2,r5
80104ef4:	e0fffe05 	stb	r3,-8(fp)
80104ef8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80104efc:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
80104f00:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
80104f04:	e0bffe03 	ldbu	r2,-8(fp)
80104f08:	10002426 	beq	r2,zero,80104f9c <bFeebCh3SetBufferSize+0xc8>
80104f0c:	e0bffe03 	ldbu	r2,-8(fp)
80104f10:	10800468 	cmpgeui	r2,r2,17
80104f14:	1000211e 	bne	r2,zero,80104f9c <bFeebCh3SetBufferSize+0xc8>
		switch (ucBufferSide) {
80104f18:	e0bfff03 	ldbu	r2,-4(fp)
80104f1c:	10000326 	beq	r2,zero,80104f2c <bFeebCh3SetBufferSize+0x58>
80104f20:	10800060 	cmpeqi	r2,r2,1
80104f24:	10000e1e 	bne	r2,zero,80104f60 <bFeebCh3SetBufferSize+0x8c>
80104f28:	00001a06 	br	80104f94 <bFeebCh3SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80104f2c:	e0bffe03 	ldbu	r2,-8(fp)
80104f30:	10bfffc4 	addi	r2,r2,-1
80104f34:	108003cc 	andi	r2,r2,15
80104f38:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
80104f3c:	e0bffd17 	ldw	r2,-12(fp)
80104f40:	100d883a 	mov	r6,r2
80104f44:	01400544 	movi	r5,21
80104f48:	01101034 	movhi	r4,16448
80104f4c:	21010004 	addi	r4,r4,1024
80104f50:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80104f54:	00800044 	movi	r2,1
80104f58:	e0bffc15 	stw	r2,-16(fp)
			break;
80104f5c:	00000f06 	br	80104f9c <bFeebCh3SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80104f60:	e0bffe03 	ldbu	r2,-8(fp)
80104f64:	10bfffc4 	addi	r2,r2,-1
80104f68:	108003cc 	andi	r2,r2,15
80104f6c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
80104f70:	e0bffd17 	ldw	r2,-12(fp)
80104f74:	100d883a 	mov	r6,r2
80104f78:	01400504 	movi	r5,20
80104f7c:	01101034 	movhi	r4,16448
80104f80:	21010004 	addi	r4,r4,1024
80104f84:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80104f88:	00800044 	movi	r2,1
80104f8c:	e0bffc15 	stw	r2,-16(fp)
			break;
80104f90:	00000206 	br	80104f9c <bFeebCh3SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
80104f94:	e03ffc15 	stw	zero,-16(fp)
			break;
80104f98:	0001883a 	nop
		}
	}

	return bStatus;
80104f9c:	e0bffc17 	ldw	r2,-16(fp)
}
80104fa0:	e037883a 	mov	sp,fp
80104fa4:	dfc00117 	ldw	ra,4(sp)
80104fa8:	df000017 	ldw	fp,0(sp)
80104fac:	dec00204 	addi	sp,sp,8
80104fb0:	f800283a 	ret

80104fb4 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
80104fb4:	defffa04 	addi	sp,sp,-24
80104fb8:	de00012e 	bgeu	sp,et,80104fc0 <bFeebCh4SetBufferSize+0xc>
80104fbc:	003b68fa 	trap	3
80104fc0:	dfc00515 	stw	ra,20(sp)
80104fc4:	df000415 	stw	fp,16(sp)
80104fc8:	df000404 	addi	fp,sp,16
80104fcc:	2007883a 	mov	r3,r4
80104fd0:	2805883a 	mov	r2,r5
80104fd4:	e0fffe05 	stb	r3,-8(fp)
80104fd8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80104fdc:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
80104fe0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
80104fe4:	e0bffe03 	ldbu	r2,-8(fp)
80104fe8:	10002226 	beq	r2,zero,80105074 <bFeebCh4SetBufferSize+0xc0>
80104fec:	e0bffe03 	ldbu	r2,-8(fp)
80104ff0:	10800468 	cmpgeui	r2,r2,17
80104ff4:	10001f1e 	bne	r2,zero,80105074 <bFeebCh4SetBufferSize+0xc0>
		switch (ucBufferSide) {
80104ff8:	e0bfff03 	ldbu	r2,-4(fp)
80104ffc:	10000326 	beq	r2,zero,8010500c <bFeebCh4SetBufferSize+0x58>
80105000:	10800060 	cmpeqi	r2,r2,1
80105004:	10000d1e 	bne	r2,zero,8010503c <bFeebCh4SetBufferSize+0x88>
80105008:	00001806 	br	8010506c <bFeebCh4SetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
8010500c:	e0bffe03 	ldbu	r2,-8(fp)
80105010:	10bfffc4 	addi	r2,r2,-1
80105014:	108003cc 	andi	r2,r2,15
80105018:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8010501c:	e0bffd17 	ldw	r2,-12(fp)
80105020:	100d883a 	mov	r6,r2
80105024:	01400544 	movi	r5,21
80105028:	01101034 	movhi	r4,16448
8010502c:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80105030:	00800044 	movi	r2,1
80105034:	e0bffc15 	stw	r2,-16(fp)
			break;
80105038:	00000e06 	br	80105074 <bFeebCh4SetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
8010503c:	e0bffe03 	ldbu	r2,-8(fp)
80105040:	10bfffc4 	addi	r2,r2,-1
80105044:	108003cc 	andi	r2,r2,15
80105048:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8010504c:	e0bffd17 	ldw	r2,-12(fp)
80105050:	100d883a 	mov	r6,r2
80105054:	01400504 	movi	r5,20
80105058:	01101034 	movhi	r4,16448
8010505c:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80105060:	00800044 	movi	r2,1
80105064:	e0bffc15 	stw	r2,-16(fp)
			break;
80105068:	00000206 	br	80105074 <bFeebCh4SetBufferSize+0xc0>
		default:
			bStatus = FALSE;
8010506c:	e03ffc15 	stw	zero,-16(fp)
			break;
80105070:	0001883a 	nop
		}
	}

	return bStatus;
80105074:	e0bffc17 	ldw	r2,-16(fp)
}
80105078:	e037883a 	mov	sp,fp
8010507c:	dfc00117 	ldw	ra,4(sp)
80105080:	df000017 	ldw	fp,0(sp)
80105084:	dec00204 	addi	sp,sp,8
80105088:	f800283a 	ret

8010508c <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
8010508c:	defffa04 	addi	sp,sp,-24
80105090:	de00012e 	bgeu	sp,et,80105098 <bFeebCh5SetBufferSize+0xc>
80105094:	003b68fa 	trap	3
80105098:	dfc00515 	stw	ra,20(sp)
8010509c:	df000415 	stw	fp,16(sp)
801050a0:	df000404 	addi	fp,sp,16
801050a4:	2007883a 	mov	r3,r4
801050a8:	2805883a 	mov	r2,r5
801050ac:	e0fffe05 	stb	r3,-8(fp)
801050b0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
801050b4:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
801050b8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
801050bc:	e0bffe03 	ldbu	r2,-8(fp)
801050c0:	10002426 	beq	r2,zero,80105154 <bFeebCh5SetBufferSize+0xc8>
801050c4:	e0bffe03 	ldbu	r2,-8(fp)
801050c8:	10800468 	cmpgeui	r2,r2,17
801050cc:	1000211e 	bne	r2,zero,80105154 <bFeebCh5SetBufferSize+0xc8>
		switch (ucBufferSide) {
801050d0:	e0bfff03 	ldbu	r2,-4(fp)
801050d4:	10000326 	beq	r2,zero,801050e4 <bFeebCh5SetBufferSize+0x58>
801050d8:	10800060 	cmpeqi	r2,r2,1
801050dc:	10000e1e 	bne	r2,zero,80105118 <bFeebCh5SetBufferSize+0x8c>
801050e0:	00001a06 	br	8010514c <bFeebCh5SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
801050e4:	e0bffe03 	ldbu	r2,-8(fp)
801050e8:	10bfffc4 	addi	r2,r2,-1
801050ec:	108003cc 	andi	r2,r2,15
801050f0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
801050f4:	e0bffd17 	ldw	r2,-12(fp)
801050f8:	100d883a 	mov	r6,r2
801050fc:	01400544 	movi	r5,21
80105100:	01101034 	movhi	r4,16448
80105104:	21030004 	addi	r4,r4,3072
80105108:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
8010510c:	00800044 	movi	r2,1
80105110:	e0bffc15 	stw	r2,-16(fp)
			break;
80105114:	00000f06 	br	80105154 <bFeebCh5SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80105118:	e0bffe03 	ldbu	r2,-8(fp)
8010511c:	10bfffc4 	addi	r2,r2,-1
80105120:	108003cc 	andi	r2,r2,15
80105124:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
80105128:	e0bffd17 	ldw	r2,-12(fp)
8010512c:	100d883a 	mov	r6,r2
80105130:	01400504 	movi	r5,20
80105134:	01101034 	movhi	r4,16448
80105138:	21030004 	addi	r4,r4,3072
8010513c:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80105140:	00800044 	movi	r2,1
80105144:	e0bffc15 	stw	r2,-16(fp)
			break;
80105148:	00000206 	br	80105154 <bFeebCh5SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
8010514c:	e03ffc15 	stw	zero,-16(fp)
			break;
80105150:	0001883a 	nop
		}
	}

	return bStatus;
80105154:	e0bffc17 	ldw	r2,-16(fp)
}
80105158:	e037883a 	mov	sp,fp
8010515c:	dfc00117 	ldw	ra,4(sp)
80105160:	df000017 	ldw	fp,0(sp)
80105164:	dec00204 	addi	sp,sp,8
80105168:	f800283a 	ret

8010516c <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
8010516c:	defffa04 	addi	sp,sp,-24
80105170:	de00012e 	bgeu	sp,et,80105178 <bFeebCh6SetBufferSize+0xc>
80105174:	003b68fa 	trap	3
80105178:	dfc00515 	stw	ra,20(sp)
8010517c:	df000415 	stw	fp,16(sp)
80105180:	df000404 	addi	fp,sp,16
80105184:	2007883a 	mov	r3,r4
80105188:	2805883a 	mov	r2,r5
8010518c:	e0fffe05 	stb	r3,-8(fp)
80105190:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80105194:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
80105198:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
8010519c:	e0bffe03 	ldbu	r2,-8(fp)
801051a0:	10002426 	beq	r2,zero,80105234 <bFeebCh6SetBufferSize+0xc8>
801051a4:	e0bffe03 	ldbu	r2,-8(fp)
801051a8:	10800468 	cmpgeui	r2,r2,17
801051ac:	1000211e 	bne	r2,zero,80105234 <bFeebCh6SetBufferSize+0xc8>
		switch (ucBufferSide) {
801051b0:	e0bfff03 	ldbu	r2,-4(fp)
801051b4:	10000326 	beq	r2,zero,801051c4 <bFeebCh6SetBufferSize+0x58>
801051b8:	10800060 	cmpeqi	r2,r2,1
801051bc:	10000e1e 	bne	r2,zero,801051f8 <bFeebCh6SetBufferSize+0x8c>
801051c0:	00001a06 	br	8010522c <bFeebCh6SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
801051c4:	e0bffe03 	ldbu	r2,-8(fp)
801051c8:	10bfffc4 	addi	r2,r2,-1
801051cc:	108003cc 	andi	r2,r2,15
801051d0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
801051d4:	e0bffd17 	ldw	r2,-12(fp)
801051d8:	100d883a 	mov	r6,r2
801051dc:	01400544 	movi	r5,21
801051e0:	01101034 	movhi	r4,16448
801051e4:	21020004 	addi	r4,r4,2048
801051e8:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
801051ec:	00800044 	movi	r2,1
801051f0:	e0bffc15 	stw	r2,-16(fp)
			break;
801051f4:	00000f06 	br	80105234 <bFeebCh6SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
801051f8:	e0bffe03 	ldbu	r2,-8(fp)
801051fc:	10bfffc4 	addi	r2,r2,-1
80105200:	108003cc 	andi	r2,r2,15
80105204:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
80105208:	e0bffd17 	ldw	r2,-12(fp)
8010520c:	100d883a 	mov	r6,r2
80105210:	01400504 	movi	r5,20
80105214:	01101034 	movhi	r4,16448
80105218:	21020004 	addi	r4,r4,2048
8010521c:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80105220:	00800044 	movi	r2,1
80105224:	e0bffc15 	stw	r2,-16(fp)
			break;
80105228:	00000206 	br	80105234 <bFeebCh6SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
8010522c:	e03ffc15 	stw	zero,-16(fp)
			break;
80105230:	0001883a 	nop
		}
	}

	return bStatus;
80105234:	e0bffc17 	ldw	r2,-16(fp)
}
80105238:	e037883a 	mov	sp,fp
8010523c:	dfc00117 	ldw	ra,4(sp)
80105240:	df000017 	ldw	fp,0(sp)
80105244:	dec00204 	addi	sp,sp,8
80105248:	f800283a 	ret

8010524c <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
8010524c:	defffa04 	addi	sp,sp,-24
80105250:	de00012e 	bgeu	sp,et,80105258 <bFeebCh7SetBufferSize+0xc>
80105254:	003b68fa 	trap	3
80105258:	dfc00515 	stw	ra,20(sp)
8010525c:	df000415 	stw	fp,16(sp)
80105260:	df000404 	addi	fp,sp,16
80105264:	2007883a 	mov	r3,r4
80105268:	2805883a 	mov	r2,r5
8010526c:	e0fffe05 	stb	r3,-8(fp)
80105270:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80105274:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
80105278:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
8010527c:	e0bffe03 	ldbu	r2,-8(fp)
80105280:	10002426 	beq	r2,zero,80105314 <bFeebCh7SetBufferSize+0xc8>
80105284:	e0bffe03 	ldbu	r2,-8(fp)
80105288:	10800468 	cmpgeui	r2,r2,17
8010528c:	1000211e 	bne	r2,zero,80105314 <bFeebCh7SetBufferSize+0xc8>
		switch (ucBufferSide) {
80105290:	e0bfff03 	ldbu	r2,-4(fp)
80105294:	10000326 	beq	r2,zero,801052a4 <bFeebCh7SetBufferSize+0x58>
80105298:	10800060 	cmpeqi	r2,r2,1
8010529c:	10000e1e 	bne	r2,zero,801052d8 <bFeebCh7SetBufferSize+0x8c>
801052a0:	00001a06 	br	8010530c <bFeebCh7SetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
801052a4:	e0bffe03 	ldbu	r2,-8(fp)
801052a8:	10bfffc4 	addi	r2,r2,-1
801052ac:	108003cc 	andi	r2,r2,15
801052b0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
801052b4:	e0bffd17 	ldw	r2,-12(fp)
801052b8:	100d883a 	mov	r6,r2
801052bc:	01400544 	movi	r5,21
801052c0:	01101034 	movhi	r4,16448
801052c4:	21010004 	addi	r4,r4,1024
801052c8:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
801052cc:	00800044 	movi	r2,1
801052d0:	e0bffc15 	stw	r2,-16(fp)
			break;
801052d4:	00000f06 	br	80105314 <bFeebCh7SetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
801052d8:	e0bffe03 	ldbu	r2,-8(fp)
801052dc:	10bfffc4 	addi	r2,r2,-1
801052e0:	108003cc 	andi	r2,r2,15
801052e4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
801052e8:	e0bffd17 	ldw	r2,-12(fp)
801052ec:	100d883a 	mov	r6,r2
801052f0:	01400504 	movi	r5,20
801052f4:	01101034 	movhi	r4,16448
801052f8:	21010004 	addi	r4,r4,1024
801052fc:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
80105300:	00800044 	movi	r2,1
80105304:	e0bffc15 	stw	r2,-16(fp)
			break;
80105308:	00000206 	br	80105314 <bFeebCh7SetBufferSize+0xc8>
		default:
			bStatus = FALSE;
8010530c:	e03ffc15 	stw	zero,-16(fp)
			break;
80105310:	0001883a 	nop
		}
	}

	return bStatus;
80105314:	e0bffc17 	ldw	r2,-16(fp)
}
80105318:	e037883a 	mov	sp,fp
8010531c:	dfc00117 	ldw	ra,4(sp)
80105320:	df000017 	ldw	fp,0(sp)
80105324:	dec00204 	addi	sp,sp,8
80105328:	f800283a 	ret

8010532c <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
8010532c:	defffa04 	addi	sp,sp,-24
80105330:	de00012e 	bgeu	sp,et,80105338 <bFeebCh8SetBufferSize+0xc>
80105334:	003b68fa 	trap	3
80105338:	dfc00515 	stw	ra,20(sp)
8010533c:	df000415 	stw	fp,16(sp)
80105340:	df000404 	addi	fp,sp,16
80105344:	2007883a 	mov	r3,r4
80105348:	2805883a 	mov	r2,r5
8010534c:	e0fffe05 	stb	r3,-8(fp)
80105350:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80105354:	e03ffc15 	stw	zero,-16(fp)
	volatile alt_u32 uliReg = 0;
80105358:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
8010535c:	e0bffe03 	ldbu	r2,-8(fp)
80105360:	10002226 	beq	r2,zero,801053ec <bFeebCh8SetBufferSize+0xc0>
80105364:	e0bffe03 	ldbu	r2,-8(fp)
80105368:	10800468 	cmpgeui	r2,r2,17
8010536c:	10001f1e 	bne	r2,zero,801053ec <bFeebCh8SetBufferSize+0xc0>
		switch (ucBufferSide) {
80105370:	e0bfff03 	ldbu	r2,-4(fp)
80105374:	10000326 	beq	r2,zero,80105384 <bFeebCh8SetBufferSize+0x58>
80105378:	10800060 	cmpeqi	r2,r2,1
8010537c:	10000d1e 	bne	r2,zero,801053b4 <bFeebCh8SetBufferSize+0x88>
80105380:	00001806 	br	801053e4 <bFeebCh8SetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80105384:	e0bffe03 	ldbu	r2,-8(fp)
80105388:	10bfffc4 	addi	r2,r2,-1
8010538c:	108003cc 	andi	r2,r2,15
80105390:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
80105394:	e0bffd17 	ldw	r2,-12(fp)
80105398:	100d883a 	mov	r6,r2
8010539c:	01400544 	movi	r5,21
801053a0:	01101034 	movhi	r4,16448
801053a4:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
801053a8:	00800044 	movi	r2,1
801053ac:	e0bffc15 	stw	r2,-16(fp)
			break;
801053b0:	00000e06 	br	801053ec <bFeebCh8SetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
801053b4:	e0bffe03 	ldbu	r2,-8(fp)
801053b8:	10bfffc4 	addi	r2,r2,-1
801053bc:	108003cc 	andi	r2,r2,15
801053c0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
801053c4:	e0bffd17 	ldw	r2,-12(fp)
801053c8:	100d883a 	mov	r6,r2
801053cc:	01400504 	movi	r5,20
801053d0:	01101034 	movhi	r4,16448
801053d4:	01072840 	call	80107284 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			bStatus = TRUE;
801053d8:	00800044 	movi	r2,1
801053dc:	e0bffc15 	stw	r2,-16(fp)
			break;
801053e0:	00000206 	br	801053ec <bFeebCh8SetBufferSize+0xc0>
		default:
			bStatus = FALSE;
801053e4:	e03ffc15 	stw	zero,-16(fp)
			break;
801053e8:	0001883a 	nop
		}
	}

	return bStatus;
801053ec:	e0bffc17 	ldw	r2,-16(fp)
}
801053f0:	e037883a 	mov	sp,fp
801053f4:	dfc00117 	ldw	ra,4(sp)
801053f8:	df000017 	ldw	fp,0(sp)
801053fc:	dec00204 	addi	sp,sp,8
80105400:	f800283a 	ret

80105404 <vFeebInitIrq>:

bool vFeebInitIrq(alt_u8 ucCommCh) {
80105404:	defffb04 	addi	sp,sp,-20
80105408:	de00012e 	bgeu	sp,et,80105410 <vFeebInitIrq+0xc>
8010540c:	003b68fa 	trap	3
80105410:	dfc00415 	stw	ra,16(sp)
80105414:	df000315 	stw	fp,12(sp)
80105418:	df000304 	addi	fp,sp,12
8010541c:	2005883a 	mov	r2,r4
80105420:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80105424:	e03ffd15 	stw	zero,-12(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
80105428:	e0bfff03 	ldbu	r2,-4(fp)
8010542c:	10c00228 	cmpgeui	r3,r2,8
80105430:	18005e1e 	bne	r3,zero,801055ac <vFeebInitIrq+0x1a8>
80105434:	100690ba 	slli	r3,r2,2
80105438:	00a00434 	movhi	r2,32784
8010543c:	10951304 	addi	r2,r2,21580
80105440:	1885883a 	add	r2,r3,r2
80105444:	10800017 	ldw	r2,0(r2)
80105448:	1000683a 	jmp	r2
8010544c:	8010546c 	andhi	zero,r16,16721
80105450:	80105494 	ori	zero,r16,16722
80105454:	801054bc 	xorhi	zero,r16,16722
80105458:	801054e4 	muli	zero,r16,16723
8010545c:	8010550c 	andi	zero,r16,16724
80105460:	80105534 	orhi	zero,r16,16724
80105464:	8010555c 	xori	zero,r16,16725
80105468:	80105584 	addi	zero,r16,16726
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
8010546c:	d0a04004 	addi	r2,gp,-32512
80105470:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
80105474:	01a00434 	movhi	r6,32784
80105478:	318db104 	addi	r6,r6,14020
8010547c:	e17ffe17 	ldw	r5,-8(fp)
80105480:	01000044 	movi	r4,1
80105484:	0131c940 	call	80131c94 <alt_irq_register>
				vFeebCh1HandleIrq);

		bStatus = TRUE;
80105488:	00800044 	movi	r2,1
8010548c:	e0bffd15 	stw	r2,-12(fp)
		break;
80105490:	00004806 	br	801055b4 <vFeebInitIrq+0x1b0>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
80105494:	d0a04104 	addi	r2,gp,-32508
80105498:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
8010549c:	01a00434 	movhi	r6,32784
801054a0:	318e3204 	addi	r6,r6,14536
801054a4:	e17ffe17 	ldw	r5,-8(fp)
801054a8:	0009883a 	mov	r4,zero
801054ac:	0131c940 	call	80131c94 <alt_irq_register>
				vFeebCh2HandleIrq);
		bStatus = TRUE;
801054b0:	00800044 	movi	r2,1
801054b4:	e0bffd15 	stw	r2,-12(fp)
		break;
801054b8:	00003e06 	br	801055b4 <vFeebInitIrq+0x1b0>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
801054bc:	d0a04204 	addi	r2,gp,-32504
801054c0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
801054c4:	01a00434 	movhi	r6,32784
801054c8:	318eb304 	addi	r6,r6,15052
801054cc:	e17ffe17 	ldw	r5,-8(fp)
801054d0:	01000084 	movi	r4,2
801054d4:	0131c940 	call	80131c94 <alt_irq_register>
				vFeebCh3HandleIrq);
		bStatus = TRUE;
801054d8:	00800044 	movi	r2,1
801054dc:	e0bffd15 	stw	r2,-12(fp)
		break;
801054e0:	00003406 	br	801055b4 <vFeebInitIrq+0x1b0>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
801054e4:	d0a04304 	addi	r2,gp,-32500
801054e8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
801054ec:	01a00434 	movhi	r6,32784
801054f0:	318f3404 	addi	r6,r6,15568
801054f4:	e17ffe17 	ldw	r5,-8(fp)
801054f8:	010000c4 	movi	r4,3
801054fc:	0131c940 	call	80131c94 <alt_irq_register>
				vFeebCh4HandleIrq);
		bStatus = TRUE;
80105500:	00800044 	movi	r2,1
80105504:	e0bffd15 	stw	r2,-12(fp)
		break;
80105508:	00002a06 	br	801055b4 <vFeebInitIrq+0x1b0>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
8010550c:	d0a04404 	addi	r2,gp,-32496
80105510:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
80105514:	01a00434 	movhi	r6,32784
80105518:	318fb504 	addi	r6,r6,16084
8010551c:	e17ffe17 	ldw	r5,-8(fp)
80105520:	013fffc4 	movi	r4,-1
80105524:	0131c940 	call	80131c94 <alt_irq_register>
				vFeebCh5HandleIrq);
		bStatus = TRUE;
80105528:	00800044 	movi	r2,1
8010552c:	e0bffd15 	stw	r2,-12(fp)
		break;
80105530:	00002006 	br	801055b4 <vFeebInitIrq+0x1b0>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
80105534:	d0a04504 	addi	r2,gp,-32492
80105538:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
8010553c:	01a00434 	movhi	r6,32784
80105540:	318fc004 	addi	r6,r6,16128
80105544:	e17ffe17 	ldw	r5,-8(fp)
80105548:	013fffc4 	movi	r4,-1
8010554c:	0131c940 	call	80131c94 <alt_irq_register>
				vFeebCh6HandleIrq);
		bStatus = TRUE;
80105550:	00800044 	movi	r2,1
80105554:	e0bffd15 	stw	r2,-12(fp)
		break;
80105558:	00001606 	br	801055b4 <vFeebInitIrq+0x1b0>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
8010555c:	d0a04604 	addi	r2,gp,-32488
80105560:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
80105564:	01a00434 	movhi	r6,32784
80105568:	318fcb04 	addi	r6,r6,16172
8010556c:	e17ffe17 	ldw	r5,-8(fp)
80105570:	013fffc4 	movi	r4,-1
80105574:	0131c940 	call	80131c94 <alt_irq_register>
				vFeebCh7HandleIrq);
		bStatus = TRUE;
80105578:	00800044 	movi	r2,1
8010557c:	e0bffd15 	stw	r2,-12(fp)
		break;
80105580:	00000c06 	br	801055b4 <vFeebInitIrq+0x1b0>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
80105584:	d0a04704 	addi	r2,gp,-32484
80105588:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
8010558c:	01a00434 	movhi	r6,32784
80105590:	318fd604 	addi	r6,r6,16216
80105594:	e17ffe17 	ldw	r5,-8(fp)
80105598:	013fffc4 	movi	r4,-1
8010559c:	0131c940 	call	80131c94 <alt_irq_register>
				vFeebCh8HandleIrq);
		bStatus = TRUE;
801055a0:	00800044 	movi	r2,1
801055a4:	e0bffd15 	stw	r2,-12(fp)
		break;
801055a8:	00000206 	br	801055b4 <vFeebInitIrq+0x1b0>
	default:
		bStatus = FALSE;
801055ac:	e03ffd15 	stw	zero,-12(fp)
		break;
801055b0:	0001883a 	nop
	}

	return bStatus;
801055b4:	e0bffd17 	ldw	r2,-12(fp)
}
801055b8:	e037883a 	mov	sp,fp
801055bc:	dfc00117 	ldw	ra,4(sp)
801055c0:	df000017 	ldw	fp,0(sp)
801055c4:	dec00204 	addi	sp,sp,8
801055c8:	f800283a 	ret

801055cc <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
801055cc:	defffb04 	addi	sp,sp,-20
801055d0:	de00012e 	bgeu	sp,et,801055d8 <bFeebSetIrqControl+0xc>
801055d4:	003b68fa 	trap	3
801055d8:	dfc00415 	stw	ra,16(sp)
801055dc:	df000315 	stw	fp,12(sp)
801055e0:	df000304 	addi	fp,sp,12
801055e4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
801055e8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
801055ec:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
801055f0:	e0bfff17 	ldw	r2,-4(fp)
801055f4:	10002526 	beq	r2,zero,8010568c <bFeebSetIrqControl+0xc0>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
801055f8:	e0bfff17 	ldw	r2,-4(fp)
801055fc:	10800017 	ldw	r2,0(r2)
80105600:	01400444 	movi	r5,17
80105604:	1009883a 	mov	r4,r2
80105608:	01072d80 	call	801072d8 <uliFeebReadReg>
8010560c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
80105610:	e0bfff17 	ldw	r2,-4(fp)
80105614:	10800217 	ldw	r2,8(r2)
80105618:	10000426 	beq	r2,zero,8010562c <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
8010561c:	e0bffe17 	ldw	r2,-8(fp)
80105620:	10808014 	ori	r2,r2,512
80105624:	e0bffe15 	stw	r2,-8(fp)
80105628:	00000406 	br	8010563c <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
8010562c:	e0fffe17 	ldw	r3,-8(fp)
80105630:	00bf7fc4 	movi	r2,-513
80105634:	1884703a 	and	r2,r3,r2
80105638:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
8010563c:	e0bfff17 	ldw	r2,-4(fp)
80105640:	10800317 	ldw	r2,12(r2)
80105644:	10000426 	beq	r2,zero,80105658 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
80105648:	e0bffe17 	ldw	r2,-8(fp)
8010564c:	10804014 	ori	r2,r2,256
80105650:	e0bffe15 	stw	r2,-8(fp)
80105654:	00000406 	br	80105668 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
80105658:	e0fffe17 	ldw	r3,-8(fp)
8010565c:	00bfbfc4 	movi	r2,-257
80105660:	1884703a 	and	r2,r3,r2
80105664:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
80105668:	e0bfff17 	ldw	r2,-4(fp)
8010566c:	10800017 	ldw	r2,0(r2)
80105670:	e0fffe17 	ldw	r3,-8(fp)
80105674:	180d883a 	mov	r6,r3
80105678:	01400444 	movi	r5,17
8010567c:	1009883a 	mov	r4,r2
80105680:	01072840 	call	80107284 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
80105684:	00800044 	movi	r2,1
80105688:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010568c:	e0bffd17 	ldw	r2,-12(fp)
}
80105690:	e037883a 	mov	sp,fp
80105694:	dfc00117 	ldw	ra,4(sp)
80105698:	df000017 	ldw	fp,0(sp)
8010569c:	dec00204 	addi	sp,sp,8
801056a0:	f800283a 	ret

801056a4 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
801056a4:	defffb04 	addi	sp,sp,-20
801056a8:	de00012e 	bgeu	sp,et,801056b0 <bFeebGetIrqControl+0xc>
801056ac:	003b68fa 	trap	3
801056b0:	dfc00415 	stw	ra,16(sp)
801056b4:	df000315 	stw	fp,12(sp)
801056b8:	df000304 	addi	fp,sp,12
801056bc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
801056c0:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
801056c4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
801056c8:	e0bfff17 	ldw	r2,-4(fp)
801056cc:	10001a26 	beq	r2,zero,80105738 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
801056d0:	e0bfff17 	ldw	r2,-4(fp)
801056d4:	10800017 	ldw	r2,0(r2)
801056d8:	01400444 	movi	r5,17
801056dc:	1009883a 	mov	r4,r2
801056e0:	01072d80 	call	801072d8 <uliFeebReadReg>
801056e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
801056e8:	e0bffe17 	ldw	r2,-8(fp)
801056ec:	1080800c 	andi	r2,r2,512
801056f0:	10000426 	beq	r2,zero,80105704 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
801056f4:	e0bfff17 	ldw	r2,-4(fp)
801056f8:	00c00044 	movi	r3,1
801056fc:	10c00215 	stw	r3,8(r2)
80105700:	00000206 	br	8010570c <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
80105704:	e0bfff17 	ldw	r2,-4(fp)
80105708:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
8010570c:	e0bffe17 	ldw	r2,-8(fp)
80105710:	1080400c 	andi	r2,r2,256
80105714:	10000426 	beq	r2,zero,80105728 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
80105718:	e0bfff17 	ldw	r2,-4(fp)
8010571c:	00c00044 	movi	r3,1
80105720:	10c00315 	stw	r3,12(r2)
80105724:	00000206 	br	80105730 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
80105728:	e0bfff17 	ldw	r2,-4(fp)
8010572c:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
80105730:	00800044 	movi	r2,1
80105734:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80105738:	e0bffd17 	ldw	r2,-12(fp)
}
8010573c:	e037883a 	mov	sp,fp
80105740:	dfc00117 	ldw	ra,4(sp)
80105744:	df000017 	ldw	fp,0(sp)
80105748:	dec00204 	addi	sp,sp,8
8010574c:	f800283a 	ret

80105750 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
80105750:	defffb04 	addi	sp,sp,-20
80105754:	de00012e 	bgeu	sp,et,8010575c <bFeebGetIrqFlags+0xc>
80105758:	003b68fa 	trap	3
8010575c:	dfc00415 	stw	ra,16(sp)
80105760:	df000315 	stw	fp,12(sp)
80105764:	df000304 	addi	fp,sp,12
80105768:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8010576c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80105770:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
80105774:	e0bfff17 	ldw	r2,-4(fp)
80105778:	10002c26 	beq	r2,zero,8010582c <bFeebGetIrqFlags+0xdc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8010577c:	e0bfff17 	ldw	r2,-4(fp)
80105780:	10800017 	ldw	r2,0(r2)
80105784:	01400484 	movi	r5,18
80105788:	1009883a 	mov	r4,r2
8010578c:	01072d80 	call	801072d8 <uliFeebReadReg>
80105790:	e0bffe15 	stw	r2,-8(fp)
				COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_L_BUFF_0_EPY_FLG_MSK) {
80105794:	e0bffe17 	ldw	r2,-8(fp)
80105798:	1081000c 	andi	r2,r2,1024
8010579c:	10000426 	beq	r2,zero,801057b0 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bLeftBufferEmpty0Flag = TRUE;
801057a0:	e0bfff17 	ldw	r2,-4(fp)
801057a4:	00c00044 	movi	r3,1
801057a8:	10c00415 	stw	r3,16(r2)
801057ac:	00000206 	br	801057b8 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bLeftBufferEmpty0Flag = FALSE;
801057b0:	e0bfff17 	ldw	r2,-4(fp)
801057b4:	10000415 	stw	zero,16(r2)
		}

		if (uliReg & COMM_IRQ_L_BUFF_1_EPY_FLG_MSK) {
801057b8:	e0bffe17 	ldw	r2,-8(fp)
801057bc:	1082000c 	andi	r2,r2,2048
801057c0:	10000426 	beq	r2,zero,801057d4 <bFeebGetIrqFlags+0x84>
			pxFeebCh->xIrqFlag.bLeftBufferEmpty1Flag = TRUE;
801057c4:	e0bfff17 	ldw	r2,-4(fp)
801057c8:	00c00044 	movi	r3,1
801057cc:	10c00515 	stw	r3,20(r2)
801057d0:	00000206 	br	801057dc <bFeebGetIrqFlags+0x8c>
		} else {
			pxFeebCh->xIrqFlag.bLeftBufferEmpty1Flag = FALSE;
801057d4:	e0bfff17 	ldw	r2,-4(fp)
801057d8:	10000515 	stw	zero,20(r2)
		}

		if (uliReg & COMM_IRQ_R_BUFF_0_EPY_FLG_MSK) {
801057dc:	e0bffe17 	ldw	r2,-8(fp)
801057e0:	1080400c 	andi	r2,r2,256
801057e4:	10000426 	beq	r2,zero,801057f8 <bFeebGetIrqFlags+0xa8>
			pxFeebCh->xIrqFlag.bRightBufferEmpty0Flag = TRUE;
801057e8:	e0bfff17 	ldw	r2,-4(fp)
801057ec:	00c00044 	movi	r3,1
801057f0:	10c00615 	stw	r3,24(r2)
801057f4:	00000206 	br	80105800 <bFeebGetIrqFlags+0xb0>
		} else {
			pxFeebCh->xIrqFlag.bRightBufferEmpty0Flag = FALSE;
801057f8:	e0bfff17 	ldw	r2,-4(fp)
801057fc:	10000615 	stw	zero,24(r2)
		}

		if (uliReg & COMM_IRQ_R_BUFF_1_EPY_FLG_MSK) {
80105800:	e0bffe17 	ldw	r2,-8(fp)
80105804:	1080800c 	andi	r2,r2,512
80105808:	10000426 	beq	r2,zero,8010581c <bFeebGetIrqFlags+0xcc>
			pxFeebCh->xIrqFlag.bRightBufferEmpty1Flag = TRUE;
8010580c:	e0bfff17 	ldw	r2,-4(fp)
80105810:	00c00044 	movi	r3,1
80105814:	10c00715 	stw	r3,28(r2)
80105818:	00000206 	br	80105824 <bFeebGetIrqFlags+0xd4>
		} else {
			pxFeebCh->xIrqFlag.bRightBufferEmpty1Flag = FALSE;
8010581c:	e0bfff17 	ldw	r2,-4(fp)
80105820:	10000715 	stw	zero,28(r2)
		}

		bStatus = TRUE;
80105824:	00800044 	movi	r2,1
80105828:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010582c:	e0bffd17 	ldw	r2,-12(fp)
}
80105830:	e037883a 	mov	sp,fp
80105834:	dfc00117 	ldw	ra,4(sp)
80105838:	df000017 	ldw	fp,0(sp)
8010583c:	dec00204 	addi	sp,sp,8
80105840:	f800283a 	ret

80105844 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
80105844:	defffb04 	addi	sp,sp,-20
80105848:	de00012e 	bgeu	sp,et,80105850 <bFeebGetBuffersStatus+0xc>
8010584c:	003b68fa 	trap	3
80105850:	dfc00415 	stw	ra,16(sp)
80105854:	df000315 	stw	fp,12(sp)
80105858:	df000304 	addi	fp,sp,12
8010585c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80105860:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80105864:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
80105868:	e0bfff17 	ldw	r2,-4(fp)
8010586c:	10004426 	beq	r2,zero,80105980 <bFeebGetBuffersStatus+0x13c>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80105870:	e0bfff17 	ldw	r2,-4(fp)
80105874:	10800017 	ldw	r2,0(r2)
80105878:	014000c4 	movi	r5,3
8010587c:	1009883a 	mov	r4,r2
80105880:	01072d80 	call	801072d8 <uliFeebReadReg>
80105884:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
80105888:	e0bffe17 	ldw	r2,-8(fp)
8010588c:	1080008c 	andi	r2,r2,2
80105890:	10000426 	beq	r2,zero,801058a4 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
80105894:	e0bfff17 	ldw	r2,-4(fp)
80105898:	00c00044 	movi	r3,1
8010589c:	10c00815 	stw	r3,32(r2)
801058a0:	00000206 	br	801058ac <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
801058a4:	e0bfff17 	ldw	r2,-4(fp)
801058a8:	10000815 	stw	zero,32(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
801058ac:	e0bffe17 	ldw	r2,-8(fp)
801058b0:	1080004c 	andi	r2,r2,1
801058b4:	10000426 	beq	r2,zero,801058c8 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
801058b8:	e0bfff17 	ldw	r2,-4(fp)
801058bc:	00c00044 	movi	r3,1
801058c0:	10c00915 	stw	r3,36(r2)
801058c4:	00000206 	br	801058d0 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
801058c8:	e0bfff17 	ldw	r2,-4(fp)
801058cc:	10000915 	stw	zero,36(r2)
		}

		if (uliReg & COMM_WIND_RIGH_FEE_BUSY_MSK) {
801058d0:	e0bffe17 	ldw	r2,-8(fp)
801058d4:	1080400c 	andi	r2,r2,256
801058d8:	10000426 	beq	r2,zero,801058ec <bFeebGetBuffersStatus+0xa8>
			pxFeebCh->xBufferStatus.bRightFeeBusy = TRUE;
801058dc:	e0bfff17 	ldw	r2,-4(fp)
801058e0:	00c00044 	movi	r3,1
801058e4:	10c00b15 	stw	r3,44(r2)
801058e8:	00000206 	br	801058f4 <bFeebGetBuffersStatus+0xb0>
		} else {
			pxFeebCh->xBufferStatus.bRightFeeBusy = FALSE;
801058ec:	e0bfff17 	ldw	r2,-4(fp)
801058f0:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_WIND_LEFT_FEE_BUSY_MSK) {
801058f4:	e0bffe17 	ldw	r2,-8(fp)
801058f8:	1080800c 	andi	r2,r2,512
801058fc:	10000426 	beq	r2,zero,80105910 <bFeebGetBuffersStatus+0xcc>
			pxFeebCh->xBufferStatus.bLeftFeeBusy = TRUE;
80105900:	e0bfff17 	ldw	r2,-4(fp)
80105904:	00c00044 	movi	r3,1
80105908:	10c00a15 	stw	r3,40(r2)
8010590c:	00000206 	br	80105918 <bFeebGetBuffersStatus+0xd4>
		} else {
			pxFeebCh->xBufferStatus.bLeftFeeBusy = FALSE;
80105910:	e0bfff17 	ldw	r2,-4(fp)
80105914:	10000a15 	stw	zero,40(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80105918:	e0bfff17 	ldw	r2,-4(fp)
8010591c:	10800017 	ldw	r2,0(r2)
80105920:	01400504 	movi	r5,20
80105924:	1009883a 	mov	r4,r2
80105928:	01072d80 	call	801072d8 <uliFeebReadReg>
8010592c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
80105930:	e0bffe17 	ldw	r2,-8(fp)
80105934:	108003cc 	andi	r2,r2,15
80105938:	10800044 	addi	r2,r2,1
8010593c:	1007883a 	mov	r3,r2
80105940:	e0bfff17 	ldw	r2,-4(fp)
80105944:	10c00c45 	stb	r3,49(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80105948:	e0bfff17 	ldw	r2,-4(fp)
8010594c:	10800017 	ldw	r2,0(r2)
80105950:	01400544 	movi	r5,21
80105954:	1009883a 	mov	r4,r2
80105958:	01072d80 	call	801072d8 <uliFeebReadReg>
8010595c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
80105960:	e0bffe17 	ldw	r2,-8(fp)
80105964:	108003cc 	andi	r2,r2,15
80105968:	10800044 	addi	r2,r2,1
8010596c:	1007883a 	mov	r3,r2
80105970:	e0bfff17 	ldw	r2,-4(fp)
80105974:	10c00c45 	stb	r3,49(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
80105978:	00800044 	movi	r2,1
8010597c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80105980:	e0bffd17 	ldw	r2,-12(fp)
}
80105984:	e037883a 	mov	sp,fp
80105988:	dfc00117 	ldw	ra,4(sp)
8010598c:	df000017 	ldw	fp,0(sp)
80105990:	dec00204 	addi	sp,sp,8
80105994:	f800283a 	ret

80105998 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh) {
80105998:	defffb04 	addi	sp,sp,-20
8010599c:	de00012e 	bgeu	sp,et,801059a4 <bFeebGetLeftBufferEmpty+0xc>
801059a0:	003b68fa 	trap	3
801059a4:	dfc00415 	stw	ra,16(sp)
801059a8:	df000315 	stw	fp,12(sp)
801059ac:	df000304 	addi	fp,sp,12
801059b0:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
801059b4:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
801059b8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
801059bc:	e0bfff17 	ldw	r2,-4(fp)
801059c0:	10000d26 	beq	r2,zero,801059f8 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
801059c4:	e0bfff17 	ldw	r2,-4(fp)
801059c8:	10800017 	ldw	r2,0(r2)
801059cc:	014000c4 	movi	r5,3
801059d0:	1009883a 	mov	r4,r2
801059d4:	01072d80 	call	801072d8 <uliFeebReadReg>
801059d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
801059dc:	e0bffe17 	ldw	r2,-8(fp)
801059e0:	1080008c 	andi	r2,r2,2
801059e4:	10000326 	beq	r2,zero,801059f4 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
801059e8:	00800044 	movi	r2,1
801059ec:	e0bffd15 	stw	r2,-12(fp)
801059f0:	00000106 	br	801059f8 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
801059f4:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
801059f8:	e0bffd17 	ldw	r2,-12(fp)
}
801059fc:	e037883a 	mov	sp,fp
80105a00:	dfc00117 	ldw	ra,4(sp)
80105a04:	df000017 	ldw	fp,0(sp)
80105a08:	dec00204 	addi	sp,sp,8
80105a0c:	f800283a 	ret

80105a10 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh) {
80105a10:	defffb04 	addi	sp,sp,-20
80105a14:	de00012e 	bgeu	sp,et,80105a1c <bFeebGetRightBufferEmpty+0xc>
80105a18:	003b68fa 	trap	3
80105a1c:	dfc00415 	stw	ra,16(sp)
80105a20:	df000315 	stw	fp,12(sp)
80105a24:	df000304 	addi	fp,sp,12
80105a28:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
80105a2c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80105a30:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
80105a34:	e0bfff17 	ldw	r2,-4(fp)
80105a38:	10000d26 	beq	r2,zero,80105a70 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80105a3c:	e0bfff17 	ldw	r2,-4(fp)
80105a40:	10800017 	ldw	r2,0(r2)
80105a44:	014000c4 	movi	r5,3
80105a48:	1009883a 	mov	r4,r2
80105a4c:	01072d80 	call	801072d8 <uliFeebReadReg>
80105a50:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
80105a54:	e0bffe17 	ldw	r2,-8(fp)
80105a58:	1080004c 	andi	r2,r2,1
80105a5c:	10000326 	beq	r2,zero,80105a6c <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
80105a60:	00800044 	movi	r2,1
80105a64:	e0bffd15 	stw	r2,-12(fp)
80105a68:	00000106 	br	80105a70 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
80105a6c:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
80105a70:	e0bffd17 	ldw	r2,-12(fp)
}
80105a74:	e037883a 	mov	sp,fp
80105a78:	dfc00117 	ldw	ra,4(sp)
80105a7c:	df000017 	ldw	fp,0(sp)
80105a80:	dec00204 	addi	sp,sp,8
80105a84:	f800283a 	ret

80105a88 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void) {
80105a88:	defff804 	addi	sp,sp,-32
80105a8c:	de00012e 	bgeu	sp,et,80105a94 <bFeebGetCh1LeftBufferEmpty+0xc>
80105a90:	003b68fa 	trap	3
80105a94:	dfc00715 	stw	ra,28(sp)
80105a98:	df000615 	stw	fp,24(sp)
80105a9c:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105aa0:	e03ffa15 	stw	zero,-24(fp)
80105aa4:	00901034 	movhi	r2,16448
80105aa8:	10830004 	addi	r2,r2,3072
80105aac:	e0bffb15 	stw	r2,-20(fp)
80105ab0:	008000c4 	movi	r2,3
80105ab4:	e0bffc15 	stw	r2,-16(fp)
80105ab8:	00800084 	movi	r2,2
80105abc:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105ac0:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105ac4:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105ac8:	e0bffb17 	ldw	r2,-20(fp)
80105acc:	e17ffc17 	ldw	r5,-16(fp)
80105ad0:	1009883a 	mov	r4,r2
80105ad4:	01072d80 	call	801072d8 <uliFeebReadReg>
80105ad8:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105adc:	e0ffff17 	ldw	r3,-4(fp)
80105ae0:	e0bffd17 	ldw	r2,-12(fp)
80105ae4:	1884703a 	and	r2,r3,r2
80105ae8:	10000326 	beq	r2,zero,80105af8 <bFeebGetCh1LeftBufferEmpty+0x70>
		bFlag = TRUE;
80105aec:	00800044 	movi	r2,1
80105af0:	e0bffe15 	stw	r2,-8(fp)
80105af4:	00000106 	br	80105afc <bFeebGetCh1LeftBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80105af8:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105afc:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh1LeftBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_1_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_BUFF_EMPTY_MSK);
80105b00:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105b04:	e0bffa17 	ldw	r2,-24(fp)
}
80105b08:	e037883a 	mov	sp,fp
80105b0c:	dfc00117 	ldw	ra,4(sp)
80105b10:	df000017 	ldw	fp,0(sp)
80105b14:	dec00204 	addi	sp,sp,8
80105b18:	f800283a 	ret

80105b1c <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void) {
80105b1c:	defff804 	addi	sp,sp,-32
80105b20:	de00012e 	bgeu	sp,et,80105b28 <bFeebGetCh1RightBufferEmpty+0xc>
80105b24:	003b68fa 	trap	3
80105b28:	dfc00715 	stw	ra,28(sp)
80105b2c:	df000615 	stw	fp,24(sp)
80105b30:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105b34:	e03ffa15 	stw	zero,-24(fp)
80105b38:	00901034 	movhi	r2,16448
80105b3c:	10830004 	addi	r2,r2,3072
80105b40:	e0bffb15 	stw	r2,-20(fp)
80105b44:	008000c4 	movi	r2,3
80105b48:	e0bffc15 	stw	r2,-16(fp)
80105b4c:	00800044 	movi	r2,1
80105b50:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105b54:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105b58:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105b5c:	e0bffb17 	ldw	r2,-20(fp)
80105b60:	e17ffc17 	ldw	r5,-16(fp)
80105b64:	1009883a 	mov	r4,r2
80105b68:	01072d80 	call	801072d8 <uliFeebReadReg>
80105b6c:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105b70:	e0ffff17 	ldw	r3,-4(fp)
80105b74:	e0bffd17 	ldw	r2,-12(fp)
80105b78:	1884703a 	and	r2,r3,r2
80105b7c:	10000326 	beq	r2,zero,80105b8c <bFeebGetCh1RightBufferEmpty+0x70>
		bFlag = TRUE;
80105b80:	00800044 	movi	r2,1
80105b84:	e0bffe15 	stw	r2,-8(fp)
80105b88:	00000106 	br	80105b90 <bFeebGetCh1RightBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80105b8c:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105b90:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh1RightBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_1_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_BUFF_EMPTY_MSK);
80105b94:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105b98:	e0bffa17 	ldw	r2,-24(fp)
}
80105b9c:	e037883a 	mov	sp,fp
80105ba0:	dfc00117 	ldw	ra,4(sp)
80105ba4:	df000017 	ldw	fp,0(sp)
80105ba8:	dec00204 	addi	sp,sp,8
80105bac:	f800283a 	ret

80105bb0 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void) {
80105bb0:	defff804 	addi	sp,sp,-32
80105bb4:	de00012e 	bgeu	sp,et,80105bbc <bFeebGetCh2LeftBufferEmpty+0xc>
80105bb8:	003b68fa 	trap	3
80105bbc:	dfc00715 	stw	ra,28(sp)
80105bc0:	df000615 	stw	fp,24(sp)
80105bc4:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105bc8:	e03ffa15 	stw	zero,-24(fp)
80105bcc:	00901034 	movhi	r2,16448
80105bd0:	10820004 	addi	r2,r2,2048
80105bd4:	e0bffb15 	stw	r2,-20(fp)
80105bd8:	008000c4 	movi	r2,3
80105bdc:	e0bffc15 	stw	r2,-16(fp)
80105be0:	00800084 	movi	r2,2
80105be4:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105be8:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105bec:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105bf0:	e0bffb17 	ldw	r2,-20(fp)
80105bf4:	e17ffc17 	ldw	r5,-16(fp)
80105bf8:	1009883a 	mov	r4,r2
80105bfc:	01072d80 	call	801072d8 <uliFeebReadReg>
80105c00:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105c04:	e0ffff17 	ldw	r3,-4(fp)
80105c08:	e0bffd17 	ldw	r2,-12(fp)
80105c0c:	1884703a 	and	r2,r3,r2
80105c10:	10000326 	beq	r2,zero,80105c20 <bFeebGetCh2LeftBufferEmpty+0x70>
		bFlag = TRUE;
80105c14:	00800044 	movi	r2,1
80105c18:	e0bffe15 	stw	r2,-8(fp)
80105c1c:	00000106 	br	80105c24 <bFeebGetCh2LeftBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80105c20:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105c24:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh2LeftBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_2_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_BUFF_EMPTY_MSK);
80105c28:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105c2c:	e0bffa17 	ldw	r2,-24(fp)
}
80105c30:	e037883a 	mov	sp,fp
80105c34:	dfc00117 	ldw	ra,4(sp)
80105c38:	df000017 	ldw	fp,0(sp)
80105c3c:	dec00204 	addi	sp,sp,8
80105c40:	f800283a 	ret

80105c44 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void) {
80105c44:	defff804 	addi	sp,sp,-32
80105c48:	de00012e 	bgeu	sp,et,80105c50 <bFeebGetCh2RightBufferEmpty+0xc>
80105c4c:	003b68fa 	trap	3
80105c50:	dfc00715 	stw	ra,28(sp)
80105c54:	df000615 	stw	fp,24(sp)
80105c58:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105c5c:	e03ffa15 	stw	zero,-24(fp)
80105c60:	00901034 	movhi	r2,16448
80105c64:	10820004 	addi	r2,r2,2048
80105c68:	e0bffb15 	stw	r2,-20(fp)
80105c6c:	008000c4 	movi	r2,3
80105c70:	e0bffc15 	stw	r2,-16(fp)
80105c74:	00800044 	movi	r2,1
80105c78:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105c7c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105c80:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105c84:	e0bffb17 	ldw	r2,-20(fp)
80105c88:	e17ffc17 	ldw	r5,-16(fp)
80105c8c:	1009883a 	mov	r4,r2
80105c90:	01072d80 	call	801072d8 <uliFeebReadReg>
80105c94:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105c98:	e0ffff17 	ldw	r3,-4(fp)
80105c9c:	e0bffd17 	ldw	r2,-12(fp)
80105ca0:	1884703a 	and	r2,r3,r2
80105ca4:	10000326 	beq	r2,zero,80105cb4 <bFeebGetCh2RightBufferEmpty+0x70>
		bFlag = TRUE;
80105ca8:	00800044 	movi	r2,1
80105cac:	e0bffe15 	stw	r2,-8(fp)
80105cb0:	00000106 	br	80105cb8 <bFeebGetCh2RightBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80105cb4:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105cb8:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh2RightBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_2_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_BUFF_EMPTY_MSK);
80105cbc:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105cc0:	e0bffa17 	ldw	r2,-24(fp)
}
80105cc4:	e037883a 	mov	sp,fp
80105cc8:	dfc00117 	ldw	ra,4(sp)
80105ccc:	df000017 	ldw	fp,0(sp)
80105cd0:	dec00204 	addi	sp,sp,8
80105cd4:	f800283a 	ret

80105cd8 <bFeebGetCh3LeftBufferEmpty>:

bool bFeebGetCh3LeftBufferEmpty(void) {
80105cd8:	defff804 	addi	sp,sp,-32
80105cdc:	de00012e 	bgeu	sp,et,80105ce4 <bFeebGetCh3LeftBufferEmpty+0xc>
80105ce0:	003b68fa 	trap	3
80105ce4:	dfc00715 	stw	ra,28(sp)
80105ce8:	df000615 	stw	fp,24(sp)
80105cec:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105cf0:	e03ffa15 	stw	zero,-24(fp)
80105cf4:	00901034 	movhi	r2,16448
80105cf8:	10810004 	addi	r2,r2,1024
80105cfc:	e0bffb15 	stw	r2,-20(fp)
80105d00:	008000c4 	movi	r2,3
80105d04:	e0bffc15 	stw	r2,-16(fp)
80105d08:	00800084 	movi	r2,2
80105d0c:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105d10:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105d14:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105d18:	e0bffb17 	ldw	r2,-20(fp)
80105d1c:	e17ffc17 	ldw	r5,-16(fp)
80105d20:	1009883a 	mov	r4,r2
80105d24:	01072d80 	call	801072d8 <uliFeebReadReg>
80105d28:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105d2c:	e0ffff17 	ldw	r3,-4(fp)
80105d30:	e0bffd17 	ldw	r2,-12(fp)
80105d34:	1884703a 	and	r2,r3,r2
80105d38:	10000326 	beq	r2,zero,80105d48 <bFeebGetCh3LeftBufferEmpty+0x70>
		bFlag = TRUE;
80105d3c:	00800044 	movi	r2,1
80105d40:	e0bffe15 	stw	r2,-8(fp)
80105d44:	00000106 	br	80105d4c <bFeebGetCh3LeftBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80105d48:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105d4c:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh3LeftBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_3_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_BUFF_EMPTY_MSK);
80105d50:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105d54:	e0bffa17 	ldw	r2,-24(fp)
}
80105d58:	e037883a 	mov	sp,fp
80105d5c:	dfc00117 	ldw	ra,4(sp)
80105d60:	df000017 	ldw	fp,0(sp)
80105d64:	dec00204 	addi	sp,sp,8
80105d68:	f800283a 	ret

80105d6c <bFeebGetCh3RightBufferEmpty>:

bool bFeebGetCh3RightBufferEmpty(void) {
80105d6c:	defff804 	addi	sp,sp,-32
80105d70:	de00012e 	bgeu	sp,et,80105d78 <bFeebGetCh3RightBufferEmpty+0xc>
80105d74:	003b68fa 	trap	3
80105d78:	dfc00715 	stw	ra,28(sp)
80105d7c:	df000615 	stw	fp,24(sp)
80105d80:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105d84:	e03ffa15 	stw	zero,-24(fp)
80105d88:	00901034 	movhi	r2,16448
80105d8c:	10810004 	addi	r2,r2,1024
80105d90:	e0bffb15 	stw	r2,-20(fp)
80105d94:	008000c4 	movi	r2,3
80105d98:	e0bffc15 	stw	r2,-16(fp)
80105d9c:	00800044 	movi	r2,1
80105da0:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105da4:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105da8:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105dac:	e0bffb17 	ldw	r2,-20(fp)
80105db0:	e17ffc17 	ldw	r5,-16(fp)
80105db4:	1009883a 	mov	r4,r2
80105db8:	01072d80 	call	801072d8 <uliFeebReadReg>
80105dbc:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105dc0:	e0ffff17 	ldw	r3,-4(fp)
80105dc4:	e0bffd17 	ldw	r2,-12(fp)
80105dc8:	1884703a 	and	r2,r3,r2
80105dcc:	10000326 	beq	r2,zero,80105ddc <bFeebGetCh3RightBufferEmpty+0x70>
		bFlag = TRUE;
80105dd0:	00800044 	movi	r2,1
80105dd4:	e0bffe15 	stw	r2,-8(fp)
80105dd8:	00000106 	br	80105de0 <bFeebGetCh3RightBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80105ddc:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105de0:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh3RightBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_3_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_BUFF_EMPTY_MSK);
80105de4:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105de8:	e0bffa17 	ldw	r2,-24(fp)
}
80105dec:	e037883a 	mov	sp,fp
80105df0:	dfc00117 	ldw	ra,4(sp)
80105df4:	df000017 	ldw	fp,0(sp)
80105df8:	dec00204 	addi	sp,sp,8
80105dfc:	f800283a 	ret

80105e00 <bFeebGetCh4LeftBufferEmpty>:

bool bFeebGetCh4LeftBufferEmpty(void) {
80105e00:	defff804 	addi	sp,sp,-32
80105e04:	de00012e 	bgeu	sp,et,80105e0c <bFeebGetCh4LeftBufferEmpty+0xc>
80105e08:	003b68fa 	trap	3
80105e0c:	dfc00715 	stw	ra,28(sp)
80105e10:	df000615 	stw	fp,24(sp)
80105e14:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105e18:	e03ffa15 	stw	zero,-24(fp)
80105e1c:	00901034 	movhi	r2,16448
80105e20:	e0bffb15 	stw	r2,-20(fp)
80105e24:	008000c4 	movi	r2,3
80105e28:	e0bffc15 	stw	r2,-16(fp)
80105e2c:	00800084 	movi	r2,2
80105e30:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105e34:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105e38:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105e3c:	e0bffb17 	ldw	r2,-20(fp)
80105e40:	e17ffc17 	ldw	r5,-16(fp)
80105e44:	1009883a 	mov	r4,r2
80105e48:	01072d80 	call	801072d8 <uliFeebReadReg>
80105e4c:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105e50:	e0ffff17 	ldw	r3,-4(fp)
80105e54:	e0bffd17 	ldw	r2,-12(fp)
80105e58:	1884703a 	and	r2,r3,r2
80105e5c:	10000326 	beq	r2,zero,80105e6c <bFeebGetCh4LeftBufferEmpty+0x6c>
		bFlag = TRUE;
80105e60:	00800044 	movi	r2,1
80105e64:	e0bffe15 	stw	r2,-8(fp)
80105e68:	00000106 	br	80105e70 <bFeebGetCh4LeftBufferEmpty+0x70>
	} else {
		bFlag = FALSE;
80105e6c:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105e70:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh4LeftBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_4_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_BUFF_EMPTY_MSK);
80105e74:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105e78:	e0bffa17 	ldw	r2,-24(fp)
}
80105e7c:	e037883a 	mov	sp,fp
80105e80:	dfc00117 	ldw	ra,4(sp)
80105e84:	df000017 	ldw	fp,0(sp)
80105e88:	dec00204 	addi	sp,sp,8
80105e8c:	f800283a 	ret

80105e90 <bFeebGetCh4RightBufferEmpty>:

bool bFeebGetCh4RightBufferEmpty(void) {
80105e90:	defff804 	addi	sp,sp,-32
80105e94:	de00012e 	bgeu	sp,et,80105e9c <bFeebGetCh4RightBufferEmpty+0xc>
80105e98:	003b68fa 	trap	3
80105e9c:	dfc00715 	stw	ra,28(sp)
80105ea0:	df000615 	stw	fp,24(sp)
80105ea4:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105ea8:	e03ffa15 	stw	zero,-24(fp)
80105eac:	00901034 	movhi	r2,16448
80105eb0:	e0bffb15 	stw	r2,-20(fp)
80105eb4:	008000c4 	movi	r2,3
80105eb8:	e0bffc15 	stw	r2,-16(fp)
80105ebc:	00800044 	movi	r2,1
80105ec0:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105ec4:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105ec8:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105ecc:	e0bffb17 	ldw	r2,-20(fp)
80105ed0:	e17ffc17 	ldw	r5,-16(fp)
80105ed4:	1009883a 	mov	r4,r2
80105ed8:	01072d80 	call	801072d8 <uliFeebReadReg>
80105edc:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105ee0:	e0ffff17 	ldw	r3,-4(fp)
80105ee4:	e0bffd17 	ldw	r2,-12(fp)
80105ee8:	1884703a 	and	r2,r3,r2
80105eec:	10000326 	beq	r2,zero,80105efc <bFeebGetCh4RightBufferEmpty+0x6c>
		bFlag = TRUE;
80105ef0:	00800044 	movi	r2,1
80105ef4:	e0bffe15 	stw	r2,-8(fp)
80105ef8:	00000106 	br	80105f00 <bFeebGetCh4RightBufferEmpty+0x70>
	} else {
		bFlag = FALSE;
80105efc:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105f00:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh4RightBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_4_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_BUFF_EMPTY_MSK);
80105f04:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105f08:	e0bffa17 	ldw	r2,-24(fp)
}
80105f0c:	e037883a 	mov	sp,fp
80105f10:	dfc00117 	ldw	ra,4(sp)
80105f14:	df000017 	ldw	fp,0(sp)
80105f18:	dec00204 	addi	sp,sp,8
80105f1c:	f800283a 	ret

80105f20 <bFeebGetCh5LeftBufferEmpty>:

bool bFeebGetCh5LeftBufferEmpty(void) {
80105f20:	defff804 	addi	sp,sp,-32
80105f24:	de00012e 	bgeu	sp,et,80105f2c <bFeebGetCh5LeftBufferEmpty+0xc>
80105f28:	003b68fa 	trap	3
80105f2c:	dfc00715 	stw	ra,28(sp)
80105f30:	df000615 	stw	fp,24(sp)
80105f34:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105f38:	e03ffa15 	stw	zero,-24(fp)
80105f3c:	00901034 	movhi	r2,16448
80105f40:	10830004 	addi	r2,r2,3072
80105f44:	e0bffb15 	stw	r2,-20(fp)
80105f48:	008000c4 	movi	r2,3
80105f4c:	e0bffc15 	stw	r2,-16(fp)
80105f50:	00800084 	movi	r2,2
80105f54:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105f58:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105f5c:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105f60:	e0bffb17 	ldw	r2,-20(fp)
80105f64:	e17ffc17 	ldw	r5,-16(fp)
80105f68:	1009883a 	mov	r4,r2
80105f6c:	01072d80 	call	801072d8 <uliFeebReadReg>
80105f70:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80105f74:	e0ffff17 	ldw	r3,-4(fp)
80105f78:	e0bffd17 	ldw	r2,-12(fp)
80105f7c:	1884703a 	and	r2,r3,r2
80105f80:	10000326 	beq	r2,zero,80105f90 <bFeebGetCh5LeftBufferEmpty+0x70>
		bFlag = TRUE;
80105f84:	00800044 	movi	r2,1
80105f88:	e0bffe15 	stw	r2,-8(fp)
80105f8c:	00000106 	br	80105f94 <bFeebGetCh5LeftBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80105f90:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80105f94:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh5LeftBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_5_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_BUFF_EMPTY_MSK);
80105f98:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80105f9c:	e0bffa17 	ldw	r2,-24(fp)
}
80105fa0:	e037883a 	mov	sp,fp
80105fa4:	dfc00117 	ldw	ra,4(sp)
80105fa8:	df000017 	ldw	fp,0(sp)
80105fac:	dec00204 	addi	sp,sp,8
80105fb0:	f800283a 	ret

80105fb4 <bFeebGetCh5RightBufferEmpty>:

bool bFeebGetCh5RightBufferEmpty(void) {
80105fb4:	defff804 	addi	sp,sp,-32
80105fb8:	de00012e 	bgeu	sp,et,80105fc0 <bFeebGetCh5RightBufferEmpty+0xc>
80105fbc:	003b68fa 	trap	3
80105fc0:	dfc00715 	stw	ra,28(sp)
80105fc4:	df000615 	stw	fp,24(sp)
80105fc8:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80105fcc:	e03ffa15 	stw	zero,-24(fp)
80105fd0:	00901034 	movhi	r2,16448
80105fd4:	10830004 	addi	r2,r2,3072
80105fd8:	e0bffb15 	stw	r2,-20(fp)
80105fdc:	008000c4 	movi	r2,3
80105fe0:	e0bffc15 	stw	r2,-16(fp)
80105fe4:	00800044 	movi	r2,1
80105fe8:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80105fec:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80105ff0:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80105ff4:	e0bffb17 	ldw	r2,-20(fp)
80105ff8:	e17ffc17 	ldw	r5,-16(fp)
80105ffc:	1009883a 	mov	r4,r2
80106000:	01072d80 	call	801072d8 <uliFeebReadReg>
80106004:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106008:	e0ffff17 	ldw	r3,-4(fp)
8010600c:	e0bffd17 	ldw	r2,-12(fp)
80106010:	1884703a 	and	r2,r3,r2
80106014:	10000326 	beq	r2,zero,80106024 <bFeebGetCh5RightBufferEmpty+0x70>
		bFlag = TRUE;
80106018:	00800044 	movi	r2,1
8010601c:	e0bffe15 	stw	r2,-8(fp)
80106020:	00000106 	br	80106028 <bFeebGetCh5RightBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80106024:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106028:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh5RightBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_5_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_BUFF_EMPTY_MSK);
8010602c:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106030:	e0bffa17 	ldw	r2,-24(fp)
}
80106034:	e037883a 	mov	sp,fp
80106038:	dfc00117 	ldw	ra,4(sp)
8010603c:	df000017 	ldw	fp,0(sp)
80106040:	dec00204 	addi	sp,sp,8
80106044:	f800283a 	ret

80106048 <bFeebGetCh6LeftBufferEmpty>:

bool bFeebGetCh6LeftBufferEmpty(void) {
80106048:	defff804 	addi	sp,sp,-32
8010604c:	de00012e 	bgeu	sp,et,80106054 <bFeebGetCh6LeftBufferEmpty+0xc>
80106050:	003b68fa 	trap	3
80106054:	dfc00715 	stw	ra,28(sp)
80106058:	df000615 	stw	fp,24(sp)
8010605c:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106060:	e03ffa15 	stw	zero,-24(fp)
80106064:	00901034 	movhi	r2,16448
80106068:	10820004 	addi	r2,r2,2048
8010606c:	e0bffb15 	stw	r2,-20(fp)
80106070:	008000c4 	movi	r2,3
80106074:	e0bffc15 	stw	r2,-16(fp)
80106078:	00800084 	movi	r2,2
8010607c:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106080:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106084:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106088:	e0bffb17 	ldw	r2,-20(fp)
8010608c:	e17ffc17 	ldw	r5,-16(fp)
80106090:	1009883a 	mov	r4,r2
80106094:	01072d80 	call	801072d8 <uliFeebReadReg>
80106098:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
8010609c:	e0ffff17 	ldw	r3,-4(fp)
801060a0:	e0bffd17 	ldw	r2,-12(fp)
801060a4:	1884703a 	and	r2,r3,r2
801060a8:	10000326 	beq	r2,zero,801060b8 <bFeebGetCh6LeftBufferEmpty+0x70>
		bFlag = TRUE;
801060ac:	00800044 	movi	r2,1
801060b0:	e0bffe15 	stw	r2,-8(fp)
801060b4:	00000106 	br	801060bc <bFeebGetCh6LeftBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
801060b8:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
801060bc:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh6LeftBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_6_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_BUFF_EMPTY_MSK);
801060c0:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
801060c4:	e0bffa17 	ldw	r2,-24(fp)
}
801060c8:	e037883a 	mov	sp,fp
801060cc:	dfc00117 	ldw	ra,4(sp)
801060d0:	df000017 	ldw	fp,0(sp)
801060d4:	dec00204 	addi	sp,sp,8
801060d8:	f800283a 	ret

801060dc <bFeebGetCh6RightBufferEmpty>:

bool bFeebGetCh6RightBufferEmpty(void) {
801060dc:	defff804 	addi	sp,sp,-32
801060e0:	de00012e 	bgeu	sp,et,801060e8 <bFeebGetCh6RightBufferEmpty+0xc>
801060e4:	003b68fa 	trap	3
801060e8:	dfc00715 	stw	ra,28(sp)
801060ec:	df000615 	stw	fp,24(sp)
801060f0:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
801060f4:	e03ffa15 	stw	zero,-24(fp)
801060f8:	00901034 	movhi	r2,16448
801060fc:	10820004 	addi	r2,r2,2048
80106100:	e0bffb15 	stw	r2,-20(fp)
80106104:	008000c4 	movi	r2,3
80106108:	e0bffc15 	stw	r2,-16(fp)
8010610c:	00800044 	movi	r2,1
80106110:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106114:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106118:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
8010611c:	e0bffb17 	ldw	r2,-20(fp)
80106120:	e17ffc17 	ldw	r5,-16(fp)
80106124:	1009883a 	mov	r4,r2
80106128:	01072d80 	call	801072d8 <uliFeebReadReg>
8010612c:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106130:	e0ffff17 	ldw	r3,-4(fp)
80106134:	e0bffd17 	ldw	r2,-12(fp)
80106138:	1884703a 	and	r2,r3,r2
8010613c:	10000326 	beq	r2,zero,8010614c <bFeebGetCh6RightBufferEmpty+0x70>
		bFlag = TRUE;
80106140:	00800044 	movi	r2,1
80106144:	e0bffe15 	stw	r2,-8(fp)
80106148:	00000106 	br	80106150 <bFeebGetCh6RightBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
8010614c:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106150:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh6RightBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_6_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_BUFF_EMPTY_MSK);
80106154:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106158:	e0bffa17 	ldw	r2,-24(fp)
}
8010615c:	e037883a 	mov	sp,fp
80106160:	dfc00117 	ldw	ra,4(sp)
80106164:	df000017 	ldw	fp,0(sp)
80106168:	dec00204 	addi	sp,sp,8
8010616c:	f800283a 	ret

80106170 <bFeebGetCh7LeftBufferEmpty>:

bool bFeebGetCh7LeftBufferEmpty(void) {
80106170:	defff804 	addi	sp,sp,-32
80106174:	de00012e 	bgeu	sp,et,8010617c <bFeebGetCh7LeftBufferEmpty+0xc>
80106178:	003b68fa 	trap	3
8010617c:	dfc00715 	stw	ra,28(sp)
80106180:	df000615 	stw	fp,24(sp)
80106184:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106188:	e03ffa15 	stw	zero,-24(fp)
8010618c:	00901034 	movhi	r2,16448
80106190:	10810004 	addi	r2,r2,1024
80106194:	e0bffb15 	stw	r2,-20(fp)
80106198:	008000c4 	movi	r2,3
8010619c:	e0bffc15 	stw	r2,-16(fp)
801061a0:	00800084 	movi	r2,2
801061a4:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
801061a8:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
801061ac:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
801061b0:	e0bffb17 	ldw	r2,-20(fp)
801061b4:	e17ffc17 	ldw	r5,-16(fp)
801061b8:	1009883a 	mov	r4,r2
801061bc:	01072d80 	call	801072d8 <uliFeebReadReg>
801061c0:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
801061c4:	e0ffff17 	ldw	r3,-4(fp)
801061c8:	e0bffd17 	ldw	r2,-12(fp)
801061cc:	1884703a 	and	r2,r3,r2
801061d0:	10000326 	beq	r2,zero,801061e0 <bFeebGetCh7LeftBufferEmpty+0x70>
		bFlag = TRUE;
801061d4:	00800044 	movi	r2,1
801061d8:	e0bffe15 	stw	r2,-8(fp)
801061dc:	00000106 	br	801061e4 <bFeebGetCh7LeftBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
801061e0:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
801061e4:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh7LeftBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_7_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_BUFF_EMPTY_MSK);
801061e8:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
801061ec:	e0bffa17 	ldw	r2,-24(fp)
}
801061f0:	e037883a 	mov	sp,fp
801061f4:	dfc00117 	ldw	ra,4(sp)
801061f8:	df000017 	ldw	fp,0(sp)
801061fc:	dec00204 	addi	sp,sp,8
80106200:	f800283a 	ret

80106204 <bFeebGetCh7RightBufferEmpty>:

bool bFeebGetCh7RightBufferEmpty(void) {
80106204:	defff804 	addi	sp,sp,-32
80106208:	de00012e 	bgeu	sp,et,80106210 <bFeebGetCh7RightBufferEmpty+0xc>
8010620c:	003b68fa 	trap	3
80106210:	dfc00715 	stw	ra,28(sp)
80106214:	df000615 	stw	fp,24(sp)
80106218:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
8010621c:	e03ffa15 	stw	zero,-24(fp)
80106220:	00901034 	movhi	r2,16448
80106224:	10810004 	addi	r2,r2,1024
80106228:	e0bffb15 	stw	r2,-20(fp)
8010622c:	008000c4 	movi	r2,3
80106230:	e0bffc15 	stw	r2,-16(fp)
80106234:	00800044 	movi	r2,1
80106238:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
8010623c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106240:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106244:	e0bffb17 	ldw	r2,-20(fp)
80106248:	e17ffc17 	ldw	r5,-16(fp)
8010624c:	1009883a 	mov	r4,r2
80106250:	01072d80 	call	801072d8 <uliFeebReadReg>
80106254:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106258:	e0ffff17 	ldw	r3,-4(fp)
8010625c:	e0bffd17 	ldw	r2,-12(fp)
80106260:	1884703a 	and	r2,r3,r2
80106264:	10000326 	beq	r2,zero,80106274 <bFeebGetCh7RightBufferEmpty+0x70>
		bFlag = TRUE;
80106268:	00800044 	movi	r2,1
8010626c:	e0bffe15 	stw	r2,-8(fp)
80106270:	00000106 	br	80106278 <bFeebGetCh7RightBufferEmpty+0x74>
	} else {
		bFlag = FALSE;
80106274:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106278:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh7RightBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_7_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_BUFF_EMPTY_MSK);
8010627c:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106280:	e0bffa17 	ldw	r2,-24(fp)
}
80106284:	e037883a 	mov	sp,fp
80106288:	dfc00117 	ldw	ra,4(sp)
8010628c:	df000017 	ldw	fp,0(sp)
80106290:	dec00204 	addi	sp,sp,8
80106294:	f800283a 	ret

80106298 <bFeebGetCh8LeftBufferEmpty>:

bool bFeebGetCh8LeftBufferEmpty(void) {
80106298:	defff804 	addi	sp,sp,-32
8010629c:	de00012e 	bgeu	sp,et,801062a4 <bFeebGetCh8LeftBufferEmpty+0xc>
801062a0:	003b68fa 	trap	3
801062a4:	dfc00715 	stw	ra,28(sp)
801062a8:	df000615 	stw	fp,24(sp)
801062ac:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
801062b0:	e03ffa15 	stw	zero,-24(fp)
801062b4:	00901034 	movhi	r2,16448
801062b8:	e0bffb15 	stw	r2,-20(fp)
801062bc:	008000c4 	movi	r2,3
801062c0:	e0bffc15 	stw	r2,-16(fp)
801062c4:	00800084 	movi	r2,2
801062c8:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
801062cc:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
801062d0:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
801062d4:	e0bffb17 	ldw	r2,-20(fp)
801062d8:	e17ffc17 	ldw	r5,-16(fp)
801062dc:	1009883a 	mov	r4,r2
801062e0:	01072d80 	call	801072d8 <uliFeebReadReg>
801062e4:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
801062e8:	e0ffff17 	ldw	r3,-4(fp)
801062ec:	e0bffd17 	ldw	r2,-12(fp)
801062f0:	1884703a 	and	r2,r3,r2
801062f4:	10000326 	beq	r2,zero,80106304 <bFeebGetCh8LeftBufferEmpty+0x6c>
		bFlag = TRUE;
801062f8:	00800044 	movi	r2,1
801062fc:	e0bffe15 	stw	r2,-8(fp)
80106300:	00000106 	br	80106308 <bFeebGetCh8LeftBufferEmpty+0x70>
	} else {
		bFlag = FALSE;
80106304:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106308:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh8LeftBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_8_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_BUFF_EMPTY_MSK);
8010630c:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106310:	e0bffa17 	ldw	r2,-24(fp)
}
80106314:	e037883a 	mov	sp,fp
80106318:	dfc00117 	ldw	ra,4(sp)
8010631c:	df000017 	ldw	fp,0(sp)
80106320:	dec00204 	addi	sp,sp,8
80106324:	f800283a 	ret

80106328 <bFeebGetCh8RightBufferEmpty>:

bool bFeebGetCh8RightBufferEmpty(void) {
80106328:	defff804 	addi	sp,sp,-32
8010632c:	de00012e 	bgeu	sp,et,80106334 <bFeebGetCh8RightBufferEmpty+0xc>
80106330:	003b68fa 	trap	3
80106334:	dfc00715 	stw	ra,28(sp)
80106338:	df000615 	stw	fp,24(sp)
8010633c:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106340:	e03ffa15 	stw	zero,-24(fp)
80106344:	00901034 	movhi	r2,16448
80106348:	e0bffb15 	stw	r2,-20(fp)
8010634c:	008000c4 	movi	r2,3
80106350:	e0bffc15 	stw	r2,-16(fp)
80106354:	00800044 	movi	r2,1
80106358:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
8010635c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106360:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106364:	e0bffb17 	ldw	r2,-20(fp)
80106368:	e17ffc17 	ldw	r5,-16(fp)
8010636c:	1009883a 	mov	r4,r2
80106370:	01072d80 	call	801072d8 <uliFeebReadReg>
80106374:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106378:	e0ffff17 	ldw	r3,-4(fp)
8010637c:	e0bffd17 	ldw	r2,-12(fp)
80106380:	1884703a 	and	r2,r3,r2
80106384:	10000326 	beq	r2,zero,80106394 <bFeebGetCh8RightBufferEmpty+0x6c>
		bFlag = TRUE;
80106388:	00800044 	movi	r2,1
8010638c:	e0bffe15 	stw	r2,-8(fp)
80106390:	00000106 	br	80106398 <bFeebGetCh8RightBufferEmpty+0x70>
	} else {
		bFlag = FALSE;
80106394:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106398:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh8RightBufferEmpty(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_8_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_BUFF_EMPTY_MSK);
8010639c:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
801063a0:	e0bffa17 	ldw	r2,-24(fp)
}
801063a4:	e037883a 	mov	sp,fp
801063a8:	dfc00117 	ldw	ra,4(sp)
801063ac:	df000017 	ldw	fp,0(sp)
801063b0:	dec00204 	addi	sp,sp,8
801063b4:	f800283a 	ret

801063b8 <bFeebGetCh1LeftFeeBusy>:


bool bFeebGetCh1LeftFeeBusy(void) {
801063b8:	defff804 	addi	sp,sp,-32
801063bc:	de00012e 	bgeu	sp,et,801063c4 <bFeebGetCh1LeftFeeBusy+0xc>
801063c0:	003b68fa 	trap	3
801063c4:	dfc00715 	stw	ra,28(sp)
801063c8:	df000615 	stw	fp,24(sp)
801063cc:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
801063d0:	e03ffa15 	stw	zero,-24(fp)
801063d4:	00901034 	movhi	r2,16448
801063d8:	10830004 	addi	r2,r2,3072
801063dc:	e0bffb15 	stw	r2,-20(fp)
801063e0:	008000c4 	movi	r2,3
801063e4:	e0bffc15 	stw	r2,-16(fp)
801063e8:	00808004 	movi	r2,512
801063ec:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
801063f0:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
801063f4:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
801063f8:	e0bffb17 	ldw	r2,-20(fp)
801063fc:	e17ffc17 	ldw	r5,-16(fp)
80106400:	1009883a 	mov	r4,r2
80106404:	01072d80 	call	801072d8 <uliFeebReadReg>
80106408:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
8010640c:	e0ffff17 	ldw	r3,-4(fp)
80106410:	e0bffd17 	ldw	r2,-12(fp)
80106414:	1884703a 	and	r2,r3,r2
80106418:	10000326 	beq	r2,zero,80106428 <bFeebGetCh1LeftFeeBusy+0x70>
		bFlag = TRUE;
8010641c:	00800044 	movi	r2,1
80106420:	e0bffe15 	stw	r2,-8(fp)
80106424:	00000106 	br	8010642c <bFeebGetCh1LeftFeeBusy+0x74>
	} else {
		bFlag = FALSE;
80106428:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
8010642c:	e0bffe17 	ldw	r2,-8(fp)
}


bool bFeebGetCh1LeftFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_1_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_FEE_BUSY_MSK);
80106430:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106434:	e0bffa17 	ldw	r2,-24(fp)
}
80106438:	e037883a 	mov	sp,fp
8010643c:	dfc00117 	ldw	ra,4(sp)
80106440:	df000017 	ldw	fp,0(sp)
80106444:	dec00204 	addi	sp,sp,8
80106448:	f800283a 	ret

8010644c <bFeebGetCh1RightFeeBusy>:

bool bFeebGetCh1RightFeeBusy(void) {
8010644c:	defff804 	addi	sp,sp,-32
80106450:	de00012e 	bgeu	sp,et,80106458 <bFeebGetCh1RightFeeBusy+0xc>
80106454:	003b68fa 	trap	3
80106458:	dfc00715 	stw	ra,28(sp)
8010645c:	df000615 	stw	fp,24(sp)
80106460:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106464:	e03ffa15 	stw	zero,-24(fp)
80106468:	00901034 	movhi	r2,16448
8010646c:	10830004 	addi	r2,r2,3072
80106470:	e0bffb15 	stw	r2,-20(fp)
80106474:	008000c4 	movi	r2,3
80106478:	e0bffc15 	stw	r2,-16(fp)
8010647c:	00804004 	movi	r2,256
80106480:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106484:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106488:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
8010648c:	e0bffb17 	ldw	r2,-20(fp)
80106490:	e17ffc17 	ldw	r5,-16(fp)
80106494:	1009883a 	mov	r4,r2
80106498:	01072d80 	call	801072d8 <uliFeebReadReg>
8010649c:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
801064a0:	e0ffff17 	ldw	r3,-4(fp)
801064a4:	e0bffd17 	ldw	r2,-12(fp)
801064a8:	1884703a 	and	r2,r3,r2
801064ac:	10000326 	beq	r2,zero,801064bc <bFeebGetCh1RightFeeBusy+0x70>
		bFlag = TRUE;
801064b0:	00800044 	movi	r2,1
801064b4:	e0bffe15 	stw	r2,-8(fp)
801064b8:	00000106 	br	801064c0 <bFeebGetCh1RightFeeBusy+0x74>
	} else {
		bFlag = FALSE;
801064bc:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
801064c0:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh1RightFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_1_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_FEE_BUSY_MSK);
801064c4:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
801064c8:	e0bffa17 	ldw	r2,-24(fp)
}
801064cc:	e037883a 	mov	sp,fp
801064d0:	dfc00117 	ldw	ra,4(sp)
801064d4:	df000017 	ldw	fp,0(sp)
801064d8:	dec00204 	addi	sp,sp,8
801064dc:	f800283a 	ret

801064e0 <bFeebGetCh2LeftFeeBusy>:

bool bFeebGetCh2LeftFeeBusy(void) {
801064e0:	defff804 	addi	sp,sp,-32
801064e4:	de00012e 	bgeu	sp,et,801064ec <bFeebGetCh2LeftFeeBusy+0xc>
801064e8:	003b68fa 	trap	3
801064ec:	dfc00715 	stw	ra,28(sp)
801064f0:	df000615 	stw	fp,24(sp)
801064f4:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
801064f8:	e03ffa15 	stw	zero,-24(fp)
801064fc:	00901034 	movhi	r2,16448
80106500:	10820004 	addi	r2,r2,2048
80106504:	e0bffb15 	stw	r2,-20(fp)
80106508:	008000c4 	movi	r2,3
8010650c:	e0bffc15 	stw	r2,-16(fp)
80106510:	00808004 	movi	r2,512
80106514:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106518:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
8010651c:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106520:	e0bffb17 	ldw	r2,-20(fp)
80106524:	e17ffc17 	ldw	r5,-16(fp)
80106528:	1009883a 	mov	r4,r2
8010652c:	01072d80 	call	801072d8 <uliFeebReadReg>
80106530:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106534:	e0ffff17 	ldw	r3,-4(fp)
80106538:	e0bffd17 	ldw	r2,-12(fp)
8010653c:	1884703a 	and	r2,r3,r2
80106540:	10000326 	beq	r2,zero,80106550 <bFeebGetCh2LeftFeeBusy+0x70>
		bFlag = TRUE;
80106544:	00800044 	movi	r2,1
80106548:	e0bffe15 	stw	r2,-8(fp)
8010654c:	00000106 	br	80106554 <bFeebGetCh2LeftFeeBusy+0x74>
	} else {
		bFlag = FALSE;
80106550:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106554:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh2LeftFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_2_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_FEE_BUSY_MSK);
80106558:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
8010655c:	e0bffa17 	ldw	r2,-24(fp)
}
80106560:	e037883a 	mov	sp,fp
80106564:	dfc00117 	ldw	ra,4(sp)
80106568:	df000017 	ldw	fp,0(sp)
8010656c:	dec00204 	addi	sp,sp,8
80106570:	f800283a 	ret

80106574 <bFeebGetCh2RightFeeBusy>:

bool bFeebGetCh2RightFeeBusy(void) {
80106574:	defff804 	addi	sp,sp,-32
80106578:	de00012e 	bgeu	sp,et,80106580 <bFeebGetCh2RightFeeBusy+0xc>
8010657c:	003b68fa 	trap	3
80106580:	dfc00715 	stw	ra,28(sp)
80106584:	df000615 	stw	fp,24(sp)
80106588:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
8010658c:	e03ffa15 	stw	zero,-24(fp)
80106590:	00901034 	movhi	r2,16448
80106594:	10820004 	addi	r2,r2,2048
80106598:	e0bffb15 	stw	r2,-20(fp)
8010659c:	008000c4 	movi	r2,3
801065a0:	e0bffc15 	stw	r2,-16(fp)
801065a4:	00804004 	movi	r2,256
801065a8:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
801065ac:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
801065b0:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
801065b4:	e0bffb17 	ldw	r2,-20(fp)
801065b8:	e17ffc17 	ldw	r5,-16(fp)
801065bc:	1009883a 	mov	r4,r2
801065c0:	01072d80 	call	801072d8 <uliFeebReadReg>
801065c4:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
801065c8:	e0ffff17 	ldw	r3,-4(fp)
801065cc:	e0bffd17 	ldw	r2,-12(fp)
801065d0:	1884703a 	and	r2,r3,r2
801065d4:	10000326 	beq	r2,zero,801065e4 <bFeebGetCh2RightFeeBusy+0x70>
		bFlag = TRUE;
801065d8:	00800044 	movi	r2,1
801065dc:	e0bffe15 	stw	r2,-8(fp)
801065e0:	00000106 	br	801065e8 <bFeebGetCh2RightFeeBusy+0x74>
	} else {
		bFlag = FALSE;
801065e4:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
801065e8:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh2RightFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_2_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_FEE_BUSY_MSK);
801065ec:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
801065f0:	e0bffa17 	ldw	r2,-24(fp)
}
801065f4:	e037883a 	mov	sp,fp
801065f8:	dfc00117 	ldw	ra,4(sp)
801065fc:	df000017 	ldw	fp,0(sp)
80106600:	dec00204 	addi	sp,sp,8
80106604:	f800283a 	ret

80106608 <bFeebGetCh3LeftFeeBusy>:

bool bFeebGetCh3LeftFeeBusy(void) {
80106608:	defff804 	addi	sp,sp,-32
8010660c:	de00012e 	bgeu	sp,et,80106614 <bFeebGetCh3LeftFeeBusy+0xc>
80106610:	003b68fa 	trap	3
80106614:	dfc00715 	stw	ra,28(sp)
80106618:	df000615 	stw	fp,24(sp)
8010661c:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106620:	e03ffa15 	stw	zero,-24(fp)
80106624:	00901034 	movhi	r2,16448
80106628:	10810004 	addi	r2,r2,1024
8010662c:	e0bffb15 	stw	r2,-20(fp)
80106630:	008000c4 	movi	r2,3
80106634:	e0bffc15 	stw	r2,-16(fp)
80106638:	00808004 	movi	r2,512
8010663c:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106640:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106644:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106648:	e0bffb17 	ldw	r2,-20(fp)
8010664c:	e17ffc17 	ldw	r5,-16(fp)
80106650:	1009883a 	mov	r4,r2
80106654:	01072d80 	call	801072d8 <uliFeebReadReg>
80106658:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
8010665c:	e0ffff17 	ldw	r3,-4(fp)
80106660:	e0bffd17 	ldw	r2,-12(fp)
80106664:	1884703a 	and	r2,r3,r2
80106668:	10000326 	beq	r2,zero,80106678 <bFeebGetCh3LeftFeeBusy+0x70>
		bFlag = TRUE;
8010666c:	00800044 	movi	r2,1
80106670:	e0bffe15 	stw	r2,-8(fp)
80106674:	00000106 	br	8010667c <bFeebGetCh3LeftFeeBusy+0x74>
	} else {
		bFlag = FALSE;
80106678:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
8010667c:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh3LeftFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_3_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_FEE_BUSY_MSK);
80106680:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106684:	e0bffa17 	ldw	r2,-24(fp)
}
80106688:	e037883a 	mov	sp,fp
8010668c:	dfc00117 	ldw	ra,4(sp)
80106690:	df000017 	ldw	fp,0(sp)
80106694:	dec00204 	addi	sp,sp,8
80106698:	f800283a 	ret

8010669c <bFeebGetCh3RightFeeBusy>:

bool bFeebGetCh3RightFeeBusy(void) {
8010669c:	defff804 	addi	sp,sp,-32
801066a0:	de00012e 	bgeu	sp,et,801066a8 <bFeebGetCh3RightFeeBusy+0xc>
801066a4:	003b68fa 	trap	3
801066a8:	dfc00715 	stw	ra,28(sp)
801066ac:	df000615 	stw	fp,24(sp)
801066b0:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
801066b4:	e03ffa15 	stw	zero,-24(fp)
801066b8:	00901034 	movhi	r2,16448
801066bc:	10810004 	addi	r2,r2,1024
801066c0:	e0bffb15 	stw	r2,-20(fp)
801066c4:	008000c4 	movi	r2,3
801066c8:	e0bffc15 	stw	r2,-16(fp)
801066cc:	00804004 	movi	r2,256
801066d0:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
801066d4:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
801066d8:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
801066dc:	e0bffb17 	ldw	r2,-20(fp)
801066e0:	e17ffc17 	ldw	r5,-16(fp)
801066e4:	1009883a 	mov	r4,r2
801066e8:	01072d80 	call	801072d8 <uliFeebReadReg>
801066ec:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
801066f0:	e0ffff17 	ldw	r3,-4(fp)
801066f4:	e0bffd17 	ldw	r2,-12(fp)
801066f8:	1884703a 	and	r2,r3,r2
801066fc:	10000326 	beq	r2,zero,8010670c <bFeebGetCh3RightFeeBusy+0x70>
		bFlag = TRUE;
80106700:	00800044 	movi	r2,1
80106704:	e0bffe15 	stw	r2,-8(fp)
80106708:	00000106 	br	80106710 <bFeebGetCh3RightFeeBusy+0x74>
	} else {
		bFlag = FALSE;
8010670c:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106710:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh3RightFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_3_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_FEE_BUSY_MSK);
80106714:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106718:	e0bffa17 	ldw	r2,-24(fp)
}
8010671c:	e037883a 	mov	sp,fp
80106720:	dfc00117 	ldw	ra,4(sp)
80106724:	df000017 	ldw	fp,0(sp)
80106728:	dec00204 	addi	sp,sp,8
8010672c:	f800283a 	ret

80106730 <bFeebGetCh4LeftFeeBusy>:

bool bFeebGetCh4LeftFeeBusy(void) {
80106730:	defff804 	addi	sp,sp,-32
80106734:	de00012e 	bgeu	sp,et,8010673c <bFeebGetCh4LeftFeeBusy+0xc>
80106738:	003b68fa 	trap	3
8010673c:	dfc00715 	stw	ra,28(sp)
80106740:	df000615 	stw	fp,24(sp)
80106744:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106748:	e03ffa15 	stw	zero,-24(fp)
8010674c:	00901034 	movhi	r2,16448
80106750:	e0bffb15 	stw	r2,-20(fp)
80106754:	008000c4 	movi	r2,3
80106758:	e0bffc15 	stw	r2,-16(fp)
8010675c:	00808004 	movi	r2,512
80106760:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106764:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106768:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
8010676c:	e0bffb17 	ldw	r2,-20(fp)
80106770:	e17ffc17 	ldw	r5,-16(fp)
80106774:	1009883a 	mov	r4,r2
80106778:	01072d80 	call	801072d8 <uliFeebReadReg>
8010677c:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106780:	e0ffff17 	ldw	r3,-4(fp)
80106784:	e0bffd17 	ldw	r2,-12(fp)
80106788:	1884703a 	and	r2,r3,r2
8010678c:	10000326 	beq	r2,zero,8010679c <bFeebGetCh4LeftFeeBusy+0x6c>
		bFlag = TRUE;
80106790:	00800044 	movi	r2,1
80106794:	e0bffe15 	stw	r2,-8(fp)
80106798:	00000106 	br	801067a0 <bFeebGetCh4LeftFeeBusy+0x70>
	} else {
		bFlag = FALSE;
8010679c:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
801067a0:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh4LeftFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_4_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_FEE_BUSY_MSK);
801067a4:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
801067a8:	e0bffa17 	ldw	r2,-24(fp)
}
801067ac:	e037883a 	mov	sp,fp
801067b0:	dfc00117 	ldw	ra,4(sp)
801067b4:	df000017 	ldw	fp,0(sp)
801067b8:	dec00204 	addi	sp,sp,8
801067bc:	f800283a 	ret

801067c0 <bFeebGetCh4RightFeeBusy>:

bool bFeebGetCh4RightFeeBusy(void) {
801067c0:	defff804 	addi	sp,sp,-32
801067c4:	de00012e 	bgeu	sp,et,801067cc <bFeebGetCh4RightFeeBusy+0xc>
801067c8:	003b68fa 	trap	3
801067cc:	dfc00715 	stw	ra,28(sp)
801067d0:	df000615 	stw	fp,24(sp)
801067d4:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
801067d8:	e03ffa15 	stw	zero,-24(fp)
801067dc:	00901034 	movhi	r2,16448
801067e0:	e0bffb15 	stw	r2,-20(fp)
801067e4:	008000c4 	movi	r2,3
801067e8:	e0bffc15 	stw	r2,-16(fp)
801067ec:	00804004 	movi	r2,256
801067f0:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
801067f4:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
801067f8:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
801067fc:	e0bffb17 	ldw	r2,-20(fp)
80106800:	e17ffc17 	ldw	r5,-16(fp)
80106804:	1009883a 	mov	r4,r2
80106808:	01072d80 	call	801072d8 <uliFeebReadReg>
8010680c:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106810:	e0ffff17 	ldw	r3,-4(fp)
80106814:	e0bffd17 	ldw	r2,-12(fp)
80106818:	1884703a 	and	r2,r3,r2
8010681c:	10000326 	beq	r2,zero,8010682c <bFeebGetCh4RightFeeBusy+0x6c>
		bFlag = TRUE;
80106820:	00800044 	movi	r2,1
80106824:	e0bffe15 	stw	r2,-8(fp)
80106828:	00000106 	br	80106830 <bFeebGetCh4RightFeeBusy+0x70>
	} else {
		bFlag = FALSE;
8010682c:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106830:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh4RightFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_4_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_FEE_BUSY_MSK);
80106834:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106838:	e0bffa17 	ldw	r2,-24(fp)
}
8010683c:	e037883a 	mov	sp,fp
80106840:	dfc00117 	ldw	ra,4(sp)
80106844:	df000017 	ldw	fp,0(sp)
80106848:	dec00204 	addi	sp,sp,8
8010684c:	f800283a 	ret

80106850 <bFeebGetCh5LeftFeeBusy>:

bool bFeebGetCh5LeftFeeBusy(void) {
80106850:	defff804 	addi	sp,sp,-32
80106854:	de00012e 	bgeu	sp,et,8010685c <bFeebGetCh5LeftFeeBusy+0xc>
80106858:	003b68fa 	trap	3
8010685c:	dfc00715 	stw	ra,28(sp)
80106860:	df000615 	stw	fp,24(sp)
80106864:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106868:	e03ffa15 	stw	zero,-24(fp)
8010686c:	00901034 	movhi	r2,16448
80106870:	10830004 	addi	r2,r2,3072
80106874:	e0bffb15 	stw	r2,-20(fp)
80106878:	008000c4 	movi	r2,3
8010687c:	e0bffc15 	stw	r2,-16(fp)
80106880:	00808004 	movi	r2,512
80106884:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106888:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
8010688c:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106890:	e0bffb17 	ldw	r2,-20(fp)
80106894:	e17ffc17 	ldw	r5,-16(fp)
80106898:	1009883a 	mov	r4,r2
8010689c:	01072d80 	call	801072d8 <uliFeebReadReg>
801068a0:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
801068a4:	e0ffff17 	ldw	r3,-4(fp)
801068a8:	e0bffd17 	ldw	r2,-12(fp)
801068ac:	1884703a 	and	r2,r3,r2
801068b0:	10000326 	beq	r2,zero,801068c0 <bFeebGetCh5LeftFeeBusy+0x70>
		bFlag = TRUE;
801068b4:	00800044 	movi	r2,1
801068b8:	e0bffe15 	stw	r2,-8(fp)
801068bc:	00000106 	br	801068c4 <bFeebGetCh5LeftFeeBusy+0x74>
	} else {
		bFlag = FALSE;
801068c0:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
801068c4:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh5LeftFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_5_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_FEE_BUSY_MSK);
801068c8:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
801068cc:	e0bffa17 	ldw	r2,-24(fp)
}
801068d0:	e037883a 	mov	sp,fp
801068d4:	dfc00117 	ldw	ra,4(sp)
801068d8:	df000017 	ldw	fp,0(sp)
801068dc:	dec00204 	addi	sp,sp,8
801068e0:	f800283a 	ret

801068e4 <bFeebGetCh5RightFeeBusy>:

bool bFeebGetCh5RightFeeBusy(void) {
801068e4:	defff804 	addi	sp,sp,-32
801068e8:	de00012e 	bgeu	sp,et,801068f0 <bFeebGetCh5RightFeeBusy+0xc>
801068ec:	003b68fa 	trap	3
801068f0:	dfc00715 	stw	ra,28(sp)
801068f4:	df000615 	stw	fp,24(sp)
801068f8:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
801068fc:	e03ffa15 	stw	zero,-24(fp)
80106900:	00901034 	movhi	r2,16448
80106904:	10830004 	addi	r2,r2,3072
80106908:	e0bffb15 	stw	r2,-20(fp)
8010690c:	008000c4 	movi	r2,3
80106910:	e0bffc15 	stw	r2,-16(fp)
80106914:	00804004 	movi	r2,256
80106918:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
8010691c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106920:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106924:	e0bffb17 	ldw	r2,-20(fp)
80106928:	e17ffc17 	ldw	r5,-16(fp)
8010692c:	1009883a 	mov	r4,r2
80106930:	01072d80 	call	801072d8 <uliFeebReadReg>
80106934:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106938:	e0ffff17 	ldw	r3,-4(fp)
8010693c:	e0bffd17 	ldw	r2,-12(fp)
80106940:	1884703a 	and	r2,r3,r2
80106944:	10000326 	beq	r2,zero,80106954 <bFeebGetCh5RightFeeBusy+0x70>
		bFlag = TRUE;
80106948:	00800044 	movi	r2,1
8010694c:	e0bffe15 	stw	r2,-8(fp)
80106950:	00000106 	br	80106958 <bFeebGetCh5RightFeeBusy+0x74>
	} else {
		bFlag = FALSE;
80106954:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106958:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh5RightFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_5_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_FEE_BUSY_MSK);
8010695c:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106960:	e0bffa17 	ldw	r2,-24(fp)
}
80106964:	e037883a 	mov	sp,fp
80106968:	dfc00117 	ldw	ra,4(sp)
8010696c:	df000017 	ldw	fp,0(sp)
80106970:	dec00204 	addi	sp,sp,8
80106974:	f800283a 	ret

80106978 <bFeebGetCh6LeftFeeBusy>:

bool bFeebGetCh6LeftFeeBusy(void) {
80106978:	defff804 	addi	sp,sp,-32
8010697c:	de00012e 	bgeu	sp,et,80106984 <bFeebGetCh6LeftFeeBusy+0xc>
80106980:	003b68fa 	trap	3
80106984:	dfc00715 	stw	ra,28(sp)
80106988:	df000615 	stw	fp,24(sp)
8010698c:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106990:	e03ffa15 	stw	zero,-24(fp)
80106994:	00901034 	movhi	r2,16448
80106998:	10820004 	addi	r2,r2,2048
8010699c:	e0bffb15 	stw	r2,-20(fp)
801069a0:	008000c4 	movi	r2,3
801069a4:	e0bffc15 	stw	r2,-16(fp)
801069a8:	00808004 	movi	r2,512
801069ac:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
801069b0:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
801069b4:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
801069b8:	e0bffb17 	ldw	r2,-20(fp)
801069bc:	e17ffc17 	ldw	r5,-16(fp)
801069c0:	1009883a 	mov	r4,r2
801069c4:	01072d80 	call	801072d8 <uliFeebReadReg>
801069c8:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
801069cc:	e0ffff17 	ldw	r3,-4(fp)
801069d0:	e0bffd17 	ldw	r2,-12(fp)
801069d4:	1884703a 	and	r2,r3,r2
801069d8:	10000326 	beq	r2,zero,801069e8 <bFeebGetCh6LeftFeeBusy+0x70>
		bFlag = TRUE;
801069dc:	00800044 	movi	r2,1
801069e0:	e0bffe15 	stw	r2,-8(fp)
801069e4:	00000106 	br	801069ec <bFeebGetCh6LeftFeeBusy+0x74>
	} else {
		bFlag = FALSE;
801069e8:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
801069ec:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh6LeftFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_6_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_FEE_BUSY_MSK);
801069f0:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
801069f4:	e0bffa17 	ldw	r2,-24(fp)
}
801069f8:	e037883a 	mov	sp,fp
801069fc:	dfc00117 	ldw	ra,4(sp)
80106a00:	df000017 	ldw	fp,0(sp)
80106a04:	dec00204 	addi	sp,sp,8
80106a08:	f800283a 	ret

80106a0c <bFeebGetCh6RightFeeBusy>:

bool bFeebGetCh6RightFeeBusy(void) {
80106a0c:	defff804 	addi	sp,sp,-32
80106a10:	de00012e 	bgeu	sp,et,80106a18 <bFeebGetCh6RightFeeBusy+0xc>
80106a14:	003b68fa 	trap	3
80106a18:	dfc00715 	stw	ra,28(sp)
80106a1c:	df000615 	stw	fp,24(sp)
80106a20:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106a24:	e03ffa15 	stw	zero,-24(fp)
80106a28:	00901034 	movhi	r2,16448
80106a2c:	10820004 	addi	r2,r2,2048
80106a30:	e0bffb15 	stw	r2,-20(fp)
80106a34:	008000c4 	movi	r2,3
80106a38:	e0bffc15 	stw	r2,-16(fp)
80106a3c:	00804004 	movi	r2,256
80106a40:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106a44:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106a48:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106a4c:	e0bffb17 	ldw	r2,-20(fp)
80106a50:	e17ffc17 	ldw	r5,-16(fp)
80106a54:	1009883a 	mov	r4,r2
80106a58:	01072d80 	call	801072d8 <uliFeebReadReg>
80106a5c:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106a60:	e0ffff17 	ldw	r3,-4(fp)
80106a64:	e0bffd17 	ldw	r2,-12(fp)
80106a68:	1884703a 	and	r2,r3,r2
80106a6c:	10000326 	beq	r2,zero,80106a7c <bFeebGetCh6RightFeeBusy+0x70>
		bFlag = TRUE;
80106a70:	00800044 	movi	r2,1
80106a74:	e0bffe15 	stw	r2,-8(fp)
80106a78:	00000106 	br	80106a80 <bFeebGetCh6RightFeeBusy+0x74>
	} else {
		bFlag = FALSE;
80106a7c:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106a80:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh6RightFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_6_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_FEE_BUSY_MSK);
80106a84:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106a88:	e0bffa17 	ldw	r2,-24(fp)
}
80106a8c:	e037883a 	mov	sp,fp
80106a90:	dfc00117 	ldw	ra,4(sp)
80106a94:	df000017 	ldw	fp,0(sp)
80106a98:	dec00204 	addi	sp,sp,8
80106a9c:	f800283a 	ret

80106aa0 <bFeebGetCh7LeftFeeBusy>:

bool bFeebGetCh7LeftFeeBusy(void) {
80106aa0:	defff804 	addi	sp,sp,-32
80106aa4:	de00012e 	bgeu	sp,et,80106aac <bFeebGetCh7LeftFeeBusy+0xc>
80106aa8:	003b68fa 	trap	3
80106aac:	dfc00715 	stw	ra,28(sp)
80106ab0:	df000615 	stw	fp,24(sp)
80106ab4:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106ab8:	e03ffa15 	stw	zero,-24(fp)
80106abc:	00901034 	movhi	r2,16448
80106ac0:	10810004 	addi	r2,r2,1024
80106ac4:	e0bffb15 	stw	r2,-20(fp)
80106ac8:	008000c4 	movi	r2,3
80106acc:	e0bffc15 	stw	r2,-16(fp)
80106ad0:	00808004 	movi	r2,512
80106ad4:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106ad8:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106adc:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106ae0:	e0bffb17 	ldw	r2,-20(fp)
80106ae4:	e17ffc17 	ldw	r5,-16(fp)
80106ae8:	1009883a 	mov	r4,r2
80106aec:	01072d80 	call	801072d8 <uliFeebReadReg>
80106af0:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106af4:	e0ffff17 	ldw	r3,-4(fp)
80106af8:	e0bffd17 	ldw	r2,-12(fp)
80106afc:	1884703a 	and	r2,r3,r2
80106b00:	10000326 	beq	r2,zero,80106b10 <bFeebGetCh7LeftFeeBusy+0x70>
		bFlag = TRUE;
80106b04:	00800044 	movi	r2,1
80106b08:	e0bffe15 	stw	r2,-8(fp)
80106b0c:	00000106 	br	80106b14 <bFeebGetCh7LeftFeeBusy+0x74>
	} else {
		bFlag = FALSE;
80106b10:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106b14:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh7LeftFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_7_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_FEE_BUSY_MSK);
80106b18:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106b1c:	e0bffa17 	ldw	r2,-24(fp)
}
80106b20:	e037883a 	mov	sp,fp
80106b24:	dfc00117 	ldw	ra,4(sp)
80106b28:	df000017 	ldw	fp,0(sp)
80106b2c:	dec00204 	addi	sp,sp,8
80106b30:	f800283a 	ret

80106b34 <bFeebGetCh7RightFeeBusy>:

bool bFeebGetCh7RightFeeBusy(void) {
80106b34:	defff804 	addi	sp,sp,-32
80106b38:	de00012e 	bgeu	sp,et,80106b40 <bFeebGetCh7RightFeeBusy+0xc>
80106b3c:	003b68fa 	trap	3
80106b40:	dfc00715 	stw	ra,28(sp)
80106b44:	df000615 	stw	fp,24(sp)
80106b48:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106b4c:	e03ffa15 	stw	zero,-24(fp)
80106b50:	00901034 	movhi	r2,16448
80106b54:	10810004 	addi	r2,r2,1024
80106b58:	e0bffb15 	stw	r2,-20(fp)
80106b5c:	008000c4 	movi	r2,3
80106b60:	e0bffc15 	stw	r2,-16(fp)
80106b64:	00804004 	movi	r2,256
80106b68:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106b6c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106b70:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106b74:	e0bffb17 	ldw	r2,-20(fp)
80106b78:	e17ffc17 	ldw	r5,-16(fp)
80106b7c:	1009883a 	mov	r4,r2
80106b80:	01072d80 	call	801072d8 <uliFeebReadReg>
80106b84:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106b88:	e0ffff17 	ldw	r3,-4(fp)
80106b8c:	e0bffd17 	ldw	r2,-12(fp)
80106b90:	1884703a 	and	r2,r3,r2
80106b94:	10000326 	beq	r2,zero,80106ba4 <bFeebGetCh7RightFeeBusy+0x70>
		bFlag = TRUE;
80106b98:	00800044 	movi	r2,1
80106b9c:	e0bffe15 	stw	r2,-8(fp)
80106ba0:	00000106 	br	80106ba8 <bFeebGetCh7RightFeeBusy+0x74>
	} else {
		bFlag = FALSE;
80106ba4:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106ba8:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh7RightFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_7_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_FEE_BUSY_MSK);
80106bac:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106bb0:	e0bffa17 	ldw	r2,-24(fp)
}
80106bb4:	e037883a 	mov	sp,fp
80106bb8:	dfc00117 	ldw	ra,4(sp)
80106bbc:	df000017 	ldw	fp,0(sp)
80106bc0:	dec00204 	addi	sp,sp,8
80106bc4:	f800283a 	ret

80106bc8 <bFeebGetCh8LeftFeeBusy>:

bool bFeebGetCh8LeftFeeBusy(void) {
80106bc8:	defff804 	addi	sp,sp,-32
80106bcc:	de00012e 	bgeu	sp,et,80106bd4 <bFeebGetCh8LeftFeeBusy+0xc>
80106bd0:	003b68fa 	trap	3
80106bd4:	dfc00715 	stw	ra,28(sp)
80106bd8:	df000615 	stw	fp,24(sp)
80106bdc:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106be0:	e03ffa15 	stw	zero,-24(fp)
80106be4:	00901034 	movhi	r2,16448
80106be8:	e0bffb15 	stw	r2,-20(fp)
80106bec:	008000c4 	movi	r2,3
80106bf0:	e0bffc15 	stw	r2,-16(fp)
80106bf4:	00808004 	movi	r2,512
80106bf8:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106bfc:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106c00:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106c04:	e0bffb17 	ldw	r2,-20(fp)
80106c08:	e17ffc17 	ldw	r5,-16(fp)
80106c0c:	1009883a 	mov	r4,r2
80106c10:	01072d80 	call	801072d8 <uliFeebReadReg>
80106c14:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106c18:	e0ffff17 	ldw	r3,-4(fp)
80106c1c:	e0bffd17 	ldw	r2,-12(fp)
80106c20:	1884703a 	and	r2,r3,r2
80106c24:	10000326 	beq	r2,zero,80106c34 <bFeebGetCh8LeftFeeBusy+0x6c>
		bFlag = TRUE;
80106c28:	00800044 	movi	r2,1
80106c2c:	e0bffe15 	stw	r2,-8(fp)
80106c30:	00000106 	br	80106c38 <bFeebGetCh8LeftFeeBusy+0x70>
	} else {
		bFlag = FALSE;
80106c34:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106c38:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh8LeftFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_8_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_LEFT_FEE_BUSY_MSK);
80106c3c:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106c40:	e0bffa17 	ldw	r2,-24(fp)
}
80106c44:	e037883a 	mov	sp,fp
80106c48:	dfc00117 	ldw	ra,4(sp)
80106c4c:	df000017 	ldw	fp,0(sp)
80106c50:	dec00204 	addi	sp,sp,8
80106c54:	f800283a 	ret

80106c58 <bFeebGetCh8RightFeeBusy>:

bool bFeebGetCh8RightFeeBusy(void) {
80106c58:	defff804 	addi	sp,sp,-32
80106c5c:	de00012e 	bgeu	sp,et,80106c64 <bFeebGetCh8RightFeeBusy+0xc>
80106c60:	003b68fa 	trap	3
80106c64:	dfc00715 	stw	ra,28(sp)
80106c68:	df000615 	stw	fp,24(sp)
80106c6c:	df000604 	addi	fp,sp,24
	bool bFlag = FALSE;
80106c70:	e03ffa15 	stw	zero,-24(fp)
80106c74:	00901034 	movhi	r2,16448
80106c78:	e0bffb15 	stw	r2,-20(fp)
80106c7c:	008000c4 	movi	r2,3
80106c80:	e0bffc15 	stw	r2,-16(fp)
80106c84:	00804004 	movi	r2,256
80106c88:	e0bffd15 	stw	r2,-12(fp)

//! [public functions]

//! [private functions]
static ALT_INLINE bool ALT_ALWAYS_INLINE bFeebGetChFlag(alt_u32 uliCommChBaseAddr, alt_u32 uliCommRegOffset, alt_u32 uliCommFlagMask) {
	bool bFlag = FALSE;
80106c8c:	e03ffe15 	stw	zero,-8(fp)
	volatile alt_u32 uliReg = 0;
80106c90:	e03fff15 	stw	zero,-4(fp)

	uliReg = uliFeebReadReg((alt_u32 *) uliCommChBaseAddr, uliCommRegOffset);
80106c94:	e0bffb17 	ldw	r2,-20(fp)
80106c98:	e17ffc17 	ldw	r5,-16(fp)
80106c9c:	1009883a 	mov	r4,r2
80106ca0:	01072d80 	call	801072d8 <uliFeebReadReg>
80106ca4:	e0bfff15 	stw	r2,-4(fp)

	if (uliReg & uliCommFlagMask) {
80106ca8:	e0ffff17 	ldw	r3,-4(fp)
80106cac:	e0bffd17 	ldw	r2,-12(fp)
80106cb0:	1884703a 	and	r2,r3,r2
80106cb4:	10000326 	beq	r2,zero,80106cc4 <bFeebGetCh8RightFeeBusy+0x6c>
		bFlag = TRUE;
80106cb8:	00800044 	movi	r2,1
80106cbc:	e0bffe15 	stw	r2,-8(fp)
80106cc0:	00000106 	br	80106cc8 <bFeebGetCh8RightFeeBusy+0x70>
	} else {
		bFlag = FALSE;
80106cc4:	e03ffe15 	stw	zero,-8(fp)

	}

	return bFlag;
80106cc8:	e0bffe17 	ldw	r2,-8(fp)
	return bFlag;
}

bool bFeebGetCh8RightFeeBusy(void) {
	bool bFlag = FALSE;
	bFlag = bFeebGetChFlag(COMM_CHANNEL_8_BASE_ADDR, COMM_FEE_BUFF_STAT_REG_OFST, COMM_WIND_RIGH_FEE_BUSY_MSK);
80106ccc:	e0bffa15 	stw	r2,-24(fp)
	return bFlag;
80106cd0:	e0bffa17 	ldw	r2,-24(fp)
}
80106cd4:	e037883a 	mov	sp,fp
80106cd8:	dfc00117 	ldw	ra,4(sp)
80106cdc:	df000017 	ldw	fp,0(sp)
80106ce0:	dec00204 	addi	sp,sp,8
80106ce4:	f800283a 	ret

80106ce8 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
80106ce8:	defff904 	addi	sp,sp,-28
80106cec:	de00012e 	bgeu	sp,et,80106cf4 <bFeebSetBufferSize+0xc>
80106cf0:	003b68fa 	trap	3
80106cf4:	dfc00615 	stw	ra,24(sp)
80106cf8:	df000515 	stw	fp,20(sp)
80106cfc:	df000504 	addi	fp,sp,20
80106d00:	e13ffd15 	stw	r4,-12(fp)
80106d04:	2807883a 	mov	r3,r5
80106d08:	3005883a 	mov	r2,r6
80106d0c:	e0fffe05 	stb	r3,-8(fp)
80106d10:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
80106d14:	00800044 	movi	r2,1
80106d18:	e0bffb15 	stw	r2,-20(fp)
	volatile alt_u32 uliReg = 0;
80106d1c:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
80106d20:	e0bffe03 	ldbu	r2,-8(fp)
80106d24:	10002326 	beq	r2,zero,80106db4 <bFeebSetBufferSize+0xcc>
80106d28:	e0bffe03 	ldbu	r2,-8(fp)
80106d2c:	10800468 	cmpgeui	r2,r2,17
80106d30:	1000201e 	bne	r2,zero,80106db4 <bFeebSetBufferSize+0xcc>
		switch (ucBufferSide) {
80106d34:	e0bfff03 	ldbu	r2,-4(fp)
80106d38:	10000326 	beq	r2,zero,80106d48 <bFeebSetBufferSize+0x60>
80106d3c:	10800060 	cmpeqi	r2,r2,1
80106d40:	10000d1e 	bne	r2,zero,80106d78 <bFeebSetBufferSize+0x90>
80106d44:	00001806 	br	80106da8 <bFeebSetBufferSize+0xc0>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80106d48:	e0bffe03 	ldbu	r2,-8(fp)
80106d4c:	10bfffc4 	addi	r2,r2,-1
80106d50:	108003cc 	andi	r2,r2,15
80106d54:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
80106d58:	e0bffd17 	ldw	r2,-12(fp)
80106d5c:	10800017 	ldw	r2,0(r2)
80106d60:	e0fffc17 	ldw	r3,-16(fp)
80106d64:	180d883a 	mov	r6,r3
80106d68:	01400544 	movi	r5,21
80106d6c:	1009883a 	mov	r4,r2
80106d70:	01072840 	call	80107284 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
80106d74:	00000e06 	br	80106db0 <bFeebSetBufferSize+0xc8>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
80106d78:	e0bffe03 	ldbu	r2,-8(fp)
80106d7c:	10bfffc4 	addi	r2,r2,-1
80106d80:	108003cc 	andi	r2,r2,15
80106d84:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
80106d88:	e0bffd17 	ldw	r2,-12(fp)
80106d8c:	10800017 	ldw	r2,0(r2)
80106d90:	e0fffc17 	ldw	r3,-16(fp)
80106d94:	180d883a 	mov	r6,r3
80106d98:	01400504 	movi	r5,20
80106d9c:	1009883a 	mov	r4,r2
80106da0:	01072840 	call	80107284 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
80106da4:	00000206 	br	80106db0 <bFeebSetBufferSize+0xc8>
		default:
			bStatus = FALSE;
80106da8:	e03ffb15 	stw	zero,-20(fp)
			break;
80106dac:	0001883a 	nop
		}
	} else {
80106db0:	00000106 	br	80106db8 <bFeebSetBufferSize+0xd0>
		bStatus = FALSE;
80106db4:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
80106db8:	e0bffb17 	ldw	r2,-20(fp)
}
80106dbc:	e037883a 	mov	sp,fp
80106dc0:	dfc00117 	ldw	ra,4(sp)
80106dc4:	df000017 	ldw	fp,0(sp)
80106dc8:	dec00204 	addi	sp,sp,8
80106dcc:	f800283a 	ret

80106dd0 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
80106dd0:	defffb04 	addi	sp,sp,-20
80106dd4:	de00012e 	bgeu	sp,et,80106ddc <bFeebSetWindowing+0xc>
80106dd8:	003b68fa 	trap	3
80106ddc:	dfc00415 	stw	ra,16(sp)
80106de0:	df000315 	stw	fp,12(sp)
80106de4:	df000304 	addi	fp,sp,12
80106de8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80106dec:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80106df0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
80106df4:	e0bfff17 	ldw	r2,-4(fp)
80106df8:	10001a26 	beq	r2,zero,80106e64 <bFeebSetWindowing+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80106dfc:	e0bfff17 	ldw	r2,-4(fp)
80106e00:	10800017 	ldw	r2,0(r2)
80106e04:	01400084 	movi	r5,2
80106e08:	1009883a 	mov	r4,r2
80106e0c:	01072d80 	call	801072d8 <uliFeebReadReg>
80106e10:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
80106e14:	e0bfff17 	ldw	r2,-4(fp)
80106e18:	10800117 	ldw	r2,4(r2)
80106e1c:	10000426 	beq	r2,zero,80106e30 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
80106e20:	e0bffe17 	ldw	r2,-8(fp)
80106e24:	10800214 	ori	r2,r2,8
80106e28:	e0bffe15 	stw	r2,-8(fp)
80106e2c:	00000406 	br	80106e40 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
80106e30:	e0fffe17 	ldw	r3,-8(fp)
80106e34:	00bffdc4 	movi	r2,-9
80106e38:	1884703a 	and	r2,r3,r2
80106e3c:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
80106e40:	e0bfff17 	ldw	r2,-4(fp)
80106e44:	10800017 	ldw	r2,0(r2)
80106e48:	e0fffe17 	ldw	r3,-8(fp)
80106e4c:	180d883a 	mov	r6,r3
80106e50:	01400084 	movi	r5,2
80106e54:	1009883a 	mov	r4,r2
80106e58:	01072840 	call	80107284 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
80106e5c:	00800044 	movi	r2,1
80106e60:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80106e64:	e0bffd17 	ldw	r2,-12(fp)
}
80106e68:	e037883a 	mov	sp,fp
80106e6c:	dfc00117 	ldw	ra,4(sp)
80106e70:	df000017 	ldw	fp,0(sp)
80106e74:	dec00204 	addi	sp,sp,8
80106e78:	f800283a 	ret

80106e7c <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
80106e7c:	defffb04 	addi	sp,sp,-20
80106e80:	de00012e 	bgeu	sp,et,80106e88 <bFeebGetWindowing+0xc>
80106e84:	003b68fa 	trap	3
80106e88:	dfc00415 	stw	ra,16(sp)
80106e8c:	df000315 	stw	fp,12(sp)
80106e90:	df000304 	addi	fp,sp,12
80106e94:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80106e98:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80106e9c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
80106ea0:	e0bfff17 	ldw	r2,-4(fp)
80106ea4:	10001126 	beq	r2,zero,80106eec <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80106ea8:	e0bfff17 	ldw	r2,-4(fp)
80106eac:	10800017 	ldw	r2,0(r2)
80106eb0:	01400084 	movi	r5,2
80106eb4:	1009883a 	mov	r4,r2
80106eb8:	01072d80 	call	801072d8 <uliFeebReadReg>
80106ebc:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
80106ec0:	e0bffe17 	ldw	r2,-8(fp)
80106ec4:	1080020c 	andi	r2,r2,8
80106ec8:	10000426 	beq	r2,zero,80106edc <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
80106ecc:	e0bfff17 	ldw	r2,-4(fp)
80106ed0:	00c00044 	movi	r3,1
80106ed4:	10c00115 	stw	r3,4(r2)
80106ed8:	00000206 	br	80106ee4 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
80106edc:	e0bfff17 	ldw	r2,-4(fp)
80106ee0:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
80106ee4:	00800044 	movi	r2,1
80106ee8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80106eec:	e0bffd17 	ldw	r2,-12(fp)
}
80106ef0:	e037883a 	mov	sp,fp
80106ef4:	dfc00117 	ldw	ra,4(sp)
80106ef8:	df000017 	ldw	fp,0(sp)
80106efc:	dec00204 	addi	sp,sp,8
80106f00:	f800283a 	ret

80106f04 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
80106f04:	defffb04 	addi	sp,sp,-20
80106f08:	de00012e 	bgeu	sp,et,80106f10 <bFeebStartCh+0xc>
80106f0c:	003b68fa 	trap	3
80106f10:	dfc00415 	stw	ra,16(sp)
80106f14:	df000315 	stw	fp,12(sp)
80106f18:	df000304 	addi	fp,sp,12
80106f1c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80106f20:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80106f24:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
80106f28:	e0bfff17 	ldw	r2,-4(fp)
80106f2c:	10001226 	beq	r2,zero,80106f78 <bFeebStartCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80106f30:	e0bfff17 	ldw	r2,-4(fp)
80106f34:	10800017 	ldw	r2,0(r2)
80106f38:	01400084 	movi	r5,2
80106f3c:	1009883a 	mov	r4,r2
80106f40:	01072d80 	call	801072d8 <uliFeebReadReg>
80106f44:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
80106f48:	e0bffe17 	ldw	r2,-8(fp)
80106f4c:	10800114 	ori	r2,r2,4
80106f50:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
80106f54:	e0bfff17 	ldw	r2,-4(fp)
80106f58:	10800017 	ldw	r2,0(r2)
80106f5c:	e0fffe17 	ldw	r3,-8(fp)
80106f60:	180d883a 	mov	r6,r3
80106f64:	01400084 	movi	r5,2
80106f68:	1009883a 	mov	r4,r2
80106f6c:	01072840 	call	80107284 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
80106f70:	00800044 	movi	r2,1
80106f74:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80106f78:	e0bffd17 	ldw	r2,-12(fp)
}
80106f7c:	e037883a 	mov	sp,fp
80106f80:	dfc00117 	ldw	ra,4(sp)
80106f84:	df000017 	ldw	fp,0(sp)
80106f88:	dec00204 	addi	sp,sp,8
80106f8c:	f800283a 	ret

80106f90 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
80106f90:	defffb04 	addi	sp,sp,-20
80106f94:	de00012e 	bgeu	sp,et,80106f9c <bFeebStopCh+0xc>
80106f98:	003b68fa 	trap	3
80106f9c:	dfc00415 	stw	ra,16(sp)
80106fa0:	df000315 	stw	fp,12(sp)
80106fa4:	df000304 	addi	fp,sp,12
80106fa8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80106fac:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80106fb0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
80106fb4:	e0bfff17 	ldw	r2,-4(fp)
80106fb8:	10001226 	beq	r2,zero,80107004 <bFeebStopCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80106fbc:	e0bfff17 	ldw	r2,-4(fp)
80106fc0:	10800017 	ldw	r2,0(r2)
80106fc4:	01400084 	movi	r5,2
80106fc8:	1009883a 	mov	r4,r2
80106fcc:	01072d80 	call	801072d8 <uliFeebReadReg>
80106fd0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
80106fd4:	e0bffe17 	ldw	r2,-8(fp)
80106fd8:	10800094 	ori	r2,r2,2
80106fdc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
80106fe0:	e0bfff17 	ldw	r2,-4(fp)
80106fe4:	10800017 	ldw	r2,0(r2)
80106fe8:	e0fffe17 	ldw	r3,-8(fp)
80106fec:	180d883a 	mov	r6,r3
80106ff0:	01400084 	movi	r5,2
80106ff4:	1009883a 	mov	r4,r2
80106ff8:	01072840 	call	80107284 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
80106ffc:	00800044 	movi	r2,1
80107000:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80107004:	e0bffd17 	ldw	r2,-12(fp)
}
80107008:	e037883a 	mov	sp,fp
8010700c:	dfc00117 	ldw	ra,4(sp)
80107010:	df000017 	ldw	fp,0(sp)
80107014:	dec00204 	addi	sp,sp,8
80107018:	f800283a 	ret

8010701c <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
8010701c:	defffb04 	addi	sp,sp,-20
80107020:	de00012e 	bgeu	sp,et,80107028 <bFeebClrCh+0xc>
80107024:	003b68fa 	trap	3
80107028:	dfc00415 	stw	ra,16(sp)
8010702c:	df000315 	stw	fp,12(sp)
80107030:	df000304 	addi	fp,sp,12
80107034:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80107038:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010703c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
80107040:	e0bfff17 	ldw	r2,-4(fp)
80107044:	10001226 	beq	r2,zero,80107090 <bFeebClrCh+0x74>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
80107048:	e0bfff17 	ldw	r2,-4(fp)
8010704c:	10800017 	ldw	r2,0(r2)
80107050:	01400084 	movi	r5,2
80107054:	1009883a 	mov	r4,r2
80107058:	01072d80 	call	801072d8 <uliFeebReadReg>
8010705c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
80107060:	e0bffe17 	ldw	r2,-8(fp)
80107064:	10800054 	ori	r2,r2,1
80107068:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
8010706c:	e0bfff17 	ldw	r2,-4(fp)
80107070:	10800017 	ldw	r2,0(r2)
80107074:	e0fffe17 	ldw	r3,-8(fp)
80107078:	180d883a 	mov	r6,r3
8010707c:	01400084 	movi	r5,2
80107080:	1009883a 	mov	r4,r2
80107084:	01072840 	call	80107284 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
80107088:	00800044 	movi	r2,1
8010708c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80107090:	e0bffd17 	ldw	r2,-12(fp)
}
80107094:	e037883a 	mov	sp,fp
80107098:	dfc00117 	ldw	ra,4(sp)
8010709c:	df000017 	ldw	fp,0(sp)
801070a0:	dec00204 	addi	sp,sp,8
801070a4:	f800283a 	ret

801070a8 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
801070a8:	defff904 	addi	sp,sp,-28
801070ac:	de00012e 	bgeu	sp,et,801070b4 <bFeebInitCh+0xc>
801070b0:	003b68fa 	trap	3
801070b4:	dfc00615 	stw	ra,24(sp)
801070b8:	df000515 	stw	fp,20(sp)
801070bc:	df000504 	addi	fp,sp,20
801070c0:	e13ffe15 	stw	r4,-8(fp)
801070c4:	2805883a 	mov	r2,r5
801070c8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
801070cc:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
801070d0:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
801070d4:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
801070d8:	e0bffe17 	ldw	r2,-8(fp)
801070dc:	10006326 	beq	r2,zero,8010726c <bFeebInitCh+0x1c4>

		switch (ucCommCh) {
801070e0:	e0bfff03 	ldbu	r2,-4(fp)
801070e4:	10c00228 	cmpgeui	r3,r2,8
801070e8:	1800441e 	bne	r3,zero,801071fc <bFeebInitCh+0x154>
801070ec:	100690ba 	slli	r3,r2,2
801070f0:	00a00434 	movhi	r2,32784
801070f4:	109c4104 	addi	r2,r2,28932
801070f8:	1885883a 	add	r2,r3,r2
801070fc:	10800017 	ldw	r2,0(r2)
80107100:	1000683a 	jmp	r2
80107104:	80107124 	muli	zero,r16,16836
80107108:	80107140 	call	88010714 <__reset+0x1ff0714>
8010710c:	8010715c 	xori	zero,r16,16837
80107110:	80107178 	rdprs	zero,r16,16837
80107114:	80107190 	cmplti	zero,r16,16838
80107118:	801071ac 	andhi	zero,r16,16838
8010711c:	801071c8 	cmpgei	zero,r16,16839
80107120:	801071e4 	muli	zero,r16,16839
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
80107124:	e0fffe17 	ldw	r3,-8(fp)
80107128:	00901034 	movhi	r2,16448
8010712c:	10830004 	addi	r2,r2,3072
80107130:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
80107134:	00800044 	movi	r2,1
80107138:	e0bffc15 	stw	r2,-16(fp)
			break;
8010713c:	00003106 	br	80107204 <bFeebInitCh+0x15c>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
80107140:	e0fffe17 	ldw	r3,-8(fp)
80107144:	00901034 	movhi	r2,16448
80107148:	10820004 	addi	r2,r2,2048
8010714c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
80107150:	00800044 	movi	r2,1
80107154:	e0bffc15 	stw	r2,-16(fp)
			break;
80107158:	00002a06 	br	80107204 <bFeebInitCh+0x15c>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8010715c:	e0fffe17 	ldw	r3,-8(fp)
80107160:	00901034 	movhi	r2,16448
80107164:	10810004 	addi	r2,r2,1024
80107168:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010716c:	00800044 	movi	r2,1
80107170:	e0bffc15 	stw	r2,-16(fp)
			break;
80107174:	00002306 	br	80107204 <bFeebInitCh+0x15c>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
80107178:	e0bffe17 	ldw	r2,-8(fp)
8010717c:	00d01034 	movhi	r3,16448
80107180:	10c00015 	stw	r3,0(r2)
			bValidCh = TRUE;
80107184:	00800044 	movi	r2,1
80107188:	e0bffc15 	stw	r2,-16(fp)
			break;
8010718c:	00001d06 	br	80107204 <bFeebInitCh+0x15c>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
80107190:	e0fffe17 	ldw	r3,-8(fp)
80107194:	00901034 	movhi	r2,16448
80107198:	10830004 	addi	r2,r2,3072
8010719c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
801071a0:	00800044 	movi	r2,1
801071a4:	e0bffc15 	stw	r2,-16(fp)
			break;
801071a8:	00001606 	br	80107204 <bFeebInitCh+0x15c>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
801071ac:	e0fffe17 	ldw	r3,-8(fp)
801071b0:	00901034 	movhi	r2,16448
801071b4:	10820004 	addi	r2,r2,2048
801071b8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
801071bc:	00800044 	movi	r2,1
801071c0:	e0bffc15 	stw	r2,-16(fp)
			break;
801071c4:	00000f06 	br	80107204 <bFeebInitCh+0x15c>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
801071c8:	e0fffe17 	ldw	r3,-8(fp)
801071cc:	00901034 	movhi	r2,16448
801071d0:	10810004 	addi	r2,r2,1024
801071d4:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
801071d8:	00800044 	movi	r2,1
801071dc:	e0bffc15 	stw	r2,-16(fp)
			break;
801071e0:	00000806 	br	80107204 <bFeebInitCh+0x15c>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
801071e4:	e0bffe17 	ldw	r2,-8(fp)
801071e8:	00d01034 	movhi	r3,16448
801071ec:	10c00015 	stw	r3,0(r2)
			bValidCh = TRUE;
801071f0:	00800044 	movi	r2,1
801071f4:	e0bffc15 	stw	r2,-16(fp)
			break;
801071f8:	00000206 	br	80107204 <bFeebInitCh+0x15c>
		default:
			bValidCh = FALSE;
801071fc:	e03ffc15 	stw	zero,-16(fp)
			break;
80107200:	0001883a 	nop
		}

		if (bValidCh) {
80107204:	e0bffc17 	ldw	r2,-16(fp)
80107208:	10001826 	beq	r2,zero,8010726c <bFeebInitCh+0x1c4>
			if (!bFeebGetIrqControl(pxFeebCh)) {
8010720c:	e13ffe17 	ldw	r4,-8(fp)
80107210:	01056a40 	call	801056a4 <bFeebGetIrqControl>
80107214:	1000021e 	bne	r2,zero,80107220 <bFeebInitCh+0x178>
				bInitFail = TRUE;
80107218:	00800044 	movi	r2,1
8010721c:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
80107220:	e13ffe17 	ldw	r4,-8(fp)
80107224:	01057500 	call	80105750 <bFeebGetIrqFlags>
80107228:	1000021e 	bne	r2,zero,80107234 <bFeebInitCh+0x18c>
				bInitFail = TRUE;
8010722c:	00800044 	movi	r2,1
80107230:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
80107234:	e13ffe17 	ldw	r4,-8(fp)
80107238:	01058440 	call	80105844 <bFeebGetBuffersStatus>
8010723c:	1000021e 	bne	r2,zero,80107248 <bFeebInitCh+0x1a0>
				bInitFail = TRUE;
80107240:	00800044 	movi	r2,1
80107244:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
80107248:	e13ffe17 	ldw	r4,-8(fp)
8010724c:	0106e7c0 	call	80106e7c <bFeebGetWindowing>
80107250:	1000021e 	bne	r2,zero,8010725c <bFeebInitCh+0x1b4>
				bInitFail = TRUE;
80107254:	00800044 	movi	r2,1
80107258:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
8010725c:	e0bffd17 	ldw	r2,-12(fp)
80107260:	1000021e 	bne	r2,zero,8010726c <bFeebInitCh+0x1c4>
				bStatus = TRUE;
80107264:	00800044 	movi	r2,1
80107268:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
8010726c:	e0bffb17 	ldw	r2,-20(fp)
}
80107270:	e037883a 	mov	sp,fp
80107274:	dfc00117 	ldw	ra,4(sp)
80107278:	df000017 	ldw	fp,0(sp)
8010727c:	dec00204 	addi	sp,sp,8
80107280:	f800283a 	ret

80107284 <vFeebWriteReg>:

	return bFlag;
}

static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
80107284:	defffc04 	addi	sp,sp,-16
80107288:	de00012e 	bgeu	sp,et,80107290 <vFeebWriteReg+0xc>
8010728c:	003b68fa 	trap	3
80107290:	df000315 	stw	fp,12(sp)
80107294:	df000304 	addi	fp,sp,12
80107298:	e13ffd15 	stw	r4,-12(fp)
8010729c:	e17ffe15 	stw	r5,-8(fp)
801072a0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
801072a4:	e0bffe17 	ldw	r2,-8(fp)
801072a8:	1085883a 	add	r2,r2,r2
801072ac:	1085883a 	add	r2,r2,r2
801072b0:	1007883a 	mov	r3,r2
801072b4:	e0bffd17 	ldw	r2,-12(fp)
801072b8:	10c5883a 	add	r2,r2,r3
801072bc:	e0ffff17 	ldw	r3,-4(fp)
801072c0:	10c00015 	stw	r3,0(r2)
}
801072c4:	0001883a 	nop
801072c8:	e037883a 	mov	sp,fp
801072cc:	df000017 	ldw	fp,0(sp)
801072d0:	dec00104 	addi	sp,sp,4
801072d4:	f800283a 	ret

801072d8 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
801072d8:	defffc04 	addi	sp,sp,-16
801072dc:	de00012e 	bgeu	sp,et,801072e4 <uliFeebReadReg+0xc>
801072e0:	003b68fa 	trap	3
801072e4:	df000315 	stw	fp,12(sp)
801072e8:	df000304 	addi	fp,sp,12
801072ec:	e13ffe15 	stw	r4,-8(fp)
801072f0:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
801072f4:	e0bfff17 	ldw	r2,-4(fp)
801072f8:	1085883a 	add	r2,r2,r2
801072fc:	1085883a 	add	r2,r2,r2
80107300:	1007883a 	mov	r3,r2
80107304:	e0bffe17 	ldw	r2,-8(fp)
80107308:	10c5883a 	add	r2,r2,r3
8010730c:	10800017 	ldw	r2,0(r2)
80107310:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
80107314:	e0bffd17 	ldw	r2,-12(fp)
}
80107318:	e037883a 	mov	sp,fp
8010731c:	df000017 	ldw	fp,0(sp)
80107320:	dec00104 	addi	sp,sp,4
80107324:	f800283a 	ret

80107328 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
80107328:	defffb04 	addi	sp,sp,-20
8010732c:	de00012e 	bgeu	sp,et,80107334 <vRmapCh1HandleIrq+0xc>
80107330:	003b68fa 	trap	3
80107334:	dfc00415 	stw	ra,16(sp)
80107338:	df000315 	stw	fp,12(sp)
8010733c:	df000304 	addi	fp,sp,12
80107340:	e13fff15 	stw	r4,-4(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"IRQ RMAP.\n");
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
80107344:	0107b380 	call	80107b38 <uliRmapCh1WriteCmdAddress>
80107348:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
8010734c:	00800444 	movi	r2,17
80107350:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
80107354:	00bffc04 	movi	r2,-16
80107358:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
8010735c:	e0bffd03 	ldbu	r2,-12(fp)
80107360:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = xDefaultsCH.ucChannelToFEE[0];
80107364:	00a005b4 	movhi	r2,32790
80107368:	10ba3204 	addi	r2,r2,-5944
8010736c:	10800003 	ldbu	r2,0(r2)
80107370:	e0bffe05 	stb	r2,-8(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
	}
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
80107374:	00a00574 	movhi	r2,32789
80107378:	109f5404 	addi	r2,r2,32080
8010737c:	10800017 	ldw	r2,0(r2)
80107380:	e0fffe17 	ldw	r3,-8(fp)
80107384:	180b883a 	mov	r5,r3
80107388:	1009883a 	mov	r4,r2
8010738c:	013957c0 	call	8013957c <OSQPostFront>
80107390:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
80107394:	e0bffd43 	ldbu	r2,-11(fp)
80107398:	10000226 	beq	r2,zero,801073a4 <vRmapCh1HandleIrq+0x7c>
		vFailSendRMAPFromIRQ( 0 );
8010739c:	0009883a 	mov	r4,zero
801073a0:	011da680 	call	8011da68 <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
801073a4:	01076680 	call	80107668 <vRmapCh1IrqFlagClrWriteCmd>
}
801073a8:	0001883a 	nop
801073ac:	e037883a 	mov	sp,fp
801073b0:	dfc00117 	ldw	ra,4(sp)
801073b4:	df000017 	ldw	fp,0(sp)
801073b8:	dec00204 	addi	sp,sp,8
801073bc:	f800283a 	ret

801073c0 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
801073c0:	defffb04 	addi	sp,sp,-20
801073c4:	de00012e 	bgeu	sp,et,801073cc <vRmapCh2HandleIrq+0xc>
801073c8:	003b68fa 	trap	3
801073cc:	dfc00415 	stw	ra,16(sp)
801073d0:	df000315 	stw	fp,12(sp)
801073d4:	df000304 	addi	fp,sp,12
801073d8:	e13fff15 	stw	r4,-4(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"IRQ RMAP.\n");
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
801073dc:	0107b8c0 	call	80107b8c <uliRmapCh2WriteCmdAddress>
801073e0:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 1;
801073e4:	00800484 	movi	r2,18
801073e8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
801073ec:	00bffc04 	movi	r2,-16
801073f0:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
801073f4:	e0bffd03 	ldbu	r2,-12(fp)
801073f8:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = xDefaultsCH.ucChannelToFEE[1];
801073fc:	00a005b4 	movhi	r2,32790
80107400:	10ba3204 	addi	r2,r2,-5944
80107404:	10800043 	ldbu	r2,1(r2)
80107408:	e0bffe05 	stb	r2,-8(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
	}
#endif

	error_codel = OSQPostFront(xFeeQ[1], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
8010740c:	00a00574 	movhi	r2,32789
80107410:	109f5404 	addi	r2,r2,32080
80107414:	10800117 	ldw	r2,4(r2)
80107418:	e0fffe17 	ldw	r3,-8(fp)
8010741c:	180b883a 	mov	r5,r3
80107420:	1009883a 	mov	r4,r2
80107424:	013957c0 	call	8013957c <OSQPostFront>
80107428:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8010742c:	e0bffd43 	ldbu	r2,-11(fp)
80107430:	10000226 	beq	r2,zero,8010743c <vRmapCh2HandleIrq+0x7c>
		vFailSendRMAPFromIRQ( 1 );
80107434:	01000044 	movi	r4,1
80107438:	011da680 	call	8011da68 <vFailSendRMAPFromIRQ>
	}


	vRmapCh2IrqFlagClrWriteCmd();
8010743c:	01076ac0 	call	801076ac <vRmapCh2IrqFlagClrWriteCmd>
}
80107440:	0001883a 	nop
80107444:	e037883a 	mov	sp,fp
80107448:	dfc00117 	ldw	ra,4(sp)
8010744c:	df000017 	ldw	fp,0(sp)
80107450:	dec00204 	addi	sp,sp,8
80107454:	f800283a 	ret

80107458 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
80107458:	defffb04 	addi	sp,sp,-20
8010745c:	de00012e 	bgeu	sp,et,80107464 <vRmapCh3HandleIrq+0xc>
80107460:	003b68fa 	trap	3
80107464:	dfc00415 	stw	ra,16(sp)
80107468:	df000315 	stw	fp,12(sp)
8010746c:	df000304 	addi	fp,sp,12
80107470:	e13fff15 	stw	r4,-4(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"IRQ RMAP.\n");
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
80107474:	0107b8c0 	call	80107b8c <uliRmapCh2WriteCmdAddress>
80107478:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 2;
8010747c:	008004c4 	movi	r2,19
80107480:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
80107484:	00bffc04 	movi	r2,-16
80107488:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
8010748c:	e0bffd03 	ldbu	r2,-12(fp)
80107490:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = xDefaultsCH.ucChannelToFEE[2];
80107494:	00a005b4 	movhi	r2,32790
80107498:	10ba3204 	addi	r2,r2,-5944
8010749c:	10800083 	ldbu	r2,2(r2)
801074a0:	e0bffe05 	stb	r2,-8(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
	}
#endif

	error_codel = OSQPostFront(xFeeQ[2], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
801074a4:	00a00574 	movhi	r2,32789
801074a8:	109f5404 	addi	r2,r2,32080
801074ac:	10800217 	ldw	r2,8(r2)
801074b0:	e0fffe17 	ldw	r3,-8(fp)
801074b4:	180b883a 	mov	r5,r3
801074b8:	1009883a 	mov	r4,r2
801074bc:	013957c0 	call	8013957c <OSQPostFront>
801074c0:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
801074c4:	e0bffd43 	ldbu	r2,-11(fp)
801074c8:	10000226 	beq	r2,zero,801074d4 <vRmapCh3HandleIrq+0x7c>
		vFailSendRMAPFromIRQ( 2 );
801074cc:	01000084 	movi	r4,2
801074d0:	011da680 	call	8011da68 <vFailSendRMAPFromIRQ>
	}

	vRmapCh3IrqFlagClrWriteCmd();
801074d4:	01076f00 	call	801076f0 <vRmapCh3IrqFlagClrWriteCmd>
}
801074d8:	0001883a 	nop
801074dc:	e037883a 	mov	sp,fp
801074e0:	dfc00117 	ldw	ra,4(sp)
801074e4:	df000017 	ldw	fp,0(sp)
801074e8:	dec00204 	addi	sp,sp,8
801074ec:	f800283a 	ret

801074f0 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
801074f0:	defffb04 	addi	sp,sp,-20
801074f4:	de00012e 	bgeu	sp,et,801074fc <vRmapCh4HandleIrq+0xc>
801074f8:	003b68fa 	trap	3
801074fc:	dfc00415 	stw	ra,16(sp)
80107500:	df000315 	stw	fp,12(sp)
80107504:	df000304 	addi	fp,sp,12
80107508:	e13fff15 	stw	r4,-4(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"IRQ RMAP.\n");
	}
#endif

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
8010750c:	0107b8c0 	call	80107b8c <uliRmapCh2WriteCmdAddress>
80107510:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 3;
80107514:	00800504 	movi	r2,20
80107518:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
8010751c:	00bffc04 	movi	r2,-16
80107520:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
80107524:	e0bffd03 	ldbu	r2,-12(fp)
80107528:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = xDefaultsCH.ucChannelToFEE[3];
8010752c:	00a005b4 	movhi	r2,32790
80107530:	10ba3204 	addi	r2,r2,-5944
80107534:	108000c3 	ldbu	r2,3(r2)
80107538:	e0bffe05 	stb	r2,-8(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
	}
#endif

	error_codel = OSQPostFront(xFeeQ[3], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
8010753c:	00a00574 	movhi	r2,32789
80107540:	109f5404 	addi	r2,r2,32080
80107544:	10800317 	ldw	r2,12(r2)
80107548:	e0fffe17 	ldw	r3,-8(fp)
8010754c:	180b883a 	mov	r5,r3
80107550:	1009883a 	mov	r4,r2
80107554:	013957c0 	call	8013957c <OSQPostFront>
80107558:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8010755c:	e0bffd43 	ldbu	r2,-11(fp)
80107560:	10000226 	beq	r2,zero,8010756c <vRmapCh4HandleIrq+0x7c>
		vFailSendRMAPFromIRQ( 3 );
80107564:	010000c4 	movi	r4,3
80107568:	011da680 	call	8011da68 <vFailSendRMAPFromIRQ>
	}

	vRmapCh4IrqFlagClrWriteCmd();
8010756c:	01077340 	call	80107734 <vRmapCh4IrqFlagClrWriteCmd>
}
80107570:	0001883a 	nop
80107574:	e037883a 	mov	sp,fp
80107578:	dfc00117 	ldw	ra,4(sp)
8010757c:	df000017 	ldw	fp,0(sp)
80107580:	dec00204 	addi	sp,sp,8
80107584:	f800283a 	ret

80107588 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
80107588:	defffd04 	addi	sp,sp,-12
8010758c:	de00012e 	bgeu	sp,et,80107594 <vRmapCh5HandleIrq+0xc>
80107590:	003b68fa 	trap	3
80107594:	dfc00215 	stw	ra,8(sp)
80107598:	df000115 	stw	fp,4(sp)
8010759c:	df000104 	addi	fp,sp,4
801075a0:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
801075a4:	01077740 	call	80107774 <vRmapCh5IrqFlagClrWriteCmd>
}
801075a8:	0001883a 	nop
801075ac:	e037883a 	mov	sp,fp
801075b0:	dfc00117 	ldw	ra,4(sp)
801075b4:	df000017 	ldw	fp,0(sp)
801075b8:	dec00204 	addi	sp,sp,8
801075bc:	f800283a 	ret

801075c0 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
801075c0:	defffd04 	addi	sp,sp,-12
801075c4:	de00012e 	bgeu	sp,et,801075cc <vRmapCh6HandleIrq+0xc>
801075c8:	003b68fa 	trap	3
801075cc:	dfc00215 	stw	ra,8(sp)
801075d0:	df000115 	stw	fp,4(sp)
801075d4:	df000104 	addi	fp,sp,4
801075d8:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
801075dc:	01077b80 	call	801077b8 <vRmapCh6IrqFlagClrWriteCmd>
}
801075e0:	0001883a 	nop
801075e4:	e037883a 	mov	sp,fp
801075e8:	dfc00117 	ldw	ra,4(sp)
801075ec:	df000017 	ldw	fp,0(sp)
801075f0:	dec00204 	addi	sp,sp,8
801075f4:	f800283a 	ret

801075f8 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
801075f8:	defffd04 	addi	sp,sp,-12
801075fc:	de00012e 	bgeu	sp,et,80107604 <vRmapCh7HandleIrq+0xc>
80107600:	003b68fa 	trap	3
80107604:	dfc00215 	stw	ra,8(sp)
80107608:	df000115 	stw	fp,4(sp)
8010760c:	df000104 	addi	fp,sp,4
80107610:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
80107614:	01077fc0 	call	801077fc <vRmapCh7IrqFlagClrWriteCmd>
}
80107618:	0001883a 	nop
8010761c:	e037883a 	mov	sp,fp
80107620:	dfc00117 	ldw	ra,4(sp)
80107624:	df000017 	ldw	fp,0(sp)
80107628:	dec00204 	addi	sp,sp,8
8010762c:	f800283a 	ret

80107630 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
80107630:	defffd04 	addi	sp,sp,-12
80107634:	de00012e 	bgeu	sp,et,8010763c <vRmapCh8HandleIrq+0xc>
80107638:	003b68fa 	trap	3
8010763c:	dfc00215 	stw	ra,8(sp)
80107640:	df000115 	stw	fp,4(sp)
80107644:	df000104 	addi	fp,sp,4
80107648:	e13fff15 	stw	r4,-4(fp)
	//volatile int* pviHoldContext = (volatile int*) pvContext;
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
8010764c:	01078400 	call	80107840 <vRmapCh8IrqFlagClrWriteCmd>
}
80107650:	0001883a 	nop
80107654:	e037883a 	mov	sp,fp
80107658:	dfc00117 	ldw	ra,4(sp)
8010765c:	df000017 	ldw	fp,0(sp)
80107660:	dec00204 	addi	sp,sp,8
80107664:	f800283a 	ret

80107668 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
80107668:	defffe04 	addi	sp,sp,-8
8010766c:	de00012e 	bgeu	sp,et,80107674 <vRmapCh1IrqFlagClrWriteCmd+0xc>
80107670:	003b68fa 	trap	3
80107674:	dfc00115 	stw	ra,4(sp)
80107678:	df000015 	stw	fp,0(sp)
8010767c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
80107680:	01800044 	movi	r6,1
80107684:	014004c4 	movi	r5,19
80107688:	01101034 	movhi	r4,16448
8010768c:	21030004 	addi	r4,r4,3072
80107690:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
80107694:	0001883a 	nop
80107698:	e037883a 	mov	sp,fp
8010769c:	dfc00117 	ldw	ra,4(sp)
801076a0:	df000017 	ldw	fp,0(sp)
801076a4:	dec00204 	addi	sp,sp,8
801076a8:	f800283a 	ret

801076ac <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
801076ac:	defffe04 	addi	sp,sp,-8
801076b0:	de00012e 	bgeu	sp,et,801076b8 <vRmapCh2IrqFlagClrWriteCmd+0xc>
801076b4:	003b68fa 	trap	3
801076b8:	dfc00115 	stw	ra,4(sp)
801076bc:	df000015 	stw	fp,0(sp)
801076c0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
801076c4:	01800044 	movi	r6,1
801076c8:	014004c4 	movi	r5,19
801076cc:	01101034 	movhi	r4,16448
801076d0:	21020004 	addi	r4,r4,2048
801076d4:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
801076d8:	0001883a 	nop
801076dc:	e037883a 	mov	sp,fp
801076e0:	dfc00117 	ldw	ra,4(sp)
801076e4:	df000017 	ldw	fp,0(sp)
801076e8:	dec00204 	addi	sp,sp,8
801076ec:	f800283a 	ret

801076f0 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
801076f0:	defffe04 	addi	sp,sp,-8
801076f4:	de00012e 	bgeu	sp,et,801076fc <vRmapCh3IrqFlagClrWriteCmd+0xc>
801076f8:	003b68fa 	trap	3
801076fc:	dfc00115 	stw	ra,4(sp)
80107700:	df000015 	stw	fp,0(sp)
80107704:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
80107708:	01800044 	movi	r6,1
8010770c:	014004c4 	movi	r5,19
80107710:	01101034 	movhi	r4,16448
80107714:	21010004 	addi	r4,r4,1024
80107718:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8010771c:	0001883a 	nop
80107720:	e037883a 	mov	sp,fp
80107724:	dfc00117 	ldw	ra,4(sp)
80107728:	df000017 	ldw	fp,0(sp)
8010772c:	dec00204 	addi	sp,sp,8
80107730:	f800283a 	ret

80107734 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
80107734:	defffe04 	addi	sp,sp,-8
80107738:	de00012e 	bgeu	sp,et,80107740 <vRmapCh4IrqFlagClrWriteCmd+0xc>
8010773c:	003b68fa 	trap	3
80107740:	dfc00115 	stw	ra,4(sp)
80107744:	df000015 	stw	fp,0(sp)
80107748:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8010774c:	01800044 	movi	r6,1
80107750:	014004c4 	movi	r5,19
80107754:	01101034 	movhi	r4,16448
80107758:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8010775c:	0001883a 	nop
80107760:	e037883a 	mov	sp,fp
80107764:	dfc00117 	ldw	ra,4(sp)
80107768:	df000017 	ldw	fp,0(sp)
8010776c:	dec00204 	addi	sp,sp,8
80107770:	f800283a 	ret

80107774 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
80107774:	defffe04 	addi	sp,sp,-8
80107778:	de00012e 	bgeu	sp,et,80107780 <vRmapCh5IrqFlagClrWriteCmd+0xc>
8010777c:	003b68fa 	trap	3
80107780:	dfc00115 	stw	ra,4(sp)
80107784:	df000015 	stw	fp,0(sp)
80107788:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8010778c:	01800044 	movi	r6,1
80107790:	014004c4 	movi	r5,19
80107794:	01101034 	movhi	r4,16448
80107798:	21030004 	addi	r4,r4,3072
8010779c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
801077a0:	0001883a 	nop
801077a4:	e037883a 	mov	sp,fp
801077a8:	dfc00117 	ldw	ra,4(sp)
801077ac:	df000017 	ldw	fp,0(sp)
801077b0:	dec00204 	addi	sp,sp,8
801077b4:	f800283a 	ret

801077b8 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
801077b8:	defffe04 	addi	sp,sp,-8
801077bc:	de00012e 	bgeu	sp,et,801077c4 <vRmapCh6IrqFlagClrWriteCmd+0xc>
801077c0:	003b68fa 	trap	3
801077c4:	dfc00115 	stw	ra,4(sp)
801077c8:	df000015 	stw	fp,0(sp)
801077cc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
801077d0:	01800044 	movi	r6,1
801077d4:	014004c4 	movi	r5,19
801077d8:	01101034 	movhi	r4,16448
801077dc:	21020004 	addi	r4,r4,2048
801077e0:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
801077e4:	0001883a 	nop
801077e8:	e037883a 	mov	sp,fp
801077ec:	dfc00117 	ldw	ra,4(sp)
801077f0:	df000017 	ldw	fp,0(sp)
801077f4:	dec00204 	addi	sp,sp,8
801077f8:	f800283a 	ret

801077fc <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
801077fc:	defffe04 	addi	sp,sp,-8
80107800:	de00012e 	bgeu	sp,et,80107808 <vRmapCh7IrqFlagClrWriteCmd+0xc>
80107804:	003b68fa 	trap	3
80107808:	dfc00115 	stw	ra,4(sp)
8010780c:	df000015 	stw	fp,0(sp)
80107810:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
80107814:	01800044 	movi	r6,1
80107818:	014004c4 	movi	r5,19
8010781c:	01101034 	movhi	r4,16448
80107820:	21010004 	addi	r4,r4,1024
80107824:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
80107828:	0001883a 	nop
8010782c:	e037883a 	mov	sp,fp
80107830:	dfc00117 	ldw	ra,4(sp)
80107834:	df000017 	ldw	fp,0(sp)
80107838:	dec00204 	addi	sp,sp,8
8010783c:	f800283a 	ret

80107840 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
80107840:	defffe04 	addi	sp,sp,-8
80107844:	de00012e 	bgeu	sp,et,8010784c <vRmapCh8IrqFlagClrWriteCmd+0xc>
80107848:	003b68fa 	trap	3
8010784c:	dfc00115 	stw	ra,4(sp)
80107850:	df000015 	stw	fp,0(sp)
80107854:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
80107858:	01800044 	movi	r6,1
8010785c:	014004c4 	movi	r5,19
80107860:	01101034 	movhi	r4,16448
80107864:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
80107868:	0001883a 	nop
8010786c:	e037883a 	mov	sp,fp
80107870:	dfc00117 	ldw	ra,4(sp)
80107874:	df000017 	ldw	fp,0(sp)
80107878:	dec00204 	addi	sp,sp,8
8010787c:	f800283a 	ret

80107880 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
80107880:	defffd04 	addi	sp,sp,-12
80107884:	de00012e 	bgeu	sp,et,8010788c <bRmapCh1IrqFlagWriteCmd+0xc>
80107888:	003b68fa 	trap	3
8010788c:	dfc00215 	stw	ra,8(sp)
80107890:	df000115 	stw	fp,4(sp)
80107894:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
80107898:	01400484 	movi	r5,18
8010789c:	01101034 	movhi	r4,16448
801078a0:	21030004 	addi	r4,r4,3072
801078a4:	010a7080 	call	8010a708 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
801078a8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
801078ac:	10000326 	beq	r2,zero,801078bc <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
801078b0:	00800044 	movi	r2,1
801078b4:	e0bfff15 	stw	r2,-4(fp)
801078b8:	00000106 	br	801078c0 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
801078bc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
801078c0:	e0bfff17 	ldw	r2,-4(fp)
}
801078c4:	e037883a 	mov	sp,fp
801078c8:	dfc00117 	ldw	ra,4(sp)
801078cc:	df000017 	ldw	fp,0(sp)
801078d0:	dec00204 	addi	sp,sp,8
801078d4:	f800283a 	ret

801078d8 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
801078d8:	defffd04 	addi	sp,sp,-12
801078dc:	de00012e 	bgeu	sp,et,801078e4 <bRmapCh2IrqFlagWriteCmd+0xc>
801078e0:	003b68fa 	trap	3
801078e4:	dfc00215 	stw	ra,8(sp)
801078e8:	df000115 	stw	fp,4(sp)
801078ec:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
801078f0:	01400484 	movi	r5,18
801078f4:	01101034 	movhi	r4,16448
801078f8:	21020004 	addi	r4,r4,2048
801078fc:	010a7080 	call	8010a708 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
80107900:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
80107904:	10000326 	beq	r2,zero,80107914 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
80107908:	00800044 	movi	r2,1
8010790c:	e0bfff15 	stw	r2,-4(fp)
80107910:	00000106 	br	80107918 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
80107914:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
80107918:	e0bfff17 	ldw	r2,-4(fp)
}
8010791c:	e037883a 	mov	sp,fp
80107920:	dfc00117 	ldw	ra,4(sp)
80107924:	df000017 	ldw	fp,0(sp)
80107928:	dec00204 	addi	sp,sp,8
8010792c:	f800283a 	ret

80107930 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
80107930:	defffd04 	addi	sp,sp,-12
80107934:	de00012e 	bgeu	sp,et,8010793c <bRmapCh3IrqFlagWriteCmd+0xc>
80107938:	003b68fa 	trap	3
8010793c:	dfc00215 	stw	ra,8(sp)
80107940:	df000115 	stw	fp,4(sp)
80107944:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
80107948:	01400484 	movi	r5,18
8010794c:	01101034 	movhi	r4,16448
80107950:	21010004 	addi	r4,r4,1024
80107954:	010a7080 	call	8010a708 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
80107958:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8010795c:	10000326 	beq	r2,zero,8010796c <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
80107960:	00800044 	movi	r2,1
80107964:	e0bfff15 	stw	r2,-4(fp)
80107968:	00000106 	br	80107970 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8010796c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
80107970:	e0bfff17 	ldw	r2,-4(fp)
}
80107974:	e037883a 	mov	sp,fp
80107978:	dfc00117 	ldw	ra,4(sp)
8010797c:	df000017 	ldw	fp,0(sp)
80107980:	dec00204 	addi	sp,sp,8
80107984:	f800283a 	ret

80107988 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
80107988:	defffd04 	addi	sp,sp,-12
8010798c:	de00012e 	bgeu	sp,et,80107994 <bRmapCh4IrqFlagWriteCmd+0xc>
80107990:	003b68fa 	trap	3
80107994:	dfc00215 	stw	ra,8(sp)
80107998:	df000115 	stw	fp,4(sp)
8010799c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
801079a0:	01400484 	movi	r5,18
801079a4:	01101034 	movhi	r4,16448
801079a8:	010a7080 	call	8010a708 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
801079ac:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
801079b0:	10000326 	beq	r2,zero,801079c0 <bRmapCh4IrqFlagWriteCmd+0x38>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
801079b4:	00800044 	movi	r2,1
801079b8:	e0bfff15 	stw	r2,-4(fp)
801079bc:	00000106 	br	801079c4 <bRmapCh4IrqFlagWriteCmd+0x3c>
	} else {
		bFlag = FALSE;
801079c0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
801079c4:	e0bfff17 	ldw	r2,-4(fp)
}
801079c8:	e037883a 	mov	sp,fp
801079cc:	dfc00117 	ldw	ra,4(sp)
801079d0:	df000017 	ldw	fp,0(sp)
801079d4:	dec00204 	addi	sp,sp,8
801079d8:	f800283a 	ret

801079dc <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
801079dc:	defffd04 	addi	sp,sp,-12
801079e0:	de00012e 	bgeu	sp,et,801079e8 <bRmapCh5IrqFlagWriteCmd+0xc>
801079e4:	003b68fa 	trap	3
801079e8:	dfc00215 	stw	ra,8(sp)
801079ec:	df000115 	stw	fp,4(sp)
801079f0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
801079f4:	01400484 	movi	r5,18
801079f8:	01101034 	movhi	r4,16448
801079fc:	21030004 	addi	r4,r4,3072
80107a00:	010a7080 	call	8010a708 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
80107a04:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
80107a08:	10000326 	beq	r2,zero,80107a18 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
80107a0c:	00800044 	movi	r2,1
80107a10:	e0bfff15 	stw	r2,-4(fp)
80107a14:	00000106 	br	80107a1c <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
80107a18:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
80107a1c:	e0bfff17 	ldw	r2,-4(fp)
}
80107a20:	e037883a 	mov	sp,fp
80107a24:	dfc00117 	ldw	ra,4(sp)
80107a28:	df000017 	ldw	fp,0(sp)
80107a2c:	dec00204 	addi	sp,sp,8
80107a30:	f800283a 	ret

80107a34 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
80107a34:	defffd04 	addi	sp,sp,-12
80107a38:	de00012e 	bgeu	sp,et,80107a40 <bRmapCh6IrqFlagWriteCmd+0xc>
80107a3c:	003b68fa 	trap	3
80107a40:	dfc00215 	stw	ra,8(sp)
80107a44:	df000115 	stw	fp,4(sp)
80107a48:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
80107a4c:	01400484 	movi	r5,18
80107a50:	01101034 	movhi	r4,16448
80107a54:	21020004 	addi	r4,r4,2048
80107a58:	010a7080 	call	8010a708 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
80107a5c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
80107a60:	10000326 	beq	r2,zero,80107a70 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
80107a64:	00800044 	movi	r2,1
80107a68:	e0bfff15 	stw	r2,-4(fp)
80107a6c:	00000106 	br	80107a74 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
80107a70:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
80107a74:	e0bfff17 	ldw	r2,-4(fp)
}
80107a78:	e037883a 	mov	sp,fp
80107a7c:	dfc00117 	ldw	ra,4(sp)
80107a80:	df000017 	ldw	fp,0(sp)
80107a84:	dec00204 	addi	sp,sp,8
80107a88:	f800283a 	ret

80107a8c <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
80107a8c:	defffd04 	addi	sp,sp,-12
80107a90:	de00012e 	bgeu	sp,et,80107a98 <bRmapCh7IrqFlagWriteCmd+0xc>
80107a94:	003b68fa 	trap	3
80107a98:	dfc00215 	stw	ra,8(sp)
80107a9c:	df000115 	stw	fp,4(sp)
80107aa0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
80107aa4:	01400484 	movi	r5,18
80107aa8:	01101034 	movhi	r4,16448
80107aac:	21010004 	addi	r4,r4,1024
80107ab0:	010a7080 	call	8010a708 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
80107ab4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
80107ab8:	10000326 	beq	r2,zero,80107ac8 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
80107abc:	00800044 	movi	r2,1
80107ac0:	e0bfff15 	stw	r2,-4(fp)
80107ac4:	00000106 	br	80107acc <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
80107ac8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
80107acc:	e0bfff17 	ldw	r2,-4(fp)
}
80107ad0:	e037883a 	mov	sp,fp
80107ad4:	dfc00117 	ldw	ra,4(sp)
80107ad8:	df000017 	ldw	fp,0(sp)
80107adc:	dec00204 	addi	sp,sp,8
80107ae0:	f800283a 	ret

80107ae4 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
80107ae4:	defffd04 	addi	sp,sp,-12
80107ae8:	de00012e 	bgeu	sp,et,80107af0 <bRmapCh8IrqFlagWriteCmd+0xc>
80107aec:	003b68fa 	trap	3
80107af0:	dfc00215 	stw	ra,8(sp)
80107af4:	df000115 	stw	fp,4(sp)
80107af8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
80107afc:	01400484 	movi	r5,18
80107b00:	01101034 	movhi	r4,16448
80107b04:	010a7080 	call	8010a708 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
80107b08:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
80107b0c:	10000326 	beq	r2,zero,80107b1c <bRmapCh8IrqFlagWriteCmd+0x38>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
80107b10:	00800044 	movi	r2,1
80107b14:	e0bfff15 	stw	r2,-4(fp)
80107b18:	00000106 	br	80107b20 <bRmapCh8IrqFlagWriteCmd+0x3c>
	} else {
		bFlag = FALSE;
80107b1c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
80107b20:	e0bfff17 	ldw	r2,-4(fp)
}
80107b24:	e037883a 	mov	sp,fp
80107b28:	dfc00117 	ldw	ra,4(sp)
80107b2c:	df000017 	ldw	fp,0(sp)
80107b30:	dec00204 	addi	sp,sp,8
80107b34:	f800283a 	ret

80107b38 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
80107b38:	defffd04 	addi	sp,sp,-12
80107b3c:	de00012e 	bgeu	sp,et,80107b44 <uliRmapCh1WriteCmdAddress+0xc>
80107b40:	003b68fa 	trap	3
80107b44:	dfc00215 	stw	ra,8(sp)
80107b48:	df000115 	stw	fp,4(sp)
80107b4c:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
80107b50:	01400184 	movi	r5,6
80107b54:	01101034 	movhi	r4,16448
80107b58:	21030004 	addi	r4,r4,3072
80107b5c:	010a7080 	call	8010a708 <uliRmapReadReg>
80107b60:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
80107b64:	e0bfff17 	ldw	r2,-4(fp)
80107b68:	1009883a 	mov	r4,r2
80107b6c:	010a7580 	call	8010a758 <uliConvRmapCfgAddr>
80107b70:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
80107b74:	e0bfff17 	ldw	r2,-4(fp)
}
80107b78:	e037883a 	mov	sp,fp
80107b7c:	dfc00117 	ldw	ra,4(sp)
80107b80:	df000017 	ldw	fp,0(sp)
80107b84:	dec00204 	addi	sp,sp,8
80107b88:	f800283a 	ret

80107b8c <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
80107b8c:	defffd04 	addi	sp,sp,-12
80107b90:	de00012e 	bgeu	sp,et,80107b98 <uliRmapCh2WriteCmdAddress+0xc>
80107b94:	003b68fa 	trap	3
80107b98:	dfc00215 	stw	ra,8(sp)
80107b9c:	df000115 	stw	fp,4(sp)
80107ba0:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
80107ba4:	01400184 	movi	r5,6
80107ba8:	01101034 	movhi	r4,16448
80107bac:	21020004 	addi	r4,r4,2048
80107bb0:	010a7080 	call	8010a708 <uliRmapReadReg>
80107bb4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
80107bb8:	e0bfff17 	ldw	r2,-4(fp)
80107bbc:	1009883a 	mov	r4,r2
80107bc0:	010a7580 	call	8010a758 <uliConvRmapCfgAddr>
80107bc4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
80107bc8:	e0bfff17 	ldw	r2,-4(fp)
}
80107bcc:	e037883a 	mov	sp,fp
80107bd0:	dfc00117 	ldw	ra,4(sp)
80107bd4:	df000017 	ldw	fp,0(sp)
80107bd8:	dec00204 	addi	sp,sp,8
80107bdc:	f800283a 	ret

80107be0 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
80107be0:	defffd04 	addi	sp,sp,-12
80107be4:	de00012e 	bgeu	sp,et,80107bec <uliRmapCh3WriteCmdAddress+0xc>
80107be8:	003b68fa 	trap	3
80107bec:	dfc00215 	stw	ra,8(sp)
80107bf0:	df000115 	stw	fp,4(sp)
80107bf4:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
80107bf8:	01400184 	movi	r5,6
80107bfc:	01101034 	movhi	r4,16448
80107c00:	21010004 	addi	r4,r4,1024
80107c04:	010a7080 	call	8010a708 <uliRmapReadReg>
80107c08:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
80107c0c:	e0bfff17 	ldw	r2,-4(fp)
80107c10:	1009883a 	mov	r4,r2
80107c14:	010a7580 	call	8010a758 <uliConvRmapCfgAddr>
80107c18:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
80107c1c:	e0bfff17 	ldw	r2,-4(fp)
}
80107c20:	e037883a 	mov	sp,fp
80107c24:	dfc00117 	ldw	ra,4(sp)
80107c28:	df000017 	ldw	fp,0(sp)
80107c2c:	dec00204 	addi	sp,sp,8
80107c30:	f800283a 	ret

80107c34 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
80107c34:	defffd04 	addi	sp,sp,-12
80107c38:	de00012e 	bgeu	sp,et,80107c40 <uliRmapCh4WriteCmdAddress+0xc>
80107c3c:	003b68fa 	trap	3
80107c40:	dfc00215 	stw	ra,8(sp)
80107c44:	df000115 	stw	fp,4(sp)
80107c48:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
80107c4c:	01400184 	movi	r5,6
80107c50:	01101034 	movhi	r4,16448
80107c54:	010a7080 	call	8010a708 <uliRmapReadReg>
80107c58:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
80107c5c:	e0bfff17 	ldw	r2,-4(fp)
80107c60:	1009883a 	mov	r4,r2
80107c64:	010a7580 	call	8010a758 <uliConvRmapCfgAddr>
80107c68:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
80107c6c:	e0bfff17 	ldw	r2,-4(fp)
}
80107c70:	e037883a 	mov	sp,fp
80107c74:	dfc00117 	ldw	ra,4(sp)
80107c78:	df000017 	ldw	fp,0(sp)
80107c7c:	dec00204 	addi	sp,sp,8
80107c80:	f800283a 	ret

80107c84 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
80107c84:	defffd04 	addi	sp,sp,-12
80107c88:	de00012e 	bgeu	sp,et,80107c90 <uliRmapCh5WriteCmdAddress+0xc>
80107c8c:	003b68fa 	trap	3
80107c90:	dfc00215 	stw	ra,8(sp)
80107c94:	df000115 	stw	fp,4(sp)
80107c98:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
80107c9c:	01400184 	movi	r5,6
80107ca0:	01101034 	movhi	r4,16448
80107ca4:	21030004 	addi	r4,r4,3072
80107ca8:	010a7080 	call	8010a708 <uliRmapReadReg>
80107cac:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
80107cb0:	e0bfff17 	ldw	r2,-4(fp)
80107cb4:	1009883a 	mov	r4,r2
80107cb8:	010a7580 	call	8010a758 <uliConvRmapCfgAddr>
80107cbc:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
80107cc0:	e0bfff17 	ldw	r2,-4(fp)
}
80107cc4:	e037883a 	mov	sp,fp
80107cc8:	dfc00117 	ldw	ra,4(sp)
80107ccc:	df000017 	ldw	fp,0(sp)
80107cd0:	dec00204 	addi	sp,sp,8
80107cd4:	f800283a 	ret

80107cd8 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
80107cd8:	defffd04 	addi	sp,sp,-12
80107cdc:	de00012e 	bgeu	sp,et,80107ce4 <uliRmapCh6WriteCmdAddress+0xc>
80107ce0:	003b68fa 	trap	3
80107ce4:	dfc00215 	stw	ra,8(sp)
80107ce8:	df000115 	stw	fp,4(sp)
80107cec:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
80107cf0:	01400184 	movi	r5,6
80107cf4:	01101034 	movhi	r4,16448
80107cf8:	21020004 	addi	r4,r4,2048
80107cfc:	010a7080 	call	8010a708 <uliRmapReadReg>
80107d00:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
80107d04:	e0bfff17 	ldw	r2,-4(fp)
80107d08:	1009883a 	mov	r4,r2
80107d0c:	010a7580 	call	8010a758 <uliConvRmapCfgAddr>
80107d10:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
80107d14:	e0bfff17 	ldw	r2,-4(fp)
}
80107d18:	e037883a 	mov	sp,fp
80107d1c:	dfc00117 	ldw	ra,4(sp)
80107d20:	df000017 	ldw	fp,0(sp)
80107d24:	dec00204 	addi	sp,sp,8
80107d28:	f800283a 	ret

80107d2c <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
80107d2c:	defffd04 	addi	sp,sp,-12
80107d30:	de00012e 	bgeu	sp,et,80107d38 <uliRmapCh7WriteCmdAddress+0xc>
80107d34:	003b68fa 	trap	3
80107d38:	dfc00215 	stw	ra,8(sp)
80107d3c:	df000115 	stw	fp,4(sp)
80107d40:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
80107d44:	01400184 	movi	r5,6
80107d48:	01101034 	movhi	r4,16448
80107d4c:	21010004 	addi	r4,r4,1024
80107d50:	010a7080 	call	8010a708 <uliRmapReadReg>
80107d54:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
80107d58:	e0bfff17 	ldw	r2,-4(fp)
80107d5c:	1009883a 	mov	r4,r2
80107d60:	010a7580 	call	8010a758 <uliConvRmapCfgAddr>
80107d64:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
80107d68:	e0bfff17 	ldw	r2,-4(fp)
}
80107d6c:	e037883a 	mov	sp,fp
80107d70:	dfc00117 	ldw	ra,4(sp)
80107d74:	df000017 	ldw	fp,0(sp)
80107d78:	dec00204 	addi	sp,sp,8
80107d7c:	f800283a 	ret

80107d80 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
80107d80:	defffd04 	addi	sp,sp,-12
80107d84:	de00012e 	bgeu	sp,et,80107d8c <uliRmapCh8WriteCmdAddress+0xc>
80107d88:	003b68fa 	trap	3
80107d8c:	dfc00215 	stw	ra,8(sp)
80107d90:	df000115 	stw	fp,4(sp)
80107d94:	df000104 	addi	fp,sp,4
	volatile alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
80107d98:	01400184 	movi	r5,6
80107d9c:	01101034 	movhi	r4,16448
80107da0:	010a7080 	call	8010a708 <uliRmapReadReg>
80107da4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
80107da8:	e0bfff17 	ldw	r2,-4(fp)
80107dac:	1009883a 	mov	r4,r2
80107db0:	010a7580 	call	8010a758 <uliConvRmapCfgAddr>
80107db4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
80107db8:	e0bfff17 	ldw	r2,-4(fp)
}
80107dbc:	e037883a 	mov	sp,fp
80107dc0:	dfc00117 	ldw	ra,4(sp)
80107dc4:	df000017 	ldw	fp,0(sp)
80107dc8:	dec00204 	addi	sp,sp,8
80107dcc:	f800283a 	ret

80107dd0 <vRmapInitIrq>:

bool vRmapInitIrq(alt_u8 ucCommCh) {
80107dd0:	defffb04 	addi	sp,sp,-20
80107dd4:	de00012e 	bgeu	sp,et,80107ddc <vRmapInitIrq+0xc>
80107dd8:	003b68fa 	trap	3
80107ddc:	dfc00415 	stw	ra,16(sp)
80107de0:	df000315 	stw	fp,12(sp)
80107de4:	df000304 	addi	fp,sp,12
80107de8:	2005883a 	mov	r2,r4
80107dec:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
80107df0:	e03ffd15 	stw	zero,-12(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
80107df4:	e0bfff03 	ldbu	r2,-4(fp)
80107df8:	10c00228 	cmpgeui	r3,r2,8
80107dfc:	18005e1e 	bne	r3,zero,80107f78 <vRmapInitIrq+0x1a8>
80107e00:	100690ba 	slli	r3,r2,2
80107e04:	00a00434 	movhi	r2,32784
80107e08:	109f8604 	addi	r2,r2,32280
80107e0c:	1885883a 	add	r2,r3,r2
80107e10:	10800017 	ldw	r2,0(r2)
80107e14:	1000683a 	jmp	r2
80107e18:	80107e38 	rdprs	zero,r16,16888
80107e1c:	80107e60 	cmpeqi	zero,r16,16889
80107e20:	80107e88 	cmpgei	zero,r16,16890
80107e24:	80107eb0 	cmpltui	zero,r16,16890
80107e28:	80107ed8 	cmpnei	zero,r16,16891
80107e2c:	80107f00 	call	880107f0 <__reset+0x1ff07f0>
80107e30:	80107f28 	cmpgeui	zero,r16,16892
80107e34:	80107f50 	cmplti	zero,r16,16893
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
80107e38:	d0a04804 	addi	r2,gp,-32480
80107e3c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
80107e40:	01a00434 	movhi	r6,32784
80107e44:	319cca04 	addi	r6,r6,29480
80107e48:	e17ffe17 	ldw	r5,-8(fp)
80107e4c:	01000344 	movi	r4,13
80107e50:	0131c940 	call	80131c94 <alt_irq_register>
		bStatus = TRUE;
80107e54:	00800044 	movi	r2,1
80107e58:	e0bffd15 	stw	r2,-12(fp)
		break;
80107e5c:	00004806 	br	80107f80 <vRmapInitIrq+0x1b0>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
80107e60:	d0a04904 	addi	r2,gp,-32476
80107e64:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
80107e68:	01a00434 	movhi	r6,32784
80107e6c:	319cf004 	addi	r6,r6,29632
80107e70:	e17ffe17 	ldw	r5,-8(fp)
80107e74:	01000304 	movi	r4,12
80107e78:	0131c940 	call	80131c94 <alt_irq_register>
		bStatus = TRUE;
80107e7c:	00800044 	movi	r2,1
80107e80:	e0bffd15 	stw	r2,-12(fp)
		break;
80107e84:	00003e06 	br	80107f80 <vRmapInitIrq+0x1b0>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
80107e88:	d0a04a04 	addi	r2,gp,-32472
80107e8c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
80107e90:	01a00434 	movhi	r6,32784
80107e94:	319d1604 	addi	r6,r6,29784
80107e98:	e17ffe17 	ldw	r5,-8(fp)
80107e9c:	01000384 	movi	r4,14
80107ea0:	0131c940 	call	80131c94 <alt_irq_register>
		bStatus = TRUE;
80107ea4:	00800044 	movi	r2,1
80107ea8:	e0bffd15 	stw	r2,-12(fp)
		break;
80107eac:	00003406 	br	80107f80 <vRmapInitIrq+0x1b0>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
80107eb0:	d0a04b04 	addi	r2,gp,-32468
80107eb4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
80107eb8:	01a00434 	movhi	r6,32784
80107ebc:	319d3c04 	addi	r6,r6,29936
80107ec0:	e17ffe17 	ldw	r5,-8(fp)
80107ec4:	010003c4 	movi	r4,15
80107ec8:	0131c940 	call	80131c94 <alt_irq_register>
		bStatus = TRUE;
80107ecc:	00800044 	movi	r2,1
80107ed0:	e0bffd15 	stw	r2,-12(fp)
		break;
80107ed4:	00002a06 	br	80107f80 <vRmapInitIrq+0x1b0>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
80107ed8:	d0a04c04 	addi	r2,gp,-32464
80107edc:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
80107ee0:	01a00434 	movhi	r6,32784
80107ee4:	319d6204 	addi	r6,r6,30088
80107ee8:	e17ffe17 	ldw	r5,-8(fp)
80107eec:	013fffc4 	movi	r4,-1
80107ef0:	0131c940 	call	80131c94 <alt_irq_register>
		bStatus = TRUE;
80107ef4:	00800044 	movi	r2,1
80107ef8:	e0bffd15 	stw	r2,-12(fp)
		break;
80107efc:	00002006 	br	80107f80 <vRmapInitIrq+0x1b0>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
80107f00:	d0a04d04 	addi	r2,gp,-32460
80107f04:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
80107f08:	01a00434 	movhi	r6,32784
80107f0c:	319d7004 	addi	r6,r6,30144
80107f10:	e17ffe17 	ldw	r5,-8(fp)
80107f14:	013fffc4 	movi	r4,-1
80107f18:	0131c940 	call	80131c94 <alt_irq_register>
		bStatus = TRUE;
80107f1c:	00800044 	movi	r2,1
80107f20:	e0bffd15 	stw	r2,-12(fp)
		break;
80107f24:	00001606 	br	80107f80 <vRmapInitIrq+0x1b0>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
80107f28:	d0a04e04 	addi	r2,gp,-32456
80107f2c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
80107f30:	01a00434 	movhi	r6,32784
80107f34:	319d7e04 	addi	r6,r6,30200
80107f38:	e17ffe17 	ldw	r5,-8(fp)
80107f3c:	013fffc4 	movi	r4,-1
80107f40:	0131c940 	call	80131c94 <alt_irq_register>
		bStatus = TRUE;
80107f44:	00800044 	movi	r2,1
80107f48:	e0bffd15 	stw	r2,-12(fp)
		break;
80107f4c:	00000c06 	br	80107f80 <vRmapInitIrq+0x1b0>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
80107f50:	d0a04f04 	addi	r2,gp,-32452
80107f54:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
80107f58:	01a00434 	movhi	r6,32784
80107f5c:	319d8c04 	addi	r6,r6,30256
80107f60:	e17ffe17 	ldw	r5,-8(fp)
80107f64:	013fffc4 	movi	r4,-1
80107f68:	0131c940 	call	80131c94 <alt_irq_register>
		bStatus = TRUE;
80107f6c:	00800044 	movi	r2,1
80107f70:	e0bffd15 	stw	r2,-12(fp)
		break;
80107f74:	00000206 	br	80107f80 <vRmapInitIrq+0x1b0>
	default:
		bStatus = FALSE;
80107f78:	e03ffd15 	stw	zero,-12(fp)
		break;
80107f7c:	0001883a 	nop
	}

	return bStatus;
80107f80:	e0bffd17 	ldw	r2,-12(fp)
}
80107f84:	e037883a 	mov	sp,fp
80107f88:	dfc00117 	ldw	ra,4(sp)
80107f8c:	df000017 	ldw	fp,0(sp)
80107f90:	dec00204 	addi	sp,sp,8
80107f94:	f800283a 	ret

80107f98 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
80107f98:	defffb04 	addi	sp,sp,-20
80107f9c:	de00012e 	bgeu	sp,et,80107fa4 <bRmapSetIrqControl+0xc>
80107fa0:	003b68fa 	trap	3
80107fa4:	dfc00415 	stw	ra,16(sp)
80107fa8:	df000315 	stw	fp,12(sp)
80107fac:	df000304 	addi	fp,sp,12
80107fb0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80107fb4:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80107fb8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
80107fbc:	e0bfff17 	ldw	r2,-4(fp)
80107fc0:	10001a26 	beq	r2,zero,8010802c <bRmapSetIrqControl+0x94>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80107fc4:	e0bfff17 	ldw	r2,-4(fp)
80107fc8:	10800017 	ldw	r2,0(r2)
80107fcc:	01400444 	movi	r5,17
80107fd0:	1009883a 	mov	r4,r2
80107fd4:	010a7080 	call	8010a708 <uliRmapReadReg>
80107fd8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
80107fdc:	e0bfff17 	ldw	r2,-4(fp)
80107fe0:	10801017 	ldw	r2,64(r2)
80107fe4:	10000426 	beq	r2,zero,80107ff8 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
80107fe8:	e0bffe17 	ldw	r2,-8(fp)
80107fec:	10800054 	ori	r2,r2,1
80107ff0:	e0bffe15 	stw	r2,-8(fp)
80107ff4:	00000406 	br	80108008 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
80107ff8:	e0fffe17 	ldw	r3,-8(fp)
80107ffc:	00bfff84 	movi	r2,-2
80108000:	1884703a 	and	r2,r3,r2
80108004:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
80108008:	e0bfff17 	ldw	r2,-4(fp)
8010800c:	10800017 	ldw	r2,0(r2)
80108010:	e0fffe17 	ldw	r3,-8(fp)
80108014:	180d883a 	mov	r6,r3
80108018:	01400444 	movi	r5,17
8010801c:	1009883a 	mov	r4,r2
80108020:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
80108024:	00800044 	movi	r2,1
80108028:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010802c:	e0bffd17 	ldw	r2,-12(fp)
}
80108030:	e037883a 	mov	sp,fp
80108034:	dfc00117 	ldw	ra,4(sp)
80108038:	df000017 	ldw	fp,0(sp)
8010803c:	dec00204 	addi	sp,sp,8
80108040:	f800283a 	ret

80108044 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
80108044:	defffb04 	addi	sp,sp,-20
80108048:	de00012e 	bgeu	sp,et,80108050 <bRmapGetIrqControl+0xc>
8010804c:	003b68fa 	trap	3
80108050:	dfc00415 	stw	ra,16(sp)
80108054:	df000315 	stw	fp,12(sp)
80108058:	df000304 	addi	fp,sp,12
8010805c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80108060:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80108064:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
80108068:	e0bfff17 	ldw	r2,-4(fp)
8010806c:	10001126 	beq	r2,zero,801080b4 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108070:	e0bfff17 	ldw	r2,-4(fp)
80108074:	10800017 	ldw	r2,0(r2)
80108078:	01400444 	movi	r5,17
8010807c:	1009883a 	mov	r4,r2
80108080:	010a7080 	call	8010a708 <uliRmapReadReg>
80108084:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
80108088:	e0bffe17 	ldw	r2,-8(fp)
8010808c:	1080004c 	andi	r2,r2,1
80108090:	10000426 	beq	r2,zero,801080a4 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
80108094:	e0bfff17 	ldw	r2,-4(fp)
80108098:	00c00044 	movi	r3,1
8010809c:	10c01015 	stw	r3,64(r2)
801080a0:	00000206 	br	801080ac <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
801080a4:	e0bfff17 	ldw	r2,-4(fp)
801080a8:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
801080ac:	00800044 	movi	r2,1
801080b0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
801080b4:	e0bffd17 	ldw	r2,-12(fp)
}
801080b8:	e037883a 	mov	sp,fp
801080bc:	dfc00117 	ldw	ra,4(sp)
801080c0:	df000017 	ldw	fp,0(sp)
801080c4:	dec00204 	addi	sp,sp,8
801080c8:	f800283a 	ret

801080cc <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
801080cc:	defffb04 	addi	sp,sp,-20
801080d0:	de00012e 	bgeu	sp,et,801080d8 <bRmapGetIrqFlags+0xc>
801080d4:	003b68fa 	trap	3
801080d8:	dfc00415 	stw	ra,16(sp)
801080dc:	df000315 	stw	fp,12(sp)
801080e0:	df000304 	addi	fp,sp,12
801080e4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
801080e8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
801080ec:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
801080f0:	e0bfff17 	ldw	r2,-4(fp)
801080f4:	10001126 	beq	r2,zero,8010813c <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801080f8:	e0bfff17 	ldw	r2,-4(fp)
801080fc:	10800017 	ldw	r2,0(r2)
80108100:	01400484 	movi	r5,18
80108104:	1009883a 	mov	r4,r2
80108108:	010a7080 	call	8010a708 <uliRmapReadReg>
8010810c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
80108110:	e0bffe17 	ldw	r2,-8(fp)
80108114:	1080004c 	andi	r2,r2,1
80108118:	10000426 	beq	r2,zero,8010812c <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
8010811c:	e0bfff17 	ldw	r2,-4(fp)
80108120:	00c00044 	movi	r3,1
80108124:	10c01115 	stw	r3,68(r2)
80108128:	00000206 	br	80108134 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
8010812c:	e0bfff17 	ldw	r2,-4(fp)
80108130:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
80108134:	00800044 	movi	r2,1
80108138:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010813c:	e0bffd17 	ldw	r2,-12(fp)
}
80108140:	e037883a 	mov	sp,fp
80108144:	dfc00117 	ldw	ra,4(sp)
80108148:	df000017 	ldw	fp,0(sp)
8010814c:	dec00204 	addi	sp,sp,8
80108150:	f800283a 	ret

80108154 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
80108154:	defffb04 	addi	sp,sp,-20
80108158:	de00012e 	bgeu	sp,et,80108160 <bRmapSetCodecConfig+0xc>
8010815c:	003b68fa 	trap	3
80108160:	dfc00415 	stw	ra,16(sp)
80108164:	df000315 	stw	fp,12(sp)
80108168:	df000304 	addi	fp,sp,12
8010816c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80108170:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80108174:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
80108178:	e0bfff17 	ldw	r2,-4(fp)
8010817c:	10002626 	beq	r2,zero,80108218 <bRmapSetCodecConfig+0xc4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108180:	e0bfff17 	ldw	r2,-4(fp)
80108184:	10800017 	ldw	r2,0(r2)
80108188:	01400104 	movi	r5,4
8010818c:	1009883a 	mov	r4,r2
80108190:	010a7080 	call	8010a708 <uliRmapReadReg>
80108194:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
80108198:	e0fffe17 	ldw	r3,-8(fp)
8010819c:	00bfc004 	movi	r2,-256
801081a0:	1884703a 	and	r2,r3,r2
801081a4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
801081a8:	e0bfff17 	ldw	r2,-4(fp)
801081ac:	10800143 	ldbu	r2,5(r2)
801081b0:	10c03fcc 	andi	r3,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
801081b4:	e0bffe17 	ldw	r2,-8(fp)
801081b8:	1884b03a 	or	r2,r3,r2
801081bc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
801081c0:	e0fffe17 	ldw	r3,-8(fp)
801081c4:	00bffff4 	movhi	r2,65535
801081c8:	10803fc4 	addi	r2,r2,255
801081cc:	1884703a 	and	r2,r3,r2
801081d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
801081d4:	e0bfff17 	ldw	r2,-4(fp)
801081d8:	10800103 	ldbu	r2,4(r2)
801081dc:	10803fcc 	andi	r2,r2,255
801081e0:	1004923a 	slli	r2,r2,8
801081e4:	10ffffcc 	andi	r3,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
801081e8:	e0bffe17 	ldw	r2,-8(fp)
801081ec:	1884b03a 	or	r2,r3,r2
801081f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
801081f4:	e0bfff17 	ldw	r2,-4(fp)
801081f8:	10800017 	ldw	r2,0(r2)
801081fc:	e0fffe17 	ldw	r3,-8(fp)
80108200:	180d883a 	mov	r6,r3
80108204:	01400104 	movi	r5,4
80108208:	1009883a 	mov	r4,r2
8010820c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
80108210:	00800044 	movi	r2,1
80108214:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80108218:	e0bffd17 	ldw	r2,-12(fp)
}
8010821c:	e037883a 	mov	sp,fp
80108220:	dfc00117 	ldw	ra,4(sp)
80108224:	df000017 	ldw	fp,0(sp)
80108228:	dec00204 	addi	sp,sp,8
8010822c:	f800283a 	ret

80108230 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
80108230:	defffb04 	addi	sp,sp,-20
80108234:	de00012e 	bgeu	sp,et,8010823c <bRmapGetCodecConfig+0xc>
80108238:	003b68fa 	trap	3
8010823c:	dfc00415 	stw	ra,16(sp)
80108240:	df000315 	stw	fp,12(sp)
80108244:	df000304 	addi	fp,sp,12
80108248:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8010824c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80108250:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
80108254:	e0bfff17 	ldw	r2,-4(fp)
80108258:	10001226 	beq	r2,zero,801082a4 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010825c:	e0bfff17 	ldw	r2,-4(fp)
80108260:	10800017 	ldw	r2,0(r2)
80108264:	01400104 	movi	r5,4
80108268:	1009883a 	mov	r4,r2
8010826c:	010a7080 	call	8010a708 <uliRmapReadReg>
80108270:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
80108274:	e0bffe17 	ldw	r2,-8(fp)
80108278:	1007883a 	mov	r3,r2
8010827c:	e0bfff17 	ldw	r2,-4(fp)
80108280:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
80108284:	e0bffe17 	ldw	r2,-8(fp)
80108288:	10bfc00c 	andi	r2,r2,65280
8010828c:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
80108290:	1007883a 	mov	r3,r2
80108294:	e0bfff17 	ldw	r2,-4(fp)
80108298:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
8010829c:	00800044 	movi	r2,1
801082a0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
801082a4:	e0bffd17 	ldw	r2,-12(fp)
}
801082a8:	e037883a 	mov	sp,fp
801082ac:	dfc00117 	ldw	ra,4(sp)
801082b0:	df000017 	ldw	fp,0(sp)
801082b4:	dec00204 	addi	sp,sp,8
801082b8:	f800283a 	ret

801082bc <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
801082bc:	defffb04 	addi	sp,sp,-20
801082c0:	de00012e 	bgeu	sp,et,801082c8 <bRmapGetCodecStatus+0xc>
801082c4:	003b68fa 	trap	3
801082c8:	dfc00415 	stw	ra,16(sp)
801082cc:	df000315 	stw	fp,12(sp)
801082d0:	df000304 	addi	fp,sp,12
801082d4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
801082d8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
801082dc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
801082e0:	e0bfff17 	ldw	r2,-4(fp)
801082e4:	10004726 	beq	r2,zero,80108404 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801082e8:	e0bfff17 	ldw	r2,-4(fp)
801082ec:	10800017 	ldw	r2,0(r2)
801082f0:	01400144 	movi	r5,5
801082f4:	1009883a 	mov	r4,r2
801082f8:	010a7080 	call	8010a708 <uliRmapReadReg>
801082fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
80108300:	e0bffe17 	ldw	r2,-8(fp)
80108304:	1080004c 	andi	r2,r2,1
80108308:	10000426 	beq	r2,zero,8010831c <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
8010830c:	e0bfff17 	ldw	r2,-4(fp)
80108310:	00c00044 	movi	r3,1
80108314:	10c00215 	stw	r3,8(r2)
80108318:	00000206 	br	80108324 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
8010831c:	e0bfff17 	ldw	r2,-4(fp)
80108320:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
80108324:	e0bffe17 	ldw	r2,-8(fp)
80108328:	1080008c 	andi	r2,r2,2
8010832c:	10000426 	beq	r2,zero,80108340 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
80108330:	e0bfff17 	ldw	r2,-4(fp)
80108334:	00c00044 	movi	r3,1
80108338:	10c00315 	stw	r3,12(r2)
8010833c:	00000206 	br	80108348 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
80108340:	e0bfff17 	ldw	r2,-4(fp)
80108344:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
80108348:	e0bffe17 	ldw	r2,-8(fp)
8010834c:	1080010c 	andi	r2,r2,4
80108350:	10000426 	beq	r2,zero,80108364 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
80108354:	e0bfff17 	ldw	r2,-4(fp)
80108358:	00c00044 	movi	r3,1
8010835c:	10c00415 	stw	r3,16(r2)
80108360:	00000206 	br	8010836c <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
80108364:	e0bfff17 	ldw	r2,-4(fp)
80108368:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
8010836c:	e0bffe17 	ldw	r2,-8(fp)
80108370:	1080020c 	andi	r2,r2,8
80108374:	10000426 	beq	r2,zero,80108388 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
80108378:	e0bfff17 	ldw	r2,-4(fp)
8010837c:	00c00044 	movi	r3,1
80108380:	10c00515 	stw	r3,20(r2)
80108384:	00000206 	br	80108390 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
80108388:	e0bfff17 	ldw	r2,-4(fp)
8010838c:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
80108390:	e0bffe17 	ldw	r2,-8(fp)
80108394:	1080040c 	andi	r2,r2,16
80108398:	10000426 	beq	r2,zero,801083ac <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
8010839c:	e0bfff17 	ldw	r2,-4(fp)
801083a0:	00c00044 	movi	r3,1
801083a4:	10c00615 	stw	r3,24(r2)
801083a8:	00000206 	br	801083b4 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
801083ac:	e0bfff17 	ldw	r2,-4(fp)
801083b0:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
801083b4:	e0bffe17 	ldw	r2,-8(fp)
801083b8:	1080080c 	andi	r2,r2,32
801083bc:	10000426 	beq	r2,zero,801083d0 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
801083c0:	e0bfff17 	ldw	r2,-4(fp)
801083c4:	00c00044 	movi	r3,1
801083c8:	10c00715 	stw	r3,28(r2)
801083cc:	00000206 	br	801083d8 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
801083d0:	e0bfff17 	ldw	r2,-4(fp)
801083d4:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
801083d8:	e0bffe17 	ldw	r2,-8(fp)
801083dc:	1080100c 	andi	r2,r2,64
801083e0:	10000426 	beq	r2,zero,801083f4 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
801083e4:	e0bfff17 	ldw	r2,-4(fp)
801083e8:	00c00044 	movi	r3,1
801083ec:	10c00815 	stw	r3,32(r2)
801083f0:	00000206 	br	801083fc <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
801083f4:	e0bfff17 	ldw	r2,-4(fp)
801083f8:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
801083fc:	00800044 	movi	r2,1
80108400:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80108404:	e0bffd17 	ldw	r2,-12(fp)
}
80108408:	e037883a 	mov	sp,fp
8010840c:	dfc00117 	ldw	ra,4(sp)
80108410:	df000017 	ldw	fp,0(sp)
80108414:	dec00204 	addi	sp,sp,8
80108418:	f800283a 	ret

8010841c <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
8010841c:	defffb04 	addi	sp,sp,-20
80108420:	de00012e 	bgeu	sp,et,80108428 <bRmapGetCodecError+0xc>
80108424:	003b68fa 	trap	3
80108428:	dfc00415 	stw	ra,16(sp)
8010842c:	df000315 	stw	fp,12(sp)
80108430:	df000304 	addi	fp,sp,12
80108434:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80108438:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010843c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
80108440:	e0bfff17 	ldw	r2,-4(fp)
80108444:	10004726 	beq	r2,zero,80108564 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108448:	e0bfff17 	ldw	r2,-4(fp)
8010844c:	10800017 	ldw	r2,0(r2)
80108450:	01400144 	movi	r5,5
80108454:	1009883a 	mov	r4,r2
80108458:	010a7080 	call	8010a708 <uliRmapReadReg>
8010845c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
80108460:	e0bffe17 	ldw	r2,-8(fp)
80108464:	1080006c 	andhi	r2,r2,1
80108468:	10000426 	beq	r2,zero,8010847c <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
8010846c:	e0bfff17 	ldw	r2,-4(fp)
80108470:	00c00044 	movi	r3,1
80108474:	10c00915 	stw	r3,36(r2)
80108478:	00000206 	br	80108484 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
8010847c:	e0bfff17 	ldw	r2,-4(fp)
80108480:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
80108484:	e0bffe17 	ldw	r2,-8(fp)
80108488:	108000ac 	andhi	r2,r2,2
8010848c:	10000426 	beq	r2,zero,801084a0 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
80108490:	e0bfff17 	ldw	r2,-4(fp)
80108494:	00c00044 	movi	r3,1
80108498:	10c00a15 	stw	r3,40(r2)
8010849c:	00000206 	br	801084a8 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
801084a0:	e0bfff17 	ldw	r2,-4(fp)
801084a4:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
801084a8:	e0bffe17 	ldw	r2,-8(fp)
801084ac:	1080012c 	andhi	r2,r2,4
801084b0:	10000426 	beq	r2,zero,801084c4 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
801084b4:	e0bfff17 	ldw	r2,-4(fp)
801084b8:	00c00044 	movi	r3,1
801084bc:	10c00b15 	stw	r3,44(r2)
801084c0:	00000206 	br	801084cc <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
801084c4:	e0bfff17 	ldw	r2,-4(fp)
801084c8:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
801084cc:	e0bffe17 	ldw	r2,-8(fp)
801084d0:	1080022c 	andhi	r2,r2,8
801084d4:	10000426 	beq	r2,zero,801084e8 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
801084d8:	e0bfff17 	ldw	r2,-4(fp)
801084dc:	00c00044 	movi	r3,1
801084e0:	10c00c15 	stw	r3,48(r2)
801084e4:	00000206 	br	801084f0 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
801084e8:	e0bfff17 	ldw	r2,-4(fp)
801084ec:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
801084f0:	e0bffe17 	ldw	r2,-8(fp)
801084f4:	1080042c 	andhi	r2,r2,16
801084f8:	10000426 	beq	r2,zero,8010850c <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
801084fc:	e0bfff17 	ldw	r2,-4(fp)
80108500:	00c00044 	movi	r3,1
80108504:	10c00d15 	stw	r3,52(r2)
80108508:	00000206 	br	80108514 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
8010850c:	e0bfff17 	ldw	r2,-4(fp)
80108510:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
80108514:	e0bffe17 	ldw	r2,-8(fp)
80108518:	1080082c 	andhi	r2,r2,32
8010851c:	10000426 	beq	r2,zero,80108530 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
80108520:	e0bfff17 	ldw	r2,-4(fp)
80108524:	00c00044 	movi	r3,1
80108528:	10c00e15 	stw	r3,56(r2)
8010852c:	00000206 	br	80108538 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
80108530:	e0bfff17 	ldw	r2,-4(fp)
80108534:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
80108538:	e0bffe17 	ldw	r2,-8(fp)
8010853c:	1080102c 	andhi	r2,r2,64
80108540:	10000426 	beq	r2,zero,80108554 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
80108544:	e0bfff17 	ldw	r2,-4(fp)
80108548:	00c00044 	movi	r3,1
8010854c:	10c00f15 	stw	r3,60(r2)
80108550:	00000206 	br	8010855c <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
80108554:	e0bfff17 	ldw	r2,-4(fp)
80108558:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
8010855c:	00800044 	movi	r2,1
80108560:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80108564:	e0bffd17 	ldw	r2,-12(fp)
}
80108568:	e037883a 	mov	sp,fp
8010856c:	dfc00117 	ldw	ra,4(sp)
80108570:	df000017 	ldw	fp,0(sp)
80108574:	dec00204 	addi	sp,sp,8
80108578:	f800283a 	ret

8010857c <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
8010857c:	defffb04 	addi	sp,sp,-20
80108580:	de00012e 	bgeu	sp,et,80108588 <bRmapSetMemConfigArea+0xc>
80108584:	003b68fa 	trap	3
80108588:	dfc00415 	stw	ra,16(sp)
8010858c:	df000315 	stw	fp,12(sp)
80108590:	df000304 	addi	fp,sp,12
80108594:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80108598:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010859c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
801085a0:	e0bfff17 	ldw	r2,-4(fp)
801085a4:	1000bc26 	beq	r2,zero,80108898 <bRmapSetMemConfigArea+0x31c>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
801085a8:	e0bfff17 	ldw	r2,-4(fp)
801085ac:	10801217 	ldw	r2,72(r2)
801085b0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
801085b4:	e0bfff17 	ldw	r2,-4(fp)
801085b8:	10800017 	ldw	r2,0(r2)
801085bc:	e0fffe17 	ldw	r3,-8(fp)
801085c0:	180d883a 	mov	r6,r3
801085c4:	01401004 	movi	r5,64
801085c8:	1009883a 	mov	r4,r2
801085cc:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
801085d0:	e0bfff17 	ldw	r2,-4(fp)
801085d4:	10801317 	ldw	r2,76(r2)
801085d8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
801085dc:	e0bfff17 	ldw	r2,-4(fp)
801085e0:	10800017 	ldw	r2,0(r2)
801085e4:	e0fffe17 	ldw	r3,-8(fp)
801085e8:	180d883a 	mov	r6,r3
801085ec:	01401044 	movi	r5,65
801085f0:	1009883a 	mov	r4,r2
801085f4:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
801085f8:	e0bfff17 	ldw	r2,-4(fp)
801085fc:	10801417 	ldw	r2,80(r2)
80108600:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
80108604:	e0bfff17 	ldw	r2,-4(fp)
80108608:	10800017 	ldw	r2,0(r2)
8010860c:	e0fffe17 	ldw	r3,-8(fp)
80108610:	180d883a 	mov	r6,r3
80108614:	01401084 	movi	r5,66
80108618:	1009883a 	mov	r4,r2
8010861c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
80108620:	e0bfff17 	ldw	r2,-4(fp)
80108624:	10801517 	ldw	r2,84(r2)
80108628:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8010862c:	e0bfff17 	ldw	r2,-4(fp)
80108630:	10800017 	ldw	r2,0(r2)
80108634:	e0fffe17 	ldw	r3,-8(fp)
80108638:	180d883a 	mov	r6,r3
8010863c:	014010c4 	movi	r5,67
80108640:	1009883a 	mov	r4,r2
80108644:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
80108648:	e0bfff17 	ldw	r2,-4(fp)
8010864c:	10802217 	ldw	r2,136(r2)
80108650:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
80108654:	e0bfff17 	ldw	r2,-4(fp)
80108658:	10800017 	ldw	r2,0(r2)
8010865c:	e0fffe17 	ldw	r3,-8(fp)
80108660:	180d883a 	mov	r6,r3
80108664:	01401104 	movi	r5,68
80108668:	1009883a 	mov	r4,r2
8010866c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
80108670:	e0bfff17 	ldw	r2,-4(fp)
80108674:	10801717 	ldw	r2,92(r2)
80108678:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8010867c:	e0bfff17 	ldw	r2,-4(fp)
80108680:	10800017 	ldw	r2,0(r2)
80108684:	e0fffe17 	ldw	r3,-8(fp)
80108688:	180d883a 	mov	r6,r3
8010868c:	01401144 	movi	r5,69
80108690:	1009883a 	mov	r4,r2
80108694:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
80108698:	e0bfff17 	ldw	r2,-4(fp)
8010869c:	10801817 	ldw	r2,96(r2)
801086a0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
801086a4:	e0bfff17 	ldw	r2,-4(fp)
801086a8:	10800017 	ldw	r2,0(r2)
801086ac:	e0fffe17 	ldw	r3,-8(fp)
801086b0:	180d883a 	mov	r6,r3
801086b4:	01401184 	movi	r5,70
801086b8:	1009883a 	mov	r4,r2
801086bc:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
801086c0:	e0bfff17 	ldw	r2,-4(fp)
801086c4:	10801917 	ldw	r2,100(r2)
801086c8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
801086cc:	e0bfff17 	ldw	r2,-4(fp)
801086d0:	10800017 	ldw	r2,0(r2)
801086d4:	e0fffe17 	ldw	r3,-8(fp)
801086d8:	180d883a 	mov	r6,r3
801086dc:	014011c4 	movi	r5,71
801086e0:	1009883a 	mov	r4,r2
801086e4:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
801086e8:	e0bfff17 	ldw	r2,-4(fp)
801086ec:	10801a17 	ldw	r2,104(r2)
801086f0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
801086f4:	e0bfff17 	ldw	r2,-4(fp)
801086f8:	10800017 	ldw	r2,0(r2)
801086fc:	e0fffe17 	ldw	r3,-8(fp)
80108700:	180d883a 	mov	r6,r3
80108704:	01401204 	movi	r5,72
80108708:	1009883a 	mov	r4,r2
8010870c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
80108710:	e0bfff17 	ldw	r2,-4(fp)
80108714:	10801b17 	ldw	r2,108(r2)
80108718:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8010871c:	e0bfff17 	ldw	r2,-4(fp)
80108720:	10800017 	ldw	r2,0(r2)
80108724:	e0fffe17 	ldw	r3,-8(fp)
80108728:	180d883a 	mov	r6,r3
8010872c:	01401244 	movi	r5,73
80108730:	1009883a 	mov	r4,r2
80108734:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108738:	e0bfff17 	ldw	r2,-4(fp)
8010873c:	10800017 	ldw	r2,0(r2)
80108740:	01401284 	movi	r5,74
80108744:	1009883a 	mov	r4,r2
80108748:	010a7080 	call	8010a708 <uliRmapReadReg>
8010874c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
80108750:	e0bfff17 	ldw	r2,-4(fp)
80108754:	10801c17 	ldw	r2,112(r2)
80108758:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8010875c:	e0bfff17 	ldw	r2,-4(fp)
80108760:	10800017 	ldw	r2,0(r2)
80108764:	e0fffe17 	ldw	r3,-8(fp)
80108768:	180d883a 	mov	r6,r3
8010876c:	01401284 	movi	r5,74
80108770:	1009883a 	mov	r4,r2
80108774:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
80108778:	e0bfff17 	ldw	r2,-4(fp)
8010877c:	10801d17 	ldw	r2,116(r2)
80108780:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
80108784:	e0bfff17 	ldw	r2,-4(fp)
80108788:	10800017 	ldw	r2,0(r2)
8010878c:	e0fffe17 	ldw	r3,-8(fp)
80108790:	180d883a 	mov	r6,r3
80108794:	014012c4 	movi	r5,75
80108798:	1009883a 	mov	r4,r2
8010879c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
801087a0:	e0bfff17 	ldw	r2,-4(fp)
801087a4:	10801e17 	ldw	r2,120(r2)
801087a8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
801087ac:	e0bfff17 	ldw	r2,-4(fp)
801087b0:	10800017 	ldw	r2,0(r2)
801087b4:	e0fffe17 	ldw	r3,-8(fp)
801087b8:	180d883a 	mov	r6,r3
801087bc:	01401304 	movi	r5,76
801087c0:	1009883a 	mov	r4,r2
801087c4:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
801087c8:	e0bfff17 	ldw	r2,-4(fp)
801087cc:	10801f17 	ldw	r2,124(r2)
801087d0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
801087d4:	e0bfff17 	ldw	r2,-4(fp)
801087d8:	10800017 	ldw	r2,0(r2)
801087dc:	e0fffe17 	ldw	r3,-8(fp)
801087e0:	180d883a 	mov	r6,r3
801087e4:	01401344 	movi	r5,77
801087e8:	1009883a 	mov	r4,r2
801087ec:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
801087f0:	e0bfff17 	ldw	r2,-4(fp)
801087f4:	10802017 	ldw	r2,128(r2)
801087f8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
801087fc:	e0bfff17 	ldw	r2,-4(fp)
80108800:	10800017 	ldw	r2,0(r2)
80108804:	e0fffe17 	ldw	r3,-8(fp)
80108808:	180d883a 	mov	r6,r3
8010880c:	01401384 	movi	r5,78
80108810:	1009883a 	mov	r4,r2
80108814:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
80108818:	e0bfff17 	ldw	r2,-4(fp)
8010881c:	10802217 	ldw	r2,136(r2)
80108820:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
80108824:	e0bfff17 	ldw	r2,-4(fp)
80108828:	10800017 	ldw	r2,0(r2)
8010882c:	e0fffe17 	ldw	r3,-8(fp)
80108830:	180d883a 	mov	r6,r3
80108834:	014013c4 	movi	r5,79
80108838:	1009883a 	mov	r4,r2
8010883c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
80108840:	e0bfff17 	ldw	r2,-4(fp)
80108844:	10802217 	ldw	r2,136(r2)
80108848:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
8010884c:	e0bfff17 	ldw	r2,-4(fp)
80108850:	10800017 	ldw	r2,0(r2)
80108854:	e0fffe17 	ldw	r3,-8(fp)
80108858:	180d883a 	mov	r6,r3
8010885c:	01401404 	movi	r5,80
80108860:	1009883a 	mov	r4,r2
80108864:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
80108868:	e0bfff17 	ldw	r2,-4(fp)
8010886c:	10802317 	ldw	r2,140(r2)
80108870:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
80108874:	e0bfff17 	ldw	r2,-4(fp)
80108878:	10800017 	ldw	r2,0(r2)
8010887c:	e0fffe17 	ldw	r3,-8(fp)
80108880:	180d883a 	mov	r6,r3
80108884:	01401444 	movi	r5,81
80108888:	1009883a 	mov	r4,r2
8010888c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
80108890:	00800044 	movi	r2,1
80108894:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80108898:	e0bffd17 	ldw	r2,-12(fp)
}
8010889c:	e037883a 	mov	sp,fp
801088a0:	dfc00117 	ldw	ra,4(sp)
801088a4:	df000017 	ldw	fp,0(sp)
801088a8:	dec00204 	addi	sp,sp,8
801088ac:	f800283a 	ret

801088b0 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
801088b0:	defffb04 	addi	sp,sp,-20
801088b4:	de00012e 	bgeu	sp,et,801088bc <bRmapGetMemConfigArea+0xc>
801088b8:	003b68fa 	trap	3
801088bc:	dfc00415 	stw	ra,16(sp)
801088c0:	df000315 	stw	fp,12(sp)
801088c4:	df000304 	addi	fp,sp,12
801088c8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
801088cc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
801088d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
801088d4:	e0bfff17 	ldw	r2,-4(fp)
801088d8:	1000a426 	beq	r2,zero,80108b6c <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801088dc:	e0bfff17 	ldw	r2,-4(fp)
801088e0:	10800017 	ldw	r2,0(r2)
801088e4:	01401004 	movi	r5,64
801088e8:	1009883a 	mov	r4,r2
801088ec:	010a7080 	call	8010a708 <uliRmapReadReg>
801088f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
801088f4:	e0fffe17 	ldw	r3,-8(fp)
801088f8:	e0bfff17 	ldw	r2,-4(fp)
801088fc:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108900:	e0bfff17 	ldw	r2,-4(fp)
80108904:	10800017 	ldw	r2,0(r2)
80108908:	01401044 	movi	r5,65
8010890c:	1009883a 	mov	r4,r2
80108910:	010a7080 	call	8010a708 <uliRmapReadReg>
80108914:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
80108918:	e0fffe17 	ldw	r3,-8(fp)
8010891c:	e0bfff17 	ldw	r2,-4(fp)
80108920:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108924:	e0bfff17 	ldw	r2,-4(fp)
80108928:	10800017 	ldw	r2,0(r2)
8010892c:	01401084 	movi	r5,66
80108930:	1009883a 	mov	r4,r2
80108934:	010a7080 	call	8010a708 <uliRmapReadReg>
80108938:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
8010893c:	e0fffe17 	ldw	r3,-8(fp)
80108940:	e0bfff17 	ldw	r2,-4(fp)
80108944:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108948:	e0bfff17 	ldw	r2,-4(fp)
8010894c:	10800017 	ldw	r2,0(r2)
80108950:	014010c4 	movi	r5,67
80108954:	1009883a 	mov	r4,r2
80108958:	010a7080 	call	8010a708 <uliRmapReadReg>
8010895c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
80108960:	e0fffe17 	ldw	r3,-8(fp)
80108964:	e0bfff17 	ldw	r2,-4(fp)
80108968:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010896c:	e0bfff17 	ldw	r2,-4(fp)
80108970:	10800017 	ldw	r2,0(r2)
80108974:	01401104 	movi	r5,68
80108978:	1009883a 	mov	r4,r2
8010897c:	010a7080 	call	8010a708 <uliRmapReadReg>
80108980:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
80108984:	e0fffe17 	ldw	r3,-8(fp)
80108988:	e0bfff17 	ldw	r2,-4(fp)
8010898c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108990:	e0bfff17 	ldw	r2,-4(fp)
80108994:	10800017 	ldw	r2,0(r2)
80108998:	01401144 	movi	r5,69
8010899c:	1009883a 	mov	r4,r2
801089a0:	010a7080 	call	8010a708 <uliRmapReadReg>
801089a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
801089a8:	e0fffe17 	ldw	r3,-8(fp)
801089ac:	e0bfff17 	ldw	r2,-4(fp)
801089b0:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801089b4:	e0bfff17 	ldw	r2,-4(fp)
801089b8:	10800017 	ldw	r2,0(r2)
801089bc:	01401184 	movi	r5,70
801089c0:	1009883a 	mov	r4,r2
801089c4:	010a7080 	call	8010a708 <uliRmapReadReg>
801089c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
801089cc:	e0fffe17 	ldw	r3,-8(fp)
801089d0:	e0bfff17 	ldw	r2,-4(fp)
801089d4:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801089d8:	e0bfff17 	ldw	r2,-4(fp)
801089dc:	10800017 	ldw	r2,0(r2)
801089e0:	014011c4 	movi	r5,71
801089e4:	1009883a 	mov	r4,r2
801089e8:	010a7080 	call	8010a708 <uliRmapReadReg>
801089ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
801089f0:	e0fffe17 	ldw	r3,-8(fp)
801089f4:	e0bfff17 	ldw	r2,-4(fp)
801089f8:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801089fc:	e0bfff17 	ldw	r2,-4(fp)
80108a00:	10800017 	ldw	r2,0(r2)
80108a04:	01401204 	movi	r5,72
80108a08:	1009883a 	mov	r4,r2
80108a0c:	010a7080 	call	8010a708 <uliRmapReadReg>
80108a10:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
80108a14:	e0fffe17 	ldw	r3,-8(fp)
80108a18:	e0bfff17 	ldw	r2,-4(fp)
80108a1c:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108a20:	e0bfff17 	ldw	r2,-4(fp)
80108a24:	10800017 	ldw	r2,0(r2)
80108a28:	01401244 	movi	r5,73
80108a2c:	1009883a 	mov	r4,r2
80108a30:	010a7080 	call	8010a708 <uliRmapReadReg>
80108a34:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
80108a38:	e0fffe17 	ldw	r3,-8(fp)
80108a3c:	e0bfff17 	ldw	r2,-4(fp)
80108a40:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108a44:	e0bfff17 	ldw	r2,-4(fp)
80108a48:	10800017 	ldw	r2,0(r2)
80108a4c:	01401284 	movi	r5,74
80108a50:	1009883a 	mov	r4,r2
80108a54:	010a7080 	call	8010a708 <uliRmapReadReg>
80108a58:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
80108a5c:	e0fffe17 	ldw	r3,-8(fp)
80108a60:	e0bfff17 	ldw	r2,-4(fp)
80108a64:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108a68:	e0bfff17 	ldw	r2,-4(fp)
80108a6c:	10800017 	ldw	r2,0(r2)
80108a70:	014012c4 	movi	r5,75
80108a74:	1009883a 	mov	r4,r2
80108a78:	010a7080 	call	8010a708 <uliRmapReadReg>
80108a7c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
80108a80:	e0fffe17 	ldw	r3,-8(fp)
80108a84:	e0bfff17 	ldw	r2,-4(fp)
80108a88:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108a8c:	e0bfff17 	ldw	r2,-4(fp)
80108a90:	10800017 	ldw	r2,0(r2)
80108a94:	01401304 	movi	r5,76
80108a98:	1009883a 	mov	r4,r2
80108a9c:	010a7080 	call	8010a708 <uliRmapReadReg>
80108aa0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
80108aa4:	e0fffe17 	ldw	r3,-8(fp)
80108aa8:	e0bfff17 	ldw	r2,-4(fp)
80108aac:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108ab0:	e0bfff17 	ldw	r2,-4(fp)
80108ab4:	10800017 	ldw	r2,0(r2)
80108ab8:	01401344 	movi	r5,77
80108abc:	1009883a 	mov	r4,r2
80108ac0:	010a7080 	call	8010a708 <uliRmapReadReg>
80108ac4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
80108ac8:	e0fffe17 	ldw	r3,-8(fp)
80108acc:	e0bfff17 	ldw	r2,-4(fp)
80108ad0:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108ad4:	e0bfff17 	ldw	r2,-4(fp)
80108ad8:	10800017 	ldw	r2,0(r2)
80108adc:	01401384 	movi	r5,78
80108ae0:	1009883a 	mov	r4,r2
80108ae4:	010a7080 	call	8010a708 <uliRmapReadReg>
80108ae8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
80108aec:	e0fffe17 	ldw	r3,-8(fp)
80108af0:	e0bfff17 	ldw	r2,-4(fp)
80108af4:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108af8:	e0bfff17 	ldw	r2,-4(fp)
80108afc:	10800017 	ldw	r2,0(r2)
80108b00:	014013c4 	movi	r5,79
80108b04:	1009883a 	mov	r4,r2
80108b08:	010a7080 	call	8010a708 <uliRmapReadReg>
80108b0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
80108b10:	e0fffe17 	ldw	r3,-8(fp)
80108b14:	e0bfff17 	ldw	r2,-4(fp)
80108b18:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108b1c:	e0bfff17 	ldw	r2,-4(fp)
80108b20:	10800017 	ldw	r2,0(r2)
80108b24:	01401404 	movi	r5,80
80108b28:	1009883a 	mov	r4,r2
80108b2c:	010a7080 	call	8010a708 <uliRmapReadReg>
80108b30:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
80108b34:	e0fffe17 	ldw	r3,-8(fp)
80108b38:	e0bfff17 	ldw	r2,-4(fp)
80108b3c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108b40:	e0bfff17 	ldw	r2,-4(fp)
80108b44:	10800017 	ldw	r2,0(r2)
80108b48:	01401444 	movi	r5,81
80108b4c:	1009883a 	mov	r4,r2
80108b50:	010a7080 	call	8010a708 <uliRmapReadReg>
80108b54:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
80108b58:	e0fffe17 	ldw	r3,-8(fp)
80108b5c:	e0bfff17 	ldw	r2,-4(fp)
80108b60:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
80108b64:	00800044 	movi	r2,1
80108b68:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80108b6c:	e0bffd17 	ldw	r2,-12(fp)
}
80108b70:	e037883a 	mov	sp,fp
80108b74:	dfc00117 	ldw	ra,4(sp)
80108b78:	df000017 	ldw	fp,0(sp)
80108b7c:	dec00204 	addi	sp,sp,8
80108b80:	f800283a 	ret

80108b84 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
80108b84:	defffb04 	addi	sp,sp,-20
80108b88:	de00012e 	bgeu	sp,et,80108b90 <bRmapGetMemConfigStat+0xc>
80108b8c:	003b68fa 	trap	3
80108b90:	dfc00415 	stw	ra,16(sp)
80108b94:	df000315 	stw	fp,12(sp)
80108b98:	df000304 	addi	fp,sp,12
80108b9c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80108ba0:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80108ba4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
80108ba8:	e0bfff17 	ldw	r2,-4(fp)
80108bac:	10001426 	beq	r2,zero,80108c00 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108bb0:	e0bfff17 	ldw	r2,-4(fp)
80108bb4:	10800017 	ldw	r2,0(r2)
80108bb8:	014001c4 	movi	r5,7
80108bbc:	1009883a 	mov	r4,r2
80108bc0:	010a7080 	call	8010a708 <uliRmapReadReg>
80108bc4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
80108bc8:	e0fffe17 	ldw	r3,-8(fp)
80108bcc:	e0bfff17 	ldw	r2,-4(fp)
80108bd0:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108bd4:	e0bfff17 	ldw	r2,-4(fp)
80108bd8:	10800017 	ldw	r2,0(r2)
80108bdc:	01400184 	movi	r5,6
80108be0:	1009883a 	mov	r4,r2
80108be4:	010a7080 	call	8010a708 <uliRmapReadReg>
80108be8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
80108bec:	e0fffe17 	ldw	r3,-8(fp)
80108bf0:	e0bfff17 	ldw	r2,-4(fp)
80108bf4:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
80108bf8:	00800044 	movi	r2,1
80108bfc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80108c00:	e0bffd17 	ldw	r2,-12(fp)
}
80108c04:	e037883a 	mov	sp,fp
80108c08:	dfc00117 	ldw	ra,4(sp)
80108c0c:	df000017 	ldw	fp,0(sp)
80108c10:	dec00204 	addi	sp,sp,8
80108c14:	f800283a 	ret

80108c18 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
80108c18:	defffb04 	addi	sp,sp,-20
80108c1c:	de00012e 	bgeu	sp,et,80108c24 <bRmapSetRmapMemHKArea+0xc>
80108c20:	003b68fa 	trap	3
80108c24:	dfc00415 	stw	ra,16(sp)
80108c28:	df000315 	stw	fp,12(sp)
80108c2c:	df000304 	addi	fp,sp,12
80108c30:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80108c34:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80108c38:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
80108c3c:	e0bfff17 	ldw	r2,-4(fp)
80108c40:	10042226 	beq	r2,zero,80109ccc <bRmapSetRmapMemHKArea+0x10b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108c44:	e0bfff17 	ldw	r2,-4(fp)
80108c48:	10800017 	ldw	r2,0(r2)
80108c4c:	01402804 	movi	r5,160
80108c50:	1009883a 	mov	r4,r2
80108c54:	010a7080 	call	8010a708 <uliRmapReadReg>
80108c58:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
80108c5c:	e0bffe17 	ldw	r2,-8(fp)
80108c60:	10bfffec 	andhi	r2,r2,65535
80108c64:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
80108c68:	e0bfff17 	ldw	r2,-4(fp)
80108c6c:	1080260b 	ldhu	r2,152(r2)
80108c70:	10ffffcc 	andi	r3,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
80108c74:	e0bffe17 	ldw	r2,-8(fp)
80108c78:	1884b03a 	or	r2,r3,r2
80108c7c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
80108c80:	e0bffe17 	ldw	r2,-8(fp)
80108c84:	10bfffcc 	andi	r2,r2,65535
80108c88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
80108c8c:	e0bfff17 	ldw	r2,-4(fp)
80108c90:	1080268b 	ldhu	r2,154(r2)
80108c94:	10bfffcc 	andi	r2,r2,65535
80108c98:	1004943a 	slli	r2,r2,16
80108c9c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
80108ca0:	e0bffe17 	ldw	r2,-8(fp)
80108ca4:	1884b03a 	or	r2,r3,r2
80108ca8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
80108cac:	e0bfff17 	ldw	r2,-4(fp)
80108cb0:	10800017 	ldw	r2,0(r2)
80108cb4:	e0fffe17 	ldw	r3,-8(fp)
80108cb8:	180d883a 	mov	r6,r3
80108cbc:	01402804 	movi	r5,160
80108cc0:	1009883a 	mov	r4,r2
80108cc4:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108cc8:	e0bfff17 	ldw	r2,-4(fp)
80108ccc:	10800017 	ldw	r2,0(r2)
80108cd0:	01402844 	movi	r5,161
80108cd4:	1009883a 	mov	r4,r2
80108cd8:	010a7080 	call	8010a708 <uliRmapReadReg>
80108cdc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
80108ce0:	e0bffe17 	ldw	r2,-8(fp)
80108ce4:	10bfffec 	andhi	r2,r2,65535
80108ce8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
80108cec:	e0bfff17 	ldw	r2,-4(fp)
80108cf0:	1080270b 	ldhu	r2,156(r2)
80108cf4:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
80108cf8:	e0bffe17 	ldw	r2,-8(fp)
80108cfc:	1884b03a 	or	r2,r3,r2
80108d00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
80108d04:	e0bffe17 	ldw	r2,-8(fp)
80108d08:	10bfffcc 	andi	r2,r2,65535
80108d0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
80108d10:	e0bfff17 	ldw	r2,-4(fp)
80108d14:	1080278b 	ldhu	r2,158(r2)
80108d18:	10bfffcc 	andi	r2,r2,65535
80108d1c:	1004943a 	slli	r2,r2,16
80108d20:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
80108d24:	e0bffe17 	ldw	r2,-8(fp)
80108d28:	1884b03a 	or	r2,r3,r2
80108d2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
80108d30:	e0bfff17 	ldw	r2,-4(fp)
80108d34:	10800017 	ldw	r2,0(r2)
80108d38:	e0fffe17 	ldw	r3,-8(fp)
80108d3c:	180d883a 	mov	r6,r3
80108d40:	01402844 	movi	r5,161
80108d44:	1009883a 	mov	r4,r2
80108d48:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108d4c:	e0bfff17 	ldw	r2,-4(fp)
80108d50:	10800017 	ldw	r2,0(r2)
80108d54:	01402884 	movi	r5,162
80108d58:	1009883a 	mov	r4,r2
80108d5c:	010a7080 	call	8010a708 <uliRmapReadReg>
80108d60:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
80108d64:	e0bffe17 	ldw	r2,-8(fp)
80108d68:	10bfffec 	andhi	r2,r2,65535
80108d6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
80108d70:	e0bfff17 	ldw	r2,-4(fp)
80108d74:	1080280b 	ldhu	r2,160(r2)
80108d78:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
80108d7c:	e0bffe17 	ldw	r2,-8(fp)
80108d80:	1884b03a 	or	r2,r3,r2
80108d84:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
80108d88:	e0bffe17 	ldw	r2,-8(fp)
80108d8c:	10bfffcc 	andi	r2,r2,65535
80108d90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
80108d94:	e0bfff17 	ldw	r2,-4(fp)
80108d98:	1080288b 	ldhu	r2,162(r2)
80108d9c:	10bfffcc 	andi	r2,r2,65535
80108da0:	1004943a 	slli	r2,r2,16
80108da4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
80108da8:	e0bffe17 	ldw	r2,-8(fp)
80108dac:	1884b03a 	or	r2,r3,r2
80108db0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
80108db4:	e0bfff17 	ldw	r2,-4(fp)
80108db8:	10800017 	ldw	r2,0(r2)
80108dbc:	e0fffe17 	ldw	r3,-8(fp)
80108dc0:	180d883a 	mov	r6,r3
80108dc4:	01402884 	movi	r5,162
80108dc8:	1009883a 	mov	r4,r2
80108dcc:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108dd0:	e0bfff17 	ldw	r2,-4(fp)
80108dd4:	10800017 	ldw	r2,0(r2)
80108dd8:	014028c4 	movi	r5,163
80108ddc:	1009883a 	mov	r4,r2
80108de0:	010a7080 	call	8010a708 <uliRmapReadReg>
80108de4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
80108de8:	e0bffe17 	ldw	r2,-8(fp)
80108dec:	10bfffec 	andhi	r2,r2,65535
80108df0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
80108df4:	e0bfff17 	ldw	r2,-4(fp)
80108df8:	1080290b 	ldhu	r2,164(r2)
80108dfc:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
80108e00:	e0bffe17 	ldw	r2,-8(fp)
80108e04:	1884b03a 	or	r2,r3,r2
80108e08:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
80108e0c:	e0bffe17 	ldw	r2,-8(fp)
80108e10:	10bfffcc 	andi	r2,r2,65535
80108e14:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
80108e18:	e0bfff17 	ldw	r2,-4(fp)
80108e1c:	1080298b 	ldhu	r2,166(r2)
80108e20:	10bfffcc 	andi	r2,r2,65535
80108e24:	1004943a 	slli	r2,r2,16
80108e28:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
80108e2c:	e0bffe17 	ldw	r2,-8(fp)
80108e30:	1884b03a 	or	r2,r3,r2
80108e34:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
80108e38:	e0bfff17 	ldw	r2,-4(fp)
80108e3c:	10800017 	ldw	r2,0(r2)
80108e40:	e0fffe17 	ldw	r3,-8(fp)
80108e44:	180d883a 	mov	r6,r3
80108e48:	014028c4 	movi	r5,163
80108e4c:	1009883a 	mov	r4,r2
80108e50:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108e54:	e0bfff17 	ldw	r2,-4(fp)
80108e58:	10800017 	ldw	r2,0(r2)
80108e5c:	01402904 	movi	r5,164
80108e60:	1009883a 	mov	r4,r2
80108e64:	010a7080 	call	8010a708 <uliRmapReadReg>
80108e68:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
80108e6c:	e0bffe17 	ldw	r2,-8(fp)
80108e70:	10bfffec 	andhi	r2,r2,65535
80108e74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
80108e78:	e0bfff17 	ldw	r2,-4(fp)
80108e7c:	10802a0b 	ldhu	r2,168(r2)
80108e80:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
80108e84:	e0bffe17 	ldw	r2,-8(fp)
80108e88:	1884b03a 	or	r2,r3,r2
80108e8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
80108e90:	e0bffe17 	ldw	r2,-8(fp)
80108e94:	10bfffcc 	andi	r2,r2,65535
80108e98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
80108e9c:	e0bfff17 	ldw	r2,-4(fp)
80108ea0:	10802a8b 	ldhu	r2,170(r2)
80108ea4:	10bfffcc 	andi	r2,r2,65535
80108ea8:	1004943a 	slli	r2,r2,16
80108eac:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
80108eb0:	e0bffe17 	ldw	r2,-8(fp)
80108eb4:	1884b03a 	or	r2,r3,r2
80108eb8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
80108ebc:	e0bfff17 	ldw	r2,-4(fp)
80108ec0:	10800017 	ldw	r2,0(r2)
80108ec4:	e0fffe17 	ldw	r3,-8(fp)
80108ec8:	180d883a 	mov	r6,r3
80108ecc:	01402904 	movi	r5,164
80108ed0:	1009883a 	mov	r4,r2
80108ed4:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108ed8:	e0bfff17 	ldw	r2,-4(fp)
80108edc:	10800017 	ldw	r2,0(r2)
80108ee0:	01402944 	movi	r5,165
80108ee4:	1009883a 	mov	r4,r2
80108ee8:	010a7080 	call	8010a708 <uliRmapReadReg>
80108eec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
80108ef0:	e0bffe17 	ldw	r2,-8(fp)
80108ef4:	10bfffec 	andhi	r2,r2,65535
80108ef8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
80108efc:	e0bfff17 	ldw	r2,-4(fp)
80108f00:	10802b0b 	ldhu	r2,172(r2)
80108f04:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
80108f08:	e0bffe17 	ldw	r2,-8(fp)
80108f0c:	1884b03a 	or	r2,r3,r2
80108f10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
80108f14:	e0bffe17 	ldw	r2,-8(fp)
80108f18:	10bfffcc 	andi	r2,r2,65535
80108f1c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
80108f20:	e0bfff17 	ldw	r2,-4(fp)
80108f24:	10802b8b 	ldhu	r2,174(r2)
80108f28:	10bfffcc 	andi	r2,r2,65535
80108f2c:	1004943a 	slli	r2,r2,16
80108f30:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
80108f34:	e0bffe17 	ldw	r2,-8(fp)
80108f38:	1884b03a 	or	r2,r3,r2
80108f3c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
80108f40:	e0bfff17 	ldw	r2,-4(fp)
80108f44:	10800017 	ldw	r2,0(r2)
80108f48:	e0fffe17 	ldw	r3,-8(fp)
80108f4c:	180d883a 	mov	r6,r3
80108f50:	01402944 	movi	r5,165
80108f54:	1009883a 	mov	r4,r2
80108f58:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108f5c:	e0bfff17 	ldw	r2,-4(fp)
80108f60:	10800017 	ldw	r2,0(r2)
80108f64:	01402984 	movi	r5,166
80108f68:	1009883a 	mov	r4,r2
80108f6c:	010a7080 	call	8010a708 <uliRmapReadReg>
80108f70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
80108f74:	e0bffe17 	ldw	r2,-8(fp)
80108f78:	10bfffec 	andhi	r2,r2,65535
80108f7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
80108f80:	e0bfff17 	ldw	r2,-4(fp)
80108f84:	10802c0b 	ldhu	r2,176(r2)
80108f88:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
80108f8c:	e0bffe17 	ldw	r2,-8(fp)
80108f90:	1884b03a 	or	r2,r3,r2
80108f94:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
80108f98:	e0bffe17 	ldw	r2,-8(fp)
80108f9c:	10bfffcc 	andi	r2,r2,65535
80108fa0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
80108fa4:	e0bfff17 	ldw	r2,-4(fp)
80108fa8:	10802c8b 	ldhu	r2,178(r2)
80108fac:	10bfffcc 	andi	r2,r2,65535
80108fb0:	1004943a 	slli	r2,r2,16
80108fb4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
80108fb8:	e0bffe17 	ldw	r2,-8(fp)
80108fbc:	1884b03a 	or	r2,r3,r2
80108fc0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
80108fc4:	e0bfff17 	ldw	r2,-4(fp)
80108fc8:	10800017 	ldw	r2,0(r2)
80108fcc:	e0fffe17 	ldw	r3,-8(fp)
80108fd0:	180d883a 	mov	r6,r3
80108fd4:	01402984 	movi	r5,166
80108fd8:	1009883a 	mov	r4,r2
80108fdc:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80108fe0:	e0bfff17 	ldw	r2,-4(fp)
80108fe4:	10800017 	ldw	r2,0(r2)
80108fe8:	014029c4 	movi	r5,167
80108fec:	1009883a 	mov	r4,r2
80108ff0:	010a7080 	call	8010a708 <uliRmapReadReg>
80108ff4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
80108ff8:	e0bffe17 	ldw	r2,-8(fp)
80108ffc:	10bfffec 	andhi	r2,r2,65535
80109000:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
80109004:	e0bfff17 	ldw	r2,-4(fp)
80109008:	10802d0b 	ldhu	r2,180(r2)
8010900c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
80109010:	e0bffe17 	ldw	r2,-8(fp)
80109014:	1884b03a 	or	r2,r3,r2
80109018:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
8010901c:	e0bffe17 	ldw	r2,-8(fp)
80109020:	10bfffcc 	andi	r2,r2,65535
80109024:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
80109028:	e0bfff17 	ldw	r2,-4(fp)
8010902c:	10802d8b 	ldhu	r2,182(r2)
80109030:	10bfffcc 	andi	r2,r2,65535
80109034:	1004943a 	slli	r2,r2,16
80109038:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
8010903c:	e0bffe17 	ldw	r2,-8(fp)
80109040:	1884b03a 	or	r2,r3,r2
80109044:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
80109048:	e0bfff17 	ldw	r2,-4(fp)
8010904c:	10800017 	ldw	r2,0(r2)
80109050:	e0fffe17 	ldw	r3,-8(fp)
80109054:	180d883a 	mov	r6,r3
80109058:	014029c4 	movi	r5,167
8010905c:	1009883a 	mov	r4,r2
80109060:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109064:	e0bfff17 	ldw	r2,-4(fp)
80109068:	10800017 	ldw	r2,0(r2)
8010906c:	01402a04 	movi	r5,168
80109070:	1009883a 	mov	r4,r2
80109074:	010a7080 	call	8010a708 <uliRmapReadReg>
80109078:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
8010907c:	e0bffe17 	ldw	r2,-8(fp)
80109080:	10bfffec 	andhi	r2,r2,65535
80109084:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
80109088:	e0bfff17 	ldw	r2,-4(fp)
8010908c:	10802e0b 	ldhu	r2,184(r2)
80109090:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
80109094:	e0bffe17 	ldw	r2,-8(fp)
80109098:	1884b03a 	or	r2,r3,r2
8010909c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
801090a0:	e0bffe17 	ldw	r2,-8(fp)
801090a4:	10bfffcc 	andi	r2,r2,65535
801090a8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
801090ac:	e0bfff17 	ldw	r2,-4(fp)
801090b0:	10802e8b 	ldhu	r2,186(r2)
801090b4:	10bfffcc 	andi	r2,r2,65535
801090b8:	1004943a 	slli	r2,r2,16
801090bc:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
801090c0:	e0bffe17 	ldw	r2,-8(fp)
801090c4:	1884b03a 	or	r2,r3,r2
801090c8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
801090cc:	e0bfff17 	ldw	r2,-4(fp)
801090d0:	10800017 	ldw	r2,0(r2)
801090d4:	e0fffe17 	ldw	r3,-8(fp)
801090d8:	180d883a 	mov	r6,r3
801090dc:	01402a04 	movi	r5,168
801090e0:	1009883a 	mov	r4,r2
801090e4:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801090e8:	e0bfff17 	ldw	r2,-4(fp)
801090ec:	10800017 	ldw	r2,0(r2)
801090f0:	01402a44 	movi	r5,169
801090f4:	1009883a 	mov	r4,r2
801090f8:	010a7080 	call	8010a708 <uliRmapReadReg>
801090fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
80109100:	e0bffe17 	ldw	r2,-8(fp)
80109104:	10bfffec 	andhi	r2,r2,65535
80109108:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
8010910c:	e0bfff17 	ldw	r2,-4(fp)
80109110:	10802f0b 	ldhu	r2,188(r2)
80109114:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
80109118:	e0bffe17 	ldw	r2,-8(fp)
8010911c:	1884b03a 	or	r2,r3,r2
80109120:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
80109124:	e0bffe17 	ldw	r2,-8(fp)
80109128:	10bfffcc 	andi	r2,r2,65535
8010912c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
80109130:	e0bfff17 	ldw	r2,-4(fp)
80109134:	10802f8b 	ldhu	r2,190(r2)
80109138:	10bfffcc 	andi	r2,r2,65535
8010913c:	1004943a 	slli	r2,r2,16
80109140:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
80109144:	e0bffe17 	ldw	r2,-8(fp)
80109148:	1884b03a 	or	r2,r3,r2
8010914c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
80109150:	e0bfff17 	ldw	r2,-4(fp)
80109154:	10800017 	ldw	r2,0(r2)
80109158:	e0fffe17 	ldw	r3,-8(fp)
8010915c:	180d883a 	mov	r6,r3
80109160:	01402a44 	movi	r5,169
80109164:	1009883a 	mov	r4,r2
80109168:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010916c:	e0bfff17 	ldw	r2,-4(fp)
80109170:	10800017 	ldw	r2,0(r2)
80109174:	01402a84 	movi	r5,170
80109178:	1009883a 	mov	r4,r2
8010917c:	010a7080 	call	8010a708 <uliRmapReadReg>
80109180:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
80109184:	e0bffe17 	ldw	r2,-8(fp)
80109188:	10bfffec 	andhi	r2,r2,65535
8010918c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
80109190:	e0bfff17 	ldw	r2,-4(fp)
80109194:	1080300b 	ldhu	r2,192(r2)
80109198:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
8010919c:	e0bffe17 	ldw	r2,-8(fp)
801091a0:	1884b03a 	or	r2,r3,r2
801091a4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
801091a8:	e0bffe17 	ldw	r2,-8(fp)
801091ac:	10bfffcc 	andi	r2,r2,65535
801091b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
801091b4:	e0bfff17 	ldw	r2,-4(fp)
801091b8:	1080308b 	ldhu	r2,194(r2)
801091bc:	10bfffcc 	andi	r2,r2,65535
801091c0:	1004943a 	slli	r2,r2,16
801091c4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
801091c8:	e0bffe17 	ldw	r2,-8(fp)
801091cc:	1884b03a 	or	r2,r3,r2
801091d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
801091d4:	e0bfff17 	ldw	r2,-4(fp)
801091d8:	10800017 	ldw	r2,0(r2)
801091dc:	e0fffe17 	ldw	r3,-8(fp)
801091e0:	180d883a 	mov	r6,r3
801091e4:	01402a84 	movi	r5,170
801091e8:	1009883a 	mov	r4,r2
801091ec:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801091f0:	e0bfff17 	ldw	r2,-4(fp)
801091f4:	10800017 	ldw	r2,0(r2)
801091f8:	01402ac4 	movi	r5,171
801091fc:	1009883a 	mov	r4,r2
80109200:	010a7080 	call	8010a708 <uliRmapReadReg>
80109204:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
80109208:	e0bffe17 	ldw	r2,-8(fp)
8010920c:	10bfffec 	andhi	r2,r2,65535
80109210:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
80109214:	e0bfff17 	ldw	r2,-4(fp)
80109218:	1080310b 	ldhu	r2,196(r2)
8010921c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
80109220:	e0bffe17 	ldw	r2,-8(fp)
80109224:	1884b03a 	or	r2,r3,r2
80109228:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
8010922c:	e0bffe17 	ldw	r2,-8(fp)
80109230:	10bfffcc 	andi	r2,r2,65535
80109234:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
80109238:	e0bfff17 	ldw	r2,-4(fp)
8010923c:	1080318b 	ldhu	r2,198(r2)
80109240:	10bfffcc 	andi	r2,r2,65535
80109244:	1004943a 	slli	r2,r2,16
80109248:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
8010924c:	e0bffe17 	ldw	r2,-8(fp)
80109250:	1884b03a 	or	r2,r3,r2
80109254:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
80109258:	e0bfff17 	ldw	r2,-4(fp)
8010925c:	10800017 	ldw	r2,0(r2)
80109260:	e0fffe17 	ldw	r3,-8(fp)
80109264:	180d883a 	mov	r6,r3
80109268:	01402ac4 	movi	r5,171
8010926c:	1009883a 	mov	r4,r2
80109270:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109274:	e0bfff17 	ldw	r2,-4(fp)
80109278:	10800017 	ldw	r2,0(r2)
8010927c:	01402b04 	movi	r5,172
80109280:	1009883a 	mov	r4,r2
80109284:	010a7080 	call	8010a708 <uliRmapReadReg>
80109288:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
8010928c:	e0bffe17 	ldw	r2,-8(fp)
80109290:	10bfffec 	andhi	r2,r2,65535
80109294:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
80109298:	e0bfff17 	ldw	r2,-4(fp)
8010929c:	1080320b 	ldhu	r2,200(r2)
801092a0:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
801092a4:	e0bffe17 	ldw	r2,-8(fp)
801092a8:	1884b03a 	or	r2,r3,r2
801092ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
801092b0:	e0bffe17 	ldw	r2,-8(fp)
801092b4:	10bfffcc 	andi	r2,r2,65535
801092b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
801092bc:	e0bfff17 	ldw	r2,-4(fp)
801092c0:	1080328b 	ldhu	r2,202(r2)
801092c4:	10bfffcc 	andi	r2,r2,65535
801092c8:	1004943a 	slli	r2,r2,16
801092cc:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
801092d0:	e0bffe17 	ldw	r2,-8(fp)
801092d4:	1884b03a 	or	r2,r3,r2
801092d8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
801092dc:	e0bfff17 	ldw	r2,-4(fp)
801092e0:	10800017 	ldw	r2,0(r2)
801092e4:	e0fffe17 	ldw	r3,-8(fp)
801092e8:	180d883a 	mov	r6,r3
801092ec:	01402b04 	movi	r5,172
801092f0:	1009883a 	mov	r4,r2
801092f4:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801092f8:	e0bfff17 	ldw	r2,-4(fp)
801092fc:	10800017 	ldw	r2,0(r2)
80109300:	01402b44 	movi	r5,173
80109304:	1009883a 	mov	r4,r2
80109308:	010a7080 	call	8010a708 <uliRmapReadReg>
8010930c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
80109310:	e0bffe17 	ldw	r2,-8(fp)
80109314:	10bfffec 	andhi	r2,r2,65535
80109318:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
8010931c:	e0bfff17 	ldw	r2,-4(fp)
80109320:	1080330b 	ldhu	r2,204(r2)
80109324:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
80109328:	e0bffe17 	ldw	r2,-8(fp)
8010932c:	1884b03a 	or	r2,r3,r2
80109330:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
80109334:	e0bffe17 	ldw	r2,-8(fp)
80109338:	10bfffcc 	andi	r2,r2,65535
8010933c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
80109340:	e0bfff17 	ldw	r2,-4(fp)
80109344:	1080338b 	ldhu	r2,206(r2)
80109348:	10bfffcc 	andi	r2,r2,65535
8010934c:	1004943a 	slli	r2,r2,16
80109350:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
80109354:	e0bffe17 	ldw	r2,-8(fp)
80109358:	1884b03a 	or	r2,r3,r2
8010935c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
80109360:	e0bfff17 	ldw	r2,-4(fp)
80109364:	10800017 	ldw	r2,0(r2)
80109368:	e0fffe17 	ldw	r3,-8(fp)
8010936c:	180d883a 	mov	r6,r3
80109370:	01402b44 	movi	r5,173
80109374:	1009883a 	mov	r4,r2
80109378:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010937c:	e0bfff17 	ldw	r2,-4(fp)
80109380:	10800017 	ldw	r2,0(r2)
80109384:	01402b84 	movi	r5,174
80109388:	1009883a 	mov	r4,r2
8010938c:	010a7080 	call	8010a708 <uliRmapReadReg>
80109390:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
80109394:	e0bffe17 	ldw	r2,-8(fp)
80109398:	10bfffec 	andhi	r2,r2,65535
8010939c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
801093a0:	e0bfff17 	ldw	r2,-4(fp)
801093a4:	1080340b 	ldhu	r2,208(r2)
801093a8:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
801093ac:	e0bffe17 	ldw	r2,-8(fp)
801093b0:	1884b03a 	or	r2,r3,r2
801093b4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
801093b8:	e0bffe17 	ldw	r2,-8(fp)
801093bc:	10bfffcc 	andi	r2,r2,65535
801093c0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
801093c4:	e0bfff17 	ldw	r2,-4(fp)
801093c8:	1080348b 	ldhu	r2,210(r2)
801093cc:	10bfffcc 	andi	r2,r2,65535
801093d0:	1004943a 	slli	r2,r2,16
801093d4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
801093d8:	e0bffe17 	ldw	r2,-8(fp)
801093dc:	1884b03a 	or	r2,r3,r2
801093e0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
801093e4:	e0bfff17 	ldw	r2,-4(fp)
801093e8:	10800017 	ldw	r2,0(r2)
801093ec:	e0fffe17 	ldw	r3,-8(fp)
801093f0:	180d883a 	mov	r6,r3
801093f4:	01402b84 	movi	r5,174
801093f8:	1009883a 	mov	r4,r2
801093fc:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109400:	e0bfff17 	ldw	r2,-4(fp)
80109404:	10800017 	ldw	r2,0(r2)
80109408:	01402bc4 	movi	r5,175
8010940c:	1009883a 	mov	r4,r2
80109410:	010a7080 	call	8010a708 <uliRmapReadReg>
80109414:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
80109418:	e0bffe17 	ldw	r2,-8(fp)
8010941c:	10bfffec 	andhi	r2,r2,65535
80109420:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
80109424:	e0bfff17 	ldw	r2,-4(fp)
80109428:	1080350b 	ldhu	r2,212(r2)
8010942c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
80109430:	e0bffe17 	ldw	r2,-8(fp)
80109434:	1884b03a 	or	r2,r3,r2
80109438:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
8010943c:	e0bffe17 	ldw	r2,-8(fp)
80109440:	10bfffcc 	andi	r2,r2,65535
80109444:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
80109448:	e0bfff17 	ldw	r2,-4(fp)
8010944c:	1080358b 	ldhu	r2,214(r2)
80109450:	10bfffcc 	andi	r2,r2,65535
80109454:	1004943a 	slli	r2,r2,16
80109458:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
8010945c:	e0bffe17 	ldw	r2,-8(fp)
80109460:	1884b03a 	or	r2,r3,r2
80109464:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
80109468:	e0bfff17 	ldw	r2,-4(fp)
8010946c:	10800017 	ldw	r2,0(r2)
80109470:	e0fffe17 	ldw	r3,-8(fp)
80109474:	180d883a 	mov	r6,r3
80109478:	01402bc4 	movi	r5,175
8010947c:	1009883a 	mov	r4,r2
80109480:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109484:	e0bfff17 	ldw	r2,-4(fp)
80109488:	10800017 	ldw	r2,0(r2)
8010948c:	01402c04 	movi	r5,176
80109490:	1009883a 	mov	r4,r2
80109494:	010a7080 	call	8010a708 <uliRmapReadReg>
80109498:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
8010949c:	e0bffe17 	ldw	r2,-8(fp)
801094a0:	10bfffec 	andhi	r2,r2,65535
801094a4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
801094a8:	e0bfff17 	ldw	r2,-4(fp)
801094ac:	1080360b 	ldhu	r2,216(r2)
801094b0:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
801094b4:	e0bffe17 	ldw	r2,-8(fp)
801094b8:	1884b03a 	or	r2,r3,r2
801094bc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
801094c0:	e0bffe17 	ldw	r2,-8(fp)
801094c4:	10bfffcc 	andi	r2,r2,65535
801094c8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
801094cc:	e0bfff17 	ldw	r2,-4(fp)
801094d0:	1080368b 	ldhu	r2,218(r2)
801094d4:	10bfffcc 	andi	r2,r2,65535
801094d8:	1004943a 	slli	r2,r2,16
801094dc:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
801094e0:	e0bffe17 	ldw	r2,-8(fp)
801094e4:	1884b03a 	or	r2,r3,r2
801094e8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
801094ec:	e0bfff17 	ldw	r2,-4(fp)
801094f0:	10800017 	ldw	r2,0(r2)
801094f4:	e0fffe17 	ldw	r3,-8(fp)
801094f8:	180d883a 	mov	r6,r3
801094fc:	01402c04 	movi	r5,176
80109500:	1009883a 	mov	r4,r2
80109504:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109508:	e0bfff17 	ldw	r2,-4(fp)
8010950c:	10800017 	ldw	r2,0(r2)
80109510:	01402c44 	movi	r5,177
80109514:	1009883a 	mov	r4,r2
80109518:	010a7080 	call	8010a708 <uliRmapReadReg>
8010951c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
80109520:	e0bffe17 	ldw	r2,-8(fp)
80109524:	10bfffec 	andhi	r2,r2,65535
80109528:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
8010952c:	e0bfff17 	ldw	r2,-4(fp)
80109530:	1080370b 	ldhu	r2,220(r2)
80109534:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
80109538:	e0bffe17 	ldw	r2,-8(fp)
8010953c:	1884b03a 	or	r2,r3,r2
80109540:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
80109544:	e0bffe17 	ldw	r2,-8(fp)
80109548:	10bfffcc 	andi	r2,r2,65535
8010954c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
80109550:	e0bfff17 	ldw	r2,-4(fp)
80109554:	1080378b 	ldhu	r2,222(r2)
80109558:	10bfffcc 	andi	r2,r2,65535
8010955c:	1004943a 	slli	r2,r2,16
80109560:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
80109564:	e0bffe17 	ldw	r2,-8(fp)
80109568:	1884b03a 	or	r2,r3,r2
8010956c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
80109570:	e0bfff17 	ldw	r2,-4(fp)
80109574:	10800017 	ldw	r2,0(r2)
80109578:	e0fffe17 	ldw	r3,-8(fp)
8010957c:	180d883a 	mov	r6,r3
80109580:	01402c44 	movi	r5,177
80109584:	1009883a 	mov	r4,r2
80109588:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010958c:	e0bfff17 	ldw	r2,-4(fp)
80109590:	10800017 	ldw	r2,0(r2)
80109594:	01402c84 	movi	r5,178
80109598:	1009883a 	mov	r4,r2
8010959c:	010a7080 	call	8010a708 <uliRmapReadReg>
801095a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
801095a4:	e0bffe17 	ldw	r2,-8(fp)
801095a8:	10bfffec 	andhi	r2,r2,65535
801095ac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
801095b0:	e0bfff17 	ldw	r2,-4(fp)
801095b4:	1080380b 	ldhu	r2,224(r2)
801095b8:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
801095bc:	e0bffe17 	ldw	r2,-8(fp)
801095c0:	1884b03a 	or	r2,r3,r2
801095c4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
801095c8:	e0bffe17 	ldw	r2,-8(fp)
801095cc:	10bfffcc 	andi	r2,r2,65535
801095d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
801095d4:	e0bfff17 	ldw	r2,-4(fp)
801095d8:	1080388b 	ldhu	r2,226(r2)
801095dc:	10bfffcc 	andi	r2,r2,65535
801095e0:	1004943a 	slli	r2,r2,16
801095e4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
801095e8:	e0bffe17 	ldw	r2,-8(fp)
801095ec:	1884b03a 	or	r2,r3,r2
801095f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
801095f4:	e0bfff17 	ldw	r2,-4(fp)
801095f8:	10800017 	ldw	r2,0(r2)
801095fc:	e0fffe17 	ldw	r3,-8(fp)
80109600:	180d883a 	mov	r6,r3
80109604:	01402c84 	movi	r5,178
80109608:	1009883a 	mov	r4,r2
8010960c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109610:	e0bfff17 	ldw	r2,-4(fp)
80109614:	10800017 	ldw	r2,0(r2)
80109618:	01402cc4 	movi	r5,179
8010961c:	1009883a 	mov	r4,r2
80109620:	010a7080 	call	8010a708 <uliRmapReadReg>
80109624:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
80109628:	e0bffe17 	ldw	r2,-8(fp)
8010962c:	10bfffec 	andhi	r2,r2,65535
80109630:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
80109634:	e0bfff17 	ldw	r2,-4(fp)
80109638:	1080390b 	ldhu	r2,228(r2)
8010963c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
80109640:	e0bffe17 	ldw	r2,-8(fp)
80109644:	1884b03a 	or	r2,r3,r2
80109648:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
8010964c:	e0bffe17 	ldw	r2,-8(fp)
80109650:	10bfffcc 	andi	r2,r2,65535
80109654:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
80109658:	e0bfff17 	ldw	r2,-4(fp)
8010965c:	1080398b 	ldhu	r2,230(r2)
80109660:	10bfffcc 	andi	r2,r2,65535
80109664:	1004943a 	slli	r2,r2,16
80109668:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
8010966c:	e0bffe17 	ldw	r2,-8(fp)
80109670:	1884b03a 	or	r2,r3,r2
80109674:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
80109678:	e0bfff17 	ldw	r2,-4(fp)
8010967c:	10800017 	ldw	r2,0(r2)
80109680:	e0fffe17 	ldw	r3,-8(fp)
80109684:	180d883a 	mov	r6,r3
80109688:	01402cc4 	movi	r5,179
8010968c:	1009883a 	mov	r4,r2
80109690:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109694:	e0bfff17 	ldw	r2,-4(fp)
80109698:	10800017 	ldw	r2,0(r2)
8010969c:	01402d04 	movi	r5,180
801096a0:	1009883a 	mov	r4,r2
801096a4:	010a7080 	call	8010a708 <uliRmapReadReg>
801096a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
801096ac:	e0bffe17 	ldw	r2,-8(fp)
801096b0:	10bfffec 	andhi	r2,r2,65535
801096b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
801096b8:	e0bfff17 	ldw	r2,-4(fp)
801096bc:	10803a0b 	ldhu	r2,232(r2)
801096c0:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
801096c4:	e0bffe17 	ldw	r2,-8(fp)
801096c8:	1884b03a 	or	r2,r3,r2
801096cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
801096d0:	e0bffe17 	ldw	r2,-8(fp)
801096d4:	10bfffcc 	andi	r2,r2,65535
801096d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
801096dc:	e0bfff17 	ldw	r2,-4(fp)
801096e0:	10803a8b 	ldhu	r2,234(r2)
801096e4:	10bfffcc 	andi	r2,r2,65535
801096e8:	1004943a 	slli	r2,r2,16
801096ec:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
801096f0:	e0bffe17 	ldw	r2,-8(fp)
801096f4:	1884b03a 	or	r2,r3,r2
801096f8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
801096fc:	e0bfff17 	ldw	r2,-4(fp)
80109700:	10800017 	ldw	r2,0(r2)
80109704:	e0fffe17 	ldw	r3,-8(fp)
80109708:	180d883a 	mov	r6,r3
8010970c:	01402d04 	movi	r5,180
80109710:	1009883a 	mov	r4,r2
80109714:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109718:	e0bfff17 	ldw	r2,-4(fp)
8010971c:	10800017 	ldw	r2,0(r2)
80109720:	01402d44 	movi	r5,181
80109724:	1009883a 	mov	r4,r2
80109728:	010a7080 	call	8010a708 <uliRmapReadReg>
8010972c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
80109730:	e0bffe17 	ldw	r2,-8(fp)
80109734:	10bfffec 	andhi	r2,r2,65535
80109738:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
8010973c:	e0bfff17 	ldw	r2,-4(fp)
80109740:	10803b0b 	ldhu	r2,236(r2)
80109744:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
80109748:	e0bffe17 	ldw	r2,-8(fp)
8010974c:	1884b03a 	or	r2,r3,r2
80109750:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
80109754:	e0bffe17 	ldw	r2,-8(fp)
80109758:	10bfffcc 	andi	r2,r2,65535
8010975c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
80109760:	e0bfff17 	ldw	r2,-4(fp)
80109764:	10803b8b 	ldhu	r2,238(r2)
80109768:	10bfffcc 	andi	r2,r2,65535
8010976c:	1004943a 	slli	r2,r2,16
80109770:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
80109774:	e0bffe17 	ldw	r2,-8(fp)
80109778:	1884b03a 	or	r2,r3,r2
8010977c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
80109780:	e0bfff17 	ldw	r2,-4(fp)
80109784:	10800017 	ldw	r2,0(r2)
80109788:	e0fffe17 	ldw	r3,-8(fp)
8010978c:	180d883a 	mov	r6,r3
80109790:	01402d44 	movi	r5,181
80109794:	1009883a 	mov	r4,r2
80109798:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010979c:	e0bfff17 	ldw	r2,-4(fp)
801097a0:	10800017 	ldw	r2,0(r2)
801097a4:	01402d84 	movi	r5,182
801097a8:	1009883a 	mov	r4,r2
801097ac:	010a7080 	call	8010a708 <uliRmapReadReg>
801097b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
801097b4:	e0bffe17 	ldw	r2,-8(fp)
801097b8:	10bfffec 	andhi	r2,r2,65535
801097bc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
801097c0:	e0bfff17 	ldw	r2,-4(fp)
801097c4:	10803c0b 	ldhu	r2,240(r2)
801097c8:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
801097cc:	e0bffe17 	ldw	r2,-8(fp)
801097d0:	1884b03a 	or	r2,r3,r2
801097d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
801097d8:	e0bffe17 	ldw	r2,-8(fp)
801097dc:	10bfffcc 	andi	r2,r2,65535
801097e0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
801097e4:	e0bfff17 	ldw	r2,-4(fp)
801097e8:	10803c8b 	ldhu	r2,242(r2)
801097ec:	10bfffcc 	andi	r2,r2,65535
801097f0:	1004943a 	slli	r2,r2,16
801097f4:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
801097f8:	e0bffe17 	ldw	r2,-8(fp)
801097fc:	1884b03a 	or	r2,r3,r2
80109800:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
80109804:	e0bfff17 	ldw	r2,-4(fp)
80109808:	10800017 	ldw	r2,0(r2)
8010980c:	e0fffe17 	ldw	r3,-8(fp)
80109810:	180d883a 	mov	r6,r3
80109814:	01402d84 	movi	r5,182
80109818:	1009883a 	mov	r4,r2
8010981c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109820:	e0bfff17 	ldw	r2,-4(fp)
80109824:	10800017 	ldw	r2,0(r2)
80109828:	01402dc4 	movi	r5,183
8010982c:	1009883a 	mov	r4,r2
80109830:	010a7080 	call	8010a708 <uliRmapReadReg>
80109834:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
80109838:	e0bffe17 	ldw	r2,-8(fp)
8010983c:	10bfffec 	andhi	r2,r2,65535
80109840:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
80109844:	e0bfff17 	ldw	r2,-4(fp)
80109848:	10803d0b 	ldhu	r2,244(r2)
8010984c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
80109850:	e0bffe17 	ldw	r2,-8(fp)
80109854:	1884b03a 	or	r2,r3,r2
80109858:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
8010985c:	e0bffe17 	ldw	r2,-8(fp)
80109860:	10bfffcc 	andi	r2,r2,65535
80109864:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
80109868:	e0bfff17 	ldw	r2,-4(fp)
8010986c:	10803d8b 	ldhu	r2,246(r2)
80109870:	10bfffcc 	andi	r2,r2,65535
80109874:	1004943a 	slli	r2,r2,16
80109878:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
8010987c:	e0bffe17 	ldw	r2,-8(fp)
80109880:	1884b03a 	or	r2,r3,r2
80109884:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
80109888:	e0bfff17 	ldw	r2,-4(fp)
8010988c:	10800017 	ldw	r2,0(r2)
80109890:	e0fffe17 	ldw	r3,-8(fp)
80109894:	180d883a 	mov	r6,r3
80109898:	01402dc4 	movi	r5,183
8010989c:	1009883a 	mov	r4,r2
801098a0:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801098a4:	e0bfff17 	ldw	r2,-4(fp)
801098a8:	10800017 	ldw	r2,0(r2)
801098ac:	01402e04 	movi	r5,184
801098b0:	1009883a 	mov	r4,r2
801098b4:	010a7080 	call	8010a708 <uliRmapReadReg>
801098b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
801098bc:	e0bffe17 	ldw	r2,-8(fp)
801098c0:	10bfffec 	andhi	r2,r2,65535
801098c4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
801098c8:	e0bfff17 	ldw	r2,-4(fp)
801098cc:	10803e0b 	ldhu	r2,248(r2)
801098d0:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
801098d4:	e0bffe17 	ldw	r2,-8(fp)
801098d8:	1884b03a 	or	r2,r3,r2
801098dc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
801098e0:	e0bffe17 	ldw	r2,-8(fp)
801098e4:	10bfffcc 	andi	r2,r2,65535
801098e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
801098ec:	e0bfff17 	ldw	r2,-4(fp)
801098f0:	10803e8b 	ldhu	r2,250(r2)
801098f4:	10bfffcc 	andi	r2,r2,65535
801098f8:	1004943a 	slli	r2,r2,16
801098fc:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
80109900:	e0bffe17 	ldw	r2,-8(fp)
80109904:	1884b03a 	or	r2,r3,r2
80109908:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
8010990c:	e0bfff17 	ldw	r2,-4(fp)
80109910:	10800017 	ldw	r2,0(r2)
80109914:	e0fffe17 	ldw	r3,-8(fp)
80109918:	180d883a 	mov	r6,r3
8010991c:	01402e04 	movi	r5,184
80109920:	1009883a 	mov	r4,r2
80109924:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109928:	e0bfff17 	ldw	r2,-4(fp)
8010992c:	10800017 	ldw	r2,0(r2)
80109930:	01402e44 	movi	r5,185
80109934:	1009883a 	mov	r4,r2
80109938:	010a7080 	call	8010a708 <uliRmapReadReg>
8010993c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
80109940:	e0bffe17 	ldw	r2,-8(fp)
80109944:	10bfffec 	andhi	r2,r2,65535
80109948:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
8010994c:	e0bfff17 	ldw	r2,-4(fp)
80109950:	10803f0b 	ldhu	r2,252(r2)
80109954:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
80109958:	e0bffe17 	ldw	r2,-8(fp)
8010995c:	1884b03a 	or	r2,r3,r2
80109960:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
80109964:	e0bffe17 	ldw	r2,-8(fp)
80109968:	10bfffcc 	andi	r2,r2,65535
8010996c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
80109970:	e0bfff17 	ldw	r2,-4(fp)
80109974:	10803f8b 	ldhu	r2,254(r2)
80109978:	10bfffcc 	andi	r2,r2,65535
8010997c:	1004943a 	slli	r2,r2,16
80109980:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
80109984:	e0bffe17 	ldw	r2,-8(fp)
80109988:	1884b03a 	or	r2,r3,r2
8010998c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
80109990:	e0bfff17 	ldw	r2,-4(fp)
80109994:	10800017 	ldw	r2,0(r2)
80109998:	e0fffe17 	ldw	r3,-8(fp)
8010999c:	180d883a 	mov	r6,r3
801099a0:	01402e44 	movi	r5,185
801099a4:	1009883a 	mov	r4,r2
801099a8:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
801099ac:	e0bfff17 	ldw	r2,-4(fp)
801099b0:	10800017 	ldw	r2,0(r2)
801099b4:	01402e84 	movi	r5,186
801099b8:	1009883a 	mov	r4,r2
801099bc:	010a7080 	call	8010a708 <uliRmapReadReg>
801099c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
801099c4:	e0bffe17 	ldw	r2,-8(fp)
801099c8:	10bfffec 	andhi	r2,r2,65535
801099cc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
801099d0:	e0bfff17 	ldw	r2,-4(fp)
801099d4:	1080400b 	ldhu	r2,256(r2)
801099d8:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
801099dc:	e0bffe17 	ldw	r2,-8(fp)
801099e0:	1884b03a 	or	r2,r3,r2
801099e4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
801099e8:	e0bffe17 	ldw	r2,-8(fp)
801099ec:	10bfffcc 	andi	r2,r2,65535
801099f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
801099f4:	e0bfff17 	ldw	r2,-4(fp)
801099f8:	1080408b 	ldhu	r2,258(r2)
801099fc:	10bfffcc 	andi	r2,r2,65535
80109a00:	1004943a 	slli	r2,r2,16
80109a04:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
80109a08:	e0bffe17 	ldw	r2,-8(fp)
80109a0c:	1884b03a 	or	r2,r3,r2
80109a10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
80109a14:	e0bfff17 	ldw	r2,-4(fp)
80109a18:	10800017 	ldw	r2,0(r2)
80109a1c:	e0fffe17 	ldw	r3,-8(fp)
80109a20:	180d883a 	mov	r6,r3
80109a24:	01402e84 	movi	r5,186
80109a28:	1009883a 	mov	r4,r2
80109a2c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109a30:	e0bfff17 	ldw	r2,-4(fp)
80109a34:	10800017 	ldw	r2,0(r2)
80109a38:	01402ec4 	movi	r5,187
80109a3c:	1009883a 	mov	r4,r2
80109a40:	010a7080 	call	8010a708 <uliRmapReadReg>
80109a44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
80109a48:	e0bffe17 	ldw	r2,-8(fp)
80109a4c:	10bfffec 	andhi	r2,r2,65535
80109a50:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
80109a54:	e0bfff17 	ldw	r2,-4(fp)
80109a58:	1080410b 	ldhu	r2,260(r2)
80109a5c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
80109a60:	e0bffe17 	ldw	r2,-8(fp)
80109a64:	1884b03a 	or	r2,r3,r2
80109a68:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
80109a6c:	e0bffe17 	ldw	r2,-8(fp)
80109a70:	10bfffcc 	andi	r2,r2,65535
80109a74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
80109a78:	e0bfff17 	ldw	r2,-4(fp)
80109a7c:	1080418b 	ldhu	r2,262(r2)
80109a80:	10bfffcc 	andi	r2,r2,65535
80109a84:	1004943a 	slli	r2,r2,16
80109a88:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
80109a8c:	e0bffe17 	ldw	r2,-8(fp)
80109a90:	1884b03a 	or	r2,r3,r2
80109a94:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
80109a98:	e0bfff17 	ldw	r2,-4(fp)
80109a9c:	10800017 	ldw	r2,0(r2)
80109aa0:	e0fffe17 	ldw	r3,-8(fp)
80109aa4:	180d883a 	mov	r6,r3
80109aa8:	01402ec4 	movi	r5,187
80109aac:	1009883a 	mov	r4,r2
80109ab0:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109ab4:	e0bfff17 	ldw	r2,-4(fp)
80109ab8:	10800017 	ldw	r2,0(r2)
80109abc:	01402f04 	movi	r5,188
80109ac0:	1009883a 	mov	r4,r2
80109ac4:	010a7080 	call	8010a708 <uliRmapReadReg>
80109ac8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
80109acc:	e0bffe17 	ldw	r2,-8(fp)
80109ad0:	10bfffec 	andhi	r2,r2,65535
80109ad4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
80109ad8:	e0bfff17 	ldw	r2,-4(fp)
80109adc:	1080420b 	ldhu	r2,264(r2)
80109ae0:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
80109ae4:	e0bffe17 	ldw	r2,-8(fp)
80109ae8:	1884b03a 	or	r2,r3,r2
80109aec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
80109af0:	e0bffe17 	ldw	r2,-8(fp)
80109af4:	10bfffcc 	andi	r2,r2,65535
80109af8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
80109afc:	e0bfff17 	ldw	r2,-4(fp)
80109b00:	1080428b 	ldhu	r2,266(r2)
80109b04:	10bfffcc 	andi	r2,r2,65535
80109b08:	1004943a 	slli	r2,r2,16
80109b0c:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
80109b10:	e0bffe17 	ldw	r2,-8(fp)
80109b14:	1884b03a 	or	r2,r3,r2
80109b18:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
80109b1c:	e0bfff17 	ldw	r2,-4(fp)
80109b20:	10800017 	ldw	r2,0(r2)
80109b24:	e0fffe17 	ldw	r3,-8(fp)
80109b28:	180d883a 	mov	r6,r3
80109b2c:	01402f04 	movi	r5,188
80109b30:	1009883a 	mov	r4,r2
80109b34:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109b38:	e0bfff17 	ldw	r2,-4(fp)
80109b3c:	10800017 	ldw	r2,0(r2)
80109b40:	01402f44 	movi	r5,189
80109b44:	1009883a 	mov	r4,r2
80109b48:	010a7080 	call	8010a708 <uliRmapReadReg>
80109b4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
80109b50:	e0bffe17 	ldw	r2,-8(fp)
80109b54:	10bfffec 	andhi	r2,r2,65535
80109b58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
80109b5c:	e0bfff17 	ldw	r2,-4(fp)
80109b60:	1080430b 	ldhu	r2,268(r2)
80109b64:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
80109b68:	e0bffe17 	ldw	r2,-8(fp)
80109b6c:	1884b03a 	or	r2,r3,r2
80109b70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
80109b74:	e0bffe17 	ldw	r2,-8(fp)
80109b78:	10bfffcc 	andi	r2,r2,65535
80109b7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
80109b80:	e0bfff17 	ldw	r2,-4(fp)
80109b84:	1080438b 	ldhu	r2,270(r2)
80109b88:	10bfffcc 	andi	r2,r2,65535
80109b8c:	1004943a 	slli	r2,r2,16
80109b90:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
80109b94:	e0bffe17 	ldw	r2,-8(fp)
80109b98:	1884b03a 	or	r2,r3,r2
80109b9c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
80109ba0:	e0bfff17 	ldw	r2,-4(fp)
80109ba4:	10800017 	ldw	r2,0(r2)
80109ba8:	e0fffe17 	ldw	r3,-8(fp)
80109bac:	180d883a 	mov	r6,r3
80109bb0:	01402f44 	movi	r5,189
80109bb4:	1009883a 	mov	r4,r2
80109bb8:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109bbc:	e0bfff17 	ldw	r2,-4(fp)
80109bc0:	10800017 	ldw	r2,0(r2)
80109bc4:	01402f84 	movi	r5,190
80109bc8:	1009883a 	mov	r4,r2
80109bcc:	010a7080 	call	8010a708 <uliRmapReadReg>
80109bd0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
80109bd4:	e0bffe17 	ldw	r2,-8(fp)
80109bd8:	10bfffec 	andhi	r2,r2,65535
80109bdc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
80109be0:	e0bfff17 	ldw	r2,-4(fp)
80109be4:	1080440b 	ldhu	r2,272(r2)
80109be8:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
80109bec:	e0bffe17 	ldw	r2,-8(fp)
80109bf0:	1884b03a 	or	r2,r3,r2
80109bf4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
80109bf8:	e0bffe17 	ldw	r2,-8(fp)
80109bfc:	10bfffcc 	andi	r2,r2,65535
80109c00:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
80109c04:	e0bfff17 	ldw	r2,-4(fp)
80109c08:	1080448b 	ldhu	r2,274(r2)
80109c0c:	10bfffcc 	andi	r2,r2,65535
80109c10:	1004943a 	slli	r2,r2,16
80109c14:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
80109c18:	e0bffe17 	ldw	r2,-8(fp)
80109c1c:	1884b03a 	or	r2,r3,r2
80109c20:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
80109c24:	e0bfff17 	ldw	r2,-4(fp)
80109c28:	10800017 	ldw	r2,0(r2)
80109c2c:	e0fffe17 	ldw	r3,-8(fp)
80109c30:	180d883a 	mov	r6,r3
80109c34:	01402f84 	movi	r5,190
80109c38:	1009883a 	mov	r4,r2
80109c3c:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109c40:	e0bfff17 	ldw	r2,-4(fp)
80109c44:	10800017 	ldw	r2,0(r2)
80109c48:	01402fc4 	movi	r5,191
80109c4c:	1009883a 	mov	r4,r2
80109c50:	010a7080 	call	8010a708 <uliRmapReadReg>
80109c54:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
80109c58:	e0bffe17 	ldw	r2,-8(fp)
80109c5c:	10bfffec 	andhi	r2,r2,65535
80109c60:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
80109c64:	e0bfff17 	ldw	r2,-4(fp)
80109c68:	1080450b 	ldhu	r2,276(r2)
80109c6c:	10ffffcc 	andi	r3,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
80109c70:	e0bffe17 	ldw	r2,-8(fp)
80109c74:	1884b03a 	or	r2,r3,r2
80109c78:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
80109c7c:	e0bffe17 	ldw	r2,-8(fp)
80109c80:	10bfffcc 	andi	r2,r2,65535
80109c84:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
80109c88:	e0bfff17 	ldw	r2,-4(fp)
80109c8c:	1080458b 	ldhu	r2,278(r2)
80109c90:	10bfffcc 	andi	r2,r2,65535
80109c94:	1004943a 	slli	r2,r2,16
80109c98:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
80109c9c:	e0bffe17 	ldw	r2,-8(fp)
80109ca0:	1884b03a 	or	r2,r3,r2
80109ca4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
80109ca8:	e0bfff17 	ldw	r2,-4(fp)
80109cac:	10800017 	ldw	r2,0(r2)
80109cb0:	e0fffe17 	ldw	r3,-8(fp)
80109cb4:	180d883a 	mov	r6,r3
80109cb8:	01402fc4 	movi	r5,191
80109cbc:	1009883a 	mov	r4,r2
80109cc0:	010a6b40 	call	8010a6b4 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
80109cc4:	00800044 	movi	r2,1
80109cc8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
80109ccc:	e0bffd17 	ldw	r2,-12(fp)
}
80109cd0:	e037883a 	mov	sp,fp
80109cd4:	dfc00117 	ldw	ra,4(sp)
80109cd8:	df000017 	ldw	fp,0(sp)
80109cdc:	dec00204 	addi	sp,sp,8
80109ce0:	f800283a 	ret

80109ce4 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
80109ce4:	defffb04 	addi	sp,sp,-20
80109ce8:	de00012e 	bgeu	sp,et,80109cf0 <bRmapGetRmapMemHKArea+0xc>
80109cec:	003b68fa 	trap	3
80109cf0:	dfc00415 	stw	ra,16(sp)
80109cf4:	df000315 	stw	fp,12(sp)
80109cf8:	df000304 	addi	fp,sp,12
80109cfc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
80109d00:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
80109d04:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
80109d08:	e0bfff17 	ldw	r2,-4(fp)
80109d0c:	1001e226 	beq	r2,zero,8010a498 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109d10:	e0bfff17 	ldw	r2,-4(fp)
80109d14:	10800017 	ldw	r2,0(r2)
80109d18:	01402804 	movi	r5,160
80109d1c:	1009883a 	mov	r4,r2
80109d20:	010a7080 	call	8010a708 <uliRmapReadReg>
80109d24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
80109d28:	e0bffe17 	ldw	r2,-8(fp)
80109d2c:	1007883a 	mov	r3,r2
80109d30:	e0bfff17 	ldw	r2,-4(fp)
80109d34:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
80109d38:	e0bffe17 	ldw	r2,-8(fp)
80109d3c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
80109d40:	1007883a 	mov	r3,r2
80109d44:	e0bfff17 	ldw	r2,-4(fp)
80109d48:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109d4c:	e0bfff17 	ldw	r2,-4(fp)
80109d50:	10800017 	ldw	r2,0(r2)
80109d54:	01402844 	movi	r5,161
80109d58:	1009883a 	mov	r4,r2
80109d5c:	010a7080 	call	8010a708 <uliRmapReadReg>
80109d60:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
80109d64:	e0bffe17 	ldw	r2,-8(fp)
80109d68:	1007883a 	mov	r3,r2
80109d6c:	e0bfff17 	ldw	r2,-4(fp)
80109d70:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
80109d74:	e0bffe17 	ldw	r2,-8(fp)
80109d78:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
80109d7c:	1007883a 	mov	r3,r2
80109d80:	e0bfff17 	ldw	r2,-4(fp)
80109d84:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109d88:	e0bfff17 	ldw	r2,-4(fp)
80109d8c:	10800017 	ldw	r2,0(r2)
80109d90:	01402884 	movi	r5,162
80109d94:	1009883a 	mov	r4,r2
80109d98:	010a7080 	call	8010a708 <uliRmapReadReg>
80109d9c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
80109da0:	e0bffe17 	ldw	r2,-8(fp)
80109da4:	1007883a 	mov	r3,r2
80109da8:	e0bfff17 	ldw	r2,-4(fp)
80109dac:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
80109db0:	e0bffe17 	ldw	r2,-8(fp)
80109db4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
80109db8:	1007883a 	mov	r3,r2
80109dbc:	e0bfff17 	ldw	r2,-4(fp)
80109dc0:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109dc4:	e0bfff17 	ldw	r2,-4(fp)
80109dc8:	10800017 	ldw	r2,0(r2)
80109dcc:	014028c4 	movi	r5,163
80109dd0:	1009883a 	mov	r4,r2
80109dd4:	010a7080 	call	8010a708 <uliRmapReadReg>
80109dd8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
80109ddc:	e0bffe17 	ldw	r2,-8(fp)
80109de0:	1007883a 	mov	r3,r2
80109de4:	e0bfff17 	ldw	r2,-4(fp)
80109de8:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
80109dec:	e0bffe17 	ldw	r2,-8(fp)
80109df0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
80109df4:	1007883a 	mov	r3,r2
80109df8:	e0bfff17 	ldw	r2,-4(fp)
80109dfc:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109e00:	e0bfff17 	ldw	r2,-4(fp)
80109e04:	10800017 	ldw	r2,0(r2)
80109e08:	01402904 	movi	r5,164
80109e0c:	1009883a 	mov	r4,r2
80109e10:	010a7080 	call	8010a708 <uliRmapReadReg>
80109e14:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
80109e18:	e0bffe17 	ldw	r2,-8(fp)
80109e1c:	1007883a 	mov	r3,r2
80109e20:	e0bfff17 	ldw	r2,-4(fp)
80109e24:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
80109e28:	e0bffe17 	ldw	r2,-8(fp)
80109e2c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
80109e30:	1007883a 	mov	r3,r2
80109e34:	e0bfff17 	ldw	r2,-4(fp)
80109e38:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109e3c:	e0bfff17 	ldw	r2,-4(fp)
80109e40:	10800017 	ldw	r2,0(r2)
80109e44:	01402944 	movi	r5,165
80109e48:	1009883a 	mov	r4,r2
80109e4c:	010a7080 	call	8010a708 <uliRmapReadReg>
80109e50:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
80109e54:	e0bffe17 	ldw	r2,-8(fp)
80109e58:	1007883a 	mov	r3,r2
80109e5c:	e0bfff17 	ldw	r2,-4(fp)
80109e60:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
80109e64:	e0bffe17 	ldw	r2,-8(fp)
80109e68:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
80109e6c:	1007883a 	mov	r3,r2
80109e70:	e0bfff17 	ldw	r2,-4(fp)
80109e74:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109e78:	e0bfff17 	ldw	r2,-4(fp)
80109e7c:	10800017 	ldw	r2,0(r2)
80109e80:	01402984 	movi	r5,166
80109e84:	1009883a 	mov	r4,r2
80109e88:	010a7080 	call	8010a708 <uliRmapReadReg>
80109e8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
80109e90:	e0bffe17 	ldw	r2,-8(fp)
80109e94:	1007883a 	mov	r3,r2
80109e98:	e0bfff17 	ldw	r2,-4(fp)
80109e9c:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
80109ea0:	e0bffe17 	ldw	r2,-8(fp)
80109ea4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
80109ea8:	1007883a 	mov	r3,r2
80109eac:	e0bfff17 	ldw	r2,-4(fp)
80109eb0:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109eb4:	e0bfff17 	ldw	r2,-4(fp)
80109eb8:	10800017 	ldw	r2,0(r2)
80109ebc:	014029c4 	movi	r5,167
80109ec0:	1009883a 	mov	r4,r2
80109ec4:	010a7080 	call	8010a708 <uliRmapReadReg>
80109ec8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
80109ecc:	e0bffe17 	ldw	r2,-8(fp)
80109ed0:	1007883a 	mov	r3,r2
80109ed4:	e0bfff17 	ldw	r2,-4(fp)
80109ed8:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
80109edc:	e0bffe17 	ldw	r2,-8(fp)
80109ee0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
80109ee4:	1007883a 	mov	r3,r2
80109ee8:	e0bfff17 	ldw	r2,-4(fp)
80109eec:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109ef0:	e0bfff17 	ldw	r2,-4(fp)
80109ef4:	10800017 	ldw	r2,0(r2)
80109ef8:	01402a04 	movi	r5,168
80109efc:	1009883a 	mov	r4,r2
80109f00:	010a7080 	call	8010a708 <uliRmapReadReg>
80109f04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
80109f08:	e0bffe17 	ldw	r2,-8(fp)
80109f0c:	1007883a 	mov	r3,r2
80109f10:	e0bfff17 	ldw	r2,-4(fp)
80109f14:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
80109f18:	e0bffe17 	ldw	r2,-8(fp)
80109f1c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
80109f20:	1007883a 	mov	r3,r2
80109f24:	e0bfff17 	ldw	r2,-4(fp)
80109f28:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109f2c:	e0bfff17 	ldw	r2,-4(fp)
80109f30:	10800017 	ldw	r2,0(r2)
80109f34:	01402a44 	movi	r5,169
80109f38:	1009883a 	mov	r4,r2
80109f3c:	010a7080 	call	8010a708 <uliRmapReadReg>
80109f40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
80109f44:	e0bffe17 	ldw	r2,-8(fp)
80109f48:	1007883a 	mov	r3,r2
80109f4c:	e0bfff17 	ldw	r2,-4(fp)
80109f50:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
80109f54:	e0bffe17 	ldw	r2,-8(fp)
80109f58:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
80109f5c:	1007883a 	mov	r3,r2
80109f60:	e0bfff17 	ldw	r2,-4(fp)
80109f64:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109f68:	e0bfff17 	ldw	r2,-4(fp)
80109f6c:	10800017 	ldw	r2,0(r2)
80109f70:	01402a84 	movi	r5,170
80109f74:	1009883a 	mov	r4,r2
80109f78:	010a7080 	call	8010a708 <uliRmapReadReg>
80109f7c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
80109f80:	e0bffe17 	ldw	r2,-8(fp)
80109f84:	1007883a 	mov	r3,r2
80109f88:	e0bfff17 	ldw	r2,-4(fp)
80109f8c:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
80109f90:	e0bffe17 	ldw	r2,-8(fp)
80109f94:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
80109f98:	1007883a 	mov	r3,r2
80109f9c:	e0bfff17 	ldw	r2,-4(fp)
80109fa0:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109fa4:	e0bfff17 	ldw	r2,-4(fp)
80109fa8:	10800017 	ldw	r2,0(r2)
80109fac:	01402ac4 	movi	r5,171
80109fb0:	1009883a 	mov	r4,r2
80109fb4:	010a7080 	call	8010a708 <uliRmapReadReg>
80109fb8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
80109fbc:	e0bffe17 	ldw	r2,-8(fp)
80109fc0:	1007883a 	mov	r3,r2
80109fc4:	e0bfff17 	ldw	r2,-4(fp)
80109fc8:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
80109fcc:	e0bffe17 	ldw	r2,-8(fp)
80109fd0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
80109fd4:	1007883a 	mov	r3,r2
80109fd8:	e0bfff17 	ldw	r2,-4(fp)
80109fdc:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
80109fe0:	e0bfff17 	ldw	r2,-4(fp)
80109fe4:	10800017 	ldw	r2,0(r2)
80109fe8:	01402b04 	movi	r5,172
80109fec:	1009883a 	mov	r4,r2
80109ff0:	010a7080 	call	8010a708 <uliRmapReadReg>
80109ff4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
80109ff8:	e0bffe17 	ldw	r2,-8(fp)
80109ffc:	1007883a 	mov	r3,r2
8010a000:	e0bfff17 	ldw	r2,-4(fp)
8010a004:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
8010a008:	e0bffe17 	ldw	r2,-8(fp)
8010a00c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
8010a010:	1007883a 	mov	r3,r2
8010a014:	e0bfff17 	ldw	r2,-4(fp)
8010a018:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a01c:	e0bfff17 	ldw	r2,-4(fp)
8010a020:	10800017 	ldw	r2,0(r2)
8010a024:	01402b44 	movi	r5,173
8010a028:	1009883a 	mov	r4,r2
8010a02c:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a030:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
8010a034:	e0bffe17 	ldw	r2,-8(fp)
8010a038:	1007883a 	mov	r3,r2
8010a03c:	e0bfff17 	ldw	r2,-4(fp)
8010a040:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
8010a044:	e0bffe17 	ldw	r2,-8(fp)
8010a048:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
8010a04c:	1007883a 	mov	r3,r2
8010a050:	e0bfff17 	ldw	r2,-4(fp)
8010a054:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a058:	e0bfff17 	ldw	r2,-4(fp)
8010a05c:	10800017 	ldw	r2,0(r2)
8010a060:	01402b84 	movi	r5,174
8010a064:	1009883a 	mov	r4,r2
8010a068:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a06c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
8010a070:	e0bffe17 	ldw	r2,-8(fp)
8010a074:	1007883a 	mov	r3,r2
8010a078:	e0bfff17 	ldw	r2,-4(fp)
8010a07c:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
8010a080:	e0bffe17 	ldw	r2,-8(fp)
8010a084:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
8010a088:	1007883a 	mov	r3,r2
8010a08c:	e0bfff17 	ldw	r2,-4(fp)
8010a090:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a094:	e0bfff17 	ldw	r2,-4(fp)
8010a098:	10800017 	ldw	r2,0(r2)
8010a09c:	01402bc4 	movi	r5,175
8010a0a0:	1009883a 	mov	r4,r2
8010a0a4:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a0a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
8010a0ac:	e0bffe17 	ldw	r2,-8(fp)
8010a0b0:	1007883a 	mov	r3,r2
8010a0b4:	e0bfff17 	ldw	r2,-4(fp)
8010a0b8:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
8010a0bc:	e0bffe17 	ldw	r2,-8(fp)
8010a0c0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
8010a0c4:	1007883a 	mov	r3,r2
8010a0c8:	e0bfff17 	ldw	r2,-4(fp)
8010a0cc:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a0d0:	e0bfff17 	ldw	r2,-4(fp)
8010a0d4:	10800017 	ldw	r2,0(r2)
8010a0d8:	01402c04 	movi	r5,176
8010a0dc:	1009883a 	mov	r4,r2
8010a0e0:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a0e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
8010a0e8:	e0bffe17 	ldw	r2,-8(fp)
8010a0ec:	1007883a 	mov	r3,r2
8010a0f0:	e0bfff17 	ldw	r2,-4(fp)
8010a0f4:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
8010a0f8:	e0bffe17 	ldw	r2,-8(fp)
8010a0fc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
8010a100:	1007883a 	mov	r3,r2
8010a104:	e0bfff17 	ldw	r2,-4(fp)
8010a108:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a10c:	e0bfff17 	ldw	r2,-4(fp)
8010a110:	10800017 	ldw	r2,0(r2)
8010a114:	01402c44 	movi	r5,177
8010a118:	1009883a 	mov	r4,r2
8010a11c:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a120:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
8010a124:	e0bffe17 	ldw	r2,-8(fp)
8010a128:	1007883a 	mov	r3,r2
8010a12c:	e0bfff17 	ldw	r2,-4(fp)
8010a130:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
8010a134:	e0bffe17 	ldw	r2,-8(fp)
8010a138:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
8010a13c:	1007883a 	mov	r3,r2
8010a140:	e0bfff17 	ldw	r2,-4(fp)
8010a144:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a148:	e0bfff17 	ldw	r2,-4(fp)
8010a14c:	10800017 	ldw	r2,0(r2)
8010a150:	01402c84 	movi	r5,178
8010a154:	1009883a 	mov	r4,r2
8010a158:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a15c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
8010a160:	e0bffe17 	ldw	r2,-8(fp)
8010a164:	1007883a 	mov	r3,r2
8010a168:	e0bfff17 	ldw	r2,-4(fp)
8010a16c:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
8010a170:	e0bffe17 	ldw	r2,-8(fp)
8010a174:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
8010a178:	1007883a 	mov	r3,r2
8010a17c:	e0bfff17 	ldw	r2,-4(fp)
8010a180:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a184:	e0bfff17 	ldw	r2,-4(fp)
8010a188:	10800017 	ldw	r2,0(r2)
8010a18c:	01402cc4 	movi	r5,179
8010a190:	1009883a 	mov	r4,r2
8010a194:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a198:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
8010a19c:	e0bffe17 	ldw	r2,-8(fp)
8010a1a0:	1007883a 	mov	r3,r2
8010a1a4:	e0bfff17 	ldw	r2,-4(fp)
8010a1a8:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
8010a1ac:	e0bffe17 	ldw	r2,-8(fp)
8010a1b0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
8010a1b4:	1007883a 	mov	r3,r2
8010a1b8:	e0bfff17 	ldw	r2,-4(fp)
8010a1bc:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a1c0:	e0bfff17 	ldw	r2,-4(fp)
8010a1c4:	10800017 	ldw	r2,0(r2)
8010a1c8:	01402d04 	movi	r5,180
8010a1cc:	1009883a 	mov	r4,r2
8010a1d0:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a1d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
8010a1d8:	e0bffe17 	ldw	r2,-8(fp)
8010a1dc:	1007883a 	mov	r3,r2
8010a1e0:	e0bfff17 	ldw	r2,-4(fp)
8010a1e4:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
8010a1e8:	e0bffe17 	ldw	r2,-8(fp)
8010a1ec:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
8010a1f0:	1007883a 	mov	r3,r2
8010a1f4:	e0bfff17 	ldw	r2,-4(fp)
8010a1f8:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a1fc:	e0bfff17 	ldw	r2,-4(fp)
8010a200:	10800017 	ldw	r2,0(r2)
8010a204:	01402d44 	movi	r5,181
8010a208:	1009883a 	mov	r4,r2
8010a20c:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a210:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
8010a214:	e0bffe17 	ldw	r2,-8(fp)
8010a218:	1007883a 	mov	r3,r2
8010a21c:	e0bfff17 	ldw	r2,-4(fp)
8010a220:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
8010a224:	e0bffe17 	ldw	r2,-8(fp)
8010a228:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
8010a22c:	1007883a 	mov	r3,r2
8010a230:	e0bfff17 	ldw	r2,-4(fp)
8010a234:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a238:	e0bfff17 	ldw	r2,-4(fp)
8010a23c:	10800017 	ldw	r2,0(r2)
8010a240:	01402d84 	movi	r5,182
8010a244:	1009883a 	mov	r4,r2
8010a248:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a24c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
8010a250:	e0bffe17 	ldw	r2,-8(fp)
8010a254:	1007883a 	mov	r3,r2
8010a258:	e0bfff17 	ldw	r2,-4(fp)
8010a25c:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
8010a260:	e0bffe17 	ldw	r2,-8(fp)
8010a264:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
8010a268:	1007883a 	mov	r3,r2
8010a26c:	e0bfff17 	ldw	r2,-4(fp)
8010a270:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a274:	e0bfff17 	ldw	r2,-4(fp)
8010a278:	10800017 	ldw	r2,0(r2)
8010a27c:	01402dc4 	movi	r5,183
8010a280:	1009883a 	mov	r4,r2
8010a284:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a288:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
8010a28c:	e0bffe17 	ldw	r2,-8(fp)
8010a290:	1007883a 	mov	r3,r2
8010a294:	e0bfff17 	ldw	r2,-4(fp)
8010a298:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
8010a29c:	e0bffe17 	ldw	r2,-8(fp)
8010a2a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
8010a2a4:	1007883a 	mov	r3,r2
8010a2a8:	e0bfff17 	ldw	r2,-4(fp)
8010a2ac:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a2b0:	e0bfff17 	ldw	r2,-4(fp)
8010a2b4:	10800017 	ldw	r2,0(r2)
8010a2b8:	01402e04 	movi	r5,184
8010a2bc:	1009883a 	mov	r4,r2
8010a2c0:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a2c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
8010a2c8:	e0bffe17 	ldw	r2,-8(fp)
8010a2cc:	1007883a 	mov	r3,r2
8010a2d0:	e0bfff17 	ldw	r2,-4(fp)
8010a2d4:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
8010a2d8:	e0bffe17 	ldw	r2,-8(fp)
8010a2dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
8010a2e0:	1007883a 	mov	r3,r2
8010a2e4:	e0bfff17 	ldw	r2,-4(fp)
8010a2e8:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a2ec:	e0bfff17 	ldw	r2,-4(fp)
8010a2f0:	10800017 	ldw	r2,0(r2)
8010a2f4:	01402e44 	movi	r5,185
8010a2f8:	1009883a 	mov	r4,r2
8010a2fc:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a300:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
8010a304:	e0bffe17 	ldw	r2,-8(fp)
8010a308:	1007883a 	mov	r3,r2
8010a30c:	e0bfff17 	ldw	r2,-4(fp)
8010a310:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
8010a314:	e0bffe17 	ldw	r2,-8(fp)
8010a318:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
8010a31c:	1007883a 	mov	r3,r2
8010a320:	e0bfff17 	ldw	r2,-4(fp)
8010a324:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a328:	e0bfff17 	ldw	r2,-4(fp)
8010a32c:	10800017 	ldw	r2,0(r2)
8010a330:	01402e84 	movi	r5,186
8010a334:	1009883a 	mov	r4,r2
8010a338:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a33c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
8010a340:	e0bffe17 	ldw	r2,-8(fp)
8010a344:	1007883a 	mov	r3,r2
8010a348:	e0bfff17 	ldw	r2,-4(fp)
8010a34c:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
8010a350:	e0bffe17 	ldw	r2,-8(fp)
8010a354:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
8010a358:	1007883a 	mov	r3,r2
8010a35c:	e0bfff17 	ldw	r2,-4(fp)
8010a360:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a364:	e0bfff17 	ldw	r2,-4(fp)
8010a368:	10800017 	ldw	r2,0(r2)
8010a36c:	01402ec4 	movi	r5,187
8010a370:	1009883a 	mov	r4,r2
8010a374:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a378:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
8010a37c:	e0bffe17 	ldw	r2,-8(fp)
8010a380:	1007883a 	mov	r3,r2
8010a384:	e0bfff17 	ldw	r2,-4(fp)
8010a388:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
8010a38c:	e0bffe17 	ldw	r2,-8(fp)
8010a390:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
8010a394:	1007883a 	mov	r3,r2
8010a398:	e0bfff17 	ldw	r2,-4(fp)
8010a39c:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a3a0:	e0bfff17 	ldw	r2,-4(fp)
8010a3a4:	10800017 	ldw	r2,0(r2)
8010a3a8:	01402f04 	movi	r5,188
8010a3ac:	1009883a 	mov	r4,r2
8010a3b0:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a3b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
8010a3b8:	e0bffe17 	ldw	r2,-8(fp)
8010a3bc:	1007883a 	mov	r3,r2
8010a3c0:	e0bfff17 	ldw	r2,-4(fp)
8010a3c4:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
8010a3c8:	e0bffe17 	ldw	r2,-8(fp)
8010a3cc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
8010a3d0:	1007883a 	mov	r3,r2
8010a3d4:	e0bfff17 	ldw	r2,-4(fp)
8010a3d8:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a3dc:	e0bfff17 	ldw	r2,-4(fp)
8010a3e0:	10800017 	ldw	r2,0(r2)
8010a3e4:	01402f44 	movi	r5,189
8010a3e8:	1009883a 	mov	r4,r2
8010a3ec:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a3f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
8010a3f4:	e0bffe17 	ldw	r2,-8(fp)
8010a3f8:	1007883a 	mov	r3,r2
8010a3fc:	e0bfff17 	ldw	r2,-4(fp)
8010a400:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
8010a404:	e0bffe17 	ldw	r2,-8(fp)
8010a408:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
8010a40c:	1007883a 	mov	r3,r2
8010a410:	e0bfff17 	ldw	r2,-4(fp)
8010a414:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a418:	e0bfff17 	ldw	r2,-4(fp)
8010a41c:	10800017 	ldw	r2,0(r2)
8010a420:	01402f84 	movi	r5,190
8010a424:	1009883a 	mov	r4,r2
8010a428:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a42c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
8010a430:	e0bffe17 	ldw	r2,-8(fp)
8010a434:	1007883a 	mov	r3,r2
8010a438:	e0bfff17 	ldw	r2,-4(fp)
8010a43c:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
8010a440:	e0bffe17 	ldw	r2,-8(fp)
8010a444:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
8010a448:	1007883a 	mov	r3,r2
8010a44c:	e0bfff17 	ldw	r2,-4(fp)
8010a450:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8010a454:	e0bfff17 	ldw	r2,-4(fp)
8010a458:	10800017 	ldw	r2,0(r2)
8010a45c:	01402fc4 	movi	r5,191
8010a460:	1009883a 	mov	r4,r2
8010a464:	010a7080 	call	8010a708 <uliRmapReadReg>
8010a468:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
8010a46c:	e0bffe17 	ldw	r2,-8(fp)
8010a470:	1007883a 	mov	r3,r2
8010a474:	e0bfff17 	ldw	r2,-4(fp)
8010a478:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
8010a47c:	e0bffe17 	ldw	r2,-8(fp)
8010a480:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
8010a484:	1007883a 	mov	r3,r2
8010a488:	e0bfff17 	ldw	r2,-4(fp)
8010a48c:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
8010a490:	00800044 	movi	r2,1
8010a494:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010a498:	e0bffd17 	ldw	r2,-12(fp)
}
8010a49c:	e037883a 	mov	sp,fp
8010a4a0:	dfc00117 	ldw	ra,4(sp)
8010a4a4:	df000017 	ldw	fp,0(sp)
8010a4a8:	dec00204 	addi	sp,sp,8
8010a4ac:	f800283a 	ret

8010a4b0 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
8010a4b0:	defff904 	addi	sp,sp,-28
8010a4b4:	de00012e 	bgeu	sp,et,8010a4bc <bRmapInitCh+0xc>
8010a4b8:	003b68fa 	trap	3
8010a4bc:	dfc00615 	stw	ra,24(sp)
8010a4c0:	df000515 	stw	fp,20(sp)
8010a4c4:	df000504 	addi	fp,sp,20
8010a4c8:	e13ffe15 	stw	r4,-8(fp)
8010a4cc:	2805883a 	mov	r2,r5
8010a4d0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8010a4d4:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
8010a4d8:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
8010a4dc:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
8010a4e0:	e0bffe17 	ldw	r2,-8(fp)
8010a4e4:	10006d26 	beq	r2,zero,8010a69c <bRmapInitCh+0x1ec>

		switch (ucCommCh) {
8010a4e8:	e0bfff03 	ldbu	r2,-4(fp)
8010a4ec:	10c00228 	cmpgeui	r3,r2,8
8010a4f0:	1800441e 	bne	r3,zero,8010a604 <bRmapInitCh+0x154>
8010a4f4:	100690ba 	slli	r3,r2,2
8010a4f8:	00a00474 	movhi	r2,32785
8010a4fc:	10a94304 	addi	r2,r2,-23284
8010a500:	1885883a 	add	r2,r3,r2
8010a504:	10800017 	ldw	r2,0(r2)
8010a508:	1000683a 	jmp	r2
8010a50c:	8010a52c 	andhi	zero,r16,17044
8010a510:	8010a548 	cmpgei	zero,r16,17045
8010a514:	8010a564 	muli	zero,r16,17045
8010a518:	8010a580 	call	88010a58 <__reset+0x1ff0a58>
8010a51c:	8010a598 	cmpnei	zero,r16,17046
8010a520:	8010a5b4 	orhi	zero,r16,17046
8010a524:	8010a5d0 	cmplti	zero,r16,17047
8010a528:	8010a5ec 	andhi	zero,r16,17047
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8010a52c:	e0fffe17 	ldw	r3,-8(fp)
8010a530:	00901034 	movhi	r2,16448
8010a534:	10830004 	addi	r2,r2,3072
8010a538:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010a53c:	00800044 	movi	r2,1
8010a540:	e0bffc15 	stw	r2,-16(fp)
			break;
8010a544:	00003106 	br	8010a60c <bRmapInitCh+0x15c>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8010a548:	e0fffe17 	ldw	r3,-8(fp)
8010a54c:	00901034 	movhi	r2,16448
8010a550:	10820004 	addi	r2,r2,2048
8010a554:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010a558:	00800044 	movi	r2,1
8010a55c:	e0bffc15 	stw	r2,-16(fp)
			break;
8010a560:	00002a06 	br	8010a60c <bRmapInitCh+0x15c>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8010a564:	e0fffe17 	ldw	r3,-8(fp)
8010a568:	00901034 	movhi	r2,16448
8010a56c:	10810004 	addi	r2,r2,1024
8010a570:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010a574:	00800044 	movi	r2,1
8010a578:	e0bffc15 	stw	r2,-16(fp)
			break;
8010a57c:	00002306 	br	8010a60c <bRmapInitCh+0x15c>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8010a580:	e0bffe17 	ldw	r2,-8(fp)
8010a584:	00d01034 	movhi	r3,16448
8010a588:	10c00015 	stw	r3,0(r2)
			bValidCh = TRUE;
8010a58c:	00800044 	movi	r2,1
8010a590:	e0bffc15 	stw	r2,-16(fp)
			break;
8010a594:	00001d06 	br	8010a60c <bRmapInitCh+0x15c>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8010a598:	e0fffe17 	ldw	r3,-8(fp)
8010a59c:	00901034 	movhi	r2,16448
8010a5a0:	10830004 	addi	r2,r2,3072
8010a5a4:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010a5a8:	00800044 	movi	r2,1
8010a5ac:	e0bffc15 	stw	r2,-16(fp)
			break;
8010a5b0:	00001606 	br	8010a60c <bRmapInitCh+0x15c>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8010a5b4:	e0fffe17 	ldw	r3,-8(fp)
8010a5b8:	00901034 	movhi	r2,16448
8010a5bc:	10820004 	addi	r2,r2,2048
8010a5c0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010a5c4:	00800044 	movi	r2,1
8010a5c8:	e0bffc15 	stw	r2,-16(fp)
			break;
8010a5cc:	00000f06 	br	8010a60c <bRmapInitCh+0x15c>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8010a5d0:	e0fffe17 	ldw	r3,-8(fp)
8010a5d4:	00901034 	movhi	r2,16448
8010a5d8:	10810004 	addi	r2,r2,1024
8010a5dc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010a5e0:	00800044 	movi	r2,1
8010a5e4:	e0bffc15 	stw	r2,-16(fp)
			break;
8010a5e8:	00000806 	br	8010a60c <bRmapInitCh+0x15c>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8010a5ec:	e0bffe17 	ldw	r2,-8(fp)
8010a5f0:	00d01034 	movhi	r3,16448
8010a5f4:	10c00015 	stw	r3,0(r2)
			bValidCh = TRUE;
8010a5f8:	00800044 	movi	r2,1
8010a5fc:	e0bffc15 	stw	r2,-16(fp)
			break;
8010a600:	00000206 	br	8010a60c <bRmapInitCh+0x15c>
		default:
			bValidCh = FALSE;
8010a604:	e03ffc15 	stw	zero,-16(fp)
			break;
8010a608:	0001883a 	nop
		}

		if (bValidCh) {
8010a60c:	e0bffc17 	ldw	r2,-16(fp)
8010a610:	10002226 	beq	r2,zero,8010a69c <bRmapInitCh+0x1ec>
			if (!bRmapGetIrqControl(pxRmapCh)) {
8010a614:	e13ffe17 	ldw	r4,-8(fp)
8010a618:	01080440 	call	80108044 <bRmapGetIrqControl>
8010a61c:	1000021e 	bne	r2,zero,8010a628 <bRmapInitCh+0x178>
				bInitFail = TRUE;
8010a620:	00800044 	movi	r2,1
8010a624:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
8010a628:	e13ffe17 	ldw	r4,-8(fp)
8010a62c:	01082300 	call	80108230 <bRmapGetCodecConfig>
8010a630:	1000021e 	bne	r2,zero,8010a63c <bRmapInitCh+0x18c>
				bInitFail = TRUE;
8010a634:	00800044 	movi	r2,1
8010a638:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
8010a63c:	e13ffe17 	ldw	r4,-8(fp)
8010a640:	01082bc0 	call	801082bc <bRmapGetCodecStatus>
8010a644:	1000021e 	bne	r2,zero,8010a650 <bRmapInitCh+0x1a0>
				bInitFail = TRUE;
8010a648:	00800044 	movi	r2,1
8010a64c:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
8010a650:	e13ffe17 	ldw	r4,-8(fp)
8010a654:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
8010a658:	1000021e 	bne	r2,zero,8010a664 <bRmapInitCh+0x1b4>
				bInitFail = TRUE;
8010a65c:	00800044 	movi	r2,1
8010a660:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
8010a664:	e13ffe17 	ldw	r4,-8(fp)
8010a668:	0108b840 	call	80108b84 <bRmapGetMemConfigStat>
8010a66c:	1000021e 	bne	r2,zero,8010a678 <bRmapInitCh+0x1c8>
				bInitFail = TRUE;
8010a670:	00800044 	movi	r2,1
8010a674:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
8010a678:	e13ffe17 	ldw	r4,-8(fp)
8010a67c:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
8010a680:	1000021e 	bne	r2,zero,8010a68c <bRmapInitCh+0x1dc>
				bInitFail = TRUE;
8010a684:	00800044 	movi	r2,1
8010a688:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
8010a68c:	e0bffd17 	ldw	r2,-12(fp)
8010a690:	1000021e 	bne	r2,zero,8010a69c <bRmapInitCh+0x1ec>
				bStatus = TRUE;
8010a694:	00800044 	movi	r2,1
8010a698:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
8010a69c:	e0bffb17 	ldw	r2,-20(fp)
}
8010a6a0:	e037883a 	mov	sp,fp
8010a6a4:	dfc00117 	ldw	ra,4(sp)
8010a6a8:	df000017 	ldw	fp,0(sp)
8010a6ac:	dec00204 	addi	sp,sp,8
8010a6b0:	f800283a 	ret

8010a6b4 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8010a6b4:	defffc04 	addi	sp,sp,-16
8010a6b8:	de00012e 	bgeu	sp,et,8010a6c0 <vRmapWriteReg+0xc>
8010a6bc:	003b68fa 	trap	3
8010a6c0:	df000315 	stw	fp,12(sp)
8010a6c4:	df000304 	addi	fp,sp,12
8010a6c8:	e13ffd15 	stw	r4,-12(fp)
8010a6cc:	e17ffe15 	stw	r5,-8(fp)
8010a6d0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8010a6d4:	e0bffe17 	ldw	r2,-8(fp)
8010a6d8:	1085883a 	add	r2,r2,r2
8010a6dc:	1085883a 	add	r2,r2,r2
8010a6e0:	1007883a 	mov	r3,r2
8010a6e4:	e0bffd17 	ldw	r2,-12(fp)
8010a6e8:	10c5883a 	add	r2,r2,r3
8010a6ec:	e0ffff17 	ldw	r3,-4(fp)
8010a6f0:	10c00015 	stw	r3,0(r2)
}
8010a6f4:	0001883a 	nop
8010a6f8:	e037883a 	mov	sp,fp
8010a6fc:	df000017 	ldw	fp,0(sp)
8010a700:	dec00104 	addi	sp,sp,4
8010a704:	f800283a 	ret

8010a708 <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8010a708:	defffc04 	addi	sp,sp,-16
8010a70c:	de00012e 	bgeu	sp,et,8010a714 <uliRmapReadReg+0xc>
8010a710:	003b68fa 	trap	3
8010a714:	df000315 	stw	fp,12(sp)
8010a718:	df000304 	addi	fp,sp,12
8010a71c:	e13ffe15 	stw	r4,-8(fp)
8010a720:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8010a724:	e0bfff17 	ldw	r2,-4(fp)
8010a728:	1085883a 	add	r2,r2,r2
8010a72c:	1085883a 	add	r2,r2,r2
8010a730:	1007883a 	mov	r3,r2
8010a734:	e0bffe17 	ldw	r2,-8(fp)
8010a738:	10c5883a 	add	r2,r2,r3
8010a73c:	10800017 	ldw	r2,0(r2)
8010a740:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8010a744:	e0bffd17 	ldw	r2,-12(fp)
}
8010a748:	e037883a 	mov	sp,fp
8010a74c:	df000017 	ldw	fp,0(sp)
8010a750:	dec00104 	addi	sp,sp,4
8010a754:	f800283a 	ret

8010a758 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
8010a758:	defffd04 	addi	sp,sp,-12
8010a75c:	de00012e 	bgeu	sp,et,8010a764 <uliConvRmapCfgAddr+0xc>
8010a760:	003b68fa 	trap	3
8010a764:	df000215 	stw	fp,8(sp)
8010a768:	df000204 	addi	fp,sp,8
8010a76c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
8010a770:	e0bfff17 	ldw	r2,-4(fp)
8010a774:	10801368 	cmpgeui	r2,r2,77
8010a778:	10008a1e 	bne	r2,zero,8010a9a4 <uliConvRmapCfgAddr+0x24c>
8010a77c:	e0bfff17 	ldw	r2,-4(fp)
8010a780:	100690ba 	slli	r3,r2,2
8010a784:	00a00474 	movhi	r2,32785
8010a788:	10a9e604 	addi	r2,r2,-22632
8010a78c:	1885883a 	add	r2,r3,r2
8010a790:	10800017 	ldw	r2,0(r2)
8010a794:	1000683a 	jmp	r2
8010a798:	8010a8cc 	andi	zero,r16,17059
8010a79c:	8010a9a4 	muli	zero,r16,17062
8010a7a0:	8010a9a4 	muli	zero,r16,17062
8010a7a4:	8010a9a4 	muli	zero,r16,17062
8010a7a8:	8010a8d8 	cmpnei	zero,r16,17059
8010a7ac:	8010a9a4 	muli	zero,r16,17062
8010a7b0:	8010a9a4 	muli	zero,r16,17062
8010a7b4:	8010a9a4 	muli	zero,r16,17062
8010a7b8:	8010a8e4 	muli	zero,r16,17059
8010a7bc:	8010a9a4 	muli	zero,r16,17062
8010a7c0:	8010a9a4 	muli	zero,r16,17062
8010a7c4:	8010a9a4 	muli	zero,r16,17062
8010a7c8:	8010a8f0 	cmpltui	zero,r16,17059
8010a7cc:	8010a9a4 	muli	zero,r16,17062
8010a7d0:	8010a9a4 	muli	zero,r16,17062
8010a7d4:	8010a9a4 	muli	zero,r16,17062
8010a7d8:	8010a8fc 	xorhi	zero,r16,17059
8010a7dc:	8010a9a4 	muli	zero,r16,17062
8010a7e0:	8010a9a4 	muli	zero,r16,17062
8010a7e4:	8010a9a4 	muli	zero,r16,17062
8010a7e8:	8010a908 	cmpgei	zero,r16,17060
8010a7ec:	8010a9a4 	muli	zero,r16,17062
8010a7f0:	8010a9a4 	muli	zero,r16,17062
8010a7f4:	8010a9a4 	muli	zero,r16,17062
8010a7f8:	8010a914 	ori	zero,r16,17060
8010a7fc:	8010a9a4 	muli	zero,r16,17062
8010a800:	8010a9a4 	muli	zero,r16,17062
8010a804:	8010a9a4 	muli	zero,r16,17062
8010a808:	8010a920 	cmpeqi	zero,r16,17060
8010a80c:	8010a9a4 	muli	zero,r16,17062
8010a810:	8010a9a4 	muli	zero,r16,17062
8010a814:	8010a9a4 	muli	zero,r16,17062
8010a818:	8010a92c 	andhi	zero,r16,17060
8010a81c:	8010a9a4 	muli	zero,r16,17062
8010a820:	8010a9a4 	muli	zero,r16,17062
8010a824:	8010a9a4 	muli	zero,r16,17062
8010a828:	8010a938 	rdprs	zero,r16,17060
8010a82c:	8010a9a4 	muli	zero,r16,17062
8010a830:	8010a9a4 	muli	zero,r16,17062
8010a834:	8010a9a4 	muli	zero,r16,17062
8010a838:	8010a944 	addi	zero,r16,17061
8010a83c:	8010a9a4 	muli	zero,r16,17062
8010a840:	8010a9a4 	muli	zero,r16,17062
8010a844:	8010a9a4 	muli	zero,r16,17062
8010a848:	8010a950 	cmplti	zero,r16,17061
8010a84c:	8010a9a4 	muli	zero,r16,17062
8010a850:	8010a9a4 	muli	zero,r16,17062
8010a854:	8010a9a4 	muli	zero,r16,17062
8010a858:	8010a9a4 	muli	zero,r16,17062
8010a85c:	8010a9a4 	muli	zero,r16,17062
8010a860:	8010a9a4 	muli	zero,r16,17062
8010a864:	8010a9a4 	muli	zero,r16,17062
8010a868:	8010a9a4 	muli	zero,r16,17062
8010a86c:	8010a9a4 	muli	zero,r16,17062
8010a870:	8010a9a4 	muli	zero,r16,17062
8010a874:	8010a9a4 	muli	zero,r16,17062
8010a878:	8010a95c 	xori	zero,r16,17061
8010a87c:	8010a9a4 	muli	zero,r16,17062
8010a880:	8010a9a4 	muli	zero,r16,17062
8010a884:	8010a9a4 	muli	zero,r16,17062
8010a888:	8010a968 	cmpgeui	zero,r16,17061
8010a88c:	8010a9a4 	muli	zero,r16,17062
8010a890:	8010a9a4 	muli	zero,r16,17062
8010a894:	8010a9a4 	muli	zero,r16,17062
8010a898:	8010a974 	orhi	zero,r16,17061
8010a89c:	8010a9a4 	muli	zero,r16,17062
8010a8a0:	8010a9a4 	muli	zero,r16,17062
8010a8a4:	8010a9a4 	muli	zero,r16,17062
8010a8a8:	8010a980 	call	88010a98 <__reset+0x1ff0a98>
8010a8ac:	8010a9a4 	muli	zero,r16,17062
8010a8b0:	8010a9a4 	muli	zero,r16,17062
8010a8b4:	8010a9a4 	muli	zero,r16,17062
8010a8b8:	8010a98c 	andi	zero,r16,17062
8010a8bc:	8010a9a4 	muli	zero,r16,17062
8010a8c0:	8010a9a4 	muli	zero,r16,17062
8010a8c4:	8010a9a4 	muli	zero,r16,17062
8010a8c8:	8010a998 	cmpnei	zero,r16,17062
	case 0x00000000:
		uliValue = 0x00000040;
8010a8cc:	00801004 	movi	r2,64
8010a8d0:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a8d4:	00003506 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
8010a8d8:	00801044 	movi	r2,65
8010a8dc:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a8e0:	00003206 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
8010a8e4:	00801084 	movi	r2,66
8010a8e8:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a8ec:	00002f06 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
8010a8f0:	008010c4 	movi	r2,67
8010a8f4:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a8f8:	00002c06 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8010a8fc:	00801104 	movi	r2,68
8010a900:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a904:	00002906 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8010a908:	00801144 	movi	r2,69
8010a90c:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a910:	00002606 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8010a914:	00801184 	movi	r2,70
8010a918:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a91c:	00002306 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8010a920:	008011c4 	movi	r2,71
8010a924:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a928:	00002006 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8010a92c:	00801204 	movi	r2,72
8010a930:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a934:	00001d06 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8010a938:	00801244 	movi	r2,73
8010a93c:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a940:	00001a06 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8010a944:	00801284 	movi	r2,74
8010a948:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a94c:	00001706 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8010a950:	008012c4 	movi	r2,75
8010a954:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a958:	00001406 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8010a95c:	00801304 	movi	r2,76
8010a960:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a964:	00001106 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8010a968:	00801344 	movi	r2,77
8010a96c:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a970:	00000e06 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8010a974:	00801384 	movi	r2,78
8010a978:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a97c:	00000b06 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8010a980:	008013c4 	movi	r2,79
8010a984:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a988:	00000806 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8010a98c:	00801404 	movi	r2,80
8010a990:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a994:	00000506 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8010a998:	00801444 	movi	r2,81
8010a99c:	e0bffe15 	stw	r2,-8(fp)
		break;
8010a9a0:	00000206 	br	8010a9ac <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8010a9a4:	e03ffe15 	stw	zero,-8(fp)
		break;
8010a9a8:	0001883a 	nop
	}

	return uliValue;
8010a9ac:	e0bffe17 	ldw	r2,-8(fp)
}
8010a9b0:	e037883a 	mov	sp,fp
8010a9b4:	df000017 	ldw	fp,0(sp)
8010a9b8:	dec00104 	addi	sp,sp,4
8010a9bc:	f800283a 	ret

8010a9c0 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8010a9c0:	defffb04 	addi	sp,sp,-20
8010a9c4:	de00012e 	bgeu	sp,et,8010a9cc <bSpwcSetLink+0xc>
8010a9c8:	003b68fa 	trap	3
8010a9cc:	dfc00415 	stw	ra,16(sp)
8010a9d0:	df000315 	stw	fp,12(sp)
8010a9d4:	df000304 	addi	fp,sp,12
8010a9d8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8010a9dc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010a9e0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8010a9e4:	e0bfff17 	ldw	r2,-4(fp)
8010a9e8:	10003d26 	beq	r2,zero,8010aae0 <bSpwcSetLink+0x120>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8010a9ec:	e0bfff17 	ldw	r2,-4(fp)
8010a9f0:	10800017 	ldw	r2,0(r2)
8010a9f4:	000b883a 	mov	r5,zero
8010a9f8:	1009883a 	mov	r4,r2
8010a9fc:	010b0ec0 	call	8010b0ec <uliSpwcReadReg>
8010aa00:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8010aa04:	e0bfff17 	ldw	r2,-4(fp)
8010aa08:	10800117 	ldw	r2,4(r2)
8010aa0c:	10000426 	beq	r2,zero,8010aa20 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8010aa10:	e0bffe17 	ldw	r2,-8(fp)
8010aa14:	10800114 	ori	r2,r2,4
8010aa18:	e0bffe15 	stw	r2,-8(fp)
8010aa1c:	00000406 	br	8010aa30 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8010aa20:	e0fffe17 	ldw	r3,-8(fp)
8010aa24:	00bffec4 	movi	r2,-5
8010aa28:	1884703a 	and	r2,r3,r2
8010aa2c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8010aa30:	e0bfff17 	ldw	r2,-4(fp)
8010aa34:	10800217 	ldw	r2,8(r2)
8010aa38:	10000426 	beq	r2,zero,8010aa4c <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8010aa3c:	e0bffe17 	ldw	r2,-8(fp)
8010aa40:	10800094 	ori	r2,r2,2
8010aa44:	e0bffe15 	stw	r2,-8(fp)
8010aa48:	00000406 	br	8010aa5c <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8010aa4c:	e0fffe17 	ldw	r3,-8(fp)
8010aa50:	00bfff44 	movi	r2,-3
8010aa54:	1884703a 	and	r2,r3,r2
8010aa58:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8010aa5c:	e0bfff17 	ldw	r2,-4(fp)
8010aa60:	10800317 	ldw	r2,12(r2)
8010aa64:	10000426 	beq	r2,zero,8010aa78 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8010aa68:	e0bffe17 	ldw	r2,-8(fp)
8010aa6c:	10800054 	ori	r2,r2,1
8010aa70:	e0bffe15 	stw	r2,-8(fp)
8010aa74:	00000406 	br	8010aa88 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8010aa78:	e0fffe17 	ldw	r3,-8(fp)
8010aa7c:	00bfff84 	movi	r2,-2
8010aa80:	1884703a 	and	r2,r3,r2
8010aa84:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8010aa88:	e0fffe17 	ldw	r3,-8(fp)
8010aa8c:	00804034 	movhi	r2,256
8010aa90:	10bfffc4 	addi	r2,r2,-1
8010aa94:	1884703a 	and	r2,r3,r2
8010aa98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8010aa9c:	e0bfff17 	ldw	r2,-4(fp)
8010aaa0:	10800403 	ldbu	r2,16(r2)
8010aaa4:	10803fcc 	andi	r2,r2,255
8010aaa8:	1004963a 	slli	r2,r2,24
8010aaac:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8010aab0:	e0bffe17 	ldw	r2,-8(fp)
8010aab4:	1884b03a 	or	r2,r3,r2
8010aab8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8010aabc:	e0bfff17 	ldw	r2,-4(fp)
8010aac0:	10800017 	ldw	r2,0(r2)
8010aac4:	e0fffe17 	ldw	r3,-8(fp)
8010aac8:	180d883a 	mov	r6,r3
8010aacc:	000b883a 	mov	r5,zero
8010aad0:	1009883a 	mov	r4,r2
8010aad4:	010b0980 	call	8010b098 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8010aad8:	00800044 	movi	r2,1
8010aadc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010aae0:	e0bffd17 	ldw	r2,-12(fp)
}
8010aae4:	e037883a 	mov	sp,fp
8010aae8:	dfc00117 	ldw	ra,4(sp)
8010aaec:	df000017 	ldw	fp,0(sp)
8010aaf0:	dec00204 	addi	sp,sp,8
8010aaf4:	f800283a 	ret

8010aaf8 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8010aaf8:	defffb04 	addi	sp,sp,-20
8010aafc:	de00012e 	bgeu	sp,et,8010ab04 <bSpwcGetLink+0xc>
8010ab00:	003b68fa 	trap	3
8010ab04:	dfc00415 	stw	ra,16(sp)
8010ab08:	df000315 	stw	fp,12(sp)
8010ab0c:	df000304 	addi	fp,sp,12
8010ab10:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8010ab14:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010ab18:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8010ab1c:	e0bfff17 	ldw	r2,-4(fp)
8010ab20:	10002826 	beq	r2,zero,8010abc4 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8010ab24:	e0bfff17 	ldw	r2,-4(fp)
8010ab28:	10800017 	ldw	r2,0(r2)
8010ab2c:	000b883a 	mov	r5,zero
8010ab30:	1009883a 	mov	r4,r2
8010ab34:	010b0ec0 	call	8010b0ec <uliSpwcReadReg>
8010ab38:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8010ab3c:	e0bffe17 	ldw	r2,-8(fp)
8010ab40:	1080010c 	andi	r2,r2,4
8010ab44:	10000426 	beq	r2,zero,8010ab58 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8010ab48:	e0bfff17 	ldw	r2,-4(fp)
8010ab4c:	00c00044 	movi	r3,1
8010ab50:	10c00115 	stw	r3,4(r2)
8010ab54:	00000206 	br	8010ab60 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8010ab58:	e0bfff17 	ldw	r2,-4(fp)
8010ab5c:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8010ab60:	e0bffe17 	ldw	r2,-8(fp)
8010ab64:	1080008c 	andi	r2,r2,2
8010ab68:	10000426 	beq	r2,zero,8010ab7c <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8010ab6c:	e0bfff17 	ldw	r2,-4(fp)
8010ab70:	00c00044 	movi	r3,1
8010ab74:	10c00215 	stw	r3,8(r2)
8010ab78:	00000206 	br	8010ab84 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8010ab7c:	e0bfff17 	ldw	r2,-4(fp)
8010ab80:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8010ab84:	e0bffe17 	ldw	r2,-8(fp)
8010ab88:	1080004c 	andi	r2,r2,1
8010ab8c:	10000426 	beq	r2,zero,8010aba0 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8010ab90:	e0bfff17 	ldw	r2,-4(fp)
8010ab94:	00c00044 	movi	r3,1
8010ab98:	10c00315 	stw	r3,12(r2)
8010ab9c:	00000206 	br	8010aba8 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8010aba0:	e0bfff17 	ldw	r2,-4(fp)
8010aba4:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8010aba8:	e0bffe17 	ldw	r2,-8(fp)
8010abac:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8010abb0:	1007883a 	mov	r3,r2
8010abb4:	e0bfff17 	ldw	r2,-4(fp)
8010abb8:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8010abbc:	00800044 	movi	r2,1
8010abc0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010abc4:	e0bffd17 	ldw	r2,-12(fp)
}
8010abc8:	e037883a 	mov	sp,fp
8010abcc:	dfc00117 	ldw	ra,4(sp)
8010abd0:	df000017 	ldw	fp,0(sp)
8010abd4:	dec00204 	addi	sp,sp,8
8010abd8:	f800283a 	ret

8010abdc <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8010abdc:	defffb04 	addi	sp,sp,-20
8010abe0:	de00012e 	bgeu	sp,et,8010abe8 <bSpwcGetLinkError+0xc>
8010abe4:	003b68fa 	trap	3
8010abe8:	dfc00415 	stw	ra,16(sp)
8010abec:	df000315 	stw	fp,12(sp)
8010abf0:	df000304 	addi	fp,sp,12
8010abf4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8010abf8:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010abfc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8010ac00:	e0bfff17 	ldw	r2,-4(fp)
8010ac04:	10002c26 	beq	r2,zero,8010acb8 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8010ac08:	e0bfff17 	ldw	r2,-4(fp)
8010ac0c:	10800017 	ldw	r2,0(r2)
8010ac10:	000b883a 	mov	r5,zero
8010ac14:	1009883a 	mov	r4,r2
8010ac18:	010b0ec0 	call	8010b0ec <uliSpwcReadReg>
8010ac1c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8010ac20:	e0bffe17 	ldw	r2,-8(fp)
8010ac24:	1080006c 	andhi	r2,r2,1
8010ac28:	10000426 	beq	r2,zero,8010ac3c <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8010ac2c:	e0bfff17 	ldw	r2,-4(fp)
8010ac30:	00c00044 	movi	r3,1
8010ac34:	10c00515 	stw	r3,20(r2)
8010ac38:	00000206 	br	8010ac44 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8010ac3c:	e0bfff17 	ldw	r2,-4(fp)
8010ac40:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8010ac44:	e0bffe17 	ldw	r2,-8(fp)
8010ac48:	108000ac 	andhi	r2,r2,2
8010ac4c:	10000426 	beq	r2,zero,8010ac60 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8010ac50:	e0bfff17 	ldw	r2,-4(fp)
8010ac54:	00c00044 	movi	r3,1
8010ac58:	10c00615 	stw	r3,24(r2)
8010ac5c:	00000206 	br	8010ac68 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8010ac60:	e0bfff17 	ldw	r2,-4(fp)
8010ac64:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8010ac68:	e0bffe17 	ldw	r2,-8(fp)
8010ac6c:	1080012c 	andhi	r2,r2,4
8010ac70:	10000426 	beq	r2,zero,8010ac84 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8010ac74:	e0bfff17 	ldw	r2,-4(fp)
8010ac78:	00c00044 	movi	r3,1
8010ac7c:	10c00715 	stw	r3,28(r2)
8010ac80:	00000206 	br	8010ac8c <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8010ac84:	e0bfff17 	ldw	r2,-4(fp)
8010ac88:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8010ac8c:	e0bffe17 	ldw	r2,-8(fp)
8010ac90:	1080022c 	andhi	r2,r2,8
8010ac94:	10000426 	beq	r2,zero,8010aca8 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8010ac98:	e0bfff17 	ldw	r2,-4(fp)
8010ac9c:	00c00044 	movi	r3,1
8010aca0:	10c00815 	stw	r3,32(r2)
8010aca4:	00000206 	br	8010acb0 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8010aca8:	e0bfff17 	ldw	r2,-4(fp)
8010acac:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8010acb0:	00800044 	movi	r2,1
8010acb4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010acb8:	e0bffd17 	ldw	r2,-12(fp)
}
8010acbc:	e037883a 	mov	sp,fp
8010acc0:	dfc00117 	ldw	ra,4(sp)
8010acc4:	df000017 	ldw	fp,0(sp)
8010acc8:	dec00204 	addi	sp,sp,8
8010accc:	f800283a 	ret

8010acd0 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8010acd0:	defffb04 	addi	sp,sp,-20
8010acd4:	de00012e 	bgeu	sp,et,8010acdc <bSpwcGetLinkStatus+0xc>
8010acd8:	003b68fa 	trap	3
8010acdc:	dfc00415 	stw	ra,16(sp)
8010ace0:	df000315 	stw	fp,12(sp)
8010ace4:	df000304 	addi	fp,sp,12
8010ace8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8010acec:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010acf0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8010acf4:	e0bfff17 	ldw	r2,-4(fp)
8010acf8:	10002326 	beq	r2,zero,8010ad88 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8010acfc:	e0bfff17 	ldw	r2,-4(fp)
8010ad00:	10800017 	ldw	r2,0(r2)
8010ad04:	000b883a 	mov	r5,zero
8010ad08:	1009883a 	mov	r4,r2
8010ad0c:	010b0ec0 	call	8010b0ec <uliSpwcReadReg>
8010ad10:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8010ad14:	e0bffe17 	ldw	r2,-8(fp)
8010ad18:	1081000c 	andi	r2,r2,1024
8010ad1c:	10000426 	beq	r2,zero,8010ad30 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8010ad20:	e0bfff17 	ldw	r2,-4(fp)
8010ad24:	00c00044 	movi	r3,1
8010ad28:	10c00915 	stw	r3,36(r2)
8010ad2c:	00000206 	br	8010ad38 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8010ad30:	e0bfff17 	ldw	r2,-4(fp)
8010ad34:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8010ad38:	e0bffe17 	ldw	r2,-8(fp)
8010ad3c:	1080800c 	andi	r2,r2,512
8010ad40:	10000426 	beq	r2,zero,8010ad54 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8010ad44:	e0bfff17 	ldw	r2,-4(fp)
8010ad48:	00c00044 	movi	r3,1
8010ad4c:	10c00a15 	stw	r3,40(r2)
8010ad50:	00000206 	br	8010ad5c <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8010ad54:	e0bfff17 	ldw	r2,-4(fp)
8010ad58:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8010ad5c:	e0bffe17 	ldw	r2,-8(fp)
8010ad60:	1080400c 	andi	r2,r2,256
8010ad64:	10000426 	beq	r2,zero,8010ad78 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8010ad68:	e0bfff17 	ldw	r2,-4(fp)
8010ad6c:	00c00044 	movi	r3,1
8010ad70:	10c00b15 	stw	r3,44(r2)
8010ad74:	00000206 	br	8010ad80 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8010ad78:	e0bfff17 	ldw	r2,-4(fp)
8010ad7c:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8010ad80:	00800044 	movi	r2,1
8010ad84:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010ad88:	e0bffd17 	ldw	r2,-12(fp)
}
8010ad8c:	e037883a 	mov	sp,fp
8010ad90:	dfc00117 	ldw	ra,4(sp)
8010ad94:	df000017 	ldw	fp,0(sp)
8010ad98:	dec00204 	addi	sp,sp,8
8010ad9c:	f800283a 	ret

8010ada0 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8010ada0:	defffb04 	addi	sp,sp,-20
8010ada4:	de00012e 	bgeu	sp,et,8010adac <bSpwcGetTimecode+0xc>
8010ada8:	003b68fa 	trap	3
8010adac:	dfc00415 	stw	ra,16(sp)
8010adb0:	df000315 	stw	fp,12(sp)
8010adb4:	df000304 	addi	fp,sp,12
8010adb8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8010adbc:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010adc0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8010adc4:	e0bfff17 	ldw	r2,-4(fp)
8010adc8:	10001326 	beq	r2,zero,8010ae18 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8010adcc:	e0bfff17 	ldw	r2,-4(fp)
8010add0:	10800017 	ldw	r2,0(r2)
8010add4:	01400044 	movi	r5,1
8010add8:	1009883a 	mov	r4,r2
8010addc:	010b0ec0 	call	8010b0ec <uliSpwcReadReg>
8010ade0:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8010ade4:	e0bffe17 	ldw	r2,-8(fp)
8010ade8:	1080300c 	andi	r2,r2,192
8010adec:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8010adf0:	1007883a 	mov	r3,r2
8010adf4:	e0bfff17 	ldw	r2,-4(fp)
8010adf8:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8010adfc:	e0bffe17 	ldw	r2,-8(fp)
8010ae00:	10800fcc 	andi	r2,r2,63
8010ae04:	1007883a 	mov	r3,r2
8010ae08:	e0bfff17 	ldw	r2,-4(fp)
8010ae0c:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8010ae10:	00800044 	movi	r2,1
8010ae14:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010ae18:	e0bffd17 	ldw	r2,-12(fp)
}
8010ae1c:	e037883a 	mov	sp,fp
8010ae20:	dfc00117 	ldw	ra,4(sp)
8010ae24:	df000017 	ldw	fp,0(sp)
8010ae28:	dec00204 	addi	sp,sp,8
8010ae2c:	f800283a 	ret

8010ae30 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8010ae30:	defffb04 	addi	sp,sp,-20
8010ae34:	de00012e 	bgeu	sp,et,8010ae3c <bSpwcClearTimecode+0xc>
8010ae38:	003b68fa 	trap	3
8010ae3c:	dfc00415 	stw	ra,16(sp)
8010ae40:	df000315 	stw	fp,12(sp)
8010ae44:	df000304 	addi	fp,sp,12
8010ae48:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8010ae4c:	e03ffd15 	stw	zero,-12(fp)
	volatile alt_u32 uliReg = 0;
8010ae50:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8010ae54:	e0bfff17 	ldw	r2,-4(fp)
8010ae58:	10001226 	beq	r2,zero,8010aea4 <bSpwcClearTimecode+0x74>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8010ae5c:	e0bfff17 	ldw	r2,-4(fp)
8010ae60:	10800017 	ldw	r2,0(r2)
8010ae64:	01400044 	movi	r5,1
8010ae68:	1009883a 	mov	r4,r2
8010ae6c:	010b0ec0 	call	8010b0ec <uliSpwcReadReg>
8010ae70:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8010ae74:	e0bffe17 	ldw	r2,-8(fp)
8010ae78:	10804014 	ori	r2,r2,256
8010ae7c:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8010ae80:	e0bfff17 	ldw	r2,-4(fp)
8010ae84:	10800017 	ldw	r2,0(r2)
8010ae88:	e0fffe17 	ldw	r3,-8(fp)
8010ae8c:	180d883a 	mov	r6,r3
8010ae90:	01400044 	movi	r5,1
8010ae94:	1009883a 	mov	r4,r2
8010ae98:	010b0980 	call	8010b098 <vSpwcWriteReg>
		bStatus = TRUE;
8010ae9c:	00800044 	movi	r2,1
8010aea0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8010aea4:	e0bffd17 	ldw	r2,-12(fp)
}
8010aea8:	e037883a 	mov	sp,fp
8010aeac:	dfc00117 	ldw	ra,4(sp)
8010aeb0:	df000017 	ldw	fp,0(sp)
8010aeb4:	dec00204 	addi	sp,sp,8
8010aeb8:	f800283a 	ret

8010aebc <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8010aebc:	defff904 	addi	sp,sp,-28
8010aec0:	de00012e 	bgeu	sp,et,8010aec8 <bSpwcInitCh+0xc>
8010aec4:	003b68fa 	trap	3
8010aec8:	dfc00615 	stw	ra,24(sp)
8010aecc:	df000515 	stw	fp,20(sp)
8010aed0:	df000504 	addi	fp,sp,20
8010aed4:	e13ffe15 	stw	r4,-8(fp)
8010aed8:	2805883a 	mov	r2,r5
8010aedc:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8010aee0:	e03ffb15 	stw	zero,-20(fp)
	bool bValidCh = FALSE;
8010aee4:	e03ffc15 	stw	zero,-16(fp)
	bool bInitFail = FALSE;
8010aee8:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8010aeec:	e0bffe17 	ldw	r2,-8(fp)
8010aef0:	10006326 	beq	r2,zero,8010b080 <bSpwcInitCh+0x1c4>

		switch (ucCommCh) {
8010aef4:	e0bfff03 	ldbu	r2,-4(fp)
8010aef8:	10c00228 	cmpgeui	r3,r2,8
8010aefc:	1800441e 	bne	r3,zero,8010b010 <bSpwcInitCh+0x154>
8010af00:	100690ba 	slli	r3,r2,2
8010af04:	00a00474 	movhi	r2,32785
8010af08:	10abc604 	addi	r2,r2,-20712
8010af0c:	1885883a 	add	r2,r3,r2
8010af10:	10800017 	ldw	r2,0(r2)
8010af14:	1000683a 	jmp	r2
8010af18:	8010af38 	rdprs	zero,r16,17084
8010af1c:	8010af54 	ori	zero,r16,17085
8010af20:	8010af70 	cmpltui	zero,r16,17085
8010af24:	8010af8c 	andi	zero,r16,17086
8010af28:	8010afa4 	muli	zero,r16,17086
8010af2c:	8010afc0 	call	88010afc <__reset+0x1ff0afc>
8010af30:	8010afdc 	xori	zero,r16,17087
8010af34:	8010aff8 	rdprs	zero,r16,17087
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8010af38:	e0fffe17 	ldw	r3,-8(fp)
8010af3c:	00901034 	movhi	r2,16448
8010af40:	10830004 	addi	r2,r2,3072
8010af44:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010af48:	00800044 	movi	r2,1
8010af4c:	e0bffc15 	stw	r2,-16(fp)
			break;
8010af50:	00003106 	br	8010b018 <bSpwcInitCh+0x15c>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8010af54:	e0fffe17 	ldw	r3,-8(fp)
8010af58:	00901034 	movhi	r2,16448
8010af5c:	10820004 	addi	r2,r2,2048
8010af60:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010af64:	00800044 	movi	r2,1
8010af68:	e0bffc15 	stw	r2,-16(fp)
			break;
8010af6c:	00002a06 	br	8010b018 <bSpwcInitCh+0x15c>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8010af70:	e0fffe17 	ldw	r3,-8(fp)
8010af74:	00901034 	movhi	r2,16448
8010af78:	10810004 	addi	r2,r2,1024
8010af7c:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010af80:	00800044 	movi	r2,1
8010af84:	e0bffc15 	stw	r2,-16(fp)
			break;
8010af88:	00002306 	br	8010b018 <bSpwcInitCh+0x15c>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8010af8c:	e0bffe17 	ldw	r2,-8(fp)
8010af90:	00d01034 	movhi	r3,16448
8010af94:	10c00015 	stw	r3,0(r2)
			bValidCh = TRUE;
8010af98:	00800044 	movi	r2,1
8010af9c:	e0bffc15 	stw	r2,-16(fp)
			break;
8010afa0:	00001d06 	br	8010b018 <bSpwcInitCh+0x15c>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8010afa4:	e0fffe17 	ldw	r3,-8(fp)
8010afa8:	00901034 	movhi	r2,16448
8010afac:	10830004 	addi	r2,r2,3072
8010afb0:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010afb4:	00800044 	movi	r2,1
8010afb8:	e0bffc15 	stw	r2,-16(fp)
			break;
8010afbc:	00001606 	br	8010b018 <bSpwcInitCh+0x15c>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8010afc0:	e0fffe17 	ldw	r3,-8(fp)
8010afc4:	00901034 	movhi	r2,16448
8010afc8:	10820004 	addi	r2,r2,2048
8010afcc:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010afd0:	00800044 	movi	r2,1
8010afd4:	e0bffc15 	stw	r2,-16(fp)
			break;
8010afd8:	00000f06 	br	8010b018 <bSpwcInitCh+0x15c>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8010afdc:	e0fffe17 	ldw	r3,-8(fp)
8010afe0:	00901034 	movhi	r2,16448
8010afe4:	10810004 	addi	r2,r2,1024
8010afe8:	18800015 	stw	r2,0(r3)
			bValidCh = TRUE;
8010afec:	00800044 	movi	r2,1
8010aff0:	e0bffc15 	stw	r2,-16(fp)
			break;
8010aff4:	00000806 	br	8010b018 <bSpwcInitCh+0x15c>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8010aff8:	e0bffe17 	ldw	r2,-8(fp)
8010affc:	00d01034 	movhi	r3,16448
8010b000:	10c00015 	stw	r3,0(r2)
			bValidCh = TRUE;
8010b004:	00800044 	movi	r2,1
8010b008:	e0bffc15 	stw	r2,-16(fp)
			break;
8010b00c:	00000206 	br	8010b018 <bSpwcInitCh+0x15c>
		default:
			bValidCh = FALSE;
8010b010:	e03ffc15 	stw	zero,-16(fp)
			break;
8010b014:	0001883a 	nop
		}

		if (bValidCh) {
8010b018:	e0bffc17 	ldw	r2,-16(fp)
8010b01c:	10001826 	beq	r2,zero,8010b080 <bSpwcInitCh+0x1c4>
			if (!bSpwcGetLink(pxSpwcCh)) {
8010b020:	e13ffe17 	ldw	r4,-8(fp)
8010b024:	010aaf80 	call	8010aaf8 <bSpwcGetLink>
8010b028:	1000021e 	bne	r2,zero,8010b034 <bSpwcInitCh+0x178>
				bInitFail = TRUE;
8010b02c:	00800044 	movi	r2,1
8010b030:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8010b034:	e13ffe17 	ldw	r4,-8(fp)
8010b038:	010abdc0 	call	8010abdc <bSpwcGetLinkError>
8010b03c:	1000021e 	bne	r2,zero,8010b048 <bSpwcInitCh+0x18c>
				bInitFail = TRUE;
8010b040:	00800044 	movi	r2,1
8010b044:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8010b048:	e13ffe17 	ldw	r4,-8(fp)
8010b04c:	010acd00 	call	8010acd0 <bSpwcGetLinkStatus>
8010b050:	1000021e 	bne	r2,zero,8010b05c <bSpwcInitCh+0x1a0>
				bInitFail = TRUE;
8010b054:	00800044 	movi	r2,1
8010b058:	e0bffd15 	stw	r2,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8010b05c:	e13ffe17 	ldw	r4,-8(fp)
8010b060:	010ada00 	call	8010ada0 <bSpwcGetTimecode>
8010b064:	1000021e 	bne	r2,zero,8010b070 <bSpwcInitCh+0x1b4>
				bInitFail = TRUE;
8010b068:	00800044 	movi	r2,1
8010b06c:	e0bffd15 	stw	r2,-12(fp)
			}

			if (!bInitFail) {
8010b070:	e0bffd17 	ldw	r2,-12(fp)
8010b074:	1000021e 	bne	r2,zero,8010b080 <bSpwcInitCh+0x1c4>
				bStatus = TRUE;
8010b078:	00800044 	movi	r2,1
8010b07c:	e0bffb15 	stw	r2,-20(fp)
			}
		}
	}
	return bStatus;
8010b080:	e0bffb17 	ldw	r2,-20(fp)
}
8010b084:	e037883a 	mov	sp,fp
8010b088:	dfc00117 	ldw	ra,4(sp)
8010b08c:	df000017 	ldw	fp,0(sp)
8010b090:	dec00204 	addi	sp,sp,8
8010b094:	f800283a 	ret

8010b098 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8010b098:	defffc04 	addi	sp,sp,-16
8010b09c:	de00012e 	bgeu	sp,et,8010b0a4 <vSpwcWriteReg+0xc>
8010b0a0:	003b68fa 	trap	3
8010b0a4:	df000315 	stw	fp,12(sp)
8010b0a8:	df000304 	addi	fp,sp,12
8010b0ac:	e13ffd15 	stw	r4,-12(fp)
8010b0b0:	e17ffe15 	stw	r5,-8(fp)
8010b0b4:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8010b0b8:	e0bffe17 	ldw	r2,-8(fp)
8010b0bc:	1085883a 	add	r2,r2,r2
8010b0c0:	1085883a 	add	r2,r2,r2
8010b0c4:	1007883a 	mov	r3,r2
8010b0c8:	e0bffd17 	ldw	r2,-12(fp)
8010b0cc:	10c5883a 	add	r2,r2,r3
8010b0d0:	e0ffff17 	ldw	r3,-4(fp)
8010b0d4:	10c00015 	stw	r3,0(r2)
}
8010b0d8:	0001883a 	nop
8010b0dc:	e037883a 	mov	sp,fp
8010b0e0:	df000017 	ldw	fp,0(sp)
8010b0e4:	dec00104 	addi	sp,sp,4
8010b0e8:	f800283a 	ret

8010b0ec <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8010b0ec:	defffc04 	addi	sp,sp,-16
8010b0f0:	de00012e 	bgeu	sp,et,8010b0f8 <uliSpwcReadReg+0xc>
8010b0f4:	003b68fa 	trap	3
8010b0f8:	df000315 	stw	fp,12(sp)
8010b0fc:	df000304 	addi	fp,sp,12
8010b100:	e13ffe15 	stw	r4,-8(fp)
8010b104:	e17fff15 	stw	r5,-4(fp)
	volatile alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8010b108:	e0bfff17 	ldw	r2,-4(fp)
8010b10c:	1085883a 	add	r2,r2,r2
8010b110:	1085883a 	add	r2,r2,r2
8010b114:	1007883a 	mov	r3,r2
8010b118:	e0bffe17 	ldw	r2,-8(fp)
8010b11c:	10c5883a 	add	r2,r2,r3
8010b120:	10800017 	ldw	r2,0(r2)
8010b124:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8010b128:	e0bffd17 	ldw	r2,-12(fp)
}
8010b12c:	e037883a 	mov	sp,fp
8010b130:	df000017 	ldw	fp,0(sp)
8010b134:	dec00104 	addi	sp,sp,4
8010b138:	f800283a 	ret

8010b13c <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8010b13c:	defffe04 	addi	sp,sp,-8
8010b140:	de00012e 	bgeu	sp,et,8010b148 <bEnableIsoDrivers+0xc>
8010b144:	003b68fa 	trap	3
8010b148:	dfc00115 	stw	ra,4(sp)
8010b14c:	df000015 	stw	fp,0(sp)
8010b150:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8010b154:	01400204 	movi	r5,8
8010b158:	01000044 	movi	r4,1
8010b15c:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
  return  TRUE;
8010b160:	00800044 	movi	r2,1
}
8010b164:	e037883a 	mov	sp,fp
8010b168:	dfc00117 	ldw	ra,4(sp)
8010b16c:	df000017 	ldw	fp,0(sp)
8010b170:	dec00204 	addi	sp,sp,8
8010b174:	f800283a 	ret

8010b178 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8010b178:	defffe04 	addi	sp,sp,-8
8010b17c:	de00012e 	bgeu	sp,et,8010b184 <bDisableIsoDrivers+0xc>
8010b180:	003b68fa 	trap	3
8010b184:	dfc00115 	stw	ra,4(sp)
8010b188:	df000015 	stw	fp,0(sp)
8010b18c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8010b190:	01400204 	movi	r5,8
8010b194:	0009883a 	mov	r4,zero
8010b198:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
  return  TRUE;
8010b19c:	00800044 	movi	r2,1
}
8010b1a0:	e037883a 	mov	sp,fp
8010b1a4:	dfc00117 	ldw	ra,4(sp)
8010b1a8:	df000017 	ldw	fp,0(sp)
8010b1ac:	dec00204 	addi	sp,sp,8
8010b1b0:	f800283a 	ret

8010b1b4 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8010b1b4:	defffe04 	addi	sp,sp,-8
8010b1b8:	de00012e 	bgeu	sp,et,8010b1c0 <bEnableLvdsBoard+0xc>
8010b1bc:	003b68fa 	trap	3
8010b1c0:	dfc00115 	stw	ra,4(sp)
8010b1c4:	df000015 	stw	fp,0(sp)
8010b1c8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8010b1cc:	01400104 	movi	r5,4
8010b1d0:	01000044 	movi	r4,1
8010b1d4:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
  return  TRUE;
8010b1d8:	00800044 	movi	r2,1
}
8010b1dc:	e037883a 	mov	sp,fp
8010b1e0:	dfc00117 	ldw	ra,4(sp)
8010b1e4:	df000017 	ldw	fp,0(sp)
8010b1e8:	dec00204 	addi	sp,sp,8
8010b1ec:	f800283a 	ret

8010b1f0 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8010b1f0:	defffe04 	addi	sp,sp,-8
8010b1f4:	de00012e 	bgeu	sp,et,8010b1fc <bDisableLvdsBoard+0xc>
8010b1f8:	003b68fa 	trap	3
8010b1fc:	dfc00115 	stw	ra,4(sp)
8010b200:	df000015 	stw	fp,0(sp)
8010b204:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8010b208:	01400104 	movi	r5,4
8010b20c:	0009883a 	mov	r4,zero
8010b210:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
  return  TRUE;
8010b214:	00800044 	movi	r2,1
}
8010b218:	e037883a 	mov	sp,fp
8010b21c:	dfc00117 	ldw	ra,4(sp)
8010b220:	df000017 	ldw	fp,0(sp)
8010b224:	dec00204 	addi	sp,sp,8
8010b228:	f800283a 	ret

8010b22c <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8010b22c:	defffd04 	addi	sp,sp,-12
8010b230:	de00012e 	bgeu	sp,et,8010b238 <bSetPreEmphasys+0xc>
8010b234:	003b68fa 	trap	3
8010b238:	dfc00215 	stw	ra,8(sp)
8010b23c:	df000115 	stw	fp,4(sp)
8010b240:	df000104 	addi	fp,sp,4
8010b244:	2005883a 	mov	r2,r4
8010b248:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8010b24c:	e0bfff03 	ldbu	r2,-4(fp)
8010b250:	10c00060 	cmpeqi	r3,r2,1
8010b254:	18000d1e 	bne	r3,zero,8010b28c <bSetPreEmphasys+0x60>
8010b258:	10c00088 	cmpgei	r3,r2,2
8010b25c:	1800021e 	bne	r3,zero,8010b268 <bSetPreEmphasys+0x3c>
8010b260:	10000626 	beq	r2,zero,8010b27c <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8010b264:	00001b06 	br	8010b2d4 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8010b268:	10c000a0 	cmpeqi	r3,r2,2
8010b26c:	18000e1e 	bne	r3,zero,8010b2a8 <bSetPreEmphasys+0x7c>
8010b270:	108000e0 	cmpeqi	r2,r2,3
8010b274:	1000131e 	bne	r2,zero,8010b2c4 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8010b278:	00001606 	br	8010b2d4 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8010b27c:	014000c4 	movi	r5,3
8010b280:	0009883a 	mov	r4,zero
8010b284:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
      break;
8010b288:	00001206 	br	8010b2d4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8010b28c:	01400084 	movi	r5,2
8010b290:	0009883a 	mov	r4,zero
8010b294:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8010b298:	01400044 	movi	r5,1
8010b29c:	01000044 	movi	r4,1
8010b2a0:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
      break;
8010b2a4:	00000b06 	br	8010b2d4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8010b2a8:	01400044 	movi	r5,1
8010b2ac:	0009883a 	mov	r4,zero
8010b2b0:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8010b2b4:	01400084 	movi	r5,2
8010b2b8:	01000044 	movi	r4,1
8010b2bc:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
      break;
8010b2c0:	00000406 	br	8010b2d4 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8010b2c4:	014000c4 	movi	r5,3
8010b2c8:	01000044 	movi	r4,1
8010b2cc:	010b2ec0 	call	8010b2ec <bCtrlIoLvdsDrive>
      break;
8010b2d0:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8010b2d4:	00800044 	movi	r2,1
}
8010b2d8:	e037883a 	mov	sp,fp
8010b2dc:	dfc00117 	ldw	ra,4(sp)
8010b2e0:	df000017 	ldw	fp,0(sp)
8010b2e4:	dec00204 	addi	sp,sp,8
8010b2e8:	f800283a 	ret

8010b2ec <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8010b2ec:	defffd04 	addi	sp,sp,-12
8010b2f0:	de00012e 	bgeu	sp,et,8010b2f8 <bCtrlIoLvdsDrive+0xc>
8010b2f4:	003b68fa 	trap	3
8010b2f8:	df000215 	stw	fp,8(sp)
8010b2fc:	df000204 	addi	fp,sp,8
8010b300:	e13ffe15 	stw	r4,-8(fp)
8010b304:	2805883a 	mov	r2,r5
8010b308:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8010b30c:	e0bffe17 	ldw	r2,-8(fp)
8010b310:	1000071e 	bne	r2,zero,8010b330 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8010b314:	e0bfff03 	ldbu	r2,-4(fp)
8010b318:	0084303a 	nor	r2,zero,r2
8010b31c:	1007883a 	mov	r3,r2
8010b320:	d0a00143 	ldbu	r2,-32763(gp)
8010b324:	1884703a 	and	r2,r3,r2
8010b328:	d0a00145 	stb	r2,-32763(gp)
8010b32c:	00000406 	br	8010b340 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8010b330:	d0e00143 	ldbu	r3,-32763(gp)
8010b334:	e0bfff03 	ldbu	r2,-4(fp)
8010b338:	1884b03a 	or	r2,r3,r2
8010b33c:	d0a00145 	stb	r2,-32763(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8010b340:	d0a00143 	ldbu	r2,-32763(gp)
8010b344:	10c03fcc 	andi	r3,r2,255
8010b348:	00900034 	movhi	r2,16384
8010b34c:	10822804 	addi	r2,r2,2208
8010b350:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8010b354:	00800044 	movi	r2,1
}
8010b358:	e037883a 	mov	sp,fp
8010b35c:	df000017 	ldw	fp,0(sp)
8010b360:	dec00104 	addi	sp,sp,4
8010b364:	f800283a 	ret

8010b368 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8010b368:	defffa04 	addi	sp,sp,-24
8010b36c:	de00012e 	bgeu	sp,et,8010b374 <I2C_TestAdress+0xc>
8010b370:	003b68fa 	trap	3
8010b374:	dfc00515 	stw	ra,20(sp)
8010b378:	df000415 	stw	fp,16(sp)
8010b37c:	df000404 	addi	fp,sp,16
8010b380:	e13ffd15 	stw	r4,-12(fp)
8010b384:	e17ffe15 	stw	r5,-8(fp)
8010b388:	3005883a 	mov	r2,r6
8010b38c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8010b390:	00800044 	movi	r2,1
8010b394:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8010b398:	e17ffe17 	ldw	r5,-8(fp)
8010b39c:	e13ffd17 	ldw	r4,-12(fp)
8010b3a0:	010b7380 	call	8010b738 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8010b3a4:	e0bfff03 	ldbu	r2,-4(fp)
8010b3a8:	10803fcc 	andi	r2,r2,255
8010b3ac:	100d883a 	mov	r6,r2
8010b3b0:	e17ffe17 	ldw	r5,-8(fp)
8010b3b4:	e13ffd17 	ldw	r4,-12(fp)
8010b3b8:	010b84c0 	call	8010b84c <i2c_write>
8010b3bc:	1000011e 	bne	r2,zero,8010b3c4 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8010b3c0:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8010b3c4:	e17ffe17 	ldw	r5,-8(fp)
8010b3c8:	e13ffd17 	ldw	r4,-12(fp)
8010b3cc:	010b7cc0 	call	8010b7cc <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8010b3d0:	0106d604 	movi	r4,7000
8010b3d4:	01330f80 	call	801330f8 <usleep>
    
    return bSuccess;
8010b3d8:	e0bffc17 	ldw	r2,-16(fp)

}
8010b3dc:	e037883a 	mov	sp,fp
8010b3e0:	dfc00117 	ldw	ra,4(sp)
8010b3e4:	df000017 	ldw	fp,0(sp)
8010b3e8:	dec00204 	addi	sp,sp,8
8010b3ec:	f800283a 	ret

8010b3f0 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8010b3f0:	defff804 	addi	sp,sp,-32
8010b3f4:	de00012e 	bgeu	sp,et,8010b3fc <I2C_Write+0xc>
8010b3f8:	003b68fa 	trap	3
8010b3fc:	dfc00715 	stw	ra,28(sp)
8010b400:	df000615 	stw	fp,24(sp)
8010b404:	df000604 	addi	fp,sp,24
8010b408:	e13ffb15 	stw	r4,-20(fp)
8010b40c:	e17ffc15 	stw	r5,-16(fp)
8010b410:	3009883a 	mov	r4,r6
8010b414:	3807883a 	mov	r3,r7
8010b418:	e0800217 	ldw	r2,8(fp)
8010b41c:	e13ffd05 	stb	r4,-12(fp)
8010b420:	e0fffe05 	stb	r3,-8(fp)
8010b424:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8010b428:	00800044 	movi	r2,1
8010b42c:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8010b430:	e17ffc17 	ldw	r5,-16(fp)
8010b434:	e13ffb17 	ldw	r4,-20(fp)
8010b438:	010b7380 	call	8010b738 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8010b43c:	e0bffd03 	ldbu	r2,-12(fp)
8010b440:	10803fcc 	andi	r2,r2,255
8010b444:	100d883a 	mov	r6,r2
8010b448:	e17ffc17 	ldw	r5,-16(fp)
8010b44c:	e13ffb17 	ldw	r4,-20(fp)
8010b450:	010b84c0 	call	8010b84c <i2c_write>
8010b454:	1000011e 	bne	r2,zero,8010b45c <I2C_Write+0x6c>
        bSuccess = FALSE;
8010b458:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8010b45c:	e0bffa17 	ldw	r2,-24(fp)
8010b460:	10000726 	beq	r2,zero,8010b480 <I2C_Write+0x90>
8010b464:	e0bffe03 	ldbu	r2,-8(fp)
8010b468:	100d883a 	mov	r6,r2
8010b46c:	e17ffc17 	ldw	r5,-16(fp)
8010b470:	e13ffb17 	ldw	r4,-20(fp)
8010b474:	010b84c0 	call	8010b84c <i2c_write>
8010b478:	1000011e 	bne	r2,zero,8010b480 <I2C_Write+0x90>
        bSuccess = FALSE;
8010b47c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8010b480:	e0bffa17 	ldw	r2,-24(fp)
8010b484:	10000726 	beq	r2,zero,8010b4a4 <I2C_Write+0xb4>
8010b488:	e0bfff03 	ldbu	r2,-4(fp)
8010b48c:	100d883a 	mov	r6,r2
8010b490:	e17ffc17 	ldw	r5,-16(fp)
8010b494:	e13ffb17 	ldw	r4,-20(fp)
8010b498:	010b84c0 	call	8010b84c <i2c_write>
8010b49c:	1000011e 	bne	r2,zero,8010b4a4 <I2C_Write+0xb4>
        bSuccess = FALSE;
8010b4a0:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8010b4a4:	e17ffc17 	ldw	r5,-16(fp)
8010b4a8:	e13ffb17 	ldw	r4,-20(fp)
8010b4ac:	010b7cc0 	call	8010b7cc <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8010b4b0:	0106d604 	movi	r4,7000
8010b4b4:	01330f80 	call	801330f8 <usleep>
    
    return bSuccess;
8010b4b8:	e0bffa17 	ldw	r2,-24(fp)

}
8010b4bc:	e037883a 	mov	sp,fp
8010b4c0:	dfc00117 	ldw	ra,4(sp)
8010b4c4:	df000017 	ldw	fp,0(sp)
8010b4c8:	dec00204 	addi	sp,sp,8
8010b4cc:	f800283a 	ret

8010b4d0 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8010b4d0:	defff904 	addi	sp,sp,-28
8010b4d4:	de00012e 	bgeu	sp,et,8010b4dc <I2C_Read+0xc>
8010b4d8:	003b68fa 	trap	3
8010b4dc:	dfc00615 	stw	ra,24(sp)
8010b4e0:	df000515 	stw	fp,20(sp)
8010b4e4:	df000504 	addi	fp,sp,20
8010b4e8:	e13ffc15 	stw	r4,-16(fp)
8010b4ec:	e17ffd15 	stw	r5,-12(fp)
8010b4f0:	3007883a 	mov	r3,r6
8010b4f4:	3805883a 	mov	r2,r7
8010b4f8:	e0fffe05 	stb	r3,-8(fp)
8010b4fc:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8010b500:	00800044 	movi	r2,1
8010b504:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8010b508:	e17ffd17 	ldw	r5,-12(fp)
8010b50c:	e13ffc17 	ldw	r4,-16(fp)
8010b510:	010b7380 	call	8010b738 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8010b514:	e0bffe03 	ldbu	r2,-8(fp)
8010b518:	10803fcc 	andi	r2,r2,255
8010b51c:	100d883a 	mov	r6,r2
8010b520:	e17ffd17 	ldw	r5,-12(fp)
8010b524:	e13ffc17 	ldw	r4,-16(fp)
8010b528:	010b84c0 	call	8010b84c <i2c_write>
8010b52c:	1000011e 	bne	r2,zero,8010b534 <I2C_Read+0x64>
        bSuccess = FALSE;
8010b530:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8010b534:	e0bffb17 	ldw	r2,-20(fp)
8010b538:	10000726 	beq	r2,zero,8010b558 <I2C_Read+0x88>
8010b53c:	e0bfff03 	ldbu	r2,-4(fp)
8010b540:	100d883a 	mov	r6,r2
8010b544:	e17ffd17 	ldw	r5,-12(fp)
8010b548:	e13ffc17 	ldw	r4,-16(fp)
8010b54c:	010b84c0 	call	8010b84c <i2c_write>
8010b550:	1000011e 	bne	r2,zero,8010b558 <I2C_Read+0x88>
        bSuccess = FALSE;
8010b554:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8010b558:	e17ffd17 	ldw	r5,-12(fp)
8010b55c:	e13ffc17 	ldw	r4,-16(fp)
8010b560:	010b7380 	call	8010b738 <i2c_start>
    DeviceAddr |= 1; // Read
8010b564:	e0bffe03 	ldbu	r2,-8(fp)
8010b568:	10800054 	ori	r2,r2,1
8010b56c:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8010b570:	e0bffb17 	ldw	r2,-20(fp)
8010b574:	10000826 	beq	r2,zero,8010b598 <I2C_Read+0xc8>
8010b578:	e0bffe03 	ldbu	r2,-8(fp)
8010b57c:	10803fcc 	andi	r2,r2,255
8010b580:	100d883a 	mov	r6,r2
8010b584:	e17ffd17 	ldw	r5,-12(fp)
8010b588:	e13ffc17 	ldw	r4,-16(fp)
8010b58c:	010b84c0 	call	8010b84c <i2c_write>
8010b590:	1000011e 	bne	r2,zero,8010b598 <I2C_Read+0xc8>
        bSuccess = FALSE;
8010b594:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8010b598:	e0bffb17 	ldw	r2,-20(fp)
8010b59c:	10000526 	beq	r2,zero,8010b5b4 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8010b5a0:	000f883a 	mov	r7,zero
8010b5a4:	e1800217 	ldw	r6,8(fp)
8010b5a8:	e17ffd17 	ldw	r5,-12(fp)
8010b5ac:	e13ffc17 	ldw	r4,-16(fp)
8010b5b0:	010b9840 	call	8010b984 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8010b5b4:	e17ffd17 	ldw	r5,-12(fp)
8010b5b8:	e13ffc17 	ldw	r4,-16(fp)
8010b5bc:	010b7cc0 	call	8010b7cc <i2c_stop>
    
    return bSuccess;
8010b5c0:	e0bffb17 	ldw	r2,-20(fp)
}
8010b5c4:	e037883a 	mov	sp,fp
8010b5c8:	dfc00117 	ldw	ra,4(sp)
8010b5cc:	df000017 	ldw	fp,0(sp)
8010b5d0:	dec00204 	addi	sp,sp,8
8010b5d4:	f800283a 	ret

8010b5d8 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8010b5d8:	defff604 	addi	sp,sp,-40
8010b5dc:	de00012e 	bgeu	sp,et,8010b5e4 <I2C_MultipleRead+0xc>
8010b5e0:	003b68fa 	trap	3
8010b5e4:	dfc00915 	stw	ra,36(sp)
8010b5e8:	df000815 	stw	fp,32(sp)
8010b5ec:	df000804 	addi	fp,sp,32
8010b5f0:	e13ffb15 	stw	r4,-20(fp)
8010b5f4:	e17ffc15 	stw	r5,-16(fp)
8010b5f8:	3007883a 	mov	r3,r6
8010b5fc:	e1fffe15 	stw	r7,-8(fp)
8010b600:	e0800217 	ldw	r2,8(fp)
8010b604:	e0fffd05 	stb	r3,-12(fp)
8010b608:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8010b60c:	00800044 	movi	r2,1
8010b610:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8010b614:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8010b618:	e17ffc17 	ldw	r5,-16(fp)
8010b61c:	e13ffb17 	ldw	r4,-20(fp)
8010b620:	010b7380 	call	8010b738 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8010b624:	e0bffd03 	ldbu	r2,-12(fp)
8010b628:	10803fcc 	andi	r2,r2,255
8010b62c:	100d883a 	mov	r6,r2
8010b630:	e17ffc17 	ldw	r5,-16(fp)
8010b634:	e13ffb17 	ldw	r4,-20(fp)
8010b638:	010b84c0 	call	8010b84c <i2c_write>
8010b63c:	1000011e 	bne	r2,zero,8010b644 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8010b640:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8010b644:	e0bff917 	ldw	r2,-28(fp)
8010b648:	10000726 	beq	r2,zero,8010b668 <I2C_MultipleRead+0x90>
8010b64c:	e0bffa03 	ldbu	r2,-24(fp)
8010b650:	100d883a 	mov	r6,r2
8010b654:	e17ffc17 	ldw	r5,-16(fp)
8010b658:	e13ffb17 	ldw	r4,-20(fp)
8010b65c:	010b84c0 	call	8010b84c <i2c_write>
8010b660:	1000011e 	bne	r2,zero,8010b668 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8010b664:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8010b668:	e0bff917 	ldw	r2,-28(fp)
8010b66c:	10000326 	beq	r2,zero,8010b67c <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8010b670:	e17ffc17 	ldw	r5,-16(fp)
8010b674:	e13ffb17 	ldw	r4,-20(fp)
8010b678:	010b7380 	call	8010b738 <i2c_start>
    DeviceAddr |= 1; // Read
8010b67c:	e0bffd03 	ldbu	r2,-12(fp)
8010b680:	10800054 	ori	r2,r2,1
8010b684:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8010b688:	e0bff917 	ldw	r2,-28(fp)
8010b68c:	10000826 	beq	r2,zero,8010b6b0 <I2C_MultipleRead+0xd8>
8010b690:	e0bffd03 	ldbu	r2,-12(fp)
8010b694:	10803fcc 	andi	r2,r2,255
8010b698:	100d883a 	mov	r6,r2
8010b69c:	e17ffc17 	ldw	r5,-16(fp)
8010b6a0:	e13ffb17 	ldw	r4,-20(fp)
8010b6a4:	010b84c0 	call	8010b84c <i2c_write>
8010b6a8:	1000011e 	bne	r2,zero,8010b6b0 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8010b6ac:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8010b6b0:	e0bff917 	ldw	r2,-28(fp)
8010b6b4:	10001726 	beq	r2,zero,8010b714 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8010b6b8:	e03ff815 	stw	zero,-32(fp)
8010b6bc:	00001006 	br	8010b700 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8010b6c0:	e0bff817 	ldw	r2,-32(fp)
8010b6c4:	e0fffe17 	ldw	r3,-8(fp)
8010b6c8:	1889883a 	add	r4,r3,r2
8010b6cc:	e0bfff0b 	ldhu	r2,-4(fp)
8010b6d0:	10ffffc4 	addi	r3,r2,-1
8010b6d4:	e0bff817 	ldw	r2,-32(fp)
8010b6d8:	1884c03a 	cmpne	r2,r3,r2
8010b6dc:	10803fcc 	andi	r2,r2,255
8010b6e0:	100f883a 	mov	r7,r2
8010b6e4:	200d883a 	mov	r6,r4
8010b6e8:	e17ffc17 	ldw	r5,-16(fp)
8010b6ec:	e13ffb17 	ldw	r4,-20(fp)
8010b6f0:	010b9840 	call	8010b984 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8010b6f4:	e0bff817 	ldw	r2,-32(fp)
8010b6f8:	10800044 	addi	r2,r2,1
8010b6fc:	e0bff815 	stw	r2,-32(fp)
8010b700:	e0bfff0b 	ldhu	r2,-4(fp)
8010b704:	e0fff817 	ldw	r3,-32(fp)
8010b708:	1880020e 	bge	r3,r2,8010b714 <I2C_MultipleRead+0x13c>
8010b70c:	e0bff917 	ldw	r2,-28(fp)
8010b710:	103feb1e 	bne	r2,zero,8010b6c0 <__reset+0xfa0eb6c0>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8010b714:	e17ffc17 	ldw	r5,-16(fp)
8010b718:	e13ffb17 	ldw	r4,-20(fp)
8010b71c:	010b7cc0 	call	8010b7cc <i2c_stop>
    
    return bSuccess;    
8010b720:	e0bff917 	ldw	r2,-28(fp)
    
}
8010b724:	e037883a 	mov	sp,fp
8010b728:	dfc00117 	ldw	ra,4(sp)
8010b72c:	df000017 	ldw	fp,0(sp)
8010b730:	dec00204 	addi	sp,sp,8
8010b734:	f800283a 	ret

8010b738 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8010b738:	defffc04 	addi	sp,sp,-16
8010b73c:	de00012e 	bgeu	sp,et,8010b744 <i2c_start+0xc>
8010b740:	003b68fa 	trap	3
8010b744:	dfc00315 	stw	ra,12(sp)
8010b748:	df000215 	stw	fp,8(sp)
8010b74c:	df000204 	addi	fp,sp,8
8010b750:	e13ffe15 	stw	r4,-8(fp)
8010b754:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8010b758:	e0bfff17 	ldw	r2,-4(fp)
8010b75c:	10800104 	addi	r2,r2,4
8010b760:	1007883a 	mov	r3,r2
8010b764:	00800044 	movi	r2,1
8010b768:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8010b76c:	e0bfff17 	ldw	r2,-4(fp)
8010b770:	00c00044 	movi	r3,1
8010b774:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8010b778:	e0bffe17 	ldw	r2,-8(fp)
8010b77c:	00c00044 	movi	r3,1
8010b780:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8010b784:	01000044 	movi	r4,1
8010b788:	01330f80 	call	801330f8 <usleep>
     
    SDA_LOW(data_base); // data low
8010b78c:	e0bfff17 	ldw	r2,-4(fp)
8010b790:	0007883a 	mov	r3,zero
8010b794:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8010b798:	01000044 	movi	r4,1
8010b79c:	01330f80 	call	801330f8 <usleep>
    SCL_LOW(clk_base); // clock low
8010b7a0:	e0bffe17 	ldw	r2,-8(fp)
8010b7a4:	0007883a 	mov	r3,zero
8010b7a8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8010b7ac:	01000044 	movi	r4,1
8010b7b0:	01330f80 	call	801330f8 <usleep>
}
8010b7b4:	0001883a 	nop
8010b7b8:	e037883a 	mov	sp,fp
8010b7bc:	dfc00117 	ldw	ra,4(sp)
8010b7c0:	df000017 	ldw	fp,0(sp)
8010b7c4:	dec00204 	addi	sp,sp,8
8010b7c8:	f800283a 	ret

8010b7cc <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8010b7cc:	defffc04 	addi	sp,sp,-16
8010b7d0:	de00012e 	bgeu	sp,et,8010b7d8 <i2c_stop+0xc>
8010b7d4:	003b68fa 	trap	3
8010b7d8:	dfc00315 	stw	ra,12(sp)
8010b7dc:	df000215 	stw	fp,8(sp)
8010b7e0:	df000204 	addi	fp,sp,8
8010b7e4:	e13ffe15 	stw	r4,-8(fp)
8010b7e8:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8010b7ec:	e0bfff17 	ldw	r2,-4(fp)
8010b7f0:	10800104 	addi	r2,r2,4
8010b7f4:	1007883a 	mov	r3,r2
8010b7f8:	00800044 	movi	r2,1
8010b7fc:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8010b800:	e0bfff17 	ldw	r2,-4(fp)
8010b804:	0007883a 	mov	r3,zero
8010b808:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8010b80c:	e0bffe17 	ldw	r2,-8(fp)
8010b810:	00c00044 	movi	r3,1
8010b814:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8010b818:	01000044 	movi	r4,1
8010b81c:	01330f80 	call	801330f8 <usleep>
    SDA_HIGH(data_base); // data high
8010b820:	e0bfff17 	ldw	r2,-4(fp)
8010b824:	00c00044 	movi	r3,1
8010b828:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8010b82c:	01000044 	movi	r4,1
8010b830:	01330f80 	call	801330f8 <usleep>
    

    
}
8010b834:	0001883a 	nop
8010b838:	e037883a 	mov	sp,fp
8010b83c:	dfc00117 	ldw	ra,4(sp)
8010b840:	df000017 	ldw	fp,0(sp)
8010b844:	dec00204 	addi	sp,sp,8
8010b848:	f800283a 	ret

8010b84c <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8010b84c:	defff804 	addi	sp,sp,-32
8010b850:	de00012e 	bgeu	sp,et,8010b858 <i2c_write+0xc>
8010b854:	003b68fa 	trap	3
8010b858:	dfc00715 	stw	ra,28(sp)
8010b85c:	df000615 	stw	fp,24(sp)
8010b860:	df000604 	addi	fp,sp,24
8010b864:	e13ffd15 	stw	r4,-12(fp)
8010b868:	e17ffe15 	stw	r5,-8(fp)
8010b86c:	3005883a 	mov	r2,r6
8010b870:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8010b874:	00bfe004 	movi	r2,-128
8010b878:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8010b87c:	e0bffe17 	ldw	r2,-8(fp)
8010b880:	10800104 	addi	r2,r2,4
8010b884:	1007883a 	mov	r3,r2
8010b888:	00800044 	movi	r2,1
8010b88c:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8010b890:	e03ffb15 	stw	zero,-20(fp)
8010b894:	00001f06 	br	8010b914 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8010b898:	e0bffd17 	ldw	r2,-12(fp)
8010b89c:	0007883a 	mov	r3,zero
8010b8a0:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8010b8a4:	e0ffff03 	ldbu	r3,-4(fp)
8010b8a8:	e0bffa03 	ldbu	r2,-24(fp)
8010b8ac:	1884703a 	and	r2,r3,r2
8010b8b0:	10803fcc 	andi	r2,r2,255
8010b8b4:	10000426 	beq	r2,zero,8010b8c8 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8010b8b8:	e0bffe17 	ldw	r2,-8(fp)
8010b8bc:	00c00044 	movi	r3,1
8010b8c0:	10c00035 	stwio	r3,0(r2)
8010b8c4:	00000306 	br	8010b8d4 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8010b8c8:	e0bffe17 	ldw	r2,-8(fp)
8010b8cc:	0007883a 	mov	r3,zero
8010b8d0:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8010b8d4:	e0bffa03 	ldbu	r2,-24(fp)
8010b8d8:	1004d07a 	srli	r2,r2,1
8010b8dc:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8010b8e0:	e0bffd17 	ldw	r2,-12(fp)
8010b8e4:	00c00044 	movi	r3,1
8010b8e8:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8010b8ec:	01000044 	movi	r4,1
8010b8f0:	01330f80 	call	801330f8 <usleep>
        SCL_LOW(clk_base);
8010b8f4:	e0bffd17 	ldw	r2,-12(fp)
8010b8f8:	0007883a 	mov	r3,zero
8010b8fc:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8010b900:	01000044 	movi	r4,1
8010b904:	01330f80 	call	801330f8 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8010b908:	e0bffb17 	ldw	r2,-20(fp)
8010b90c:	10800044 	addi	r2,r2,1
8010b910:	e0bffb15 	stw	r2,-20(fp)
8010b914:	e0bffb17 	ldw	r2,-20(fp)
8010b918:	10800210 	cmplti	r2,r2,8
8010b91c:	103fde1e 	bne	r2,zero,8010b898 <__reset+0xfa0eb898>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8010b920:	e0bffe17 	ldw	r2,-8(fp)
8010b924:	10800104 	addi	r2,r2,4
8010b928:	0007883a 	mov	r3,zero
8010b92c:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8010b930:	e0bffd17 	ldw	r2,-12(fp)
8010b934:	00c00044 	movi	r3,1
8010b938:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8010b93c:	01000044 	movi	r4,1
8010b940:	01330f80 	call	801330f8 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8010b944:	e0bffe17 	ldw	r2,-8(fp)
8010b948:	10800037 	ldwio	r2,0(r2)
8010b94c:	1005003a 	cmpeq	r2,r2,zero
8010b950:	10803fcc 	andi	r2,r2,255
8010b954:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8010b958:	e0bffd17 	ldw	r2,-12(fp)
8010b95c:	0007883a 	mov	r3,zero
8010b960:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8010b964:	01000044 	movi	r4,1
8010b968:	01330f80 	call	801330f8 <usleep>
    return bAck;
8010b96c:	e0bffc17 	ldw	r2,-16(fp)
}    
8010b970:	e037883a 	mov	sp,fp
8010b974:	dfc00117 	ldw	ra,4(sp)
8010b978:	df000017 	ldw	fp,0(sp)
8010b97c:	dec00204 	addi	sp,sp,8
8010b980:	f800283a 	ret

8010b984 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8010b984:	defff804 	addi	sp,sp,-32
8010b988:	de00012e 	bgeu	sp,et,8010b990 <i2c_read+0xc>
8010b98c:	003b68fa 	trap	3
8010b990:	dfc00715 	stw	ra,28(sp)
8010b994:	df000615 	stw	fp,24(sp)
8010b998:	df000604 	addi	fp,sp,24
8010b99c:	e13ffc15 	stw	r4,-16(fp)
8010b9a0:	e17ffd15 	stw	r5,-12(fp)
8010b9a4:	e1bffe15 	stw	r6,-8(fp)
8010b9a8:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8010b9ac:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8010b9b0:	e0bffd17 	ldw	r2,-12(fp)
8010b9b4:	10800104 	addi	r2,r2,4
8010b9b8:	0007883a 	mov	r3,zero
8010b9bc:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8010b9c0:	e0bffc17 	ldw	r2,-16(fp)
8010b9c4:	0007883a 	mov	r3,zero
8010b9c8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8010b9cc:	01000044 	movi	r4,1
8010b9d0:	01330f80 	call	801330f8 <usleep>

    for(i=0;i<8;i++){
8010b9d4:	e03ffb15 	stw	zero,-20(fp)
8010b9d8:	00001606 	br	8010ba34 <i2c_read+0xb0>
        Data <<= 1;
8010b9dc:	e0bffa03 	ldbu	r2,-24(fp)
8010b9e0:	1085883a 	add	r2,r2,r2
8010b9e4:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8010b9e8:	e0bffc17 	ldw	r2,-16(fp)
8010b9ec:	00c00044 	movi	r3,1
8010b9f0:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8010b9f4:	01000044 	movi	r4,1
8010b9f8:	01330f80 	call	801330f8 <usleep>
        if (SDA_READ(data_base))  // read data   
8010b9fc:	e0bffd17 	ldw	r2,-12(fp)
8010ba00:	10800037 	ldwio	r2,0(r2)
8010ba04:	10000326 	beq	r2,zero,8010ba14 <i2c_read+0x90>
            Data |= 0x01;
8010ba08:	e0bffa03 	ldbu	r2,-24(fp)
8010ba0c:	10800054 	ori	r2,r2,1
8010ba10:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8010ba14:	e0bffc17 	ldw	r2,-16(fp)
8010ba18:	0007883a 	mov	r3,zero
8010ba1c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8010ba20:	01000044 	movi	r4,1
8010ba24:	01330f80 	call	801330f8 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8010ba28:	e0bffb17 	ldw	r2,-20(fp)
8010ba2c:	10800044 	addi	r2,r2,1
8010ba30:	e0bffb15 	stw	r2,-20(fp)
8010ba34:	e0bffb17 	ldw	r2,-20(fp)
8010ba38:	10800210 	cmplti	r2,r2,8
8010ba3c:	103fe71e 	bne	r2,zero,8010b9dc <__reset+0xfa0eb9dc>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8010ba40:	e0bffc17 	ldw	r2,-16(fp)
8010ba44:	0007883a 	mov	r3,zero
8010ba48:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8010ba4c:	e0bffd17 	ldw	r2,-12(fp)
8010ba50:	10800104 	addi	r2,r2,4
8010ba54:	1007883a 	mov	r3,r2
8010ba58:	00800044 	movi	r2,1
8010ba5c:	18800035 	stwio	r2,0(r3)
    if (bAck)
8010ba60:	e0bfff17 	ldw	r2,-4(fp)
8010ba64:	10000426 	beq	r2,zero,8010ba78 <i2c_read+0xf4>
        SDA_LOW(data_base);
8010ba68:	e0bffd17 	ldw	r2,-12(fp)
8010ba6c:	0007883a 	mov	r3,zero
8010ba70:	10c00035 	stwio	r3,0(r2)
8010ba74:	00000306 	br	8010ba84 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8010ba78:	e0bffd17 	ldw	r2,-12(fp)
8010ba7c:	00c00044 	movi	r3,1
8010ba80:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8010ba84:	e0bffc17 	ldw	r2,-16(fp)
8010ba88:	00c00044 	movi	r3,1
8010ba8c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8010ba90:	01000044 	movi	r4,1
8010ba94:	01330f80 	call	801330f8 <usleep>
    SCL_LOW(clk_base); // clock low
8010ba98:	e0bffc17 	ldw	r2,-16(fp)
8010ba9c:	0007883a 	mov	r3,zero
8010baa0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8010baa4:	01000044 	movi	r4,1
8010baa8:	01330f80 	call	801330f8 <usleep>
    SDA_LOW(data_base);  // data low
8010baac:	e0bffd17 	ldw	r2,-12(fp)
8010bab0:	0007883a 	mov	r3,zero
8010bab4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8010bab8:	01000044 	movi	r4,1
8010babc:	01330f80 	call	801330f8 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8010bac0:	e0bffe17 	ldw	r2,-8(fp)
8010bac4:	e0fffa03 	ldbu	r3,-24(fp)
8010bac8:	10c00005 	stb	r3,0(r2)
}
8010bacc:	0001883a 	nop
8010bad0:	e037883a 	mov	sp,fp
8010bad4:	dfc00117 	ldw	ra,4(sp)
8010bad8:	df000017 	ldw	fp,0(sp)
8010badc:	dec00204 	addi	sp,sp,8
8010bae0:	f800283a 	ret

8010bae4 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8010bae4:	defffd04 	addi	sp,sp,-12
8010bae8:	de00012e 	bgeu	sp,et,8010baf0 <bSetBoardLeds+0xc>
8010baec:	003b68fa 	trap	3
8010baf0:	df000215 	stw	fp,8(sp)
8010baf4:	df000204 	addi	fp,sp,8
8010baf8:	e13ffe15 	stw	r4,-8(fp)
8010bafc:	2805883a 	mov	r2,r5
8010bb00:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8010bb04:	e0bffe17 	ldw	r2,-8(fp)
8010bb08:	10800058 	cmpnei	r2,r2,1
8010bb0c:	1000071e 	bne	r2,zero,8010bb2c <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8010bb10:	e0bfff03 	ldbu	r2,-4(fp)
8010bb14:	0084303a 	nor	r2,zero,r2
8010bb18:	1007883a 	mov	r3,r2
8010bb1c:	d0a05003 	ldbu	r2,-32448(gp)
8010bb20:	1884703a 	and	r2,r3,r2
8010bb24:	d0a05005 	stb	r2,-32448(gp)
8010bb28:	00000406 	br	8010bb3c <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8010bb2c:	d0e05003 	ldbu	r3,-32448(gp)
8010bb30:	e0bfff03 	ldbu	r2,-4(fp)
8010bb34:	1884b03a 	or	r2,r3,r2
8010bb38:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8010bb3c:	d0a05003 	ldbu	r2,-32448(gp)
8010bb40:	10c03fcc 	andi	r3,r2,255
8010bb44:	00900034 	movhi	r2,16384
8010bb48:	10827404 	addi	r2,r2,2512
8010bb4c:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8010bb50:	00800044 	movi	r2,1
}
8010bb54:	e037883a 	mov	sp,fp
8010bb58:	df000017 	ldw	fp,0(sp)
8010bb5c:	dec00104 	addi	sp,sp,4
8010bb60:	f800283a 	ret

8010bb64 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8010bb64:	defffd04 	addi	sp,sp,-12
8010bb68:	de00012e 	bgeu	sp,et,8010bb70 <bSetPainelLeds+0xc>
8010bb6c:	003b68fa 	trap	3
8010bb70:	df000215 	stw	fp,8(sp)
8010bb74:	df000204 	addi	fp,sp,8
8010bb78:	e13ffe15 	stw	r4,-8(fp)
8010bb7c:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8010bb80:	e0bffe17 	ldw	r2,-8(fp)
8010bb84:	10800058 	cmpnei	r2,r2,1
8010bb88:	1000051e 	bne	r2,zero,8010bba0 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8010bb8c:	d0e00217 	ldw	r3,-32760(gp)
8010bb90:	e0bfff17 	ldw	r2,-4(fp)
8010bb94:	1884b03a 	or	r2,r3,r2
8010bb98:	d0a00215 	stw	r2,-32760(gp)
8010bb9c:	00000506 	br	8010bbb4 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8010bba0:	e0bfff17 	ldw	r2,-4(fp)
8010bba4:	0086303a 	nor	r3,zero,r2
8010bba8:	d0a00217 	ldw	r2,-32760(gp)
8010bbac:	1884703a 	and	r2,r3,r2
8010bbb0:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8010bbb4:	d0a00217 	ldw	r2,-32760(gp)
8010bbb8:	1007883a 	mov	r3,r2
8010bbbc:	00900034 	movhi	r2,16384
8010bbc0:	10824004 	addi	r2,r2,2304
8010bbc4:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8010bbc8:	00800044 	movi	r2,1
}
8010bbcc:	e037883a 	mov	sp,fp
8010bbd0:	df000017 	ldw	fp,0(sp)
8010bbd4:	dec00104 	addi	sp,sp,4
8010bbd8:	f800283a 	ret

8010bbdc <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8010bbdc:	defffc04 	addi	sp,sp,-16
8010bbe0:	de00012e 	bgeu	sp,et,8010bbe8 <msgdma_write_extended_descriptor+0xc>
8010bbe4:	003b68fa 	trap	3
8010bbe8:	df000315 	stw	fp,12(sp)
8010bbec:	df000304 	addi	fp,sp,12
8010bbf0:	e13ffd15 	stw	r4,-12(fp)
8010bbf4:	e17ffe15 	stw	r5,-8(fp)
8010bbf8:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8010bbfc:	e0bffd17 	ldw	r2,-12(fp)
8010bc00:	10800037 	ldwio	r2,0(r2)
8010bc04:	1080010c 	andi	r2,r2,4
8010bc08:	10000226 	beq	r2,zero,8010bc14 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8010bc0c:	00bff904 	movi	r2,-28
8010bc10:	00003d06 	br	8010bd08 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8010bc14:	e0bfff17 	ldw	r2,-4(fp)
8010bc18:	10800017 	ldw	r2,0(r2)
8010bc1c:	1007883a 	mov	r3,r2
8010bc20:	e0bffe17 	ldw	r2,-8(fp)
8010bc24:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8010bc28:	e0bffe17 	ldw	r2,-8(fp)
8010bc2c:	10800104 	addi	r2,r2,4
8010bc30:	e0ffff17 	ldw	r3,-4(fp)
8010bc34:	18c00117 	ldw	r3,4(r3)
8010bc38:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8010bc3c:	e0bffe17 	ldw	r2,-8(fp)
8010bc40:	10800204 	addi	r2,r2,8
8010bc44:	e0ffff17 	ldw	r3,-4(fp)
8010bc48:	18c00217 	ldw	r3,8(r3)
8010bc4c:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8010bc50:	e0bffe17 	ldw	r2,-8(fp)
8010bc54:	10800304 	addi	r2,r2,12
8010bc58:	e0ffff17 	ldw	r3,-4(fp)
8010bc5c:	18c0030b 	ldhu	r3,12(r3)
8010bc60:	18ffffcc 	andi	r3,r3,65535
8010bc64:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8010bc68:	e0bffe17 	ldw	r2,-8(fp)
8010bc6c:	10800384 	addi	r2,r2,14
8010bc70:	e0ffff17 	ldw	r3,-4(fp)
8010bc74:	18c00383 	ldbu	r3,14(r3)
8010bc78:	18c03fcc 	andi	r3,r3,255
8010bc7c:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8010bc80:	e0bffe17 	ldw	r2,-8(fp)
8010bc84:	108003c4 	addi	r2,r2,15
8010bc88:	e0ffff17 	ldw	r3,-4(fp)
8010bc8c:	18c003c3 	ldbu	r3,15(r3)
8010bc90:	18c03fcc 	andi	r3,r3,255
8010bc94:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8010bc98:	e0bffe17 	ldw	r2,-8(fp)
8010bc9c:	10800404 	addi	r2,r2,16
8010bca0:	e0ffff17 	ldw	r3,-4(fp)
8010bca4:	18c0040b 	ldhu	r3,16(r3)
8010bca8:	18ffffcc 	andi	r3,r3,65535
8010bcac:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8010bcb0:	e0bffe17 	ldw	r2,-8(fp)
8010bcb4:	10800484 	addi	r2,r2,18
8010bcb8:	e0ffff17 	ldw	r3,-4(fp)
8010bcbc:	18c0048b 	ldhu	r3,18(r3)
8010bcc0:	18ffffcc 	andi	r3,r3,65535
8010bcc4:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8010bcc8:	e0bffe17 	ldw	r2,-8(fp)
8010bccc:	10800504 	addi	r2,r2,20
8010bcd0:	e0ffff17 	ldw	r3,-4(fp)
8010bcd4:	18c00517 	ldw	r3,20(r3)
8010bcd8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8010bcdc:	e0bffe17 	ldw	r2,-8(fp)
8010bce0:	10800604 	addi	r2,r2,24
8010bce4:	e0ffff17 	ldw	r3,-4(fp)
8010bce8:	18c00617 	ldw	r3,24(r3)
8010bcec:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8010bcf0:	e0bffe17 	ldw	r2,-8(fp)
8010bcf4:	10800704 	addi	r2,r2,28
8010bcf8:	e0ffff17 	ldw	r3,-4(fp)
8010bcfc:	18c00717 	ldw	r3,28(r3)
8010bd00:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8010bd04:	0005883a 	mov	r2,zero
}
8010bd08:	e037883a 	mov	sp,fp
8010bd0c:	df000017 	ldw	fp,0(sp)
8010bd10:	dec00104 	addi	sp,sp,4
8010bd14:	f800283a 	ret

8010bd18 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8010bd18:	defff604 	addi	sp,sp,-40
8010bd1c:	de00012e 	bgeu	sp,et,8010bd24 <msgdma_construct_extended_descriptor+0xc>
8010bd20:	003b68fa 	trap	3
8010bd24:	df000915 	stw	fp,36(sp)
8010bd28:	df000904 	addi	fp,sp,36
8010bd2c:	e13ff715 	stw	r4,-36(fp)
8010bd30:	e17ff815 	stw	r5,-32(fp)
8010bd34:	e1bff915 	stw	r6,-28(fp)
8010bd38:	e1fffa15 	stw	r7,-24(fp)
8010bd3c:	e1800517 	ldw	r6,20(fp)
8010bd40:	e1400617 	ldw	r5,24(fp)
8010bd44:	e1000717 	ldw	r4,28(fp)
8010bd48:	e0c00817 	ldw	r3,32(fp)
8010bd4c:	e0800917 	ldw	r2,36(fp)
8010bd50:	e1bffb0d 	sth	r6,-20(fp)
8010bd54:	e17ffc05 	stb	r5,-16(fp)
8010bd58:	e13ffd05 	stb	r4,-12(fp)
8010bd5c:	e0fffe0d 	sth	r3,-8(fp)
8010bd60:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8010bd64:	e0bff717 	ldw	r2,-36(fp)
8010bd68:	10c01217 	ldw	r3,72(r2)
8010bd6c:	e0800117 	ldw	r2,4(fp)
8010bd70:	18801936 	bltu	r3,r2,8010bdd8 <msgdma_construct_extended_descriptor+0xc0>
8010bd74:	e13ff717 	ldw	r4,-36(fp)
8010bd78:	20801317 	ldw	r2,76(r4)
8010bd7c:	20c01417 	ldw	r3,80(r4)
8010bd80:	e13ffe0b 	ldhu	r4,-8(fp)
8010bd84:	213fffcc 	andi	r4,r4,65535
8010bd88:	2015883a 	mov	r10,r4
8010bd8c:	0017883a 	mov	r11,zero
8010bd90:	1ac01136 	bltu	r3,r11,8010bdd8 <msgdma_construct_extended_descriptor+0xc0>
8010bd94:	58c0011e 	bne	r11,r3,8010bd9c <msgdma_construct_extended_descriptor+0x84>
8010bd98:	12800f36 	bltu	r2,r10,8010bdd8 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8010bd9c:	e13ff717 	ldw	r4,-36(fp)
8010bda0:	20801317 	ldw	r2,76(r4)
8010bda4:	20c01417 	ldw	r3,80(r4)
8010bda8:	e13fff0b 	ldhu	r4,-4(fp)
8010bdac:	213fffcc 	andi	r4,r4,65535
8010bdb0:	2011883a 	mov	r8,r4
8010bdb4:	0013883a 	mov	r9,zero
8010bdb8:	1a400736 	bltu	r3,r9,8010bdd8 <msgdma_construct_extended_descriptor+0xc0>
8010bdbc:	48c0011e 	bne	r9,r3,8010bdc4 <msgdma_construct_extended_descriptor+0xac>
8010bdc0:	12000536 	bltu	r2,r8,8010bdd8 <msgdma_construct_extended_descriptor+0xc0>
8010bdc4:	e0bff717 	ldw	r2,-36(fp)
8010bdc8:	10801703 	ldbu	r2,92(r2)
8010bdcc:	10803fcc 	andi	r2,r2,255
8010bdd0:	10800060 	cmpeqi	r2,r2,1
8010bdd4:	1000021e 	bne	r2,zero,8010bde0 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8010bdd8:	00bffa84 	movi	r2,-22
8010bddc:	00002306 	br	8010be6c <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8010bde0:	e0bff817 	ldw	r2,-32(fp)
8010bde4:	e0fff917 	ldw	r3,-28(fp)
8010bde8:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8010bdec:	e0bff817 	ldw	r2,-32(fp)
8010bdf0:	e0fffa17 	ldw	r3,-24(fp)
8010bdf4:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8010bdf8:	e0bff817 	ldw	r2,-32(fp)
8010bdfc:	e0c00117 	ldw	r3,4(fp)
8010be00:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8010be04:	e0bff817 	ldw	r2,-32(fp)
8010be08:	e0fffb0b 	ldhu	r3,-20(fp)
8010be0c:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8010be10:	e0bff817 	ldw	r2,-32(fp)
8010be14:	e0fffc03 	ldbu	r3,-16(fp)
8010be18:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8010be1c:	e0bff817 	ldw	r2,-32(fp)
8010be20:	e0fffd03 	ldbu	r3,-12(fp)
8010be24:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8010be28:	e0bff817 	ldw	r2,-32(fp)
8010be2c:	e0fffe0b 	ldhu	r3,-8(fp)
8010be30:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8010be34:	e0bff817 	ldw	r2,-32(fp)
8010be38:	e0ffff0b 	ldhu	r3,-4(fp)
8010be3c:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8010be40:	e0bff817 	ldw	r2,-32(fp)
8010be44:	e0c00317 	ldw	r3,12(fp)
8010be48:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8010be4c:	e0bff817 	ldw	r2,-32(fp)
8010be50:	e0c00417 	ldw	r3,16(fp)
8010be54:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8010be58:	e0800217 	ldw	r2,8(fp)
8010be5c:	10e00034 	orhi	r3,r2,32768
8010be60:	e0bff817 	ldw	r2,-32(fp)
8010be64:	10c00715 	stw	r3,28(r2)

	return 0;
8010be68:	0005883a 	mov	r2,zero

}
8010be6c:	e037883a 	mov	sp,fp
8010be70:	df000017 	ldw	fp,0(sp)
8010be74:	dec00104 	addi	sp,sp,4
8010be78:	f800283a 	ret

8010be7c <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8010be7c:	deffee04 	addi	sp,sp,-72
8010be80:	de00012e 	bgeu	sp,et,8010be88 <msgdma_descriptor_async_transfer+0xc>
8010be84:	003b68fa 	trap	3
8010be88:	dfc01115 	stw	ra,68(sp)
8010be8c:	df001015 	stw	fp,64(sp)
8010be90:	df001004 	addi	fp,sp,64
8010be94:	e13ffd15 	stw	r4,-12(fp)
8010be98:	e17ffe15 	stw	r5,-8(fp)
8010be9c:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8010bea0:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8010bea4:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8010bea8:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8010beac:	e0bffd17 	ldw	r2,-12(fp)
8010beb0:	10800317 	ldw	r2,12(r2)
8010beb4:	10800204 	addi	r2,r2,8
8010beb8:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8010bebc:	10bfffcc 	andi	r2,r2,65535
8010bec0:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8010bec4:	e0bffd17 	ldw	r2,-12(fp)
8010bec8:	10800317 	ldw	r2,12(r2)
8010becc:	10800204 	addi	r2,r2,8
8010bed0:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8010bed4:	1004d43a 	srli	r2,r2,16
8010bed8:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8010bedc:	e0bffd17 	ldw	r2,-12(fp)
8010bee0:	10800917 	ldw	r2,36(r2)
8010bee4:	e0fff417 	ldw	r3,-48(fp)
8010bee8:	1880042e 	bgeu	r3,r2,8010befc <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8010beec:	e0bffd17 	ldw	r2,-12(fp)
8010bef0:	10800917 	ldw	r2,36(r2)
8010bef4:	e0fff317 	ldw	r3,-52(fp)
8010bef8:	18800236 	bltu	r3,r2,8010bf04 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8010befc:	00bff904 	movi	r2,-28
8010bf00:	00009106 	br	8010c148 <msgdma_descriptor_async_transfer+0x2cc>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8010bf04:	e0bffd17 	ldw	r2,-12(fp)
8010bf08:	10801817 	ldw	r2,96(r2)
8010bf0c:	e0bff615 	stw	r2,-40(fp)
8010bf10:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8010bf14:	e0bffc0b 	ldhu	r2,-16(fp)
8010bf18:	e0fffc84 	addi	r3,fp,-14
8010bf1c:	180d883a 	mov	r6,r3
8010bf20:	100b883a 	mov	r5,r2
8010bf24:	e13ff617 	ldw	r4,-40(fp)
8010bf28:	0139efc0 	call	80139efc <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8010bf2c:	00800804 	movi	r2,32
8010bf30:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8010bf34:	0005303a 	rdctl	r2,status
8010bf38:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8010bf3c:	e0fff717 	ldw	r3,-36(fp)
8010bf40:	00bfff84 	movi	r2,-2
8010bf44:	1884703a 	and	r2,r3,r2
8010bf48:	1001703a 	wrctl	status,r2
  
  return context;
8010bf4c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8010bf50:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8010bf54:	e0bffd17 	ldw	r2,-12(fp)
8010bf58:	10800317 	ldw	r2,12(r2)
8010bf5c:	10800104 	addi	r2,r2,4
8010bf60:	e0fff117 	ldw	r3,-60(fp)
8010bf64:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8010bf68:	e0bffd17 	ldw	r2,-12(fp)
8010bf6c:	10800317 	ldw	r2,12(r2)
8010bf70:	e0fffd17 	ldw	r3,-12(fp)
8010bf74:	18c00317 	ldw	r3,12(r3)
8010bf78:	18c00037 	ldwio	r3,0(r3)
8010bf7c:	10c00035 	stwio	r3,0(r2)
8010bf80:	e0bff217 	ldw	r2,-56(fp)
8010bf84:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8010bf88:	e0bffb17 	ldw	r2,-20(fp)
8010bf8c:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8010bf90:	e0bffe17 	ldw	r2,-8(fp)
8010bf94:	10000926 	beq	r2,zero,8010bfbc <msgdma_descriptor_async_transfer+0x140>
8010bf98:	e0bfff17 	ldw	r2,-4(fp)
8010bf9c:	1000071e 	bne	r2,zero,8010bfbc <msgdma_descriptor_async_transfer+0x140>
		counter = 0; /* reset counter */
8010bfa0:	e03ff00d 	sth	zero,-64(fp)
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8010bfa4:	e0bffd17 	ldw	r2,-12(fp)
8010bfa8:	10801817 	ldw	r2,96(r2)
8010bfac:	1009883a 	mov	r4,r2
8010bfb0:	013a2840 	call	8013a284 <OSSemPost>

		return -ETIME;
8010bfb4:	00bff084 	movi	r2,-62
8010bfb8:	00006306 	br	8010c148 <msgdma_descriptor_async_transfer+0x2cc>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8010bfbc:	e0bffe17 	ldw	r2,-8(fp)
8010bfc0:	10001c1e 	bne	r2,zero,8010c034 <msgdma_descriptor_async_transfer+0x1b8>
8010bfc4:	e0bfff17 	ldw	r2,-4(fp)
8010bfc8:	10001a26 	beq	r2,zero,8010c034 <msgdma_descriptor_async_transfer+0x1b8>
		counter = 0; /* reset counter */
8010bfcc:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8010bfd0:	00000e06 	br	8010c00c <msgdma_descriptor_async_transfer+0x190>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8010bfd4:	01000044 	movi	r4,1
8010bfd8:	01318f00 	call	801318f0 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8010bfdc:	e0bff00b 	ldhu	r2,-64(fp)
8010bfe0:	1084e230 	cmpltui	r2,r2,5000
8010bfe4:	1000061e 	bne	r2,zero,8010c000 <msgdma_descriptor_async_transfer+0x184>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8010bfe8:	e0bffd17 	ldw	r2,-12(fp)
8010bfec:	10801817 	ldw	r2,96(r2)
8010bff0:	1009883a 	mov	r4,r2
8010bff4:	013a2840 	call	8013a284 <OSSemPost>

				return -ETIME;
8010bff8:	00bff084 	movi	r2,-62
8010bffc:	00005206 	br	8010c148 <msgdma_descriptor_async_transfer+0x2cc>
			}
			counter++;
8010c000:	e0bff00b 	ldhu	r2,-64(fp)
8010c004:	10800044 	addi	r2,r2,1
8010c008:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8010c00c:	e0bffd17 	ldw	r2,-12(fp)
8010c010:	10c00317 	ldw	r3,12(r2)
8010c014:	e0bffd17 	ldw	r2,-12(fp)
8010c018:	10800417 	ldw	r2,16(r2)
8010c01c:	e1bfff17 	ldw	r6,-4(fp)
8010c020:	100b883a 	mov	r5,r2
8010c024:	1809883a 	mov	r4,r3
8010c028:	010bbdc0 	call	8010bbdc <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8010c02c:	103fe91e 	bne	r2,zero,8010bfd4 <__reset+0xfa0ebfd4>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8010c030:	00000606 	br	8010c04c <msgdma_descriptor_async_transfer+0x1d0>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8010c034:	e0bffd17 	ldw	r2,-12(fp)
8010c038:	10801817 	ldw	r2,96(r2)
8010c03c:	1009883a 	mov	r4,r2
8010c040:	013a2840 	call	8013a284 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8010c044:	00bfffc4 	movi	r2,-1
8010c048:	00003f06 	br	8010c148 <msgdma_descriptor_async_transfer+0x2cc>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8010c04c:	e0bffd17 	ldw	r2,-12(fp)
8010c050:	10800b17 	ldw	r2,44(r2)
8010c054:	10001c26 	beq	r2,zero,8010c0c8 <msgdma_descriptor_async_transfer+0x24c>

		control |= (dev->control |
8010c058:	e0bffd17 	ldw	r2,-12(fp)
8010c05c:	10c00d17 	ldw	r3,52(r2)
8010c060:	e0bff117 	ldw	r2,-60(fp)
8010c064:	1884b03a 	or	r2,r3,r2
8010c068:	10800514 	ori	r2,r2,20
8010c06c:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8010c070:	e0fff117 	ldw	r3,-60(fp)
8010c074:	00bff7c4 	movi	r2,-33
8010c078:	1884703a 	and	r2,r3,r2
8010c07c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8010c080:	0005303a 	rdctl	r2,status
8010c084:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8010c088:	e0fff917 	ldw	r3,-28(fp)
8010c08c:	00bfff84 	movi	r2,-2
8010c090:	1884703a 	and	r2,r3,r2
8010c094:	1001703a 	wrctl	status,r2
  
  return context;
8010c098:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8010c09c:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8010c0a0:	e0bffd17 	ldw	r2,-12(fp)
8010c0a4:	10800317 	ldw	r2,12(r2)
8010c0a8:	10800104 	addi	r2,r2,4
8010c0ac:	e0fff117 	ldw	r3,-60(fp)
8010c0b0:	10c00035 	stwio	r3,0(r2)
8010c0b4:	e0bff217 	ldw	r2,-56(fp)
8010c0b8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8010c0bc:	e0bff517 	ldw	r2,-44(fp)
8010c0c0:	1001703a 	wrctl	status,r2
8010c0c4:	00001b06 	br	8010c134 <msgdma_descriptor_async_transfer+0x2b8>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8010c0c8:	e0bffd17 	ldw	r2,-12(fp)
8010c0cc:	10c00d17 	ldw	r3,52(r2)
8010c0d0:	e0bff117 	ldw	r2,-60(fp)
8010c0d4:	1884b03a 	or	r2,r3,r2
8010c0d8:	10800114 	ori	r2,r2,4
8010c0dc:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8010c0e0:	e0fff117 	ldw	r3,-60(fp)
8010c0e4:	00bff3c4 	movi	r2,-49
8010c0e8:	1884703a 	and	r2,r3,r2
8010c0ec:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8010c0f0:	0005303a 	rdctl	r2,status
8010c0f4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8010c0f8:	e0fffa17 	ldw	r3,-24(fp)
8010c0fc:	00bfff84 	movi	r2,-2
8010c100:	1884703a 	and	r2,r3,r2
8010c104:	1001703a 	wrctl	status,r2
  
  return context;
8010c108:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8010c10c:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8010c110:	e0bffd17 	ldw	r2,-12(fp)
8010c114:	10800317 	ldw	r2,12(r2)
8010c118:	10800104 	addi	r2,r2,4
8010c11c:	e0fff117 	ldw	r3,-60(fp)
8010c120:	10c00035 	stwio	r3,0(r2)
8010c124:	e0bff217 	ldw	r2,-56(fp)
8010c128:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8010c12c:	e0bff817 	ldw	r2,-32(fp)
8010c130:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8010c134:	e0bffd17 	ldw	r2,-12(fp)
8010c138:	10801817 	ldw	r2,96(r2)
8010c13c:	1009883a 	mov	r4,r2
8010c140:	013a2840 	call	8013a284 <OSSemPost>

	return 0;
8010c144:	0005883a 	mov	r2,zero
}
8010c148:	e037883a 	mov	sp,fp
8010c14c:	dfc00117 	ldw	ra,4(sp)
8010c150:	df000017 	ldw	fp,0(sp)
8010c154:	dec00204 	addi	sp,sp,8
8010c158:	f800283a 	ret

8010c15c <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8010c15c:	deffee04 	addi	sp,sp,-72
8010c160:	de00012e 	bgeu	sp,et,8010c168 <msgdma_descriptor_sync_transfer+0xc>
8010c164:	003b68fa 	trap	3
8010c168:	dfc01115 	stw	ra,68(sp)
8010c16c:	df001015 	stw	fp,64(sp)
8010c170:	df001004 	addi	fp,sp,64
8010c174:	e13ffd15 	stw	r4,-12(fp)
8010c178:	e17ffe15 	stw	r5,-8(fp)
8010c17c:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8010c180:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8010c184:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8010c188:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8010c18c:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8010c190:	e0bffd17 	ldw	r2,-12(fp)
8010c194:	10800317 	ldw	r2,12(r2)
8010c198:	10800204 	addi	r2,r2,8
8010c19c:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8010c1a0:	10bfffcc 	andi	r2,r2,65535
8010c1a4:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8010c1a8:	e0bffd17 	ldw	r2,-12(fp)
8010c1ac:	10800317 	ldw	r2,12(r2)
8010c1b0:	10800204 	addi	r2,r2,8
8010c1b4:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8010c1b8:	1004d43a 	srli	r2,r2,16
8010c1bc:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8010c1c0:	00807804 	movi	r2,480
8010c1c4:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8010c1c8:	00001606 	br	8010c224 <msgdma_descriptor_sync_transfer+0xc8>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8010c1cc:	01000044 	movi	r4,1
8010c1d0:	01318f00 	call	801318f0 <alt_busy_sleep>
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
		fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
	}
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8010c1d4:	e0bff10b 	ldhu	r2,-60(fp)
8010c1d8:	1084e230 	cmpltui	r2,r2,5000
8010c1dc:	1000021e 	bne	r2,zero,8010c1e8 <msgdma_descriptor_sync_transfer+0x8c>
#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
		debug(fp, "time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
	}
#endif
			return -ETIME;
8010c1e0:	00bff084 	movi	r2,-62
8010c1e4:	0000bb06 	br	8010c4d4 <msgdma_descriptor_sync_transfer+0x378>
		}
		counter++;
8010c1e8:	e0bff10b 	ldhu	r2,-60(fp)
8010c1ec:	10800044 	addi	r2,r2,1
8010c1f0:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8010c1f4:	e0bffd17 	ldw	r2,-12(fp)
8010c1f8:	10800317 	ldw	r2,12(r2)
8010c1fc:	10800204 	addi	r2,r2,8
8010c200:	10800037 	ldwio	r2,0(r2)
	}
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8010c204:	10bfffcc 	andi	r2,r2,65535
8010c208:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8010c20c:	e0bffd17 	ldw	r2,-12(fp)
8010c210:	10800317 	ldw	r2,12(r2)
8010c214:	10800204 	addi	r2,r2,8
8010c218:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8010c21c:	1004d43a 	srli	r2,r2,16
8010c220:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8010c224:	e0bffd17 	ldw	r2,-12(fp)
8010c228:	10800917 	ldw	r2,36(r2)
8010c22c:	e0fff317 	ldw	r3,-52(fp)
8010c230:	18bfe62e 	bgeu	r3,r2,8010c1cc <__reset+0xfa0ec1cc>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8010c234:	e0bffd17 	ldw	r2,-12(fp)
8010c238:	10800917 	ldw	r2,36(r2)
8010c23c:	e0fff217 	ldw	r3,-56(fp)
8010c240:	18bfe22e 	bgeu	r3,r2,8010c1cc <__reset+0xfa0ec1cc>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8010c244:	e0bffd17 	ldw	r2,-12(fp)
8010c248:	10801817 	ldw	r2,96(r2)
8010c24c:	e0bff815 	stw	r2,-32(fp)
8010c250:	e03ffc0d 	sth	zero,-16(fp)
8010c254:	e0bffc0b 	ldhu	r2,-16(fp)
8010c258:	e0fffc84 	addi	r3,fp,-14
8010c25c:	180d883a 	mov	r6,r3
8010c260:	100b883a 	mov	r5,r2
8010c264:	e13ff817 	ldw	r4,-32(fp)
8010c268:	0139efc0 	call	80139efc <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8010c26c:	0005303a 	rdctl	r2,status
8010c270:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8010c274:	e0fffb17 	ldw	r3,-20(fp)
8010c278:	00bfff84 	movi	r2,-2
8010c27c:	1884703a 	and	r2,r3,r2
8010c280:	1001703a 	wrctl	status,r2
  
  return context;
8010c284:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8010c288:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8010c28c:	e0bffd17 	ldw	r2,-12(fp)
8010c290:	10800317 	ldw	r2,12(r2)
8010c294:	10800104 	addi	r2,r2,4
8010c298:	00c00804 	movi	r3,32
8010c29c:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8010c2a0:	e0bffd17 	ldw	r2,-12(fp)
8010c2a4:	10800317 	ldw	r2,12(r2)
8010c2a8:	e0fffd17 	ldw	r3,-12(fp)
8010c2ac:	18c00317 	ldw	r3,12(r3)
8010c2b0:	18c00037 	ldwio	r3,0(r3)
8010c2b4:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8010c2b8:	e0bffe17 	ldw	r2,-8(fp)
8010c2bc:	10000926 	beq	r2,zero,8010c2e4 <msgdma_descriptor_sync_transfer+0x188>
8010c2c0:	e0bfff17 	ldw	r2,-4(fp)
8010c2c4:	1000071e 	bne	r2,zero,8010c2e4 <msgdma_descriptor_sync_transfer+0x188>
		counter = 0; /* reset counter */
8010c2c8:	e03ff10d 	sth	zero,-60(fp)
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8010c2cc:	e0bffd17 	ldw	r2,-12(fp)
8010c2d0:	10801817 	ldw	r2,96(r2)
8010c2d4:	1009883a 	mov	r4,r2
8010c2d8:	013a2840 	call	8013a284 <OSSemPost>

		return -ETIME;
8010c2dc:	00bff084 	movi	r2,-62
8010c2e0:	00007c06 	br	8010c4d4 <msgdma_descriptor_sync_transfer+0x378>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8010c2e4:	e0bffe17 	ldw	r2,-8(fp)
8010c2e8:	10001c1e 	bne	r2,zero,8010c35c <msgdma_descriptor_sync_transfer+0x200>
8010c2ec:	e0bfff17 	ldw	r2,-4(fp)
8010c2f0:	10001a26 	beq	r2,zero,8010c35c <msgdma_descriptor_sync_transfer+0x200>
		counter = 0; /* reset counter */
8010c2f4:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8010c2f8:	00000e06 	br	8010c334 <msgdma_descriptor_sync_transfer+0x1d8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8010c2fc:	01000044 	movi	r4,1
8010c300:	01318f00 	call	801318f0 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8010c304:	e0bff10b 	ldhu	r2,-60(fp)
8010c308:	1084e230 	cmpltui	r2,r2,5000
8010c30c:	1000061e 	bne	r2,zero,8010c328 <msgdma_descriptor_sync_transfer+0x1cc>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8010c310:	e0bffd17 	ldw	r2,-12(fp)
8010c314:	10801817 	ldw	r2,96(r2)
8010c318:	1009883a 	mov	r4,r2
8010c31c:	013a2840 	call	8013a284 <OSSemPost>

				return -ETIME;
8010c320:	00bff084 	movi	r2,-62
8010c324:	00006b06 	br	8010c4d4 <msgdma_descriptor_sync_transfer+0x378>
			}
			counter++;
8010c328:	e0bff10b 	ldhu	r2,-60(fp)
8010c32c:	10800044 	addi	r2,r2,1
8010c330:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8010c334:	e0bffd17 	ldw	r2,-12(fp)
8010c338:	10c00317 	ldw	r3,12(r2)
8010c33c:	e0bffd17 	ldw	r2,-12(fp)
8010c340:	10800417 	ldw	r2,16(r2)
8010c344:	e1bfff17 	ldw	r6,-4(fp)
8010c348:	100b883a 	mov	r5,r2
8010c34c:	1809883a 	mov	r4,r3
8010c350:	010bbdc0 	call	8010bbdc <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8010c354:	103fe91e 	bne	r2,zero,8010c2fc <__reset+0xfa0ec2fc>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8010c358:	00000606 	br	8010c374 <msgdma_descriptor_sync_transfer+0x218>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8010c35c:	e0bffd17 	ldw	r2,-12(fp)
8010c360:	10801817 	ldw	r2,96(r2)
8010c364:	1009883a 	mov	r4,r2
8010c368:	013a2840 	call	8013a284 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8010c36c:	00bfffc4 	movi	r2,-1
8010c370:	00005806 	br	8010c4d4 <msgdma_descriptor_sync_transfer+0x378>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8010c374:	e0bffd17 	ldw	r2,-12(fp)
8010c378:	10800317 	ldw	r2,12(r2)
8010c37c:	10800104 	addi	r2,r2,4
8010c380:	e0fffd17 	ldw	r3,-12(fp)
8010c384:	19000d17 	ldw	r4,52(r3)
8010c388:	00fff2c4 	movi	r3,-53
8010c38c:	20c6703a 	and	r3,r4,r3
8010c390:	18c00114 	ori	r3,r3,4
8010c394:	10c00035 	stwio	r3,0(r2)
8010c398:	e0bff517 	ldw	r2,-44(fp)
8010c39c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8010c3a0:	e0bff717 	ldw	r2,-36(fp)
8010c3a4:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8010c3a8:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8010c3ac:	e0bffd17 	ldw	r2,-12(fp)
8010c3b0:	10800317 	ldw	r2,12(r2)
8010c3b4:	10800037 	ldwio	r2,0(r2)
8010c3b8:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8010c3bc:	00001206 	br	8010c408 <msgdma_descriptor_sync_transfer+0x2ac>
		alt_busy_sleep(1); /* delay 1us */
8010c3c0:	01000044 	movi	r4,1
8010c3c4:	01318f00 	call	801318f0 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8010c3c8:	e0bff10b 	ldhu	r2,-60(fp)
8010c3cc:	1084e230 	cmpltui	r2,r2,5000
8010c3d0:	1000061e 	bne	r2,zero,8010c3ec <msgdma_descriptor_sync_transfer+0x290>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8010c3d4:	e0bffd17 	ldw	r2,-12(fp)
8010c3d8:	10801817 	ldw	r2,96(r2)
8010c3dc:	1009883a 	mov	r4,r2
8010c3e0:	013a2840 	call	8013a284 <OSSemPost>

			return -ETIME;
8010c3e4:	00bff084 	movi	r2,-62
8010c3e8:	00003a06 	br	8010c4d4 <msgdma_descriptor_sync_transfer+0x378>
		}
		counter++;
8010c3ec:	e0bff10b 	ldhu	r2,-60(fp)
8010c3f0:	10800044 	addi	r2,r2,1
8010c3f4:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8010c3f8:	e0bffd17 	ldw	r2,-12(fp)
8010c3fc:	10800317 	ldw	r2,12(r2)
8010c400:	10800037 	ldwio	r2,0(r2)
8010c404:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8010c408:	e0fff017 	ldw	r3,-64(fp)
8010c40c:	e0bff617 	ldw	r2,-40(fp)
8010c410:	1884703a 	and	r2,r3,r2
8010c414:	1000031e 	bne	r2,zero,8010c424 <msgdma_descriptor_sync_transfer+0x2c8>
8010c418:	e0bff017 	ldw	r2,-64(fp)
8010c41c:	1080004c 	andi	r2,r2,1
8010c420:	103fe71e 	bne	r2,zero,8010c3c0 <__reset+0xfa0ec3c0>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8010c424:	e0fff017 	ldw	r3,-64(fp)
8010c428:	e0bff617 	ldw	r2,-40(fp)
8010c42c:	1884703a 	and	r2,r3,r2
8010c430:	10000626 	beq	r2,zero,8010c44c <msgdma_descriptor_sync_transfer+0x2f0>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8010c434:	e0bffd17 	ldw	r2,-12(fp)
8010c438:	10801817 	ldw	r2,96(r2)
8010c43c:	1009883a 	mov	r4,r2
8010c440:	013a2840 	call	8013a284 <OSSemPost>

		return error;
8010c444:	e0bff617 	ldw	r2,-40(fp)
8010c448:	00002206 	br	8010c4d4 <msgdma_descriptor_sync_transfer+0x378>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8010c44c:	e0bffd17 	ldw	r2,-12(fp)
8010c450:	10800317 	ldw	r2,12(r2)
8010c454:	10800104 	addi	r2,r2,4
8010c458:	10800037 	ldwio	r2,0(r2)
8010c45c:	10800814 	ori	r2,r2,32
8010c460:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8010c464:	0005303a 	rdctl	r2,status
8010c468:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8010c46c:	e0fffa17 	ldw	r3,-24(fp)
8010c470:	00bfff84 	movi	r2,-2
8010c474:	1884703a 	and	r2,r3,r2
8010c478:	1001703a 	wrctl	status,r2
  
  return context;
8010c47c:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8010c480:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8010c484:	e0bffd17 	ldw	r2,-12(fp)
8010c488:	10800317 	ldw	r2,12(r2)
8010c48c:	10800104 	addi	r2,r2,4
8010c490:	e0fff417 	ldw	r3,-48(fp)
8010c494:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8010c498:	e0bffd17 	ldw	r2,-12(fp)
8010c49c:	10800317 	ldw	r2,12(r2)
8010c4a0:	e0fffd17 	ldw	r3,-12(fp)
8010c4a4:	18c00317 	ldw	r3,12(r3)
8010c4a8:	18c00037 	ldwio	r3,0(r3)
8010c4ac:	10c00035 	stwio	r3,0(r2)
8010c4b0:	e0bff517 	ldw	r2,-44(fp)
8010c4b4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8010c4b8:	e0bff917 	ldw	r2,-28(fp)
8010c4bc:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8010c4c0:	e0bffd17 	ldw	r2,-12(fp)
8010c4c4:	10801817 	ldw	r2,96(r2)
8010c4c8:	1009883a 	mov	r4,r2
8010c4cc:	013a2840 	call	8013a284 <OSSemPost>

	return 0;
8010c4d0:	0005883a 	mov	r2,zero

}
8010c4d4:	e037883a 	mov	sp,fp
8010c4d8:	dfc00117 	ldw	ra,4(sp)
8010c4dc:	df000017 	ldw	fp,0(sp)
8010c4e0:	dec00204 	addi	sp,sp,8
8010c4e4:	f800283a 	ret

8010c4e8 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8010c4e8:	deffec04 	addi	sp,sp,-80
8010c4ec:	de00012e 	bgeu	sp,et,8010c4f4 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8010c4f0:	003b68fa 	trap	3
8010c4f4:	dfc01315 	stw	ra,76(sp)
8010c4f8:	df001215 	stw	fp,72(sp)
8010c4fc:	df001204 	addi	fp,sp,72
8010c500:	e13ff715 	stw	r4,-36(fp)
8010c504:	e17ff815 	stw	r5,-32(fp)
8010c508:	e1bff915 	stw	r6,-28(fp)
8010c50c:	e1fffa15 	stw	r7,-24(fp)
8010c510:	e1800617 	ldw	r6,24(fp)
8010c514:	e1400717 	ldw	r5,28(fp)
8010c518:	e1000817 	ldw	r4,32(fp)
8010c51c:	e0c00917 	ldw	r3,36(fp)
8010c520:	e0800a17 	ldw	r2,40(fp)
8010c524:	e1bffb0d 	sth	r6,-20(fp)
8010c528:	e17ffc05 	stb	r5,-16(fp)
8010c52c:	e13ffd05 	stb	r4,-12(fp)
8010c530:	e0fffe0d 	sth	r3,-8(fp)
8010c534:	e0bfff0d 	sth	r2,-4(fp)

	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8010c538:	e0bffb0b 	ldhu	r2,-20(fp)
8010c53c:	e0fffc03 	ldbu	r3,-16(fp)
8010c540:	e13ffd03 	ldbu	r4,-12(fp)
8010c544:	e17ffe0b 	ldhu	r5,-8(fp)
8010c548:	e1bfff0b 	ldhu	r6,-4(fp)
8010c54c:	d9800815 	stw	r6,32(sp)
8010c550:	d9400715 	stw	r5,28(sp)
8010c554:	d9000615 	stw	r4,24(sp)
8010c558:	d8c00515 	stw	r3,20(sp)
8010c55c:	d8800415 	stw	r2,16(sp)
8010c560:	e0800517 	ldw	r2,20(fp)
8010c564:	d8800315 	stw	r2,12(sp)
8010c568:	e0800417 	ldw	r2,16(fp)
8010c56c:	d8800215 	stw	r2,8(sp)
8010c570:	e0800317 	ldw	r2,12(fp)
8010c574:	d8800115 	stw	r2,4(sp)
8010c578:	e0800217 	ldw	r2,8(fp)
8010c57c:	d8800015 	stw	r2,0(sp)
8010c580:	e1fffa17 	ldw	r7,-24(fp)
8010c584:	e1bff917 	ldw	r6,-28(fp)
8010c588:	e17ff817 	ldw	r5,-32(fp)
8010c58c:	e13ff717 	ldw	r4,-36(fp)
8010c590:	010bd180 	call	8010bd18 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8010c594:	e037883a 	mov	sp,fp
8010c598:	dfc00117 	ldw	ra,4(sp)
8010c59c:	df000017 	ldw	fp,0(sp)
8010c5a0:	dec00204 	addi	sp,sp,8
8010c5a4:	f800283a 	ret

8010c5a8 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8010c5a8:	defffc04 	addi	sp,sp,-16
8010c5ac:	de00012e 	bgeu	sp,et,8010c5b4 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8010c5b0:	003b68fa 	trap	3
8010c5b4:	dfc00315 	stw	ra,12(sp)
8010c5b8:	df000215 	stw	fp,8(sp)
8010c5bc:	df000204 	addi	fp,sp,8
8010c5c0:	e13ffe15 	stw	r4,-8(fp)
8010c5c4:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8010c5c8:	e1bfff17 	ldw	r6,-4(fp)
8010c5cc:	000b883a 	mov	r5,zero
8010c5d0:	e13ffe17 	ldw	r4,-8(fp)
8010c5d4:	010be7c0 	call	8010be7c <msgdma_descriptor_async_transfer>
}
8010c5d8:	e037883a 	mov	sp,fp
8010c5dc:	dfc00117 	ldw	ra,4(sp)
8010c5e0:	df000017 	ldw	fp,0(sp)
8010c5e4:	dec00204 	addi	sp,sp,8
8010c5e8:	f800283a 	ret

8010c5ec <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8010c5ec:	defffc04 	addi	sp,sp,-16
8010c5f0:	de00012e 	bgeu	sp,et,8010c5f8 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8010c5f4:	003b68fa 	trap	3
8010c5f8:	dfc00315 	stw	ra,12(sp)
8010c5fc:	df000215 	stw	fp,8(sp)
8010c600:	df000204 	addi	fp,sp,8
8010c604:	e13ffe15 	stw	r4,-8(fp)
8010c608:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8010c60c:	e1bfff17 	ldw	r6,-4(fp)
8010c610:	000b883a 	mov	r5,zero
8010c614:	e13ffe17 	ldw	r4,-8(fp)
8010c618:	010c15c0 	call	8010c15c <msgdma_descriptor_sync_transfer>
}
8010c61c:	e037883a 	mov	sp,fp
8010c620:	dfc00117 	ldw	ra,4(sp)
8010c624:	df000017 	ldw	fp,0(sp)
8010c628:	dec00204 	addi	sp,sp,8
8010c62c:	f800283a 	ret

8010c630 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8010c630:	defff204 	addi	sp,sp,-56
8010c634:	de00012e 	bgeu	sp,et,8010c63c <POWER_SPI_RW+0xc>
8010c638:	003b68fa 	trap	3
8010c63c:	dfc00d15 	stw	ra,52(sp)
8010c640:	df000c15 	stw	fp,48(sp)
8010c644:	df000c04 	addi	fp,sp,48
8010c648:	2007883a 	mov	r3,r4
8010c64c:	2805883a 	mov	r2,r5
8010c650:	e1bffe15 	stw	r6,-8(fp)
8010c654:	e1ffff15 	stw	r7,-4(fp)
8010c658:	e0fffc05 	stb	r3,-16(fp)
8010c65c:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8010c660:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8010c664:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8010c668:	008003f4 	movhi	r2,15
8010c66c:	10909004 	addi	r2,r2,16960
8010c670:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8010c674:	00bfe004 	movi	r2,-128
8010c678:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8010c67c:	e0bffe17 	ldw	r2,-8(fp)
8010c680:	10000226 	beq	r2,zero,8010c68c <POWER_SPI_RW+0x5c>
8010c684:	00800804 	movi	r2,32
8010c688:	00000106 	br	8010c690 <POWER_SPI_RW+0x60>
8010c68c:	0005883a 	mov	r2,zero
8010c690:	e0fff403 	ldbu	r3,-48(fp)
8010c694:	10c4b03a 	or	r2,r2,r3
8010c698:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8010c69c:	e0800217 	ldw	r2,8(fp)
8010c6a0:	10000226 	beq	r2,zero,8010c6ac <POWER_SPI_RW+0x7c>
8010c6a4:	00800404 	movi	r2,16
8010c6a8:	00000106 	br	8010c6b0 <POWER_SPI_RW+0x80>
8010c6ac:	0005883a 	mov	r2,zero
8010c6b0:	e0fff403 	ldbu	r3,-48(fp)
8010c6b4:	10c4b03a 	or	r2,r2,r3
8010c6b8:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8010c6bc:	e0bfff17 	ldw	r2,-4(fp)
8010c6c0:	10000226 	beq	r2,zero,8010c6cc <POWER_SPI_RW+0x9c>
8010c6c4:	00800204 	movi	r2,8
8010c6c8:	00000106 	br	8010c6d0 <POWER_SPI_RW+0xa0>
8010c6cc:	0005883a 	mov	r2,zero
8010c6d0:	e0fff403 	ldbu	r3,-48(fp)
8010c6d4:	10c4b03a 	or	r2,r2,r3
8010c6d8:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8010c6dc:	e0bffd03 	ldbu	r2,-12(fp)
8010c6e0:	108001cc 	andi	r2,r2,7
8010c6e4:	1007883a 	mov	r3,r2
8010c6e8:	e0bff403 	ldbu	r2,-48(fp)
8010c6ec:	1884b03a 	or	r2,r3,r2
8010c6f0:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8010c6f4:	0007883a 	mov	r3,zero
8010c6f8:	00900034 	movhi	r2,16384
8010c6fc:	10824404 	addi	r2,r2,2320
8010c700:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8010c704:	0007883a 	mov	r3,zero
8010c708:	00900034 	movhi	r2,16384
8010c70c:	10824c04 	addi	r2,r2,2352
8010c710:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8010c714:	e0bffc03 	ldbu	r2,-16(fp)
8010c718:	1000021e 	bne	r2,zero,8010c724 <POWER_SPI_RW+0xf4>
8010c71c:	00c00084 	movi	r3,2
8010c720:	00000106 	br	8010c728 <POWER_SPI_RW+0xf8>
8010c724:	00c00044 	movi	r3,1
8010c728:	00900034 	movhi	r2,16384
8010c72c:	10824804 	addi	r2,r2,2336
8010c730:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8010c734:	010003c4 	movi	r4,15
8010c738:	01330f80 	call	801330f8 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8010c73c:	00000306 	br	8010c74c <POWER_SPI_RW+0x11c>
		nWait++;
8010c740:	e0bff817 	ldw	r2,-32(fp)
8010c744:	10800044 	addi	r2,r2,1
8010c748:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8010c74c:	00900034 	movhi	r2,16384
8010c750:	10825404 	addi	r2,r2,2384
8010c754:	10800037 	ldwio	r2,0(r2)
8010c758:	1080004c 	andi	r2,r2,1
8010c75c:	10000326 	beq	r2,zero,8010c76c <POWER_SPI_RW+0x13c>
8010c760:	e0fff817 	ldw	r3,-32(fp)
8010c764:	e0bffa17 	ldw	r2,-24(fp)
8010c768:	18bff516 	blt	r3,r2,8010c740 <__reset+0xfa0ec740>
		nWait++;
	}

	if (SPI_SDO) {
8010c76c:	00900034 	movhi	r2,16384
8010c770:	10825404 	addi	r2,r2,2384
8010c774:	10800037 	ldwio	r2,0(r2)
8010c778:	1080004c 	andi	r2,r2,1
8010c77c:	10000626 	beq	r2,zero,8010c798 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8010c780:	00c000c4 	movi	r3,3
8010c784:	00900034 	movhi	r2,16384
8010c788:	10824804 	addi	r2,r2,2336
8010c78c:	10c00035 	stwio	r3,0(r2)
		return FALSE;
8010c790:	0005883a 	mov	r2,zero
8010c794:	0000db06 	br	8010cb04 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8010c798:	e03ff715 	stw	zero,-36(fp)
8010c79c:	00002406 	br	8010c830 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8010c7a0:	e0bff403 	ldbu	r2,-48(fp)
8010c7a4:	10803fcc 	andi	r2,r2,255
8010c7a8:	1004d1fa 	srli	r2,r2,7
8010c7ac:	10c03fcc 	andi	r3,r2,255
8010c7b0:	00900034 	movhi	r2,16384
8010c7b4:	10825004 	addi	r2,r2,2368
8010c7b8:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8010c7bc:	e0bff403 	ldbu	r2,-48(fp)
8010c7c0:	1085883a 	add	r2,r2,r2
8010c7c4:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8010c7c8:	e0bff517 	ldw	r2,-44(fp)
8010c7cc:	1085883a 	add	r2,r2,r2
8010c7d0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8010c7d4:	00900034 	movhi	r2,16384
8010c7d8:	10825404 	addi	r2,r2,2384
8010c7dc:	10800037 	ldwio	r2,0(r2)
8010c7e0:	1080004c 	andi	r2,r2,1
8010c7e4:	1007883a 	mov	r3,r2
8010c7e8:	e0bff517 	ldw	r2,-44(fp)
8010c7ec:	10c4b03a 	or	r2,r2,r3
8010c7f0:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8010c7f4:	00c00044 	movi	r3,1
8010c7f8:	00900034 	movhi	r2,16384
8010c7fc:	10824c04 	addi	r2,r2,2352
8010c800:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010c804:	010003c4 	movi	r4,15
8010c808:	01330f80 	call	801330f8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8010c80c:	0007883a 	mov	r3,zero
8010c810:	00900034 	movhi	r2,16384
8010c814:	10824c04 	addi	r2,r2,2352
8010c818:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010c81c:	010003c4 	movi	r4,15
8010c820:	01330f80 	call	801330f8 <usleep>
	if (SPI_SDO) {
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8010c824:	e0bff717 	ldw	r2,-36(fp)
8010c828:	10800044 	addi	r2,r2,1
8010c82c:	e0bff715 	stw	r2,-36(fp)
8010c830:	e0bff717 	ldw	r2,-36(fp)
8010c834:	10800090 	cmplti	r2,r2,2
8010c838:	103fd91e 	bne	r2,zero,8010c7a0 <__reset+0xfa0ec7a0>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8010c83c:	e03ff715 	stw	zero,-36(fp)
8010c840:	00002406 	br	8010c8d4 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8010c844:	e0bff403 	ldbu	r2,-48(fp)
8010c848:	10803fcc 	andi	r2,r2,255
8010c84c:	1004d1fa 	srli	r2,r2,7
8010c850:	10c03fcc 	andi	r3,r2,255
8010c854:	00900034 	movhi	r2,16384
8010c858:	10825004 	addi	r2,r2,2368
8010c85c:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8010c860:	e0bff403 	ldbu	r2,-48(fp)
8010c864:	1085883a 	add	r2,r2,r2
8010c868:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8010c86c:	e0bff517 	ldw	r2,-44(fp)
8010c870:	1085883a 	add	r2,r2,r2
8010c874:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8010c878:	00900034 	movhi	r2,16384
8010c87c:	10825404 	addi	r2,r2,2384
8010c880:	10800037 	ldwio	r2,0(r2)
8010c884:	1080004c 	andi	r2,r2,1
8010c888:	1007883a 	mov	r3,r2
8010c88c:	e0bff517 	ldw	r2,-44(fp)
8010c890:	10c4b03a 	or	r2,r2,r3
8010c894:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8010c898:	00c00044 	movi	r3,1
8010c89c:	00900034 	movhi	r2,16384
8010c8a0:	10824c04 	addi	r2,r2,2352
8010c8a4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010c8a8:	010003c4 	movi	r4,15
8010c8ac:	01330f80 	call	801330f8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8010c8b0:	0007883a 	mov	r3,zero
8010c8b4:	00900034 	movhi	r2,16384
8010c8b8:	10824c04 	addi	r2,r2,2352
8010c8bc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010c8c0:	010003c4 	movi	r4,15
8010c8c4:	01330f80 	call	801330f8 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8010c8c8:	e0bff717 	ldw	r2,-36(fp)
8010c8cc:	10800044 	addi	r2,r2,1
8010c8d0:	e0bff715 	stw	r2,-36(fp)
8010c8d4:	e0bff717 	ldw	r2,-36(fp)
8010c8d8:	10800210 	cmplti	r2,r2,8
8010c8dc:	103fd91e 	bne	r2,zero,8010c844 <__reset+0xfa0ec844>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8010c8e0:	e03ff715 	stw	zero,-36(fp)
8010c8e4:	00001a06 	br	8010c950 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8010c8e8:	e0bff517 	ldw	r2,-44(fp)
8010c8ec:	1085883a 	add	r2,r2,r2
8010c8f0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8010c8f4:	00900034 	movhi	r2,16384
8010c8f8:	10825404 	addi	r2,r2,2384
8010c8fc:	10800037 	ldwio	r2,0(r2)
8010c900:	1080004c 	andi	r2,r2,1
8010c904:	1007883a 	mov	r3,r2
8010c908:	e0bff517 	ldw	r2,-44(fp)
8010c90c:	10c4b03a 	or	r2,r2,r3
8010c910:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8010c914:	00c00044 	movi	r3,1
8010c918:	00900034 	movhi	r2,16384
8010c91c:	10824c04 	addi	r2,r2,2352
8010c920:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010c924:	010003c4 	movi	r4,15
8010c928:	01330f80 	call	801330f8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8010c92c:	0007883a 	mov	r3,zero
8010c930:	00900034 	movhi	r2,16384
8010c934:	10824c04 	addi	r2,r2,2352
8010c938:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010c93c:	010003c4 	movi	r4,15
8010c940:	01330f80 	call	801330f8 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8010c944:	e0bff717 	ldw	r2,-36(fp)
8010c948:	10800044 	addi	r2,r2,1
8010c94c:	e0bff715 	stw	r2,-36(fp)
8010c950:	e0bff717 	ldw	r2,-36(fp)
8010c954:	10800210 	cmplti	r2,r2,8
8010c958:	103fe31e 	bne	r2,zero,8010c8e8 <__reset+0xfa0ec8e8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8010c95c:	e03ff715 	stw	zero,-36(fp)
8010c960:	00001a06 	br	8010c9cc <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8010c964:	e0bff517 	ldw	r2,-44(fp)
8010c968:	1085883a 	add	r2,r2,r2
8010c96c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8010c970:	00900034 	movhi	r2,16384
8010c974:	10825404 	addi	r2,r2,2384
8010c978:	10800037 	ldwio	r2,0(r2)
8010c97c:	1080004c 	andi	r2,r2,1
8010c980:	1007883a 	mov	r3,r2
8010c984:	e0bff517 	ldw	r2,-44(fp)
8010c988:	10c4b03a 	or	r2,r2,r3
8010c98c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8010c990:	00c00044 	movi	r3,1
8010c994:	00900034 	movhi	r2,16384
8010c998:	10824c04 	addi	r2,r2,2352
8010c99c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010c9a0:	010003c4 	movi	r4,15
8010c9a4:	01330f80 	call	801330f8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8010c9a8:	0007883a 	mov	r3,zero
8010c9ac:	00900034 	movhi	r2,16384
8010c9b0:	10824c04 	addi	r2,r2,2352
8010c9b4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010c9b8:	010003c4 	movi	r4,15
8010c9bc:	01330f80 	call	801330f8 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8010c9c0:	e0bff717 	ldw	r2,-36(fp)
8010c9c4:	10800044 	addi	r2,r2,1
8010c9c8:	e0bff715 	stw	r2,-36(fp)
8010c9cc:	e0bff717 	ldw	r2,-36(fp)
8010c9d0:	10800210 	cmplti	r2,r2,8
8010c9d4:	103fe31e 	bne	r2,zero,8010c964 <__reset+0xfa0ec964>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8010c9d8:	e03ff715 	stw	zero,-36(fp)
8010c9dc:	00001a06 	br	8010ca48 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8010c9e0:	e0bff517 	ldw	r2,-44(fp)
8010c9e4:	1085883a 	add	r2,r2,r2
8010c9e8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8010c9ec:	00900034 	movhi	r2,16384
8010c9f0:	10825404 	addi	r2,r2,2384
8010c9f4:	10800037 	ldwio	r2,0(r2)
8010c9f8:	1080004c 	andi	r2,r2,1
8010c9fc:	1007883a 	mov	r3,r2
8010ca00:	e0bff517 	ldw	r2,-44(fp)
8010ca04:	10c4b03a 	or	r2,r2,r3
8010ca08:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8010ca0c:	00c00044 	movi	r3,1
8010ca10:	00900034 	movhi	r2,16384
8010ca14:	10824c04 	addi	r2,r2,2352
8010ca18:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010ca1c:	010003c4 	movi	r4,15
8010ca20:	01330f80 	call	801330f8 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8010ca24:	0007883a 	mov	r3,zero
8010ca28:	00900034 	movhi	r2,16384
8010ca2c:	10824c04 	addi	r2,r2,2352
8010ca30:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8010ca34:	010003c4 	movi	r4,15
8010ca38:	01330f80 	call	801330f8 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8010ca3c:	e0bff717 	ldw	r2,-36(fp)
8010ca40:	10800044 	addi	r2,r2,1
8010ca44:	e0bff715 	stw	r2,-36(fp)
8010ca48:	e0bff717 	ldw	r2,-36(fp)
8010ca4c:	10800190 	cmplti	r2,r2,6
8010ca50:	103fe31e 	bne	r2,zero,8010c9e0 <__reset+0xfa0ec9e0>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8010ca54:	00c00044 	movi	r3,1
8010ca58:	00900034 	movhi	r2,16384
8010ca5c:	10824c04 	addi	r2,r2,2352
8010ca60:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8010ca64:	010003c4 	movi	r4,15
8010ca68:	01330f80 	call	801330f8 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8010ca6c:	00c000c4 	movi	r3,3
8010ca70:	00900034 	movhi	r2,16384
8010ca74:	10824804 	addi	r2,r2,2336
8010ca78:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8010ca7c:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8010ca80:	00800044 	movi	r2,1
8010ca84:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8010ca88:	e03ff715 	stw	zero,-36(fp)
8010ca8c:	00000d06 	br	8010cac4 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8010ca90:	e0fff517 	ldw	r3,-44(fp)
8010ca94:	e0bff617 	ldw	r2,-40(fp)
8010ca98:	1884703a 	and	r2,r3,r2
8010ca9c:	1000031e 	bne	r2,zero,8010caac <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8010caa0:	e0bff917 	ldw	r2,-28(fp)
8010caa4:	10800044 	addi	r2,r2,1
8010caa8:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8010caac:	e0bff617 	ldw	r2,-40(fp)
8010cab0:	1085883a 	add	r2,r2,r2
8010cab4:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8010cab8:	e0bff717 	ldw	r2,-36(fp)
8010cabc:	10800044 	addi	r2,r2,1
8010cac0:	e0bff715 	stw	r2,-36(fp)
8010cac4:	e0bff717 	ldw	r2,-36(fp)
8010cac8:	10800810 	cmplti	r2,r2,32
8010cacc:	103ff01e 	bne	r2,zero,8010ca90 <__reset+0xfa0eca90>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8010cad0:	e0bff917 	ldw	r2,-28(fp)
8010cad4:	1080004c 	andi	r2,r2,1
8010cad8:	1005003a 	cmpeq	r2,r2,zero
8010cadc:	10803fcc 	andi	r2,r2,255
8010cae0:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8010cae4:	e0bffb17 	ldw	r2,-20(fp)
8010cae8:	1000021e 	bne	r2,zero,8010caf4 <POWER_SPI_RW+0x4c4>
		return FALSE;
8010caec:	0005883a 	mov	r2,zero
8010caf0:	00000406 	br	8010cb04 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8010caf4:	e0800317 	ldw	r2,12(fp)
8010caf8:	e0fff517 	ldw	r3,-44(fp)
8010cafc:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8010cb00:	e0bffb17 	ldw	r2,-20(fp)
}
8010cb04:	e037883a 	mov	sp,fp
8010cb08:	dfc00117 	ldw	ra,4(sp)
8010cb0c:	df000017 	ldw	fp,0(sp)
8010cb10:	dec00204 	addi	sp,sp,8
8010cb14:	f800283a 	ret

8010cb18 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8010cb18:	defffc04 	addi	sp,sp,-16
8010cb1c:	de00012e 	bgeu	sp,et,8010cb24 <vRstcSimucamReset+0xc>
8010cb20:	003b68fa 	trap	3
8010cb24:	dfc00315 	stw	ra,12(sp)
8010cb28:	df000215 	stw	fp,8(sp)
8010cb2c:	df000204 	addi	fp,sp,8
8010cb30:	2005883a 	mov	r2,r4
8010cb34:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8010cb38:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8010cb3c:	e0bfff0b 	ldhu	r2,-4(fp)
8010cb40:	e0fffe17 	ldw	r3,-8(fp)
8010cb44:	1884b03a 	or	r2,r3,r2
8010cb48:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8010cb4c:	e0bffe17 	ldw	r2,-8(fp)
8010cb50:	10800074 	orhi	r2,r2,1
8010cb54:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8010cb58:	e1bffe17 	ldw	r6,-8(fp)
8010cb5c:	000b883a 	mov	r5,zero
8010cb60:	01100034 	movhi	r4,16384
8010cb64:	21020004 	addi	r4,r4,2048
8010cb68:	010cc680 	call	8010cc68 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8010cb6c:	0001883a 	nop
8010cb70:	e037883a 	mov	sp,fp
8010cb74:	dfc00117 	ldw	ra,4(sp)
8010cb78:	df000017 	ldw	fp,0(sp)
8010cb7c:	dec00204 	addi	sp,sp,8
8010cb80:	f800283a 	ret

8010cb84 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8010cb84:	defffc04 	addi	sp,sp,-16
8010cb88:	de00012e 	bgeu	sp,et,8010cb90 <vRstcReleaseDeviceReset+0xc>
8010cb8c:	003b68fa 	trap	3
8010cb90:	dfc00315 	stw	ra,12(sp)
8010cb94:	df000215 	stw	fp,8(sp)
8010cb98:	df000204 	addi	fp,sp,8
8010cb9c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8010cba0:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8010cba4:	01400044 	movi	r5,1
8010cba8:	01100034 	movhi	r4,16384
8010cbac:	21020004 	addi	r4,r4,2048
8010cbb0:	010ccbc0 	call	8010ccbc <uliRstReadReg>
8010cbb4:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8010cbb8:	e0bfff17 	ldw	r2,-4(fp)
8010cbbc:	0084303a 	nor	r2,zero,r2
8010cbc0:	e0fffe17 	ldw	r3,-8(fp)
8010cbc4:	1884703a 	and	r2,r3,r2
8010cbc8:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8010cbcc:	e1bffe17 	ldw	r6,-8(fp)
8010cbd0:	01400044 	movi	r5,1
8010cbd4:	01100034 	movhi	r4,16384
8010cbd8:	21020004 	addi	r4,r4,2048
8010cbdc:	010cc680 	call	8010cc68 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8010cbe0:	0001883a 	nop
8010cbe4:	e037883a 	mov	sp,fp
8010cbe8:	dfc00117 	ldw	ra,4(sp)
8010cbec:	df000017 	ldw	fp,0(sp)
8010cbf0:	dec00204 	addi	sp,sp,8
8010cbf4:	f800283a 	ret

8010cbf8 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8010cbf8:	defffc04 	addi	sp,sp,-16
8010cbfc:	de00012e 	bgeu	sp,et,8010cc04 <vRstcHoldDeviceReset+0xc>
8010cc00:	003b68fa 	trap	3
8010cc04:	dfc00315 	stw	ra,12(sp)
8010cc08:	df000215 	stw	fp,8(sp)
8010cc0c:	df000204 	addi	fp,sp,8
8010cc10:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8010cc14:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8010cc18:	01400044 	movi	r5,1
8010cc1c:	01100034 	movhi	r4,16384
8010cc20:	21020004 	addi	r4,r4,2048
8010cc24:	010ccbc0 	call	8010ccbc <uliRstReadReg>
8010cc28:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8010cc2c:	e0fffe17 	ldw	r3,-8(fp)
8010cc30:	e0bfff17 	ldw	r2,-4(fp)
8010cc34:	1884b03a 	or	r2,r3,r2
8010cc38:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8010cc3c:	e1bffe17 	ldw	r6,-8(fp)
8010cc40:	01400044 	movi	r5,1
8010cc44:	01100034 	movhi	r4,16384
8010cc48:	21020004 	addi	r4,r4,2048
8010cc4c:	010cc680 	call	8010cc68 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8010cc50:	0001883a 	nop
8010cc54:	e037883a 	mov	sp,fp
8010cc58:	dfc00117 	ldw	ra,4(sp)
8010cc5c:	df000017 	ldw	fp,0(sp)
8010cc60:	dec00204 	addi	sp,sp,8
8010cc64:	f800283a 	ret

8010cc68 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8010cc68:	defffc04 	addi	sp,sp,-16
8010cc6c:	de00012e 	bgeu	sp,et,8010cc74 <vRstcWriteReg+0xc>
8010cc70:	003b68fa 	trap	3
8010cc74:	df000315 	stw	fp,12(sp)
8010cc78:	df000304 	addi	fp,sp,12
8010cc7c:	e13ffd15 	stw	r4,-12(fp)
8010cc80:	e17ffe15 	stw	r5,-8(fp)
8010cc84:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8010cc88:	e0bffe17 	ldw	r2,-8(fp)
8010cc8c:	1085883a 	add	r2,r2,r2
8010cc90:	1085883a 	add	r2,r2,r2
8010cc94:	1007883a 	mov	r3,r2
8010cc98:	e0bffd17 	ldw	r2,-12(fp)
8010cc9c:	10c5883a 	add	r2,r2,r3
8010cca0:	e0ffff17 	ldw	r3,-4(fp)
8010cca4:	10c00015 	stw	r3,0(r2)
}
8010cca8:	0001883a 	nop
8010ccac:	e037883a 	mov	sp,fp
8010ccb0:	df000017 	ldw	fp,0(sp)
8010ccb4:	dec00104 	addi	sp,sp,4
8010ccb8:	f800283a 	ret

8010ccbc <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8010ccbc:	defffc04 	addi	sp,sp,-16
8010ccc0:	de00012e 	bgeu	sp,et,8010ccc8 <uliRstReadReg+0xc>
8010ccc4:	003b68fa 	trap	3
8010ccc8:	df000315 	stw	fp,12(sp)
8010cccc:	df000304 	addi	fp,sp,12
8010ccd0:	e13ffe15 	stw	r4,-8(fp)
8010ccd4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8010ccd8:	e0bfff17 	ldw	r2,-4(fp)
8010ccdc:	1085883a 	add	r2,r2,r2
8010cce0:	1085883a 	add	r2,r2,r2
8010cce4:	1007883a 	mov	r3,r2
8010cce8:	e0bffe17 	ldw	r2,-8(fp)
8010ccec:	10c5883a 	add	r2,r2,r3
8010ccf0:	10800017 	ldw	r2,0(r2)
8010ccf4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8010ccf8:	e0bffd17 	ldw	r2,-12(fp)
}
8010ccfc:	e037883a 	mov	sp,fp
8010cd00:	df000017 	ldw	fp,0(sp)
8010cd04:	dec00104 	addi	sp,sp,4
8010cd08:	f800283a 	ret

8010cd0c <v_spi_start>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8010cd0c:	defffe04 	addi	sp,sp,-8
8010cd10:	de00012e 	bgeu	sp,et,8010cd18 <v_spi_start+0xc>
8010cd14:	003b68fa 	trap	3
8010cd18:	dfc00115 	stw	ra,4(sp)
8010cd1c:	df000015 	stw	fp,0(sp)
8010cd20:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8010cd24:	0007883a 	mov	r3,zero
8010cd28:	00900034 	movhi	r2,16384
8010cd2c:	10823004 	addi	r2,r2,2240
8010cd30:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8010cd34:	0007883a 	mov	r3,zero
8010cd38:	00900034 	movhi	r2,16384
8010cd3c:	10822c04 	addi	r2,r2,2224
8010cd40:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8010cd44:	01002584 	movi	r4,150
8010cd48:	01330f80 	call	801330f8 <usleep>
}
8010cd4c:	0001883a 	nop
8010cd50:	e037883a 	mov	sp,fp
8010cd54:	dfc00117 	ldw	ra,4(sp)
8010cd58:	df000017 	ldw	fp,0(sp)
8010cd5c:	dec00204 	addi	sp,sp,8
8010cd60:	f800283a 	ret

8010cd64 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8010cd64:	defffc04 	addi	sp,sp,-16
8010cd68:	de00012e 	bgeu	sp,et,8010cd70 <v_spi_send_byte+0xc>
8010cd6c:	003b68fa 	trap	3
8010cd70:	dfc00315 	stw	ra,12(sp)
8010cd74:	df000215 	stw	fp,8(sp)
8010cd78:	df000204 	addi	fp,sp,8
8010cd7c:	2005883a 	mov	r2,r4
8010cd80:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8010cd84:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8010cd88:	00bfe004 	movi	r2,-128
8010cd8c:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8010cd90:	e03ffe05 	stb	zero,-8(fp)
8010cd94:	00001b06 	br	8010ce04 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8010cd98:	e0ffff03 	ldbu	r3,-4(fp)
8010cd9c:	e0bffe43 	ldbu	r2,-7(fp)
8010cda0:	1884703a 	and	r2,r3,r2
8010cda4:	10803fcc 	andi	r2,r2,255
8010cda8:	1004c03a 	cmpne	r2,r2,zero
8010cdac:	10c03fcc 	andi	r3,r2,255
8010cdb0:	00900034 	movhi	r2,16384
8010cdb4:	10823404 	addi	r2,r2,2256
8010cdb8:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8010cdbc:	e0bffe43 	ldbu	r2,-7(fp)
8010cdc0:	1004d07a 	srli	r2,r2,1
8010cdc4:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8010cdc8:	00c00044 	movi	r3,1
8010cdcc:	00900034 	movhi	r2,16384
8010cdd0:	10823004 	addi	r2,r2,2240
8010cdd4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8010cdd8:	01002584 	movi	r4,150
8010cddc:	01330f80 	call	801330f8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8010cde0:	0007883a 	mov	r3,zero
8010cde4:	00900034 	movhi	r2,16384
8010cde8:	10823004 	addi	r2,r2,2240
8010cdec:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8010cdf0:	01002584 	movi	r4,150
8010cdf4:	01330f80 	call	801330f8 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8010cdf8:	e0bffe03 	ldbu	r2,-8(fp)
8010cdfc:	10800044 	addi	r2,r2,1
8010ce00:	e0bffe05 	stb	r2,-8(fp)
8010ce04:	e0bffe03 	ldbu	r2,-8(fp)
8010ce08:	10800230 	cmpltui	r2,r2,8
8010ce0c:	103fe21e 	bne	r2,zero,8010cd98 <__reset+0xfa0ecd98>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8010ce10:	0001883a 	nop
8010ce14:	e037883a 	mov	sp,fp
8010ce18:	dfc00117 	ldw	ra,4(sp)
8010ce1c:	df000017 	ldw	fp,0(sp)
8010ce20:	dec00204 	addi	sp,sp,8
8010ce24:	f800283a 	ret

8010ce28 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8010ce28:	defffd04 	addi	sp,sp,-12
8010ce2c:	de00012e 	bgeu	sp,et,8010ce34 <uc_spi_get_byte+0xc>
8010ce30:	003b68fa 	trap	3
8010ce34:	dfc00215 	stw	ra,8(sp)
8010ce38:	df000115 	stw	fp,4(sp)
8010ce3c:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8010ce40:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8010ce44:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8010ce48:	e03fff05 	stb	zero,-4(fp)
8010ce4c:	00001a06 	br	8010ceb8 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8010ce50:	e0bfff43 	ldbu	r2,-3(fp)
8010ce54:	1085883a 	add	r2,r2,r2
8010ce58:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8010ce5c:	00900034 	movhi	r2,16384
8010ce60:	10823804 	addi	r2,r2,2272
8010ce64:	10800037 	ldwio	r2,0(r2)
8010ce68:	1080004c 	andi	r2,r2,1
8010ce6c:	1007883a 	mov	r3,r2
8010ce70:	e0bfff43 	ldbu	r2,-3(fp)
8010ce74:	1884b03a 	or	r2,r3,r2
8010ce78:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8010ce7c:	00c00044 	movi	r3,1
8010ce80:	00900034 	movhi	r2,16384
8010ce84:	10823004 	addi	r2,r2,2240
8010ce88:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8010ce8c:	01002584 	movi	r4,150
8010ce90:	01330f80 	call	801330f8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8010ce94:	0007883a 	mov	r3,zero
8010ce98:	00900034 	movhi	r2,16384
8010ce9c:	10823004 	addi	r2,r2,2240
8010cea0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8010cea4:	01002584 	movi	r4,150
8010cea8:	01330f80 	call	801330f8 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8010ceac:	e0bfff03 	ldbu	r2,-4(fp)
8010ceb0:	10800044 	addi	r2,r2,1
8010ceb4:	e0bfff05 	stb	r2,-4(fp)
8010ceb8:	e0bfff03 	ldbu	r2,-4(fp)
8010cebc:	10800230 	cmpltui	r2,r2,8
8010cec0:	103fe31e 	bne	r2,zero,8010ce50 <__reset+0xfa0ece50>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8010cec4:	e0bfff43 	ldbu	r2,-3(fp)
}
8010cec8:	e037883a 	mov	sp,fp
8010cecc:	dfc00117 	ldw	ra,4(sp)
8010ced0:	df000017 	ldw	fp,0(sp)
8010ced4:	dec00204 	addi	sp,sp,8
8010ced8:	f800283a 	ret

8010cedc <v_spi_end>:

void v_spi_end(void){
8010cedc:	defffe04 	addi	sp,sp,-8
8010cee0:	de00012e 	bgeu	sp,et,8010cee8 <v_spi_end+0xc>
8010cee4:	003b68fa 	trap	3
8010cee8:	dfc00115 	stw	ra,4(sp)
8010ceec:	df000015 	stw	fp,0(sp)
8010cef0:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8010cef4:	0007883a 	mov	r3,zero
8010cef8:	00900034 	movhi	r2,16384
8010cefc:	10823004 	addi	r2,r2,2240
8010cf00:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8010cf04:	01002584 	movi	r4,150
8010cf08:	01330f80 	call	801330f8 <usleep>
    SPI_CS_N(1);
8010cf0c:	00c00044 	movi	r3,1
8010cf10:	00900034 	movhi	r2,16384
8010cf14:	10822c04 	addi	r2,r2,2224
8010cf18:	10c00035 	stwio	r3,0(r2)
}
8010cf1c:	0001883a 	nop
8010cf20:	e037883a 	mov	sp,fp
8010cf24:	dfc00117 	ldw	ra,4(sp)
8010cf28:	df000017 	ldw	fp,0(sp)
8010cf2c:	dec00204 	addi	sp,sp,8
8010cf30:	f800283a 	ret

8010cf34 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8010cf34:	defffa04 	addi	sp,sp,-24
8010cf38:	de00012e 	bgeu	sp,et,8010cf40 <RTCC_SPI_R_MAC+0xc>
8010cf3c:	003b68fa 	trap	3
8010cf40:	dfc00515 	stw	ra,20(sp)
8010cf44:	df000415 	stw	fp,16(sp)
8010cf48:	df000404 	addi	fp,sp,16
8010cf4c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8010cf50:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8010cf54:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8010cf58:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8010cf5c:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8010cf60:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8010cf64:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8010cf68:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8010cf6c:	00800084 	movi	r2,2
8010cf70:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8010cf74:	00800cc4 	movi	r2,51
8010cf78:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8010cf7c:	010cd0c0 	call	8010cd0c <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8010cf80:	e0bffec3 	ldbu	r2,-5(fp)
8010cf84:	1009883a 	mov	r4,r2
8010cf88:	010cd640 	call	8010cd64 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8010cf8c:	e0bffe83 	ldbu	r2,-6(fp)
8010cf90:	1009883a 	mov	r4,r2
8010cf94:	010cd640 	call	8010cd64 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8010cf98:	010ce280 	call	8010ce28 <uc_spi_get_byte>
8010cf9c:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8010cfa0:	010ce280 	call	8010ce28 <uc_spi_get_byte>
8010cfa4:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8010cfa8:	010ce280 	call	8010ce28 <uc_spi_get_byte>
8010cfac:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8010cfb0:	010ce280 	call	8010ce28 <uc_spi_get_byte>
8010cfb4:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8010cfb8:	010ce280 	call	8010ce28 <uc_spi_get_byte>
8010cfbc:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8010cfc0:	010ce280 	call	8010ce28 <uc_spi_get_byte>
8010cfc4:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8010cfc8:	010cedc0 	call	8010cedc <v_spi_end>

    bSuccess = TRUE;
8010cfcc:	00800044 	movi	r2,1
8010cfd0:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8010cfd4:	e0bfff17 	ldw	r2,-4(fp)
8010cfd8:	e0fffd03 	ldbu	r3,-12(fp)
8010cfdc:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8010cfe0:	e0bfff17 	ldw	r2,-4(fp)
8010cfe4:	10800044 	addi	r2,r2,1
8010cfe8:	e0fffd43 	ldbu	r3,-11(fp)
8010cfec:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8010cff0:	e0bfff17 	ldw	r2,-4(fp)
8010cff4:	10800084 	addi	r2,r2,2
8010cff8:	e0fffd83 	ldbu	r3,-10(fp)
8010cffc:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8010d000:	e0bfff17 	ldw	r2,-4(fp)
8010d004:	108000c4 	addi	r2,r2,3
8010d008:	e0fffdc3 	ldbu	r3,-9(fp)
8010d00c:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8010d010:	e0bfff17 	ldw	r2,-4(fp)
8010d014:	10800104 	addi	r2,r2,4
8010d018:	e0fffe03 	ldbu	r3,-8(fp)
8010d01c:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8010d020:	e0bfff17 	ldw	r2,-4(fp)
8010d024:	10800144 	addi	r2,r2,5
8010d028:	e0fffe43 	ldbu	r3,-7(fp)
8010d02c:	10c00005 	stb	r3,0(r2)
		sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
		debug(fp, cDebugBuffer);
    }
#endif

    return bSuccess;
8010d030:	e0bffc17 	ldw	r2,-16(fp)
}
8010d034:	e037883a 	mov	sp,fp
8010d038:	dfc00117 	ldw	ra,4(sp)
8010d03c:	df000017 	ldw	fp,0(sp)
8010d040:	dec00204 	addi	sp,sp,8
8010d044:	f800283a 	ret

8010d048 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8010d048:	defffd04 	addi	sp,sp,-12
8010d04c:	de00012e 	bgeu	sp,et,8010d054 <bSSDisplayConfig+0xc>
8010d050:	003b68fa 	trap	3
8010d054:	df000215 	stw	fp,8(sp)
8010d058:	df000204 	addi	fp,sp,8
8010d05c:	2005883a 	mov	r2,r4
8010d060:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8010d064:	e0bfff03 	ldbu	r2,-4(fp)
8010d068:	10c00168 	cmpgeui	r3,r2,5
8010d06c:	18001c1e 	bne	r3,zero,8010d0e0 <bSSDisplayConfig+0x98>
8010d070:	100690ba 	slli	r3,r2,2
8010d074:	00a00474 	movhi	r2,32785
8010d078:	10b42204 	addi	r2,r2,-12152
8010d07c:	1885883a 	add	r2,r3,r2
8010d080:	10800017 	ldw	r2,0(r2)
8010d084:	1000683a 	jmp	r2
8010d088:	8010d09c 	xori	zero,r16,17218
8010d08c:	8010d0a8 	cmpgeui	zero,r16,17218
8010d090:	8010d0b4 	orhi	zero,r16,17218
8010d094:	8010d0c8 	cmpgei	zero,r16,17219
8010d098:	8010d0d8 	cmpnei	zero,r16,17219
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8010d09c:	00800cc4 	movi	r2,51
8010d0a0:	d0a05045 	stb	r2,-32447(gp)
	    break;
8010d0a4:	00001006 	br	8010d0e8 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8010d0a8:	00801544 	movi	r2,85
8010d0ac:	d0a05045 	stb	r2,-32447(gp)
	    break;
8010d0b0:	00000d06 	br	8010d0e8 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8010d0b4:	d0e05043 	ldbu	r3,-32447(gp)
8010d0b8:	00bff744 	movi	r2,-35
8010d0bc:	1884703a 	and	r2,r3,r2
8010d0c0:	d0a05045 	stb	r2,-32447(gp)
	    break;
8010d0c4:	00000806 	br	8010d0e8 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8010d0c8:	d0a05043 	ldbu	r2,-32447(gp)
8010d0cc:	10800894 	ori	r2,r2,34
8010d0d0:	d0a05045 	stb	r2,-32447(gp)
	    break;
8010d0d4:	00000406 	br	8010d0e8 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8010d0d8:	d0205045 	stb	zero,-32447(gp)
	    break;
8010d0dc:	00000206 	br	8010d0e8 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8010d0e0:	0005883a 	mov	r2,zero
8010d0e4:	00000806 	br	8010d108 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8010d0e8:	00900034 	movhi	r2,16384
8010d0ec:	10828404 	addi	r2,r2,2576
8010d0f0:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8010d0f4:	d0a05043 	ldbu	r2,-32447(gp)
8010d0f8:	10c03fcc 	andi	r3,r2,255
8010d0fc:	e0bffe17 	ldw	r2,-8(fp)
8010d100:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8010d104:	00800044 	movi	r2,1
}
8010d108:	e037883a 	mov	sp,fp
8010d10c:	df000017 	ldw	fp,0(sp)
8010d110:	dec00104 	addi	sp,sp,4
8010d114:	f800283a 	ret

8010d118 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8010d118:	defffd04 	addi	sp,sp,-12
8010d11c:	de00012e 	bgeu	sp,et,8010d124 <bSSDisplayUpdate+0xc>
8010d120:	003b68fa 	trap	3
8010d124:	df000215 	stw	fp,8(sp)
8010d128:	df000204 	addi	fp,sp,8
8010d12c:	2005883a 	mov	r2,r4
8010d130:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8010d134:	00900034 	movhi	r2,16384
8010d138:	10828404 	addi	r2,r2,2576
8010d13c:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8010d140:	e0bffe17 	ldw	r2,-8(fp)
8010d144:	10800104 	addi	r2,r2,4
8010d148:	e0ffff03 	ldbu	r3,-4(fp)
8010d14c:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8010d150:	00800044 	movi	r2,1
}
8010d154:	e037883a 	mov	sp,fp
8010d158:	df000017 	ldw	fp,0(sp)
8010d15c:	dec00104 	addi	sp,sp,4
8010d160:	f800283a 	ret

8010d164 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8010d164:	defffb04 	addi	sp,sp,-20
8010d168:	de00012e 	bgeu	sp,et,8010d170 <vSyncHandleIrq+0xc>
8010d16c:	003b68fa 	trap	3
8010d170:	dfc00415 	stw	ra,16(sp)
8010d174:	df000315 	stw	fp,12(sp)
8010d178:	df000304 	addi	fp,sp,12
8010d17c:	e13fff15 	stw	r4,-4(fp)
	tQMask uiCmdtoSend;

//	volatile int* pviHoldContext = (volatile int*) pvContext;


	uiCmdtoSend.ulWord = 0;
8010d180:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8010d184:	d0a05203 	ldbu	r2,-32440(gp)
8010d188:	108000cc 	andi	r2,r2,3
8010d18c:	e0bffd45 	stb	r2,-11(fp)
	if ( ucSyncL == 0 )
8010d190:	e0bffd43 	ldbu	r2,-11(fp)
8010d194:	1000031e 	bne	r2,zero,8010d1a4 <vSyncHandleIrq+0x40>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8010d198:	00bff804 	movi	r2,-32
8010d19c:	e0bffe85 	stb	r2,-6(fp)
8010d1a0:	00000206 	br	8010d1ac <vSyncHandleIrq+0x48>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8010d1a4:	00bff844 	movi	r2,-31
8010d1a8:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8010d1ac:	00800044 	movi	r2,1
8010d1b0:	e0bffec5 	stb	r2,-5(fp)



	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8010d1b4:	d0a07317 	ldw	r2,-32308(gp)
8010d1b8:	e0fffe17 	ldw	r3,-8(fp)
8010d1bc:	180b883a 	mov	r5,r3
8010d1c0:	1009883a 	mov	r4,r2
8010d1c4:	013957c0 	call	8013957c <OSQPostFront>
8010d1c8:	e0bffd85 	stb	r2,-10(fp)
	if ( error_codel != OS_ERR_NONE ) {
8010d1cc:	e0bffd83 	ldbu	r2,-10(fp)
8010d1d0:	10000126 	beq	r2,zero,8010d1d8 <vSyncHandleIrq+0x74>
		vFailSendMsgMasterSyncMeb( );
8010d1d4:	011daf80 	call	8011daf8 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8010d1d8:	e03ffd05 	stb	zero,-12(fp)
8010d1dc:	00002006 	br	8010d260 <vSyncHandleIrq+0xfc>
		if (xSimMeb.xFeeControl.xNfee[ucIL].xControl.bSimulating == TRUE) {
8010d1e0:	e0fffd03 	ldbu	r3,-12(fp)
8010d1e4:	00a00574 	movhi	r2,32789
8010d1e8:	10813104 	addi	r2,r2,1220
8010d1ec:	18c09b24 	muli	r3,r3,620
8010d1f0:	10c5883a 	add	r2,r2,r3
8010d1f4:	10804204 	addi	r2,r2,264
8010d1f8:	10800017 	ldw	r2,0(r2)
8010d1fc:	10800058 	cmpnei	r2,r2,1
8010d200:	1000141e 	bne	r2,zero,8010d254 <vSyncHandleIrq+0xf0>
			uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8010d204:	e0bffd03 	ldbu	r2,-12(fp)
8010d208:	10800444 	addi	r2,r2,17
8010d20c:	e0bffec5 	stb	r2,-5(fp)
			error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8010d210:	e0fffd03 	ldbu	r3,-12(fp)
8010d214:	00a00574 	movhi	r2,32789
8010d218:	109f5404 	addi	r2,r2,32080
8010d21c:	18c7883a 	add	r3,r3,r3
8010d220:	18c7883a 	add	r3,r3,r3
8010d224:	10c5883a 	add	r2,r2,r3
8010d228:	10800017 	ldw	r2,0(r2)
8010d22c:	e0fffe17 	ldw	r3,-8(fp)
8010d230:	180b883a 	mov	r5,r3
8010d234:	1009883a 	mov	r4,r2
8010d238:	013957c0 	call	8013957c <OSQPostFront>
8010d23c:	e0bffd85 	stb	r2,-10(fp)
			if ( error_codel != OS_ERR_NONE ) {
8010d240:	e0bffd83 	ldbu	r2,-10(fp)
8010d244:	10000326 	beq	r2,zero,8010d254 <vSyncHandleIrq+0xf0>
				vFailSendMsgSync( ucIL );
8010d248:	e0bffd03 	ldbu	r2,-12(fp)
8010d24c:	1009883a 	mov	r4,r2
8010d250:	011da980 	call	8011da98 <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8010d254:	e0bffd03 	ldbu	r2,-12(fp)
8010d258:	10800044 	addi	r2,r2,1
8010d25c:	e0bffd05 	stb	r2,-12(fp)
8010d260:	e0bffd03 	ldbu	r2,-12(fp)
8010d264:	10800130 	cmpltui	r2,r2,4
8010d268:	103fdd1e 	bne	r2,zero,8010d1e0 <__reset+0xfa0ed1e0>
				vFailSendMsgSync( ucIL );
			}
		}
	}

	vucN += 1;
8010d26c:	d0a05203 	ldbu	r2,-32440(gp)
8010d270:	10800044 	addi	r2,r2,1
8010d274:	d0a05205 	stb	r2,-32440(gp)

	vSyncIrqFlagClrSync();
8010d278:	010d30c0 	call	8010d30c <vSyncIrqFlagClrSync>
}
8010d27c:	0001883a 	nop
8010d280:	e037883a 	mov	sp,fp
8010d284:	dfc00117 	ldw	ra,4(sp)
8010d288:	df000017 	ldw	fp,0(sp)
8010d28c:	dec00204 	addi	sp,sp,8
8010d290:	f800283a 	ret

8010d294 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8010d294:	deffff04 	addi	sp,sp,-4
8010d298:	de00012e 	bgeu	sp,et,8010d2a0 <vSyncClearCounter+0xc>
8010d29c:	003b68fa 	trap	3
8010d2a0:	df000015 	stw	fp,0(sp)
8010d2a4:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8010d2a8:	d0205205 	stb	zero,-32440(gp)
}
8010d2ac:	0001883a 	nop
8010d2b0:	e037883a 	mov	sp,fp
8010d2b4:	df000017 	ldw	fp,0(sp)
8010d2b8:	dec00104 	addi	sp,sp,4
8010d2bc:	f800283a 	ret

8010d2c0 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8010d2c0:	defffd04 	addi	sp,sp,-12
8010d2c4:	de00012e 	bgeu	sp,et,8010d2cc <vSyncInitIrq+0xc>
8010d2c8:	003b68fa 	trap	3
8010d2cc:	dfc00215 	stw	ra,8(sp)
8010d2d0:	df000115 	stw	fp,4(sp)
8010d2d4:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8010d2d8:	d0a05104 	addi	r2,gp,-32444
8010d2dc:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8010d2e0:	01a00474 	movhi	r6,32785
8010d2e4:	31b45904 	addi	r6,r6,-11932
8010d2e8:	e17fff17 	ldw	r5,-4(fp)
8010d2ec:	01000184 	movi	r4,6
8010d2f0:	0131c940 	call	80131c94 <alt_irq_register>
}
8010d2f4:	0001883a 	nop
8010d2f8:	e037883a 	mov	sp,fp
8010d2fc:	dfc00117 	ldw	ra,4(sp)
8010d300:	df000017 	ldw	fp,0(sp)
8010d304:	dec00204 	addi	sp,sp,8
8010d308:	f800283a 	ret

8010d30c <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8010d30c:	defffe04 	addi	sp,sp,-8
8010d310:	de00012e 	bgeu	sp,et,8010d318 <vSyncIrqFlagClrSync+0xc>
8010d314:	003b68fa 	trap	3
8010d318:	dfc00115 	stw	ra,4(sp)
8010d31c:	df000015 	stw	fp,0(sp)
8010d320:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8010d324:	01400044 	movi	r5,1
8010d328:	010002c4 	movi	r4,11
8010d32c:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
}
8010d330:	0001883a 	nop
8010d334:	e037883a 	mov	sp,fp
8010d338:	dfc00117 	ldw	ra,4(sp)
8010d33c:	df000017 	ldw	fp,0(sp)
8010d340:	dec00204 	addi	sp,sp,8
8010d344:	f800283a 	ret

8010d348 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8010d348:	defffd04 	addi	sp,sp,-12
8010d34c:	de00012e 	bgeu	sp,et,8010d354 <bSyncIrqFlagSync+0xc>
8010d350:	003b68fa 	trap	3
8010d354:	dfc00215 	stw	ra,8(sp)
8010d358:	df000115 	stw	fp,4(sp)
8010d35c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8010d360:	01000304 	movi	r4,12
8010d364:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d368:	1080004c 	andi	r2,r2,1
8010d36c:	10000326 	beq	r2,zero,8010d37c <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8010d370:	00800044 	movi	r2,1
8010d374:	e0bfff15 	stw	r2,-4(fp)
8010d378:	00000106 	br	8010d380 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8010d37c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8010d380:	e0bfff17 	ldw	r2,-4(fp)
}
8010d384:	e037883a 	mov	sp,fp
8010d388:	dfc00117 	ldw	ra,4(sp)
8010d38c:	df000017 	ldw	fp,0(sp)
8010d390:	dec00204 	addi	sp,sp,8
8010d394:	f800283a 	ret

8010d398 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8010d398:	defffc04 	addi	sp,sp,-16
8010d39c:	de00012e 	bgeu	sp,et,8010d3a4 <bSyncStatusExtnIrq+0xc>
8010d3a0:	003b68fa 	trap	3
8010d3a4:	dfc00315 	stw	ra,12(sp)
8010d3a8:	df000215 	stw	fp,8(sp)
8010d3ac:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8010d3b0:	0009883a 	mov	r4,zero
8010d3b4:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d3b8:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8010d3bc:	e0bfff17 	ldw	r2,-4(fp)
8010d3c0:	1000030e 	bge	r2,zero,8010d3d0 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8010d3c4:	00800044 	movi	r2,1
8010d3c8:	e0bffe15 	stw	r2,-8(fp)
8010d3cc:	00000106 	br	8010d3d4 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8010d3d0:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8010d3d4:	e0bffe17 	ldw	r2,-8(fp)
}
8010d3d8:	e037883a 	mov	sp,fp
8010d3dc:	dfc00117 	ldw	ra,4(sp)
8010d3e0:	df000017 	ldw	fp,0(sp)
8010d3e4:	dec00204 	addi	sp,sp,8
8010d3e8:	f800283a 	ret

8010d3ec <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8010d3ec:	defffc04 	addi	sp,sp,-16
8010d3f0:	de00012e 	bgeu	sp,et,8010d3f8 <ucSyncStatusState+0xc>
8010d3f4:	003b68fa 	trap	3
8010d3f8:	dfc00315 	stw	ra,12(sp)
8010d3fc:	df000215 	stw	fp,8(sp)
8010d400:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8010d404:	0009883a 	mov	r4,zero
8010d408:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d40c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8010d410:	e0bffe17 	ldw	r2,-8(fp)
8010d414:	10803fec 	andhi	r2,r2,255
8010d418:	1004d43a 	srli	r2,r2,16
8010d41c:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8010d420:	e0bfff03 	ldbu	r2,-4(fp)
}
8010d424:	e037883a 	mov	sp,fp
8010d428:	dfc00117 	ldw	ra,4(sp)
8010d42c:	df000017 	ldw	fp,0(sp)
8010d430:	dec00204 	addi	sp,sp,8
8010d434:	f800283a 	ret

8010d438 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8010d438:	defffc04 	addi	sp,sp,-16
8010d43c:	de00012e 	bgeu	sp,et,8010d444 <ucSyncStatusErrorCode+0xc>
8010d440:	003b68fa 	trap	3
8010d444:	dfc00315 	stw	ra,12(sp)
8010d448:	df000215 	stw	fp,8(sp)
8010d44c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8010d450:	0009883a 	mov	r4,zero
8010d454:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d458:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8010d45c:	e0bffe17 	ldw	r2,-8(fp)
8010d460:	10bfc00c 	andi	r2,r2,65280
8010d464:	1004d23a 	srli	r2,r2,8
8010d468:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8010d46c:	e0bfff03 	ldbu	r2,-4(fp)
}
8010d470:	e037883a 	mov	sp,fp
8010d474:	dfc00117 	ldw	ra,4(sp)
8010d478:	df000017 	ldw	fp,0(sp)
8010d47c:	dec00204 	addi	sp,sp,8
8010d480:	f800283a 	ret

8010d484 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8010d484:	defffc04 	addi	sp,sp,-16
8010d488:	de00012e 	bgeu	sp,et,8010d490 <ucSyncStatusCycleNumber+0xc>
8010d48c:	003b68fa 	trap	3
8010d490:	dfc00315 	stw	ra,12(sp)
8010d494:	df000215 	stw	fp,8(sp)
8010d498:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8010d49c:	0009883a 	mov	r4,zero
8010d4a0:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d4a4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8010d4a8:	e0bffe17 	ldw	r2,-8(fp)
8010d4ac:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8010d4b0:	e0bfff03 	ldbu	r2,-4(fp)
}
8010d4b4:	e037883a 	mov	sp,fp
8010d4b8:	dfc00117 	ldw	ra,4(sp)
8010d4bc:	df000017 	ldw	fp,0(sp)
8010d4c0:	dec00204 	addi	sp,sp,8
8010d4c4:	f800283a 	ret

8010d4c8 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8010d4c8:	defffd04 	addi	sp,sp,-12
8010d4cc:	de00012e 	bgeu	sp,et,8010d4d4 <bSyncSetMbt+0xc>
8010d4d0:	003b68fa 	trap	3
8010d4d4:	dfc00215 	stw	ra,8(sp)
8010d4d8:	df000115 	stw	fp,4(sp)
8010d4dc:	df000104 	addi	fp,sp,4
8010d4e0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8010d4e4:	e17fff17 	ldw	r5,-4(fp)
8010d4e8:	01000104 	movi	r4,4
8010d4ec:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d4f0:	00800044 	movi	r2,1
}
8010d4f4:	e037883a 	mov	sp,fp
8010d4f8:	dfc00117 	ldw	ra,4(sp)
8010d4fc:	df000017 	ldw	fp,0(sp)
8010d500:	dec00204 	addi	sp,sp,8
8010d504:	f800283a 	ret

8010d508 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8010d508:	defffd04 	addi	sp,sp,-12
8010d50c:	de00012e 	bgeu	sp,et,8010d514 <bSyncSetBt+0xc>
8010d510:	003b68fa 	trap	3
8010d514:	dfc00215 	stw	ra,8(sp)
8010d518:	df000115 	stw	fp,4(sp)
8010d51c:	df000104 	addi	fp,sp,4
8010d520:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8010d524:	e17fff17 	ldw	r5,-4(fp)
8010d528:	01000144 	movi	r4,5
8010d52c:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d530:	00800044 	movi	r2,1
}
8010d534:	e037883a 	mov	sp,fp
8010d538:	dfc00117 	ldw	ra,4(sp)
8010d53c:	df000017 	ldw	fp,0(sp)
8010d540:	dec00204 	addi	sp,sp,8
8010d544:	f800283a 	ret

8010d548 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8010d548:	defffd04 	addi	sp,sp,-12
8010d54c:	de00012e 	bgeu	sp,et,8010d554 <bSyncSetPer+0xc>
8010d550:	003b68fa 	trap	3
8010d554:	dfc00215 	stw	ra,8(sp)
8010d558:	df000115 	stw	fp,4(sp)
8010d55c:	df000104 	addi	fp,sp,4
8010d560:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8010d564:	e17fff17 	ldw	r5,-4(fp)
8010d568:	01000184 	movi	r4,6
8010d56c:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d570:	00800044 	movi	r2,1
}
8010d574:	e037883a 	mov	sp,fp
8010d578:	dfc00117 	ldw	ra,4(sp)
8010d57c:	df000017 	ldw	fp,0(sp)
8010d580:	dec00204 	addi	sp,sp,8
8010d584:	f800283a 	ret

8010d588 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8010d588:	defffd04 	addi	sp,sp,-12
8010d58c:	de00012e 	bgeu	sp,et,8010d594 <bSyncSetOst+0xc>
8010d590:	003b68fa 	trap	3
8010d594:	dfc00215 	stw	ra,8(sp)
8010d598:	df000115 	stw	fp,4(sp)
8010d59c:	df000104 	addi	fp,sp,4
8010d5a0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8010d5a4:	e17fff17 	ldw	r5,-4(fp)
8010d5a8:	010001c4 	movi	r4,7
8010d5ac:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d5b0:	00800044 	movi	r2,1
}
8010d5b4:	e037883a 	mov	sp,fp
8010d5b8:	dfc00117 	ldw	ra,4(sp)
8010d5bc:	df000017 	ldw	fp,0(sp)
8010d5c0:	dec00204 	addi	sp,sp,8
8010d5c4:	f800283a 	ret

8010d5c8 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8010d5c8:	defffc04 	addi	sp,sp,-16
8010d5cc:	de00012e 	bgeu	sp,et,8010d5d4 <bSyncSetPolarity+0xc>
8010d5d0:	003b68fa 	trap	3
8010d5d4:	dfc00315 	stw	ra,12(sp)
8010d5d8:	df000215 	stw	fp,8(sp)
8010d5dc:	df000204 	addi	fp,sp,8
8010d5e0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8010d5e4:	01000204 	movi	r4,8
8010d5e8:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d5ec:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010d5f0:	e0bfff17 	ldw	r2,-4(fp)
8010d5f4:	1000051e 	bne	r2,zero,8010d60c <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8010d5f8:	e0fffe17 	ldw	r3,-8(fp)
8010d5fc:	00bfbfc4 	movi	r2,-257
8010d600:	1884703a 	and	r2,r3,r2
8010d604:	e0bffe15 	stw	r2,-8(fp)
8010d608:	00000306 	br	8010d618 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8010d60c:	e0bffe17 	ldw	r2,-8(fp)
8010d610:	10804014 	ori	r2,r2,256
8010d614:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8010d618:	e17ffe17 	ldw	r5,-8(fp)
8010d61c:	01000204 	movi	r4,8
8010d620:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d624:	00800044 	movi	r2,1
}
8010d628:	e037883a 	mov	sp,fp
8010d62c:	dfc00117 	ldw	ra,4(sp)
8010d630:	df000017 	ldw	fp,0(sp)
8010d634:	dec00204 	addi	sp,sp,8
8010d638:	f800283a 	ret

8010d63c <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8010d63c:	defffc04 	addi	sp,sp,-16
8010d640:	de00012e 	bgeu	sp,et,8010d648 <bSyncSetNCycles+0xc>
8010d644:	003b68fa 	trap	3
8010d648:	dfc00315 	stw	ra,12(sp)
8010d64c:	df000215 	stw	fp,8(sp)
8010d650:	df000204 	addi	fp,sp,8
8010d654:	2005883a 	mov	r2,r4
8010d658:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8010d65c:	01000204 	movi	r4,8
8010d660:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d664:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8010d668:	e0fffe17 	ldw	r3,-8(fp)
8010d66c:	00bfc004 	movi	r2,-256
8010d670:	1884703a 	and	r2,r3,r2
8010d674:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8010d678:	e0bfff03 	ldbu	r2,-4(fp)
8010d67c:	e0fffe17 	ldw	r3,-8(fp)
8010d680:	1884b03a 	or	r2,r3,r2
8010d684:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8010d688:	e17ffe17 	ldw	r5,-8(fp)
8010d68c:	01000204 	movi	r4,8
8010d690:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d694:	00800044 	movi	r2,1
}
8010d698:	e037883a 	mov	sp,fp
8010d69c:	dfc00117 	ldw	ra,4(sp)
8010d6a0:	df000017 	ldw	fp,0(sp)
8010d6a4:	dec00204 	addi	sp,sp,8
8010d6a8:	f800283a 	ret

8010d6ac <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8010d6ac:	defffd04 	addi	sp,sp,-12
8010d6b0:	de00012e 	bgeu	sp,et,8010d6b8 <uliSyncGetMbt+0xc>
8010d6b4:	003b68fa 	trap	3
8010d6b8:	dfc00215 	stw	ra,8(sp)
8010d6bc:	df000115 	stw	fp,4(sp)
8010d6c0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8010d6c4:	01000104 	movi	r4,4
8010d6c8:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d6cc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8010d6d0:	e0bfff17 	ldw	r2,-4(fp)
}
8010d6d4:	e037883a 	mov	sp,fp
8010d6d8:	dfc00117 	ldw	ra,4(sp)
8010d6dc:	df000017 	ldw	fp,0(sp)
8010d6e0:	dec00204 	addi	sp,sp,8
8010d6e4:	f800283a 	ret

8010d6e8 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8010d6e8:	defffd04 	addi	sp,sp,-12
8010d6ec:	de00012e 	bgeu	sp,et,8010d6f4 <uliSyncGetBt+0xc>
8010d6f0:	003b68fa 	trap	3
8010d6f4:	dfc00215 	stw	ra,8(sp)
8010d6f8:	df000115 	stw	fp,4(sp)
8010d6fc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8010d700:	01000144 	movi	r4,5
8010d704:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d708:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8010d70c:	e0bfff17 	ldw	r2,-4(fp)
}
8010d710:	e037883a 	mov	sp,fp
8010d714:	dfc00117 	ldw	ra,4(sp)
8010d718:	df000017 	ldw	fp,0(sp)
8010d71c:	dec00204 	addi	sp,sp,8
8010d720:	f800283a 	ret

8010d724 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8010d724:	defffd04 	addi	sp,sp,-12
8010d728:	de00012e 	bgeu	sp,et,8010d730 <uliSyncGetPer+0xc>
8010d72c:	003b68fa 	trap	3
8010d730:	dfc00215 	stw	ra,8(sp)
8010d734:	df000115 	stw	fp,4(sp)
8010d738:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8010d73c:	01000184 	movi	r4,6
8010d740:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d744:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8010d748:	e0bfff17 	ldw	r2,-4(fp)
}
8010d74c:	e037883a 	mov	sp,fp
8010d750:	dfc00117 	ldw	ra,4(sp)
8010d754:	df000017 	ldw	fp,0(sp)
8010d758:	dec00204 	addi	sp,sp,8
8010d75c:	f800283a 	ret

8010d760 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8010d760:	defffd04 	addi	sp,sp,-12
8010d764:	de00012e 	bgeu	sp,et,8010d76c <uliSyncGetOst+0xc>
8010d768:	003b68fa 	trap	3
8010d76c:	dfc00215 	stw	ra,8(sp)
8010d770:	df000115 	stw	fp,4(sp)
8010d774:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8010d778:	010001c4 	movi	r4,7
8010d77c:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d780:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8010d784:	e0bfff17 	ldw	r2,-4(fp)
}
8010d788:	e037883a 	mov	sp,fp
8010d78c:	dfc00117 	ldw	ra,4(sp)
8010d790:	df000017 	ldw	fp,0(sp)
8010d794:	dec00204 	addi	sp,sp,8
8010d798:	f800283a 	ret

8010d79c <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8010d79c:	defffd04 	addi	sp,sp,-12
8010d7a0:	de00012e 	bgeu	sp,et,8010d7a8 <uliSyncGetGeneral+0xc>
8010d7a4:	003b68fa 	trap	3
8010d7a8:	dfc00215 	stw	ra,8(sp)
8010d7ac:	df000115 	stw	fp,4(sp)
8010d7b0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8010d7b4:	01000204 	movi	r4,8
8010d7b8:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d7bc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8010d7c0:	e0bfff17 	ldw	r2,-4(fp)
}
8010d7c4:	e037883a 	mov	sp,fp
8010d7c8:	dfc00117 	ldw	ra,4(sp)
8010d7cc:	df000017 	ldw	fp,0(sp)
8010d7d0:	dec00204 	addi	sp,sp,8
8010d7d4:	f800283a 	ret

8010d7d8 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8010d7d8:	defffd04 	addi	sp,sp,-12
8010d7dc:	de00012e 	bgeu	sp,et,8010d7e4 <bSyncErrInj+0xc>
8010d7e0:	003b68fa 	trap	3
8010d7e4:	dfc00215 	stw	ra,8(sp)
8010d7e8:	df000115 	stw	fp,4(sp)
8010d7ec:	df000104 	addi	fp,sp,4
8010d7f0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8010d7f4:	e17fff17 	ldw	r5,-4(fp)
8010d7f8:	01000244 	movi	r4,9
8010d7fc:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d800:	00800044 	movi	r2,1
}
8010d804:	e037883a 	mov	sp,fp
8010d808:	dfc00117 	ldw	ra,4(sp)
8010d80c:	df000017 	ldw	fp,0(sp)
8010d810:	dec00204 	addi	sp,sp,8
8010d814:	f800283a 	ret

8010d818 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8010d818:	defffc04 	addi	sp,sp,-16
8010d81c:	de00012e 	bgeu	sp,et,8010d824 <bSyncCtrExtnIrq+0xc>
8010d820:	003b68fa 	trap	3
8010d824:	dfc00315 	stw	ra,12(sp)
8010d828:	df000215 	stw	fp,8(sp)
8010d82c:	df000204 	addi	fp,sp,8
8010d830:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010d834:	01000284 	movi	r4,10
8010d838:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d83c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010d840:	e0bfff17 	ldw	r2,-4(fp)
8010d844:	1000061e 	bne	r2,zero,8010d860 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8010d848:	e0fffe17 	ldw	r3,-8(fp)
8010d84c:	00a00034 	movhi	r2,32768
8010d850:	10bfffc4 	addi	r2,r2,-1
8010d854:	1884703a 	and	r2,r3,r2
8010d858:	e0bffe15 	stw	r2,-8(fp)
8010d85c:	00000306 	br	8010d86c <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8010d860:	e0bffe17 	ldw	r2,-8(fp)
8010d864:	10a00034 	orhi	r2,r2,32768
8010d868:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010d86c:	e17ffe17 	ldw	r5,-8(fp)
8010d870:	01000284 	movi	r4,10
8010d874:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d878:	00800044 	movi	r2,1
}
8010d87c:	e037883a 	mov	sp,fp
8010d880:	dfc00117 	ldw	ra,4(sp)
8010d884:	df000017 	ldw	fp,0(sp)
8010d888:	dec00204 	addi	sp,sp,8
8010d88c:	f800283a 	ret

8010d890 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8010d890:	defffd04 	addi	sp,sp,-12
8010d894:	de00012e 	bgeu	sp,et,8010d89c <bSyncCtrStart+0xc>
8010d898:	003b68fa 	trap	3
8010d89c:	dfc00215 	stw	ra,8(sp)
8010d8a0:	df000115 	stw	fp,4(sp)
8010d8a4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010d8a8:	01000284 	movi	r4,10
8010d8ac:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d8b0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8010d8b4:	e0bfff17 	ldw	r2,-4(fp)
8010d8b8:	10800234 	orhi	r2,r2,8
8010d8bc:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010d8c0:	e17fff17 	ldw	r5,-4(fp)
8010d8c4:	01000284 	movi	r4,10
8010d8c8:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d8cc:	00800044 	movi	r2,1
}
8010d8d0:	e037883a 	mov	sp,fp
8010d8d4:	dfc00117 	ldw	ra,4(sp)
8010d8d8:	df000017 	ldw	fp,0(sp)
8010d8dc:	dec00204 	addi	sp,sp,8
8010d8e0:	f800283a 	ret

8010d8e4 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8010d8e4:	defffd04 	addi	sp,sp,-12
8010d8e8:	de00012e 	bgeu	sp,et,8010d8f0 <bSyncCtrReset+0xc>
8010d8ec:	003b68fa 	trap	3
8010d8f0:	dfc00215 	stw	ra,8(sp)
8010d8f4:	df000115 	stw	fp,4(sp)
8010d8f8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010d8fc:	01000284 	movi	r4,10
8010d900:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d904:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8010d908:	e0bfff17 	ldw	r2,-4(fp)
8010d90c:	10800134 	orhi	r2,r2,4
8010d910:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010d914:	e17fff17 	ldw	r5,-4(fp)
8010d918:	01000284 	movi	r4,10
8010d91c:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d920:	00800044 	movi	r2,1
}
8010d924:	e037883a 	mov	sp,fp
8010d928:	dfc00117 	ldw	ra,4(sp)
8010d92c:	df000017 	ldw	fp,0(sp)
8010d930:	dec00204 	addi	sp,sp,8
8010d934:	f800283a 	ret

8010d938 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8010d938:	defffd04 	addi	sp,sp,-12
8010d93c:	de00012e 	bgeu	sp,et,8010d944 <bSyncCtrOneShot+0xc>
8010d940:	003b68fa 	trap	3
8010d944:	dfc00215 	stw	ra,8(sp)
8010d948:	df000115 	stw	fp,4(sp)
8010d94c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010d950:	01000284 	movi	r4,10
8010d954:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d958:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8010d95c:	e0bfff17 	ldw	r2,-4(fp)
8010d960:	108000b4 	orhi	r2,r2,2
8010d964:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010d968:	e17fff17 	ldw	r5,-4(fp)
8010d96c:	01000284 	movi	r4,10
8010d970:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d974:	00800044 	movi	r2,1
}
8010d978:	e037883a 	mov	sp,fp
8010d97c:	dfc00117 	ldw	ra,4(sp)
8010d980:	df000017 	ldw	fp,0(sp)
8010d984:	dec00204 	addi	sp,sp,8
8010d988:	f800283a 	ret

8010d98c <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8010d98c:	defffd04 	addi	sp,sp,-12
8010d990:	de00012e 	bgeu	sp,et,8010d998 <bSyncCtrErrInj+0xc>
8010d994:	003b68fa 	trap	3
8010d998:	dfc00215 	stw	ra,8(sp)
8010d99c:	df000115 	stw	fp,4(sp)
8010d9a0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010d9a4:	01000284 	movi	r4,10
8010d9a8:	010e1480 	call	8010e148 <uliSyncReadReg>
8010d9ac:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8010d9b0:	e0bfff17 	ldw	r2,-4(fp)
8010d9b4:	10800074 	orhi	r2,r2,1
8010d9b8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010d9bc:	e17fff17 	ldw	r5,-4(fp)
8010d9c0:	01000284 	movi	r4,10
8010d9c4:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010d9c8:	00800044 	movi	r2,1
}
8010d9cc:	e037883a 	mov	sp,fp
8010d9d0:	dfc00117 	ldw	ra,4(sp)
8010d9d4:	df000017 	ldw	fp,0(sp)
8010d9d8:	dec00204 	addi	sp,sp,8
8010d9dc:	f800283a 	ret

8010d9e0 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8010d9e0:	defffc04 	addi	sp,sp,-16
8010d9e4:	de00012e 	bgeu	sp,et,8010d9ec <bSyncCtrSyncOutEnable+0xc>
8010d9e8:	003b68fa 	trap	3
8010d9ec:	dfc00315 	stw	ra,12(sp)
8010d9f0:	df000215 	stw	fp,8(sp)
8010d9f4:	df000204 	addi	fp,sp,8
8010d9f8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010d9fc:	01000284 	movi	r4,10
8010da00:	010e1480 	call	8010e148 <uliSyncReadReg>
8010da04:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010da08:	e0bfff17 	ldw	r2,-4(fp)
8010da0c:	1000051e 	bne	r2,zero,8010da24 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8010da10:	e0fffe17 	ldw	r3,-8(fp)
8010da14:	00bfbfc4 	movi	r2,-257
8010da18:	1884703a 	and	r2,r3,r2
8010da1c:	e0bffe15 	stw	r2,-8(fp)
8010da20:	00000306 	br	8010da30 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8010da24:	e0bffe17 	ldw	r2,-8(fp)
8010da28:	10804014 	ori	r2,r2,256
8010da2c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010da30:	e17ffe17 	ldw	r5,-8(fp)
8010da34:	01000284 	movi	r4,10
8010da38:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010da3c:	00800044 	movi	r2,1
}
8010da40:	e037883a 	mov	sp,fp
8010da44:	dfc00117 	ldw	ra,4(sp)
8010da48:	df000017 	ldw	fp,0(sp)
8010da4c:	dec00204 	addi	sp,sp,8
8010da50:	f800283a 	ret

8010da54 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8010da54:	defffc04 	addi	sp,sp,-16
8010da58:	de00012e 	bgeu	sp,et,8010da60 <bSyncCtrCh1OutEnable+0xc>
8010da5c:	003b68fa 	trap	3
8010da60:	dfc00315 	stw	ra,12(sp)
8010da64:	df000215 	stw	fp,8(sp)
8010da68:	df000204 	addi	fp,sp,8
8010da6c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010da70:	01000284 	movi	r4,10
8010da74:	010e1480 	call	8010e148 <uliSyncReadReg>
8010da78:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010da7c:	e0bfff17 	ldw	r2,-4(fp)
8010da80:	1000051e 	bne	r2,zero,8010da98 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8010da84:	e0fffe17 	ldw	r3,-8(fp)
8010da88:	00bfff84 	movi	r2,-2
8010da8c:	1884703a 	and	r2,r3,r2
8010da90:	e0bffe15 	stw	r2,-8(fp)
8010da94:	00000306 	br	8010daa4 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8010da98:	e0bffe17 	ldw	r2,-8(fp)
8010da9c:	10800054 	ori	r2,r2,1
8010daa0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010daa4:	e17ffe17 	ldw	r5,-8(fp)
8010daa8:	01000284 	movi	r4,10
8010daac:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010dab0:	00800044 	movi	r2,1
}
8010dab4:	e037883a 	mov	sp,fp
8010dab8:	dfc00117 	ldw	ra,4(sp)
8010dabc:	df000017 	ldw	fp,0(sp)
8010dac0:	dec00204 	addi	sp,sp,8
8010dac4:	f800283a 	ret

8010dac8 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8010dac8:	defffc04 	addi	sp,sp,-16
8010dacc:	de00012e 	bgeu	sp,et,8010dad4 <bSyncCtrCh2OutEnable+0xc>
8010dad0:	003b68fa 	trap	3
8010dad4:	dfc00315 	stw	ra,12(sp)
8010dad8:	df000215 	stw	fp,8(sp)
8010dadc:	df000204 	addi	fp,sp,8
8010dae0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010dae4:	01000284 	movi	r4,10
8010dae8:	010e1480 	call	8010e148 <uliSyncReadReg>
8010daec:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010daf0:	e0bfff17 	ldw	r2,-4(fp)
8010daf4:	1000051e 	bne	r2,zero,8010db0c <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8010daf8:	e0fffe17 	ldw	r3,-8(fp)
8010dafc:	00bfff44 	movi	r2,-3
8010db00:	1884703a 	and	r2,r3,r2
8010db04:	e0bffe15 	stw	r2,-8(fp)
8010db08:	00000306 	br	8010db18 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8010db0c:	e0bffe17 	ldw	r2,-8(fp)
8010db10:	10800094 	ori	r2,r2,2
8010db14:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010db18:	e17ffe17 	ldw	r5,-8(fp)
8010db1c:	01000284 	movi	r4,10
8010db20:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010db24:	00800044 	movi	r2,1
}
8010db28:	e037883a 	mov	sp,fp
8010db2c:	dfc00117 	ldw	ra,4(sp)
8010db30:	df000017 	ldw	fp,0(sp)
8010db34:	dec00204 	addi	sp,sp,8
8010db38:	f800283a 	ret

8010db3c <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8010db3c:	defffc04 	addi	sp,sp,-16
8010db40:	de00012e 	bgeu	sp,et,8010db48 <bSyncCtrCh3OutEnable+0xc>
8010db44:	003b68fa 	trap	3
8010db48:	dfc00315 	stw	ra,12(sp)
8010db4c:	df000215 	stw	fp,8(sp)
8010db50:	df000204 	addi	fp,sp,8
8010db54:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010db58:	01000284 	movi	r4,10
8010db5c:	010e1480 	call	8010e148 <uliSyncReadReg>
8010db60:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010db64:	e0bfff17 	ldw	r2,-4(fp)
8010db68:	1000051e 	bne	r2,zero,8010db80 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8010db6c:	e0fffe17 	ldw	r3,-8(fp)
8010db70:	00bffec4 	movi	r2,-5
8010db74:	1884703a 	and	r2,r3,r2
8010db78:	e0bffe15 	stw	r2,-8(fp)
8010db7c:	00000306 	br	8010db8c <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8010db80:	e0bffe17 	ldw	r2,-8(fp)
8010db84:	10800114 	ori	r2,r2,4
8010db88:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010db8c:	e17ffe17 	ldw	r5,-8(fp)
8010db90:	01000284 	movi	r4,10
8010db94:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010db98:	00800044 	movi	r2,1
}
8010db9c:	e037883a 	mov	sp,fp
8010dba0:	dfc00117 	ldw	ra,4(sp)
8010dba4:	df000017 	ldw	fp,0(sp)
8010dba8:	dec00204 	addi	sp,sp,8
8010dbac:	f800283a 	ret

8010dbb0 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8010dbb0:	defffc04 	addi	sp,sp,-16
8010dbb4:	de00012e 	bgeu	sp,et,8010dbbc <bSyncCtrCh4OutEnable+0xc>
8010dbb8:	003b68fa 	trap	3
8010dbbc:	dfc00315 	stw	ra,12(sp)
8010dbc0:	df000215 	stw	fp,8(sp)
8010dbc4:	df000204 	addi	fp,sp,8
8010dbc8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010dbcc:	01000284 	movi	r4,10
8010dbd0:	010e1480 	call	8010e148 <uliSyncReadReg>
8010dbd4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010dbd8:	e0bfff17 	ldw	r2,-4(fp)
8010dbdc:	1000051e 	bne	r2,zero,8010dbf4 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8010dbe0:	e0fffe17 	ldw	r3,-8(fp)
8010dbe4:	00bffdc4 	movi	r2,-9
8010dbe8:	1884703a 	and	r2,r3,r2
8010dbec:	e0bffe15 	stw	r2,-8(fp)
8010dbf0:	00000306 	br	8010dc00 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8010dbf4:	e0bffe17 	ldw	r2,-8(fp)
8010dbf8:	10800214 	ori	r2,r2,8
8010dbfc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010dc00:	e17ffe17 	ldw	r5,-8(fp)
8010dc04:	01000284 	movi	r4,10
8010dc08:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010dc0c:	00800044 	movi	r2,1
}
8010dc10:	e037883a 	mov	sp,fp
8010dc14:	dfc00117 	ldw	ra,4(sp)
8010dc18:	df000017 	ldw	fp,0(sp)
8010dc1c:	dec00204 	addi	sp,sp,8
8010dc20:	f800283a 	ret

8010dc24 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8010dc24:	defffc04 	addi	sp,sp,-16
8010dc28:	de00012e 	bgeu	sp,et,8010dc30 <bSyncCtrCh5OutEnable+0xc>
8010dc2c:	003b68fa 	trap	3
8010dc30:	dfc00315 	stw	ra,12(sp)
8010dc34:	df000215 	stw	fp,8(sp)
8010dc38:	df000204 	addi	fp,sp,8
8010dc3c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010dc40:	01000284 	movi	r4,10
8010dc44:	010e1480 	call	8010e148 <uliSyncReadReg>
8010dc48:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010dc4c:	e0bfff17 	ldw	r2,-4(fp)
8010dc50:	1000051e 	bne	r2,zero,8010dc68 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8010dc54:	e0fffe17 	ldw	r3,-8(fp)
8010dc58:	00bffbc4 	movi	r2,-17
8010dc5c:	1884703a 	and	r2,r3,r2
8010dc60:	e0bffe15 	stw	r2,-8(fp)
8010dc64:	00000306 	br	8010dc74 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8010dc68:	e0bffe17 	ldw	r2,-8(fp)
8010dc6c:	10800414 	ori	r2,r2,16
8010dc70:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010dc74:	e17ffe17 	ldw	r5,-8(fp)
8010dc78:	01000284 	movi	r4,10
8010dc7c:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010dc80:	00800044 	movi	r2,1
}
8010dc84:	e037883a 	mov	sp,fp
8010dc88:	dfc00117 	ldw	ra,4(sp)
8010dc8c:	df000017 	ldw	fp,0(sp)
8010dc90:	dec00204 	addi	sp,sp,8
8010dc94:	f800283a 	ret

8010dc98 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8010dc98:	defffc04 	addi	sp,sp,-16
8010dc9c:	de00012e 	bgeu	sp,et,8010dca4 <bSyncCtrCh6OutEnable+0xc>
8010dca0:	003b68fa 	trap	3
8010dca4:	dfc00315 	stw	ra,12(sp)
8010dca8:	df000215 	stw	fp,8(sp)
8010dcac:	df000204 	addi	fp,sp,8
8010dcb0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010dcb4:	01000284 	movi	r4,10
8010dcb8:	010e1480 	call	8010e148 <uliSyncReadReg>
8010dcbc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010dcc0:	e0bfff17 	ldw	r2,-4(fp)
8010dcc4:	1000051e 	bne	r2,zero,8010dcdc <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8010dcc8:	e0fffe17 	ldw	r3,-8(fp)
8010dccc:	00bff7c4 	movi	r2,-33
8010dcd0:	1884703a 	and	r2,r3,r2
8010dcd4:	e0bffe15 	stw	r2,-8(fp)
8010dcd8:	00000306 	br	8010dce8 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8010dcdc:	e0bffe17 	ldw	r2,-8(fp)
8010dce0:	10800814 	ori	r2,r2,32
8010dce4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010dce8:	e17ffe17 	ldw	r5,-8(fp)
8010dcec:	01000284 	movi	r4,10
8010dcf0:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010dcf4:	00800044 	movi	r2,1
}
8010dcf8:	e037883a 	mov	sp,fp
8010dcfc:	dfc00117 	ldw	ra,4(sp)
8010dd00:	df000017 	ldw	fp,0(sp)
8010dd04:	dec00204 	addi	sp,sp,8
8010dd08:	f800283a 	ret

8010dd0c <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8010dd0c:	defffc04 	addi	sp,sp,-16
8010dd10:	de00012e 	bgeu	sp,et,8010dd18 <bSyncCtrCh7OutEnable+0xc>
8010dd14:	003b68fa 	trap	3
8010dd18:	dfc00315 	stw	ra,12(sp)
8010dd1c:	df000215 	stw	fp,8(sp)
8010dd20:	df000204 	addi	fp,sp,8
8010dd24:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010dd28:	01000284 	movi	r4,10
8010dd2c:	010e1480 	call	8010e148 <uliSyncReadReg>
8010dd30:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010dd34:	e0bfff17 	ldw	r2,-4(fp)
8010dd38:	1000051e 	bne	r2,zero,8010dd50 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8010dd3c:	e0fffe17 	ldw	r3,-8(fp)
8010dd40:	00bfefc4 	movi	r2,-65
8010dd44:	1884703a 	and	r2,r3,r2
8010dd48:	e0bffe15 	stw	r2,-8(fp)
8010dd4c:	00000306 	br	8010dd5c <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8010dd50:	e0bffe17 	ldw	r2,-8(fp)
8010dd54:	10801014 	ori	r2,r2,64
8010dd58:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010dd5c:	e17ffe17 	ldw	r5,-8(fp)
8010dd60:	01000284 	movi	r4,10
8010dd64:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010dd68:	00800044 	movi	r2,1
}
8010dd6c:	e037883a 	mov	sp,fp
8010dd70:	dfc00117 	ldw	ra,4(sp)
8010dd74:	df000017 	ldw	fp,0(sp)
8010dd78:	dec00204 	addi	sp,sp,8
8010dd7c:	f800283a 	ret

8010dd80 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8010dd80:	defffc04 	addi	sp,sp,-16
8010dd84:	de00012e 	bgeu	sp,et,8010dd8c <bSyncCtrCh8OutEnable+0xc>
8010dd88:	003b68fa 	trap	3
8010dd8c:	dfc00315 	stw	ra,12(sp)
8010dd90:	df000215 	stw	fp,8(sp)
8010dd94:	df000204 	addi	fp,sp,8
8010dd98:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010dd9c:	01000284 	movi	r4,10
8010dda0:	010e1480 	call	8010e148 <uliSyncReadReg>
8010dda4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010dda8:	e0bfff17 	ldw	r2,-4(fp)
8010ddac:	1000051e 	bne	r2,zero,8010ddc4 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8010ddb0:	e0fffe17 	ldw	r3,-8(fp)
8010ddb4:	00bfdfc4 	movi	r2,-129
8010ddb8:	1884703a 	and	r2,r3,r2
8010ddbc:	e0bffe15 	stw	r2,-8(fp)
8010ddc0:	00000306 	br	8010ddd0 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8010ddc4:	e0bffe17 	ldw	r2,-8(fp)
8010ddc8:	10802014 	ori	r2,r2,128
8010ddcc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8010ddd0:	e17ffe17 	ldw	r5,-8(fp)
8010ddd4:	01000284 	movi	r4,10
8010ddd8:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010dddc:	00800044 	movi	r2,1
}
8010dde0:	e037883a 	mov	sp,fp
8010dde4:	dfc00117 	ldw	ra,4(sp)
8010dde8:	df000017 	ldw	fp,0(sp)
8010ddec:	dec00204 	addi	sp,sp,8
8010ddf0:	f800283a 	ret

8010ddf4 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8010ddf4:	defffc04 	addi	sp,sp,-16
8010ddf8:	de00012e 	bgeu	sp,et,8010de00 <bSyncIrqEnableError+0xc>
8010ddfc:	003b68fa 	trap	3
8010de00:	dfc00315 	stw	ra,12(sp)
8010de04:	df000215 	stw	fp,8(sp)
8010de08:	df000204 	addi	fp,sp,8
8010de0c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8010de10:	01000044 	movi	r4,1
8010de14:	010e1480 	call	8010e148 <uliSyncReadReg>
8010de18:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010de1c:	e0bfff17 	ldw	r2,-4(fp)
8010de20:	1000051e 	bne	r2,zero,8010de38 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8010de24:	e0fffe17 	ldw	r3,-8(fp)
8010de28:	00bfff44 	movi	r2,-3
8010de2c:	1884703a 	and	r2,r3,r2
8010de30:	e0bffe15 	stw	r2,-8(fp)
8010de34:	00000306 	br	8010de44 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8010de38:	e0bffe17 	ldw	r2,-8(fp)
8010de3c:	10800094 	ori	r2,r2,2
8010de40:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8010de44:	e17ffe17 	ldw	r5,-8(fp)
8010de48:	01000044 	movi	r4,1
8010de4c:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010de50:	00800044 	movi	r2,1
}
8010de54:	e037883a 	mov	sp,fp
8010de58:	dfc00117 	ldw	ra,4(sp)
8010de5c:	df000017 	ldw	fp,0(sp)
8010de60:	dec00204 	addi	sp,sp,8
8010de64:	f800283a 	ret

8010de68 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8010de68:	defffc04 	addi	sp,sp,-16
8010de6c:	de00012e 	bgeu	sp,et,8010de74 <bSyncIrqEnableBlank+0xc>
8010de70:	003b68fa 	trap	3
8010de74:	dfc00315 	stw	ra,12(sp)
8010de78:	df000215 	stw	fp,8(sp)
8010de7c:	df000204 	addi	fp,sp,8
8010de80:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8010de84:	01000044 	movi	r4,1
8010de88:	010e1480 	call	8010e148 <uliSyncReadReg>
8010de8c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010de90:	e0bfff17 	ldw	r2,-4(fp)
8010de94:	1000051e 	bne	r2,zero,8010deac <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8010de98:	e0fffe17 	ldw	r3,-8(fp)
8010de9c:	00bfff84 	movi	r2,-2
8010dea0:	1884703a 	and	r2,r3,r2
8010dea4:	e0bffe15 	stw	r2,-8(fp)
8010dea8:	00000306 	br	8010deb8 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8010deac:	e0bffe17 	ldw	r2,-8(fp)
8010deb0:	10800054 	ori	r2,r2,1
8010deb4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8010deb8:	e17ffe17 	ldw	r5,-8(fp)
8010debc:	01000044 	movi	r4,1
8010dec0:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010dec4:	00800044 	movi	r2,1
}
8010dec8:	e037883a 	mov	sp,fp
8010decc:	dfc00117 	ldw	ra,4(sp)
8010ded0:	df000017 	ldw	fp,0(sp)
8010ded4:	dec00204 	addi	sp,sp,8
8010ded8:	f800283a 	ret

8010dedc <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8010dedc:	defffc04 	addi	sp,sp,-16
8010dee0:	de00012e 	bgeu	sp,et,8010dee8 <bSyncIrqFlagClrError+0xc>
8010dee4:	003b68fa 	trap	3
8010dee8:	dfc00315 	stw	ra,12(sp)
8010deec:	df000215 	stw	fp,8(sp)
8010def0:	df000204 	addi	fp,sp,8
8010def4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8010def8:	01000084 	movi	r4,2
8010defc:	010e1480 	call	8010e148 <uliSyncReadReg>
8010df00:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010df04:	e0bfff17 	ldw	r2,-4(fp)
8010df08:	1000051e 	bne	r2,zero,8010df20 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8010df0c:	e0fffe17 	ldw	r3,-8(fp)
8010df10:	00bfff44 	movi	r2,-3
8010df14:	1884703a 	and	r2,r3,r2
8010df18:	e0bffe15 	stw	r2,-8(fp)
8010df1c:	00000306 	br	8010df2c <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8010df20:	e0bffe17 	ldw	r2,-8(fp)
8010df24:	10800094 	ori	r2,r2,2
8010df28:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8010df2c:	e17ffe17 	ldw	r5,-8(fp)
8010df30:	01000084 	movi	r4,2
8010df34:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010df38:	00800044 	movi	r2,1
}
8010df3c:	e037883a 	mov	sp,fp
8010df40:	dfc00117 	ldw	ra,4(sp)
8010df44:	df000017 	ldw	fp,0(sp)
8010df48:	dec00204 	addi	sp,sp,8
8010df4c:	f800283a 	ret

8010df50 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8010df50:	defffc04 	addi	sp,sp,-16
8010df54:	de00012e 	bgeu	sp,et,8010df5c <bSyncIrqFlagClrBlank+0xc>
8010df58:	003b68fa 	trap	3
8010df5c:	dfc00315 	stw	ra,12(sp)
8010df60:	df000215 	stw	fp,8(sp)
8010df64:	df000204 	addi	fp,sp,8
8010df68:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8010df6c:	01000084 	movi	r4,2
8010df70:	010e1480 	call	8010e148 <uliSyncReadReg>
8010df74:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8010df78:	e0bfff17 	ldw	r2,-4(fp)
8010df7c:	1000051e 	bne	r2,zero,8010df94 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8010df80:	e0fffe17 	ldw	r3,-8(fp)
8010df84:	00bfff84 	movi	r2,-2
8010df88:	1884703a 	and	r2,r3,r2
8010df8c:	e0bffe15 	stw	r2,-8(fp)
8010df90:	00000306 	br	8010dfa0 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8010df94:	e0bffe17 	ldw	r2,-8(fp)
8010df98:	10800054 	ori	r2,r2,1
8010df9c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8010dfa0:	e17ffe17 	ldw	r5,-8(fp)
8010dfa4:	01000084 	movi	r4,2
8010dfa8:	010e0ec0 	call	8010e0ec <bSyncWriteReg>
	return TRUE;
8010dfac:	00800044 	movi	r2,1
}
8010dfb0:	e037883a 	mov	sp,fp
8010dfb4:	dfc00117 	ldw	ra,4(sp)
8010dfb8:	df000017 	ldw	fp,0(sp)
8010dfbc:	dec00204 	addi	sp,sp,8
8010dfc0:	f800283a 	ret

8010dfc4 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8010dfc4:	defffc04 	addi	sp,sp,-16
8010dfc8:	de00012e 	bgeu	sp,et,8010dfd0 <bSyncIrqFlagError+0xc>
8010dfcc:	003b68fa 	trap	3
8010dfd0:	dfc00315 	stw	ra,12(sp)
8010dfd4:	df000215 	stw	fp,8(sp)
8010dfd8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8010dfdc:	010000c4 	movi	r4,3
8010dfe0:	010e1480 	call	8010e148 <uliSyncReadReg>
8010dfe4:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8010dfe8:	e0bfff17 	ldw	r2,-4(fp)
8010dfec:	1080008c 	andi	r2,r2,2
8010dff0:	10000326 	beq	r2,zero,8010e000 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8010dff4:	00800044 	movi	r2,1
8010dff8:	e0bffe15 	stw	r2,-8(fp)
8010dffc:	00000106 	br	8010e004 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8010e000:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8010e004:	e0bffe17 	ldw	r2,-8(fp)
}
8010e008:	e037883a 	mov	sp,fp
8010e00c:	dfc00117 	ldw	ra,4(sp)
8010e010:	df000017 	ldw	fp,0(sp)
8010e014:	dec00204 	addi	sp,sp,8
8010e018:	f800283a 	ret

8010e01c <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8010e01c:	defffc04 	addi	sp,sp,-16
8010e020:	de00012e 	bgeu	sp,et,8010e028 <bSyncIrqFlagBlank+0xc>
8010e024:	003b68fa 	trap	3
8010e028:	dfc00315 	stw	ra,12(sp)
8010e02c:	df000215 	stw	fp,8(sp)
8010e030:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8010e034:	010000c4 	movi	r4,3
8010e038:	010e1480 	call	8010e148 <uliSyncReadReg>
8010e03c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8010e040:	e0bfff17 	ldw	r2,-4(fp)
8010e044:	1080004c 	andi	r2,r2,1
8010e048:	10000326 	beq	r2,zero,8010e058 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8010e04c:	00800044 	movi	r2,1
8010e050:	e0bffe15 	stw	r2,-8(fp)
8010e054:	00000106 	br	8010e05c <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8010e058:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8010e05c:	e0bffe17 	ldw	r2,-8(fp)
}
8010e060:	e037883a 	mov	sp,fp
8010e064:	dfc00117 	ldw	ra,4(sp)
8010e068:	df000017 	ldw	fp,0(sp)
8010e06c:	dec00204 	addi	sp,sp,8
8010e070:	f800283a 	ret

8010e074 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8010e074:	defffd04 	addi	sp,sp,-12
8010e078:	de00012e 	bgeu	sp,et,8010e080 <uliSyncGetCtr+0xc>
8010e07c:	003b68fa 	trap	3
8010e080:	dfc00215 	stw	ra,8(sp)
8010e084:	df000115 	stw	fp,4(sp)
8010e088:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8010e08c:	01000284 	movi	r4,10
8010e090:	010e1480 	call	8010e148 <uliSyncReadReg>
8010e094:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8010e098:	e0bfff17 	ldw	r2,-4(fp)
}
8010e09c:	e037883a 	mov	sp,fp
8010e0a0:	dfc00117 	ldw	ra,4(sp)
8010e0a4:	df000017 	ldw	fp,0(sp)
8010e0a8:	dec00204 	addi	sp,sp,8
8010e0ac:	f800283a 	ret

8010e0b0 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8010e0b0:	defffd04 	addi	sp,sp,-12
8010e0b4:	de00012e 	bgeu	sp,et,8010e0bc <uliSyncReadStatus+0xc>
8010e0b8:	003b68fa 	trap	3
8010e0bc:	dfc00215 	stw	ra,8(sp)
8010e0c0:	df000115 	stw	fp,4(sp)
8010e0c4:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8010e0c8:	0009883a 	mov	r4,zero
8010e0cc:	010e1480 	call	8010e148 <uliSyncReadReg>
8010e0d0:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8010e0d4:	e0bfff17 	ldw	r2,-4(fp)
}
8010e0d8:	e037883a 	mov	sp,fp
8010e0dc:	dfc00117 	ldw	ra,4(sp)
8010e0e0:	df000017 	ldw	fp,0(sp)
8010e0e4:	dec00204 	addi	sp,sp,8
8010e0e8:	f800283a 	ret

8010e0ec <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8010e0ec:	defffc04 	addi	sp,sp,-16
8010e0f0:	de00012e 	bgeu	sp,et,8010e0f8 <bSyncWriteReg+0xc>
8010e0f4:	003b68fa 	trap	3
8010e0f8:	df000315 	stw	fp,12(sp)
8010e0fc:	df000304 	addi	fp,sp,12
8010e100:	e13ffe15 	stw	r4,-8(fp)
8010e104:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8010e108:	00900034 	movhi	r2,16384
8010e10c:	10810004 	addi	r2,r2,1024
8010e110:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8010e114:	e0bffe17 	ldw	r2,-8(fp)
8010e118:	1085883a 	add	r2,r2,r2
8010e11c:	1085883a 	add	r2,r2,r2
8010e120:	1007883a 	mov	r3,r2
8010e124:	e0bffd17 	ldw	r2,-12(fp)
8010e128:	10c5883a 	add	r2,r2,r3
8010e12c:	e0ffff17 	ldw	r3,-4(fp)
8010e130:	10c00015 	stw	r3,0(r2)
	return TRUE;
8010e134:	00800044 	movi	r2,1
}
8010e138:	e037883a 	mov	sp,fp
8010e13c:	df000017 	ldw	fp,0(sp)
8010e140:	dec00104 	addi	sp,sp,4
8010e144:	f800283a 	ret

8010e148 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8010e148:	defffc04 	addi	sp,sp,-16
8010e14c:	de00012e 	bgeu	sp,et,8010e154 <uliSyncReadReg+0xc>
8010e150:	003b68fa 	trap	3
8010e154:	df000315 	stw	fp,12(sp)
8010e158:	df000304 	addi	fp,sp,12
8010e15c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8010e160:	00900034 	movhi	r2,16384
8010e164:	10810004 	addi	r2,r2,1024
8010e168:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8010e16c:	e0bfff17 	ldw	r2,-4(fp)
8010e170:	1085883a 	add	r2,r2,r2
8010e174:	1085883a 	add	r2,r2,r2
8010e178:	1007883a 	mov	r3,r2
8010e17c:	e0bffd17 	ldw	r2,-12(fp)
8010e180:	10c5883a 	add	r2,r2,r3
8010e184:	10800017 	ldw	r2,0(r2)
8010e188:	e0bffe15 	stw	r2,-8(fp)
	return value;
8010e18c:	e0bffe17 	ldw	r2,-8(fp)
}
8010e190:	e037883a 	mov	sp,fp
8010e194:	df000017 	ldw	fp,0(sp)
8010e198:	dec00104 	addi	sp,sp,4
8010e19c:	f800283a 	ret

8010e1a0 <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8010e1a0:	defffc04 	addi	sp,sp,-16
8010e1a4:	de00012e 	bgeu	sp,et,8010e1ac <uliPerCalcPeriodMs+0xc>
8010e1a8:	003b68fa 	trap	3
8010e1ac:	dfc00315 	stw	ra,12(sp)
8010e1b0:	df000215 	stw	fp,8(sp)
8010e1b4:	df000204 	addi	fp,sp,8
8010e1b8:	2005883a 	mov	r2,r4
8010e1bc:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8010e1c0:	e0bfff0b 	ldhu	r2,-4(fp)
8010e1c4:	1009883a 	mov	r4,r2
8010e1c8:	012102c0 	call	8012102c <__floatsidf>
8010e1cc:	1011883a 	mov	r8,r2
8010e1d0:	1813883a 	mov	r9,r3
8010e1d4:	000d883a 	mov	r6,zero
8010e1d8:	01d03a34 	movhi	r7,16616
8010e1dc:	39da8004 	addi	r7,r7,27136
8010e1e0:	4009883a 	mov	r4,r8
8010e1e4:	480b883a 	mov	r5,r9
8010e1e8:	011ff880 	call	8011ff88 <__muldf3>
8010e1ec:	1009883a 	mov	r4,r2
8010e1f0:	180b883a 	mov	r5,r3
8010e1f4:	2005883a 	mov	r2,r4
8010e1f8:	2807883a 	mov	r3,r5
8010e1fc:	1009883a 	mov	r4,r2
8010e200:	180b883a 	mov	r5,r3
8010e204:	011f4ec0 	call	8011f4ec <__fixunsdfsi>
8010e208:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8010e20c:	e0bffe17 	ldw	r2,-8(fp)
}
8010e210:	e037883a 	mov	sp,fp
8010e214:	dfc00117 	ldw	ra,4(sp)
8010e218:	df000017 	ldw	fp,0(sp)
8010e21c:	dec00204 	addi	sp,sp,8
8010e220:	f800283a 	ret

8010e224 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8010e224:	defff804 	addi	sp,sp,-32
8010e228:	de00012e 	bgeu	sp,et,8010e230 <vDataControlTask+0xc>
8010e22c:	003b68fa 	trap	3
8010e230:	dfc00715 	stw	ra,28(sp)
8010e234:	df000615 	stw	fp,24(sp)
8010e238:	df000604 	addi	fp,sp,24
8010e23c:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8010e240:	e0bffd17 	ldw	r2,-12(fp)
8010e244:	e0bffa15 	stw	r2,-24(fp)
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
        debug(fp,"Data Controller Task. (Task on)\n");
	}
    #endif

    pxDataC->bUpdateComplete = TRUE;
8010e248:	e0bffa17 	ldw	r2,-24(fp)
8010e24c:	00c00044 	movi	r3,1
8010e250:	10c00e15 	stw	r3,56(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8010e254:	d0a06a17 	ldw	r2,-32344(gp)
8010e258:	1009883a 	mov	r4,r2
8010e25c:	0138f440 	call	80138f44 <OSQFlush>
8010e260:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8010e264:	e0bffc03 	ldbu	r2,-16(fp)
8010e268:	10803fcc 	andi	r2,r2,255
8010e26c:	10000126 	beq	r2,zero,8010e274 <vDataControlTask+0x50>
		vFailFlushQueueData();
8010e270:	011db980 	call	8011db98 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskDataCtrl, 0, &error_code); /* Blocking operation */
8010e274:	d0a06a17 	ldw	r2,-32344(gp)
8010e278:	e0fffc04 	addi	r3,fp,-16
8010e27c:	180d883a 	mov	r6,r3
8010e280:	000b883a 	mov	r5,zero
8010e284:	1009883a 	mov	r4,r2
8010e288:	01390040 	call	80139004 <OSQPend>
8010e28c:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8010e290:	000f883a 	mov	r7,zero
8010e294:	01800144 	movi	r6,5
8010e298:	000b883a 	mov	r5,zero
8010e29c:	0009883a 	mov	r4,zero
8010e2a0:	013be940 	call	8013be94 <OSTimeDlyHMSM>
	}
8010e2a4:	003ff306 	br	8010e274 <__reset+0xfa0ee274>

8010e2a8 <vFeeTask>:

const char *cTemp[64];
static unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8010e2a8:	defff204 	addi	sp,sp,-56
8010e2ac:	de00012e 	bgeu	sp,et,8010e2b4 <vFeeTask+0xc>
8010e2b0:	003b68fa 	trap	3
8010e2b4:	dfc00d15 	stw	ra,52(sp)
8010e2b8:	df000c15 	stw	fp,48(sp)
8010e2bc:	df000c04 	addi	fp,sp,48
8010e2c0:	e13fff15 	stw	r4,-4(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8010e2c4:	e0bfff17 	ldw	r2,-4(fp)
8010e2c8:	d0a05415 	stw	r2,-32432(gp)
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8010e2cc:	d0a05417 	ldw	r2,-32432(gp)
8010e2d0:	10802c17 	ldw	r2,176(r2)
8010e2d4:	10c00368 	cmpgeui	r3,r2,13
8010e2d8:	1804211e 	bne	r3,zero,8010f360 <vFeeTask+0x10b8>
8010e2dc:	100690ba 	slli	r3,r2,2
8010e2e0:	00a00474 	movhi	r2,32785
8010e2e4:	10b8bd04 	addi	r2,r2,-7436
8010e2e8:	1885883a 	add	r2,r3,r2
8010e2ec:	10800017 	ldw	r2,0(r2)
8010e2f0:	1000683a 	jmp	r2
8010e2f4:	8010e328 	cmpgeui	zero,r16,17292
8010e2f8:	8010e97c 	xorhi	zero,r16,17317
8010e2fc:	8010e9dc 	xori	zero,r16,17319
8010e300:	8010eb1c 	xori	zero,r16,17324
8010e304:	8010ef9c 	xori	zero,r16,17342
8010e308:	8010e7d8 	cmpnei	zero,r16,17311
8010e30c:	8010e9ec 	andhi	zero,r16,17319
8010e310:	8010eee4 	muli	zero,r16,17339
8010e314:	8010f360 	cmpeqi	zero,r16,17357
8010e318:	8010f360 	cmpeqi	zero,r16,17357
8010e31c:	8010eb7c 	xorhi	zero,r16,17325
8010e320:	8010f244 	addi	zero,r16,17353
8010e324:	8010f300 	call	88010f30 <__reset+0x1ff0f30>
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8010e328:	d0a05417 	ldw	r2,-32432(gp)
8010e32c:	10800003 	ldbu	r2,0(r2)
8010e330:	10c03fcc 	andi	r3,r2,255
8010e334:	00a00574 	movhi	r2,32789
8010e338:	109f5404 	addi	r2,r2,32080
8010e33c:	18c7883a 	add	r3,r3,r3
8010e340:	18c7883a 	add	r3,r3,r3
8010e344:	10c5883a 	add	r2,r2,r3
8010e348:	10800017 	ldw	r2,0(r2)
8010e34c:	1009883a 	mov	r4,r2
8010e350:	0138f440 	call	80138f44 <OSQFlush>
8010e354:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8010e358:	e0bffd03 	ldbu	r2,-12(fp)
8010e35c:	10803fcc 	andi	r2,r2,255
8010e360:	10000126 	beq	r2,zero,8010e368 <vFeeTask+0xc0>
					vFailFlushNFEEQueue();
8010e364:	011dbe80 	call	8011dbe8 <vFailFlushNFEEQueue>
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}
				*/

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8010e368:	d0a05417 	ldw	r2,-32432(gp)
8010e36c:	10803304 	addi	r2,r2,204
8010e370:	1009883a 	mov	r4,r2
8010e374:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8010e378:	d0a05417 	ldw	r2,-32432(gp)
8010e37c:	d0e05417 	ldw	r3,-32432(gp)
8010e380:	1900308b 	ldhu	r4,194(r3)
8010e384:	d0e05417 	ldw	r3,-32432(gp)
8010e388:	18c02f0b 	ldhu	r3,188(r3)
8010e38c:	20c7883a 	add	r3,r4,r3
8010e390:	1809883a 	mov	r4,r3
8010e394:	d0e05417 	ldw	r3,-32432(gp)
8010e398:	18c02f8b 	ldhu	r3,190(r3)
8010e39c:	20c7883a 	add	r3,r4,r3
8010e3a0:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8010e3a4:	d0a05417 	ldw	r2,-32432(gp)
8010e3a8:	d0e05417 	ldw	r3,-32432(gp)
8010e3ac:	1900310b 	ldhu	r4,196(r3)
8010e3b0:	d0e05417 	ldw	r3,-32432(gp)
8010e3b4:	18c0300b 	ldhu	r3,192(r3)
8010e3b8:	20c7883a 	add	r3,r4,r3
8010e3bc:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8010e3c0:	d0a05417 	ldw	r2,-32432(gp)
8010e3c4:	d0e05417 	ldw	r3,-32432(gp)
8010e3c8:	18c0310b 	ldhu	r3,196(r3)
8010e3cc:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8010e3d0:	d0a05417 	ldw	r2,-32432(gp)
8010e3d4:	d0e05417 	ldw	r3,-32432(gp)
8010e3d8:	18c0300b 	ldhu	r3,192(r3)
8010e3dc:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8010e3e0:	d0a05417 	ldw	r2,-32432(gp)
8010e3e4:	00e00004 	movi	r3,-32768
8010e3e8:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8010e3ec:	d0a05417 	ldw	r2,-32432(gp)
8010e3f0:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8010e3f4:	d0a05417 	ldw	r2,-32432(gp)
8010e3f8:	10003685 	stb	zero,218(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucProtocolId = xDefaults.usiDataProtId; /* 0xF0 ou  0x02*/
8010e3fc:	d0e05417 	ldw	r3,-32432(gp)
8010e400:	00a005b4 	movhi	r2,32790
8010e404:	10ba3604 	addi	r2,r2,-5928
8010e408:	10800c0b 	ldhu	r2,48(r2)
8010e40c:	18803705 	stb	r2,220(r3)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucLogicalAddr = xDefaults.usiDpuLogicalAddr;
8010e410:	d0e05417 	ldw	r3,-32432(gp)
8010e414:	00a005b4 	movhi	r2,32790
8010e418:	10ba3604 	addi	r2,r2,-5928
8010e41c:	10800c8b 	ldhu	r2,50(r2)
8010e420:	18803745 	stb	r2,221(r3)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8010e424:	d0a05417 	ldw	r2,-32432(gp)
8010e428:	10803304 	addi	r2,r2,204
8010e42c:	1009883a 	mov	r4,r2
8010e430:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8010e434:	d0a05417 	ldw	r2,-32432(gp)
8010e438:	10804804 	addi	r2,r2,288
8010e43c:	1009883a 	mov	r4,r2
8010e440:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8010e444:	d0a05417 	ldw	r2,-32432(gp)
8010e448:	00ffc004 	movi	r3,-256
8010e44c:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8010e450:	d0a05417 	ldw	r2,-32432(gp)
8010e454:	00ffc044 	movi	r3,-255
8010e458:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8010e45c:	d0a05417 	ldw	r2,-32432(gp)
8010e460:	00ffc084 	movi	r3,-254
8010e464:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8010e468:	d0a05417 	ldw	r2,-32432(gp)
8010e46c:	00ffc0c4 	movi	r3,-253
8010e470:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8010e474:	d0a05417 	ldw	r2,-32432(gp)
8010e478:	00ffc104 	movi	r3,-252
8010e47c:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8010e480:	d0a05417 	ldw	r2,-32432(gp)
8010e484:	00ffc144 	movi	r3,-251
8010e488:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8010e48c:	d0a05417 	ldw	r2,-32432(gp)
8010e490:	00ffc184 	movi	r3,-250
8010e494:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8010e498:	d0a05417 	ldw	r2,-32432(gp)
8010e49c:	00ffc1c4 	movi	r3,-249
8010e4a0:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8010e4a4:	d0a05417 	ldw	r2,-32432(gp)
8010e4a8:	00ffc204 	movi	r3,-248
8010e4ac:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8010e4b0:	d0a05417 	ldw	r2,-32432(gp)
8010e4b4:	00ffc244 	movi	r3,-247
8010e4b8:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8010e4bc:	d0a05417 	ldw	r2,-32432(gp)
8010e4c0:	00ffc284 	movi	r3,-246
8010e4c4:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8010e4c8:	d0a05417 	ldw	r2,-32432(gp)
8010e4cc:	00ffc2c4 	movi	r3,-245
8010e4d0:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8010e4d4:	d0a05417 	ldw	r2,-32432(gp)
8010e4d8:	00ffc304 	movi	r3,-244
8010e4dc:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8010e4e0:	d0a05417 	ldw	r2,-32432(gp)
8010e4e4:	00ffc344 	movi	r3,-243
8010e4e8:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8010e4ec:	d0a05417 	ldw	r2,-32432(gp)
8010e4f0:	00ffc384 	movi	r3,-242
8010e4f4:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8010e4f8:	d0a05417 	ldw	r2,-32432(gp)
8010e4fc:	00ffc3c4 	movi	r3,-241
8010e500:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8010e504:	d0a05417 	ldw	r2,-32432(gp)
8010e508:	00ffc404 	movi	r3,-240
8010e50c:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8010e510:	d0a05417 	ldw	r2,-32432(gp)
8010e514:	00ffc444 	movi	r3,-239
8010e518:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8010e51c:	d0a05417 	ldw	r2,-32432(gp)
8010e520:	00ffc484 	movi	r3,-238
8010e524:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8010e528:	d0a05417 	ldw	r2,-32432(gp)
8010e52c:	00ffc4c4 	movi	r3,-237
8010e530:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8010e534:	d0a05417 	ldw	r2,-32432(gp)
8010e538:	00ffc504 	movi	r3,-236
8010e53c:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8010e540:	d0a05417 	ldw	r2,-32432(gp)
8010e544:	00ffc544 	movi	r3,-235
8010e548:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8010e54c:	d0a05417 	ldw	r2,-32432(gp)
8010e550:	00ffc584 	movi	r3,-234
8010e554:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8010e558:	d0a05417 	ldw	r2,-32432(gp)
8010e55c:	00ffc5c4 	movi	r3,-233
8010e560:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8010e564:	d0a05417 	ldw	r2,-32432(gp)
8010e568:	00ffc604 	movi	r3,-232
8010e56c:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8010e570:	d0a05417 	ldw	r2,-32432(gp)
8010e574:	00ffc644 	movi	r3,-231
8010e578:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8010e57c:	d0a05417 	ldw	r2,-32432(gp)
8010e580:	00ffc684 	movi	r3,-230
8010e584:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8010e588:	d0a05417 	ldw	r2,-32432(gp)
8010e58c:	00ffc6c4 	movi	r3,-229
8010e590:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8010e594:	d0a05417 	ldw	r2,-32432(gp)
8010e598:	00ffc704 	movi	r3,-228
8010e59c:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8010e5a0:	d0a05417 	ldw	r2,-32432(gp)
8010e5a4:	00ffc744 	movi	r3,-227
8010e5a8:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8010e5ac:	d0a05417 	ldw	r2,-32432(gp)
8010e5b0:	00ffc784 	movi	r3,-226
8010e5b4:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8010e5b8:	d0a05417 	ldw	r2,-32432(gp)
8010e5bc:	00ffc7c4 	movi	r3,-225
8010e5c0:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8010e5c4:	d0a05417 	ldw	r2,-32432(gp)
8010e5c8:	00ffc804 	movi	r3,-224
8010e5cc:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8010e5d0:	d0a05417 	ldw	r2,-32432(gp)
8010e5d4:	00ffc844 	movi	r3,-223
8010e5d8:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8010e5dc:	d0a05417 	ldw	r2,-32432(gp)
8010e5e0:	00ffc884 	movi	r3,-222
8010e5e4:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8010e5e8:	d0a05417 	ldw	r2,-32432(gp)
8010e5ec:	00ffc8c4 	movi	r3,-221
8010e5f0:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8010e5f4:	d0a05417 	ldw	r2,-32432(gp)
8010e5f8:	00ffc904 	movi	r3,-220
8010e5fc:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8010e600:	d0a05417 	ldw	r2,-32432(gp)
8010e604:	00ffc944 	movi	r3,-219
8010e608:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8010e60c:	d0a05417 	ldw	r2,-32432(gp)
8010e610:	00ffc984 	movi	r3,-218
8010e614:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8010e618:	d0a05417 	ldw	r2,-32432(gp)
8010e61c:	00ffc9c4 	movi	r3,-217
8010e620:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8010e624:	d0a05417 	ldw	r2,-32432(gp)
8010e628:	00ffca04 	movi	r3,-216
8010e62c:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8010e630:	d0a05417 	ldw	r2,-32432(gp)
8010e634:	00ffca44 	movi	r3,-215
8010e638:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8010e63c:	d0a05417 	ldw	r2,-32432(gp)
8010e640:	00ffca84 	movi	r3,-214
8010e644:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8010e648:	d0a05417 	ldw	r2,-32432(gp)
8010e64c:	00ffcac4 	movi	r3,-213
8010e650:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8010e654:	d0a05417 	ldw	r2,-32432(gp)
8010e658:	00ffcb04 	movi	r3,-212
8010e65c:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8010e660:	d0a05417 	ldw	r2,-32432(gp)
8010e664:	00ffcb44 	movi	r3,-211
8010e668:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8010e66c:	d0a05417 	ldw	r2,-32432(gp)
8010e670:	00ffcb84 	movi	r3,-210
8010e674:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8010e678:	d0a05417 	ldw	r2,-32432(gp)
8010e67c:	00ffcbc4 	movi	r3,-209
8010e680:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8010e684:	d0a05417 	ldw	r2,-32432(gp)
8010e688:	00ffcc04 	movi	r3,-208
8010e68c:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8010e690:	d0a05417 	ldw	r2,-32432(gp)
8010e694:	00ffcc44 	movi	r3,-207
8010e698:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8010e69c:	d0a05417 	ldw	r2,-32432(gp)
8010e6a0:	00ffcc84 	movi	r3,-206
8010e6a4:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8010e6a8:	d0a05417 	ldw	r2,-32432(gp)
8010e6ac:	00ffccc4 	movi	r3,-205
8010e6b0:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8010e6b4:	d0a05417 	ldw	r2,-32432(gp)
8010e6b8:	00ffcd04 	movi	r3,-204
8010e6bc:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8010e6c0:	d0a05417 	ldw	r2,-32432(gp)
8010e6c4:	00ffcd44 	movi	r3,-203
8010e6c8:	10c0888d 	sth	r3,546(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8010e6cc:	d0a05417 	ldw	r2,-32432(gp)
8010e6d0:	00ffcd84 	movi	r3,-202
8010e6d4:	10c0890d 	sth	r3,548(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8010e6d8:	d0a05417 	ldw	r2,-32432(gp)
8010e6dc:	00ffcdc4 	movi	r3,-201
8010e6e0:	10c0898d 	sth	r3,550(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8010e6e4:	d0a05417 	ldw	r2,-32432(gp)
8010e6e8:	00ffce04 	movi	r3,-200
8010e6ec:	10c08a0d 	sth	r3,552(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8010e6f0:	d0a05417 	ldw	r2,-32432(gp)
8010e6f4:	00ffce44 	movi	r3,-199
8010e6f8:	10c08a8d 	sth	r3,554(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8010e6fc:	d0a05417 	ldw	r2,-32432(gp)
8010e700:	00ffce84 	movi	r3,-198
8010e704:	10c08b0d 	sth	r3,556(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8010e708:	d0a05417 	ldw	r2,-32432(gp)
8010e70c:	00ffcec4 	movi	r3,-197
8010e710:	10c08b8d 	sth	r3,558(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8010e714:	d0a05417 	ldw	r2,-32432(gp)
8010e718:	00ffcf04 	movi	r3,-196
8010e71c:	10c08c0d 	sth	r3,560(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8010e720:	d0a05417 	ldw	r2,-32432(gp)
8010e724:	00ffcf44 	movi	r3,-195
8010e728:	10c08c8d 	sth	r3,562(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8010e72c:	d0a05417 	ldw	r2,-32432(gp)
8010e730:	00ffcf84 	movi	r3,-194
8010e734:	10c08d0d 	sth	r3,564(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8010e738:	d0a05417 	ldw	r2,-32432(gp)
8010e73c:	00ffcfc4 	movi	r3,-193
8010e740:	10c08d8d 	sth	r3,566(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8010e744:	d0a05417 	ldw	r2,-32432(gp)
8010e748:	10804804 	addi	r2,r2,288
8010e74c:	1009883a 	mov	r4,r2
8010e750:	0108c180 	call	80108c18 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8010e754:	0110f640 	call	80110f64 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8010e758:	d0a05417 	ldw	r2,-32432(gp)
8010e75c:	10804804 	addi	r2,r2,288
8010e760:	1009883a 	mov	r4,r2
8010e764:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8010e768:	d0a05417 	ldw	r2,-32432(gp)
8010e76c:	10806e04 	addi	r2,r2,440
8010e770:	e0bffb15 	stw	r2,-20(fp)
					fprintf(fp,"\n================= H  K ==================\n\n");
				}
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8010e774:	d0a05417 	ldw	r2,-32432(gp)
8010e778:	10804804 	addi	r2,r2,288
8010e77c:	1009883a 	mov	r4,r2
8010e780:	01082300 	call	80108230 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8010e784:	d0e05417 	ldw	r3,-32432(gp)
8010e788:	00a005b4 	movhi	r2,32790
8010e78c:	10ba3604 	addi	r2,r2,-5928
8010e790:	1080080b 	ldhu	r2,32(r2)
8010e794:	18804905 	stb	r2,292(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8010e798:	d0e05417 	ldw	r3,-32432(gp)
8010e79c:	00a005b4 	movhi	r2,32790
8010e7a0:	10ba3604 	addi	r2,r2,-5928
8010e7a4:	1080088b 	ldhu	r2,34(r2)
8010e7a8:	18804945 	stb	r2,293(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8010e7ac:	d0a05417 	ldw	r2,-32432(gp)
8010e7b0:	10804804 	addi	r2,r2,288
8010e7b4:	1009883a 	mov	r4,r2
8010e7b8:	01081540 	call	80108154 <bRmapSetCodecConfig>
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", pxNFee->ucId ,xDefaults.ucRmapKey );
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", pxNFee->ucId, xDefaults.ucLogicalAddr);
				}
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8010e7bc:	d0a05417 	ldw	r2,-32432(gp)
8010e7c0:	00c00144 	movi	r3,5
8010e7c4:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8010e7c8:	d0a05417 	ldw	r2,-32432(gp)
8010e7cc:	10802e17 	ldw	r2,184(r2)
8010e7d0:	d0a05305 	stb	r2,-32436(gp)

				break;
8010e7d4:	0002ef06 	br	8010f394 <vFeeTask+0x10ec>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8010e7d8:	d0a05417 	ldw	r2,-32432(gp)
8010e7dc:	10804804 	addi	r2,r2,288
8010e7e0:	1009883a 	mov	r4,r2
8010e7e4:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8010e7e8:	d0a05417 	ldw	r2,-32432(gp)
8010e7ec:	00c00184 	movi	r3,6
8010e7f0:	10c06b15 	stw	r3,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8010e7f4:	d0a05417 	ldw	r2,-32432(gp)
8010e7f8:	10804804 	addi	r2,r2,288
8010e7fc:	1009883a 	mov	r4,r2
8010e800:	010857c0 	call	8010857c <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8010e804:	d0a05417 	ldw	r2,-32432(gp)
8010e808:	10808e04 	addi	r2,r2,568
8010e80c:	1009883a 	mov	r4,r2
8010e810:	01103080 	call	80110308 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8010e814:	d0a05417 	ldw	r2,-32432(gp)
8010e818:	10002615 	stw	zero,152(r2)
				bSetPainelLeds( LEDS_OFF , uliReturnMaskG( pxNFee->ucSPWId ) );
8010e81c:	d0a05417 	ldw	r2,-32432(gp)
8010e820:	10800043 	ldbu	r2,1(r2)
8010e824:	10803fcc 	andi	r2,r2,255
8010e828:	1009883a 	mov	r4,r2
8010e82c:	0110e840 	call	80110e84 <uliReturnMaskG>
8010e830:	100b883a 	mov	r5,r2
8010e834:	0009883a 	mov	r4,zero
8010e838:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , uliReturnMaskR( pxNFee->ucSPWId ) );
8010e83c:	d0a05417 	ldw	r2,-32432(gp)
8010e840:	10800043 	ldbu	r2,1(r2)
8010e844:	10803fcc 	andi	r2,r2,255
8010e848:	1009883a 	mov	r4,r2
8010e84c:	0110da40 	call	80110da4 <uliReturnMaskR>
8010e850:	100b883a 	mov	r5,r2
8010e854:	01000044 	movi	r4,1
8010e858:	010bb640 	call	8010bb64 <bSetPainelLeds>

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
8010e85c:	d0a05417 	ldw	r2,-32432(gp)
8010e860:	10c04804 	addi	r3,r2,288
8010e864:	d0a05417 	ldw	r2,-32432(gp)
8010e868:	10800043 	ldbu	r2,1(r2)
8010e86c:	10803fcc 	andi	r2,r2,255
8010e870:	100b883a 	mov	r5,r2
8010e874:	1809883a 	mov	r4,r3
8010e878:	011025c0 	call	8011025c <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8010e87c:	d0a05417 	ldw	r2,-32432(gp)
8010e880:	10803b04 	addi	r2,r2,236
8010e884:	1009883a 	mov	r4,r2
8010e888:	01104600 	call	80110460 <bDisAndClrDbBuffer>
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
				}
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8010e88c:	d0a05417 	ldw	r2,-32432(gp)
8010e890:	10802217 	ldw	r2,136(r2)
8010e894:	10800058 	cmpnei	r2,r2,1
8010e898:	10000a1e 	bne	r2,zero,8010e8c4 <vFeeTask+0x61c>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8010e89c:	e0fff503 	ldbu	r3,-44(fp)
8010e8a0:	00a005b4 	movhi	r2,32790
8010e8a4:	10ad6e04 	addi	r2,r2,-19016
8010e8a8:	180690fa 	slli	r3,r3,3
8010e8ac:	10c5883a 	add	r2,r2,r3
8010e8b0:	10800017 	ldw	r2,0(r2)
8010e8b4:	1009883a 	mov	r4,r2
8010e8b8:	01384940 	call	80138494 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8010e8bc:	d0a05417 	ldw	r2,-32432(gp)
8010e8c0:	10002215 	stw	zero,136(r2)
					vFailFlushNFEEQueue();
				}
				*/

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8010e8c4:	d0a05417 	ldw	r2,-32432(gp)
8010e8c8:	10800003 	ldbu	r2,0(r2)
8010e8cc:	10803fcc 	andi	r2,r2,255
8010e8d0:	100d883a 	mov	r6,r2
8010e8d4:	000b883a 	mov	r5,zero
8010e8d8:	01002044 	movi	r4,129
8010e8dc:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8010e8e0:	d0a05417 	ldw	r2,-32432(gp)
8010e8e4:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8010e8e8:	d0a05417 	ldw	r2,-32432(gp)
8010e8ec:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8010e8f0:	d0a05417 	ldw	r2,-32432(gp)
8010e8f4:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8010e8f8:	d0a05417 	ldw	r2,-32432(gp)
8010e8fc:	00c00044 	movi	r3,1
8010e900:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8010e904:	d0a05417 	ldw	r2,-32432(gp)
8010e908:	1009883a 	mov	r4,r2
8010e90c:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8010e910:	d0a05417 	ldw	r2,-32432(gp)
8010e914:	10800003 	ldbu	r2,0(r2)
8010e918:	10c03fcc 	andi	r3,r2,255
8010e91c:	00a00574 	movhi	r2,32789
8010e920:	109f5404 	addi	r2,r2,32080
8010e924:	18c7883a 	add	r3,r3,r3
8010e928:	18c7883a 	add	r3,r3,r3
8010e92c:	10c5883a 	add	r2,r2,r3
8010e930:	10800017 	ldw	r2,0(r2)
8010e934:	1009883a 	mov	r4,r2
8010e938:	0138f440 	call	80138f44 <OSQFlush>
8010e93c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8010e940:	e0bffd03 	ldbu	r2,-12(fp)
8010e944:	10803fcc 	andi	r2,r2,255
8010e948:	10000126 	beq	r2,zero,8010e950 <vFeeTask+0x6a8>
					vFailFlushNFEEQueue();
8010e94c:	011dbe80 	call	8011dbe8 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8010e950:	d0a05417 	ldw	r2,-32432(gp)
8010e954:	00c00044 	movi	r3,1
8010e958:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8010e95c:	d0a05417 	ldw	r2,-32432(gp)
8010e960:	00c00044 	movi	r3,1
8010e964:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8010e968:	d0a05417 	ldw	r2,-32432(gp)
8010e96c:	10802e17 	ldw	r2,184(r2)
8010e970:	d0a05305 	stb	r2,-32436(gp)
				bFinal = FALSE;
8010e974:	e03ffa15 	stw	zero,-24(fp)
				break;
8010e978:	00028606 	br	8010f394 <vFeeTask+0x10ec>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8010e97c:	d0a05417 	ldw	r2,-32432(gp)
8010e980:	10800003 	ldbu	r2,0(r2)
8010e984:	10c03fcc 	andi	r3,r2,255
8010e988:	00a00574 	movhi	r2,32789
8010e98c:	109f5404 	addi	r2,r2,32080
8010e990:	18c7883a 	add	r3,r3,r3
8010e994:	18c7883a 	add	r3,r3,r3
8010e998:	10c5883a 	add	r2,r2,r3
8010e99c:	10800017 	ldw	r2,0(r2)
8010e9a0:	e0fffd04 	addi	r3,fp,-12
8010e9a4:	180d883a 	mov	r6,r3
8010e9a8:	000b883a 	mov	r5,zero
8010e9ac:	1009883a 	mov	r4,r2
8010e9b0:	01390040 	call	80139004 <OSQPend>
8010e9b4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8010e9b8:	e0bffd03 	ldbu	r2,-12(fp)
8010e9bc:	10803fcc 	andi	r2,r2,255
8010e9c0:	10026b1e 	bne	r2,zero,8010f370 <vFeeTask+0x10c8>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8010e9c4:	d0a05417 	ldw	r2,-32432(gp)
8010e9c8:	e0fffe17 	ldw	r3,-8(fp)
8010e9cc:	180b883a 	mov	r5,r3
8010e9d0:	1009883a 	mov	r4,r2
8010e9d4:	010f56c0 	call	8010f56c <vQCmdFEEinConfig>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8010e9d8:	00026506 	br	8010f370 <vFeeTask+0x10c8>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8010e9dc:	d0a05417 	ldw	r2,-32432(gp)
8010e9e0:	00c00184 	movi	r3,6
8010e9e4:	10c02c15 	stw	r3,176(r2)
				break;
8010e9e8:	00026a06 	br	8010f394 <vFeeTask+0x10ec>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8010e9ec:	d0a05417 	ldw	r2,-32432(gp)
8010e9f0:	10804804 	addi	r2,r2,288
8010e9f4:	1009883a 	mov	r4,r2
8010e9f8:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8010e9fc:	d0a05417 	ldw	r2,-32432(gp)
8010ea00:	10006b15 	stw	zero,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8010ea04:	d0a05417 	ldw	r2,-32432(gp)
8010ea08:	10804804 	addi	r2,r2,288
8010ea0c:	1009883a 	mov	r4,r2
8010ea10:	010857c0 	call	8010857c <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8010ea14:	d0a05417 	ldw	r2,-32432(gp)
8010ea18:	10803b04 	addi	r2,r2,236
8010ea1c:	1009883a 	mov	r4,r2
8010ea20:	01104600 	call	80110460 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8010ea24:	d0a05417 	ldw	r2,-32432(gp)
8010ea28:	10c04804 	addi	r3,r2,288
8010ea2c:	d0a05417 	ldw	r2,-32432(gp)
8010ea30:	10800003 	ldbu	r2,0(r2)
8010ea34:	10803fcc 	andi	r2,r2,255
8010ea38:	100b883a 	mov	r5,r2
8010ea3c:	1809883a 	mov	r4,r3
8010ea40:	01102b00 	call	801102b0 <bEnableRmapIRQ>

				/* Enable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8010ea44:	d0a05417 	ldw	r2,-32432(gp)
8010ea48:	10808e04 	addi	r2,r2,568
8010ea4c:	1009883a 	mov	r4,r2
8010ea50:	01103680 	call	80110368 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8010ea54:	d0a05417 	ldw	r2,-32432(gp)
8010ea58:	00c00044 	movi	r3,1
8010ea5c:	10c02615 	stw	r3,152(r2)
				bSetPainelLeds( LEDS_OFF , uliReturnMaskR( pxNFee->ucSPWId ) );
8010ea60:	d0a05417 	ldw	r2,-32432(gp)
8010ea64:	10800043 	ldbu	r2,1(r2)
8010ea68:	10803fcc 	andi	r2,r2,255
8010ea6c:	1009883a 	mov	r4,r2
8010ea70:	0110da40 	call	80110da4 <uliReturnMaskR>
8010ea74:	100b883a 	mov	r5,r2
8010ea78:	0009883a 	mov	r4,zero
8010ea7c:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , uliReturnMaskG( pxNFee->ucSPWId ) );
8010ea80:	d0a05417 	ldw	r2,-32432(gp)
8010ea84:	10800043 	ldbu	r2,1(r2)
8010ea88:	10803fcc 	andi	r2,r2,255
8010ea8c:	1009883a 	mov	r4,r2
8010ea90:	0110e840 	call	80110e84 <uliReturnMaskG>
8010ea94:	100b883a 	mov	r5,r2
8010ea98:	01000044 	movi	r4,1
8010ea9c:	010bb640 	call	8010bb64 <bSetPainelLeds>


				pxNFee->xControl.bSimulating = TRUE;
8010eaa0:	d0a05417 	ldw	r2,-32432(gp)
8010eaa4:	00c00044 	movi	r3,1
8010eaa8:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8010eaac:	d0a05417 	ldw	r2,-32432(gp)
8010eab0:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8010eab4:	d0a05417 	ldw	r2,-32432(gp)
8010eab8:	00c00044 	movi	r3,1
8010eabc:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8010eac0:	d0a05417 	ldw	r2,-32432(gp)
8010eac4:	10800003 	ldbu	r2,0(r2)
8010eac8:	10803fcc 	andi	r2,r2,255
8010eacc:	100d883a 	mov	r6,r2
8010ead0:	000b883a 	mov	r5,zero
8010ead4:	01002044 	movi	r4,129
8010ead8:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8010eadc:	d0a05417 	ldw	r2,-32432(gp)
8010eae0:	10002815 	stw	zero,160(r2)
					fprintf(fp,"NFEE-%hu Task: Standby\n", pxNFee->ucId);
				}
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8010eae4:	d0a05417 	ldw	r2,-32432(gp)
8010eae8:	1009883a 	mov	r4,r2
8010eaec:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				incrementador = 0;
8010eaf0:	d0205515 	stw	zero,-32428(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8010eaf4:	d0a05417 	ldw	r2,-32432(gp)
8010eaf8:	00c00044 	movi	r3,1
8010eafc:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8010eb00:	d0a05417 	ldw	r2,-32432(gp)
8010eb04:	00c000c4 	movi	r3,3
8010eb08:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8010eb0c:	d0a05417 	ldw	r2,-32432(gp)
8010eb10:	10802e17 	ldw	r2,184(r2)
8010eb14:	d0a05305 	stb	r2,-32436(gp)
				break;
8010eb18:	00021e06 	br	8010f394 <vFeeTask+0x10ec>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8010eb1c:	d0a05417 	ldw	r2,-32432(gp)
8010eb20:	10800003 	ldbu	r2,0(r2)
8010eb24:	10c03fcc 	andi	r3,r2,255
8010eb28:	00a00574 	movhi	r2,32789
8010eb2c:	109f5404 	addi	r2,r2,32080
8010eb30:	18c7883a 	add	r3,r3,r3
8010eb34:	18c7883a 	add	r3,r3,r3
8010eb38:	10c5883a 	add	r2,r2,r3
8010eb3c:	10800017 	ldw	r2,0(r2)
8010eb40:	e0fffd04 	addi	r3,fp,-12
8010eb44:	180d883a 	mov	r6,r3
8010eb48:	000b883a 	mov	r5,zero
8010eb4c:	1009883a 	mov	r4,r2
8010eb50:	01390040 	call	80139004 <OSQPend>
8010eb54:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8010eb58:	e0bffd03 	ldbu	r2,-12(fp)
8010eb5c:	10803fcc 	andi	r2,r2,255
8010eb60:	1002051e 	bne	r2,zero,8010f378 <vFeeTask+0x10d0>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8010eb64:	d0a05417 	ldw	r2,-32432(gp)
8010eb68:	e0fffe17 	ldw	r3,-8(fp)
8010eb6c:	180b883a 	mov	r5,r3
8010eb70:	1009883a 	mov	r4,r2
8010eb74:	010f6a80 	call	8010f6a8 <vQCmdFEEinStandBy>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8010eb78:	0001ff06 	br	8010f378 <vFeeTask+0x10d0>
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}
				*/

				pxNFee->xControl.bUsingDMA = TRUE;
8010eb7c:	d0a05417 	ldw	r2,-32432(gp)
8010eb80:	00c00044 	movi	r3,1
8010eb84:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8010eb88:	d0a05417 	ldw	r2,-32432(gp)
8010eb8c:	00c00044 	movi	r3,1
8010eb90:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8010eb94:	d0a05417 	ldw	r2,-32432(gp)
8010eb98:	1009883a 	mov	r4,r2
8010eb9c:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				/* Wait until both buffers are empty  */
				vWaitUntilBufferEmpty( pxNFee->ucSPWId );
8010eba0:	d0a05417 	ldw	r2,-32432(gp)
8010eba4:	10800043 	ldbu	r2,1(r2)
8010eba8:	10803fcc 	andi	r2,r2,255
8010ebac:	1009883a 	mov	r4,r2
8010ebb0:	0110c9c0 	call	80110c9c <vWaitUntilBufferEmpty>
					while ( (bFeebGetCh2LeftFeeBusy()== TRUE) || (bFeebGetCh2RightFeeBusy()== TRUE)  ) {}
				}
				*/


				OSTimeDlyHMSM(0,0,0,xDefaults.usiGuardNFEEDelay);
8010ebb4:	00a005b4 	movhi	r2,32790
8010ebb8:	10ba3604 	addi	r2,r2,-5928
8010ebbc:	10800b8b 	ldhu	r2,46(r2)
8010ebc0:	10bfffcc 	andi	r2,r2,65535
8010ebc4:	100f883a 	mov	r7,r2
8010ebc8:	000d883a 	mov	r6,zero
8010ebcc:	000b883a 	mov	r5,zero
8010ebd0:	0009883a 	mov	r4,zero
8010ebd4:	013be940 	call	8013be94 <OSTimeDlyHMSM>

				vSetDoubleBufferLeftSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
8010ebd8:	d0a05417 	ldw	r2,-32432(gp)
8010ebdc:	10800043 	ldbu	r2,1(r2)
8010ebe0:	10803fcc 	andi	r2,r2,255
8010ebe4:	100b883a 	mov	r5,r2
8010ebe8:	01000404 	movi	r4,16
8010ebec:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
				vSetDoubleBufferRightSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
8010ebf0:	d0a05417 	ldw	r2,-32432(gp)
8010ebf4:	10800043 	ldbu	r2,1(r2)
8010ebf8:	10803fcc 	andi	r2,r2,255
8010ebfc:	100b883a 	mov	r5,r2
8010ec00:	01000404 	movi	r4,16
8010ec04:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}*/

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8010ec08:	d0a05417 	ldw	r2,-32432(gp)
8010ec0c:	10803b04 	addi	r2,r2,236
8010ec10:	1009883a 	mov	r4,r2
8010ec14:	01103c80 	call	801103c8 <bEnableDbBuffer>

				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8010ec18:	d0a05417 	ldw	r2,-32432(gp)
8010ec1c:	10808e04 	addi	r2,r2,568
8010ec20:	1009883a 	mov	r4,r2
8010ec24:	010ada00 	call	8010ada0 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8010ec28:	d0a05417 	ldw	r2,-32432(gp)
8010ec2c:	10809a43 	ldbu	r2,617(r2)
8010ec30:	10803fcc 	andi	r2,r2,255
8010ec34:	d0a05615 	stw	r2,-32424(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8010ec38:	d0a05617 	ldw	r2,-32424(gp)
8010ec3c:	10800044 	addi	r2,r2,1
8010ec40:	108000cc 	andi	r2,r2,3
8010ec44:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8010ec48:	e0bffc17 	ldw	r2,-16(fp)
8010ec4c:	10000e1e 	bne	r2,zero,8010ec88 <vFeeTask+0x9e0>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8010ec50:	d0a05417 	ldw	r2,-32432(gp)
8010ec54:	10802917 	ldw	r2,164(r2)
8010ec58:	10800003 	ldbu	r2,0(r2)
8010ec5c:	10803fcc 	andi	r2,r2,255
8010ec60:	10c00044 	addi	r3,r2,1
8010ec64:	00a00034 	movhi	r2,32768
8010ec68:	10800044 	addi	r2,r2,1
8010ec6c:	1884703a 	and	r2,r3,r2
8010ec70:	1000040e 	bge	r2,zero,8010ec84 <vFeeTask+0x9dc>
8010ec74:	10bfffc4 	addi	r2,r2,-1
8010ec78:	00ffff84 	movi	r3,-2
8010ec7c:	10c4b03a 	or	r2,r2,r3
8010ec80:	10800044 	addi	r2,r2,1
8010ec84:	e0bff505 	stb	r2,-44(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8010ec88:	d0e05417 	ldw	r3,-32432(gp)
8010ec8c:	e0bffc17 	ldw	r2,-16(fp)
8010ec90:	1885883a 	add	r2,r3,r2
8010ec94:	10802a44 	addi	r2,r2,169
8010ec98:	10800003 	ldbu	r2,0(r2)
8010ec9c:	e0bff705 	stb	r2,-36(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8010eca0:	d0a05417 	ldw	r2,-32432(gp)
8010eca4:	10802e17 	ldw	r2,184(r2)
8010eca8:	1000071e 	bne	r2,zero,8010ecc8 <vFeeTask+0xa20>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8010ecac:	d0e05417 	ldw	r3,-32432(gp)
8010ecb0:	e0bff703 	ldbu	r2,-36(fp)
8010ecb4:	10800624 	muli	r2,r2,24
8010ecb8:	10800904 	addi	r2,r2,36
8010ecbc:	1885883a 	add	r2,r3,r2
8010ecc0:	e0bff615 	stw	r2,-40(fp)
8010ecc4:	00000606 	br	8010ece0 <vFeeTask+0xa38>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8010ecc8:	d0e05417 	ldw	r3,-32432(gp)
8010eccc:	e0bff703 	ldbu	r2,-36(fp)
8010ecd0:	10800624 	muli	r2,r2,24
8010ecd4:	10800c04 	addi	r2,r2,48
8010ecd8:	1885883a 	add	r2,r3,r2
8010ecdc:	e0bff615 	stw	r2,-40(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8010ece0:	d0a05417 	ldw	r2,-32432(gp)
8010ece4:	10802e17 	ldw	r2,184(r2)
8010ece8:	d0a05305 	stb	r2,-32436(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8010ecec:	d0a05417 	ldw	r2,-32432(gp)
8010ecf0:	10803304 	addi	r2,r2,204
8010ecf4:	1009883a 	mov	r4,r2
8010ecf8:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8010ecfc:	d0a05417 	ldw	r2,-32432(gp)
8010ed00:	e0fff703 	ldbu	r3,-36(fp)
8010ed04:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern;
8010ed08:	d0a05417 	ldw	r2,-32432(gp)
8010ed0c:	00c00244 	movi	r3,9
8010ed10:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8010ed14:	d0a05417 	ldw	r2,-32432(gp)
8010ed18:	10803304 	addi	r2,r2,204
8010ed1c:	1009883a 	mov	r4,r2
8010ed20:	0102c480 	call	80102c48 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8010ed24:	d0a05417 	ldw	r2,-32432(gp)
8010ed28:	10803304 	addi	r2,r2,204
8010ed2c:	1009883a 	mov	r4,r2
8010ed30:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
					fprintf(fp,"=========DATA PACKET=============\n");
				}
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8010ed34:	d0a05417 	ldw	r2,-32432(gp)
8010ed38:	10800003 	ldbu	r2,0(r2)
8010ed3c:	10803fcc 	andi	r2,r2,255
8010ed40:	100d883a 	mov	r6,r2
8010ed44:	000b883a 	mov	r5,zero
8010ed48:	01002004 	movi	r4,128
8010ed4c:	01104cc0 	call	801104cc <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8010ed50:	e03ff915 	stw	zero,-28(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8010ed54:	d0a05417 	ldw	r2,-32432(gp)
8010ed58:	10800003 	ldbu	r2,0(r2)
8010ed5c:	10c03fcc 	andi	r3,r2,255
8010ed60:	00a00574 	movhi	r2,32789
8010ed64:	109f5404 	addi	r2,r2,32080
8010ed68:	18c7883a 	add	r3,r3,r3
8010ed6c:	18c7883a 	add	r3,r3,r3
8010ed70:	10c5883a 	add	r2,r2,r3
8010ed74:	10800017 	ldw	r2,0(r2)
8010ed78:	e0fffd04 	addi	r3,fp,-12
8010ed7c:	180d883a 	mov	r6,r3
8010ed80:	000b883a 	mov	r5,zero
8010ed84:	1009883a 	mov	r4,r2
8010ed88:	01390040 	call	80139004 <OSQPend>
8010ed8c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8010ed90:	e0bffd03 	ldbu	r2,-12(fp)
8010ed94:	10803fcc 	andi	r2,r2,255
8010ed98:	1001791e 	bne	r2,zero,8010f380 <vFeeTask+0x10d8>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8010ed9c:	e0bffe83 	ldbu	r2,-6(fp)
8010eda0:	10803fcc 	andi	r2,r2,255
8010eda4:	108023d8 	cmpnei	r2,r2,143
8010eda8:	1000481e 	bne	r2,zero,8010eecc <vFeeTask+0xc24>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8010edac:	e0fff503 	ldbu	r3,-44(fp)
8010edb0:	00a005b4 	movhi	r2,32790
8010edb4:	10ad6e04 	addi	r2,r2,-19016
8010edb8:	180690fa 	slli	r3,r3,3
8010edbc:	10c5883a 	add	r2,r2,r3
8010edc0:	10800017 	ldw	r2,0(r2)
8010edc4:	e0fffd04 	addi	r3,fp,-12
8010edc8:	180d883a 	mov	r6,r3
8010edcc:	000b883a 	mov	r5,zero
8010edd0:	1009883a 	mov	r4,r2
8010edd4:	0137ef00 	call	80137ef0 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8010edd8:	e0bffd03 	ldbu	r2,-12(fp)
8010eddc:	10803fcc 	andi	r2,r2,255
8010ede0:	10001b1e 	bne	r2,zero,8010ee50 <vFeeTask+0xba8>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8010ede4:	d0a05417 	ldw	r2,-32432(gp)
8010ede8:	00c00044 	movi	r3,1
8010edec:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee, ucIterationSide );
8010edf0:	e0fff503 	ldbu	r3,-44(fp)
8010edf4:	d0a05417 	ldw	r2,-32432(gp)
8010edf8:	10800003 	ldbu	r2,0(r2)
8010edfc:	11003fcc 	andi	r4,r2,255
8010ee00:	d1605417 	ldw	r5,-32432(gp)
8010ee04:	d0a05303 	ldbu	r2,-32436(gp)
8010ee08:	10803fcc 	andi	r2,r2,255
8010ee0c:	d8800015 	stw	r2,0(sp)
8010ee10:	280f883a 	mov	r7,r5
8010ee14:	200d883a 	mov	r6,r4
8010ee18:	180b883a 	mov	r5,r3
8010ee1c:	e13ff617 	ldw	r4,-40(fp)
8010ee20:	01106b80 	call	801106b8 <bPrepareDoubleBuffer>
8010ee24:	e0bff915 	stw	r2,-28(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8010ee28:	e0fff503 	ldbu	r3,-44(fp)
8010ee2c:	00a005b4 	movhi	r2,32790
8010ee30:	10ad6e04 	addi	r2,r2,-19016
8010ee34:	180690fa 	slli	r3,r3,3
8010ee38:	10c5883a 	add	r2,r2,r3
8010ee3c:	10800017 	ldw	r2,0(r2)
8010ee40:	1009883a 	mov	r4,r2
8010ee44:	01384940 	call	80138494 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8010ee48:	d0a05417 	ldw	r2,-32432(gp)
8010ee4c:	10002215 	stw	zero,136(r2)
		
						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8010ee50:	d0a05417 	ldw	r2,-32432(gp)
8010ee54:	10800003 	ldbu	r2,0(r2)
8010ee58:	10803fcc 	andi	r2,r2,255
8010ee5c:	100d883a 	mov	r6,r2
8010ee60:	000b883a 	mov	r5,zero
8010ee64:	01002044 	movi	r4,129
8010ee68:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8010ee6c:	e0bff917 	ldw	r2,-28(fp)
8010ee70:	10800058 	cmpnei	r2,r2,1
8010ee74:	1001421e 	bne	r2,zero,8010f380 <vFeeTask+0x10d8>
							if (pxNFee->xControl.bWatingSync==TRUE) {
8010ee78:	d0a05417 	ldw	r2,-32432(gp)
8010ee7c:	10802817 	ldw	r2,160(r2)
8010ee80:	10800058 	cmpnei	r2,r2,1
8010ee84:	1000071e 	bne	r2,zero,8010eea4 <vFeeTask+0xbfc>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8010ee88:	d0a05417 	ldw	r2,-32432(gp)
8010ee8c:	00c001c4 	movi	r3,7
8010ee90:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8010ee94:	d0a05417 	ldw	r2,-32432(gp)
8010ee98:	00c00304 	movi	r3,12
8010ee9c:	10c02c15 	stw	r3,176(r2)
8010eea0:	00000606 	br	8010eebc <vFeeTask+0xc14>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8010eea4:	d0a05417 	ldw	r2,-32432(gp)
8010eea8:	00c001c4 	movi	r3,7
8010eeac:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8010eeb0:	d0a05417 	ldw	r2,-32432(gp)
8010eeb4:	00c001c4 	movi	r3,7
8010eeb8:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
8010eebc:	d0a05517 	ldw	r2,-32428(gp)
8010eec0:	10800044 	addi	r2,r2,1
8010eec4:	d0a05515 	stw	r2,-32428(gp)
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8010eec8:	00012d06 	br	8010f380 <vFeeTask+0x10d8>
								fprintf(fp,"\nNFEE-%hu Task: Could not prepare the double buffer\n", pxNFee->ucId);
							}
							#endif
						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8010eecc:	d0a05417 	ldw	r2,-32432(gp)
8010eed0:	e0fffe17 	ldw	r3,-8(fp)
8010eed4:	180b883a 	mov	r5,r3
8010eed8:	1009883a 	mov	r4,r2
8010eedc:	010f8380 	call	8010f838 <vQCmdFEEinFullPattern>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8010eee0:	00012706 	br	8010f380 <vFeeTask+0x10d8>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8010eee4:	e03ffa15 	stw	zero,-24(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8010eee8:	d0a05417 	ldw	r2,-32432(gp)
8010eeec:	10804804 	addi	r2,r2,288
8010eef0:	1009883a 	mov	r4,r2
8010eef4:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8010eef8:	d0a05417 	ldw	r2,-32432(gp)
8010eefc:	00c00084 	movi	r3,2
8010ef00:	10c06b15 	stw	r3,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8010ef04:	d0a05417 	ldw	r2,-32432(gp)
8010ef08:	10804804 	addi	r2,r2,288
8010ef0c:	1009883a 	mov	r4,r2
8010ef10:	010857c0 	call	8010857c <bRmapSetMemConfigArea>
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
				}
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
8010ef14:	d0a05417 	ldw	r2,-32432(gp)
8010ef18:	10802e17 	ldw	r2,184(r2)
8010ef1c:	d0a05305 	stb	r2,-32436(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8010ef20:	d0a05417 	ldw	r2,-32432(gp)
8010ef24:	00c00044 	movi	r3,1
8010ef28:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8010ef2c:	d0a05417 	ldw	r2,-32432(gp)
8010ef30:	00c00104 	movi	r3,4
8010ef34:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8010ef38:	d0a05417 	ldw	r2,-32432(gp)
8010ef3c:	00c00104 	movi	r3,4
8010ef40:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8010ef44:	d0a05417 	ldw	r2,-32432(gp)
8010ef48:	00c00044 	movi	r3,1
8010ef4c:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8010ef50:	d0a05417 	ldw	r2,-32432(gp)
8010ef54:	00c00044 	movi	r3,1
8010ef58:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8010ef5c:	d0a05417 	ldw	r2,-32432(gp)
8010ef60:	00c00044 	movi	r3,1
8010ef64:	10c02115 	stw	r3,132(r2)
				//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				vSetDoubleBufferLeftSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
8010ef68:	d0a05417 	ldw	r2,-32432(gp)
8010ef6c:	10800043 	ldbu	r2,1(r2)
8010ef70:	10803fcc 	andi	r2,r2,255
8010ef74:	100b883a 	mov	r5,r2
8010ef78:	01000404 	movi	r4,16
8010ef7c:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
				vSetDoubleBufferRightSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
8010ef80:	d0a05417 	ldw	r2,-32432(gp)
8010ef84:	10800043 	ldbu	r2,1(r2)
8010ef88:	10803fcc 	andi	r2,r2,255
8010ef8c:	100b883a 	mov	r5,r2
8010ef90:	01000404 	movi	r4,16
8010ef94:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}*/

				break;
8010ef98:	0000fe06 	br	8010f394 <vFeeTask+0x10ec>

			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8010ef9c:	e03ffa15 	stw	zero,-24(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8010efa0:	d0a05417 	ldw	r2,-32432(gp)
8010efa4:	10800003 	ldbu	r2,0(r2)
8010efa8:	10c03fcc 	andi	r3,r2,255
8010efac:	00a00574 	movhi	r2,32789
8010efb0:	109f5404 	addi	r2,r2,32080
8010efb4:	18c7883a 	add	r3,r3,r3
8010efb8:	18c7883a 	add	r3,r3,r3
8010efbc:	10c5883a 	add	r2,r2,r3
8010efc0:	10800017 	ldw	r2,0(r2)
8010efc4:	e0fffd04 	addi	r3,fp,-12
8010efc8:	180d883a 	mov	r6,r3
8010efcc:	000b883a 	mov	r5,zero
8010efd0:	1009883a 	mov	r4,r2
8010efd4:	01390040 	call	80139004 <OSQPend>
8010efd8:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8010efdc:	e0bffd03 	ldbu	r2,-12(fp)
8010efe0:	10803fcc 	andi	r2,r2,255
8010efe4:	1000e81e 	bne	r2,zero,8010f388 <vFeeTask+0x10e0>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8010efe8:	e0bffe83 	ldbu	r2,-6(fp)
8010efec:	10803fcc 	andi	r2,r2,255
8010eff0:	108023d8 	cmpnei	r2,r2,143
8010eff4:	1000861e 	bne	r2,zero,8010f210 <vFeeTask+0xf68>

						/* Try to get the Mutex */
						OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8010eff8:	e0fff503 	ldbu	r3,-44(fp)
8010effc:	00a005b4 	movhi	r2,32790
8010f000:	10ad6e04 	addi	r2,r2,-19016
8010f004:	180690fa 	slli	r3,r3,3
8010f008:	10c5883a 	add	r2,r2,r3
8010f00c:	10800017 	ldw	r2,0(r2)
8010f010:	e0fffd04 	addi	r3,fp,-12
8010f014:	180d883a 	mov	r6,r3
8010f018:	000b883a 	mov	r5,zero
8010f01c:	1009883a 	mov	r4,r2
8010f020:	0137ef00 	call	80137ef0 <OSMutexPend>
						if ( error_code == OS_ERR_NONE ) {
8010f024:	e0bffd03 	ldbu	r2,-12(fp)
8010f028:	10803fcc 	andi	r2,r2,255
8010f02c:	1000d61e 	bne	r2,zero,8010f388 <vFeeTask+0x10e0>
							pxNFee->xControl.bDMALocked = TRUE;
8010f030:	d0a05417 	ldw	r2,-32432(gp)
8010f034:	00c00044 	movi	r3,1
8010f038:	10c02215 	stw	r3,136(r2)

							/* Is this the last block? */
							if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8010f03c:	e0bff617 	ldw	r2,-40(fp)
8010f040:	10800117 	ldw	r2,4(r2)
8010f044:	10c00404 	addi	r3,r2,16
8010f048:	d0a05417 	ldw	r2,-32432(gp)
8010f04c:	10800417 	ldw	r2,16(r2)
8010f050:	18801936 	bltu	r3,r2,8010f0b8 <vFeeTask+0xe10>

								/*Define the size of the data in the double buffer (need this to create the interrupt right)*/
								usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8010f054:	d0a05417 	ldw	r2,-32432(gp)
8010f058:	10c00417 	ldw	r3,16(r2)
8010f05c:	e0bff617 	ldw	r2,-40(fp)
8010f060:	10800117 	ldw	r2,4(r2)
8010f064:	1885c83a 	sub	r2,r3,r2
8010f068:	e0bff815 	stw	r2,-32(fp)

								vSetDoubleBufferLeftSize( (unsigned char)usiLengthBlocks, pxNFee->ucSPWId );
8010f06c:	e0bff817 	ldw	r2,-32(fp)
8010f070:	10c03fcc 	andi	r3,r2,255
8010f074:	d0a05417 	ldw	r2,-32432(gp)
8010f078:	10800043 	ldbu	r2,1(r2)
8010f07c:	10803fcc 	andi	r2,r2,255
8010f080:	100b883a 	mov	r5,r2
8010f084:	1809883a 	mov	r4,r3
8010f088:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
								vSetDoubleBufferRightSize( (unsigned char)usiLengthBlocks, pxNFee->ucSPWId );
8010f08c:	e0bff817 	ldw	r2,-32(fp)
8010f090:	10c03fcc 	andi	r3,r2,255
8010f094:	d0a05417 	ldw	r2,-32432(gp)
8010f098:	10800043 	ldbu	r2,1(r2)
8010f09c:	10803fcc 	andi	r2,r2,255
8010f0a0:	100b883a 	mov	r5,r2
8010f0a4:	1809883a 	mov	r4,r3
8010f0a8:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
								} else {
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
								}*/

								bFinal = TRUE;
8010f0ac:	00800044 	movi	r2,1
8010f0b0:	e0bffa15 	stw	r2,-24(fp)
8010f0b4:	00000206 	br	8010f0c0 <vFeeTask+0xe18>

							} else {
								usiLengthBlocks = SDMA_MAX_BLOCKS;
8010f0b8:	00800404 	movi	r2,16
8010f0bc:	e0bff815 	stw	r2,-32(fp)
							}


							if ( ucMemUsing == 0  ) {
8010f0c0:	e0bff503 	ldbu	r2,-44(fp)
8010f0c4:	1000111e 	bne	r2,zero,8010f10c <vFeeTask+0xe64>
								bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8010f0c8:	e0bff617 	ldw	r2,-40(fp)
8010f0cc:	10800217 	ldw	r2,8(r2)
8010f0d0:	1011883a 	mov	r8,r2
8010f0d4:	e0bff817 	ldw	r2,-32(fp)
8010f0d8:	10ffffcc 	andi	r3,r2,65535
8010f0dc:	d0a05303 	ldbu	r2,-32436(gp)
8010f0e0:	11003fcc 	andi	r4,r2,255
8010f0e4:	d0a05417 	ldw	r2,-32432(gp)
8010f0e8:	10800043 	ldbu	r2,1(r2)
8010f0ec:	10803fcc 	andi	r2,r2,255
8010f0f0:	100f883a 	mov	r7,r2
8010f0f4:	200d883a 	mov	r6,r4
8010f0f8:	180b883a 	mov	r5,r3
8010f0fc:	4009883a 	mov	r4,r8
8010f100:	0101fd00 	call	80101fd0 <bSdmaDmaM1Transfer>
8010f104:	e0bff915 	stw	r2,-28(fp)
8010f108:	00001006 	br	8010f14c <vFeeTask+0xea4>
							} else {
								bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8010f10c:	e0bff617 	ldw	r2,-40(fp)
8010f110:	10800217 	ldw	r2,8(r2)
8010f114:	1011883a 	mov	r8,r2
8010f118:	e0bff817 	ldw	r2,-32(fp)
8010f11c:	10ffffcc 	andi	r3,r2,65535
8010f120:	d0a05303 	ldbu	r2,-32436(gp)
8010f124:	11003fcc 	andi	r4,r2,255
8010f128:	d0a05417 	ldw	r2,-32432(gp)
8010f12c:	10800043 	ldbu	r2,1(r2)
8010f130:	10803fcc 	andi	r2,r2,255
8010f134:	100f883a 	mov	r7,r2
8010f138:	200d883a 	mov	r6,r4
8010f13c:	180b883a 	mov	r5,r3
8010f140:	4009883a 	mov	r4,r8
8010f144:	01024540 	call	80102454 <bSdmaDmaM2Transfer>
8010f148:	e0bff915 	stw	r2,-28(fp)
							}

							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8010f14c:	e0fff503 	ldbu	r3,-44(fp)
8010f150:	00a005b4 	movhi	r2,32790
8010f154:	10ad6e04 	addi	r2,r2,-19016
8010f158:	180690fa 	slli	r3,r3,3
8010f15c:	10c5883a 	add	r2,r2,r3
8010f160:	10800017 	ldw	r2,0(r2)
8010f164:	1009883a 	mov	r4,r2
8010f168:	01384940 	call	80138494 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8010f16c:	d0a05417 	ldw	r2,-32432(gp)
8010f170:	10002215 	stw	zero,136(r2)

							if ( bDmaReturn == TRUE ) {
8010f174:	e0bff917 	ldw	r2,-28(fp)
8010f178:	10800058 	cmpnei	r2,r2,1
8010f17c:	10000e1e 	bne	r2,zero,8010f1b8 <vFeeTask+0xf10>
								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8010f180:	e0bff617 	ldw	r2,-40(fp)
8010f184:	10c00217 	ldw	r3,8(r2)
8010f188:	e0bff817 	ldw	r2,-32(fp)
8010f18c:	10802224 	muli	r2,r2,136
8010f190:	1887883a 	add	r3,r3,r2
8010f194:	e0bff617 	ldw	r2,-40(fp)
8010f198:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += usiLengthBlocks;
8010f19c:	e0bff617 	ldw	r2,-40(fp)
8010f1a0:	10c00117 	ldw	r3,4(r2)
8010f1a4:	e0bff817 	ldw	r2,-32(fp)
8010f1a8:	1887883a 	add	r3,r3,r2
8010f1ac:	e0bff617 	ldw	r2,-40(fp)
8010f1b0:	10c00115 	stw	r3,4(r2)
8010f1b4:	00000806 	br	8010f1d8 <vFeeTask+0xf30>
							} else {
								bFinal = FALSE;
8010f1b8:	e03ffa15 	stw	zero,-24(fp)

								/* Send the request for use the DMA, but to front of the QUEUE */
								bSendRequestNFeeCtrl_Front( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8010f1bc:	d0a05417 	ldw	r2,-32432(gp)
8010f1c0:	10800003 	ldbu	r2,0(r2)
8010f1c4:	10803fcc 	andi	r2,r2,255
8010f1c8:	100d883a 	mov	r6,r2
8010f1cc:	000b883a 	mov	r5,zero
8010f1d0:	01002004 	movi	r4,128
8010f1d4:	01105700 	call	80110570 <bSendRequestNFeeCtrl_Front>
							}


							/* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8010f1d8:	d0a05417 	ldw	r2,-32432(gp)
8010f1dc:	10800003 	ldbu	r2,0(r2)
8010f1e0:	10803fcc 	andi	r2,r2,255
8010f1e4:	100d883a 	mov	r6,r2
8010f1e8:	000b883a 	mov	r5,zero
8010f1ec:	01002044 	movi	r4,129
8010f1f0:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

							if ( bFinal == TRUE ) {
8010f1f4:	e0bffa17 	ldw	r2,-24(fp)
8010f1f8:	10800058 	cmpnei	r2,r2,1
8010f1fc:	1000621e 	bne	r2,zero,8010f388 <vFeeTask+0x10e0>
								pxNFee->xControl.eMode = sEndTransmission;
8010f200:	d0a05417 	ldw	r2,-32432(gp)
8010f204:	00c002c4 	movi	r3,11
8010f208:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8010f20c:	00005e06 	br	8010f388 <vFeeTask+0x10e0>
								//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
							}

						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8010f210:	d0a05417 	ldw	r2,-32432(gp)
8010f214:	e0fffe17 	ldw	r3,-8(fp)
8010f218:	180b883a 	mov	r5,r3
8010f21c:	1009883a 	mov	r4,r2
8010f220:	010f8380 	call	8010f838 <vQCmdFEEinFullPattern>

						if ( pxNFee->xControl.bWatingSync == FALSE ) {
8010f224:	d0a05417 	ldw	r2,-32432(gp)
8010f228:	10802817 	ldw	r2,160(r2)
8010f22c:	1000561e 	bne	r2,zero,8010f388 <vFeeTask+0x10e0>
							pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8010f230:	d0a05417 	ldw	r2,-32432(gp)
8010f234:	d0e05417 	ldw	r3,-32432(gp)
8010f238:	18c02d17 	ldw	r3,180(r3)
8010f23c:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8010f240:	00005106 	br	8010f388 <vFeeTask+0x10e0>
					fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu\n", pxNFee->ucId, ucReadout);
					fprintf(fp,"Memory used: %u\n", ucMemUsing);
				}
				#endif

				pxNFee->xControl.bWatingSync = TRUE;
8010f244:	d0a05417 	ldw	r2,-32432(gp)
8010f248:	00c00044 	movi	r3,1
8010f24c:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8010f250:	d0a05417 	ldw	r2,-32432(gp)
8010f254:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bOneShot == FALSE ) {
8010f258:	00a005b4 	movhi	r2,32790
8010f25c:	10ba3604 	addi	r2,r2,-5928
8010f260:	10800917 	ldw	r2,36(r2)
8010f264:	10001f1e 	bne	r2,zero,8010f2e4 <vFeeTask+0x103c>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8010f268:	d0a05417 	ldw	r2,-32432(gp)
8010f26c:	10802d17 	ldw	r2,180(r2)
8010f270:	10800198 	cmpnei	r2,r2,6
8010f274:	1000141e 	bne	r2,zero,8010f2c8 <vFeeTask+0x1020>

						bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8010f278:	d0a05417 	ldw	r2,-32432(gp)
8010f27c:	10803304 	addi	r2,r2,204
8010f280:	1009883a 	mov	r4,r2
8010f284:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8010f288:	d0a05417 	ldw	r2,-32432(gp)
8010f28c:	e0fff703 	ldbu	r3,-36(fp)
8010f290:	10c036c5 	stb	r3,219(r2)
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8010f294:	d0a05417 	ldw	r2,-32432(gp)
8010f298:	10003685 	stb	zero,218(r2)
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8010f29c:	d0a05417 	ldw	r2,-32432(gp)
8010f2a0:	10803304 	addi	r2,r2,204
8010f2a4:	1009883a 	mov	r4,r2
8010f2a8:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

						pxNFee->xControl.eMode =  sFeeWaitingSync;
8010f2ac:	d0a05417 	ldw	r2,-32432(gp)
8010f2b0:	00c00304 	movi	r3,12
8010f2b4:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8010f2b8:	d0a05417 	ldw	r2,-32432(gp)
8010f2bc:	00c00184 	movi	r3,6
8010f2c0:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8010f2c4:	00003306 	br	8010f394 <vFeeTask+0x10ec>
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8010f2c8:	d0a05417 	ldw	r2,-32432(gp)
8010f2cc:	00c00284 	movi	r3,10
8010f2d0:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8010f2d4:	d0a05417 	ldw	r2,-32432(gp)
8010f2d8:	00c00304 	movi	r3,12
8010f2dc:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
8010f2e0:	00002c06 	br	8010f394 <vFeeTask+0x10ec>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
8010f2e4:	d0a05417 	ldw	r2,-32432(gp)
8010f2e8:	00c00304 	movi	r3,12
8010f2ec:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
8010f2f0:	d0a05417 	ldw	r2,-32432(gp)
8010f2f4:	00c00184 	movi	r3,6
8010f2f8:	10c02d15 	stw	r3,180(r2)
				}

				break;
8010f2fc:	00002506 	br	8010f394 <vFeeTask+0x10ec>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
				}
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8010f300:	d0a05417 	ldw	r2,-32432(gp)
8010f304:	10800003 	ldbu	r2,0(r2)
8010f308:	10c03fcc 	andi	r3,r2,255
8010f30c:	00a00574 	movhi	r2,32789
8010f310:	109f5404 	addi	r2,r2,32080
8010f314:	18c7883a 	add	r3,r3,r3
8010f318:	18c7883a 	add	r3,r3,r3
8010f31c:	10c5883a 	add	r2,r2,r3
8010f320:	10800017 	ldw	r2,0(r2)
8010f324:	e0fffd04 	addi	r3,fp,-12
8010f328:	180d883a 	mov	r6,r3
8010f32c:	000b883a 	mov	r5,zero
8010f330:	1009883a 	mov	r4,r2
8010f334:	01390040 	call	80139004 <OSQPend>
8010f338:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8010f33c:	e0bffd03 	ldbu	r2,-12(fp)
8010f340:	10803fcc 	andi	r2,r2,255
8010f344:	1000121e 	bne	r2,zero,8010f390 <vFeeTask+0x10e8>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					}
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8010f348:	d0a05417 	ldw	r2,-32432(gp)
8010f34c:	e0fffe17 	ldw	r3,-8(fp)
8010f350:	180b883a 	mov	r5,r3
8010f354:	1009883a 	mov	r4,r2
8010f358:	010f3980 	call	8010f398 <vQCmdFEEinWaitingSync>
				}

				break;
8010f35c:	00000c06 	br	8010f390 <vFeeTask+0x10e8>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8010f360:	d0a05417 	ldw	r2,-32432(gp)
8010f364:	00c00144 	movi	r3,5
8010f368:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
8010f36c:	00000906 	br	8010f394 <vFeeTask+0x10ec>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8010f370:	0001883a 	nop
8010f374:	003bd506 	br	8010e2cc <__reset+0xfa0ee2cc>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8010f378:	0001883a 	nop
8010f37c:	003bd306 	br	8010e2cc <__reset+0xfa0ee2cc>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}	
				break;
8010f380:	0001883a 	nop
8010f384:	003bd106 	br	8010e2cc <__reset+0xfa0ee2cc>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8010f388:	0001883a 	nop
8010f38c:	003bcf06 	br	8010e2cc <__reset+0xfa0ee2cc>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8010f390:	0001883a 	nop
				}
				#endif
				break;
		}

	}
8010f394:	003bcd06 	br	8010e2cc <__reset+0xfa0ee2cc>

8010f398 <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8010f398:	defffb04 	addi	sp,sp,-20
8010f39c:	de00012e 	bgeu	sp,et,8010f3a4 <vQCmdFEEinWaitingSync+0xc>
8010f3a0:	003b68fa 	trap	3
8010f3a4:	dfc00415 	stw	ra,16(sp)
8010f3a8:	df000315 	stw	fp,12(sp)
8010f3ac:	df000304 	addi	fp,sp,12
8010f3b0:	e13ffe15 	stw	r4,-8(fp)
8010f3b4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8010f3b8:	e0bfff17 	ldw	r2,-4(fp)
8010f3bc:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8010f3c0:	e0bffdc3 	ldbu	r2,-9(fp)
8010f3c4:	10c03fcc 	andi	r3,r2,255
8010f3c8:	e0bffe17 	ldw	r2,-8(fp)
8010f3cc:	10800003 	ldbu	r2,0(r2)
8010f3d0:	10803fcc 	andi	r2,r2,255
8010f3d4:	10800444 	addi	r2,r2,17
8010f3d8:	18805e1e 	bne	r3,r2,8010f554 <vQCmdFEEinWaitingSync+0x1bc>

		switch (uiCmdFEEL.ucByte[2]) {
8010f3dc:	e0bffd83 	ldbu	r2,-10(fp)
8010f3e0:	10803fcc 	andi	r2,r2,255
8010f3e4:	10c02860 	cmpeqi	r3,r2,161
8010f3e8:	18001a1e 	bne	r3,zero,8010f454 <vQCmdFEEinWaitingSync+0xbc>
8010f3ec:	10c02888 	cmpgei	r3,r2,162
8010f3f0:	18000c1e 	bne	r3,zero,8010f424 <vQCmdFEEinWaitingSync+0x8c>
8010f3f4:	10c00120 	cmpeqi	r3,r2,4
8010f3f8:	18001f1e 	bne	r3,zero,8010f478 <vQCmdFEEinWaitingSync+0xe0>
8010f3fc:	10c00148 	cmpgei	r3,r2,5
8010f400:	1800031e 	bne	r3,zero,8010f410 <vQCmdFEEinWaitingSync+0x78>
8010f404:	10800060 	cmpeqi	r2,r2,1
8010f408:	1000121e 	bne	r2,zero,8010f454 <vQCmdFEEinWaitingSync+0xbc>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f40c:	00005106 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f410:	10c00220 	cmpeqi	r3,r2,8
8010f414:	1800301e 	bne	r3,zero,8010f4d8 <vQCmdFEEinWaitingSync+0x140>
8010f418:	108023e0 	cmpeqi	r2,r2,143
8010f41c:	1000431e 	bne	r2,zero,8010f52c <vQCmdFEEinWaitingSync+0x194>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f420:	00004c06 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f424:	10c03888 	cmpgei	r3,r2,226
8010f428:	1800071e 	bne	r3,zero,8010f448 <vQCmdFEEinWaitingSync+0xb0>
8010f42c:	10c03808 	cmpgei	r3,r2,224
8010f430:	1800371e 	bne	r3,zero,8010f510 <vQCmdFEEinWaitingSync+0x178>
8010f434:	10c02920 	cmpeqi	r3,r2,164
8010f438:	18000f1e 	bne	r3,zero,8010f478 <vQCmdFEEinWaitingSync+0xe0>
8010f43c:	10802a20 	cmpeqi	r2,r2,168
8010f440:	1000251e 	bne	r2,zero,8010f4d8 <vQCmdFEEinWaitingSync+0x140>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f444:	00004306 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f448:	10803c20 	cmpeqi	r2,r2,240
8010f44c:	10002c1e 	bne	r2,zero,8010f500 <vQCmdFEEinWaitingSync+0x168>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f450:	00004006 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>
	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8010f454:	e0bffe17 	ldw	r2,-8(fp)
8010f458:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8010f45c:	e0bffe17 	ldw	r2,-8(fp)
8010f460:	00c00144 	movi	r3,5
8010f464:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8010f468:	e0bffe17 	ldw	r2,-8(fp)
8010f46c:	00c00144 	movi	r3,5
8010f470:	10c02d15 	stw	r3,180(r2)
				break;
8010f474:	00003706 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8010f478:	e0bffe17 	ldw	r2,-8(fp)
8010f47c:	00c00044 	movi	r3,1
8010f480:	10c02815 	stw	r3,160(r2)

				/* If a transition to Standby was requested when the FEE is waiting to go to Calibration,
				 * configure the hardware to not send any data in the next sync */
				if ( sFeeTestFullPattern == pxNFeeP->xControl.eNextMode ) {
8010f484:	e0bffe17 	ldw	r2,-8(fp)
8010f488:	10802d17 	ldw	r2,180(r2)
8010f48c:	10800118 	cmpnei	r2,r2,4
8010f490:	10000a1e 	bne	r2,zero,8010f4bc <vQCmdFEEinWaitingSync+0x124>

					bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8010f494:	e0bffe17 	ldw	r2,-8(fp)
8010f498:	10803304 	addi	r2,r2,204
8010f49c:	1009883a 	mov	r4,r2
8010f4a0:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
					pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8010f4a4:	e0bffe17 	ldw	r2,-8(fp)
8010f4a8:	10003685 	stb	zero,218(r2)
					bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8010f4ac:	e0bffe17 	ldw	r2,-8(fp)
8010f4b0:	10803304 	addi	r2,r2,204
8010f4b4:	1009883a 	mov	r4,r2
8010f4b8:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

				}

				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8010f4bc:	e0bffe17 	ldw	r2,-8(fp)
8010f4c0:	00c00304 	movi	r3,12
8010f4c4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8010f4c8:	e0bffe17 	ldw	r2,-8(fp)
8010f4cc:	00c00184 	movi	r3,6
8010f4d0:	10c02d15 	stw	r3,180(r2)
				break;
8010f4d4:	00001f06 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8010f4d8:	e0bffe17 	ldw	r2,-8(fp)
8010f4dc:	00c00044 	movi	r3,1
8010f4e0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8010f4e4:	e0bffe17 	ldw	r2,-8(fp)
8010f4e8:	00c00284 	movi	r3,10
8010f4ec:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8010f4f0:	e0bffe17 	ldw	r2,-8(fp)
8010f4f4:	00c00304 	movi	r3,12
8010f4f8:	10c02d15 	stw	r3,180(r2)
				break;
8010f4fc:	00001506 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"\nNFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8010f500:	e17fff17 	ldw	r5,-4(fp)
8010f504:	e13ffe17 	ldw	r4,-8(fp)
8010f508:	010fff00 	call	8010fff0 <vQCmdFeeRMAPWaitingSync>
				break;
8010f50c:	00001106 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8010f510:	e0bffe17 	ldw	r2,-8(fp)
8010f514:	10c02d17 	ldw	r3,180(r2)
8010f518:	e0bffe17 	ldw	r2,-8(fp)
8010f51c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8010f520:	e0bffe17 	ldw	r2,-8(fp)
8010f524:	10002815 	stw	zero,160(r2)

				break;
8010f528:	00000a06 	br	8010f554 <vQCmdFEEinWaitingSync+0x1bc>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8010f52c:	e0bffe17 	ldw	r2,-8(fp)
8010f530:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8010f534:	e0bffe17 	ldw	r2,-8(fp)
8010f538:	10800003 	ldbu	r2,0(r2)
8010f53c:	10803fcc 	andi	r2,r2,255
8010f540:	100d883a 	mov	r6,r2
8010f544:	000b883a 	mov	r5,zero
8010f548:	01002044 	movi	r4,129
8010f54c:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>
				break;
8010f550:	0001883a 	nop
				}
				#endif
				break;
		}
	}
}
8010f554:	0001883a 	nop
8010f558:	e037883a 	mov	sp,fp
8010f55c:	dfc00117 	ldw	ra,4(sp)
8010f560:	df000017 	ldw	fp,0(sp)
8010f564:	dec00204 	addi	sp,sp,8
8010f568:	f800283a 	ret

8010f56c <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8010f56c:	defffb04 	addi	sp,sp,-20
8010f570:	de00012e 	bgeu	sp,et,8010f578 <vQCmdFEEinConfig+0xc>
8010f574:	003b68fa 	trap	3
8010f578:	dfc00415 	stw	ra,16(sp)
8010f57c:	df000315 	stw	fp,12(sp)
8010f580:	df000304 	addi	fp,sp,12
8010f584:	e13ffe15 	stw	r4,-8(fp)
8010f588:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8010f58c:	e0bfff17 	ldw	r2,-4(fp)
8010f590:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8010f594:	e0bffdc3 	ldbu	r2,-9(fp)
8010f598:	10c03fcc 	andi	r3,r2,255
8010f59c:	e0bffe17 	ldw	r2,-8(fp)
8010f5a0:	10800003 	ldbu	r2,0(r2)
8010f5a4:	10803fcc 	andi	r2,r2,255
8010f5a8:	10800444 	addi	r2,r2,17
8010f5ac:	1880381e 	bne	r3,r2,8010f690 <vQCmdFEEinConfig+0x124>

		switch (uiCmdFEEL.ucByte[2]) {
8010f5b0:	e0bffd83 	ldbu	r2,-10(fp)
8010f5b4:	10803fcc 	andi	r2,r2,255
8010f5b8:	10c02860 	cmpeqi	r3,r2,161
8010f5bc:	18002d1e 	bne	r3,zero,8010f674 <vQCmdFEEinConfig+0x108>
8010f5c0:	10c02888 	cmpgei	r3,r2,162
8010f5c4:	18000c1e 	bne	r3,zero,8010f5f8 <vQCmdFEEinConfig+0x8c>
8010f5c8:	10c00120 	cmpeqi	r3,r2,4
8010f5cc:	1800161e 	bne	r3,zero,8010f628 <vQCmdFEEinConfig+0xbc>
8010f5d0:	10c00148 	cmpgei	r3,r2,5
8010f5d4:	1800031e 	bne	r3,zero,8010f5e4 <vQCmdFEEinConfig+0x78>
8010f5d8:	10800060 	cmpeqi	r2,r2,1
8010f5dc:	1000251e 	bne	r2,zero,8010f674 <vQCmdFEEinConfig+0x108>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f5e0:	00002b06 	br	8010f690 <vQCmdFEEinConfig+0x124>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f5e4:	10c00220 	cmpeqi	r3,r2,8
8010f5e8:	1800241e 	bne	r3,zero,8010f67c <vQCmdFEEinConfig+0x110>
8010f5ec:	108023e0 	cmpeqi	r2,r2,143
8010f5f0:	1000161e 	bne	r2,zero,8010f64c <vQCmdFEEinConfig+0xe0>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f5f4:	00002606 	br	8010f690 <vQCmdFEEinConfig+0x124>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f5f8:	10c03888 	cmpgei	r3,r2,226
8010f5fc:	1800071e 	bne	r3,zero,8010f61c <vQCmdFEEinConfig+0xb0>
8010f600:	10c03808 	cmpgei	r3,r2,224
8010f604:	18001f1e 	bne	r3,zero,8010f684 <vQCmdFEEinConfig+0x118>
8010f608:	10c02920 	cmpeqi	r3,r2,164
8010f60c:	1800061e 	bne	r3,zero,8010f628 <vQCmdFEEinConfig+0xbc>
8010f610:	10802a20 	cmpeqi	r2,r2,168
8010f614:	1000191e 	bne	r2,zero,8010f67c <vQCmdFEEinConfig+0x110>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f618:	00001d06 	br	8010f690 <vQCmdFEEinConfig+0x124>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f61c:	10803c20 	cmpeqi	r2,r2,240
8010f620:	10001a1e 	bne	r2,zero,8010f68c <vQCmdFEEinConfig+0x120>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f624:	00001a06 	br	8010f690 <vQCmdFEEinConfig+0x124>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8010f628:	e0bffe17 	ldw	r2,-8(fp)
8010f62c:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8010f630:	e0bffe17 	ldw	r2,-8(fp)
8010f634:	00c00184 	movi	r3,6
8010f638:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8010f63c:	e0bffe17 	ldw	r2,-8(fp)
8010f640:	00c00184 	movi	r3,6
8010f644:	10c02d15 	stw	r3,180(r2)
				break;				
8010f648:	00001106 	br	8010f690 <vQCmdFEEinConfig+0x124>
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8010f64c:	e0bffe17 	ldw	r2,-8(fp)
8010f650:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8010f654:	e0bffe17 	ldw	r2,-8(fp)
8010f658:	10800003 	ldbu	r2,0(r2)
8010f65c:	10803fcc 	andi	r2,r2,255
8010f660:	100d883a 	mov	r6,r2
8010f664:	000b883a 	mov	r5,zero
8010f668:	01002044 	movi	r4,129
8010f66c:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>
				break;
8010f670:	00000706 	br	8010f690 <vQCmdFEEinConfig+0x124>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f674:	0001883a 	nop
8010f678:	00000506 	br	8010f690 <vQCmdFEEinConfig+0x124>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f67c:	0001883a 	nop
8010f680:	00000306 	br	8010f690 <vQCmdFEEinConfig+0x124>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8010f684:	0001883a 	nop
8010f688:	00000106 	br	8010f690 <vQCmdFEEinConfig+0x124>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task: Can't threat RMAP Messages in this mode (Config)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f68c:	0001883a 	nop
				}
				#endif
				break;
		}
	}
}
8010f690:	0001883a 	nop
8010f694:	e037883a 	mov	sp,fp
8010f698:	dfc00117 	ldw	ra,4(sp)
8010f69c:	df000017 	ldw	fp,0(sp)
8010f6a0:	dec00204 	addi	sp,sp,8
8010f6a4:	f800283a 	ret

8010f6a8 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8010f6a8:	defffb04 	addi	sp,sp,-20
8010f6ac:	de00012e 	bgeu	sp,et,8010f6b4 <vQCmdFEEinStandBy+0xc>
8010f6b0:	003b68fa 	trap	3
8010f6b4:	dfc00415 	stw	ra,16(sp)
8010f6b8:	df000315 	stw	fp,12(sp)
8010f6bc:	df000304 	addi	fp,sp,12
8010f6c0:	e13ffe15 	stw	r4,-8(fp)
8010f6c4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8010f6c8:	e0bfff17 	ldw	r2,-4(fp)
8010f6cc:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8010f6d0:	e0bffdc3 	ldbu	r2,-9(fp)
8010f6d4:	10c03fcc 	andi	r3,r2,255
8010f6d8:	e0bffe17 	ldw	r2,-8(fp)
8010f6dc:	10800003 	ldbu	r2,0(r2)
8010f6e0:	10803fcc 	andi	r2,r2,255
8010f6e4:	10800444 	addi	r2,r2,17
8010f6e8:	18804d1e 	bne	r3,r2,8010f820 <vQCmdFEEinStandBy+0x178>

		switch (uiCmdFEEL.ucByte[2]) {
8010f6ec:	e0bffd83 	ldbu	r2,-10(fp)
8010f6f0:	10803fcc 	andi	r2,r2,255
8010f6f4:	10c02860 	cmpeqi	r3,r2,161
8010f6f8:	18001a1e 	bne	r3,zero,8010f764 <vQCmdFEEinStandBy+0xbc>
8010f6fc:	10c02888 	cmpgei	r3,r2,162
8010f700:	18000c1e 	bne	r3,zero,8010f734 <vQCmdFEEinStandBy+0x8c>
8010f704:	10c00120 	cmpeqi	r3,r2,4
8010f708:	1800421e 	bne	r3,zero,8010f814 <vQCmdFEEinStandBy+0x16c>
8010f70c:	10c00148 	cmpgei	r3,r2,5
8010f710:	1800031e 	bne	r3,zero,8010f720 <vQCmdFEEinStandBy+0x78>
8010f714:	10800060 	cmpeqi	r2,r2,1
8010f718:	1000121e 	bne	r2,zero,8010f764 <vQCmdFEEinStandBy+0xbc>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f71c:	00004006 	br	8010f820 <vQCmdFEEinStandBy+0x178>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f720:	10c00220 	cmpeqi	r3,r2,8
8010f724:	1800181e 	bne	r3,zero,8010f788 <vQCmdFEEinStandBy+0xe0>
8010f728:	108023e0 	cmpeqi	r2,r2,143
8010f72c:	10002f1e 	bne	r2,zero,8010f7ec <vQCmdFEEinStandBy+0x144>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f730:	00003b06 	br	8010f820 <vQCmdFEEinStandBy+0x178>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f734:	10c03888 	cmpgei	r3,r2,226
8010f738:	1800071e 	bne	r3,zero,8010f758 <vQCmdFEEinStandBy+0xb0>
8010f73c:	10c03808 	cmpgei	r3,r2,224
8010f740:	18001f1e 	bne	r3,zero,8010f7c0 <vQCmdFEEinStandBy+0x118>
8010f744:	10c02920 	cmpeqi	r3,r2,164
8010f748:	1800321e 	bne	r3,zero,8010f814 <vQCmdFEEinStandBy+0x16c>
8010f74c:	10802a20 	cmpeqi	r2,r2,168
8010f750:	10000d1e 	bne	r2,zero,8010f788 <vQCmdFEEinStandBy+0xe0>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f754:	00003206 	br	8010f820 <vQCmdFEEinStandBy+0x178>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f758:	10803c20 	cmpeqi	r2,r2,240
8010f75c:	1000141e 	bne	r2,zero,8010f7b0 <vQCmdFEEinStandBy+0x108>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f760:	00002f06 	br	8010f820 <vQCmdFEEinStandBy+0x178>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8010f764:	e0bffe17 	ldw	r2,-8(fp)
8010f768:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8010f76c:	e0bffe17 	ldw	r2,-8(fp)
8010f770:	00c00144 	movi	r3,5
8010f774:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8010f778:	e0bffe17 	ldw	r2,-8(fp)
8010f77c:	00c00144 	movi	r3,5
8010f780:	10c02d15 	stw	r3,180(r2)
				break;				
8010f784:	00002606 	br	8010f820 <vQCmdFEEinStandBy+0x178>
				}
				#endif
				break;
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8010f788:	e0bffe17 	ldw	r2,-8(fp)
8010f78c:	00c00044 	movi	r3,1
8010f790:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8010f794:	e0bffe17 	ldw	r2,-8(fp)
8010f798:	00c00284 	movi	r3,10
8010f79c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8010f7a0:	e0bffe17 	ldw	r2,-8(fp)
8010f7a4:	00c00304 	movi	r3,12
8010f7a8:	10c02d15 	stw	r3,180(r2)
				break;
8010f7ac:	00001c06 	br	8010f820 <vQCmdFEEinStandBy+0x178>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8010f7b0:	e17fff17 	ldw	r5,-4(fp)
8010f7b4:	e13ffe17 	ldw	r4,-8(fp)
8010f7b8:	010f9fc0 	call	8010f9fc <vQCmdFeeRMAPinStandBy>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
				}
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8010f7bc:	00001806 	br	8010f820 <vQCmdFEEinStandBy+0x178>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8010f7c0:	e0bffe17 	ldw	r2,-8(fp)
8010f7c4:	10802c17 	ldw	r2,176(r2)
8010f7c8:	10800318 	cmpnei	r2,r2,12
8010f7cc:	1000131e 	bne	r2,zero,8010f81c <vQCmdFEEinStandBy+0x174>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8010f7d0:	e0bffe17 	ldw	r2,-8(fp)
8010f7d4:	10c02d17 	ldw	r3,180(r2)
8010f7d8:	e0bffe17 	ldw	r2,-8(fp)
8010f7dc:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8010f7e0:	e0bffe17 	ldw	r2,-8(fp)
8010f7e4:	10002815 	stw	zero,160(r2)
				}
				break;
8010f7e8:	00000c06 	br	8010f81c <vQCmdFEEinStandBy+0x174>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8010f7ec:	e0bffe17 	ldw	r2,-8(fp)
8010f7f0:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8010f7f4:	e0bffe17 	ldw	r2,-8(fp)
8010f7f8:	10800003 	ldbu	r2,0(r2)
8010f7fc:	10803fcc 	andi	r2,r2,255
8010f800:	100d883a 	mov	r6,r2
8010f804:	000b883a 	mov	r5,zero
8010f808:	01002044 	movi	r4,129
8010f80c:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>
				break;
8010f810:	00000306 	br	8010f820 <vQCmdFEEinStandBy+0x178>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f814:	0001883a 	nop
8010f818:	00000106 	br	8010f820 <vQCmdFEEinStandBy+0x178>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8010f81c:	0001883a 	nop
				}
				#endif
				break;
		}
	}
}
8010f820:	0001883a 	nop
8010f824:	e037883a 	mov	sp,fp
8010f828:	dfc00117 	ldw	ra,4(sp)
8010f82c:	df000017 	ldw	fp,0(sp)
8010f830:	dec00204 	addi	sp,sp,8
8010f834:	f800283a 	ret

8010f838 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8010f838:	defffb04 	addi	sp,sp,-20
8010f83c:	de00012e 	bgeu	sp,et,8010f844 <vQCmdFEEinFullPattern+0xc>
8010f840:	003b68fa 	trap	3
8010f844:	dfc00415 	stw	ra,16(sp)
8010f848:	df000315 	stw	fp,12(sp)
8010f84c:	df000304 	addi	fp,sp,12
8010f850:	e13ffe15 	stw	r4,-8(fp)
8010f854:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8010f858:	e0bfff17 	ldw	r2,-4(fp)
8010f85c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8010f860:	e0bffdc3 	ldbu	r2,-9(fp)
8010f864:	10c03fcc 	andi	r3,r2,255
8010f868:	e0bffe17 	ldw	r2,-8(fp)
8010f86c:	10800003 	ldbu	r2,0(r2)
8010f870:	10803fcc 	andi	r2,r2,255
8010f874:	10800444 	addi	r2,r2,17
8010f878:	18805a1e 	bne	r3,r2,8010f9e4 <vQCmdFEEinFullPattern+0x1ac>

		switch (uiCmdFEEL.ucByte[2]) {
8010f87c:	e0bffd83 	ldbu	r2,-10(fp)
8010f880:	10803fcc 	andi	r2,r2,255
8010f884:	10c02860 	cmpeqi	r3,r2,161
8010f888:	1800181e 	bne	r3,zero,8010f8ec <vQCmdFEEinFullPattern+0xb4>
8010f88c:	10c02888 	cmpgei	r3,r2,162
8010f890:	18000c1e 	bne	r3,zero,8010f8c4 <vQCmdFEEinFullPattern+0x8c>
8010f894:	10c000a0 	cmpeqi	r3,r2,2
8010f898:	18004d1e 	bne	r3,zero,8010f9d0 <vQCmdFEEinFullPattern+0x198>
8010f89c:	10c000c8 	cmpgei	r3,r2,3
8010f8a0:	1800031e 	bne	r3,zero,8010f8b0 <vQCmdFEEinFullPattern+0x78>
8010f8a4:	10800060 	cmpeqi	r2,r2,1
8010f8a8:	1000101e 	bne	r2,zero,8010f8ec <vQCmdFEEinFullPattern+0xb4>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f8ac:	00004d06 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f8b0:	10c00120 	cmpeqi	r3,r2,4
8010f8b4:	1800161e 	bne	r3,zero,8010f910 <vQCmdFEEinFullPattern+0xd8>
8010f8b8:	10800220 	cmpeqi	r2,r2,8
8010f8bc:	1000461e 	bne	r2,zero,8010f9d8 <vQCmdFEEinFullPattern+0x1a0>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f8c0:	00004806 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f8c4:	10c03888 	cmpgei	r3,r2,226
8010f8c8:	1800051e 	bne	r3,zero,8010f8e0 <vQCmdFEEinFullPattern+0xa8>
8010f8cc:	10c03808 	cmpgei	r3,r2,224
8010f8d0:	1800341e 	bne	r3,zero,8010f9a4 <vQCmdFEEinFullPattern+0x16c>
8010f8d4:	10802920 	cmpeqi	r2,r2,164
8010f8d8:	1000251e 	bne	r2,zero,8010f970 <vQCmdFEEinFullPattern+0x138>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f8dc:	00004106 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8010f8e0:	10803c20 	cmpeqi	r2,r2,240
8010f8e4:	10002b1e 	bne	r2,zero,8010f994 <vQCmdFEEinFullPattern+0x15c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f8e8:	00003e06 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8010f8ec:	e0bffe17 	ldw	r2,-8(fp)
8010f8f0:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8010f8f4:	e0bffe17 	ldw	r2,-8(fp)
8010f8f8:	00c00144 	movi	r3,5
8010f8fc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8010f900:	e0bffe17 	ldw	r2,-8(fp)
8010f904:	00c00144 	movi	r3,5
8010f908:	10c02d15 	stw	r3,180(r2)
				break;				
8010f90c:	00003506 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8010f910:	e0bffe17 	ldw	r2,-8(fp)
8010f914:	10802c17 	ldw	r2,176(r2)
8010f918:	10800298 	cmpnei	r2,r2,10
8010f91c:	10000a1e 	bne	r2,zero,8010f948 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8010f920:	e0bffe17 	ldw	r2,-8(fp)
8010f924:	00c00044 	movi	r3,1
8010f928:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8010f92c:	e0bffe17 	ldw	r2,-8(fp)
8010f930:	00c00304 	movi	r3,12
8010f934:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8010f938:	e0bffe17 	ldw	r2,-8(fp)
8010f93c:	00c00184 	movi	r3,6
8010f940:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8010f944:	00002706 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8010f948:	e0bffe17 	ldw	r2,-8(fp)
8010f94c:	00c00044 	movi	r3,1
8010f950:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8010f954:	e0bffe17 	ldw	r2,-8(fp)
8010f958:	00c00104 	movi	r3,4
8010f95c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8010f960:	e0bffe17 	ldw	r2,-8(fp)
8010f964:	00c00184 	movi	r3,6
8010f968:	10c02d15 	stw	r3,180(r2)
				}

				break;
8010f96c:	00001d06 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8010f970:	e0bffe17 	ldw	r2,-8(fp)
8010f974:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8010f978:	e0bffe17 	ldw	r2,-8(fp)
8010f97c:	00c00184 	movi	r3,6
8010f980:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8010f984:	e0bffe17 	ldw	r2,-8(fp)
8010f988:	00c00184 	movi	r3,6
8010f98c:	10c02d15 	stw	r3,180(r2)
				break;				
8010f990:	00001406 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>
					fprintf(fp,"NFEE %hhu Task: RMAP Message\n", pxNFeeP->ucId);
				}
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8010f994:	e17fff17 	ldw	r5,-4(fp)
8010f998:	e13ffe17 	ldw	r4,-8(fp)
8010f99c:	010fd580 	call	8010fd58 <vQCmdFeeRMAPinFullPattern>

				break;
8010f9a0:	00001006 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8010f9a4:	e0bffe17 	ldw	r2,-8(fp)
8010f9a8:	10802c17 	ldw	r2,176(r2)
8010f9ac:	10800318 	cmpnei	r2,r2,12
8010f9b0:	10000b1e 	bne	r2,zero,8010f9e0 <vQCmdFEEinFullPattern+0x1a8>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8010f9b4:	e0bffe17 	ldw	r2,-8(fp)
8010f9b8:	10c02d17 	ldw	r3,180(r2)
8010f9bc:	e0bffe17 	ldw	r2,-8(fp)
8010f9c0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8010f9c4:	e0bffe17 	ldw	r2,-8(fp)
8010f9c8:	10002815 	stw	zero,160(r2)
				}

				break;
8010f9cc:	00000406 	br	8010f9e0 <vQCmdFEEinFullPattern+0x1a8>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8010f9d0:	0001883a 	nop
8010f9d4:	00000306 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
				}
				#endif
				break;
8010f9d8:	0001883a 	nop
8010f9dc:	00000106 	br	8010f9e4 <vQCmdFEEinFullPattern+0x1ac>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8010f9e0:	0001883a 	nop
				}
				#endif
				break;
		}
	}
}
8010f9e4:	0001883a 	nop
8010f9e8:	e037883a 	mov	sp,fp
8010f9ec:	dfc00117 	ldw	ra,4(sp)
8010f9f0:	df000017 	ldw	fp,0(sp)
8010f9f4:	dec00204 	addi	sp,sp,8
8010f9f8:	f800283a 	ret

8010f9fc <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8010f9fc:	defff704 	addi	sp,sp,-36
8010fa00:	de00012e 	bgeu	sp,et,8010fa08 <vQCmdFeeRMAPinStandBy+0xc>
8010fa04:	003b68fa 	trap	3
8010fa08:	dfc00815 	stw	ra,32(sp)
8010fa0c:	df000715 	stw	fp,28(sp)
8010fa10:	df000704 	addi	fp,sp,28
8010fa14:	e13ffe15 	stw	r4,-8(fp)
8010fa18:	e17fff15 	stw	r5,-4(fp)
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
	}
#endif


	uiCmdFEEL.ulWord = cmd;
8010fa1c:	e0bfff17 	ldw	r2,-4(fp)
8010fa20:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8010fa24:	e0bffd43 	ldbu	r2,-11(fp)
8010fa28:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8010fa2c:	e0bffe17 	ldw	r2,-8(fp)
8010fa30:	10804817 	ldw	r2,288(r2)
8010fa34:	e0fff903 	ldbu	r3,-28(fp)
8010fa38:	180b883a 	mov	r5,r3
8010fa3c:	1009883a 	mov	r4,r2
8010fa40:	010a7080 	call	8010a708 <uliRmapReadReg>
8010fa44:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8010fa48:	e0bff903 	ldbu	r2,-28(fp)
8010fa4c:	10bff004 	addi	r2,r2,-64
8010fa50:	10c003a8 	cmpgeui	r3,r2,14
8010fa54:	1800b51e 	bne	r3,zero,8010fd2c <vQCmdFeeRMAPinStandBy+0x330>
8010fa58:	100690ba 	slli	r3,r2,2
8010fa5c:	00a00474 	movhi	r2,32785
8010fa60:	10be9c04 	addi	r2,r2,-1424
8010fa64:	1885883a 	add	r2,r3,r2
8010fa68:	10800017 	ldw	r2,0(r2)
8010fa6c:	1000683a 	jmp	r2
8010fa70:	8010faa8 	cmpgeui	zero,r16,17386
8010fa74:	8010fd34 	orhi	zero,r16,17396
8010fa78:	8010fb94 	ori	zero,r16,17390
8010fa7c:	8010fd34 	orhi	zero,r16,17396
8010fa80:	8010fd34 	orhi	zero,r16,17396
8010fa84:	8010fd34 	orhi	zero,r16,17396
8010fa88:	8010fd34 	orhi	zero,r16,17396
8010fa8c:	8010fd34 	orhi	zero,r16,17396
8010fa90:	8010fd34 	orhi	zero,r16,17396
8010fa94:	8010fd34 	orhi	zero,r16,17396
8010fa98:	8010fd34 	orhi	zero,r16,17396
8010fa9c:	8010fd34 	orhi	zero,r16,17396
8010faa0:	8010fc74 	orhi	zero,r16,17393
8010faa4:	8010fcd8 	cmpnei	zero,r16,17395
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8010faa8:	e0fffa17 	ldw	r3,-24(fp)
8010faac:	00800434 	movhi	r2,16
8010fab0:	10bffc04 	addi	r2,r2,-16
8010fab4:	1884703a 	and	r2,r3,r2
8010fab8:	1004d13a 	srli	r2,r2,4
8010fabc:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8010fac0:	e0bffa17 	ldw	r2,-24(fp)
8010fac4:	1004d53a 	srli	r2,r2,20
8010fac8:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8010facc:	e0bffb17 	ldw	r2,-20(fp)
8010fad0:	1007883a 	mov	r3,r2
8010fad4:	e0bffe17 	ldw	r2,-8(fp)
8010fad8:	1080300b 	ldhu	r2,192(r2)
8010fadc:	1885c83a 	sub	r2,r3,r2
8010fae0:	1007883a 	mov	r3,r2
8010fae4:	e0bffe17 	ldw	r2,-8(fp)
8010fae8:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
8010faec:	e0bffc17 	ldw	r2,-16(fp)
8010faf0:	1009883a 	mov	r4,r2
8010faf4:	e0bffe17 	ldw	r2,-8(fp)
8010faf8:	10c02f8b 	ldhu	r3,190(r2)
8010fafc:	e0bffe17 	ldw	r2,-8(fp)
8010fb00:	10802f0b 	ldhu	r2,188(r2)
8010fb04:	1885883a 	add	r2,r3,r2
8010fb08:	2085c83a 	sub	r2,r4,r2
8010fb0c:	1007883a 	mov	r3,r2
8010fb10:	e0bffe17 	ldw	r2,-8(fp)
8010fb14:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8010fb18:	e13ffe17 	ldw	r4,-8(fp)
8010fb1c:	011dea80 	call	8011dea8 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8010fb20:	e0bffe17 	ldw	r2,-8(fp)
8010fb24:	10803304 	addi	r2,r2,204
8010fb28:	1009883a 	mov	r4,r2
8010fb2c:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
8010fb30:	e0bffe17 	ldw	r2,-8(fp)
8010fb34:	10c0300b 	ldhu	r3,192(r2)
8010fb38:	e0bffe17 	ldw	r2,-8(fp)
8010fb3c:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
8010fb40:	e0bffc17 	ldw	r2,-16(fp)
8010fb44:	1007883a 	mov	r3,r2
8010fb48:	e0bffe17 	ldw	r2,-8(fp)
8010fb4c:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
8010fb50:	e0bffb17 	ldw	r2,-20(fp)
8010fb54:	1007883a 	mov	r3,r2
8010fb58:	e0bffe17 	ldw	r2,-8(fp)
8010fb5c:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8010fb60:	e0bffb17 	ldw	r2,-20(fp)
8010fb64:	1007883a 	mov	r3,r2
8010fb68:	e0bffe17 	ldw	r2,-8(fp)
8010fb6c:	1080300b 	ldhu	r2,192(r2)
8010fb70:	1885c83a 	sub	r2,r3,r2
8010fb74:	1007883a 	mov	r3,r2
8010fb78:	e0bffe17 	ldw	r2,-8(fp)
8010fb7c:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8010fb80:	e0bffe17 	ldw	r2,-8(fp)
8010fb84:	10803304 	addi	r2,r2,204
8010fb88:	1009883a 	mov	r4,r2
8010fb8c:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

			break;
8010fb90:	00006b06 	br	8010fd40 <vQCmdFeeRMAPinStandBy+0x344>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8010fb94:	e0fffa17 	ldw	r3,-24(fp)
8010fb98:	00800434 	movhi	r2,16
8010fb9c:	10bffc04 	addi	r2,r2,-16
8010fba0:	1884703a 	and	r2,r3,r2
8010fba4:	1004d13a 	srli	r2,r2,4
8010fba8:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8010fbac:	e0bffe17 	ldw	r2,-8(fp)
8010fbb0:	10803304 	addi	r2,r2,204
8010fbb4:	1009883a 	mov	r4,r2
8010fbb8:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8010fbbc:	e0bffb17 	ldw	r2,-20(fp)
8010fbc0:	1007883a 	mov	r3,r2
8010fbc4:	e0bffe17 	ldw	r2,-8(fp)
8010fbc8:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8010fbcc:	e0bffe17 	ldw	r2,-8(fp)
8010fbd0:	10803304 	addi	r2,r2,204
8010fbd4:	1009883a 	mov	r4,r2
8010fbd8:	0102c480 	call	80102c48 <bDpktSetPacketConfig>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"- Pckt Length: %lu\n", ucValueMasked);
			}
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8010fbdc:	e0bffa17 	ldw	r2,-24(fp)
8010fbe0:	1080030c 	andi	r2,r2,12
8010fbe4:	1004d0ba 	srli	r2,r2,2
8010fbe8:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8010fbec:	e0bffc17 	ldw	r2,-16(fp)
8010fbf0:	10c000a0 	cmpeqi	r3,r2,2
8010fbf4:	1800071e 	bne	r3,zero,8010fc14 <vQCmdFeeRMAPinStandBy+0x218>
8010fbf8:	10c000e0 	cmpeqi	r3,r2,3
8010fbfc:	1800091e 	bne	r3,zero,8010fc24 <vQCmdFeeRMAPinStandBy+0x228>
8010fc00:	10800060 	cmpeqi	r2,r2,1
8010fc04:	10000926 	beq	r2,zero,8010fc2c <vQCmdFeeRMAPinStandBy+0x230>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8010fc08:	e0bffe17 	ldw	r2,-8(fp)
8010fc0c:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Left side\n");
					}
					#endif
					break;
8010fc10:	00001706 	br	8010fc70 <vQCmdFeeRMAPinStandBy+0x274>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8010fc14:	e0bffe17 	ldw	r2,-8(fp)
8010fc18:	00c00044 	movi	r3,1
8010fc1c:	10c02e15 	stw	r3,184(r2)
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Right side\n");
					}
					#endif
					break;
8010fc20:	00001306 	br	8010fc70 <vQCmdFeeRMAPinStandBy+0x274>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8010fc24:	e0bffe17 	ldw	r2,-8(fp)
8010fc28:	10002e15 	stw	zero,184(r2)
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
					}
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8010fc2c:	e0bffe17 	ldw	r2,-8(fp)
8010fc30:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8010fc34:	e0bffe17 	ldw	r2,-8(fp)
8010fc38:	10804804 	addi	r2,r2,288
8010fc3c:	1009883a 	mov	r4,r2
8010fc40:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8010fc44:	e0bffe17 	ldw	r2,-8(fp)
8010fc48:	10c05c17 	ldw	r3,368(r2)
8010fc4c:	00bffdc4 	movi	r2,-9
8010fc50:	1886703a 	and	r3,r3,r2
8010fc54:	e0bffe17 	ldw	r2,-8(fp)
8010fc58:	10c05c15 	stw	r3,368(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8010fc5c:	e0bffe17 	ldw	r2,-8(fp)
8010fc60:	10804804 	addi	r2,r2,288
8010fc64:	1009883a 	mov	r4,r2
8010fc68:	010857c0 	call	8010857c <bRmapSetMemConfigArea>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp," - Switching to Left side\n");
					}
					#endif
					break;
8010fc6c:	0001883a 	nop
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
			}
			#endif
			break;
8010fc70:	00003306 	br	8010fd40 <vQCmdFeeRMAPinStandBy+0x344>
			}
			#endif
				break;
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8010fc74:	e0bffa17 	ldw	r2,-24(fp)
8010fc78:	10803c0c 	andi	r2,r2,240
8010fc7c:	1004d13a 	srli	r2,r2,4
8010fc80:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8010fc84:	e0bffb17 	ldw	r2,-20(fp)
8010fc88:	10c000a0 	cmpeqi	r3,r2,2
8010fc8c:	1800041e 	bne	r3,zero,8010fca0 <vQCmdFeeRMAPinStandBy+0x2a4>
8010fc90:	10c001a0 	cmpeqi	r3,r2,6
8010fc94:	18000c1e 	bne	r3,zero,8010fcc8 <vQCmdFeeRMAPinStandBy+0x2cc>
8010fc98:	10000d26 	beq	r2,zero,8010fcd0 <vQCmdFeeRMAPinStandBy+0x2d4>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"- mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
8010fc9c:	00000d06 	br	8010fcd4 <vQCmdFeeRMAPinStandBy+0x2d8>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- to Full-Image-Pattern\n");
					}
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8010fca0:	e0bffe17 	ldw	r2,-8(fp)
8010fca4:	00c00044 	movi	r3,1
8010fca8:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8010fcac:	e0bffe17 	ldw	r2,-8(fp)
8010fcb0:	00c00284 	movi	r3,10
8010fcb4:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8010fcb8:	e0bffe17 	ldw	r2,-8(fp)
8010fcbc:	00c00304 	movi	r3,12
8010fcc0:	10c02d15 	stw	r3,180(r2)

					break;
8010fcc4:	00000306 	br	8010fcd4 <vQCmdFeeRMAPinStandBy+0x2d8>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- Off-Mode not allowed.\n");
					}
				#endif
					break;
8010fcc8:	0001883a 	nop
8010fccc:	00001c06 	br	8010fd40 <vQCmdFeeRMAPinStandBy+0x344>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"- already in Stand by mode\n");
					}
				#endif

					break;
8010fcd0:	0001883a 	nop
					}
					#endif
					break;
			}

			break;
8010fcd4:	00001a06 	br	8010fd40 <vQCmdFeeRMAPinStandBy+0x344>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8010fcd8:	e0bffa17 	ldw	r2,-24(fp)
8010fcdc:	1080010c 	andi	r2,r2,4
8010fce0:	1004d0ba 	srli	r2,r2,2
8010fce4:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8010fce8:	e0bffb17 	ldw	r2,-20(fp)
8010fcec:	10001326 	beq	r2,zero,8010fd3c <vQCmdFeeRMAPinStandBy+0x340>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
				}
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8010fcf0:	e0bffe17 	ldw	r2,-8(fp)
8010fcf4:	10804804 	addi	r2,r2,288
8010fcf8:	1009883a 	mov	r4,r2
8010fcfc:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8010fd00:	e0bffe17 	ldw	r2,-8(fp)
8010fd04:	10c06717 	ldw	r3,412(r2)
8010fd08:	00bffec4 	movi	r2,-5
8010fd0c:	1886703a 	and	r3,r3,r2
8010fd10:	e0bffe17 	ldw	r2,-8(fp)
8010fd14:	10c06715 	stw	r3,412(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8010fd18:	e0bffe17 	ldw	r2,-8(fp)
8010fd1c:	10804804 	addi	r2,r2,288
8010fd20:	1009883a 	mov	r4,r2
8010fd24:	010857c0 	call	8010857c <bRmapSetMemConfigArea>
			}

			break;
8010fd28:	00000406 	br	8010fd3c <vQCmdFeeRMAPinStandBy+0x340>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
8010fd2c:	0001883a 	nop
8010fd30:	00000306 	br	8010fd40 <vQCmdFeeRMAPinStandBy+0x344>
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8010fd34:	0001883a 	nop
8010fd38:	00000106 	br	8010fd40 <vQCmdFeeRMAPinStandBy+0x344>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8010fd3c:	0001883a 	nop
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
		}
}
8010fd40:	0001883a 	nop
8010fd44:	e037883a 	mov	sp,fp
8010fd48:	dfc00117 	ldw	ra,4(sp)
8010fd4c:	df000017 	ldw	fp,0(sp)
8010fd50:	dec00204 	addi	sp,sp,8
8010fd54:	f800283a 	ret

8010fd58 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
8010fd58:	defff804 	addi	sp,sp,-32
8010fd5c:	de00012e 	bgeu	sp,et,8010fd64 <vQCmdFeeRMAPinFullPattern+0xc>
8010fd60:	003b68fa 	trap	3
8010fd64:	dfc00715 	stw	ra,28(sp)
8010fd68:	df000615 	stw	fp,24(sp)
8010fd6c:	df000604 	addi	fp,sp,24
8010fd70:	e13ffe15 	stw	r4,-8(fp)
8010fd74:	e17fff15 	stw	r5,-4(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
8010fd78:	e0bfff17 	ldw	r2,-4(fp)
8010fd7c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8010fd80:	e0bffd43 	ldbu	r2,-11(fp)
8010fd84:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8010fd88:	e0bffe17 	ldw	r2,-8(fp)
8010fd8c:	10804817 	ldw	r2,288(r2)
8010fd90:	e0fffa03 	ldbu	r3,-24(fp)
8010fd94:	180b883a 	mov	r5,r3
8010fd98:	1009883a 	mov	r4,r2
8010fd9c:	010a7080 	call	8010a708 <uliRmapReadReg>
8010fda0:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8010fda4:	e0bffa03 	ldbu	r2,-24(fp)
8010fda8:	10bff004 	addi	r2,r2,-64
8010fdac:	10c003a8 	cmpgeui	r3,r2,14
8010fdb0:	1800821e 	bne	r3,zero,8010ffbc <vQCmdFeeRMAPinFullPattern+0x264>
8010fdb4:	100690ba 	slli	r3,r2,2
8010fdb8:	00a00474 	movhi	r2,32785
8010fdbc:	10bf7304 	addi	r2,r2,-564
8010fdc0:	1885883a 	add	r2,r3,r2
8010fdc4:	10800017 	ldw	r2,0(r2)
8010fdc8:	1000683a 	jmp	r2
8010fdcc:	8010fe04 	addi	zero,r16,17400
8010fdd0:	8010fe04 	addi	zero,r16,17400
8010fdd4:	8010fe04 	addi	zero,r16,17400
8010fdd8:	8010ffc4 	addi	zero,r16,17407
8010fddc:	8010ffc4 	addi	zero,r16,17407
8010fde0:	8010ffc4 	addi	zero,r16,17407
8010fde4:	8010ffc4 	addi	zero,r16,17407
8010fde8:	8010ffc4 	addi	zero,r16,17407
8010fdec:	8010ffc4 	addi	zero,r16,17407
8010fdf0:	8010ffc4 	addi	zero,r16,17407
8010fdf4:	8010ffc4 	addi	zero,r16,17407
8010fdf8:	8010ffc4 	addi	zero,r16,17407
8010fdfc:	8010fed4 	ori	zero,r16,17403
8010fe00:	8010ff70 	cmpltui	zero,r16,17405
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8010fe04:	e0bffe17 	ldw	r2,-8(fp)
8010fe08:	10802d17 	ldw	r2,180(r2)
8010fe0c:	108001e0 	cmpeqi	r2,r2,7
8010fe10:	1000041e 	bne	r2,zero,8010fe24 <vQCmdFeeRMAPinFullPattern+0xcc>
8010fe14:	e0bffe17 	ldw	r2,-8(fp)
8010fe18:	10802d17 	ldw	r2,180(r2)
8010fe1c:	10800318 	cmpnei	r2,r2,12
8010fe20:	10006a1e 	bne	r2,zero,8010ffcc <vQCmdFeeRMAPinFullPattern+0x274>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8010fe24:	e0bffa43 	ldbu	r2,-23(fp)
8010fe28:	1080030c 	andi	r2,r2,12
8010fe2c:	1005d0ba 	srai	r2,r2,2
8010fe30:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
8010fe34:	e0bffb17 	ldw	r2,-20(fp)
8010fe38:	10c000a0 	cmpeqi	r3,r2,2
8010fe3c:	1800071e 	bne	r3,zero,8010fe5c <vQCmdFeeRMAPinFullPattern+0x104>
8010fe40:	10c000e0 	cmpeqi	r3,r2,3
8010fe44:	1800091e 	bne	r3,zero,8010fe6c <vQCmdFeeRMAPinFullPattern+0x114>
8010fe48:	10800060 	cmpeqi	r2,r2,1
8010fe4c:	10000926 	beq	r2,zero,8010fe74 <vQCmdFeeRMAPinFullPattern+0x11c>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
8010fe50:	e0bffe17 	ldw	r2,-8(fp)
8010fe54:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
8010fe58:	00001706 	br	8010feb8 <vQCmdFeeRMAPinFullPattern+0x160>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
8010fe5c:	e0bffe17 	ldw	r2,-8(fp)
8010fe60:	00c00044 	movi	r3,1
8010fe64:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
8010fe68:	00001306 	br	8010feb8 <vQCmdFeeRMAPinFullPattern+0x160>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
8010fe6c:	e0bffe17 	ldw	r2,-8(fp)
8010fe70:	10002e15 	stw	zero,184(r2)
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
8010fe74:	e0bffe17 	ldw	r2,-8(fp)
8010fe78:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8010fe7c:	e0bffe17 	ldw	r2,-8(fp)
8010fe80:	10804804 	addi	r2,r2,288
8010fe84:	1009883a 	mov	r4,r2
8010fe88:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8010fe8c:	e0bffe17 	ldw	r2,-8(fp)
8010fe90:	10c05c17 	ldw	r3,368(r2)
8010fe94:	00bffdc4 	movi	r2,-9
8010fe98:	1886703a 	and	r3,r3,r2
8010fe9c:	e0bffe17 	ldw	r2,-8(fp)
8010fea0:	10c05c15 	stw	r3,368(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8010fea4:	e0bffe17 	ldw	r2,-8(fp)
8010fea8:	10804804 	addi	r2,r2,288
8010feac:	1009883a 	mov	r4,r2
8010feb0:	010857c0 	call	8010857c <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
8010feb4:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
8010feb8:	e0bffe17 	ldw	r2,-8(fp)
8010febc:	00c00284 	movi	r3,10
8010fec0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
8010fec4:	e0bffe17 	ldw	r2,-8(fp)
8010fec8:	00c00304 	movi	r3,12
8010fecc:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
8010fed0:	00003e06 	br	8010ffcc <vQCmdFeeRMAPinFullPattern+0x274>
			#endif
				break;

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8010fed4:	e0bffa43 	ldbu	r2,-23(fp)
8010fed8:	1004d13a 	srli	r2,r2,4
8010fedc:	10803fcc 	andi	r2,r2,255
8010fee0:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
8010fee4:	e0bffc17 	ldw	r2,-16(fp)
8010fee8:	10c000a0 	cmpeqi	r3,r2,2
8010feec:	18001c1e 	bne	r3,zero,8010ff60 <vQCmdFeeRMAPinFullPattern+0x208>
8010fef0:	10c001a0 	cmpeqi	r3,r2,6
8010fef4:	18001c1e 	bne	r3,zero,8010ff68 <vQCmdFeeRMAPinFullPattern+0x210>
8010fef8:	10000126 	beq	r2,zero,8010ff00 <vQCmdFeeRMAPinFullPattern+0x1a8>
					#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
					}
					#endif
					break;
8010fefc:	00001b06 	br	8010ff6c <vQCmdFeeRMAPinFullPattern+0x214>
					if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
						fprintf(fp,"- to Stand-By\n");
					}
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8010ff00:	e0bffe17 	ldw	r2,-8(fp)
8010ff04:	10802c17 	ldw	r2,176(r2)
8010ff08:	10800298 	cmpnei	r2,r2,10
8010ff0c:	10000a1e 	bne	r2,zero,8010ff38 <vQCmdFeeRMAPinFullPattern+0x1e0>
						pxNFeeP->xControl.bWatingSync = TRUE;
8010ff10:	e0bffe17 	ldw	r2,-8(fp)
8010ff14:	00c00044 	movi	r3,1
8010ff18:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
8010ff1c:	e0bffe17 	ldw	r2,-8(fp)
8010ff20:	00c00304 	movi	r3,12
8010ff24:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8010ff28:	e0bffe17 	ldw	r2,-8(fp)
8010ff2c:	00c00184 	movi	r3,6
8010ff30:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8010ff34:	00000d06 	br	8010ff6c <vQCmdFeeRMAPinFullPattern+0x214>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
8010ff38:	e0bffe17 	ldw	r2,-8(fp)
8010ff3c:	00c00044 	movi	r3,1
8010ff40:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8010ff44:	e0bffe17 	ldw	r2,-8(fp)
8010ff48:	00c00104 	movi	r3,4
8010ff4c:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8010ff50:	e0bffe17 	ldw	r2,-8(fp)
8010ff54:	00c00184 	movi	r3,6
8010ff58:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8010ff5c:	00000306 	br	8010ff6c <vQCmdFeeRMAPinFullPattern+0x214>
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
					}
					#endif

					break;
8010ff60:	0001883a 	nop
8010ff64:	00001c06 	br	8010ffd8 <vQCmdFeeRMAPinFullPattern+0x280>
				#if DEBUG_ON
					if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
						fprintf(fp," Off-Mode not allowed.\n");
					}
				#endif
					break;
8010ff68:	0001883a 	nop
					}
					#endif
					break;
			}

			break;
8010ff6c:	00001a06 	br	8010ffd8 <vQCmdFeeRMAPinFullPattern+0x280>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8010ff70:	e0bffa43 	ldbu	r2,-23(fp)
8010ff74:	1080010c 	andi	r2,r2,4
8010ff78:	10803fcc 	andi	r2,r2,255
8010ff7c:	1004d0ba 	srli	r2,r2,2
8010ff80:	10803fcc 	andi	r2,r2,255
8010ff84:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
8010ff88:	e0bffc17 	ldw	r2,-16(fp)
8010ff8c:	10001126 	beq	r2,zero,8010ffd4 <vQCmdFeeRMAPinFullPattern+0x27c>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8010ff90:	e0bffe17 	ldw	r2,-8(fp)
8010ff94:	10802d17 	ldw	r2,180(r2)
8010ff98:	10800198 	cmpnei	r2,r2,6
8010ff9c:	10000d1e 	bne	r2,zero,8010ffd4 <vQCmdFeeRMAPinFullPattern+0x27c>
					pxNFeeP->xControl.bWatingSync = FALSE;
8010ffa0:	e0bffe17 	ldw	r2,-8(fp)
8010ffa4:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8010ffa8:	e0bffe17 	ldw	r2,-8(fp)
8010ffac:	10c02d17 	ldw	r3,180(r2)
8010ffb0:	e0bffe17 	ldw	r2,-8(fp)
8010ffb4:	10c02c15 	stw	r3,176(r2)
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8010ffb8:	00000606 	br	8010ffd4 <vQCmdFeeRMAPinFullPattern+0x27c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
8010ffbc:	0001883a 	nop
8010ffc0:	00000506 	br	8010ffd8 <vQCmdFeeRMAPinFullPattern+0x280>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
				break;
8010ffc4:	0001883a 	nop
8010ffc8:	00000306 	br	8010ffd8 <vQCmdFeeRMAPinFullPattern+0x280>
				}
			}



			break;
8010ffcc:	0001883a 	nop
8010ffd0:	00000106 	br	8010ffd8 <vQCmdFeeRMAPinFullPattern+0x280>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8010ffd4:	0001883a 	nop
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
		}
}
8010ffd8:	0001883a 	nop
8010ffdc:	e037883a 	mov	sp,fp
8010ffe0:	dfc00117 	ldw	ra,4(sp)
8010ffe4:	df000017 	ldw	fp,0(sp)
8010ffe8:	dec00204 	addi	sp,sp,8
8010ffec:	f800283a 	ret

8010fff0 <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
8010fff0:	defff804 	addi	sp,sp,-32
8010fff4:	de00012e 	bgeu	sp,et,8010fffc <vQCmdFeeRMAPWaitingSync+0xc>
8010fff8:	003b68fa 	trap	3
8010fffc:	dfc00715 	stw	ra,28(sp)
80110000:	df000615 	stw	fp,24(sp)
80110004:	df000604 	addi	fp,sp,24
80110008:	e13ffe15 	stw	r4,-8(fp)
8011000c:	e17fff15 	stw	r5,-4(fp)
	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
	}
	#endif

	uiCmdFEEL.ulWord = cmd;
80110010:	e0bfff17 	ldw	r2,-4(fp)
80110014:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
80110018:	e0bffd43 	ldbu	r2,-11(fp)
8011001c:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
80110020:	e0bffe17 	ldw	r2,-8(fp)
80110024:	10804817 	ldw	r2,288(r2)
80110028:	e0fffa03 	ldbu	r3,-24(fp)
8011002c:	180b883a 	mov	r5,r3
80110030:	1009883a 	mov	r4,r2
80110034:	010a7080 	call	8010a708 <uliRmapReadReg>
80110038:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8011003c:	e0bffa03 	ldbu	r2,-24(fp)
80110040:	10c010c8 	cmpgei	r3,r2,67
80110044:	1800051e 	bne	r3,zero,8011005c <vQCmdFeeRMAPWaitingSync+0x6c>
80110048:	10c01008 	cmpgei	r3,r2,64
8011004c:	1800081e 	bne	r3,zero,80110070 <vQCmdFeeRMAPWaitingSync+0x80>
80110050:	108000a0 	cmpeqi	r2,r2,2
80110054:	10005b1e 	bne	r2,zero,801101c4 <vQCmdFeeRMAPWaitingSync+0x1d4>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
80110058:	00007a06 	br	80110244 <vQCmdFeeRMAPWaitingSync+0x254>

	ucADDRReg = uiCmdFEEL.ucByte[1];
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);


	switch (ucADDRReg) {
8011005c:	10c01350 	cmplti	r3,r2,77
80110060:	1800371e 	bne	r3,zero,80110140 <vQCmdFeeRMAPWaitingSync+0x150>
80110064:	10801360 	cmpeqi	r2,r2,77
80110068:	1000601e 	bne	r2,zero,801101ec <vQCmdFeeRMAPWaitingSync+0x1fc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
8011006c:	00007506 	br	80110244 <vQCmdFeeRMAPWaitingSync+0x254>
	switch (ucADDRReg) {
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
80110070:	e0bffe17 	ldw	r2,-8(fp)
80110074:	10802d17 	ldw	r2,180(r2)
80110078:	108001e0 	cmpeqi	r2,r2,7
8011007c:	1000041e 	bne	r2,zero,80110090 <vQCmdFeeRMAPWaitingSync+0xa0>
80110080:	e0bffe17 	ldw	r2,-8(fp)
80110084:	10802d17 	ldw	r2,180(r2)
80110088:	10800318 	cmpnei	r2,r2,12
8011008c:	10006a1e 	bne	r2,zero,80110238 <vQCmdFeeRMAPWaitingSync+0x248>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
80110090:	e0bffa43 	ldbu	r2,-23(fp)
80110094:	1080030c 	andi	r2,r2,12
80110098:	1005d0ba 	srai	r2,r2,2
8011009c:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
801100a0:	e0bffb17 	ldw	r2,-20(fp)
801100a4:	10c000a0 	cmpeqi	r3,r2,2
801100a8:	1800071e 	bne	r3,zero,801100c8 <vQCmdFeeRMAPWaitingSync+0xd8>
801100ac:	10c000e0 	cmpeqi	r3,r2,3
801100b0:	1800091e 	bne	r3,zero,801100d8 <vQCmdFeeRMAPWaitingSync+0xe8>
801100b4:	10800060 	cmpeqi	r2,r2,1
801100b8:	10000926 	beq	r2,zero,801100e0 <vQCmdFeeRMAPWaitingSync+0xf0>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
801100bc:	e0bffe17 	ldw	r2,-8(fp)
801100c0:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Left side\n");
						}
						#endif
						break;
801100c4:	00001706 	br	80110124 <vQCmdFeeRMAPWaitingSync+0x134>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
801100c8:	e0bffe17 	ldw	r2,-8(fp)
801100cc:	00c00044 	movi	r3,1
801100d0:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Right side\n");
						}
						#endif
						break;
801100d4:	00001306 	br	80110124 <vQCmdFeeRMAPWaitingSync+0x134>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
801100d8:	e0bffe17 	ldw	r2,-8(fp)
801100dc:	10002e15 	stw	zero,184(r2)
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
						}
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
801100e0:	e0bffe17 	ldw	r2,-8(fp)
801100e4:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
801100e8:	e0bffe17 	ldw	r2,-8(fp)
801100ec:	10804804 	addi	r2,r2,288
801100f0:	1009883a 	mov	r4,r2
801100f4:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
801100f8:	e0bffe17 	ldw	r2,-8(fp)
801100fc:	10c05c17 	ldw	r3,368(r2)
80110100:	00bffdc4 	movi	r2,-9
80110104:	1886703a 	and	r3,r3,r2
80110108:	e0bffe17 	ldw	r2,-8(fp)
8011010c:	10c05c15 	stw	r3,368(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
80110110:	e0bffe17 	ldw	r2,-8(fp)
80110114:	10804804 	addi	r2,r2,288
80110118:	1009883a 	mov	r4,r2
8011011c:	010857c0 	call	8010857c <bRmapSetMemConfigArea>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
							fprintf(fp," - Switching to Left side\n");
						}
						#endif
					break;
80110120:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
				}
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
80110124:	e0bffe17 	ldw	r2,-8(fp)
80110128:	00c00284 	movi	r3,10
8011012c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
80110130:	e0bffe17 	ldw	r2,-8(fp)
80110134:	00c00304 	movi	r3,12
80110138:	10c02d15 	stw	r3,180(r2)
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
8011013c:	00003e06 	br	80110238 <vQCmdFeeRMAPWaitingSync+0x248>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
80110140:	e0bffa43 	ldbu	r2,-23(fp)
80110144:	1004d13a 	srli	r2,r2,4
80110148:	10803fcc 	andi	r2,r2,255
8011014c:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
80110150:	e0bffc17 	ldw	r2,-16(fp)
80110154:	10c000a0 	cmpeqi	r3,r2,2
80110158:	18000e1e 	bne	r3,zero,80110194 <vQCmdFeeRMAPWaitingSync+0x1a4>
8011015c:	10c001a0 	cmpeqi	r3,r2,6
80110160:	1800161e 	bne	r3,zero,801101bc <vQCmdFeeRMAPWaitingSync+0x1cc>
80110164:	10000126 	beq	r2,zero,8011016c <vQCmdFeeRMAPWaitingSync+0x17c>
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," mode not allowed yet ( %lu )\n", ucValueMasked);
				}
				#endif
				break;
80110168:	00001506 	br	801101c0 <vQCmdFeeRMAPWaitingSync+0x1d0>
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"- to Stand-By\n");
				}
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
8011016c:	e0bffe17 	ldw	r2,-8(fp)
80110170:	00c00044 	movi	r3,1
80110174:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
80110178:	e0bffe17 	ldw	r2,-8(fp)
8011017c:	00c00304 	movi	r3,12
80110180:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
80110184:	e0bffe17 	ldw	r2,-8(fp)
80110188:	00c00184 	movi	r3,6
8011018c:	10c02d15 	stw	r3,180(r2)


				break;
80110190:	00000b06 	br	801101c0 <vQCmdFeeRMAPWaitingSync+0x1d0>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
80110194:	e0bffe17 	ldw	r2,-8(fp)
80110198:	00c00044 	movi	r3,1
8011019c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
801101a0:	e0bffe17 	ldw	r2,-8(fp)
801101a4:	00c00304 	movi	r3,12
801101a8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
801101ac:	e0bffe17 	ldw	r2,-8(fp)
801101b0:	00c00284 	movi	r3,10
801101b4:	10c02d15 	stw	r3,180(r2)

				break;
801101b8:	00000106 	br	801101c0 <vQCmdFeeRMAPWaitingSync+0x1d0>
			#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp," Off-Mode not allowed.\n");
				}
			#endif
				break;
801101bc:	0001883a 	nop
				}
				#endif
				break;
		}

			break;
801101c0:	00002006 	br	80110244 <vQCmdFeeRMAPWaitingSync+0x254>
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
			}
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
801101c4:	e0bffe17 	ldw	r2,-8(fp)
801101c8:	00c00044 	movi	r3,1
801101cc:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
801101d0:	e0bffe17 	ldw	r2,-8(fp)
801101d4:	00c00284 	movi	r3,10
801101d8:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
801101dc:	e0bffe17 	ldw	r2,-8(fp)
801101e0:	00c00304 	movi	r3,12
801101e4:	10c02d15 	stw	r3,180(r2)

			break;
801101e8:	00001606 	br	80110244 <vQCmdFeeRMAPWaitingSync+0x254>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
801101ec:	e0bffa43 	ldbu	r2,-23(fp)
801101f0:	1080010c 	andi	r2,r2,4
801101f4:	10803fcc 	andi	r2,r2,255
801101f8:	1004d0ba 	srli	r2,r2,2
801101fc:	10803fcc 	andi	r2,r2,255
80110200:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
80110204:	e0bffc17 	ldw	r2,-16(fp)
80110208:	10000d26 	beq	r2,zero,80110240 <vQCmdFeeRMAPWaitingSync+0x250>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8011020c:	e0bffe17 	ldw	r2,-8(fp)
80110210:	10802d17 	ldw	r2,180(r2)
80110214:	10800198 	cmpnei	r2,r2,6
80110218:	1000091e 	bne	r2,zero,80110240 <vQCmdFeeRMAPWaitingSync+0x250>
					pxNFeeP->xControl.bWatingSync = FALSE;
8011021c:	e0bffe17 	ldw	r2,-8(fp)
80110220:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
80110224:	e0bffe17 	ldw	r2,-8(fp)
80110228:	10c02d17 	ldw	r3,180(r2)
8011022c:	e0bffe17 	ldw	r2,-8(fp)
80110230:	10c02c15 	stw	r3,176(r2)
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
80110234:	00000206 	br	80110240 <vQCmdFeeRMAPWaitingSync+0x250>
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					}
					#endif
				}
			}
			break;
80110238:	0001883a 	nop
8011023c:	00000106 	br	80110244 <vQCmdFeeRMAPWaitingSync+0x254>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
80110240:	0001883a 	nop
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			}
			#endif
			break;
		}
}
80110244:	0001883a 	nop
80110248:	e037883a 	mov	sp,fp
8011024c:	dfc00117 	ldw	ra,4(sp)
80110250:	df000017 	ldw	fp,0(sp)
80110254:	dec00204 	addi	sp,sp,8
80110258:	f800283a 	ret

8011025c <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
8011025c:	defffc04 	addi	sp,sp,-16
80110260:	de00012e 	bgeu	sp,et,80110268 <bDisableRmapIRQ+0xc>
80110264:	003b68fa 	trap	3
80110268:	dfc00315 	stw	ra,12(sp)
8011026c:	df000215 	stw	fp,8(sp)
80110270:	df000204 	addi	fp,sp,8
80110274:	e13ffe15 	stw	r4,-8(fp)
80110278:	2805883a 	mov	r2,r5
8011027c:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
80110280:	e13ffe17 	ldw	r4,-8(fp)
80110284:	01080440 	call	80108044 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
80110288:	e0bffe17 	ldw	r2,-8(fp)
8011028c:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
80110290:	e13ffe17 	ldw	r4,-8(fp)
80110294:	0107f980 	call	80107f98 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
80110298:	00800044 	movi	r2,1
}
8011029c:	e037883a 	mov	sp,fp
801102a0:	dfc00117 	ldw	ra,4(sp)
801102a4:	df000017 	ldw	fp,0(sp)
801102a8:	dec00204 	addi	sp,sp,8
801102ac:	f800283a 	ret

801102b0 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
801102b0:	defffc04 	addi	sp,sp,-16
801102b4:	de00012e 	bgeu	sp,et,801102bc <bEnableRmapIRQ+0xc>
801102b8:	003b68fa 	trap	3
801102bc:	dfc00315 	stw	ra,12(sp)
801102c0:	df000215 	stw	fp,8(sp)
801102c4:	df000204 	addi	fp,sp,8
801102c8:	e13ffe15 	stw	r4,-8(fp)
801102cc:	2805883a 	mov	r2,r5
801102d0:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
801102d4:	e13ffe17 	ldw	r4,-8(fp)
801102d8:	01080440 	call	80108044 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
801102dc:	e0bffe17 	ldw	r2,-8(fp)
801102e0:	00c00044 	movi	r3,1
801102e4:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
801102e8:	e13ffe17 	ldw	r4,-8(fp)
801102ec:	0107f980 	call	80107f98 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
801102f0:	00800044 	movi	r2,1
}
801102f4:	e037883a 	mov	sp,fp
801102f8:	dfc00117 	ldw	ra,4(sp)
801102fc:	df000017 	ldw	fp,0(sp)
80110300:	dec00204 	addi	sp,sp,8
80110304:	f800283a 	ret

80110308 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
80110308:	defffd04 	addi	sp,sp,-12
8011030c:	de00012e 	bgeu	sp,et,80110314 <bDisableSPWChannel+0xc>
80110310:	003b68fa 	trap	3
80110314:	dfc00215 	stw	ra,8(sp)
80110318:	df000115 	stw	fp,4(sp)
8011031c:	df000104 	addi	fp,sp,4
80110320:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
80110324:	e13fff17 	ldw	r4,-4(fp)
80110328:	010aaf80 	call	8010aaf8 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8011032c:	e0bfff17 	ldw	r2,-4(fp)
80110330:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
80110334:	e0bfff17 	ldw	r2,-4(fp)
80110338:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8011033c:	e0bfff17 	ldw	r2,-4(fp)
80110340:	00c00044 	movi	r3,1
80110344:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
80110348:	e13fff17 	ldw	r4,-4(fp)
8011034c:	010a9c00 	call	8010a9c0 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
80110350:	00800044 	movi	r2,1
}
80110354:	e037883a 	mov	sp,fp
80110358:	dfc00117 	ldw	ra,4(sp)
8011035c:	df000017 	ldw	fp,0(sp)
80110360:	dec00204 	addi	sp,sp,8
80110364:	f800283a 	ret

80110368 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
80110368:	defffd04 	addi	sp,sp,-12
8011036c:	de00012e 	bgeu	sp,et,80110374 <bEnableSPWChannel+0xc>
80110370:	003b68fa 	trap	3
80110374:	dfc00215 	stw	ra,8(sp)
80110378:	df000115 	stw	fp,4(sp)
8011037c:	df000104 	addi	fp,sp,4
80110380:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
80110384:	e13fff17 	ldw	r4,-4(fp)
80110388:	010aaf80 	call	8010aaf8 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8011038c:	e0bfff17 	ldw	r2,-4(fp)
80110390:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
80110394:	e0bfff17 	ldw	r2,-4(fp)
80110398:	00c00044 	movi	r3,1
8011039c:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
801103a0:	e0bfff17 	ldw	r2,-4(fp)
801103a4:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
801103a8:	e13fff17 	ldw	r4,-4(fp)
801103ac:	010a9c00 	call	8010a9c0 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
801103b0:	00800044 	movi	r2,1
}
801103b4:	e037883a 	mov	sp,fp
801103b8:	dfc00117 	ldw	ra,4(sp)
801103bc:	df000017 	ldw	fp,0(sp)
801103c0:	dec00204 	addi	sp,sp,8
801103c4:	f800283a 	ret

801103c8 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
801103c8:	defffd04 	addi	sp,sp,-12
801103cc:	de00012e 	bgeu	sp,et,801103d4 <bEnableDbBuffer+0xc>
801103d0:	003b68fa 	trap	3
801103d4:	dfc00215 	stw	ra,8(sp)
801103d8:	df000115 	stw	fp,4(sp)
801103dc:	df000104 	addi	fp,sp,4
801103e0:	e13fff15 	stw	r4,-4(fp)
	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
801103e4:	e13fff17 	ldw	r4,-4(fp)
801103e8:	0106f900 	call	80106f90 <bFeebStopCh>
	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
801103ec:	e13fff17 	ldw	r4,-4(fp)
801103f0:	010701c0 	call	8010701c <bFeebClrCh>
	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
801103f4:	e13fff17 	ldw	r4,-4(fp)
801103f8:	0106f040 	call	80106f04 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
801103fc:	e13fff17 	ldw	r4,-4(fp)
80110400:	0106e7c0 	call	80106e7c <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
80110404:	00a005b4 	movhi	r2,32790
80110408:	10ba3604 	addi	r2,r2,-5928
8011040c:	10c00417 	ldw	r3,16(r2)
80110410:	e0bfff17 	ldw	r2,-4(fp)
80110414:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
80110418:	e13fff17 	ldw	r4,-4(fp)
8011041c:	0106dd00 	call	80106dd0 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
80110420:	e13fff17 	ldw	r4,-4(fp)
80110424:	01056a40 	call	801056a4 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
80110428:	e0bfff17 	ldw	r2,-4(fp)
8011042c:	00c00044 	movi	r3,1
80110430:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
80110434:	e0bfff17 	ldw	r2,-4(fp)
80110438:	00c00044 	movi	r3,1
8011043c:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
80110440:	e13fff17 	ldw	r4,-4(fp)
80110444:	01055cc0 	call	801055cc <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
80110448:	00800044 	movi	r2,1
}
8011044c:	e037883a 	mov	sp,fp
80110450:	dfc00117 	ldw	ra,4(sp)
80110454:	df000017 	ldw	fp,0(sp)
80110458:	dec00204 	addi	sp,sp,8
8011045c:	f800283a 	ret

80110460 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
80110460:	defffd04 	addi	sp,sp,-12
80110464:	de00012e 	bgeu	sp,et,8011046c <bDisAndClrDbBuffer+0xc>
80110468:	003b68fa 	trap	3
8011046c:	dfc00215 	stw	ra,8(sp)
80110470:	df000115 	stw	fp,4(sp)
80110474:	df000104 	addi	fp,sp,4
80110478:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8011047c:	e13fff17 	ldw	r4,-4(fp)
80110480:	01056a40 	call	801056a4 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
80110484:	e0bfff17 	ldw	r2,-4(fp)
80110488:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8011048c:	e0bfff17 	ldw	r2,-4(fp)
80110490:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
80110494:	e13fff17 	ldw	r4,-4(fp)
80110498:	01055cc0 	call	801055cc <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8011049c:	e13fff17 	ldw	r4,-4(fp)
801104a0:	0106f900 	call	80106f90 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
801104a4:	e13fff17 	ldw	r4,-4(fp)
801104a8:	010701c0 	call	8010701c <bFeebClrCh>
	bFeebStartCh(pxFeebCh);
801104ac:	e13fff17 	ldw	r4,-4(fp)
801104b0:	0106f040 	call	80106f04 <bFeebStartCh>

	/*todo: No treatment for now  */
	return TRUE;
801104b4:	00800044 	movi	r2,1
}
801104b8:	e037883a 	mov	sp,fp
801104bc:	dfc00117 	ldw	ra,4(sp)
801104c0:	df000017 	ldw	fp,0(sp)
801104c4:	dec00204 	addi	sp,sp,8
801104c8:	f800283a 	ret

801104cc <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
801104cc:	defff804 	addi	sp,sp,-32
801104d0:	de00012e 	bgeu	sp,et,801104d8 <bSendRequestNFeeCtrl+0xc>
801104d4:	003b68fa 	trap	3
801104d8:	dfc00715 	stw	ra,28(sp)
801104dc:	df000615 	stw	fp,24(sp)
801104e0:	df000604 	addi	fp,sp,24
801104e4:	2807883a 	mov	r3,r5
801104e8:	3005883a 	mov	r2,r6
801104ec:	e13ffd05 	stb	r4,-12(fp)
801104f0:	e0fffe05 	stb	r3,-8(fp)
801104f4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
801104f8:	00800404 	movi	r2,16
801104fc:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
80110500:	e0bffd03 	ldbu	r2,-12(fp)
80110504:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
80110508:	e0bffe03 	ldbu	r2,-8(fp)
8011050c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
80110510:	e0bfff03 	ldbu	r2,-4(fp)
80110514:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
80110518:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8011051c:	d0a06817 	ldw	r2,-32352(gp)
80110520:	e0fffc17 	ldw	r3,-16(fp)
80110524:	180b883a 	mov	r5,r3
80110528:	1009883a 	mov	r4,r2
8011052c:	013940c0 	call	8013940c <OSQPost>
80110530:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
80110534:	e0bffb03 	ldbu	r2,-20(fp)
80110538:	10000526 	beq	r2,zero,80110550 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8011053c:	e0bfff03 	ldbu	r2,-4(fp)
80110540:	1009883a 	mov	r4,r2
80110544:	011da080 	call	8011da08 <vFailRequestDMA>
		bSuccesL = FALSE;
80110548:	e03ffa15 	stw	zero,-24(fp)
8011054c:	00000206 	br	80110558 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
80110550:	00800044 	movi	r2,1
80110554:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
80110558:	e0bffa17 	ldw	r2,-24(fp)
}
8011055c:	e037883a 	mov	sp,fp
80110560:	dfc00117 	ldw	ra,4(sp)
80110564:	df000017 	ldw	fp,0(sp)
80110568:	dec00204 	addi	sp,sp,8
8011056c:	f800283a 	ret

80110570 <bSendRequestNFeeCtrl_Front>:

bool bSendRequestNFeeCtrl_Front( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80110570:	defff804 	addi	sp,sp,-32
80110574:	de00012e 	bgeu	sp,et,8011057c <bSendRequestNFeeCtrl_Front+0xc>
80110578:	003b68fa 	trap	3
8011057c:	dfc00715 	stw	ra,28(sp)
80110580:	df000615 	stw	fp,24(sp)
80110584:	df000604 	addi	fp,sp,24
80110588:	2807883a 	mov	r3,r5
8011058c:	3005883a 	mov	r2,r6
80110590:	e13ffd05 	stb	r4,-12(fp)
80110594:	e0fffe05 	stb	r3,-8(fp)
80110598:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8011059c:	00800404 	movi	r2,16
801105a0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
801105a4:	e0bffd03 	ldbu	r2,-12(fp)
801105a8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
801105ac:	e0bffe03 	ldbu	r2,-8(fp)
801105b0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
801105b4:	e0bfff03 	ldbu	r2,-4(fp)
801105b8:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
801105bc:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPostFront(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
801105c0:	d0a06817 	ldw	r2,-32352(gp)
801105c4:	e0fffc17 	ldw	r3,-16(fp)
801105c8:	180b883a 	mov	r5,r3
801105cc:	1009883a 	mov	r4,r2
801105d0:	013957c0 	call	8013957c <OSQPostFront>
801105d4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
801105d8:	e0bffb03 	ldbu	r2,-20(fp)
801105dc:	10000526 	beq	r2,zero,801105f4 <bSendRequestNFeeCtrl_Front+0x84>
		vFailRequestDMA( ucValue );
801105e0:	e0bfff03 	ldbu	r2,-4(fp)
801105e4:	1009883a 	mov	r4,r2
801105e8:	011da080 	call	8011da08 <vFailRequestDMA>
		bSuccesL = FALSE;
801105ec:	e03ffa15 	stw	zero,-24(fp)
801105f0:	00000206 	br	801105fc <bSendRequestNFeeCtrl_Front+0x8c>
	} else {
		bSuccesL =  TRUE;
801105f4:	00800044 	movi	r2,1
801105f8:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
801105fc:	e0bffa17 	ldw	r2,-24(fp)
}
80110600:	e037883a 	mov	sp,fp
80110604:	dfc00117 	ldw	ra,4(sp)
80110608:	df000017 	ldw	fp,0(sp)
8011060c:	dec00204 	addi	sp,sp,8
80110610:	f800283a 	ret

80110614 <bSendGiveBackNFeeCtrl>:

bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80110614:	defff804 	addi	sp,sp,-32
80110618:	de00012e 	bgeu	sp,et,80110620 <bSendGiveBackNFeeCtrl+0xc>
8011061c:	003b68fa 	trap	3
80110620:	dfc00715 	stw	ra,28(sp)
80110624:	df000615 	stw	fp,24(sp)
80110628:	df000604 	addi	fp,sp,24
8011062c:	2807883a 	mov	r3,r5
80110630:	3005883a 	mov	r2,r6
80110634:	e13ffd05 	stb	r4,-12(fp)
80110638:	e0fffe05 	stb	r3,-8(fp)
8011063c:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
80110640:	00800404 	movi	r2,16
80110644:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
80110648:	e0bffd03 	ldbu	r2,-12(fp)
8011064c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
80110650:	e0bffe03 	ldbu	r2,-8(fp)
80110654:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
80110658:	e0bfff03 	ldbu	r2,-4(fp)
8011065c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
80110660:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
80110664:	d0a07917 	ldw	r2,-32284(gp)
80110668:	e0fffc17 	ldw	r3,-16(fp)
8011066c:	180b883a 	mov	r5,r3
80110670:	1009883a 	mov	r4,r2
80110674:	013940c0 	call	8013940c <OSQPost>
80110678:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8011067c:	e0bffb03 	ldbu	r2,-20(fp)
80110680:	10000526 	beq	r2,zero,80110698 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
80110684:	e0bfff03 	ldbu	r2,-4(fp)
80110688:	1009883a 	mov	r4,r2
8011068c:	011da080 	call	8011da08 <vFailRequestDMA>
		bSuccesL = FALSE;
80110690:	e03ffa15 	stw	zero,-24(fp)
80110694:	00000206 	br	801106a0 <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
80110698:	00800044 	movi	r2,1
8011069c:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
801106a0:	e0bffa17 	ldw	r2,-24(fp)
}
801106a4:	e037883a 	mov	sp,fp
801106a8:	dfc00117 	ldw	ra,4(sp)
801106ac:	df000017 	ldw	fp,0(sp)
801106b0:	dec00204 	addi	sp,sp,8
801106b4:	f800283a 	ret

801106b8 <bPrepareDoubleBuffer>:
		fprintf(fp,"\n");
	}
#endif


bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID, TNFee *pxNFee, unsigned char ucSide ) {
801106b8:	defff704 	addi	sp,sp,-36
801106bc:	de00012e 	bgeu	sp,et,801106c4 <bPrepareDoubleBuffer+0xc>
801106c0:	003b68fa 	trap	3
801106c4:	dfc00815 	stw	ra,32(sp)
801106c8:	df000715 	stw	fp,28(sp)
801106cc:	df000704 	addi	fp,sp,28
801106d0:	e13ffb15 	stw	r4,-20(fp)
801106d4:	2809883a 	mov	r4,r5
801106d8:	3007883a 	mov	r3,r6
801106dc:	e1fffe15 	stw	r7,-8(fp)
801106e0:	e0800217 	ldw	r2,8(fp)
801106e4:	e13ffc05 	stb	r4,-16(fp)
801106e8:	e0fffd05 	stb	r3,-12(fp)
801106ec:	e0bfff05 	stb	r2,-4(fp)
	bool  bDmaReturn;
	unsigned long ulLengthBlocks;

	bDmaReturn = FALSE;
801106f0:	e03ff915 	stw	zero,-28(fp)
	xCcdMapLocal->ulBlockI = 0;
801106f4:	e0bffb17 	ldw	r2,-20(fp)
801106f8:	10000115 	stw	zero,4(r2)
	xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
801106fc:	e0bffb17 	ldw	r2,-20(fp)
80110700:	10c00017 	ldw	r3,0(r2)
80110704:	e0bffb17 	ldw	r2,-20(fp)
80110708:	10c00215 	stw	r3,8(r2)


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8011070c:	e0bffb17 	ldw	r2,-20(fp)
80110710:	10800117 	ldw	r2,4(r2)
80110714:	10c00404 	addi	r3,r2,16
80110718:	e0bffe17 	ldw	r2,-8(fp)
8011071c:	10800417 	ldw	r2,16(r2)
80110720:	18800736 	bltu	r3,r2,80110740 <bPrepareDoubleBuffer+0x88>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
80110724:	e0bffe17 	ldw	r2,-8(fp)
80110728:	10c00417 	ldw	r3,16(r2)
8011072c:	e0bffb17 	ldw	r2,-20(fp)
80110730:	10800117 	ldw	r2,4(r2)
80110734:	1885c83a 	sub	r2,r3,r2
80110738:	e0bffa15 	stw	r2,-24(fp)
8011073c:	00000206 	br	80110748 <bPrepareDoubleBuffer+0x90>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
80110740:	00800404 	movi	r2,16
80110744:	e0bffa15 	stw	r2,-24(fp)
	}

	vSetDoubleBufferLeftSize( (unsigned char)ulLengthBlocks, pxNFee->ucSPWId);
80110748:	e0bffa17 	ldw	r2,-24(fp)
8011074c:	10c03fcc 	andi	r3,r2,255
80110750:	e0bffe17 	ldw	r2,-8(fp)
80110754:	10800043 	ldbu	r2,1(r2)
80110758:	10803fcc 	andi	r2,r2,255
8011075c:	100b883a 	mov	r5,r2
80110760:	1809883a 	mov	r4,r3
80110764:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
	vSetDoubleBufferRightSize( (unsigned char)ulLengthBlocks, pxNFee->ucSPWId );
80110768:	e0bffa17 	ldw	r2,-24(fp)
8011076c:	10c03fcc 	andi	r3,r2,255
80110770:	e0bffe17 	ldw	r2,-8(fp)
80110774:	10800043 	ldbu	r2,1(r2)
80110778:	10803fcc 	andi	r2,r2,255
8011077c:	100b883a 	mov	r5,r2
80110780:	1809883a 	mov	r4,r3
80110784:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
	}*/

	if (  ucMem == 0  ) {
80110788:	e0bffc03 	ldbu	r2,-16(fp)
8011078c:	1000221e 	bne	r2,zero,80110818 <bPrepareDoubleBuffer+0x160>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucSide, pxNFee->ucSPWId);
80110790:	e0bffb17 	ldw	r2,-20(fp)
80110794:	10800217 	ldw	r2,8(r2)
80110798:	1011883a 	mov	r8,r2
8011079c:	e0bffa17 	ldw	r2,-24(fp)
801107a0:	10ffffcc 	andi	r3,r2,65535
801107a4:	e13fff03 	ldbu	r4,-4(fp)
801107a8:	e0bffe17 	ldw	r2,-8(fp)
801107ac:	10800043 	ldbu	r2,1(r2)
801107b0:	10803fcc 	andi	r2,r2,255
801107b4:	100f883a 	mov	r7,r2
801107b8:	200d883a 	mov	r6,r4
801107bc:	180b883a 	mov	r5,r3
801107c0:	4009883a 	mov	r4,r8
801107c4:	0101fd00 	call	80101fd0 <bSdmaDmaM1Transfer>
801107c8:	e0bff915 	stw	r2,-28(fp)
		if ( bDmaReturn == TRUE ) {
801107cc:	e0bff917 	ldw	r2,-28(fp)
801107d0:	10800058 	cmpnei	r2,r2,1
801107d4:	10000e1e 	bne	r2,zero,80110810 <bPrepareDoubleBuffer+0x158>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
801107d8:	e0bffb17 	ldw	r2,-20(fp)
801107dc:	10c00217 	ldw	r3,8(r2)
801107e0:	e0bffa17 	ldw	r2,-24(fp)
801107e4:	10802224 	muli	r2,r2,136
801107e8:	1887883a 	add	r3,r3,r2
801107ec:	e0bffb17 	ldw	r2,-20(fp)
801107f0:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
801107f4:	e0bffb17 	ldw	r2,-20(fp)
801107f8:	10c00117 	ldw	r3,4(r2)
801107fc:	e0bffa17 	ldw	r2,-24(fp)
80110800:	1887883a 	add	r3,r3,r2
80110804:	e0bffb17 	ldw	r2,-20(fp)
80110808:	10c00115 	stw	r3,4(r2)
8011080c:	00002406 	br	801108a0 <bPrepareDoubleBuffer+0x1e8>
		} else
			return bDmaReturn;
80110810:	e0bff917 	ldw	r2,-28(fp)
80110814:	00008806 	br	80110a38 <bPrepareDoubleBuffer+0x380>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucSide, pxNFee->ucSPWId);
80110818:	e0bffb17 	ldw	r2,-20(fp)
8011081c:	10800217 	ldw	r2,8(r2)
80110820:	1011883a 	mov	r8,r2
80110824:	e0bffa17 	ldw	r2,-24(fp)
80110828:	10ffffcc 	andi	r3,r2,65535
8011082c:	e13fff03 	ldbu	r4,-4(fp)
80110830:	e0bffe17 	ldw	r2,-8(fp)
80110834:	10800043 	ldbu	r2,1(r2)
80110838:	10803fcc 	andi	r2,r2,255
8011083c:	100f883a 	mov	r7,r2
80110840:	200d883a 	mov	r6,r4
80110844:	180b883a 	mov	r5,r3
80110848:	4009883a 	mov	r4,r8
8011084c:	01024540 	call	80102454 <bSdmaDmaM2Transfer>
80110850:	e0bff915 	stw	r2,-28(fp)
		if ( bDmaReturn == TRUE ) {
80110854:	e0bff917 	ldw	r2,-28(fp)
80110858:	10800058 	cmpnei	r2,r2,1
8011085c:	10000e1e 	bne	r2,zero,80110898 <bPrepareDoubleBuffer+0x1e0>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
80110860:	e0bffb17 	ldw	r2,-20(fp)
80110864:	10c00217 	ldw	r3,8(r2)
80110868:	e0bffa17 	ldw	r2,-24(fp)
8011086c:	10802224 	muli	r2,r2,136
80110870:	1887883a 	add	r3,r3,r2
80110874:	e0bffb17 	ldw	r2,-20(fp)
80110878:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
8011087c:	e0bffb17 	ldw	r2,-20(fp)
80110880:	10c00117 	ldw	r3,4(r2)
80110884:	e0bffa17 	ldw	r2,-24(fp)
80110888:	1887883a 	add	r3,r3,r2
8011088c:	e0bffb17 	ldw	r2,-20(fp)
80110890:	10c00115 	stw	r3,4(r2)
80110894:	00000206 	br	801108a0 <bPrepareDoubleBuffer+0x1e8>
		} else
			return bDmaReturn;
80110898:	e0bff917 	ldw	r2,-28(fp)
8011089c:	00006606 	br	80110a38 <bPrepareDoubleBuffer+0x380>
	}


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
801108a0:	e0bffb17 	ldw	r2,-20(fp)
801108a4:	10800117 	ldw	r2,4(r2)
801108a8:	10c00404 	addi	r3,r2,16
801108ac:	e0bffe17 	ldw	r2,-8(fp)
801108b0:	10800417 	ldw	r2,16(r2)
801108b4:	18800736 	bltu	r3,r2,801108d4 <bPrepareDoubleBuffer+0x21c>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
801108b8:	e0bffe17 	ldw	r2,-8(fp)
801108bc:	10c00417 	ldw	r3,16(r2)
801108c0:	e0bffb17 	ldw	r2,-20(fp)
801108c4:	10800117 	ldw	r2,4(r2)
801108c8:	1885c83a 	sub	r2,r3,r2
801108cc:	e0bffa15 	stw	r2,-24(fp)
801108d0:	00000206 	br	801108dc <bPrepareDoubleBuffer+0x224>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
801108d4:	00800404 	movi	r2,16
801108d8:	e0bffa15 	stw	r2,-24(fp)
	}

	vSetDoubleBufferLeftSize( (unsigned char)ulLengthBlocks, pxNFee->ucSPWId );
801108dc:	e0bffa17 	ldw	r2,-24(fp)
801108e0:	10c03fcc 	andi	r3,r2,255
801108e4:	e0bffe17 	ldw	r2,-8(fp)
801108e8:	10800043 	ldbu	r2,1(r2)
801108ec:	10803fcc 	andi	r2,r2,255
801108f0:	100b883a 	mov	r5,r2
801108f4:	1809883a 	mov	r4,r3
801108f8:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
	vSetDoubleBufferRightSize( (unsigned char)ulLengthBlocks, pxNFee->ucSPWId );
801108fc:	e0bffa17 	ldw	r2,-24(fp)
80110900:	10c03fcc 	andi	r3,r2,255
80110904:	e0bffe17 	ldw	r2,-8(fp)
80110908:	10800043 	ldbu	r2,1(r2)
8011090c:	10803fcc 	andi	r2,r2,255
80110910:	100b883a 	mov	r5,r2
80110914:	1809883a 	mov	r4,r3
80110918:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
	}*/

	if (  ucMem == 0  ) {
8011091c:	e0bffc03 	ldbu	r2,-16(fp)
80110920:	1000221e 	bne	r2,zero,801109ac <bPrepareDoubleBuffer+0x2f4>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucSide, pxNFee->ucSPWId);
80110924:	e0bffb17 	ldw	r2,-20(fp)
80110928:	10800217 	ldw	r2,8(r2)
8011092c:	1011883a 	mov	r8,r2
80110930:	e0bffa17 	ldw	r2,-24(fp)
80110934:	10ffffcc 	andi	r3,r2,65535
80110938:	e13fff03 	ldbu	r4,-4(fp)
8011093c:	e0bffe17 	ldw	r2,-8(fp)
80110940:	10800043 	ldbu	r2,1(r2)
80110944:	10803fcc 	andi	r2,r2,255
80110948:	100f883a 	mov	r7,r2
8011094c:	200d883a 	mov	r6,r4
80110950:	180b883a 	mov	r5,r3
80110954:	4009883a 	mov	r4,r8
80110958:	0101fd00 	call	80101fd0 <bSdmaDmaM1Transfer>
8011095c:	e0bff915 	stw	r2,-28(fp)
		if ( bDmaReturn == TRUE ) {
80110960:	e0bff917 	ldw	r2,-28(fp)
80110964:	10800058 	cmpnei	r2,r2,1
80110968:	10000e1e 	bne	r2,zero,801109a4 <bPrepareDoubleBuffer+0x2ec>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
8011096c:	e0bffb17 	ldw	r2,-20(fp)
80110970:	10c00217 	ldw	r3,8(r2)
80110974:	e0bffa17 	ldw	r2,-24(fp)
80110978:	10802224 	muli	r2,r2,136
8011097c:	1887883a 	add	r3,r3,r2
80110980:	e0bffb17 	ldw	r2,-20(fp)
80110984:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
80110988:	e0bffb17 	ldw	r2,-20(fp)
8011098c:	10c00117 	ldw	r3,4(r2)
80110990:	e0bffa17 	ldw	r2,-24(fp)
80110994:	1887883a 	add	r3,r3,r2
80110998:	e0bffb17 	ldw	r2,-20(fp)
8011099c:	10c00115 	stw	r3,4(r2)
801109a0:	00002406 	br	80110a34 <bPrepareDoubleBuffer+0x37c>
		} else
			return bDmaReturn;
801109a4:	e0bff917 	ldw	r2,-28(fp)
801109a8:	00002306 	br	80110a38 <bPrepareDoubleBuffer+0x380>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucSide, pxNFee->ucSPWId);
801109ac:	e0bffb17 	ldw	r2,-20(fp)
801109b0:	10800217 	ldw	r2,8(r2)
801109b4:	1011883a 	mov	r8,r2
801109b8:	e0bffa17 	ldw	r2,-24(fp)
801109bc:	10ffffcc 	andi	r3,r2,65535
801109c0:	e13fff03 	ldbu	r4,-4(fp)
801109c4:	e0bffe17 	ldw	r2,-8(fp)
801109c8:	10800043 	ldbu	r2,1(r2)
801109cc:	10803fcc 	andi	r2,r2,255
801109d0:	100f883a 	mov	r7,r2
801109d4:	200d883a 	mov	r6,r4
801109d8:	180b883a 	mov	r5,r3
801109dc:	4009883a 	mov	r4,r8
801109e0:	01024540 	call	80102454 <bSdmaDmaM2Transfer>
801109e4:	e0bff915 	stw	r2,-28(fp)
		if ( bDmaReturn == TRUE ) {
801109e8:	e0bff917 	ldw	r2,-28(fp)
801109ec:	10800058 	cmpnei	r2,r2,1
801109f0:	10000e1e 	bne	r2,zero,80110a2c <bPrepareDoubleBuffer+0x374>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
801109f4:	e0bffb17 	ldw	r2,-20(fp)
801109f8:	10c00217 	ldw	r3,8(r2)
801109fc:	e0bffa17 	ldw	r2,-24(fp)
80110a00:	10802224 	muli	r2,r2,136
80110a04:	1887883a 	add	r3,r3,r2
80110a08:	e0bffb17 	ldw	r2,-20(fp)
80110a0c:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
80110a10:	e0bffb17 	ldw	r2,-20(fp)
80110a14:	10c00117 	ldw	r3,4(r2)
80110a18:	e0bffa17 	ldw	r2,-24(fp)
80110a1c:	1887883a 	add	r3,r3,r2
80110a20:	e0bffb17 	ldw	r2,-20(fp)
80110a24:	10c00115 	stw	r3,4(r2)
80110a28:	00000206 	br	80110a34 <bPrepareDoubleBuffer+0x37c>
		} else
			return bDmaReturn;
80110a2c:	e0bff917 	ldw	r2,-28(fp)
80110a30:	00000106 	br	80110a38 <bPrepareDoubleBuffer+0x380>
	}

	return bDmaReturn;
80110a34:	e0bff917 	ldw	r2,-28(fp)

}
80110a38:	e037883a 	mov	sp,fp
80110a3c:	dfc00117 	ldw	ra,4(sp)
80110a40:	df000017 	ldw	fp,0(sp)
80110a44:	dec00204 	addi	sp,sp,8
80110a48:	f800283a 	ret

80110a4c <vSetDoubleBufferRightSize>:


void vSetDoubleBufferRightSize( unsigned char ucLength, unsigned char ucId ) {
80110a4c:	defffc04 	addi	sp,sp,-16
80110a50:	de00012e 	bgeu	sp,et,80110a58 <vSetDoubleBufferRightSize+0xc>
80110a54:	003b68fa 	trap	3
80110a58:	dfc00315 	stw	ra,12(sp)
80110a5c:	df000215 	stw	fp,8(sp)
80110a60:	df000204 	addi	fp,sp,8
80110a64:	2007883a 	mov	r3,r4
80110a68:	2805883a 	mov	r2,r5
80110a6c:	e0fffe05 	stb	r3,-8(fp)
80110a70:	e0bfff05 	stb	r2,-4(fp)

	switch (ucId) {
80110a74:	e0bfff03 	ldbu	r2,-4(fp)
80110a78:	10c00228 	cmpgeui	r3,r2,8
80110a7c:	1800361e 	bne	r3,zero,80110b58 <vSetDoubleBufferRightSize+0x10c>
80110a80:	100690ba 	slli	r3,r2,2
80110a84:	00a00474 	movhi	r2,32785
80110a88:	1082a604 	addi	r2,r2,2712
80110a8c:	1885883a 	add	r2,r3,r2
80110a90:	10800017 	ldw	r2,0(r2)
80110a94:	1000683a 	jmp	r2
80110a98:	80110ab8 	rdprs	zero,r16,17450
80110a9c:	80110acc 	andi	zero,r16,17451
80110aa0:	80110ae0 	cmpeqi	zero,r16,17451
80110aa4:	80110af4 	orhi	zero,r16,17451
80110aa8:	80110b08 	cmpgei	zero,r16,17452
80110aac:	80110b1c 	xori	zero,r16,17452
80110ab0:	80110b30 	cmpltui	zero,r16,17452
80110ab4:	80110b44 	addi	zero,r16,17453
		case 0:
			bFeebCh1SetBufferSize( ucLength, 1);
80110ab8:	e0bffe03 	ldbu	r2,-8(fp)
80110abc:	01400044 	movi	r5,1
80110ac0:	1009883a 	mov	r4,r2
80110ac4:	0104d140 	call	80104d14 <bFeebCh1SetBufferSize>
			break;
80110ac8:	00002406 	br	80110b5c <vSetDoubleBufferRightSize+0x110>
		case 1:
			bFeebCh2SetBufferSize( ucLength, 1);
80110acc:	e0bffe03 	ldbu	r2,-8(fp)
80110ad0:	01400044 	movi	r5,1
80110ad4:	1009883a 	mov	r4,r2
80110ad8:	0104df40 	call	80104df4 <bFeebCh2SetBufferSize>
			break;
80110adc:	00001f06 	br	80110b5c <vSetDoubleBufferRightSize+0x110>
		case 2:
			bFeebCh3SetBufferSize( ucLength, 1);
80110ae0:	e0bffe03 	ldbu	r2,-8(fp)
80110ae4:	01400044 	movi	r5,1
80110ae8:	1009883a 	mov	r4,r2
80110aec:	0104ed40 	call	80104ed4 <bFeebCh3SetBufferSize>
			break;
80110af0:	00001a06 	br	80110b5c <vSetDoubleBufferRightSize+0x110>
		case 3:
			bFeebCh4SetBufferSize( ucLength, 1);
80110af4:	e0bffe03 	ldbu	r2,-8(fp)
80110af8:	01400044 	movi	r5,1
80110afc:	1009883a 	mov	r4,r2
80110b00:	0104fb40 	call	80104fb4 <bFeebCh4SetBufferSize>
			break;
80110b04:	00001506 	br	80110b5c <vSetDoubleBufferRightSize+0x110>
		case 4:
			bFeebCh5SetBufferSize( ucLength, 1);
80110b08:	e0bffe03 	ldbu	r2,-8(fp)
80110b0c:	01400044 	movi	r5,1
80110b10:	1009883a 	mov	r4,r2
80110b14:	010508c0 	call	8010508c <bFeebCh5SetBufferSize>
			break;
80110b18:	00001006 	br	80110b5c <vSetDoubleBufferRightSize+0x110>
		case 5:
			bFeebCh6SetBufferSize( ucLength, 1);
80110b1c:	e0bffe03 	ldbu	r2,-8(fp)
80110b20:	01400044 	movi	r5,1
80110b24:	1009883a 	mov	r4,r2
80110b28:	010516c0 	call	8010516c <bFeebCh6SetBufferSize>
			break;
80110b2c:	00000b06 	br	80110b5c <vSetDoubleBufferRightSize+0x110>
		case 6:
			bFeebCh7SetBufferSize( ucLength, 1);
80110b30:	e0bffe03 	ldbu	r2,-8(fp)
80110b34:	01400044 	movi	r5,1
80110b38:	1009883a 	mov	r4,r2
80110b3c:	010524c0 	call	8010524c <bFeebCh7SetBufferSize>
			break;
80110b40:	00000606 	br	80110b5c <vSetDoubleBufferRightSize+0x110>
		case 7:
			bFeebCh8SetBufferSize( ucLength, 1);
80110b44:	e0bffe03 	ldbu	r2,-8(fp)
80110b48:	01400044 	movi	r5,1
80110b4c:	1009883a 	mov	r4,r2
80110b50:	010532c0 	call	8010532c <bFeebCh8SetBufferSize>
			break;
80110b54:	00000106 	br	80110b5c <vSetDoubleBufferRightSize+0x110>
		default:
			break;
80110b58:	0001883a 	nop
	}

}
80110b5c:	0001883a 	nop
80110b60:	e037883a 	mov	sp,fp
80110b64:	dfc00117 	ldw	ra,4(sp)
80110b68:	df000017 	ldw	fp,0(sp)
80110b6c:	dec00204 	addi	sp,sp,8
80110b70:	f800283a 	ret

80110b74 <vSetDoubleBufferLeftSize>:

void vSetDoubleBufferLeftSize( unsigned char ucLength, unsigned char ucId ) {
80110b74:	defffc04 	addi	sp,sp,-16
80110b78:	de00012e 	bgeu	sp,et,80110b80 <vSetDoubleBufferLeftSize+0xc>
80110b7c:	003b68fa 	trap	3
80110b80:	dfc00315 	stw	ra,12(sp)
80110b84:	df000215 	stw	fp,8(sp)
80110b88:	df000204 	addi	fp,sp,8
80110b8c:	2007883a 	mov	r3,r4
80110b90:	2805883a 	mov	r2,r5
80110b94:	e0fffe05 	stb	r3,-8(fp)
80110b98:	e0bfff05 	stb	r2,-4(fp)

	switch (ucId) {
80110b9c:	e0bfff03 	ldbu	r2,-4(fp)
80110ba0:	10c00228 	cmpgeui	r3,r2,8
80110ba4:	1800361e 	bne	r3,zero,80110c80 <vSetDoubleBufferLeftSize+0x10c>
80110ba8:	100690ba 	slli	r3,r2,2
80110bac:	00a00474 	movhi	r2,32785
80110bb0:	1082f004 	addi	r2,r2,3008
80110bb4:	1885883a 	add	r2,r3,r2
80110bb8:	10800017 	ldw	r2,0(r2)
80110bbc:	1000683a 	jmp	r2
80110bc0:	80110be0 	cmpeqi	zero,r16,17455
80110bc4:	80110bf4 	orhi	zero,r16,17455
80110bc8:	80110c08 	cmpgei	zero,r16,17456
80110bcc:	80110c1c 	xori	zero,r16,17456
80110bd0:	80110c30 	cmpltui	zero,r16,17456
80110bd4:	80110c44 	addi	zero,r16,17457
80110bd8:	80110c58 	cmpnei	zero,r16,17457
80110bdc:	80110c6c 	andhi	zero,r16,17457
		case 0:
			bFeebCh1SetBufferSize( ucLength, 0);
80110be0:	e0bffe03 	ldbu	r2,-8(fp)
80110be4:	000b883a 	mov	r5,zero
80110be8:	1009883a 	mov	r4,r2
80110bec:	0104d140 	call	80104d14 <bFeebCh1SetBufferSize>
			break;
80110bf0:	00002406 	br	80110c84 <vSetDoubleBufferLeftSize+0x110>
		case 1:
			bFeebCh2SetBufferSize( ucLength, 0);
80110bf4:	e0bffe03 	ldbu	r2,-8(fp)
80110bf8:	000b883a 	mov	r5,zero
80110bfc:	1009883a 	mov	r4,r2
80110c00:	0104df40 	call	80104df4 <bFeebCh2SetBufferSize>
			break;
80110c04:	00001f06 	br	80110c84 <vSetDoubleBufferLeftSize+0x110>
		case 2:
			bFeebCh3SetBufferSize( ucLength, 0);
80110c08:	e0bffe03 	ldbu	r2,-8(fp)
80110c0c:	000b883a 	mov	r5,zero
80110c10:	1009883a 	mov	r4,r2
80110c14:	0104ed40 	call	80104ed4 <bFeebCh3SetBufferSize>
			break;
80110c18:	00001a06 	br	80110c84 <vSetDoubleBufferLeftSize+0x110>
		case 3:
			bFeebCh4SetBufferSize( ucLength, 0);
80110c1c:	e0bffe03 	ldbu	r2,-8(fp)
80110c20:	000b883a 	mov	r5,zero
80110c24:	1009883a 	mov	r4,r2
80110c28:	0104fb40 	call	80104fb4 <bFeebCh4SetBufferSize>
			break;
80110c2c:	00001506 	br	80110c84 <vSetDoubleBufferLeftSize+0x110>
		case 4:
			bFeebCh5SetBufferSize( ucLength, 0);
80110c30:	e0bffe03 	ldbu	r2,-8(fp)
80110c34:	000b883a 	mov	r5,zero
80110c38:	1009883a 	mov	r4,r2
80110c3c:	010508c0 	call	8010508c <bFeebCh5SetBufferSize>
			break;
80110c40:	00001006 	br	80110c84 <vSetDoubleBufferLeftSize+0x110>
		case 5:
			bFeebCh6SetBufferSize( ucLength, 0);
80110c44:	e0bffe03 	ldbu	r2,-8(fp)
80110c48:	000b883a 	mov	r5,zero
80110c4c:	1009883a 	mov	r4,r2
80110c50:	010516c0 	call	8010516c <bFeebCh6SetBufferSize>
			break;
80110c54:	00000b06 	br	80110c84 <vSetDoubleBufferLeftSize+0x110>
		case 6:
			bFeebCh7SetBufferSize( ucLength, 0);
80110c58:	e0bffe03 	ldbu	r2,-8(fp)
80110c5c:	000b883a 	mov	r5,zero
80110c60:	1009883a 	mov	r4,r2
80110c64:	010524c0 	call	8010524c <bFeebCh7SetBufferSize>
			break;
80110c68:	00000606 	br	80110c84 <vSetDoubleBufferLeftSize+0x110>
		case 7:
			bFeebCh8SetBufferSize( ucLength, 0);
80110c6c:	e0bffe03 	ldbu	r2,-8(fp)
80110c70:	000b883a 	mov	r5,zero
80110c74:	1009883a 	mov	r4,r2
80110c78:	010532c0 	call	8010532c <bFeebCh8SetBufferSize>
			break;
80110c7c:	00000106 	br	80110c84 <vSetDoubleBufferLeftSize+0x110>
		default:
			break;
80110c80:	0001883a 	nop
	}

}
80110c84:	0001883a 	nop
80110c88:	e037883a 	mov	sp,fp
80110c8c:	dfc00117 	ldw	ra,4(sp)
80110c90:	df000017 	ldw	fp,0(sp)
80110c94:	dec00204 	addi	sp,sp,8
80110c98:	f800283a 	ret

80110c9c <vWaitUntilBufferEmpty>:

void vWaitUntilBufferEmpty( unsigned char ucId ) {
80110c9c:	defffd04 	addi	sp,sp,-12
80110ca0:	de00012e 	bgeu	sp,et,80110ca8 <vWaitUntilBufferEmpty+0xc>
80110ca4:	003b68fa 	trap	3
80110ca8:	dfc00215 	stw	ra,8(sp)
80110cac:	df000115 	stw	fp,4(sp)
80110cb0:	df000104 	addi	fp,sp,4
80110cb4:	2005883a 	mov	r2,r4
80110cb8:	e0bfff05 	stb	r2,-4(fp)

	switch (ucId) {
80110cbc:	e0bfff03 	ldbu	r2,-4(fp)
80110cc0:	10c00228 	cmpgeui	r3,r2,8
80110cc4:	18002e1e 	bne	r3,zero,80110d80 <vWaitUntilBufferEmpty+0xe4>
80110cc8:	100690ba 	slli	r3,r2,2
80110ccc:	00a00474 	movhi	r2,32785
80110cd0:	10833804 	addi	r2,r2,3296
80110cd4:	1885883a 	add	r2,r3,r2
80110cd8:	10800017 	ldw	r2,0(r2)
80110cdc:	1000683a 	jmp	r2
80110ce0:	80110d00 	call	880110d0 <__reset+0x1ff10d0>
80110ce4:	80110d20 	cmpeqi	zero,r16,17460
80110ce8:	80110d40 	call	880110d4 <__reset+0x1ff10d4>
80110cec:	80110d60 	cmpeqi	zero,r16,17461
80110cf0:	80110d88 	cmpgei	zero,r16,17462
80110cf4:	80110d88 	cmpgei	zero,r16,17462
80110cf8:	80110d88 	cmpgei	zero,r16,17462
80110cfc:	80110d88 	cmpgei	zero,r16,17462
		case 0:
			while ( (bFeebGetCh1LeftFeeBusy()== TRUE) || (bFeebGetCh1RightFeeBusy()== TRUE)  ) {}
80110d00:	0001883a 	nop
80110d04:	01063b80 	call	801063b8 <bFeebGetCh1LeftFeeBusy>
80110d08:	10800060 	cmpeqi	r2,r2,1
80110d0c:	103ffd1e 	bne	r2,zero,80110d04 <__reset+0xfa0f0d04>
80110d10:	010644c0 	call	8010644c <bFeebGetCh1RightFeeBusy>
80110d14:	10800060 	cmpeqi	r2,r2,1
80110d18:	103ffa1e 	bne	r2,zero,80110d04 <__reset+0xfa0f0d04>
			break;
80110d1c:	00001b06 	br	80110d8c <vWaitUntilBufferEmpty+0xf0>
		case 1:
			while ( (bFeebGetCh2LeftFeeBusy()== TRUE) || (bFeebGetCh2RightFeeBusy()== TRUE)  ) {}
80110d20:	0001883a 	nop
80110d24:	01064e00 	call	801064e0 <bFeebGetCh2LeftFeeBusy>
80110d28:	10800060 	cmpeqi	r2,r2,1
80110d2c:	103ffd1e 	bne	r2,zero,80110d24 <__reset+0xfa0f0d24>
80110d30:	01065740 	call	80106574 <bFeebGetCh2RightFeeBusy>
80110d34:	10800060 	cmpeqi	r2,r2,1
80110d38:	103ffa1e 	bne	r2,zero,80110d24 <__reset+0xfa0f0d24>
			break;
80110d3c:	00001306 	br	80110d8c <vWaitUntilBufferEmpty+0xf0>
		case 2:
			while ( (bFeebGetCh3LeftFeeBusy()== TRUE) || (bFeebGetCh3RightFeeBusy()== TRUE)  ) {}
80110d40:	0001883a 	nop
80110d44:	01066080 	call	80106608 <bFeebGetCh3LeftFeeBusy>
80110d48:	10800060 	cmpeqi	r2,r2,1
80110d4c:	103ffd1e 	bne	r2,zero,80110d44 <__reset+0xfa0f0d44>
80110d50:	010669c0 	call	8010669c <bFeebGetCh3RightFeeBusy>
80110d54:	10800060 	cmpeqi	r2,r2,1
80110d58:	103ffa1e 	bne	r2,zero,80110d44 <__reset+0xfa0f0d44>
			break;
80110d5c:	00000b06 	br	80110d8c <vWaitUntilBufferEmpty+0xf0>
		case 3:
			while ( (bFeebGetCh4LeftFeeBusy()== TRUE) || (bFeebGetCh4RightFeeBusy()== TRUE)  ) {}
80110d60:	0001883a 	nop
80110d64:	01067300 	call	80106730 <bFeebGetCh4LeftFeeBusy>
80110d68:	10800060 	cmpeqi	r2,r2,1
80110d6c:	103ffd1e 	bne	r2,zero,80110d64 <__reset+0xfa0f0d64>
80110d70:	01067c00 	call	801067c0 <bFeebGetCh4RightFeeBusy>
80110d74:	10800060 	cmpeqi	r2,r2,1
80110d78:	103ffa1e 	bne	r2,zero,80110d64 <__reset+0xfa0f0d64>
			break;
80110d7c:	00000306 	br	80110d8c <vWaitUntilBufferEmpty+0xf0>
			break;
		case 7:
			//while ( (bFeebGetCh8LeftFeeBusy()== TRUE) || (bFeebGetCh8RightFeeBusy()== TRUE)  ) {}
			break;
		default:
			break;
80110d80:	0001883a 	nop
80110d84:	00000106 	br	80110d8c <vWaitUntilBufferEmpty+0xf0>
		case 6:
			//while ( (bFeebGetCh7LeftFeeBusy()== TRUE) || (bFeebGetCh7RightFeeBusy()== TRUE)  ) {}
			break;
		case 7:
			//while ( (bFeebGetCh8LeftFeeBusy()== TRUE) || (bFeebGetCh8RightFeeBusy()== TRUE)  ) {}
			break;
80110d88:	0001883a 	nop
		default:
			break;
	}

}
80110d8c:	0001883a 	nop
80110d90:	e037883a 	mov	sp,fp
80110d94:	dfc00117 	ldw	ra,4(sp)
80110d98:	df000017 	ldw	fp,0(sp)
80110d9c:	dec00204 	addi	sp,sp,8
80110da0:	f800283a 	ret

80110da4 <uliReturnMaskR>:

inline unsigned long int uliReturnMaskR( unsigned char ucChannel ){
80110da4:	defffd04 	addi	sp,sp,-12
80110da8:	de00012e 	bgeu	sp,et,80110db0 <uliReturnMaskR+0xc>
80110dac:	003b68fa 	trap	3
80110db0:	df000215 	stw	fp,8(sp)
80110db4:	df000204 	addi	fp,sp,8
80110db8:	2005883a 	mov	r2,r4
80110dbc:	e0bfff05 	stb	r2,-4(fp)
	unsigned long int uliOut;

	switch (ucChannel) {
80110dc0:	e0bfff03 	ldbu	r2,-4(fp)
80110dc4:	10c00228 	cmpgeui	r3,r2,8
80110dc8:	1800261e 	bne	r3,zero,80110e64 <uliReturnMaskR+0xc0>
80110dcc:	100690ba 	slli	r3,r2,2
80110dd0:	00a00474 	movhi	r2,32785
80110dd4:	10837904 	addi	r2,r2,3556
80110dd8:	1885883a 	add	r2,r3,r2
80110ddc:	10800017 	ldw	r2,0(r2)
80110de0:	1000683a 	jmp	r2
80110de4:	80110e04 	addi	zero,r16,17464
80110de8:	80110e10 	cmplti	zero,r16,17464
80110dec:	80110e1c 	xori	zero,r16,17464
80110df0:	80110e28 	cmpgeui	zero,r16,17464
80110df4:	80110e34 	orhi	zero,r16,17464
80110df8:	80110e40 	call	880110e4 <__reset+0x1ff10e4>
80110dfc:	80110e4c 	andi	zero,r16,17465
80110e00:	80110e58 	cmpnei	zero,r16,17465
		case 0:
			uliOut = LEDS_1R_MASK;
80110e04:	00800084 	movi	r2,2
80110e08:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e0c:	00001806 	br	80110e70 <uliReturnMaskR+0xcc>
		case 1:
			uliOut = LEDS_2R_MASK;
80110e10:	00800204 	movi	r2,8
80110e14:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e18:	00001506 	br	80110e70 <uliReturnMaskR+0xcc>
		case 2:
			uliOut = LEDS_3R_MASK;
80110e1c:	00800804 	movi	r2,32
80110e20:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e24:	00001206 	br	80110e70 <uliReturnMaskR+0xcc>
		case 3:
			uliOut = LEDS_4R_MASK;
80110e28:	00802004 	movi	r2,128
80110e2c:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e30:	00000f06 	br	80110e70 <uliReturnMaskR+0xcc>
		case 4:
			uliOut = LEDS_5R_MASK;
80110e34:	00808004 	movi	r2,512
80110e38:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e3c:	00000c06 	br	80110e70 <uliReturnMaskR+0xcc>
		case 5:
			uliOut = LEDS_6R_MASK;
80110e40:	00820004 	movi	r2,2048
80110e44:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e48:	00000906 	br	80110e70 <uliReturnMaskR+0xcc>
		case 6:
			uliOut = LEDS_7R_MASK;
80110e4c:	00880004 	movi	r2,8192
80110e50:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e54:	00000606 	br	80110e70 <uliReturnMaskR+0xcc>
		case 7:
			uliOut = LEDS_8R_MASK;
80110e58:	00a00014 	movui	r2,32768
80110e5c:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e60:	00000306 	br	80110e70 <uliReturnMaskR+0xcc>
		default:
			uliOut = LEDS_R_ALL_MASK;
80110e64:	00aaaa94 	movui	r2,43690
80110e68:	e0bffe15 	stw	r2,-8(fp)
			break;
80110e6c:	0001883a 	nop
	}
	return uliOut;
80110e70:	e0bffe17 	ldw	r2,-8(fp)
}
80110e74:	e037883a 	mov	sp,fp
80110e78:	df000017 	ldw	fp,0(sp)
80110e7c:	dec00104 	addi	sp,sp,4
80110e80:	f800283a 	ret

80110e84 <uliReturnMaskG>:


inline unsigned long int uliReturnMaskG( unsigned char ucChannel ){
80110e84:	defffd04 	addi	sp,sp,-12
80110e88:	de00012e 	bgeu	sp,et,80110e90 <uliReturnMaskG+0xc>
80110e8c:	003b68fa 	trap	3
80110e90:	df000215 	stw	fp,8(sp)
80110e94:	df000204 	addi	fp,sp,8
80110e98:	2005883a 	mov	r2,r4
80110e9c:	e0bfff05 	stb	r2,-4(fp)
	unsigned long int uliOut;

	switch (ucChannel) {
80110ea0:	e0bfff03 	ldbu	r2,-4(fp)
80110ea4:	10c00228 	cmpgeui	r3,r2,8
80110ea8:	1800261e 	bne	r3,zero,80110f44 <uliReturnMaskG+0xc0>
80110eac:	100690ba 	slli	r3,r2,2
80110eb0:	00a00474 	movhi	r2,32785
80110eb4:	1083b104 	addi	r2,r2,3780
80110eb8:	1885883a 	add	r2,r3,r2
80110ebc:	10800017 	ldw	r2,0(r2)
80110ec0:	1000683a 	jmp	r2
80110ec4:	80110ee4 	muli	zero,r16,17467
80110ec8:	80110ef0 	cmpltui	zero,r16,17467
80110ecc:	80110efc 	xorhi	zero,r16,17467
80110ed0:	80110f08 	cmpgei	zero,r16,17468
80110ed4:	80110f14 	ori	zero,r16,17468
80110ed8:	80110f20 	cmpeqi	zero,r16,17468
80110edc:	80110f2c 	andhi	zero,r16,17468
80110ee0:	80110f38 	rdprs	zero,r16,17468
		case 0:
			uliOut = LEDS_1G_MASK;
80110ee4:	00800044 	movi	r2,1
80110ee8:	e0bffe15 	stw	r2,-8(fp)
			break;
80110eec:	00001806 	br	80110f50 <uliReturnMaskG+0xcc>
		case 1:
			uliOut = LEDS_2G_MASK;
80110ef0:	00800104 	movi	r2,4
80110ef4:	e0bffe15 	stw	r2,-8(fp)
			break;
80110ef8:	00001506 	br	80110f50 <uliReturnMaskG+0xcc>
		case 2:
			uliOut = LEDS_3G_MASK;
80110efc:	00800404 	movi	r2,16
80110f00:	e0bffe15 	stw	r2,-8(fp)
			break;
80110f04:	00001206 	br	80110f50 <uliReturnMaskG+0xcc>
		case 3:
			uliOut = LEDS_4G_MASK;
80110f08:	00801004 	movi	r2,64
80110f0c:	e0bffe15 	stw	r2,-8(fp)
			break;
80110f10:	00000f06 	br	80110f50 <uliReturnMaskG+0xcc>
		case 4:
			uliOut = LEDS_5G_MASK;
80110f14:	00804004 	movi	r2,256
80110f18:	e0bffe15 	stw	r2,-8(fp)
			break;
80110f1c:	00000c06 	br	80110f50 <uliReturnMaskG+0xcc>
		case 5:
			uliOut = LEDS_6G_MASK;
80110f20:	00810004 	movi	r2,1024
80110f24:	e0bffe15 	stw	r2,-8(fp)
			break;
80110f28:	00000906 	br	80110f50 <uliReturnMaskG+0xcc>
		case 6:
			uliOut = LEDS_7G_MASK;
80110f2c:	00840004 	movi	r2,4096
80110f30:	e0bffe15 	stw	r2,-8(fp)
			break;
80110f34:	00000606 	br	80110f50 <uliReturnMaskG+0xcc>
		case 7:
			uliOut = LEDS_8G_MASK;
80110f38:	00900004 	movi	r2,16384
80110f3c:	e0bffe15 	stw	r2,-8(fp)
			break;
80110f40:	00000306 	br	80110f50 <uliReturnMaskG+0xcc>
		default:
			uliOut = LEDS_G_ALL_MASK;
80110f44:	00955544 	movi	r2,21845
80110f48:	e0bffe15 	stw	r2,-8(fp)
			break;
80110f4c:	0001883a 	nop
	}
	return uliOut;
80110f50:	e0bffe17 	ldw	r2,-8(fp)
}
80110f54:	e037883a 	mov	sp,fp
80110f58:	df000017 	ldw	fp,0(sp)
80110f5c:	dec00104 	addi	sp,sp,4
80110f60:	f800283a 	ret

80110f64 <vLoadCtemp>:


void vLoadCtemp(void) {
80110f64:	deffff04 	addi	sp,sp,-4
80110f68:	de00012e 	bgeu	sp,et,80110f70 <vLoadCtemp+0xc>
80110f6c:	003b68fa 	trap	3
80110f70:	df000015 	stw	fp,0(sp)
80110f74:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
80110f78:	00a00574 	movhi	r2,32789
80110f7c:	10abb504 	addi	r2,r2,-20780
80110f80:	00e00534 	movhi	r3,32788
80110f84:	18dc5804 	addi	r3,r3,29024
80110f88:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
80110f8c:	00a00574 	movhi	r2,32789
80110f90:	10abb504 	addi	r2,r2,-20780
80110f94:	00e00534 	movhi	r3,32788
80110f98:	18dc5c04 	addi	r3,r3,29040
80110f9c:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
80110fa0:	00a00574 	movhi	r2,32789
80110fa4:	10abb504 	addi	r2,r2,-20780
80110fa8:	00e00534 	movhi	r3,32788
80110fac:	18dc6004 	addi	r3,r3,29056
80110fb0:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
80110fb4:	00a00574 	movhi	r2,32789
80110fb8:	10abb504 	addi	r2,r2,-20780
80110fbc:	00e00534 	movhi	r3,32788
80110fc0:	18dc6404 	addi	r3,r3,29072
80110fc4:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
80110fc8:	00a00574 	movhi	r2,32789
80110fcc:	10abb504 	addi	r2,r2,-20780
80110fd0:	00e00534 	movhi	r3,32788
80110fd4:	18dc6804 	addi	r3,r3,29088
80110fd8:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
80110fdc:	00a00574 	movhi	r2,32789
80110fe0:	10abb504 	addi	r2,r2,-20780
80110fe4:	00e00534 	movhi	r3,32788
80110fe8:	18dc6c04 	addi	r3,r3,29104
80110fec:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
80110ff0:	00a00574 	movhi	r2,32789
80110ff4:	10abb504 	addi	r2,r2,-20780
80110ff8:	00e00534 	movhi	r3,32788
80110ffc:	18dc7004 	addi	r3,r3,29120
80111000:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
80111004:	00a00574 	movhi	r2,32789
80111008:	10abb504 	addi	r2,r2,-20780
8011100c:	00e00534 	movhi	r3,32788
80111010:	18dc7404 	addi	r3,r3,29136
80111014:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
80111018:	00a00574 	movhi	r2,32789
8011101c:	10abb504 	addi	r2,r2,-20780
80111020:	00e00534 	movhi	r3,32788
80111024:	18dc7804 	addi	r3,r3,29152
80111028:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
8011102c:	00a00574 	movhi	r2,32789
80111030:	10abb504 	addi	r2,r2,-20780
80111034:	00e00534 	movhi	r3,32788
80111038:	18dc7c04 	addi	r3,r3,29168
8011103c:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
80111040:	00a00574 	movhi	r2,32789
80111044:	10abb504 	addi	r2,r2,-20780
80111048:	00e00534 	movhi	r3,32788
8011104c:	18dc8004 	addi	r3,r3,29184
80111050:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
80111054:	00a00574 	movhi	r2,32789
80111058:	10abb504 	addi	r2,r2,-20780
8011105c:	00e00534 	movhi	r3,32788
80111060:	18dc8404 	addi	r3,r3,29200
80111064:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
80111068:	00a00574 	movhi	r2,32789
8011106c:	10abb504 	addi	r2,r2,-20780
80111070:	00e00534 	movhi	r3,32788
80111074:	18dc8804 	addi	r3,r3,29216
80111078:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
8011107c:	00a00574 	movhi	r2,32789
80111080:	10abb504 	addi	r2,r2,-20780
80111084:	00e00534 	movhi	r3,32788
80111088:	18dc8b04 	addi	r3,r3,29228
8011108c:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
80111090:	00a00574 	movhi	r2,32789
80111094:	10abb504 	addi	r2,r2,-20780
80111098:	00e00534 	movhi	r3,32788
8011109c:	18dc8e04 	addi	r3,r3,29240
801110a0:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
801110a4:	00a00574 	movhi	r2,32789
801110a8:	10abb504 	addi	r2,r2,-20780
801110ac:	00e00534 	movhi	r3,32788
801110b0:	18dc9104 	addi	r3,r3,29252
801110b4:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
801110b8:	00a00574 	movhi	r2,32789
801110bc:	10abb504 	addi	r2,r2,-20780
801110c0:	00e00534 	movhi	r3,32788
801110c4:	18dc9504 	addi	r3,r3,29268
801110c8:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
801110cc:	00a00574 	movhi	r2,32789
801110d0:	10abb504 	addi	r2,r2,-20780
801110d4:	00e00534 	movhi	r3,32788
801110d8:	18dc9804 	addi	r3,r3,29280
801110dc:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
801110e0:	00a00574 	movhi	r2,32789
801110e4:	10abb504 	addi	r2,r2,-20780
801110e8:	00e00534 	movhi	r3,32788
801110ec:	18dc9b04 	addi	r3,r3,29292
801110f0:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
801110f4:	00a00574 	movhi	r2,32789
801110f8:	10abb504 	addi	r2,r2,-20780
801110fc:	00e00534 	movhi	r3,32788
80111100:	18dc9f04 	addi	r3,r3,29308
80111104:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
80111108:	00a00574 	movhi	r2,32789
8011110c:	10abb504 	addi	r2,r2,-20780
80111110:	00e00534 	movhi	r3,32788
80111114:	18dca304 	addi	r3,r3,29324
80111118:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
8011111c:	00a00574 	movhi	r2,32789
80111120:	10abb504 	addi	r2,r2,-20780
80111124:	00e00534 	movhi	r3,32788
80111128:	18dca704 	addi	r3,r3,29340
8011112c:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
80111130:	00a00574 	movhi	r2,32789
80111134:	10abb504 	addi	r2,r2,-20780
80111138:	00e00534 	movhi	r3,32788
8011113c:	18dcab04 	addi	r3,r3,29356
80111140:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
80111144:	00a00574 	movhi	r2,32789
80111148:	10abb504 	addi	r2,r2,-20780
8011114c:	00e00534 	movhi	r3,32788
80111150:	18dcaf04 	addi	r3,r3,29372
80111154:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
80111158:	00a00574 	movhi	r2,32789
8011115c:	10abb504 	addi	r2,r2,-20780
80111160:	00e00534 	movhi	r3,32788
80111164:	18dcb204 	addi	r3,r3,29384
80111168:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
8011116c:	00a00574 	movhi	r2,32789
80111170:	10abb504 	addi	r2,r2,-20780
80111174:	00e00534 	movhi	r3,32788
80111178:	18dcb604 	addi	r3,r3,29400
8011117c:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
80111180:	00a00574 	movhi	r2,32789
80111184:	10abb504 	addi	r2,r2,-20780
80111188:	00e00534 	movhi	r3,32788
8011118c:	18dcba04 	addi	r3,r3,29416
80111190:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
80111194:	00a00574 	movhi	r2,32789
80111198:	10abb504 	addi	r2,r2,-20780
8011119c:	00e00534 	movhi	r3,32788
801111a0:	18dcbe04 	addi	r3,r3,29432
801111a4:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
801111a8:	00a00574 	movhi	r2,32789
801111ac:	10abb504 	addi	r2,r2,-20780
801111b0:	00e00534 	movhi	r3,32788
801111b4:	18dcc204 	addi	r3,r3,29448
801111b8:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
801111bc:	00a00574 	movhi	r2,32789
801111c0:	10abb504 	addi	r2,r2,-20780
801111c4:	00e00534 	movhi	r3,32788
801111c8:	18dcc604 	addi	r3,r3,29464
801111cc:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
801111d0:	00a00574 	movhi	r2,32789
801111d4:	10abb504 	addi	r2,r2,-20780
801111d8:	00e00534 	movhi	r3,32788
801111dc:	18dccb04 	addi	r3,r3,29484
801111e0:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
801111e4:	00a00574 	movhi	r2,32789
801111e8:	10abb504 	addi	r2,r2,-20780
801111ec:	00e00534 	movhi	r3,32788
801111f0:	18dccf04 	addi	r3,r3,29500
801111f4:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
801111f8:	00a00574 	movhi	r2,32789
801111fc:	10abb504 	addi	r2,r2,-20780
80111200:	00e00534 	movhi	r3,32788
80111204:	18dcd304 	addi	r3,r3,29516
80111208:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
8011120c:	00a00574 	movhi	r2,32789
80111210:	10abb504 	addi	r2,r2,-20780
80111214:	00e00534 	movhi	r3,32788
80111218:	18dcd704 	addi	r3,r3,29532
8011121c:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
80111220:	00a00574 	movhi	r2,32789
80111224:	10abb504 	addi	r2,r2,-20780
80111228:	00e00534 	movhi	r3,32788
8011122c:	18dcdb04 	addi	r3,r3,29548
80111230:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
80111234:	00a00574 	movhi	r2,32789
80111238:	10abb504 	addi	r2,r2,-20780
8011123c:	00e00534 	movhi	r3,32788
80111240:	18dcdf04 	addi	r3,r3,29564
80111244:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
80111248:	00a00574 	movhi	r2,32789
8011124c:	10abb504 	addi	r2,r2,-20780
80111250:	00e00534 	movhi	r3,32788
80111254:	18dce304 	addi	r3,r3,29580
80111258:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
8011125c:	00a00574 	movhi	r2,32789
80111260:	10abb504 	addi	r2,r2,-20780
80111264:	00e00534 	movhi	r3,32788
80111268:	18dce704 	addi	r3,r3,29596
8011126c:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
80111270:	00a00574 	movhi	r2,32789
80111274:	10abb504 	addi	r2,r2,-20780
80111278:	00e00534 	movhi	r3,32788
8011127c:	18dceb04 	addi	r3,r3,29612
80111280:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
80111284:	00a00574 	movhi	r2,32789
80111288:	10abb504 	addi	r2,r2,-20780
8011128c:	00e00534 	movhi	r3,32788
80111290:	18dcef04 	addi	r3,r3,29628
80111294:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
80111298:	00a00574 	movhi	r2,32789
8011129c:	10abb504 	addi	r2,r2,-20780
801112a0:	00e00534 	movhi	r3,32788
801112a4:	18dcf304 	addi	r3,r3,29644
801112a8:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
801112ac:	00a00574 	movhi	r2,32789
801112b0:	10abb504 	addi	r2,r2,-20780
801112b4:	00e00534 	movhi	r3,32788
801112b8:	18dcf704 	addi	r3,r3,29660
801112bc:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
801112c0:	00a00574 	movhi	r2,32789
801112c4:	10abb504 	addi	r2,r2,-20780
801112c8:	00e00534 	movhi	r3,32788
801112cc:	18dcfb04 	addi	r3,r3,29676
801112d0:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
801112d4:	00a00574 	movhi	r2,32789
801112d8:	10abb504 	addi	r2,r2,-20780
801112dc:	00e00534 	movhi	r3,32788
801112e0:	18dcff04 	addi	r3,r3,29692
801112e4:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
801112e8:	00a00574 	movhi	r2,32789
801112ec:	10abb504 	addi	r2,r2,-20780
801112f0:	00e00534 	movhi	r3,32788
801112f4:	18dd0304 	addi	r3,r3,29708
801112f8:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
801112fc:	00a00574 	movhi	r2,32789
80111300:	10abb504 	addi	r2,r2,-20780
80111304:	00e00534 	movhi	r3,32788
80111308:	18dd0704 	addi	r3,r3,29724
8011130c:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
80111310:	00a00574 	movhi	r2,32789
80111314:	10abb504 	addi	r2,r2,-20780
80111318:	00e00534 	movhi	r3,32788
8011131c:	18dd0b04 	addi	r3,r3,29740
80111320:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
80111324:	00a00574 	movhi	r2,32789
80111328:	10abb504 	addi	r2,r2,-20780
8011132c:	00e00534 	movhi	r3,32788
80111330:	18dd0f04 	addi	r3,r3,29756
80111334:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
80111338:	00a00574 	movhi	r2,32789
8011133c:	10abb504 	addi	r2,r2,-20780
80111340:	00e00534 	movhi	r3,32788
80111344:	18dd1304 	addi	r3,r3,29772
80111348:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
8011134c:	00a00574 	movhi	r2,32789
80111350:	10abb504 	addi	r2,r2,-20780
80111354:	00e00534 	movhi	r3,32788
80111358:	18dd1704 	addi	r3,r3,29788
8011135c:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
80111360:	00a00574 	movhi	r2,32789
80111364:	10abb504 	addi	r2,r2,-20780
80111368:	00e00534 	movhi	r3,32788
8011136c:	18dd1b04 	addi	r3,r3,29804
80111370:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
80111374:	00a00574 	movhi	r2,32789
80111378:	10abb504 	addi	r2,r2,-20780
8011137c:	00e00534 	movhi	r3,32788
80111380:	18dd1f04 	addi	r3,r3,29820
80111384:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
80111388:	00a00574 	movhi	r2,32789
8011138c:	10abb504 	addi	r2,r2,-20780
80111390:	00e00534 	movhi	r3,32788
80111394:	18dd2304 	addi	r3,r3,29836
80111398:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
8011139c:	00a00574 	movhi	r2,32789
801113a0:	10abb504 	addi	r2,r2,-20780
801113a4:	00e00534 	movhi	r3,32788
801113a8:	18dd2704 	addi	r3,r3,29852
801113ac:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
801113b0:	00a00574 	movhi	r2,32789
801113b4:	10abb504 	addi	r2,r2,-20780
801113b8:	00e00534 	movhi	r3,32788
801113bc:	18dd2b04 	addi	r3,r3,29868
801113c0:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
801113c4:	00a00574 	movhi	r2,32789
801113c8:	10abb504 	addi	r2,r2,-20780
801113cc:	00e00534 	movhi	r3,32788
801113d0:	18dd2f04 	addi	r3,r3,29884
801113d4:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
801113d8:	00a00574 	movhi	r2,32789
801113dc:	10abb504 	addi	r2,r2,-20780
801113e0:	00e00534 	movhi	r3,32788
801113e4:	18dd3304 	addi	r3,r3,29900
801113e8:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
801113ec:	00a00574 	movhi	r2,32789
801113f0:	10abb504 	addi	r2,r2,-20780
801113f4:	00e00534 	movhi	r3,32788
801113f8:	18dd3704 	addi	r3,r3,29916
801113fc:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
80111400:	00a00574 	movhi	r2,32789
80111404:	10abb504 	addi	r2,r2,-20780
80111408:	00e00534 	movhi	r3,32788
8011140c:	18dd3b04 	addi	r3,r3,29932
80111410:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
80111414:	00a00574 	movhi	r2,32789
80111418:	10abb504 	addi	r2,r2,-20780
8011141c:	00e00534 	movhi	r3,32788
80111420:	18dd3f04 	addi	r3,r3,29948
80111424:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
80111428:	00a00574 	movhi	r2,32789
8011142c:	10abb504 	addi	r2,r2,-20780
80111430:	00e00534 	movhi	r3,32788
80111434:	18dd4304 	addi	r3,r3,29964
80111438:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
8011143c:	00a00574 	movhi	r2,32789
80111440:	10abb504 	addi	r2,r2,-20780
80111444:	00e00534 	movhi	r3,32788
80111448:	18dd4704 	addi	r3,r3,29980
8011144c:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
80111450:	00a00574 	movhi	r2,32789
80111454:	10abb504 	addi	r2,r2,-20780
80111458:	00e00534 	movhi	r3,32788
8011145c:	18dd4b04 	addi	r3,r3,29996
80111460:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
80111464:	00a00574 	movhi	r2,32789
80111468:	10abb504 	addi	r2,r2,-20780
8011146c:	00e00534 	movhi	r3,32788
80111470:	18dd4f04 	addi	r3,r3,30012
80111474:	10c03f15 	stw	r3,252(r2)
}
80111478:	0001883a 	nop
8011147c:	e037883a 	mov	sp,fp
80111480:	df000017 	ldw	fp,0(sp)
80111484:	dec00104 	addi	sp,sp,4
80111488:	f800283a 	ret

8011148c <vFeeTask1>:
#include "fee_task1.h"


static unsigned char ucIterationSide;

void vFeeTask1(void *task_data) {
8011148c:	defff204 	addi	sp,sp,-56
80111490:	de00012e 	bgeu	sp,et,80111498 <vFeeTask1+0xc>
80111494:	003b68fa 	trap	3
80111498:	dfc00d15 	stw	ra,52(sp)
8011149c:	df000c15 	stw	fp,48(sp)
801114a0:	df000c04 	addi	fp,sp,48
801114a4:	e13fff15 	stw	r4,-4(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
801114a8:	e0bfff17 	ldw	r2,-4(fp)
801114ac:	d0a05815 	stw	r2,-32416(gp)
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
801114b0:	d0a05817 	ldw	r2,-32416(gp)
801114b4:	10802c17 	ldw	r2,176(r2)
801114b8:	10c00368 	cmpgeui	r3,r2,13
801114bc:	1804241e 	bne	r3,zero,80112550 <vFeeTask1+0x10c4>
801114c0:	100690ba 	slli	r3,r2,2
801114c4:	00a00474 	movhi	r2,32785
801114c8:	10853604 	addi	r2,r2,5336
801114cc:	1885883a 	add	r2,r3,r2
801114d0:	10800017 	ldw	r2,0(r2)
801114d4:	1000683a 	jmp	r2
801114d8:	8011150c 	andi	zero,r16,17492
801114dc:	80111b6c 	andhi	zero,r16,17517
801114e0:	80111bcc 	andi	zero,r16,17519
801114e4:	80111d0c 	andi	zero,r16,17524
801114e8:	8011218c 	andi	zero,r16,17542
801114ec:	801119c0 	call	8801119c <__reset+0x1ff119c>
801114f0:	80111bdc 	xori	zero,r16,17519
801114f4:	801120d4 	ori	zero,r16,17539
801114f8:	80112550 	cmplti	zero,r16,17557
801114fc:	80112550 	cmplti	zero,r16,17557
80111500:	80111d6c 	andhi	zero,r16,17525
80111504:	80112434 	orhi	zero,r16,17552
80111508:	801124f0 	cmpltui	zero,r16,17555
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8011150c:	d0a05817 	ldw	r2,-32416(gp)
80111510:	10800003 	ldbu	r2,0(r2)
80111514:	10c03fcc 	andi	r3,r2,255
80111518:	00a00574 	movhi	r2,32789
8011151c:	109f5404 	addi	r2,r2,32080
80111520:	18c7883a 	add	r3,r3,r3
80111524:	18c7883a 	add	r3,r3,r3
80111528:	10c5883a 	add	r2,r2,r3
8011152c:	10800017 	ldw	r2,0(r2)
80111530:	1009883a 	mov	r4,r2
80111534:	0138f440 	call	80138f44 <OSQFlush>
80111538:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8011153c:	e0bffd03 	ldbu	r2,-12(fp)
80111540:	10803fcc 	andi	r2,r2,255
80111544:	10000126 	beq	r2,zero,8011154c <vFeeTask1+0xc0>
					vFailFlushNFEEQueue();
80111548:	011dbe80 	call	8011dbe8 <vFailFlushNFEEQueue>
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}
				*/

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8011154c:	d0a05817 	ldw	r2,-32416(gp)
80111550:	10803304 	addi	r2,r2,204
80111554:	1009883a 	mov	r4,r2
80111558:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8011155c:	d0a05817 	ldw	r2,-32416(gp)
80111560:	d0e05817 	ldw	r3,-32416(gp)
80111564:	1900308b 	ldhu	r4,194(r3)
80111568:	d0e05817 	ldw	r3,-32416(gp)
8011156c:	18c02f0b 	ldhu	r3,188(r3)
80111570:	20c7883a 	add	r3,r4,r3
80111574:	1809883a 	mov	r4,r3
80111578:	d0e05817 	ldw	r3,-32416(gp)
8011157c:	18c02f8b 	ldhu	r3,190(r3)
80111580:	20c7883a 	add	r3,r4,r3
80111584:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
80111588:	d0a05817 	ldw	r2,-32416(gp)
8011158c:	d0e05817 	ldw	r3,-32416(gp)
80111590:	1900310b 	ldhu	r4,196(r3)
80111594:	d0e05817 	ldw	r3,-32416(gp)
80111598:	18c0300b 	ldhu	r3,192(r3)
8011159c:	20c7883a 	add	r3,r4,r3
801115a0:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
801115a4:	d0a05817 	ldw	r2,-32416(gp)
801115a8:	d0e05817 	ldw	r3,-32416(gp)
801115ac:	18c0310b 	ldhu	r3,196(r3)
801115b0:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
801115b4:	d0a05817 	ldw	r2,-32416(gp)
801115b8:	d0e05817 	ldw	r3,-32416(gp)
801115bc:	18c0300b 	ldhu	r3,192(r3)
801115c0:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
801115c4:	d0a05817 	ldw	r2,-32416(gp)
801115c8:	00e00004 	movi	r3,-32768
801115cc:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
801115d0:	d0a05817 	ldw	r2,-32416(gp)
801115d4:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
801115d8:	d0a05817 	ldw	r2,-32416(gp)
801115dc:	10003685 	stb	zero,218(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucProtocolId = xDefaults.usiDataProtId; /* 0xF0 ou  0x02*/
801115e0:	d0e05817 	ldw	r3,-32416(gp)
801115e4:	00a005b4 	movhi	r2,32790
801115e8:	10ba3604 	addi	r2,r2,-5928
801115ec:	10800c0b 	ldhu	r2,48(r2)
801115f0:	18803705 	stb	r2,220(r3)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucLogicalAddr = xDefaults.usiDpuLogicalAddr + 1;
801115f4:	d0e05817 	ldw	r3,-32416(gp)
801115f8:	00a005b4 	movhi	r2,32790
801115fc:	10ba3604 	addi	r2,r2,-5928
80111600:	10800c8b 	ldhu	r2,50(r2)
80111604:	10800044 	addi	r2,r2,1
80111608:	18803745 	stb	r2,221(r3)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8011160c:	d0a05817 	ldw	r2,-32416(gp)
80111610:	10803304 	addi	r2,r2,204
80111614:	1009883a 	mov	r4,r2
80111618:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8011161c:	d0a05817 	ldw	r2,-32416(gp)
80111620:	10804804 	addi	r2,r2,288
80111624:	1009883a 	mov	r4,r2
80111628:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8011162c:	d0a05817 	ldw	r2,-32416(gp)
80111630:	00ffc004 	movi	r3,-256
80111634:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
80111638:	d0a05817 	ldw	r2,-32416(gp)
8011163c:	00ffc044 	movi	r3,-255
80111640:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
80111644:	d0a05817 	ldw	r2,-32416(gp)
80111648:	00ffc084 	movi	r3,-254
8011164c:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
80111650:	d0a05817 	ldw	r2,-32416(gp)
80111654:	00ffc0c4 	movi	r3,-253
80111658:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8011165c:	d0a05817 	ldw	r2,-32416(gp)
80111660:	00ffc104 	movi	r3,-252
80111664:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
80111668:	d0a05817 	ldw	r2,-32416(gp)
8011166c:	00ffc144 	movi	r3,-251
80111670:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
80111674:	d0a05817 	ldw	r2,-32416(gp)
80111678:	00ffc184 	movi	r3,-250
8011167c:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
80111680:	d0a05817 	ldw	r2,-32416(gp)
80111684:	00ffc1c4 	movi	r3,-249
80111688:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8011168c:	d0a05817 	ldw	r2,-32416(gp)
80111690:	00ffc204 	movi	r3,-248
80111694:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
80111698:	d0a05817 	ldw	r2,-32416(gp)
8011169c:	00ffc244 	movi	r3,-247
801116a0:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
801116a4:	d0a05817 	ldw	r2,-32416(gp)
801116a8:	00ffc284 	movi	r3,-246
801116ac:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
801116b0:	d0a05817 	ldw	r2,-32416(gp)
801116b4:	00ffc2c4 	movi	r3,-245
801116b8:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
801116bc:	d0a05817 	ldw	r2,-32416(gp)
801116c0:	00ffc304 	movi	r3,-244
801116c4:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
801116c8:	d0a05817 	ldw	r2,-32416(gp)
801116cc:	00ffc344 	movi	r3,-243
801116d0:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
801116d4:	d0a05817 	ldw	r2,-32416(gp)
801116d8:	00ffc384 	movi	r3,-242
801116dc:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
801116e0:	d0a05817 	ldw	r2,-32416(gp)
801116e4:	00ffc3c4 	movi	r3,-241
801116e8:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
801116ec:	d0a05817 	ldw	r2,-32416(gp)
801116f0:	00ffc404 	movi	r3,-240
801116f4:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
801116f8:	d0a05817 	ldw	r2,-32416(gp)
801116fc:	00ffc444 	movi	r3,-239
80111700:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
80111704:	d0a05817 	ldw	r2,-32416(gp)
80111708:	00ffc484 	movi	r3,-238
8011170c:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
80111710:	d0a05817 	ldw	r2,-32416(gp)
80111714:	00ffc4c4 	movi	r3,-237
80111718:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8011171c:	d0a05817 	ldw	r2,-32416(gp)
80111720:	00ffc504 	movi	r3,-236
80111724:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
80111728:	d0a05817 	ldw	r2,-32416(gp)
8011172c:	00ffc544 	movi	r3,-235
80111730:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
80111734:	d0a05817 	ldw	r2,-32416(gp)
80111738:	00ffc584 	movi	r3,-234
8011173c:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
80111740:	d0a05817 	ldw	r2,-32416(gp)
80111744:	00ffc5c4 	movi	r3,-233
80111748:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8011174c:	d0a05817 	ldw	r2,-32416(gp)
80111750:	00ffc604 	movi	r3,-232
80111754:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
80111758:	d0a05817 	ldw	r2,-32416(gp)
8011175c:	00ffc644 	movi	r3,-231
80111760:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
80111764:	d0a05817 	ldw	r2,-32416(gp)
80111768:	00ffc684 	movi	r3,-230
8011176c:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
80111770:	d0a05817 	ldw	r2,-32416(gp)
80111774:	00ffc6c4 	movi	r3,-229
80111778:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8011177c:	d0a05817 	ldw	r2,-32416(gp)
80111780:	00ffc704 	movi	r3,-228
80111784:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
80111788:	d0a05817 	ldw	r2,-32416(gp)
8011178c:	00ffc744 	movi	r3,-227
80111790:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
80111794:	d0a05817 	ldw	r2,-32416(gp)
80111798:	00ffc784 	movi	r3,-226
8011179c:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
801117a0:	d0a05817 	ldw	r2,-32416(gp)
801117a4:	00ffc7c4 	movi	r3,-225
801117a8:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
801117ac:	d0a05817 	ldw	r2,-32416(gp)
801117b0:	00ffc804 	movi	r3,-224
801117b4:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
801117b8:	d0a05817 	ldw	r2,-32416(gp)
801117bc:	00ffc844 	movi	r3,-223
801117c0:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
801117c4:	d0a05817 	ldw	r2,-32416(gp)
801117c8:	00ffc884 	movi	r3,-222
801117cc:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
801117d0:	d0a05817 	ldw	r2,-32416(gp)
801117d4:	00ffc8c4 	movi	r3,-221
801117d8:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
801117dc:	d0a05817 	ldw	r2,-32416(gp)
801117e0:	00ffc904 	movi	r3,-220
801117e4:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
801117e8:	d0a05817 	ldw	r2,-32416(gp)
801117ec:	00ffc944 	movi	r3,-219
801117f0:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
801117f4:	d0a05817 	ldw	r2,-32416(gp)
801117f8:	00ffc984 	movi	r3,-218
801117fc:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
80111800:	d0a05817 	ldw	r2,-32416(gp)
80111804:	00ffc9c4 	movi	r3,-217
80111808:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8011180c:	d0a05817 	ldw	r2,-32416(gp)
80111810:	00ffca04 	movi	r3,-216
80111814:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
80111818:	d0a05817 	ldw	r2,-32416(gp)
8011181c:	00ffca44 	movi	r3,-215
80111820:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
80111824:	d0a05817 	ldw	r2,-32416(gp)
80111828:	00ffca84 	movi	r3,-214
8011182c:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
80111830:	d0a05817 	ldw	r2,-32416(gp)
80111834:	00ffcac4 	movi	r3,-213
80111838:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8011183c:	d0a05817 	ldw	r2,-32416(gp)
80111840:	00ffcb04 	movi	r3,-212
80111844:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
80111848:	d0a05817 	ldw	r2,-32416(gp)
8011184c:	00ffcb44 	movi	r3,-211
80111850:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
80111854:	d0a05817 	ldw	r2,-32416(gp)
80111858:	00ffcb84 	movi	r3,-210
8011185c:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
80111860:	d0a05817 	ldw	r2,-32416(gp)
80111864:	00ffcbc4 	movi	r3,-209
80111868:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8011186c:	d0a05817 	ldw	r2,-32416(gp)
80111870:	00ffcc04 	movi	r3,-208
80111874:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
80111878:	d0a05817 	ldw	r2,-32416(gp)
8011187c:	00ffcc44 	movi	r3,-207
80111880:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
80111884:	d0a05817 	ldw	r2,-32416(gp)
80111888:	00ffcc84 	movi	r3,-206
8011188c:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
80111890:	d0a05817 	ldw	r2,-32416(gp)
80111894:	00ffccc4 	movi	r3,-205
80111898:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8011189c:	d0a05817 	ldw	r2,-32416(gp)
801118a0:	00ffcd04 	movi	r3,-204
801118a4:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
801118a8:	d0a05817 	ldw	r2,-32416(gp)
801118ac:	00ffcd44 	movi	r3,-203
801118b0:	10c0888d 	sth	r3,546(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
801118b4:	d0a05817 	ldw	r2,-32416(gp)
801118b8:	00ffcd84 	movi	r3,-202
801118bc:	10c0890d 	sth	r3,548(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
801118c0:	d0a05817 	ldw	r2,-32416(gp)
801118c4:	00ffcdc4 	movi	r3,-201
801118c8:	10c0898d 	sth	r3,550(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
801118cc:	d0a05817 	ldw	r2,-32416(gp)
801118d0:	00ffce04 	movi	r3,-200
801118d4:	10c08a0d 	sth	r3,552(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
801118d8:	d0a05817 	ldw	r2,-32416(gp)
801118dc:	00ffce44 	movi	r3,-199
801118e0:	10c08a8d 	sth	r3,554(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
801118e4:	d0a05817 	ldw	r2,-32416(gp)
801118e8:	00ffce84 	movi	r3,-198
801118ec:	10c08b0d 	sth	r3,556(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
801118f0:	d0a05817 	ldw	r2,-32416(gp)
801118f4:	00ffcec4 	movi	r3,-197
801118f8:	10c08b8d 	sth	r3,558(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
801118fc:	d0a05817 	ldw	r2,-32416(gp)
80111900:	00ffcf04 	movi	r3,-196
80111904:	10c08c0d 	sth	r3,560(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
80111908:	d0a05817 	ldw	r2,-32416(gp)
8011190c:	00ffcf44 	movi	r3,-195
80111910:	10c08c8d 	sth	r3,562(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
80111914:	d0a05817 	ldw	r2,-32416(gp)
80111918:	00ffcf84 	movi	r3,-194
8011191c:	10c08d0d 	sth	r3,564(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
80111920:	d0a05817 	ldw	r2,-32416(gp)
80111924:	00ffcfc4 	movi	r3,-193
80111928:	10c08d8d 	sth	r3,566(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8011192c:	d0a05817 	ldw	r2,-32416(gp)
80111930:	10804804 	addi	r2,r2,288
80111934:	1009883a 	mov	r4,r2
80111938:	0108c180 	call	80108c18 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8011193c:	0110f640 	call	80110f64 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
80111940:	d0a05817 	ldw	r2,-32416(gp)
80111944:	10804804 	addi	r2,r2,288
80111948:	1009883a 	mov	r4,r2
8011194c:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
80111950:	d0a05817 	ldw	r2,-32416(gp)
80111954:	10806e04 	addi	r2,r2,440
80111958:	e0bffb15 	stw	r2,-20(fp)
					fprintf(fp,"\n================= H  K ==================\n\n");
				}
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8011195c:	d0a05817 	ldw	r2,-32416(gp)
80111960:	10804804 	addi	r2,r2,288
80111964:	1009883a 	mov	r4,r2
80111968:	01082300 	call	80108230 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8011196c:	d0e05817 	ldw	r3,-32416(gp)
80111970:	00a005b4 	movhi	r2,32790
80111974:	10ba3604 	addi	r2,r2,-5928
80111978:	1080080b 	ldhu	r2,32(r2)
8011197c:	18804905 	stb	r2,292(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
80111980:	d0e05817 	ldw	r3,-32416(gp)
80111984:	00a005b4 	movhi	r2,32790
80111988:	10ba3604 	addi	r2,r2,-5928
8011198c:	1080088b 	ldhu	r2,34(r2)
80111990:	18804945 	stb	r2,293(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
80111994:	d0a05817 	ldw	r2,-32416(gp)
80111998:	10804804 	addi	r2,r2,288
8011199c:	1009883a 	mov	r4,r2
801119a0:	01081540 	call	80108154 <bRmapSetCodecConfig>
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", pxNFee->ucId ,xDefaults.ucRmapKey );
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", pxNFee->ucId, xDefaults.ucLogicalAddr);
				}
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
801119a4:	d0a05817 	ldw	r2,-32416(gp)
801119a8:	00c00144 	movi	r3,5
801119ac:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
801119b0:	d0a05817 	ldw	r2,-32416(gp)
801119b4:	10802e17 	ldw	r2,184(r2)
801119b8:	d0a05705 	stb	r2,-32420(gp)

				break;
801119bc:	0002f106 	br	80112584 <vFeeTask1+0x10f8>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
801119c0:	d0a05817 	ldw	r2,-32416(gp)
801119c4:	10804804 	addi	r2,r2,288
801119c8:	1009883a 	mov	r4,r2
801119cc:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
801119d0:	d0a05817 	ldw	r2,-32416(gp)
801119d4:	00c00184 	movi	r3,6
801119d8:	10c06b15 	stw	r3,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
801119dc:	d0a05817 	ldw	r2,-32416(gp)
801119e0:	10804804 	addi	r2,r2,288
801119e4:	1009883a 	mov	r4,r2
801119e8:	010857c0 	call	8010857c <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
801119ec:	d0a05817 	ldw	r2,-32416(gp)
801119f0:	10808e04 	addi	r2,r2,568
801119f4:	1009883a 	mov	r4,r2
801119f8:	01103080 	call	80110308 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
801119fc:	d0a05817 	ldw	r2,-32416(gp)
80111a00:	10002615 	stw	zero,152(r2)
				bSetPainelLeds( LEDS_OFF , uliReturnMaskG( pxNFee->ucSPWId ) );
80111a04:	d0a05817 	ldw	r2,-32416(gp)
80111a08:	10800043 	ldbu	r2,1(r2)
80111a0c:	10803fcc 	andi	r2,r2,255
80111a10:	1009883a 	mov	r4,r2
80111a14:	0110e840 	call	80110e84 <uliReturnMaskG>
80111a18:	100b883a 	mov	r5,r2
80111a1c:	0009883a 	mov	r4,zero
80111a20:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , uliReturnMaskR( pxNFee->ucSPWId ) );
80111a24:	d0a05817 	ldw	r2,-32416(gp)
80111a28:	10800043 	ldbu	r2,1(r2)
80111a2c:	10803fcc 	andi	r2,r2,255
80111a30:	1009883a 	mov	r4,r2
80111a34:	0110da40 	call	80110da4 <uliReturnMaskR>
80111a38:	100b883a 	mov	r5,r2
80111a3c:	01000044 	movi	r4,1
80111a40:	010bb640 	call	8010bb64 <bSetPainelLeds>

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
80111a44:	d0a05817 	ldw	r2,-32416(gp)
80111a48:	10c04804 	addi	r3,r2,288
80111a4c:	d0a05817 	ldw	r2,-32416(gp)
80111a50:	10800043 	ldbu	r2,1(r2)
80111a54:	10803fcc 	andi	r2,r2,255
80111a58:	100b883a 	mov	r5,r2
80111a5c:	1809883a 	mov	r4,r3
80111a60:	011025c0 	call	8011025c <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80111a64:	d0a05817 	ldw	r2,-32416(gp)
80111a68:	10803b04 	addi	r2,r2,236
80111a6c:	1009883a 	mov	r4,r2
80111a70:	01104600 	call	80110460 <bDisAndClrDbBuffer>
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
				}
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
80111a74:	d0a05817 	ldw	r2,-32416(gp)
80111a78:	10802217 	ldw	r2,136(r2)
80111a7c:	10800058 	cmpnei	r2,r2,1
80111a80:	10000a1e 	bne	r2,zero,80111aac <vFeeTask1+0x620>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
80111a84:	e0fff503 	ldbu	r3,-44(fp)
80111a88:	00a005b4 	movhi	r2,32790
80111a8c:	10ad6e04 	addi	r2,r2,-19016
80111a90:	180690fa 	slli	r3,r3,3
80111a94:	10c5883a 	add	r2,r2,r3
80111a98:	10800017 	ldw	r2,0(r2)
80111a9c:	1009883a 	mov	r4,r2
80111aa0:	01384940 	call	80138494 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
80111aa4:	d0a05817 	ldw	r2,-32416(gp)
80111aa8:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
80111aac:	d0a05817 	ldw	r2,-32416(gp)
80111ab0:	10002815 	stw	zero,160(r2)
					vFailFlushNFEEQueue();
				}
				*/

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
80111ab4:	d0a05817 	ldw	r2,-32416(gp)
80111ab8:	10800003 	ldbu	r2,0(r2)
80111abc:	10803fcc 	andi	r2,r2,255
80111ac0:	100d883a 	mov	r6,r2
80111ac4:	000b883a 	mov	r5,zero
80111ac8:	01002044 	movi	r4,129
80111acc:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
80111ad0:	d0a05817 	ldw	r2,-32416(gp)
80111ad4:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
80111ad8:	d0a05817 	ldw	r2,-32416(gp)
80111adc:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
80111ae0:	d0a05817 	ldw	r2,-32416(gp)
80111ae4:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
80111ae8:	d0a05817 	ldw	r2,-32416(gp)
80111aec:	00c00044 	movi	r3,1
80111af0:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
80111af4:	d0a05817 	ldw	r2,-32416(gp)
80111af8:	1009883a 	mov	r4,r2
80111afc:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
80111b00:	d0a05817 	ldw	r2,-32416(gp)
80111b04:	10800003 	ldbu	r2,0(r2)
80111b08:	10c03fcc 	andi	r3,r2,255
80111b0c:	00a00574 	movhi	r2,32789
80111b10:	109f5404 	addi	r2,r2,32080
80111b14:	18c7883a 	add	r3,r3,r3
80111b18:	18c7883a 	add	r3,r3,r3
80111b1c:	10c5883a 	add	r2,r2,r3
80111b20:	10800017 	ldw	r2,0(r2)
80111b24:	1009883a 	mov	r4,r2
80111b28:	0138f440 	call	80138f44 <OSQFlush>
80111b2c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
80111b30:	e0bffd03 	ldbu	r2,-12(fp)
80111b34:	10803fcc 	andi	r2,r2,255
80111b38:	10000126 	beq	r2,zero,80111b40 <vFeeTask1+0x6b4>
					vFailFlushNFEEQueue();
80111b3c:	011dbe80 	call	8011dbe8 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
80111b40:	d0a05817 	ldw	r2,-32416(gp)
80111b44:	00c00044 	movi	r3,1
80111b48:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
80111b4c:	d0a05817 	ldw	r2,-32416(gp)
80111b50:	00c00044 	movi	r3,1
80111b54:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
80111b58:	d0a05817 	ldw	r2,-32416(gp)
80111b5c:	10802e17 	ldw	r2,184(r2)
80111b60:	d0a05705 	stb	r2,-32420(gp)
				bFinal = FALSE;
80111b64:	e03ffa15 	stw	zero,-24(fp)
				break;
80111b68:	00028606 	br	80112584 <vFeeTask1+0x10f8>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80111b6c:	d0a05817 	ldw	r2,-32416(gp)
80111b70:	10800003 	ldbu	r2,0(r2)
80111b74:	10c03fcc 	andi	r3,r2,255
80111b78:	00a00574 	movhi	r2,32789
80111b7c:	109f5404 	addi	r2,r2,32080
80111b80:	18c7883a 	add	r3,r3,r3
80111b84:	18c7883a 	add	r3,r3,r3
80111b88:	10c5883a 	add	r2,r2,r3
80111b8c:	10800017 	ldw	r2,0(r2)
80111b90:	e0fffd04 	addi	r3,fp,-12
80111b94:	180d883a 	mov	r6,r3
80111b98:	000b883a 	mov	r5,zero
80111b9c:	1009883a 	mov	r4,r2
80111ba0:	01390040 	call	80139004 <OSQPend>
80111ba4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
80111ba8:	e0bffd03 	ldbu	r2,-12(fp)
80111bac:	10803fcc 	andi	r2,r2,255
80111bb0:	10026b1e 	bne	r2,zero,80112560 <vFeeTask1+0x10d4>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
80111bb4:	d0a05817 	ldw	r2,-32416(gp)
80111bb8:	e0fffe17 	ldw	r3,-8(fp)
80111bbc:	180b883a 	mov	r5,r3
80111bc0:	1009883a 	mov	r4,r2
80111bc4:	010f56c0 	call	8010f56c <vQCmdFEEinConfig>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80111bc8:	00026506 	br	80112560 <vFeeTask1+0x10d4>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
80111bcc:	d0a05817 	ldw	r2,-32416(gp)
80111bd0:	00c00184 	movi	r3,6
80111bd4:	10c02c15 	stw	r3,176(r2)
				break;
80111bd8:	00026a06 	br	80112584 <vFeeTask1+0x10f8>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
80111bdc:	d0a05817 	ldw	r2,-32416(gp)
80111be0:	10804804 	addi	r2,r2,288
80111be4:	1009883a 	mov	r4,r2
80111be8:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
80111bec:	d0a05817 	ldw	r2,-32416(gp)
80111bf0:	10006b15 	stw	zero,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
80111bf4:	d0a05817 	ldw	r2,-32416(gp)
80111bf8:	10804804 	addi	r2,r2,288
80111bfc:	1009883a 	mov	r4,r2
80111c00:	010857c0 	call	8010857c <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80111c04:	d0a05817 	ldw	r2,-32416(gp)
80111c08:	10803b04 	addi	r2,r2,236
80111c0c:	1009883a 	mov	r4,r2
80111c10:	01104600 	call	80110460 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
80111c14:	d0a05817 	ldw	r2,-32416(gp)
80111c18:	10c04804 	addi	r3,r2,288
80111c1c:	d0a05817 	ldw	r2,-32416(gp)
80111c20:	10800003 	ldbu	r2,0(r2)
80111c24:	10803fcc 	andi	r2,r2,255
80111c28:	100b883a 	mov	r5,r2
80111c2c:	1809883a 	mov	r4,r3
80111c30:	01102b00 	call	801102b0 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
80111c34:	d0a05817 	ldw	r2,-32416(gp)
80111c38:	10808e04 	addi	r2,r2,568
80111c3c:	1009883a 	mov	r4,r2
80111c40:	01103680 	call	80110368 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
80111c44:	d0a05817 	ldw	r2,-32416(gp)
80111c48:	00c00044 	movi	r3,1
80111c4c:	10c02615 	stw	r3,152(r2)
				bSetPainelLeds( LEDS_OFF , uliReturnMaskR( pxNFee->ucSPWId ) );
80111c50:	d0a05817 	ldw	r2,-32416(gp)
80111c54:	10800043 	ldbu	r2,1(r2)
80111c58:	10803fcc 	andi	r2,r2,255
80111c5c:	1009883a 	mov	r4,r2
80111c60:	0110da40 	call	80110da4 <uliReturnMaskR>
80111c64:	100b883a 	mov	r5,r2
80111c68:	0009883a 	mov	r4,zero
80111c6c:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , uliReturnMaskG( pxNFee->ucSPWId ) );
80111c70:	d0a05817 	ldw	r2,-32416(gp)
80111c74:	10800043 	ldbu	r2,1(r2)
80111c78:	10803fcc 	andi	r2,r2,255
80111c7c:	1009883a 	mov	r4,r2
80111c80:	0110e840 	call	80110e84 <uliReturnMaskG>
80111c84:	100b883a 	mov	r5,r2
80111c88:	01000044 	movi	r4,1
80111c8c:	010bb640 	call	8010bb64 <bSetPainelLeds>


				pxNFee->xControl.bSimulating = TRUE;
80111c90:	d0a05817 	ldw	r2,-32416(gp)
80111c94:	00c00044 	movi	r3,1
80111c98:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
80111c9c:	d0a05817 	ldw	r2,-32416(gp)
80111ca0:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
80111ca4:	d0a05817 	ldw	r2,-32416(gp)
80111ca8:	00c00044 	movi	r3,1
80111cac:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
80111cb0:	d0a05817 	ldw	r2,-32416(gp)
80111cb4:	10800003 	ldbu	r2,0(r2)
80111cb8:	10803fcc 	andi	r2,r2,255
80111cbc:	100d883a 	mov	r6,r2
80111cc0:	000b883a 	mov	r5,zero
80111cc4:	01002044 	movi	r4,129
80111cc8:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
80111ccc:	d0a05817 	ldw	r2,-32416(gp)
80111cd0:	10002815 	stw	zero,160(r2)
					fprintf(fp,"NFEE-%hu Task: Standby\n", pxNFee->ucId);
				}
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
80111cd4:	d0a05817 	ldw	r2,-32416(gp)
80111cd8:	1009883a 	mov	r4,r2
80111cdc:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				incrementador = 0;
80111ce0:	d0205915 	stw	zero,-32412(gp)

				pxNFee->xControl.bWatingSync = TRUE;
80111ce4:	d0a05817 	ldw	r2,-32416(gp)
80111ce8:	00c00044 	movi	r3,1
80111cec:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
80111cf0:	d0a05817 	ldw	r2,-32416(gp)
80111cf4:	00c000c4 	movi	r3,3
80111cf8:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
80111cfc:	d0a05817 	ldw	r2,-32416(gp)
80111d00:	10802e17 	ldw	r2,184(r2)
80111d04:	d0a05705 	stb	r2,-32420(gp)
				break;
80111d08:	00021e06 	br	80112584 <vFeeTask1+0x10f8>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80111d0c:	d0a05817 	ldw	r2,-32416(gp)
80111d10:	10800003 	ldbu	r2,0(r2)
80111d14:	10c03fcc 	andi	r3,r2,255
80111d18:	00a00574 	movhi	r2,32789
80111d1c:	109f5404 	addi	r2,r2,32080
80111d20:	18c7883a 	add	r3,r3,r3
80111d24:	18c7883a 	add	r3,r3,r3
80111d28:	10c5883a 	add	r2,r2,r3
80111d2c:	10800017 	ldw	r2,0(r2)
80111d30:	e0fffd04 	addi	r3,fp,-12
80111d34:	180d883a 	mov	r6,r3
80111d38:	000b883a 	mov	r5,zero
80111d3c:	1009883a 	mov	r4,r2
80111d40:	01390040 	call	80139004 <OSQPend>
80111d44:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
80111d48:	e0bffd03 	ldbu	r2,-12(fp)
80111d4c:	10803fcc 	andi	r2,r2,255
80111d50:	1002051e 	bne	r2,zero,80112568 <vFeeTask1+0x10dc>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
80111d54:	d0a05817 	ldw	r2,-32416(gp)
80111d58:	e0fffe17 	ldw	r3,-8(fp)
80111d5c:	180b883a 	mov	r5,r3
80111d60:	1009883a 	mov	r4,r2
80111d64:	010f6a80 	call	8010f6a8 <vQCmdFEEinStandBy>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80111d68:	0001ff06 	br	80112568 <vFeeTask1+0x10dc>
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}
				*/

				pxNFee->xControl.bUsingDMA = TRUE;
80111d6c:	d0a05817 	ldw	r2,-32416(gp)
80111d70:	00c00044 	movi	r3,1
80111d74:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
80111d78:	d0a05817 	ldw	r2,-32416(gp)
80111d7c:	00c00044 	movi	r3,1
80111d80:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
80111d84:	d0a05817 	ldw	r2,-32416(gp)
80111d88:	1009883a 	mov	r4,r2
80111d8c:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				/* Wait until both buffers are empty  */
				vWaitUntilBufferEmpty( pxNFee->ucSPWId );
80111d90:	d0a05817 	ldw	r2,-32416(gp)
80111d94:	10800043 	ldbu	r2,1(r2)
80111d98:	10803fcc 	andi	r2,r2,255
80111d9c:	1009883a 	mov	r4,r2
80111da0:	0110c9c0 	call	80110c9c <vWaitUntilBufferEmpty>
					while ( (bFeebGetCh2LeftFeeBusy()== TRUE) || (bFeebGetCh2RightFeeBusy()== TRUE)  ) {}
				}
				*/


				OSTimeDlyHMSM(0,0,0,xDefaults.usiGuardNFEEDelay);
80111da4:	00a005b4 	movhi	r2,32790
80111da8:	10ba3604 	addi	r2,r2,-5928
80111dac:	10800b8b 	ldhu	r2,46(r2)
80111db0:	10bfffcc 	andi	r2,r2,65535
80111db4:	100f883a 	mov	r7,r2
80111db8:	000d883a 	mov	r6,zero
80111dbc:	000b883a 	mov	r5,zero
80111dc0:	0009883a 	mov	r4,zero
80111dc4:	013be940 	call	8013be94 <OSTimeDlyHMSM>

				vSetDoubleBufferLeftSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80111dc8:	d0a05817 	ldw	r2,-32416(gp)
80111dcc:	10800043 	ldbu	r2,1(r2)
80111dd0:	10803fcc 	andi	r2,r2,255
80111dd4:	100b883a 	mov	r5,r2
80111dd8:	01000404 	movi	r4,16
80111ddc:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
				vSetDoubleBufferRightSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80111de0:	d0a05817 	ldw	r2,-32416(gp)
80111de4:	10800043 	ldbu	r2,1(r2)
80111de8:	10803fcc 	andi	r2,r2,255
80111dec:	100b883a 	mov	r5,r2
80111df0:	01000404 	movi	r4,16
80111df4:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}*/

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80111df8:	d0a05817 	ldw	r2,-32416(gp)
80111dfc:	10803b04 	addi	r2,r2,236
80111e00:	1009883a 	mov	r4,r2
80111e04:	01103c80 	call	801103c8 <bEnableDbBuffer>

				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
80111e08:	d0a05817 	ldw	r2,-32416(gp)
80111e0c:	10808e04 	addi	r2,r2,568
80111e10:	1009883a 	mov	r4,r2
80111e14:	010ada00 	call	8010ada0 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
80111e18:	d0a05817 	ldw	r2,-32416(gp)
80111e1c:	10809a43 	ldbu	r2,617(r2)
80111e20:	10803fcc 	andi	r2,r2,255
80111e24:	d0a05a15 	stw	r2,-32408(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
80111e28:	d0a05a17 	ldw	r2,-32408(gp)
80111e2c:	10800044 	addi	r2,r2,1
80111e30:	108000cc 	andi	r2,r2,3
80111e34:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
80111e38:	e0bffc17 	ldw	r2,-16(fp)
80111e3c:	10000e1e 	bne	r2,zero,80111e78 <vFeeTask1+0x9ec>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
80111e40:	d0a05817 	ldw	r2,-32416(gp)
80111e44:	10802917 	ldw	r2,164(r2)
80111e48:	10800003 	ldbu	r2,0(r2)
80111e4c:	10803fcc 	andi	r2,r2,255
80111e50:	10c00044 	addi	r3,r2,1
80111e54:	00a00034 	movhi	r2,32768
80111e58:	10800044 	addi	r2,r2,1
80111e5c:	1884703a 	and	r2,r3,r2
80111e60:	1000040e 	bge	r2,zero,80111e74 <vFeeTask1+0x9e8>
80111e64:	10bfffc4 	addi	r2,r2,-1
80111e68:	00ffff84 	movi	r3,-2
80111e6c:	10c4b03a 	or	r2,r2,r3
80111e70:	10800044 	addi	r2,r2,1
80111e74:	e0bff505 	stb	r2,-44(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
80111e78:	d0e05817 	ldw	r3,-32416(gp)
80111e7c:	e0bffc17 	ldw	r2,-16(fp)
80111e80:	1885883a 	add	r2,r3,r2
80111e84:	10802a44 	addi	r2,r2,169
80111e88:	10800003 	ldbu	r2,0(r2)
80111e8c:	e0bff705 	stb	r2,-36(fp)

				if ( pxNFee->xControl.eSide == sLeft )
80111e90:	d0a05817 	ldw	r2,-32416(gp)
80111e94:	10802e17 	ldw	r2,184(r2)
80111e98:	1000071e 	bne	r2,zero,80111eb8 <vFeeTask1+0xa2c>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
80111e9c:	d0e05817 	ldw	r3,-32416(gp)
80111ea0:	e0bff703 	ldbu	r2,-36(fp)
80111ea4:	10800624 	muli	r2,r2,24
80111ea8:	10800904 	addi	r2,r2,36
80111eac:	1885883a 	add	r2,r3,r2
80111eb0:	e0bff615 	stw	r2,-40(fp)
80111eb4:	00000606 	br	80111ed0 <vFeeTask1+0xa44>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
80111eb8:	d0e05817 	ldw	r3,-32416(gp)
80111ebc:	e0bff703 	ldbu	r2,-36(fp)
80111ec0:	10800624 	muli	r2,r2,24
80111ec4:	10800c04 	addi	r2,r2,48
80111ec8:	1885883a 	add	r2,r3,r2
80111ecc:	e0bff615 	stw	r2,-40(fp)

				ucIterationSide = pxNFee->xControl.eSide;
80111ed0:	d0a05817 	ldw	r2,-32416(gp)
80111ed4:	10802e17 	ldw	r2,184(r2)
80111ed8:	d0a05705 	stb	r2,-32420(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80111edc:	d0a05817 	ldw	r2,-32416(gp)
80111ee0:	10803304 	addi	r2,r2,204
80111ee4:	1009883a 	mov	r4,r2
80111ee8:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
80111eec:	d0a05817 	ldw	r2,-32416(gp)
80111ef0:	e0fff703 	ldbu	r3,-36(fp)
80111ef4:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern;
80111ef8:	d0a05817 	ldw	r2,-32416(gp)
80111efc:	00c00244 	movi	r3,9
80111f00:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
80111f04:	d0a05817 	ldw	r2,-32416(gp)
80111f08:	10803304 	addi	r2,r2,204
80111f0c:	1009883a 	mov	r4,r2
80111f10:	0102c480 	call	80102c48 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80111f14:	d0a05817 	ldw	r2,-32416(gp)
80111f18:	10803304 	addi	r2,r2,204
80111f1c:	1009883a 	mov	r4,r2
80111f20:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
					fprintf(fp,"=========DATA PACKET=============\n");
				}
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
80111f24:	d0a05817 	ldw	r2,-32416(gp)
80111f28:	10800003 	ldbu	r2,0(r2)
80111f2c:	10803fcc 	andi	r2,r2,255
80111f30:	100d883a 	mov	r6,r2
80111f34:	000b883a 	mov	r5,zero
80111f38:	01002004 	movi	r4,128
80111f3c:	01104cc0 	call	801104cc <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
80111f40:	e03ff915 	stw	zero,-28(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80111f44:	d0a05817 	ldw	r2,-32416(gp)
80111f48:	10800003 	ldbu	r2,0(r2)
80111f4c:	10c03fcc 	andi	r3,r2,255
80111f50:	00a00574 	movhi	r2,32789
80111f54:	109f5404 	addi	r2,r2,32080
80111f58:	18c7883a 	add	r3,r3,r3
80111f5c:	18c7883a 	add	r3,r3,r3
80111f60:	10c5883a 	add	r2,r2,r3
80111f64:	10800017 	ldw	r2,0(r2)
80111f68:	e0fffd04 	addi	r3,fp,-12
80111f6c:	180d883a 	mov	r6,r3
80111f70:	000b883a 	mov	r5,zero
80111f74:	1009883a 	mov	r4,r2
80111f78:	01390040 	call	80139004 <OSQPend>
80111f7c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
80111f80:	e0bffd03 	ldbu	r2,-12(fp)
80111f84:	10803fcc 	andi	r2,r2,255
80111f88:	1001791e 	bne	r2,zero,80112570 <vFeeTask1+0x10e4>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
80111f8c:	e0bffe83 	ldbu	r2,-6(fp)
80111f90:	10803fcc 	andi	r2,r2,255
80111f94:	108023d8 	cmpnei	r2,r2,143
80111f98:	1000481e 	bne	r2,zero,801120bc <vFeeTask1+0xc30>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
80111f9c:	e0fff503 	ldbu	r3,-44(fp)
80111fa0:	00a005b4 	movhi	r2,32790
80111fa4:	10ad6e04 	addi	r2,r2,-19016
80111fa8:	180690fa 	slli	r3,r3,3
80111fac:	10c5883a 	add	r2,r2,r3
80111fb0:	10800017 	ldw	r2,0(r2)
80111fb4:	e0fffd04 	addi	r3,fp,-12
80111fb8:	180d883a 	mov	r6,r3
80111fbc:	000b883a 	mov	r5,zero
80111fc0:	1009883a 	mov	r4,r2
80111fc4:	0137ef00 	call	80137ef0 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
80111fc8:	e0bffd03 	ldbu	r2,-12(fp)
80111fcc:	10803fcc 	andi	r2,r2,255
80111fd0:	10001b1e 	bne	r2,zero,80112040 <vFeeTask1+0xbb4>
	                    	pxNFee->xControl.bDMALocked = TRUE;
80111fd4:	d0a05817 	ldw	r2,-32416(gp)
80111fd8:	00c00044 	movi	r3,1
80111fdc:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee, ucIterationSide );
80111fe0:	e0fff503 	ldbu	r3,-44(fp)
80111fe4:	d0a05817 	ldw	r2,-32416(gp)
80111fe8:	10800003 	ldbu	r2,0(r2)
80111fec:	11003fcc 	andi	r4,r2,255
80111ff0:	d1605817 	ldw	r5,-32416(gp)
80111ff4:	d0a05703 	ldbu	r2,-32420(gp)
80111ff8:	10803fcc 	andi	r2,r2,255
80111ffc:	d8800015 	stw	r2,0(sp)
80112000:	280f883a 	mov	r7,r5
80112004:	200d883a 	mov	r6,r4
80112008:	180b883a 	mov	r5,r3
8011200c:	e13ff617 	ldw	r4,-40(fp)
80112010:	01106b80 	call	801106b8 <bPrepareDoubleBuffer>
80112014:	e0bff915 	stw	r2,-28(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
80112018:	e0fff503 	ldbu	r3,-44(fp)
8011201c:	00a005b4 	movhi	r2,32790
80112020:	10ad6e04 	addi	r2,r2,-19016
80112024:	180690fa 	slli	r3,r3,3
80112028:	10c5883a 	add	r2,r2,r3
8011202c:	10800017 	ldw	r2,0(r2)
80112030:	1009883a 	mov	r4,r2
80112034:	01384940 	call	80138494 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
80112038:	d0a05817 	ldw	r2,-32416(gp)
8011203c:	10002215 	stw	zero,136(r2)

						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
80112040:	d0a05817 	ldw	r2,-32416(gp)
80112044:	10800003 	ldbu	r2,0(r2)
80112048:	10803fcc 	andi	r2,r2,255
8011204c:	100d883a 	mov	r6,r2
80112050:	000b883a 	mov	r5,zero
80112054:	01002044 	movi	r4,129
80112058:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8011205c:	e0bff917 	ldw	r2,-28(fp)
80112060:	10800058 	cmpnei	r2,r2,1
80112064:	1001421e 	bne	r2,zero,80112570 <vFeeTask1+0x10e4>
							if (pxNFee->xControl.bWatingSync==TRUE) {
80112068:	d0a05817 	ldw	r2,-32416(gp)
8011206c:	10802817 	ldw	r2,160(r2)
80112070:	10800058 	cmpnei	r2,r2,1
80112074:	1000071e 	bne	r2,zero,80112094 <vFeeTask1+0xc08>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
80112078:	d0a05817 	ldw	r2,-32416(gp)
8011207c:	00c001c4 	movi	r3,7
80112080:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
80112084:	d0a05817 	ldw	r2,-32416(gp)
80112088:	00c00304 	movi	r3,12
8011208c:	10c02c15 	stw	r3,176(r2)
80112090:	00000606 	br	801120ac <vFeeTask1+0xc20>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
80112094:	d0a05817 	ldw	r2,-32416(gp)
80112098:	00c001c4 	movi	r3,7
8011209c:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
801120a0:	d0a05817 	ldw	r2,-32416(gp)
801120a4:	00c001c4 	movi	r3,7
801120a8:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
801120ac:	d0a05917 	ldw	r2,-32412(gp)
801120b0:	10800044 	addi	r2,r2,1
801120b4:	d0a05915 	stw	r2,-32412(gp)
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
801120b8:	00012d06 	br	80112570 <vFeeTask1+0x10e4>
								fprintf(fp,"\nNFEE-%hu Task: Could not prepare the double buffer\n", pxNFee->ucId);
							}
							#endif
						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
801120bc:	d0a05817 	ldw	r2,-32416(gp)
801120c0:	e0fffe17 	ldw	r3,-8(fp)
801120c4:	180b883a 	mov	r5,r3
801120c8:	1009883a 	mov	r4,r2
801120cc:	010f8380 	call	8010f838 <vQCmdFEEinFullPattern>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
801120d0:	00012706 	br	80112570 <vFeeTask1+0x10e4>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
801120d4:	e03ffa15 	stw	zero,-24(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
801120d8:	d0a05817 	ldw	r2,-32416(gp)
801120dc:	10804804 	addi	r2,r2,288
801120e0:	1009883a 	mov	r4,r2
801120e4:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
801120e8:	d0a05817 	ldw	r2,-32416(gp)
801120ec:	00c00084 	movi	r3,2
801120f0:	10c06b15 	stw	r3,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
801120f4:	d0a05817 	ldw	r2,-32416(gp)
801120f8:	10804804 	addi	r2,r2,288
801120fc:	1009883a 	mov	r4,r2
80112100:	010857c0 	call	8010857c <bRmapSetMemConfigArea>
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
				}
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
80112104:	d0a05817 	ldw	r2,-32416(gp)
80112108:	10802e17 	ldw	r2,184(r2)
8011210c:	d0a05705 	stb	r2,-32420(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
80112110:	d0a05817 	ldw	r2,-32416(gp)
80112114:	00c00044 	movi	r3,1
80112118:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8011211c:	d0a05817 	ldw	r2,-32416(gp)
80112120:	00c00104 	movi	r3,4
80112124:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
80112128:	d0a05817 	ldw	r2,-32416(gp)
8011212c:	00c00104 	movi	r3,4
80112130:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
80112134:	d0a05817 	ldw	r2,-32416(gp)
80112138:	00c00044 	movi	r3,1
8011213c:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
80112140:	d0a05817 	ldw	r2,-32416(gp)
80112144:	00c00044 	movi	r3,1
80112148:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8011214c:	d0a05817 	ldw	r2,-32416(gp)
80112150:	00c00044 	movi	r3,1
80112154:	10c02115 	stw	r3,132(r2)
				//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				vSetDoubleBufferLeftSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80112158:	d0a05817 	ldw	r2,-32416(gp)
8011215c:	10800043 	ldbu	r2,1(r2)
80112160:	10803fcc 	andi	r2,r2,255
80112164:	100b883a 	mov	r5,r2
80112168:	01000404 	movi	r4,16
8011216c:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
				vSetDoubleBufferRightSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80112170:	d0a05817 	ldw	r2,-32416(gp)
80112174:	10800043 	ldbu	r2,1(r2)
80112178:	10803fcc 	andi	r2,r2,255
8011217c:	100b883a 	mov	r5,r2
80112180:	01000404 	movi	r4,16
80112184:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}*/

				break;
80112188:	0000fe06 	br	80112584 <vFeeTask1+0x10f8>

			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8011218c:	e03ffa15 	stw	zero,-24(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80112190:	d0a05817 	ldw	r2,-32416(gp)
80112194:	10800003 	ldbu	r2,0(r2)
80112198:	10c03fcc 	andi	r3,r2,255
8011219c:	00a00574 	movhi	r2,32789
801121a0:	109f5404 	addi	r2,r2,32080
801121a4:	18c7883a 	add	r3,r3,r3
801121a8:	18c7883a 	add	r3,r3,r3
801121ac:	10c5883a 	add	r2,r2,r3
801121b0:	10800017 	ldw	r2,0(r2)
801121b4:	e0fffd04 	addi	r3,fp,-12
801121b8:	180d883a 	mov	r6,r3
801121bc:	000b883a 	mov	r5,zero
801121c0:	1009883a 	mov	r4,r2
801121c4:	01390040 	call	80139004 <OSQPend>
801121c8:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
801121cc:	e0bffd03 	ldbu	r2,-12(fp)
801121d0:	10803fcc 	andi	r2,r2,255
801121d4:	1000e81e 	bne	r2,zero,80112578 <vFeeTask1+0x10ec>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
801121d8:	e0bffe83 	ldbu	r2,-6(fp)
801121dc:	10803fcc 	andi	r2,r2,255
801121e0:	108023d8 	cmpnei	r2,r2,143
801121e4:	1000861e 	bne	r2,zero,80112400 <vFeeTask1+0xf74>

						/* Try to get the Mutex */
						OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
801121e8:	e0fff503 	ldbu	r3,-44(fp)
801121ec:	00a005b4 	movhi	r2,32790
801121f0:	10ad6e04 	addi	r2,r2,-19016
801121f4:	180690fa 	slli	r3,r3,3
801121f8:	10c5883a 	add	r2,r2,r3
801121fc:	10800017 	ldw	r2,0(r2)
80112200:	e0fffd04 	addi	r3,fp,-12
80112204:	180d883a 	mov	r6,r3
80112208:	000b883a 	mov	r5,zero
8011220c:	1009883a 	mov	r4,r2
80112210:	0137ef00 	call	80137ef0 <OSMutexPend>
						if ( error_code == OS_ERR_NONE ) {
80112214:	e0bffd03 	ldbu	r2,-12(fp)
80112218:	10803fcc 	andi	r2,r2,255
8011221c:	1000d61e 	bne	r2,zero,80112578 <vFeeTask1+0x10ec>
							pxNFee->xControl.bDMALocked = TRUE;
80112220:	d0a05817 	ldw	r2,-32416(gp)
80112224:	00c00044 	movi	r3,1
80112228:	10c02215 	stw	r3,136(r2)

							/* Is this the last block? */
							if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8011222c:	e0bff617 	ldw	r2,-40(fp)
80112230:	10800117 	ldw	r2,4(r2)
80112234:	10c00404 	addi	r3,r2,16
80112238:	d0a05817 	ldw	r2,-32416(gp)
8011223c:	10800417 	ldw	r2,16(r2)
80112240:	18801936 	bltu	r3,r2,801122a8 <vFeeTask1+0xe1c>

								/*Define the size of the data in the double buffer (need this to create the interrupt right)*/
								usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
80112244:	d0a05817 	ldw	r2,-32416(gp)
80112248:	10c00417 	ldw	r3,16(r2)
8011224c:	e0bff617 	ldw	r2,-40(fp)
80112250:	10800117 	ldw	r2,4(r2)
80112254:	1885c83a 	sub	r2,r3,r2
80112258:	e0bff815 	stw	r2,-32(fp)

								vSetDoubleBufferLeftSize( (unsigned char)usiLengthBlocks, pxNFee->ucSPWId );
8011225c:	e0bff817 	ldw	r2,-32(fp)
80112260:	10c03fcc 	andi	r3,r2,255
80112264:	d0a05817 	ldw	r2,-32416(gp)
80112268:	10800043 	ldbu	r2,1(r2)
8011226c:	10803fcc 	andi	r2,r2,255
80112270:	100b883a 	mov	r5,r2
80112274:	1809883a 	mov	r4,r3
80112278:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
								vSetDoubleBufferRightSize( (unsigned char)usiLengthBlocks, pxNFee->ucSPWId );
8011227c:	e0bff817 	ldw	r2,-32(fp)
80112280:	10c03fcc 	andi	r3,r2,255
80112284:	d0a05817 	ldw	r2,-32416(gp)
80112288:	10800043 	ldbu	r2,1(r2)
8011228c:	10803fcc 	andi	r2,r2,255
80112290:	100b883a 	mov	r5,r2
80112294:	1809883a 	mov	r4,r3
80112298:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
								} else {
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
								}*/

								bFinal = TRUE;
8011229c:	00800044 	movi	r2,1
801122a0:	e0bffa15 	stw	r2,-24(fp)
801122a4:	00000206 	br	801122b0 <vFeeTask1+0xe24>

							} else {
								usiLengthBlocks = SDMA_MAX_BLOCKS;
801122a8:	00800404 	movi	r2,16
801122ac:	e0bff815 	stw	r2,-32(fp)
							}


							if ( ucMemUsing == 0  ) {
801122b0:	e0bff503 	ldbu	r2,-44(fp)
801122b4:	1000111e 	bne	r2,zero,801122fc <vFeeTask1+0xe70>
								bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
801122b8:	e0bff617 	ldw	r2,-40(fp)
801122bc:	10800217 	ldw	r2,8(r2)
801122c0:	1011883a 	mov	r8,r2
801122c4:	e0bff817 	ldw	r2,-32(fp)
801122c8:	10ffffcc 	andi	r3,r2,65535
801122cc:	d0a05703 	ldbu	r2,-32420(gp)
801122d0:	11003fcc 	andi	r4,r2,255
801122d4:	d0a05817 	ldw	r2,-32416(gp)
801122d8:	10800043 	ldbu	r2,1(r2)
801122dc:	10803fcc 	andi	r2,r2,255
801122e0:	100f883a 	mov	r7,r2
801122e4:	200d883a 	mov	r6,r4
801122e8:	180b883a 	mov	r5,r3
801122ec:	4009883a 	mov	r4,r8
801122f0:	0101fd00 	call	80101fd0 <bSdmaDmaM1Transfer>
801122f4:	e0bff915 	stw	r2,-28(fp)
801122f8:	00001006 	br	8011233c <vFeeTask1+0xeb0>
							} else {
								bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
801122fc:	e0bff617 	ldw	r2,-40(fp)
80112300:	10800217 	ldw	r2,8(r2)
80112304:	1011883a 	mov	r8,r2
80112308:	e0bff817 	ldw	r2,-32(fp)
8011230c:	10ffffcc 	andi	r3,r2,65535
80112310:	d0a05703 	ldbu	r2,-32420(gp)
80112314:	11003fcc 	andi	r4,r2,255
80112318:	d0a05817 	ldw	r2,-32416(gp)
8011231c:	10800043 	ldbu	r2,1(r2)
80112320:	10803fcc 	andi	r2,r2,255
80112324:	100f883a 	mov	r7,r2
80112328:	200d883a 	mov	r6,r4
8011232c:	180b883a 	mov	r5,r3
80112330:	4009883a 	mov	r4,r8
80112334:	01024540 	call	80102454 <bSdmaDmaM2Transfer>
80112338:	e0bff915 	stw	r2,-28(fp)
							}

							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8011233c:	e0fff503 	ldbu	r3,-44(fp)
80112340:	00a005b4 	movhi	r2,32790
80112344:	10ad6e04 	addi	r2,r2,-19016
80112348:	180690fa 	slli	r3,r3,3
8011234c:	10c5883a 	add	r2,r2,r3
80112350:	10800017 	ldw	r2,0(r2)
80112354:	1009883a 	mov	r4,r2
80112358:	01384940 	call	80138494 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8011235c:	d0a05817 	ldw	r2,-32416(gp)
80112360:	10002215 	stw	zero,136(r2)

							if ( bDmaReturn == TRUE ) {
80112364:	e0bff917 	ldw	r2,-28(fp)
80112368:	10800058 	cmpnei	r2,r2,1
8011236c:	10000e1e 	bne	r2,zero,801123a8 <vFeeTask1+0xf1c>
								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
80112370:	e0bff617 	ldw	r2,-40(fp)
80112374:	10c00217 	ldw	r3,8(r2)
80112378:	e0bff817 	ldw	r2,-32(fp)
8011237c:	10802224 	muli	r2,r2,136
80112380:	1887883a 	add	r3,r3,r2
80112384:	e0bff617 	ldw	r2,-40(fp)
80112388:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += usiLengthBlocks;
8011238c:	e0bff617 	ldw	r2,-40(fp)
80112390:	10c00117 	ldw	r3,4(r2)
80112394:	e0bff817 	ldw	r2,-32(fp)
80112398:	1887883a 	add	r3,r3,r2
8011239c:	e0bff617 	ldw	r2,-40(fp)
801123a0:	10c00115 	stw	r3,4(r2)
801123a4:	00000806 	br	801123c8 <vFeeTask1+0xf3c>
							} else {
								bFinal = FALSE;
801123a8:	e03ffa15 	stw	zero,-24(fp)

								/* Send the request for use the DMA, but to front of the QUEUE */
								bSendRequestNFeeCtrl_Front( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
801123ac:	d0a05817 	ldw	r2,-32416(gp)
801123b0:	10800003 	ldbu	r2,0(r2)
801123b4:	10803fcc 	andi	r2,r2,255
801123b8:	100d883a 	mov	r6,r2
801123bc:	000b883a 	mov	r5,zero
801123c0:	01002004 	movi	r4,128
801123c4:	01105700 	call	80110570 <bSendRequestNFeeCtrl_Front>
							}

							/* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
801123c8:	d0a05817 	ldw	r2,-32416(gp)
801123cc:	10800003 	ldbu	r2,0(r2)
801123d0:	10803fcc 	andi	r2,r2,255
801123d4:	100d883a 	mov	r6,r2
801123d8:	000b883a 	mov	r5,zero
801123dc:	01002044 	movi	r4,129
801123e0:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

							if ( bFinal == TRUE ) {
801123e4:	e0bffa17 	ldw	r2,-24(fp)
801123e8:	10800058 	cmpnei	r2,r2,1
801123ec:	1000621e 	bne	r2,zero,80112578 <vFeeTask1+0x10ec>
								pxNFee->xControl.eMode = sEndTransmission;
801123f0:	d0a05817 	ldw	r2,-32416(gp)
801123f4:	00c002c4 	movi	r3,11
801123f8:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
801123fc:	00005e06 	br	80112578 <vFeeTask1+0x10ec>
								//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
							}

						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
80112400:	d0a05817 	ldw	r2,-32416(gp)
80112404:	e0fffe17 	ldw	r3,-8(fp)
80112408:	180b883a 	mov	r5,r3
8011240c:	1009883a 	mov	r4,r2
80112410:	010f8380 	call	8010f838 <vQCmdFEEinFullPattern>

						if ( pxNFee->xControl.bWatingSync == FALSE ) {
80112414:	d0a05817 	ldw	r2,-32416(gp)
80112418:	10802817 	ldw	r2,160(r2)
8011241c:	1000561e 	bne	r2,zero,80112578 <vFeeTask1+0x10ec>
							pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
80112420:	d0a05817 	ldw	r2,-32416(gp)
80112424:	d0e05817 	ldw	r3,-32416(gp)
80112428:	18c02d17 	ldw	r3,180(r3)
8011242c:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80112430:	00005106 	br	80112578 <vFeeTask1+0x10ec>
					fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu\n", pxNFee->ucId, ucReadout);
					fprintf(fp,"Memory used: %u\n", ucMemUsing);
				}
				#endif

				pxNFee->xControl.bWatingSync = TRUE;
80112434:	d0a05817 	ldw	r2,-32416(gp)
80112438:	00c00044 	movi	r3,1
8011243c:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
80112440:	d0a05817 	ldw	r2,-32416(gp)
80112444:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bOneShot == FALSE ) {
80112448:	00a005b4 	movhi	r2,32790
8011244c:	10ba3604 	addi	r2,r2,-5928
80112450:	10800917 	ldw	r2,36(r2)
80112454:	10001f1e 	bne	r2,zero,801124d4 <vFeeTask1+0x1048>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
80112458:	d0a05817 	ldw	r2,-32416(gp)
8011245c:	10802d17 	ldw	r2,180(r2)
80112460:	10800198 	cmpnei	r2,r2,6
80112464:	1000141e 	bne	r2,zero,801124b8 <vFeeTask1+0x102c>

						bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80112468:	d0a05817 	ldw	r2,-32416(gp)
8011246c:	10803304 	addi	r2,r2,204
80112470:	1009883a 	mov	r4,r2
80112474:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
80112478:	d0a05817 	ldw	r2,-32416(gp)
8011247c:	e0fff703 	ldbu	r3,-36(fp)
80112480:	10c036c5 	stb	r3,219(r2)
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
80112484:	d0a05817 	ldw	r2,-32416(gp)
80112488:	10003685 	stb	zero,218(r2)
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8011248c:	d0a05817 	ldw	r2,-32416(gp)
80112490:	10803304 	addi	r2,r2,204
80112494:	1009883a 	mov	r4,r2
80112498:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

						pxNFee->xControl.eMode =  sFeeWaitingSync;
8011249c:	d0a05817 	ldw	r2,-32416(gp)
801124a0:	00c00304 	movi	r3,12
801124a4:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
801124a8:	d0a05817 	ldw	r2,-32416(gp)
801124ac:	00c00184 	movi	r3,6
801124b0:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
801124b4:	00003306 	br	80112584 <vFeeTask1+0x10f8>
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
801124b8:	d0a05817 	ldw	r2,-32416(gp)
801124bc:	00c00284 	movi	r3,10
801124c0:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
801124c4:	d0a05817 	ldw	r2,-32416(gp)
801124c8:	00c00304 	movi	r3,12
801124cc:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
801124d0:	00002c06 	br	80112584 <vFeeTask1+0x10f8>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
801124d4:	d0a05817 	ldw	r2,-32416(gp)
801124d8:	00c00304 	movi	r3,12
801124dc:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
801124e0:	d0a05817 	ldw	r2,-32416(gp)
801124e4:	00c00184 	movi	r3,6
801124e8:	10c02d15 	stw	r3,180(r2)
				}

				break;
801124ec:	00002506 	br	80112584 <vFeeTask1+0x10f8>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
				}
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
801124f0:	d0a05817 	ldw	r2,-32416(gp)
801124f4:	10800003 	ldbu	r2,0(r2)
801124f8:	10c03fcc 	andi	r3,r2,255
801124fc:	00a00574 	movhi	r2,32789
80112500:	109f5404 	addi	r2,r2,32080
80112504:	18c7883a 	add	r3,r3,r3
80112508:	18c7883a 	add	r3,r3,r3
8011250c:	10c5883a 	add	r2,r2,r3
80112510:	10800017 	ldw	r2,0(r2)
80112514:	e0fffd04 	addi	r3,fp,-12
80112518:	180d883a 	mov	r6,r3
8011251c:	000b883a 	mov	r5,zero
80112520:	1009883a 	mov	r4,r2
80112524:	01390040 	call	80139004 <OSQPend>
80112528:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8011252c:	e0bffd03 	ldbu	r2,-12(fp)
80112530:	10803fcc 	andi	r2,r2,255
80112534:	1000121e 	bne	r2,zero,80112580 <vFeeTask1+0x10f4>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					}
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
80112538:	d0a05817 	ldw	r2,-32416(gp)
8011253c:	e0fffe17 	ldw	r3,-8(fp)
80112540:	180b883a 	mov	r5,r3
80112544:	1009883a 	mov	r4,r2
80112548:	010f3980 	call	8010f398 <vQCmdFEEinWaitingSync>
				}

				break;
8011254c:	00000c06 	br	80112580 <vFeeTask1+0x10f4>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
80112550:	d0a05817 	ldw	r2,-32416(gp)
80112554:	00c00144 	movi	r3,5
80112558:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
8011255c:	00000906 	br	80112584 <vFeeTask1+0x10f8>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80112560:	0001883a 	nop
80112564:	003bd206 	br	801114b0 <__reset+0xfa0f14b0>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80112568:	0001883a 	nop
8011256c:	003bd006 	br	801114b0 <__reset+0xfa0f14b0>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
80112570:	0001883a 	nop
80112574:	003bce06 	br	801114b0 <__reset+0xfa0f14b0>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80112578:	0001883a 	nop
8011257c:	003bcc06 	br	801114b0 <__reset+0xfa0f14b0>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
80112580:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
		}
	}
80112584:	003bca06 	br	801114b0 <__reset+0xfa0f14b0>

80112588 <vFeeTask2>:
#include "fee_task2.h"


static unsigned char ucIterationSide;

void vFeeTask2(void *task_data) {
80112588:	defff204 	addi	sp,sp,-56
8011258c:	de00012e 	bgeu	sp,et,80112594 <vFeeTask2+0xc>
80112590:	003b68fa 	trap	3
80112594:	dfc00d15 	stw	ra,52(sp)
80112598:	df000c15 	stw	fp,48(sp)
8011259c:	df000c04 	addi	fp,sp,48
801125a0:	e13fff15 	stw	r4,-4(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
801125a4:	e0bfff17 	ldw	r2,-4(fp)
801125a8:	d0a05c15 	stw	r2,-32400(gp)
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
801125ac:	d0a05c17 	ldw	r2,-32400(gp)
801125b0:	10802c17 	ldw	r2,176(r2)
801125b4:	10c00368 	cmpgeui	r3,r2,13
801125b8:	1804241e 	bne	r3,zero,8011364c <vFeeTask2+0x10c4>
801125bc:	100690ba 	slli	r3,r2,2
801125c0:	00a00474 	movhi	r2,32785
801125c4:	10897504 	addi	r2,r2,9684
801125c8:	1885883a 	add	r2,r3,r2
801125cc:	10800017 	ldw	r2,0(r2)
801125d0:	1000683a 	jmp	r2
801125d4:	80112608 	cmpgei	zero,r16,17560
801125d8:	80112c68 	cmpgeui	zero,r16,17585
801125dc:	80112cc8 	cmpgei	zero,r16,17587
801125e0:	80112e08 	cmpgei	zero,r16,17592
801125e4:	80113288 	cmpgei	zero,r16,17610
801125e8:	80112abc 	xorhi	zero,r16,17578
801125ec:	80112cd8 	cmpnei	zero,r16,17587
801125f0:	801131d0 	cmplti	zero,r16,17607
801125f4:	8011364c 	andi	zero,r16,17625
801125f8:	8011364c 	andi	zero,r16,17625
801125fc:	80112e68 	cmpgeui	zero,r16,17593
80112600:	80113530 	cmpltui	zero,r16,17620
80112604:	801135ec 	andhi	zero,r16,17623
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
80112608:	d0a05c17 	ldw	r2,-32400(gp)
8011260c:	10800003 	ldbu	r2,0(r2)
80112610:	10c03fcc 	andi	r3,r2,255
80112614:	00a00574 	movhi	r2,32789
80112618:	109f5404 	addi	r2,r2,32080
8011261c:	18c7883a 	add	r3,r3,r3
80112620:	18c7883a 	add	r3,r3,r3
80112624:	10c5883a 	add	r2,r2,r3
80112628:	10800017 	ldw	r2,0(r2)
8011262c:	1009883a 	mov	r4,r2
80112630:	0138f440 	call	80138f44 <OSQFlush>
80112634:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
80112638:	e0bffd03 	ldbu	r2,-12(fp)
8011263c:	10803fcc 	andi	r2,r2,255
80112640:	10000126 	beq	r2,zero,80112648 <vFeeTask2+0xc0>
					vFailFlushNFEEQueue();
80112644:	011dbe80 	call	8011dbe8 <vFailFlushNFEEQueue>
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}
				*/

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80112648:	d0a05c17 	ldw	r2,-32400(gp)
8011264c:	10803304 	addi	r2,r2,204
80112650:	1009883a 	mov	r4,r2
80112654:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
80112658:	d0a05c17 	ldw	r2,-32400(gp)
8011265c:	d0e05c17 	ldw	r3,-32400(gp)
80112660:	1900308b 	ldhu	r4,194(r3)
80112664:	d0e05c17 	ldw	r3,-32400(gp)
80112668:	18c02f0b 	ldhu	r3,188(r3)
8011266c:	20c7883a 	add	r3,r4,r3
80112670:	1809883a 	mov	r4,r3
80112674:	d0e05c17 	ldw	r3,-32400(gp)
80112678:	18c02f8b 	ldhu	r3,190(r3)
8011267c:	20c7883a 	add	r3,r4,r3
80112680:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
80112684:	d0a05c17 	ldw	r2,-32400(gp)
80112688:	d0e05c17 	ldw	r3,-32400(gp)
8011268c:	1900310b 	ldhu	r4,196(r3)
80112690:	d0e05c17 	ldw	r3,-32400(gp)
80112694:	18c0300b 	ldhu	r3,192(r3)
80112698:	20c7883a 	add	r3,r4,r3
8011269c:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
801126a0:	d0a05c17 	ldw	r2,-32400(gp)
801126a4:	d0e05c17 	ldw	r3,-32400(gp)
801126a8:	18c0310b 	ldhu	r3,196(r3)
801126ac:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
801126b0:	d0a05c17 	ldw	r2,-32400(gp)
801126b4:	d0e05c17 	ldw	r3,-32400(gp)
801126b8:	18c0300b 	ldhu	r3,192(r3)
801126bc:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
801126c0:	d0a05c17 	ldw	r2,-32400(gp)
801126c4:	00e00004 	movi	r3,-32768
801126c8:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
801126cc:	d0a05c17 	ldw	r2,-32400(gp)
801126d0:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
801126d4:	d0a05c17 	ldw	r2,-32400(gp)
801126d8:	10003685 	stb	zero,218(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucProtocolId = xDefaults.usiDataProtId; /* 0xF0 ou  0x02*/
801126dc:	d0e05c17 	ldw	r3,-32400(gp)
801126e0:	00a005b4 	movhi	r2,32790
801126e4:	10ba3604 	addi	r2,r2,-5928
801126e8:	10800c0b 	ldhu	r2,48(r2)
801126ec:	18803705 	stb	r2,220(r3)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucLogicalAddr = xDefaults.usiDpuLogicalAddr + 2;
801126f0:	d0e05c17 	ldw	r3,-32400(gp)
801126f4:	00a005b4 	movhi	r2,32790
801126f8:	10ba3604 	addi	r2,r2,-5928
801126fc:	10800c8b 	ldhu	r2,50(r2)
80112700:	10800084 	addi	r2,r2,2
80112704:	18803745 	stb	r2,221(r3)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
80112708:	d0a05c17 	ldw	r2,-32400(gp)
8011270c:	10803304 	addi	r2,r2,204
80112710:	1009883a 	mov	r4,r2
80112714:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
80112718:	d0a05c17 	ldw	r2,-32400(gp)
8011271c:	10804804 	addi	r2,r2,288
80112720:	1009883a 	mov	r4,r2
80112724:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
80112728:	d0a05c17 	ldw	r2,-32400(gp)
8011272c:	00ffc004 	movi	r3,-256
80112730:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
80112734:	d0a05c17 	ldw	r2,-32400(gp)
80112738:	00ffc044 	movi	r3,-255
8011273c:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
80112740:	d0a05c17 	ldw	r2,-32400(gp)
80112744:	00ffc084 	movi	r3,-254
80112748:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8011274c:	d0a05c17 	ldw	r2,-32400(gp)
80112750:	00ffc0c4 	movi	r3,-253
80112754:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
80112758:	d0a05c17 	ldw	r2,-32400(gp)
8011275c:	00ffc104 	movi	r3,-252
80112760:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
80112764:	d0a05c17 	ldw	r2,-32400(gp)
80112768:	00ffc144 	movi	r3,-251
8011276c:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
80112770:	d0a05c17 	ldw	r2,-32400(gp)
80112774:	00ffc184 	movi	r3,-250
80112778:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8011277c:	d0a05c17 	ldw	r2,-32400(gp)
80112780:	00ffc1c4 	movi	r3,-249
80112784:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
80112788:	d0a05c17 	ldw	r2,-32400(gp)
8011278c:	00ffc204 	movi	r3,-248
80112790:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
80112794:	d0a05c17 	ldw	r2,-32400(gp)
80112798:	00ffc244 	movi	r3,-247
8011279c:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
801127a0:	d0a05c17 	ldw	r2,-32400(gp)
801127a4:	00ffc284 	movi	r3,-246
801127a8:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
801127ac:	d0a05c17 	ldw	r2,-32400(gp)
801127b0:	00ffc2c4 	movi	r3,-245
801127b4:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
801127b8:	d0a05c17 	ldw	r2,-32400(gp)
801127bc:	00ffc304 	movi	r3,-244
801127c0:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
801127c4:	d0a05c17 	ldw	r2,-32400(gp)
801127c8:	00ffc344 	movi	r3,-243
801127cc:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
801127d0:	d0a05c17 	ldw	r2,-32400(gp)
801127d4:	00ffc384 	movi	r3,-242
801127d8:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
801127dc:	d0a05c17 	ldw	r2,-32400(gp)
801127e0:	00ffc3c4 	movi	r3,-241
801127e4:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
801127e8:	d0a05c17 	ldw	r2,-32400(gp)
801127ec:	00ffc404 	movi	r3,-240
801127f0:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
801127f4:	d0a05c17 	ldw	r2,-32400(gp)
801127f8:	00ffc444 	movi	r3,-239
801127fc:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
80112800:	d0a05c17 	ldw	r2,-32400(gp)
80112804:	00ffc484 	movi	r3,-238
80112808:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8011280c:	d0a05c17 	ldw	r2,-32400(gp)
80112810:	00ffc4c4 	movi	r3,-237
80112814:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
80112818:	d0a05c17 	ldw	r2,-32400(gp)
8011281c:	00ffc504 	movi	r3,-236
80112820:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
80112824:	d0a05c17 	ldw	r2,-32400(gp)
80112828:	00ffc544 	movi	r3,-235
8011282c:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
80112830:	d0a05c17 	ldw	r2,-32400(gp)
80112834:	00ffc584 	movi	r3,-234
80112838:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8011283c:	d0a05c17 	ldw	r2,-32400(gp)
80112840:	00ffc5c4 	movi	r3,-233
80112844:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
80112848:	d0a05c17 	ldw	r2,-32400(gp)
8011284c:	00ffc604 	movi	r3,-232
80112850:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
80112854:	d0a05c17 	ldw	r2,-32400(gp)
80112858:	00ffc644 	movi	r3,-231
8011285c:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
80112860:	d0a05c17 	ldw	r2,-32400(gp)
80112864:	00ffc684 	movi	r3,-230
80112868:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8011286c:	d0a05c17 	ldw	r2,-32400(gp)
80112870:	00ffc6c4 	movi	r3,-229
80112874:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
80112878:	d0a05c17 	ldw	r2,-32400(gp)
8011287c:	00ffc704 	movi	r3,-228
80112880:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
80112884:	d0a05c17 	ldw	r2,-32400(gp)
80112888:	00ffc744 	movi	r3,-227
8011288c:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
80112890:	d0a05c17 	ldw	r2,-32400(gp)
80112894:	00ffc784 	movi	r3,-226
80112898:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8011289c:	d0a05c17 	ldw	r2,-32400(gp)
801128a0:	00ffc7c4 	movi	r3,-225
801128a4:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
801128a8:	d0a05c17 	ldw	r2,-32400(gp)
801128ac:	00ffc804 	movi	r3,-224
801128b0:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
801128b4:	d0a05c17 	ldw	r2,-32400(gp)
801128b8:	00ffc844 	movi	r3,-223
801128bc:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
801128c0:	d0a05c17 	ldw	r2,-32400(gp)
801128c4:	00ffc884 	movi	r3,-222
801128c8:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
801128cc:	d0a05c17 	ldw	r2,-32400(gp)
801128d0:	00ffc8c4 	movi	r3,-221
801128d4:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
801128d8:	d0a05c17 	ldw	r2,-32400(gp)
801128dc:	00ffc904 	movi	r3,-220
801128e0:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
801128e4:	d0a05c17 	ldw	r2,-32400(gp)
801128e8:	00ffc944 	movi	r3,-219
801128ec:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
801128f0:	d0a05c17 	ldw	r2,-32400(gp)
801128f4:	00ffc984 	movi	r3,-218
801128f8:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
801128fc:	d0a05c17 	ldw	r2,-32400(gp)
80112900:	00ffc9c4 	movi	r3,-217
80112904:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
80112908:	d0a05c17 	ldw	r2,-32400(gp)
8011290c:	00ffca04 	movi	r3,-216
80112910:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
80112914:	d0a05c17 	ldw	r2,-32400(gp)
80112918:	00ffca44 	movi	r3,-215
8011291c:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
80112920:	d0a05c17 	ldw	r2,-32400(gp)
80112924:	00ffca84 	movi	r3,-214
80112928:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8011292c:	d0a05c17 	ldw	r2,-32400(gp)
80112930:	00ffcac4 	movi	r3,-213
80112934:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
80112938:	d0a05c17 	ldw	r2,-32400(gp)
8011293c:	00ffcb04 	movi	r3,-212
80112940:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
80112944:	d0a05c17 	ldw	r2,-32400(gp)
80112948:	00ffcb44 	movi	r3,-211
8011294c:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
80112950:	d0a05c17 	ldw	r2,-32400(gp)
80112954:	00ffcb84 	movi	r3,-210
80112958:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8011295c:	d0a05c17 	ldw	r2,-32400(gp)
80112960:	00ffcbc4 	movi	r3,-209
80112964:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
80112968:	d0a05c17 	ldw	r2,-32400(gp)
8011296c:	00ffcc04 	movi	r3,-208
80112970:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
80112974:	d0a05c17 	ldw	r2,-32400(gp)
80112978:	00ffcc44 	movi	r3,-207
8011297c:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
80112980:	d0a05c17 	ldw	r2,-32400(gp)
80112984:	00ffcc84 	movi	r3,-206
80112988:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8011298c:	d0a05c17 	ldw	r2,-32400(gp)
80112990:	00ffccc4 	movi	r3,-205
80112994:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
80112998:	d0a05c17 	ldw	r2,-32400(gp)
8011299c:	00ffcd04 	movi	r3,-204
801129a0:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
801129a4:	d0a05c17 	ldw	r2,-32400(gp)
801129a8:	00ffcd44 	movi	r3,-203
801129ac:	10c0888d 	sth	r3,546(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
801129b0:	d0a05c17 	ldw	r2,-32400(gp)
801129b4:	00ffcd84 	movi	r3,-202
801129b8:	10c0890d 	sth	r3,548(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
801129bc:	d0a05c17 	ldw	r2,-32400(gp)
801129c0:	00ffcdc4 	movi	r3,-201
801129c4:	10c0898d 	sth	r3,550(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
801129c8:	d0a05c17 	ldw	r2,-32400(gp)
801129cc:	00ffce04 	movi	r3,-200
801129d0:	10c08a0d 	sth	r3,552(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
801129d4:	d0a05c17 	ldw	r2,-32400(gp)
801129d8:	00ffce44 	movi	r3,-199
801129dc:	10c08a8d 	sth	r3,554(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
801129e0:	d0a05c17 	ldw	r2,-32400(gp)
801129e4:	00ffce84 	movi	r3,-198
801129e8:	10c08b0d 	sth	r3,556(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
801129ec:	d0a05c17 	ldw	r2,-32400(gp)
801129f0:	00ffcec4 	movi	r3,-197
801129f4:	10c08b8d 	sth	r3,558(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
801129f8:	d0a05c17 	ldw	r2,-32400(gp)
801129fc:	00ffcf04 	movi	r3,-196
80112a00:	10c08c0d 	sth	r3,560(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
80112a04:	d0a05c17 	ldw	r2,-32400(gp)
80112a08:	00ffcf44 	movi	r3,-195
80112a0c:	10c08c8d 	sth	r3,562(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
80112a10:	d0a05c17 	ldw	r2,-32400(gp)
80112a14:	00ffcf84 	movi	r3,-194
80112a18:	10c08d0d 	sth	r3,564(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
80112a1c:	d0a05c17 	ldw	r2,-32400(gp)
80112a20:	00ffcfc4 	movi	r3,-193
80112a24:	10c08d8d 	sth	r3,566(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
80112a28:	d0a05c17 	ldw	r2,-32400(gp)
80112a2c:	10804804 	addi	r2,r2,288
80112a30:	1009883a 	mov	r4,r2
80112a34:	0108c180 	call	80108c18 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
80112a38:	0110f640 	call	80110f64 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
80112a3c:	d0a05c17 	ldw	r2,-32400(gp)
80112a40:	10804804 	addi	r2,r2,288
80112a44:	1009883a 	mov	r4,r2
80112a48:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
80112a4c:	d0a05c17 	ldw	r2,-32400(gp)
80112a50:	10806e04 	addi	r2,r2,440
80112a54:	e0bffb15 	stw	r2,-20(fp)
					fprintf(fp,"\n================= H  K ==================\n\n");
				}
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
80112a58:	d0a05c17 	ldw	r2,-32400(gp)
80112a5c:	10804804 	addi	r2,r2,288
80112a60:	1009883a 	mov	r4,r2
80112a64:	01082300 	call	80108230 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
80112a68:	d0e05c17 	ldw	r3,-32400(gp)
80112a6c:	00a005b4 	movhi	r2,32790
80112a70:	10ba3604 	addi	r2,r2,-5928
80112a74:	1080080b 	ldhu	r2,32(r2)
80112a78:	18804905 	stb	r2,292(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
80112a7c:	d0e05c17 	ldw	r3,-32400(gp)
80112a80:	00a005b4 	movhi	r2,32790
80112a84:	10ba3604 	addi	r2,r2,-5928
80112a88:	1080088b 	ldhu	r2,34(r2)
80112a8c:	18804945 	stb	r2,293(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
80112a90:	d0a05c17 	ldw	r2,-32400(gp)
80112a94:	10804804 	addi	r2,r2,288
80112a98:	1009883a 	mov	r4,r2
80112a9c:	01081540 	call	80108154 <bRmapSetCodecConfig>
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", pxNFee->ucId ,xDefaults.ucRmapKey );
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", pxNFee->ucId, xDefaults.ucLogicalAddr);
				}
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
80112aa0:	d0a05c17 	ldw	r2,-32400(gp)
80112aa4:	00c00144 	movi	r3,5
80112aa8:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
80112aac:	d0a05c17 	ldw	r2,-32400(gp)
80112ab0:	10802e17 	ldw	r2,184(r2)
80112ab4:	d0a05b05 	stb	r2,-32404(gp)

				break;
80112ab8:	0002f106 	br	80113680 <vFeeTask2+0x10f8>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
80112abc:	d0a05c17 	ldw	r2,-32400(gp)
80112ac0:	10804804 	addi	r2,r2,288
80112ac4:	1009883a 	mov	r4,r2
80112ac8:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
80112acc:	d0a05c17 	ldw	r2,-32400(gp)
80112ad0:	00c00184 	movi	r3,6
80112ad4:	10c06b15 	stw	r3,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
80112ad8:	d0a05c17 	ldw	r2,-32400(gp)
80112adc:	10804804 	addi	r2,r2,288
80112ae0:	1009883a 	mov	r4,r2
80112ae4:	010857c0 	call	8010857c <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
80112ae8:	d0a05c17 	ldw	r2,-32400(gp)
80112aec:	10808e04 	addi	r2,r2,568
80112af0:	1009883a 	mov	r4,r2
80112af4:	01103080 	call	80110308 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
80112af8:	d0a05c17 	ldw	r2,-32400(gp)
80112afc:	10002615 	stw	zero,152(r2)
				bSetPainelLeds( LEDS_OFF , uliReturnMaskG( pxNFee->ucSPWId ) );
80112b00:	d0a05c17 	ldw	r2,-32400(gp)
80112b04:	10800043 	ldbu	r2,1(r2)
80112b08:	10803fcc 	andi	r2,r2,255
80112b0c:	1009883a 	mov	r4,r2
80112b10:	0110e840 	call	80110e84 <uliReturnMaskG>
80112b14:	100b883a 	mov	r5,r2
80112b18:	0009883a 	mov	r4,zero
80112b1c:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , uliReturnMaskR( pxNFee->ucSPWId ) );
80112b20:	d0a05c17 	ldw	r2,-32400(gp)
80112b24:	10800043 	ldbu	r2,1(r2)
80112b28:	10803fcc 	andi	r2,r2,255
80112b2c:	1009883a 	mov	r4,r2
80112b30:	0110da40 	call	80110da4 <uliReturnMaskR>
80112b34:	100b883a 	mov	r5,r2
80112b38:	01000044 	movi	r4,1
80112b3c:	010bb640 	call	8010bb64 <bSetPainelLeds>

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
80112b40:	d0a05c17 	ldw	r2,-32400(gp)
80112b44:	10c04804 	addi	r3,r2,288
80112b48:	d0a05c17 	ldw	r2,-32400(gp)
80112b4c:	10800043 	ldbu	r2,1(r2)
80112b50:	10803fcc 	andi	r2,r2,255
80112b54:	100b883a 	mov	r5,r2
80112b58:	1809883a 	mov	r4,r3
80112b5c:	011025c0 	call	8011025c <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80112b60:	d0a05c17 	ldw	r2,-32400(gp)
80112b64:	10803b04 	addi	r2,r2,236
80112b68:	1009883a 	mov	r4,r2
80112b6c:	01104600 	call	80110460 <bDisAndClrDbBuffer>
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
				}
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
80112b70:	d0a05c17 	ldw	r2,-32400(gp)
80112b74:	10802217 	ldw	r2,136(r2)
80112b78:	10800058 	cmpnei	r2,r2,1
80112b7c:	10000a1e 	bne	r2,zero,80112ba8 <vFeeTask2+0x620>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
80112b80:	e0fff503 	ldbu	r3,-44(fp)
80112b84:	00a005b4 	movhi	r2,32790
80112b88:	10ad6e04 	addi	r2,r2,-19016
80112b8c:	180690fa 	slli	r3,r3,3
80112b90:	10c5883a 	add	r2,r2,r3
80112b94:	10800017 	ldw	r2,0(r2)
80112b98:	1009883a 	mov	r4,r2
80112b9c:	01384940 	call	80138494 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
80112ba0:	d0a05c17 	ldw	r2,-32400(gp)
80112ba4:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
80112ba8:	d0a05c17 	ldw	r2,-32400(gp)
80112bac:	10002815 	stw	zero,160(r2)
					vFailFlushNFEEQueue();
				}
				*/

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
80112bb0:	d0a05c17 	ldw	r2,-32400(gp)
80112bb4:	10800003 	ldbu	r2,0(r2)
80112bb8:	10803fcc 	andi	r2,r2,255
80112bbc:	100d883a 	mov	r6,r2
80112bc0:	000b883a 	mov	r5,zero
80112bc4:	01002044 	movi	r4,129
80112bc8:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
80112bcc:	d0a05c17 	ldw	r2,-32400(gp)
80112bd0:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
80112bd4:	d0a05c17 	ldw	r2,-32400(gp)
80112bd8:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
80112bdc:	d0a05c17 	ldw	r2,-32400(gp)
80112be0:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
80112be4:	d0a05c17 	ldw	r2,-32400(gp)
80112be8:	00c00044 	movi	r3,1
80112bec:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
80112bf0:	d0a05c17 	ldw	r2,-32400(gp)
80112bf4:	1009883a 	mov	r4,r2
80112bf8:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
80112bfc:	d0a05c17 	ldw	r2,-32400(gp)
80112c00:	10800003 	ldbu	r2,0(r2)
80112c04:	10c03fcc 	andi	r3,r2,255
80112c08:	00a00574 	movhi	r2,32789
80112c0c:	109f5404 	addi	r2,r2,32080
80112c10:	18c7883a 	add	r3,r3,r3
80112c14:	18c7883a 	add	r3,r3,r3
80112c18:	10c5883a 	add	r2,r2,r3
80112c1c:	10800017 	ldw	r2,0(r2)
80112c20:	1009883a 	mov	r4,r2
80112c24:	0138f440 	call	80138f44 <OSQFlush>
80112c28:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
80112c2c:	e0bffd03 	ldbu	r2,-12(fp)
80112c30:	10803fcc 	andi	r2,r2,255
80112c34:	10000126 	beq	r2,zero,80112c3c <vFeeTask2+0x6b4>
					vFailFlushNFEEQueue();
80112c38:	011dbe80 	call	8011dbe8 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
80112c3c:	d0a05c17 	ldw	r2,-32400(gp)
80112c40:	00c00044 	movi	r3,1
80112c44:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
80112c48:	d0a05c17 	ldw	r2,-32400(gp)
80112c4c:	00c00044 	movi	r3,1
80112c50:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
80112c54:	d0a05c17 	ldw	r2,-32400(gp)
80112c58:	10802e17 	ldw	r2,184(r2)
80112c5c:	d0a05b05 	stb	r2,-32404(gp)
				bFinal = FALSE;
80112c60:	e03ffa15 	stw	zero,-24(fp)
				break;
80112c64:	00028606 	br	80113680 <vFeeTask2+0x10f8>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80112c68:	d0a05c17 	ldw	r2,-32400(gp)
80112c6c:	10800003 	ldbu	r2,0(r2)
80112c70:	10c03fcc 	andi	r3,r2,255
80112c74:	00a00574 	movhi	r2,32789
80112c78:	109f5404 	addi	r2,r2,32080
80112c7c:	18c7883a 	add	r3,r3,r3
80112c80:	18c7883a 	add	r3,r3,r3
80112c84:	10c5883a 	add	r2,r2,r3
80112c88:	10800017 	ldw	r2,0(r2)
80112c8c:	e0fffd04 	addi	r3,fp,-12
80112c90:	180d883a 	mov	r6,r3
80112c94:	000b883a 	mov	r5,zero
80112c98:	1009883a 	mov	r4,r2
80112c9c:	01390040 	call	80139004 <OSQPend>
80112ca0:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
80112ca4:	e0bffd03 	ldbu	r2,-12(fp)
80112ca8:	10803fcc 	andi	r2,r2,255
80112cac:	10026b1e 	bne	r2,zero,8011365c <vFeeTask2+0x10d4>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
80112cb0:	d0a05c17 	ldw	r2,-32400(gp)
80112cb4:	e0fffe17 	ldw	r3,-8(fp)
80112cb8:	180b883a 	mov	r5,r3
80112cbc:	1009883a 	mov	r4,r2
80112cc0:	010f56c0 	call	8010f56c <vQCmdFEEinConfig>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80112cc4:	00026506 	br	8011365c <vFeeTask2+0x10d4>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
80112cc8:	d0a05c17 	ldw	r2,-32400(gp)
80112ccc:	00c00184 	movi	r3,6
80112cd0:	10c02c15 	stw	r3,176(r2)
				break;
80112cd4:	00026a06 	br	80113680 <vFeeTask2+0x10f8>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
80112cd8:	d0a05c17 	ldw	r2,-32400(gp)
80112cdc:	10804804 	addi	r2,r2,288
80112ce0:	1009883a 	mov	r4,r2
80112ce4:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
80112ce8:	d0a05c17 	ldw	r2,-32400(gp)
80112cec:	10006b15 	stw	zero,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
80112cf0:	d0a05c17 	ldw	r2,-32400(gp)
80112cf4:	10804804 	addi	r2,r2,288
80112cf8:	1009883a 	mov	r4,r2
80112cfc:	010857c0 	call	8010857c <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80112d00:	d0a05c17 	ldw	r2,-32400(gp)
80112d04:	10803b04 	addi	r2,r2,236
80112d08:	1009883a 	mov	r4,r2
80112d0c:	01104600 	call	80110460 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
80112d10:	d0a05c17 	ldw	r2,-32400(gp)
80112d14:	10c04804 	addi	r3,r2,288
80112d18:	d0a05c17 	ldw	r2,-32400(gp)
80112d1c:	10800003 	ldbu	r2,0(r2)
80112d20:	10803fcc 	andi	r2,r2,255
80112d24:	100b883a 	mov	r5,r2
80112d28:	1809883a 	mov	r4,r3
80112d2c:	01102b00 	call	801102b0 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
80112d30:	d0a05c17 	ldw	r2,-32400(gp)
80112d34:	10808e04 	addi	r2,r2,568
80112d38:	1009883a 	mov	r4,r2
80112d3c:	01103680 	call	80110368 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
80112d40:	d0a05c17 	ldw	r2,-32400(gp)
80112d44:	00c00044 	movi	r3,1
80112d48:	10c02615 	stw	r3,152(r2)
				bSetPainelLeds( LEDS_OFF , uliReturnMaskR( pxNFee->ucSPWId ) );
80112d4c:	d0a05c17 	ldw	r2,-32400(gp)
80112d50:	10800043 	ldbu	r2,1(r2)
80112d54:	10803fcc 	andi	r2,r2,255
80112d58:	1009883a 	mov	r4,r2
80112d5c:	0110da40 	call	80110da4 <uliReturnMaskR>
80112d60:	100b883a 	mov	r5,r2
80112d64:	0009883a 	mov	r4,zero
80112d68:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , uliReturnMaskG( pxNFee->ucSPWId ) );
80112d6c:	d0a05c17 	ldw	r2,-32400(gp)
80112d70:	10800043 	ldbu	r2,1(r2)
80112d74:	10803fcc 	andi	r2,r2,255
80112d78:	1009883a 	mov	r4,r2
80112d7c:	0110e840 	call	80110e84 <uliReturnMaskG>
80112d80:	100b883a 	mov	r5,r2
80112d84:	01000044 	movi	r4,1
80112d88:	010bb640 	call	8010bb64 <bSetPainelLeds>

				pxNFee->xControl.bSimulating = TRUE;
80112d8c:	d0a05c17 	ldw	r2,-32400(gp)
80112d90:	00c00044 	movi	r3,1
80112d94:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
80112d98:	d0a05c17 	ldw	r2,-32400(gp)
80112d9c:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
80112da0:	d0a05c17 	ldw	r2,-32400(gp)
80112da4:	00c00044 	movi	r3,1
80112da8:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
80112dac:	d0a05c17 	ldw	r2,-32400(gp)
80112db0:	10800003 	ldbu	r2,0(r2)
80112db4:	10803fcc 	andi	r2,r2,255
80112db8:	100d883a 	mov	r6,r2
80112dbc:	000b883a 	mov	r5,zero
80112dc0:	01002044 	movi	r4,129
80112dc4:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
80112dc8:	d0a05c17 	ldw	r2,-32400(gp)
80112dcc:	10002815 	stw	zero,160(r2)
					fprintf(fp,"NFEE-%hu Task: Standby\n", pxNFee->ucId);
				}
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
80112dd0:	d0a05c17 	ldw	r2,-32400(gp)
80112dd4:	1009883a 	mov	r4,r2
80112dd8:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				incrementador = 0;
80112ddc:	d0205d15 	stw	zero,-32396(gp)

				pxNFee->xControl.bWatingSync = TRUE;
80112de0:	d0a05c17 	ldw	r2,-32400(gp)
80112de4:	00c00044 	movi	r3,1
80112de8:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
80112dec:	d0a05c17 	ldw	r2,-32400(gp)
80112df0:	00c000c4 	movi	r3,3
80112df4:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
80112df8:	d0a05c17 	ldw	r2,-32400(gp)
80112dfc:	10802e17 	ldw	r2,184(r2)
80112e00:	d0a05b05 	stb	r2,-32404(gp)
				break;
80112e04:	00021e06 	br	80113680 <vFeeTask2+0x10f8>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80112e08:	d0a05c17 	ldw	r2,-32400(gp)
80112e0c:	10800003 	ldbu	r2,0(r2)
80112e10:	10c03fcc 	andi	r3,r2,255
80112e14:	00a00574 	movhi	r2,32789
80112e18:	109f5404 	addi	r2,r2,32080
80112e1c:	18c7883a 	add	r3,r3,r3
80112e20:	18c7883a 	add	r3,r3,r3
80112e24:	10c5883a 	add	r2,r2,r3
80112e28:	10800017 	ldw	r2,0(r2)
80112e2c:	e0fffd04 	addi	r3,fp,-12
80112e30:	180d883a 	mov	r6,r3
80112e34:	000b883a 	mov	r5,zero
80112e38:	1009883a 	mov	r4,r2
80112e3c:	01390040 	call	80139004 <OSQPend>
80112e40:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
80112e44:	e0bffd03 	ldbu	r2,-12(fp)
80112e48:	10803fcc 	andi	r2,r2,255
80112e4c:	1002051e 	bne	r2,zero,80113664 <vFeeTask2+0x10dc>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
80112e50:	d0a05c17 	ldw	r2,-32400(gp)
80112e54:	e0fffe17 	ldw	r3,-8(fp)
80112e58:	180b883a 	mov	r5,r3
80112e5c:	1009883a 	mov	r4,r2
80112e60:	010f6a80 	call	8010f6a8 <vQCmdFEEinStandBy>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80112e64:	0001ff06 	br	80113664 <vFeeTask2+0x10dc>
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}
				*/

				pxNFee->xControl.bUsingDMA = TRUE;
80112e68:	d0a05c17 	ldw	r2,-32400(gp)
80112e6c:	00c00044 	movi	r3,1
80112e70:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
80112e74:	d0a05c17 	ldw	r2,-32400(gp)
80112e78:	00c00044 	movi	r3,1
80112e7c:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
80112e80:	d0a05c17 	ldw	r2,-32400(gp)
80112e84:	1009883a 	mov	r4,r2
80112e88:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				/* Wait until both buffers are empty  */
				vWaitUntilBufferEmpty( pxNFee->ucSPWId );
80112e8c:	d0a05c17 	ldw	r2,-32400(gp)
80112e90:	10800043 	ldbu	r2,1(r2)
80112e94:	10803fcc 	andi	r2,r2,255
80112e98:	1009883a 	mov	r4,r2
80112e9c:	0110c9c0 	call	80110c9c <vWaitUntilBufferEmpty>
					while ( (bFeebGetCh2LeftFeeBusy()== TRUE) || (bFeebGetCh2RightFeeBusy()== TRUE)  ) {}
				}
				*/


				OSTimeDlyHMSM(0,0,0,xDefaults.usiGuardNFEEDelay);
80112ea0:	00a005b4 	movhi	r2,32790
80112ea4:	10ba3604 	addi	r2,r2,-5928
80112ea8:	10800b8b 	ldhu	r2,46(r2)
80112eac:	10bfffcc 	andi	r2,r2,65535
80112eb0:	100f883a 	mov	r7,r2
80112eb4:	000d883a 	mov	r6,zero
80112eb8:	000b883a 	mov	r5,zero
80112ebc:	0009883a 	mov	r4,zero
80112ec0:	013be940 	call	8013be94 <OSTimeDlyHMSM>

				vSetDoubleBufferLeftSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80112ec4:	d0a05c17 	ldw	r2,-32400(gp)
80112ec8:	10800043 	ldbu	r2,1(r2)
80112ecc:	10803fcc 	andi	r2,r2,255
80112ed0:	100b883a 	mov	r5,r2
80112ed4:	01000404 	movi	r4,16
80112ed8:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
				vSetDoubleBufferRightSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80112edc:	d0a05c17 	ldw	r2,-32400(gp)
80112ee0:	10800043 	ldbu	r2,1(r2)
80112ee4:	10803fcc 	andi	r2,r2,255
80112ee8:	100b883a 	mov	r5,r2
80112eec:	01000404 	movi	r4,16
80112ef0:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}*/

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80112ef4:	d0a05c17 	ldw	r2,-32400(gp)
80112ef8:	10803b04 	addi	r2,r2,236
80112efc:	1009883a 	mov	r4,r2
80112f00:	01103c80 	call	801103c8 <bEnableDbBuffer>

				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
80112f04:	d0a05c17 	ldw	r2,-32400(gp)
80112f08:	10808e04 	addi	r2,r2,568
80112f0c:	1009883a 	mov	r4,r2
80112f10:	010ada00 	call	8010ada0 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
80112f14:	d0a05c17 	ldw	r2,-32400(gp)
80112f18:	10809a43 	ldbu	r2,617(r2)
80112f1c:	10803fcc 	andi	r2,r2,255
80112f20:	d0a05e15 	stw	r2,-32392(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
80112f24:	d0a05e17 	ldw	r2,-32392(gp)
80112f28:	10800044 	addi	r2,r2,1
80112f2c:	108000cc 	andi	r2,r2,3
80112f30:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
80112f34:	e0bffc17 	ldw	r2,-16(fp)
80112f38:	10000e1e 	bne	r2,zero,80112f74 <vFeeTask2+0x9ec>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
80112f3c:	d0a05c17 	ldw	r2,-32400(gp)
80112f40:	10802917 	ldw	r2,164(r2)
80112f44:	10800003 	ldbu	r2,0(r2)
80112f48:	10803fcc 	andi	r2,r2,255
80112f4c:	10c00044 	addi	r3,r2,1
80112f50:	00a00034 	movhi	r2,32768
80112f54:	10800044 	addi	r2,r2,1
80112f58:	1884703a 	and	r2,r3,r2
80112f5c:	1000040e 	bge	r2,zero,80112f70 <vFeeTask2+0x9e8>
80112f60:	10bfffc4 	addi	r2,r2,-1
80112f64:	00ffff84 	movi	r3,-2
80112f68:	10c4b03a 	or	r2,r2,r3
80112f6c:	10800044 	addi	r2,r2,1
80112f70:	e0bff505 	stb	r2,-44(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
80112f74:	d0e05c17 	ldw	r3,-32400(gp)
80112f78:	e0bffc17 	ldw	r2,-16(fp)
80112f7c:	1885883a 	add	r2,r3,r2
80112f80:	10802a44 	addi	r2,r2,169
80112f84:	10800003 	ldbu	r2,0(r2)
80112f88:	e0bff705 	stb	r2,-36(fp)

				if ( pxNFee->xControl.eSide == sLeft )
80112f8c:	d0a05c17 	ldw	r2,-32400(gp)
80112f90:	10802e17 	ldw	r2,184(r2)
80112f94:	1000071e 	bne	r2,zero,80112fb4 <vFeeTask2+0xa2c>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
80112f98:	d0e05c17 	ldw	r3,-32400(gp)
80112f9c:	e0bff703 	ldbu	r2,-36(fp)
80112fa0:	10800624 	muli	r2,r2,24
80112fa4:	10800904 	addi	r2,r2,36
80112fa8:	1885883a 	add	r2,r3,r2
80112fac:	e0bff615 	stw	r2,-40(fp)
80112fb0:	00000606 	br	80112fcc <vFeeTask2+0xa44>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
80112fb4:	d0e05c17 	ldw	r3,-32400(gp)
80112fb8:	e0bff703 	ldbu	r2,-36(fp)
80112fbc:	10800624 	muli	r2,r2,24
80112fc0:	10800c04 	addi	r2,r2,48
80112fc4:	1885883a 	add	r2,r3,r2
80112fc8:	e0bff615 	stw	r2,-40(fp)

				ucIterationSide = pxNFee->xControl.eSide;
80112fcc:	d0a05c17 	ldw	r2,-32400(gp)
80112fd0:	10802e17 	ldw	r2,184(r2)
80112fd4:	d0a05b05 	stb	r2,-32404(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80112fd8:	d0a05c17 	ldw	r2,-32400(gp)
80112fdc:	10803304 	addi	r2,r2,204
80112fe0:	1009883a 	mov	r4,r2
80112fe4:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
80112fe8:	d0a05c17 	ldw	r2,-32400(gp)
80112fec:	e0fff703 	ldbu	r3,-36(fp)
80112ff0:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern;
80112ff4:	d0a05c17 	ldw	r2,-32400(gp)
80112ff8:	00c00244 	movi	r3,9
80112ffc:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
80113000:	d0a05c17 	ldw	r2,-32400(gp)
80113004:	10803304 	addi	r2,r2,204
80113008:	1009883a 	mov	r4,r2
8011300c:	0102c480 	call	80102c48 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80113010:	d0a05c17 	ldw	r2,-32400(gp)
80113014:	10803304 	addi	r2,r2,204
80113018:	1009883a 	mov	r4,r2
8011301c:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
					fprintf(fp,"=========DATA PACKET=============\n");
				}
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
80113020:	d0a05c17 	ldw	r2,-32400(gp)
80113024:	10800003 	ldbu	r2,0(r2)
80113028:	10803fcc 	andi	r2,r2,255
8011302c:	100d883a 	mov	r6,r2
80113030:	000b883a 	mov	r5,zero
80113034:	01002004 	movi	r4,128
80113038:	01104cc0 	call	801104cc <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8011303c:	e03ff915 	stw	zero,-28(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80113040:	d0a05c17 	ldw	r2,-32400(gp)
80113044:	10800003 	ldbu	r2,0(r2)
80113048:	10c03fcc 	andi	r3,r2,255
8011304c:	00a00574 	movhi	r2,32789
80113050:	109f5404 	addi	r2,r2,32080
80113054:	18c7883a 	add	r3,r3,r3
80113058:	18c7883a 	add	r3,r3,r3
8011305c:	10c5883a 	add	r2,r2,r3
80113060:	10800017 	ldw	r2,0(r2)
80113064:	e0fffd04 	addi	r3,fp,-12
80113068:	180d883a 	mov	r6,r3
8011306c:	000b883a 	mov	r5,zero
80113070:	1009883a 	mov	r4,r2
80113074:	01390040 	call	80139004 <OSQPend>
80113078:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8011307c:	e0bffd03 	ldbu	r2,-12(fp)
80113080:	10803fcc 	andi	r2,r2,255
80113084:	1001791e 	bne	r2,zero,8011366c <vFeeTask2+0x10e4>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
80113088:	e0bffe83 	ldbu	r2,-6(fp)
8011308c:	10803fcc 	andi	r2,r2,255
80113090:	108023d8 	cmpnei	r2,r2,143
80113094:	1000481e 	bne	r2,zero,801131b8 <vFeeTask2+0xc30>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
80113098:	e0fff503 	ldbu	r3,-44(fp)
8011309c:	00a005b4 	movhi	r2,32790
801130a0:	10ad6e04 	addi	r2,r2,-19016
801130a4:	180690fa 	slli	r3,r3,3
801130a8:	10c5883a 	add	r2,r2,r3
801130ac:	10800017 	ldw	r2,0(r2)
801130b0:	e0fffd04 	addi	r3,fp,-12
801130b4:	180d883a 	mov	r6,r3
801130b8:	000b883a 	mov	r5,zero
801130bc:	1009883a 	mov	r4,r2
801130c0:	0137ef00 	call	80137ef0 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
801130c4:	e0bffd03 	ldbu	r2,-12(fp)
801130c8:	10803fcc 	andi	r2,r2,255
801130cc:	10001b1e 	bne	r2,zero,8011313c <vFeeTask2+0xbb4>
	                    	pxNFee->xControl.bDMALocked = TRUE;
801130d0:	d0a05c17 	ldw	r2,-32400(gp)
801130d4:	00c00044 	movi	r3,1
801130d8:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee, ucIterationSide );
801130dc:	e0fff503 	ldbu	r3,-44(fp)
801130e0:	d0a05c17 	ldw	r2,-32400(gp)
801130e4:	10800003 	ldbu	r2,0(r2)
801130e8:	11003fcc 	andi	r4,r2,255
801130ec:	d1605c17 	ldw	r5,-32400(gp)
801130f0:	d0a05b03 	ldbu	r2,-32404(gp)
801130f4:	10803fcc 	andi	r2,r2,255
801130f8:	d8800015 	stw	r2,0(sp)
801130fc:	280f883a 	mov	r7,r5
80113100:	200d883a 	mov	r6,r4
80113104:	180b883a 	mov	r5,r3
80113108:	e13ff617 	ldw	r4,-40(fp)
8011310c:	01106b80 	call	801106b8 <bPrepareDoubleBuffer>
80113110:	e0bff915 	stw	r2,-28(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
80113114:	e0fff503 	ldbu	r3,-44(fp)
80113118:	00a005b4 	movhi	r2,32790
8011311c:	10ad6e04 	addi	r2,r2,-19016
80113120:	180690fa 	slli	r3,r3,3
80113124:	10c5883a 	add	r2,r2,r3
80113128:	10800017 	ldw	r2,0(r2)
8011312c:	1009883a 	mov	r4,r2
80113130:	01384940 	call	80138494 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
80113134:	d0a05c17 	ldw	r2,-32400(gp)
80113138:	10002215 	stw	zero,136(r2)

						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8011313c:	d0a05c17 	ldw	r2,-32400(gp)
80113140:	10800003 	ldbu	r2,0(r2)
80113144:	10803fcc 	andi	r2,r2,255
80113148:	100d883a 	mov	r6,r2
8011314c:	000b883a 	mov	r5,zero
80113150:	01002044 	movi	r4,129
80113154:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
80113158:	e0bff917 	ldw	r2,-28(fp)
8011315c:	10800058 	cmpnei	r2,r2,1
80113160:	1001421e 	bne	r2,zero,8011366c <vFeeTask2+0x10e4>
							if (pxNFee->xControl.bWatingSync==TRUE) {
80113164:	d0a05c17 	ldw	r2,-32400(gp)
80113168:	10802817 	ldw	r2,160(r2)
8011316c:	10800058 	cmpnei	r2,r2,1
80113170:	1000071e 	bne	r2,zero,80113190 <vFeeTask2+0xc08>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
80113174:	d0a05c17 	ldw	r2,-32400(gp)
80113178:	00c001c4 	movi	r3,7
8011317c:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
80113180:	d0a05c17 	ldw	r2,-32400(gp)
80113184:	00c00304 	movi	r3,12
80113188:	10c02c15 	stw	r3,176(r2)
8011318c:	00000606 	br	801131a8 <vFeeTask2+0xc20>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
80113190:	d0a05c17 	ldw	r2,-32400(gp)
80113194:	00c001c4 	movi	r3,7
80113198:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8011319c:	d0a05c17 	ldw	r2,-32400(gp)
801131a0:	00c001c4 	movi	r3,7
801131a4:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
801131a8:	d0a05d17 	ldw	r2,-32396(gp)
801131ac:	10800044 	addi	r2,r2,1
801131b0:	d0a05d15 	stw	r2,-32396(gp)
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
801131b4:	00012d06 	br	8011366c <vFeeTask2+0x10e4>
							#endif
						}


					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
801131b8:	d0a05c17 	ldw	r2,-32400(gp)
801131bc:	e0fffe17 	ldw	r3,-8(fp)
801131c0:	180b883a 	mov	r5,r3
801131c4:	1009883a 	mov	r4,r2
801131c8:	010f8380 	call	8010f838 <vQCmdFEEinFullPattern>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
801131cc:	00012706 	br	8011366c <vFeeTask2+0x10e4>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
801131d0:	e03ffa15 	stw	zero,-24(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
801131d4:	d0a05c17 	ldw	r2,-32400(gp)
801131d8:	10804804 	addi	r2,r2,288
801131dc:	1009883a 	mov	r4,r2
801131e0:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
801131e4:	d0a05c17 	ldw	r2,-32400(gp)
801131e8:	00c00084 	movi	r3,2
801131ec:	10c06b15 	stw	r3,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
801131f0:	d0a05c17 	ldw	r2,-32400(gp)
801131f4:	10804804 	addi	r2,r2,288
801131f8:	1009883a 	mov	r4,r2
801131fc:	010857c0 	call	8010857c <bRmapSetMemConfigArea>
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
				}
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
80113200:	d0a05c17 	ldw	r2,-32400(gp)
80113204:	10802e17 	ldw	r2,184(r2)
80113208:	d0a05b05 	stb	r2,-32404(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8011320c:	d0a05c17 	ldw	r2,-32400(gp)
80113210:	00c00044 	movi	r3,1
80113214:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
80113218:	d0a05c17 	ldw	r2,-32400(gp)
8011321c:	00c00104 	movi	r3,4
80113220:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
80113224:	d0a05c17 	ldw	r2,-32400(gp)
80113228:	00c00104 	movi	r3,4
8011322c:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
80113230:	d0a05c17 	ldw	r2,-32400(gp)
80113234:	00c00044 	movi	r3,1
80113238:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8011323c:	d0a05c17 	ldw	r2,-32400(gp)
80113240:	00c00044 	movi	r3,1
80113244:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
80113248:	d0a05c17 	ldw	r2,-32400(gp)
8011324c:	00c00044 	movi	r3,1
80113250:	10c02115 	stw	r3,132(r2)
				//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				vSetDoubleBufferLeftSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80113254:	d0a05c17 	ldw	r2,-32400(gp)
80113258:	10800043 	ldbu	r2,1(r2)
8011325c:	10803fcc 	andi	r2,r2,255
80113260:	100b883a 	mov	r5,r2
80113264:	01000404 	movi	r4,16
80113268:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
				vSetDoubleBufferRightSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
8011326c:	d0a05c17 	ldw	r2,-32400(gp)
80113270:	10800043 	ldbu	r2,1(r2)
80113274:	10803fcc 	andi	r2,r2,255
80113278:	100b883a 	mov	r5,r2
8011327c:	01000404 	movi	r4,16
80113280:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}*/
				break;
80113284:	0000fe06 	br	80113680 <vFeeTask2+0x10f8>

			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
80113288:	e03ffa15 	stw	zero,-24(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8011328c:	d0a05c17 	ldw	r2,-32400(gp)
80113290:	10800003 	ldbu	r2,0(r2)
80113294:	10c03fcc 	andi	r3,r2,255
80113298:	00a00574 	movhi	r2,32789
8011329c:	109f5404 	addi	r2,r2,32080
801132a0:	18c7883a 	add	r3,r3,r3
801132a4:	18c7883a 	add	r3,r3,r3
801132a8:	10c5883a 	add	r2,r2,r3
801132ac:	10800017 	ldw	r2,0(r2)
801132b0:	e0fffd04 	addi	r3,fp,-12
801132b4:	180d883a 	mov	r6,r3
801132b8:	000b883a 	mov	r5,zero
801132bc:	1009883a 	mov	r4,r2
801132c0:	01390040 	call	80139004 <OSQPend>
801132c4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
801132c8:	e0bffd03 	ldbu	r2,-12(fp)
801132cc:	10803fcc 	andi	r2,r2,255
801132d0:	1000e81e 	bne	r2,zero,80113674 <vFeeTask2+0x10ec>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
801132d4:	e0bffe83 	ldbu	r2,-6(fp)
801132d8:	10803fcc 	andi	r2,r2,255
801132dc:	108023d8 	cmpnei	r2,r2,143
801132e0:	1000861e 	bne	r2,zero,801134fc <vFeeTask2+0xf74>

						/* Try to get the Mutex */
						OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
801132e4:	e0fff503 	ldbu	r3,-44(fp)
801132e8:	00a005b4 	movhi	r2,32790
801132ec:	10ad6e04 	addi	r2,r2,-19016
801132f0:	180690fa 	slli	r3,r3,3
801132f4:	10c5883a 	add	r2,r2,r3
801132f8:	10800017 	ldw	r2,0(r2)
801132fc:	e0fffd04 	addi	r3,fp,-12
80113300:	180d883a 	mov	r6,r3
80113304:	000b883a 	mov	r5,zero
80113308:	1009883a 	mov	r4,r2
8011330c:	0137ef00 	call	80137ef0 <OSMutexPend>
						if ( error_code == OS_ERR_NONE ) {
80113310:	e0bffd03 	ldbu	r2,-12(fp)
80113314:	10803fcc 	andi	r2,r2,255
80113318:	1000d61e 	bne	r2,zero,80113674 <vFeeTask2+0x10ec>
							pxNFee->xControl.bDMALocked = TRUE;
8011331c:	d0a05c17 	ldw	r2,-32400(gp)
80113320:	00c00044 	movi	r3,1
80113324:	10c02215 	stw	r3,136(r2)

							/* Is this the last block? */
							if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
80113328:	e0bff617 	ldw	r2,-40(fp)
8011332c:	10800117 	ldw	r2,4(r2)
80113330:	10c00404 	addi	r3,r2,16
80113334:	d0a05c17 	ldw	r2,-32400(gp)
80113338:	10800417 	ldw	r2,16(r2)
8011333c:	18801936 	bltu	r3,r2,801133a4 <vFeeTask2+0xe1c>

								/*Define the size of the data in the double buffer (need this to create the interrupt right)*/
								usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
80113340:	d0a05c17 	ldw	r2,-32400(gp)
80113344:	10c00417 	ldw	r3,16(r2)
80113348:	e0bff617 	ldw	r2,-40(fp)
8011334c:	10800117 	ldw	r2,4(r2)
80113350:	1885c83a 	sub	r2,r3,r2
80113354:	e0bff815 	stw	r2,-32(fp)

								vSetDoubleBufferLeftSize( (unsigned char)usiLengthBlocks, pxNFee->ucSPWId );
80113358:	e0bff817 	ldw	r2,-32(fp)
8011335c:	10c03fcc 	andi	r3,r2,255
80113360:	d0a05c17 	ldw	r2,-32400(gp)
80113364:	10800043 	ldbu	r2,1(r2)
80113368:	10803fcc 	andi	r2,r2,255
8011336c:	100b883a 	mov	r5,r2
80113370:	1809883a 	mov	r4,r3
80113374:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
								vSetDoubleBufferRightSize( (unsigned char)usiLengthBlocks, pxNFee->ucSPWId );
80113378:	e0bff817 	ldw	r2,-32(fp)
8011337c:	10c03fcc 	andi	r3,r2,255
80113380:	d0a05c17 	ldw	r2,-32400(gp)
80113384:	10800043 	ldbu	r2,1(r2)
80113388:	10803fcc 	andi	r2,r2,255
8011338c:	100b883a 	mov	r5,r2
80113390:	1809883a 	mov	r4,r3
80113394:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
								} else {
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
								}*/

								bFinal = TRUE;
80113398:	00800044 	movi	r2,1
8011339c:	e0bffa15 	stw	r2,-24(fp)
801133a0:	00000206 	br	801133ac <vFeeTask2+0xe24>

							} else {
								usiLengthBlocks = SDMA_MAX_BLOCKS;
801133a4:	00800404 	movi	r2,16
801133a8:	e0bff815 	stw	r2,-32(fp)
							}


							if ( ucMemUsing == 0  ) {
801133ac:	e0bff503 	ldbu	r2,-44(fp)
801133b0:	1000111e 	bne	r2,zero,801133f8 <vFeeTask2+0xe70>
								bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
801133b4:	e0bff617 	ldw	r2,-40(fp)
801133b8:	10800217 	ldw	r2,8(r2)
801133bc:	1011883a 	mov	r8,r2
801133c0:	e0bff817 	ldw	r2,-32(fp)
801133c4:	10ffffcc 	andi	r3,r2,65535
801133c8:	d0a05b03 	ldbu	r2,-32404(gp)
801133cc:	11003fcc 	andi	r4,r2,255
801133d0:	d0a05c17 	ldw	r2,-32400(gp)
801133d4:	10800043 	ldbu	r2,1(r2)
801133d8:	10803fcc 	andi	r2,r2,255
801133dc:	100f883a 	mov	r7,r2
801133e0:	200d883a 	mov	r6,r4
801133e4:	180b883a 	mov	r5,r3
801133e8:	4009883a 	mov	r4,r8
801133ec:	0101fd00 	call	80101fd0 <bSdmaDmaM1Transfer>
801133f0:	e0bff915 	stw	r2,-28(fp)
801133f4:	00001006 	br	80113438 <vFeeTask2+0xeb0>
							} else {
								bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
801133f8:	e0bff617 	ldw	r2,-40(fp)
801133fc:	10800217 	ldw	r2,8(r2)
80113400:	1011883a 	mov	r8,r2
80113404:	e0bff817 	ldw	r2,-32(fp)
80113408:	10ffffcc 	andi	r3,r2,65535
8011340c:	d0a05b03 	ldbu	r2,-32404(gp)
80113410:	11003fcc 	andi	r4,r2,255
80113414:	d0a05c17 	ldw	r2,-32400(gp)
80113418:	10800043 	ldbu	r2,1(r2)
8011341c:	10803fcc 	andi	r2,r2,255
80113420:	100f883a 	mov	r7,r2
80113424:	200d883a 	mov	r6,r4
80113428:	180b883a 	mov	r5,r3
8011342c:	4009883a 	mov	r4,r8
80113430:	01024540 	call	80102454 <bSdmaDmaM2Transfer>
80113434:	e0bff915 	stw	r2,-28(fp)
							}

							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
80113438:	e0fff503 	ldbu	r3,-44(fp)
8011343c:	00a005b4 	movhi	r2,32790
80113440:	10ad6e04 	addi	r2,r2,-19016
80113444:	180690fa 	slli	r3,r3,3
80113448:	10c5883a 	add	r2,r2,r3
8011344c:	10800017 	ldw	r2,0(r2)
80113450:	1009883a 	mov	r4,r2
80113454:	01384940 	call	80138494 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
80113458:	d0a05c17 	ldw	r2,-32400(gp)
8011345c:	10002215 	stw	zero,136(r2)

							if ( bDmaReturn == TRUE ) {
80113460:	e0bff917 	ldw	r2,-28(fp)
80113464:	10800058 	cmpnei	r2,r2,1
80113468:	10000e1e 	bne	r2,zero,801134a4 <vFeeTask2+0xf1c>
								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8011346c:	e0bff617 	ldw	r2,-40(fp)
80113470:	10c00217 	ldw	r3,8(r2)
80113474:	e0bff817 	ldw	r2,-32(fp)
80113478:	10802224 	muli	r2,r2,136
8011347c:	1887883a 	add	r3,r3,r2
80113480:	e0bff617 	ldw	r2,-40(fp)
80113484:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += usiLengthBlocks;
80113488:	e0bff617 	ldw	r2,-40(fp)
8011348c:	10c00117 	ldw	r3,4(r2)
80113490:	e0bff817 	ldw	r2,-32(fp)
80113494:	1887883a 	add	r3,r3,r2
80113498:	e0bff617 	ldw	r2,-40(fp)
8011349c:	10c00115 	stw	r3,4(r2)
801134a0:	00000806 	br	801134c4 <vFeeTask2+0xf3c>
							} else {
								bFinal = FALSE;
801134a4:	e03ffa15 	stw	zero,-24(fp)

								/* Send the request for use the DMA, but to front of the QUEUE */
								bSendRequestNFeeCtrl_Front( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
801134a8:	d0a05c17 	ldw	r2,-32400(gp)
801134ac:	10800003 	ldbu	r2,0(r2)
801134b0:	10803fcc 	andi	r2,r2,255
801134b4:	100d883a 	mov	r6,r2
801134b8:	000b883a 	mov	r5,zero
801134bc:	01002004 	movi	r4,128
801134c0:	01105700 	call	80110570 <bSendRequestNFeeCtrl_Front>
							}

							/* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
801134c4:	d0a05c17 	ldw	r2,-32400(gp)
801134c8:	10800003 	ldbu	r2,0(r2)
801134cc:	10803fcc 	andi	r2,r2,255
801134d0:	100d883a 	mov	r6,r2
801134d4:	000b883a 	mov	r5,zero
801134d8:	01002044 	movi	r4,129
801134dc:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

							if ( bFinal == TRUE ) {
801134e0:	e0bffa17 	ldw	r2,-24(fp)
801134e4:	10800058 	cmpnei	r2,r2,1
801134e8:	1000621e 	bne	r2,zero,80113674 <vFeeTask2+0x10ec>
								pxNFee->xControl.eMode = sEndTransmission;
801134ec:	d0a05c17 	ldw	r2,-32400(gp)
801134f0:	00c002c4 	movi	r3,11
801134f4:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
801134f8:	00005e06 	br	80113674 <vFeeTask2+0x10ec>
								//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
							}

						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
801134fc:	d0a05c17 	ldw	r2,-32400(gp)
80113500:	e0fffe17 	ldw	r3,-8(fp)
80113504:	180b883a 	mov	r5,r3
80113508:	1009883a 	mov	r4,r2
8011350c:	010f8380 	call	8010f838 <vQCmdFEEinFullPattern>

						if ( pxNFee->xControl.bWatingSync == FALSE ) {
80113510:	d0a05c17 	ldw	r2,-32400(gp)
80113514:	10802817 	ldw	r2,160(r2)
80113518:	1000561e 	bne	r2,zero,80113674 <vFeeTask2+0x10ec>
							pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8011351c:	d0a05c17 	ldw	r2,-32400(gp)
80113520:	d0e05c17 	ldw	r3,-32400(gp)
80113524:	18c02d17 	ldw	r3,180(r3)
80113528:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8011352c:	00005106 	br	80113674 <vFeeTask2+0x10ec>
					fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu\n", pxNFee->ucId, ucReadout);
					fprintf(fp,"Memory used: %u\n", ucMemUsing);
				}
				#endif

				pxNFee->xControl.bWatingSync = TRUE;
80113530:	d0a05c17 	ldw	r2,-32400(gp)
80113534:	00c00044 	movi	r3,1
80113538:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8011353c:	d0a05c17 	ldw	r2,-32400(gp)
80113540:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bOneShot == FALSE ) {
80113544:	00a005b4 	movhi	r2,32790
80113548:	10ba3604 	addi	r2,r2,-5928
8011354c:	10800917 	ldw	r2,36(r2)
80113550:	10001f1e 	bne	r2,zero,801135d0 <vFeeTask2+0x1048>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
80113554:	d0a05c17 	ldw	r2,-32400(gp)
80113558:	10802d17 	ldw	r2,180(r2)
8011355c:	10800198 	cmpnei	r2,r2,6
80113560:	1000141e 	bne	r2,zero,801135b4 <vFeeTask2+0x102c>

						bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80113564:	d0a05c17 	ldw	r2,-32400(gp)
80113568:	10803304 	addi	r2,r2,204
8011356c:	1009883a 	mov	r4,r2
80113570:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
80113574:	d0a05c17 	ldw	r2,-32400(gp)
80113578:	e0fff703 	ldbu	r3,-36(fp)
8011357c:	10c036c5 	stb	r3,219(r2)
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
80113580:	d0a05c17 	ldw	r2,-32400(gp)
80113584:	10003685 	stb	zero,218(r2)
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
80113588:	d0a05c17 	ldw	r2,-32400(gp)
8011358c:	10803304 	addi	r2,r2,204
80113590:	1009883a 	mov	r4,r2
80113594:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

						pxNFee->xControl.eMode =  sFeeWaitingSync;
80113598:	d0a05c17 	ldw	r2,-32400(gp)
8011359c:	00c00304 	movi	r3,12
801135a0:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
801135a4:	d0a05c17 	ldw	r2,-32400(gp)
801135a8:	00c00184 	movi	r3,6
801135ac:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
801135b0:	00003306 	br	80113680 <vFeeTask2+0x10f8>
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
801135b4:	d0a05c17 	ldw	r2,-32400(gp)
801135b8:	00c00284 	movi	r3,10
801135bc:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
801135c0:	d0a05c17 	ldw	r2,-32400(gp)
801135c4:	00c00304 	movi	r3,12
801135c8:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
801135cc:	00002c06 	br	80113680 <vFeeTask2+0x10f8>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
801135d0:	d0a05c17 	ldw	r2,-32400(gp)
801135d4:	00c00304 	movi	r3,12
801135d8:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
801135dc:	d0a05c17 	ldw	r2,-32400(gp)
801135e0:	00c00184 	movi	r3,6
801135e4:	10c02d15 	stw	r3,180(r2)
				}

				break;
801135e8:	00002506 	br	80113680 <vFeeTask2+0x10f8>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
				}
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
801135ec:	d0a05c17 	ldw	r2,-32400(gp)
801135f0:	10800003 	ldbu	r2,0(r2)
801135f4:	10c03fcc 	andi	r3,r2,255
801135f8:	00a00574 	movhi	r2,32789
801135fc:	109f5404 	addi	r2,r2,32080
80113600:	18c7883a 	add	r3,r3,r3
80113604:	18c7883a 	add	r3,r3,r3
80113608:	10c5883a 	add	r2,r2,r3
8011360c:	10800017 	ldw	r2,0(r2)
80113610:	e0fffd04 	addi	r3,fp,-12
80113614:	180d883a 	mov	r6,r3
80113618:	000b883a 	mov	r5,zero
8011361c:	1009883a 	mov	r4,r2
80113620:	01390040 	call	80139004 <OSQPend>
80113624:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
80113628:	e0bffd03 	ldbu	r2,-12(fp)
8011362c:	10803fcc 	andi	r2,r2,255
80113630:	1000121e 	bne	r2,zero,8011367c <vFeeTask2+0x10f4>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					}
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
80113634:	d0a05c17 	ldw	r2,-32400(gp)
80113638:	e0fffe17 	ldw	r3,-8(fp)
8011363c:	180b883a 	mov	r5,r3
80113640:	1009883a 	mov	r4,r2
80113644:	010f3980 	call	8010f398 <vQCmdFEEinWaitingSync>
				}

				break;
80113648:	00000c06 	br	8011367c <vFeeTask2+0x10f4>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8011364c:	d0a05c17 	ldw	r2,-32400(gp)
80113650:	00c00144 	movi	r3,5
80113654:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
80113658:	00000906 	br	80113680 <vFeeTask2+0x10f8>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
8011365c:	0001883a 	nop
80113660:	003bd206 	br	801125ac <__reset+0xfa0f25ac>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80113664:	0001883a 	nop
80113668:	003bd006 	br	801125ac <__reset+0xfa0f25ac>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
8011366c:	0001883a 	nop
80113670:	003bce06 	br	801125ac <__reset+0xfa0f25ac>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80113674:	0001883a 	nop
80113678:	003bcc06 	br	801125ac <__reset+0xfa0f25ac>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8011367c:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
		}
	}
80113680:	003bca06 	br	801125ac <__reset+0xfa0f25ac>

80113684 <vFeeTask3>:
#include "fee_task3.h"


static unsigned char ucIterationSide;

void vFeeTask3(void *task_data) {
80113684:	defff204 	addi	sp,sp,-56
80113688:	de00012e 	bgeu	sp,et,80113690 <vFeeTask3+0xc>
8011368c:	003b68fa 	trap	3
80113690:	dfc00d15 	stw	ra,52(sp)
80113694:	df000c15 	stw	fp,48(sp)
80113698:	df000c04 	addi	fp,sp,48
8011369c:	e13fff15 	stw	r4,-4(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
801136a0:	e0bfff17 	ldw	r2,-4(fp)
801136a4:	d0a06015 	stw	r2,-32384(gp)
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
801136a8:	d0a06017 	ldw	r2,-32384(gp)
801136ac:	10802c17 	ldw	r2,176(r2)
801136b0:	10c00368 	cmpgeui	r3,r2,13
801136b4:	1804241e 	bne	r3,zero,80114748 <vFeeTask3+0x10c4>
801136b8:	100690ba 	slli	r3,r2,2
801136bc:	00a00474 	movhi	r2,32785
801136c0:	108db404 	addi	r2,r2,14032
801136c4:	1885883a 	add	r2,r3,r2
801136c8:	10800017 	ldw	r2,0(r2)
801136cc:	1000683a 	jmp	r2
801136d0:	80113704 	addi	zero,r16,17628
801136d4:	80113d64 	muli	zero,r16,17653
801136d8:	80113dc4 	addi	zero,r16,17655
801136dc:	80113f04 	addi	zero,r16,17660
801136e0:	80114384 	addi	zero,r16,17678
801136e4:	80113bb8 	rdprs	zero,r16,17646
801136e8:	80113dd4 	ori	zero,r16,17655
801136ec:	801142cc 	andi	zero,r16,17675
801136f0:	80114748 	cmpgei	zero,r16,17693
801136f4:	80114748 	cmpgei	zero,r16,17693
801136f8:	80113f64 	muli	zero,r16,17661
801136fc:	8011462c 	andhi	zero,r16,17688
80113700:	801146e8 	cmpgeui	zero,r16,17691
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
80113704:	d0a06017 	ldw	r2,-32384(gp)
80113708:	10800003 	ldbu	r2,0(r2)
8011370c:	10c03fcc 	andi	r3,r2,255
80113710:	00a00574 	movhi	r2,32789
80113714:	109f5404 	addi	r2,r2,32080
80113718:	18c7883a 	add	r3,r3,r3
8011371c:	18c7883a 	add	r3,r3,r3
80113720:	10c5883a 	add	r2,r2,r3
80113724:	10800017 	ldw	r2,0(r2)
80113728:	1009883a 	mov	r4,r2
8011372c:	0138f440 	call	80138f44 <OSQFlush>
80113730:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
80113734:	e0bffd03 	ldbu	r2,-12(fp)
80113738:	10803fcc 	andi	r2,r2,255
8011373c:	10000126 	beq	r2,zero,80113744 <vFeeTask3+0xc0>
					vFailFlushNFEEQueue();
80113740:	011dbe80 	call	8011dbe8 <vFailFlushNFEEQueue>
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}
				*/

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80113744:	d0a06017 	ldw	r2,-32384(gp)
80113748:	10803304 	addi	r2,r2,204
8011374c:	1009883a 	mov	r4,r2
80113750:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
80113754:	d0a06017 	ldw	r2,-32384(gp)
80113758:	d0e06017 	ldw	r3,-32384(gp)
8011375c:	1900308b 	ldhu	r4,194(r3)
80113760:	d0e06017 	ldw	r3,-32384(gp)
80113764:	18c02f0b 	ldhu	r3,188(r3)
80113768:	20c7883a 	add	r3,r4,r3
8011376c:	1809883a 	mov	r4,r3
80113770:	d0e06017 	ldw	r3,-32384(gp)
80113774:	18c02f8b 	ldhu	r3,190(r3)
80113778:	20c7883a 	add	r3,r4,r3
8011377c:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
80113780:	d0a06017 	ldw	r2,-32384(gp)
80113784:	d0e06017 	ldw	r3,-32384(gp)
80113788:	1900310b 	ldhu	r4,196(r3)
8011378c:	d0e06017 	ldw	r3,-32384(gp)
80113790:	18c0300b 	ldhu	r3,192(r3)
80113794:	20c7883a 	add	r3,r4,r3
80113798:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8011379c:	d0a06017 	ldw	r2,-32384(gp)
801137a0:	d0e06017 	ldw	r3,-32384(gp)
801137a4:	18c0310b 	ldhu	r3,196(r3)
801137a8:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
801137ac:	d0a06017 	ldw	r2,-32384(gp)
801137b0:	d0e06017 	ldw	r3,-32384(gp)
801137b4:	18c0300b 	ldhu	r3,192(r3)
801137b8:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
801137bc:	d0a06017 	ldw	r2,-32384(gp)
801137c0:	00e00004 	movi	r3,-32768
801137c4:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
801137c8:	d0a06017 	ldw	r2,-32384(gp)
801137cc:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
801137d0:	d0a06017 	ldw	r2,-32384(gp)
801137d4:	10003685 	stb	zero,218(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucProtocolId = xDefaults.usiDataProtId; /* 0xF0 ou  0x02*/
801137d8:	d0e06017 	ldw	r3,-32384(gp)
801137dc:	00a005b4 	movhi	r2,32790
801137e0:	10ba3604 	addi	r2,r2,-5928
801137e4:	10800c0b 	ldhu	r2,48(r2)
801137e8:	18803705 	stb	r2,220(r3)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucLogicalAddr = xDefaults.usiDpuLogicalAddr + 3;
801137ec:	d0e06017 	ldw	r3,-32384(gp)
801137f0:	00a005b4 	movhi	r2,32790
801137f4:	10ba3604 	addi	r2,r2,-5928
801137f8:	10800c8b 	ldhu	r2,50(r2)
801137fc:	108000c4 	addi	r2,r2,3
80113800:	18803745 	stb	r2,221(r3)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
80113804:	d0a06017 	ldw	r2,-32384(gp)
80113808:	10803304 	addi	r2,r2,204
8011380c:	1009883a 	mov	r4,r2
80113810:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
80113814:	d0a06017 	ldw	r2,-32384(gp)
80113818:	10804804 	addi	r2,r2,288
8011381c:	1009883a 	mov	r4,r2
80113820:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
80113824:	d0a06017 	ldw	r2,-32384(gp)
80113828:	00ffc004 	movi	r3,-256
8011382c:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
80113830:	d0a06017 	ldw	r2,-32384(gp)
80113834:	00ffc044 	movi	r3,-255
80113838:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8011383c:	d0a06017 	ldw	r2,-32384(gp)
80113840:	00ffc084 	movi	r3,-254
80113844:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
80113848:	d0a06017 	ldw	r2,-32384(gp)
8011384c:	00ffc0c4 	movi	r3,-253
80113850:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
80113854:	d0a06017 	ldw	r2,-32384(gp)
80113858:	00ffc104 	movi	r3,-252
8011385c:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
80113860:	d0a06017 	ldw	r2,-32384(gp)
80113864:	00ffc144 	movi	r3,-251
80113868:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8011386c:	d0a06017 	ldw	r2,-32384(gp)
80113870:	00ffc184 	movi	r3,-250
80113874:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
80113878:	d0a06017 	ldw	r2,-32384(gp)
8011387c:	00ffc1c4 	movi	r3,-249
80113880:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
80113884:	d0a06017 	ldw	r2,-32384(gp)
80113888:	00ffc204 	movi	r3,-248
8011388c:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
80113890:	d0a06017 	ldw	r2,-32384(gp)
80113894:	00ffc244 	movi	r3,-247
80113898:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8011389c:	d0a06017 	ldw	r2,-32384(gp)
801138a0:	00ffc284 	movi	r3,-246
801138a4:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
801138a8:	d0a06017 	ldw	r2,-32384(gp)
801138ac:	00ffc2c4 	movi	r3,-245
801138b0:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
801138b4:	d0a06017 	ldw	r2,-32384(gp)
801138b8:	00ffc304 	movi	r3,-244
801138bc:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
801138c0:	d0a06017 	ldw	r2,-32384(gp)
801138c4:	00ffc344 	movi	r3,-243
801138c8:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
801138cc:	d0a06017 	ldw	r2,-32384(gp)
801138d0:	00ffc384 	movi	r3,-242
801138d4:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
801138d8:	d0a06017 	ldw	r2,-32384(gp)
801138dc:	00ffc3c4 	movi	r3,-241
801138e0:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
801138e4:	d0a06017 	ldw	r2,-32384(gp)
801138e8:	00ffc404 	movi	r3,-240
801138ec:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
801138f0:	d0a06017 	ldw	r2,-32384(gp)
801138f4:	00ffc444 	movi	r3,-239
801138f8:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
801138fc:	d0a06017 	ldw	r2,-32384(gp)
80113900:	00ffc484 	movi	r3,-238
80113904:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
80113908:	d0a06017 	ldw	r2,-32384(gp)
8011390c:	00ffc4c4 	movi	r3,-237
80113910:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
80113914:	d0a06017 	ldw	r2,-32384(gp)
80113918:	00ffc504 	movi	r3,-236
8011391c:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
80113920:	d0a06017 	ldw	r2,-32384(gp)
80113924:	00ffc544 	movi	r3,-235
80113928:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8011392c:	d0a06017 	ldw	r2,-32384(gp)
80113930:	00ffc584 	movi	r3,-234
80113934:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
80113938:	d0a06017 	ldw	r2,-32384(gp)
8011393c:	00ffc5c4 	movi	r3,-233
80113940:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
80113944:	d0a06017 	ldw	r2,-32384(gp)
80113948:	00ffc604 	movi	r3,-232
8011394c:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
80113950:	d0a06017 	ldw	r2,-32384(gp)
80113954:	00ffc644 	movi	r3,-231
80113958:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8011395c:	d0a06017 	ldw	r2,-32384(gp)
80113960:	00ffc684 	movi	r3,-230
80113964:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
80113968:	d0a06017 	ldw	r2,-32384(gp)
8011396c:	00ffc6c4 	movi	r3,-229
80113970:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
80113974:	d0a06017 	ldw	r2,-32384(gp)
80113978:	00ffc704 	movi	r3,-228
8011397c:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
80113980:	d0a06017 	ldw	r2,-32384(gp)
80113984:	00ffc744 	movi	r3,-227
80113988:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8011398c:	d0a06017 	ldw	r2,-32384(gp)
80113990:	00ffc784 	movi	r3,-226
80113994:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
80113998:	d0a06017 	ldw	r2,-32384(gp)
8011399c:	00ffc7c4 	movi	r3,-225
801139a0:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
801139a4:	d0a06017 	ldw	r2,-32384(gp)
801139a8:	00ffc804 	movi	r3,-224
801139ac:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
801139b0:	d0a06017 	ldw	r2,-32384(gp)
801139b4:	00ffc844 	movi	r3,-223
801139b8:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
801139bc:	d0a06017 	ldw	r2,-32384(gp)
801139c0:	00ffc884 	movi	r3,-222
801139c4:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
801139c8:	d0a06017 	ldw	r2,-32384(gp)
801139cc:	00ffc8c4 	movi	r3,-221
801139d0:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
801139d4:	d0a06017 	ldw	r2,-32384(gp)
801139d8:	00ffc904 	movi	r3,-220
801139dc:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
801139e0:	d0a06017 	ldw	r2,-32384(gp)
801139e4:	00ffc944 	movi	r3,-219
801139e8:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
801139ec:	d0a06017 	ldw	r2,-32384(gp)
801139f0:	00ffc984 	movi	r3,-218
801139f4:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
801139f8:	d0a06017 	ldw	r2,-32384(gp)
801139fc:	00ffc9c4 	movi	r3,-217
80113a00:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
80113a04:	d0a06017 	ldw	r2,-32384(gp)
80113a08:	00ffca04 	movi	r3,-216
80113a0c:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
80113a10:	d0a06017 	ldw	r2,-32384(gp)
80113a14:	00ffca44 	movi	r3,-215
80113a18:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
80113a1c:	d0a06017 	ldw	r2,-32384(gp)
80113a20:	00ffca84 	movi	r3,-214
80113a24:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
80113a28:	d0a06017 	ldw	r2,-32384(gp)
80113a2c:	00ffcac4 	movi	r3,-213
80113a30:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
80113a34:	d0a06017 	ldw	r2,-32384(gp)
80113a38:	00ffcb04 	movi	r3,-212
80113a3c:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
80113a40:	d0a06017 	ldw	r2,-32384(gp)
80113a44:	00ffcb44 	movi	r3,-211
80113a48:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
80113a4c:	d0a06017 	ldw	r2,-32384(gp)
80113a50:	00ffcb84 	movi	r3,-210
80113a54:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
80113a58:	d0a06017 	ldw	r2,-32384(gp)
80113a5c:	00ffcbc4 	movi	r3,-209
80113a60:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
80113a64:	d0a06017 	ldw	r2,-32384(gp)
80113a68:	00ffcc04 	movi	r3,-208
80113a6c:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
80113a70:	d0a06017 	ldw	r2,-32384(gp)
80113a74:	00ffcc44 	movi	r3,-207
80113a78:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
80113a7c:	d0a06017 	ldw	r2,-32384(gp)
80113a80:	00ffcc84 	movi	r3,-206
80113a84:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
80113a88:	d0a06017 	ldw	r2,-32384(gp)
80113a8c:	00ffccc4 	movi	r3,-205
80113a90:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
80113a94:	d0a06017 	ldw	r2,-32384(gp)
80113a98:	00ffcd04 	movi	r3,-204
80113a9c:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
80113aa0:	d0a06017 	ldw	r2,-32384(gp)
80113aa4:	00ffcd44 	movi	r3,-203
80113aa8:	10c0888d 	sth	r3,546(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
80113aac:	d0a06017 	ldw	r2,-32384(gp)
80113ab0:	00ffcd84 	movi	r3,-202
80113ab4:	10c0890d 	sth	r3,548(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
80113ab8:	d0a06017 	ldw	r2,-32384(gp)
80113abc:	00ffcdc4 	movi	r3,-201
80113ac0:	10c0898d 	sth	r3,550(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
80113ac4:	d0a06017 	ldw	r2,-32384(gp)
80113ac8:	00ffce04 	movi	r3,-200
80113acc:	10c08a0d 	sth	r3,552(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
80113ad0:	d0a06017 	ldw	r2,-32384(gp)
80113ad4:	00ffce44 	movi	r3,-199
80113ad8:	10c08a8d 	sth	r3,554(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
80113adc:	d0a06017 	ldw	r2,-32384(gp)
80113ae0:	00ffce84 	movi	r3,-198
80113ae4:	10c08b0d 	sth	r3,556(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
80113ae8:	d0a06017 	ldw	r2,-32384(gp)
80113aec:	00ffcec4 	movi	r3,-197
80113af0:	10c08b8d 	sth	r3,558(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
80113af4:	d0a06017 	ldw	r2,-32384(gp)
80113af8:	00ffcf04 	movi	r3,-196
80113afc:	10c08c0d 	sth	r3,560(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
80113b00:	d0a06017 	ldw	r2,-32384(gp)
80113b04:	00ffcf44 	movi	r3,-195
80113b08:	10c08c8d 	sth	r3,562(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
80113b0c:	d0a06017 	ldw	r2,-32384(gp)
80113b10:	00ffcf84 	movi	r3,-194
80113b14:	10c08d0d 	sth	r3,564(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
80113b18:	d0a06017 	ldw	r2,-32384(gp)
80113b1c:	00ffcfc4 	movi	r3,-193
80113b20:	10c08d8d 	sth	r3,566(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
80113b24:	d0a06017 	ldw	r2,-32384(gp)
80113b28:	10804804 	addi	r2,r2,288
80113b2c:	1009883a 	mov	r4,r2
80113b30:	0108c180 	call	80108c18 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
80113b34:	0110f640 	call	80110f64 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
80113b38:	d0a06017 	ldw	r2,-32384(gp)
80113b3c:	10804804 	addi	r2,r2,288
80113b40:	1009883a 	mov	r4,r2
80113b44:	0109ce40 	call	80109ce4 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
80113b48:	d0a06017 	ldw	r2,-32384(gp)
80113b4c:	10806e04 	addi	r2,r2,440
80113b50:	e0bffb15 	stw	r2,-20(fp)
					fprintf(fp,"\n================= H  K ==================\n\n");
				}
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
80113b54:	d0a06017 	ldw	r2,-32384(gp)
80113b58:	10804804 	addi	r2,r2,288
80113b5c:	1009883a 	mov	r4,r2
80113b60:	01082300 	call	80108230 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
80113b64:	d0e06017 	ldw	r3,-32384(gp)
80113b68:	00a005b4 	movhi	r2,32790
80113b6c:	10ba3604 	addi	r2,r2,-5928
80113b70:	1080080b 	ldhu	r2,32(r2)
80113b74:	18804905 	stb	r2,292(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
80113b78:	d0e06017 	ldw	r3,-32384(gp)
80113b7c:	00a005b4 	movhi	r2,32790
80113b80:	10ba3604 	addi	r2,r2,-5928
80113b84:	1080088b 	ldhu	r2,34(r2)
80113b88:	18804945 	stb	r2,293(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
80113b8c:	d0a06017 	ldw	r2,-32384(gp)
80113b90:	10804804 	addi	r2,r2,288
80113b94:	1009883a 	mov	r4,r2
80113b98:	01081540 	call	80108154 <bRmapSetCodecConfig>
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", pxNFee->ucId ,xDefaults.ucRmapKey );
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", pxNFee->ucId, xDefaults.ucLogicalAddr);
				}
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
80113b9c:	d0a06017 	ldw	r2,-32384(gp)
80113ba0:	00c00144 	movi	r3,5
80113ba4:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
80113ba8:	d0a06017 	ldw	r2,-32384(gp)
80113bac:	10802e17 	ldw	r2,184(r2)
80113bb0:	d0a05f05 	stb	r2,-32388(gp)

				break;
80113bb4:	0002f106 	br	8011477c <vFeeTask3+0x10f8>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
80113bb8:	d0a06017 	ldw	r2,-32384(gp)
80113bbc:	10804804 	addi	r2,r2,288
80113bc0:	1009883a 	mov	r4,r2
80113bc4:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
80113bc8:	d0a06017 	ldw	r2,-32384(gp)
80113bcc:	00c00184 	movi	r3,6
80113bd0:	10c06b15 	stw	r3,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
80113bd4:	d0a06017 	ldw	r2,-32384(gp)
80113bd8:	10804804 	addi	r2,r2,288
80113bdc:	1009883a 	mov	r4,r2
80113be0:	010857c0 	call	8010857c <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
80113be4:	d0a06017 	ldw	r2,-32384(gp)
80113be8:	10808e04 	addi	r2,r2,568
80113bec:	1009883a 	mov	r4,r2
80113bf0:	01103080 	call	80110308 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
80113bf4:	d0a06017 	ldw	r2,-32384(gp)
80113bf8:	10002615 	stw	zero,152(r2)
				bSetPainelLeds( LEDS_OFF , uliReturnMaskG( pxNFee->ucSPWId ) );
80113bfc:	d0a06017 	ldw	r2,-32384(gp)
80113c00:	10800043 	ldbu	r2,1(r2)
80113c04:	10803fcc 	andi	r2,r2,255
80113c08:	1009883a 	mov	r4,r2
80113c0c:	0110e840 	call	80110e84 <uliReturnMaskG>
80113c10:	100b883a 	mov	r5,r2
80113c14:	0009883a 	mov	r4,zero
80113c18:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , uliReturnMaskR( pxNFee->ucSPWId ) );
80113c1c:	d0a06017 	ldw	r2,-32384(gp)
80113c20:	10800043 	ldbu	r2,1(r2)
80113c24:	10803fcc 	andi	r2,r2,255
80113c28:	1009883a 	mov	r4,r2
80113c2c:	0110da40 	call	80110da4 <uliReturnMaskR>
80113c30:	100b883a 	mov	r5,r2
80113c34:	01000044 	movi	r4,1
80113c38:	010bb640 	call	8010bb64 <bSetPainelLeds>

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
80113c3c:	d0a06017 	ldw	r2,-32384(gp)
80113c40:	10c04804 	addi	r3,r2,288
80113c44:	d0a06017 	ldw	r2,-32384(gp)
80113c48:	10800043 	ldbu	r2,1(r2)
80113c4c:	10803fcc 	andi	r2,r2,255
80113c50:	100b883a 	mov	r5,r2
80113c54:	1809883a 	mov	r4,r3
80113c58:	011025c0 	call	8011025c <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80113c5c:	d0a06017 	ldw	r2,-32384(gp)
80113c60:	10803b04 	addi	r2,r2,236
80113c64:	1009883a 	mov	r4,r2
80113c68:	01104600 	call	80110460 <bDisAndClrDbBuffer>
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
				}
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
80113c6c:	d0a06017 	ldw	r2,-32384(gp)
80113c70:	10802217 	ldw	r2,136(r2)
80113c74:	10800058 	cmpnei	r2,r2,1
80113c78:	10000a1e 	bne	r2,zero,80113ca4 <vFeeTask3+0x620>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
80113c7c:	e0fff503 	ldbu	r3,-44(fp)
80113c80:	00a005b4 	movhi	r2,32790
80113c84:	10ad6e04 	addi	r2,r2,-19016
80113c88:	180690fa 	slli	r3,r3,3
80113c8c:	10c5883a 	add	r2,r2,r3
80113c90:	10800017 	ldw	r2,0(r2)
80113c94:	1009883a 	mov	r4,r2
80113c98:	01384940 	call	80138494 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
80113c9c:	d0a06017 	ldw	r2,-32384(gp)
80113ca0:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
80113ca4:	d0a06017 	ldw	r2,-32384(gp)
80113ca8:	10002815 	stw	zero,160(r2)
					vFailFlushNFEEQueue();
				}
				*/

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
80113cac:	d0a06017 	ldw	r2,-32384(gp)
80113cb0:	10800003 	ldbu	r2,0(r2)
80113cb4:	10803fcc 	andi	r2,r2,255
80113cb8:	100d883a 	mov	r6,r2
80113cbc:	000b883a 	mov	r5,zero
80113cc0:	01002044 	movi	r4,129
80113cc4:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
80113cc8:	d0a06017 	ldw	r2,-32384(gp)
80113ccc:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
80113cd0:	d0a06017 	ldw	r2,-32384(gp)
80113cd4:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
80113cd8:	d0a06017 	ldw	r2,-32384(gp)
80113cdc:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
80113ce0:	d0a06017 	ldw	r2,-32384(gp)
80113ce4:	00c00044 	movi	r3,1
80113ce8:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
80113cec:	d0a06017 	ldw	r2,-32384(gp)
80113cf0:	1009883a 	mov	r4,r2
80113cf4:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
80113cf8:	d0a06017 	ldw	r2,-32384(gp)
80113cfc:	10800003 	ldbu	r2,0(r2)
80113d00:	10c03fcc 	andi	r3,r2,255
80113d04:	00a00574 	movhi	r2,32789
80113d08:	109f5404 	addi	r2,r2,32080
80113d0c:	18c7883a 	add	r3,r3,r3
80113d10:	18c7883a 	add	r3,r3,r3
80113d14:	10c5883a 	add	r2,r2,r3
80113d18:	10800017 	ldw	r2,0(r2)
80113d1c:	1009883a 	mov	r4,r2
80113d20:	0138f440 	call	80138f44 <OSQFlush>
80113d24:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
80113d28:	e0bffd03 	ldbu	r2,-12(fp)
80113d2c:	10803fcc 	andi	r2,r2,255
80113d30:	10000126 	beq	r2,zero,80113d38 <vFeeTask3+0x6b4>
					vFailFlushNFEEQueue();
80113d34:	011dbe80 	call	8011dbe8 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
80113d38:	d0a06017 	ldw	r2,-32384(gp)
80113d3c:	00c00044 	movi	r3,1
80113d40:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
80113d44:	d0a06017 	ldw	r2,-32384(gp)
80113d48:	00c00044 	movi	r3,1
80113d4c:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
80113d50:	d0a06017 	ldw	r2,-32384(gp)
80113d54:	10802e17 	ldw	r2,184(r2)
80113d58:	d0a05f05 	stb	r2,-32388(gp)
				bFinal = FALSE;
80113d5c:	e03ffa15 	stw	zero,-24(fp)
				break;
80113d60:	00028606 	br	8011477c <vFeeTask3+0x10f8>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80113d64:	d0a06017 	ldw	r2,-32384(gp)
80113d68:	10800003 	ldbu	r2,0(r2)
80113d6c:	10c03fcc 	andi	r3,r2,255
80113d70:	00a00574 	movhi	r2,32789
80113d74:	109f5404 	addi	r2,r2,32080
80113d78:	18c7883a 	add	r3,r3,r3
80113d7c:	18c7883a 	add	r3,r3,r3
80113d80:	10c5883a 	add	r2,r2,r3
80113d84:	10800017 	ldw	r2,0(r2)
80113d88:	e0fffd04 	addi	r3,fp,-12
80113d8c:	180d883a 	mov	r6,r3
80113d90:	000b883a 	mov	r5,zero
80113d94:	1009883a 	mov	r4,r2
80113d98:	01390040 	call	80139004 <OSQPend>
80113d9c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
80113da0:	e0bffd03 	ldbu	r2,-12(fp)
80113da4:	10803fcc 	andi	r2,r2,255
80113da8:	10026b1e 	bne	r2,zero,80114758 <vFeeTask3+0x10d4>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
80113dac:	d0a06017 	ldw	r2,-32384(gp)
80113db0:	e0fffe17 	ldw	r3,-8(fp)
80113db4:	180b883a 	mov	r5,r3
80113db8:	1009883a 	mov	r4,r2
80113dbc:	010f56c0 	call	8010f56c <vQCmdFEEinConfig>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80113dc0:	00026506 	br	80114758 <vFeeTask3+0x10d4>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
80113dc4:	d0a06017 	ldw	r2,-32384(gp)
80113dc8:	00c00184 	movi	r3,6
80113dcc:	10c02c15 	stw	r3,176(r2)
				break;
80113dd0:	00026a06 	br	8011477c <vFeeTask3+0x10f8>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
80113dd4:	d0a06017 	ldw	r2,-32384(gp)
80113dd8:	10804804 	addi	r2,r2,288
80113ddc:	1009883a 	mov	r4,r2
80113de0:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
80113de4:	d0a06017 	ldw	r2,-32384(gp)
80113de8:	10006b15 	stw	zero,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
80113dec:	d0a06017 	ldw	r2,-32384(gp)
80113df0:	10804804 	addi	r2,r2,288
80113df4:	1009883a 	mov	r4,r2
80113df8:	010857c0 	call	8010857c <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80113dfc:	d0a06017 	ldw	r2,-32384(gp)
80113e00:	10803b04 	addi	r2,r2,236
80113e04:	1009883a 	mov	r4,r2
80113e08:	01104600 	call	80110460 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
80113e0c:	d0a06017 	ldw	r2,-32384(gp)
80113e10:	10c04804 	addi	r3,r2,288
80113e14:	d0a06017 	ldw	r2,-32384(gp)
80113e18:	10800003 	ldbu	r2,0(r2)
80113e1c:	10803fcc 	andi	r2,r2,255
80113e20:	100b883a 	mov	r5,r2
80113e24:	1809883a 	mov	r4,r3
80113e28:	01102b00 	call	801102b0 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
80113e2c:	d0a06017 	ldw	r2,-32384(gp)
80113e30:	10808e04 	addi	r2,r2,568
80113e34:	1009883a 	mov	r4,r2
80113e38:	01103680 	call	80110368 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
80113e3c:	d0a06017 	ldw	r2,-32384(gp)
80113e40:	00c00044 	movi	r3,1
80113e44:	10c02615 	stw	r3,152(r2)
				bSetPainelLeds( LEDS_OFF , uliReturnMaskR( pxNFee->ucSPWId ) );
80113e48:	d0a06017 	ldw	r2,-32384(gp)
80113e4c:	10800043 	ldbu	r2,1(r2)
80113e50:	10803fcc 	andi	r2,r2,255
80113e54:	1009883a 	mov	r4,r2
80113e58:	0110da40 	call	80110da4 <uliReturnMaskR>
80113e5c:	100b883a 	mov	r5,r2
80113e60:	0009883a 	mov	r4,zero
80113e64:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , uliReturnMaskG( pxNFee->ucSPWId ) );
80113e68:	d0a06017 	ldw	r2,-32384(gp)
80113e6c:	10800043 	ldbu	r2,1(r2)
80113e70:	10803fcc 	andi	r2,r2,255
80113e74:	1009883a 	mov	r4,r2
80113e78:	0110e840 	call	80110e84 <uliReturnMaskG>
80113e7c:	100b883a 	mov	r5,r2
80113e80:	01000044 	movi	r4,1
80113e84:	010bb640 	call	8010bb64 <bSetPainelLeds>

				pxNFee->xControl.bSimulating = TRUE;
80113e88:	d0a06017 	ldw	r2,-32384(gp)
80113e8c:	00c00044 	movi	r3,1
80113e90:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
80113e94:	d0a06017 	ldw	r2,-32384(gp)
80113e98:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
80113e9c:	d0a06017 	ldw	r2,-32384(gp)
80113ea0:	00c00044 	movi	r3,1
80113ea4:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
80113ea8:	d0a06017 	ldw	r2,-32384(gp)
80113eac:	10800003 	ldbu	r2,0(r2)
80113eb0:	10803fcc 	andi	r2,r2,255
80113eb4:	100d883a 	mov	r6,r2
80113eb8:	000b883a 	mov	r5,zero
80113ebc:	01002044 	movi	r4,129
80113ec0:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
80113ec4:	d0a06017 	ldw	r2,-32384(gp)
80113ec8:	10002815 	stw	zero,160(r2)
					fprintf(fp,"NFEE-%hu Task: Standby\n", pxNFee->ucId);
				}
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
80113ecc:	d0a06017 	ldw	r2,-32384(gp)
80113ed0:	1009883a 	mov	r4,r2
80113ed4:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				incrementador = 0;
80113ed8:	d0206115 	stw	zero,-32380(gp)

				pxNFee->xControl.bWatingSync = TRUE;
80113edc:	d0a06017 	ldw	r2,-32384(gp)
80113ee0:	00c00044 	movi	r3,1
80113ee4:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
80113ee8:	d0a06017 	ldw	r2,-32384(gp)
80113eec:	00c000c4 	movi	r3,3
80113ef0:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
80113ef4:	d0a06017 	ldw	r2,-32384(gp)
80113ef8:	10802e17 	ldw	r2,184(r2)
80113efc:	d0a05f05 	stb	r2,-32388(gp)
				break;
80113f00:	00021e06 	br	8011477c <vFeeTask3+0x10f8>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80113f04:	d0a06017 	ldw	r2,-32384(gp)
80113f08:	10800003 	ldbu	r2,0(r2)
80113f0c:	10c03fcc 	andi	r3,r2,255
80113f10:	00a00574 	movhi	r2,32789
80113f14:	109f5404 	addi	r2,r2,32080
80113f18:	18c7883a 	add	r3,r3,r3
80113f1c:	18c7883a 	add	r3,r3,r3
80113f20:	10c5883a 	add	r2,r2,r3
80113f24:	10800017 	ldw	r2,0(r2)
80113f28:	e0fffd04 	addi	r3,fp,-12
80113f2c:	180d883a 	mov	r6,r3
80113f30:	000b883a 	mov	r5,zero
80113f34:	1009883a 	mov	r4,r2
80113f38:	01390040 	call	80139004 <OSQPend>
80113f3c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
80113f40:	e0bffd03 	ldbu	r2,-12(fp)
80113f44:	10803fcc 	andi	r2,r2,255
80113f48:	1002051e 	bne	r2,zero,80114760 <vFeeTask3+0x10dc>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
80113f4c:	d0a06017 	ldw	r2,-32384(gp)
80113f50:	e0fffe17 	ldw	r3,-8(fp)
80113f54:	180b883a 	mov	r5,r3
80113f58:	1009883a 	mov	r4,r2
80113f5c:	010f6a80 	call	8010f6a8 <vQCmdFEEinStandBy>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80113f60:	0001ff06 	br	80114760 <vFeeTask3+0x10dc>
				if ( error_code != OS_NO_ERR ) {
					vFailFlushNFEEQueue();
				}
				*/

				pxNFee->xControl.bUsingDMA = TRUE;
80113f64:	d0a06017 	ldw	r2,-32384(gp)
80113f68:	00c00044 	movi	r3,1
80113f6c:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
80113f70:	d0a06017 	ldw	r2,-32384(gp)
80113f74:	00c00044 	movi	r3,1
80113f78:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
80113f7c:	d0a06017 	ldw	r2,-32384(gp)
80113f80:	1009883a 	mov	r4,r2
80113f84:	011e1e80 	call	8011e1e8 <vResetMemCCDFEE>

				/* Wait until both buffers are empty  */
				vWaitUntilBufferEmpty( pxNFee->ucSPWId );
80113f88:	d0a06017 	ldw	r2,-32384(gp)
80113f8c:	10800043 	ldbu	r2,1(r2)
80113f90:	10803fcc 	andi	r2,r2,255
80113f94:	1009883a 	mov	r4,r2
80113f98:	0110c9c0 	call	80110c9c <vWaitUntilBufferEmpty>
					while ( (bFeebGetCh2LeftFeeBusy()== TRUE) || (bFeebGetCh2RightFeeBusy()== TRUE)  ) {}
				}
				*/


				OSTimeDlyHMSM(0,0,0,xDefaults.usiGuardNFEEDelay);
80113f9c:	00a005b4 	movhi	r2,32790
80113fa0:	10ba3604 	addi	r2,r2,-5928
80113fa4:	10800b8b 	ldhu	r2,46(r2)
80113fa8:	10bfffcc 	andi	r2,r2,65535
80113fac:	100f883a 	mov	r7,r2
80113fb0:	000d883a 	mov	r6,zero
80113fb4:	000b883a 	mov	r5,zero
80113fb8:	0009883a 	mov	r4,zero
80113fbc:	013be940 	call	8013be94 <OSTimeDlyHMSM>

				vSetDoubleBufferLeftSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80113fc0:	d0a06017 	ldw	r2,-32384(gp)
80113fc4:	10800043 	ldbu	r2,1(r2)
80113fc8:	10803fcc 	andi	r2,r2,255
80113fcc:	100b883a 	mov	r5,r2
80113fd0:	01000404 	movi	r4,16
80113fd4:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
				vSetDoubleBufferRightSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80113fd8:	d0a06017 	ldw	r2,-32384(gp)
80113fdc:	10800043 	ldbu	r2,1(r2)
80113fe0:	10803fcc 	andi	r2,r2,255
80113fe4:	100b883a 	mov	r5,r2
80113fe8:	01000404 	movi	r4,16
80113fec:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}*/

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
80113ff0:	d0a06017 	ldw	r2,-32384(gp)
80113ff4:	10803b04 	addi	r2,r2,236
80113ff8:	1009883a 	mov	r4,r2
80113ffc:	01103c80 	call	801103c8 <bEnableDbBuffer>

				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
80114000:	d0a06017 	ldw	r2,-32384(gp)
80114004:	10808e04 	addi	r2,r2,568
80114008:	1009883a 	mov	r4,r2
8011400c:	010ada00 	call	8010ada0 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
80114010:	d0a06017 	ldw	r2,-32384(gp)
80114014:	10809a43 	ldbu	r2,617(r2)
80114018:	10803fcc 	andi	r2,r2,255
8011401c:	d0a06215 	stw	r2,-32376(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
80114020:	d0a06217 	ldw	r2,-32376(gp)
80114024:	10800044 	addi	r2,r2,1
80114028:	108000cc 	andi	r2,r2,3
8011402c:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
80114030:	e0bffc17 	ldw	r2,-16(fp)
80114034:	10000e1e 	bne	r2,zero,80114070 <vFeeTask3+0x9ec>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
80114038:	d0a06017 	ldw	r2,-32384(gp)
8011403c:	10802917 	ldw	r2,164(r2)
80114040:	10800003 	ldbu	r2,0(r2)
80114044:	10803fcc 	andi	r2,r2,255
80114048:	10c00044 	addi	r3,r2,1
8011404c:	00a00034 	movhi	r2,32768
80114050:	10800044 	addi	r2,r2,1
80114054:	1884703a 	and	r2,r3,r2
80114058:	1000040e 	bge	r2,zero,8011406c <vFeeTask3+0x9e8>
8011405c:	10bfffc4 	addi	r2,r2,-1
80114060:	00ffff84 	movi	r3,-2
80114064:	10c4b03a 	or	r2,r2,r3
80114068:	10800044 	addi	r2,r2,1
8011406c:	e0bff505 	stb	r2,-44(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
80114070:	d0e06017 	ldw	r3,-32384(gp)
80114074:	e0bffc17 	ldw	r2,-16(fp)
80114078:	1885883a 	add	r2,r3,r2
8011407c:	10802a44 	addi	r2,r2,169
80114080:	10800003 	ldbu	r2,0(r2)
80114084:	e0bff705 	stb	r2,-36(fp)

				if ( pxNFee->xControl.eSide == sLeft )
80114088:	d0a06017 	ldw	r2,-32384(gp)
8011408c:	10802e17 	ldw	r2,184(r2)
80114090:	1000071e 	bne	r2,zero,801140b0 <vFeeTask3+0xa2c>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
80114094:	d0e06017 	ldw	r3,-32384(gp)
80114098:	e0bff703 	ldbu	r2,-36(fp)
8011409c:	10800624 	muli	r2,r2,24
801140a0:	10800904 	addi	r2,r2,36
801140a4:	1885883a 	add	r2,r3,r2
801140a8:	e0bff615 	stw	r2,-40(fp)
801140ac:	00000606 	br	801140c8 <vFeeTask3+0xa44>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
801140b0:	d0e06017 	ldw	r3,-32384(gp)
801140b4:	e0bff703 	ldbu	r2,-36(fp)
801140b8:	10800624 	muli	r2,r2,24
801140bc:	10800c04 	addi	r2,r2,48
801140c0:	1885883a 	add	r2,r3,r2
801140c4:	e0bff615 	stw	r2,-40(fp)

				ucIterationSide = pxNFee->xControl.eSide;
801140c8:	d0a06017 	ldw	r2,-32384(gp)
801140cc:	10802e17 	ldw	r2,184(r2)
801140d0:	d0a05f05 	stb	r2,-32388(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
801140d4:	d0a06017 	ldw	r2,-32384(gp)
801140d8:	10803304 	addi	r2,r2,204
801140dc:	1009883a 	mov	r4,r2
801140e0:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
801140e4:	d0a06017 	ldw	r2,-32384(gp)
801140e8:	e0fff703 	ldbu	r3,-36(fp)
801140ec:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern;
801140f0:	d0a06017 	ldw	r2,-32384(gp)
801140f4:	00c00244 	movi	r3,9
801140f8:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
801140fc:	d0a06017 	ldw	r2,-32384(gp)
80114100:	10803304 	addi	r2,r2,204
80114104:	1009883a 	mov	r4,r2
80114108:	0102c480 	call	80102c48 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8011410c:	d0a06017 	ldw	r2,-32384(gp)
80114110:	10803304 	addi	r2,r2,204
80114114:	1009883a 	mov	r4,r2
80114118:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
					fprintf(fp,"=========DATA PACKET=============\n");
				}
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8011411c:	d0a06017 	ldw	r2,-32384(gp)
80114120:	10800003 	ldbu	r2,0(r2)
80114124:	10803fcc 	andi	r2,r2,255
80114128:	100d883a 	mov	r6,r2
8011412c:	000b883a 	mov	r5,zero
80114130:	01002004 	movi	r4,128
80114134:	01104cc0 	call	801104cc <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
80114138:	e03ff915 	stw	zero,-28(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8011413c:	d0a06017 	ldw	r2,-32384(gp)
80114140:	10800003 	ldbu	r2,0(r2)
80114144:	10c03fcc 	andi	r3,r2,255
80114148:	00a00574 	movhi	r2,32789
8011414c:	109f5404 	addi	r2,r2,32080
80114150:	18c7883a 	add	r3,r3,r3
80114154:	18c7883a 	add	r3,r3,r3
80114158:	10c5883a 	add	r2,r2,r3
8011415c:	10800017 	ldw	r2,0(r2)
80114160:	e0fffd04 	addi	r3,fp,-12
80114164:	180d883a 	mov	r6,r3
80114168:	000b883a 	mov	r5,zero
8011416c:	1009883a 	mov	r4,r2
80114170:	01390040 	call	80139004 <OSQPend>
80114174:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
80114178:	e0bffd03 	ldbu	r2,-12(fp)
8011417c:	10803fcc 	andi	r2,r2,255
80114180:	1001791e 	bne	r2,zero,80114768 <vFeeTask3+0x10e4>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
80114184:	e0bffe83 	ldbu	r2,-6(fp)
80114188:	10803fcc 	andi	r2,r2,255
8011418c:	108023d8 	cmpnei	r2,r2,143
80114190:	1000481e 	bne	r2,zero,801142b4 <vFeeTask3+0xc30>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
80114194:	e0fff503 	ldbu	r3,-44(fp)
80114198:	00a005b4 	movhi	r2,32790
8011419c:	10ad6e04 	addi	r2,r2,-19016
801141a0:	180690fa 	slli	r3,r3,3
801141a4:	10c5883a 	add	r2,r2,r3
801141a8:	10800017 	ldw	r2,0(r2)
801141ac:	e0fffd04 	addi	r3,fp,-12
801141b0:	180d883a 	mov	r6,r3
801141b4:	000b883a 	mov	r5,zero
801141b8:	1009883a 	mov	r4,r2
801141bc:	0137ef00 	call	80137ef0 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
801141c0:	e0bffd03 	ldbu	r2,-12(fp)
801141c4:	10803fcc 	andi	r2,r2,255
801141c8:	10001b1e 	bne	r2,zero,80114238 <vFeeTask3+0xbb4>
	                    	pxNFee->xControl.bDMALocked = TRUE;
801141cc:	d0a06017 	ldw	r2,-32384(gp)
801141d0:	00c00044 	movi	r3,1
801141d4:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee, ucIterationSide );
801141d8:	e0fff503 	ldbu	r3,-44(fp)
801141dc:	d0a06017 	ldw	r2,-32384(gp)
801141e0:	10800003 	ldbu	r2,0(r2)
801141e4:	11003fcc 	andi	r4,r2,255
801141e8:	d1606017 	ldw	r5,-32384(gp)
801141ec:	d0a05f03 	ldbu	r2,-32388(gp)
801141f0:	10803fcc 	andi	r2,r2,255
801141f4:	d8800015 	stw	r2,0(sp)
801141f8:	280f883a 	mov	r7,r5
801141fc:	200d883a 	mov	r6,r4
80114200:	180b883a 	mov	r5,r3
80114204:	e13ff617 	ldw	r4,-40(fp)
80114208:	01106b80 	call	801106b8 <bPrepareDoubleBuffer>
8011420c:	e0bff915 	stw	r2,-28(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
80114210:	e0fff503 	ldbu	r3,-44(fp)
80114214:	00a005b4 	movhi	r2,32790
80114218:	10ad6e04 	addi	r2,r2,-19016
8011421c:	180690fa 	slli	r3,r3,3
80114220:	10c5883a 	add	r2,r2,r3
80114224:	10800017 	ldw	r2,0(r2)
80114228:	1009883a 	mov	r4,r2
8011422c:	01384940 	call	80138494 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
80114230:	d0a06017 	ldw	r2,-32384(gp)
80114234:	10002215 	stw	zero,136(r2)

						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
80114238:	d0a06017 	ldw	r2,-32384(gp)
8011423c:	10800003 	ldbu	r2,0(r2)
80114240:	10803fcc 	andi	r2,r2,255
80114244:	100d883a 	mov	r6,r2
80114248:	000b883a 	mov	r5,zero
8011424c:	01002044 	movi	r4,129
80114250:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
80114254:	e0bff917 	ldw	r2,-28(fp)
80114258:	10800058 	cmpnei	r2,r2,1
8011425c:	1001421e 	bne	r2,zero,80114768 <vFeeTask3+0x10e4>
							if (pxNFee->xControl.bWatingSync==TRUE) {
80114260:	d0a06017 	ldw	r2,-32384(gp)
80114264:	10802817 	ldw	r2,160(r2)
80114268:	10800058 	cmpnei	r2,r2,1
8011426c:	1000071e 	bne	r2,zero,8011428c <vFeeTask3+0xc08>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
80114270:	d0a06017 	ldw	r2,-32384(gp)
80114274:	00c001c4 	movi	r3,7
80114278:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8011427c:	d0a06017 	ldw	r2,-32384(gp)
80114280:	00c00304 	movi	r3,12
80114284:	10c02c15 	stw	r3,176(r2)
80114288:	00000606 	br	801142a4 <vFeeTask3+0xc20>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8011428c:	d0a06017 	ldw	r2,-32384(gp)
80114290:	00c001c4 	movi	r3,7
80114294:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
80114298:	d0a06017 	ldw	r2,-32384(gp)
8011429c:	00c001c4 	movi	r3,7
801142a0:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
801142a4:	d0a06117 	ldw	r2,-32380(gp)
801142a8:	10800044 	addi	r2,r2,1
801142ac:	d0a06115 	stw	r2,-32380(gp)
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
801142b0:	00012d06 	br	80114768 <vFeeTask3+0x10e4>
								fprintf(fp,"\nNFEE-%hu Task: Could not prepare the double buffer\n", pxNFee->ucId);
							}
							#endif
						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
801142b4:	d0a06017 	ldw	r2,-32384(gp)
801142b8:	e0fffe17 	ldw	r3,-8(fp)
801142bc:	180b883a 	mov	r5,r3
801142c0:	1009883a 	mov	r4,r2
801142c4:	010f8380 	call	8010f838 <vQCmdFEEinFullPattern>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
801142c8:	00012706 	br	80114768 <vFeeTask3+0x10e4>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
801142cc:	e03ffa15 	stw	zero,-24(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
801142d0:	d0a06017 	ldw	r2,-32384(gp)
801142d4:	10804804 	addi	r2,r2,288
801142d8:	1009883a 	mov	r4,r2
801142dc:	01088b00 	call	801088b0 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
801142e0:	d0a06017 	ldw	r2,-32384(gp)
801142e4:	00c00084 	movi	r3,2
801142e8:	10c06b15 	stw	r3,428(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
801142ec:	d0a06017 	ldw	r2,-32384(gp)
801142f0:	10804804 	addi	r2,r2,288
801142f4:	1009883a 	mov	r4,r2
801142f8:	010857c0 	call	8010857c <bRmapSetMemConfigArea>
				if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
				}
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
801142fc:	d0a06017 	ldw	r2,-32384(gp)
80114300:	10802e17 	ldw	r2,184(r2)
80114304:	d0a05f05 	stb	r2,-32388(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
80114308:	d0a06017 	ldw	r2,-32384(gp)
8011430c:	00c00044 	movi	r3,1
80114310:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
80114314:	d0a06017 	ldw	r2,-32384(gp)
80114318:	00c00104 	movi	r3,4
8011431c:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
80114320:	d0a06017 	ldw	r2,-32384(gp)
80114324:	00c00104 	movi	r3,4
80114328:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8011432c:	d0a06017 	ldw	r2,-32384(gp)
80114330:	00c00044 	movi	r3,1
80114334:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
80114338:	d0a06017 	ldw	r2,-32384(gp)
8011433c:	00c00044 	movi	r3,1
80114340:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
80114344:	d0a06017 	ldw	r2,-32384(gp)
80114348:	00c00044 	movi	r3,1
8011434c:	10c02115 	stw	r3,132(r2)
				//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				vSetDoubleBufferLeftSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80114350:	d0a06017 	ldw	r2,-32384(gp)
80114354:	10800043 	ldbu	r2,1(r2)
80114358:	10803fcc 	andi	r2,r2,255
8011435c:	100b883a 	mov	r5,r2
80114360:	01000404 	movi	r4,16
80114364:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
				vSetDoubleBufferRightSize( SDMA_MAX_BLOCKS, pxNFee->ucSPWId );
80114368:	d0a06017 	ldw	r2,-32384(gp)
8011436c:	10800043 	ldbu	r2,1(r2)
80114370:	10803fcc 	andi	r2,r2,255
80114374:	100b883a 	mov	r5,r2
80114378:	01000404 	movi	r4,16
8011437c:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				}*/
				break;
80114380:	0000fe06 	br	8011477c <vFeeTask3+0x10f8>

			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
80114384:	e03ffa15 	stw	zero,-24(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
80114388:	d0a06017 	ldw	r2,-32384(gp)
8011438c:	10800003 	ldbu	r2,0(r2)
80114390:	10c03fcc 	andi	r3,r2,255
80114394:	00a00574 	movhi	r2,32789
80114398:	109f5404 	addi	r2,r2,32080
8011439c:	18c7883a 	add	r3,r3,r3
801143a0:	18c7883a 	add	r3,r3,r3
801143a4:	10c5883a 	add	r2,r2,r3
801143a8:	10800017 	ldw	r2,0(r2)
801143ac:	e0fffd04 	addi	r3,fp,-12
801143b0:	180d883a 	mov	r6,r3
801143b4:	000b883a 	mov	r5,zero
801143b8:	1009883a 	mov	r4,r2
801143bc:	01390040 	call	80139004 <OSQPend>
801143c0:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
801143c4:	e0bffd03 	ldbu	r2,-12(fp)
801143c8:	10803fcc 	andi	r2,r2,255
801143cc:	1000e81e 	bne	r2,zero,80114770 <vFeeTask3+0x10ec>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
801143d0:	e0bffe83 	ldbu	r2,-6(fp)
801143d4:	10803fcc 	andi	r2,r2,255
801143d8:	108023d8 	cmpnei	r2,r2,143
801143dc:	1000861e 	bne	r2,zero,801145f8 <vFeeTask3+0xf74>

						/* Try to get the Mutex */
						OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
801143e0:	e0fff503 	ldbu	r3,-44(fp)
801143e4:	00a005b4 	movhi	r2,32790
801143e8:	10ad6e04 	addi	r2,r2,-19016
801143ec:	180690fa 	slli	r3,r3,3
801143f0:	10c5883a 	add	r2,r2,r3
801143f4:	10800017 	ldw	r2,0(r2)
801143f8:	e0fffd04 	addi	r3,fp,-12
801143fc:	180d883a 	mov	r6,r3
80114400:	000b883a 	mov	r5,zero
80114404:	1009883a 	mov	r4,r2
80114408:	0137ef00 	call	80137ef0 <OSMutexPend>
						if ( error_code == OS_ERR_NONE ) {
8011440c:	e0bffd03 	ldbu	r2,-12(fp)
80114410:	10803fcc 	andi	r2,r2,255
80114414:	1000d61e 	bne	r2,zero,80114770 <vFeeTask3+0x10ec>
							pxNFee->xControl.bDMALocked = TRUE;
80114418:	d0a06017 	ldw	r2,-32384(gp)
8011441c:	00c00044 	movi	r3,1
80114420:	10c02215 	stw	r3,136(r2)

							/* Is this the last block? */
							if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
80114424:	e0bff617 	ldw	r2,-40(fp)
80114428:	10800117 	ldw	r2,4(r2)
8011442c:	10c00404 	addi	r3,r2,16
80114430:	d0a06017 	ldw	r2,-32384(gp)
80114434:	10800417 	ldw	r2,16(r2)
80114438:	18801936 	bltu	r3,r2,801144a0 <vFeeTask3+0xe1c>

								/*Define the size of the data in the double buffer (need this to create the interrupt right)*/
								usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8011443c:	d0a06017 	ldw	r2,-32384(gp)
80114440:	10c00417 	ldw	r3,16(r2)
80114444:	e0bff617 	ldw	r2,-40(fp)
80114448:	10800117 	ldw	r2,4(r2)
8011444c:	1885c83a 	sub	r2,r3,r2
80114450:	e0bff815 	stw	r2,-32(fp)

								vSetDoubleBufferLeftSize( (unsigned char)usiLengthBlocks, pxNFee->ucSPWId );
80114454:	e0bff817 	ldw	r2,-32(fp)
80114458:	10c03fcc 	andi	r3,r2,255
8011445c:	d0a06017 	ldw	r2,-32384(gp)
80114460:	10800043 	ldbu	r2,1(r2)
80114464:	10803fcc 	andi	r2,r2,255
80114468:	100b883a 	mov	r5,r2
8011446c:	1809883a 	mov	r4,r3
80114470:	0110b740 	call	80110b74 <vSetDoubleBufferLeftSize>
								vSetDoubleBufferRightSize( (unsigned char)usiLengthBlocks, pxNFee->ucSPWId );
80114474:	e0bff817 	ldw	r2,-32(fp)
80114478:	10c03fcc 	andi	r3,r2,255
8011447c:	d0a06017 	ldw	r2,-32384(gp)
80114480:	10800043 	ldbu	r2,1(r2)
80114484:	10803fcc 	andi	r2,r2,255
80114488:	100b883a 	mov	r5,r2
8011448c:	1809883a 	mov	r4,r3
80114490:	0110a4c0 	call	80110a4c <vSetDoubleBufferRightSize>
								} else {
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
									bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
								}*/

								bFinal = TRUE;
80114494:	00800044 	movi	r2,1
80114498:	e0bffa15 	stw	r2,-24(fp)
8011449c:	00000206 	br	801144a8 <vFeeTask3+0xe24>

							} else {
								usiLengthBlocks = SDMA_MAX_BLOCKS;
801144a0:	00800404 	movi	r2,16
801144a4:	e0bff815 	stw	r2,-32(fp)
							}


							if ( ucMemUsing == 0  ) {
801144a8:	e0bff503 	ldbu	r2,-44(fp)
801144ac:	1000111e 	bne	r2,zero,801144f4 <vFeeTask3+0xe70>
								bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
801144b0:	e0bff617 	ldw	r2,-40(fp)
801144b4:	10800217 	ldw	r2,8(r2)
801144b8:	1011883a 	mov	r8,r2
801144bc:	e0bff817 	ldw	r2,-32(fp)
801144c0:	10ffffcc 	andi	r3,r2,65535
801144c4:	d0a05f03 	ldbu	r2,-32388(gp)
801144c8:	11003fcc 	andi	r4,r2,255
801144cc:	d0a06017 	ldw	r2,-32384(gp)
801144d0:	10800043 	ldbu	r2,1(r2)
801144d4:	10803fcc 	andi	r2,r2,255
801144d8:	100f883a 	mov	r7,r2
801144dc:	200d883a 	mov	r6,r4
801144e0:	180b883a 	mov	r5,r3
801144e4:	4009883a 	mov	r4,r8
801144e8:	0101fd00 	call	80101fd0 <bSdmaDmaM1Transfer>
801144ec:	e0bff915 	stw	r2,-28(fp)
801144f0:	00001006 	br	80114534 <vFeeTask3+0xeb0>
							} else {
								bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
801144f4:	e0bff617 	ldw	r2,-40(fp)
801144f8:	10800217 	ldw	r2,8(r2)
801144fc:	1011883a 	mov	r8,r2
80114500:	e0bff817 	ldw	r2,-32(fp)
80114504:	10ffffcc 	andi	r3,r2,65535
80114508:	d0a05f03 	ldbu	r2,-32388(gp)
8011450c:	11003fcc 	andi	r4,r2,255
80114510:	d0a06017 	ldw	r2,-32384(gp)
80114514:	10800043 	ldbu	r2,1(r2)
80114518:	10803fcc 	andi	r2,r2,255
8011451c:	100f883a 	mov	r7,r2
80114520:	200d883a 	mov	r6,r4
80114524:	180b883a 	mov	r5,r3
80114528:	4009883a 	mov	r4,r8
8011452c:	01024540 	call	80102454 <bSdmaDmaM2Transfer>
80114530:	e0bff915 	stw	r2,-28(fp)
							}

							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
80114534:	e0fff503 	ldbu	r3,-44(fp)
80114538:	00a005b4 	movhi	r2,32790
8011453c:	10ad6e04 	addi	r2,r2,-19016
80114540:	180690fa 	slli	r3,r3,3
80114544:	10c5883a 	add	r2,r2,r3
80114548:	10800017 	ldw	r2,0(r2)
8011454c:	1009883a 	mov	r4,r2
80114550:	01384940 	call	80138494 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
80114554:	d0a06017 	ldw	r2,-32384(gp)
80114558:	10002215 	stw	zero,136(r2)

							if ( bDmaReturn == TRUE ) {
8011455c:	e0bff917 	ldw	r2,-28(fp)
80114560:	10800058 	cmpnei	r2,r2,1
80114564:	10000e1e 	bne	r2,zero,801145a0 <vFeeTask3+0xf1c>
								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
80114568:	e0bff617 	ldw	r2,-40(fp)
8011456c:	10c00217 	ldw	r3,8(r2)
80114570:	e0bff817 	ldw	r2,-32(fp)
80114574:	10802224 	muli	r2,r2,136
80114578:	1887883a 	add	r3,r3,r2
8011457c:	e0bff617 	ldw	r2,-40(fp)
80114580:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += usiLengthBlocks;
80114584:	e0bff617 	ldw	r2,-40(fp)
80114588:	10c00117 	ldw	r3,4(r2)
8011458c:	e0bff817 	ldw	r2,-32(fp)
80114590:	1887883a 	add	r3,r3,r2
80114594:	e0bff617 	ldw	r2,-40(fp)
80114598:	10c00115 	stw	r3,4(r2)
8011459c:	00000806 	br	801145c0 <vFeeTask3+0xf3c>
							} else {
								bFinal = FALSE;
801145a0:	e03ffa15 	stw	zero,-24(fp)

								/* Send the request for use the DMA, but to front of the QUEUE */
								bSendRequestNFeeCtrl_Front( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
801145a4:	d0a06017 	ldw	r2,-32384(gp)
801145a8:	10800003 	ldbu	r2,0(r2)
801145ac:	10803fcc 	andi	r2,r2,255
801145b0:	100d883a 	mov	r6,r2
801145b4:	000b883a 	mov	r5,zero
801145b8:	01002004 	movi	r4,128
801145bc:	01105700 	call	80110570 <bSendRequestNFeeCtrl_Front>
							}

							/* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
801145c0:	d0a06017 	ldw	r2,-32384(gp)
801145c4:	10800003 	ldbu	r2,0(r2)
801145c8:	10803fcc 	andi	r2,r2,255
801145cc:	100d883a 	mov	r6,r2
801145d0:	000b883a 	mov	r5,zero
801145d4:	01002044 	movi	r4,129
801145d8:	01106140 	call	80110614 <bSendGiveBackNFeeCtrl>

							if ( bFinal == TRUE ) {
801145dc:	e0bffa17 	ldw	r2,-24(fp)
801145e0:	10800058 	cmpnei	r2,r2,1
801145e4:	1000621e 	bne	r2,zero,80114770 <vFeeTask3+0x10ec>
								pxNFee->xControl.eMode = sEndTransmission;
801145e8:	d0a06017 	ldw	r2,-32384(gp)
801145ec:	00c002c4 	movi	r3,11
801145f0:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
801145f4:	00005e06 	br	80114770 <vFeeTask3+0x10ec>
								//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
							}

						}
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
801145f8:	d0a06017 	ldw	r2,-32384(gp)
801145fc:	e0fffe17 	ldw	r3,-8(fp)
80114600:	180b883a 	mov	r5,r3
80114604:	1009883a 	mov	r4,r2
80114608:	010f8380 	call	8010f838 <vQCmdFEEinFullPattern>

						if ( pxNFee->xControl.bWatingSync == FALSE ) {
8011460c:	d0a06017 	ldw	r2,-32384(gp)
80114610:	10802817 	ldw	r2,160(r2)
80114614:	1000561e 	bne	r2,zero,80114770 <vFeeTask3+0x10ec>
							pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
80114618:	d0a06017 	ldw	r2,-32384(gp)
8011461c:	d0e06017 	ldw	r3,-32384(gp)
80114620:	18c02d17 	ldw	r3,180(r3)
80114624:	10c02c15 	stw	r3,176(r2)
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80114628:	00005106 	br	80114770 <vFeeTask3+0x10ec>
					fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu\n", pxNFee->ucId, ucReadout);
					fprintf(fp,"Memory used: %u\n", ucMemUsing);
				}
				#endif

				pxNFee->xControl.bWatingSync = TRUE;
8011462c:	d0a06017 	ldw	r2,-32384(gp)
80114630:	00c00044 	movi	r3,1
80114634:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
80114638:	d0a06017 	ldw	r2,-32384(gp)
8011463c:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bOneShot == FALSE ) {
80114640:	00a005b4 	movhi	r2,32790
80114644:	10ba3604 	addi	r2,r2,-5928
80114648:	10800917 	ldw	r2,36(r2)
8011464c:	10001f1e 	bne	r2,zero,801146cc <vFeeTask3+0x1048>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
80114650:	d0a06017 	ldw	r2,-32384(gp)
80114654:	10802d17 	ldw	r2,180(r2)
80114658:	10800198 	cmpnei	r2,r2,6
8011465c:	1000141e 	bne	r2,zero,801146b0 <vFeeTask3+0x102c>

						bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
80114660:	d0a06017 	ldw	r2,-32384(gp)
80114664:	10803304 	addi	r2,r2,204
80114668:	1009883a 	mov	r4,r2
8011466c:	0102eec0 	call	80102eec <bDpktGetPacketConfig>
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
80114670:	d0a06017 	ldw	r2,-32384(gp)
80114674:	e0fff703 	ldbu	r3,-36(fp)
80114678:	10c036c5 	stb	r3,219(r2)
						pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktStandBy;
8011467c:	d0a06017 	ldw	r2,-32384(gp)
80114680:	10003685 	stb	zero,218(r2)
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
80114684:	d0a06017 	ldw	r2,-32384(gp)
80114688:	10803304 	addi	r2,r2,204
8011468c:	1009883a 	mov	r4,r2
80114690:	0102c480 	call	80102c48 <bDpktSetPacketConfig>

						pxNFee->xControl.eMode =  sFeeWaitingSync;
80114694:	d0a06017 	ldw	r2,-32384(gp)
80114698:	00c00304 	movi	r3,12
8011469c:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
801146a0:	d0a06017 	ldw	r2,-32384(gp)
801146a4:	00c00184 	movi	r3,6
801146a8:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
801146ac:	00003306 	br	8011477c <vFeeTask3+0x10f8>
						bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

						pxNFee->xControl.eMode =  sFeeWaitingSync;
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
801146b0:	d0a06017 	ldw	r2,-32384(gp)
801146b4:	00c00284 	movi	r3,10
801146b8:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
801146bc:	d0a06017 	ldw	r2,-32384(gp)
801146c0:	00c00304 	movi	r3,12
801146c4:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				}

				break;
801146c8:	00002c06 	br	8011477c <vFeeTask3+0x10f8>
						pxNFee->xControl.eMode =  sNextPatternIteration;
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
					}

				} else {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
801146cc:	d0a06017 	ldw	r2,-32384(gp)
801146d0:	00c00304 	movi	r3,12
801146d4:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
801146d8:	d0a06017 	ldw	r2,-32384(gp)
801146dc:	00c00184 	movi	r3,6
801146e0:	10c02d15 	stw	r3,180(r2)
				}

				break;
801146e4:	00002506 	br	8011477c <vFeeTask3+0x10f8>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
				}
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
801146e8:	d0a06017 	ldw	r2,-32384(gp)
801146ec:	10800003 	ldbu	r2,0(r2)
801146f0:	10c03fcc 	andi	r3,r2,255
801146f4:	00a00574 	movhi	r2,32789
801146f8:	109f5404 	addi	r2,r2,32080
801146fc:	18c7883a 	add	r3,r3,r3
80114700:	18c7883a 	add	r3,r3,r3
80114704:	10c5883a 	add	r2,r2,r3
80114708:	10800017 	ldw	r2,0(r2)
8011470c:	e0fffd04 	addi	r3,fp,-12
80114710:	180d883a 	mov	r6,r3
80114714:	000b883a 	mov	r5,zero
80114718:	1009883a 	mov	r4,r2
8011471c:	01390040 	call	80139004 <OSQPend>
80114720:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
80114724:	e0bffd03 	ldbu	r2,-12(fp)
80114728:	10803fcc 	andi	r2,r2,255
8011472c:	1000121e 	bne	r2,zero,80114778 <vFeeTask3+0x10f4>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					}
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
80114730:	d0a06017 	ldw	r2,-32384(gp)
80114734:	e0fffe17 	ldw	r3,-8(fp)
80114738:	180b883a 	mov	r5,r3
8011473c:	1009883a 	mov	r4,r2
80114740:	010f3980 	call	8010f398 <vQCmdFEEinWaitingSync>
				}

				break;
80114744:	00000c06 	br	80114778 <vFeeTask3+0x10f4>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
80114748:	d0a06017 	ldw	r2,-32384(gp)
8011474c:	00c00144 	movi	r3,5
80114750:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
80114754:	00000906 	br	8011477c <vFeeTask3+0x10f8>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80114758:	0001883a 	nop
8011475c:	003bd206 	br	801136a8 <__reset+0xfa0f36a8>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80114760:	0001883a 	nop
80114764:	003bd006 	br	801136a8 <__reset+0xfa0f36a8>
					if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}
				break;
80114768:	0001883a 	nop
8011476c:	003bce06 	br	801136a8 <__reset+0xfa0f36a8>
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					}
					#endif
				}

				break;
80114770:	0001883a 	nop
80114774:	003bcc06 	br	801136a8 <__reset+0xfa0f36a8>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
80114778:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				}
				#endif
				break;
		}
	}
8011477c:	003bca06 	br	801136a8 <__reset+0xfa0f36a8>

80114780 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
80114780:	defff604 	addi	sp,sp,-40
80114784:	de00012e 	bgeu	sp,et,8011478c <vInAckHandlerTaskV2+0xc>
80114788:	003b68fa 	trap	3
8011478c:	dfc00915 	stw	ra,36(sp)
80114790:	df000815 	stw	fp,32(sp)
80114794:	df000804 	addi	fp,sp,32
80114798:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8011479c:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
801147a0:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
801147a4:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
801147a8:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
801147ac:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
801147b0:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
801147b4:	e03ffa45 	stb	zero,-23(fp)
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
        debug(fp,"In Ack Handler Task. (Task on)\n");
    }
    #endif

	eReceiverAckState = sRAConfiguring;
801147b8:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
801147bc:	e0bff917 	ldw	r2,-28(fp)
801147c0:	10c00060 	cmpeqi	r3,r2,1
801147c4:	1800071e 	bne	r3,zero,801147e4 <vInAckHandlerTaskV2+0x64>
801147c8:	0080032e 	bgeu	zero,r2,801147d8 <vInAckHandlerTaskV2+0x58>
801147cc:	108000a0 	cmpeqi	r2,r2,2
801147d0:	10004a1e 	bne	r2,zero,801148fc <vInAckHandlerTaskV2+0x17c>
801147d4:	0000ac06 	br	80114a88 <vInAckHandlerTaskV2+0x308>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
801147d8:	00800044 	movi	r2,1
801147dc:	e0bff915 	stw	r2,-28(fp)
				break;
801147e0:	0000ac06 	br	80114a94 <vInAckHandlerTaskV2+0x314>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
801147e4:	00800044 	movi	r2,1
801147e8:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
801147ec:	d0a07017 	ldw	r2,-32320(gp)
801147f0:	e0fffe04 	addi	r3,fp,-8
801147f4:	180d883a 	mov	r6,r3
801147f8:	000b883a 	mov	r5,zero
801147fc:	1009883a 	mov	r4,r2
80114800:	0139efc0 	call	80139efc <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
80114804:	e0bffe03 	ldbu	r2,-8(fp)
80114808:	10803fcc 	andi	r2,r2,255
8011480c:	1000391e 	bne	r2,zero,801148f4 <vInAckHandlerTaskV2+0x174>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
80114810:	d0a06f17 	ldw	r2,-32324(gp)
80114814:	e0fffe04 	addi	r3,fp,-8
80114818:	180d883a 	mov	r6,r3
8011481c:	000b883a 	mov	r5,zero
80114820:	1009883a 	mov	r4,r2
80114824:	0137ef00 	call	80137ef0 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
80114828:	e0bffe03 	ldbu	r2,-8(fp)
8011482c:	10803fcc 	andi	r2,r2,255
80114830:	10002b1e 	bne	r2,zero,801148e0 <vInAckHandlerTaskV2+0x160>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
80114834:	e03ffa45 	stb	zero,-23(fp)
80114838:	00002206 	br	801148c4 <vInAckHandlerTaskV2+0x144>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8011483c:	e0fffa43 	ldbu	r3,-23(fp)
80114840:	00a005b4 	movhi	r2,32790
80114844:	10a36804 	addi	r2,r2,-29280
80114848:	18c7883a 	add	r3,r3,r3
8011484c:	18c7883a 	add	r3,r3,r3
80114850:	10c5883a 	add	r2,r2,r3
80114854:	10800003 	ldbu	r2,0(r2)
80114858:	10803fcc 	andi	r2,r2,255
8011485c:	1080201c 	xori	r2,r2,128
80114860:	10bfe004 	addi	r2,r2,-128
80114864:	10001426 	beq	r2,zero,801148b8 <vInAckHandlerTaskV2+0x138>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
80114868:	e0fffa43 	ldbu	r3,-23(fp)
8011486c:	00a005b4 	movhi	r2,32790
80114870:	10a36804 	addi	r2,r2,-29280
80114874:	18c7883a 	add	r3,r3,r3
80114878:	18c7883a 	add	r3,r3,r3
8011487c:	10c5883a 	add	r2,r2,r3
80114880:	10c0000b 	ldhu	r3,0(r2)
80114884:	d0e0630d 	sth	r3,-32372(gp)
80114888:	1080008b 	ldhu	r2,2(r2)
8011488c:	d0a0638d 	sth	r2,-32370(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
80114890:	e0fffa43 	ldbu	r3,-23(fp)
80114894:	00a005b4 	movhi	r2,32790
80114898:	10a36804 	addi	r2,r2,-29280
8011489c:	18c7883a 	add	r3,r3,r3
801148a0:	18c7883a 	add	r3,r3,r3
801148a4:	10c5883a 	add	r2,r2,r3
801148a8:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
801148ac:	00800084 	movi	r2,2
801148b0:	e0bff915 	stw	r2,-28(fp)
                                break;                                
801148b4:	00000606 	br	801148d0 <vInAckHandlerTaskV2+0x150>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
801148b8:	e0bffa43 	ldbu	r2,-23(fp)
801148bc:	10800044 	addi	r2,r2,1
801148c0:	e0bffa45 	stb	r2,-23(fp)
801148c4:	e0bffa43 	ldbu	r2,-23(fp)
801148c8:	108001b0 	cmpltui	r2,r2,6
801148cc:	103fdb1e 	bne	r2,zero,8011483c <__reset+0xfa0f483c>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
801148d0:	d0a06f17 	ldw	r2,-32324(gp)
801148d4:	1009883a 	mov	r4,r2
801148d8:	01384940 	call	80138494 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
801148dc:	00006d06 	br	80114a94 <vInAckHandlerTaskV2+0x314>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
801148e0:	d0a07017 	ldw	r2,-32320(gp)
801148e4:	1009883a 	mov	r4,r2
801148e8:	013a2840 	call	8013a284 <OSSemPost>
                    	vFailGetMutexReceiverTask();
801148ec:	011d0500 	call	8011d050 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
801148f0:	00006806 	br	80114a94 <vInAckHandlerTaskV2+0x314>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
801148f4:	011d0280 	call	8011d028 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
801148f8:	00006606 	br	80114a94 <vInAckHandlerTaskV2+0x314>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
801148fc:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
80114900:	d0a07283 	ldbu	r2,-32310(gp)
80114904:	10803fcc 	andi	r2,r2,255
80114908:	10800218 	cmpnei	r2,r2,8
8011490c:	1000021e 	bne	r2,zero,80114918 <vInAckHandlerTaskV2+0x198>
80114910:	00c00104 	movi	r3,4
80114914:	00000106 	br	8011491c <vInAckHandlerTaskV2+0x19c>
80114918:	0007883a 	mov	r3,zero
8011491c:	d0a07e03 	ldbu	r2,-32264(gp)
80114920:	10803fcc 	andi	r2,r2,255
80114924:	10800218 	cmpnei	r2,r2,8
80114928:	1000021e 	bne	r2,zero,80114934 <vInAckHandlerTaskV2+0x1b4>
8011492c:	00800084 	movi	r2,2
80114930:	00000106 	br	80114938 <vInAckHandlerTaskV2+0x1b8>
80114934:	0005883a 	mov	r2,zero
80114938:	1884b03a 	or	r2,r3,r2
8011493c:	1007883a 	mov	r3,r2
80114940:	d0a07e43 	ldbu	r2,-32263(gp)
80114944:	10803fcc 	andi	r2,r2,255
80114948:	108001a0 	cmpeqi	r2,r2,6
8011494c:	1884b03a 	or	r2,r3,r2
80114950:	1007883a 	mov	r3,r2
80114954:	e0bffa83 	ldbu	r2,-22(fp)
80114958:	1884b03a 	or	r2,r3,r2
8011495c:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
80114960:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
80114964:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
80114968:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8011496c:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
80114970:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
80114974:	e0bffa03 	ldbu	r2,-24(fp)
80114978:	10800044 	addi	r2,r2,1
8011497c:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
80114980:	e0bffa83 	ldbu	r2,-22(fp)
80114984:	1080004c 	andi	r2,r2,1
80114988:	10803fcc 	andi	r2,r2,255
8011498c:	1000061e 	bne	r2,zero,801149a8 <vInAckHandlerTaskV2+0x228>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
80114990:	e0bffd04 	addi	r2,fp,-12
80114994:	100b883a 	mov	r5,r2
80114998:	d1206304 	addi	r4,gp,-32372
8011499c:	0114a980 	call	80114a98 <bCheckInAck128>
801149a0:	e0bff815 	stw	r2,-32(fp)
801149a4:	00000206 	br	801149b0 <vInAckHandlerTaskV2+0x230>
                    else
                        bFinished128 = TRUE;
801149a8:	00800044 	movi	r2,1
801149ac:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
801149b0:	e0bffa83 	ldbu	r2,-22(fp)
801149b4:	1080008c 	andi	r2,r2,2
801149b8:	10803fcc 	andi	r2,r2,255
801149bc:	1000081e 	bne	r2,zero,801149e0 <vInAckHandlerTaskV2+0x260>
801149c0:	e0bff817 	ldw	r2,-32(fp)
801149c4:	1000061e 	bne	r2,zero,801149e0 <vInAckHandlerTaskV2+0x260>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
801149c8:	e0bffc04 	addi	r2,fp,-16
801149cc:	100b883a 	mov	r5,r2
801149d0:	d1206304 	addi	r4,gp,-32372
801149d4:	0114be00 	call	80114be0 <bCheckInAck64>
801149d8:	e0bff815 	stw	r2,-32(fp)
801149dc:	00000206 	br	801149e8 <vInAckHandlerTaskV2+0x268>
                    else
                        bFinished64 = TRUE;
801149e0:	00800044 	movi	r2,1
801149e4:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
801149e8:	e0bffa83 	ldbu	r2,-22(fp)
801149ec:	1080010c 	andi	r2,r2,4
801149f0:	10803fcc 	andi	r2,r2,255
801149f4:	1000081e 	bne	r2,zero,80114a18 <vInAckHandlerTaskV2+0x298>
801149f8:	e0bff817 	ldw	r2,-32(fp)
801149fc:	1000061e 	bne	r2,zero,80114a18 <vInAckHandlerTaskV2+0x298>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
80114a00:	e0bffb04 	addi	r2,fp,-20
80114a04:	100b883a 	mov	r5,r2
80114a08:	d1206304 	addi	r4,gp,-32372
80114a0c:	0114d2c0 	call	80114d2c <bCheckInAck32>
80114a10:	e0bff815 	stw	r2,-32(fp)
80114a14:	00000206 	br	80114a20 <vInAckHandlerTaskV2+0x2a0>
                    else
                        bFinished32 = TRUE;
80114a18:	00800044 	movi	r2,1
80114a1c:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
80114a20:	e0bffa03 	ldbu	r2,-24(fp)
80114a24:	10c00044 	addi	r3,r2,1
80114a28:	e0fffa05 	stb	r3,-24(fp)
80114a2c:	10803fcc 	andi	r2,r2,255
80114a30:	10800ca8 	cmpgeui	r2,r2,50
80114a34:	10000e1e 	bne	r2,zero,80114a70 <vInAckHandlerTaskV2+0x2f0>
80114a38:	e0bff817 	ldw	r2,-32(fp)
80114a3c:	10000c1e 	bne	r2,zero,80114a70 <vInAckHandlerTaskV2+0x2f0>
80114a40:	e0bffb17 	ldw	r2,-20(fp)
80114a44:	1005003a 	cmpeq	r2,r2,zero
80114a48:	1007883a 	mov	r3,r2
80114a4c:	e0bffc17 	ldw	r2,-16(fp)
80114a50:	1005003a 	cmpeq	r2,r2,zero
80114a54:	1884b03a 	or	r2,r3,r2
80114a58:	10c03fcc 	andi	r3,r2,255
80114a5c:	e0bffd17 	ldw	r2,-12(fp)
80114a60:	1005003a 	cmpeq	r2,r2,zero
80114a64:	10803fcc 	andi	r2,r2,255
80114a68:	1884b03a 	or	r2,r3,r2
80114a6c:	103fc11e 	bne	r2,zero,80114974 <__reset+0xfa0f4974>
                
                if (bFound == FALSE) {
80114a70:	e0bff817 	ldw	r2,-32(fp)
80114a74:	1000011e 	bne	r2,zero,80114a7c <vInAckHandlerTaskV2+0x2fc>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
80114a78:	011d2640 	call	8011d264 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
80114a7c:	00800044 	movi	r2,1
80114a80:	e0bff915 	stw	r2,-28(fp)
				break;
80114a84:	00000306 	br	80114a94 <vInAckHandlerTaskV2+0x314>
                #if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly) {
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
				}
	            #endif
                eReceiverAckState = sRAGettingACK;
80114a88:	00800044 	movi	r2,1
80114a8c:	e0bff915 	stw	r2,-28(fp)
				break;
80114a90:	0001883a 	nop
		}
	}
80114a94:	003f4906 	br	801147bc <__reset+0xfa0f47bc>

80114a98 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
80114a98:	defffa04 	addi	sp,sp,-24
80114a9c:	de00012e 	bgeu	sp,et,80114aa4 <bCheckInAck128+0xc>
80114aa0:	003b68fa 	trap	3
80114aa4:	dfc00515 	stw	ra,20(sp)
80114aa8:	df000415 	stw	fp,16(sp)
80114aac:	df000404 	addi	fp,sp,16
80114ab0:	e13ffe15 	stw	r4,-8(fp)
80114ab4:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
80114ab8:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
80114abc:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
80114ac0:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
80114ac4:	e0bfff17 	ldw	r2,-4(fp)
80114ac8:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
80114acc:	d0a07717 	ldw	r2,-32292(gp)
80114ad0:	e0fffd44 	addi	r3,fp,-11
80114ad4:	180d883a 	mov	r6,r3
80114ad8:	01400144 	movi	r5,5
80114adc:	1009883a 	mov	r4,r2
80114ae0:	0137ef00 	call	80137ef0 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
80114ae4:	e0bffd43 	ldbu	r2,-11(fp)
80114ae8:	10803fcc 	andi	r2,r2,255
80114aec:	10000226 	beq	r2,zero,80114af8 <bCheckInAck128+0x60>
        return bFound;
80114af0:	e0bffc17 	ldw	r2,-16(fp)
80114af4:	00003506 	br	80114bcc <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
80114af8:	e03ffd05 	stb	zero,-12(fp)
80114afc:	00002706 	br	80114b9c <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
80114b00:	e0fffd03 	ldbu	r3,-12(fp)
80114b04:	00a00574 	movhi	r2,32789
80114b08:	109a6204 	addi	r2,r2,27016
80114b0c:	18c02324 	muli	r3,r3,140
80114b10:	10c5883a 	add	r2,r2,r3
80114b14:	10802104 	addi	r2,r2,132
80114b18:	10c0000b 	ldhu	r3,0(r2)
80114b1c:	e0bffe17 	ldw	r2,-8(fp)
80114b20:	1080008b 	ldhu	r2,2(r2)
80114b24:	18ffffcc 	andi	r3,r3,65535
80114b28:	10bfffcc 	andi	r2,r2,65535
80114b2c:	1880181e 	bne	r3,r2,80114b90 <bCheckInAck128+0xf8>
            bFound = TRUE;
80114b30:	00800044 	movi	r2,1
80114b34:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
80114b38:	e0fffd03 	ldbu	r3,-12(fp)
80114b3c:	00a00574 	movhi	r2,32789
80114b40:	109a3c04 	addi	r2,r2,26864
80114b44:	18c7883a 	add	r3,r3,r3
80114b48:	18c7883a 	add	r3,r3,r3
80114b4c:	10c5883a 	add	r2,r2,r3
80114b50:	10000015 	stw	zero,0(r2)
            SemCount128++;
80114b54:	d0a07e43 	ldbu	r2,-32263(gp)
80114b58:	10800044 	addi	r2,r2,1
80114b5c:	d0a07e45 	stb	r2,-32263(gp)
            error_code = OSSemPost(xSemCountBuffer128);
80114b60:	d0a06d17 	ldw	r2,-32332(gp)
80114b64:	1009883a 	mov	r4,r2
80114b68:	013a2840 	call	8013a284 <OSSemPost>
80114b6c:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
80114b70:	e0bffd43 	ldbu	r2,-11(fp)
80114b74:	10803fcc 	andi	r2,r2,255
80114b78:	10000c26 	beq	r2,zero,80114bac <bCheckInAck128+0x114>
                SemCount128--;
80114b7c:	d0a07e43 	ldbu	r2,-32263(gp)
80114b80:	10bfffc4 	addi	r2,r2,-1
80114b84:	d0a07e45 	stb	r2,-32263(gp)
                vFailSetCountSemaphorexBuffer128();
80114b88:	011d1c40 	call	8011d1c4 <vFailSetCountSemaphorexBuffer128>
            }
            break;
80114b8c:	00000706 	br	80114bac <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
80114b90:	e0bffd03 	ldbu	r2,-12(fp)
80114b94:	10800044 	addi	r2,r2,1
80114b98:	e0bffd05 	stb	r2,-12(fp)
80114b9c:	e0bffd03 	ldbu	r2,-12(fp)
80114ba0:	108001b0 	cmpltui	r2,r2,6
80114ba4:	103fd61e 	bne	r2,zero,80114b00 <__reset+0xfa0f4b00>
80114ba8:	00000106 	br	80114bb0 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
80114bac:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
80114bb0:	d0a07717 	ldw	r2,-32292(gp)
80114bb4:	1009883a 	mov	r4,r2
80114bb8:	01384940 	call	80138494 <OSMutexPost>
    (*bFinished) = TRUE;
80114bbc:	e0bfff17 	ldw	r2,-4(fp)
80114bc0:	00c00044 	movi	r3,1
80114bc4:	10c00015 	stw	r3,0(r2)

    return bFound;
80114bc8:	e0bffc17 	ldw	r2,-16(fp)
}
80114bcc:	e037883a 	mov	sp,fp
80114bd0:	dfc00117 	ldw	ra,4(sp)
80114bd4:	df000017 	ldw	fp,0(sp)
80114bd8:	dec00204 	addi	sp,sp,8
80114bdc:	f800283a 	ret

80114be0 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
80114be0:	defffa04 	addi	sp,sp,-24
80114be4:	de00012e 	bgeu	sp,et,80114bec <bCheckInAck64+0xc>
80114be8:	003b68fa 	trap	3
80114bec:	dfc00515 	stw	ra,20(sp)
80114bf0:	df000415 	stw	fp,16(sp)
80114bf4:	df000404 	addi	fp,sp,16
80114bf8:	e13ffe15 	stw	r4,-8(fp)
80114bfc:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
80114c00:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
80114c04:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
80114c08:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
80114c0c:	e0bfff17 	ldw	r2,-4(fp)
80114c10:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
80114c14:	d0a07a17 	ldw	r2,-32280(gp)
80114c18:	e0fffd44 	addi	r3,fp,-11
80114c1c:	180d883a 	mov	r6,r3
80114c20:	01400044 	movi	r5,1
80114c24:	1009883a 	mov	r4,r2
80114c28:	0137ef00 	call	80137ef0 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
80114c2c:	e0bffd43 	ldbu	r2,-11(fp)
80114c30:	10803fcc 	andi	r2,r2,255
80114c34:	10000226 	beq	r2,zero,80114c40 <bCheckInAck64+0x60>
        return bFound;
80114c38:	e0bffc17 	ldw	r2,-16(fp)
80114c3c:	00003606 	br	80114d18 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
80114c40:	e03ffd05 	stb	zero,-12(fp)
80114c44:	00002806 	br	80114ce8 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
80114c48:	e0fffd03 	ldbu	r3,-12(fp)
80114c4c:	00a00574 	movhi	r2,32789
80114c50:	10b3f504 	addi	r2,r2,-12332
80114c54:	18c01324 	muli	r3,r3,76
80114c58:	10c5883a 	add	r2,r2,r3
80114c5c:	10801104 	addi	r2,r2,68
80114c60:	10c0000b 	ldhu	r3,0(r2)
80114c64:	e0bffe17 	ldw	r2,-8(fp)
80114c68:	1080008b 	ldhu	r2,2(r2)
80114c6c:	18ffffcc 	andi	r3,r3,65535
80114c70:	10bfffcc 	andi	r2,r2,65535
80114c74:	1880191e 	bne	r3,r2,80114cdc <bCheckInAck64+0xfc>
            bFound = TRUE;
80114c78:	00800044 	movi	r2,1
80114c7c:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
80114c80:	e0fffd03 	ldbu	r3,-12(fp)
80114c84:	00a00574 	movhi	r2,32789
80114c88:	109a3c04 	addi	r2,r2,26864
80114c8c:	18c00184 	addi	r3,r3,6
80114c90:	18c7883a 	add	r3,r3,r3
80114c94:	18c7883a 	add	r3,r3,r3
80114c98:	10c5883a 	add	r2,r2,r3
80114c9c:	10000015 	stw	zero,0(r2)
            SemCount64++;
80114ca0:	d0a07e03 	ldbu	r2,-32264(gp)
80114ca4:	10800044 	addi	r2,r2,1
80114ca8:	d0a07e05 	stb	r2,-32264(gp)
            error_code = OSSemPost(xSemCountBuffer64);
80114cac:	d0a06917 	ldw	r2,-32348(gp)
80114cb0:	1009883a 	mov	r4,r2
80114cb4:	013a2840 	call	8013a284 <OSSemPost>
80114cb8:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
80114cbc:	e0bffd43 	ldbu	r2,-11(fp)
80114cc0:	10803fcc 	andi	r2,r2,255
80114cc4:	10000c26 	beq	r2,zero,80114cf8 <bCheckInAck64+0x118>
                SemCount64--;
80114cc8:	d0a07e03 	ldbu	r2,-32264(gp)
80114ccc:	10bfffc4 	addi	r2,r2,-1
80114cd0:	d0a07e05 	stb	r2,-32264(gp)
                vFailSetCountSemaphorexBuffer64();
80114cd4:	011d19c0 	call	8011d19c <vFailSetCountSemaphorexBuffer64>
            }
            break;
80114cd8:	00000706 	br	80114cf8 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
80114cdc:	e0bffd03 	ldbu	r2,-12(fp)
80114ce0:	10800044 	addi	r2,r2,1
80114ce4:	e0bffd05 	stb	r2,-12(fp)
80114ce8:	e0bffd03 	ldbu	r2,-12(fp)
80114cec:	10800230 	cmpltui	r2,r2,8
80114cf0:	103fd51e 	bne	r2,zero,80114c48 <__reset+0xfa0f4c48>
80114cf4:	00000106 	br	80114cfc <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
80114cf8:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
80114cfc:	d0a07a17 	ldw	r2,-32280(gp)
80114d00:	1009883a 	mov	r4,r2
80114d04:	01384940 	call	80138494 <OSMutexPost>
    (*bFinished) = TRUE;
80114d08:	e0bfff17 	ldw	r2,-4(fp)
80114d0c:	00c00044 	movi	r3,1
80114d10:	10c00015 	stw	r3,0(r2)

    return bFound;
80114d14:	e0bffc17 	ldw	r2,-16(fp)
}
80114d18:	e037883a 	mov	sp,fp
80114d1c:	dfc00117 	ldw	ra,4(sp)
80114d20:	df000017 	ldw	fp,0(sp)
80114d24:	dec00204 	addi	sp,sp,8
80114d28:	f800283a 	ret

80114d2c <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
80114d2c:	defffa04 	addi	sp,sp,-24
80114d30:	de00012e 	bgeu	sp,et,80114d38 <bCheckInAck32+0xc>
80114d34:	003b68fa 	trap	3
80114d38:	dfc00515 	stw	ra,20(sp)
80114d3c:	df000415 	stw	fp,16(sp)
80114d40:	df000404 	addi	fp,sp,16
80114d44:	e13ffe15 	stw	r4,-8(fp)
80114d48:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
80114d4c:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
80114d50:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
80114d54:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
80114d58:	e0bfff17 	ldw	r2,-4(fp)
80114d5c:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
80114d60:	d0a07517 	ldw	r2,-32300(gp)
80114d64:	e0fffd44 	addi	r3,fp,-11
80114d68:	180d883a 	mov	r6,r3
80114d6c:	01400044 	movi	r5,1
80114d70:	1009883a 	mov	r4,r2
80114d74:	0137ef00 	call	80137ef0 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
80114d78:	e0bffd43 	ldbu	r2,-11(fp)
80114d7c:	10803fcc 	andi	r2,r2,255
80114d80:	10000226 	beq	r2,zero,80114d8c <bCheckInAck32+0x60>
        return bFound;
80114d84:	e0bffc17 	ldw	r2,-16(fp)
80114d88:	00003606 	br	80114e64 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
80114d8c:	e03ffd05 	stb	zero,-12(fp)
80114d90:	00002806 	br	80114e34 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
80114d94:	e0fffd03 	ldbu	r3,-12(fp)
80114d98:	00a00574 	movhi	r2,32789
80114d9c:	1087c404 	addi	r2,r2,7952
80114da0:	18c00b24 	muli	r3,r3,44
80114da4:	10c5883a 	add	r2,r2,r3
80114da8:	10800904 	addi	r2,r2,36
80114dac:	10c0000b 	ldhu	r3,0(r2)
80114db0:	e0bffe17 	ldw	r2,-8(fp)
80114db4:	1080008b 	ldhu	r2,2(r2)
80114db8:	18ffffcc 	andi	r3,r3,65535
80114dbc:	10bfffcc 	andi	r2,r2,65535
80114dc0:	1880191e 	bne	r3,r2,80114e28 <bCheckInAck32+0xfc>
            bFound = TRUE;
80114dc4:	00800044 	movi	r2,1
80114dc8:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
80114dcc:	e0fffd03 	ldbu	r3,-12(fp)
80114dd0:	00a00574 	movhi	r2,32789
80114dd4:	109a3c04 	addi	r2,r2,26864
80114dd8:	18c00384 	addi	r3,r3,14
80114ddc:	18c7883a 	add	r3,r3,r3
80114de0:	18c7883a 	add	r3,r3,r3
80114de4:	10c5883a 	add	r2,r2,r3
80114de8:	10000015 	stw	zero,0(r2)
            SemCount32++;
80114dec:	d0a07283 	ldbu	r2,-32310(gp)
80114df0:	10800044 	addi	r2,r2,1
80114df4:	d0a07285 	stb	r2,-32310(gp)
            error_code = OSSemPost(xSemCountBuffer32);
80114df8:	d0a07817 	ldw	r2,-32288(gp)
80114dfc:	1009883a 	mov	r4,r2
80114e00:	013a2840 	call	8013a284 <OSSemPost>
80114e04:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
80114e08:	e0bffd43 	ldbu	r2,-11(fp)
80114e0c:	10803fcc 	andi	r2,r2,255
80114e10:	10000c26 	beq	r2,zero,80114e44 <bCheckInAck32+0x118>
                SemCount32--;
80114e14:	d0a07283 	ldbu	r2,-32310(gp)
80114e18:	10bfffc4 	addi	r2,r2,-1
80114e1c:	d0a07285 	stb	r2,-32310(gp)
                vFailSetCountSemaphorexBuffer32();
80114e20:	011d1740 	call	8011d174 <vFailSetCountSemaphorexBuffer32>
            }
            break;
80114e24:	00000706 	br	80114e44 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
80114e28:	e0bffd03 	ldbu	r2,-12(fp)
80114e2c:	10800044 	addi	r2,r2,1
80114e30:	e0bffd05 	stb	r2,-12(fp)
80114e34:	e0bffd03 	ldbu	r2,-12(fp)
80114e38:	10800230 	cmpltui	r2,r2,8
80114e3c:	103fd51e 	bne	r2,zero,80114d94 <__reset+0xfa0f4d94>
80114e40:	00000106 	br	80114e48 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
80114e44:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
80114e48:	d0a07517 	ldw	r2,-32300(gp)
80114e4c:	1009883a 	mov	r4,r2
80114e50:	01384940 	call	80138494 <OSMutexPost>
    (*bFinished) = TRUE;
80114e54:	e0bfff17 	ldw	r2,-4(fp)
80114e58:	00c00044 	movi	r3,1
80114e5c:	10c00015 	stw	r3,0(r2)

    return bFound;
80114e60:	e0bffc17 	ldw	r2,-16(fp)
}
80114e64:	e037883a 	mov	sp,fp
80114e68:	dfc00117 	ldw	ra,4(sp)
80114e6c:	df000017 	ldw	fp,0(sp)
80114e70:	dec00204 	addi	sp,sp,8
80114e74:	f800283a 	ret

80114e78 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
80114e78:	defff704 	addi	sp,sp,-36
80114e7c:	de00012e 	bgeu	sp,et,80114e84 <vInitialTask+0xc>
80114e80:	003b68fa 	trap	3
80114e84:	dfc00815 	stw	ra,32(sp)
80114e88:	df000715 	stw	fp,28(sp)
80114e8c:	df000704 	addi	fp,sp,28
80114e90:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code = OS_ERR_NONE;
80114e94:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
80114e98:	d8000415 	stw	zero,16(sp)
80114e9c:	d8000315 	stw	zero,12(sp)
80114ea0:	00810004 	movi	r2,1024
80114ea4:	d8800215 	stw	r2,8(sp)
80114ea8:	00a00574 	movhi	r2,32789
80114eac:	10abf504 	addi	r2,r2,-20524
80114eb0:	d8800115 	stw	r2,4(sp)
80114eb4:	008002c4 	movi	r2,11
80114eb8:	d8800015 	stw	r2,0(sp)
80114ebc:	01c002c4 	movi	r7,11
80114ec0:	01a00574 	movhi	r6,32789
80114ec4:	31aff404 	addi	r6,r6,-16432
80114ec8:	01600574 	movhi	r5,32789
80114ecc:	29414c04 	addi	r5,r5,1328
80114ed0:	01200474 	movhi	r4,32785
80114ed4:	2138aa04 	addi	r4,r4,-7512
80114ed8:	013ac680 	call	8013ac68 <OSTaskCreateExt>
80114edc:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80114ee0:	e0bffe03 	ldbu	r2,-8(fp)
80114ee4:	10803fcc 	andi	r2,r2,255
80114ee8:	10000126 	beq	r2,zero,80114ef0 <vInitialTask+0x78>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
			vCoudlNotCreateNFee0Task();
80114eec:	011d7280 	call	8011d728 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
80114ef0:	01c17704 	movi	r7,1500
80114ef4:	000d883a 	mov	r6,zero
80114ef8:	000b883a 	mov	r5,zero
80114efc:	0009883a 	mov	r4,zero
80114f00:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vFeeTask1_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask1,
80114f04:	d8000415 	stw	zero,16(sp)
80114f08:	d8000315 	stw	zero,12(sp)
80114f0c:	00810004 	movi	r2,1024
80114f10:	d8800215 	stw	r2,8(sp)
80114f14:	00a005b4 	movhi	r2,32790
80114f18:	10a36e04 	addi	r2,r2,-29256
80114f1c:	d8800115 	stw	r2,4(sp)
80114f20:	00800304 	movi	r2,12
80114f24:	d8800015 	stw	r2,0(sp)
80114f28:	01c00304 	movi	r7,12
80114f2c:	01a005b4 	movhi	r6,32790
80114f30:	31a76d04 	addi	r6,r6,-25164
80114f34:	01600574 	movhi	r5,32789
80114f38:	2941e704 	addi	r5,r5,1948
80114f3c:	01200474 	movhi	r4,32785
80114f40:	21052304 	addi	r4,r4,5260
80114f44:	013ac680 	call	8013ac68 <OSTaskCreateExt>
80114f48:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80114f4c:	e0bffe03 	ldbu	r2,-8(fp)
80114f50:	10803fcc 	andi	r2,r2,255
80114f54:	10000126 	beq	r2,zero,80114f5c <vInitialTask+0xe4>
		/* Can't create Task */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
			vCoudlNotCreateNFee1Task();
80114f58:	011d7500 	call	8011d750 <vCoudlNotCreateNFee1Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
80114f5c:	01c17704 	movi	r7,1500
80114f60:	000d883a 	mov	r6,zero
80114f64:	000b883a 	mov	r5,zero
80114f68:	0009883a 	mov	r4,zero
80114f6c:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vFeeTask2_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask2,
80114f70:	d8000415 	stw	zero,16(sp)
80114f74:	d8000315 	stw	zero,12(sp)
80114f78:	00810004 	movi	r2,1024
80114f7c:	d8800215 	stw	r2,8(sp)
80114f80:	00a005b4 	movhi	r2,32790
80114f84:	10b57204 	addi	r2,r2,-10808
80114f88:	d8800115 	stw	r2,4(sp)
80114f8c:	00800344 	movi	r2,13
80114f90:	d8800015 	stw	r2,0(sp)
80114f94:	01c00344 	movi	r7,13
80114f98:	01a005b4 	movhi	r6,32790
80114f9c:	31b97104 	addi	r6,r6,-6716
80114fa0:	01600574 	movhi	r5,32789
80114fa4:	29428204 	addi	r5,r5,2568
80114fa8:	01200474 	movhi	r4,32785
80114fac:	21096204 	addi	r4,r4,9608
80114fb0:	013ac680 	call	8013ac68 <OSTaskCreateExt>
80114fb4:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80114fb8:	e0bffe03 	ldbu	r2,-8(fp)
80114fbc:	10803fcc 	andi	r2,r2,255
80114fc0:	10000126 	beq	r2,zero,80114fc8 <vInitialTask+0x150>
		//* Can't create Task */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
			vCoudlNotCreateNFee2Task();
80114fc4:	011d7780 	call	8011d778 <vCoudlNotCreateNFee2Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
80114fc8:	01c17704 	movi	r7,1500
80114fcc:	000d883a 	mov	r6,zero
80114fd0:	000b883a 	mov	r5,zero
80114fd4:	0009883a 	mov	r4,zero
80114fd8:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vFeeTask3_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask3,
80114fdc:	d8000415 	stw	zero,16(sp)
80114fe0:	d8000315 	stw	zero,12(sp)
80114fe4:	00810004 	movi	r2,1024
80114fe8:	d8800215 	stw	r2,8(sp)
80114fec:	00a005b4 	movhi	r2,32790
80114ff0:	10b17204 	addi	r2,r2,-14904
80114ff4:	d8800115 	stw	r2,4(sp)
80114ff8:	00800384 	movi	r2,14
80114ffc:	d8800015 	stw	r2,0(sp)
80115000:	01c00384 	movi	r7,14
80115004:	01a005b4 	movhi	r6,32790
80115008:	31b57104 	addi	r6,r6,-10812
8011500c:	01600574 	movhi	r5,32789
80115010:	29431d04 	addi	r5,r5,3188
80115014:	01200474 	movhi	r4,32785
80115018:	210da104 	addi	r4,r4,13956
8011501c:	013ac680 	call	8013ac68 <OSTaskCreateExt>
80115020:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80115024:	e0bffe03 	ldbu	r2,-8(fp)
80115028:	10803fcc 	andi	r2,r2,255
8011502c:	10000126 	beq	r2,zero,80115034 <vInitialTask+0x1bc>
		/* Can't create Task */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
			vCoudlNotCreateNFee3Task();
80115030:	011d7a00 	call	8011d7a0 <vCoudlNotCreateNFee3Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
80115034:	01c17704 	movi	r7,1500
80115038:	000d883a 	mov	r6,zero
8011503c:	000b883a 	mov	r5,zero
80115040:	0009883a 	mov	r4,zero
80115044:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
80115048:	d8000415 	stw	zero,16(sp)
8011504c:	d8000315 	stw	zero,12(sp)
80115050:	00810004 	movi	r2,1024
80115054:	d8800215 	stw	r2,8(sp)
80115058:	00a00574 	movhi	r2,32789
8011505c:	10bd3104 	addi	r2,r2,-2876
80115060:	d8800115 	stw	r2,4(sp)
80115064:	00800284 	movi	r2,10
80115068:	d8800015 	stw	r2,0(sp)
8011506c:	01c00284 	movi	r7,10
80115070:	01a00574 	movhi	r6,32789
80115074:	31813004 	addi	r6,r6,1216
80115078:	01600574 	movhi	r5,32789
8011507c:	29413b04 	addi	r5,r5,1260
80115080:	01200474 	movhi	r4,32785
80115084:	21388904 	addi	r4,r4,-7644
80115088:	013ac680 	call	8013ac68 <OSTaskCreateExt>
8011508c:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80115090:	e0bffe03 	ldbu	r2,-8(fp)
80115094:	10803fcc 	andi	r2,r2,255
80115098:	10000126 	beq	r2,zero,801150a0 <vInitialTask+0x228>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
			vCoudlNotCreateDataControllerTask();
8011509c:	011d8400 	call	8011d840 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
801150a0:	01c17704 	movi	r7,1500
801150a4:	000d883a 	mov	r6,zero
801150a8:	000b883a 	mov	r5,zero
801150ac:	0009883a 	mov	r4,zero
801150b0:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
801150b4:	d8000415 	stw	zero,16(sp)
801150b8:	d8000315 	stw	zero,12(sp)
801150bc:	00810004 	movi	r2,1024
801150c0:	d8800215 	stw	r2,8(sp)
801150c4:	00a00574 	movhi	r2,32789
801150c8:	109b5404 	addi	r2,r2,27984
801150cc:	d8800115 	stw	r2,4(sp)
801150d0:	00800244 	movi	r2,9
801150d4:	d8800015 	stw	r2,0(sp)
801150d8:	01c00244 	movi	r7,9
801150dc:	01a00574 	movhi	r6,32789
801150e0:	319f5304 	addi	r6,r6,32076
801150e4:	01600574 	movhi	r5,32789
801150e8:	29414c04 	addi	r5,r5,1328
801150ec:	01200474 	movhi	r4,32785
801150f0:	21152404 	addi	r4,r4,21648
801150f4:	013ac680 	call	8013ac68 <OSTaskCreateExt>
801150f8:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
801150fc:	e0bffe03 	ldbu	r2,-8(fp)
80115100:	10803fcc 	andi	r2,r2,255
80115104:	10000126 	beq	r2,zero,8011510c <vInitialTask+0x294>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
			vCoudlNotCreateNFeeControllerTask();
80115108:	011d8180 	call	8011d818 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8011510c:	01c17704 	movi	r7,1500
80115110:	000d883a 	mov	r6,zero
80115114:	000b883a 	mov	r5,zero
80115118:	0009883a 	mov	r4,zero
8011511c:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
80115120:	d8000415 	stw	zero,16(sp)
80115124:	d8000315 	stw	zero,12(sp)
80115128:	00810004 	movi	r2,1024
8011512c:	d8800215 	stw	r2,8(sp)
80115130:	00a005b4 	movhi	r2,32790
80115134:	10ad7204 	addi	r2,r2,-19000
80115138:	d8800115 	stw	r2,4(sp)
8011513c:	00800204 	movi	r2,8
80115140:	d8800015 	stw	r2,0(sp)
80115144:	01c00204 	movi	r7,8
80115148:	01a005b4 	movhi	r6,32790
8011514c:	31b17104 	addi	r6,r6,-14908
80115150:	01600574 	movhi	r5,32789
80115154:	29413104 	addi	r5,r5,1220
80115158:	01200474 	movhi	r4,32785
8011515c:	211c7004 	addi	r4,r4,29120
80115160:	013ac680 	call	8013ac68 <OSTaskCreateExt>
80115164:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80115168:	e0bffe03 	ldbu	r2,-8(fp)
8011516c:	10803fcc 	andi	r2,r2,255
80115170:	10000126 	beq	r2,zero,80115178 <vInitialTask+0x300>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
			vCoudlNotCreateMebTask();
80115174:	011d8680 	call	8011d868 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
80115178:	01c17704 	movi	r7,1500
8011517c:	000d883a 	mov	r6,zero
80115180:	000b883a 	mov	r5,zero
80115184:	0009883a 	mov	r4,zero
80115188:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
8011518c:	d8000415 	stw	zero,16(sp)
80115190:	d8000315 	stw	zero,12(sp)
80115194:	00810004 	movi	r2,1024
80115198:	d8800215 	stw	r2,8(sp)
8011519c:	00a00574 	movhi	r2,32789
801151a0:	10b93104 	addi	r2,r2,-6972
801151a4:	d8800115 	stw	r2,4(sp)
801151a8:	00800784 	movi	r2,30
801151ac:	d8800015 	stw	r2,0(sp)
801151b0:	01c00784 	movi	r7,30
801151b4:	01a00574 	movhi	r6,32789
801151b8:	31bd3004 	addi	r6,r6,-2880
801151bc:	000b883a 	mov	r5,zero
801151c0:	012004b4 	movhi	r4,32786
801151c4:	21208604 	addi	r4,r4,-32232
801151c8:	013ac680 	call	8013ac68 <OSTaskCreateExt>
801151cc:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
801151d0:	e0bffe03 	ldbu	r2,-8(fp)
801151d4:	10803fcc 	andi	r2,r2,255
801151d8:	10000126 	beq	r2,zero,801151e0 <vInitialTask+0x368>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
		vFailTimeoutCheckerTaskCreate();
801151dc:	011d4940 	call	8011d494 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
801151e0:	01c03204 	movi	r7,200
801151e4:	000d883a 	mov	r6,zero
801151e8:	000b883a 	mov	r5,zero
801151ec:	0009883a 	mov	r4,zero
801151f0:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
801151f4:	d8000415 	stw	zero,16(sp)
801151f8:	d8000315 	stw	zero,12(sp)
801151fc:	00810004 	movi	r2,1024
80115200:	d8800215 	stw	r2,8(sp)
80115204:	00a00574 	movhi	r2,32789
80115208:	108e2c04 	addi	r2,r2,14512
8011520c:	d8800115 	stw	r2,4(sp)
80115210:	008006c4 	movi	r2,27
80115214:	d8800015 	stw	r2,0(sp)
80115218:	01c006c4 	movi	r7,27
8011521c:	01a00574 	movhi	r6,32789
80115220:	31922b04 	addi	r6,r6,18604
80115224:	000b883a 	mov	r5,zero
80115228:	01200474 	movhi	r4,32785
8011522c:	2116cb04 	addi	r4,r4,23340
80115230:	013ac680 	call	8013ac68 <OSTaskCreateExt>
80115234:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80115238:	e0bffe03 	ldbu	r2,-8(fp)
8011523c:	10803fcc 	andi	r2,r2,255
80115240:	10000126 	beq	r2,zero,80115248 <vInitialTask+0x3d0>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
		vFailOutAckHandlerTaskCreate();
80115244:	011d41c0 	call	8011d41c <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
80115248:	01c03204 	movi	r7,200
8011524c:	000d883a 	mov	r6,zero
80115250:	000b883a 	mov	r5,zero
80115254:	0009883a 	mov	r4,zero
80115258:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
8011525c:	d8000415 	stw	zero,16(sp)
80115260:	d8000315 	stw	zero,12(sp)
80115264:	00810004 	movi	r2,1024
80115268:	d8800215 	stw	r2,8(sp)
8011526c:	00a00574 	movhi	r2,32789
80115270:	10aff504 	addi	r2,r2,-16428
80115274:	d8800115 	stw	r2,4(sp)
80115278:	00800644 	movi	r2,25
8011527c:	d8800015 	stw	r2,0(sp)
80115280:	01c00644 	movi	r7,25
80115284:	01a00574 	movhi	r6,32789
80115288:	31b3f404 	addi	r6,r6,-12336
8011528c:	000b883a 	mov	r5,zero
80115290:	01200474 	movhi	r4,32785
80115294:	2111e004 	addi	r4,r4,18304
80115298:	013ac680 	call	8013ac68 <OSTaskCreateExt>
8011529c:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
801152a0:	e0bffe03 	ldbu	r2,-8(fp)
801152a4:	10803fcc 	andi	r2,r2,255
801152a8:	10000126 	beq	r2,zero,801152b0 <vInitialTask+0x438>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
		vFailInAckHandlerTaskCreate();
801152ac:	011d3f40 	call	8011d3f4 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
801152b0:	01c03204 	movi	r7,200
801152b4:	000d883a 	mov	r6,zero
801152b8:	000b883a 	mov	r5,zero
801152bc:	0009883a 	mov	r4,zero
801152c0:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
801152c4:	d8000415 	stw	zero,16(sp)
801152c8:	d8000315 	stw	zero,12(sp)
801152cc:	00818004 	movi	r2,1536
801152d0:	d8800215 	stw	r2,8(sp)
801152d4:	00a005b4 	movhi	r2,32790
801152d8:	10a76e04 	addi	r2,r2,-25160
801152dc:	d8800115 	stw	r2,4(sp)
801152e0:	00800704 	movi	r2,28
801152e4:	d8800015 	stw	r2,0(sp)
801152e8:	01c00704 	movi	r7,28
801152ec:	01a005b4 	movhi	r6,32790
801152f0:	31ad6d04 	addi	r6,r6,-19020
801152f4:	000b883a 	mov	r5,zero
801152f8:	01200474 	movhi	r4,32785
801152fc:	21177b04 	addi	r4,r4,24044
80115300:	013ac680 	call	8013ac68 <OSTaskCreateExt>
80115304:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80115308:	e0bffe03 	ldbu	r2,-8(fp)
8011530c:	10803fcc 	andi	r2,r2,255
80115310:	10000126 	beq	r2,zero,80115318 <vInitialTask+0x4a0>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
		vFailParserCommTaskCreate();
80115314:	011d3cc0 	call	8011d3cc <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
80115318:	01c03204 	movi	r7,200
8011531c:	000d883a 	mov	r6,zero
80115320:	000b883a 	mov	r5,zero
80115324:	0009883a 	mov	r4,zero
80115328:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8011532c:	d8000415 	stw	zero,16(sp)
80115330:	d8000315 	stw	zero,12(sp)
80115334:	00818004 	movi	r2,1536
80115338:	d8800215 	stw	r2,8(sp)
8011533c:	00a00574 	movhi	r2,32789
80115340:	10881c04 	addi	r2,r2,8304
80115344:	d8800115 	stw	r2,4(sp)
80115348:	00800804 	movi	r2,32
8011534c:	d8800015 	stw	r2,0(sp)
80115350:	01c00804 	movi	r7,32
80115354:	01a00574 	movhi	r6,32789
80115358:	318e1b04 	addi	r6,r6,14444
8011535c:	000b883a 	mov	r5,zero
80115360:	01200474 	movhi	r4,32785
80115364:	2119dd04 	addi	r4,r4,26484
80115368:	013ac680 	call	8013ac68 <OSTaskCreateExt>
8011536c:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
80115370:	e0bffe03 	ldbu	r2,-8(fp)
80115374:	10803fcc 	andi	r2,r2,255
80115378:	10000126 	beq	r2,zero,80115380 <vInitialTask+0x508>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
		vFailReceiverCreate();
8011537c:	011d0fc0 	call	8011d0fc <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
80115380:	01c03204 	movi	r7,200
80115384:	000d883a 	mov	r6,zero
80115388:	000b883a 	mov	r5,zero
8011538c:	0009883a 	mov	r4,zero
80115390:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
80115394:	d8000415 	stw	zero,16(sp)
80115398:	d8000315 	stw	zero,12(sp)
8011539c:	00810004 	movi	r2,1024
801153a0:	d8800215 	stw	r2,8(sp)
801153a4:	00a00574 	movhi	r2,32789
801153a8:	10b4f104 	addi	r2,r2,-11324
801153ac:	d8800115 	stw	r2,4(sp)
801153b0:	00800684 	movi	r2,26
801153b4:	d8800015 	stw	r2,0(sp)
801153b8:	01c00684 	movi	r7,26
801153bc:	01a00574 	movhi	r6,32789
801153c0:	31b8f004 	addi	r6,r6,-7232
801153c4:	000b883a 	mov	r5,zero
801153c8:	01200474 	movhi	r4,32785
801153cc:	211c3c04 	addi	r4,r4,28912
801153d0:	013ac680 	call	8013ac68 <OSTaskCreateExt>
801153d4:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
801153d8:	01c03204 	movi	r7,200
801153dc:	000d883a 	mov	r6,zero
801153e0:	000b883a 	mov	r5,zero
801153e4:	0009883a 	mov	r4,zero
801153e8:	013be940 	call	8013be94 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
801153ec:	e0bffe03 	ldbu	r2,-8(fp)
801153f0:	10803fcc 	andi	r2,r2,255
801153f4:	10000126 	beq	r2,zero,801153fc <vInitialTask+0x584>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );
		}
		#endif
		vFailSenderCreate();
801153f8:	011d1240 	call	8011d124 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
801153fc:	d0a07617 	ldw	r2,-32296(gp)
80115400:	e17ffe04 	addi	r5,fp,-8
80115404:	1009883a 	mov	r4,r2
80115408:	013c9880 	call	8013c988 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8011540c:	e0bffe03 	ldbu	r2,-8(fp)
80115410:	10803fcc 	andi	r2,r2,255
80115414:	10000126 	beq	r2,zero,8011541c <vInitialTask+0x5a4>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
80115418:	011d5ac0 	call	8011d5ac <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8011541c:	01c00084 	movi	r7,2
80115420:	01800784 	movi	r6,30
80115424:	000b883a 	mov	r5,zero
80115428:	0009883a 	mov	r4,zero
8011542c:	013be940 	call	8013be94 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
80115430:	01003fc4 	movi	r4,255
80115434:	013ae540 	call	8013ae54 <OSTaskDel>
80115438:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8011543c:	e0bffe03 	ldbu	r2,-8(fp)
80115440:	10803fcc 	andi	r2,r2,255
80115444:	10000c26 	beq	r2,zero,80115478 <vInitialTask+0x600>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			printErrorTask( error_code );		
		}
		#endif
		vFailDeleteInitialization();
80115448:	011d14c0 	call	8011d14c <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8011544c:	014009c4 	movi	r5,39
80115450:	01000044 	movi	r4,1
80115454:	013a5bc0 	call	8013a5bc <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
80115458:	01003fc4 	movi	r4,255
8011545c:	013ae540 	call	8013ae54 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
80115460:	000f883a 	mov	r7,zero
80115464:	01800284 	movi	r6,10
80115468:	000b883a 	mov	r5,zero
8011546c:	0009883a 	mov	r4,zero
80115470:	013be940 	call	8013be94 <OSTimeDlyHMSM>
		}
80115474:	003ff806 	br	80115458 <__reset+0xfa0f5458>
	}

}
80115478:	0001883a 	nop
8011547c:	e037883a 	mov	sp,fp
80115480:	dfc00117 	ldw	ra,4(sp)
80115484:	df000017 	ldw	fp,0(sp)
80115488:	dec00204 	addi	sp,sp,8
8011548c:	f800283a 	ret

80115490 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
80115490:	defff704 	addi	sp,sp,-36
80115494:	de00012e 	bgeu	sp,et,8011549c <vNFeeControlTask+0xc>
80115498:	003b68fa 	trap	3
8011549c:	dfc00815 	stw	ra,32(sp)
801154a0:	df000715 	stw	fp,28(sp)
801154a4:	df000704 	addi	fp,sp,28
801154a8:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
801154ac:	e0bfff17 	ldw	r2,-4(fp)
801154b0:	e0bffa15 	stw	r2,-24(fp)
	}
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
801154b4:	e0bffa17 	ldw	r2,-24(fp)
801154b8:	10827617 	ldw	r2,2520(r2)
801154bc:	10c00168 	cmpgeui	r3,r2,5
801154c0:	1800cf1e 	bne	r3,zero,80115800 <vNFeeControlTask+0x370>
801154c4:	100690ba 	slli	r3,r2,2
801154c8:	00a00474 	movhi	r2,32785
801154cc:	10953704 	addi	r2,r2,21724
801154d0:	1885883a 	add	r2,r3,r2
801154d4:	10800017 	ldw	r2,0(r2)
801154d8:	1000683a 	jmp	r2
801154dc:	801154f0 	cmpltui	zero,r16,17747
801154e0:	80115520 	cmpeqi	zero,r16,17748
801154e4:	80115564 	muli	zero,r16,17749
801154e8:	80115604 	addi	zero,r16,17752
801154ec:	80115664 	muli	zero,r16,17753
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
801154f0:	d0a07917 	ldw	r2,-32284(gp)
801154f4:	1009883a 	mov	r4,r2
801154f8:	0138f440 	call	80138f44 <OSQFlush>
801154fc:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
80115500:	e0bffe03 	ldbu	r2,-8(fp)
80115504:	10803fcc 	andi	r2,r2,255
80115508:	10000126 	beq	r2,zero,80115510 <vNFeeControlTask+0x80>
					vFailFlushQueue();
8011550c:	011db700 	call	8011db70 <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
80115510:	e0bffa17 	ldw	r2,-24(fp)
80115514:	00c00044 	movi	r3,1
80115518:	10c27615 	stw	r3,2520(r2)
				break;
8011551c:	0000bd06 	br	80115814 <vNFeeControlTask+0x384>
					debug(fp,"NFEE Controller Task: Config Mode\n");
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
80115520:	d0a06817 	ldw	r2,-32352(gp)
80115524:	1009883a 	mov	r4,r2
80115528:	0138f440 	call	80138f44 <OSQFlush>
8011552c:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
80115530:	e0bffe03 	ldbu	r2,-8(fp)
80115534:	10803fcc 	andi	r2,r2,255
80115538:	10000126 	beq	r2,zero,80115540 <vNFeeControlTask+0xb0>
					vFailFlushQueue();
8011553c:	011db700 	call	8011db70 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
80115540:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
80115544:	00800044 	movi	r2,1
80115548:	d0a06415 	stw	r2,-32368(gp)
				ucWhoGetDMA = 255;
8011554c:	00bfffc4 	movi	r2,-1
80115550:	d0a06505 	stb	r2,-32364(gp)
				pxFeeC->sMode = sMebConfig;
80115554:	e0bffa17 	ldw	r2,-24(fp)
80115558:	00c000c4 	movi	r3,3
8011555c:	10c27615 	stw	r3,2520(r2)
				break;
80115560:	0000ac06 	br	80115814 <vNFeeControlTask+0x384>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
80115564:	011dc380 	call	8011dc38 <vEvtChangeFeeControllerMode>
					debug(fp,"NFEE Controller Task: RUN Mode\n");
				}
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
80115568:	d0a06817 	ldw	r2,-32352(gp)
8011556c:	1009883a 	mov	r4,r2
80115570:	0138f440 	call	80138f44 <OSQFlush>
80115574:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
80115578:	e0bffe03 	ldbu	r2,-8(fp)
8011557c:	10803fcc 	andi	r2,r2,255
80115580:	10000126 	beq	r2,zero,80115588 <vNFeeControlTask+0xf8>
					vFailFlushQueue();
80115584:	011db700 	call	8011db70 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
80115588:	e03ff905 	stb	zero,-28(fp)
8011558c:	00001106 	br	801155d4 <vNFeeControlTask+0x144>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
80115590:	e0fff903 	ldbu	r3,-28(fp)
80115594:	00a00574 	movhi	r2,32789
80115598:	109f5404 	addi	r2,r2,32080
8011559c:	18c7883a 	add	r3,r3,r3
801155a0:	18c7883a 	add	r3,r3,r3
801155a4:	10c5883a 	add	r2,r2,r3
801155a8:	10800017 	ldw	r2,0(r2)
801155ac:	1009883a 	mov	r4,r2
801155b0:	0138f440 	call	80138f44 <OSQFlush>
801155b4:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
801155b8:	e0bffe03 	ldbu	r2,-8(fp)
801155bc:	10803fcc 	andi	r2,r2,255
801155c0:	10000126 	beq	r2,zero,801155c8 <vNFeeControlTask+0x138>
						vFailFlushQueue();
801155c4:	011db700 	call	8011db70 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
801155c8:	e0bff903 	ldbu	r2,-28(fp)
801155cc:	10800044 	addi	r2,r2,1
801155d0:	e0bff905 	stb	r2,-28(fp)
801155d4:	e0bff903 	ldbu	r2,-28(fp)
801155d8:	10800130 	cmpltui	r2,r2,4
801155dc:	103fec1e 	bne	r2,zero,80115590 <__reset+0xfa0f5590>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
801155e0:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
801155e4:	00800044 	movi	r2,1
801155e8:	d0a06415 	stw	r2,-32368(gp)
				ucWhoGetDMA = 255;
801155ec:	00bfffc4 	movi	r2,-1
801155f0:	d0a06505 	stb	r2,-32364(gp)
				pxFeeC->sMode = sMebRun;
801155f4:	e0bffa17 	ldw	r2,-24(fp)
801155f8:	00c00104 	movi	r3,4
801155fc:	10c27615 	stw	r3,2520(r2)
				break;
80115600:	00008406 	br	80115814 <vNFeeControlTask+0x384>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
80115604:	d0a07917 	ldw	r2,-32284(gp)
80115608:	e0fffe04 	addi	r3,fp,-8
8011560c:	180d883a 	mov	r6,r3
80115610:	000b883a 	mov	r5,zero
80115614:	1009883a 	mov	r4,r2
80115618:	01390040 	call	80139004 <OSQPend>
8011561c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
80115620:	e0bffe03 	ldbu	r2,-8(fp)
80115624:	10803fcc 	andi	r2,r2,255
80115628:	10000c1e 	bne	r2,zero,8011565c <vNFeeControlTask+0x1cc>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8011562c:	e0bffdc3 	ldbu	r2,-9(fp)
80115630:	10803fcc 	andi	r2,r2,255
80115634:	10800418 	cmpnei	r2,r2,16
80115638:	1000041e 	bne	r2,zero,8011564c <vNFeeControlTask+0x1bc>
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8011563c:	e0bffd17 	ldw	r2,-12(fp)
80115640:	e17ffa17 	ldw	r5,-24(fp)
80115644:	1009883a 	mov	r4,r2
80115648:	01158180 	call	80115818 <vPerformActionNFCConfig>
					}
					bCmdSent = FALSE;
8011564c:	e03ffb15 	stw	zero,-20(fp)
					bDmaBack = TRUE;
80115650:	00800044 	movi	r2,1
80115654:	d0a06415 	stw	r2,-32368(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
80115658:	00006e06 	br	80115814 <vNFeeControlTask+0x384>
					}
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8011565c:	011d9880 	call	8011d988 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
80115660:	00006c06 	br	80115814 <vNFeeControlTask+0x384>
				/* 	We have 2 importantes Queues here.  
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fast way and
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				
				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
80115664:	d0a06417 	ldw	r2,-32368(gp)
80115668:	10800058 	cmpnei	r2,r2,1
8011566c:	1000221e 	bne	r2,zero,801156f8 <vNFeeControlTask+0x268>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
80115670:	d0a06817 	ldw	r2,-32352(gp)
80115674:	e0fffe04 	addi	r3,fp,-8
80115678:	180d883a 	mov	r6,r3
8011567c:	01400104 	movi	r5,4
80115680:	1009883a 	mov	r4,r2
80115684:	01390040 	call	80139004 <OSQPend>
80115688:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
8011568c:	e0bffe03 	ldbu	r2,-8(fp)
80115690:	10803fcc 	andi	r2,r2,255
80115694:	1000181e 	bne	r2,zero,801156f8 <vNFeeControlTask+0x268>
						ucFeeInstL = uiCmdNFC.ucByte[0];
80115698:	e0bffd03 	ldbu	r2,-12(fp)
8011569c:	e0bffc05 	stb	r2,-16(fp)

						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
801156a0:	e0bffc03 	ldbu	r2,-16(fp)
801156a4:	e0fffa17 	ldw	r3,-24(fp)
801156a8:	10809b24 	muli	r2,r2,620
801156ac:	1885883a 	add	r2,r3,r2
801156b0:	10802304 	addi	r2,r2,140
801156b4:	10800017 	ldw	r2,0(r2)
801156b8:	10800058 	cmpnei	r2,r2,1
801156bc:	10000e1e 	bne	r2,zero,801156f8 <vNFeeControlTask+0x268>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
801156c0:	e0bffc03 	ldbu	r2,-16(fp)
801156c4:	e0fffc03 	ldbu	r3,-16(fp)
801156c8:	180f883a 	mov	r7,r3
801156cc:	000d883a 	mov	r6,zero
801156d0:	014023c4 	movi	r5,143
801156d4:	1009883a 	mov	r4,r2
801156d8:	01159940 	call	80115994 <bSendCmdQToNFeeInst>
801156dc:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE ) {
801156e0:	e0bffb17 	ldw	r2,-20(fp)
801156e4:	10800058 	cmpnei	r2,r2,1
801156e8:	1000031e 	bne	r2,zero,801156f8 <vNFeeControlTask+0x268>
								bDmaBack = FALSE;
801156ec:	d0206415 	stw	zero,-32368(gp)
								ucWhoGetDMA = ucFeeInstL;
801156f0:	e0bffc03 	ldbu	r2,-16(fp)
801156f4:	d0a06505 	stb	r2,-32364(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
801156f8:	d0a06417 	ldw	r2,-32368(gp)
801156fc:	1000081e 	bne	r2,zero,80115720 <vNFeeControlTask+0x290>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
80115700:	d0a07917 	ldw	r2,-32284(gp)
80115704:	e0fffe04 	addi	r3,fp,-8
80115708:	180d883a 	mov	r6,r3
8011570c:	000b883a 	mov	r5,zero
80115710:	1009883a 	mov	r4,r2
80115714:	01390040 	call	80139004 <OSQPend>
80115718:	e0bffd15 	stw	r2,-12(fp)
8011571c:	00000706 	br	8011573c <vNFeeControlTask+0x2ac>
				} else {
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
80115720:	d0a07917 	ldw	r2,-32284(gp)
80115724:	e0fffe04 	addi	r3,fp,-8
80115728:	180d883a 	mov	r6,r3
8011572c:	01400104 	movi	r5,4
80115730:	1009883a 	mov	r4,r2
80115734:	01390040 	call	80139004 <OSQPend>
80115738:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
8011573c:	e0bffe03 	ldbu	r2,-8(fp)
80115740:	10803fcc 	andi	r2,r2,255
80115744:	1000321e 	bne	r2,zero,80115810 <vNFeeControlTask+0x380>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
80115748:	e0bffd83 	ldbu	r2,-10(fp)
8011574c:	10803fcc 	andi	r2,r2,255
80115750:	10802058 	cmpnei	r2,r2,129
80115754:	10000a1e 	bne	r2,zero,80115780 <vNFeeControlTask+0x2f0>
						if ( uiCmdNFC.ucByte[0] == ucWhoGetDMA ){
80115758:	e0fffd03 	ldbu	r3,-12(fp)
8011575c:	d0a06503 	ldbu	r2,-32364(gp)
80115760:	18c03fcc 	andi	r3,r3,255
80115764:	10803fcc 	andi	r2,r2,255
80115768:	1880291e 	bne	r3,r2,80115810 <vNFeeControlTask+0x380>
							bDmaBack = TRUE;
8011576c:	00800044 	movi	r2,1
80115770:	d0a06415 	stw	r2,-32368(gp)
							ucFeeInstL = 255;
80115774:	00bfffc4 	movi	r2,-1
80115778:	e0bffc05 	stb	r2,-16(fp)
							}
						}
					}
				}
				
				break;		
8011577c:	00002406 	br	80115810 <vNFeeControlTask+0x380>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
80115780:	e0bffdc3 	ldbu	r2,-9(fp)
80115784:	10803fcc 	andi	r2,r2,255
80115788:	10800418 	cmpnei	r2,r2,16
8011578c:	1000051e 	bne	r2,zero,801157a4 <vNFeeControlTask+0x314>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
80115790:	e0bffd17 	ldw	r2,-12(fp)
80115794:	e17ffa17 	ldw	r5,-24(fp)
80115798:	1009883a 	mov	r4,r2
8011579c:	011589c0 	call	8011589c <vPerformActionNFCRunning>
							}
						}
					}
				}
				
				break;		
801157a0:	00001b06 	br	80115810 <vNFeeControlTask+0x380>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
801157a4:	e0bffdc3 	ldbu	r2,-9(fp)
801157a8:	10803fcc 	andi	r2,r2,255
801157ac:	10800470 	cmpltui	r2,r2,17
801157b0:	1000171e 	bne	r2,zero,80115810 <vNFeeControlTask+0x380>
801157b4:	e0bffdc3 	ldbu	r2,-9(fp)
801157b8:	10803fcc 	andi	r2,r2,255
801157bc:	108005a8 	cmpgeui	r2,r2,22
801157c0:	1000131e 	bne	r2,zero,80115810 <vNFeeControlTask+0x380>
								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
801157c4:	e0bffdc3 	ldbu	r2,-9(fp)
801157c8:	10bffbc4 	addi	r2,r2,-17
801157cc:	10803fcc 	andi	r2,r2,255
801157d0:	e0fffd83 	ldbu	r3,-10(fp)
801157d4:	18c03fcc 	andi	r3,r3,255
801157d8:	e13ffd43 	ldbu	r4,-11(fp)
801157dc:	21003fcc 	andi	r4,r4,255
801157e0:	e17ffd03 	ldbu	r5,-12(fp)
801157e4:	29403fcc 	andi	r5,r5,255
801157e8:	280f883a 	mov	r7,r5
801157ec:	200d883a 	mov	r6,r4
801157f0:	180b883a 	mov	r5,r3
801157f4:	1009883a 	mov	r4,r2
801157f8:	01159940 	call	80115994 <bSendCmdQToNFeeInst>
							}
						}
					}
				}
				
				break;		
801157fc:	00000406 	br	80115810 <vNFeeControlTask+0x380>
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
				}
				#endif
				
				pxFeeC->sMode = sMebConfig;
80115800:	e0bffa17 	ldw	r2,-24(fp)
80115804:	00c000c4 	movi	r3,3
80115808:	10c27615 	stw	r3,2520(r2)
				break;
8011580c:	00000106 	br	80115814 <vNFeeControlTask+0x384>
							}
						}
					}
				}
				
				break;		
80115810:	0001883a 	nop
				#endif
				
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
80115814:	003f2706 	br	801154b4 <__reset+0xfa0f54b4>

80115818 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
80115818:	defffc04 	addi	sp,sp,-16
8011581c:	de00012e 	bgeu	sp,et,80115824 <vPerformActionNFCConfig+0xc>
80115820:	003b68fa 	trap	3
80115824:	df000315 	stw	fp,12(sp)
80115828:	df000304 	addi	fp,sp,12
8011582c:	e13ffe15 	stw	r4,-8(fp)
80115830:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;

	uiCmdLocal.ulWord = uiCmdParam;
80115834:	e0bffe17 	ldw	r2,-8(fp)
80115838:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8011583c:	e0bffd83 	ldbu	r2,-10(fp)
80115840:	10803fcc 	andi	r2,r2,255
80115844:	10c000a0 	cmpeqi	r3,r2,2
80115848:	18000a1e 	bne	r3,zero,80115874 <vPerformActionNFCConfig+0x5c>
8011584c:	10c000c8 	cmpgei	r3,r2,3
80115850:	1800031e 	bne	r3,zero,80115860 <vPerformActionNFCConfig+0x48>
80115854:	10800060 	cmpeqi	r2,r2,1
80115858:	10000a1e 	bne	r2,zero,80115884 <vPerformActionNFCConfig+0x6c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
8011585c:	00000a06 	br	80115888 <vPerformActionNFCConfig+0x70>
void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
	tQMask uiCmdLocal;

	uiCmdLocal.ulWord = uiCmdParam;

	switch (uiCmdLocal.ucByte[2]) {
80115860:	10c02860 	cmpeqi	r3,r2,161
80115864:	1800071e 	bne	r3,zero,80115884 <vPerformActionNFCConfig+0x6c>
80115868:	108028a0 	cmpeqi	r2,r2,162
8011586c:	1000011e 	bne	r2,zero,80115874 <vPerformActionNFCConfig+0x5c>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
80115870:	00000506 	br	80115888 <vPerformActionNFCConfig+0x70>
			/* Do nothing for now */
			break;

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
80115874:	e0bfff17 	ldw	r2,-4(fp)
80115878:	00c00084 	movi	r3,2
8011587c:	10c27615 	stw	r3,2520(r2)
			break;
80115880:	00000106 	br	80115888 <vPerformActionNFCConfig+0x70>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
			}
			#endif
			/* Do nothing for now */
			break;
80115884:	0001883a 	nop
			}
			#endif	
			break;
	}

}
80115888:	0001883a 	nop
8011588c:	e037883a 	mov	sp,fp
80115890:	df000017 	ldw	fp,0(sp)
80115894:	dec00104 	addi	sp,sp,4
80115898:	f800283a 	ret

8011589c <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8011589c:	defffa04 	addi	sp,sp,-24
801158a0:	de00012e 	bgeu	sp,et,801158a8 <vPerformActionNFCRunning+0xc>
801158a4:	003b68fa 	trap	3
801158a8:	dfc00515 	stw	ra,20(sp)
801158ac:	df000415 	stw	fp,16(sp)
801158b0:	df000404 	addi	fp,sp,16
801158b4:	e13ffe15 	stw	r4,-8(fp)
801158b8:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
801158bc:	e0bffe17 	ldw	r2,-8(fp)
801158c0:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
801158c4:	e0bffd83 	ldbu	r2,-10(fp)
801158c8:	10803fcc 	andi	r2,r2,255
801158cc:	10c02088 	cmpgei	r3,r2,130
801158d0:	1800071e 	bne	r3,zero,801158f0 <vPerformActionNFCRunning+0x54>
801158d4:	10c02008 	cmpgei	r3,r2,128
801158d8:	1800251e 	bne	r3,zero,80115970 <vPerformActionNFCRunning+0xd4>
801158dc:	10c00060 	cmpeqi	r3,r2,1
801158e0:	1800061e 	bne	r3,zero,801158fc <vPerformActionNFCRunning+0x60>
801158e4:	108000a0 	cmpeqi	r2,r2,2
801158e8:	1000231e 	bne	r2,zero,80115978 <vPerformActionNFCRunning+0xdc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
801158ec:	00002306 	br	8011597c <vPerformActionNFCRunning+0xe0>
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;

	switch (uiCmdLocal.ucByte[2]) {
801158f0:	10802860 	cmpeqi	r2,r2,161
801158f4:	1000011e 	bne	r2,zero,801158fc <vPerformActionNFCRunning+0x60>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
801158f8:	00002006 	br	8011597c <vPerformActionNFCRunning+0xe0>

	switch (uiCmdLocal.ucByte[2]) {
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
801158fc:	e0bfff17 	ldw	r2,-4(fp)
80115900:	00c00044 	movi	r3,1
80115904:	10c27615 	stw	r3,2520(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
80115908:	e03ffc05 	stb	zero,-16(fp)
8011590c:	00001406 	br	80115960 <vPerformActionNFCRunning+0xc4>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
80115910:	e0bffc03 	ldbu	r2,-16(fp)
80115914:	e0ffff17 	ldw	r3,-4(fp)
80115918:	10809b44 	addi	r2,r2,621
8011591c:	1085883a 	add	r2,r2,r2
80115920:	1085883a 	add	r2,r2,r2
80115924:	1885883a 	add	r2,r3,r2
80115928:	10800017 	ldw	r2,0(r2)
8011592c:	10800017 	ldw	r2,0(r2)
80115930:	10800058 	cmpnei	r2,r2,1
80115934:	1000071e 	bne	r2,zero,80115954 <vPerformActionNFCRunning+0xb8>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
80115938:	e0bffc03 	ldbu	r2,-16(fp)
8011593c:	e0fffc03 	ldbu	r3,-16(fp)
80115940:	180f883a 	mov	r7,r3
80115944:	000d883a 	mov	r6,zero
80115948:	01402844 	movi	r5,161
8011594c:	1009883a 	mov	r4,r2
80115950:	0115a600 	call	80115a60 <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
80115954:	e0bffc03 	ldbu	r2,-16(fp)
80115958:	10800044 	addi	r2,r2,1
8011595c:	e0bffc05 	stb	r2,-16(fp)
80115960:	e0bffc03 	ldbu	r2,-16(fp)
80115964:	10800130 	cmpltui	r2,r2,4
80115968:	103fe91e 	bne	r2,zero,80115910 <__reset+0xfa0f5910>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
8011596c:	00000306 	br	8011597c <vPerformActionNFCRunning+0xe0>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
80115970:	0001883a 	nop
80115974:	00000106 	br	8011597c <vPerformActionNFCRunning+0xe0>
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
			}
			#endif		
			/* Do nothing for now */

			break;
80115978:	0001883a 	nop
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			}
			#endif	
			break;
	}
}
8011597c:	0001883a 	nop
80115980:	e037883a 	mov	sp,fp
80115984:	dfc00117 	ldw	ra,4(sp)
80115988:	df000017 	ldw	fp,0(sp)
8011598c:	dec00204 	addi	sp,sp,8
80115990:	f800283a 	ret

80115994 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80115994:	defff704 	addi	sp,sp,-36
80115998:	de00012e 	bgeu	sp,et,801159a0 <bSendCmdQToNFeeInst+0xc>
8011599c:	003b68fa 	trap	3
801159a0:	dfc00815 	stw	ra,32(sp)
801159a4:	df000715 	stw	fp,28(sp)
801159a8:	df000704 	addi	fp,sp,28
801159ac:	2011883a 	mov	r8,r4
801159b0:	2809883a 	mov	r4,r5
801159b4:	3007883a 	mov	r3,r6
801159b8:	3805883a 	mov	r2,r7
801159bc:	e23ffc05 	stb	r8,-16(fp)
801159c0:	e13ffd05 	stb	r4,-12(fp)
801159c4:	e0fffe05 	stb	r3,-8(fp)
801159c8:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
801159cc:	e0bffc03 	ldbu	r2,-16(fp)
801159d0:	10800444 	addi	r2,r2,17
801159d4:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
801159d8:	e0bffd03 	ldbu	r2,-12(fp)
801159dc:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
801159e0:	e0bffe03 	ldbu	r2,-8(fp)
801159e4:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
801159e8:	e0bfff03 	ldbu	r2,-4(fp)
801159ec:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
801159f0:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
801159f4:	e0fffc03 	ldbu	r3,-16(fp)
801159f8:	00a00574 	movhi	r2,32789
801159fc:	109f5404 	addi	r2,r2,32080
80115a00:	18c7883a 	add	r3,r3,r3
80115a04:	18c7883a 	add	r3,r3,r3
80115a08:	10c5883a 	add	r2,r2,r3
80115a0c:	10800017 	ldw	r2,0(r2)
80115a10:	e0fffb17 	ldw	r3,-20(fp)
80115a14:	180b883a 	mov	r5,r3
80115a18:	1009883a 	mov	r4,r2
80115a1c:	013940c0 	call	8013940c <OSQPost>
80115a20:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
80115a24:	e0bffa03 	ldbu	r2,-24(fp)
80115a28:	10000526 	beq	r2,zero,80115a40 <bSendCmdQToNFeeInst+0xac>
		vFailSendMsgAccessDMA( ucFeeInstP );
80115a2c:	e0bffc03 	ldbu	r2,-16(fp)
80115a30:	1009883a 	mov	r4,r2
80115a34:	011d9d80 	call	8011d9d8 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
80115a38:	e03ff915 	stw	zero,-28(fp)
80115a3c:	00000206 	br	80115a48 <bSendCmdQToNFeeInst+0xb4>
	} else {
		bSuccesL =  TRUE;
80115a40:	00800044 	movi	r2,1
80115a44:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
80115a48:	e0bff917 	ldw	r2,-28(fp)
}
80115a4c:	e037883a 	mov	sp,fp
80115a50:	dfc00117 	ldw	ra,4(sp)
80115a54:	df000017 	ldw	fp,0(sp)
80115a58:	dec00204 	addi	sp,sp,8
80115a5c:	f800283a 	ret

80115a60 <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80115a60:	defff704 	addi	sp,sp,-36
80115a64:	de00012e 	bgeu	sp,et,80115a6c <bSendCmdQToNFeeInst_Prio+0xc>
80115a68:	003b68fa 	trap	3
80115a6c:	dfc00815 	stw	ra,32(sp)
80115a70:	df000715 	stw	fp,28(sp)
80115a74:	df000704 	addi	fp,sp,28
80115a78:	2011883a 	mov	r8,r4
80115a7c:	2809883a 	mov	r4,r5
80115a80:	3007883a 	mov	r3,r6
80115a84:	3805883a 	mov	r2,r7
80115a88:	e23ffc05 	stb	r8,-16(fp)
80115a8c:	e13ffd05 	stb	r4,-12(fp)
80115a90:	e0fffe05 	stb	r3,-8(fp)
80115a94:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
80115a98:	e0bffc03 	ldbu	r2,-16(fp)
80115a9c:	10800444 	addi	r2,r2,17
80115aa0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
80115aa4:	e0bffd03 	ldbu	r2,-12(fp)
80115aa8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
80115aac:	e0bffe03 	ldbu	r2,-8(fp)
80115ab0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
80115ab4:	e0bfff03 	ldbu	r2,-4(fp)
80115ab8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
80115abc:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
80115ac0:	e0fffc03 	ldbu	r3,-16(fp)
80115ac4:	00a00574 	movhi	r2,32789
80115ac8:	109f5404 	addi	r2,r2,32080
80115acc:	18c7883a 	add	r3,r3,r3
80115ad0:	18c7883a 	add	r3,r3,r3
80115ad4:	10c5883a 	add	r2,r2,r3
80115ad8:	10800017 	ldw	r2,0(r2)
80115adc:	e0fffb17 	ldw	r3,-20(fp)
80115ae0:	180b883a 	mov	r5,r3
80115ae4:	1009883a 	mov	r4,r2
80115ae8:	013957c0 	call	8013957c <OSQPostFront>
80115aec:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
80115af0:	e0bffa03 	ldbu	r2,-24(fp)
80115af4:	10000526 	beq	r2,zero,80115b0c <bSendCmdQToNFeeInst_Prio+0xac>
		vFailSendMsgAccessDMA( ucFeeInstP );
80115af8:	e0bffc03 	ldbu	r2,-16(fp)
80115afc:	1009883a 	mov	r4,r2
80115b00:	011d9d80 	call	8011d9d8 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
80115b04:	e03ff915 	stw	zero,-28(fp)
80115b08:	00000206 	br	80115b14 <bSendCmdQToNFeeInst_Prio+0xb4>
	} else {
		bSuccesL =  TRUE;
80115b0c:	00800044 	movi	r2,1
80115b10:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
80115b14:	e0bff917 	ldw	r2,-28(fp)
}
80115b18:	e037883a 	mov	sp,fp
80115b1c:	dfc00117 	ldw	ra,4(sp)
80115b20:	df000017 	ldw	fp,0(sp)
80115b24:	dec00204 	addi	sp,sp,8
80115b28:	f800283a 	ret

80115b2c <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
80115b2c:	defff704 	addi	sp,sp,-36
80115b30:	de00012e 	bgeu	sp,et,80115b38 <vOutAckHandlerTask+0xc>
80115b34:	003b68fa 	trap	3
80115b38:	dfc00815 	stw	ra,32(sp)
80115b3c:	df000715 	stw	fp,28(sp)
80115b40:	df000704 	addi	fp,sp,28
80115b44:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
80115b48:	e03ffac5 	stb	zero,-21(fp)
80115b4c:	e03ffb05 	stb	zero,-20(fp)
80115b50:	e03ffb45 	stb	zero,-19(fp)
80115b54:	e03ffb85 	stb	zero,-18(fp)
80115b58:	e03ffbc5 	stb	zero,-17(fp)
80115b5c:	e03ffc05 	stb	zero,-16(fp)
80115b60:	e03ffc45 	stb	zero,-15(fp)
80115b64:	e03ffc85 	stb	zero,-14(fp)
80115b68:	e03ffcc5 	stb	zero,-13(fp)
80115b6c:	e03ffd05 	stb	zero,-12(fp)
80115b70:	e03ffd45 	stb	zero,-11(fp)
80115b74:	e03ffd85 	stb	zero,-10(fp)
80115b78:	e03ffdc5 	stb	zero,-9(fp)
80115b7c:	e03ffe05 	stb	zero,-8(fp)
80115b80:	e03ffe45 	stb	zero,-7(fp)
80115b84:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
80115b88:	e03ffa45 	stb	zero,-23(fp)
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
		debug(fp,"Out Ack Handler Task. (Task on)\n");
    }
	#endif

	eSenderAckState = sSAConfiguring;
80115b8c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
80115b90:	e0bff917 	ldw	r2,-28(fp)
80115b94:	10c00060 	cmpeqi	r3,r2,1
80115b98:	1800071e 	bne	r3,zero,80115bb8 <vOutAckHandlerTask+0x8c>
80115b9c:	0080032e 	bgeu	zero,r2,80115bac <vOutAckHandlerTask+0x80>
80115ba0:	108000a0 	cmpeqi	r2,r2,2
80115ba4:	1000471e 	bne	r2,zero,80115cc4 <vOutAckHandlerTask+0x198>
80115ba8:	00008c06 	br	80115ddc <vOutAckHandlerTask+0x2b0>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
80115bac:	00800044 	movi	r2,1
80115bb0:	e0bff915 	stw	r2,-28(fp)
				break;
80115bb4:	00008c06 	br	80115de8 <vOutAckHandlerTask+0x2bc>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
80115bb8:	00800044 	movi	r2,1
80115bbc:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
80115bc0:	d0a06c17 	ldw	r2,-32336(gp)
80115bc4:	e0fffa84 	addi	r3,fp,-22
80115bc8:	180d883a 	mov	r6,r3
80115bcc:	000b883a 	mov	r5,zero
80115bd0:	1009883a 	mov	r4,r2
80115bd4:	0139efc0 	call	80139efc <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
80115bd8:	e0bffa83 	ldbu	r2,-22(fp)
80115bdc:	10803fcc 	andi	r2,r2,255
80115be0:	1000361e 	bne	r2,zero,80115cbc <vOutAckHandlerTask+0x190>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
80115be4:	d0a07b17 	ldw	r2,-32276(gp)
80115be8:	e0fffa84 	addi	r3,fp,-22
80115bec:	180d883a 	mov	r6,r3
80115bf0:	000b883a 	mov	r5,zero
80115bf4:	1009883a 	mov	r4,r2
80115bf8:	0137ef00 	call	80137ef0 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
80115bfc:	e0bffa83 	ldbu	r2,-22(fp)
80115c00:	10803fcc 	andi	r2,r2,255
80115c04:	10002b1e 	bne	r2,zero,80115cb4 <vOutAckHandlerTask+0x188>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
80115c08:	e03ffa05 	stb	zero,-24(fp)
80115c0c:	00002206 	br	80115c98 <vOutAckHandlerTask+0x16c>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
80115c10:	e0fffa03 	ldbu	r3,-24(fp)
80115c14:	00a005b4 	movhi	r2,32790
80115c18:	10b98204 	addi	r2,r2,-6648
80115c1c:	18c7883a 	add	r3,r3,r3
80115c20:	18c7883a 	add	r3,r3,r3
80115c24:	10c5883a 	add	r2,r2,r3
80115c28:	10800003 	ldbu	r2,0(r2)
80115c2c:	10803fcc 	andi	r2,r2,255
80115c30:	1080201c 	xori	r2,r2,128
80115c34:	10bfe004 	addi	r2,r2,-128
80115c38:	10001426 	beq	r2,zero,80115c8c <vOutAckHandlerTask+0x160>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
80115c3c:	e0fffa03 	ldbu	r3,-24(fp)
80115c40:	00a005b4 	movhi	r2,32790
80115c44:	10b98204 	addi	r2,r2,-6648
80115c48:	18c7883a 	add	r3,r3,r3
80115c4c:	18c7883a 	add	r3,r3,r3
80115c50:	10c5883a 	add	r2,r2,r3
80115c54:	10c0000b 	ldhu	r3,0(r2)
80115c58:	d0e0658d 	sth	r3,-32362(gp)
80115c5c:	1080008b 	ldhu	r2,2(r2)
80115c60:	d0a0660d 	sth	r2,-32360(gp)
                                eSenderAckState = sSASending;
80115c64:	00800084 	movi	r2,2
80115c68:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
80115c6c:	e0fffa03 	ldbu	r3,-24(fp)
80115c70:	00a005b4 	movhi	r2,32790
80115c74:	10b98204 	addi	r2,r2,-6648
80115c78:	18c7883a 	add	r3,r3,r3
80115c7c:	18c7883a 	add	r3,r3,r3
80115c80:	10c5883a 	add	r2,r2,r3
80115c84:	10000005 	stb	zero,0(r2)
                                break;
80115c88:	00000606 	br	80115ca4 <vOutAckHandlerTask+0x178>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
80115c8c:	e0bffa03 	ldbu	r2,-24(fp)
80115c90:	10800044 	addi	r2,r2,1
80115c94:	e0bffa05 	stb	r2,-24(fp)
80115c98:	e0bffa03 	ldbu	r2,-24(fp)
80115c9c:	10800230 	cmpltui	r2,r2,8
80115ca0:	103fdb1e 	bne	r2,zero,80115c10 <__reset+0xfa0f5c10>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
80115ca4:	d0a07b17 	ldw	r2,-32276(gp)
80115ca8:	1009883a 	mov	r4,r2
80115cac:	01384940 	call	80138494 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
80115cb0:	00004d06 	br	80115de8 <vOutAckHandlerTask+0x2bc>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
80115cb4:	011d0000 	call	8011d000 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
80115cb8:	00004b06 	br	80115de8 <vOutAckHandlerTask+0x2bc>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
80115cbc:	011cfd80 	call	8011cfd8 <vFailGetCountSemaphoreSenderTask>
                }

                break;
80115cc0:	00004906 	br	80115de8 <vOutAckHandlerTask+0x2bc>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
80115cc4:	d0a06583 	ldbu	r2,-32362(gp)
80115cc8:	10803fcc 	andi	r2,r2,255
80115ccc:	1080201c 	xori	r2,r2,128
80115cd0:	10bfe004 	addi	r2,r2,-128
80115cd4:	108008e0 	cmpeqi	r2,r2,35
80115cd8:	1000201e 	bne	r2,zero,80115d5c <vOutAckHandlerTask+0x230>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
80115cdc:	d0a065c3 	ldbu	r2,-32361(gp)
80115ce0:	10c03fcc 	andi	r3,r2,255
80115ce4:	18c0201c 	xori	r3,r3,128
80115ce8:	18ffe004 	addi	r3,r3,-128
80115cec:	d0a0660b 	ldhu	r2,-32360(gp)
80115cf0:	113fffcc 	andi	r4,r2,65535
80115cf4:	e0bffac4 	addi	r2,fp,-21
80115cf8:	200f883a 	mov	r7,r4
80115cfc:	180d883a 	mov	r6,r3
80115d00:	01600534 	movhi	r5,32788
80115d04:	295d5304 	addi	r5,r5,30028
80115d08:	1009883a 	mov	r4,r2
80115d0c:	01218940 	call	80121894 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
80115d10:	e0bffac4 	addi	r2,fp,-21
80115d14:	1009883a 	mov	r4,r2
80115d18:	01219540 	call	80121954 <strlen>
80115d1c:	1007883a 	mov	r3,r2
80115d20:	e0bffac4 	addi	r2,fp,-21
80115d24:	180b883a 	mov	r5,r3
80115d28:	1009883a 	mov	r4,r2
80115d2c:	011cd040 	call	8011cd04 <ucCrc8wInit>
80115d30:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
80115d34:	e13ffa43 	ldbu	r4,-23(fp)
80115d38:	e0fffac4 	addi	r3,fp,-21
80115d3c:	e0bffac4 	addi	r2,fp,-21
80115d40:	200f883a 	mov	r7,r4
80115d44:	180d883a 	mov	r6,r3
80115d48:	01600534 	movhi	r5,32788
80115d4c:	295d5504 	addi	r5,r5,30036
80115d50:	1009883a 	mov	r4,r2
80115d54:	01218940 	call	80121894 <sprintf>
80115d58:	00000c06 	br	80115d8c <vOutAckHandlerTask+0x260>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
80115d5c:	e0bffac4 	addi	r2,fp,-21
80115d60:	00c008c4 	movi	r3,35
80115d64:	10c00005 	stb	r3,0(r2)
80115d68:	00c01f04 	movi	r3,124
80115d6c:	10c00045 	stb	r3,1(r2)
80115d70:	00c00d44 	movi	r3,53
80115d74:	10c00085 	stb	r3,2(r2)
80115d78:	00c00d04 	movi	r3,52
80115d7c:	10c000c5 	stb	r3,3(r2)
80115d80:	00c00ec4 	movi	r3,59
80115d84:	10c00105 	stb	r3,4(r2)
80115d88:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
80115d8c:	d0a07d17 	ldw	r2,-32268(gp)
80115d90:	e0fffa84 	addi	r3,fp,-22
80115d94:	180d883a 	mov	r6,r3
80115d98:	01401904 	movi	r5,100
80115d9c:	1009883a 	mov	r4,r2
80115da0:	0137ef00 	call	80137ef0 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
80115da4:	e0bffa83 	ldbu	r2,-22(fp)
80115da8:	10803fcc 	andi	r2,r2,255
80115dac:	1000071e 	bne	r2,zero,80115dcc <vOutAckHandlerTask+0x2a0>
                    puts(cBufferAck);
80115db0:	e0bffac4 	addi	r2,fp,-21
80115db4:	1009883a 	mov	r4,r2
80115db8:	01217a40 	call	801217a4 <puts>
                    OSMutexPost(xTxUARTMutex);
80115dbc:	d0a07d17 	ldw	r2,-32268(gp)
80115dc0:	1009883a 	mov	r4,r2
80115dc4:	01384940 	call	80138494 <OSMutexPost>
80115dc8:	00000106 	br	80115dd0 <vOutAckHandlerTask+0x2a4>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
80115dcc:	011d0780 	call	8011d078 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
80115dd0:	00800044 	movi	r2,1
80115dd4:	e0bff915 	stw	r2,-28(fp)
                
				break;
80115dd8:	00000306 	br	80115de8 <vOutAckHandlerTask+0x2bc>
            	#if DEBUG_ON
				if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
				}
	            #endif
                eSenderAckState = sSAGettingACK;
80115ddc:	00800044 	movi	r2,1
80115de0:	e0bff915 	stw	r2,-28(fp)
				break;
80115de4:	0001883a 	nop
		}
	}
80115de8:	003f6906 	br	80115b90 <__reset+0xfa0f5b90>

80115dec <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
80115dec:	defffa04 	addi	sp,sp,-24
80115df0:	de00012e 	bgeu	sp,et,80115df8 <vParserCommTask+0xc>
80115df4:	003b68fa 	trap	3
80115df8:	dfc00515 	stw	ra,20(sp)
80115dfc:	df000415 	stw	fp,16(sp)
80115e00:	df000404 	addi	fp,sp,16
80115e04:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
80115e08:	e03ffd15 	stw	zero,-12(fp)
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
			debug(fp,"Parser Comm Task. (Task on)\n");
		}
    #endif

	eParserMode = sConfiguring;
80115e0c:	e03ffc15 	stw	zero,-16(fp)

	for(;;){

		switch (eParserMode) {
80115e10:	e0bffc17 	ldw	r2,-16(fp)
80115e14:	10800168 	cmpgeui	r2,r2,5
80115e18:	1001b21e 	bne	r2,zero,801164e4 <vParserCommTask+0x6f8>
80115e1c:	e0bffc17 	ldw	r2,-16(fp)
80115e20:	100690ba 	slli	r3,r2,2
80115e24:	00a00474 	movhi	r2,32785
80115e28:	10978e04 	addi	r2,r2,24120
80115e2c:	1885883a 	add	r2,r3,r2
80115e30:	10800017 	ldw	r2,0(r2)
80115e34:	1000683a 	jmp	r2
80115e38:	80115e4c 	andi	zero,r16,17785
80115e3c:	80115e58 	cmpnei	zero,r16,17785
80115e40:	80115eec 	andhi	zero,r16,17787
80115e44:	80115fb0 	cmpltui	zero,r16,17790
80115e48:	80115ff4 	orhi	zero,r16,17791
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
80115e4c:	00800044 	movi	r2,1
80115e50:	e0bffc15 	stw	r2,-16(fp)
				break;
80115e54:	0001a606 	br	801164f0 <vParserCommTask+0x704>
			case sWaitingMessage:

				bSuccess = FALSE;
80115e58:	e03ffd15 	stw	zero,-12(fp)
				eParserMode = sWaitingMessage;
80115e5c:	00800044 	movi	r2,1
80115e60:	e0bffc15 	stw	r2,-16(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
80115e64:	d0a06e17 	ldw	r2,-32328(gp)
80115e68:	e0fffe84 	addi	r3,fp,-6
80115e6c:	180d883a 	mov	r6,r3
80115e70:	000b883a 	mov	r5,zero
80115e74:	1009883a 	mov	r4,r2
80115e78:	0139efc0 	call	80139efc <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
80115e7c:	e0bffe83 	ldbu	r2,-6(fp)
80115e80:	10803fcc 	andi	r2,r2,255
80115e84:	1000171e 	bne	r2,zero,80115ee4 <vParserCommTask+0xf8>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
80115e88:	01200574 	movhi	r4,32789
80115e8c:	21294304 	addi	r4,r4,-23284
80115e90:	01164f40 	call	801164f4 <getPreParsedPacket>
80115e94:	e0bffd15 	stw	r2,-12(fp)
					if (bSuccess == TRUE) {
80115e98:	e0bffd17 	ldw	r2,-12(fp)
80115e9c:	10800058 	cmpnei	r2,r2,1
80115ea0:	10000e1e 	bne	r2,zero,80115edc <vParserCommTask+0xf0>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
80115ea4:	00a00574 	movhi	r2,32789
80115ea8:	10a94304 	addi	r2,r2,-23284
80115eac:	10800103 	ldbu	r2,4(r2)
80115eb0:	10803fcc 	andi	r2,r2,255
80115eb4:	1080201c 	xori	r2,r2,128
80115eb8:	10bfe004 	addi	r2,r2,-128
80115ebc:	10800858 	cmpnei	r2,r2,33
80115ec0:	1000031e 	bne	r2,zero,80115ed0 <vParserCommTask+0xe4>
							eParserMode = sReplyParsing;
80115ec4:	008000c4 	movi	r2,3
80115ec8:	e0bffc15 	stw	r2,-16(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
80115ecc:	00018806 	br	801164f0 <vParserCommTask+0x704>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
80115ed0:	00800084 	movi	r2,2
80115ed4:	e0bffc15 	stw	r2,-16(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
80115ed8:	00018506 	br	801164f0 <vParserCommTask+0x704>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
80115edc:	011d2dc0 	call	8011d2dc <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
80115ee0:	00018306 	br	801164f0 <vParserCommTask+0x704>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
80115ee4:	011d28c0 	call	8011d28c <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
80115ee8:	00018106 	br	801164f0 <vParserCommTask+0x704>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
80115eec:	00a00574 	movhi	r2,32789
80115ef0:	10a94304 	addi	r2,r2,-23284
80115ef4:	10800143 	ldbu	r2,5(r2)
80115ef8:	10803fcc 	andi	r2,r2,255
80115efc:	1080201c 	xori	r2,r2,128
80115f00:	10bfe004 	addi	r2,r2,-128
80115f04:	10c010e0 	cmpeqi	r3,r2,67
80115f08:	1800031e 	bne	r3,zero,80115f18 <vParserCommTask+0x12c>
80115f0c:	10801420 	cmpeqi	r2,r2,80
80115f10:	1000051e 	bne	r2,zero,80115f28 <vParserCommTask+0x13c>
80115f14:	00002206 	br	80115fa0 <vParserCommTask+0x1b4>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
80115f18:	011a0c00 	call	8011a0c0 <vSendEthConf>
						eParserMode = sWaitingMessage;
80115f1c:	00800044 	movi	r2,1
80115f20:	e0bffc15 	stw	r2,-16(fp)
						break;
80115f24:	00002106 	br	80115fac <vParserCommTask+0x1c0>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
							debug(fp, cPUSDebug );
                    	}
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
80115f28:	00a00574 	movhi	r2,32789
80115f2c:	10a94304 	addi	r2,r2,-23284
80115f30:	10c0030b 	ldhu	r3,12(r2)
80115f34:	00a00574 	movhi	r2,32789
80115f38:	10a95604 	addi	r2,r2,-23208
80115f3c:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
80115f40:	00a00574 	movhi	r2,32789
80115f44:	10a94304 	addi	r2,r2,-23284
80115f48:	10c0038b 	ldhu	r3,14(r2)
80115f4c:	00a00574 	movhi	r2,32789
80115f50:	10a95604 	addi	r2,r2,-23208
80115f54:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
80115f58:	00a00574 	movhi	r2,32789
80115f5c:	10a94304 	addi	r2,r2,-23284
80115f60:	10c0040b 	ldhu	r3,16(r2)
80115f64:	00a00574 	movhi	r2,32789
80115f68:	10a95604 	addi	r2,r2,-23208
80115f6c:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
80115f70:	00a00574 	movhi	r2,32789
80115f74:	10a94304 	addi	r2,r2,-23284
80115f78:	10c0048b 	ldhu	r3,18(r2)
80115f7c:	00a00574 	movhi	r2,32789
80115f80:	10a95604 	addi	r2,r2,-23208
80115f84:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
80115f88:	00a00574 	movhi	r2,32789
80115f8c:	10a95604 	addi	r2,r2,-23208
80115f90:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
80115f94:	00800104 	movi	r2,4
80115f98:	e0bffc15 	stw	r2,-16(fp)
                        break;						
80115f9c:	00000306 	br	80115fac <vParserCommTask+0x1c0>
					default:
						eParserMode = sWaitingMessage;
80115fa0:	00800044 	movi	r2,1
80115fa4:	e0bffc15 	stw	r2,-16(fp)
						break;
80115fa8:	0001883a 	nop
				}
				break;
80115fac:	00015006 	br	801164f0 <vParserCommTask+0x704>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
80115fb0:	00800044 	movi	r2,1
80115fb4:	e0bffc15 	stw	r2,-16(fp)
                switch ( xTcPusL.usiType )
80115fb8:	00a00574 	movhi	r2,32789
80115fbc:	10a95604 	addi	r2,r2,-23208
80115fc0:	1080030b 	ldhu	r2,12(r2)
80115fc4:	10bfffcc 	andi	r2,r2,65535
80115fc8:	10c01220 	cmpeqi	r3,r2,72
80115fcc:	1800051e 	bne	r3,zero,80115fe4 <vParserCommTask+0x1f8>
80115fd0:	108014e0 	cmpeqi	r2,r2,83
80115fd4:	1000051e 	bne	r2,zero,80115fec <vParserCommTask+0x200>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
80115fd8:	00800044 	movi	r2,1
80115fdc:	e0bffc15 	stw	r2,-16(fp)
                        break;
80115fe0:	00000306 	br	80115ff0 <vParserCommTask+0x204>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
80115fe4:	0001883a 	nop
80115fe8:	00014106 	br	801164f0 <vParserCommTask+0x704>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
80115fec:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
80115ff0:	00013f06 	br	801164f0 <vParserCommTask+0x704>
			case sPusHandling:
				eParserMode = sWaitingMessage;
80115ff4:	00800044 	movi	r2,1
80115ff8:	e0bffc15 	stw	r2,-16(fp)
				
                switch ( xTcPusL.usiType )
80115ffc:	00a00574 	movhi	r2,32789
80116000:	10a95604 	addi	r2,r2,-23208
80116004:	1080030b 	ldhu	r2,12(r2)
80116008:	10bfffcc 	andi	r2,r2,65535
8011600c:	10c03ea0 	cmpeqi	r3,r2,250
80116010:	18001b1e 	bne	r3,zero,80116080 <vParserCommTask+0x294>
80116014:	10c03ec8 	cmpgei	r3,r2,251
80116018:	1800031e 	bne	r3,zero,80116028 <vParserCommTask+0x23c>
8011601c:	10800460 	cmpeqi	r2,r2,17
80116020:	1000061e 	bne	r2,zero,8011603c <vParserCommTask+0x250>
80116024:	00012a06 	br	801164d0 <vParserCommTask+0x6e4>
80116028:	10c03ee0 	cmpeqi	r3,r2,251
8011602c:	18003e1e 	bne	r3,zero,80116128 <vParserCommTask+0x33c>
80116030:	10803f20 	cmpeqi	r2,r2,252
80116034:	1000701e 	bne	r2,zero,801161f8 <vParserCommTask+0x40c>
80116038:	00012506 	br	801164d0 <vParserCommTask+0x6e4>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
8011603c:	00a00574 	movhi	r2,32789
80116040:	10a95604 	addi	r2,r2,-23208
80116044:	1080038b 	ldhu	r2,14(r2)
80116048:	10bfffcc 	andi	r2,r2,65535
8011604c:	10800060 	cmpeqi	r2,r2,1
80116050:	10000726 	beq	r2,zero,80116070 <vParserCommTask+0x284>
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
								}
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
80116054:	00a00574 	movhi	r2,32789
80116058:	10a95604 	addi	r2,r2,-23208
8011605c:	1080040b 	ldhu	r2,16(r2)
80116060:	10bfffcc 	andi	r2,r2,65535
80116064:	1009883a 	mov	r4,r2
80116068:	011aac00 	call	8011aac0 <vTMPusTestConnection>

								break;
8011606c:	00000306 	br	8011607c <vParserCommTask+0x290>
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
									debug(fp, cPUSDebug );
								}
								#endif
								eParserMode = sWaitingMessage;
80116070:	00800044 	movi	r2,1
80116074:	e0bffc15 	stw	r2,-16(fp)
								break;
80116078:	0001883a 	nop
						}
                        break;
8011607c:	00011806 	br	801164e0 <vParserCommTask+0x6f4>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
80116080:	00a00574 	movhi	r2,32789
80116084:	10a95604 	addi	r2,r2,-23208
80116088:	1080038b 	ldhu	r2,14(r2)
8011608c:	10bfffcc 	andi	r2,r2,65535
80116090:	10c00f20 	cmpeqi	r3,r2,60
80116094:	1800131e 	bne	r3,zero,801160e4 <vParserCommTask+0x2f8>
80116098:	10c00f48 	cmpgei	r3,r2,61
8011609c:	1800031e 	bne	r3,zero,801160ac <vParserCommTask+0x2c0>
801160a0:	10800ee0 	cmpeqi	r2,r2,59
801160a4:	1000061e 	bne	r2,zero,801160c0 <vParserCommTask+0x2d4>
801160a8:	00001b06 	br	80116118 <vParserCommTask+0x32c>
801160ac:	10c00f60 	cmpeqi	r3,r2,61
801160b0:	1800101e 	bne	r3,zero,801160f4 <vParserCommTask+0x308>
801160b4:	10800fa0 	cmpeqi	r2,r2,62
801160b8:	1000121e 	bne	r2,zero,80116104 <vParserCommTask+0x318>
801160bc:	00001606 	br	80116118 <vParserCommTask+0x32c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
								}
								#endif
								vSendReset();
801160c0:	011a4680 	call	8011a468 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
801160c4:	000f883a 	mov	r7,zero
801160c8:	018000c4 	movi	r6,3
801160cc:	000b883a 	mov	r5,zero
801160d0:	0009883a 	mov	r4,zero
801160d4:	013be940 	call	8013be94 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
801160d8:	0104e204 	movi	r4,5000
801160dc:	010cb180 	call	8010cb18 <vRstcSimucamReset>

								break;
801160e0:	00001006 	br	80116124 <vParserCommTask+0x338>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
801160e4:	01200574 	movhi	r4,32789
801160e8:	21295604 	addi	r4,r4,-23208
801160ec:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

								break;
801160f0:	00000c06 	br	80116124 <vParserCommTask+0x338>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
801160f4:	01200574 	movhi	r4,32789
801160f8:	21295604 	addi	r4,r4,-23208
801160fc:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

								break;
80116100:	00000806 	br	80116124 <vParserCommTask+0x338>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
								}
								#endif
								vSendTurnOff();
80116104:	011a3500 	call	8011a350 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
80116108:	01200574 	movhi	r4,32789
8011610c:	21295604 	addi	r4,r4,-23208
80116110:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

								break;
80116114:	00000306 	br	80116124 <vParserCommTask+0x338>
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
									debug(fp, cPUSDebug );
								}
								#endif							
								eParserMode = sWaitingMessage;
80116118:	00800044 	movi	r2,1
8011611c:	e0bffc15 	stw	r2,-16(fp)
								break;
80116120:	0001883a 	nop
						}
                        break;
80116124:	0000ee06 	br	801164e0 <vParserCommTask+0x6f4>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
80116128:	00a00574 	movhi	r2,32789
8011612c:	10a94304 	addi	r2,r2,-23284
80116130:	1080050b 	ldhu	r2,20(r2)
80116134:	e0bffe0d 	sth	r2,-8(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
80116138:	e0bffe0b 	ldhu	r2,-8(fp)
8011613c:	10800168 	cmpgeui	r2,r2,5
80116140:	1000e61e 	bne	r2,zero,801164dc <vParserCommTask+0x6f0>
								debug(fp, cPUSDebug );
							}
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
80116144:	00a00574 	movhi	r2,32789
80116148:	10a95604 	addi	r2,r2,-23208
8011614c:	10800483 	ldbu	r2,18(r2)
80116150:	10c03fcc 	andi	r3,r2,255
80116154:	00a00574 	movhi	r2,32789
80116158:	10a95604 	addi	r2,r2,-23208
8011615c:	18c00284 	addi	r3,r3,10
80116160:	18c7883a 	add	r3,r3,r3
80116164:	10c5883a 	add	r2,r2,r3
80116168:	e0fffe0b 	ldhu	r3,-8(fp)
8011616c:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
80116170:	00a00574 	movhi	r2,32789
80116174:	10a95604 	addi	r2,r2,-23208
80116178:	10800483 	ldbu	r2,18(r2)
8011617c:	10800044 	addi	r2,r2,1
80116180:	1007883a 	mov	r3,r2
80116184:	00a00574 	movhi	r2,32789
80116188:	10a95604 	addi	r2,r2,-23208
8011618c:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
80116190:	00a00574 	movhi	r2,32789
80116194:	10a95604 	addi	r2,r2,-23208
80116198:	1080038b 	ldhu	r2,14(r2)
8011619c:	10bfffcc 	andi	r2,r2,65535
801161a0:	10c000a0 	cmpeqi	r3,r2,2
801161a4:	1800081e 	bne	r3,zero,801161c8 <vParserCommTask+0x3dc>
801161a8:	10c00160 	cmpeqi	r3,r2,5
801161ac:	18000a1e 	bne	r3,zero,801161d8 <vParserCommTask+0x3ec>
801161b0:	10800060 	cmpeqi	r2,r2,1
801161b4:	10000c26 	beq	r2,zero,801161e8 <vParserCommTask+0x3fc>
										memset(cPUSDebug,0,128);
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
										debug(fp, cPUSDebug );
									}
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
801161b8:	01200574 	movhi	r4,32789
801161bc:	21295604 	addi	r4,r4,-23208
801161c0:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

									break;
801161c4:	00000b06 	br	801161f4 <vParserCommTask+0x408>
										memset(cPUSDebug,0,128);
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
										debug(fp, cPUSDebug );
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
801161c8:	01200574 	movhi	r4,32789
801161cc:	21295604 	addi	r4,r4,-23208
801161d0:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

									break;
801161d4:	00000706 	br	801161f4 <vParserCommTask+0x408>
										memset(cPUSDebug,0,128);
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
										debug(fp, cPUSDebug );
									}
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
801161d8:	01200574 	movhi	r4,32789
801161dc:	21295604 	addi	r4,r4,-23208
801161e0:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

									break;
801161e4:	00000306 	br	801161f4 <vParserCommTask+0x408>
										memset(cPUSDebug,0,128);
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
										debug(fp, cPUSDebug );
									}
									#endif							
									eParserMode = sWaitingMessage;
801161e8:	00800044 	movi	r2,1
801161ec:	e0bffc15 	stw	r2,-16(fp)
									break;
801161f0:	0001883a 	nop
							}
						}
                        break;
801161f4:	0000b906 	br	801164dc <vParserCommTask+0x6f0>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
801161f8:	00a00574 	movhi	r2,32789
801161fc:	10a94304 	addi	r2,r2,-23284
80116200:	1080050b 	ldhu	r2,20(r2)
80116204:	e0bffe0d 	sth	r2,-8(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
80116208:	00a00574 	movhi	r2,32789
8011620c:	10a95604 	addi	r2,r2,-23208
80116210:	10800483 	ldbu	r2,18(r2)
80116214:	10c03fcc 	andi	r3,r2,255
80116218:	00a00574 	movhi	r2,32789
8011621c:	10a95604 	addi	r2,r2,-23208
80116220:	18c00284 	addi	r3,r3,10
80116224:	18c7883a 	add	r3,r3,r3
80116228:	10c5883a 	add	r2,r2,r3
8011622c:	e0fffe0b 	ldhu	r3,-8(fp)
80116230:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
80116234:	00a00574 	movhi	r2,32789
80116238:	10a95604 	addi	r2,r2,-23208
8011623c:	10800483 	ldbu	r2,18(r2)
80116240:	10800044 	addi	r2,r2,1
80116244:	1007883a 	mov	r3,r2
80116248:	00a00574 	movhi	r2,32789
8011624c:	10a95604 	addi	r2,r2,-23208
80116250:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
80116254:	00a00574 	movhi	r2,32789
80116258:	10a95604 	addi	r2,r2,-23208
8011625c:	1080038b 	ldhu	r2,14(r2)
80116260:	10bfffcc 	andi	r2,r2,65535
80116264:	10c000e0 	cmpeqi	r3,r2,3
80116268:	18000a1e 	bne	r3,zero,80116294 <vParserCommTask+0x4a8>
8011626c:	10c00108 	cmpgei	r3,r2,4
80116270:	1800031e 	bne	r3,zero,80116280 <vParserCommTask+0x494>
80116274:	108000a0 	cmpeqi	r2,r2,2
80116278:	1000121e 	bne	r2,zero,801162c4 <vParserCommTask+0x4d8>
8011627c:	00009006 	br	801164c0 <vParserCommTask+0x6d4>
80116280:	10c00120 	cmpeqi	r3,r2,4
80116284:	1800071e 	bne	r3,zero,801162a4 <vParserCommTask+0x4b8>
80116288:	10800160 	cmpeqi	r2,r2,5
8011628c:	1000091e 	bne	r2,zero,801162b4 <vParserCommTask+0x4c8>
80116290:	00008b06 	br	801164c0 <vParserCommTask+0x6d4>
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
									debug(fp, cPUSDebug );
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
80116294:	01200574 	movhi	r4,32789
80116298:	21295604 	addi	r4,r4,-23208
8011629c:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

								break;
801162a0:	00008a06 	br	801164cc <vParserCommTask+0x6e0>
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
									debug(fp, cPUSDebug );
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
801162a4:	01200574 	movhi	r4,32789
801162a8:	21295604 	addi	r4,r4,-23208
801162ac:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

								break;
801162b0:	00008606 	br	801164cc <vParserCommTask+0x6e0>
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
									debug(fp, cPUSDebug );
								}
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
801162b4:	01200574 	movhi	r4,32789
801162b8:	21295604 	addi	r4,r4,-23208
801162bc:	011660c0 	call	8011660c <bSendMessagePUStoMebTask>

								break;
801162c0:	00008206 	br	801164cc <vParserCommTask+0x6e0>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
801162c4:	00a00574 	movhi	r2,32789
801162c8:	10a95604 	addi	r2,r2,-23208
801162cc:	10800483 	ldbu	r2,18(r2)
801162d0:	10c03fcc 	andi	r3,r2,255
801162d4:	00a00574 	movhi	r2,32789
801162d8:	10a94304 	addi	r2,r2,-23284
801162dc:	1100058b 	ldhu	r4,22(r2)
801162e0:	00a00574 	movhi	r2,32789
801162e4:	10a95604 	addi	r2,r2,-23208
801162e8:	18c00284 	addi	r3,r3,10
801162ec:	18c7883a 	add	r3,r3,r3
801162f0:	10c5883a 	add	r2,r2,r3
801162f4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
801162f8:	00a00574 	movhi	r2,32789
801162fc:	10a95604 	addi	r2,r2,-23208
80116300:	10800483 	ldbu	r2,18(r2)
80116304:	10800044 	addi	r2,r2,1
80116308:	1007883a 	mov	r3,r2
8011630c:	00a00574 	movhi	r2,32789
80116310:	10a95604 	addi	r2,r2,-23208
80116314:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
80116318:	00a00574 	movhi	r2,32789
8011631c:	10a95604 	addi	r2,r2,-23208
80116320:	10800483 	ldbu	r2,18(r2)
80116324:	10c03fcc 	andi	r3,r2,255
80116328:	00a00574 	movhi	r2,32789
8011632c:	10a94304 	addi	r2,r2,-23284
80116330:	1100060b 	ldhu	r4,24(r2)
80116334:	00a00574 	movhi	r2,32789
80116338:	10a95604 	addi	r2,r2,-23208
8011633c:	18c00284 	addi	r3,r3,10
80116340:	18c7883a 	add	r3,r3,r3
80116344:	10c5883a 	add	r2,r2,r3
80116348:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8011634c:	00a00574 	movhi	r2,32789
80116350:	10a95604 	addi	r2,r2,-23208
80116354:	10800483 	ldbu	r2,18(r2)
80116358:	10800044 	addi	r2,r2,1
8011635c:	1007883a 	mov	r3,r2
80116360:	00a00574 	movhi	r2,32789
80116364:	10a95604 	addi	r2,r2,-23208
80116368:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
8011636c:	00a00574 	movhi	r2,32789
80116370:	10a95604 	addi	r2,r2,-23208
80116374:	10800483 	ldbu	r2,18(r2)
80116378:	10c03fcc 	andi	r3,r2,255
8011637c:	00a00574 	movhi	r2,32789
80116380:	10a94304 	addi	r2,r2,-23284
80116384:	1100068b 	ldhu	r4,26(r2)
80116388:	00a00574 	movhi	r2,32789
8011638c:	10a95604 	addi	r2,r2,-23208
80116390:	18c00284 	addi	r3,r3,10
80116394:	18c7883a 	add	r3,r3,r3
80116398:	10c5883a 	add	r2,r2,r3
8011639c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
801163a0:	00a00574 	movhi	r2,32789
801163a4:	10a95604 	addi	r2,r2,-23208
801163a8:	10800483 	ldbu	r2,18(r2)
801163ac:	10800044 	addi	r2,r2,1
801163b0:	1007883a 	mov	r3,r2
801163b4:	00a00574 	movhi	r2,32789
801163b8:	10a95604 	addi	r2,r2,-23208
801163bc:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
801163c0:	00a00574 	movhi	r2,32789
801163c4:	10a95604 	addi	r2,r2,-23208
801163c8:	10800483 	ldbu	r2,18(r2)
801163cc:	10c03fcc 	andi	r3,r2,255
801163d0:	00a00574 	movhi	r2,32789
801163d4:	10a94304 	addi	r2,r2,-23284
801163d8:	1100070b 	ldhu	r4,28(r2)
801163dc:	00a00574 	movhi	r2,32789
801163e0:	10a95604 	addi	r2,r2,-23208
801163e4:	18c00284 	addi	r3,r3,10
801163e8:	18c7883a 	add	r3,r3,r3
801163ec:	10c5883a 	add	r2,r2,r3
801163f0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
801163f4:	00a00574 	movhi	r2,32789
801163f8:	10a95604 	addi	r2,r2,-23208
801163fc:	10800483 	ldbu	r2,18(r2)
80116400:	10800044 	addi	r2,r2,1
80116404:	1007883a 	mov	r3,r2
80116408:	00a00574 	movhi	r2,32789
8011640c:	10a95604 	addi	r2,r2,-23208
80116410:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
80116414:	00a00574 	movhi	r2,32789
80116418:	10a95604 	addi	r2,r2,-23208
8011641c:	10800483 	ldbu	r2,18(r2)
80116420:	10c03fcc 	andi	r3,r2,255
80116424:	00a00574 	movhi	r2,32789
80116428:	10a94304 	addi	r2,r2,-23284
8011642c:	1100078b 	ldhu	r4,30(r2)
80116430:	00a00574 	movhi	r2,32789
80116434:	10a95604 	addi	r2,r2,-23208
80116438:	18c00284 	addi	r3,r3,10
8011643c:	18c7883a 	add	r3,r3,r3
80116440:	10c5883a 	add	r2,r2,r3
80116444:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
80116448:	00a00574 	movhi	r2,32789
8011644c:	10a95604 	addi	r2,r2,-23208
80116450:	10800483 	ldbu	r2,18(r2)
80116454:	10800044 	addi	r2,r2,1
80116458:	1007883a 	mov	r3,r2
8011645c:	00a00574 	movhi	r2,32789
80116460:	10a95604 	addi	r2,r2,-23208
80116464:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
80116468:	00a00574 	movhi	r2,32789
8011646c:	10a95604 	addi	r2,r2,-23208
80116470:	10800483 	ldbu	r2,18(r2)
80116474:	10c03fcc 	andi	r3,r2,255
80116478:	00a00574 	movhi	r2,32789
8011647c:	10a94304 	addi	r2,r2,-23284
80116480:	1100080b 	ldhu	r4,32(r2)
80116484:	00a00574 	movhi	r2,32789
80116488:	10a95604 	addi	r2,r2,-23208
8011648c:	18c00284 	addi	r3,r3,10
80116490:	18c7883a 	add	r3,r3,r3
80116494:	10c5883a 	add	r2,r2,r3
80116498:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8011649c:	00a00574 	movhi	r2,32789
801164a0:	10a95604 	addi	r2,r2,-23208
801164a4:	10800483 	ldbu	r2,18(r2)
801164a8:	10800044 	addi	r2,r2,1
801164ac:	1007883a 	mov	r3,r2
801164b0:	00a00574 	movhi	r2,32789
801164b4:	10a95604 	addi	r2,r2,-23208
801164b8:	10c00485 	stb	r3,18(r2)
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
									debug(fp, cPUSDebug );
								}
								#endif

								break;
801164bc:	00000306 	br	801164cc <vParserCommTask+0x6e0>
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
									debug(fp, cPUSDebug );
								}
								#endif							
								eParserMode = sWaitingMessage;
801164c0:	00800044 	movi	r2,1
801164c4:	e0bffc15 	stw	r2,-16(fp)
								break;
801164c8:	0001883a 	nop
						}
                        break;
801164cc:	00000406 	br	801164e0 <vParserCommTask+0x6f4>
                    default:
						eParserMode = sWaitingMessage;
801164d0:	00800044 	movi	r2,1
801164d4:	e0bffc15 	stw	r2,-16(fp)
                        break;
801164d8:	00000106 	br	801164e0 <vParserCommTask+0x6f4>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
801164dc:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;				
801164e0:	00000306 	br	801164f0 <vParserCommTask+0x704>
			default:
				eParserMode = sWaitingMessage;
801164e4:	00800044 	movi	r2,1
801164e8:	e0bffc15 	stw	r2,-16(fp)
				break;
801164ec:	0001883a 	nop
		}
	}
801164f0:	003e4706 	br	80115e10 <__reset+0xfa0f5e10>

801164f4 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
801164f4:	defffb04 	addi	sp,sp,-20
801164f8:	de00012e 	bgeu	sp,et,80116500 <getPreParsedPacket+0xc>
801164fc:	003b68fa 	trap	3
80116500:	dfc00415 	stw	ra,16(sp)
80116504:	df000315 	stw	fp,12(sp)
80116508:	df000304 	addi	fp,sp,12
8011650c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
80116510:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
80116514:	d0a07417 	ldw	r2,-32304(gp)
80116518:	e0fffe44 	addi	r3,fp,-7
8011651c:	180d883a 	mov	r6,r3
80116520:	000b883a 	mov	r5,zero
80116524:	1009883a 	mov	r4,r2
80116528:	0137ef00 	call	80137ef0 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
8011652c:	e0bffe43 	ldbu	r2,-7(fp)
80116530:	10803fcc 	andi	r2,r2,255
80116534:	10002e1e 	bne	r2,zero,801165f0 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
80116538:	e03ffe05 	stb	zero,-8(fp)
8011653c:	00002506 	br	801165d4 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
80116540:	e0fffe03 	ldbu	r3,-8(fp)
80116544:	00a005b4 	movhi	r2,32790
80116548:	10b98a04 	addi	r2,r2,-6616
8011654c:	18c01324 	muli	r3,r3,76
80116550:	10c5883a 	add	r2,r2,r3
80116554:	10800104 	addi	r2,r2,4
80116558:	10800003 	ldbu	r2,0(r2)
8011655c:	10803fcc 	andi	r2,r2,255
80116560:	1080201c 	xori	r2,r2,128
80116564:	10bfe004 	addi	r2,r2,-128
80116568:	10001726 	beq	r2,zero,801165c8 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
8011656c:	e0fffe03 	ldbu	r3,-8(fp)
80116570:	e13fff17 	ldw	r4,-4(fp)
80116574:	00a005b4 	movhi	r2,32790
80116578:	10b98a04 	addi	r2,r2,-6616
8011657c:	18c01324 	muli	r3,r3,76
80116580:	10c5883a 	add	r2,r2,r3
80116584:	2007883a 	mov	r3,r4
80116588:	1009883a 	mov	r4,r2
8011658c:	00801304 	movi	r2,76
80116590:	100d883a 	mov	r6,r2
80116594:	200b883a 	mov	r5,r4
80116598:	1809883a 	mov	r4,r3
8011659c:	01214640 	call	80121464 <memcpy>
                bSuccess = TRUE;
801165a0:	00800044 	movi	r2,1
801165a4:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
801165a8:	e0fffe03 	ldbu	r3,-8(fp)
801165ac:	00a005b4 	movhi	r2,32790
801165b0:	10b98a04 	addi	r2,r2,-6616
801165b4:	18c01324 	muli	r3,r3,76
801165b8:	10c5883a 	add	r2,r2,r3
801165bc:	10800104 	addi	r2,r2,4
801165c0:	10000005 	stb	zero,0(r2)
                break;
801165c4:	00000606 	br	801165e0 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
801165c8:	e0bffe03 	ldbu	r2,-8(fp)
801165cc:	10800044 	addi	r2,r2,1
801165d0:	e0bffe05 	stb	r2,-8(fp)
801165d4:	e0bffe03 	ldbu	r2,-8(fp)
801165d8:	10800230 	cmpltui	r2,r2,8
801165dc:	103fd81e 	bne	r2,zero,80116540 <__reset+0xfa0f6540>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
801165e0:	d0a07417 	ldw	r2,-32304(gp)
801165e4:	1009883a 	mov	r4,r2
801165e8:	01384940 	call	80138494 <OSMutexPost>
801165ec:	00000106 	br	801165f4 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
801165f0:	011d2b40 	call	8011d2b4 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
801165f4:	e0bffd17 	ldw	r2,-12(fp)
}
801165f8:	e037883a 	mov	sp,fp
801165fc:	dfc00117 	ldw	ra,4(sp)
80116600:	df000017 	ldw	fp,0(sp)
80116604:	dec00204 	addi	sp,sp,8
80116608:	f800283a 	ret

8011660c <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
8011660c:	defffa04 	addi	sp,sp,-24
80116610:	de00012e 	bgeu	sp,et,80116618 <bSendMessagePUStoMebTask+0xc>
80116614:	003b68fa 	trap	3
80116618:	dfc00515 	stw	ra,20(sp)
8011661c:	df000415 	stw	fp,16(sp)
80116620:	df000404 	addi	fp,sp,16
80116624:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
80116628:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
8011662c:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
80116630:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
80116634:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
80116638:	d0a07c17 	ldw	r2,-32272(gp)
8011663c:	e0fffd44 	addi	r3,fp,-11
80116640:	180d883a 	mov	r6,r3
80116644:	01400284 	movi	r5,10
80116648:	1009883a 	mov	r4,r2
8011664c:	0137ef00 	call	80137ef0 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
80116650:	e0bffd43 	ldbu	r2,-11(fp)
80116654:	10803fcc 	andi	r2,r2,255
80116658:	1000401e 	bne	r2,zero,8011675c <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
8011665c:	e03ffd05 	stb	zero,-12(fp)
80116660:	00003806 	br	80116744 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
80116664:	e0fffd03 	ldbu	r3,-12(fp)
80116668:	00a00574 	movhi	r2,32789
8011666c:	10b48d04 	addi	r2,r2,-11724
80116670:	18c01524 	muli	r3,r3,84
80116674:	10c5883a 	add	r2,r2,r3
80116678:	10800104 	addi	r2,r2,4
8011667c:	10800017 	ldw	r2,0(r2)
80116680:	10002d1e 	bne	r2,zero,80116738 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
80116684:	e0fffd03 	ldbu	r3,-12(fp)
80116688:	00a00574 	movhi	r2,32789
8011668c:	10b48d04 	addi	r2,r2,-11724
80116690:	18c01524 	muli	r3,r3,84
80116694:	10c7883a 	add	r3,r2,r3
80116698:	e0bfff17 	ldw	r2,-4(fp)
8011669c:	1009883a 	mov	r4,r2
801166a0:	00801504 	movi	r2,84
801166a4:	100d883a 	mov	r6,r2
801166a8:	200b883a 	mov	r5,r4
801166ac:	1809883a 	mov	r4,r3
801166b0:	01214640 	call	80121464 <memcpy>
            	xPus[i].bInUse = TRUE;
801166b4:	e0fffd03 	ldbu	r3,-12(fp)
801166b8:	00a00574 	movhi	r2,32789
801166bc:	10b48d04 	addi	r2,r2,-11724
801166c0:	18c01524 	muli	r3,r3,84
801166c4:	10c5883a 	add	r2,r2,r3
801166c8:	10800104 	addi	r2,r2,4
801166cc:	00c00044 	movi	r3,1
801166d0:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
801166d4:	00800044 	movi	r2,1
801166d8:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
801166dc:	00800044 	movi	r2,1
801166e0:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
801166e4:	d0a07317 	ldw	r2,-32308(gp)
801166e8:	e0fffe17 	ldw	r3,-8(fp)
801166ec:	180b883a 	mov	r5,r3
801166f0:	1009883a 	mov	r4,r2
801166f4:	013940c0 	call	8013940c <OSQPost>
801166f8:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
801166fc:	e0bffd43 	ldbu	r2,-11(fp)
80116700:	10803fcc 	andi	r2,r2,255
80116704:	10000926 	beq	r2,zero,8011672c <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
80116708:	011d8c00 	call	8011d8c0 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
8011670c:	e0fffd03 	ldbu	r3,-12(fp)
80116710:	00a00574 	movhi	r2,32789
80116714:	10b48d04 	addi	r2,r2,-11724
80116718:	18c01524 	muli	r3,r3,84
8011671c:	10c5883a 	add	r2,r2,r3
80116720:	10800104 	addi	r2,r2,4
80116724:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
80116728:	00000906 	br	80116750 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
8011672c:	00800044 	movi	r2,1
80116730:	e0bffc15 	stw	r2,-16(fp)
                break;
80116734:	00000606 	br	80116750 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
80116738:	e0bffd03 	ldbu	r2,-12(fp)
8011673c:	10800044 	addi	r2,r2,1
80116740:	e0bffd05 	stb	r2,-12(fp)
80116744:	e0bffd03 	ldbu	r2,-12(fp)
80116748:	10800130 	cmpltui	r2,r2,4
8011674c:	103fc51e 	bne	r2,zero,80116664 <__reset+0xfa0f6664>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
80116750:	d0a07c17 	ldw	r2,-32272(gp)
80116754:	1009883a 	mov	r4,r2
80116758:	01384940 	call	80138494 <OSMutexPost>
    }

    return bSuccess;
8011675c:	e0bffc17 	ldw	r2,-16(fp)
}
80116760:	e037883a 	mov	sp,fp
80116764:	dfc00117 	ldw	ra,4(sp)
80116768:	df000017 	ldw	fp,0(sp)
8011676c:	dec00204 	addi	sp,sp,8
80116770:	f800283a 	ret

80116774 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
80116774:	deffab04 	addi	sp,sp,-340
80116778:	de00012e 	bgeu	sp,et,80116780 <vReceiverUartTask+0xc>
8011677c:	003b68fa 	trap	3
80116780:	dfc05415 	stw	ra,336(sp)
80116784:	df005315 	stw	fp,332(sp)
80116788:	df005304 	addi	fp,sp,332
8011678c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
80116790:	e03fae15 	stw	zero,-328(fp)
    if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
        debug(fp,"Receiver UART Task. (Task on)\n");
    }
    #endif

    eReaderRXMode = sRConfiguring;
80116794:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
80116798:	e0bfad17 	ldw	r2,-332(fp)
8011679c:	10c00060 	cmpeqi	r3,r2,1
801167a0:	1800091e 	bne	r3,zero,801167c8 <vReceiverUartTask+0x54>
801167a4:	0080052e 	bgeu	zero,r2,801167bc <vReceiverUartTask+0x48>
801167a8:	10c000a0 	cmpeqi	r3,r2,2
801167ac:	1800561e 	bne	r3,zero,80116908 <vReceiverUartTask+0x194>
801167b0:	108000e0 	cmpeqi	r2,r2,3
801167b4:	1000671e 	bne	r2,zero,80116954 <vReceiverUartTask+0x1e0>
801167b8:	00007006 	br	8011697c <vReceiverUartTask+0x208>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
801167bc:	00800044 	movi	r2,1
801167c0:	e0bfad15 	stw	r2,-332(fp)
                break;
801167c4:	00007006 	br	80116988 <vReceiverUartTask+0x214>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
801167c8:	e0bfaf04 	addi	r2,fp,-324
801167cc:	01802004 	movi	r6,128
801167d0:	000b883a 	mov	r5,zero
801167d4:	1009883a 	mov	r4,r2
801167d8:	01215b40 	call	801215b4 <memset>
                scanf("%s", cReceive);
801167dc:	e0bfcf04 	addi	r2,fp,-196
801167e0:	100b883a 	mov	r5,r2
801167e4:	01200534 	movhi	r4,32788
801167e8:	211d5804 	addi	r4,r4,30048
801167ec:	01217b80 	call	801217b8 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
801167f0:	e0ffcf04 	addi	r3,fp,-196
801167f4:	e0bfaf04 	addi	r2,fp,-324
801167f8:	01801fc4 	movi	r6,127
801167fc:	180b883a 	mov	r5,r3
80116800:	1009883a 	mov	r4,r2
80116804:	01214640 	call	80121464 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
80116808:	e0bfaf04 	addi	r2,fp,-324
8011680c:	01600574 	movhi	r5,32789
80116810:	29696b04 	addi	r5,r5,-23124
80116814:	1009883a 	mov	r4,r2
80116818:	0116dc00 	call	80116dc0 <bPreParserV2>
8011681c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
80116820:	e0bfae17 	ldw	r2,-328(fp)
80116824:	10800058 	cmpnei	r2,r2,1
80116828:	1000211e 	bne	r2,zero,801168b0 <vReceiverUartTask+0x13c>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
8011682c:	00a00574 	movhi	r2,32789
80116830:	10a96b04 	addi	r2,r2,-23124
80116834:	10800103 	ldbu	r2,4(r2)
80116838:	10803fcc 	andi	r2,r2,255
8011683c:	1080201c 	xori	r2,r2,128
80116840:	10bfe004 	addi	r2,r2,-128
80116844:	10800fe0 	cmpeqi	r2,r2,63
80116848:	1000081e 	bne	r2,zero,8011686c <vReceiverUartTask+0xf8>
8011684c:	00a00574 	movhi	r2,32789
80116850:	10a96b04 	addi	r2,r2,-23124
80116854:	10800103 	ldbu	r2,4(r2)
80116858:	10803fcc 	andi	r2,r2,255
8011685c:	1080201c 	xori	r2,r2,128
80116860:	10bfe004 	addi	r2,r2,-128
80116864:	10800858 	cmpnei	r2,r2,33
80116868:	1000031e 	bne	r2,zero,80116878 <vReceiverUartTask+0x104>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
8011686c:	00800084 	movi	r2,2
80116870:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
80116874:	00004406 	br	80116988 <vReceiverUartTask+0x214>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
80116878:	00a00574 	movhi	r2,32789
8011687c:	10a96b04 	addi	r2,r2,-23124
80116880:	10800103 	ldbu	r2,4(r2)
80116884:	10803fcc 	andi	r2,r2,255
80116888:	1080201c 	xori	r2,r2,128
8011688c:	10bfe004 	addi	r2,r2,-128
80116890:	108008d8 	cmpnei	r2,r2,35
80116894:	1000031e 	bne	r2,zero,801168a4 <vReceiverUartTask+0x130>
                            eReaderRXMode = sGetRxUart;
80116898:	00800044 	movi	r2,1
8011689c:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
801168a0:	00003906 	br	80116988 <vReceiverUartTask+0x214>
                            if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
                                debug(fp,"Nack Received. Do nothing!\n");
                            }
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
801168a4:	008000c4 	movi	r2,3
801168a8:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
801168ac:	00003606 	br	80116988 <vReceiverUartTask+0x214>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
801168b0:	00a00574 	movhi	r2,32789
801168b4:	10a96b04 	addi	r2,r2,-23124
801168b8:	00c008c4 	movi	r3,35
801168bc:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
801168c0:	00a00574 	movhi	r2,32789
801168c4:	10a96b04 	addi	r2,r2,-23124
801168c8:	00c00b84 	movi	r3,46
801168cc:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
801168d0:	00a00574 	movhi	r2,32789
801168d4:	10a96b04 	addi	r2,r2,-23124
801168d8:	00c00044 	movi	r3,1
801168dc:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
801168e0:	01200574 	movhi	r4,32789
801168e4:	21296b04 	addi	r4,r4,-23124
801168e8:	0116ac80 	call	80116ac8 <setPreAckSenderFreePos>
801168ec:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
801168f0:	e0bfae17 	ldw	r2,-328(fp)
801168f4:	1000011e 	bne	r2,zero,801168fc <vReceiverUartTask+0x188>
                        vFailSendNack();
801168f8:	011d32c0 	call	8011d32c <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
801168fc:	00800044 	movi	r2,1
80116900:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
80116904:	00002006 	br	80116988 <vReceiverUartTask+0x214>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
80116908:	01200574 	movhi	r4,32789
8011690c:	21296b04 	addi	r4,r4,-23124
80116910:	0116ac80 	call	80116ac8 <setPreAckSenderFreePos>
80116914:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
80116918:	e0bfae17 	ldw	r2,-328(fp)
8011691c:	10800058 	cmpnei	r2,r2,1
80116920:	1000081e 	bne	r2,zero,80116944 <vReceiverUartTask+0x1d0>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
80116924:	01200574 	movhi	r4,32789
80116928:	21296b04 	addi	r4,r4,-23124
8011692c:	011698c0 	call	8011698c <setPreParsedFreePos>
80116930:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
80116934:	e0bfae17 	ldw	r2,-328(fp)
80116938:	1000031e 	bne	r2,zero,80116948 <vReceiverUartTask+0x1d4>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
8011693c:	011d37c0 	call	8011d37c <vFailSetPreParsedBuffer>
80116940:	00000106 	br	80116948 <vReceiverUartTask+0x1d4>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
80116944:	011d3540 	call	8011d354 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
80116948:	00800044 	movi	r2,1
8011694c:	e0bfad15 	stw	r2,-332(fp)
                break;
80116950:	00000d06 	br	80116988 <vReceiverUartTask+0x214>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
80116954:	01200574 	movhi	r4,32789
80116958:	21296b04 	addi	r4,r4,-23124
8011695c:	0116c440 	call	80116c44 <setPreAckReceiverFreePos>
80116960:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
80116964:	e0bfae17 	ldw	r2,-328(fp)
80116968:	1000011e 	bne	r2,zero,80116970 <vReceiverUartTask+0x1fc>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
8011696c:	011d3a40 	call	8011d3a4 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
80116970:	00800044 	movi	r2,1
80116974:	e0bfad15 	stw	r2,-332(fp)
                break;
80116978:	00000306 	br	80116988 <vReceiverUartTask+0x214>
            default:
                eReaderRXMode = sGetRxUart;
8011697c:	00800044 	movi	r2,1
80116980:	e0bfad15 	stw	r2,-332(fp)
                break;
80116984:	0001883a 	nop
        }

    }
80116988:	003f8306 	br	80116798 <__reset+0xfa0f6798>

8011698c <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
8011698c:	defffb04 	addi	sp,sp,-20
80116990:	de00012e 	bgeu	sp,et,80116998 <setPreParsedFreePos+0xc>
80116994:	003b68fa 	trap	3
80116998:	dfc00415 	stw	ra,16(sp)
8011699c:	df000315 	stw	fp,12(sp)
801169a0:	df000304 	addi	fp,sp,12
801169a4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
801169a8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
801169ac:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
801169b0:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
801169b4:	d0a07417 	ldw	r2,-32304(gp)
801169b8:	e0fffe44 	addi	r3,fp,-7
801169bc:	180d883a 	mov	r6,r3
801169c0:	01400284 	movi	r5,10
801169c4:	1009883a 	mov	r4,r2
801169c8:	0137ef00 	call	80137ef0 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
801169cc:	e0bffe43 	ldbu	r2,-7(fp)
801169d0:	10803fcc 	andi	r2,r2,255
801169d4:	1000361e 	bne	r2,zero,80116ab0 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
801169d8:	e03ffe05 	stb	zero,-8(fp)
801169dc:	00002e06 	br	80116a98 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
801169e0:	e0fffe03 	ldbu	r3,-8(fp)
801169e4:	00a005b4 	movhi	r2,32790
801169e8:	10b98a04 	addi	r2,r2,-6616
801169ec:	18c01324 	muli	r3,r3,76
801169f0:	10c5883a 	add	r2,r2,r3
801169f4:	10800104 	addi	r2,r2,4
801169f8:	10800003 	ldbu	r2,0(r2)
801169fc:	10803fcc 	andi	r2,r2,255
80116a00:	1080201c 	xori	r2,r2,128
80116a04:	10bfe004 	addi	r2,r2,-128
80116a08:	1000201e 	bne	r2,zero,80116a8c <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
80116a0c:	e0fffe03 	ldbu	r3,-8(fp)
80116a10:	00a005b4 	movhi	r2,32790
80116a14:	10b98a04 	addi	r2,r2,-6616
80116a18:	18c01324 	muli	r3,r3,76
80116a1c:	10c7883a 	add	r3,r2,r3
80116a20:	e0bfff17 	ldw	r2,-4(fp)
80116a24:	1009883a 	mov	r4,r2
80116a28:	00801304 	movi	r2,76
80116a2c:	100d883a 	mov	r6,r2
80116a30:	200b883a 	mov	r5,r4
80116a34:	1809883a 	mov	r4,r3
80116a38:	01214640 	call	80121464 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
80116a3c:	d0a06e17 	ldw	r2,-32328(gp)
80116a40:	1009883a 	mov	r4,r2
80116a44:	013a2840 	call	8013a284 <OSSemPost>
80116a48:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
80116a4c:	e0bffe43 	ldbu	r2,-7(fp)
80116a50:	10803fcc 	andi	r2,r2,255
80116a54:	1000031e 	bne	r2,zero,80116a64 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
80116a58:	00800044 	movi	r2,1
80116a5c:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
80116a60:	00001006 	br	80116aa4 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
80116a64:	011cf600 	call	8011cf60 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
80116a68:	e0fffe03 	ldbu	r3,-8(fp)
80116a6c:	00a005b4 	movhi	r2,32790
80116a70:	10b98a04 	addi	r2,r2,-6616
80116a74:	18c01324 	muli	r3,r3,76
80116a78:	10c5883a 	add	r2,r2,r3
80116a7c:	10800104 	addi	r2,r2,4
80116a80:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
80116a84:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
80116a88:	00000606 	br	80116aa4 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
80116a8c:	e0bffe03 	ldbu	r2,-8(fp)
80116a90:	10800044 	addi	r2,r2,1
80116a94:	e0bffe05 	stb	r2,-8(fp)
80116a98:	e0bffe03 	ldbu	r2,-8(fp)
80116a9c:	10800230 	cmpltui	r2,r2,8
80116aa0:	103fcf1e 	bne	r2,zero,801169e0 <__reset+0xfa0f69e0>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
80116aa4:	d0a07417 	ldw	r2,-32304(gp)
80116aa8:	1009883a 	mov	r4,r2
80116aac:	01384940 	call	80138494 <OSMutexPost>
    }
    return bSuccess;
80116ab0:	e0bffd17 	ldw	r2,-12(fp)
}
80116ab4:	e037883a 	mov	sp,fp
80116ab8:	dfc00117 	ldw	ra,4(sp)
80116abc:	df000017 	ldw	fp,0(sp)
80116ac0:	dec00204 	addi	sp,sp,8
80116ac4:	f800283a 	ret

80116ac8 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
80116ac8:	defffb04 	addi	sp,sp,-20
80116acc:	de00012e 	bgeu	sp,et,80116ad4 <setPreAckSenderFreePos+0xc>
80116ad0:	003b68fa 	trap	3
80116ad4:	dfc00415 	stw	ra,16(sp)
80116ad8:	df000315 	stw	fp,12(sp)
80116adc:	df000304 	addi	fp,sp,12
80116ae0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
80116ae4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
80116ae8:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
80116aec:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
80116af0:	d0a07b17 	ldw	r2,-32276(gp)
80116af4:	e0fffe44 	addi	r3,fp,-7
80116af8:	180d883a 	mov	r6,r3
80116afc:	01400284 	movi	r5,10
80116b00:	1009883a 	mov	r4,r2
80116b04:	0137ef00 	call	80137ef0 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
80116b08:	e0bffe43 	ldbu	r2,-7(fp)
80116b0c:	10803fcc 	andi	r2,r2,255
80116b10:	1000461e 	bne	r2,zero,80116c2c <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
80116b14:	e03ffe05 	stb	zero,-8(fp)
80116b18:	00003e06 	br	80116c14 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
80116b1c:	e0fffe03 	ldbu	r3,-8(fp)
80116b20:	00a005b4 	movhi	r2,32790
80116b24:	10b98204 	addi	r2,r2,-6648
80116b28:	18c7883a 	add	r3,r3,r3
80116b2c:	18c7883a 	add	r3,r3,r3
80116b30:	10c5883a 	add	r2,r2,r3
80116b34:	10800003 	ldbu	r2,0(r2)
80116b38:	10803fcc 	andi	r2,r2,255
80116b3c:	1080201c 	xori	r2,r2,128
80116b40:	10bfe004 	addi	r2,r2,-128
80116b44:	1000301e 	bne	r2,zero,80116c08 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
80116b48:	e0fffe03 	ldbu	r3,-8(fp)
80116b4c:	e0bfff17 	ldw	r2,-4(fp)
80116b50:	11000103 	ldbu	r4,4(r2)
80116b54:	00a005b4 	movhi	r2,32790
80116b58:	10b98204 	addi	r2,r2,-6648
80116b5c:	18c7883a 	add	r3,r3,r3
80116b60:	18c7883a 	add	r3,r3,r3
80116b64:	10c5883a 	add	r2,r2,r3
80116b68:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
80116b6c:	e0fffe03 	ldbu	r3,-8(fp)
80116b70:	e0bfff17 	ldw	r2,-4(fp)
80116b74:	11000143 	ldbu	r4,5(r2)
80116b78:	00a005b4 	movhi	r2,32790
80116b7c:	10b98204 	addi	r2,r2,-6648
80116b80:	18c7883a 	add	r3,r3,r3
80116b84:	18c7883a 	add	r3,r3,r3
80116b88:	10c5883a 	add	r2,r2,r3
80116b8c:	10800044 	addi	r2,r2,1
80116b90:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
80116b94:	e0fffe03 	ldbu	r3,-8(fp)
80116b98:	e0bfff17 	ldw	r2,-4(fp)
80116b9c:	1100020b 	ldhu	r4,8(r2)
80116ba0:	00a005b4 	movhi	r2,32790
80116ba4:	10b98204 	addi	r2,r2,-6648
80116ba8:	18c7883a 	add	r3,r3,r3
80116bac:	18c7883a 	add	r3,r3,r3
80116bb0:	10c5883a 	add	r2,r2,r3
80116bb4:	10800084 	addi	r2,r2,2
80116bb8:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
80116bbc:	d0a06c17 	ldw	r2,-32336(gp)
80116bc0:	1009883a 	mov	r4,r2
80116bc4:	013a2840 	call	8013a284 <OSSemPost>
80116bc8:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
80116bcc:	e0bffe43 	ldbu	r2,-7(fp)
80116bd0:	10803fcc 	andi	r2,r2,255
80116bd4:	10000926 	beq	r2,zero,80116bfc <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
80116bd8:	011cfb00 	call	8011cfb0 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
80116bdc:	e0fffe03 	ldbu	r3,-8(fp)
80116be0:	00a005b4 	movhi	r2,32790
80116be4:	10b98204 	addi	r2,r2,-6648
80116be8:	18c7883a 	add	r3,r3,r3
80116bec:	18c7883a 	add	r3,r3,r3
80116bf0:	10c5883a 	add	r2,r2,r3
80116bf4:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
80116bf8:	00000906 	br	80116c20 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
80116bfc:	00800044 	movi	r2,1
80116c00:	e0bffd15 	stw	r2,-12(fp)
                break;
80116c04:	00000606 	br	80116c20 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
80116c08:	e0bffe03 	ldbu	r2,-8(fp)
80116c0c:	10800044 	addi	r2,r2,1
80116c10:	e0bffe05 	stb	r2,-8(fp)
80116c14:	e0bffe03 	ldbu	r2,-8(fp)
80116c18:	10800230 	cmpltui	r2,r2,8
80116c1c:	103fbf1e 	bne	r2,zero,80116b1c <__reset+0xfa0f6b1c>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
80116c20:	d0a07b17 	ldw	r2,-32276(gp)
80116c24:	1009883a 	mov	r4,r2
80116c28:	01384940 	call	80138494 <OSMutexPost>
    }

    return bSuccess;
80116c2c:	e0bffd17 	ldw	r2,-12(fp)
}
80116c30:	e037883a 	mov	sp,fp
80116c34:	dfc00117 	ldw	ra,4(sp)
80116c38:	df000017 	ldw	fp,0(sp)
80116c3c:	dec00204 	addi	sp,sp,8
80116c40:	f800283a 	ret

80116c44 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
80116c44:	defffb04 	addi	sp,sp,-20
80116c48:	de00012e 	bgeu	sp,et,80116c50 <setPreAckReceiverFreePos+0xc>
80116c4c:	003b68fa 	trap	3
80116c50:	dfc00415 	stw	ra,16(sp)
80116c54:	df000315 	stw	fp,12(sp)
80116c58:	df000304 	addi	fp,sp,12
80116c5c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
80116c60:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
80116c64:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
80116c68:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
80116c6c:	d0a06f17 	ldw	r2,-32324(gp)
80116c70:	e0fffe44 	addi	r3,fp,-7
80116c74:	180d883a 	mov	r6,r3
80116c78:	01400504 	movi	r5,20
80116c7c:	1009883a 	mov	r4,r2
80116c80:	0137ef00 	call	80137ef0 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
80116c84:	e0bffe43 	ldbu	r2,-7(fp)
80116c88:	10803fcc 	andi	r2,r2,255
80116c8c:	1000461e 	bne	r2,zero,80116da8 <setPreAckReceiverFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
80116c90:	e03ffe05 	stb	zero,-8(fp)
80116c94:	00003e06 	br	80116d90 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
80116c98:	e0fffe03 	ldbu	r3,-8(fp)
80116c9c:	00a005b4 	movhi	r2,32790
80116ca0:	10a36804 	addi	r2,r2,-29280
80116ca4:	18c7883a 	add	r3,r3,r3
80116ca8:	18c7883a 	add	r3,r3,r3
80116cac:	10c5883a 	add	r2,r2,r3
80116cb0:	10800003 	ldbu	r2,0(r2)
80116cb4:	10803fcc 	andi	r2,r2,255
80116cb8:	1080201c 	xori	r2,r2,128
80116cbc:	10bfe004 	addi	r2,r2,-128
80116cc0:	1000301e 	bne	r2,zero,80116d84 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
80116cc4:	e0fffe03 	ldbu	r3,-8(fp)
80116cc8:	e0bfff17 	ldw	r2,-4(fp)
80116ccc:	11000103 	ldbu	r4,4(r2)
80116cd0:	00a005b4 	movhi	r2,32790
80116cd4:	10a36804 	addi	r2,r2,-29280
80116cd8:	18c7883a 	add	r3,r3,r3
80116cdc:	18c7883a 	add	r3,r3,r3
80116ce0:	10c5883a 	add	r2,r2,r3
80116ce4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
80116ce8:	e0fffe03 	ldbu	r3,-8(fp)
80116cec:	e0bfff17 	ldw	r2,-4(fp)
80116cf0:	11000143 	ldbu	r4,5(r2)
80116cf4:	00a005b4 	movhi	r2,32790
80116cf8:	10a36804 	addi	r2,r2,-29280
80116cfc:	18c7883a 	add	r3,r3,r3
80116d00:	18c7883a 	add	r3,r3,r3
80116d04:	10c5883a 	add	r2,r2,r3
80116d08:	10800044 	addi	r2,r2,1
80116d0c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
80116d10:	e0fffe03 	ldbu	r3,-8(fp)
80116d14:	e0bfff17 	ldw	r2,-4(fp)
80116d18:	1100020b 	ldhu	r4,8(r2)
80116d1c:	00a005b4 	movhi	r2,32790
80116d20:	10a36804 	addi	r2,r2,-29280
80116d24:	18c7883a 	add	r3,r3,r3
80116d28:	18c7883a 	add	r3,r3,r3
80116d2c:	10c5883a 	add	r2,r2,r3
80116d30:	10800084 	addi	r2,r2,2
80116d34:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
80116d38:	d0a07017 	ldw	r2,-32320(gp)
80116d3c:	1009883a 	mov	r4,r2
80116d40:	013a2840 	call	8013a284 <OSSemPost>
80116d44:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
80116d48:	e0bffe43 	ldbu	r2,-7(fp)
80116d4c:	10803fcc 	andi	r2,r2,255
80116d50:	1000031e 	bne	r2,zero,80116d60 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
80116d54:	00800044 	movi	r2,1
80116d58:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
80116d5c:	00000f06 	br	80116d9c <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
80116d60:	011cf880 	call	8011cf88 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
80116d64:	e0fffe03 	ldbu	r3,-8(fp)
80116d68:	00a005b4 	movhi	r2,32790
80116d6c:	10a36804 	addi	r2,r2,-29280
80116d70:	18c7883a 	add	r3,r3,r3
80116d74:	18c7883a 	add	r3,r3,r3
80116d78:	10c5883a 	add	r2,r2,r3
80116d7c:	10000005 	stb	zero,0(r2)
                }
                break;
80116d80:	00000606 	br	80116d9c <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
80116d84:	e0bffe03 	ldbu	r2,-8(fp)
80116d88:	10800044 	addi	r2,r2,1
80116d8c:	e0bffe05 	stb	r2,-8(fp)
80116d90:	e0bffe03 	ldbu	r2,-8(fp)
80116d94:	108001b0 	cmpltui	r2,r2,6
80116d98:	103fbf1e 	bne	r2,zero,80116c98 <__reset+0xfa0f6c98>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
80116d9c:	d0a06f17 	ldw	r2,-32324(gp)
80116da0:	1009883a 	mov	r4,r2
80116da4:	01384940 	call	80138494 <OSMutexPost>
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
    	}
        #endif
    }

    return bSuccess;
80116da8:	e0bffd17 	ldw	r2,-12(fp)
}
80116dac:	e037883a 	mov	sp,fp
80116db0:	dfc00117 	ldw	ra,4(sp)
80116db4:	df000017 	ldw	fp,0(sp)
80116db8:	dec00204 	addi	sp,sp,8
80116dbc:	f800283a 	ret

80116dc0 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
80116dc0:	defff404 	addi	sp,sp,-48
80116dc4:	de00012e 	bgeu	sp,et,80116dcc <bPreParserV2+0xc>
80116dc8:	003b68fa 	trap	3
80116dcc:	dfc00b15 	stw	ra,44(sp)
80116dd0:	df000a15 	stw	fp,40(sp)
80116dd4:	dc000915 	stw	r16,36(sp)
80116dd8:	df000a04 	addi	fp,sp,40
80116ddc:	e13ffd15 	stw	r4,-12(fp)
80116de0:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
80116de4:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
80116de8:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
80116dec:	01402004 	movi	r5,128
80116df0:	e13ffd17 	ldw	r4,-12(fp)
80116df4:	01219ec0 	call	801219ec <strnlen>
80116df8:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
80116dfc:	01400ec4 	movi	r5,59
80116e00:	e13ffd17 	ldw	r4,-12(fp)
80116e04:	011a6d00 	call	8011a6d0 <siPosStr>
80116e08:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
80116e0c:	e0fff98f 	ldh	r3,-26(fp)
80116e10:	e0bff90f 	ldh	r2,-28(fp)
80116e14:	10bfffc4 	addi	r2,r2,-1
80116e18:	18800226 	beq	r3,r2,80116e24 <bPreParserV2+0x64>
        return bSuccess;
80116e1c:	e0bff617 	ldw	r2,-40(fp)
80116e20:	0000ad06 	br	801170d8 <bPreParserV2+0x318>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
80116e24:	01401f04 	movi	r5,124
80116e28:	e13ffd17 	ldw	r4,-12(fp)
80116e2c:	011a6d00 	call	8011a6d0 <siPosStr>
80116e30:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
80116e34:	e0bffa0f 	ldh	r2,-24(fp)
80116e38:	e0fff98f 	ldh	r3,-26(fp)
80116e3c:	1880020e 	bge	r3,r2,80116e48 <bPreParserV2+0x88>
        return bSuccess;
80116e40:	e0bff617 	ldw	r2,-40(fp)
80116e44:	0000a406 	br	801170d8 <bPreParserV2+0x318>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
80116e48:	01600534 	movhi	r5,32788
80116e4c:	295d5904 	addi	r5,r5,30052
80116e50:	e13ffd17 	ldw	r4,-12(fp)
80116e54:	01219080 	call	80121908 <strcspn>
80116e58:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
80116e5c:	e0bffa8f 	ldh	r2,-22(fp)
80116e60:	e0fffa0f 	ldh	r3,-24(fp)
80116e64:	1880020e 	bge	r3,r2,80116e70 <bPreParserV2+0xb0>
        return bSuccess;
80116e68:	e0bff617 	ldw	r2,-40(fp)
80116e6c:	00009a06 	br	801170d8 <bPreParserV2+0x318>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
80116e70:	e0bffa8f 	ldh	r2,-22(fp)
80116e74:	e0fffd17 	ldw	r3,-12(fp)
80116e78:	1885883a 	add	r2,r3,r2
80116e7c:	10c00003 	ldbu	r3,0(r2)
80116e80:	e0bffe17 	ldw	r2,-8(fp)
80116e84:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
80116e88:	e0bffe17 	ldw	r2,-8(fp)
80116e8c:	10800103 	ldbu	r2,4(r2)
80116e90:	10803fcc 	andi	r2,r2,255
80116e94:	1080201c 	xori	r2,r2,128
80116e98:	10bfe004 	addi	r2,r2,-128
80116e9c:	108008d8 	cmpnei	r2,r2,35
80116ea0:	1000041e 	bne	r2,zero,80116eb4 <bPreParserV2+0xf4>
        bSuccess = TRUE;
80116ea4:	00800044 	movi	r2,1
80116ea8:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
80116eac:	e0bff617 	ldw	r2,-40(fp)
80116eb0:	00008906 	br	801170d8 <bPreParserV2+0x318>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
80116eb4:	e0bffa8f 	ldh	r2,-22(fp)
80116eb8:	e0fffd17 	ldw	r3,-12(fp)
80116ebc:	1889883a 	add	r4,r3,r2
80116ec0:	e0fffa0f 	ldh	r3,-24(fp)
80116ec4:	e0bffa8f 	ldh	r2,-22(fp)
80116ec8:	1885c83a 	sub	r2,r3,r2
80116ecc:	100b883a 	mov	r5,r2
80116ed0:	011cd040 	call	8011cd04 <ucCrc8wInit>
80116ed4:	1007883a 	mov	r3,r2
80116ed8:	e0bffe17 	ldw	r2,-8(fp)
80116edc:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
80116ee0:	e0bffa8f 	ldh	r2,-22(fp)
80116ee4:	10800044 	addi	r2,r2,1
80116ee8:	e0fffd17 	ldw	r3,-12(fp)
80116eec:	1885883a 	add	r2,r3,r2
80116ef0:	10c00003 	ldbu	r3,0(r2)
80116ef4:	e0bffe17 	ldw	r2,-8(fp)
80116ef8:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
80116efc:	e0bffe17 	ldw	r2,-8(fp)
80116f00:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
80116f04:	e0bffe17 	ldw	r2,-8(fp)
80116f08:	10800204 	addi	r2,r2,8
80116f0c:	01801004 	movi	r6,64
80116f10:	000b883a 	mov	r5,zero
80116f14:	1009883a 	mov	r4,r2
80116f18:	01215b40 	call	801215b4 <memset>

    i = siIni + 3; /* "?C:i..." */
80116f1c:	e0bffa8b 	ldhu	r2,-22(fp)
80116f20:	108000c4 	addi	r2,r2,3
80116f24:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
80116f28:	e0bffb44 	addi	r2,fp,-19
80116f2c:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
80116f30:	e0bffb44 	addi	r2,fp,-19
80116f34:	01800184 	movi	r6,6
80116f38:	000b883a 	mov	r5,zero
80116f3c:	1009883a 	mov	r4,r2
80116f40:	01215b40 	call	801215b4 <memset>
        do {
            c = buffer[i];
80116f44:	e0bff703 	ldbu	r2,-36(fp)
80116f48:	e0fffd17 	ldw	r3,-12(fp)
80116f4c:	1885883a 	add	r2,r3,r2
80116f50:	10800003 	ldbu	r2,0(r2)
80116f54:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
80116f58:	d0e00317 	ldw	r3,-32756(gp)
80116f5c:	e0bffb07 	ldb	r2,-20(fp)
80116f60:	10800044 	addi	r2,r2,1
80116f64:	1885883a 	add	r2,r3,r2
80116f68:	10800003 	ldbu	r2,0(r2)
80116f6c:	10803fcc 	andi	r2,r2,255
80116f70:	1080010c 	andi	r2,r2,4
80116f74:	10000626 	beq	r2,zero,80116f90 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
80116f78:	e0bff817 	ldw	r2,-32(fp)
80116f7c:	e0fffb03 	ldbu	r3,-20(fp)
80116f80:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
80116f84:	e0bff817 	ldw	r2,-32(fp)
80116f88:	10800044 	addi	r2,r2,1
80116f8c:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
80116f90:	e0bff703 	ldbu	r2,-36(fp)
80116f94:	10800044 	addi	r2,r2,1
80116f98:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
80116f9c:	e0bff90f 	ldh	r2,-28(fp)
80116fa0:	e0fff703 	ldbu	r3,-36(fp)
80116fa4:	1880090e 	bge	r3,r2,80116fcc <bPreParserV2+0x20c>
80116fa8:	e0bffb07 	ldb	r2,-20(fp)
80116fac:	10800ea0 	cmpeqi	r2,r2,58
80116fb0:	1000061e 	bne	r2,zero,80116fcc <bPreParserV2+0x20c>
80116fb4:	e0bffb07 	ldb	r2,-20(fp)
80116fb8:	10800ee0 	cmpeqi	r2,r2,59
80116fbc:	1000031e 	bne	r2,zero,80116fcc <bPreParserV2+0x20c>
80116fc0:	e0bffb07 	ldb	r2,-20(fp)
80116fc4:	10801f18 	cmpnei	r2,r2,124
80116fc8:	103fde1e 	bne	r2,zero,80116f44 <__reset+0xfa0f6f44>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
80116fcc:	e0bff817 	ldw	r2,-32(fp)
80116fd0:	00c00284 	movi	r3,10
80116fd4:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
80116fd8:	e0bffb07 	ldb	r2,-20(fp)
80116fdc:	10800ea0 	cmpeqi	r2,r2,58
80116fe0:	1000031e 	bne	r2,zero,80116ff0 <bPreParserV2+0x230>
80116fe4:	e0bffb07 	ldb	r2,-20(fp)
80116fe8:	10801f18 	cmpnei	r2,r2,124
80116fec:	10001a1e 	bne	r2,zero,80117058 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
80116ff0:	e0bffe17 	ldw	r2,-8(fp)
80116ff4:	10800183 	ldbu	r2,6(r2)
80116ff8:	10803fcc 	andi	r2,r2,255
80116ffc:	10800828 	cmpgeui	r2,r2,32
80117000:	1000041e 	bne	r2,zero,80117014 <bPreParserV2+0x254>
80117004:	e0bffe17 	ldw	r2,-8(fp)
80117008:	10800183 	ldbu	r2,6(r2)
8011700c:	14003fcc 	andi	r16,r2,255
80117010:	00000106 	br	80117018 <bPreParserV2+0x258>
80117014:	04000804 	movi	r16,32
80117018:	e0bffb44 	addi	r2,fp,-19
8011701c:	1009883a 	mov	r4,r2
80117020:	01214340 	call	80121434 <atoi>
80117024:	1009883a 	mov	r4,r2
80117028:	e0fffe17 	ldw	r3,-8(fp)
8011702c:	80800104 	addi	r2,r16,4
80117030:	1085883a 	add	r2,r2,r2
80117034:	1885883a 	add	r2,r3,r2
80117038:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8011703c:	e0bffe17 	ldw	r2,-8(fp)
80117040:	10800183 	ldbu	r2,6(r2)
80117044:	10800044 	addi	r2,r2,1
80117048:	1007883a 	mov	r3,r2
8011704c:	e0bffe17 	ldw	r2,-8(fp)
80117050:	10c00185 	stb	r3,6(r2)
80117054:	00000906 	br	8011707c <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
80117058:	e0bffb07 	ldb	r2,-20(fp)
8011705c:	10800ed8 	cmpnei	r2,r2,59
80117060:	1000061e 	bne	r2,zero,8011707c <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
80117064:	e0bffb44 	addi	r2,fp,-19
80117068:	1009883a 	mov	r4,r2
8011706c:	01214340 	call	80121434 <atoi>
80117070:	1007883a 	mov	r3,r2
80117074:	e0bffe17 	ldw	r2,-8(fp)
80117078:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8011707c:	e0bffb07 	ldb	r2,-20(fp)
80117080:	10800ee0 	cmpeqi	r2,r2,59
80117084:	1000031e 	bne	r2,zero,80117094 <bPreParserV2+0x2d4>
80117088:	e0bff90f 	ldh	r2,-28(fp)
8011708c:	e0fff703 	ldbu	r3,-36(fp)
80117090:	18bfa516 	blt	r3,r2,80116f28 <__reset+0xfa0f6f28>


    if ( c == FINAL_CHAR )
80117094:	e0bffb07 	ldb	r2,-20(fp)
80117098:	10800ed8 	cmpnei	r2,r2,59
8011709c:	10000c1e 	bne	r2,zero,801170d0 <bPreParserV2+0x310>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
801170a0:	e0bffe17 	ldw	r2,-8(fp)
801170a4:	10c01243 	ldbu	r3,73(r2)
801170a8:	e0bffe17 	ldw	r2,-8(fp)
801170ac:	10801203 	ldbu	r2,72(r2)
801170b0:	18c03fcc 	andi	r3,r3,255
801170b4:	10803fcc 	andi	r2,r2,255
801170b8:	1880031e 	bne	r3,r2,801170c8 <bPreParserV2+0x308>
            bSuccess = TRUE;
801170bc:	00800044 	movi	r2,1
801170c0:	e0bff615 	stw	r2,-40(fp)
801170c4:	00000306 	br	801170d4 <bPreParserV2+0x314>
            #if DEBUG_ON
        	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
        	}
            #endif
            bSuccess = FALSE;
801170c8:	e03ff615 	stw	zero,-40(fp)
801170cc:	00000106 	br	801170d4 <bPreParserV2+0x314>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
801170d0:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
801170d4:	e0bff617 	ldw	r2,-40(fp)
}
801170d8:	e6ffff04 	addi	sp,fp,-4
801170dc:	dfc00217 	ldw	ra,8(sp)
801170e0:	df000117 	ldw	fp,4(sp)
801170e4:	dc000017 	ldw	r16,0(sp)
801170e8:	dec00304 	addi	sp,sp,12
801170ec:	f800283a 	ret

801170f0 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
801170f0:	defffb04 	addi	sp,sp,-20
801170f4:	de00012e 	bgeu	sp,et,801170fc <vSenderComTask+0xc>
801170f8:	003b68fa 	trap	3
801170fc:	dfc00415 	stw	ra,16(sp)
80117100:	df000315 	stw	fp,12(sp)
80117104:	df000304 	addi	fp,sp,12
80117108:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
8011710c:	e03ffd15 	stw	zero,-12(fp)
    }
    #endif

    for (;;){
        
        switch (eSenderMode)
80117110:	e0bffd17 	ldw	r2,-12(fp)
80117114:	10c00060 	cmpeqi	r3,r2,1
80117118:	1800091e 	bne	r3,zero,80117140 <vSenderComTask+0x50>
8011711c:	0080052e 	bgeu	zero,r2,80117134 <vSenderComTask+0x44>
80117120:	10c000a0 	cmpeqi	r3,r2,2
80117124:	1800241e 	bne	r3,zero,801171b8 <vSenderComTask+0xc8>
80117128:	10800160 	cmpeqi	r2,r2,5
8011712c:	1000171e 	bne	r2,zero,8011718c <vSenderComTask+0x9c>
80117130:	00001e06 	br	801171ac <vSenderComTask+0xbc>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
80117134:	00800044 	movi	r2,1
80117138:	e0bffd15 	stw	r2,-12(fp)
                break;
8011713c:	00001f06 	br	801171bc <vSenderComTask+0xcc>
                    debug(fp,"Preparing the Start Sequence.\n");
            	}
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
80117140:	01400044 	movi	r5,1
80117144:	01200534 	movhi	r4,32788
80117148:	211d5b04 	addi	r4,r4,30060
8011714c:	0119e000 	call	80119e00 <bSendUART32v2>
80117150:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
80117154:	e0bffe17 	ldw	r2,-8(fp)
80117158:	10800058 	cmpnei	r2,r2,1
8011715c:	1000031e 	bne	r2,zero,8011716c <vSenderComTask+0x7c>
                    eSenderMode = sDummySender;
80117160:	00800144 	movi	r2,5
80117164:	e0bffd15 	stw	r2,-12(fp)
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
80117168:	00001406 	br	801171bc <vSenderComTask+0xcc>
                    #if DEBUG_ON
                	if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
                        debug(fp,"Fail, try again in 5 seconds.\n");
                	}
                    #endif 
                    eSenderMode = sStartingConnSender;
8011716c:	00800044 	movi	r2,1
80117170:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
80117174:	000f883a 	mov	r7,zero
80117178:	01800144 	movi	r6,5
8011717c:	000b883a 	mov	r5,zero
80117180:	0009883a 	mov	r4,zero
80117184:	013be940 	call	8013be94 <OSTimeDlyHMSM>
                }
                break;
80117188:	00000c06 	br	801171bc <vSenderComTask+0xcc>
            case sReadingQueue:

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
8011718c:	00800144 	movi	r2,5
80117190:	e0bffd15 	stw	r2,-12(fp)
                if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
                    debug(fp,"Working...\n");
                }
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
80117194:	000f883a 	mov	r7,zero
80117198:	01800644 	movi	r6,25
8011719c:	000b883a 	mov	r5,zero
801171a0:	0009883a 	mov	r4,zero
801171a4:	013be940 	call	8013be94 <OSTimeDlyHMSM>

                break;
801171a8:	00000406 	br	801171bc <vSenderComTask+0xcc>
                #if DEBUG_ON
            	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
                    debug(fp,"Sender default\n");
            	}
                #endif
                eSenderMode = sDummySender;
801171ac:	00800144 	movi	r2,5
801171b0:	e0bffd15 	stw	r2,-12(fp)
                break;
801171b4:	00000106 	br	801171bc <vSenderComTask+0xcc>
                break;


            case sReadingQueue:

                break;
801171b8:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
801171bc:	003fd406 	br	80117110 <__reset+0xfa0f7110>

801171c0 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
801171c0:	defff904 	addi	sp,sp,-28
801171c4:	de00012e 	bgeu	sp,et,801171cc <vSimMebTask+0xc>
801171c8:	003b68fa 	trap	3
801171cc:	dfc00615 	stw	ra,24(sp)
801171d0:	df000515 	stw	fp,20(sp)
801171d4:	df000504 	addi	fp,sp,20
801171d8:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
801171dc:	e0bfff17 	ldw	r2,-4(fp)
801171e0:	e0bffc15 	stw	r2,-16(fp)
	}
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
801171e4:	e0bffc17 	ldw	r2,-16(fp)
801171e8:	10800117 	ldw	r2,4(r2)
801171ec:	10c00168 	cmpgeui	r3,r2,5
801171f0:	1800821e 	bne	r3,zero,801173fc <vSimMebTask+0x23c>
801171f4:	100690ba 	slli	r3,r2,2
801171f8:	00a00474 	movhi	r2,32785
801171fc:	109c8304 	addi	r2,r2,29196
80117200:	1885883a 	add	r2,r3,r2
80117204:	10800017 	ldw	r2,0(r2)
80117208:	1000683a 	jmp	r2
8011720c:	80117220 	cmpeqi	zero,r16,17864
80117210:	80117238 	rdprs	zero,r16,17864
80117214:	8011724c 	andi	zero,r16,17865
80117218:	80117308 	cmpgei	zero,r16,17868
8011721c:	80117378 	rdprs	zero,r16,17869
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
80117220:	e13ffc17 	ldw	r4,-16(fp)
80117224:	01180880 	call	80118088 <vMebInit>
				pxMebC->eMode = sMebToConfig;
80117228:	e0bffc17 	ldw	r2,-16(fp)
8011722c:	00c00044 	movi	r3,1
80117230:	10c00115 	stw	r3,4(r2)
				break;
80117234:	00007806 	br	80117418 <vSimMebTask+0x258>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					debug(fp,"MEB Task: Config Mode\n");
				}
				#endif

				vEnterConfigRoutine();
80117238:	01181900 	call	80118190 <vEnterConfigRoutine>

				pxMebC->eMode = sMebConfig;
8011723c:	e0bffc17 	ldw	r2,-16(fp)
80117240:	00c000c4 	movi	r3,3
80117244:	10c00115 	stw	r3,4(r2)
				break;
80117248:	00007306 	br	80117418 <vSimMebTask+0x258>


			case sMebToRun:

				bEnableIsoDrivers();
8011724c:	010b13c0 	call	8010b13c <bEnableIsoDrivers>
				bEnableLvdsBoard();
80117250:	010b1b40 	call	8010b1b4 <bEnableLvdsBoard>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					debug(fp,"MEB Task: Run Mode\n");
				}
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
80117254:	000d883a 	mov	r6,zero
80117258:	000b883a 	mov	r5,zero
8011725c:	01002884 	movi	r4,162
80117260:	0117e5c0 	call	80117e5c <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
80117264:	000d883a 	mov	r6,zero
80117268:	000b883a 	mov	r5,zero
8011726c:	01002884 	movi	r4,162
80117270:	01180000 	call	80118000 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
80117274:	e0bffc17 	ldw	r2,-16(fp)
80117278:	1080050b 	ldhu	r2,20(r2)
8011727c:	10bfffcc 	andi	r2,r2,65535
80117280:	100f883a 	mov	r7,r2
80117284:	000d883a 	mov	r6,zero
80117288:	000b883a 	mov	r5,zero
8011728c:	0009883a 	mov	r4,zero
80117290:	013be940 	call	8013be94 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
80117294:	e03ffb05 	stb	zero,-20(fp)
80117298:	00001006 	br	801172dc <vSimMebTask+0x11c>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
8011729c:	e0bffb03 	ldbu	r2,-20(fp)
801172a0:	10809b24 	muli	r2,r2,620
801172a4:	1080a904 	addi	r2,r2,676
801172a8:	e0fffc17 	ldw	r3,-16(fp)
801172ac:	1885883a 	add	r2,r3,r2
801172b0:	1009883a 	mov	r4,r2
801172b4:	010ae300 	call	8010ae30 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
801172b8:	e0bffb03 	ldbu	r2,-20(fp)
801172bc:	e0fffc17 	ldw	r3,-16(fp)
801172c0:	10809b24 	muli	r2,r2,620
801172c4:	1885883a 	add	r2,r3,r2
801172c8:	10804504 	addi	r2,r2,276
801172cc:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
801172d0:	e0bffb03 	ldbu	r2,-20(fp)
801172d4:	10800044 	addi	r2,r2,1
801172d8:	e0bffb05 	stb	r2,-20(fp)
801172dc:	e0bffb03 	ldbu	r2,-20(fp)
801172e0:	10800130 	cmpltui	r2,r2,4
801172e4:	103fed1e 	bne	r2,zero,8011729c <__reset+0xfa0f729c>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
801172e8:	010d8e40 	call	8010d8e4 <bSyncCtrReset>
				vSyncClearCounter();
801172ec:	010d2940 	call	8010d294 <vSyncClearCounter>
				bStartSync();
801172f0:	011f1540 	call	8011f154 <bStartSync>

				vEvtChangeMebMode();
801172f4:	011dc100 	call	8011dc10 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
801172f8:	e0bffc17 	ldw	r2,-16(fp)
801172fc:	00c00104 	movi	r3,4
80117300:	10c00115 	stw	r3,4(r2)
				break;
80117304:	00004406 	br	80117418 <vSimMebTask+0x258>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
80117308:	d0a07317 	ldw	r2,-32308(gp)
8011730c:	e0fffe04 	addi	r3,fp,-8
80117310:	180d883a 	mov	r6,r3
80117314:	000b883a 	mov	r5,zero
80117318:	1009883a 	mov	r4,r2
8011731c:	01390040 	call	80139004 <OSQPend>
80117320:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
80117324:	e0bffe03 	ldbu	r2,-8(fp)
80117328:	10803fcc 	andi	r2,r2,255
8011732c:	10000e1e 	bne	r2,zero,80117368 <vSimMebTask+0x1a8>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
80117330:	e0bffdc3 	ldbu	r2,-9(fp)
80117334:	10803fcc 	andi	r2,r2,255
80117338:	10800058 	cmpnei	r2,r2,1
8011733c:	1000331e 	bne	r2,zero,8011740c <vSimMebTask+0x24c>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
80117340:	e0bffd83 	ldbu	r2,-10(fp)
80117344:	10803fcc 	andi	r2,r2,255
80117348:	10c00060 	cmpeqi	r3,r2,1
8011734c:	1800031e 	bne	r3,zero,8011735c <vSimMebTask+0x19c>
80117350:	10803820 	cmpeqi	r2,r2,224
80117354:	1000061e 	bne	r2,zero,80117370 <vSimMebTask+0x1b0>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
80117358:	00000606 	br	80117374 <vSimMebTask+0x1b4>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
8011735c:	e13ffc17 	ldw	r4,-16(fp)
80117360:	011741c0 	call	8011741c <vPusMebTask>
								break;
80117364:	00000306 	br	80117374 <vSimMebTask+0x1b4>
						}
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
80117368:	011d8e80 	call	8011d8e8 <vCouldNotGetCmdQueueMeb>
				}

				break;
8011736c:	00002706 	br	8011740c <vSimMebTask+0x24c>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
								}
								#endif
								break;
80117370:	0001883a 	nop
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
80117374:	00002506 	br	8011740c <vSimMebTask+0x24c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
80117378:	d0a07317 	ldw	r2,-32308(gp)
8011737c:	e0fffe04 	addi	r3,fp,-8
80117380:	180d883a 	mov	r6,r3
80117384:	000b883a 	mov	r5,zero
80117388:	1009883a 	mov	r4,r2
8011738c:	01390040 	call	80139004 <OSQPend>
80117390:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
80117394:	e0bffe03 	ldbu	r2,-8(fp)
80117398:	10803fcc 	andi	r2,r2,255
8011739c:	1000131e 	bne	r2,zero,801173ec <vSimMebTask+0x22c>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
801173a0:	e0bffdc3 	ldbu	r2,-9(fp)
801173a4:	10803fcc 	andi	r2,r2,255
801173a8:	10800058 	cmpnei	r2,r2,1
801173ac:	1000191e 	bne	r2,zero,80117414 <vSimMebTask+0x254>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
801173b0:	e0bffd83 	ldbu	r2,-10(fp)
801173b4:	10803fcc 	andi	r2,r2,255
801173b8:	10c03820 	cmpeqi	r3,r2,224
801173bc:	1800081e 	bne	r3,zero,801173e0 <vSimMebTask+0x220>
801173c0:	10c03860 	cmpeqi	r3,r2,225
801173c4:	18000b1e 	bne	r3,zero,801173f4 <vSimMebTask+0x234>
801173c8:	10800060 	cmpeqi	r2,r2,1
801173cc:	1000011e 	bne	r2,zero,801173d4 <vSimMebTask+0x214>
								#if DEBUG_ON
								if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
								}
								#endif
								break;
801173d0:	00000906 	br	801173f8 <vSimMebTask+0x238>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
801173d4:	e13ffc17 	ldw	r4,-16(fp)
801173d8:	011741c0 	call	8011741c <vPusMebTask>
								break;
801173dc:	00000606 	br	801173f8 <vSimMebTask+0x238>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
801173e0:	e13ffc17 	ldw	r4,-16(fp)
801173e4:	01180ec0 	call	801180ec <vSwapMemmory>
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
									}
								}
								#endif

								break;
801173e8:	00000206 	br	801173f4 <vSimMebTask+0x234>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
801173ec:	011d8e80 	call	8011d8e8 <vCouldNotGetCmdQueueMeb>
				}			
				break;
801173f0:	00000806 	br	80117414 <vSimMebTask+0x254>
										fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
									}
								}
								#endif

								break;
801173f4:	0001883a 	nop

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
801173f8:	00000606 	br	80117414 <vSimMebTask+0x254>
					debug(fp,"MEB Task: Unknown state, backing to Config Mode\n");
				}
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
801173fc:	e0bffc17 	ldw	r2,-16(fp)
80117400:	00c00044 	movi	r3,1
80117404:	10c00115 	stw	r3,4(r2)
				break;
80117408:	00000306 	br	80117418 <vSimMebTask+0x258>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
8011740c:	0001883a 	nop
80117410:	003f7406 	br	801171e4 <__reset+0xfa0f71e4>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
80117414:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
				break;
		}
	}
80117418:	003f7206 	br	801171e4 <__reset+0xfa0f71e4>

8011741c <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
8011741c:	defffb04 	addi	sp,sp,-20
80117420:	de00012e 	bgeu	sp,et,80117428 <vPusMebTask+0xc>
80117424:	003b68fa 	trap	3
80117428:	dfc00415 	stw	ra,16(sp)
8011742c:	df000315 	stw	fp,12(sp)
80117430:	df000304 	addi	fp,sp,12
80117434:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
80117438:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
8011743c:	d0a07c17 	ldw	r2,-32272(gp)
80117440:	e0fffe44 	addi	r3,fp,-7
80117444:	180d883a 	mov	r6,r3
80117448:	01400084 	movi	r5,2
8011744c:	1009883a 	mov	r4,r2
80117450:	0137ef00 	call	80137ef0 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
80117454:	e0bffe43 	ldbu	r2,-7(fp)
80117458:	10803fcc 	andi	r2,r2,255
8011745c:	10002c1e 	bne	r2,zero,80117510 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
80117460:	e03ffe05 	stb	zero,-8(fp)
80117464:	00002306 	br	801174f4 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
80117468:	e0fffe03 	ldbu	r3,-8(fp)
8011746c:	00a00574 	movhi	r2,32789
80117470:	10b48d04 	addi	r2,r2,-11724
80117474:	18c01524 	muli	r3,r3,84
80117478:	10c5883a 	add	r2,r2,r3
8011747c:	10800104 	addi	r2,r2,4
80117480:	10800017 	ldw	r2,0(r2)
80117484:	10800058 	cmpnei	r2,r2,1
80117488:	1000171e 	bne	r2,zero,801174e8 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
8011748c:	e13ffe03 	ldbu	r4,-8(fp)
80117490:	00e00574 	movhi	r3,32789
80117494:	18e97e04 	addi	r3,r3,-23048
80117498:	00a00574 	movhi	r2,32789
8011749c:	10b48d04 	addi	r2,r2,-11724
801174a0:	21001524 	muli	r4,r4,84
801174a4:	1105883a 	add	r2,r2,r4
801174a8:	1009883a 	mov	r4,r2
801174ac:	00801504 	movi	r2,84
801174b0:	100d883a 	mov	r6,r2
801174b4:	200b883a 	mov	r5,r4
801174b8:	1809883a 	mov	r4,r3
801174bc:	01214640 	call	80121464 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
801174c0:	e0fffe03 	ldbu	r3,-8(fp)
801174c4:	00a00574 	movhi	r2,32789
801174c8:	10b48d04 	addi	r2,r2,-11724
801174cc:	18c01524 	muli	r3,r3,84
801174d0:	10c5883a 	add	r2,r2,r3
801174d4:	10800104 	addi	r2,r2,4
801174d8:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
801174dc:	00800044 	movi	r2,1
801174e0:	e0bffd15 	stw	r2,-12(fp)
                break;
801174e4:	00000606 	br	80117500 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
801174e8:	e0bffe03 	ldbu	r2,-8(fp)
801174ec:	10800044 	addi	r2,r2,1
801174f0:	e0bffe05 	stb	r2,-8(fp)
801174f4:	e0bffe03 	ldbu	r2,-8(fp)
801174f8:	10800130 	cmpltui	r2,r2,4
801174fc:	103fda1e 	bne	r2,zero,80117468 <__reset+0xfa0f7468>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
80117500:	d0a07c17 	ldw	r2,-32272(gp)
80117504:	1009883a 	mov	r4,r2
80117508:	01384940 	call	80138494 <OSMutexPost>
8011750c:	00000106 	br	80117514 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
80117510:	011d9100 	call	8011d910 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
80117514:	e0bffd17 	ldw	r2,-12(fp)
80117518:	10001126 	beq	r2,zero,80117560 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
8011751c:	e0bfff17 	ldw	r2,-4(fp)
80117520:	10800117 	ldw	r2,4(r2)
80117524:	10c000e0 	cmpeqi	r3,r2,3
80117528:	1800031e 	bne	r3,zero,80117538 <vPusMebTask+0x11c>
8011752c:	10800120 	cmpeqi	r2,r2,4
80117530:	1000061e 	bne	r2,zero,8011754c <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
80117534:	00000a06 	br	80117560 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
80117538:	01600574 	movhi	r5,32789
8011753c:	29697e04 	addi	r5,r5,-23048
80117540:	e13fff17 	ldw	r4,-4(fp)
80117544:	01175780 	call	80117578 <vPusMebInTaskConfigMode>
				break;
80117548:	00000506 	br	80117560 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
8011754c:	01600574 	movhi	r5,32789
80117550:	29697e04 	addi	r5,r5,-23048
80117554:	e13fff17 	ldw	r4,-4(fp)
80117558:	01178940 	call	80117894 <vPusMebInTaskRunningMode>
				break;
8011755c:	0001883a 	nop
			default:
				break;
		}
	}
}
80117560:	0001883a 	nop
80117564:	e037883a 	mov	sp,fp
80117568:	dfc00117 	ldw	ra,4(sp)
8011756c:	df000017 	ldw	fp,0(sp)
80117570:	dec00204 	addi	sp,sp,8
80117574:	f800283a 	ret

80117578 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
80117578:	defffc04 	addi	sp,sp,-16
8011757c:	de00012e 	bgeu	sp,et,80117584 <vPusMebInTaskConfigMode+0xc>
80117580:	003b68fa 	trap	3
80117584:	dfc00315 	stw	ra,12(sp)
80117588:	df000215 	stw	fp,8(sp)
8011758c:	df000204 	addi	fp,sp,8
80117590:	e13ffe15 	stw	r4,-8(fp)
80117594:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
80117598:	e0bfff17 	ldw	r2,-4(fp)
8011759c:	1080030b 	ldhu	r2,12(r2)
801175a0:	10bfffcc 	andi	r2,r2,65535
801175a4:	10c03ee0 	cmpeqi	r3,r2,251
801175a8:	1800091e 	bne	r3,zero,801175d0 <vPusMebInTaskConfigMode+0x58>
801175ac:	10c03f20 	cmpeqi	r3,r2,252
801175b0:	18000b1e 	bne	r3,zero,801175e0 <vPusMebInTaskConfigMode+0x68>
801175b4:	10803ea0 	cmpeqi	r2,r2,250
801175b8:	1000011e 	bne	r2,zero,801175c0 <vPusMebInTaskConfigMode+0x48>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
			}
			#endif
			break;
801175bc:	00000c06 	br	801175f0 <vPusMebInTaskConfigMode+0x78>
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {

	switch (xPusL->usiType) {
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
801175c0:	e17fff17 	ldw	r5,-4(fp)
801175c4:	e13ffe17 	ldw	r4,-8(fp)
801175c8:	01176080 	call	80117608 <vPusType250conf>
			break;
801175cc:	00000806 	br	801175f0 <vPusMebInTaskConfigMode+0x78>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
801175d0:	e17fff17 	ldw	r5,-4(fp)
801175d4:	e13ffe17 	ldw	r4,-8(fp)
801175d8:	01176e00 	call	801176e0 <vPusType251conf>
			break;
801175dc:	00000406 	br	801175f0 <vPusMebInTaskConfigMode+0x78>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
801175e0:	e17fff17 	ldw	r5,-4(fp)
801175e4:	e13ffe17 	ldw	r4,-8(fp)
801175e8:	01177100 	call	80117710 <vPusType252conf>
			break;
801175ec:	0001883a 	nop
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
			}
			#endif
			break;
	}
}
801175f0:	0001883a 	nop
801175f4:	e037883a 	mov	sp,fp
801175f8:	dfc00117 	ldw	ra,4(sp)
801175fc:	df000017 	ldw	fp,0(sp)
80117600:	dec00204 	addi	sp,sp,8
80117604:	f800283a 	ret

80117608 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
80117608:	defffb04 	addi	sp,sp,-20
8011760c:	de00012e 	bgeu	sp,et,80117614 <vPusType250conf+0xc>
80117610:	003b68fa 	trap	3
80117614:	dfc00415 	stw	ra,16(sp)
80117618:	df000315 	stw	fp,12(sp)
8011761c:	df000304 	addi	fp,sp,12
80117620:	e13ffe15 	stw	r4,-8(fp)
80117624:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucShutDownI = 0;
80117628:	e03ffd05 	stb	zero,-12(fp)


	switch (xPusL->usiSubType) {
8011762c:	e0bfff17 	ldw	r2,-4(fp)
80117630:	1080038b 	ldhu	r2,14(r2)
80117634:	10bfffcc 	andi	r2,r2,65535
80117638:	10c00f60 	cmpeqi	r3,r2,61
8011763c:	1800031e 	bne	r3,zero,8011764c <vPusType250conf+0x44>
80117640:	10800fa0 	cmpeqi	r2,r2,62
80117644:	1000051e 	bne	r2,zero,8011765c <vPusType250conf+0x54>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
80117648:	00001f06 	br	801176c8 <vPusType250conf+0xc0>


	switch (xPusL->usiSubType) {
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
8011764c:	e0bffe17 	ldw	r2,-8(fp)
80117650:	00c00084 	movi	r3,2
80117654:	10c00115 	stw	r3,4(r2)
			break;
80117658:	00001b06 	br	801176c8 <vPusType250conf+0xc0>
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			/* Animate LED */
			/* Wait for N seconds */
			for (ucShutDownI = 0; ucShutDownI < N_SEC_WAIT_SHUTDOWN; ucShutDownI++) {
8011765c:	e03ffd05 	stb	zero,-12(fp)
80117660:	00001206 	br	801176ac <vPusType250conf+0xa4>

				bSetPainelLeds( LEDS_OFF , LEDS_ST_ALL_MASK );
80117664:	014007f4 	movhi	r5,31
80117668:	0009883a 	mov	r4,zero
8011766c:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , (LEDS_ST_1_MASK << ( ucShutDownI % 4 )) );
80117670:	e0bffd03 	ldbu	r2,-12(fp)
80117674:	108000cc 	andi	r2,r2,3
80117678:	00c000b4 	movhi	r3,2
8011767c:	1884983a 	sll	r2,r3,r2
80117680:	100b883a 	mov	r5,r2
80117684:	01000044 	movi	r4,1
80117688:	010bb640 	call	8010bb64 <bSetPainelLeds>

				OSTimeDlyHMSM(0,0,1,0);
8011768c:	000f883a 	mov	r7,zero
80117690:	01800044 	movi	r6,1
80117694:	000b883a 	mov	r5,zero
80117698:	0009883a 	mov	r4,zero
8011769c:	013be940 	call	8013be94 <OSTimeDlyHMSM>
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			/* Animate LED */
			/* Wait for N seconds */
			for (ucShutDownI = 0; ucShutDownI < N_SEC_WAIT_SHUTDOWN; ucShutDownI++) {
801176a0:	e0bffd03 	ldbu	r2,-12(fp)
801176a4:	10800044 	addi	r2,r2,1
801176a8:	e0bffd05 	stb	r2,-12(fp)
801176ac:	e0bffd03 	ldbu	r2,-12(fp)
801176b0:	108003f0 	cmpltui	r2,r2,15
801176b4:	103feb1e 	bne	r2,zero,80117664 <__reset+0xfa0f7664>

				OSTimeDlyHMSM(0,0,1,0);
			}

			/* Sinalize that can safely shutdown the Simucam */
			bSetPainelLeds( LEDS_ON , LEDS_ST_ALL_MASK );
801176b8:	014007f4 	movhi	r5,31
801176bc:	01000044 	movi	r4,1
801176c0:	010bb640 	call	8010bb64 <bSetPainelLeds>

			break;
801176c4:	0001883a 	nop
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
	}
}
801176c8:	0001883a 	nop
801176cc:	e037883a 	mov	sp,fp
801176d0:	dfc00117 	ldw	ra,4(sp)
801176d4:	df000017 	ldw	fp,0(sp)
801176d8:	dec00204 	addi	sp,sp,8
801176dc:	f800283a 	ret

801176e0 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
801176e0:	defffd04 	addi	sp,sp,-12
801176e4:	de00012e 	bgeu	sp,et,801176ec <vPusType251conf+0xc>
801176e8:	003b68fa 	trap	3
801176ec:	df000215 	stw	fp,8(sp)
801176f0:	df000204 	addi	fp,sp,8
801176f4:	e13ffe15 	stw	r4,-8(fp)
801176f8:	e17fff15 	stw	r5,-4(fp)
	#if DEBUG_ON
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
	}
	#endif
}
801176fc:	0001883a 	nop
80117700:	e037883a 	mov	sp,fp
80117704:	df000017 	ldw	fp,0(sp)
80117708:	dec00104 	addi	sp,sp,4
8011770c:	f800283a 	ret

80117710 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
80117710:	defffa04 	addi	sp,sp,-24
80117714:	de00012e 	bgeu	sp,et,8011771c <vPusType252conf+0xc>
80117718:	003b68fa 	trap	3
8011771c:	dfc00515 	stw	ra,20(sp)
80117720:	df000415 	stw	fp,16(sp)
80117724:	df000404 	addi	fp,sp,16
80117728:	e13ffd15 	stw	r4,-12(fp)
8011772c:	e17ffe15 	stw	r5,-8(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
80117730:	e0bffe17 	ldw	r2,-8(fp)
80117734:	1080050b 	ldhu	r2,20(r2)
80117738:	e0bffc0d 	sth	r2,-16(fp)
	switch (xPusL->usiSubType) {
8011773c:	e0bffe17 	ldw	r2,-8(fp)
80117740:	1080038b 	ldhu	r2,14(r2)
80117744:	10bfffcc 	andi	r2,r2,65535
80117748:	108000a0 	cmpeqi	r2,r2,2
8011774c:	1000011e 	bne	r2,zero,80117754 <vPusType252conf+0x44>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
80117750:	00004a06 	br	8011787c <vPusType252conf+0x16c>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
80117754:	e0bffc0b 	ldhu	r2,-16(fp)
80117758:	10809b24 	muli	r2,r2,620
8011775c:	10806304 	addi	r2,r2,396
80117760:	e0fffd17 	ldw	r3,-12(fp)
80117764:	1885883a 	add	r2,r3,r2
80117768:	1009883a 	mov	r4,r2
8011776c:	01080440 	call	80108044 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
80117770:	e0bffc0b 	ldhu	r2,-16(fp)
80117774:	e0fffd17 	ldw	r3,-12(fp)
80117778:	10809b24 	muli	r2,r2,620
8011777c:	1885883a 	add	r2,r3,r2
80117780:	10807304 	addi	r2,r2,460
80117784:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
80117788:	e0bffc0b 	ldhu	r2,-16(fp)
8011778c:	10809b24 	muli	r2,r2,620
80117790:	10806304 	addi	r2,r2,396
80117794:	e0fffd17 	ldw	r3,-12(fp)
80117798:	1885883a 	add	r2,r3,r2
8011779c:	1009883a 	mov	r4,r2
801177a0:	0107f980 	call	80107f98 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
801177a4:	e0bffc0b 	ldhu	r2,-16(fp)
801177a8:	10809b24 	muli	r2,r2,620
801177ac:	10806304 	addi	r2,r2,396
801177b0:	e0fffd17 	ldw	r3,-12(fp)
801177b4:	1885883a 	add	r2,r3,r2
801177b8:	1009883a 	mov	r4,r2
801177bc:	01082300 	call	80108230 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
801177c0:	e0bffc0b 	ldhu	r2,-16(fp)
801177c4:	e0fffe17 	ldw	r3,-8(fp)
801177c8:	18c00b0b 	ldhu	r3,44(r3)
801177cc:	1809883a 	mov	r4,r3
801177d0:	e0fffd17 	ldw	r3,-12(fp)
801177d4:	10809b24 	muli	r2,r2,620
801177d8:	1885883a 	add	r2,r3,r2
801177dc:	10806404 	addi	r2,r2,400
801177e0:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
801177e4:	e0bffc0b 	ldhu	r2,-16(fp)
801177e8:	e0fffe17 	ldw	r3,-8(fp)
801177ec:	18c0098b 	ldhu	r3,38(r3)
801177f0:	1809883a 	mov	r4,r3
801177f4:	e0fffd17 	ldw	r3,-12(fp)
801177f8:	10809b24 	muli	r2,r2,620
801177fc:	1885883a 	add	r2,r3,r2
80117800:	10806444 	addi	r2,r2,401
80117804:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
80117808:	e0bffc0b 	ldhu	r2,-16(fp)
8011780c:	10809b24 	muli	r2,r2,620
80117810:	10806304 	addi	r2,r2,396
80117814:	e0fffd17 	ldw	r3,-12(fp)
80117818:	1885883a 	add	r2,r3,r2
8011781c:	1009883a 	mov	r4,r2
80117820:	01081540 	call	80108154 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
80117824:	e0bffc0b 	ldhu	r2,-16(fp)
80117828:	10809b24 	muli	r2,r2,620
8011782c:	10806304 	addi	r2,r2,396
80117830:	e0fffd17 	ldw	r3,-12(fp)
80117834:	1885883a 	add	r2,r3,r2
80117838:	1009883a 	mov	r4,r2
8011783c:	01080440 	call	80108044 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
80117840:	e0bffc0b 	ldhu	r2,-16(fp)
80117844:	e0fffd17 	ldw	r3,-12(fp)
80117848:	10809b24 	muli	r2,r2,620
8011784c:	1885883a 	add	r2,r3,r2
80117850:	10807304 	addi	r2,r2,460
80117854:	00c00044 	movi	r3,1
80117858:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8011785c:	e0bffc0b 	ldhu	r2,-16(fp)
80117860:	10809b24 	muli	r2,r2,620
80117864:	10806304 	addi	r2,r2,396
80117868:	e0fffd17 	ldw	r3,-12(fp)
8011786c:	1885883a 	add	r2,r3,r2
80117870:	1009883a 	mov	r4,r2
80117874:	0107f980 	call	80107f98 <bRmapSetIrqControl>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif

			break;
80117878:	0001883a 	nop
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			}
			#endif
			break;
	}
}
8011787c:	0001883a 	nop
80117880:	e037883a 	mov	sp,fp
80117884:	dfc00117 	ldw	ra,4(sp)
80117888:	df000017 	ldw	fp,0(sp)
8011788c:	dec00204 	addi	sp,sp,8
80117890:	f800283a 	ret

80117894 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
80117894:	defffc04 	addi	sp,sp,-16
80117898:	de00012e 	bgeu	sp,et,801178a0 <vPusMebInTaskRunningMode+0xc>
8011789c:	003b68fa 	trap	3
801178a0:	dfc00315 	stw	ra,12(sp)
801178a4:	df000215 	stw	fp,8(sp)
801178a8:	df000204 	addi	fp,sp,8
801178ac:	e13ffe15 	stw	r4,-8(fp)
801178b0:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
801178b4:	e0bfff17 	ldw	r2,-4(fp)
801178b8:	1080030b 	ldhu	r2,12(r2)
801178bc:	10bfffcc 	andi	r2,r2,65535
801178c0:	10c03ee0 	cmpeqi	r3,r2,251
801178c4:	1800091e 	bne	r3,zero,801178ec <vPusMebInTaskRunningMode+0x58>
801178c8:	10c03f20 	cmpeqi	r3,r2,252
801178cc:	18000b1e 	bne	r3,zero,801178fc <vPusMebInTaskRunningMode+0x68>
801178d0:	10803ea0 	cmpeqi	r2,r2,250
801178d4:	1000011e 	bne	r2,zero,801178dc <vPusMebInTaskRunningMode+0x48>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
801178d8:	00000c06 	br	8011790c <vPusMebInTaskRunningMode+0x78>
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {

	switch (xPusL->usiType) {
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
801178dc:	e17fff17 	ldw	r5,-4(fp)
801178e0:	e13ffe17 	ldw	r4,-8(fp)
801178e4:	01179240 	call	80117924 <vPusType250run>
			break;
801178e8:	00000806 	br	8011790c <vPusMebInTaskRunningMode+0x78>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
801178ec:	e17fff17 	ldw	r5,-4(fp)
801178f0:	e13ffe17 	ldw	r4,-8(fp)
801178f4:	0117a000 	call	80117a00 <vPusType251run>
			break;
801178f8:	00000406 	br	8011790c <vPusMebInTaskRunningMode+0x78>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
801178fc:	e17fff17 	ldw	r5,-4(fp)
80117900:	e13ffe17 	ldw	r4,-8(fp)
80117904:	0117af00 	call	80117af0 <vPusType252run>
			break;
80117908:	0001883a 	nop
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
	}
}
8011790c:	0001883a 	nop
80117910:	e037883a 	mov	sp,fp
80117914:	dfc00117 	ldw	ra,4(sp)
80117918:	df000017 	ldw	fp,0(sp)
8011791c:	dec00204 	addi	sp,sp,8
80117920:	f800283a 	ret

80117924 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
80117924:	defffb04 	addi	sp,sp,-20
80117928:	de00012e 	bgeu	sp,et,80117930 <vPusType250run+0xc>
8011792c:	003b68fa 	trap	3
80117930:	dfc00415 	stw	ra,16(sp)
80117934:	df000315 	stw	fp,12(sp)
80117938:	df000304 	addi	fp,sp,12
8011793c:	e13ffe15 	stw	r4,-8(fp)
80117940:	e17fff15 	stw	r5,-4(fp)

	unsigned char ucShutDownI=0;
80117944:	e03ffd05 	stb	zero,-12(fp)

	switch (xPusL->usiSubType) {
80117948:	e0bfff17 	ldw	r2,-4(fp)
8011794c:	1080038b 	ldhu	r2,14(r2)
80117950:	10bfffcc 	andi	r2,r2,65535
80117954:	10c00f20 	cmpeqi	r3,r2,60
80117958:	1800031e 	bne	r3,zero,80117968 <vPusType250run+0x44>
8011795c:	10800fa0 	cmpeqi	r2,r2,62
80117960:	1000051e 	bne	r2,zero,80117978 <vPusType250run+0x54>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
80117964:	00002006 	br	801179e8 <vPusType250run+0xc4>
	unsigned char ucShutDownI=0;

	switch (xPusL->usiSubType) {
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
80117968:	e0bffe17 	ldw	r2,-8(fp)
8011796c:	00c00044 	movi	r3,1
80117970:	10c00115 	stw	r3,4(r2)
			break;
80117974:	00001c06 	br	801179e8 <vPusType250run+0xc4>
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			/* Force all go to Config Mode */
			vEnterConfigRoutine();
80117978:	01181900 	call	80118190 <vEnterConfigRoutine>

			/* Animate LED */
			/* Wait for N seconds */
			for (ucShutDownI = 0; ucShutDownI < N_SEC_WAIT_SHUTDOWN; ucShutDownI++) {
8011797c:	e03ffd05 	stb	zero,-12(fp)
80117980:	00001206 	br	801179cc <vPusType250run+0xa8>

				bSetPainelLeds( LEDS_OFF , LEDS_ST_ALL_MASK );
80117984:	014007f4 	movhi	r5,31
80117988:	0009883a 	mov	r4,zero
8011798c:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , (LEDS_ST_1_MASK << ( ucShutDownI % 4 )) );
80117990:	e0bffd03 	ldbu	r2,-12(fp)
80117994:	108000cc 	andi	r2,r2,3
80117998:	00c000b4 	movhi	r3,2
8011799c:	1884983a 	sll	r2,r3,r2
801179a0:	100b883a 	mov	r5,r2
801179a4:	01000044 	movi	r4,1
801179a8:	010bb640 	call	8010bb64 <bSetPainelLeds>

				OSTimeDlyHMSM(0,0,1,0);
801179ac:	000f883a 	mov	r7,zero
801179b0:	01800044 	movi	r6,1
801179b4:	000b883a 	mov	r5,zero
801179b8:	0009883a 	mov	r4,zero
801179bc:	013be940 	call	8013be94 <OSTimeDlyHMSM>
			/* Force all go to Config Mode */
			vEnterConfigRoutine();

			/* Animate LED */
			/* Wait for N seconds */
			for (ucShutDownI = 0; ucShutDownI < N_SEC_WAIT_SHUTDOWN; ucShutDownI++) {
801179c0:	e0bffd03 	ldbu	r2,-12(fp)
801179c4:	10800044 	addi	r2,r2,1
801179c8:	e0bffd05 	stb	r2,-12(fp)
801179cc:	e0bffd03 	ldbu	r2,-12(fp)
801179d0:	108003f0 	cmpltui	r2,r2,15
801179d4:	103feb1e 	bne	r2,zero,80117984 <__reset+0xfa0f7984>

				OSTimeDlyHMSM(0,0,1,0);
			}

			/* Sinalize that can safely shutdown the Simucam */
			bSetPainelLeds( LEDS_ON , LEDS_ST_ALL_MASK );
801179d8:	014007f4 	movhi	r5,31
801179dc:	01000044 	movi	r4,1
801179e0:	010bb640 	call	8010bb64 <bSetPainelLeds>


			break;
801179e4:	0001883a 	nop
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
	}
}
801179e8:	0001883a 	nop
801179ec:	e037883a 	mov	sp,fp
801179f0:	dfc00117 	ldw	ra,4(sp)
801179f4:	df000017 	ldw	fp,0(sp)
801179f8:	dec00204 	addi	sp,sp,8
801179fc:	f800283a 	ret

80117a00 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
80117a00:	defffb04 	addi	sp,sp,-20
80117a04:	de00012e 	bgeu	sp,et,80117a0c <vPusType251run+0xc>
80117a08:	003b68fa 	trap	3
80117a0c:	dfc00415 	stw	ra,16(sp)
80117a10:	df000315 	stw	fp,12(sp)
80117a14:	df000304 	addi	fp,sp,12
80117a18:	e13ffe15 	stw	r4,-8(fp)
80117a1c:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
80117a20:	e0bfff17 	ldw	r2,-4(fp)
80117a24:	1080050b 	ldhu	r2,20(r2)
80117a28:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
80117a2c:	e0bfff17 	ldw	r2,-4(fp)
80117a30:	1080038b 	ldhu	r2,14(r2)
80117a34:	10bfffcc 	andi	r2,r2,65535
80117a38:	10c000a0 	cmpeqi	r3,r2,2
80117a3c:	1800101e 	bne	r3,zero,80117a80 <vPusType251run+0x80>
80117a40:	10c00160 	cmpeqi	r3,r2,5
80117a44:	1800191e 	bne	r3,zero,80117aac <vPusType251run+0xac>
80117a48:	10800060 	cmpeqi	r2,r2,1
80117a4c:	1000011e 	bne	r2,zero,80117a54 <vPusType251run+0x54>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
			}
			#endif
			break;
80117a50:	00002106 	br	80117ad8 <vPusType251run+0xd8>
	usiFeeInstL = xPusL->usiValues[0];
	switch (xPusL->usiSubType) {
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
80117a54:	e0bffd0b 	ldhu	r2,-12(fp)
80117a58:	10800444 	addi	r2,r2,17
80117a5c:	10803fcc 	andi	r2,r2,255
80117a60:	e0fffd0b 	ldhu	r3,-12(fp)
80117a64:	18c03fcc 	andi	r3,r3,255
80117a68:	180f883a 	mov	r7,r3
80117a6c:	000d883a 	mov	r6,zero
80117a70:	01400044 	movi	r5,1
80117a74:	1009883a 	mov	r4,r2
80117a78:	0117ee40 	call	80117ee4 <vSendCmdQToNFeeCTRL_GEN>
			break;
80117a7c:	00001606 	br	80117ad8 <vPusType251run+0xd8>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
80117a80:	e0bffd0b 	ldhu	r2,-12(fp)
80117a84:	10800444 	addi	r2,r2,17
80117a88:	10803fcc 	andi	r2,r2,255
80117a8c:	e0fffd0b 	ldhu	r3,-12(fp)
80117a90:	18c03fcc 	andi	r3,r3,255
80117a94:	180f883a 	mov	r7,r3
80117a98:	000d883a 	mov	r6,zero
80117a9c:	01400104 	movi	r5,4
80117aa0:	1009883a 	mov	r4,r2
80117aa4:	0117ee40 	call	80117ee4 <vSendCmdQToNFeeCTRL_GEN>
			break;
80117aa8:	00000b06 	br	80117ad8 <vPusType251run+0xd8>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
80117aac:	e0bffd0b 	ldhu	r2,-12(fp)
80117ab0:	10800444 	addi	r2,r2,17
80117ab4:	10803fcc 	andi	r2,r2,255
80117ab8:	e0fffd0b 	ldhu	r3,-12(fp)
80117abc:	18c03fcc 	andi	r3,r3,255
80117ac0:	180f883a 	mov	r7,r3
80117ac4:	000d883a 	mov	r6,zero
80117ac8:	01400204 	movi	r5,8
80117acc:	1009883a 	mov	r4,r2
80117ad0:	0117ee40 	call	80117ee4 <vSendCmdQToNFeeCTRL_GEN>
			break;
80117ad4:	0001883a 	nop
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
			}
			#endif
			break;
	}
}
80117ad8:	0001883a 	nop
80117adc:	e037883a 	mov	sp,fp
80117ae0:	dfc00117 	ldw	ra,4(sp)
80117ae4:	df000017 	ldw	fp,0(sp)
80117ae8:	dec00204 	addi	sp,sp,8
80117aec:	f800283a 	ret

80117af0 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
80117af0:	defffb04 	addi	sp,sp,-20
80117af4:	de00012e 	bgeu	sp,et,80117afc <vPusType252run+0xc>
80117af8:	003b68fa 	trap	3
80117afc:	dfc00415 	stw	ra,16(sp)
80117b00:	df000315 	stw	fp,12(sp)
80117b04:	df000304 	addi	fp,sp,12
80117b08:	e13ffe15 	stw	r4,-8(fp)
80117b0c:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
80117b10:	e0bfff17 	ldw	r2,-4(fp)
80117b14:	1080050b 	ldhu	r2,20(r2)
80117b18:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
80117b1c:	e0bfff17 	ldw	r2,-4(fp)
80117b20:	1080038b 	ldhu	r2,14(r2)
80117b24:	10bfffcc 	andi	r2,r2,65535
80117b28:	10c000e0 	cmpeqi	r3,r2,3
80117b2c:	18000a1e 	bne	r3,zero,80117b58 <vPusType252run+0x68>
80117b30:	10c00108 	cmpgei	r3,r2,4
80117b34:	1800031e 	bne	r3,zero,80117b44 <vPusType252run+0x54>
80117b38:	108000a0 	cmpeqi	r2,r2,2
80117b3c:	10004a1e 	bne	r2,zero,80117c68 <vPusType252run+0x178>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
80117b40:	00009e06 	br	80117dbc <vPusType252run+0x2cc>

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
	switch (xPusL->usiSubType) {
80117b44:	10c00120 	cmpeqi	r3,r2,4
80117b48:	1800251e 	bne	r3,zero,80117be0 <vPusType252run+0xf0>
80117b4c:	10800160 	cmpeqi	r2,r2,5
80117b50:	1000971e 	bne	r2,zero,80117db0 <vPusType252run+0x2c0>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
80117b54:	00009906 	br	80117dbc <vPusType252run+0x2cc>
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
	switch (xPusL->usiSubType) {
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
80117b58:	e0bffd0b 	ldhu	r2,-12(fp)
80117b5c:	10809b24 	muli	r2,r2,620
80117b60:	1080a904 	addi	r2,r2,676
80117b64:	e0fffe17 	ldw	r3,-8(fp)
80117b68:	1885883a 	add	r2,r3,r2
80117b6c:	1009883a 	mov	r4,r2
80117b70:	010aaf80 	call	8010aaf8 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
80117b74:	e0bffd0b 	ldhu	r2,-12(fp)
80117b78:	e0fffe17 	ldw	r3,-8(fp)
80117b7c:	10809b24 	muli	r2,r2,620
80117b80:	1885883a 	add	r2,r3,r2
80117b84:	1080ab04 	addi	r2,r2,684
80117b88:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
80117b8c:	e0bffd0b 	ldhu	r2,-12(fp)
80117b90:	e0fffe17 	ldw	r3,-8(fp)
80117b94:	10809b24 	muli	r2,r2,620
80117b98:	1885883a 	add	r2,r3,r2
80117b9c:	1080aa04 	addi	r2,r2,680
80117ba0:	00c00044 	movi	r3,1
80117ba4:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
80117ba8:	e0bffd0b 	ldhu	r2,-12(fp)
80117bac:	e0fffe17 	ldw	r3,-8(fp)
80117bb0:	10809b24 	muli	r2,r2,620
80117bb4:	1885883a 	add	r2,r3,r2
80117bb8:	1080ac04 	addi	r2,r2,688
80117bbc:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
80117bc0:	e0bffd0b 	ldhu	r2,-12(fp)
80117bc4:	10809b24 	muli	r2,r2,620
80117bc8:	1080a904 	addi	r2,r2,676
80117bcc:	e0fffe17 	ldw	r3,-8(fp)
80117bd0:	1885883a 	add	r2,r3,r2
80117bd4:	1009883a 	mov	r4,r2
80117bd8:	010a9c00 	call	8010a9c0 <bSpwcSetLink>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
80117bdc:	00007706 	br	80117dbc <vPusType252run+0x2cc>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
80117be0:	e0bffd0b 	ldhu	r2,-12(fp)
80117be4:	10809b24 	muli	r2,r2,620
80117be8:	1080a904 	addi	r2,r2,676
80117bec:	e0fffe17 	ldw	r3,-8(fp)
80117bf0:	1885883a 	add	r2,r3,r2
80117bf4:	1009883a 	mov	r4,r2
80117bf8:	010aaf80 	call	8010aaf8 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
80117bfc:	e0bffd0b 	ldhu	r2,-12(fp)
80117c00:	e0fffe17 	ldw	r3,-8(fp)
80117c04:	10809b24 	muli	r2,r2,620
80117c08:	1885883a 	add	r2,r3,r2
80117c0c:	1080ab04 	addi	r2,r2,684
80117c10:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
80117c14:	e0bffd0b 	ldhu	r2,-12(fp)
80117c18:	e0fffe17 	ldw	r3,-8(fp)
80117c1c:	10809b24 	muli	r2,r2,620
80117c20:	1885883a 	add	r2,r3,r2
80117c24:	1080aa04 	addi	r2,r2,680
80117c28:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
80117c2c:	e0bffd0b 	ldhu	r2,-12(fp)
80117c30:	e0fffe17 	ldw	r3,-8(fp)
80117c34:	10809b24 	muli	r2,r2,620
80117c38:	1885883a 	add	r2,r3,r2
80117c3c:	1080ac04 	addi	r2,r2,688
80117c40:	00c00044 	movi	r3,1
80117c44:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
80117c48:	e0bffd0b 	ldhu	r2,-12(fp)
80117c4c:	10809b24 	muli	r2,r2,620
80117c50:	1080a904 	addi	r2,r2,676
80117c54:	e0fffe17 	ldw	r3,-8(fp)
80117c58:	1885883a 	add	r2,r3,r2
80117c5c:	1009883a 	mov	r4,r2
80117c60:	010a9c00 	call	8010a9c0 <bSpwcSetLink>
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
			}
			#endif

			break;
80117c64:	00005506 	br	80117dbc <vPusType252run+0x2cc>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
80117c68:	e0bffd0b 	ldhu	r2,-12(fp)
80117c6c:	e0fffe17 	ldw	r3,-8(fp)
80117c70:	10809b24 	muli	r2,r2,620
80117c74:	1885883a 	add	r2,r3,r2
80117c78:	10804704 	addi	r2,r2,284
80117c7c:	10800017 	ldw	r2,0(r2)
80117c80:	10800058 	cmpnei	r2,r2,1
80117c84:	10004c1e 	bne	r2,zero,80117db8 <vPusType252run+0x2c8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
80117c88:	e0bffd0b 	ldhu	r2,-12(fp)
80117c8c:	10809b24 	muli	r2,r2,620
80117c90:	10806304 	addi	r2,r2,396
80117c94:	e0fffe17 	ldw	r3,-8(fp)
80117c98:	1885883a 	add	r2,r3,r2
80117c9c:	1009883a 	mov	r4,r2
80117ca0:	01080440 	call	80108044 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
80117ca4:	e0bffd0b 	ldhu	r2,-12(fp)
80117ca8:	e0fffe17 	ldw	r3,-8(fp)
80117cac:	10809b24 	muli	r2,r2,620
80117cb0:	1885883a 	add	r2,r3,r2
80117cb4:	10807304 	addi	r2,r2,460
80117cb8:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
80117cbc:	e0bffd0b 	ldhu	r2,-12(fp)
80117cc0:	10809b24 	muli	r2,r2,620
80117cc4:	10806304 	addi	r2,r2,396
80117cc8:	e0fffe17 	ldw	r3,-8(fp)
80117ccc:	1885883a 	add	r2,r3,r2
80117cd0:	1009883a 	mov	r4,r2
80117cd4:	0107f980 	call	80107f98 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
80117cd8:	e0bffd0b 	ldhu	r2,-12(fp)
80117cdc:	10809b24 	muli	r2,r2,620
80117ce0:	10806304 	addi	r2,r2,396
80117ce4:	e0fffe17 	ldw	r3,-8(fp)
80117ce8:	1885883a 	add	r2,r3,r2
80117cec:	1009883a 	mov	r4,r2
80117cf0:	01082300 	call	80108230 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
80117cf4:	e0bffd0b 	ldhu	r2,-12(fp)
80117cf8:	e0ffff17 	ldw	r3,-4(fp)
80117cfc:	18c00b0b 	ldhu	r3,44(r3)
80117d00:	1809883a 	mov	r4,r3
80117d04:	e0fffe17 	ldw	r3,-8(fp)
80117d08:	10809b24 	muli	r2,r2,620
80117d0c:	1885883a 	add	r2,r3,r2
80117d10:	10806404 	addi	r2,r2,400
80117d14:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
80117d18:	e0bffd0b 	ldhu	r2,-12(fp)
80117d1c:	e0ffff17 	ldw	r3,-4(fp)
80117d20:	18c0098b 	ldhu	r3,38(r3)
80117d24:	1809883a 	mov	r4,r3
80117d28:	e0fffe17 	ldw	r3,-8(fp)
80117d2c:	10809b24 	muli	r2,r2,620
80117d30:	1885883a 	add	r2,r3,r2
80117d34:	10806444 	addi	r2,r2,401
80117d38:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
80117d3c:	e0bffd0b 	ldhu	r2,-12(fp)
80117d40:	10809b24 	muli	r2,r2,620
80117d44:	10806304 	addi	r2,r2,396
80117d48:	e0fffe17 	ldw	r3,-8(fp)
80117d4c:	1885883a 	add	r2,r3,r2
80117d50:	1009883a 	mov	r4,r2
80117d54:	01081540 	call	80108154 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
80117d58:	e0bffd0b 	ldhu	r2,-12(fp)
80117d5c:	10809b24 	muli	r2,r2,620
80117d60:	10806304 	addi	r2,r2,396
80117d64:	e0fffe17 	ldw	r3,-8(fp)
80117d68:	1885883a 	add	r2,r3,r2
80117d6c:	1009883a 	mov	r4,r2
80117d70:	01080440 	call	80108044 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
80117d74:	e0bffd0b 	ldhu	r2,-12(fp)
80117d78:	e0fffe17 	ldw	r3,-8(fp)
80117d7c:	10809b24 	muli	r2,r2,620
80117d80:	1885883a 	add	r2,r3,r2
80117d84:	10807304 	addi	r2,r2,460
80117d88:	00c00044 	movi	r3,1
80117d8c:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
80117d90:	e0bffd0b 	ldhu	r2,-12(fp)
80117d94:	10809b24 	muli	r2,r2,620
80117d98:	10806304 	addi	r2,r2,396
80117d9c:	e0fffe17 	ldw	r3,-8(fp)
80117da0:	1885883a 	add	r2,r3,r2
80117da4:	1009883a 	mov	r4,r2
80117da8:	0107f980 	call	80107f98 <bRmapSetIrqControl>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif
			break;
80117dac:	00000206 	br	80117db8 <vPusType252run+0x2c8>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
80117db0:	0001883a 	nop
80117db4:	00000106 	br	80117dbc <vPusType252run+0x2cc>
			#if DEBUG_ON
			if ( xDefaults.usiDebugLevel <= dlMinorMessage ) {
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			}
			#endif
			break;
80117db8:	0001883a 	nop
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			}
			#endif
			break;
	}
}
80117dbc:	0001883a 	nop
80117dc0:	e037883a 	mov	sp,fp
80117dc4:	dfc00117 	ldw	ra,4(sp)
80117dc8:	df000017 	ldw	fp,0(sp)
80117dcc:	dec00204 	addi	sp,sp,8
80117dd0:	f800283a 	ret

80117dd4 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80117dd4:	defff904 	addi	sp,sp,-28
80117dd8:	de00012e 	bgeu	sp,et,80117de0 <vSendCmdQToNFeeCTRL+0xc>
80117ddc:	003b68fa 	trap	3
80117de0:	dfc00615 	stw	ra,24(sp)
80117de4:	df000515 	stw	fp,20(sp)
80117de8:	df000504 	addi	fp,sp,20
80117dec:	2807883a 	mov	r3,r5
80117df0:	3005883a 	mov	r2,r6
80117df4:	e13ffd05 	stb	r4,-12(fp)
80117df8:	e0fffe05 	stb	r3,-8(fp)
80117dfc:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
80117e00:	00800404 	movi	r2,16
80117e04:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
80117e08:	e0bffd03 	ldbu	r2,-12(fp)
80117e0c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
80117e10:	e0bffe03 	ldbu	r2,-8(fp)
80117e14:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
80117e18:	e0bfff03 	ldbu	r2,-4(fp)
80117e1c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
80117e20:	d0a07917 	ldw	r2,-32284(gp)
80117e24:	e0fffc17 	ldw	r3,-16(fp)
80117e28:	180b883a 	mov	r5,r3
80117e2c:	1009883a 	mov	r4,r2
80117e30:	013940c0 	call	8013940c <OSQPost>
80117e34:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
80117e38:	e0bffb03 	ldbu	r2,-20(fp)
80117e3c:	10000126 	beq	r2,zero,80117e44 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
80117e40:	011db200 	call	8011db20 <vFailSendMsgFeeCTRL>
	}
}
80117e44:	0001883a 	nop
80117e48:	e037883a 	mov	sp,fp
80117e4c:	dfc00117 	ldw	ra,4(sp)
80117e50:	df000017 	ldw	fp,0(sp)
80117e54:	dec00204 	addi	sp,sp,8
80117e58:	f800283a 	ret

80117e5c <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80117e5c:	defff904 	addi	sp,sp,-28
80117e60:	de00012e 	bgeu	sp,et,80117e68 <vSendCmdQToNFeeCTRL_PRIO+0xc>
80117e64:	003b68fa 	trap	3
80117e68:	dfc00615 	stw	ra,24(sp)
80117e6c:	df000515 	stw	fp,20(sp)
80117e70:	df000504 	addi	fp,sp,20
80117e74:	2807883a 	mov	r3,r5
80117e78:	3005883a 	mov	r2,r6
80117e7c:	e13ffd05 	stb	r4,-12(fp)
80117e80:	e0fffe05 	stb	r3,-8(fp)
80117e84:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
80117e88:	00800404 	movi	r2,16
80117e8c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
80117e90:	e0bffd03 	ldbu	r2,-12(fp)
80117e94:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
80117e98:	e0bffe03 	ldbu	r2,-8(fp)
80117e9c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
80117ea0:	e0bfff03 	ldbu	r2,-4(fp)
80117ea4:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
80117ea8:	d0a07917 	ldw	r2,-32284(gp)
80117eac:	e0fffc17 	ldw	r3,-16(fp)
80117eb0:	180b883a 	mov	r5,r3
80117eb4:	1009883a 	mov	r4,r2
80117eb8:	013957c0 	call	8013957c <OSQPostFront>
80117ebc:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
80117ec0:	e0bffb03 	ldbu	r2,-20(fp)
80117ec4:	10000126 	beq	r2,zero,80117ecc <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
80117ec8:	011db200 	call	8011db20 <vFailSendMsgFeeCTRL>
	}
}
80117ecc:	0001883a 	nop
80117ed0:	e037883a 	mov	sp,fp
80117ed4:	dfc00117 	ldw	ra,4(sp)
80117ed8:	df000017 	ldw	fp,0(sp)
80117edc:	dec00204 	addi	sp,sp,8
80117ee0:	f800283a 	ret

80117ee4 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80117ee4:	defff804 	addi	sp,sp,-32
80117ee8:	de00012e 	bgeu	sp,et,80117ef0 <vSendCmdQToNFeeCTRL_GEN+0xc>
80117eec:	003b68fa 	trap	3
80117ef0:	dfc00715 	stw	ra,28(sp)
80117ef4:	df000615 	stw	fp,24(sp)
80117ef8:	df000604 	addi	fp,sp,24
80117efc:	2011883a 	mov	r8,r4
80117f00:	2809883a 	mov	r4,r5
80117f04:	3007883a 	mov	r3,r6
80117f08:	3805883a 	mov	r2,r7
80117f0c:	e23ffc05 	stb	r8,-16(fp)
80117f10:	e13ffd05 	stb	r4,-12(fp)
80117f14:	e0fffe05 	stb	r3,-8(fp)
80117f18:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
80117f1c:	e0bffc03 	ldbu	r2,-16(fp)
80117f20:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
80117f24:	e0bffd03 	ldbu	r2,-12(fp)
80117f28:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
80117f2c:	e0bffe03 	ldbu	r2,-8(fp)
80117f30:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
80117f34:	e0bfff03 	ldbu	r2,-4(fp)
80117f38:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
80117f3c:	d0a07917 	ldw	r2,-32284(gp)
80117f40:	e0fffb17 	ldw	r3,-20(fp)
80117f44:	180b883a 	mov	r5,r3
80117f48:	1009883a 	mov	r4,r2
80117f4c:	013940c0 	call	8013940c <OSQPost>
80117f50:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
80117f54:	e0bffa03 	ldbu	r2,-24(fp)
80117f58:	10000126 	beq	r2,zero,80117f60 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
80117f5c:	011db200 	call	8011db20 <vFailSendMsgFeeCTRL>
	}
}
80117f60:	0001883a 	nop
80117f64:	e037883a 	mov	sp,fp
80117f68:	dfc00117 	ldw	ra,4(sp)
80117f6c:	df000017 	ldw	fp,0(sp)
80117f70:	dec00204 	addi	sp,sp,8
80117f74:	f800283a 	ret

80117f78 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80117f78:	defff904 	addi	sp,sp,-28
80117f7c:	de00012e 	bgeu	sp,et,80117f84 <vSendCmdQToDataCTRL+0xc>
80117f80:	003b68fa 	trap	3
80117f84:	dfc00615 	stw	ra,24(sp)
80117f88:	df000515 	stw	fp,20(sp)
80117f8c:	df000504 	addi	fp,sp,20
80117f90:	2807883a 	mov	r3,r5
80117f94:	3005883a 	mov	r2,r6
80117f98:	e13ffd05 	stb	r4,-12(fp)
80117f9c:	e0fffe05 	stb	r3,-8(fp)
80117fa0:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
80117fa4:	00800804 	movi	r2,32
80117fa8:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
80117fac:	e0bffd03 	ldbu	r2,-12(fp)
80117fb0:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
80117fb4:	e0bffe03 	ldbu	r2,-8(fp)
80117fb8:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
80117fbc:	e0bfff03 	ldbu	r2,-4(fp)
80117fc0:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
80117fc4:	d0a06a17 	ldw	r2,-32344(gp)
80117fc8:	e0fffc17 	ldw	r3,-16(fp)
80117fcc:	180b883a 	mov	r5,r3
80117fd0:	1009883a 	mov	r4,r2
80117fd4:	013940c0 	call	8013940c <OSQPost>
80117fd8:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
80117fdc:	e0bffb03 	ldbu	r2,-20(fp)
80117fe0:	10000126 	beq	r2,zero,80117fe8 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
80117fe4:	011db480 	call	8011db48 <vFailSendMsgDataCTRL>
	}
}
80117fe8:	0001883a 	nop
80117fec:	e037883a 	mov	sp,fp
80117ff0:	dfc00117 	ldw	ra,4(sp)
80117ff4:	df000017 	ldw	fp,0(sp)
80117ff8:	dec00204 	addi	sp,sp,8
80117ffc:	f800283a 	ret

80118000 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
80118000:	defff904 	addi	sp,sp,-28
80118004:	de00012e 	bgeu	sp,et,8011800c <vSendCmdQToDataCTRL_PRIO+0xc>
80118008:	003b68fa 	trap	3
8011800c:	dfc00615 	stw	ra,24(sp)
80118010:	df000515 	stw	fp,20(sp)
80118014:	df000504 	addi	fp,sp,20
80118018:	2807883a 	mov	r3,r5
8011801c:	3005883a 	mov	r2,r6
80118020:	e13ffd05 	stb	r4,-12(fp)
80118024:	e0fffe05 	stb	r3,-8(fp)
80118028:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8011802c:	00800404 	movi	r2,16
80118030:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
80118034:	e0bffd03 	ldbu	r2,-12(fp)
80118038:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8011803c:	e0bffe03 	ldbu	r2,-8(fp)
80118040:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
80118044:	e0bfff03 	ldbu	r2,-4(fp)
80118048:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
8011804c:	d0a06a17 	ldw	r2,-32344(gp)
80118050:	e0fffc17 	ldw	r3,-16(fp)
80118054:	180b883a 	mov	r5,r3
80118058:	1009883a 	mov	r4,r2
8011805c:	013957c0 	call	8013957c <OSQPostFront>
80118060:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
80118064:	e0bffb03 	ldbu	r2,-20(fp)
80118068:	10000126 	beq	r2,zero,80118070 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
8011806c:	011db200 	call	8011db20 <vFailSendMsgFeeCTRL>
	}
}
80118070:	0001883a 	nop
80118074:	e037883a 	mov	sp,fp
80118078:	dfc00117 	ldw	ra,4(sp)
8011807c:	df000017 	ldw	fp,0(sp)
80118080:	dec00204 	addi	sp,sp,8
80118084:	f800283a 	ret

80118088 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
80118088:	defffc04 	addi	sp,sp,-16
8011808c:	de00012e 	bgeu	sp,et,80118094 <vMebInit+0xc>
80118090:	003b68fa 	trap	3
80118094:	dfc00315 	stw	ra,12(sp)
80118098:	df000215 	stw	fp,8(sp)
8011809c:	df000204 	addi	fp,sp,8
801180a0:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
801180a4:	e0bfff17 	ldw	r2,-4(fp)
801180a8:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
801180ac:	e0bfff17 	ldw	r2,-4(fp)
801180b0:	00c00044 	movi	r3,1
801180b4:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
801180b8:	d0a07317 	ldw	r2,-32308(gp)
801180bc:	1009883a 	mov	r4,r2
801180c0:	0138f440 	call	80138f44 <OSQFlush>
801180c4:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
801180c8:	e0bffe03 	ldbu	r2,-8(fp)
801180cc:	10000126 	beq	r2,zero,801180d4 <vMebInit+0x4c>
		vFailFlushMEBQueue();
801180d0:	011dbc00 	call	8011dbc0 <vFailFlushMEBQueue>
	}
}
801180d4:	0001883a 	nop
801180d8:	e037883a 	mov	sp,fp
801180dc:	dfc00117 	ldw	ra,4(sp)
801180e0:	df000017 	ldw	fp,0(sp)
801180e4:	dec00204 	addi	sp,sp,8
801180e8:	f800283a 	ret

801180ec <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
801180ec:	defffe04 	addi	sp,sp,-8
801180f0:	de00012e 	bgeu	sp,et,801180f8 <vSwapMemmory+0xc>
801180f4:	003b68fa 	trap	3
801180f8:	df000115 	stw	fp,4(sp)
801180fc:	df000104 	addi	fp,sp,4
80118100:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
80118104:	e0bfff17 	ldw	r2,-4(fp)
80118108:	10800203 	ldbu	r2,8(r2)
8011810c:	10803fcc 	andi	r2,r2,255
80118110:	10c00044 	addi	r3,r2,1
80118114:	00a00034 	movhi	r2,32768
80118118:	10800044 	addi	r2,r2,1
8011811c:	1884703a 	and	r2,r3,r2
80118120:	1000040e 	bge	r2,zero,80118134 <vSwapMemmory+0x48>
80118124:	10bfffc4 	addi	r2,r2,-1
80118128:	00ffff84 	movi	r3,-2
8011812c:	10c4b03a 	or	r2,r2,r3
80118130:	10800044 	addi	r2,r2,1
80118134:	1007883a 	mov	r3,r2
80118138:	e0bfff17 	ldw	r2,-4(fp)
8011813c:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
80118140:	e0bfff17 	ldw	r2,-4(fp)
80118144:	10800243 	ldbu	r2,9(r2)
80118148:	10803fcc 	andi	r2,r2,255
8011814c:	10c00044 	addi	r3,r2,1
80118150:	00a00034 	movhi	r2,32768
80118154:	10800044 	addi	r2,r2,1
80118158:	1884703a 	and	r2,r3,r2
8011815c:	1000040e 	bge	r2,zero,80118170 <vSwapMemmory+0x84>
80118160:	10bfffc4 	addi	r2,r2,-1
80118164:	00ffff84 	movi	r3,-2
80118168:	10c4b03a 	or	r2,r2,r3
8011816c:	10800044 	addi	r2,r2,1
80118170:	1007883a 	mov	r3,r2
80118174:	e0bfff17 	ldw	r2,-4(fp)
80118178:	10c00245 	stb	r3,9(r2)

}
8011817c:	0001883a 	nop
80118180:	e037883a 	mov	sp,fp
80118184:	df000017 	ldw	fp,0(sp)
80118188:	dec00104 	addi	sp,sp,4
8011818c:	f800283a 	ret

80118190 <vEnterConfigRoutine>:


void vEnterConfigRoutine( void ) {
80118190:	defffe04 	addi	sp,sp,-8
80118194:	de00012e 	bgeu	sp,et,8011819c <vEnterConfigRoutine+0xc>
80118198:	003b68fa 	trap	3
8011819c:	dfc00115 	stw	ra,4(sp)
801181a0:	df000015 	stw	fp,0(sp)
801181a4:	d839883a 	mov	fp,sp

	/* Stop the Sync (Stopping the simulation) */
	bStopSync();
801181a8:	011f1900 	call	8011f190 <bStopSync>
	vSyncClearCounter();
801181ac:	010d2940 	call	8010d294 <vSyncClearCounter>

	/* Give time to all tasks receive the command */
	OSTimeDlyHMSM(0, 0, 0, 5);
801181b0:	01c00144 	movi	r7,5
801181b4:	000d883a 	mov	r6,zero
801181b8:	000b883a 	mov	r5,zero
801181bc:	0009883a 	mov	r4,zero
801181c0:	013be940 	call	8013be94 <OSTimeDlyHMSM>

	/* Transition to Config Mode (Ending the simulation) */
	/* Send a message to the NFEE Controller forcing the mode */
	vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
801181c4:	000d883a 	mov	r6,zero
801181c8:	000b883a 	mov	r5,zero
801181cc:	01002844 	movi	r4,161
801181d0:	0117e5c0 	call	80117e5c <vSendCmdQToNFeeCTRL_PRIO>
	vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
801181d4:	000d883a 	mov	r6,zero
801181d8:	000b883a 	mov	r5,zero
801181dc:	01002844 	movi	r4,161
801181e0:	01180000 	call	80118000 <vSendCmdQToDataCTRL_PRIO>

	/* Give time to all tasks receive the command */
	OSTimeDlyHMSM(0, 0, 0, 250);
801181e4:	01c03e84 	movi	r7,250
801181e8:	000d883a 	mov	r6,zero
801181ec:	000b883a 	mov	r5,zero
801181f0:	0009883a 	mov	r4,zero
801181f4:	013be940 	call	8013be94 <OSTimeDlyHMSM>

	bDisableIsoDrivers();
801181f8:	010b1780 	call	8010b178 <bDisableIsoDrivers>
	bDisableLvdsBoard();
801181fc:	010b1f00 	call	8010b1f0 <bDisableLvdsBoard>

}
80118200:	0001883a 	nop
80118204:	e037883a 	mov	sp,fp
80118208:	dfc00117 	ldw	ra,4(sp)
8011820c:	df000017 	ldw	fp,0(sp)
80118210:	dec00204 	addi	sp,sp,8
80118214:	f800283a 	ret

80118218 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
80118218:	defffc04 	addi	sp,sp,-16
8011821c:	de00012e 	bgeu	sp,et,80118224 <vTimeoutCheckerTaskv2+0xc>
80118220:	003b68fa 	trap	3
80118224:	dfc00315 	stw	ra,12(sp)
80118228:	df000215 	stw	fp,8(sp)
8011822c:	df000204 	addi	fp,sp,8
80118230:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
80118234:	e03ffe05 	stb	zero,-8(fp)
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
	}
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
80118238:	d0a07117 	ldw	r2,-32316(gp)
8011823c:	e1bffe04 	addi	r6,fp,-8
80118240:	000b883a 	mov	r5,zero
80118244:	1009883a 	mov	r4,r2
80118248:	0139efc0 	call	80139efc <OSSemPend>

        if ( ucErrorCode == OS_NO_ERR ) {
8011824c:	e0bffe03 	ldbu	r2,-8(fp)
80118250:	10803fcc 	andi	r2,r2,255
80118254:	1000021e 	bne	r2,zero,80118260 <vTimeoutCheckerTaskv2+0x48>
            /* Just check the restransmission buffer */
            vCheck();
80118258:	01182680 	call	80118268 <vCheck>
8011825c:	003ff606 	br	80118238 <__reset+0xfa0f8238>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
80118260:	011d4bc0 	call	8011d4bc <vFailGetBlockingSemTimeoutTask>
        }
    }
80118264:	003ff406 	br	80118238 <__reset+0xfa0f8238>

80118268 <vCheck>:
}


void vCheck( void ) {
80118268:	defffd04 	addi	sp,sp,-12
8011826c:	de00012e 	bgeu	sp,et,80118274 <vCheck+0xc>
80118270:	003b68fa 	trap	3
80118274:	dfc00215 	stw	ra,8(sp)
80118278:	df000115 	stw	fp,4(sp)
8011827c:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
80118280:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
80118284:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
80118288:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8011828c:	d0a07283 	ldbu	r2,-32310(gp)
80118290:	10803fcc 	andi	r2,r2,255
80118294:	10800218 	cmpnei	r2,r2,8
80118298:	1000021e 	bne	r2,zero,801182a4 <vCheck+0x3c>
8011829c:	00c00104 	movi	r3,4
801182a0:	00000106 	br	801182a8 <vCheck+0x40>
801182a4:	0007883a 	mov	r3,zero
801182a8:	d0a07e03 	ldbu	r2,-32264(gp)
801182ac:	10803fcc 	andi	r2,r2,255
801182b0:	10800218 	cmpnei	r2,r2,8
801182b4:	1000021e 	bne	r2,zero,801182c0 <vCheck+0x58>
801182b8:	00800084 	movi	r2,2
801182bc:	00000106 	br	801182c4 <vCheck+0x5c>
801182c0:	0005883a 	mov	r2,zero
801182c4:	1884b03a 	or	r2,r3,r2
801182c8:	1007883a 	mov	r3,r2
801182cc:	d0a07e43 	ldbu	r2,-32263(gp)
801182d0:	10803fcc 	andi	r2,r2,255
801182d4:	108001a0 	cmpeqi	r2,r2,6
801182d8:	1884b03a 	or	r2,r3,r2
801182dc:	1007883a 	mov	r3,r2
801182e0:	e0bfff03 	ldbu	r2,-4(fp)
801182e4:	1884b03a 	or	r2,r3,r2
801182e8:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
801182ec:	e0bfff03 	ldbu	r2,-4(fp)
801182f0:	108001d8 	cmpnei	r2,r2,7
801182f4:	10002f26 	beq	r2,zero,801183b4 <vCheck+0x14c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
801182f8:	d0a07d17 	ldw	r2,-32268(gp)
801182fc:	e0ffff44 	addi	r3,fp,-3
80118300:	180d883a 	mov	r6,r3
80118304:	000b883a 	mov	r5,zero
80118308:	1009883a 	mov	r4,r2
8011830c:	0137ef00 	call	80137ef0 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
80118310:	e0bfff43 	ldbu	r2,-3(fp)
80118314:	10803fcc 	andi	r2,r2,255
80118318:	1000281e 	bne	r2,zero,801183bc <vCheck+0x154>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8011831c:	e0bfff03 	ldbu	r2,-4(fp)
80118320:	1080004c 	andi	r2,r2,1
80118324:	10803fcc 	andi	r2,r2,255
80118328:	1000021e 	bne	r2,zero,80118334 <vCheck+0xcc>
        vCheckRetransmission128();
8011832c:	01183d40 	call	801183d4 <vCheckRetransmission128>
80118330:	00000506 	br	80118348 <vCheck+0xe0>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
80118334:	01800604 	movi	r6,24
80118338:	000b883a 	mov	r5,zero
8011833c:	01200574 	movhi	r4,32789
80118340:	211a3c04 	addi	r4,r4,26864
80118344:	01215b40 	call	801215b4 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
80118348:	e0bfff03 	ldbu	r2,-4(fp)
8011834c:	1080008c 	andi	r2,r2,2
80118350:	10803fcc 	andi	r2,r2,255
80118354:	1000021e 	bne	r2,zero,80118360 <vCheck+0xf8>
        vCheckRetransmission64();
80118358:	01186580 	call	80118658 <vCheckRetransmission64>
8011835c:	00000506 	br	80118374 <vCheck+0x10c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
80118360:	01800804 	movi	r6,32
80118364:	000b883a 	mov	r5,zero
80118368:	01200574 	movhi	r4,32789
8011836c:	211a4204 	addi	r4,r4,26888
80118370:	01215b40 	call	801215b4 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
80118374:	e0bfff03 	ldbu	r2,-4(fp)
80118378:	1080010c 	andi	r2,r2,4
8011837c:	10803fcc 	andi	r2,r2,255
80118380:	1000021e 	bne	r2,zero,8011838c <vCheck+0x124>
        vCheckRetransmission32();
80118384:	01188e40 	call	801188e4 <vCheckRetransmission32>
80118388:	00000506 	br	801183a0 <vCheck+0x138>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
8011838c:	01800804 	movi	r6,32
80118390:	000b883a 	mov	r5,zero
80118394:	01200574 	movhi	r4,32789
80118398:	211a4a04 	addi	r4,r4,26920
8011839c:	01215b40 	call	801215b4 <memset>


    OSMutexPost(xTxUARTMutex);
801183a0:	d0a07d17 	ldw	r2,-32268(gp)
801183a4:	1009883a 	mov	r4,r2
801183a8:	01384940 	call	80138494 <OSMutexPost>

    return;
801183ac:	0001883a 	nop
801183b0:	00000306 	br	801183c0 <vCheck+0x158>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
801183b4:	0001883a 	nop
801183b8:	00000106 	br	801183c0 <vCheck+0x158>
		#if DEBUG_ON
    	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
    	}
		#endif
        return;
801183bc:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
801183c0:	e037883a 	mov	sp,fp
801183c4:	dfc00117 	ldw	ra,4(sp)
801183c8:	df000017 	ldw	fp,0(sp)
801183cc:	dec00204 	addi	sp,sp,8
801183d0:	f800283a 	ret

801183d4 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
801183d4:	defffd04 	addi	sp,sp,-12
801183d8:	de00012e 	bgeu	sp,et,801183e0 <vCheckRetransmission128+0xc>
801183dc:	003b68fa 	trap	3
801183e0:	dfc00215 	stw	ra,8(sp)
801183e4:	df000115 	stw	fp,4(sp)
801183e8:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
801183ec:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
801183f0:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
801183f4:	d0a07717 	ldw	r2,-32292(gp)
801183f8:	e0ffff44 	addi	r3,fp,-3
801183fc:	180b883a 	mov	r5,r3
80118400:	1009883a 	mov	r4,r2
80118404:	01378700 	call	80137870 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
80118408:	e0bfff43 	ldbu	r2,-3(fp)
8011840c:	10803fcc 	andi	r2,r2,255
80118410:	10008b1e 	bne	r2,zero,80118640 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
80118414:	e03fff05 	stb	zero,-4(fp)
80118418:	00008106 	br	80118620 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
8011841c:	e0ffff03 	ldbu	r3,-4(fp)
80118420:	00a00574 	movhi	r2,32789
80118424:	109a3c04 	addi	r2,r2,26864
80118428:	18c7883a 	add	r3,r3,r3
8011842c:	18c7883a 	add	r3,r3,r3
80118430:	10c5883a 	add	r2,r2,r3
80118434:	10800017 	ldw	r2,0(r2)
80118438:	10800058 	cmpnei	r2,r2,1
8011843c:	1000751e 	bne	r2,zero,80118614 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
80118440:	e0ffff03 	ldbu	r3,-4(fp)
80118444:	00a00574 	movhi	r2,32789
80118448:	109a6204 	addi	r2,r2,27016
8011844c:	18c02324 	muli	r3,r3,140
80118450:	10c5883a 	add	r2,r2,r3
80118454:	10802004 	addi	r2,r2,128
80118458:	10800017 	ldw	r2,0(r2)
8011845c:	10800058 	cmpnei	r2,r2,1
80118460:	1000211e 	bne	r2,zero,801184e8 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
80118464:	e0ffff03 	ldbu	r3,-4(fp)
80118468:	00a00574 	movhi	r2,32789
8011846c:	109a6204 	addi	r2,r2,27016
80118470:	19002324 	muli	r4,r3,140
80118474:	1105883a 	add	r2,r2,r4
80118478:	10802184 	addi	r2,r2,134
8011847c:	1080000b 	ldhu	r2,0(r2)
80118480:	10800044 	addi	r2,r2,1
80118484:	100b883a 	mov	r5,r2
80118488:	00a00574 	movhi	r2,32789
8011848c:	109a6204 	addi	r2,r2,27016
80118490:	19002324 	muli	r4,r3,140
80118494:	1105883a 	add	r2,r2,r4
80118498:	10802184 	addi	r2,r2,134
8011849c:	1140000d 	sth	r5,0(r2)
801184a0:	00a00574 	movhi	r2,32789
801184a4:	109a6204 	addi	r2,r2,27016
801184a8:	18c02324 	muli	r3,r3,140
801184ac:	10c5883a 	add	r2,r2,r3
801184b0:	10802184 	addi	r2,r2,134
801184b4:	1080000b 	ldhu	r2,0(r2)
801184b8:	10bfffcc 	andi	r2,r2,65535
801184bc:	10a0001c 	xori	r2,r2,32768
801184c0:	10a00004 	addi	r2,r2,-32768
801184c4:	10800090 	cmplti	r2,r2,2
801184c8:	1000071e 	bne	r2,zero,801184e8 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
801184cc:	e0ffff03 	ldbu	r3,-4(fp)
801184d0:	00a00574 	movhi	r2,32789
801184d4:	109a6204 	addi	r2,r2,27016
801184d8:	18c02324 	muli	r3,r3,140
801184dc:	10c5883a 	add	r2,r2,r3
801184e0:	10802004 	addi	r2,r2,128
801184e4:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
801184e8:	e0ffff03 	ldbu	r3,-4(fp)
801184ec:	00a00574 	movhi	r2,32789
801184f0:	109a6204 	addi	r2,r2,27016
801184f4:	18c02324 	muli	r3,r3,140
801184f8:	10c5883a 	add	r2,r2,r3
801184fc:	10802004 	addi	r2,r2,128
80118500:	10800017 	ldw	r2,0(r2)
80118504:	1000431e 	bne	r2,zero,80118614 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
80118508:	e0bfff03 	ldbu	r2,-4(fp)
8011850c:	10c02324 	muli	r3,r2,140
80118510:	00a00574 	movhi	r2,32789
80118514:	109a6204 	addi	r2,r2,27016
80118518:	1885883a 	add	r2,r3,r2
8011851c:	1009883a 	mov	r4,r2
80118520:	01217a40 	call	801217a4 <puts>
                xBuffer128[ucIL].bSent = TRUE;
80118524:	e0ffff03 	ldbu	r3,-4(fp)
80118528:	00a00574 	movhi	r2,32789
8011852c:	109a6204 	addi	r2,r2,27016
80118530:	18c02324 	muli	r3,r3,140
80118534:	10c5883a 	add	r2,r2,r3
80118538:	10802004 	addi	r2,r2,128
8011853c:	00c00044 	movi	r3,1
80118540:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
80118544:	e0ffff03 	ldbu	r3,-4(fp)
80118548:	00a00574 	movhi	r2,32789
8011854c:	109a6204 	addi	r2,r2,27016
80118550:	18c02324 	muli	r3,r3,140
80118554:	10c5883a 	add	r2,r2,r3
80118558:	10802184 	addi	r2,r2,134
8011855c:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
80118560:	e0ffff03 	ldbu	r3,-4(fp)
80118564:	00a00574 	movhi	r2,32789
80118568:	109a6204 	addi	r2,r2,27016
8011856c:	19002324 	muli	r4,r3,140
80118570:	1105883a 	add	r2,r2,r4
80118574:	10802204 	addi	r2,r2,136
80118578:	10800003 	ldbu	r2,0(r2)
8011857c:	10800044 	addi	r2,r2,1
80118580:	100b883a 	mov	r5,r2
80118584:	00a00574 	movhi	r2,32789
80118588:	109a6204 	addi	r2,r2,27016
8011858c:	19002324 	muli	r4,r3,140
80118590:	1105883a 	add	r2,r2,r4
80118594:	10802204 	addi	r2,r2,136
80118598:	11400005 	stb	r5,0(r2)
8011859c:	00a00574 	movhi	r2,32789
801185a0:	109a6204 	addi	r2,r2,27016
801185a4:	18c02324 	muli	r3,r3,140
801185a8:	10c5883a 	add	r2,r2,r3
801185ac:	10802204 	addi	r2,r2,136
801185b0:	10800003 	ldbu	r2,0(r2)
801185b4:	10803fcc 	andi	r2,r2,255
801185b8:	108000b0 	cmpltui	r2,r2,2
801185bc:	1000151e 	bne	r2,zero,80118614 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
801185c0:	e0ffff03 	ldbu	r3,-4(fp)
801185c4:	00a00574 	movhi	r2,32789
801185c8:	109a3c04 	addi	r2,r2,26864
801185cc:	18c7883a 	add	r3,r3,r3
801185d0:	18c7883a 	add	r3,r3,r3
801185d4:	10c5883a 	add	r2,r2,r3
801185d8:	10000015 	stw	zero,0(r2)
                    SemCount128++;
801185dc:	d0a07e43 	ldbu	r2,-32263(gp)
801185e0:	10800044 	addi	r2,r2,1
801185e4:	d0a07e45 	stb	r2,-32263(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
801185e8:	d0a06d17 	ldw	r2,-32332(gp)
801185ec:	1009883a 	mov	r4,r2
801185f0:	013a2840 	call	8013a284 <OSSemPost>
801185f4:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
801185f8:	e0bfff43 	ldbu	r2,-3(fp)
801185fc:	10803fcc 	andi	r2,r2,255
80118600:	10000426 	beq	r2,zero,80118614 <vCheckRetransmission128+0x240>
                        SemCount128--;
80118604:	d0a07e43 	ldbu	r2,-32263(gp)
80118608:	10bfffc4 	addi	r2,r2,-1
8011860c:	d0a07e45 	stb	r2,-32263(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
80118610:	011d1c40 	call	8011d1c4 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
80118614:	e0bfff03 	ldbu	r2,-4(fp)
80118618:	10800044 	addi	r2,r2,1
8011861c:	e0bfff05 	stb	r2,-4(fp)
80118620:	e0bfff03 	ldbu	r2,-4(fp)
80118624:	108001b0 	cmpltui	r2,r2,6
80118628:	103f7c1e 	bne	r2,zero,8011841c <__reset+0xfa0f841c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
8011862c:	d0a07717 	ldw	r2,-32292(gp)
80118630:	1009883a 	mov	r4,r2
80118634:	01384940 	call	80138494 <OSMutexPost>

    return;
80118638:	0001883a 	nop
8011863c:	00000106 	br	80118644 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
80118640:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
80118644:	e037883a 	mov	sp,fp
80118648:	dfc00117 	ldw	ra,4(sp)
8011864c:	df000017 	ldw	fp,0(sp)
80118650:	dec00204 	addi	sp,sp,8
80118654:	f800283a 	ret

80118658 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
80118658:	defffd04 	addi	sp,sp,-12
8011865c:	de00012e 	bgeu	sp,et,80118664 <vCheckRetransmission64+0xc>
80118660:	003b68fa 	trap	3
80118664:	dfc00215 	stw	ra,8(sp)
80118668:	df000115 	stw	fp,4(sp)
8011866c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
80118670:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
80118674:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
80118678:	d0a07a17 	ldw	r2,-32280(gp)
8011867c:	e0ffff44 	addi	r3,fp,-3
80118680:	180b883a 	mov	r5,r3
80118684:	1009883a 	mov	r4,r2
80118688:	01378700 	call	80137870 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8011868c:	e0bfff43 	ldbu	r2,-3(fp)
80118690:	10803fcc 	andi	r2,r2,255
80118694:	10008d1e 	bne	r2,zero,801188cc <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
80118698:	e03fff05 	stb	zero,-4(fp)
8011869c:	00008306 	br	801188ac <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
801186a0:	e0ffff03 	ldbu	r3,-4(fp)
801186a4:	00a00574 	movhi	r2,32789
801186a8:	109a3c04 	addi	r2,r2,26864
801186ac:	18c00184 	addi	r3,r3,6
801186b0:	18c7883a 	add	r3,r3,r3
801186b4:	18c7883a 	add	r3,r3,r3
801186b8:	10c5883a 	add	r2,r2,r3
801186bc:	10800017 	ldw	r2,0(r2)
801186c0:	10800058 	cmpnei	r2,r2,1
801186c4:	1000761e 	bne	r2,zero,801188a0 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
801186c8:	e0ffff03 	ldbu	r3,-4(fp)
801186cc:	00a00574 	movhi	r2,32789
801186d0:	10b3f504 	addi	r2,r2,-12332
801186d4:	18c01324 	muli	r3,r3,76
801186d8:	10c5883a 	add	r2,r2,r3
801186dc:	10801004 	addi	r2,r2,64
801186e0:	10800017 	ldw	r2,0(r2)
801186e4:	10800058 	cmpnei	r2,r2,1
801186e8:	1000211e 	bne	r2,zero,80118770 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
801186ec:	e0ffff03 	ldbu	r3,-4(fp)
801186f0:	00a00574 	movhi	r2,32789
801186f4:	10b3f504 	addi	r2,r2,-12332
801186f8:	19001324 	muli	r4,r3,76
801186fc:	1105883a 	add	r2,r2,r4
80118700:	10801184 	addi	r2,r2,70
80118704:	1080000b 	ldhu	r2,0(r2)
80118708:	10800044 	addi	r2,r2,1
8011870c:	100b883a 	mov	r5,r2
80118710:	00a00574 	movhi	r2,32789
80118714:	10b3f504 	addi	r2,r2,-12332
80118718:	19001324 	muli	r4,r3,76
8011871c:	1105883a 	add	r2,r2,r4
80118720:	10801184 	addi	r2,r2,70
80118724:	1140000d 	sth	r5,0(r2)
80118728:	00a00574 	movhi	r2,32789
8011872c:	10b3f504 	addi	r2,r2,-12332
80118730:	18c01324 	muli	r3,r3,76
80118734:	10c5883a 	add	r2,r2,r3
80118738:	10801184 	addi	r2,r2,70
8011873c:	1080000b 	ldhu	r2,0(r2)
80118740:	10bfffcc 	andi	r2,r2,65535
80118744:	10a0001c 	xori	r2,r2,32768
80118748:	10a00004 	addi	r2,r2,-32768
8011874c:	10800090 	cmplti	r2,r2,2
80118750:	1000071e 	bne	r2,zero,80118770 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
80118754:	e0ffff03 	ldbu	r3,-4(fp)
80118758:	00a00574 	movhi	r2,32789
8011875c:	10b3f504 	addi	r2,r2,-12332
80118760:	18c01324 	muli	r3,r3,76
80118764:	10c5883a 	add	r2,r2,r3
80118768:	10801004 	addi	r2,r2,64
8011876c:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
80118770:	e0ffff03 	ldbu	r3,-4(fp)
80118774:	00a00574 	movhi	r2,32789
80118778:	10b3f504 	addi	r2,r2,-12332
8011877c:	18c01324 	muli	r3,r3,76
80118780:	10c5883a 	add	r2,r2,r3
80118784:	10801004 	addi	r2,r2,64
80118788:	10800017 	ldw	r2,0(r2)
8011878c:	1000441e 	bne	r2,zero,801188a0 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
80118790:	e0bfff03 	ldbu	r2,-4(fp)
80118794:	10c01324 	muli	r3,r2,76
80118798:	00a00574 	movhi	r2,32789
8011879c:	10b3f504 	addi	r2,r2,-12332
801187a0:	1885883a 	add	r2,r3,r2
801187a4:	1009883a 	mov	r4,r2
801187a8:	01217a40 	call	801217a4 <puts>
                xBuffer64[ucIL].bSent = TRUE;
801187ac:	e0ffff03 	ldbu	r3,-4(fp)
801187b0:	00a00574 	movhi	r2,32789
801187b4:	10b3f504 	addi	r2,r2,-12332
801187b8:	18c01324 	muli	r3,r3,76
801187bc:	10c5883a 	add	r2,r2,r3
801187c0:	10801004 	addi	r2,r2,64
801187c4:	00c00044 	movi	r3,1
801187c8:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
801187cc:	e0ffff03 	ldbu	r3,-4(fp)
801187d0:	00a00574 	movhi	r2,32789
801187d4:	10b3f504 	addi	r2,r2,-12332
801187d8:	18c01324 	muli	r3,r3,76
801187dc:	10c5883a 	add	r2,r2,r3
801187e0:	10801184 	addi	r2,r2,70
801187e4:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
801187e8:	e0ffff03 	ldbu	r3,-4(fp)
801187ec:	00a00574 	movhi	r2,32789
801187f0:	10b3f504 	addi	r2,r2,-12332
801187f4:	19001324 	muli	r4,r3,76
801187f8:	1105883a 	add	r2,r2,r4
801187fc:	10801204 	addi	r2,r2,72
80118800:	10800003 	ldbu	r2,0(r2)
80118804:	10800044 	addi	r2,r2,1
80118808:	100b883a 	mov	r5,r2
8011880c:	00a00574 	movhi	r2,32789
80118810:	10b3f504 	addi	r2,r2,-12332
80118814:	19001324 	muli	r4,r3,76
80118818:	1105883a 	add	r2,r2,r4
8011881c:	10801204 	addi	r2,r2,72
80118820:	11400005 	stb	r5,0(r2)
80118824:	00a00574 	movhi	r2,32789
80118828:	10b3f504 	addi	r2,r2,-12332
8011882c:	18c01324 	muli	r3,r3,76
80118830:	10c5883a 	add	r2,r2,r3
80118834:	10801204 	addi	r2,r2,72
80118838:	10800003 	ldbu	r2,0(r2)
8011883c:	10803fcc 	andi	r2,r2,255
80118840:	108000b0 	cmpltui	r2,r2,2
80118844:	1000161e 	bne	r2,zero,801188a0 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
80118848:	e0ffff03 	ldbu	r3,-4(fp)
8011884c:	00a00574 	movhi	r2,32789
80118850:	109a3c04 	addi	r2,r2,26864
80118854:	18c00184 	addi	r3,r3,6
80118858:	18c7883a 	add	r3,r3,r3
8011885c:	18c7883a 	add	r3,r3,r3
80118860:	10c5883a 	add	r2,r2,r3
80118864:	10000015 	stw	zero,0(r2)
                    SemCount64++;
80118868:	d0a07e03 	ldbu	r2,-32264(gp)
8011886c:	10800044 	addi	r2,r2,1
80118870:	d0a07e05 	stb	r2,-32264(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
80118874:	d0a06917 	ldw	r2,-32348(gp)
80118878:	1009883a 	mov	r4,r2
8011887c:	013a2840 	call	8013a284 <OSSemPost>
80118880:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
80118884:	e0bfff43 	ldbu	r2,-3(fp)
80118888:	10803fcc 	andi	r2,r2,255
8011888c:	10000426 	beq	r2,zero,801188a0 <vCheckRetransmission64+0x248>
                        SemCount64--;
80118890:	d0a07e03 	ldbu	r2,-32264(gp)
80118894:	10bfffc4 	addi	r2,r2,-1
80118898:	d0a07e05 	stb	r2,-32264(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8011889c:	011d19c0 	call	8011d19c <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
801188a0:	e0bfff03 	ldbu	r2,-4(fp)
801188a4:	10800044 	addi	r2,r2,1
801188a8:	e0bfff05 	stb	r2,-4(fp)
801188ac:	e0bfff03 	ldbu	r2,-4(fp)
801188b0:	10800230 	cmpltui	r2,r2,8
801188b4:	103f7a1e 	bne	r2,zero,801186a0 <__reset+0xfa0f86a0>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
801188b8:	d0a07a17 	ldw	r2,-32280(gp)
801188bc:	1009883a 	mov	r4,r2
801188c0:	01384940 	call	80138494 <OSMutexPost>

    return;
801188c4:	0001883a 	nop
801188c8:	00000106 	br	801188d0 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
801188cc:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
801188d0:	e037883a 	mov	sp,fp
801188d4:	dfc00117 	ldw	ra,4(sp)
801188d8:	df000017 	ldw	fp,0(sp)
801188dc:	dec00204 	addi	sp,sp,8
801188e0:	f800283a 	ret

801188e4 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
801188e4:	defffd04 	addi	sp,sp,-12
801188e8:	de00012e 	bgeu	sp,et,801188f0 <vCheckRetransmission32+0xc>
801188ec:	003b68fa 	trap	3
801188f0:	dfc00215 	stw	ra,8(sp)
801188f4:	df000115 	stw	fp,4(sp)
801188f8:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
801188fc:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
80118900:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
80118904:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
80118908:	d0a07517 	ldw	r2,-32300(gp)
8011890c:	e0ffff84 	addi	r3,fp,-2
80118910:	180b883a 	mov	r5,r3
80118914:	1009883a 	mov	r4,r2
80118918:	01378700 	call	80137870 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8011891c:	e0bfff83 	ldbu	r2,-2(fp)
80118920:	10803fcc 	andi	r2,r2,255
80118924:	10009b1e 	bne	r2,zero,80118b94 <vCheckRetransmission32+0x2b0>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
80118928:	e03fff05 	stb	zero,-4(fp)
8011892c:	00009106 	br	80118b74 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
80118930:	e0ffff03 	ldbu	r3,-4(fp)
80118934:	00a00574 	movhi	r2,32789
80118938:	109a3c04 	addi	r2,r2,26864
8011893c:	18c00384 	addi	r3,r3,14
80118940:	18c7883a 	add	r3,r3,r3
80118944:	18c7883a 	add	r3,r3,r3
80118948:	10c5883a 	add	r2,r2,r3
8011894c:	10800017 	ldw	r2,0(r2)
80118950:	10800058 	cmpnei	r2,r2,1
80118954:	1000841e 	bne	r2,zero,80118b68 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
80118958:	e0ffff03 	ldbu	r3,-4(fp)
8011895c:	00a00574 	movhi	r2,32789
80118960:	1087c404 	addi	r2,r2,7952
80118964:	18c00b24 	muli	r3,r3,44
80118968:	10c5883a 	add	r2,r2,r3
8011896c:	10800804 	addi	r2,r2,32
80118970:	10800017 	ldw	r2,0(r2)
80118974:	10800058 	cmpnei	r2,r2,1
80118978:	1000211e 	bne	r2,zero,80118a00 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
8011897c:	e0ffff03 	ldbu	r3,-4(fp)
80118980:	00a00574 	movhi	r2,32789
80118984:	1087c404 	addi	r2,r2,7952
80118988:	19000b24 	muli	r4,r3,44
8011898c:	1105883a 	add	r2,r2,r4
80118990:	10800984 	addi	r2,r2,38
80118994:	1080000b 	ldhu	r2,0(r2)
80118998:	10800044 	addi	r2,r2,1
8011899c:	100b883a 	mov	r5,r2
801189a0:	00a00574 	movhi	r2,32789
801189a4:	1087c404 	addi	r2,r2,7952
801189a8:	19000b24 	muli	r4,r3,44
801189ac:	1105883a 	add	r2,r2,r4
801189b0:	10800984 	addi	r2,r2,38
801189b4:	1140000d 	sth	r5,0(r2)
801189b8:	00a00574 	movhi	r2,32789
801189bc:	1087c404 	addi	r2,r2,7952
801189c0:	18c00b24 	muli	r3,r3,44
801189c4:	10c5883a 	add	r2,r2,r3
801189c8:	10800984 	addi	r2,r2,38
801189cc:	1080000b 	ldhu	r2,0(r2)
801189d0:	10bfffcc 	andi	r2,r2,65535
801189d4:	10a0001c 	xori	r2,r2,32768
801189d8:	10a00004 	addi	r2,r2,-32768
801189dc:	10800090 	cmplti	r2,r2,2
801189e0:	1000071e 	bne	r2,zero,80118a00 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
801189e4:	e0ffff03 	ldbu	r3,-4(fp)
801189e8:	00a00574 	movhi	r2,32789
801189ec:	1087c404 	addi	r2,r2,7952
801189f0:	18c00b24 	muli	r3,r3,44
801189f4:	10c5883a 	add	r2,r2,r3
801189f8:	10800804 	addi	r2,r2,32
801189fc:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
80118a00:	e0ffff03 	ldbu	r3,-4(fp)
80118a04:	00a00574 	movhi	r2,32789
80118a08:	1087c404 	addi	r2,r2,7952
80118a0c:	18c00b24 	muli	r3,r3,44
80118a10:	10c5883a 	add	r2,r2,r3
80118a14:	10800804 	addi	r2,r2,32
80118a18:	10800017 	ldw	r2,0(r2)
80118a1c:	1000521e 	bne	r2,zero,80118b68 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
80118a20:	e0bfff03 	ldbu	r2,-4(fp)
80118a24:	10c00b24 	muli	r3,r2,44
80118a28:	00a00574 	movhi	r2,32789
80118a2c:	1087c404 	addi	r2,r2,7952
80118a30:	1885883a 	add	r2,r3,r2
80118a34:	1009883a 	mov	r4,r2
80118a38:	01217a40 	call	801217a4 <puts>
                xBuffer32[ucIL].bSent = TRUE;
80118a3c:	e0ffff03 	ldbu	r3,-4(fp)
80118a40:	00a00574 	movhi	r2,32789
80118a44:	1087c404 	addi	r2,r2,7952
80118a48:	18c00b24 	muli	r3,r3,44
80118a4c:	10c5883a 	add	r2,r2,r3
80118a50:	10800804 	addi	r2,r2,32
80118a54:	00c00044 	movi	r3,1
80118a58:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
80118a5c:	e0ffff03 	ldbu	r3,-4(fp)
80118a60:	00a00574 	movhi	r2,32789
80118a64:	1087c404 	addi	r2,r2,7952
80118a68:	18c00b24 	muli	r3,r3,44
80118a6c:	10c5883a 	add	r2,r2,r3
80118a70:	10800984 	addi	r2,r2,38
80118a74:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
80118a78:	e0ffff03 	ldbu	r3,-4(fp)
80118a7c:	00a00574 	movhi	r2,32789
80118a80:	1087c404 	addi	r2,r2,7952
80118a84:	18c00b24 	muli	r3,r3,44
80118a88:	10c5883a 	add	r2,r2,r3
80118a8c:	10800904 	addi	r2,r2,36
80118a90:	1080000b 	ldhu	r2,0(r2)
80118a94:	10bfffcc 	andi	r2,r2,65535
80118a98:	10800058 	cmpnei	r2,r2,1
80118a9c:	1000021e 	bne	r2,zero,80118aa8 <vCheckRetransmission32+0x1c4>
80118aa0:	00bffe84 	movi	r2,-6
80118aa4:	00000106 	br	80118aac <vCheckRetransmission32+0x1c8>
80118aa8:	00800044 	movi	r2,1
80118aac:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
80118ab0:	e0ffff03 	ldbu	r3,-4(fp)
80118ab4:	00a00574 	movhi	r2,32789
80118ab8:	1087c404 	addi	r2,r2,7952
80118abc:	19000b24 	muli	r4,r3,44
80118ac0:	1105883a 	add	r2,r2,r4
80118ac4:	10800a04 	addi	r2,r2,40
80118ac8:	10800003 	ldbu	r2,0(r2)
80118acc:	10800044 	addi	r2,r2,1
80118ad0:	100b883a 	mov	r5,r2
80118ad4:	00a00574 	movhi	r2,32789
80118ad8:	1087c404 	addi	r2,r2,7952
80118adc:	19000b24 	muli	r4,r3,44
80118ae0:	1105883a 	add	r2,r2,r4
80118ae4:	10800a04 	addi	r2,r2,40
80118ae8:	11400005 	stb	r5,0(r2)
80118aec:	00a00574 	movhi	r2,32789
80118af0:	1087c404 	addi	r2,r2,7952
80118af4:	18c00b24 	muli	r3,r3,44
80118af8:	10c5883a 	add	r2,r2,r3
80118afc:	10800a04 	addi	r2,r2,40
80118b00:	10800003 	ldbu	r2,0(r2)
80118b04:	10803fcc 	andi	r2,r2,255
80118b08:	e0ffff43 	ldbu	r3,-3(fp)
80118b0c:	1880162e 	bgeu	r3,r2,80118b68 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
80118b10:	e0ffff03 	ldbu	r3,-4(fp)
80118b14:	00a00574 	movhi	r2,32789
80118b18:	109a3c04 	addi	r2,r2,26864
80118b1c:	18c00384 	addi	r3,r3,14
80118b20:	18c7883a 	add	r3,r3,r3
80118b24:	18c7883a 	add	r3,r3,r3
80118b28:	10c5883a 	add	r2,r2,r3
80118b2c:	10000015 	stw	zero,0(r2)
                    SemCount32++;
80118b30:	d0a07283 	ldbu	r2,-32310(gp)
80118b34:	10800044 	addi	r2,r2,1
80118b38:	d0a07285 	stb	r2,-32310(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
80118b3c:	d0a07817 	ldw	r2,-32288(gp)
80118b40:	1009883a 	mov	r4,r2
80118b44:	013a2840 	call	8013a284 <OSSemPost>
80118b48:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
80118b4c:	e0bfff83 	ldbu	r2,-2(fp)
80118b50:	10803fcc 	andi	r2,r2,255
80118b54:	10000426 	beq	r2,zero,80118b68 <vCheckRetransmission32+0x284>
                        SemCount32--;
80118b58:	d0a07283 	ldbu	r2,-32310(gp)
80118b5c:	10bfffc4 	addi	r2,r2,-1
80118b60:	d0a07285 	stb	r2,-32310(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
80118b64:	011d1740 	call	8011d174 <vFailSetCountSemaphorexBuffer32>
    }
    
    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
80118b68:	e0bfff03 	ldbu	r2,-4(fp)
80118b6c:	10800044 	addi	r2,r2,1
80118b70:	e0bfff05 	stb	r2,-4(fp)
80118b74:	e0bfff03 	ldbu	r2,-4(fp)
80118b78:	10800230 	cmpltui	r2,r2,8
80118b7c:	103f6c1e 	bne	r2,zero,80118930 <__reset+0xfa0f8930>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
80118b80:	d0a07517 	ldw	r2,-32300(gp)
80118b84:	1009883a 	mov	r4,r2
80118b88:	01384940 	call	80138494 <OSMutexPost>

    return;
80118b8c:	0001883a 	nop
80118b90:	00000106 	br	80118b98 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
80118b94:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
80118b98:	e037883a 	mov	sp,fp
80118b9c:	dfc00117 	ldw	ra,4(sp)
80118ba0:	df000017 	ldw	fp,0(sp)
80118ba4:	dec00204 	addi	sp,sp,8
80118ba8:	f800283a 	ret

80118bac <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
80118bac:	defff904 	addi	sp,sp,-28
80118bb0:	de00012e 	bgeu	sp,et,80118bb8 <bResourcesInitRTOS+0xc>
80118bb4:	003b68fa 	trap	3
80118bb8:	dfc00615 	stw	ra,24(sp)
80118bbc:	df000515 	stw	fp,20(sp)
80118bc0:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
80118bc4:	00800044 	movi	r2,1
80118bc8:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
80118bcc:	0009883a 	mov	r4,zero
80118bd0:	0139bd40 	call	80139bd4 <OSSemCreate>
80118bd4:	d0a06b15 	stw	r2,-32340(gp)
	if (!xSemCommInit) {
80118bd8:	d0a06b17 	ldw	r2,-32340(gp)
80118bdc:	1000021e 	bne	r2,zero,80118be8 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
80118be0:	011cedc0 	call	8011cedc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
80118be4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
80118be8:	e0bfff04 	addi	r2,fp,-4
80118bec:	100b883a 	mov	r5,r2
80118bf0:	01000444 	movi	r4,17
80118bf4:	0137a1c0 	call	80137a1c <OSMutexCreate>
80118bf8:	d0a07d15 	stw	r2,-32268(gp)
	if ( err != OS_ERR_NONE ) {
80118bfc:	e0bfff03 	ldbu	r2,-4(fp)
80118c00:	10803fcc 	andi	r2,r2,255
80118c04:	10000526 	beq	r2,zero,80118c1c <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
80118c08:	e0bfff03 	ldbu	r2,-4(fp)
80118c0c:	10803fcc 	andi	r2,r2,255
80118c10:	1009883a 	mov	r4,r2
80118c14:	011ce840 	call	8011ce84 <vFailCreateMutexSResources>
		bSuccess = FALSE;
80118c18:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
80118c1c:	e0bfff04 	addi	r2,fp,-4
80118c20:	100b883a 	mov	r5,r2
80118c24:	01000504 	movi	r4,20
80118c28:	0137a1c0 	call	80137a1c <OSMutexCreate>
80118c2c:	d0a07715 	stw	r2,-32292(gp)
	if ( err != OS_ERR_NONE ) {
80118c30:	e0bfff03 	ldbu	r2,-4(fp)
80118c34:	10803fcc 	andi	r2,r2,255
80118c38:	10000526 	beq	r2,zero,80118c50 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
80118c3c:	e0bfff03 	ldbu	r2,-4(fp)
80118c40:	10803fcc 	andi	r2,r2,255
80118c44:	1009883a 	mov	r4,r2
80118c48:	011ce840 	call	8011ce84 <vFailCreateMutexSResources>
		bSuccess = FALSE;
80118c4c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
80118c50:	e0bfff04 	addi	r2,fp,-4
80118c54:	100b883a 	mov	r5,r2
80118c58:	01000544 	movi	r4,21
80118c5c:	0137a1c0 	call	80137a1c <OSMutexCreate>
80118c60:	d0a07a15 	stw	r2,-32280(gp)
	if ( err != OS_ERR_NONE ) {
80118c64:	e0bfff03 	ldbu	r2,-4(fp)
80118c68:	10803fcc 	andi	r2,r2,255
80118c6c:	10000526 	beq	r2,zero,80118c84 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
80118c70:	e0bfff03 	ldbu	r2,-4(fp)
80118c74:	10803fcc 	andi	r2,r2,255
80118c78:	1009883a 	mov	r4,r2
80118c7c:	011ce840 	call	8011ce84 <vFailCreateMutexSResources>
		bSuccess = FALSE;
80118c80:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
80118c84:	e0bfff04 	addi	r2,fp,-4
80118c88:	100b883a 	mov	r5,r2
80118c8c:	01000584 	movi	r4,22
80118c90:	0137a1c0 	call	80137a1c <OSMutexCreate>
80118c94:	d0a07515 	stw	r2,-32300(gp)
	if ( err != OS_ERR_NONE ) {
80118c98:	e0bfff03 	ldbu	r2,-4(fp)
80118c9c:	10803fcc 	andi	r2,r2,255
80118ca0:	10000526 	beq	r2,zero,80118cb8 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
80118ca4:	e0bfff03 	ldbu	r2,-4(fp)
80118ca8:	10803fcc 	andi	r2,r2,255
80118cac:	1009883a 	mov	r4,r2
80118cb0:	011ce840 	call	8011ce84 <vFailCreateMutexSResources>
		bSuccess = FALSE;
80118cb4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
80118cb8:	00800184 	movi	r2,6
80118cbc:	d0a07e45 	stb	r2,-32263(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
80118cc0:	01000184 	movi	r4,6
80118cc4:	0139bd40 	call	80139bd4 <OSSemCreate>
80118cc8:	d0a06d15 	stw	r2,-32332(gp)
	if (!xSemCountBuffer128) {
80118ccc:	d0a06d17 	ldw	r2,-32332(gp)
80118cd0:	1000031e 	bne	r2,zero,80118ce0 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
80118cd4:	d0207e45 	stb	zero,-32263(gp)
		vFailCreateSemaphoreResources();
80118cd8:	011cedc0 	call	8011cedc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
80118cdc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
80118ce0:	00800204 	movi	r2,8
80118ce4:	d0a07e05 	stb	r2,-32264(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
80118ce8:	01000204 	movi	r4,8
80118cec:	0139bd40 	call	80139bd4 <OSSemCreate>
80118cf0:	d0a06915 	stw	r2,-32348(gp)
	if (!xSemCountBuffer64) {
80118cf4:	d0a06917 	ldw	r2,-32348(gp)
80118cf8:	1000031e 	bne	r2,zero,80118d08 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
80118cfc:	d0207e05 	stb	zero,-32264(gp)
		vFailCreateSemaphoreResources();
80118d00:	011cedc0 	call	8011cedc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
80118d04:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
80118d08:	00800204 	movi	r2,8
80118d0c:	d0a07285 	stb	r2,-32310(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
80118d10:	01000204 	movi	r4,8
80118d14:	0139bd40 	call	80139bd4 <OSSemCreate>
80118d18:	d0a07815 	stw	r2,-32288(gp)
	if (!xSemCountBuffer32) {
80118d1c:	d0a07817 	ldw	r2,-32288(gp)
80118d20:	1000031e 	bne	r2,zero,80118d30 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
80118d24:	d0207285 	stb	zero,-32310(gp)
		vFailCreateSemaphoreResources();
80118d28:	011cedc0 	call	8011cedc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
80118d2c:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
80118d30:	e0bfff04 	addi	r2,fp,-4
80118d34:	100b883a 	mov	r5,r2
80118d38:	010004c4 	movi	r4,19
80118d3c:	0137a1c0 	call	80137a1c <OSMutexCreate>
80118d40:	d0a06f15 	stw	r2,-32324(gp)
	if ( err != OS_ERR_NONE ) {
80118d44:	e0bfff03 	ldbu	r2,-4(fp)
80118d48:	10803fcc 	andi	r2,r2,255
80118d4c:	10000526 	beq	r2,zero,80118d64 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
80118d50:	e0bfff03 	ldbu	r2,-4(fp)
80118d54:	10803fcc 	andi	r2,r2,255
80118d58:	1009883a 	mov	r4,r2
80118d5c:	011ce840 	call	8011ce84 <vFailCreateMutexSResources>
		bSuccess = FALSE;
80118d60:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
80118d64:	e0bfff04 	addi	r2,fp,-4
80118d68:	100b883a 	mov	r5,r2
80118d6c:	010005c4 	movi	r4,23
80118d70:	0137a1c0 	call	80137a1c <OSMutexCreate>
80118d74:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
80118d78:	e0bfff03 	ldbu	r2,-4(fp)
80118d7c:	10803fcc 	andi	r2,r2,255
80118d80:	10000526 	beq	r2,zero,80118d98 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
80118d84:	e0bfff03 	ldbu	r2,-4(fp)
80118d88:	10803fcc 	andi	r2,r2,255
80118d8c:	1009883a 	mov	r4,r2
80118d90:	011ce840 	call	8011ce84 <vFailCreateMutexSResources>
		bSuccess = FALSE;
80118d94:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
80118d98:	0009883a 	mov	r4,zero
80118d9c:	0139bd40 	call	80139bd4 <OSSemCreate>
80118da0:	d0a07015 	stw	r2,-32320(gp)
	if (!xSemCountReceivedACK) {
80118da4:	d0a07017 	ldw	r2,-32320(gp)
80118da8:	1000021e 	bne	r2,zero,80118db4 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
80118dac:	011cedc0 	call	8011cedc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
80118db0:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
80118db4:	0009883a 	mov	r4,zero
80118db8:	0139bd40 	call	80139bd4 <OSSemCreate>
80118dbc:	d0a06e15 	stw	r2,-32328(gp)
	if (!xSemCountPreParsed) {
80118dc0:	d0a06e17 	ldw	r2,-32328(gp)
80118dc4:	1000021e 	bne	r2,zero,80118dd0 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
80118dc8:	011cedc0 	call	8011cedc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
80118dcc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
80118dd0:	0009883a 	mov	r4,zero
80118dd4:	0139bd40 	call	80139bd4 <OSSemCreate>
80118dd8:	d0a06c15 	stw	r2,-32336(gp)
	if (!xSemCountSenderACK) {
80118ddc:	d0a06c17 	ldw	r2,-32336(gp)
80118de0:	1000021e 	bne	r2,zero,80118dec <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
80118de4:	011cedc0 	call	8011cedc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
80118de8:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
80118dec:	e0bfff04 	addi	r2,fp,-4
80118df0:	100b883a 	mov	r5,r2
80118df4:	01000484 	movi	r4,18
80118df8:	0137a1c0 	call	80137a1c <OSMutexCreate>
80118dfc:	d0a07b15 	stw	r2,-32276(gp)
	if ( err != OS_ERR_NONE ) {
80118e00:	e0bfff03 	ldbu	r2,-4(fp)
80118e04:	10803fcc 	andi	r2,r2,255
80118e08:	10000526 	beq	r2,zero,80118e20 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
80118e0c:	e0bfff03 	ldbu	r2,-4(fp)
80118e10:	10803fcc 	andi	r2,r2,255
80118e14:	1009883a 	mov	r4,r2
80118e18:	011ce840 	call	8011ce84 <vFailCreateMutexSResources>
		bSuccess = FALSE;
80118e1c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
80118e20:	0009883a 	mov	r4,zero
80118e24:	0139bd40 	call	80139bd4 <OSSemCreate>
80118e28:	d0a07115 	stw	r2,-32316(gp)
	if (!xSemTimeoutChecker) {
80118e2c:	d0a07117 	ldw	r2,-32316(gp)
80118e30:	1000021e 	bne	r2,zero,80118e3c <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
80118e34:	011cedc0 	call	8011cedc <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
80118e38:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
80118e3c:	e0bfff04 	addi	r2,fp,-4
80118e40:	d8800215 	stw	r2,8(sp)
80118e44:	00a00534 	movhi	r2,32788
80118e48:	109d5e04 	addi	r2,r2,30072
80118e4c:	d8800115 	stw	r2,4(sp)
80118e50:	d8000015 	stw	zero,0(sp)
80118e54:	01e004b4 	movhi	r7,32786
80118e58:	39e9c804 	addi	r7,r7,-22752
80118e5c:	01800084 	movi	r6,2
80118e60:	01400104 	movi	r5,4
80118e64:	01000284 	movi	r4,10
80118e68:	013c2a00 	call	8013c2a0 <OSTmrCreate>
80118e6c:	d0a07615 	stw	r2,-32296(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
80118e70:	e0bfff03 	ldbu	r2,-4(fp)
80118e74:	10803fcc 	andi	r2,r2,255
80118e78:	10000226 	beq	r2,zero,80118e84 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
80118e7c:	011d4440 	call	8011d444 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
80118e80:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
80118e84:	01401004 	movi	r5,64
80118e88:	01200574 	movhi	r4,32789
80118e8c:	2138f104 	addi	r4,r4,-7228
80118e90:	0138b080 	call	80138b08 <OSQCreate>
80118e94:	d0a06815 	stw	r2,-32352(gp)
	if ( xNfeeSchedule == NULL ) {
80118e98:	d0a06817 	ldw	r2,-32352(gp)
80118e9c:	1000021e 	bne	r2,zero,80118ea8 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
80118ea0:	011d6a00 	call	8011d6a0 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
80118ea4:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
80118ea8:	01400404 	movi	r5,16
80118eac:	012005b4 	movhi	r4,32790
80118eb0:	213a2204 	addi	r4,r4,-6008
80118eb4:	0138b080 	call	80138b08 <OSQCreate>
80118eb8:	1007883a 	mov	r3,r2
80118ebc:	00a00574 	movhi	r2,32789
80118ec0:	109f5404 	addi	r2,r2,32080
80118ec4:	10c00015 	stw	r3,0(r2)
	if ( xFeeQ[0] == NULL ) {
80118ec8:	00a00574 	movhi	r2,32789
80118ecc:	109f5404 	addi	r2,r2,32080
80118ed0:	10800017 	ldw	r2,0(r2)
80118ed4:	1000031e 	bne	r2,zero,80118ee4 <bResourcesInitRTOS+0x338>
		vFailCreateNFEEQueue( 0 );
80118ed8:	0009883a 	mov	r4,zero
80118edc:	011d6c80 	call	8011d6c8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
80118ee0:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[1] = OSQCreate(&xFeeQueueTBL1[0], N_MSG_FEE);
80118ee4:	01400404 	movi	r5,16
80118ee8:	012005b4 	movhi	r4,32790
80118eec:	21397204 	addi	r4,r4,-6712
80118ef0:	0138b080 	call	80138b08 <OSQCreate>
80118ef4:	1007883a 	mov	r3,r2
80118ef8:	00a00574 	movhi	r2,32789
80118efc:	109f5404 	addi	r2,r2,32080
80118f00:	10c00115 	stw	r3,4(r2)
	if ( xFeeQ[1] == NULL ) {
80118f04:	00a00574 	movhi	r2,32789
80118f08:	109f5404 	addi	r2,r2,32080
80118f0c:	10800117 	ldw	r2,4(r2)
80118f10:	1000031e 	bne	r2,zero,80118f20 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 1 );
80118f14:	01000044 	movi	r4,1
80118f18:	011d6c80 	call	8011d6c8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
80118f1c:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[2] = OSQCreate(&xFeeQueueTBL2[0], N_MSG_FEE);
80118f20:	01400404 	movi	r5,16
80118f24:	01200574 	movhi	r4,32789
80118f28:	211f5804 	addi	r4,r4,32096
80118f2c:	0138b080 	call	80138b08 <OSQCreate>
80118f30:	1007883a 	mov	r3,r2
80118f34:	00a00574 	movhi	r2,32789
80118f38:	109f5404 	addi	r2,r2,32080
80118f3c:	10c00215 	stw	r3,8(r2)
	if ( xFeeQ[2] == NULL ) {
80118f40:	00a00574 	movhi	r2,32789
80118f44:	109f5404 	addi	r2,r2,32080
80118f48:	10800217 	ldw	r2,8(r2)
80118f4c:	1000031e 	bne	r2,zero,80118f5c <bResourcesInitRTOS+0x3b0>
		vFailCreateNFEEQueue( 2 );
80118f50:	01000084 	movi	r4,2
80118f54:	011d6c80 	call	8011d6c8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
80118f58:	e03ffe15 	stw	zero,-8(fp)
	}
	
	xFeeQ[3] = OSQCreate(&xFeeQueueTBL3[0], N_MSG_FEE);
80118f5c:	01400404 	movi	r5,16
80118f60:	01200574 	movhi	r4,32789
80118f64:	2134e104 	addi	r4,r4,-11388
80118f68:	0138b080 	call	80138b08 <OSQCreate>
80118f6c:	1007883a 	mov	r3,r2
80118f70:	00a00574 	movhi	r2,32789
80118f74:	109f5404 	addi	r2,r2,32080
80118f78:	10c00315 	stw	r3,12(r2)
	if ( xFeeQ[3] == NULL ) {
80118f7c:	00a00574 	movhi	r2,32789
80118f80:	109f5404 	addi	r2,r2,32080
80118f84:	10800317 	ldw	r2,12(r2)
80118f88:	1000031e 	bne	r2,zero,80118f98 <bResourcesInitRTOS+0x3ec>
		vFailCreateNFEEQueue( 3 );
80118f8c:	010000c4 	movi	r4,3
80118f90:	011d6c80 	call	8011d6c8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
80118f94:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;
	}
	*/

	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
80118f98:	01400404 	movi	r5,16
80118f9c:	01200574 	movhi	r4,32789
80118fa0:	211a5204 	addi	r4,r4,26952
80118fa4:	0138b080 	call	80138b08 <OSQCreate>
80118fa8:	d0a07315 	stw	r2,-32308(gp)
	if ( xMebQ == NULL ) {
80118fac:	d0a07317 	ldw	r2,-32308(gp)
80118fb0:	1000031e 	bne	r2,zero,80118fc0 <bResourcesInitRTOS+0x414>
		vFailCreateNFEEQueue( 5 );
80118fb4:	01000144 	movi	r4,5
80118fb8:	011d6c80 	call	8011d6c8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
80118fbc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
80118fc0:	e0bfff04 	addi	r2,fp,-4
80118fc4:	100b883a 	mov	r5,r2
80118fc8:	010001c4 	movi	r4,7
80118fcc:	0137a1c0 	call	80137a1c <OSMutexCreate>
80118fd0:	d0a07c15 	stw	r2,-32272(gp)
	if ( err != OS_ERR_NONE ) {
80118fd4:	e0bfff03 	ldbu	r2,-4(fp)
80118fd8:	10803fcc 	andi	r2,r2,255
80118fdc:	10000526 	beq	r2,zero,80118ff4 <bResourcesInitRTOS+0x448>
		vFailCreateMutexSPUSQueueMeb(err);
80118fe0:	e0bfff03 	ldbu	r2,-4(fp)
80118fe4:	10803fcc 	andi	r2,r2,255
80118fe8:	1009883a 	mov	r4,r2
80118fec:	011d8900 	call	8011d890 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
80118ff0:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
80118ff4:	01400404 	movi	r5,16
80118ff8:	01200574 	movhi	r4,32789
80118ffc:	211b3404 	addi	r4,r4,27856
80119000:	0138b080 	call	80138b08 <OSQCreate>
80119004:	d0a07915 	stw	r2,-32284(gp)
	if ( xQMaskFeeCtrl == NULL ) {
80119008:	d0a07917 	ldw	r2,-32284(gp)
8011900c:	1000021e 	bne	r2,zero,80119018 <bResourcesInitRTOS+0x46c>
		vCouldNotCreateQueueMaskNfeeCtrl( );
80119010:	011d9380 	call	8011d938 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
80119014:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
80119018:	01400404 	movi	r5,16
8011901c:	01200574 	movhi	r4,32789
80119020:	210e1c04 	addi	r4,r4,14448
80119024:	0138b080 	call	80138b08 <OSQCreate>
80119028:	d0a06a15 	stw	r2,-32344(gp)
	if ( xQMaskDataCtrl == NULL ) {
8011902c:	d0a06a17 	ldw	r2,-32344(gp)
80119030:	1000021e 	bne	r2,zero,8011903c <bResourcesInitRTOS+0x490>
		vCouldNotCreateQueueMaskDataCtrl( );
80119034:	011d9600 	call	8011d960 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
80119038:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
8011903c:	e0bfff04 	addi	r2,fp,-4
80119040:	100b883a 	mov	r5,r2
80119044:	01000104 	movi	r4,4
80119048:	0137a1c0 	call	80137a1c <OSMutexCreate>
8011904c:	1007883a 	mov	r3,r2
80119050:	00a005b4 	movhi	r2,32790
80119054:	10ad6e04 	addi	r2,r2,-19016
80119058:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
8011905c:	e0bfff03 	ldbu	r2,-4(fp)
80119060:	10803fcc 	andi	r2,r2,255
80119064:	10000226 	beq	r2,zero,80119070 <bResourcesInitRTOS+0x4c4>
		vFailCreateMutexDMA();
80119068:	011ceb40 	call	8011ceb4 <vFailCreateMutexDMA>
		bSuccess = FALSE;
8011906c:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
80119070:	e0bfff04 	addi	r2,fp,-4
80119074:	100b883a 	mov	r5,r2
80119078:	01000184 	movi	r4,6
8011907c:	0137a1c0 	call	80137a1c <OSMutexCreate>
80119080:	1007883a 	mov	r3,r2
80119084:	00a005b4 	movhi	r2,32790
80119088:	10ad6e04 	addi	r2,r2,-19016
8011908c:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
80119090:	e0bfff03 	ldbu	r2,-4(fp)
80119094:	10803fcc 	andi	r2,r2,255
80119098:	10000226 	beq	r2,zero,801190a4 <bResourcesInitRTOS+0x4f8>
		vFailCreateMutexDMA();
8011909c:	011ceb40 	call	8011ceb4 <vFailCreateMutexDMA>
		bSuccess = FALSE;
801190a0:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
801190a4:	e0bffe17 	ldw	r2,-8(fp)
}
801190a8:	e037883a 	mov	sp,fp
801190ac:	dfc00117 	ldw	ra,4(sp)
801190b0:	df000017 	ldw	fp,0(sp)
801190b4:	dec00204 	addi	sp,sp,8
801190b8:	f800283a 	ret

801190bc <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
801190bc:	defffd04 	addi	sp,sp,-12
801190c0:	de00012e 	bgeu	sp,et,801190c8 <vVariablesInitialization+0xc>
801190c4:	003b68fa 	trap	3
801190c8:	dfc00215 	stw	ra,8(sp)
801190cc:	df000115 	stw	fp,4(sp)
801190d0:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
801190d4:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
801190d8:	00800084 	movi	r2,2
801190dc:	d0a0720d 	sth	r2,-32312(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
801190e0:	01800604 	movi	r6,24
801190e4:	000b883a 	mov	r5,zero
801190e8:	01200574 	movhi	r4,32789
801190ec:	211a3c04 	addi	r4,r4,26864
801190f0:	01215b40 	call	801215b4 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
801190f4:	01800804 	movi	r6,32
801190f8:	000b883a 	mov	r5,zero
801190fc:	01200574 	movhi	r4,32789
80119100:	211a4204 	addi	r4,r4,26888
80119104:	01215b40 	call	801215b4 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
80119108:	01800804 	movi	r6,32
8011910c:	000b883a 	mov	r5,zero
80119110:	01200574 	movhi	r4,32789
80119114:	211a4a04 	addi	r4,r4,26920
80119118:	01215b40 	call	801215b4 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8011911c:	e03fff05 	stb	zero,-4(fp)
80119120:	00002806 	br	801191c4 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
80119124:	e0bfff03 	ldbu	r2,-4(fp)
80119128:	10c02324 	muli	r3,r2,140
8011912c:	00a00574 	movhi	r2,32789
80119130:	109a6204 	addi	r2,r2,27016
80119134:	1885883a 	add	r2,r3,r2
80119138:	01802004 	movi	r6,128
8011913c:	000b883a 	mov	r5,zero
80119140:	1009883a 	mov	r4,r2
80119144:	01215b40 	call	801215b4 <memset>
		xBuffer128[ucIL].bSent = FALSE;
80119148:	e0ffff03 	ldbu	r3,-4(fp)
8011914c:	00a00574 	movhi	r2,32789
80119150:	109a6204 	addi	r2,r2,27016
80119154:	18c02324 	muli	r3,r3,140
80119158:	10c5883a 	add	r2,r2,r3
8011915c:	10802004 	addi	r2,r2,128
80119160:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
80119164:	e0ffff03 	ldbu	r3,-4(fp)
80119168:	00a00574 	movhi	r2,32789
8011916c:	109a6204 	addi	r2,r2,27016
80119170:	18c02324 	muli	r3,r3,140
80119174:	10c5883a 	add	r2,r2,r3
80119178:	10802104 	addi	r2,r2,132
8011917c:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
80119180:	e0ffff03 	ldbu	r3,-4(fp)
80119184:	00a00574 	movhi	r2,32789
80119188:	109a6204 	addi	r2,r2,27016
8011918c:	18c02324 	muli	r3,r3,140
80119190:	10c5883a 	add	r2,r2,r3
80119194:	10802184 	addi	r2,r2,134
80119198:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
8011919c:	e0ffff03 	ldbu	r3,-4(fp)
801191a0:	00a00574 	movhi	r2,32789
801191a4:	109a6204 	addi	r2,r2,27016
801191a8:	18c02324 	muli	r3,r3,140
801191ac:	10c5883a 	add	r2,r2,r3
801191b0:	10802204 	addi	r2,r2,136
801191b4:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
801191b8:	e0bfff03 	ldbu	r2,-4(fp)
801191bc:	10800044 	addi	r2,r2,1
801191c0:	e0bfff05 	stb	r2,-4(fp)
801191c4:	e0bfff03 	ldbu	r2,-4(fp)
801191c8:	108001b0 	cmpltui	r2,r2,6
801191cc:	103fd51e 	bne	r2,zero,80119124 <__reset+0xfa0f9124>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
801191d0:	e03fff05 	stb	zero,-4(fp)
801191d4:	00002806 	br	80119278 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
801191d8:	e0bfff03 	ldbu	r2,-4(fp)
801191dc:	10c01324 	muli	r3,r2,76
801191e0:	00a00574 	movhi	r2,32789
801191e4:	10b3f504 	addi	r2,r2,-12332
801191e8:	1885883a 	add	r2,r3,r2
801191ec:	01801004 	movi	r6,64
801191f0:	000b883a 	mov	r5,zero
801191f4:	1009883a 	mov	r4,r2
801191f8:	01215b40 	call	801215b4 <memset>
		xBuffer64[ucIL].bSent = FALSE;
801191fc:	e0ffff03 	ldbu	r3,-4(fp)
80119200:	00a00574 	movhi	r2,32789
80119204:	10b3f504 	addi	r2,r2,-12332
80119208:	18c01324 	muli	r3,r3,76
8011920c:	10c5883a 	add	r2,r2,r3
80119210:	10801004 	addi	r2,r2,64
80119214:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
80119218:	e0ffff03 	ldbu	r3,-4(fp)
8011921c:	00a00574 	movhi	r2,32789
80119220:	10b3f504 	addi	r2,r2,-12332
80119224:	18c01324 	muli	r3,r3,76
80119228:	10c5883a 	add	r2,r2,r3
8011922c:	10801104 	addi	r2,r2,68
80119230:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
80119234:	e0ffff03 	ldbu	r3,-4(fp)
80119238:	00a00574 	movhi	r2,32789
8011923c:	10b3f504 	addi	r2,r2,-12332
80119240:	18c01324 	muli	r3,r3,76
80119244:	10c5883a 	add	r2,r2,r3
80119248:	10801184 	addi	r2,r2,70
8011924c:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
80119250:	e0ffff03 	ldbu	r3,-4(fp)
80119254:	00a00574 	movhi	r2,32789
80119258:	10b3f504 	addi	r2,r2,-12332
8011925c:	18c01324 	muli	r3,r3,76
80119260:	10c5883a 	add	r2,r2,r3
80119264:	10801204 	addi	r2,r2,72
80119268:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8011926c:	e0bfff03 	ldbu	r2,-4(fp)
80119270:	10800044 	addi	r2,r2,1
80119274:	e0bfff05 	stb	r2,-4(fp)
80119278:	e0bfff03 	ldbu	r2,-4(fp)
8011927c:	10800230 	cmpltui	r2,r2,8
80119280:	103fd51e 	bne	r2,zero,801191d8 <__reset+0xfa0f91d8>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
80119284:	e03fff05 	stb	zero,-4(fp)
80119288:	00002806 	br	8011932c <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
8011928c:	e0bfff03 	ldbu	r2,-4(fp)
80119290:	10c00b24 	muli	r3,r2,44
80119294:	00a00574 	movhi	r2,32789
80119298:	1087c404 	addi	r2,r2,7952
8011929c:	1885883a 	add	r2,r3,r2
801192a0:	01800804 	movi	r6,32
801192a4:	000b883a 	mov	r5,zero
801192a8:	1009883a 	mov	r4,r2
801192ac:	01215b40 	call	801215b4 <memset>
		xBuffer32[ucIL].bSent = FALSE;
801192b0:	e0ffff03 	ldbu	r3,-4(fp)
801192b4:	00a00574 	movhi	r2,32789
801192b8:	1087c404 	addi	r2,r2,7952
801192bc:	18c00b24 	muli	r3,r3,44
801192c0:	10c5883a 	add	r2,r2,r3
801192c4:	10800804 	addi	r2,r2,32
801192c8:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
801192cc:	e0ffff03 	ldbu	r3,-4(fp)
801192d0:	00a00574 	movhi	r2,32789
801192d4:	1087c404 	addi	r2,r2,7952
801192d8:	18c00b24 	muli	r3,r3,44
801192dc:	10c5883a 	add	r2,r2,r3
801192e0:	10800904 	addi	r2,r2,36
801192e4:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
801192e8:	e0ffff03 	ldbu	r3,-4(fp)
801192ec:	00a00574 	movhi	r2,32789
801192f0:	1087c404 	addi	r2,r2,7952
801192f4:	18c00b24 	muli	r3,r3,44
801192f8:	10c5883a 	add	r2,r2,r3
801192fc:	10800984 	addi	r2,r2,38
80119300:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
80119304:	e0ffff03 	ldbu	r3,-4(fp)
80119308:	00a00574 	movhi	r2,32789
8011930c:	1087c404 	addi	r2,r2,7952
80119310:	18c00b24 	muli	r3,r3,44
80119314:	10c5883a 	add	r2,r2,r3
80119318:	10800a04 	addi	r2,r2,40
8011931c:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
80119320:	e0bfff03 	ldbu	r2,-4(fp)
80119324:	10800044 	addi	r2,r2,1
80119328:	e0bfff05 	stb	r2,-4(fp)
8011932c:	e0bfff03 	ldbu	r2,-4(fp)
80119330:	10800230 	cmpltui	r2,r2,8
80119334:	103fd51e 	bne	r2,zero,8011928c <__reset+0xfa0f928c>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
80119338:	e03fff05 	stb	zero,-4(fp)
8011933c:	00001b06 	br	801193ac <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
80119340:	e0ffff03 	ldbu	r3,-4(fp)
80119344:	00a00574 	movhi	r2,32789
80119348:	10b48d04 	addi	r2,r2,-11724
8011934c:	18c01524 	muli	r3,r3,84
80119350:	10c5883a 	add	r2,r2,r3
80119354:	10800104 	addi	r2,r2,4
80119358:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
8011935c:	e0ffff03 	ldbu	r3,-4(fp)
80119360:	00a00574 	movhi	r2,32789
80119364:	10b48d04 	addi	r2,r2,-11724
80119368:	18c01524 	muli	r3,r3,84
8011936c:	10c5883a 	add	r2,r2,r3
80119370:	10800484 	addi	r2,r2,18
80119374:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
80119378:	e0bfff03 	ldbu	r2,-4(fp)
8011937c:	10801524 	muli	r2,r2,84
80119380:	10c00504 	addi	r3,r2,20
80119384:	00a00574 	movhi	r2,32789
80119388:	10b48d04 	addi	r2,r2,-11724
8011938c:	1885883a 	add	r2,r3,r2
80119390:	01801004 	movi	r6,64
80119394:	000b883a 	mov	r5,zero
80119398:	1009883a 	mov	r4,r2
8011939c:	01215b40 	call	801215b4 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
801193a0:	e0bfff03 	ldbu	r2,-4(fp)
801193a4:	10800044 	addi	r2,r2,1
801193a8:	e0bfff05 	stb	r2,-4(fp)
801193ac:	e0bfff03 	ldbu	r2,-4(fp)
801193b0:	10800130 	cmpltui	r2,r2,4
801193b4:	103fe21e 	bne	r2,zero,80119340 <__reset+0xfa0f9340>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
801193b8:	0001883a 	nop
801193bc:	e037883a 	mov	sp,fp
801193c0:	dfc00117 	ldw	ra,4(sp)
801193c4:	df000017 	ldw	fp,0(sp)
801193c8:	dec00204 	addi	sp,sp,8
801193cc:	f800283a 	ret

801193d0 <main>:
void vFillMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
801193d0:	defff704 	addi	sp,sp,-36
801193d4:	de00012e 	bgeu	sp,et,801193dc <main+0xc>
801193d8:	003b68fa 	trap	3
801193dc:	dfc00815 	stw	ra,32(sp)
801193e0:	df000715 	stw	fp,28(sp)
801193e4:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
801193e8:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
801193ec:	0133eb80 	call	80133eb8 <OSInit>
	#if DEBUG_ON
		debug(fp, "Main entry point.\n");
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
801193f0:	011e6a40 	call	8011e6a4 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
801193f4:	011f1f40 	call	8011f1f4 <bTestSimucamCriticalHW>
801193f8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
801193fc:	e0bffe17 	ldw	r2,-8(fp)
80119400:	1000031e 	bne	r2,zero,80119410 <main+0x40>
		vFailTestCriticasParts();
80119404:	011cf040 	call	8011cf04 <vFailTestCriticasParts>
		return -1;
80119408:	00bfffc4 	movi	r2,-1
8011940c:	00005006 	br	80119550 <main+0x180>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
80119410:	011ee5c0 	call	8011ee5c <bInitializeSDCard>
80119414:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
80119418:	e0bffe17 	ldw	r2,-8(fp)
8011941c:	1000031e 	bne	r2,zero,8011942c <main+0x5c>
		vFailTestCriticasParts();
80119420:	011cf040 	call	8011cf04 <vFailTestCriticasParts>
		return -1;
80119424:	00bfffc4 	movi	r2,-1
80119428:	00004906 	br	80119550 <main+0x180>
	}

	bIniSimucamStatus = vLoadDebugConfs();
8011942c:	011bd0c0 	call	8011bd0c <vLoadDebugConfs>
80119430:	e0bffe15 	stw	r2,-8(fp)
	/*Check if the debug level was loaded */
	if ( (xDefaults.usiDebugLevel < 0) || (xDefaults.usiDebugLevel > 8) ) {
80119434:	00a005b4 	movhi	r2,32790
80119438:	10ba3604 	addi	r2,r2,-5928
8011943c:	10800a8b 	ldhu	r2,42(r2)
80119440:	10bfffcc 	andi	r2,r2,65535
80119444:	10800270 	cmpltui	r2,r2,9
80119448:	1000041e 	bne	r2,zero,8011945c <main+0x8c>
		#if DEBUG_ON
			debug(fp, "Didn't load Debug level from SDCard, setting to 4, Main messages and Main Progress.\n");
		#endif
		xDefaults.usiDebugLevel = 4;
8011944c:	00a005b4 	movhi	r2,32790
80119450:	10ba3604 	addi	r2,r2,-5928
80119454:	00c00104 	movi	r3,4
80119458:	10c00a8d 	sth	r3,42(r2)
	}
	if (bIniSimucamStatus == FALSE) {
8011945c:	e0bffe17 	ldw	r2,-8(fp)
80119460:	1000031e 	bne	r2,zero,80119470 <main+0xa0>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
		}
		#endif
		vCriticalErrorLedPanel();
80119464:	011ce440 	call	8011ce44 <vCriticalErrorLedPanel>
		return -1;
80119468:	00bfffc4 	movi	r2,-1
8011946c:	00003806 	br	80119550 <main+0x180>
		fprintf(fp, "xDefaults.usiGuardNFEEDelay %u \n", xDefaults.usiGuardNFEEDelay);
	}
#endif

	/* Load the Binding configuration ( FEE instance <-> SPWChannel ) */
	bIniSimucamStatus = vCHConfs();
80119470:	011ab480 	call	8011ab48 <vCHConfs>
80119474:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
80119478:	e0bffe17 	ldw	r2,-8(fp)
8011947c:	1000031e 	bne	r2,zero,8011948c <main+0xbc>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp, "Didn't load the bind configuration of the FEEs. \n");
		}
		#endif
		vCriticalErrorLedPanel();
80119480:	011ce440 	call	8011ce44 <vCriticalErrorLedPanel>
		return -1;
80119484:	00bfffc4 	movi	r2,-1
80119488:	00003106 	br	80119550 <main+0x180>
		fprintf(fp, "Channel 2 - FEE %hhu \n", xDefaultsCH.ucChannelToFEE[2]);
		fprintf(fp, "Channel 3 - FEE %hhu \n", xDefaultsCH.ucChannelToFEE[3]);
	}
#endif

	bIniSimucamStatus = vLoadDefaultETHConf();
8011948c:	011b3f40 	call	8011b3f4 <vLoadDefaultETHConf>
80119490:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
80119494:	e0bffe17 	ldw	r2,-8(fp)
80119498:	1000031e 	bne	r2,zero,801194a8 <main+0xd8>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp, "Didn't load ETH configuration from SDCard. \n");
		}
		#endif
		vCriticalErrorLedPanel();
8011949c:	011ce440 	call	8011ce44 <vCriticalErrorLedPanel>
		return -1;
801194a0:	00bfffc4 	movi	r2,-1
801194a4:	00002a06 	br	80119550 <main+0x180>
	}
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
801194a8:	0118bac0 	call	80118bac <bResourcesInitRTOS>
801194ac:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
801194b0:	e0bffe17 	ldw	r2,-8(fp)
801194b4:	1000031e 	bne	r2,zero,801194c4 <main+0xf4>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp, "Can't allocate resources for RTOS. (exit) \n");
		}
		#endif
		vCriticalErrorLedPanel();
801194b8:	011ce440 	call	8011ce44 <vCriticalErrorLedPanel>
		return -1;
801194bc:	00bfffc4 	movi	r2,-1
801194c0:	00002306 	br	80119550 <main+0x180>
	}

	vVariablesInitialization();
801194c4:	01190bc0 	call	801190bc <vVariablesInitialization>

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
801194c8:	01200574 	movhi	r4,32789
801194cc:	21013104 	addi	r4,r4,1220
801194d0:	011e8280 	call	8011e828 <vSimucamStructureInit>

	bInitSync();
801194d4:	011ef980 	call	8011ef98 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
801194d8:	01200574 	movhi	r4,32789
801194dc:	21013104 	addi	r4,r4,1220
801194e0:	01195640 	call	80119564 <vFillMemmoryPattern>
	bSetPainelLeds( LEDS_OFF , LEDS_ST_ALL_MASK );
801194e4:	014007f4 	movhi	r5,31
801194e8:	0009883a 	mov	r4,zero
801194ec:	010bb640 	call	8010bb64 <bSetPainelLeds>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
801194f0:	d8000415 	stw	zero,16(sp)
801194f4:	d8000315 	stw	zero,12(sp)
801194f8:	00810004 	movi	r2,1024
801194fc:	d8800215 	stw	r2,8(sp)
80119500:	00a00574 	movhi	r2,32789
80119504:	10923c04 	addi	r2,r2,18672
80119508:	d8800115 	stw	r2,4(sp)
8011950c:	00800044 	movi	r2,1
80119510:	d8800015 	stw	r2,0(sp)
80119514:	01c00044 	movi	r7,1
80119518:	01a00574 	movhi	r6,32789
8011951c:	31963b04 	addi	r6,r6,22764
80119520:	000b883a 	mov	r5,zero
80119524:	01200474 	movhi	r4,32785
80119528:	21139e04 	addi	r4,r4,20088
8011952c:	013ac680 	call	8013ac68 <OSTaskCreateExt>
80119530:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
80119534:	e0bfff03 	ldbu	r2,-4(fp)
80119538:	1000031e 	bne	r2,zero,80119548 <main+0x178>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
8011953c:	01341e80 	call	801341e8 <OSStart>
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
		return -1;
	}
  
	return 0;
80119540:	0005883a 	mov	r2,zero
80119544:	00000206 	br	80119550 <main+0x180>
	if ( error_code == OS_ERR_NONE ) {
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
80119548:	011d0c80 	call	8011d0c8 <vFailInitialization>
		return -1;
8011954c:	00bfffc4 	movi	r2,-1
	}
  
	return 0;
}
80119550:	e037883a 	mov	sp,fp
80119554:	dfc00117 	ldw	ra,4(sp)
80119558:	df000017 	ldw	fp,0(sp)
8011955c:	dec00204 	addi	sp,sp,8
80119560:	f800283a 	ret

80119564 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
80119564:	defff604 	addi	sp,sp,-40
80119568:	de00012e 	bgeu	sp,et,80119570 <vFillMemmoryPattern+0xc>
8011956c:	003b68fa 	trap	3
80119570:	dfc00915 	stw	ra,36(sp)
80119574:	df000815 	stw	fp,32(sp)
80119578:	df000804 	addi	fp,sp,32
8011957c:	e13fff15 	stw	r4,-4(fp)
		debug(fp, "\nStart to fill the memory with Pattern.\n");
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
80119580:	e03ffa05 	stb	zero,-24(fp)
80119584:	00006f06 	br	80119744 <vFillMemmoryPattern+0x1e0>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
			fprintf(fp, "Memory %i\n",mem_number);
		}
		#endif
		for( NFee_i = 0; NFee_i < N_OF_NFEE; NFee_i++ ) {
80119588:	e03ffc85 	stb	zero,-14(fp)
8011958c:	00006706 	br	8011972c <vFillMemmoryPattern+0x1c8>
			if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
				fprintf(fp, "--NFEE %i\n", NFee_i);
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
80119590:	e0bffc83 	ldbu	r2,-14(fp)
80119594:	e0ffff17 	ldw	r3,-4(fp)
80119598:	10809b24 	muli	r2,r2,620
8011959c:	1885883a 	add	r2,r3,r2
801195a0:	10804c04 	addi	r2,r2,304
801195a4:	1080000b 	ldhu	r2,0(r2)
801195a8:	10ffffcc 	andi	r3,r2,65535
801195ac:	e0bffc83 	ldbu	r2,-14(fp)
801195b0:	e13fff17 	ldw	r4,-4(fp)
801195b4:	10809b24 	muli	r2,r2,620
801195b8:	2085883a 	add	r2,r4,r2
801195bc:	10804b04 	addi	r2,r2,300
801195c0:	1080000b 	ldhu	r2,0(r2)
801195c4:	10bfffcc 	andi	r2,r2,65535
801195c8:	1885883a 	add	r2,r3,r2
801195cc:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
801195d0:	e0bffc83 	ldbu	r2,-14(fp)
801195d4:	e0ffff17 	ldw	r3,-4(fp)
801195d8:	10809b24 	muli	r2,r2,620
801195dc:	1885883a 	add	r2,r3,r2
801195e0:	10804b84 	addi	r2,r2,302
801195e4:	1080000b 	ldhu	r2,0(r2)
801195e8:	10ffffcc 	andi	r3,r2,65535
801195ec:	e0bffc83 	ldbu	r2,-14(fp)
801195f0:	e13fff17 	ldw	r4,-4(fp)
801195f4:	10809b24 	muli	r2,r2,620
801195f8:	2085883a 	add	r2,r4,r2
801195fc:	10804a84 	addi	r2,r2,298
80119600:	1080000b 	ldhu	r2,0(r2)
80119604:	10bfffcc 	andi	r2,r2,65535
80119608:	1887883a 	add	r3,r3,r2
8011960c:	e0bffc83 	ldbu	r2,-14(fp)
80119610:	e13fff17 	ldw	r4,-4(fp)
80119614:	10809b24 	muli	r2,r2,620
80119618:	2085883a 	add	r2,r4,r2
8011961c:	10804a04 	addi	r2,r2,296
80119620:	1080000b 	ldhu	r2,0(r2)
80119624:	10bfffcc 	andi	r2,r2,65535
80119628:	1885883a 	add	r2,r3,r2
8011962c:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
80119630:	e03ffc05 	stb	zero,-16(fp)
80119634:	00003706 	br	80119714 <vFillMemmoryPattern+0x1b0>
				if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
					fprintf(fp, "-----CCD %i\n", ccd_number);
				}
				#endif

				bSetPainelLeds( LEDS_OFF , LEDS_ST_ALL_MASK );
80119638:	014007f4 	movhi	r5,31
8011963c:	0009883a 	mov	r4,zero
80119640:	010bb640 	call	8010bb64 <bSetPainelLeds>
				bSetPainelLeds( LEDS_ON , (LEDS_ST_1_MASK << ccd_number) );
80119644:	e0bffc03 	ldbu	r2,-16(fp)
80119648:	00c000b4 	movhi	r3,2
8011964c:	1884983a 	sll	r2,r3,r2
80119650:	100b883a 	mov	r5,r2
80119654:	01000044 	movi	r4,1
80119658:	010bb640 	call	8010bb64 <bSetPainelLeds>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8011965c:	e03ffc45 	stb	zero,-15(fp)
80119660:	00002606 	br	801196fc <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
80119664:	e0bffc43 	ldbu	r2,-15(fp)
80119668:	10000b1e 	bne	r2,zero,80119698 <vFillMemmoryPattern+0x134>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
							fprintf(fp, "------Left side\n");
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
8011966c:	e0bffc83 	ldbu	r2,-14(fp)
80119670:	e13ffc03 	ldbu	r4,-16(fp)
80119674:	e0ffff17 	ldw	r3,-4(fp)
80119678:	21000624 	muli	r4,r4,24
8011967c:	10809b24 	muli	r2,r2,620
80119680:	2085883a 	add	r2,r4,r2
80119684:	1885883a 	add	r2,r3,r2
80119688:	10802404 	addi	r2,r2,144
8011968c:	10800017 	ldw	r2,0(r2)
80119690:	e0bffb15 	stw	r2,-20(fp)
80119694:	00000a06 	br	801196c0 <vFillMemmoryPattern+0x15c>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
							fprintf(fp, "------Right side\n");
						}
						#endif
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
80119698:	e0bffc83 	ldbu	r2,-14(fp)
8011969c:	e13ffc03 	ldbu	r4,-16(fp)
801196a0:	e0ffff17 	ldw	r3,-4(fp)
801196a4:	21000624 	muli	r4,r4,24
801196a8:	10809b24 	muli	r2,r2,620
801196ac:	2085883a 	add	r2,r4,r2
801196b0:	1885883a 	add	r2,r3,r2
801196b4:	10802704 	addi	r2,r2,156
801196b8:	10800017 	ldw	r2,0(r2)
801196bc:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
801196c0:	e0fffa03 	ldbu	r3,-24(fp)
801196c4:	e13ffc03 	ldbu	r4,-16(fp)
801196c8:	e17ffc43 	ldbu	r5,-15(fp)
801196cc:	e0bffd17 	ldw	r2,-12(fp)
801196d0:	d8800115 	stw	r2,4(sp)
801196d4:	e0bffe17 	ldw	r2,-8(fp)
801196d8:	d8800015 	stw	r2,0(sp)
801196dc:	280f883a 	mov	r7,r5
801196e0:	200d883a 	mov	r6,r4
801196e4:	e17ffb17 	ldw	r5,-20(fp)
801196e8:	1809883a 	mov	r4,r3
801196ec:	011ebec0 	call	8011ebec <pattern_createPattern>
				#endif

				bSetPainelLeds( LEDS_OFF , LEDS_ST_ALL_MASK );
				bSetPainelLeds( LEDS_ON , (LEDS_ST_1_MASK << ccd_number) );

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
801196f0:	e0bffc43 	ldbu	r2,-15(fp)
801196f4:	10800044 	addi	r2,r2,1
801196f8:	e0bffc45 	stb	r2,-15(fp)
801196fc:	e0bffc43 	ldbu	r2,-15(fp)
80119700:	108000b0 	cmpltui	r2,r2,2
80119704:	103fd71e 	bne	r2,zero,80119664 <__reset+0xfa0f9664>
			}
			#endif
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
80119708:	e0bffc03 	ldbu	r2,-16(fp)
8011970c:	10800044 	addi	r2,r2,1
80119710:	e0bffc05 	stb	r2,-16(fp)
80119714:	e0bffc03 	ldbu	r2,-16(fp)
80119718:	10800130 	cmpltui	r2,r2,4
8011971c:	103fc61e 	bne	r2,zero,80119638 <__reset+0xfa0f9638>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
			fprintf(fp, "Memory %i\n",mem_number);
		}
		#endif
		for( NFee_i = 0; NFee_i < N_OF_NFEE; NFee_i++ ) {
80119720:	e0bffc83 	ldbu	r2,-14(fp)
80119724:	10800044 	addi	r2,r2,1
80119728:	e0bffc85 	stb	r2,-14(fp)
8011972c:	e0bffc83 	ldbu	r2,-14(fp)
80119730:	10800130 	cmpltui	r2,r2,4
80119734:	103f961e 	bne	r2,zero,80119590 <__reset+0xfa0f9590>
		debug(fp, "\nStart to fill the memory with Pattern.\n");
	}
#endif

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
80119738:	e0bffa03 	ldbu	r2,-24(fp)
8011973c:	10800044 	addi	r2,r2,1
80119740:	e0bffa05 	stb	r2,-24(fp)
80119744:	e0bffa03 	ldbu	r2,-24(fp)
80119748:	108000b0 	cmpltui	r2,r2,2
8011974c:	103f8e1e 	bne	r2,zero,80119588 <__reset+0xfa0f9588>
	if ( xDefaults.usiDebugLevel <= dlMajorMessage ) {
	debug(fp, "\nMemory Filled\n");
	}
#endif

}
80119750:	0001883a 	nop
80119754:	e037883a 	mov	sp,fp
80119758:	dfc00117 	ldw	ra,4(sp)
8011975c:	df000017 	ldw	fp,0(sp)
80119760:	dec00204 	addi	sp,sp,8
80119764:	f800283a 	ret

80119768 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
80119768:	defffe04 	addi	sp,sp,-8
8011976c:	de00012e 	bgeu	sp,et,80119774 <vCCDLoadDefaultValues+0xc>
80119770:	003b68fa 	trap	3
80119774:	df000115 	stw	fp,4(sp)
80119778:	df000104 	addi	fp,sp,4
8011977c:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
80119780:	00a005b4 	movhi	r2,32790
80119784:	10ba3604 	addi	r2,r2,-5928
80119788:	10c0030b 	ldhu	r3,12(r2)
8011978c:	e0bfff17 	ldw	r2,-4(fp)
80119790:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
80119794:	00a005b4 	movhi	r2,32790
80119798:	10ba3604 	addi	r2,r2,-5928
8011979c:	10c0020b 	ldhu	r3,8(r2)
801197a0:	e0bfff17 	ldw	r2,-4(fp)
801197a4:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
801197a8:	00a005b4 	movhi	r2,32790
801197ac:	10ba3604 	addi	r2,r2,-5928
801197b0:	10c0028b 	ldhu	r3,10(r2)
801197b4:	e0bfff17 	ldw	r2,-4(fp)
801197b8:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
801197bc:	00a005b4 	movhi	r2,32790
801197c0:	10ba3604 	addi	r2,r2,-5928
801197c4:	10c0010b 	ldhu	r3,4(r2)
801197c8:	e0bfff17 	ldw	r2,-4(fp)
801197cc:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
801197d0:	00a005b4 	movhi	r2,32790
801197d4:	10ba3604 	addi	r2,r2,-5928
801197d8:	10c0018b 	ldhu	r3,6(r2)
801197dc:	e0bfff17 	ldw	r2,-4(fp)
801197e0:	10c0000d 	sth	r3,0(r2)
		fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
		fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
	}
#endif

}
801197e4:	0001883a 	nop
801197e8:	e037883a 	mov	sp,fp
801197ec:	df000017 	ldw	fp,0(sp)
801197f0:	dec00104 	addi	sp,sp,4
801197f4:	f800283a 	ret

801197f8 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
801197f8:	defff904 	addi	sp,sp,-28
801197fc:	de00012e 	bgeu	sp,et,80119804 <vCCDChangeValues+0xc>
80119800:	003b68fa 	trap	3
80119804:	df000615 	stw	fp,24(sp)
80119808:	df000604 	addi	fp,sp,24
8011980c:	e13ffa15 	stw	r4,-24(fp)
80119810:	2811883a 	mov	r8,r5
80119814:	300b883a 	mov	r5,r6
80119818:	3809883a 	mov	r4,r7
8011981c:	e0c00117 	ldw	r3,4(fp)
80119820:	e0800217 	ldw	r2,8(fp)
80119824:	e23ffb0d 	sth	r8,-20(fp)
80119828:	e17ffc0d 	sth	r5,-16(fp)
8011982c:	e13ffd0d 	sth	r4,-12(fp)
80119830:	e0fffe0d 	sth	r3,-8(fp)
80119834:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
80119838:	e0bffa17 	ldw	r2,-24(fp)
8011983c:	e0fffb0b 	ldhu	r3,-20(fp)
80119840:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
80119844:	e0bffa17 	ldw	r2,-24(fp)
80119848:	e0fffc0b 	ldhu	r3,-16(fp)
8011984c:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
80119850:	e0bffa17 	ldw	r2,-24(fp)
80119854:	e0fffd0b 	ldhu	r3,-12(fp)
80119858:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
8011985c:	e0bffa17 	ldw	r2,-24(fp)
80119860:	e0fffe0b 	ldhu	r3,-8(fp)
80119864:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
80119868:	e0bffa17 	ldw	r2,-24(fp)
8011986c:	e0ffff0b 	ldhu	r3,-4(fp)
80119870:	10c0000d 	sth	r3,0(r2)
}
80119874:	0001883a 	nop
80119878:	e037883a 	mov	sp,fp
8011987c:	df000017 	ldw	fp,0(sp)
80119880:	dec00104 	addi	sp,sp,4
80119884:	f800283a 	ret

80119888 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
80119888:	defff904 	addi	sp,sp,-28
8011988c:	de00012e 	bgeu	sp,et,80119894 <bSendUART128v2+0xc>
80119890:	003b68fa 	trap	3
80119894:	dfc00615 	stw	ra,24(sp)
80119898:	df000515 	stw	fp,20(sp)
8011989c:	df000504 	addi	fp,sp,20
801198a0:	e13ffe15 	stw	r4,-8(fp)
801198a4:	2805883a 	mov	r2,r5
801198a8:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
801198ac:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
801198b0:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
801198b4:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
801198b8:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
801198bc:	d0a06d17 	ldw	r2,-32332(gp)
801198c0:	e0fffd04 	addi	r3,fp,-12
801198c4:	180d883a 	mov	r6,r3
801198c8:	01400504 	movi	r5,20
801198cc:	1009883a 	mov	r4,r2
801198d0:	0139efc0 	call	80139efc <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
801198d4:	e0bffd03 	ldbu	r2,-12(fp)
801198d8:	10803fcc 	andi	r2,r2,255
801198dc:	10000326 	beq	r2,zero,801198ec <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
801198e0:	011d1ec0 	call	8011d1ec <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
801198e4:	e0bffc17 	ldw	r2,-16(fp)
801198e8:	00009006 	br	80119b2c <bSendUART128v2+0x2a4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
801198ec:	d0a07717 	ldw	r2,-32292(gp)
801198f0:	e0fffd04 	addi	r3,fp,-12
801198f4:	180d883a 	mov	r6,r3
801198f8:	01400104 	movi	r5,4
801198fc:	1009883a 	mov	r4,r2
80119900:	0137ef00 	call	80137ef0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
80119904:	e0bffd03 	ldbu	r2,-12(fp)
80119908:	10803fcc 	andi	r2,r2,255
8011990c:	10000a26 	beq	r2,zero,80119938 <bSendUART128v2+0xb0>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
80119910:	d0a06d17 	ldw	r2,-32332(gp)
80119914:	1009883a 	mov	r4,r2
80119918:	013a2840 	call	8013a284 <OSSemPost>
8011991c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
80119920:	e0bffd03 	ldbu	r2,-12(fp)
80119924:	10803fcc 	andi	r2,r2,255
80119928:	10000126 	beq	r2,zero,80119930 <bSendUART128v2+0xa8>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8011992c:	011d1c40 	call	8011d1c4 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
80119930:	e0bffc17 	ldw	r2,-16(fp)
80119934:	00007d06 	br	80119b2c <bSendUART128v2+0x2a4>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
80119938:	e03ffb05 	stb	zero,-20(fp)
8011993c:	00004306 	br	80119a4c <bSendUART128v2+0x1c4>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
80119940:	e0fffb03 	ldbu	r3,-20(fp)
80119944:	00a00574 	movhi	r2,32789
80119948:	109a3c04 	addi	r2,r2,26864
8011994c:	18c7883a 	add	r3,r3,r3
80119950:	18c7883a 	add	r3,r3,r3
80119954:	10c5883a 	add	r2,r2,r3
80119958:	10800017 	ldw	r2,0(r2)
8011995c:	1000381e 	bne	r2,zero,80119a40 <bSendUART128v2+0x1b8>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
80119960:	e0bffb03 	ldbu	r2,-20(fp)
80119964:	10c02324 	muli	r3,r2,140
80119968:	00a00574 	movhi	r2,32789
8011996c:	109a6204 	addi	r2,r2,27016
80119970:	1885883a 	add	r2,r3,r2
80119974:	01802004 	movi	r6,128
80119978:	000b883a 	mov	r5,zero
8011997c:	1009883a 	mov	r4,r2
80119980:	01215b40 	call	801215b4 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
80119984:	e0bffb03 	ldbu	r2,-20(fp)
80119988:	10c02324 	muli	r3,r2,140
8011998c:	00a00574 	movhi	r2,32789
80119990:	109a6204 	addi	r2,r2,27016
80119994:	1885883a 	add	r2,r3,r2
80119998:	01801fc4 	movi	r6,127
8011999c:	e17ffe17 	ldw	r5,-8(fp)
801199a0:	1009883a 	mov	r4,r2
801199a4:	01214640 	call	80121464 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
801199a8:	e13ffb03 	ldbu	r4,-20(fp)
801199ac:	e0ffff0b 	ldhu	r3,-4(fp)
801199b0:	00a00574 	movhi	r2,32789
801199b4:	109a6204 	addi	r2,r2,27016
801199b8:	21002324 	muli	r4,r4,140
801199bc:	1105883a 	add	r2,r2,r4
801199c0:	10802104 	addi	r2,r2,132
801199c4:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
801199c8:	e0fffb03 	ldbu	r3,-20(fp)
801199cc:	00a00574 	movhi	r2,32789
801199d0:	109a6204 	addi	r2,r2,27016
801199d4:	18c02324 	muli	r3,r3,140
801199d8:	10c5883a 	add	r2,r2,r3
801199dc:	10802204 	addi	r2,r2,136
801199e0:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
801199e4:	e0fffb03 	ldbu	r3,-20(fp)
801199e8:	00a00574 	movhi	r2,32789
801199ec:	109a6204 	addi	r2,r2,27016
801199f0:	18c02324 	muli	r3,r3,140
801199f4:	10c5883a 	add	r2,r2,r3
801199f8:	10802184 	addi	r2,r2,134
801199fc:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
80119a00:	e0fffb03 	ldbu	r3,-20(fp)
80119a04:	00a00574 	movhi	r2,32789
80119a08:	109a6204 	addi	r2,r2,27016
80119a0c:	18c02324 	muli	r3,r3,140
80119a10:	10c5883a 	add	r2,r2,r3
80119a14:	10802004 	addi	r2,r2,128
80119a18:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
80119a1c:	e0fffb03 	ldbu	r3,-20(fp)
80119a20:	00a00574 	movhi	r2,32789
80119a24:	109a3c04 	addi	r2,r2,26864
80119a28:	18c7883a 	add	r3,r3,r3
80119a2c:	18c7883a 	add	r3,r3,r3
80119a30:	10c5883a 	add	r2,r2,r3
80119a34:	00c00044 	movi	r3,1
80119a38:	10c00015 	stw	r3,0(r2)
			break;
80119a3c:	00000606 	br	80119a58 <bSendUART128v2+0x1d0>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
80119a40:	e0bffb03 	ldbu	r2,-20(fp)
80119a44:	10800044 	addi	r2,r2,1
80119a48:	e0bffb05 	stb	r2,-20(fp)
80119a4c:	e0bffb03 	ldbu	r2,-20(fp)
80119a50:	108001b0 	cmpltui	r2,r2,6
80119a54:	103fba1e 	bne	r2,zero,80119940 <__reset+0xfa0f9940>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
80119a58:	e0bffb03 	ldbu	r2,-20(fp)
80119a5c:	108001b0 	cmpltui	r2,r2,6
80119a60:	1000091e 	bne	r2,zero,80119a88 <bSendUART128v2+0x200>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
80119a64:	d0a06d17 	ldw	r2,-32332(gp)
80119a68:	1009883a 	mov	r4,r2
80119a6c:	013a2840 	call	8013a284 <OSSemPost>
80119a70:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
80119a74:	d0a07717 	ldw	r2,-32292(gp)
80119a78:	1009883a 	mov	r4,r2
80119a7c:	01384940 	call	80138494 <OSMutexPost>
		return bSuccessL;
80119a80:	e0bffc17 	ldw	r2,-16(fp)
80119a84:	00002906 	br	80119b2c <bSendUART128v2+0x2a4>
	}

	bSuccessL = TRUE;
80119a88:	00800044 	movi	r2,1
80119a8c:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
80119a90:	d0a07e43 	ldbu	r2,-32263(gp)
80119a94:	10bfffc4 	addi	r2,r2,-1
80119a98:	d0a07e45 	stb	r2,-32263(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
80119a9c:	d0a07d17 	ldw	r2,-32268(gp)
80119aa0:	e0fffd04 	addi	r3,fp,-12
80119aa4:	180d883a 	mov	r6,r3
80119aa8:	01400084 	movi	r5,2
80119aac:	1009883a 	mov	r4,r2
80119ab0:	0137ef00 	call	80137ef0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
80119ab4:	e0bffd03 	ldbu	r2,-12(fp)
80119ab8:	10803fcc 	andi	r2,r2,255
80119abc:	10000526 	beq	r2,zero,80119ad4 <bSendUART128v2+0x24c>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
80119ac0:	d0a07717 	ldw	r2,-32292(gp)
80119ac4:	1009883a 	mov	r4,r2
80119ac8:	01384940 	call	80138494 <OSMutexPost>
		return bSuccessL;
80119acc:	e0bffc17 	ldw	r2,-16(fp)
80119ad0:	00001606 	br	80119b2c <bSendUART128v2+0x2a4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
80119ad4:	e0bffb03 	ldbu	r2,-20(fp)
80119ad8:	10c02324 	muli	r3,r2,140
80119adc:	00a00574 	movhi	r2,32789
80119ae0:	109a6204 	addi	r2,r2,27016
80119ae4:	1885883a 	add	r2,r3,r2
80119ae8:	1009883a 	mov	r4,r2
80119aec:	01217a40 	call	801217a4 <puts>
	xBuffer128[ucIL].bSent = TRUE;
80119af0:	e0fffb03 	ldbu	r3,-20(fp)
80119af4:	00a00574 	movhi	r2,32789
80119af8:	109a6204 	addi	r2,r2,27016
80119afc:	18c02324 	muli	r3,r3,140
80119b00:	10c5883a 	add	r2,r2,r3
80119b04:	10802004 	addi	r2,r2,128
80119b08:	00c00044 	movi	r3,1
80119b0c:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
80119b10:	d0a07d17 	ldw	r2,-32268(gp)
80119b14:	1009883a 	mov	r4,r2
80119b18:	01384940 	call	80138494 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
80119b1c:	d0a07717 	ldw	r2,-32292(gp)
80119b20:	1009883a 	mov	r4,r2
80119b24:	01384940 	call	80138494 <OSMutexPost>

	return bSuccessL;
80119b28:	e0bffc17 	ldw	r2,-16(fp)
}
80119b2c:	e037883a 	mov	sp,fp
80119b30:	dfc00117 	ldw	ra,4(sp)
80119b34:	df000017 	ldw	fp,0(sp)
80119b38:	dec00204 	addi	sp,sp,8
80119b3c:	f800283a 	ret

80119b40 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
80119b40:	defff904 	addi	sp,sp,-28
80119b44:	de00012e 	bgeu	sp,et,80119b4c <bSendUART64v2+0xc>
80119b48:	003b68fa 	trap	3
80119b4c:	dfc00615 	stw	ra,24(sp)
80119b50:	df000515 	stw	fp,20(sp)
80119b54:	df000504 	addi	fp,sp,20
80119b58:	e13ffe15 	stw	r4,-8(fp)
80119b5c:	2805883a 	mov	r2,r5
80119b60:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
80119b64:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
80119b68:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
80119b6c:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
80119b70:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
80119b74:	d0a06917 	ldw	r2,-32348(gp)
80119b78:	e0fffd04 	addi	r3,fp,-12
80119b7c:	180d883a 	mov	r6,r3
80119b80:	01400504 	movi	r5,20
80119b84:	1009883a 	mov	r4,r2
80119b88:	0139efc0 	call	80139efc <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
80119b8c:	e0bffd03 	ldbu	r2,-12(fp)
80119b90:	10803fcc 	andi	r2,r2,255
80119b94:	10000326 	beq	r2,zero,80119ba4 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
80119b98:	011d2140 	call	8011d214 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
80119b9c:	e0bffc17 	ldw	r2,-16(fp)
80119ba0:	00009206 	br	80119dec <bSendUART64v2+0x2ac>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
80119ba4:	d0a07a17 	ldw	r2,-32280(gp)
80119ba8:	e0fffd04 	addi	r3,fp,-12
80119bac:	180d883a 	mov	r6,r3
80119bb0:	01400104 	movi	r5,4
80119bb4:	1009883a 	mov	r4,r2
80119bb8:	0137ef00 	call	80137ef0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
80119bbc:	e0bffd03 	ldbu	r2,-12(fp)
80119bc0:	10803fcc 	andi	r2,r2,255
80119bc4:	10000a26 	beq	r2,zero,80119bf0 <bSendUART64v2+0xb0>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
80119bc8:	d0a06917 	ldw	r2,-32348(gp)
80119bcc:	1009883a 	mov	r4,r2
80119bd0:	013a2840 	call	8013a284 <OSSemPost>
80119bd4:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
80119bd8:	e0bffd03 	ldbu	r2,-12(fp)
80119bdc:	10803fcc 	andi	r2,r2,255
80119be0:	10000126 	beq	r2,zero,80119be8 <bSendUART64v2+0xa8>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
80119be4:	011d19c0 	call	8011d19c <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
80119be8:	e0bffc17 	ldw	r2,-16(fp)
80119bec:	00007f06 	br	80119dec <bSendUART64v2+0x2ac>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
80119bf0:	e03ffb05 	stb	zero,-20(fp)
80119bf4:	00004506 	br	80119d0c <bSendUART64v2+0x1cc>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
80119bf8:	e0fffb03 	ldbu	r3,-20(fp)
80119bfc:	00a00574 	movhi	r2,32789
80119c00:	109a3c04 	addi	r2,r2,26864
80119c04:	18c00184 	addi	r3,r3,6
80119c08:	18c7883a 	add	r3,r3,r3
80119c0c:	18c7883a 	add	r3,r3,r3
80119c10:	10c5883a 	add	r2,r2,r3
80119c14:	10800017 	ldw	r2,0(r2)
80119c18:	1000391e 	bne	r2,zero,80119d00 <bSendUART64v2+0x1c0>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
80119c1c:	e0bffb03 	ldbu	r2,-20(fp)
80119c20:	10c01324 	muli	r3,r2,76
80119c24:	00a00574 	movhi	r2,32789
80119c28:	10b3f504 	addi	r2,r2,-12332
80119c2c:	1885883a 	add	r2,r3,r2
80119c30:	01801004 	movi	r6,64
80119c34:	000b883a 	mov	r5,zero
80119c38:	1009883a 	mov	r4,r2
80119c3c:	01215b40 	call	801215b4 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
80119c40:	e0bffb03 	ldbu	r2,-20(fp)
80119c44:	10c01324 	muli	r3,r2,76
80119c48:	00a00574 	movhi	r2,32789
80119c4c:	10b3f504 	addi	r2,r2,-12332
80119c50:	1885883a 	add	r2,r3,r2
80119c54:	01800fc4 	movi	r6,63
80119c58:	e17ffe17 	ldw	r5,-8(fp)
80119c5c:	1009883a 	mov	r4,r2
80119c60:	01214640 	call	80121464 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
80119c64:	e13ffb03 	ldbu	r4,-20(fp)
80119c68:	e0ffff0b 	ldhu	r3,-4(fp)
80119c6c:	00a00574 	movhi	r2,32789
80119c70:	10b3f504 	addi	r2,r2,-12332
80119c74:	21001324 	muli	r4,r4,76
80119c78:	1105883a 	add	r2,r2,r4
80119c7c:	10801104 	addi	r2,r2,68
80119c80:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
80119c84:	e0fffb03 	ldbu	r3,-20(fp)
80119c88:	00a00574 	movhi	r2,32789
80119c8c:	10b3f504 	addi	r2,r2,-12332
80119c90:	18c01324 	muli	r3,r3,76
80119c94:	10c5883a 	add	r2,r2,r3
80119c98:	10801204 	addi	r2,r2,72
80119c9c:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
80119ca0:	e0fffb03 	ldbu	r3,-20(fp)
80119ca4:	00a00574 	movhi	r2,32789
80119ca8:	10b3f504 	addi	r2,r2,-12332
80119cac:	18c01324 	muli	r3,r3,76
80119cb0:	10c5883a 	add	r2,r2,r3
80119cb4:	10801184 	addi	r2,r2,70
80119cb8:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
80119cbc:	e0fffb03 	ldbu	r3,-20(fp)
80119cc0:	00a00574 	movhi	r2,32789
80119cc4:	10b3f504 	addi	r2,r2,-12332
80119cc8:	18c01324 	muli	r3,r3,76
80119ccc:	10c5883a 	add	r2,r2,r3
80119cd0:	10801004 	addi	r2,r2,64
80119cd4:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
80119cd8:	e0fffb03 	ldbu	r3,-20(fp)
80119cdc:	00a00574 	movhi	r2,32789
80119ce0:	109a3c04 	addi	r2,r2,26864
80119ce4:	18c00184 	addi	r3,r3,6
80119ce8:	18c7883a 	add	r3,r3,r3
80119cec:	18c7883a 	add	r3,r3,r3
80119cf0:	10c5883a 	add	r2,r2,r3
80119cf4:	00c00044 	movi	r3,1
80119cf8:	10c00015 	stw	r3,0(r2)
			break;
80119cfc:	00000606 	br	80119d18 <bSendUART64v2+0x1d8>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
80119d00:	e0bffb03 	ldbu	r2,-20(fp)
80119d04:	10800044 	addi	r2,r2,1
80119d08:	e0bffb05 	stb	r2,-20(fp)
80119d0c:	e0bffb03 	ldbu	r2,-20(fp)
80119d10:	10800230 	cmpltui	r2,r2,8
80119d14:	103fb81e 	bne	r2,zero,80119bf8 <__reset+0xfa0f9bf8>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
80119d18:	e0bffb03 	ldbu	r2,-20(fp)
80119d1c:	10800230 	cmpltui	r2,r2,8
80119d20:	1000091e 	bne	r2,zero,80119d48 <bSendUART64v2+0x208>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
80119d24:	d0a06917 	ldw	r2,-32348(gp)
80119d28:	1009883a 	mov	r4,r2
80119d2c:	013a2840 	call	8013a284 <OSSemPost>
80119d30:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
80119d34:	d0a07a17 	ldw	r2,-32280(gp)
80119d38:	1009883a 	mov	r4,r2
80119d3c:	01384940 	call	80138494 <OSMutexPost>
		return bSuccessL;
80119d40:	e0bffc17 	ldw	r2,-16(fp)
80119d44:	00002906 	br	80119dec <bSendUART64v2+0x2ac>
	}

	bSuccessL = TRUE;
80119d48:	00800044 	movi	r2,1
80119d4c:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
80119d50:	d0a07e03 	ldbu	r2,-32264(gp)
80119d54:	10bfffc4 	addi	r2,r2,-1
80119d58:	d0a07e05 	stb	r2,-32264(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
80119d5c:	d0a07d17 	ldw	r2,-32268(gp)
80119d60:	e0fffd04 	addi	r3,fp,-12
80119d64:	180d883a 	mov	r6,r3
80119d68:	01400084 	movi	r5,2
80119d6c:	1009883a 	mov	r4,r2
80119d70:	0137ef00 	call	80137ef0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
80119d74:	e0bffd03 	ldbu	r2,-12(fp)
80119d78:	10803fcc 	andi	r2,r2,255
80119d7c:	10000526 	beq	r2,zero,80119d94 <bSendUART64v2+0x254>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
80119d80:	d0a07a17 	ldw	r2,-32280(gp)
80119d84:	1009883a 	mov	r4,r2
80119d88:	01384940 	call	80138494 <OSMutexPost>
		return bSuccessL;
80119d8c:	e0bffc17 	ldw	r2,-16(fp)
80119d90:	00001606 	br	80119dec <bSendUART64v2+0x2ac>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
80119d94:	e0bffb03 	ldbu	r2,-20(fp)
80119d98:	10c01324 	muli	r3,r2,76
80119d9c:	00a00574 	movhi	r2,32789
80119da0:	10b3f504 	addi	r2,r2,-12332
80119da4:	1885883a 	add	r2,r3,r2
80119da8:	1009883a 	mov	r4,r2
80119dac:	01217a40 	call	801217a4 <puts>
	xBuffer64[ucIL].bSent = TRUE;
80119db0:	e0fffb03 	ldbu	r3,-20(fp)
80119db4:	00a00574 	movhi	r2,32789
80119db8:	10b3f504 	addi	r2,r2,-12332
80119dbc:	18c01324 	muli	r3,r3,76
80119dc0:	10c5883a 	add	r2,r2,r3
80119dc4:	10801004 	addi	r2,r2,64
80119dc8:	00c00044 	movi	r3,1
80119dcc:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
80119dd0:	d0a07d17 	ldw	r2,-32268(gp)
80119dd4:	1009883a 	mov	r4,r2
80119dd8:	01384940 	call	80138494 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
80119ddc:	d0a07a17 	ldw	r2,-32280(gp)
80119de0:	1009883a 	mov	r4,r2
80119de4:	01384940 	call	80138494 <OSMutexPost>

	return bSuccessL;
80119de8:	e0bffc17 	ldw	r2,-16(fp)
}
80119dec:	e037883a 	mov	sp,fp
80119df0:	dfc00117 	ldw	ra,4(sp)
80119df4:	df000017 	ldw	fp,0(sp)
80119df8:	dec00204 	addi	sp,sp,8
80119dfc:	f800283a 	ret

80119e00 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
80119e00:	defff904 	addi	sp,sp,-28
80119e04:	de00012e 	bgeu	sp,et,80119e0c <bSendUART32v2+0xc>
80119e08:	003b68fa 	trap	3
80119e0c:	dfc00615 	stw	ra,24(sp)
80119e10:	df000515 	stw	fp,20(sp)
80119e14:	df000504 	addi	fp,sp,20
80119e18:	e13ffe15 	stw	r4,-8(fp)
80119e1c:	2805883a 	mov	r2,r5
80119e20:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
80119e24:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
80119e28:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
80119e2c:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
80119e30:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
80119e34:	d0a07817 	ldw	r2,-32288(gp)
80119e38:	e0fffd04 	addi	r3,fp,-12
80119e3c:	180d883a 	mov	r6,r3
80119e40:	01400504 	movi	r5,20
80119e44:	1009883a 	mov	r4,r2
80119e48:	0139efc0 	call	80139efc <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
80119e4c:	e0bffd03 	ldbu	r2,-12(fp)
80119e50:	10803fcc 	andi	r2,r2,255
80119e54:	10000326 	beq	r2,zero,80119e64 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
80119e58:	011d23c0 	call	8011d23c <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
80119e5c:	e0bffc17 	ldw	r2,-16(fp)
80119e60:	00009206 	br	8011a0ac <bSendUART32v2+0x2ac>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
80119e64:	d0a07517 	ldw	r2,-32300(gp)
80119e68:	e0fffd04 	addi	r3,fp,-12
80119e6c:	180d883a 	mov	r6,r3
80119e70:	01400104 	movi	r5,4
80119e74:	1009883a 	mov	r4,r2
80119e78:	0137ef00 	call	80137ef0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
80119e7c:	e0bffd03 	ldbu	r2,-12(fp)
80119e80:	10803fcc 	andi	r2,r2,255
80119e84:	10000a26 	beq	r2,zero,80119eb0 <bSendUART32v2+0xb0>
		#if DEBUG_ON
		if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
		}
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
80119e88:	d0a07817 	ldw	r2,-32288(gp)
80119e8c:	1009883a 	mov	r4,r2
80119e90:	013a2840 	call	8013a284 <OSSemPost>
80119e94:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
80119e98:	e0bffd03 	ldbu	r2,-12(fp)
80119e9c:	10803fcc 	andi	r2,r2,255
80119ea0:	10000126 	beq	r2,zero,80119ea8 <bSendUART32v2+0xa8>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
80119ea4:	011d1740 	call	8011d174 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
80119ea8:	e0bffc17 	ldw	r2,-16(fp)
80119eac:	00007f06 	br	8011a0ac <bSendUART32v2+0x2ac>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
80119eb0:	e03ffb05 	stb	zero,-20(fp)
80119eb4:	00004506 	br	80119fcc <bSendUART32v2+0x1cc>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
80119eb8:	e0fffb03 	ldbu	r3,-20(fp)
80119ebc:	00a00574 	movhi	r2,32789
80119ec0:	109a3c04 	addi	r2,r2,26864
80119ec4:	18c00384 	addi	r3,r3,14
80119ec8:	18c7883a 	add	r3,r3,r3
80119ecc:	18c7883a 	add	r3,r3,r3
80119ed0:	10c5883a 	add	r2,r2,r3
80119ed4:	10800017 	ldw	r2,0(r2)
80119ed8:	1000391e 	bne	r2,zero,80119fc0 <bSendUART32v2+0x1c0>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
80119edc:	e0bffb03 	ldbu	r2,-20(fp)
80119ee0:	10c00b24 	muli	r3,r2,44
80119ee4:	00a00574 	movhi	r2,32789
80119ee8:	1087c404 	addi	r2,r2,7952
80119eec:	1885883a 	add	r2,r3,r2
80119ef0:	01800804 	movi	r6,32
80119ef4:	000b883a 	mov	r5,zero
80119ef8:	1009883a 	mov	r4,r2
80119efc:	01215b40 	call	801215b4 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
80119f00:	e0bffb03 	ldbu	r2,-20(fp)
80119f04:	10c00b24 	muli	r3,r2,44
80119f08:	00a00574 	movhi	r2,32789
80119f0c:	1087c404 	addi	r2,r2,7952
80119f10:	1885883a 	add	r2,r3,r2
80119f14:	018007c4 	movi	r6,31
80119f18:	e17ffe17 	ldw	r5,-8(fp)
80119f1c:	1009883a 	mov	r4,r2
80119f20:	01214640 	call	80121464 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
80119f24:	e13ffb03 	ldbu	r4,-20(fp)
80119f28:	e0ffff0b 	ldhu	r3,-4(fp)
80119f2c:	00a00574 	movhi	r2,32789
80119f30:	1087c404 	addi	r2,r2,7952
80119f34:	21000b24 	muli	r4,r4,44
80119f38:	1105883a 	add	r2,r2,r4
80119f3c:	10800904 	addi	r2,r2,36
80119f40:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
80119f44:	e0fffb03 	ldbu	r3,-20(fp)
80119f48:	00a00574 	movhi	r2,32789
80119f4c:	1087c404 	addi	r2,r2,7952
80119f50:	18c00b24 	muli	r3,r3,44
80119f54:	10c5883a 	add	r2,r2,r3
80119f58:	10800a04 	addi	r2,r2,40
80119f5c:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
80119f60:	e0fffb03 	ldbu	r3,-20(fp)
80119f64:	00a00574 	movhi	r2,32789
80119f68:	1087c404 	addi	r2,r2,7952
80119f6c:	18c00b24 	muli	r3,r3,44
80119f70:	10c5883a 	add	r2,r2,r3
80119f74:	10800984 	addi	r2,r2,38
80119f78:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
80119f7c:	e0fffb03 	ldbu	r3,-20(fp)
80119f80:	00a00574 	movhi	r2,32789
80119f84:	1087c404 	addi	r2,r2,7952
80119f88:	18c00b24 	muli	r3,r3,44
80119f8c:	10c5883a 	add	r2,r2,r3
80119f90:	10800804 	addi	r2,r2,32
80119f94:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
80119f98:	e0fffb03 	ldbu	r3,-20(fp)
80119f9c:	00a00574 	movhi	r2,32789
80119fa0:	109a3c04 	addi	r2,r2,26864
80119fa4:	18c00384 	addi	r3,r3,14
80119fa8:	18c7883a 	add	r3,r3,r3
80119fac:	18c7883a 	add	r3,r3,r3
80119fb0:	10c5883a 	add	r2,r2,r3
80119fb4:	00c00044 	movi	r3,1
80119fb8:	10c00015 	stw	r3,0(r2)
			break;
80119fbc:	00000606 	br	80119fd8 <bSendUART32v2+0x1d8>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
80119fc0:	e0bffb03 	ldbu	r2,-20(fp)
80119fc4:	10800044 	addi	r2,r2,1
80119fc8:	e0bffb05 	stb	r2,-20(fp)
80119fcc:	e0bffb03 	ldbu	r2,-20(fp)
80119fd0:	10800230 	cmpltui	r2,r2,8
80119fd4:	103fb81e 	bne	r2,zero,80119eb8 <__reset+0xfa0f9eb8>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
80119fd8:	e0bffb03 	ldbu	r2,-20(fp)
80119fdc:	10800230 	cmpltui	r2,r2,8
80119fe0:	1000091e 	bne	r2,zero,8011a008 <bSendUART32v2+0x208>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
80119fe4:	d0a07817 	ldw	r2,-32288(gp)
80119fe8:	1009883a 	mov	r4,r2
80119fec:	013a2840 	call	8013a284 <OSSemPost>
80119ff0:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
80119ff4:	d0a07517 	ldw	r2,-32300(gp)
80119ff8:	1009883a 	mov	r4,r2
80119ffc:	01384940 	call	80138494 <OSMutexPost>
		return bSuccessL;
8011a000:	e0bffc17 	ldw	r2,-16(fp)
8011a004:	00002906 	br	8011a0ac <bSendUART32v2+0x2ac>
	}
	
	bSuccessL = TRUE;
8011a008:	00800044 	movi	r2,1
8011a00c:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
8011a010:	d0a07283 	ldbu	r2,-32310(gp)
8011a014:	10bfffc4 	addi	r2,r2,-1
8011a018:	d0a07285 	stb	r2,-32310(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8011a01c:	d0a07d17 	ldw	r2,-32268(gp)
8011a020:	e0fffd04 	addi	r3,fp,-12
8011a024:	180d883a 	mov	r6,r3
8011a028:	01400084 	movi	r5,2
8011a02c:	1009883a 	mov	r4,r2
8011a030:	0137ef00 	call	80137ef0 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8011a034:	e0bffd03 	ldbu	r2,-12(fp)
8011a038:	10803fcc 	andi	r2,r2,255
8011a03c:	10000526 	beq	r2,zero,8011a054 <bSendUART32v2+0x254>
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
		}
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
8011a040:	d0a07517 	ldw	r2,-32300(gp)
8011a044:	1009883a 	mov	r4,r2
8011a048:	01384940 	call	80138494 <OSMutexPost>
		return bSuccessL;
8011a04c:	e0bffc17 	ldw	r2,-16(fp)
8011a050:	00001606 	br	8011a0ac <bSendUART32v2+0x2ac>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
8011a054:	e0bffb03 	ldbu	r2,-20(fp)
8011a058:	10c00b24 	muli	r3,r2,44
8011a05c:	00a00574 	movhi	r2,32789
8011a060:	1087c404 	addi	r2,r2,7952
8011a064:	1885883a 	add	r2,r3,r2
8011a068:	1009883a 	mov	r4,r2
8011a06c:	01217a40 	call	801217a4 <puts>
	xBuffer32[ucIL].bSent = TRUE;
8011a070:	e0fffb03 	ldbu	r3,-20(fp)
8011a074:	00a00574 	movhi	r2,32789
8011a078:	1087c404 	addi	r2,r2,7952
8011a07c:	18c00b24 	muli	r3,r3,44
8011a080:	10c5883a 	add	r2,r2,r3
8011a084:	10800804 	addi	r2,r2,32
8011a088:	00c00044 	movi	r3,1
8011a08c:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
8011a090:	d0a07d17 	ldw	r2,-32268(gp)
8011a094:	1009883a 	mov	r4,r2
8011a098:	01384940 	call	80138494 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
8011a09c:	d0a07517 	ldw	r2,-32300(gp)
8011a0a0:	1009883a 	mov	r4,r2
8011a0a4:	01384940 	call	80138494 <OSMutexPost>

	return bSuccessL;
8011a0a8:	e0bffc17 	ldw	r2,-16(fp)
}
8011a0ac:	e037883a 	mov	sp,fp
8011a0b0:	dfc00117 	ldw	ra,4(sp)
8011a0b4:	df000017 	ldw	fp,0(sp)
8011a0b8:	dec00204 	addi	sp,sp,8
8011a0bc:	f800283a 	ret

8011a0c0 <vSendEthConf>:


void vSendEthConf ( void ) {
8011a0c0:	deffc304 	addi	sp,sp,-244
8011a0c4:	de00012e 	bgeu	sp,et,8011a0cc <vSendEthConf+0xc>
8011a0c8:	003b68fa 	trap	3
8011a0cc:	dfc03c15 	stw	ra,240(sp)
8011a0d0:	df003b15 	stw	fp,236(sp)
8011a0d4:	dd403a15 	stw	r21,232(sp)
8011a0d8:	dd003915 	stw	r20,228(sp)
8011a0dc:	dcc03815 	stw	r19,224(sp)
8011a0e0:	dc803715 	stw	r18,220(sp)
8011a0e4:	dc403615 	stw	r17,216(sp)
8011a0e8:	dc003515 	stw	r16,212(sp)
8011a0ec:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
8011a0f0:	e03fd98d 	sth	zero,-154(fp)
8011a0f4:	e03fda0d 	sth	zero,-152(fp)
8011a0f8:	e0bfda84 	addi	r2,fp,-150
8011a0fc:	00c01f04 	movi	r3,124
8011a100:	180d883a 	mov	r6,r3
8011a104:	000b883a 	mov	r5,zero
8011a108:	1009883a 	mov	r4,r2
8011a10c:	01215b40 	call	801215b4 <memset>
    unsigned char crc = 0;
8011a110:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8011a114:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
8011a118:	011a6800 	call	8011a680 <usiGetIdCMD>
8011a11c:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a120:	e57fd90b 	ldhu	r21,-156(fp)
8011a124:	00a005b4 	movhi	r2,32790
8011a128:	10ba4304 	addi	r2,r2,-5876
8011a12c:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8011a130:	00a005b4 	movhi	r2,32790
8011a134:	10ba4304 	addi	r2,r2,-5876
8011a138:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a13c:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8011a140:	00a005b4 	movhi	r2,32790
8011a144:	10ba4304 	addi	r2,r2,-5876
8011a148:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a14c:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8011a150:	00a005b4 	movhi	r2,32790
8011a154:	10ba4304 	addi	r2,r2,-5876
8011a158:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a15c:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8011a160:	00a005b4 	movhi	r2,32790
8011a164:	10ba4304 	addi	r2,r2,-5876
8011a168:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a16c:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8011a170:	00a005b4 	movhi	r2,32790
8011a174:	10ba4304 	addi	r2,r2,-5876
8011a178:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a17c:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8011a180:	00a005b4 	movhi	r2,32790
8011a184:	10ba4304 	addi	r2,r2,-5876
8011a188:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a18c:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8011a190:	00a005b4 	movhi	r2,32790
8011a194:	10ba4304 	addi	r2,r2,-5876
8011a198:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a19c:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8011a1a0:	00a005b4 	movhi	r2,32790
8011a1a4:	10ba4304 	addi	r2,r2,-5876
8011a1a8:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a1ac:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8011a1b0:	00a005b4 	movhi	r2,32790
8011a1b4:	10ba4304 	addi	r2,r2,-5876
8011a1b8:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a1bc:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8011a1c0:	00a005b4 	movhi	r2,32790
8011a1c4:	10ba4304 	addi	r2,r2,-5876
8011a1c8:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a1cc:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8011a1d0:	00a005b4 	movhi	r2,32790
8011a1d4:	10ba4304 	addi	r2,r2,-5876
8011a1d8:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a1dc:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8011a1e0:	00a005b4 	movhi	r2,32790
8011a1e4:	10ba4304 	addi	r2,r2,-5876
8011a1e8:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a1ec:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8011a1f0:	00a005b4 	movhi	r2,32790
8011a1f4:	10ba4304 	addi	r2,r2,-5876
8011a1f8:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a1fc:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8011a200:	00a005b4 	movhi	r2,32790
8011a204:	10ba4304 	addi	r2,r2,-5876
8011a208:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a20c:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8011a210:	00a005b4 	movhi	r2,32790
8011a214:	10ba4304 	addi	r2,r2,-5876
8011a218:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a21c:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8011a220:	00a005b4 	movhi	r2,32790
8011a224:	10ba4304 	addi	r2,r2,-5876
8011a228:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a22c:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
8011a230:	00a005b4 	movhi	r2,32790
8011a234:	10ba4304 	addi	r2,r2,-5876
8011a238:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8011a23c:	10bfffcc 	andi	r2,r2,65535
8011a240:	e53fd984 	addi	r20,fp,-154
8011a244:	d8801115 	stw	r2,68(sp)
8011a248:	dcc01015 	stw	r19,64(sp)
8011a24c:	dc800f15 	stw	r18,60(sp)
8011a250:	dc400e15 	stw	r17,56(sp)
8011a254:	dc000d15 	stw	r16,52(sp)
8011a258:	dbc00c15 	stw	r15,48(sp)
8011a25c:	db800b15 	stw	r14,44(sp)
8011a260:	db400a15 	stw	r13,40(sp)
8011a264:	db000915 	stw	r12,36(sp)
8011a268:	dac00815 	stw	r11,32(sp)
8011a26c:	da800715 	stw	r10,28(sp)
8011a270:	da400615 	stw	r9,24(sp)
8011a274:	da000515 	stw	r8,20(sp)
8011a278:	d9c00415 	stw	r7,16(sp)
8011a27c:	d9800315 	stw	r6,12(sp)
8011a280:	d9400215 	stw	r5,8(sp)
8011a284:	d9000115 	stw	r4,4(sp)
8011a288:	d8c00015 	stw	r3,0(sp)
8011a28c:	a80f883a 	mov	r7,r21
8011a290:	018010c4 	movi	r6,67
8011a294:	01600534 	movhi	r5,32788
8011a298:	295d6204 	addi	r5,r5,30088
8011a29c:	a009883a 	mov	r4,r20
8011a2a0:	01218940 	call	80121894 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
8011a2a4:	e0bfd984 	addi	r2,fp,-154
8011a2a8:	1009883a 	mov	r4,r2
8011a2ac:	01219540 	call	80121954 <strlen>
8011a2b0:	1007883a 	mov	r3,r2
8011a2b4:	e0bfd984 	addi	r2,fp,-154
8011a2b8:	180b883a 	mov	r5,r3
8011a2bc:	1009883a 	mov	r4,r2
8011a2c0:	011cd040 	call	8011cd04 <ucCrc8wInit>
8011a2c4:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
8011a2c8:	e13fd703 	ldbu	r4,-164(fp)
8011a2cc:	e0ffd984 	addi	r3,fp,-154
8011a2d0:	e0bfd984 	addi	r2,fp,-154
8011a2d4:	200f883a 	mov	r7,r4
8011a2d8:	180d883a 	mov	r6,r3
8011a2dc:	01600534 	movhi	r5,32788
8011a2e0:	295d7a04 	addi	r5,r5,30184
8011a2e4:	1009883a 	mov	r4,r2
8011a2e8:	01218940 	call	80121894 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
8011a2ec:	e0bfd90b 	ldhu	r2,-156(fp)
8011a2f0:	10ffffcc 	andi	r3,r2,65535
8011a2f4:	18e0001c 	xori	r3,r3,32768
8011a2f8:	18e00004 	addi	r3,r3,-32768
8011a2fc:	e0bfd984 	addi	r2,fp,-154
8011a300:	180b883a 	mov	r5,r3
8011a304:	1009883a 	mov	r4,r2
8011a308:	01198880 	call	80119888 <bSendUART128v2>
8011a30c:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
8011a310:	e0bfd817 	ldw	r2,-160(fp)
8011a314:	10800060 	cmpeqi	r2,r2,1
8011a318:	1000011e 	bne	r2,zero,8011a320 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
8011a31c:	011d3040 	call	8011d304 <vCouldNotSendEthConfUART>
	}
}
8011a320:	0001883a 	nop
8011a324:	e6fffa04 	addi	sp,fp,-24
8011a328:	dfc00717 	ldw	ra,28(sp)
8011a32c:	df000617 	ldw	fp,24(sp)
8011a330:	dd400517 	ldw	r21,20(sp)
8011a334:	dd000417 	ldw	r20,16(sp)
8011a338:	dcc00317 	ldw	r19,12(sp)
8011a33c:	dc800217 	ldw	r18,8(sp)
8011a340:	dc400117 	ldw	r17,4(sp)
8011a344:	dc000017 	ldw	r16,0(sp)
8011a348:	dec00804 	addi	sp,sp,32
8011a34c:	f800283a 	ret

8011a350 <vSendTurnOff>:


void vSendTurnOff ( void ) {
8011a350:	defff304 	addi	sp,sp,-52
8011a354:	de00012e 	bgeu	sp,et,8011a35c <vSendTurnOff+0xc>
8011a358:	003b68fa 	trap	3
8011a35c:	dfc00c15 	stw	ra,48(sp)
8011a360:	df000b15 	stw	fp,44(sp)
8011a364:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8011a368:	e03ff78d 	sth	zero,-34(fp)
8011a36c:	e03ff80d 	sth	zero,-32(fp)
8011a370:	e03ff88d 	sth	zero,-30(fp)
8011a374:	e03ff90d 	sth	zero,-28(fp)
8011a378:	e03ff98d 	sth	zero,-26(fp)
8011a37c:	e03ffa0d 	sth	zero,-24(fp)
8011a380:	e03ffa8d 	sth	zero,-22(fp)
8011a384:	e03ffb0d 	sth	zero,-20(fp)
8011a388:	e03ffb8d 	sth	zero,-18(fp)
8011a38c:	e03ffc0d 	sth	zero,-16(fp)
8011a390:	e03ffc8d 	sth	zero,-14(fp)
8011a394:	e03ffd0d 	sth	zero,-12(fp)
8011a398:	e03ffd8d 	sth	zero,-10(fp)
8011a39c:	e03ffe0d 	sth	zero,-8(fp)
8011a3a0:	e03ffe8d 	sth	zero,-6(fp)
8011a3a4:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8011a3a8:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8011a3ac:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8011a3b0:	011a6800 	call	8011a680 <usiGetIdCMD>
8011a3b4:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
8011a3b8:	e0fff70b 	ldhu	r3,-36(fp)
8011a3bc:	e0bff784 	addi	r2,fp,-34
8011a3c0:	180d883a 	mov	r6,r3
8011a3c4:	01600534 	movhi	r5,32788
8011a3c8:	295d7d04 	addi	r5,r5,30196
8011a3cc:	1009883a 	mov	r4,r2
8011a3d0:	01218940 	call	80121894 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8011a3d4:	e0bff784 	addi	r2,fp,-34
8011a3d8:	1009883a 	mov	r4,r2
8011a3dc:	01219540 	call	80121954 <strlen>
8011a3e0:	1007883a 	mov	r3,r2
8011a3e4:	e0bff784 	addi	r2,fp,-34
8011a3e8:	180b883a 	mov	r5,r3
8011a3ec:	1009883a 	mov	r4,r2
8011a3f0:	011cd040 	call	8011cd04 <ucCrc8wInit>
8011a3f4:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8011a3f8:	e13ff503 	ldbu	r4,-44(fp)
8011a3fc:	e0fff784 	addi	r3,fp,-34
8011a400:	e0bff784 	addi	r2,fp,-34
8011a404:	200f883a 	mov	r7,r4
8011a408:	180d883a 	mov	r6,r3
8011a40c:	01600534 	movhi	r5,32788
8011a410:	295d7a04 	addi	r5,r5,30184
8011a414:	1009883a 	mov	r4,r2
8011a418:	01218940 	call	80121894 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8011a41c:	e0bff70b 	ldhu	r2,-36(fp)
8011a420:	10ffffcc 	andi	r3,r2,65535
8011a424:	18e0001c 	xori	r3,r3,32768
8011a428:	18e00004 	addi	r3,r3,-32768
8011a42c:	e0bff784 	addi	r2,fp,-34
8011a430:	180b883a 	mov	r5,r3
8011a434:	1009883a 	mov	r4,r2
8011a438:	0119e000 	call	80119e00 <bSendUART32v2>
8011a43c:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8011a440:	e0bff617 	ldw	r2,-40(fp)
8011a444:	10800060 	cmpeqi	r2,r2,1
8011a448:	1000011e 	bne	r2,zero,8011a450 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8011a44c:	011d5d40 	call	8011d5d4 <vCouldNotSendTurnOff>
	}
}
8011a450:	0001883a 	nop
8011a454:	e037883a 	mov	sp,fp
8011a458:	dfc00117 	ldw	ra,4(sp)
8011a45c:	df000017 	ldw	fp,0(sp)
8011a460:	dec00204 	addi	sp,sp,8
8011a464:	f800283a 	ret

8011a468 <vSendReset>:

void vSendReset ( void ) {
8011a468:	defff304 	addi	sp,sp,-52
8011a46c:	de00012e 	bgeu	sp,et,8011a474 <vSendReset+0xc>
8011a470:	003b68fa 	trap	3
8011a474:	dfc00c15 	stw	ra,48(sp)
8011a478:	df000b15 	stw	fp,44(sp)
8011a47c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
8011a480:	e03ff78d 	sth	zero,-34(fp)
8011a484:	e03ff80d 	sth	zero,-32(fp)
8011a488:	e03ff88d 	sth	zero,-30(fp)
8011a48c:	e03ff90d 	sth	zero,-28(fp)
8011a490:	e03ff98d 	sth	zero,-26(fp)
8011a494:	e03ffa0d 	sth	zero,-24(fp)
8011a498:	e03ffa8d 	sth	zero,-22(fp)
8011a49c:	e03ffb0d 	sth	zero,-20(fp)
8011a4a0:	e03ffb8d 	sth	zero,-18(fp)
8011a4a4:	e03ffc0d 	sth	zero,-16(fp)
8011a4a8:	e03ffc8d 	sth	zero,-14(fp)
8011a4ac:	e03ffd0d 	sth	zero,-12(fp)
8011a4b0:	e03ffd8d 	sth	zero,-10(fp)
8011a4b4:	e03ffe0d 	sth	zero,-8(fp)
8011a4b8:	e03ffe8d 	sth	zero,-6(fp)
8011a4bc:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8011a4c0:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8011a4c4:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8011a4c8:	011a6800 	call	8011a680 <usiGetIdCMD>
8011a4cc:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
8011a4d0:	e0fff70b 	ldhu	r3,-36(fp)
8011a4d4:	e0bff784 	addi	r2,fp,-34
8011a4d8:	180d883a 	mov	r6,r3
8011a4dc:	01600534 	movhi	r5,32788
8011a4e0:	295d7f04 	addi	r5,r5,30204
8011a4e4:	1009883a 	mov	r4,r2
8011a4e8:	01218940 	call	80121894 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8011a4ec:	e0bff784 	addi	r2,fp,-34
8011a4f0:	1009883a 	mov	r4,r2
8011a4f4:	01219540 	call	80121954 <strlen>
8011a4f8:	1007883a 	mov	r3,r2
8011a4fc:	e0bff784 	addi	r2,fp,-34
8011a500:	180b883a 	mov	r5,r3
8011a504:	1009883a 	mov	r4,r2
8011a508:	011cd040 	call	8011cd04 <ucCrc8wInit>
8011a50c:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8011a510:	e13ff503 	ldbu	r4,-44(fp)
8011a514:	e0fff784 	addi	r3,fp,-34
8011a518:	e0bff784 	addi	r2,fp,-34
8011a51c:	200f883a 	mov	r7,r4
8011a520:	180d883a 	mov	r6,r3
8011a524:	01600534 	movhi	r5,32788
8011a528:	295d7a04 	addi	r5,r5,30184
8011a52c:	1009883a 	mov	r4,r2
8011a530:	01218940 	call	80121894 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8011a534:	e0bff70b 	ldhu	r2,-36(fp)
8011a538:	10ffffcc 	andi	r3,r2,65535
8011a53c:	18e0001c 	xori	r3,r3,32768
8011a540:	18e00004 	addi	r3,r3,-32768
8011a544:	e0bff784 	addi	r2,fp,-34
8011a548:	180b883a 	mov	r5,r3
8011a54c:	1009883a 	mov	r4,r2
8011a550:	0119e000 	call	80119e00 <bSendUART32v2>
8011a554:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
8011a558:	e0bff617 	ldw	r2,-40(fp)
8011a55c:	10800060 	cmpeqi	r2,r2,1
8011a560:	1000011e 	bne	r2,zero,8011a568 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8011a564:	011d5d40 	call	8011d5d4 <vCouldNotSendTurnOff>
	}
}
8011a568:	0001883a 	nop
8011a56c:	e037883a 	mov	sp,fp
8011a570:	dfc00117 	ldw	ra,4(sp)
8011a574:	df000017 	ldw	fp,0(sp)
8011a578:	dec00204 	addi	sp,sp,8
8011a57c:	f800283a 	ret

8011a580 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
8011a580:	deffda04 	addi	sp,sp,-152
8011a584:	de00012e 	bgeu	sp,et,8011a58c <vSendLog+0xc>
8011a588:	003b68fa 	trap	3
8011a58c:	dfc02515 	stw	ra,148(sp)
8011a590:	df002415 	stw	fp,144(sp)
8011a594:	df002404 	addi	fp,sp,144
8011a598:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8011a59c:	e03fde8d 	sth	zero,-134(fp)
8011a5a0:	e03fdf0d 	sth	zero,-132(fp)
8011a5a4:	e0bfdf84 	addi	r2,fp,-130
8011a5a8:	00c01f04 	movi	r3,124
8011a5ac:	180d883a 	mov	r6,r3
8011a5b0:	000b883a 	mov	r5,zero
8011a5b4:	1009883a 	mov	r4,r2
8011a5b8:	01215b40 	call	801215b4 <memset>
    unsigned char crc = 0;
8011a5bc:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8011a5c0:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8011a5c4:	011a6800 	call	8011a680 <usiGetIdCMD>
8011a5c8:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8011a5cc:	e0ffde0b 	ldhu	r3,-136(fp)
8011a5d0:	e0bfde84 	addi	r2,fp,-134
8011a5d4:	e1ffff17 	ldw	r7,-4(fp)
8011a5d8:	180d883a 	mov	r6,r3
8011a5dc:	01600534 	movhi	r5,32788
8011a5e0:	295d8104 	addi	r5,r5,30212
8011a5e4:	1009883a 	mov	r4,r2
8011a5e8:	01218940 	call	80121894 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
8011a5ec:	e0bfde84 	addi	r2,fp,-134
8011a5f0:	1009883a 	mov	r4,r2
8011a5f4:	01219540 	call	80121954 <strlen>
8011a5f8:	1007883a 	mov	r3,r2
8011a5fc:	e0bfde84 	addi	r2,fp,-134
8011a600:	180b883a 	mov	r5,r3
8011a604:	1009883a 	mov	r4,r2
8011a608:	011cd040 	call	8011cd04 <ucCrc8wInit>
8011a60c:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8011a610:	e13fdc03 	ldbu	r4,-144(fp)
8011a614:	e0ffde84 	addi	r3,fp,-134
8011a618:	e0bfde84 	addi	r2,fp,-134
8011a61c:	200f883a 	mov	r7,r4
8011a620:	180d883a 	mov	r6,r3
8011a624:	01600534 	movhi	r5,32788
8011a628:	295d7a04 	addi	r5,r5,30184
8011a62c:	1009883a 	mov	r4,r2
8011a630:	01218940 	call	80121894 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8011a634:	e0bfde0b 	ldhu	r2,-136(fp)
8011a638:	10ffffcc 	andi	r3,r2,65535
8011a63c:	18e0001c 	xori	r3,r3,32768
8011a640:	18e00004 	addi	r3,r3,-32768
8011a644:	e0bfde84 	addi	r2,fp,-134
8011a648:	180b883a 	mov	r5,r3
8011a64c:	1009883a 	mov	r4,r2
8011a650:	01198880 	call	80119888 <bSendUART128v2>
8011a654:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
8011a658:	e0bfdd17 	ldw	r2,-140(fp)
8011a65c:	10800060 	cmpeqi	r2,r2,1
8011a660:	1000011e 	bne	r2,zero,8011a668 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8011a664:	011d6240 	call	8011d624 <vCouldNotSendLog>
	}
}
8011a668:	0001883a 	nop
8011a66c:	e037883a 	mov	sp,fp
8011a670:	dfc00117 	ldw	ra,4(sp)
8011a674:	df000017 	ldw	fp,0(sp)
8011a678:	dec00204 	addi	sp,sp,8
8011a67c:	f800283a 	ret

8011a680 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
8011a680:	deffff04 	addi	sp,sp,-4
8011a684:	de00012e 	bgeu	sp,et,8011a68c <usiGetIdCMD+0xc>
8011a688:	003b68fa 	trap	3
8011a68c:	df000015 	stw	fp,0(sp)
8011a690:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8011a694:	d0a0720b 	ldhu	r2,-32312(gp)
8011a698:	10ffffcc 	andi	r3,r2,65535
8011a69c:	00bfffd4 	movui	r2,65535
8011a6a0:	1880031e 	bne	r3,r2,8011a6b0 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8011a6a4:	00800084 	movi	r2,2
8011a6a8:	d0a0720d 	sth	r2,-32312(gp)
8011a6ac:	00000306 	br	8011a6bc <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8011a6b0:	d0a0720b 	ldhu	r2,-32312(gp)
8011a6b4:	10800044 	addi	r2,r2,1
8011a6b8:	d0a0720d 	sth	r2,-32312(gp)

    return usiIdCMD;
8011a6bc:	d0a0720b 	ldhu	r2,-32312(gp)
}
8011a6c0:	e037883a 	mov	sp,fp
8011a6c4:	df000017 	ldw	fp,0(sp)
8011a6c8:	dec00104 	addi	sp,sp,4
8011a6cc:	f800283a 	ret

8011a6d0 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8011a6d0:	defffb04 	addi	sp,sp,-20
8011a6d4:	de00012e 	bgeu	sp,et,8011a6dc <siPosStr+0xc>
8011a6d8:	003b68fa 	trap	3
8011a6dc:	dfc00415 	stw	ra,16(sp)
8011a6e0:	df000315 	stw	fp,12(sp)
8011a6e4:	df000304 	addi	fp,sp,12
8011a6e8:	e13ffe15 	stw	r4,-8(fp)
8011a6ec:	2805883a 	mov	r2,r5
8011a6f0:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
8011a6f4:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
8011a6f8:	e0bfff03 	ldbu	r2,-4(fp)
8011a6fc:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8011a700:	e17ffd04 	addi	r5,fp,-12
8011a704:	e13ffe17 	ldw	r4,-8(fp)
8011a708:	01219080 	call	80121908 <strcspn>
}
8011a70c:	e037883a 	mov	sp,fp
8011a710:	dfc00117 	ldw	ra,4(sp)
8011a714:	df000017 	ldw	fp,0(sp)
8011a718:	dec00204 	addi	sp,sp,8
8011a71c:	f800283a 	ret

8011a720 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8011a720:	defffc04 	addi	sp,sp,-16
8011a724:	de00012e 	bgeu	sp,et,8011a72c <vTimeoutCheck+0xc>
8011a728:	003b68fa 	trap	3
8011a72c:	dfc00315 	stw	ra,12(sp)
8011a730:	df000215 	stw	fp,8(sp)
8011a734:	df000204 	addi	fp,sp,8
8011a738:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8011a73c:	d0a07117 	ldw	r2,-32316(gp)
8011a740:	1009883a 	mov	r4,r2
8011a744:	013a2840 	call	8013a284 <OSSemPost>
8011a748:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8011a74c:	e0bffe03 	ldbu	r2,-8(fp)
8011a750:	10000126 	beq	r2,zero,8011a758 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8011a754:	011d4e40 	call	8011d4e4 <vFailPostBlockingSemTimeoutTask>
	}
}
8011a758:	0001883a 	nop
8011a75c:	e037883a 	mov	sp,fp
8011a760:	dfc00117 	ldw	ra,4(sp)
8011a764:	df000017 	ldw	fp,0(sp)
8011a768:	dec00204 	addi	sp,sp,8
8011a76c:	f800283a 	ret

8011a770 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
8011a770:	deffe304 	addi	sp,sp,-116
8011a774:	de00012e 	bgeu	sp,et,8011a77c <vSendPusTM64+0xc>
8011a778:	003b68fa 	trap	3
8011a77c:	dfc01815 	stw	ra,96(sp)
8011a780:	df001715 	stw	fp,92(sp)
8011a784:	df001704 	addi	fp,sp,92
8011a788:	e1000215 	stw	r4,8(fp)
8011a78c:	e1400315 	stw	r5,12(fp)
8011a790:	e1800415 	stw	r6,16(fp)
8011a794:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
8011a798:	e03fef8d 	sth	zero,-66(fp)
8011a79c:	e03ff00d 	sth	zero,-64(fp)
8011a7a0:	e0bff084 	addi	r2,fp,-62
8011a7a4:	00c00f04 	movi	r3,60
8011a7a8:	180d883a 	mov	r6,r3
8011a7ac:	000b883a 	mov	r5,zero
8011a7b0:	1009883a 	mov	r4,r2
8011a7b4:	01215b40 	call	801215b4 <memset>
    unsigned char crc = 0;
8011a7b8:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8011a7bc:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8011a7c0:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8011a7c4:	011a6800 	call	8011a680 <usiGetIdCMD>
8011a7c8:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8011a7cc:	e1bfef0b 	ldhu	r6,-68(fp)
8011a7d0:	e080040b 	ldhu	r2,16(fp)
8011a7d4:	11ffffcc 	andi	r7,r2,65535
8011a7d8:	e080048b 	ldhu	r2,18(fp)
8011a7dc:	10bfffcc 	andi	r2,r2,65535
8011a7e0:	e0c0050b 	ldhu	r3,20(fp)
8011a7e4:	18ffffcc 	andi	r3,r3,65535
8011a7e8:	e100058b 	ldhu	r4,22(fp)
8011a7ec:	213fffcc 	andi	r4,r4,65535
8011a7f0:	e140060b 	ldhu	r5,24(fp)
8011a7f4:	297fffcc 	andi	r5,r5,65535
8011a7f8:	e23fef84 	addi	r8,fp,-66
8011a7fc:	d9400315 	stw	r5,12(sp)
8011a800:	d9000215 	stw	r4,8(sp)
8011a804:	d8c00115 	stw	r3,4(sp)
8011a808:	d8800015 	stw	r2,0(sp)
8011a80c:	01600534 	movhi	r5,32788
8011a810:	295d8404 	addi	r5,r5,30224
8011a814:	4009883a 	mov	r4,r8
8011a818:	01218940 	call	80121894 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8011a81c:	e03fed05 	stb	zero,-76(fp)
8011a820:	00001206 	br	8011a86c <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8011a824:	e0bfed03 	ldbu	r2,-76(fp)
8011a828:	10800284 	addi	r2,r2,10
8011a82c:	1085883a 	add	r2,r2,r2
8011a830:	e0c00204 	addi	r3,fp,8
8011a834:	1885883a 	add	r2,r3,r2
8011a838:	1080000b 	ldhu	r2,0(r2)
8011a83c:	113fffcc 	andi	r4,r2,65535
8011a840:	e0ffef84 	addi	r3,fp,-66
8011a844:	e0bfef84 	addi	r2,fp,-66
8011a848:	200f883a 	mov	r7,r4
8011a84c:	180d883a 	mov	r6,r3
8011a850:	01600534 	movhi	r5,32788
8011a854:	295d8b04 	addi	r5,r5,30252
8011a858:	1009883a 	mov	r4,r2
8011a85c:	01218940 	call	80121894 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8011a860:	e0bfed03 	ldbu	r2,-76(fp)
8011a864:	10800044 	addi	r2,r2,1
8011a868:	e0bfed05 	stb	r2,-76(fp)
8011a86c:	e0800683 	ldbu	r2,26(fp)
8011a870:	10803fcc 	andi	r2,r2,255
8011a874:	e0ffed03 	ldbu	r3,-76(fp)
8011a878:	18bfea36 	bltu	r3,r2,8011a824 <__reset+0xfa0fa824>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8011a87c:	e0bfef84 	addi	r2,fp,-66
8011a880:	1009883a 	mov	r4,r2
8011a884:	01219540 	call	80121954 <strlen>
8011a888:	1007883a 	mov	r3,r2
8011a88c:	e0bfef84 	addi	r2,fp,-66
8011a890:	180b883a 	mov	r5,r3
8011a894:	1009883a 	mov	r4,r2
8011a898:	011cd040 	call	8011cd04 <ucCrc8wInit>
8011a89c:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8011a8a0:	e13fed43 	ldbu	r4,-75(fp)
8011a8a4:	e0ffef84 	addi	r3,fp,-66
8011a8a8:	e0bfef84 	addi	r2,fp,-66
8011a8ac:	200f883a 	mov	r7,r4
8011a8b0:	180d883a 	mov	r6,r3
8011a8b4:	01600534 	movhi	r5,32788
8011a8b8:	295d7a04 	addi	r5,r5,30184
8011a8bc:	1009883a 	mov	r4,r2
8011a8c0:	01218940 	call	80121894 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8011a8c4:	e0bfef0b 	ldhu	r2,-68(fp)
8011a8c8:	10ffffcc 	andi	r3,r2,65535
8011a8cc:	18e0001c 	xori	r3,r3,32768
8011a8d0:	18e00004 	addi	r3,r3,-32768
8011a8d4:	e0bfef84 	addi	r2,fp,-66
8011a8d8:	180b883a 	mov	r5,r3
8011a8dc:	1009883a 	mov	r4,r2
8011a8e0:	0119b400 	call	80119b40 <bSendUART64v2>
8011a8e4:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
8011a8e8:	e0bfee17 	ldw	r2,-72(fp)
8011a8ec:	10800060 	cmpeqi	r2,r2,1
8011a8f0:	1000031e 	bne	r2,zero,8011a900 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8011a8f4:	e0bfef84 	addi	r2,fp,-66
8011a8f8:	1009883a 	mov	r4,r2
8011a8fc:	011d64c0 	call	8011d64c <vCouldNotSendTMPusCommand>
	}
}
8011a900:	0001883a 	nop
8011a904:	e037883a 	mov	sp,fp
8011a908:	dfc00117 	ldw	ra,4(sp)
8011a90c:	df000017 	ldw	fp,0(sp)
8011a910:	dec00604 	addi	sp,sp,24
8011a914:	f800283a 	ret

8011a918 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
8011a918:	deffd304 	addi	sp,sp,-180
8011a91c:	de00012e 	bgeu	sp,et,8011a924 <vSendPusTM128+0xc>
8011a920:	003b68fa 	trap	3
8011a924:	dfc02815 	stw	ra,160(sp)
8011a928:	df002715 	stw	fp,156(sp)
8011a92c:	df002704 	addi	fp,sp,156
8011a930:	e1000215 	stw	r4,8(fp)
8011a934:	e1400315 	stw	r5,12(fp)
8011a938:	e1800415 	stw	r6,16(fp)
8011a93c:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
8011a940:	e03fdf8d 	sth	zero,-130(fp)
8011a944:	e03fe00d 	sth	zero,-128(fp)
8011a948:	e0bfe084 	addi	r2,fp,-126
8011a94c:	00c01f04 	movi	r3,124
8011a950:	180d883a 	mov	r6,r3
8011a954:	000b883a 	mov	r5,zero
8011a958:	1009883a 	mov	r4,r2
8011a95c:	01215b40 	call	801215b4 <memset>
    unsigned char crc = 0;
8011a960:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
8011a964:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
8011a968:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8011a96c:	011a6800 	call	8011a680 <usiGetIdCMD>
8011a970:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8011a974:	e1bfdf0b 	ldhu	r6,-132(fp)
8011a978:	e080040b 	ldhu	r2,16(fp)
8011a97c:	11ffffcc 	andi	r7,r2,65535
8011a980:	e080048b 	ldhu	r2,18(fp)
8011a984:	10bfffcc 	andi	r2,r2,65535
8011a988:	e0c0050b 	ldhu	r3,20(fp)
8011a98c:	18ffffcc 	andi	r3,r3,65535
8011a990:	e100058b 	ldhu	r4,22(fp)
8011a994:	213fffcc 	andi	r4,r4,65535
8011a998:	e140060b 	ldhu	r5,24(fp)
8011a99c:	297fffcc 	andi	r5,r5,65535
8011a9a0:	e23fdf84 	addi	r8,fp,-130
8011a9a4:	d9400315 	stw	r5,12(sp)
8011a9a8:	d9000215 	stw	r4,8(sp)
8011a9ac:	d8c00115 	stw	r3,4(sp)
8011a9b0:	d8800015 	stw	r2,0(sp)
8011a9b4:	01600534 	movhi	r5,32788
8011a9b8:	295d8404 	addi	r5,r5,30224
8011a9bc:	4009883a 	mov	r4,r8
8011a9c0:	01218940 	call	80121894 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8011a9c4:	e03fdd05 	stb	zero,-140(fp)
8011a9c8:	00001206 	br	8011aa14 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8011a9cc:	e0bfdd03 	ldbu	r2,-140(fp)
8011a9d0:	10800284 	addi	r2,r2,10
8011a9d4:	1085883a 	add	r2,r2,r2
8011a9d8:	e0c00204 	addi	r3,fp,8
8011a9dc:	1885883a 	add	r2,r3,r2
8011a9e0:	1080000b 	ldhu	r2,0(r2)
8011a9e4:	113fffcc 	andi	r4,r2,65535
8011a9e8:	e0ffdf84 	addi	r3,fp,-130
8011a9ec:	e0bfdf84 	addi	r2,fp,-130
8011a9f0:	200f883a 	mov	r7,r4
8011a9f4:	180d883a 	mov	r6,r3
8011a9f8:	01600534 	movhi	r5,32788
8011a9fc:	295d8b04 	addi	r5,r5,30252
8011aa00:	1009883a 	mov	r4,r2
8011aa04:	01218940 	call	80121894 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
8011aa08:	e0bfdd03 	ldbu	r2,-140(fp)
8011aa0c:	10800044 	addi	r2,r2,1
8011aa10:	e0bfdd05 	stb	r2,-140(fp)
8011aa14:	e0800683 	ldbu	r2,26(fp)
8011aa18:	10803fcc 	andi	r2,r2,255
8011aa1c:	e0ffdd03 	ldbu	r3,-140(fp)
8011aa20:	18bfea36 	bltu	r3,r2,8011a9cc <__reset+0xfa0fa9cc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8011aa24:	e0bfdf84 	addi	r2,fp,-130
8011aa28:	1009883a 	mov	r4,r2
8011aa2c:	01219540 	call	80121954 <strlen>
8011aa30:	1007883a 	mov	r3,r2
8011aa34:	e0bfdf84 	addi	r2,fp,-130
8011aa38:	180b883a 	mov	r5,r3
8011aa3c:	1009883a 	mov	r4,r2
8011aa40:	011cd040 	call	8011cd04 <ucCrc8wInit>
8011aa44:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
8011aa48:	e13fdd43 	ldbu	r4,-139(fp)
8011aa4c:	e0ffdf84 	addi	r3,fp,-130
8011aa50:	e0bfdf84 	addi	r2,fp,-130
8011aa54:	200f883a 	mov	r7,r4
8011aa58:	180d883a 	mov	r6,r3
8011aa5c:	01600534 	movhi	r5,32788
8011aa60:	295d7a04 	addi	r5,r5,30184
8011aa64:	1009883a 	mov	r4,r2
8011aa68:	01218940 	call	80121894 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
8011aa6c:	e0bfdf0b 	ldhu	r2,-132(fp)
8011aa70:	10ffffcc 	andi	r3,r2,65535
8011aa74:	18e0001c 	xori	r3,r3,32768
8011aa78:	18e00004 	addi	r3,r3,-32768
8011aa7c:	e0bfdf84 	addi	r2,fp,-130
8011aa80:	180b883a 	mov	r5,r3
8011aa84:	1009883a 	mov	r4,r2
8011aa88:	01198880 	call	80119888 <bSendUART128v2>
8011aa8c:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
8011aa90:	e0bfde17 	ldw	r2,-136(fp)
8011aa94:	10800060 	cmpeqi	r2,r2,1
8011aa98:	1000031e 	bne	r2,zero,8011aaa8 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
8011aa9c:	e0bfdf84 	addi	r2,fp,-130
8011aaa0:	1009883a 	mov	r4,r2
8011aaa4:	011d64c0 	call	8011d64c <vCouldNotSendTMPusCommand>
	}
}
8011aaa8:	0001883a 	nop
8011aaac:	e037883a 	mov	sp,fp
8011aab0:	dfc00117 	ldw	ra,4(sp)
8011aab4:	df000017 	ldw	fp,0(sp)
8011aab8:	dec00604 	addi	sp,sp,24
8011aabc:	f800283a 	ret

8011aac0 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
8011aac0:	deffd704 	addi	sp,sp,-164
8011aac4:	de00012e 	bgeu	sp,et,8011aacc <vTMPusTestConnection+0xc>
8011aac8:	003b68fa 	trap	3
8011aacc:	dfc02815 	stw	ra,160(sp)
8011aad0:	df002715 	stw	fp,156(sp)
8011aad4:	df002704 	addi	fp,sp,156
8011aad8:	2005883a 	mov	r2,r4
8011aadc:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
8011aae0:	e0bfff0b 	ldhu	r2,-4(fp)
8011aae4:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
8011aae8:	00801c04 	movi	r2,112
8011aaec:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
8011aaf0:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
8011aaf4:	00800444 	movi	r2,17
8011aaf8:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
8011aafc:	00800084 	movi	r2,2
8011ab00:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
8011ab04:	d809883a 	mov	r4,sp
8011ab08:	e0bfee04 	addi	r2,fp,-72
8011ab0c:	00c01104 	movi	r3,68
8011ab10:	180d883a 	mov	r6,r3
8011ab14:	100b883a 	mov	r5,r2
8011ab18:	01214640 	call	80121464 <memcpy>
8011ab1c:	e13fea17 	ldw	r4,-88(fp)
8011ab20:	e17feb17 	ldw	r5,-84(fp)
8011ab24:	e1bfec17 	ldw	r6,-80(fp)
8011ab28:	e1ffed17 	ldw	r7,-76(fp)
8011ab2c:	011a7700 	call	8011a770 <vSendPusTM64>
}
8011ab30:	0001883a 	nop
8011ab34:	e037883a 	mov	sp,fp
8011ab38:	dfc00117 	ldw	ra,4(sp)
8011ab3c:	df000017 	ldw	fp,0(sp)
8011ab40:	dec00204 	addi	sp,sp,8
8011ab44:	f800283a 	ret

8011ab48 <vCHConfs>:
TDefaultsCH xDefaultsCH;

bool ucCheckAndApllySPWChannel( char cLetter, unsigned char *ucChannelNumber );

/* Load the bind configuration of the SPW channels and FEE instance*/
bool vCHConfs( void ){
8011ab48:	defff904 	addi	sp,sp,-28
8011ab4c:	de00012e 	bgeu	sp,et,8011ab54 <vCHConfs+0xc>
8011ab50:	003b68fa 	trap	3
8011ab54:	dfc00615 	stw	ra,24(sp)
8011ab58:	df000515 	stw	fp,20(sp)
8011ab5c:	df000504 	addi	fp,sp,20
	short int siFile;
	bool bSuccess = FALSE;
8011ab60:	e03ffb15 	stw	zero,-20(fp)
	bool bEOF = FALSE;
8011ab64:	e03ffc15 	stw	zero,-16(fp)
	bool close = FALSE;
8011ab68:	e03ffe15 	stw	zero,-8(fp)
	char c, cChannel;


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8011ab6c:	d0a07f17 	ldw	r2,-32260(gp)
8011ab70:	10800058 	cmpnei	r2,r2,1
8011ab74:	1002071e 	bne	r2,zero,8011b394 <vCHConfs+0x84c>
8011ab78:	011edfc0 	call	8011edfc <bSDcardIsPresent>
8011ab7c:	10020526 	beq	r2,zero,8011b394 <vCHConfs+0x84c>
8011ab80:	011ee2c0 	call	8011ee2c <bSDcardFAT16Check>
8011ab84:	10020326 	beq	r2,zero,8011b394 <vCHConfs+0x84c>

		siFile = siOpenFile( SPW_FILE_NAME );
8011ab88:	01200534 	movhi	r4,32788
8011ab8c:	211d8d04 	addi	r4,r4,30260
8011ab90:	011eedc0 	call	8011eedc <siOpenFile>
8011ab94:	e0bfff0d 	sth	r2,-4(fp)

		if ( siFile >= 0 ){
8011ab98:	e0bfff0f 	ldh	r2,-4(fp)
8011ab9c:	1001fd16 	blt	r2,zero,8011b394 <vCHConfs+0x84c>

			cChannel = -1;
8011aba0:	00bfffc4 	movi	r2,-1
8011aba4:	e0bffd45 	stb	r2,-11(fp)

			do {
				c = cGetNextChar(siFile);
8011aba8:	e0bfff0f 	ldh	r2,-4(fp)
8011abac:	1009883a 	mov	r4,r2
8011abb0:	011ef580 	call	8011ef58 <cGetNextChar>
8011abb4:	e0bffd05 	stb	r2,-12(fp)
				//printf("%c \n", c);
				switch (c) {
8011abb8:	e0bffd07 	ldb	r2,-12(fp)
8011abbc:	10800084 	addi	r2,r2,2
8011abc0:	10c00fe8 	cmpgeui	r3,r2,63
8011abc4:	1801f01e 	bne	r3,zero,8011b388 <vCHConfs+0x840>
8011abc8:	100690ba 	slli	r3,r2,2
8011abcc:	00a004b4 	movhi	r2,32786
8011abd0:	10aaf804 	addi	r2,r2,-21536
8011abd4:	1885883a 	add	r2,r3,r2
8011abd8:	10800017 	ldw	r2,0(r2)
8011abdc:	1000683a 	jmp	r2
8011abe0:	8011ad1c 	xori	zero,r16,18100
8011abe4:	8011ad10 	cmplti	zero,r16,18100
8011abe8:	8011b388 	cmpgei	zero,r16,18126
8011abec:	8011b388 	cmpgei	zero,r16,18126
8011abf0:	8011b388 	cmpgei	zero,r16,18126
8011abf4:	8011b388 	cmpgei	zero,r16,18126
8011abf8:	8011b388 	cmpgei	zero,r16,18126
8011abfc:	8011b388 	cmpgei	zero,r16,18126
8011ac00:	8011b388 	cmpgei	zero,r16,18126
8011ac04:	8011b388 	cmpgei	zero,r16,18126
8011ac08:	8011b388 	cmpgei	zero,r16,18126
8011ac0c:	8011b388 	cmpgei	zero,r16,18126
8011ac10:	8011b388 	cmpgei	zero,r16,18126
8011ac14:	8011b388 	cmpgei	zero,r16,18126
8011ac18:	8011b388 	cmpgei	zero,r16,18126
8011ac1c:	8011b388 	cmpgei	zero,r16,18126
8011ac20:	8011b388 	cmpgei	zero,r16,18126
8011ac24:	8011b388 	cmpgei	zero,r16,18126
8011ac28:	8011b388 	cmpgei	zero,r16,18126
8011ac2c:	8011b388 	cmpgei	zero,r16,18126
8011ac30:	8011b388 	cmpgei	zero,r16,18126
8011ac34:	8011b388 	cmpgei	zero,r16,18126
8011ac38:	8011b388 	cmpgei	zero,r16,18126
8011ac3c:	8011b388 	cmpgei	zero,r16,18126
8011ac40:	8011b388 	cmpgei	zero,r16,18126
8011ac44:	8011b388 	cmpgei	zero,r16,18126
8011ac48:	8011b388 	cmpgei	zero,r16,18126
8011ac4c:	8011b388 	cmpgei	zero,r16,18126
8011ac50:	8011b388 	cmpgei	zero,r16,18126
8011ac54:	8011b388 	cmpgei	zero,r16,18126
8011ac58:	8011b388 	cmpgei	zero,r16,18126
8011ac5c:	8011b388 	cmpgei	zero,r16,18126
8011ac60:	8011b388 	cmpgei	zero,r16,18126
8011ac64:	8011b388 	cmpgei	zero,r16,18126
8011ac68:	8011b388 	cmpgei	zero,r16,18126
8011ac6c:	8011b388 	cmpgei	zero,r16,18126
8011ac70:	8011b388 	cmpgei	zero,r16,18126
8011ac74:	8011b388 	cmpgei	zero,r16,18126
8011ac78:	8011b388 	cmpgei	zero,r16,18126
8011ac7c:	8011b388 	cmpgei	zero,r16,18126
8011ac80:	8011b388 	cmpgei	zero,r16,18126
8011ac84:	8011acdc 	xori	zero,r16,18099
8011ac88:	8011b388 	cmpgei	zero,r16,18126
8011ac8c:	8011b388 	cmpgei	zero,r16,18126
8011ac90:	8011b388 	cmpgei	zero,r16,18126
8011ac94:	8011b388 	cmpgei	zero,r16,18126
8011ac98:	8011b388 	cmpgei	zero,r16,18126
8011ac9c:	8011b388 	cmpgei	zero,r16,18126
8011aca0:	8011b388 	cmpgei	zero,r16,18126
8011aca4:	8011b388 	cmpgei	zero,r16,18126
8011aca8:	8011ad28 	cmpgeui	zero,r16,18100
8011acac:	8011adec 	andhi	zero,r16,18103
8011acb0:	8011aeb4 	orhi	zero,r16,18106
8011acb4:	8011af7c 	xorhi	zero,r16,18109
8011acb8:	8011b044 	addi	zero,r16,18113
8011acbc:	8011b10c 	andi	zero,r16,18116
8011acc0:	8011b1d4 	ori	zero,r16,18119
8011acc4:	8011b29c 	xori	zero,r16,18122
8011acc8:	8011b388 	cmpgei	zero,r16,18126
8011accc:	8011b388 	cmpgei	zero,r16,18126
8011acd0:	8011b388 	cmpgei	zero,r16,18126
8011acd4:	8011b388 	cmpgei	zero,r16,18126
8011acd8:	8011b364 	muli	zero,r16,18125
					case 39:// single quote '
						c = cGetNextChar(siFile);
8011acdc:	e0bfff0f 	ldh	r2,-4(fp)
8011ace0:	1009883a 	mov	r4,r2
8011ace4:	011ef580 	call	8011ef58 <cGetNextChar>
8011ace8:	e0bffd05 	stb	r2,-12(fp)
						while ( c != 39 ){
8011acec:	00000406 	br	8011ad00 <vCHConfs+0x1b8>
							c = cGetNextChar(siFile);
8011acf0:	e0bfff0f 	ldh	r2,-4(fp)
8011acf4:	1009883a 	mov	r4,r2
8011acf8:	011ef580 	call	8011ef58 <cGetNextChar>
8011acfc:	e0bffd05 	stb	r2,-12(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8011ad00:	e0bffd07 	ldb	r2,-12(fp)
8011ad04:	108009d8 	cmpnei	r2,r2,39
8011ad08:	103ff91e 	bne	r2,zero,8011acf0 <__reset+0xfa0facf0>
							c = cGetNextChar(siFile);
						}
						break;
8011ad0c:	00019f06 	br	8011b38c <vCHConfs+0x844>
					case -1: 	//EOF
						bEOF = TRUE;
8011ad10:	00800044 	movi	r2,1
8011ad14:	e0bffc15 	stw	r2,-16(fp)
						break;
8011ad18:	00019c06 	br	8011b38c <vCHConfs+0x844>
					case -2: 	//EOF
						#if DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
						#endif
						bEOF = TRUE;
8011ad1c:	00800044 	movi	r2,1
8011ad20:	e0bffc15 	stw	r2,-16(fp)
						break;
8011ad24:	00019906 	br	8011b38c <vCHConfs+0x844>
						break;

					case '0':
						do {
							do {
								c = cGetNextChar(siFile);
8011ad28:	e0bfff0f 	ldh	r2,-4(fp)
8011ad2c:	1009883a 	mov	r4,r2
8011ad30:	011ef580 	call	8011ef58 <cGetNextChar>
8011ad34:	e0bffd05 	stb	r2,-12(fp)
								if ( (isalpha(c)) && (c !=46) && (c !=59) ) {
8011ad38:	d0e00317 	ldw	r3,-32756(gp)
8011ad3c:	e0bffd07 	ldb	r2,-12(fp)
8011ad40:	10800044 	addi	r2,r2,1
8011ad44:	1885883a 	add	r2,r3,r2
8011ad48:	10800003 	ldbu	r2,0(r2)
8011ad4c:	10803fcc 	andi	r2,r2,255
8011ad50:	108000cc 	andi	r2,r2,3
8011ad54:	10000826 	beq	r2,zero,8011ad78 <vCHConfs+0x230>
8011ad58:	e0bffd07 	ldb	r2,-12(fp)
8011ad5c:	10800ba0 	cmpeqi	r2,r2,46
8011ad60:	1000051e 	bne	r2,zero,8011ad78 <vCHConfs+0x230>
8011ad64:	e0bffd07 	ldb	r2,-12(fp)
8011ad68:	10800ee0 	cmpeqi	r2,r2,59
8011ad6c:	1000021e 	bne	r2,zero,8011ad78 <vCHConfs+0x230>
									cChannel = c;
8011ad70:	e0bffd03 	ldbu	r2,-12(fp)
8011ad74:	e0bffd45 	stb	r2,-11(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011ad78:	e0bffd07 	ldb	r2,-12(fp)
8011ad7c:	10800ba0 	cmpeqi	r2,r2,46
8011ad80:	1000031e 	bne	r2,zero,8011ad90 <vCHConfs+0x248>
8011ad84:	e0bffd07 	ldb	r2,-12(fp)
8011ad88:	10800ed8 	cmpnei	r2,r2,59
8011ad8c:	103fe61e 	bne	r2,zero,8011ad28 <__reset+0xfa0fad28>

							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[0] );
8011ad90:	e0bffd47 	ldb	r2,-11(fp)
8011ad94:	016005b4 	movhi	r5,32790
8011ad98:	297a3404 	addi	r5,r5,-5936
8011ad9c:	1009883a 	mov	r4,r2
8011ada0:	011b3ac0 	call	8011b3ac <ucCheckAndApllySPWChannel>
8011ada4:	e0bffb15 	stw	r2,-20(fp)

							if (bSuccess == TRUE) {
8011ada8:	e0bffb17 	ldw	r2,-20(fp)
8011adac:	10800058 	cmpnei	r2,r2,1
8011adb0:	10000c1e 	bne	r2,zero,8011ade4 <vCHConfs+0x29c>
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[0] ] = 0;
8011adb4:	00a005b4 	movhi	r2,32790
8011adb8:	10ba3204 	addi	r2,r2,-5944
8011adbc:	10800203 	ldbu	r2,8(r2)
8011adc0:	10c03fcc 	andi	r3,r2,255
8011adc4:	00a005b4 	movhi	r2,32790
8011adc8:	10ba3204 	addi	r2,r2,-5944
8011adcc:	10c5883a 	add	r2,r2,r3
8011add0:	10000005 	stb	zero,0(r2)
							} else {
								return FALSE;
							}
						} while ( (c !=59) );
8011add4:	e0bffd07 	ldb	r2,-12(fp)
8011add8:	10800ed8 	cmpnei	r2,r2,59
8011addc:	103fd21e 	bne	r2,zero,8011ad28 <__reset+0xfa0fad28>

						break;
8011ade0:	00016a06 	br	8011b38c <vCHConfs+0x844>
							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[0] );

							if (bSuccess == TRUE) {
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[0] ] = 0;
							} else {
								return FALSE;
8011ade4:	0005883a 	mov	r2,zero
8011ade8:	00016b06 	br	8011b398 <vCHConfs+0x850>
						break;

					case '1':
						do {
							do {
								c = cGetNextChar(siFile);
8011adec:	e0bfff0f 	ldh	r2,-4(fp)
8011adf0:	1009883a 	mov	r4,r2
8011adf4:	011ef580 	call	8011ef58 <cGetNextChar>
8011adf8:	e0bffd05 	stb	r2,-12(fp)
								if ( (isalpha(c)) && (c !=46) && (c !=59) ) {
8011adfc:	d0e00317 	ldw	r3,-32756(gp)
8011ae00:	e0bffd07 	ldb	r2,-12(fp)
8011ae04:	10800044 	addi	r2,r2,1
8011ae08:	1885883a 	add	r2,r3,r2
8011ae0c:	10800003 	ldbu	r2,0(r2)
8011ae10:	10803fcc 	andi	r2,r2,255
8011ae14:	108000cc 	andi	r2,r2,3
8011ae18:	10000826 	beq	r2,zero,8011ae3c <vCHConfs+0x2f4>
8011ae1c:	e0bffd07 	ldb	r2,-12(fp)
8011ae20:	10800ba0 	cmpeqi	r2,r2,46
8011ae24:	1000051e 	bne	r2,zero,8011ae3c <vCHConfs+0x2f4>
8011ae28:	e0bffd07 	ldb	r2,-12(fp)
8011ae2c:	10800ee0 	cmpeqi	r2,r2,59
8011ae30:	1000021e 	bne	r2,zero,8011ae3c <vCHConfs+0x2f4>
									cChannel = c;
8011ae34:	e0bffd03 	ldbu	r2,-12(fp)
8011ae38:	e0bffd45 	stb	r2,-11(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011ae3c:	e0bffd07 	ldb	r2,-12(fp)
8011ae40:	10800ba0 	cmpeqi	r2,r2,46
8011ae44:	1000031e 	bne	r2,zero,8011ae54 <vCHConfs+0x30c>
8011ae48:	e0bffd07 	ldb	r2,-12(fp)
8011ae4c:	10800ed8 	cmpnei	r2,r2,59
8011ae50:	103fe61e 	bne	r2,zero,8011adec <__reset+0xfa0fadec>

							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[1] );
8011ae54:	e0bffd47 	ldb	r2,-11(fp)
8011ae58:	016005b4 	movhi	r5,32790
8011ae5c:	297a3444 	addi	r5,r5,-5935
8011ae60:	1009883a 	mov	r4,r2
8011ae64:	011b3ac0 	call	8011b3ac <ucCheckAndApllySPWChannel>
8011ae68:	e0bffb15 	stw	r2,-20(fp)

							if (bSuccess == TRUE) {
8011ae6c:	e0bffb17 	ldw	r2,-20(fp)
8011ae70:	10800058 	cmpnei	r2,r2,1
8011ae74:	10000d1e 	bne	r2,zero,8011aeac <vCHConfs+0x364>
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[1] ] = 1;
8011ae78:	00a005b4 	movhi	r2,32790
8011ae7c:	10ba3204 	addi	r2,r2,-5944
8011ae80:	10800243 	ldbu	r2,9(r2)
8011ae84:	10c03fcc 	andi	r3,r2,255
8011ae88:	00a005b4 	movhi	r2,32790
8011ae8c:	10ba3204 	addi	r2,r2,-5944
8011ae90:	10c5883a 	add	r2,r2,r3
8011ae94:	00c00044 	movi	r3,1
8011ae98:	10c00005 	stb	r3,0(r2)
							} else {
								return FALSE;
							}
						} while ( (c !=59) );
8011ae9c:	e0bffd07 	ldb	r2,-12(fp)
8011aea0:	10800ed8 	cmpnei	r2,r2,59
8011aea4:	103fd11e 	bne	r2,zero,8011adec <__reset+0xfa0fadec>

						break;
8011aea8:	00013806 	br	8011b38c <vCHConfs+0x844>
							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[1] );

							if (bSuccess == TRUE) {
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[1] ] = 1;
							} else {
								return FALSE;
8011aeac:	0005883a 	mov	r2,zero
8011aeb0:	00013906 	br	8011b398 <vCHConfs+0x850>
						break;

					case '2':
						do {
							do {
								c = cGetNextChar(siFile);
8011aeb4:	e0bfff0f 	ldh	r2,-4(fp)
8011aeb8:	1009883a 	mov	r4,r2
8011aebc:	011ef580 	call	8011ef58 <cGetNextChar>
8011aec0:	e0bffd05 	stb	r2,-12(fp)
								if ( (isalpha(c)) && (c !=46) && (c !=59) ) {
8011aec4:	d0e00317 	ldw	r3,-32756(gp)
8011aec8:	e0bffd07 	ldb	r2,-12(fp)
8011aecc:	10800044 	addi	r2,r2,1
8011aed0:	1885883a 	add	r2,r3,r2
8011aed4:	10800003 	ldbu	r2,0(r2)
8011aed8:	10803fcc 	andi	r2,r2,255
8011aedc:	108000cc 	andi	r2,r2,3
8011aee0:	10000826 	beq	r2,zero,8011af04 <vCHConfs+0x3bc>
8011aee4:	e0bffd07 	ldb	r2,-12(fp)
8011aee8:	10800ba0 	cmpeqi	r2,r2,46
8011aeec:	1000051e 	bne	r2,zero,8011af04 <vCHConfs+0x3bc>
8011aef0:	e0bffd07 	ldb	r2,-12(fp)
8011aef4:	10800ee0 	cmpeqi	r2,r2,59
8011aef8:	1000021e 	bne	r2,zero,8011af04 <vCHConfs+0x3bc>
									cChannel = c;
8011aefc:	e0bffd03 	ldbu	r2,-12(fp)
8011af00:	e0bffd45 	stb	r2,-11(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011af04:	e0bffd07 	ldb	r2,-12(fp)
8011af08:	10800ba0 	cmpeqi	r2,r2,46
8011af0c:	1000031e 	bne	r2,zero,8011af1c <vCHConfs+0x3d4>
8011af10:	e0bffd07 	ldb	r2,-12(fp)
8011af14:	10800ed8 	cmpnei	r2,r2,59
8011af18:	103fe61e 	bne	r2,zero,8011aeb4 <__reset+0xfa0faeb4>

							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[2] );
8011af1c:	e0bffd47 	ldb	r2,-11(fp)
8011af20:	016005b4 	movhi	r5,32790
8011af24:	297a3484 	addi	r5,r5,-5934
8011af28:	1009883a 	mov	r4,r2
8011af2c:	011b3ac0 	call	8011b3ac <ucCheckAndApllySPWChannel>
8011af30:	e0bffb15 	stw	r2,-20(fp)

							if (bSuccess == TRUE) {
8011af34:	e0bffb17 	ldw	r2,-20(fp)
8011af38:	10800058 	cmpnei	r2,r2,1
8011af3c:	10000d1e 	bne	r2,zero,8011af74 <vCHConfs+0x42c>
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[2] ] = 2;
8011af40:	00a005b4 	movhi	r2,32790
8011af44:	10ba3204 	addi	r2,r2,-5944
8011af48:	10800283 	ldbu	r2,10(r2)
8011af4c:	10c03fcc 	andi	r3,r2,255
8011af50:	00a005b4 	movhi	r2,32790
8011af54:	10ba3204 	addi	r2,r2,-5944
8011af58:	10c5883a 	add	r2,r2,r3
8011af5c:	00c00084 	movi	r3,2
8011af60:	10c00005 	stb	r3,0(r2)
							} else {
								return FALSE;
							}
						} while ( (c !=59) );
8011af64:	e0bffd07 	ldb	r2,-12(fp)
8011af68:	10800ed8 	cmpnei	r2,r2,59
8011af6c:	103fd11e 	bne	r2,zero,8011aeb4 <__reset+0xfa0faeb4>

						break;
8011af70:	00010606 	br	8011b38c <vCHConfs+0x844>
							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[2] );

							if (bSuccess == TRUE) {
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[2] ] = 2;
							} else {
								return FALSE;
8011af74:	0005883a 	mov	r2,zero
8011af78:	00010706 	br	8011b398 <vCHConfs+0x850>
						break;

					case '3':
						do {
							do {
								c = cGetNextChar(siFile);
8011af7c:	e0bfff0f 	ldh	r2,-4(fp)
8011af80:	1009883a 	mov	r4,r2
8011af84:	011ef580 	call	8011ef58 <cGetNextChar>
8011af88:	e0bffd05 	stb	r2,-12(fp)
								if ( (isalpha(c)) && (c !=46) && (c !=59) ) {
8011af8c:	d0e00317 	ldw	r3,-32756(gp)
8011af90:	e0bffd07 	ldb	r2,-12(fp)
8011af94:	10800044 	addi	r2,r2,1
8011af98:	1885883a 	add	r2,r3,r2
8011af9c:	10800003 	ldbu	r2,0(r2)
8011afa0:	10803fcc 	andi	r2,r2,255
8011afa4:	108000cc 	andi	r2,r2,3
8011afa8:	10000826 	beq	r2,zero,8011afcc <vCHConfs+0x484>
8011afac:	e0bffd07 	ldb	r2,-12(fp)
8011afb0:	10800ba0 	cmpeqi	r2,r2,46
8011afb4:	1000051e 	bne	r2,zero,8011afcc <vCHConfs+0x484>
8011afb8:	e0bffd07 	ldb	r2,-12(fp)
8011afbc:	10800ee0 	cmpeqi	r2,r2,59
8011afc0:	1000021e 	bne	r2,zero,8011afcc <vCHConfs+0x484>
									cChannel = c;
8011afc4:	e0bffd03 	ldbu	r2,-12(fp)
8011afc8:	e0bffd45 	stb	r2,-11(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011afcc:	e0bffd07 	ldb	r2,-12(fp)
8011afd0:	10800ba0 	cmpeqi	r2,r2,46
8011afd4:	1000031e 	bne	r2,zero,8011afe4 <vCHConfs+0x49c>
8011afd8:	e0bffd07 	ldb	r2,-12(fp)
8011afdc:	10800ed8 	cmpnei	r2,r2,59
8011afe0:	103fe61e 	bne	r2,zero,8011af7c <__reset+0xfa0faf7c>

							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[3] );
8011afe4:	e0bffd47 	ldb	r2,-11(fp)
8011afe8:	016005b4 	movhi	r5,32790
8011afec:	297a34c4 	addi	r5,r5,-5933
8011aff0:	1009883a 	mov	r4,r2
8011aff4:	011b3ac0 	call	8011b3ac <ucCheckAndApllySPWChannel>
8011aff8:	e0bffb15 	stw	r2,-20(fp)

							if (bSuccess == TRUE) {
8011affc:	e0bffb17 	ldw	r2,-20(fp)
8011b000:	10800058 	cmpnei	r2,r2,1
8011b004:	10000d1e 	bne	r2,zero,8011b03c <vCHConfs+0x4f4>
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[3] ] = 3;
8011b008:	00a005b4 	movhi	r2,32790
8011b00c:	10ba3204 	addi	r2,r2,-5944
8011b010:	108002c3 	ldbu	r2,11(r2)
8011b014:	10c03fcc 	andi	r3,r2,255
8011b018:	00a005b4 	movhi	r2,32790
8011b01c:	10ba3204 	addi	r2,r2,-5944
8011b020:	10c5883a 	add	r2,r2,r3
8011b024:	00c000c4 	movi	r3,3
8011b028:	10c00005 	stb	r3,0(r2)
							} else {
								return FALSE;
							}
						} while ( (c !=59) );
8011b02c:	e0bffd07 	ldb	r2,-12(fp)
8011b030:	10800ed8 	cmpnei	r2,r2,59
8011b034:	103fd11e 	bne	r2,zero,8011af7c <__reset+0xfa0faf7c>

						break;
8011b038:	0000d406 	br	8011b38c <vCHConfs+0x844>
							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[3] );

							if (bSuccess == TRUE) {
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[3] ] = 3;
							} else {
								return FALSE;
8011b03c:	0005883a 	mov	r2,zero
8011b040:	0000d506 	br	8011b398 <vCHConfs+0x850>
						break;

					case '4':
						do {
							do {
								c = cGetNextChar(siFile);
8011b044:	e0bfff0f 	ldh	r2,-4(fp)
8011b048:	1009883a 	mov	r4,r2
8011b04c:	011ef580 	call	8011ef58 <cGetNextChar>
8011b050:	e0bffd05 	stb	r2,-12(fp)
								if ( (isalpha(c)) && (c !=46) && (c !=59) ) {
8011b054:	d0e00317 	ldw	r3,-32756(gp)
8011b058:	e0bffd07 	ldb	r2,-12(fp)
8011b05c:	10800044 	addi	r2,r2,1
8011b060:	1885883a 	add	r2,r3,r2
8011b064:	10800003 	ldbu	r2,0(r2)
8011b068:	10803fcc 	andi	r2,r2,255
8011b06c:	108000cc 	andi	r2,r2,3
8011b070:	10000826 	beq	r2,zero,8011b094 <vCHConfs+0x54c>
8011b074:	e0bffd07 	ldb	r2,-12(fp)
8011b078:	10800ba0 	cmpeqi	r2,r2,46
8011b07c:	1000051e 	bne	r2,zero,8011b094 <vCHConfs+0x54c>
8011b080:	e0bffd07 	ldb	r2,-12(fp)
8011b084:	10800ee0 	cmpeqi	r2,r2,59
8011b088:	1000021e 	bne	r2,zero,8011b094 <vCHConfs+0x54c>
									cChannel = c;
8011b08c:	e0bffd03 	ldbu	r2,-12(fp)
8011b090:	e0bffd45 	stb	r2,-11(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011b094:	e0bffd07 	ldb	r2,-12(fp)
8011b098:	10800ba0 	cmpeqi	r2,r2,46
8011b09c:	1000031e 	bne	r2,zero,8011b0ac <vCHConfs+0x564>
8011b0a0:	e0bffd07 	ldb	r2,-12(fp)
8011b0a4:	10800ed8 	cmpnei	r2,r2,59
8011b0a8:	103fe61e 	bne	r2,zero,8011b044 <__reset+0xfa0fb044>

							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[4] );
8011b0ac:	e0bffd47 	ldb	r2,-11(fp)
8011b0b0:	016005b4 	movhi	r5,32790
8011b0b4:	297a3504 	addi	r5,r5,-5932
8011b0b8:	1009883a 	mov	r4,r2
8011b0bc:	011b3ac0 	call	8011b3ac <ucCheckAndApllySPWChannel>
8011b0c0:	e0bffb15 	stw	r2,-20(fp)

							if (bSuccess == TRUE) {
8011b0c4:	e0bffb17 	ldw	r2,-20(fp)
8011b0c8:	10800058 	cmpnei	r2,r2,1
8011b0cc:	10000d1e 	bne	r2,zero,8011b104 <vCHConfs+0x5bc>
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[4] ] = 4;
8011b0d0:	00a005b4 	movhi	r2,32790
8011b0d4:	10ba3204 	addi	r2,r2,-5944
8011b0d8:	10800303 	ldbu	r2,12(r2)
8011b0dc:	10c03fcc 	andi	r3,r2,255
8011b0e0:	00a005b4 	movhi	r2,32790
8011b0e4:	10ba3204 	addi	r2,r2,-5944
8011b0e8:	10c5883a 	add	r2,r2,r3
8011b0ec:	00c00104 	movi	r3,4
8011b0f0:	10c00005 	stb	r3,0(r2)
							} else {
								return FALSE;
							}
						} while ( (c !=59) );
8011b0f4:	e0bffd07 	ldb	r2,-12(fp)
8011b0f8:	10800ed8 	cmpnei	r2,r2,59
8011b0fc:	103fd11e 	bne	r2,zero,8011b044 <__reset+0xfa0fb044>

						break;
8011b100:	0000a206 	br	8011b38c <vCHConfs+0x844>
							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[4] );

							if (bSuccess == TRUE) {
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[4] ] = 4;
							} else {
								return FALSE;
8011b104:	0005883a 	mov	r2,zero
8011b108:	0000a306 	br	8011b398 <vCHConfs+0x850>
						break;

					case '5':
						do {
							do {
								c = cGetNextChar(siFile);
8011b10c:	e0bfff0f 	ldh	r2,-4(fp)
8011b110:	1009883a 	mov	r4,r2
8011b114:	011ef580 	call	8011ef58 <cGetNextChar>
8011b118:	e0bffd05 	stb	r2,-12(fp)
								if ( (isalpha(c)) && (c !=46) && (c !=59) ) {
8011b11c:	d0e00317 	ldw	r3,-32756(gp)
8011b120:	e0bffd07 	ldb	r2,-12(fp)
8011b124:	10800044 	addi	r2,r2,1
8011b128:	1885883a 	add	r2,r3,r2
8011b12c:	10800003 	ldbu	r2,0(r2)
8011b130:	10803fcc 	andi	r2,r2,255
8011b134:	108000cc 	andi	r2,r2,3
8011b138:	10000826 	beq	r2,zero,8011b15c <vCHConfs+0x614>
8011b13c:	e0bffd07 	ldb	r2,-12(fp)
8011b140:	10800ba0 	cmpeqi	r2,r2,46
8011b144:	1000051e 	bne	r2,zero,8011b15c <vCHConfs+0x614>
8011b148:	e0bffd07 	ldb	r2,-12(fp)
8011b14c:	10800ee0 	cmpeqi	r2,r2,59
8011b150:	1000021e 	bne	r2,zero,8011b15c <vCHConfs+0x614>
									cChannel = c;
8011b154:	e0bffd03 	ldbu	r2,-12(fp)
8011b158:	e0bffd45 	stb	r2,-11(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011b15c:	e0bffd07 	ldb	r2,-12(fp)
8011b160:	10800ba0 	cmpeqi	r2,r2,46
8011b164:	1000031e 	bne	r2,zero,8011b174 <vCHConfs+0x62c>
8011b168:	e0bffd07 	ldb	r2,-12(fp)
8011b16c:	10800ed8 	cmpnei	r2,r2,59
8011b170:	103fe61e 	bne	r2,zero,8011b10c <__reset+0xfa0fb10c>

							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[5] );
8011b174:	e0bffd47 	ldb	r2,-11(fp)
8011b178:	016005b4 	movhi	r5,32790
8011b17c:	297a3544 	addi	r5,r5,-5931
8011b180:	1009883a 	mov	r4,r2
8011b184:	011b3ac0 	call	8011b3ac <ucCheckAndApllySPWChannel>
8011b188:	e0bffb15 	stw	r2,-20(fp)

							if (bSuccess == TRUE) {
8011b18c:	e0bffb17 	ldw	r2,-20(fp)
8011b190:	10800058 	cmpnei	r2,r2,1
8011b194:	10000d1e 	bne	r2,zero,8011b1cc <vCHConfs+0x684>
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[5] ] = 5;
8011b198:	00a005b4 	movhi	r2,32790
8011b19c:	10ba3204 	addi	r2,r2,-5944
8011b1a0:	10800343 	ldbu	r2,13(r2)
8011b1a4:	10c03fcc 	andi	r3,r2,255
8011b1a8:	00a005b4 	movhi	r2,32790
8011b1ac:	10ba3204 	addi	r2,r2,-5944
8011b1b0:	10c5883a 	add	r2,r2,r3
8011b1b4:	00c00144 	movi	r3,5
8011b1b8:	10c00005 	stb	r3,0(r2)
							} else {
								return FALSE;
							}
						} while ( (c !=59) );
8011b1bc:	e0bffd07 	ldb	r2,-12(fp)
8011b1c0:	10800ed8 	cmpnei	r2,r2,59
8011b1c4:	103fd11e 	bne	r2,zero,8011b10c <__reset+0xfa0fb10c>

						break;
8011b1c8:	00007006 	br	8011b38c <vCHConfs+0x844>
							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[5] );

							if (bSuccess == TRUE) {
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[5] ] = 5;
							} else {
								return FALSE;
8011b1cc:	0005883a 	mov	r2,zero
8011b1d0:	00007106 	br	8011b398 <vCHConfs+0x850>
						break;

					case '6':
						do {
							do {
								c = cGetNextChar(siFile);
8011b1d4:	e0bfff0f 	ldh	r2,-4(fp)
8011b1d8:	1009883a 	mov	r4,r2
8011b1dc:	011ef580 	call	8011ef58 <cGetNextChar>
8011b1e0:	e0bffd05 	stb	r2,-12(fp)
								if ( (isalpha(c)) && (c !=46) && (c !=59) ) {
8011b1e4:	d0e00317 	ldw	r3,-32756(gp)
8011b1e8:	e0bffd07 	ldb	r2,-12(fp)
8011b1ec:	10800044 	addi	r2,r2,1
8011b1f0:	1885883a 	add	r2,r3,r2
8011b1f4:	10800003 	ldbu	r2,0(r2)
8011b1f8:	10803fcc 	andi	r2,r2,255
8011b1fc:	108000cc 	andi	r2,r2,3
8011b200:	10000826 	beq	r2,zero,8011b224 <vCHConfs+0x6dc>
8011b204:	e0bffd07 	ldb	r2,-12(fp)
8011b208:	10800ba0 	cmpeqi	r2,r2,46
8011b20c:	1000051e 	bne	r2,zero,8011b224 <vCHConfs+0x6dc>
8011b210:	e0bffd07 	ldb	r2,-12(fp)
8011b214:	10800ee0 	cmpeqi	r2,r2,59
8011b218:	1000021e 	bne	r2,zero,8011b224 <vCHConfs+0x6dc>
									cChannel = c;
8011b21c:	e0bffd03 	ldbu	r2,-12(fp)
8011b220:	e0bffd45 	stb	r2,-11(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011b224:	e0bffd07 	ldb	r2,-12(fp)
8011b228:	10800ba0 	cmpeqi	r2,r2,46
8011b22c:	1000031e 	bne	r2,zero,8011b23c <vCHConfs+0x6f4>
8011b230:	e0bffd07 	ldb	r2,-12(fp)
8011b234:	10800ed8 	cmpnei	r2,r2,59
8011b238:	103fe61e 	bne	r2,zero,8011b1d4 <__reset+0xfa0fb1d4>

							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[6] );
8011b23c:	e0bffd47 	ldb	r2,-11(fp)
8011b240:	016005b4 	movhi	r5,32790
8011b244:	297a3584 	addi	r5,r5,-5930
8011b248:	1009883a 	mov	r4,r2
8011b24c:	011b3ac0 	call	8011b3ac <ucCheckAndApllySPWChannel>
8011b250:	e0bffb15 	stw	r2,-20(fp)

							if (bSuccess == TRUE) {
8011b254:	e0bffb17 	ldw	r2,-20(fp)
8011b258:	10800058 	cmpnei	r2,r2,1
8011b25c:	10000d1e 	bne	r2,zero,8011b294 <vCHConfs+0x74c>
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[6] ] = 6;
8011b260:	00a005b4 	movhi	r2,32790
8011b264:	10ba3204 	addi	r2,r2,-5944
8011b268:	10800383 	ldbu	r2,14(r2)
8011b26c:	10c03fcc 	andi	r3,r2,255
8011b270:	00a005b4 	movhi	r2,32790
8011b274:	10ba3204 	addi	r2,r2,-5944
8011b278:	10c5883a 	add	r2,r2,r3
8011b27c:	00c00184 	movi	r3,6
8011b280:	10c00005 	stb	r3,0(r2)
							} else {
								return FALSE;
							}
						} while ( (c !=59) );
8011b284:	e0bffd07 	ldb	r2,-12(fp)
8011b288:	10800ed8 	cmpnei	r2,r2,59
8011b28c:	103fd11e 	bne	r2,zero,8011b1d4 <__reset+0xfa0fb1d4>

						break;
8011b290:	00003e06 	br	8011b38c <vCHConfs+0x844>
							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[6] );

							if (bSuccess == TRUE) {
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[6] ] = 6;
							} else {
								return FALSE;
8011b294:	0005883a 	mov	r2,zero
8011b298:	00003f06 	br	8011b398 <vCHConfs+0x850>
						break;

					case '7':
						do {
							do {
								c = cGetNextChar(siFile);
8011b29c:	e0bfff0f 	ldh	r2,-4(fp)
8011b2a0:	1009883a 	mov	r4,r2
8011b2a4:	011ef580 	call	8011ef58 <cGetNextChar>
8011b2a8:	e0bffd05 	stb	r2,-12(fp)
								if ( (isalpha(c)) && (c !=46) && (c !=59) ) {
8011b2ac:	d0e00317 	ldw	r3,-32756(gp)
8011b2b0:	e0bffd07 	ldb	r2,-12(fp)
8011b2b4:	10800044 	addi	r2,r2,1
8011b2b8:	1885883a 	add	r2,r3,r2
8011b2bc:	10800003 	ldbu	r2,0(r2)
8011b2c0:	10803fcc 	andi	r2,r2,255
8011b2c4:	108000cc 	andi	r2,r2,3
8011b2c8:	10000826 	beq	r2,zero,8011b2ec <vCHConfs+0x7a4>
8011b2cc:	e0bffd07 	ldb	r2,-12(fp)
8011b2d0:	10800ba0 	cmpeqi	r2,r2,46
8011b2d4:	1000051e 	bne	r2,zero,8011b2ec <vCHConfs+0x7a4>
8011b2d8:	e0bffd07 	ldb	r2,-12(fp)
8011b2dc:	10800ee0 	cmpeqi	r2,r2,59
8011b2e0:	1000021e 	bne	r2,zero,8011b2ec <vCHConfs+0x7a4>
									cChannel = c;
8011b2e4:	e0bffd03 	ldbu	r2,-12(fp)
8011b2e8:	e0bffd45 	stb	r2,-11(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011b2ec:	e0bffd07 	ldb	r2,-12(fp)
8011b2f0:	10800ba0 	cmpeqi	r2,r2,46
8011b2f4:	1000031e 	bne	r2,zero,8011b304 <vCHConfs+0x7bc>
8011b2f8:	e0bffd07 	ldb	r2,-12(fp)
8011b2fc:	10800ed8 	cmpnei	r2,r2,59
8011b300:	103fe61e 	bne	r2,zero,8011b29c <__reset+0xfa0fb29c>

							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[7] );
8011b304:	e0bffd47 	ldb	r2,-11(fp)
8011b308:	016005b4 	movhi	r5,32790
8011b30c:	297a35c4 	addi	r5,r5,-5929
8011b310:	1009883a 	mov	r4,r2
8011b314:	011b3ac0 	call	8011b3ac <ucCheckAndApllySPWChannel>
8011b318:	e0bffb15 	stw	r2,-20(fp)

							if (bSuccess == TRUE) {
8011b31c:	e0bffb17 	ldw	r2,-20(fp)
8011b320:	10800058 	cmpnei	r2,r2,1
8011b324:	10000d1e 	bne	r2,zero,8011b35c <vCHConfs+0x814>
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[7] ] = 7;
8011b328:	00a005b4 	movhi	r2,32790
8011b32c:	10ba3204 	addi	r2,r2,-5944
8011b330:	108003c3 	ldbu	r2,15(r2)
8011b334:	10c03fcc 	andi	r3,r2,255
8011b338:	00a005b4 	movhi	r2,32790
8011b33c:	10ba3204 	addi	r2,r2,-5944
8011b340:	10c5883a 	add	r2,r2,r3
8011b344:	00c001c4 	movi	r3,7
8011b348:	10c00005 	stb	r3,0(r2)
							} else {
								return FALSE;
							}
						} while ( (c !=59) );
8011b34c:	e0bffd07 	ldb	r2,-12(fp)
8011b350:	10800ed8 	cmpnei	r2,r2,59
8011b354:	103fd11e 	bne	r2,zero,8011b29c <__reset+0xfa0fb29c>

						break;
8011b358:	00000c06 	br	8011b38c <vCHConfs+0x844>
							bSuccess = ucCheckAndApllySPWChannel( cChannel , &xDefaultsCH.ucFEEtoChanell[7] );

							if (bSuccess == TRUE) {
								xDefaultsCH.ucChannelToFEE[ xDefaultsCH.ucFEEtoChanell[7] ] = 7;
							} else {
								return FALSE;
8011b35c:	0005883a 	mov	r2,zero
8011b360:	00000d06 	br	8011b398 <vCHConfs+0x850>
						} while ( (c !=59) );

						break;

					case 0x3C: //"<"
						close = siCloseFile(siFile);
8011b364:	e0bfff0f 	ldh	r2,-4(fp)
8011b368:	1009883a 	mov	r4,r2
8011b36c:	011ef180 	call	8011ef18 <siCloseFile>
8011b370:	e0bffe15 	stw	r2,-8(fp)
							#if DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8011b374:	00800044 	movi	r2,1
8011b378:	e0bffc15 	stw	r2,-16(fp)
						bSuccess = TRUE; //pensar melhor
8011b37c:	00800044 	movi	r2,1
8011b380:	e0bffb15 	stw	r2,-20(fp)
						break;
8011b384:	00000106 	br	8011b38c <vCHConfs+0x844>
					default:
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser. (%hhu)\n",c);
						#endif
						break;
8011b388:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
8011b38c:	e0bffc17 	ldw	r2,-16(fp)
8011b390:	103e0526 	beq	r2,zero,8011aba8 <__reset+0xfa0faba8>
	if ( bSuccess == FALSE ) {
		/* Load default? */

	}

	return bSuccess;
8011b394:	e0bffb17 	ldw	r2,-20(fp)
}
8011b398:	e037883a 	mov	sp,fp
8011b39c:	dfc00117 	ldw	ra,4(sp)
8011b3a0:	df000017 	ldw	fp,0(sp)
8011b3a4:	dec00204 	addi	sp,sp,8
8011b3a8:	f800283a 	ret

8011b3ac <ucCheckAndApllySPWChannel>:


bool ucCheckAndApllySPWChannel( char cLetter, unsigned char *ucChannelNumber ) {
8011b3ac:	defffd04 	addi	sp,sp,-12
8011b3b0:	de00012e 	bgeu	sp,et,8011b3b8 <ucCheckAndApllySPWChannel+0xc>
8011b3b4:	003b68fa 	trap	3
8011b3b8:	df000215 	stw	fp,8(sp)
8011b3bc:	df000204 	addi	fp,sp,8
8011b3c0:	2005883a 	mov	r2,r4
8011b3c4:	e17fff15 	stw	r5,-4(fp)
8011b3c8:	e0bffe05 	stb	r2,-8(fp)
//
//	*ucChannelNumber = cChannelLists[ucIterator];

	// The verification will be implemented later

	*ucChannelNumber = (unsigned char) cLetter - 65;
8011b3cc:	e0bffe03 	ldbu	r2,-8(fp)
8011b3d0:	10bfefc4 	addi	r2,r2,-65
8011b3d4:	1007883a 	mov	r3,r2
8011b3d8:	e0bfff17 	ldw	r2,-4(fp)
8011b3dc:	10c00005 	stb	r3,0(r2)

	return TRUE;
8011b3e0:	00800044 	movi	r2,1
}
8011b3e4:	e037883a 	mov	sp,fp
8011b3e8:	df000017 	ldw	fp,0(sp)
8011b3ec:	dec00104 	addi	sp,sp,4
8011b3f0:	f800283a 	ret

8011b3f4 <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
8011b3f4:	defff504 	addi	sp,sp,-44
8011b3f8:	de00012e 	bgeu	sp,et,8011b400 <vLoadDefaultETHConf+0xc>
8011b3fc:	003b68fa 	trap	3
8011b400:	dfc00a15 	stw	ra,40(sp)
8011b404:	df000915 	stw	fp,36(sp)
8011b408:	dc000815 	stw	r16,32(sp)
8011b40c:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8011b410:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
8011b414:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8011b418:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8011b41c:	d0a07f17 	ldw	r2,-32260(gp)
8011b420:	10800058 	cmpnei	r2,r2,1
8011b424:	1001e41e 	bne	r2,zero,8011bbb8 <vLoadDefaultETHConf+0x7c4>
8011b428:	011edfc0 	call	8011edfc <bSDcardIsPresent>
8011b42c:	1001e226 	beq	r2,zero,8011bbb8 <vLoadDefaultETHConf+0x7c4>
8011b430:	011ee2c0 	call	8011ee2c <bSDcardFAT16Check>
8011b434:	1001e026 	beq	r2,zero,8011bbb8 <vLoadDefaultETHConf+0x7c4>

		siFile = siOpenFile( ETH_FILE_NAME );
8011b438:	01200534 	movhi	r4,32788
8011b43c:	211d8f04 	addi	r4,r4,30268
8011b440:	011eedc0 	call	8011eedc <siOpenFile>
8011b444:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8011b448:	e0bffc0f 	ldh	r2,-16(fp)
8011b44c:	1001da16 	blt	r2,zero,8011bbb8 <vLoadDefaultETHConf+0x7c4>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8011b450:	e0bffd04 	addi	r2,fp,-12
8011b454:	01800204 	movi	r6,8
8011b458:	01400284 	movi	r5,10
8011b45c:	1009883a 	mov	r4,r2
8011b460:	01215b40 	call	801215b4 <memset>
			p_inteiro = inteiro;
8011b464:	e0bffd04 	addi	r2,fp,-12
8011b468:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
8011b46c:	e0bffc0f 	ldh	r2,-16(fp)
8011b470:	1009883a 	mov	r4,r2
8011b474:	011ef580 	call	8011ef58 <cGetNextChar>
8011b478:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
8011b47c:	e0bff947 	ldb	r2,-27(fp)
8011b480:	10800084 	addi	r2,r2,2
8011b484:	10c015a8 	cmpgeui	r3,r2,86
8011b488:	1801c81e 	bne	r3,zero,8011bbac <vLoadDefaultETHConf+0x7b8>
8011b48c:	100690ba 	slli	r3,r2,2
8011b490:	00a004b4 	movhi	r2,32786
8011b494:	10ad2904 	addi	r2,r2,-19292
8011b498:	1885883a 	add	r2,r3,r2
8011b49c:	10800017 	ldw	r2,0(r2)
8011b4a0:	1000683a 	jmp	r2
8011b4a4:	8011b63c 	xorhi	zero,r16,18136
8011b4a8:	8011b630 	cmpltui	zero,r16,18136
8011b4ac:	8011bbac 	andhi	zero,r16,18158
8011b4b0:	8011bbac 	andhi	zero,r16,18158
8011b4b4:	8011bbac 	andhi	zero,r16,18158
8011b4b8:	8011bbac 	andhi	zero,r16,18158
8011b4bc:	8011bbac 	andhi	zero,r16,18158
8011b4c0:	8011bbac 	andhi	zero,r16,18158
8011b4c4:	8011bbac 	andhi	zero,r16,18158
8011b4c8:	8011bbac 	andhi	zero,r16,18158
8011b4cc:	8011bbac 	andhi	zero,r16,18158
8011b4d0:	8011bbac 	andhi	zero,r16,18158
8011b4d4:	8011bbac 	andhi	zero,r16,18158
8011b4d8:	8011bbac 	andhi	zero,r16,18158
8011b4dc:	8011bbac 	andhi	zero,r16,18158
8011b4e0:	8011bbac 	andhi	zero,r16,18158
8011b4e4:	8011bbac 	andhi	zero,r16,18158
8011b4e8:	8011bbac 	andhi	zero,r16,18158
8011b4ec:	8011bbac 	andhi	zero,r16,18158
8011b4f0:	8011bbac 	andhi	zero,r16,18158
8011b4f4:	8011bbac 	andhi	zero,r16,18158
8011b4f8:	8011bbac 	andhi	zero,r16,18158
8011b4fc:	8011bbac 	andhi	zero,r16,18158
8011b500:	8011bbac 	andhi	zero,r16,18158
8011b504:	8011bbac 	andhi	zero,r16,18158
8011b508:	8011bbac 	andhi	zero,r16,18158
8011b50c:	8011bbac 	andhi	zero,r16,18158
8011b510:	8011bbac 	andhi	zero,r16,18158
8011b514:	8011bbac 	andhi	zero,r16,18158
8011b518:	8011bbac 	andhi	zero,r16,18158
8011b51c:	8011bbac 	andhi	zero,r16,18158
8011b520:	8011bbac 	andhi	zero,r16,18158
8011b524:	8011bbac 	andhi	zero,r16,18158
8011b528:	8011bbac 	andhi	zero,r16,18158
8011b52c:	8011bbac 	andhi	zero,r16,18158
8011b530:	8011bbac 	andhi	zero,r16,18158
8011b534:	8011bbac 	andhi	zero,r16,18158
8011b538:	8011bbac 	andhi	zero,r16,18158
8011b53c:	8011bbac 	andhi	zero,r16,18158
8011b540:	8011bbac 	andhi	zero,r16,18158
8011b544:	8011bbac 	andhi	zero,r16,18158
8011b548:	8011b5fc 	xorhi	zero,r16,18135
8011b54c:	8011bbac 	andhi	zero,r16,18158
8011b550:	8011bbac 	andhi	zero,r16,18158
8011b554:	8011bbac 	andhi	zero,r16,18158
8011b558:	8011bbac 	andhi	zero,r16,18158
8011b55c:	8011bbac 	andhi	zero,r16,18158
8011b560:	8011bbac 	andhi	zero,r16,18158
8011b564:	8011bbac 	andhi	zero,r16,18158
8011b568:	8011bbac 	andhi	zero,r16,18158
8011b56c:	8011bbac 	andhi	zero,r16,18158
8011b570:	8011bbac 	andhi	zero,r16,18158
8011b574:	8011bbac 	andhi	zero,r16,18158
8011b578:	8011bbac 	andhi	zero,r16,18158
8011b57c:	8011bbac 	andhi	zero,r16,18158
8011b580:	8011bbac 	andhi	zero,r16,18158
8011b584:	8011bbac 	andhi	zero,r16,18158
8011b588:	8011bbac 	andhi	zero,r16,18158
8011b58c:	8011bbac 	andhi	zero,r16,18158
8011b590:	8011bbac 	andhi	zero,r16,18158
8011b594:	8011bbac 	andhi	zero,r16,18158
8011b598:	8011bbac 	andhi	zero,r16,18158
8011b59c:	8011bb88 	cmpgei	zero,r16,18158
8011b5a0:	8011bbac 	andhi	zero,r16,18158
8011b5a4:	8011bbac 	andhi	zero,r16,18158
8011b5a8:	8011bbac 	andhi	zero,r16,18158
8011b5ac:	8011bbac 	andhi	zero,r16,18158
8011b5b0:	8011bbac 	andhi	zero,r16,18158
8011b5b4:	8011bbac 	andhi	zero,r16,18158
8011b5b8:	8011bbac 	andhi	zero,r16,18158
8011b5bc:	8011bab8 	rdprs	zero,r16,18154
8011b5c0:	8011bbac 	andhi	zero,r16,18158
8011b5c4:	8011bbac 	andhi	zero,r16,18158
8011b5c8:	8011b7e4 	muli	zero,r16,18143
8011b5cc:	8011b940 	call	88011b94 <__reset+0x1ff1b94>
8011b5d0:	8011b718 	cmpnei	zero,r16,18140
8011b5d4:	8011bbac 	andhi	zero,r16,18158
8011b5d8:	8011bbac 	andhi	zero,r16,18158
8011b5dc:	8011bbac 	andhi	zero,r16,18158
8011b5e0:	8011b648 	cmpgei	zero,r16,18137
8011b5e4:	8011bbac 	andhi	zero,r16,18158
8011b5e8:	8011bbac 	andhi	zero,r16,18158
8011b5ec:	8011b8b4 	orhi	zero,r16,18146
8011b5f0:	8011bbac 	andhi	zero,r16,18158
8011b5f4:	8011bbac 	andhi	zero,r16,18158
8011b5f8:	8011b9e8 	cmpgeui	zero,r16,18151
					case 39:// single quote '
						c = cGetNextChar(siFile);
8011b5fc:	e0bffc0f 	ldh	r2,-16(fp)
8011b600:	1009883a 	mov	r4,r2
8011b604:	011ef580 	call	8011ef58 <cGetNextChar>
8011b608:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
8011b60c:	00000406 	br	8011b620 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8011b610:	e0bffc0f 	ldh	r2,-16(fp)
8011b614:	1009883a 	mov	r4,r2
8011b618:	011ef580 	call	8011ef58 <cGetNextChar>
8011b61c:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8011b620:	e0bff947 	ldb	r2,-27(fp)
8011b624:	108009d8 	cmpnei	r2,r2,39
8011b628:	103ff91e 	bne	r2,zero,8011b610 <__reset+0xfa0fb610>
							c = cGetNextChar(siFile);
						}
						break;
8011b62c:	00016006 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
					case -1: 	//EOF
						bEOF = TRUE;
8011b630:	00800044 	movi	r2,1
8011b634:	e0bff815 	stw	r2,-32(fp)
						break;
8011b638:	00015d06 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
							debug(fp,"SDCard: Problem with SDCard");
						}
						#endif
						bEOF = TRUE;
8011b63c:	00800044 	movi	r2,1
8011b640:	e0bff815 	stw	r2,-32(fp)
						break;
8011b644:	00015a06 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
8011b648:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011b64c:	e0bffc0f 	ldh	r2,-16(fp)
8011b650:	1009883a 	mov	r4,r2
8011b654:	011ef580 	call	8011ef58 <cGetNextChar>
8011b658:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8011b65c:	d0e00317 	ldw	r3,-32756(gp)
8011b660:	e0bff947 	ldb	r2,-27(fp)
8011b664:	10800044 	addi	r2,r2,1
8011b668:	1885883a 	add	r2,r3,r2
8011b66c:	10800003 	ldbu	r2,0(r2)
8011b670:	10803fcc 	andi	r2,r2,255
8011b674:	1080010c 	andi	r2,r2,4
8011b678:	10000626 	beq	r2,zero,8011b694 <vLoadDefaultETHConf+0x2a0>
									(*p_inteiro) = c;
8011b67c:	e0bffa17 	ldw	r2,-24(fp)
8011b680:	e0fff943 	ldbu	r3,-27(fp)
8011b684:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011b688:	e0bffa17 	ldw	r2,-24(fp)
8011b68c:	10800044 	addi	r2,r2,1
8011b690:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8011b694:	e0bff947 	ldb	r2,-27(fp)
8011b698:	10800ea0 	cmpeqi	r2,r2,58
8011b69c:	1000031e 	bne	r2,zero,8011b6ac <vLoadDefaultETHConf+0x2b8>
8011b6a0:	e0bff947 	ldb	r2,-27(fp)
8011b6a4:	10800ed8 	cmpnei	r2,r2,59
8011b6a8:	103fe81e 	bne	r2,zero,8011b64c <__reset+0xfa0fb64c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011b6ac:	e0bffa17 	ldw	r2,-24(fp)
8011b6b0:	00c00284 	movi	r3,10
8011b6b4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = (unsigned char)atoi( inteiro );
8011b6b8:	e0bff903 	ldbu	r2,-28(fp)
8011b6bc:	10800168 	cmpgeui	r2,r2,5
8011b6c0:	1000021e 	bne	r2,zero,8011b6cc <vLoadDefaultETHConf+0x2d8>
8011b6c4:	e43ff903 	ldbu	r16,-28(fp)
8011b6c8:	00000106 	br	8011b6d0 <vLoadDefaultETHConf+0x2dc>
8011b6cc:	04000144 	movi	r16,5
8011b6d0:	e0bffd04 	addi	r2,fp,-12
8011b6d4:	1009883a 	mov	r4,r2
8011b6d8:	01214340 	call	80121434 <atoi>
8011b6dc:	1007883a 	mov	r3,r2
8011b6e0:	00a005b4 	movhi	r2,32790
8011b6e4:	10ba4304 	addi	r2,r2,-5876
8011b6e8:	1405883a 	add	r2,r2,r16
8011b6ec:	10800404 	addi	r2,r2,16
8011b6f0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011b6f4:	e0bffd04 	addi	r2,fp,-12
8011b6f8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8011b6fc:	e0bff903 	ldbu	r2,-28(fp)
8011b700:	10800044 	addi	r2,r2,1
8011b704:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8011b708:	e0bff947 	ldb	r2,-27(fp)
8011b70c:	10800ed8 	cmpnei	r2,r2,59
8011b710:	103fce1e 	bne	r2,zero,8011b64c <__reset+0xfa0fb64c>

						break;
8011b714:	00012606 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
					case 'I':

						ucParser = 0;
8011b718:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011b71c:	e0bffc0f 	ldh	r2,-16(fp)
8011b720:	1009883a 	mov	r4,r2
8011b724:	011ef580 	call	8011ef58 <cGetNextChar>
8011b728:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8011b72c:	d0e00317 	ldw	r3,-32756(gp)
8011b730:	e0bff947 	ldb	r2,-27(fp)
8011b734:	10800044 	addi	r2,r2,1
8011b738:	1885883a 	add	r2,r3,r2
8011b73c:	10800003 	ldbu	r2,0(r2)
8011b740:	10803fcc 	andi	r2,r2,255
8011b744:	1080010c 	andi	r2,r2,4
8011b748:	10000626 	beq	r2,zero,8011b764 <vLoadDefaultETHConf+0x370>
									(*p_inteiro) = c;
8011b74c:	e0bffa17 	ldw	r2,-24(fp)
8011b750:	e0fff943 	ldbu	r3,-27(fp)
8011b754:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011b758:	e0bffa17 	ldw	r2,-24(fp)
8011b75c:	10800044 	addi	r2,r2,1
8011b760:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011b764:	e0bff947 	ldb	r2,-27(fp)
8011b768:	10800ba0 	cmpeqi	r2,r2,46
8011b76c:	1000031e 	bne	r2,zero,8011b77c <vLoadDefaultETHConf+0x388>
8011b770:	e0bff947 	ldb	r2,-27(fp)
8011b774:	10800ed8 	cmpnei	r2,r2,59
8011b778:	103fe81e 	bne	r2,zero,8011b71c <__reset+0xfa0fb71c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011b77c:	e0bffa17 	ldw	r2,-24(fp)
8011b780:	00c00284 	movi	r3,10
8011b784:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8011b788:	e0bff903 	ldbu	r2,-28(fp)
8011b78c:	108000e8 	cmpgeui	r2,r2,3
8011b790:	1000021e 	bne	r2,zero,8011b79c <vLoadDefaultETHConf+0x3a8>
8011b794:	e43ff903 	ldbu	r16,-28(fp)
8011b798:	00000106 	br	8011b7a0 <vLoadDefaultETHConf+0x3ac>
8011b79c:	040000c4 	movi	r16,3
8011b7a0:	e0bffd04 	addi	r2,fp,-12
8011b7a4:	1009883a 	mov	r4,r2
8011b7a8:	01214340 	call	80121434 <atoi>
8011b7ac:	1007883a 	mov	r3,r2
8011b7b0:	00a005b4 	movhi	r2,32790
8011b7b4:	10ba4304 	addi	r2,r2,-5876
8011b7b8:	1405883a 	add	r2,r2,r16
8011b7bc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011b7c0:	e0bffd04 	addi	r2,fp,-12
8011b7c4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8011b7c8:	e0bff903 	ldbu	r2,-28(fp)
8011b7cc:	10800044 	addi	r2,r2,1
8011b7d0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8011b7d4:	e0bff947 	ldb	r2,-27(fp)
8011b7d8:	10800ed8 	cmpnei	r2,r2,59
8011b7dc:	103fcf1e 	bne	r2,zero,8011b71c <__reset+0xfa0fb71c>

						break;
8011b7e0:	0000f306 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
					case 'G':

						ucParser = 0;
8011b7e4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011b7e8:	e0bffc0f 	ldh	r2,-16(fp)
8011b7ec:	1009883a 	mov	r4,r2
8011b7f0:	011ef580 	call	8011ef58 <cGetNextChar>
8011b7f4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8011b7f8:	d0e00317 	ldw	r3,-32756(gp)
8011b7fc:	e0bff947 	ldb	r2,-27(fp)
8011b800:	10800044 	addi	r2,r2,1
8011b804:	1885883a 	add	r2,r3,r2
8011b808:	10800003 	ldbu	r2,0(r2)
8011b80c:	10803fcc 	andi	r2,r2,255
8011b810:	1080010c 	andi	r2,r2,4
8011b814:	10000626 	beq	r2,zero,8011b830 <vLoadDefaultETHConf+0x43c>
									(*p_inteiro) = c;
8011b818:	e0bffa17 	ldw	r2,-24(fp)
8011b81c:	e0fff943 	ldbu	r3,-27(fp)
8011b820:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011b824:	e0bffa17 	ldw	r2,-24(fp)
8011b828:	10800044 	addi	r2,r2,1
8011b82c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011b830:	e0bff947 	ldb	r2,-27(fp)
8011b834:	10800ba0 	cmpeqi	r2,r2,46
8011b838:	1000031e 	bne	r2,zero,8011b848 <vLoadDefaultETHConf+0x454>
8011b83c:	e0bff947 	ldb	r2,-27(fp)
8011b840:	10800ed8 	cmpnei	r2,r2,59
8011b844:	103fe81e 	bne	r2,zero,8011b7e8 <__reset+0xfa0fb7e8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011b848:	e0bffa17 	ldw	r2,-24(fp)
8011b84c:	00c00284 	movi	r3,10
8011b850:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8011b854:	e0bff903 	ldbu	r2,-28(fp)
8011b858:	108000e8 	cmpgeui	r2,r2,3
8011b85c:	1000021e 	bne	r2,zero,8011b868 <vLoadDefaultETHConf+0x474>
8011b860:	e43ff903 	ldbu	r16,-28(fp)
8011b864:	00000106 	br	8011b86c <vLoadDefaultETHConf+0x478>
8011b868:	040000c4 	movi	r16,3
8011b86c:	e0bffd04 	addi	r2,fp,-12
8011b870:	1009883a 	mov	r4,r2
8011b874:	01214340 	call	80121434 <atoi>
8011b878:	1007883a 	mov	r3,r2
8011b87c:	00a005b4 	movhi	r2,32790
8011b880:	10ba4304 	addi	r2,r2,-5876
8011b884:	1405883a 	add	r2,r2,r16
8011b888:	10800104 	addi	r2,r2,4
8011b88c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011b890:	e0bffd04 	addi	r2,fp,-12
8011b894:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8011b898:	e0bff903 	ldbu	r2,-28(fp)
8011b89c:	10800044 	addi	r2,r2,1
8011b8a0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8011b8a4:	e0bff947 	ldb	r2,-27(fp)
8011b8a8:	10800ed8 	cmpnei	r2,r2,59
8011b8ac:	103fce1e 	bne	r2,zero,8011b7e8 <__reset+0xfa0fb7e8>

						break;
8011b8b0:	0000bf06 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
					case 'P':
						ucParser = 0;
8011b8b4:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
8011b8b8:	e0bffc0f 	ldh	r2,-16(fp)
8011b8bc:	1009883a 	mov	r4,r2
8011b8c0:	011ef580 	call	8011ef58 <cGetNextChar>
8011b8c4:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8011b8c8:	d0e00317 	ldw	r3,-32756(gp)
8011b8cc:	e0bff947 	ldb	r2,-27(fp)
8011b8d0:	10800044 	addi	r2,r2,1
8011b8d4:	1885883a 	add	r2,r3,r2
8011b8d8:	10800003 	ldbu	r2,0(r2)
8011b8dc:	10803fcc 	andi	r2,r2,255
8011b8e0:	1080010c 	andi	r2,r2,4
8011b8e4:	10000626 	beq	r2,zero,8011b900 <vLoadDefaultETHConf+0x50c>
								(*p_inteiro) = c;
8011b8e8:	e0bffa17 	ldw	r2,-24(fp)
8011b8ec:	e0fff943 	ldbu	r3,-27(fp)
8011b8f0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011b8f4:	e0bffa17 	ldw	r2,-24(fp)
8011b8f8:	10800044 	addi	r2,r2,1
8011b8fc:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011b900:	e0bff947 	ldb	r2,-27(fp)
8011b904:	10800ed8 	cmpnei	r2,r2,59
8011b908:	103feb1e 	bne	r2,zero,8011b8b8 <__reset+0xfa0fb8b8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011b90c:	e0bffa17 	ldw	r2,-24(fp)
8011b910:	00c00284 	movi	r3,10
8011b914:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = (unsigned short int)atoi( inteiro );
8011b918:	e0bffd04 	addi	r2,fp,-12
8011b91c:	1009883a 	mov	r4,r2
8011b920:	01214340 	call	80121434 <atoi>
8011b924:	1007883a 	mov	r3,r2
8011b928:	00a005b4 	movhi	r2,32790
8011b92c:	10ba4304 	addi	r2,r2,-5876
8011b930:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011b934:	e0bffd04 	addi	r2,fp,-12
8011b938:	e0bffa15 	stw	r2,-24(fp)

						break;
8011b93c:	00009c06 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8011b940:	e0bffc0f 	ldh	r2,-16(fp)
8011b944:	1009883a 	mov	r4,r2
8011b948:	011ef580 	call	8011ef58 <cGetNextChar>
8011b94c:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8011b950:	d0e00317 	ldw	r3,-32756(gp)
8011b954:	e0bff947 	ldb	r2,-27(fp)
8011b958:	10800044 	addi	r2,r2,1
8011b95c:	1885883a 	add	r2,r3,r2
8011b960:	10800003 	ldbu	r2,0(r2)
8011b964:	10803fcc 	andi	r2,r2,255
8011b968:	1080010c 	andi	r2,r2,4
8011b96c:	10000626 	beq	r2,zero,8011b988 <vLoadDefaultETHConf+0x594>
								(*p_inteiro) = c;
8011b970:	e0bffa17 	ldw	r2,-24(fp)
8011b974:	e0fff943 	ldbu	r3,-27(fp)
8011b978:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011b97c:	e0bffa17 	ldw	r2,-24(fp)
8011b980:	10800044 	addi	r2,r2,1
8011b984:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011b988:	e0bff947 	ldb	r2,-27(fp)
8011b98c:	10800ed8 	cmpnei	r2,r2,59
8011b990:	103feb1e 	bne	r2,zero,8011b940 <__reset+0xfa0fb940>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011b994:	e0bffa17 	ldw	r2,-24(fp)
8011b998:	00c00284 	movi	r3,10
8011b99c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8011b9a0:	e0bffd04 	addi	r2,fp,-12
8011b9a4:	1009883a 	mov	r4,r2
8011b9a8:	01214340 	call	80121434 <atoi>
8011b9ac:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8011b9b0:	e0bffc8f 	ldh	r2,-14(fp)
8011b9b4:	10800058 	cmpnei	r2,r2,1
8011b9b8:	1000051e 	bne	r2,zero,8011b9d0 <vLoadDefaultETHConf+0x5dc>
							xConfEth.bDHCP = TRUE;
8011b9bc:	00a005b4 	movhi	r2,32790
8011b9c0:	10ba4304 	addi	r2,r2,-5876
8011b9c4:	00c00044 	movi	r3,1
8011b9c8:	10c00615 	stw	r3,24(r2)
8011b9cc:	00000306 	br	8011b9dc <vLoadDefaultETHConf+0x5e8>
						else
							xConfEth.bDHCP = FALSE;
8011b9d0:	00a005b4 	movhi	r2,32790
8011b9d4:	10ba4304 	addi	r2,r2,-5876
8011b9d8:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011b9dc:	e0bffd04 	addi	r2,fp,-12
8011b9e0:	e0bffa15 	stw	r2,-24(fp)

						break;
8011b9e4:	00007206 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>

					case 'S':

						ucParser = 0;
8011b9e8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011b9ec:	e0bffc0f 	ldh	r2,-16(fp)
8011b9f0:	1009883a 	mov	r4,r2
8011b9f4:	011ef580 	call	8011ef58 <cGetNextChar>
8011b9f8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8011b9fc:	d0e00317 	ldw	r3,-32756(gp)
8011ba00:	e0bff947 	ldb	r2,-27(fp)
8011ba04:	10800044 	addi	r2,r2,1
8011ba08:	1885883a 	add	r2,r3,r2
8011ba0c:	10800003 	ldbu	r2,0(r2)
8011ba10:	10803fcc 	andi	r2,r2,255
8011ba14:	1080010c 	andi	r2,r2,4
8011ba18:	10000626 	beq	r2,zero,8011ba34 <vLoadDefaultETHConf+0x640>
									(*p_inteiro) = c;
8011ba1c:	e0bffa17 	ldw	r2,-24(fp)
8011ba20:	e0fff943 	ldbu	r3,-27(fp)
8011ba24:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011ba28:	e0bffa17 	ldw	r2,-24(fp)
8011ba2c:	10800044 	addi	r2,r2,1
8011ba30:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011ba34:	e0bff947 	ldb	r2,-27(fp)
8011ba38:	10800ba0 	cmpeqi	r2,r2,46
8011ba3c:	1000031e 	bne	r2,zero,8011ba4c <vLoadDefaultETHConf+0x658>
8011ba40:	e0bff947 	ldb	r2,-27(fp)
8011ba44:	10800ed8 	cmpnei	r2,r2,59
8011ba48:	103fe81e 	bne	r2,zero,8011b9ec <__reset+0xfa0fb9ec>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011ba4c:	e0bffa17 	ldw	r2,-24(fp)
8011ba50:	00c00284 	movi	r3,10
8011ba54:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8011ba58:	e0bff903 	ldbu	r2,-28(fp)
8011ba5c:	108000e8 	cmpgeui	r2,r2,3
8011ba60:	1000021e 	bne	r2,zero,8011ba6c <vLoadDefaultETHConf+0x678>
8011ba64:	e43ff903 	ldbu	r16,-28(fp)
8011ba68:	00000106 	br	8011ba70 <vLoadDefaultETHConf+0x67c>
8011ba6c:	040000c4 	movi	r16,3
8011ba70:	e0bffd04 	addi	r2,fp,-12
8011ba74:	1009883a 	mov	r4,r2
8011ba78:	01214340 	call	80121434 <atoi>
8011ba7c:	1007883a 	mov	r3,r2
8011ba80:	00a005b4 	movhi	r2,32790
8011ba84:	10ba4304 	addi	r2,r2,-5876
8011ba88:	1405883a 	add	r2,r2,r16
8011ba8c:	10800204 	addi	r2,r2,8
8011ba90:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011ba94:	e0bffd04 	addi	r2,fp,-12
8011ba98:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8011ba9c:	e0bff903 	ldbu	r2,-28(fp)
8011baa0:	10800044 	addi	r2,r2,1
8011baa4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8011baa8:	e0bff947 	ldb	r2,-27(fp)
8011baac:	10800ed8 	cmpnei	r2,r2,59
8011bab0:	103fce1e 	bne	r2,zero,8011b9ec <__reset+0xfa0fb9ec>

						break;
8011bab4:	00003e06 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
					case 'D':

						ucParser = 0;
8011bab8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011babc:	e0bffc0f 	ldh	r2,-16(fp)
8011bac0:	1009883a 	mov	r4,r2
8011bac4:	011ef580 	call	8011ef58 <cGetNextChar>
8011bac8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8011bacc:	d0e00317 	ldw	r3,-32756(gp)
8011bad0:	e0bff947 	ldb	r2,-27(fp)
8011bad4:	10800044 	addi	r2,r2,1
8011bad8:	1885883a 	add	r2,r3,r2
8011badc:	10800003 	ldbu	r2,0(r2)
8011bae0:	10803fcc 	andi	r2,r2,255
8011bae4:	1080010c 	andi	r2,r2,4
8011bae8:	10000626 	beq	r2,zero,8011bb04 <vLoadDefaultETHConf+0x710>
									(*p_inteiro) = c;
8011baec:	e0bffa17 	ldw	r2,-24(fp)
8011baf0:	e0fff943 	ldbu	r3,-27(fp)
8011baf4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011baf8:	e0bffa17 	ldw	r2,-24(fp)
8011bafc:	10800044 	addi	r2,r2,1
8011bb00:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011bb04:	e0bff947 	ldb	r2,-27(fp)
8011bb08:	10800ba0 	cmpeqi	r2,r2,46
8011bb0c:	1000031e 	bne	r2,zero,8011bb1c <vLoadDefaultETHConf+0x728>
8011bb10:	e0bff947 	ldb	r2,-27(fp)
8011bb14:	10800ed8 	cmpnei	r2,r2,59
8011bb18:	103fe81e 	bne	r2,zero,8011babc <__reset+0xfa0fbabc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011bb1c:	e0bffa17 	ldw	r2,-24(fp)
8011bb20:	00c00284 	movi	r3,10
8011bb24:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8011bb28:	e0bff903 	ldbu	r2,-28(fp)
8011bb2c:	108000e8 	cmpgeui	r2,r2,3
8011bb30:	1000021e 	bne	r2,zero,8011bb3c <vLoadDefaultETHConf+0x748>
8011bb34:	e43ff903 	ldbu	r16,-28(fp)
8011bb38:	00000106 	br	8011bb40 <vLoadDefaultETHConf+0x74c>
8011bb3c:	040000c4 	movi	r16,3
8011bb40:	e0bffd04 	addi	r2,fp,-12
8011bb44:	1009883a 	mov	r4,r2
8011bb48:	01214340 	call	80121434 <atoi>
8011bb4c:	1007883a 	mov	r3,r2
8011bb50:	00a005b4 	movhi	r2,32790
8011bb54:	10ba4304 	addi	r2,r2,-5876
8011bb58:	1405883a 	add	r2,r2,r16
8011bb5c:	10800304 	addi	r2,r2,12
8011bb60:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011bb64:	e0bffd04 	addi	r2,fp,-12
8011bb68:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8011bb6c:	e0bff903 	ldbu	r2,-28(fp)
8011bb70:	10800044 	addi	r2,r2,1
8011bb74:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8011bb78:	e0bff947 	ldb	r2,-27(fp)
8011bb7c:	10800ed8 	cmpnei	r2,r2,59
8011bb80:	103fce1e 	bne	r2,zero,8011babc <__reset+0xfa0fbabc>

						break;						
8011bb84:	00000a06 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8011bb88:	e0bffc0f 	ldh	r2,-16(fp)
8011bb8c:	1009883a 	mov	r4,r2
8011bb90:	011ef180 	call	8011ef18 <siCloseFile>
8011bb94:	e0bffb15 	stw	r2,-20(fp)
								debug(fp,"SDCard: Can't close the file.\n");
							}
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8011bb98:	00800044 	movi	r2,1
8011bb9c:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8011bba0:	00800044 	movi	r2,1
8011bba4:	e0bff715 	stw	r2,-36(fp)
						break;
8011bba8:	00000106 	br	8011bbb0 <vLoadDefaultETHConf+0x7bc>
						#if DEBUG_ON
						if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
							fprintf(fp,"SDCard: Problem with the parser.\n");
						}
						#endif
						break;
8011bbac:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
8011bbb0:	e0bff817 	ldw	r2,-32(fp)
8011bbb4:	103e2d26 	beq	r2,zero,8011b46c <__reset+0xfa0fb46c>
			fprintf(fp,"SDCard: No SDCard.\n");
		}
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8011bbb8:	e0bff717 	ldw	r2,-36(fp)
8011bbbc:	10004c1e 	bne	r2,zero,8011bcf0 <vLoadDefaultETHConf+0x8fc>
		xConfEth.siPortPUS = 17000;
8011bbc0:	00a005b4 	movhi	r2,32790
8011bbc4:	10ba4304 	addi	r2,r2,-5876
8011bbc8:	00d09a04 	movi	r3,17000
8011bbcc:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8011bbd0:	00a005b4 	movhi	r2,32790
8011bbd4:	10ba4304 	addi	r2,r2,-5876
8011bbd8:	00fff004 	movi	r3,-64
8011bbdc:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8011bbe0:	00a005b4 	movhi	r2,32790
8011bbe4:	10ba4304 	addi	r2,r2,-5876
8011bbe8:	00ffea04 	movi	r3,-88
8011bbec:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8011bbf0:	00a005b4 	movhi	r2,32790
8011bbf4:	10ba4304 	addi	r2,r2,-5876
8011bbf8:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
8011bbfc:	00a005b4 	movhi	r2,32790
8011bc00:	10ba4304 	addi	r2,r2,-5876
8011bc04:	00c00144 	movi	r3,5
8011bc08:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
8011bc0c:	00a005b4 	movhi	r2,32790
8011bc10:	10ba4304 	addi	r2,r2,-5876
8011bc14:	00fff004 	movi	r3,-64
8011bc18:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
8011bc1c:	00a005b4 	movhi	r2,32790
8011bc20:	10ba4304 	addi	r2,r2,-5876
8011bc24:	00ffea04 	movi	r3,-88
8011bc28:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8011bc2c:	00a005b4 	movhi	r2,32790
8011bc30:	10ba4304 	addi	r2,r2,-5876
8011bc34:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
8011bc38:	00a005b4 	movhi	r2,32790
8011bc3c:	10ba4304 	addi	r2,r2,-5876
8011bc40:	00c00044 	movi	r3,1
8011bc44:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
8011bc48:	00a005b4 	movhi	r2,32790
8011bc4c:	10ba4304 	addi	r2,r2,-5876
8011bc50:	00ffffc4 	movi	r3,-1
8011bc54:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
8011bc58:	00a005b4 	movhi	r2,32790
8011bc5c:	10ba4304 	addi	r2,r2,-5876
8011bc60:	00ffffc4 	movi	r3,-1
8011bc64:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
8011bc68:	00a005b4 	movhi	r2,32790
8011bc6c:	10ba4304 	addi	r2,r2,-5876
8011bc70:	00ffffc4 	movi	r3,-1
8011bc74:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
8011bc78:	00a005b4 	movhi	r2,32790
8011bc7c:	10ba4304 	addi	r2,r2,-5876
8011bc80:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8011bc84:	00a005b4 	movhi	r2,32790
8011bc88:	10ba4304 	addi	r2,r2,-5876
8011bc8c:	00ffff04 	movi	r3,-4
8011bc90:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8011bc94:	00a005b4 	movhi	r2,32790
8011bc98:	10ba4304 	addi	r2,r2,-5876
8011bc9c:	00fffdc4 	movi	r3,-9
8011bca0:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8011bca4:	00a005b4 	movhi	r2,32790
8011bca8:	10ba4304 	addi	r2,r2,-5876
8011bcac:	00c018c4 	movi	r3,99
8011bcb0:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8011bcb4:	00a005b4 	movhi	r2,32790
8011bcb8:	10ba4304 	addi	r2,r2,-5876
8011bcbc:	00c01344 	movi	r3,77
8011bcc0:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8011bcc4:	00a005b4 	movhi	r2,32790
8011bcc8:	10ba4304 	addi	r2,r2,-5876
8011bccc:	00c007c4 	movi	r3,31
8011bcd0:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8011bcd4:	00a005b4 	movhi	r2,32790
8011bcd8:	10ba4304 	addi	r2,r2,-5876
8011bcdc:	00c01084 	movi	r3,66
8011bce0:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8011bce4:	00a005b4 	movhi	r2,32790
8011bce8:	10ba4304 	addi	r2,r2,-5876
8011bcec:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8011bcf0:	e0bff717 	ldw	r2,-36(fp)
}
8011bcf4:	e6ffff04 	addi	sp,fp,-4
8011bcf8:	dfc00217 	ldw	ra,8(sp)
8011bcfc:	df000117 	ldw	fp,4(sp)
8011bd00:	dc000017 	ldw	r16,0(sp)
8011bd04:	dec00304 	addi	sp,sp,12
8011bd08:	f800283a 	ret

8011bd0c <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
8011bd0c:	deffee04 	addi	sp,sp,-72
8011bd10:	de00012e 	bgeu	sp,et,8011bd18 <vLoadDebugConfs+0xc>
8011bd14:	003b68fa 	trap	3
8011bd18:	dfc01115 	stw	ra,68(sp)
8011bd1c:	df001015 	stw	fp,64(sp)
8011bd20:	dc000f15 	stw	r16,60(sp)
8011bd24:	df001004 	addi	fp,sp,64
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
8011bd28:	e03ff015 	stw	zero,-64(fp)
	bool bEOF = FALSE;
8011bd2c:	e03ff115 	stw	zero,-60(fp)
	bool close = FALSE;
8011bd30:	e03ff515 	stw	zero,-44(fp)
	char c, *p_inteiro, *p_inteiroll;
	char inteiro[8];
	char inteiroll[24];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
8011bd34:	d0a07f17 	ldw	r2,-32260(gp)
8011bd38:	10800058 	cmpnei	r2,r2,1
8011bd3c:	1003c11e 	bne	r2,zero,8011cc44 <vLoadDebugConfs+0xf38>
8011bd40:	011edfc0 	call	8011edfc <bSDcardIsPresent>
8011bd44:	1003bf26 	beq	r2,zero,8011cc44 <vLoadDebugConfs+0xf38>
8011bd48:	011ee2c0 	call	8011ee2c <bSDcardFAT16Check>
8011bd4c:	1003bd26 	beq	r2,zero,8011cc44 <vLoadDebugConfs+0xf38>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8011bd50:	01200534 	movhi	r4,32788
8011bd54:	211d9104 	addi	r4,r4,30276
8011bd58:	011eedc0 	call	8011eedc <siOpenFile>
8011bd5c:	e0bff60d 	sth	r2,-40(fp)

		if ( siFile >= 0 ){
8011bd60:	e0bff60f 	ldh	r2,-40(fp)
8011bd64:	1003b716 	blt	r2,zero,8011cc44 <vLoadDebugConfs+0xf38>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
8011bd68:	e0bff704 	addi	r2,fp,-36
8011bd6c:	01800204 	movi	r6,8
8011bd70:	01400284 	movi	r5,10
8011bd74:	1009883a 	mov	r4,r2
8011bd78:	01215b40 	call	801215b4 <memset>
			memset( &(inteiroll) , 10 , sizeof( inteiroll ) );
8011bd7c:	e0bff904 	addi	r2,fp,-28
8011bd80:	01800604 	movi	r6,24
8011bd84:	01400284 	movi	r5,10
8011bd88:	1009883a 	mov	r4,r2
8011bd8c:	01215b40 	call	801215b4 <memset>
			p_inteiro = inteiro;
8011bd90:	e0bff704 	addi	r2,fp,-36
8011bd94:	e0bff315 	stw	r2,-52(fp)
			p_inteiroll = inteiroll;
8011bd98:	e0bff904 	addi	r2,fp,-28
8011bd9c:	e0bff415 	stw	r2,-48(fp)

			do {
				c = cGetNextChar(siFile);
8011bda0:	e0bff60f 	ldh	r2,-40(fp)
8011bda4:	1009883a 	mov	r4,r2
8011bda8:	011ef580 	call	8011ef58 <cGetNextChar>
8011bdac:	e0bff245 	stb	r2,-55(fp)
				//printf("%c \n", c);
				switch (c) {
8011bdb0:	e0bff247 	ldb	r2,-55(fp)
8011bdb4:	10800084 	addi	r2,r2,2
8011bdb8:	10c01768 	cmpgeui	r3,r2,93
8011bdbc:	18039e1e 	bne	r3,zero,8011cc38 <vLoadDebugConfs+0xf2c>
8011bdc0:	100690ba 	slli	r3,r2,2
8011bdc4:	00a004b4 	movhi	r2,32786
8011bdc8:	10af7604 	addi	r2,r2,-16936
8011bdcc:	1885883a 	add	r2,r3,r2
8011bdd0:	10800017 	ldw	r2,0(r2)
8011bdd4:	1000683a 	jmp	r2
8011bdd8:	8011bf8c 	andi	zero,r16,18174
8011bddc:	8011bf80 	call	88011bf8 <__reset+0x1ff1bf8>
8011bde0:	8011cc38 	rdprs	zero,r16,18224
8011bde4:	8011cc38 	rdprs	zero,r16,18224
8011bde8:	8011cc38 	rdprs	zero,r16,18224
8011bdec:	8011cc38 	rdprs	zero,r16,18224
8011bdf0:	8011cc38 	rdprs	zero,r16,18224
8011bdf4:	8011cc38 	rdprs	zero,r16,18224
8011bdf8:	8011cc38 	rdprs	zero,r16,18224
8011bdfc:	8011cc38 	rdprs	zero,r16,18224
8011be00:	8011cc38 	rdprs	zero,r16,18224
8011be04:	8011cc38 	rdprs	zero,r16,18224
8011be08:	8011cc38 	rdprs	zero,r16,18224
8011be0c:	8011cc38 	rdprs	zero,r16,18224
8011be10:	8011cc38 	rdprs	zero,r16,18224
8011be14:	8011cc38 	rdprs	zero,r16,18224
8011be18:	8011cc38 	rdprs	zero,r16,18224
8011be1c:	8011cc38 	rdprs	zero,r16,18224
8011be20:	8011cc38 	rdprs	zero,r16,18224
8011be24:	8011cc38 	rdprs	zero,r16,18224
8011be28:	8011cc38 	rdprs	zero,r16,18224
8011be2c:	8011cc38 	rdprs	zero,r16,18224
8011be30:	8011cc38 	rdprs	zero,r16,18224
8011be34:	8011cc38 	rdprs	zero,r16,18224
8011be38:	8011cc38 	rdprs	zero,r16,18224
8011be3c:	8011cc38 	rdprs	zero,r16,18224
8011be40:	8011cc38 	rdprs	zero,r16,18224
8011be44:	8011cc38 	rdprs	zero,r16,18224
8011be48:	8011cc38 	rdprs	zero,r16,18224
8011be4c:	8011cc38 	rdprs	zero,r16,18224
8011be50:	8011cc38 	rdprs	zero,r16,18224
8011be54:	8011cc38 	rdprs	zero,r16,18224
8011be58:	8011cc38 	rdprs	zero,r16,18224
8011be5c:	8011cc38 	rdprs	zero,r16,18224
8011be60:	8011cc38 	rdprs	zero,r16,18224
8011be64:	8011cc38 	rdprs	zero,r16,18224
8011be68:	8011cc38 	rdprs	zero,r16,18224
8011be6c:	8011cc38 	rdprs	zero,r16,18224
8011be70:	8011cc38 	rdprs	zero,r16,18224
8011be74:	8011cc38 	rdprs	zero,r16,18224
8011be78:	8011cc38 	rdprs	zero,r16,18224
8011be7c:	8011bf4c 	andi	zero,r16,18173
8011be80:	8011cc38 	rdprs	zero,r16,18224
8011be84:	8011cc38 	rdprs	zero,r16,18224
8011be88:	8011cc38 	rdprs	zero,r16,18224
8011be8c:	8011cc38 	rdprs	zero,r16,18224
8011be90:	8011cc38 	rdprs	zero,r16,18224
8011be94:	8011cc38 	rdprs	zero,r16,18224
8011be98:	8011cc38 	rdprs	zero,r16,18224
8011be9c:	8011cc38 	rdprs	zero,r16,18224
8011bea0:	8011cc38 	rdprs	zero,r16,18224
8011bea4:	8011cc38 	rdprs	zero,r16,18224
8011bea8:	8011cc38 	rdprs	zero,r16,18224
8011beac:	8011cc38 	rdprs	zero,r16,18224
8011beb0:	8011cc38 	rdprs	zero,r16,18224
8011beb4:	8011cc38 	rdprs	zero,r16,18224
8011beb8:	8011cc38 	rdprs	zero,r16,18224
8011bebc:	8011cc38 	rdprs	zero,r16,18224
8011bec0:	8011cc38 	rdprs	zero,r16,18224
8011bec4:	8011cc38 	rdprs	zero,r16,18224
8011bec8:	8011cc38 	rdprs	zero,r16,18224
8011becc:	8011cc38 	rdprs	zero,r16,18224
8011bed0:	8011cc14 	ori	zero,r16,18224
8011bed4:	8011cc38 	rdprs	zero,r16,18224
8011bed8:	8011cc38 	rdprs	zero,r16,18224
8011bedc:	8011cc38 	rdprs	zero,r16,18224
8011bee0:	8011cc38 	rdprs	zero,r16,18224
8011bee4:	8011c258 	cmpnei	zero,r16,18185
8011bee8:	8011c6c8 	cmpgei	zero,r16,18203
8011beec:	8011c468 	cmpgeui	zero,r16,18193
8011bef0:	8011c8e8 	cmpgeui	zero,r16,18211
8011bef4:	8011c9f8 	rdprs	zero,r16,18215
8011bef8:	8011c750 	cmplti	zero,r16,18205
8011befc:	8011cc38 	rdprs	zero,r16,18224
8011bf00:	8011c970 	cmpltui	zero,r16,18213
8011bf04:	8011cc38 	rdprs	zero,r16,18224
8011bf08:	8011c638 	rdprs	zero,r16,18200
8011bf0c:	8011c518 	cmpnei	zero,r16,18196
8011bf10:	8011c308 	cmpgei	zero,r16,18188
8011bf14:	8011c5a8 	cmpgeui	zero,r16,18198
8011bf18:	8011c0f8 	rdprs	zero,r16,18179
8011bf1c:	8011c3b8 	rdprs	zero,r16,18190
8011bf20:	8011c048 	cmpgei	zero,r16,18177
8011bf24:	8011c7d8 	cmpnei	zero,r16,18207
8011bf28:	8011c1a8 	cmpgeui	zero,r16,18182
8011bf2c:	8011bf98 	cmpnei	zero,r16,18174
8011bf30:	8011cac4 	addi	zero,r16,18219
8011bf34:	8011cc38 	rdprs	zero,r16,18224
8011bf38:	8011cc38 	rdprs	zero,r16,18224
8011bf3c:	8011cc38 	rdprs	zero,r16,18224
8011bf40:	8011cc38 	rdprs	zero,r16,18224
8011bf44:	8011c860 	cmpeqi	zero,r16,18209
8011bf48:	8011cb6c 	andhi	zero,r16,18221
					case 39:// single quote '
						c = cGetNextChar(siFile);
8011bf4c:	e0bff60f 	ldh	r2,-40(fp)
8011bf50:	1009883a 	mov	r4,r2
8011bf54:	011ef580 	call	8011ef58 <cGetNextChar>
8011bf58:	e0bff245 	stb	r2,-55(fp)
						while ( c != 39 ){
8011bf5c:	00000406 	br	8011bf70 <vLoadDebugConfs+0x264>
							c = cGetNextChar(siFile);
8011bf60:	e0bff60f 	ldh	r2,-40(fp)
8011bf64:	1009883a 	mov	r4,r2
8011bf68:	011ef580 	call	8011ef58 <cGetNextChar>
8011bf6c:	e0bff245 	stb	r2,-55(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8011bf70:	e0bff247 	ldb	r2,-55(fp)
8011bf74:	108009d8 	cmpnei	r2,r2,39
8011bf78:	103ff91e 	bne	r2,zero,8011bf60 <__reset+0xfa0fbf60>
							c = cGetNextChar(siFile);
						}
						break;
8011bf7c:	00032f06 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case -1: 	//EOF
						bEOF = TRUE;
8011bf80:	00800044 	movi	r2,1
8011bf84:	e0bff115 	stw	r2,-60(fp)
						break;
8011bf88:	00032c06 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case -2: 	//EOF
						#if DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
						#endif
						bEOF = TRUE;
8011bf8c:	00800044 	movi	r2,1
8011bf90:	e0bff115 	stw	r2,-60(fp)
						break;
8011bf94:	00032906 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
8011bf98:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011bf9c:	e0bff60f 	ldh	r2,-40(fp)
8011bfa0:	1009883a 	mov	r4,r2
8011bfa4:	011ef580 	call	8011ef58 <cGetNextChar>
8011bfa8:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011bfac:	d0e00317 	ldw	r3,-32756(gp)
8011bfb0:	e0bff247 	ldb	r2,-55(fp)
8011bfb4:	10800044 	addi	r2,r2,1
8011bfb8:	1885883a 	add	r2,r3,r2
8011bfbc:	10800003 	ldbu	r2,0(r2)
8011bfc0:	10803fcc 	andi	r2,r2,255
8011bfc4:	1080010c 	andi	r2,r2,4
8011bfc8:	10000626 	beq	r2,zero,8011bfe4 <vLoadDebugConfs+0x2d8>
									(*p_inteiro) = c;
8011bfcc:	e0bff317 	ldw	r2,-52(fp)
8011bfd0:	e0fff243 	ldbu	r3,-55(fp)
8011bfd4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011bfd8:	e0bff317 	ldw	r2,-52(fp)
8011bfdc:	10800044 	addi	r2,r2,1
8011bfe0:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011bfe4:	e0bff247 	ldb	r2,-55(fp)
8011bfe8:	10800ba0 	cmpeqi	r2,r2,46
8011bfec:	1000031e 	bne	r2,zero,8011bffc <vLoadDebugConfs+0x2f0>
8011bff0:	e0bff247 	ldb	r2,-55(fp)
8011bff4:	10800ed8 	cmpnei	r2,r2,59
8011bff8:	103fe81e 	bne	r2,zero,8011bf9c <__reset+0xfa0fbf9c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011bffc:	e0bff317 	ldw	r2,-52(fp)
8011c000:	00c00284 	movi	r3,10
8011c004:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = (unsigned short int)atoi( inteiro );
8011c008:	e0bff704 	addi	r2,fp,-36
8011c00c:	1009883a 	mov	r4,r2
8011c010:	01214340 	call	80121434 <atoi>
8011c014:	1007883a 	mov	r3,r2
8011c018:	00a005b4 	movhi	r2,32790
8011c01c:	10ba3604 	addi	r2,r2,-5928
8011c020:	10c0038d 	sth	r3,14(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011c024:	e0bff704 	addi	r2,fp,-36
8011c028:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011c02c:	e0bff203 	ldbu	r2,-56(fp)
8011c030:	10800044 	addi	r2,r2,1
8011c034:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011c038:	e0bff247 	ldb	r2,-55(fp)
8011c03c:	10800ed8 	cmpnei	r2,r2,59
8011c040:	103fd61e 	bne	r2,zero,8011bf9c <__reset+0xfa0fbf9c>

						break;
8011c044:	0002fd06 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'P':
						ucParser = 0;
8011c048:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011c04c:	e0bff60f 	ldh	r2,-40(fp)
8011c050:	1009883a 	mov	r4,r2
8011c054:	011ef580 	call	8011ef58 <cGetNextChar>
8011c058:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011c05c:	d0e00317 	ldw	r3,-32756(gp)
8011c060:	e0bff247 	ldb	r2,-55(fp)
8011c064:	10800044 	addi	r2,r2,1
8011c068:	1885883a 	add	r2,r3,r2
8011c06c:	10800003 	ldbu	r2,0(r2)
8011c070:	10803fcc 	andi	r2,r2,255
8011c074:	1080010c 	andi	r2,r2,4
8011c078:	10000626 	beq	r2,zero,8011c094 <vLoadDebugConfs+0x388>
									(*p_inteiro) = c;
8011c07c:	e0bff317 	ldw	r2,-52(fp)
8011c080:	e0fff243 	ldbu	r3,-55(fp)
8011c084:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011c088:	e0bff317 	ldw	r2,-52(fp)
8011c08c:	10800044 	addi	r2,r2,1
8011c090:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011c094:	e0bff247 	ldb	r2,-55(fp)
8011c098:	10800ba0 	cmpeqi	r2,r2,46
8011c09c:	1000031e 	bne	r2,zero,8011c0ac <vLoadDebugConfs+0x3a0>
8011c0a0:	e0bff247 	ldb	r2,-55(fp)
8011c0a4:	10800ed8 	cmpnei	r2,r2,59
8011c0a8:	103fe81e 	bne	r2,zero,8011c04c <__reset+0xfa0fc04c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c0ac:	e0bff317 	ldw	r2,-52(fp)
8011c0b0:	00c00284 	movi	r3,10
8011c0b4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = (unsigned short int)atoi( inteiro );
8011c0b8:	e0bff704 	addi	r2,fp,-36
8011c0bc:	1009883a 	mov	r4,r2
8011c0c0:	01214340 	call	80121434 <atoi>
8011c0c4:	1007883a 	mov	r3,r2
8011c0c8:	00a005b4 	movhi	r2,32790
8011c0cc:	10ba3604 	addi	r2,r2,-5928
8011c0d0:	10c0018d 	sth	r3,6(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011c0d4:	e0bff704 	addi	r2,fp,-36
8011c0d8:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011c0dc:	e0bff203 	ldbu	r2,-56(fp)
8011c0e0:	10800044 	addi	r2,r2,1
8011c0e4:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011c0e8:	e0bff247 	ldb	r2,-55(fp)
8011c0ec:	10800ed8 	cmpnei	r2,r2,59
8011c0f0:	103fd61e 	bne	r2,zero,8011c04c <__reset+0xfa0fc04c>

						break;
8011c0f4:	0002d106 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'N':
						ucParser = 0;
8011c0f8:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011c0fc:	e0bff60f 	ldh	r2,-40(fp)
8011c100:	1009883a 	mov	r4,r2
8011c104:	011ef580 	call	8011ef58 <cGetNextChar>
8011c108:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011c10c:	d0e00317 	ldw	r3,-32756(gp)
8011c110:	e0bff247 	ldb	r2,-55(fp)
8011c114:	10800044 	addi	r2,r2,1
8011c118:	1885883a 	add	r2,r3,r2
8011c11c:	10800003 	ldbu	r2,0(r2)
8011c120:	10803fcc 	andi	r2,r2,255
8011c124:	1080010c 	andi	r2,r2,4
8011c128:	10000626 	beq	r2,zero,8011c144 <vLoadDebugConfs+0x438>
									(*p_inteiro) = c;
8011c12c:	e0bff317 	ldw	r2,-52(fp)
8011c130:	e0fff243 	ldbu	r3,-55(fp)
8011c134:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011c138:	e0bff317 	ldw	r2,-52(fp)
8011c13c:	10800044 	addi	r2,r2,1
8011c140:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011c144:	e0bff247 	ldb	r2,-55(fp)
8011c148:	10800ba0 	cmpeqi	r2,r2,46
8011c14c:	1000031e 	bne	r2,zero,8011c15c <vLoadDebugConfs+0x450>
8011c150:	e0bff247 	ldb	r2,-55(fp)
8011c154:	10800ed8 	cmpnei	r2,r2,59
8011c158:	103fe81e 	bne	r2,zero,8011c0fc <__reset+0xfa0fc0fc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c15c:	e0bff317 	ldw	r2,-52(fp)
8011c160:	00c00284 	movi	r3,10
8011c164:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = (unsigned short int)atoi( inteiro );
8011c168:	e0bff704 	addi	r2,fp,-36
8011c16c:	1009883a 	mov	r4,r2
8011c170:	01214340 	call	80121434 <atoi>
8011c174:	1007883a 	mov	r3,r2
8011c178:	00a005b4 	movhi	r2,32790
8011c17c:	10ba3604 	addi	r2,r2,-5928
8011c180:	10c0010d 	sth	r3,4(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011c184:	e0bff704 	addi	r2,fp,-36
8011c188:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011c18c:	e0bff203 	ldbu	r2,-56(fp)
8011c190:	10800044 	addi	r2,r2,1
8011c194:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011c198:	e0bff247 	ldb	r2,-55(fp)
8011c19c:	10800ed8 	cmpnei	r2,r2,59
8011c1a0:	103fd61e 	bne	r2,zero,8011c0fc <__reset+0xfa0fc0fc>

						break;
8011c1a4:	0002a506 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'R':
						ucParser = 0;
8011c1a8:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011c1ac:	e0bff60f 	ldh	r2,-40(fp)
8011c1b0:	1009883a 	mov	r4,r2
8011c1b4:	011ef580 	call	8011ef58 <cGetNextChar>
8011c1b8:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011c1bc:	d0e00317 	ldw	r3,-32756(gp)
8011c1c0:	e0bff247 	ldb	r2,-55(fp)
8011c1c4:	10800044 	addi	r2,r2,1
8011c1c8:	1885883a 	add	r2,r3,r2
8011c1cc:	10800003 	ldbu	r2,0(r2)
8011c1d0:	10803fcc 	andi	r2,r2,255
8011c1d4:	1080010c 	andi	r2,r2,4
8011c1d8:	10000626 	beq	r2,zero,8011c1f4 <vLoadDebugConfs+0x4e8>
									(*p_inteiro) = c;
8011c1dc:	e0bff317 	ldw	r2,-52(fp)
8011c1e0:	e0fff243 	ldbu	r3,-55(fp)
8011c1e4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011c1e8:	e0bff317 	ldw	r2,-52(fp)
8011c1ec:	10800044 	addi	r2,r2,1
8011c1f0:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011c1f4:	e0bff247 	ldb	r2,-55(fp)
8011c1f8:	10800ba0 	cmpeqi	r2,r2,46
8011c1fc:	1000031e 	bne	r2,zero,8011c20c <vLoadDebugConfs+0x500>
8011c200:	e0bff247 	ldb	r2,-55(fp)
8011c204:	10800ed8 	cmpnei	r2,r2,59
8011c208:	103fe81e 	bne	r2,zero,8011c1ac <__reset+0xfa0fc1ac>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c20c:	e0bff317 	ldw	r2,-52(fp)
8011c210:	00c00284 	movi	r3,10
8011c214:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = (unsigned short int)atoi( inteiro );
8011c218:	e0bff704 	addi	r2,fp,-36
8011c21c:	1009883a 	mov	r4,r2
8011c220:	01214340 	call	80121434 <atoi>
8011c224:	1007883a 	mov	r3,r2
8011c228:	00a005b4 	movhi	r2,32790
8011c22c:	10ba3604 	addi	r2,r2,-5928
8011c230:	10c0080d 	sth	r3,32(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011c234:	e0bff704 	addi	r2,fp,-36
8011c238:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011c23c:	e0bff203 	ldbu	r2,-56(fp)
8011c240:	10800044 	addi	r2,r2,1
8011c244:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011c248:	e0bff247 	ldb	r2,-55(fp)
8011c24c:	10800ed8 	cmpnei	r2,r2,59
8011c250:	103fd61e 	bne	r2,zero,8011c1ac <__reset+0xfa0fc1ac>

						break;
8011c254:	00027906 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'A':
						ucParser = 0;
8011c258:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011c25c:	e0bff60f 	ldh	r2,-40(fp)
8011c260:	1009883a 	mov	r4,r2
8011c264:	011ef580 	call	8011ef58 <cGetNextChar>
8011c268:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011c26c:	d0e00317 	ldw	r3,-32756(gp)
8011c270:	e0bff247 	ldb	r2,-55(fp)
8011c274:	10800044 	addi	r2,r2,1
8011c278:	1885883a 	add	r2,r3,r2
8011c27c:	10800003 	ldbu	r2,0(r2)
8011c280:	10803fcc 	andi	r2,r2,255
8011c284:	1080010c 	andi	r2,r2,4
8011c288:	10000626 	beq	r2,zero,8011c2a4 <vLoadDebugConfs+0x598>
									(*p_inteiro) = c;
8011c28c:	e0bff317 	ldw	r2,-52(fp)
8011c290:	e0fff243 	ldbu	r3,-55(fp)
8011c294:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011c298:	e0bff317 	ldw	r2,-52(fp)
8011c29c:	10800044 	addi	r2,r2,1
8011c2a0:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011c2a4:	e0bff247 	ldb	r2,-55(fp)
8011c2a8:	10800ba0 	cmpeqi	r2,r2,46
8011c2ac:	1000031e 	bne	r2,zero,8011c2bc <vLoadDebugConfs+0x5b0>
8011c2b0:	e0bff247 	ldb	r2,-55(fp)
8011c2b4:	10800ed8 	cmpnei	r2,r2,59
8011c2b8:	103fe81e 	bne	r2,zero,8011c25c <__reset+0xfa0fc25c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c2bc:	e0bff317 	ldw	r2,-52(fp)
8011c2c0:	00c00284 	movi	r3,10
8011c2c4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = (unsigned short int)atoi( inteiro );
8011c2c8:	e0bff704 	addi	r2,fp,-36
8011c2cc:	1009883a 	mov	r4,r2
8011c2d0:	01214340 	call	80121434 <atoi>
8011c2d4:	1007883a 	mov	r3,r2
8011c2d8:	00a005b4 	movhi	r2,32790
8011c2dc:	10ba3604 	addi	r2,r2,-5928
8011c2e0:	10c0088d 	sth	r3,34(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011c2e4:	e0bff704 	addi	r2,fp,-36
8011c2e8:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011c2ec:	e0bff203 	ldbu	r2,-56(fp)
8011c2f0:	10800044 	addi	r2,r2,1
8011c2f4:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011c2f8:	e0bff247 	ldb	r2,-55(fp)
8011c2fc:	10800ed8 	cmpnei	r2,r2,59
8011c300:	103fd61e 	bne	r2,zero,8011c25c <__reset+0xfa0fc25c>

						break;
8011c304:	00024d06 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'L':
						ucParser = 0;
8011c308:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011c30c:	e0bff60f 	ldh	r2,-40(fp)
8011c310:	1009883a 	mov	r4,r2
8011c314:	011ef580 	call	8011ef58 <cGetNextChar>
8011c318:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011c31c:	d0e00317 	ldw	r3,-32756(gp)
8011c320:	e0bff247 	ldb	r2,-55(fp)
8011c324:	10800044 	addi	r2,r2,1
8011c328:	1885883a 	add	r2,r3,r2
8011c32c:	10800003 	ldbu	r2,0(r2)
8011c330:	10803fcc 	andi	r2,r2,255
8011c334:	1080010c 	andi	r2,r2,4
8011c338:	10000626 	beq	r2,zero,8011c354 <vLoadDebugConfs+0x648>
									(*p_inteiro) = c;
8011c33c:	e0bff317 	ldw	r2,-52(fp)
8011c340:	e0fff243 	ldbu	r3,-55(fp)
8011c344:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011c348:	e0bff317 	ldw	r2,-52(fp)
8011c34c:	10800044 	addi	r2,r2,1
8011c350:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011c354:	e0bff247 	ldb	r2,-55(fp)
8011c358:	10800ba0 	cmpeqi	r2,r2,46
8011c35c:	1000031e 	bne	r2,zero,8011c36c <vLoadDebugConfs+0x660>
8011c360:	e0bff247 	ldb	r2,-55(fp)
8011c364:	10800ed8 	cmpnei	r2,r2,59
8011c368:	103fe81e 	bne	r2,zero,8011c30c <__reset+0xfa0fc30c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c36c:	e0bff317 	ldw	r2,-52(fp)
8011c370:	00c00284 	movi	r3,10
8011c374:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = (unsigned short int)atoi( inteiro );
8011c378:	e0bff704 	addi	r2,fp,-36
8011c37c:	1009883a 	mov	r4,r2
8011c380:	01214340 	call	80121434 <atoi>
8011c384:	1007883a 	mov	r3,r2
8011c388:	00a005b4 	movhi	r2,32790
8011c38c:	10ba3604 	addi	r2,r2,-5928
8011c390:	10c0030d 	sth	r3,12(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011c394:	e0bff704 	addi	r2,fp,-36
8011c398:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011c39c:	e0bff203 	ldbu	r2,-56(fp)
8011c3a0:	10800044 	addi	r2,r2,1
8011c3a4:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011c3a8:	e0bff247 	ldb	r2,-55(fp)
8011c3ac:	10800ed8 	cmpnei	r2,r2,59
8011c3b0:	103fd61e 	bne	r2,zero,8011c30c <__reset+0xfa0fc30c>

						break;
8011c3b4:	00022106 	br	8011cc3c <vLoadDebugConfs+0xf30>

					case 'O':
						ucParser = 0;
8011c3b8:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011c3bc:	e0bff60f 	ldh	r2,-40(fp)
8011c3c0:	1009883a 	mov	r4,r2
8011c3c4:	011ef580 	call	8011ef58 <cGetNextChar>
8011c3c8:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011c3cc:	d0e00317 	ldw	r3,-32756(gp)
8011c3d0:	e0bff247 	ldb	r2,-55(fp)
8011c3d4:	10800044 	addi	r2,r2,1
8011c3d8:	1885883a 	add	r2,r3,r2
8011c3dc:	10800003 	ldbu	r2,0(r2)
8011c3e0:	10803fcc 	andi	r2,r2,255
8011c3e4:	1080010c 	andi	r2,r2,4
8011c3e8:	10000626 	beq	r2,zero,8011c404 <vLoadDebugConfs+0x6f8>
									(*p_inteiro) = c;
8011c3ec:	e0bff317 	ldw	r2,-52(fp)
8011c3f0:	e0fff243 	ldbu	r3,-55(fp)
8011c3f4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011c3f8:	e0bff317 	ldw	r2,-52(fp)
8011c3fc:	10800044 	addi	r2,r2,1
8011c400:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011c404:	e0bff247 	ldb	r2,-55(fp)
8011c408:	10800ba0 	cmpeqi	r2,r2,46
8011c40c:	1000031e 	bne	r2,zero,8011c41c <vLoadDebugConfs+0x710>
8011c410:	e0bff247 	ldb	r2,-55(fp)
8011c414:	10800ed8 	cmpnei	r2,r2,59
8011c418:	103fe81e 	bne	r2,zero,8011c3bc <__reset+0xfa0fc3bc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c41c:	e0bff317 	ldw	r2,-52(fp)
8011c420:	00c00284 	movi	r3,10
8011c424:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = (unsigned short int)atoi( inteiro );
8011c428:	e0bff704 	addi	r2,fp,-36
8011c42c:	1009883a 	mov	r4,r2
8011c430:	01214340 	call	80121434 <atoi>
8011c434:	1007883a 	mov	r3,r2
8011c438:	00a005b4 	movhi	r2,32790
8011c43c:	10ba3604 	addi	r2,r2,-5928
8011c440:	10c0020d 	sth	r3,8(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011c444:	e0bff704 	addi	r2,fp,-36
8011c448:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011c44c:	e0bff203 	ldbu	r2,-56(fp)
8011c450:	10800044 	addi	r2,r2,1
8011c454:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011c458:	e0bff247 	ldb	r2,-55(fp)
8011c45c:	10800ed8 	cmpnei	r2,r2,59
8011c460:	103fd61e 	bne	r2,zero,8011c3bc <__reset+0xfa0fc3bc>

						break;
8011c464:	0001f506 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'C':
						ucParser = 0;
8011c468:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011c46c:	e0bff60f 	ldh	r2,-40(fp)
8011c470:	1009883a 	mov	r4,r2
8011c474:	011ef580 	call	8011ef58 <cGetNextChar>
8011c478:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011c47c:	d0e00317 	ldw	r3,-32756(gp)
8011c480:	e0bff247 	ldb	r2,-55(fp)
8011c484:	10800044 	addi	r2,r2,1
8011c488:	1885883a 	add	r2,r3,r2
8011c48c:	10800003 	ldbu	r2,0(r2)
8011c490:	10803fcc 	andi	r2,r2,255
8011c494:	1080010c 	andi	r2,r2,4
8011c498:	10000626 	beq	r2,zero,8011c4b4 <vLoadDebugConfs+0x7a8>
									(*p_inteiro) = c;
8011c49c:	e0bff317 	ldw	r2,-52(fp)
8011c4a0:	e0fff243 	ldbu	r3,-55(fp)
8011c4a4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011c4a8:	e0bff317 	ldw	r2,-52(fp)
8011c4ac:	10800044 	addi	r2,r2,1
8011c4b0:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011c4b4:	e0bff247 	ldb	r2,-55(fp)
8011c4b8:	10800ba0 	cmpeqi	r2,r2,46
8011c4bc:	1000031e 	bne	r2,zero,8011c4cc <vLoadDebugConfs+0x7c0>
8011c4c0:	e0bff247 	ldb	r2,-55(fp)
8011c4c4:	10800ed8 	cmpnei	r2,r2,59
8011c4c8:	103fe81e 	bne	r2,zero,8011c46c <__reset+0xfa0fc46c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c4cc:	e0bff317 	ldw	r2,-52(fp)
8011c4d0:	00c00284 	movi	r3,10
8011c4d4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = (unsigned short int)atoi( inteiro );
8011c4d8:	e0bff704 	addi	r2,fp,-36
8011c4dc:	1009883a 	mov	r4,r2
8011c4e0:	01214340 	call	80121434 <atoi>
8011c4e4:	1007883a 	mov	r3,r2
8011c4e8:	00a005b4 	movhi	r2,32790
8011c4ec:	10ba3604 	addi	r2,r2,-5928
8011c4f0:	10c0028d 	sth	r3,10(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011c4f4:	e0bff704 	addi	r2,fp,-36
8011c4f8:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011c4fc:	e0bff203 	ldbu	r2,-56(fp)
8011c500:	10800044 	addi	r2,r2,1
8011c504:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011c508:	e0bff247 	ldb	r2,-55(fp)
8011c50c:	10800ed8 	cmpnei	r2,r2,59
8011c510:	103fd61e 	bne	r2,zero,8011c46c <__reset+0xfa0fc46c>

						break;
8011c514:	0001c906 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8011c518:	e0bff60f 	ldh	r2,-40(fp)
8011c51c:	1009883a 	mov	r4,r2
8011c520:	011ef580 	call	8011ef58 <cGetNextChar>
8011c524:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c528:	d0e00317 	ldw	r3,-32756(gp)
8011c52c:	e0bff247 	ldb	r2,-55(fp)
8011c530:	10800044 	addi	r2,r2,1
8011c534:	1885883a 	add	r2,r3,r2
8011c538:	10800003 	ldbu	r2,0(r2)
8011c53c:	10803fcc 	andi	r2,r2,255
8011c540:	1080010c 	andi	r2,r2,4
8011c544:	10000626 	beq	r2,zero,8011c560 <vLoadDebugConfs+0x854>
								(*p_inteiroll) = c;
8011c548:	e0bff417 	ldw	r2,-48(fp)
8011c54c:	e0fff243 	ldbu	r3,-55(fp)
8011c550:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8011c554:	e0bff417 	ldw	r2,-48(fp)
8011c558:	10800044 	addi	r2,r2,1
8011c55c:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c560:	e0bff247 	ldb	r2,-55(fp)
8011c564:	10800ed8 	cmpnei	r2,r2,59
8011c568:	103feb1e 	bne	r2,zero,8011c518 <__reset+0xfa0fc518>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c56c:	e0bff417 	ldw	r2,-48(fp)
8011c570:	00c00284 	movi	r3,10
8011c574:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = (unsigned long)atoll( inteiroll );
8011c578:	e0bff904 	addi	r2,fp,-28
8011c57c:	1009883a 	mov	r4,r2
8011c580:	012144c0 	call	8012144c <atoll>
8011c584:	1009883a 	mov	r4,r2
8011c588:	180b883a 	mov	r5,r3
8011c58c:	2007883a 	mov	r3,r4
8011c590:	00a005b4 	movhi	r2,32790
8011c594:	10ba3604 	addi	r2,r2,-5928
8011c598:	10c00615 	stw	r3,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8011c59c:	e0bff904 	addi	r2,fp,-28
8011c5a0:	e0bff415 	stw	r2,-48(fp)

						break;
8011c5a4:	0001a506 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8011c5a8:	e0bff60f 	ldh	r2,-40(fp)
8011c5ac:	1009883a 	mov	r4,r2
8011c5b0:	011ef580 	call	8011ef58 <cGetNextChar>
8011c5b4:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c5b8:	d0e00317 	ldw	r3,-32756(gp)
8011c5bc:	e0bff247 	ldb	r2,-55(fp)
8011c5c0:	10800044 	addi	r2,r2,1
8011c5c4:	1885883a 	add	r2,r3,r2
8011c5c8:	10800003 	ldbu	r2,0(r2)
8011c5cc:	10803fcc 	andi	r2,r2,255
8011c5d0:	1080010c 	andi	r2,r2,4
8011c5d4:	10000626 	beq	r2,zero,8011c5f0 <vLoadDebugConfs+0x8e4>
								(*p_inteiroll) = c;
8011c5d8:	e0bff417 	ldw	r2,-48(fp)
8011c5dc:	e0fff243 	ldbu	r3,-55(fp)
8011c5e0:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8011c5e4:	e0bff417 	ldw	r2,-48(fp)
8011c5e8:	10800044 	addi	r2,r2,1
8011c5ec:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c5f0:	e0bff247 	ldb	r2,-55(fp)
8011c5f4:	10800ed8 	cmpnei	r2,r2,59
8011c5f8:	103feb1e 	bne	r2,zero,8011c5a8 <__reset+0xfa0fc5a8>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c5fc:	e0bff417 	ldw	r2,-48(fp)
8011c600:	00c00284 	movi	r3,10
8011c604:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = (unsigned long)atoll( inteiroll );
8011c608:	e0bff904 	addi	r2,fp,-28
8011c60c:	1009883a 	mov	r4,r2
8011c610:	012144c0 	call	8012144c <atoll>
8011c614:	1009883a 	mov	r4,r2
8011c618:	180b883a 	mov	r5,r3
8011c61c:	2007883a 	mov	r3,r4
8011c620:	00a005b4 	movhi	r2,32790
8011c624:	10ba3604 	addi	r2,r2,-5928
8011c628:	10c00715 	stw	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8011c62c:	e0bff904 	addi	r2,fp,-28
8011c630:	e0bff415 	stw	r2,-48(fp)

						break;
8011c634:	00018106 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8011c638:	e0bff60f 	ldh	r2,-40(fp)
8011c63c:	1009883a 	mov	r4,r2
8011c640:	011ef580 	call	8011ef58 <cGetNextChar>
8011c644:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c648:	d0e00317 	ldw	r3,-32756(gp)
8011c64c:	e0bff247 	ldb	r2,-55(fp)
8011c650:	10800044 	addi	r2,r2,1
8011c654:	1885883a 	add	r2,r3,r2
8011c658:	10800003 	ldbu	r2,0(r2)
8011c65c:	10803fcc 	andi	r2,r2,255
8011c660:	1080010c 	andi	r2,r2,4
8011c664:	10000626 	beq	r2,zero,8011c680 <vLoadDebugConfs+0x974>
								(*p_inteiroll) = c;
8011c668:	e0bff417 	ldw	r2,-48(fp)
8011c66c:	e0fff243 	ldbu	r3,-55(fp)
8011c670:	10c00005 	stb	r3,0(r2)
								p_inteiroll++;
8011c674:	e0bff417 	ldw	r2,-48(fp)
8011c678:	10800044 	addi	r2,r2,1
8011c67c:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c680:	e0bff247 	ldb	r2,-55(fp)
8011c684:	10800ed8 	cmpnei	r2,r2,59
8011c688:	103feb1e 	bne	r2,zero,8011c638 <__reset+0xfa0fc638>
						(*p_inteiroll) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c68c:	e0bff417 	ldw	r2,-48(fp)
8011c690:	00c00284 	movi	r3,10
8011c694:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = (unsigned long)atoll( inteiroll );
8011c698:	e0bff904 	addi	r2,fp,-28
8011c69c:	1009883a 	mov	r4,r2
8011c6a0:	012144c0 	call	8012144c <atoll>
8011c6a4:	1009883a 	mov	r4,r2
8011c6a8:	180b883a 	mov	r5,r3
8011c6ac:	2007883a 	mov	r3,r4
8011c6b0:	00a005b4 	movhi	r2,32790
8011c6b4:	10ba3604 	addi	r2,r2,-5928
8011c6b8:	10c00515 	stw	r3,20(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiroll = inteiroll;
8011c6bc:	e0bff904 	addi	r2,fp,-28
8011c6c0:	e0bff415 	stw	r2,-48(fp)

						break;
8011c6c4:	00015d06 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'B':

						do {
							c = cGetNextChar(siFile);
8011c6c8:	e0bff60f 	ldh	r2,-40(fp)
8011c6cc:	1009883a 	mov	r4,r2
8011c6d0:	011ef580 	call	8011ef58 <cGetNextChar>
8011c6d4:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c6d8:	d0e00317 	ldw	r3,-32756(gp)
8011c6dc:	e0bff247 	ldb	r2,-55(fp)
8011c6e0:	10800044 	addi	r2,r2,1
8011c6e4:	1885883a 	add	r2,r3,r2
8011c6e8:	10800003 	ldbu	r2,0(r2)
8011c6ec:	10803fcc 	andi	r2,r2,255
8011c6f0:	1080010c 	andi	r2,r2,4
8011c6f4:	10000626 	beq	r2,zero,8011c710 <vLoadDebugConfs+0xa04>
								(*p_inteiro) = c;
8011c6f8:	e0bff317 	ldw	r2,-52(fp)
8011c6fc:	e0fff243 	ldbu	r3,-55(fp)
8011c700:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011c704:	e0bff317 	ldw	r2,-52(fp)
8011c708:	10800044 	addi	r2,r2,1
8011c70c:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c710:	e0bff247 	ldb	r2,-55(fp)
8011c714:	10800ed8 	cmpnei	r2,r2,59
8011c718:	103feb1e 	bne	r2,zero,8011c6c8 <__reset+0xfa0fc6c8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c71c:	e0bff317 	ldw	r2,-52(fp)
8011c720:	00c00284 	movi	r3,10
8011c724:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiLinkNFEE0 = (unsigned short int)atoi( inteiro );
8011c728:	e0bff704 	addi	r2,fp,-36
8011c72c:	1009883a 	mov	r4,r2
8011c730:	01214340 	call	80121434 <atoi>
8011c734:	1007883a 	mov	r3,r2
8011c738:	00a005b4 	movhi	r2,32790
8011c73c:	10ba3604 	addi	r2,r2,-5928
8011c740:	10c00a0d 	sth	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011c744:	e0bff704 	addi	r2,fp,-36
8011c748:	e0bff315 	stw	r2,-52(fp)

						break;
8011c74c:	00013b06 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'F':

						do {
							c = cGetNextChar(siFile);
8011c750:	e0bff60f 	ldh	r2,-40(fp)
8011c754:	1009883a 	mov	r4,r2
8011c758:	011ef580 	call	8011ef58 <cGetNextChar>
8011c75c:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c760:	d0e00317 	ldw	r3,-32756(gp)
8011c764:	e0bff247 	ldb	r2,-55(fp)
8011c768:	10800044 	addi	r2,r2,1
8011c76c:	1885883a 	add	r2,r3,r2
8011c770:	10800003 	ldbu	r2,0(r2)
8011c774:	10803fcc 	andi	r2,r2,255
8011c778:	1080010c 	andi	r2,r2,4
8011c77c:	10000626 	beq	r2,zero,8011c798 <vLoadDebugConfs+0xa8c>
								(*p_inteiro) = c;
8011c780:	e0bff317 	ldw	r2,-52(fp)
8011c784:	e0fff243 	ldbu	r3,-55(fp)
8011c788:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011c78c:	e0bff317 	ldw	r2,-52(fp)
8011c790:	10800044 	addi	r2,r2,1
8011c794:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c798:	e0bff247 	ldb	r2,-55(fp)
8011c79c:	10800ed8 	cmpnei	r2,r2,59
8011c7a0:	103feb1e 	bne	r2,zero,8011c750 <__reset+0xfa0fc750>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c7a4:	e0bff317 	ldw	r2,-52(fp)
8011c7a8:	00c00284 	movi	r3,10
8011c7ac:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDebugLevel = (unsigned short int)atoi( inteiro );
8011c7b0:	e0bff704 	addi	r2,fp,-36
8011c7b4:	1009883a 	mov	r4,r2
8011c7b8:	01214340 	call	80121434 <atoi>
8011c7bc:	1007883a 	mov	r3,r2
8011c7c0:	00a005b4 	movhi	r2,32790
8011c7c4:	10ba3604 	addi	r2,r2,-5928
8011c7c8:	10c00a8d 	sth	r3,42(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011c7cc:	e0bff704 	addi	r2,fp,-36
8011c7d0:	e0bff315 	stw	r2,-52(fp)

						break;
8011c7d4:	00011906 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'Q':

						do {
							c = cGetNextChar(siFile);
8011c7d8:	e0bff60f 	ldh	r2,-40(fp)
8011c7dc:	1009883a 	mov	r4,r2
8011c7e0:	011ef580 	call	8011ef58 <cGetNextChar>
8011c7e4:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c7e8:	d0e00317 	ldw	r3,-32756(gp)
8011c7ec:	e0bff247 	ldb	r2,-55(fp)
8011c7f0:	10800044 	addi	r2,r2,1
8011c7f4:	1885883a 	add	r2,r3,r2
8011c7f8:	10800003 	ldbu	r2,0(r2)
8011c7fc:	10803fcc 	andi	r2,r2,255
8011c800:	1080010c 	andi	r2,r2,4
8011c804:	10000626 	beq	r2,zero,8011c820 <vLoadDebugConfs+0xb14>
								(*p_inteiro) = c;
8011c808:	e0bff317 	ldw	r2,-52(fp)
8011c80c:	e0fff243 	ldbu	r3,-55(fp)
8011c810:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011c814:	e0bff317 	ldw	r2,-52(fp)
8011c818:	10800044 	addi	r2,r2,1
8011c81c:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c820:	e0bff247 	ldb	r2,-55(fp)
8011c824:	10800ed8 	cmpnei	r2,r2,59
8011c828:	103feb1e 	bne	r2,zero,8011c7d8 <__reset+0xfa0fc7d8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c82c:	e0bff317 	ldw	r2,-52(fp)
8011c830:	00c00284 	movi	r3,10
8011c834:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiPatternType = (unsigned short int)atoi( inteiro );
8011c838:	e0bff704 	addi	r2,fp,-36
8011c83c:	1009883a 	mov	r4,r2
8011c840:	01214340 	call	80121434 <atoi>
8011c844:	1007883a 	mov	r3,r2
8011c848:	00a005b4 	movhi	r2,32790
8011c84c:	10ba3604 	addi	r2,r2,-5928
8011c850:	10c00b0d 	sth	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011c854:	e0bff704 	addi	r2,fp,-36
8011c858:	e0bff315 	stw	r2,-52(fp)

						break;
8011c85c:	0000f706 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'Y':

						do {
							c = cGetNextChar(siFile);
8011c860:	e0bff60f 	ldh	r2,-40(fp)
8011c864:	1009883a 	mov	r4,r2
8011c868:	011ef580 	call	8011ef58 <cGetNextChar>
8011c86c:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c870:	d0e00317 	ldw	r3,-32756(gp)
8011c874:	e0bff247 	ldb	r2,-55(fp)
8011c878:	10800044 	addi	r2,r2,1
8011c87c:	1885883a 	add	r2,r3,r2
8011c880:	10800003 	ldbu	r2,0(r2)
8011c884:	10803fcc 	andi	r2,r2,255
8011c888:	1080010c 	andi	r2,r2,4
8011c88c:	10000626 	beq	r2,zero,8011c8a8 <vLoadDebugConfs+0xb9c>
								(*p_inteiro) = c;
8011c890:	e0bff317 	ldw	r2,-52(fp)
8011c894:	e0fff243 	ldbu	r3,-55(fp)
8011c898:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011c89c:	e0bff317 	ldw	r2,-52(fp)
8011c8a0:	10800044 	addi	r2,r2,1
8011c8a4:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c8a8:	e0bff247 	ldb	r2,-55(fp)
8011c8ac:	10800ed8 	cmpnei	r2,r2,59
8011c8b0:	103feb1e 	bne	r2,zero,8011c860 <__reset+0xfa0fc860>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c8b4:	e0bff317 	ldw	r2,-52(fp)
8011c8b8:	00c00284 	movi	r3,10
8011c8bc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiGuardNFEEDelay = (unsigned short int)atoi( inteiro );
8011c8c0:	e0bff704 	addi	r2,fp,-36
8011c8c4:	1009883a 	mov	r4,r2
8011c8c8:	01214340 	call	80121434 <atoi>
8011c8cc:	1007883a 	mov	r3,r2
8011c8d0:	00a005b4 	movhi	r2,32790
8011c8d4:	10ba3604 	addi	r2,r2,-5928
8011c8d8:	10c00b8d 	sth	r3,46(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011c8dc:	e0bff704 	addi	r2,fp,-36
8011c8e0:	e0bff315 	stw	r2,-52(fp)

						break;
8011c8e4:	0000d506 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'D':

						do {
							c = cGetNextChar(siFile);
8011c8e8:	e0bff60f 	ldh	r2,-40(fp)
8011c8ec:	1009883a 	mov	r4,r2
8011c8f0:	011ef580 	call	8011ef58 <cGetNextChar>
8011c8f4:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c8f8:	d0e00317 	ldw	r3,-32756(gp)
8011c8fc:	e0bff247 	ldb	r2,-55(fp)
8011c900:	10800044 	addi	r2,r2,1
8011c904:	1885883a 	add	r2,r3,r2
8011c908:	10800003 	ldbu	r2,0(r2)
8011c90c:	10803fcc 	andi	r2,r2,255
8011c910:	1080010c 	andi	r2,r2,4
8011c914:	10000626 	beq	r2,zero,8011c930 <vLoadDebugConfs+0xc24>
								(*p_inteiro) = c;
8011c918:	e0bff317 	ldw	r2,-52(fp)
8011c91c:	e0fff243 	ldbu	r3,-55(fp)
8011c920:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011c924:	e0bff317 	ldw	r2,-52(fp)
8011c928:	10800044 	addi	r2,r2,1
8011c92c:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c930:	e0bff247 	ldb	r2,-55(fp)
8011c934:	10800ed8 	cmpnei	r2,r2,59
8011c938:	103feb1e 	bne	r2,zero,8011c8e8 <__reset+0xfa0fc8e8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c93c:	e0bff317 	ldw	r2,-52(fp)
8011c940:	00c00284 	movi	r3,10
8011c944:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDataProtId = (unsigned short int)atoi( inteiro );
8011c948:	e0bff704 	addi	r2,fp,-36
8011c94c:	1009883a 	mov	r4,r2
8011c950:	01214340 	call	80121434 <atoi>
8011c954:	1007883a 	mov	r3,r2
8011c958:	00a005b4 	movhi	r2,32790
8011c95c:	10ba3604 	addi	r2,r2,-5928
8011c960:	10c00c0d 	sth	r3,48(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011c964:	e0bff704 	addi	r2,fp,-36
8011c968:	e0bff315 	stw	r2,-52(fp)

						break;
8011c96c:	0000b306 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8011c970:	e0bff60f 	ldh	r2,-40(fp)
8011c974:	1009883a 	mov	r4,r2
8011c978:	011ef580 	call	8011ef58 <cGetNextChar>
8011c97c:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011c980:	d0e00317 	ldw	r3,-32756(gp)
8011c984:	e0bff247 	ldb	r2,-55(fp)
8011c988:	10800044 	addi	r2,r2,1
8011c98c:	1885883a 	add	r2,r3,r2
8011c990:	10800003 	ldbu	r2,0(r2)
8011c994:	10803fcc 	andi	r2,r2,255
8011c998:	1080010c 	andi	r2,r2,4
8011c99c:	10000626 	beq	r2,zero,8011c9b8 <vLoadDebugConfs+0xcac>
								(*p_inteiro) = c;
8011c9a0:	e0bff317 	ldw	r2,-52(fp)
8011c9a4:	e0fff243 	ldbu	r3,-55(fp)
8011c9a8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011c9ac:	e0bff317 	ldw	r2,-52(fp)
8011c9b0:	10800044 	addi	r2,r2,1
8011c9b4:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011c9b8:	e0bff247 	ldb	r2,-55(fp)
8011c9bc:	10800ed8 	cmpnei	r2,r2,59
8011c9c0:	103feb1e 	bne	r2,zero,8011c970 <__reset+0xfa0fc970>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011c9c4:	e0bff317 	ldw	r2,-52(fp)
8011c9c8:	00c00284 	movi	r3,10
8011c9cc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDpuLogicalAddr = (unsigned short int)atoi( inteiro );
8011c9d0:	e0bff704 	addi	r2,fp,-36
8011c9d4:	1009883a 	mov	r4,r2
8011c9d8:	01214340 	call	80121434 <atoi>
8011c9dc:	1007883a 	mov	r3,r2
8011c9e0:	00a005b4 	movhi	r2,32790
8011c9e4:	10ba3604 	addi	r2,r2,-5928
8011c9e8:	10c00c8d 	sth	r3,50(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011c9ec:	e0bff704 	addi	r2,fp,-36
8011c9f0:	e0bff315 	stw	r2,-52(fp)

						break;
8011c9f4:	00009106 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'E':

						ucParser = 0;
8011c9f8:	e03ff205 	stb	zero,-56(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8011c9fc:	e0bff60f 	ldh	r2,-40(fp)
8011ca00:	1009883a 	mov	r4,r2
8011ca04:	011ef580 	call	8011ef58 <cGetNextChar>
8011ca08:	e0bff245 	stb	r2,-55(fp)
								if ( isdigit( c ) ) {
8011ca0c:	d0e00317 	ldw	r3,-32756(gp)
8011ca10:	e0bff247 	ldb	r2,-55(fp)
8011ca14:	10800044 	addi	r2,r2,1
8011ca18:	1885883a 	add	r2,r3,r2
8011ca1c:	10800003 	ldbu	r2,0(r2)
8011ca20:	10803fcc 	andi	r2,r2,255
8011ca24:	1080010c 	andi	r2,r2,4
8011ca28:	10000626 	beq	r2,zero,8011ca44 <vLoadDebugConfs+0xd38>
									(*p_inteiro) = c;
8011ca2c:	e0bff317 	ldw	r2,-52(fp)
8011ca30:	e0fff243 	ldbu	r3,-55(fp)
8011ca34:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8011ca38:	e0bff317 	ldw	r2,-52(fp)
8011ca3c:	10800044 	addi	r2,r2,1
8011ca40:	e0bff315 	stw	r2,-52(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8011ca44:	e0bff247 	ldb	r2,-55(fp)
8011ca48:	10800ba0 	cmpeqi	r2,r2,46
8011ca4c:	1000031e 	bne	r2,zero,8011ca5c <vLoadDebugConfs+0xd50>
8011ca50:	e0bff247 	ldb	r2,-55(fp)
8011ca54:	10800ed8 	cmpnei	r2,r2,59
8011ca58:	103fe81e 	bne	r2,zero,8011c9fc <__reset+0xfa0fc9fc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011ca5c:	e0bff317 	ldw	r2,-52(fp)
8011ca60:	00c00284 	movi	r3,10
8011ca64:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucReadOutOrder[min_sim(ucParser,3)] = (unsigned char)atoi( inteiro );
8011ca68:	e0bff203 	ldbu	r2,-56(fp)
8011ca6c:	108000e8 	cmpgeui	r2,r2,3
8011ca70:	1000021e 	bne	r2,zero,8011ca7c <vLoadDebugConfs+0xd70>
8011ca74:	e43ff203 	ldbu	r16,-56(fp)
8011ca78:	00000106 	br	8011ca80 <vLoadDebugConfs+0xd74>
8011ca7c:	040000c4 	movi	r16,3
8011ca80:	e0bff704 	addi	r2,fp,-36
8011ca84:	1009883a 	mov	r4,r2
8011ca88:	01214340 	call	80121434 <atoi>
8011ca8c:	1007883a 	mov	r3,r2
8011ca90:	00a005b4 	movhi	r2,32790
8011ca94:	10ba3604 	addi	r2,r2,-5928
8011ca98:	1405883a 	add	r2,r2,r16
8011ca9c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8011caa0:	e0bff704 	addi	r2,fp,-36
8011caa4:	e0bff315 	stw	r2,-52(fp)
							ucParser++;
8011caa8:	e0bff203 	ldbu	r2,-56(fp)
8011caac:	10800044 	addi	r2,r2,1
8011cab0:	e0bff205 	stb	r2,-56(fp)
						} while ( (c !=59) );
8011cab4:	e0bff247 	ldb	r2,-55(fp)
8011cab8:	10800ed8 	cmpnei	r2,r2,59
8011cabc:	103fcf1e 	bne	r2,zero,8011c9fc <__reset+0xfa0fc9fc>

						break;
8011cac0:	00005e06 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8011cac4:	e0bff60f 	ldh	r2,-40(fp)
8011cac8:	1009883a 	mov	r4,r2
8011cacc:	011ef580 	call	8011ef58 <cGetNextChar>
8011cad0:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011cad4:	d0e00317 	ldw	r3,-32756(gp)
8011cad8:	e0bff247 	ldb	r2,-55(fp)
8011cadc:	10800044 	addi	r2,r2,1
8011cae0:	1885883a 	add	r2,r3,r2
8011cae4:	10800003 	ldbu	r2,0(r2)
8011cae8:	10803fcc 	andi	r2,r2,255
8011caec:	1080010c 	andi	r2,r2,4
8011caf0:	10000626 	beq	r2,zero,8011cb0c <vLoadDebugConfs+0xe00>
								(*p_inteiro) = c;
8011caf4:	e0bff317 	ldw	r2,-52(fp)
8011caf8:	e0fff243 	ldbu	r3,-55(fp)
8011cafc:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011cb00:	e0bff317 	ldw	r2,-52(fp)
8011cb04:	10800044 	addi	r2,r2,1
8011cb08:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011cb0c:	e0bff247 	ldb	r2,-55(fp)
8011cb10:	10800ed8 	cmpnei	r2,r2,59
8011cb14:	103feb1e 	bne	r2,zero,8011cac4 <__reset+0xfa0fcac4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011cb18:	e0bff317 	ldw	r2,-52(fp)
8011cb1c:	00c00284 	movi	r3,10
8011cb20:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8011cb24:	e0bff704 	addi	r2,fp,-36
8011cb28:	1009883a 	mov	r4,r2
8011cb2c:	01214340 	call	80121434 <atoi>
8011cb30:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8011cb34:	e0bff68f 	ldh	r2,-38(fp)
8011cb38:	10800058 	cmpnei	r2,r2,1
8011cb3c:	1000051e 	bne	r2,zero,8011cb54 <vLoadDebugConfs+0xe48>
							xDefaults.bDataPacket = TRUE;
8011cb40:	00a005b4 	movhi	r2,32790
8011cb44:	10ba3604 	addi	r2,r2,-5928
8011cb48:	00c00044 	movi	r3,1
8011cb4c:	10c00415 	stw	r3,16(r2)
8011cb50:	00000306 	br	8011cb60 <vLoadDebugConfs+0xe54>
						else
							xDefaults.bDataPacket = FALSE;
8011cb54:	00a005b4 	movhi	r2,32790
8011cb58:	10ba3604 	addi	r2,r2,-5928
8011cb5c:	10000415 	stw	zero,16(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011cb60:	e0bff704 	addi	r2,fp,-36
8011cb64:	e0bff315 	stw	r2,-52(fp)

						break;
8011cb68:	00003406 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 'Z':

						do {
							c = cGetNextChar(siFile);
8011cb6c:	e0bff60f 	ldh	r2,-40(fp)
8011cb70:	1009883a 	mov	r4,r2
8011cb74:	011ef580 	call	8011ef58 <cGetNextChar>
8011cb78:	e0bff245 	stb	r2,-55(fp)
							if ( isdigit( c ) ) {
8011cb7c:	d0e00317 	ldw	r3,-32756(gp)
8011cb80:	e0bff247 	ldb	r2,-55(fp)
8011cb84:	10800044 	addi	r2,r2,1
8011cb88:	1885883a 	add	r2,r3,r2
8011cb8c:	10800003 	ldbu	r2,0(r2)
8011cb90:	10803fcc 	andi	r2,r2,255
8011cb94:	1080010c 	andi	r2,r2,4
8011cb98:	10000626 	beq	r2,zero,8011cbb4 <vLoadDebugConfs+0xea8>
								(*p_inteiro) = c;
8011cb9c:	e0bff317 	ldw	r2,-52(fp)
8011cba0:	e0fff243 	ldbu	r3,-55(fp)
8011cba4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8011cba8:	e0bff317 	ldw	r2,-52(fp)
8011cbac:	10800044 	addi	r2,r2,1
8011cbb0:	e0bff315 	stw	r2,-52(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8011cbb4:	e0bff247 	ldb	r2,-55(fp)
8011cbb8:	10800ed8 	cmpnei	r2,r2,59
8011cbbc:	103feb1e 	bne	r2,zero,8011cb6c <__reset+0xfa0fcb6c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8011cbc0:	e0bff317 	ldw	r2,-52(fp)
8011cbc4:	00c00284 	movi	r3,10
8011cbc8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8011cbcc:	e0bff704 	addi	r2,fp,-36
8011cbd0:	1009883a 	mov	r4,r2
8011cbd4:	01214340 	call	80121434 <atoi>
8011cbd8:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
8011cbdc:	e0bff68f 	ldh	r2,-38(fp)
8011cbe0:	10800058 	cmpnei	r2,r2,1
8011cbe4:	1000051e 	bne	r2,zero,8011cbfc <vLoadDebugConfs+0xef0>
							xDefaults.bOneShot = TRUE;
8011cbe8:	00a005b4 	movhi	r2,32790
8011cbec:	10ba3604 	addi	r2,r2,-5928
8011cbf0:	00c00044 	movi	r3,1
8011cbf4:	10c00915 	stw	r3,36(r2)
8011cbf8:	00000306 	br	8011cc08 <vLoadDebugConfs+0xefc>
						else
							xDefaults.bOneShot = FALSE;
8011cbfc:	00a005b4 	movhi	r2,32790
8011cc00:	10ba3604 	addi	r2,r2,-5928
8011cc04:	10000915 	stw	zero,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8011cc08:	e0bff704 	addi	r2,fp,-36
8011cc0c:	e0bff315 	stw	r2,-52(fp)

						break;
8011cc10:	00000a06 	br	8011cc3c <vLoadDebugConfs+0xf30>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8011cc14:	e0bff60f 	ldh	r2,-40(fp)
8011cc18:	1009883a 	mov	r4,r2
8011cc1c:	011ef180 	call	8011ef18 <siCloseFile>
8011cc20:	e0bff515 	stw	r2,-44(fp)
							#if DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8011cc24:	00800044 	movi	r2,1
8011cc28:	e0bff115 	stw	r2,-60(fp)
						bSuccess = TRUE; //pensar melhor
8011cc2c:	00800044 	movi	r2,1
8011cc30:	e0bff015 	stw	r2,-64(fp)
						break;
8011cc34:	00000106 	br	8011cc3c <vLoadDebugConfs+0xf30>
					default:
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser. (%hhu)\n",c);
						#endif
						break;
8011cc38:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
8011cc3c:	e0bff117 	ldw	r2,-60(fp)
8011cc40:	103c5726 	beq	r2,zero,8011bda0 <__reset+0xfa0fbda0>
	if ( bSuccess == FALSE ) {
		/* Load default? */

	}

	return bSuccess;
8011cc44:	e0bff017 	ldw	r2,-64(fp)
}
8011cc48:	e6ffff04 	addi	sp,fp,-4
8011cc4c:	dfc00217 	ldw	ra,8(sp)
8011cc50:	df000117 	ldw	fp,4(sp)
8011cc54:	dc000017 	ldw	r16,0(sp)
8011cc58:	dec00304 	addi	sp,sp,12
8011cc5c:	f800283a 	ret

8011cc60 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8011cc60:	defffb04 	addi	sp,sp,-20
8011cc64:	de00012e 	bgeu	sp,et,8011cc6c <ucCrc8+0xc>
8011cc68:	003b68fa 	trap	3
8011cc6c:	df000415 	stw	fp,16(sp)
8011cc70:	df000404 	addi	fp,sp,16
8011cc74:	e13ffd15 	stw	r4,-12(fp)
8011cc78:	e17ffe15 	stw	r5,-8(fp)
8011cc7c:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8011cc80:	e0bffe17 	ldw	r2,-8(fp)
8011cc84:	1000021e 	bne	r2,zero,8011cc90 <ucCrc8+0x30>
        return 0;
8011cc88:	0005883a 	mov	r2,zero
8011cc8c:	00001906 	br	8011ccf4 <ucCrc8+0x94>
    crc &= 0xff;
8011cc90:	e0bffd17 	ldw	r2,-12(fp)
8011cc94:	10803fcc 	andi	r2,r2,255
8011cc98:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8011cc9c:	e0fffe17 	ldw	r3,-8(fp)
8011cca0:	e0bfff17 	ldw	r2,-4(fp)
8011cca4:	1885883a 	add	r2,r3,r2
8011cca8:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8011ccac:	00000d06 	br	8011cce4 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8011ccb0:	e0bffe17 	ldw	r2,-8(fp)
8011ccb4:	10c00044 	addi	r3,r2,1
8011ccb8:	e0fffe15 	stw	r3,-8(fp)
8011ccbc:	10800003 	ldbu	r2,0(r2)
8011ccc0:	10c03fcc 	andi	r3,r2,255
8011ccc4:	e0bffd17 	ldw	r2,-12(fp)
8011ccc8:	1886f03a 	xor	r3,r3,r2
8011cccc:	00a00534 	movhi	r2,32788
8011ccd0:	109d9384 	addi	r2,r2,30286
8011ccd4:	10c5883a 	add	r2,r2,r3
8011ccd8:	10800003 	ldbu	r2,0(r2)
8011ccdc:	10803fcc 	andi	r2,r2,255
8011cce0:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8011cce4:	e0fffe17 	ldw	r3,-8(fp)
8011cce8:	e0bffc17 	ldw	r2,-16(fp)
8011ccec:	18bff036 	bltu	r3,r2,8011ccb0 <__reset+0xfa0fccb0>
        crc = crc8_table[crc ^ *data++];
    return crc;
8011ccf0:	e0bffd17 	ldw	r2,-12(fp)
}
8011ccf4:	e037883a 	mov	sp,fp
8011ccf8:	df000017 	ldw	fp,0(sp)
8011ccfc:	dec00104 	addi	sp,sp,4
8011cd00:	f800283a 	ret

8011cd04 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8011cd04:	defffb04 	addi	sp,sp,-20
8011cd08:	de00012e 	bgeu	sp,et,8011cd10 <ucCrc8wInit+0xc>
8011cd0c:	003b68fa 	trap	3
8011cd10:	dfc00415 	stw	ra,16(sp)
8011cd14:	df000315 	stw	fp,12(sp)
8011cd18:	df000304 	addi	fp,sp,12
8011cd1c:	e13ffe15 	stw	r4,-8(fp)
8011cd20:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8011cd24:	000d883a 	mov	r6,zero
8011cd28:	000b883a 	mov	r5,zero
8011cd2c:	0009883a 	mov	r4,zero
8011cd30:	011cc600 	call	8011cc60 <ucCrc8>
8011cd34:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8011cd38:	e0bffd03 	ldbu	r2,-12(fp)
8011cd3c:	e1bfff17 	ldw	r6,-4(fp)
8011cd40:	e17ffe17 	ldw	r5,-8(fp)
8011cd44:	1009883a 	mov	r4,r2
8011cd48:	011cc600 	call	8011cc60 <ucCrc8>
}
8011cd4c:	e037883a 	mov	sp,fp
8011cd50:	dfc00117 	ldw	ra,4(sp)
8011cd54:	df000017 	ldw	fp,0(sp)
8011cd58:	dec00204 	addi	sp,sp,8
8011cd5c:	f800283a 	ret

8011cd60 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8011cd60:	defffc04 	addi	sp,sp,-16
8011cd64:	de00012e 	bgeu	sp,et,8011cd6c <vDataControllerInit+0xc>
8011cd68:	003b68fa 	trap	3
8011cd6c:	df000315 	stw	fp,12(sp)
8011cd70:	df000304 	addi	fp,sp,12
8011cd74:	e13ffe15 	stw	r4,-8(fp)
8011cd78:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8011cd7c:	e0bffe17 	ldw	r2,-8(fp)
8011cd80:	10000f15 	stw	zero,60(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8011cd84:	e03ffd05 	stb	zero,-12(fp)
8011cd88:	00001c06 	br	8011cdfc <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8011cd8c:	e0bffd03 	ldbu	r2,-12(fp)
8011cd90:	e0fffd03 	ldbu	r3,-12(fp)
8011cd94:	18c09b24 	muli	r3,r3,620
8011cd98:	e13fff17 	ldw	r4,-4(fp)
8011cd9c:	20c7883a 	add	r3,r4,r3
8011cda0:	e13ffe17 	ldw	r4,-8(fp)
8011cda4:	10800144 	addi	r2,r2,5
8011cda8:	1085883a 	add	r2,r2,r2
8011cdac:	1085883a 	add	r2,r2,r2
8011cdb0:	2085883a 	add	r2,r4,r2
8011cdb4:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8011cdb8:	e17ffd03 	ldbu	r5,-12(fp)
8011cdbc:	e0bffd03 	ldbu	r2,-12(fp)
8011cdc0:	e0ffff17 	ldw	r3,-4(fp)
8011cdc4:	10809b44 	addi	r2,r2,621
8011cdc8:	1085883a 	add	r2,r2,r2
8011cdcc:	1085883a 	add	r2,r2,r2
8011cdd0:	1885883a 	add	r2,r3,r2
8011cdd4:	10c00017 	ldw	r3,0(r2)
8011cdd8:	e13ffe17 	ldw	r4,-8(fp)
8011cddc:	28800244 	addi	r2,r5,9
8011cde0:	1085883a 	add	r2,r2,r2
8011cde4:	1085883a 	add	r2,r2,r2
8011cde8:	2085883a 	add	r2,r4,r2
8011cdec:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8011cdf0:	e0bffd03 	ldbu	r2,-12(fp)
8011cdf4:	10800044 	addi	r2,r2,1
8011cdf8:	e0bffd05 	stb	r2,-12(fp)
8011cdfc:	e0bffd03 	ldbu	r2,-12(fp)
8011ce00:	10800130 	cmpltui	r2,r2,4
8011ce04:	103fe11e 	bne	r2,zero,8011cd8c <__reset+0xfa0fcd8c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8011ce08:	e0bfff17 	ldw	r2,-4(fp)
8011ce0c:	10c27504 	addi	r3,r2,2516
8011ce10:	e0bffe17 	ldw	r2,-8(fp)
8011ce14:	10c00d15 	stw	r3,52(r2)
	xDataControlL->bUpdateComplete = FALSE;
8011ce18:	e0bffe17 	ldw	r2,-8(fp)
8011ce1c:	10000e15 	stw	zero,56(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8011ce20:	e0bffe17 	ldw	r2,-8(fp)
8011ce24:	10c00e04 	addi	r3,r2,56
8011ce28:	e0bfff17 	ldw	r2,-4(fp)
8011ce2c:	10c27715 	stw	r3,2524(r2)
}
8011ce30:	0001883a 	nop
8011ce34:	e037883a 	mov	sp,fp
8011ce38:	df000017 	ldw	fp,0(sp)
8011ce3c:	dec00104 	addi	sp,sp,4
8011ce40:	f800283a 	ret

8011ce44 <vCriticalErrorLedPanel>:
		debug(fp, buffer);
	}
#endif

/* If some critical error ocours all LEDs in the panel will turn on */
void vCriticalErrorLedPanel( void ) {
8011ce44:	defffe04 	addi	sp,sp,-8
8011ce48:	de00012e 	bgeu	sp,et,8011ce50 <vCriticalErrorLedPanel+0xc>
8011ce4c:	003b68fa 	trap	3
8011ce50:	dfc00115 	stw	ra,4(sp)
8011ce54:	df000015 	stw	fp,0(sp)
8011ce58:	d839883a 	mov	fp,sp

	bSetPainelLeds( LEDS_ON, LEDS_PAINEL_ALL_MASK );
8011ce5c:	01400834 	movhi	r5,32
8011ce60:	297fffc4 	addi	r5,r5,-1
8011ce64:	01000044 	movi	r4,1
8011ce68:	010bb640 	call	8010bb64 <bSetPainelLeds>
}
8011ce6c:	0001883a 	nop
8011ce70:	e037883a 	mov	sp,fp
8011ce74:	dfc00117 	ldw	ra,4(sp)
8011ce78:	df000017 	ldw	fp,0(sp)
8011ce7c:	dec00204 	addi	sp,sp,8
8011ce80:	f800283a 	ret

8011ce84 <vFailCreateMutexSResources>:

void vFailCreateMutexSResources( INT8U error_code )
{
8011ce84:	defffe04 	addi	sp,sp,-8
8011ce88:	de00012e 	bgeu	sp,et,8011ce90 <vFailCreateMutexSResources+0xc>
8011ce8c:	003b68fa 	trap	3
8011ce90:	df000115 	stw	fp,4(sp)
8011ce94:	df000104 	addi	fp,sp,4
8011ce98:	2005883a 	mov	r2,r4
8011ce9c:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cea0:	0001883a 	nop
8011cea4:	e037883a 	mov	sp,fp
8011cea8:	df000017 	ldw	fp,0(sp)
8011ceac:	dec00104 	addi	sp,sp,4
8011ceb0:	f800283a 	ret

8011ceb4 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8011ceb4:	deffff04 	addi	sp,sp,-4
8011ceb8:	de00012e 	bgeu	sp,et,8011cec0 <vFailCreateMutexDMA+0xc>
8011cebc:	003b68fa 	trap	3
8011cec0:	df000015 	stw	fp,0(sp)
8011cec4:	d839883a 	mov	fp,sp

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cec8:	0001883a 	nop
8011cecc:	e037883a 	mov	sp,fp
8011ced0:	df000017 	ldw	fp,0(sp)
8011ced4:	dec00104 	addi	sp,sp,4
8011ced8:	f800283a 	ret

8011cedc <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8011cedc:	deffff04 	addi	sp,sp,-4
8011cee0:	de00012e 	bgeu	sp,et,8011cee8 <vFailCreateSemaphoreResources+0xc>
8011cee4:	003b68fa 	trap	3
8011cee8:	df000015 	stw	fp,0(sp)
8011ceec:	d839883a 	mov	fp,sp

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cef0:	0001883a 	nop
8011cef4:	e037883a 	mov	sp,fp
8011cef8:	df000017 	ldw	fp,0(sp)
8011cefc:	dec00104 	addi	sp,sp,4
8011cf00:	f800283a 	ret

8011cf04 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8011cf04:	defffe04 	addi	sp,sp,-8
8011cf08:	de00012e 	bgeu	sp,et,8011cf10 <vFailTestCriticasParts+0xc>
8011cf0c:	003b68fa 	trap	3
8011cf10:	dfc00115 	stw	ra,4(sp)
8011cf14:	df000015 	stw	fp,0(sp)
8011cf18:	d839883a 	mov	fp,sp
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
		debug(fp,"vFailTestCriticasParts. (exit)\n");
	}
	#endif

	vCriticalErrorLedPanel();
8011cf1c:	011ce440 	call	8011ce44 <vCriticalErrorLedPanel>
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cf20:	0001883a 	nop
8011cf24:	e037883a 	mov	sp,fp
8011cf28:	dfc00117 	ldw	ra,4(sp)
8011cf2c:	df000017 	ldw	fp,0(sp)
8011cf30:	dec00204 	addi	sp,sp,8
8011cf34:	f800283a 	ret

8011cf38 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8011cf38:	deffff04 	addi	sp,sp,-4
8011cf3c:	de00012e 	bgeu	sp,et,8011cf44 <vFailSendxSemCommInit+0xc>
8011cf40:	003b68fa 	trap	3
8011cf44:	df000015 	stw	fp,0(sp)
8011cf48:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cf4c:	0001883a 	nop
8011cf50:	e037883a 	mov	sp,fp
8011cf54:	df000017 	ldw	fp,0(sp)
8011cf58:	dec00104 	addi	sp,sp,4
8011cf5c:	f800283a 	ret

8011cf60 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8011cf60:	deffff04 	addi	sp,sp,-4
8011cf64:	de00012e 	bgeu	sp,et,8011cf6c <vFailSendPreParsedSemaphore+0xc>
8011cf68:	003b68fa 	trap	3
8011cf6c:	df000015 	stw	fp,0(sp)
8011cf70:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cf74:	0001883a 	nop
8011cf78:	e037883a 	mov	sp,fp
8011cf7c:	df000017 	ldw	fp,0(sp)
8011cf80:	dec00104 	addi	sp,sp,4
8011cf84:	f800283a 	ret

8011cf88 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8011cf88:	deffff04 	addi	sp,sp,-4
8011cf8c:	de00012e 	bgeu	sp,et,8011cf94 <vFailSendPreAckReceiverSemaphore+0xc>
8011cf90:	003b68fa 	trap	3
8011cf94:	df000015 	stw	fp,0(sp)
8011cf98:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cf9c:	0001883a 	nop
8011cfa0:	e037883a 	mov	sp,fp
8011cfa4:	df000017 	ldw	fp,0(sp)
8011cfa8:	dec00104 	addi	sp,sp,4
8011cfac:	f800283a 	ret

8011cfb0 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8011cfb0:	deffff04 	addi	sp,sp,-4
8011cfb4:	de00012e 	bgeu	sp,et,8011cfbc <vFailSendPreAckSenderSemaphore+0xc>
8011cfb8:	003b68fa 	trap	3
8011cfbc:	df000015 	stw	fp,0(sp)
8011cfc0:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cfc4:	0001883a 	nop
8011cfc8:	e037883a 	mov	sp,fp
8011cfcc:	df000017 	ldw	fp,0(sp)
8011cfd0:	dec00104 	addi	sp,sp,4
8011cfd4:	f800283a 	ret

8011cfd8 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8011cfd8:	deffff04 	addi	sp,sp,-4
8011cfdc:	de00012e 	bgeu	sp,et,8011cfe4 <vFailGetCountSemaphoreSenderTask+0xc>
8011cfe0:	003b68fa 	trap	3
8011cfe4:	df000015 	stw	fp,0(sp)
8011cfe8:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011cfec:	0001883a 	nop
8011cff0:	e037883a 	mov	sp,fp
8011cff4:	df000017 	ldw	fp,0(sp)
8011cff8:	dec00104 	addi	sp,sp,4
8011cffc:	f800283a 	ret

8011d000 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8011d000:	deffff04 	addi	sp,sp,-4
8011d004:	de00012e 	bgeu	sp,et,8011d00c <vFailGetMutexSenderTask+0xc>
8011d008:	003b68fa 	trap	3
8011d00c:	df000015 	stw	fp,0(sp)
8011d010:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d014:	0001883a 	nop
8011d018:	e037883a 	mov	sp,fp
8011d01c:	df000017 	ldw	fp,0(sp)
8011d020:	dec00104 	addi	sp,sp,4
8011d024:	f800283a 	ret

8011d028 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8011d028:	deffff04 	addi	sp,sp,-4
8011d02c:	de00012e 	bgeu	sp,et,8011d034 <vFailGetCountSemaphoreReceiverTask+0xc>
8011d030:	003b68fa 	trap	3
8011d034:	df000015 	stw	fp,0(sp)
8011d038:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d03c:	0001883a 	nop
8011d040:	e037883a 	mov	sp,fp
8011d044:	df000017 	ldw	fp,0(sp)
8011d048:	dec00104 	addi	sp,sp,4
8011d04c:	f800283a 	ret

8011d050 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8011d050:	deffff04 	addi	sp,sp,-4
8011d054:	de00012e 	bgeu	sp,et,8011d05c <vFailGetMutexReceiverTask+0xc>
8011d058:	003b68fa 	trap	3
8011d05c:	df000015 	stw	fp,0(sp)
8011d060:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d064:	0001883a 	nop
8011d068:	e037883a 	mov	sp,fp
8011d06c:	df000017 	ldw	fp,0(sp)
8011d070:	dec00104 	addi	sp,sp,4
8011d074:	f800283a 	ret

8011d078 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8011d078:	deffff04 	addi	sp,sp,-4
8011d07c:	de00012e 	bgeu	sp,et,8011d084 <vFailGetMutexTxUARTSenderTask+0xc>
8011d080:	003b68fa 	trap	3
8011d084:	df000015 	stw	fp,0(sp)
8011d088:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d08c:	0001883a 	nop
8011d090:	e037883a 	mov	sp,fp
8011d094:	df000017 	ldw	fp,0(sp)
8011d098:	dec00104 	addi	sp,sp,4
8011d09c:	f800283a 	ret

8011d0a0 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8011d0a0:	deffff04 	addi	sp,sp,-4
8011d0a4:	de00012e 	bgeu	sp,et,8011d0ac <vFailGetMacRTC+0xc>
8011d0a8:	003b68fa 	trap	3
8011d0ac:	df000015 	stw	fp,0(sp)
8011d0b0:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d0b4:	0001883a 	nop
8011d0b8:	e037883a 	mov	sp,fp
8011d0bc:	df000017 	ldw	fp,0(sp)
8011d0c0:	dec00104 	addi	sp,sp,4
8011d0c4:	f800283a 	ret

8011d0c8 <vFailInitialization>:


void vFailInitialization( void )
{
8011d0c8:	defffe04 	addi	sp,sp,-8
8011d0cc:	de00012e 	bgeu	sp,et,8011d0d4 <vFailInitialization+0xc>
8011d0d0:	003b68fa 	trap	3
8011d0d4:	dfc00115 	stw	ra,4(sp)
8011d0d8:	df000015 	stw	fp,0(sp)
8011d0dc:	d839883a 	mov	fp,sp
	if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
		debug(fp,"vFailInitialization\n");
	}
	#endif

	vCriticalErrorLedPanel();
8011d0e0:	011ce440 	call	8011ce44 <vCriticalErrorLedPanel>
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d0e4:	0001883a 	nop
8011d0e8:	e037883a 	mov	sp,fp
8011d0ec:	dfc00117 	ldw	ra,4(sp)
8011d0f0:	df000017 	ldw	fp,0(sp)
8011d0f4:	dec00204 	addi	sp,sp,8
8011d0f8:	f800283a 	ret

8011d0fc <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8011d0fc:	deffff04 	addi	sp,sp,-4
8011d100:	de00012e 	bgeu	sp,et,8011d108 <vFailReceiverCreate+0xc>
8011d104:	003b68fa 	trap	3
8011d108:	df000015 	stw	fp,0(sp)
8011d10c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d110:	0001883a 	nop
8011d114:	e037883a 	mov	sp,fp
8011d118:	df000017 	ldw	fp,0(sp)
8011d11c:	dec00104 	addi	sp,sp,4
8011d120:	f800283a 	ret

8011d124 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8011d124:	deffff04 	addi	sp,sp,-4
8011d128:	de00012e 	bgeu	sp,et,8011d130 <vFailSenderCreate+0xc>
8011d12c:	003b68fa 	trap	3
8011d130:	df000015 	stw	fp,0(sp)
8011d134:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d138:	0001883a 	nop
8011d13c:	e037883a 	mov	sp,fp
8011d140:	df000017 	ldw	fp,0(sp)
8011d144:	dec00104 	addi	sp,sp,4
8011d148:	f800283a 	ret

8011d14c <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8011d14c:	deffff04 	addi	sp,sp,-4
8011d150:	de00012e 	bgeu	sp,et,8011d158 <vFailDeleteInitialization+0xc>
8011d154:	003b68fa 	trap	3
8011d158:	df000015 	stw	fp,0(sp)
8011d15c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d160:	0001883a 	nop
8011d164:	e037883a 	mov	sp,fp
8011d168:	df000017 	ldw	fp,0(sp)
8011d16c:	dec00104 	addi	sp,sp,4
8011d170:	f800283a 	ret

8011d174 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8011d174:	deffff04 	addi	sp,sp,-4
8011d178:	de00012e 	bgeu	sp,et,8011d180 <vFailSetCountSemaphorexBuffer32+0xc>
8011d17c:	003b68fa 	trap	3
8011d180:	df000015 	stw	fp,0(sp)
8011d184:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d188:	0001883a 	nop
8011d18c:	e037883a 	mov	sp,fp
8011d190:	df000017 	ldw	fp,0(sp)
8011d194:	dec00104 	addi	sp,sp,4
8011d198:	f800283a 	ret

8011d19c <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8011d19c:	deffff04 	addi	sp,sp,-4
8011d1a0:	de00012e 	bgeu	sp,et,8011d1a8 <vFailSetCountSemaphorexBuffer64+0xc>
8011d1a4:	003b68fa 	trap	3
8011d1a8:	df000015 	stw	fp,0(sp)
8011d1ac:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d1b0:	0001883a 	nop
8011d1b4:	e037883a 	mov	sp,fp
8011d1b8:	df000017 	ldw	fp,0(sp)
8011d1bc:	dec00104 	addi	sp,sp,4
8011d1c0:	f800283a 	ret

8011d1c4 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8011d1c4:	deffff04 	addi	sp,sp,-4
8011d1c8:	de00012e 	bgeu	sp,et,8011d1d0 <vFailSetCountSemaphorexBuffer128+0xc>
8011d1cc:	003b68fa 	trap	3
8011d1d0:	df000015 	stw	fp,0(sp)
8011d1d4:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d1d8:	0001883a 	nop
8011d1dc:	e037883a 	mov	sp,fp
8011d1e0:	df000017 	ldw	fp,0(sp)
8011d1e4:	dec00104 	addi	sp,sp,4
8011d1e8:	f800283a 	ret

8011d1ec <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8011d1ec:	deffff04 	addi	sp,sp,-4
8011d1f0:	de00012e 	bgeu	sp,et,8011d1f8 <vFailGetCountSemaphorexBuffer128+0xc>
8011d1f4:	003b68fa 	trap	3
8011d1f8:	df000015 	stw	fp,0(sp)
8011d1fc:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d200:	0001883a 	nop
8011d204:	e037883a 	mov	sp,fp
8011d208:	df000017 	ldw	fp,0(sp)
8011d20c:	dec00104 	addi	sp,sp,4
8011d210:	f800283a 	ret

8011d214 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8011d214:	deffff04 	addi	sp,sp,-4
8011d218:	de00012e 	bgeu	sp,et,8011d220 <vFailGetCountSemaphorexBuffer64+0xc>
8011d21c:	003b68fa 	trap	3
8011d220:	df000015 	stw	fp,0(sp)
8011d224:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d228:	0001883a 	nop
8011d22c:	e037883a 	mov	sp,fp
8011d230:	df000017 	ldw	fp,0(sp)
8011d234:	dec00104 	addi	sp,sp,4
8011d238:	f800283a 	ret

8011d23c <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8011d23c:	deffff04 	addi	sp,sp,-4
8011d240:	de00012e 	bgeu	sp,et,8011d248 <vFailGetCountSemaphorexBuffer32+0xc>
8011d244:	003b68fa 	trap	3
8011d248:	df000015 	stw	fp,0(sp)
8011d24c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d250:	0001883a 	nop
8011d254:	e037883a 	mov	sp,fp
8011d258:	df000017 	ldw	fp,0(sp)
8011d25c:	dec00104 	addi	sp,sp,4
8011d260:	f800283a 	ret

8011d264 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8011d264:	deffff04 	addi	sp,sp,-4
8011d268:	de00012e 	bgeu	sp,et,8011d270 <vFailFoundBufferRetransmission+0xc>
8011d26c:	003b68fa 	trap	3
8011d270:	df000015 	stw	fp,0(sp)
8011d274:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d278:	0001883a 	nop
8011d27c:	e037883a 	mov	sp,fp
8011d280:	df000017 	ldw	fp,0(sp)
8011d284:	dec00104 	addi	sp,sp,4
8011d288:	f800283a 	ret

8011d28c <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8011d28c:	deffff04 	addi	sp,sp,-4
8011d290:	de00012e 	bgeu	sp,et,8011d298 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8011d294:	003b68fa 	trap	3
8011d298:	df000015 	stw	fp,0(sp)
8011d29c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d2a0:	0001883a 	nop
8011d2a4:	e037883a 	mov	sp,fp
8011d2a8:	df000017 	ldw	fp,0(sp)
8011d2ac:	dec00104 	addi	sp,sp,4
8011d2b0:	f800283a 	ret

8011d2b4 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8011d2b4:	deffff04 	addi	sp,sp,-4
8011d2b8:	de00012e 	bgeu	sp,et,8011d2c0 <vFailGetxMutexPreParsedParserRxTask+0xc>
8011d2bc:	003b68fa 	trap	3
8011d2c0:	df000015 	stw	fp,0(sp)
8011d2c4:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d2c8:	0001883a 	nop
8011d2cc:	e037883a 	mov	sp,fp
8011d2d0:	df000017 	ldw	fp,0(sp)
8011d2d4:	dec00104 	addi	sp,sp,4
8011d2d8:	f800283a 	ret

8011d2dc <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8011d2dc:	deffff04 	addi	sp,sp,-4
8011d2e0:	de00012e 	bgeu	sp,et,8011d2e8 <vNoContentInPreParsedBuffer+0xc>
8011d2e4:	003b68fa 	trap	3
8011d2e8:	df000015 	stw	fp,0(sp)
8011d2ec:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d2f0:	0001883a 	nop
8011d2f4:	e037883a 	mov	sp,fp
8011d2f8:	df000017 	ldw	fp,0(sp)
8011d2fc:	dec00104 	addi	sp,sp,4
8011d300:	f800283a 	ret

8011d304 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8011d304:	deffff04 	addi	sp,sp,-4
8011d308:	de00012e 	bgeu	sp,et,8011d310 <vCouldNotSendEthConfUART+0xc>
8011d30c:	003b68fa 	trap	3
8011d310:	df000015 	stw	fp,0(sp)
8011d314:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d318:	0001883a 	nop
8011d31c:	e037883a 	mov	sp,fp
8011d320:	df000017 	ldw	fp,0(sp)
8011d324:	dec00104 	addi	sp,sp,4
8011d328:	f800283a 	ret

8011d32c <vFailSendNack>:

void vFailSendNack( void )
{
8011d32c:	deffff04 	addi	sp,sp,-4
8011d330:	de00012e 	bgeu	sp,et,8011d338 <vFailSendNack+0xc>
8011d334:	003b68fa 	trap	3
8011d338:	df000015 	stw	fp,0(sp)
8011d33c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d340:	0001883a 	nop
8011d344:	e037883a 	mov	sp,fp
8011d348:	df000017 	ldw	fp,0(sp)
8011d34c:	dec00104 	addi	sp,sp,4
8011d350:	f800283a 	ret

8011d354 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8011d354:	deffff04 	addi	sp,sp,-4
8011d358:	de00012e 	bgeu	sp,et,8011d360 <vFailSetPreAckSenderBuffer+0xc>
8011d35c:	003b68fa 	trap	3
8011d360:	df000015 	stw	fp,0(sp)
8011d364:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d368:	0001883a 	nop
8011d36c:	e037883a 	mov	sp,fp
8011d370:	df000017 	ldw	fp,0(sp)
8011d374:	dec00104 	addi	sp,sp,4
8011d378:	f800283a 	ret

8011d37c <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8011d37c:	deffff04 	addi	sp,sp,-4
8011d380:	de00012e 	bgeu	sp,et,8011d388 <vFailSetPreParsedBuffer+0xc>
8011d384:	003b68fa 	trap	3
8011d388:	df000015 	stw	fp,0(sp)
8011d38c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d390:	0001883a 	nop
8011d394:	e037883a 	mov	sp,fp
8011d398:	df000017 	ldw	fp,0(sp)
8011d39c:	dec00104 	addi	sp,sp,4
8011d3a0:	f800283a 	ret

8011d3a4 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8011d3a4:	deffff04 	addi	sp,sp,-4
8011d3a8:	de00012e 	bgeu	sp,et,8011d3b0 <vFailSetPreAckReceiverBuffer+0xc>
8011d3ac:	003b68fa 	trap	3
8011d3b0:	df000015 	stw	fp,0(sp)
8011d3b4:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d3b8:	0001883a 	nop
8011d3bc:	e037883a 	mov	sp,fp
8011d3c0:	df000017 	ldw	fp,0(sp)
8011d3c4:	dec00104 	addi	sp,sp,4
8011d3c8:	f800283a 	ret

8011d3cc <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8011d3cc:	deffff04 	addi	sp,sp,-4
8011d3d0:	de00012e 	bgeu	sp,et,8011d3d8 <vFailParserCommTaskCreate+0xc>
8011d3d4:	003b68fa 	trap	3
8011d3d8:	df000015 	stw	fp,0(sp)
8011d3dc:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d3e0:	0001883a 	nop
8011d3e4:	e037883a 	mov	sp,fp
8011d3e8:	df000017 	ldw	fp,0(sp)
8011d3ec:	dec00104 	addi	sp,sp,4
8011d3f0:	f800283a 	ret

8011d3f4 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8011d3f4:	deffff04 	addi	sp,sp,-4
8011d3f8:	de00012e 	bgeu	sp,et,8011d400 <vFailInAckHandlerTaskCreate+0xc>
8011d3fc:	003b68fa 	trap	3
8011d400:	df000015 	stw	fp,0(sp)
8011d404:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d408:	0001883a 	nop
8011d40c:	e037883a 	mov	sp,fp
8011d410:	df000017 	ldw	fp,0(sp)
8011d414:	dec00104 	addi	sp,sp,4
8011d418:	f800283a 	ret

8011d41c <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8011d41c:	deffff04 	addi	sp,sp,-4
8011d420:	de00012e 	bgeu	sp,et,8011d428 <vFailOutAckHandlerTaskCreate+0xc>
8011d424:	003b68fa 	trap	3
8011d428:	df000015 	stw	fp,0(sp)
8011d42c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d430:	0001883a 	nop
8011d434:	e037883a 	mov	sp,fp
8011d438:	df000017 	ldw	fp,0(sp)
8011d43c:	dec00104 	addi	sp,sp,4
8011d440:	f800283a 	ret

8011d444 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8011d444:	deffff04 	addi	sp,sp,-4
8011d448:	de00012e 	bgeu	sp,et,8011d450 <vFailCreateTimerRetransmisison+0xc>
8011d44c:	003b68fa 	trap	3
8011d450:	df000015 	stw	fp,0(sp)
8011d454:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d458:	0001883a 	nop
8011d45c:	e037883a 	mov	sp,fp
8011d460:	df000017 	ldw	fp,0(sp)
8011d464:	dec00104 	addi	sp,sp,4
8011d468:	f800283a 	ret

8011d46c <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8011d46c:	deffff04 	addi	sp,sp,-4
8011d470:	de00012e 	bgeu	sp,et,8011d478 <vCouldNotCheckBufferTimeOutFunction+0xc>
8011d474:	003b68fa 	trap	3
8011d478:	df000015 	stw	fp,0(sp)
8011d47c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d480:	0001883a 	nop
8011d484:	e037883a 	mov	sp,fp
8011d488:	df000017 	ldw	fp,0(sp)
8011d48c:	dec00104 	addi	sp,sp,4
8011d490:	f800283a 	ret

8011d494 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8011d494:	deffff04 	addi	sp,sp,-4
8011d498:	de00012e 	bgeu	sp,et,8011d4a0 <vFailTimeoutCheckerTaskCreate+0xc>
8011d49c:	003b68fa 	trap	3
8011d4a0:	df000015 	stw	fp,0(sp)
8011d4a4:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d4a8:	0001883a 	nop
8011d4ac:	e037883a 	mov	sp,fp
8011d4b0:	df000017 	ldw	fp,0(sp)
8011d4b4:	dec00104 	addi	sp,sp,4
8011d4b8:	f800283a 	ret

8011d4bc <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8011d4bc:	deffff04 	addi	sp,sp,-4
8011d4c0:	de00012e 	bgeu	sp,et,8011d4c8 <vFailGetBlockingSemTimeoutTask+0xc>
8011d4c4:	003b68fa 	trap	3
8011d4c8:	df000015 	stw	fp,0(sp)
8011d4cc:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d4d0:	0001883a 	nop
8011d4d4:	e037883a 	mov	sp,fp
8011d4d8:	df000017 	ldw	fp,0(sp)
8011d4dc:	dec00104 	addi	sp,sp,4
8011d4e0:	f800283a 	ret

8011d4e4 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8011d4e4:	deffff04 	addi	sp,sp,-4
8011d4e8:	de00012e 	bgeu	sp,et,8011d4f0 <vFailPostBlockingSemTimeoutTask+0xc>
8011d4ec:	003b68fa 	trap	3
8011d4f0:	df000015 	stw	fp,0(sp)
8011d4f4:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d4f8:	0001883a 	nop
8011d4fc:	e037883a 	mov	sp,fp
8011d500:	df000017 	ldw	fp,0(sp)
8011d504:	dec00104 	addi	sp,sp,4
8011d508:	f800283a 	ret

8011d50c <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8011d50c:	deffff04 	addi	sp,sp,-4
8011d510:	de00012e 	bgeu	sp,et,8011d518 <vFailCouldNotRetransmitTimeoutTask+0xc>
8011d514:	003b68fa 	trap	3
8011d518:	df000015 	stw	fp,0(sp)
8011d51c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d520:	0001883a 	nop
8011d524:	e037883a 	mov	sp,fp
8011d528:	df000017 	ldw	fp,0(sp)
8011d52c:	dec00104 	addi	sp,sp,4
8011d530:	f800283a 	ret

8011d534 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8011d534:	deffff04 	addi	sp,sp,-4
8011d538:	de00012e 	bgeu	sp,et,8011d540 <vCouldNotRetransmitB32TimeoutTask+0xc>
8011d53c:	003b68fa 	trap	3
8011d540:	df000015 	stw	fp,0(sp)
8011d544:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d548:	0001883a 	nop
8011d54c:	e037883a 	mov	sp,fp
8011d550:	df000017 	ldw	fp,0(sp)
8011d554:	dec00104 	addi	sp,sp,4
8011d558:	f800283a 	ret

8011d55c <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8011d55c:	deffff04 	addi	sp,sp,-4
8011d560:	de00012e 	bgeu	sp,et,8011d568 <vCouldNotRetransmitB64TimeoutTask+0xc>
8011d564:	003b68fa 	trap	3
8011d568:	df000015 	stw	fp,0(sp)
8011d56c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d570:	0001883a 	nop
8011d574:	e037883a 	mov	sp,fp
8011d578:	df000017 	ldw	fp,0(sp)
8011d57c:	dec00104 	addi	sp,sp,4
8011d580:	f800283a 	ret

8011d584 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8011d584:	deffff04 	addi	sp,sp,-4
8011d588:	de00012e 	bgeu	sp,et,8011d590 <vCouldNotRetransmitB128TimeoutTask+0xc>
8011d58c:	003b68fa 	trap	3
8011d590:	df000015 	stw	fp,0(sp)
8011d594:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d598:	0001883a 	nop
8011d59c:	e037883a 	mov	sp,fp
8011d5a0:	df000017 	ldw	fp,0(sp)
8011d5a4:	dec00104 	addi	sp,sp,4
8011d5a8:	f800283a 	ret

8011d5ac <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8011d5ac:	deffff04 	addi	sp,sp,-4
8011d5b0:	de00012e 	bgeu	sp,et,8011d5b8 <vFailStartTimerRetransmission+0xc>
8011d5b4:	003b68fa 	trap	3
8011d5b8:	df000015 	stw	fp,0(sp)
8011d5bc:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d5c0:	0001883a 	nop
8011d5c4:	e037883a 	mov	sp,fp
8011d5c8:	df000017 	ldw	fp,0(sp)
8011d5cc:	dec00104 	addi	sp,sp,4
8011d5d0:	f800283a 	ret

8011d5d4 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8011d5d4:	deffff04 	addi	sp,sp,-4
8011d5d8:	de00012e 	bgeu	sp,et,8011d5e0 <vCouldNotSendTurnOff+0xc>
8011d5dc:	003b68fa 	trap	3
8011d5e0:	df000015 	stw	fp,0(sp)
8011d5e4:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d5e8:	0001883a 	nop
8011d5ec:	e037883a 	mov	sp,fp
8011d5f0:	df000017 	ldw	fp,0(sp)
8011d5f4:	dec00104 	addi	sp,sp,4
8011d5f8:	f800283a 	ret

8011d5fc <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8011d5fc:	deffff04 	addi	sp,sp,-4
8011d600:	de00012e 	bgeu	sp,et,8011d608 <vCouldNotSendReset+0xc>
8011d604:	003b68fa 	trap	3
8011d608:	df000015 	stw	fp,0(sp)
8011d60c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d610:	0001883a 	nop
8011d614:	e037883a 	mov	sp,fp
8011d618:	df000017 	ldw	fp,0(sp)
8011d61c:	dec00104 	addi	sp,sp,4
8011d620:	f800283a 	ret

8011d624 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8011d624:	deffff04 	addi	sp,sp,-4
8011d628:	de00012e 	bgeu	sp,et,8011d630 <vCouldNotSendLog+0xc>
8011d62c:	003b68fa 	trap	3
8011d630:	df000015 	stw	fp,0(sp)
8011d634:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d638:	0001883a 	nop
8011d63c:	e037883a 	mov	sp,fp
8011d640:	df000017 	ldw	fp,0(sp)
8011d644:	dec00104 	addi	sp,sp,4
8011d648:	f800283a 	ret

8011d64c <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8011d64c:	defffe04 	addi	sp,sp,-8
8011d650:	de00012e 	bgeu	sp,et,8011d658 <vCouldNotSendTMPusCommand+0xc>
8011d654:	003b68fa 	trap	3
8011d658:	df000115 	stw	fp,4(sp)
8011d65c:	df000104 	addi	fp,sp,4
8011d660:	e13fff15 	stw	r4,-4(fp)
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d664:	0001883a 	nop
8011d668:	e037883a 	mov	sp,fp
8011d66c:	df000017 	ldw	fp,0(sp)
8011d670:	dec00104 	addi	sp,sp,4
8011d674:	f800283a 	ret

8011d678 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8011d678:	deffff04 	addi	sp,sp,-4
8011d67c:	de00012e 	bgeu	sp,et,8011d684 <vWarnCouldNotgetMutexRetrans128+0xc>
8011d680:	003b68fa 	trap	3
8011d684:	df000015 	stw	fp,0(sp)
8011d688:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d68c:	0001883a 	nop
8011d690:	e037883a 	mov	sp,fp
8011d694:	df000017 	ldw	fp,0(sp)
8011d698:	dec00104 	addi	sp,sp,4
8011d69c:	f800283a 	ret

8011d6a0 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8011d6a0:	deffff04 	addi	sp,sp,-4
8011d6a4:	de00012e 	bgeu	sp,et,8011d6ac <vFailCreateScheduleQueue+0xc>
8011d6a8:	003b68fa 	trap	3
8011d6ac:	df000015 	stw	fp,0(sp)
8011d6b0:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d6b4:	0001883a 	nop
8011d6b8:	e037883a 	mov	sp,fp
8011d6bc:	df000017 	ldw	fp,0(sp)
8011d6c0:	dec00104 	addi	sp,sp,4
8011d6c4:	f800283a 	ret

8011d6c8 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8011d6c8:	defffe04 	addi	sp,sp,-8
8011d6cc:	de00012e 	bgeu	sp,et,8011d6d4 <vFailCreateNFEEQueue+0xc>
8011d6d0:	003b68fa 	trap	3
8011d6d4:	df000115 	stw	fp,4(sp)
8011d6d8:	df000104 	addi	fp,sp,4
8011d6dc:	2005883a 	mov	r2,r4
8011d6e0:	e0bfff05 	stb	r2,-4(fp)
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d6e4:	0001883a 	nop
8011d6e8:	e037883a 	mov	sp,fp
8011d6ec:	df000017 	ldw	fp,0(sp)
8011d6f0:	dec00104 	addi	sp,sp,4
8011d6f4:	f800283a 	ret

8011d6f8 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8011d6f8:	defffe04 	addi	sp,sp,-8
8011d6fc:	de00012e 	bgeu	sp,et,8011d704 <vFailCreateNFEESyncQueue+0xc>
8011d700:	003b68fa 	trap	3
8011d704:	df000115 	stw	fp,4(sp)
8011d708:	df000104 	addi	fp,sp,4
8011d70c:	2005883a 	mov	r2,r4
8011d710:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d714:	0001883a 	nop
8011d718:	e037883a 	mov	sp,fp
8011d71c:	df000017 	ldw	fp,0(sp)
8011d720:	dec00104 	addi	sp,sp,4
8011d724:	f800283a 	ret

8011d728 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8011d728:	deffff04 	addi	sp,sp,-4
8011d72c:	de00012e 	bgeu	sp,et,8011d734 <vCoudlNotCreateNFee0Task+0xc>
8011d730:	003b68fa 	trap	3
8011d734:	df000015 	stw	fp,0(sp)
8011d738:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d73c:	0001883a 	nop
8011d740:	e037883a 	mov	sp,fp
8011d744:	df000017 	ldw	fp,0(sp)
8011d748:	dec00104 	addi	sp,sp,4
8011d74c:	f800283a 	ret

8011d750 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8011d750:	deffff04 	addi	sp,sp,-4
8011d754:	de00012e 	bgeu	sp,et,8011d75c <vCoudlNotCreateNFee1Task+0xc>
8011d758:	003b68fa 	trap	3
8011d75c:	df000015 	stw	fp,0(sp)
8011d760:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d764:	0001883a 	nop
8011d768:	e037883a 	mov	sp,fp
8011d76c:	df000017 	ldw	fp,0(sp)
8011d770:	dec00104 	addi	sp,sp,4
8011d774:	f800283a 	ret

8011d778 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8011d778:	deffff04 	addi	sp,sp,-4
8011d77c:	de00012e 	bgeu	sp,et,8011d784 <vCoudlNotCreateNFee2Task+0xc>
8011d780:	003b68fa 	trap	3
8011d784:	df000015 	stw	fp,0(sp)
8011d788:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d78c:	0001883a 	nop
8011d790:	e037883a 	mov	sp,fp
8011d794:	df000017 	ldw	fp,0(sp)
8011d798:	dec00104 	addi	sp,sp,4
8011d79c:	f800283a 	ret

8011d7a0 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8011d7a0:	deffff04 	addi	sp,sp,-4
8011d7a4:	de00012e 	bgeu	sp,et,8011d7ac <vCoudlNotCreateNFee3Task+0xc>
8011d7a8:	003b68fa 	trap	3
8011d7ac:	df000015 	stw	fp,0(sp)
8011d7b0:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d7b4:	0001883a 	nop
8011d7b8:	e037883a 	mov	sp,fp
8011d7bc:	df000017 	ldw	fp,0(sp)
8011d7c0:	dec00104 	addi	sp,sp,4
8011d7c4:	f800283a 	ret

8011d7c8 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8011d7c8:	deffff04 	addi	sp,sp,-4
8011d7cc:	de00012e 	bgeu	sp,et,8011d7d4 <vCoudlNotCreateNFee4Task+0xc>
8011d7d0:	003b68fa 	trap	3
8011d7d4:	df000015 	stw	fp,0(sp)
8011d7d8:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d7dc:	0001883a 	nop
8011d7e0:	e037883a 	mov	sp,fp
8011d7e4:	df000017 	ldw	fp,0(sp)
8011d7e8:	dec00104 	addi	sp,sp,4
8011d7ec:	f800283a 	ret

8011d7f0 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8011d7f0:	deffff04 	addi	sp,sp,-4
8011d7f4:	de00012e 	bgeu	sp,et,8011d7fc <vCoudlNotCreateNFee5Task+0xc>
8011d7f8:	003b68fa 	trap	3
8011d7fc:	df000015 	stw	fp,0(sp)
8011d800:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d804:	0001883a 	nop
8011d808:	e037883a 	mov	sp,fp
8011d80c:	df000017 	ldw	fp,0(sp)
8011d810:	dec00104 	addi	sp,sp,4
8011d814:	f800283a 	ret

8011d818 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8011d818:	deffff04 	addi	sp,sp,-4
8011d81c:	de00012e 	bgeu	sp,et,8011d824 <vCoudlNotCreateNFeeControllerTask+0xc>
8011d820:	003b68fa 	trap	3
8011d824:	df000015 	stw	fp,0(sp)
8011d828:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d82c:	0001883a 	nop
8011d830:	e037883a 	mov	sp,fp
8011d834:	df000017 	ldw	fp,0(sp)
8011d838:	dec00104 	addi	sp,sp,4
8011d83c:	f800283a 	ret

8011d840 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8011d840:	deffff04 	addi	sp,sp,-4
8011d844:	de00012e 	bgeu	sp,et,8011d84c <vCoudlNotCreateDataControllerTask+0xc>
8011d848:	003b68fa 	trap	3
8011d84c:	df000015 	stw	fp,0(sp)
8011d850:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d854:	0001883a 	nop
8011d858:	e037883a 	mov	sp,fp
8011d85c:	df000017 	ldw	fp,0(sp)
8011d860:	dec00104 	addi	sp,sp,4
8011d864:	f800283a 	ret

8011d868 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8011d868:	deffff04 	addi	sp,sp,-4
8011d86c:	de00012e 	bgeu	sp,et,8011d874 <vCoudlNotCreateMebTask+0xc>
8011d870:	003b68fa 	trap	3
8011d874:	df000015 	stw	fp,0(sp)
8011d878:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d87c:	0001883a 	nop
8011d880:	e037883a 	mov	sp,fp
8011d884:	df000017 	ldw	fp,0(sp)
8011d888:	dec00104 	addi	sp,sp,4
8011d88c:	f800283a 	ret

8011d890 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8011d890:	defffe04 	addi	sp,sp,-8
8011d894:	de00012e 	bgeu	sp,et,8011d89c <vFailCreateMutexSPUSQueueMeb+0xc>
8011d898:	003b68fa 	trap	3
8011d89c:	df000115 	stw	fp,4(sp)
8011d8a0:	df000104 	addi	fp,sp,4
8011d8a4:	2005883a 	mov	r2,r4
8011d8a8:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d8ac:	0001883a 	nop
8011d8b0:	e037883a 	mov	sp,fp
8011d8b4:	df000017 	ldw	fp,0(sp)
8011d8b8:	dec00104 	addi	sp,sp,4
8011d8bc:	f800283a 	ret

8011d8c0 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8011d8c0:	deffff04 	addi	sp,sp,-4
8011d8c4:	de00012e 	bgeu	sp,et,8011d8cc <vFailSendPUStoMebTask+0xc>
8011d8c8:	003b68fa 	trap	3
8011d8cc:	df000015 	stw	fp,0(sp)
8011d8d0:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d8d4:	0001883a 	nop
8011d8d8:	e037883a 	mov	sp,fp
8011d8dc:	df000017 	ldw	fp,0(sp)
8011d8e0:	dec00104 	addi	sp,sp,4
8011d8e4:	f800283a 	ret

8011d8e8 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8011d8e8:	deffff04 	addi	sp,sp,-4
8011d8ec:	de00012e 	bgeu	sp,et,8011d8f4 <vCouldNotGetCmdQueueMeb+0xc>
8011d8f0:	003b68fa 	trap	3
8011d8f4:	df000015 	stw	fp,0(sp)
8011d8f8:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d8fc:	0001883a 	nop
8011d900:	e037883a 	mov	sp,fp
8011d904:	df000017 	ldw	fp,0(sp)
8011d908:	dec00104 	addi	sp,sp,4
8011d90c:	f800283a 	ret

8011d910 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8011d910:	deffff04 	addi	sp,sp,-4
8011d914:	de00012e 	bgeu	sp,et,8011d91c <vCouldNotGetMutexMebPus+0xc>
8011d918:	003b68fa 	trap	3
8011d91c:	df000015 	stw	fp,0(sp)
8011d920:	d839883a 	mov	fp,sp
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d924:	0001883a 	nop
8011d928:	e037883a 	mov	sp,fp
8011d92c:	df000017 	ldw	fp,0(sp)
8011d930:	dec00104 	addi	sp,sp,4
8011d934:	f800283a 	ret

8011d938 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8011d938:	deffff04 	addi	sp,sp,-4
8011d93c:	de00012e 	bgeu	sp,et,8011d944 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8011d940:	003b68fa 	trap	3
8011d944:	df000015 	stw	fp,0(sp)
8011d948:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d94c:	0001883a 	nop
8011d950:	e037883a 	mov	sp,fp
8011d954:	df000017 	ldw	fp,0(sp)
8011d958:	dec00104 	addi	sp,sp,4
8011d95c:	f800283a 	ret

8011d960 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8011d960:	deffff04 	addi	sp,sp,-4
8011d964:	de00012e 	bgeu	sp,et,8011d96c <vCouldNotCreateQueueMaskDataCtrl+0xc>
8011d968:	003b68fa 	trap	3
8011d96c:	df000015 	stw	fp,0(sp)
8011d970:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d974:	0001883a 	nop
8011d978:	e037883a 	mov	sp,fp
8011d97c:	df000017 	ldw	fp,0(sp)
8011d980:	dec00104 	addi	sp,sp,4
8011d984:	f800283a 	ret

8011d988 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8011d988:	deffff04 	addi	sp,sp,-4
8011d98c:	de00012e 	bgeu	sp,et,8011d994 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8011d990:	003b68fa 	trap	3
8011d994:	df000015 	stw	fp,0(sp)
8011d998:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d99c:	0001883a 	nop
8011d9a0:	e037883a 	mov	sp,fp
8011d9a4:	df000017 	ldw	fp,0(sp)
8011d9a8:	dec00104 	addi	sp,sp,4
8011d9ac:	f800283a 	ret

8011d9b0 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8011d9b0:	deffff04 	addi	sp,sp,-4
8011d9b4:	de00012e 	bgeu	sp,et,8011d9bc <vCouldNotGetQueueMaskDataCtrl+0xc>
8011d9b8:	003b68fa 	trap	3
8011d9bc:	df000015 	stw	fp,0(sp)
8011d9c0:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d9c4:	0001883a 	nop
8011d9c8:	e037883a 	mov	sp,fp
8011d9cc:	df000017 	ldw	fp,0(sp)
8011d9d0:	dec00104 	addi	sp,sp,4
8011d9d4:	f800283a 	ret

8011d9d8 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8011d9d8:	defffe04 	addi	sp,sp,-8
8011d9dc:	de00012e 	bgeu	sp,et,8011d9e4 <vFailSendMsgAccessDMA+0xc>
8011d9e0:	003b68fa 	trap	3
8011d9e4:	df000115 	stw	fp,4(sp)
8011d9e8:	df000104 	addi	fp,sp,4
8011d9ec:	2005883a 	mov	r2,r4
8011d9f0:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011d9f4:	0001883a 	nop
8011d9f8:	e037883a 	mov	sp,fp
8011d9fc:	df000017 	ldw	fp,0(sp)
8011da00:	dec00104 	addi	sp,sp,4
8011da04:	f800283a 	ret

8011da08 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8011da08:	defffe04 	addi	sp,sp,-8
8011da0c:	de00012e 	bgeu	sp,et,8011da14 <vFailRequestDMA+0xc>
8011da10:	003b68fa 	trap	3
8011da14:	df000115 	stw	fp,4(sp)
8011da18:	df000104 	addi	fp,sp,4
8011da1c:	2005883a 	mov	r2,r4
8011da20:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011da24:	0001883a 	nop
8011da28:	e037883a 	mov	sp,fp
8011da2c:	df000017 	ldw	fp,0(sp)
8011da30:	dec00104 	addi	sp,sp,4
8011da34:	f800283a 	ret

8011da38 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8011da38:	defffe04 	addi	sp,sp,-8
8011da3c:	de00012e 	bgeu	sp,et,8011da44 <vFailRequestDMAFromIRQ+0xc>
8011da40:	003b68fa 	trap	3
8011da44:	df000115 	stw	fp,4(sp)
8011da48:	df000104 	addi	fp,sp,4
8011da4c:	2005883a 	mov	r2,r4
8011da50:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011da54:	0001883a 	nop
8011da58:	e037883a 	mov	sp,fp
8011da5c:	df000017 	ldw	fp,0(sp)
8011da60:	dec00104 	addi	sp,sp,4
8011da64:	f800283a 	ret

8011da68 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8011da68:	defffe04 	addi	sp,sp,-8
8011da6c:	de00012e 	bgeu	sp,et,8011da74 <vFailSendRMAPFromIRQ+0xc>
8011da70:	003b68fa 	trap	3
8011da74:	df000115 	stw	fp,4(sp)
8011da78:	df000104 	addi	fp,sp,4
8011da7c:	2005883a 	mov	r2,r4
8011da80:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011da84:	0001883a 	nop
8011da88:	e037883a 	mov	sp,fp
8011da8c:	df000017 	ldw	fp,0(sp)
8011da90:	dec00104 	addi	sp,sp,4
8011da94:	f800283a 	ret

8011da98 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8011da98:	defffe04 	addi	sp,sp,-8
8011da9c:	de00012e 	bgeu	sp,et,8011daa4 <vFailSendMsgSync+0xc>
8011daa0:	003b68fa 	trap	3
8011daa4:	df000115 	stw	fp,4(sp)
8011daa8:	df000104 	addi	fp,sp,4
8011daac:	2005883a 	mov	r2,r4
8011dab0:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011dab4:	0001883a 	nop
8011dab8:	e037883a 	mov	sp,fp
8011dabc:	df000017 	ldw	fp,0(sp)
8011dac0:	dec00104 	addi	sp,sp,4
8011dac4:	f800283a 	ret

8011dac8 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8011dac8:	defffe04 	addi	sp,sp,-8
8011dacc:	de00012e 	bgeu	sp,et,8011dad4 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8011dad0:	003b68fa 	trap	3
8011dad4:	df000115 	stw	fp,4(sp)
8011dad8:	df000104 	addi	fp,sp,4
8011dadc:	2005883a 	mov	r2,r4
8011dae0:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011dae4:	0001883a 	nop
8011dae8:	e037883a 	mov	sp,fp
8011daec:	df000017 	ldw	fp,0(sp)
8011daf0:	dec00104 	addi	sp,sp,4
8011daf4:	f800283a 	ret

8011daf8 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8011daf8:	deffff04 	addi	sp,sp,-4
8011dafc:	de00012e 	bgeu	sp,et,8011db04 <vFailSendMsgMasterSyncMeb+0xc>
8011db00:	003b68fa 	trap	3
8011db04:	df000015 	stw	fp,0(sp)
8011db08:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011db0c:	0001883a 	nop
8011db10:	e037883a 	mov	sp,fp
8011db14:	df000017 	ldw	fp,0(sp)
8011db18:	dec00104 	addi	sp,sp,4
8011db1c:	f800283a 	ret

8011db20 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8011db20:	deffff04 	addi	sp,sp,-4
8011db24:	de00012e 	bgeu	sp,et,8011db2c <vFailSendMsgFeeCTRL+0xc>
8011db28:	003b68fa 	trap	3
8011db2c:	df000015 	stw	fp,0(sp)
8011db30:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011db34:	0001883a 	nop
8011db38:	e037883a 	mov	sp,fp
8011db3c:	df000017 	ldw	fp,0(sp)
8011db40:	dec00104 	addi	sp,sp,4
8011db44:	f800283a 	ret

8011db48 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8011db48:	deffff04 	addi	sp,sp,-4
8011db4c:	de00012e 	bgeu	sp,et,8011db54 <vFailSendMsgDataCTRL+0xc>
8011db50:	003b68fa 	trap	3
8011db54:	df000015 	stw	fp,0(sp)
8011db58:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011db5c:	0001883a 	nop
8011db60:	e037883a 	mov	sp,fp
8011db64:	df000017 	ldw	fp,0(sp)
8011db68:	dec00104 	addi	sp,sp,4
8011db6c:	f800283a 	ret

8011db70 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8011db70:	deffff04 	addi	sp,sp,-4
8011db74:	de00012e 	bgeu	sp,et,8011db7c <vFailFlushQueue+0xc>
8011db78:	003b68fa 	trap	3
8011db7c:	df000015 	stw	fp,0(sp)
8011db80:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011db84:	0001883a 	nop
8011db88:	e037883a 	mov	sp,fp
8011db8c:	df000017 	ldw	fp,0(sp)
8011db90:	dec00104 	addi	sp,sp,4
8011db94:	f800283a 	ret

8011db98 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8011db98:	deffff04 	addi	sp,sp,-4
8011db9c:	de00012e 	bgeu	sp,et,8011dba4 <vFailFlushQueueData+0xc>
8011dba0:	003b68fa 	trap	3
8011dba4:	df000015 	stw	fp,0(sp)
8011dba8:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011dbac:	0001883a 	nop
8011dbb0:	e037883a 	mov	sp,fp
8011dbb4:	df000017 	ldw	fp,0(sp)
8011dbb8:	dec00104 	addi	sp,sp,4
8011dbbc:	f800283a 	ret

8011dbc0 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8011dbc0:	deffff04 	addi	sp,sp,-4
8011dbc4:	de00012e 	bgeu	sp,et,8011dbcc <vFailFlushMEBQueue+0xc>
8011dbc8:	003b68fa 	trap	3
8011dbcc:	df000015 	stw	fp,0(sp)
8011dbd0:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011dbd4:	0001883a 	nop
8011dbd8:	e037883a 	mov	sp,fp
8011dbdc:	df000017 	ldw	fp,0(sp)
8011dbe0:	dec00104 	addi	sp,sp,4
8011dbe4:	f800283a 	ret

8011dbe8 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8011dbe8:	deffff04 	addi	sp,sp,-4
8011dbec:	de00012e 	bgeu	sp,et,8011dbf4 <vFailFlushNFEEQueue+0xc>
8011dbf0:	003b68fa 	trap	3
8011dbf4:	df000015 	stw	fp,0(sp)
8011dbf8:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8011dbfc:	0001883a 	nop
8011dc00:	e037883a 	mov	sp,fp
8011dc04:	df000017 	ldw	fp,0(sp)
8011dc08:	dec00104 	addi	sp,sp,4
8011dc0c:	f800283a 	ret

8011dc10 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8011dc10:	deffff04 	addi	sp,sp,-4
8011dc14:	de00012e 	bgeu	sp,et,8011dc1c <vEvtChangeMebMode+0xc>
8011dc18:	003b68fa 	trap	3
8011dc1c:	df000015 	stw	fp,0(sp)
8011dc20:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8011dc24:	0001883a 	nop
8011dc28:	e037883a 	mov	sp,fp
8011dc2c:	df000017 	ldw	fp,0(sp)
8011dc30:	dec00104 	addi	sp,sp,4
8011dc34:	f800283a 	ret

8011dc38 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8011dc38:	deffff04 	addi	sp,sp,-4
8011dc3c:	de00012e 	bgeu	sp,et,8011dc44 <vEvtChangeFeeControllerMode+0xc>
8011dc40:	003b68fa 	trap	3
8011dc44:	df000015 	stw	fp,0(sp)
8011dc48:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8011dc4c:	0001883a 	nop
8011dc50:	e037883a 	mov	sp,fp
8011dc54:	df000017 	ldw	fp,0(sp)
8011dc58:	dec00104 	addi	sp,sp,4
8011dc5c:	f800283a 	ret

8011dc60 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8011dc60:	deffff04 	addi	sp,sp,-4
8011dc64:	de00012e 	bgeu	sp,et,8011dc6c <vEvtChangeDataControllerMode+0xc>
8011dc68:	003b68fa 	trap	3
8011dc6c:	df000015 	stw	fp,0(sp)
8011dc70:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8011dc74:	0001883a 	nop
8011dc78:	e037883a 	mov	sp,fp
8011dc7c:	df000017 	ldw	fp,0(sp)
8011dc80:	dec00104 	addi	sp,sp,4
8011dc84:	f800283a 	ret

8011dc88 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8011dc88:	defffd04 	addi	sp,sp,-12
8011dc8c:	de00012e 	bgeu	sp,et,8011dc94 <vNFeeNotInUse+0xc>
8011dc90:	003b68fa 	trap	3
8011dc94:	df000215 	stw	fp,8(sp)
8011dc98:	df000204 	addi	fp,sp,8
8011dc9c:	e13ffe15 	stw	r4,-8(fp)
8011dca0:	2805883a 	mov	r2,r5
8011dca4:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8011dca8:	e0bffe17 	ldw	r2,-8(fp)
8011dcac:	e0ffff03 	ldbu	r3,-4(fp)
8011dcb0:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8011dcb4:	e0bffe17 	ldw	r2,-8(fp)
8011dcb8:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8011dcbc:	e0bffe17 	ldw	r2,-8(fp)
8011dcc0:	10002315 	stw	zero,140(r2)
}
8011dcc4:	0001883a 	nop
8011dcc8:	e037883a 	mov	sp,fp
8011dccc:	df000017 	ldw	fp,0(sp)
8011dcd0:	dec00104 	addi	sp,sp,4
8011dcd4:	f800283a 	ret

8011dcd8 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8011dcd8:	defffb04 	addi	sp,sp,-20
8011dcdc:	de00012e 	bgeu	sp,et,8011dce4 <vNFeeStructureInit+0xc>
8011dce0:	003b68fa 	trap	3
8011dce4:	dfc00415 	stw	ra,16(sp)
8011dce8:	df000315 	stw	fp,12(sp)
8011dcec:	df000304 	addi	fp,sp,12
8011dcf0:	e13ffe15 	stw	r4,-8(fp)
8011dcf4:	2805883a 	mov	r2,r5
8011dcf8:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8011dcfc:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8011dd00:	e0bffe17 	ldw	r2,-8(fp)
8011dd04:	e0ffff03 	ldbu	r3,-4(fp)
8011dd08:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8011dd0c:	e0bffe17 	ldw	r2,-8(fp)
8011dd10:	10802f04 	addi	r2,r2,188
8011dd14:	1009883a 	mov	r4,r2
8011dd18:	01197680 	call	80119768 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8011dd1c:	e13ffe17 	ldw	r4,-8(fp)
8011dd20:	011dea80 	call	8011dea8 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8011dd24:	e0bffe17 	ldw	r2,-8(fp)
8011dd28:	00c00044 	movi	r3,1
8011dd2c:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8011dd30:	e0bffe17 	ldw	r2,-8(fp)
8011dd34:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8011dd38:	e0bffe17 	ldw	r2,-8(fp)
8011dd3c:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8011dd40:	e0bffe17 	ldw	r2,-8(fp)
8011dd44:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8011dd48:	e0bffe17 	ldw	r2,-8(fp)
8011dd4c:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8011dd50:	e0bffe17 	ldw	r2,-8(fp)
8011dd54:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8011dd58:	e0bffe17 	ldw	r2,-8(fp)
8011dd5c:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8011dd60:	e0bffe17 	ldw	r2,-8(fp)
8011dd64:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8011dd68:	e0bffe17 	ldw	r2,-8(fp)
8011dd6c:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8011dd70:	e0bffe17 	ldw	r2,-8(fp)
8011dd74:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8011dd78:	e0bffe17 	ldw	r2,-8(fp)
8011dd7c:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8011dd80:	e0bffe17 	ldw	r2,-8(fp)
8011dd84:	10002d15 	stw	zero,180(r2)

    pxNfeeL->ucSPWId = (unsigned char)xDefaultsCH.ucFEEtoChanell[ ucIdNFEE ];
8011dd88:	e0ffff03 	ldbu	r3,-4(fp)
8011dd8c:	00a005b4 	movhi	r2,32790
8011dd90:	10ba3204 	addi	r2,r2,-5944
8011dd94:	10c5883a 	add	r2,r2,r3
8011dd98:	10800204 	addi	r2,r2,8
8011dd9c:	10c00003 	ldbu	r3,0(r2)
8011dda0:	e0bffe17 	ldw	r2,-8(fp)
8011dda4:	10c00045 	stb	r3,1(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8011dda8:	e03ffd05 	stb	zero,-12(fp)
8011ddac:	00000d06 	br	8011dde4 <vNFeeStructureInit+0x10c>
        pxNfeeL->xControl.ucROutOrder[ucIL] =  xDefaults.ucReadOutOrder[ucIL];
8011ddb0:	e13ffd03 	ldbu	r4,-12(fp)
8011ddb4:	e0fffd03 	ldbu	r3,-12(fp)
8011ddb8:	00a005b4 	movhi	r2,32790
8011ddbc:	10ba3604 	addi	r2,r2,-5928
8011ddc0:	10c5883a 	add	r2,r2,r3
8011ddc4:	10c00003 	ldbu	r3,0(r2)
8011ddc8:	e0bffe17 	ldw	r2,-8(fp)
8011ddcc:	1105883a 	add	r2,r2,r4
8011ddd0:	10802a44 	addi	r2,r2,169
8011ddd4:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8011ddd8:	e0bffd03 	ldbu	r2,-12(fp)
8011dddc:	10800044 	addi	r2,r2,1
8011dde0:	e0bffd05 	stb	r2,-12(fp)
8011dde4:	e0bffd03 	ldbu	r2,-12(fp)
8011dde8:	10800130 	cmpltui	r2,r2,4
8011ddec:	103ff01e 	bne	r2,zero,8011ddb0 <__reset+0xfa0fddb0>
        pxNfeeL->xControl.ucROutOrder[ucIL] =  xDefaults.ucReadOutOrder[ucIL];

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, pxNfeeL->ucSPWId ) == FALSE ) {
8011ddf0:	e0bffe17 	ldw	r2,-8(fp)
8011ddf4:	10c03204 	addi	r3,r2,200
8011ddf8:	e0bffe17 	ldw	r2,-8(fp)
8011ddfc:	10800043 	ldbu	r2,1(r2)
8011de00:	10803fcc 	andi	r2,r2,255
8011de04:	100b883a 	mov	r5,r2
8011de08:	1809883a 	mov	r4,r3
8011de0c:	0102a900 	call	80102a90 <bCommInitCh>
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
    	}
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, pxNfeeL->ucSPWId ) == FALSE ) {
8011de10:	e0bffe17 	ldw	r2,-8(fp)
8011de14:	10800043 	ldbu	r2,1(r2)
8011de18:	10803fcc 	andi	r2,r2,255
8011de1c:	100b883a 	mov	r5,r2
8011de20:	01000044 	movi	r4,1
8011de24:	01028e00 	call	801028e0 <bCommSetGlobalIrqEn>
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
    	}
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8011de28:	e0bffe17 	ldw	r2,-8(fp)
8011de2c:	10803304 	addi	r2,r2,204
8011de30:	1009883a 	mov	r4,r2
8011de34:	010325c0 	call	8010325c <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8011de38:	00a005b4 	movhi	r2,32790
8011de3c:	10ba3604 	addi	r2,r2,-5928
8011de40:	10800717 	ldw	r2,28(r2)
8011de44:	1009883a 	mov	r4,r2
8011de48:	010358c0 	call	8010358c <usiAdcPxDelayCalcPeriodNs>
8011de4c:	1007883a 	mov	r3,r2
8011de50:	e0bffe17 	ldw	r2,-8(fp)
8011de54:	10c03a8d 	sth	r3,234(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8011de58:	e0bffe17 	ldw	r2,-8(fp)
8011de5c:	10003a0d 	sth	zero,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8011de60:	00a005b4 	movhi	r2,32790
8011de64:	10ba3604 	addi	r2,r2,-5928
8011de68:	10800517 	ldw	r2,20(r2)
8011de6c:	1009883a 	mov	r4,r2
8011de70:	01036380 	call	80103638 <usiLineTrDelayCalcPeriodNs>
8011de74:	1007883a 	mov	r3,r2
8011de78:	e0bffe17 	ldw	r2,-8(fp)
8011de7c:	10c0398d 	sth	r3,230(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8011de80:	e0bffe17 	ldw	r2,-8(fp)
8011de84:	10803304 	addi	r2,r2,204
8011de88:	1009883a 	mov	r4,r2
8011de8c:	01031080 	call	80103108 <bDpktSetPixelDelay>

}
8011de90:	0001883a 	nop
8011de94:	e037883a 	mov	sp,fp
8011de98:	dfc00117 	ldw	ra,4(sp)
8011de9c:	df000017 	ldw	fp,0(sp)
8011dea0:	dec00204 	addi	sp,sp,8
8011dea4:	f800283a 	ret

8011dea8 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8011dea8:	defff404 	addi	sp,sp,-48
8011deac:	de00012e 	bgeu	sp,et,8011deb4 <vUpdateMemMapFEE+0xc>
8011deb0:	003b68fa 	trap	3
8011deb4:	df000b15 	stw	fp,44(sp)
8011deb8:	df000b04 	addi	fp,sp,44
8011debc:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8011dec0:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8011dec4:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8011dec8:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8011decc:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8011ded0:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8011ded4:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8011ded8:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8011dedc:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8011dee0:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8011dee4:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8011dee8:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8011deec:	e17fff17 	ldw	r5,-4(fp)
8011def0:	01035a34 	movhi	r4,3432
8011def4:	21348c04 	addi	r4,r4,-11728
8011def8:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8011defc:	e13fff17 	ldw	r4,-4(fp)
8011df00:	21000003 	ldbu	r4,0(r4)
8011df04:	21403fcc 	andi	r5,r4,255
8011df08:	01035a34 	movhi	r4,3432
8011df0c:	21348c04 	addi	r4,r4,-11728
8011df10:	2909383a 	mul	r4,r5,r4
8011df14:	200b883a 	mov	r5,r4
8011df18:	e13fff17 	ldw	r4,-4(fp)
8011df1c:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8011df20:	e13fff17 	ldw	r4,-4(fp)
8011df24:	21400117 	ldw	r5,4(r4)
8011df28:	01033234 	movhi	r4,3272
8011df2c:	21348c04 	addi	r4,r4,-11728
8011df30:	290b883a 	add	r5,r5,r4
8011df34:	e13fff17 	ldw	r4,-4(fp)
8011df38:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8011df3c:	e13fff17 	ldw	r4,-4(fp)
8011df40:	2100310b 	ldhu	r4,196(r4)
8011df44:	217fffcc 	andi	r5,r4,65535
8011df48:	e13fff17 	ldw	r4,-4(fp)
8011df4c:	2100300b 	ldhu	r4,192(r4)
8011df50:	213fffcc 	andi	r4,r4,65535
8011df54:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8011df58:	e13fff17 	ldw	r4,-4(fp)
8011df5c:	2100308b 	ldhu	r4,194(r4)
8011df60:	21bfffcc 	andi	r6,r4,65535
8011df64:	e13fff17 	ldw	r4,-4(fp)
8011df68:	21002f8b 	ldhu	r4,190(r4)
8011df6c:	213fffcc 	andi	r4,r4,65535
8011df70:	310d883a 	add	r6,r6,r4
8011df74:	e13fff17 	ldw	r4,-4(fp)
8011df78:	21002f0b 	ldhu	r4,188(r4)
8011df7c:	213fffcc 	andi	r4,r4,65535
8011df80:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8011df84:	2909383a 	mul	r4,r5,r4
8011df88:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8011df8c:	e13ffa17 	ldw	r4,-24(fp)
8011df90:	2109883a 	add	r4,r4,r4
8011df94:	200b883a 	mov	r5,r4
8011df98:	e13fff17 	ldw	r4,-4(fp)
8011df9c:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8011dfa0:	e13fff17 	ldw	r4,-4(fp)
8011dfa4:	21000517 	ldw	r4,20(r4)
8011dfa8:	2008d0fa 	srli	r4,r4,3
8011dfac:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8011dfb0:	e13fff17 	ldw	r4,-4(fp)
8011dfb4:	21000517 	ldw	r4,20(r4)
8011dfb8:	210001cc 	andi	r4,r4,7
8011dfbc:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8011dfc0:	e13ffb17 	ldw	r4,-20(fp)
8011dfc4:	20001226 	beq	r4,zero,8011e010 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8011dfc8:	e13ff517 	ldw	r4,-44(fp)
8011dfcc:	21000044 	addi	r4,r4,1
8011dfd0:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8011dfd4:	e13fff17 	ldw	r4,-4(fp)
8011dfd8:	21400517 	ldw	r5,20(r4)
8011dfdc:	e13ffb17 	ldw	r4,-20(fp)
8011dfe0:	2909c83a 	sub	r4,r5,r4
8011dfe4:	21400204 	addi	r5,r4,8
8011dfe8:	e13fff17 	ldw	r4,-4(fp)
8011dfec:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8011dff0:	e13ffb17 	ldw	r4,-20(fp)
8011dff4:	200b883a 	mov	r5,r4
8011dff8:	01000204 	movi	r4,8
8011dffc:	2149c83a 	sub	r4,r4,r5
8011e000:	200b883a 	mov	r5,r4
8011e004:	e13fff17 	ldw	r4,-4(fp)
8011e008:	21400605 	stb	r5,24(r4)
8011e00c:	00000206 	br	8011e018 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8011e010:	e13fff17 	ldw	r4,-4(fp)
8011e014:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8011e018:	e13ff517 	ldw	r4,-44(fp)
8011e01c:	2008d13a 	srli	r4,r4,4
8011e020:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8011e024:	e13ff517 	ldw	r4,-44(fp)
8011e028:	210003cc 	andi	r4,r4,15
8011e02c:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8011e030:	e13ffc17 	ldw	r4,-16(fp)
8011e034:	20000b26 	beq	r4,zero,8011e064 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8011e038:	e13ff717 	ldw	r4,-36(fp)
8011e03c:	21000044 	addi	r4,r4,1
8011e040:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8011e044:	e17ff517 	ldw	r5,-44(fp)
8011e048:	e13ffc17 	ldw	r4,-16(fp)
8011e04c:	290bc83a 	sub	r5,r5,r4
8011e050:	e13ff717 	ldw	r4,-36(fp)
8011e054:	2909883a 	add	r4,r5,r4
8011e058:	21000404 	addi	r4,r4,16
8011e05c:	e13ff615 	stw	r4,-40(fp)
8011e060:	00000406 	br	8011e074 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8011e064:	e17ff517 	ldw	r5,-44(fp)
8011e068:	e13ff717 	ldw	r4,-36(fp)
8011e06c:	2909883a 	add	r4,r5,r4
8011e070:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8011e074:	e13ff617 	ldw	r4,-40(fp)
8011e078:	200a90fa 	slli	r5,r4,3
8011e07c:	e13fff17 	ldw	r4,-4(fp)
8011e080:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8011e084:	e13ffb17 	ldw	r4,-20(fp)
8011e088:	20000926 	beq	r4,zero,8011e0b0 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8011e08c:	e13ffc17 	ldw	r4,-16(fp)
8011e090:	2109883a 	add	r4,r4,r4
8011e094:	2109883a 	add	r4,r4,r4
8011e098:	200b883a 	mov	r5,r4
8011e09c:	e13ffb17 	ldw	r4,-20(fp)
8011e0a0:	2008d07a 	srli	r4,r4,1
8011e0a4:	2909883a 	add	r4,r5,r4
8011e0a8:	e13ff805 	stb	r4,-32(fp)
8011e0ac:	00000406 	br	8011e0c0 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8011e0b0:	e13ffc17 	ldw	r4,-16(fp)
8011e0b4:	2109883a 	add	r4,r4,r4
8011e0b8:	2109883a 	add	r4,r4,r4
8011e0bc:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8011e0c0:	e13ff803 	ldbu	r4,-32(fp)
8011e0c4:	01401004 	movi	r5,64
8011e0c8:	2909c83a 	sub	r4,r5,r4
8011e0cc:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);
8011e0d0:	e13ffd03 	ldbu	r4,-12(fp)
8011e0d4:	217ff804 	addi	r5,r4,-32
8011e0d8:	28000416 	blt	r5,zero,8011e0ec <vUpdateMemMapFEE+0x244>
8011e0dc:	013fffc4 	movi	r4,-1
8011e0e0:	2146983a 	sll	r3,r4,r5
8011e0e4:	0005883a 	mov	r2,zero
8011e0e8:	00000a06 	br	8011e114 <vUpdateMemMapFEE+0x26c>
8011e0ec:	017fffc4 	movi	r5,-1
8011e0f0:	280cd07a 	srli	r6,r5,1
8011e0f4:	014007c4 	movi	r5,31
8011e0f8:	290bc83a 	sub	r5,r5,r4
8011e0fc:	314ad83a 	srl	r5,r6,r5
8011e100:	01bfffc4 	movi	r6,-1
8011e104:	3106983a 	sll	r3,r6,r4
8011e108:	28c6b03a 	or	r3,r5,r3
8011e10c:	017fffc4 	movi	r5,-1
8011e110:	2904983a 	sll	r2,r5,r4
8011e114:	e13fff17 	ldw	r4,-4(fp)
8011e118:	20800715 	stw	r2,28(r4)
8011e11c:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF);


    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8011e120:	e0bfff17 	ldw	r2,-4(fp)
8011e124:	e0fff717 	ldw	r3,-36(fp)
8011e128:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8011e12c:	e0bfff17 	ldw	r2,-4(fp)
8011e130:	10c00117 	ldw	r3,4(r2)
8011e134:	008004b4 	movhi	r2,18
8011e138:	10a40004 	addi	r2,r2,-28672
8011e13c:	1885883a 	add	r2,r3,r2
8011e140:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8011e144:	e0bfff17 	ldw	r2,-4(fp)
8011e148:	10c00517 	ldw	r3,20(r2)
8011e14c:	008000b4 	movhi	r2,2
8011e150:	10a40004 	addi	r2,r2,-28672
8011e154:	1885883a 	add	r2,r3,r2
8011e158:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8011e15c:	e03ff845 	stb	zero,-31(fp)
8011e160:	00001906 	br	8011e1c8 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8011e164:	e0bff843 	ldbu	r2,-31(fp)
8011e168:	e0ffff17 	ldw	r3,-4(fp)
8011e16c:	10800624 	muli	r2,r2,24
8011e170:	1885883a 	add	r2,r3,r2
8011e174:	10800904 	addi	r2,r2,36
8011e178:	e0fff917 	ldw	r3,-28(fp)
8011e17c:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8011e180:	e0fff917 	ldw	r3,-28(fp)
8011e184:	e0bffe17 	ldw	r2,-8(fp)
8011e188:	1885883a 	add	r2,r3,r2
8011e18c:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8011e190:	e0bff843 	ldbu	r2,-31(fp)
8011e194:	e0ffff17 	ldw	r3,-4(fp)
8011e198:	10800624 	muli	r2,r2,24
8011e19c:	1885883a 	add	r2,r3,r2
8011e1a0:	10800c04 	addi	r2,r2,48
8011e1a4:	e0fff917 	ldw	r3,-28(fp)
8011e1a8:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8011e1ac:	e0fff917 	ldw	r3,-28(fp)
8011e1b0:	e0bffe17 	ldw	r2,-8(fp)
8011e1b4:	1885883a 	add	r2,r3,r2
8011e1b8:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8011e1bc:	e0bff843 	ldbu	r2,-31(fp)
8011e1c0:	10800044 	addi	r2,r2,1
8011e1c4:	e0bff845 	stb	r2,-31(fp)
8011e1c8:	e0bff843 	ldbu	r2,-31(fp)
8011e1cc:	10800130 	cmpltui	r2,r2,4
8011e1d0:	103fe41e 	bne	r2,zero,8011e164 <__reset+0xfa0fe164>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
8011e1d4:	0001883a 	nop
8011e1d8:	e037883a 	mov	sp,fp
8011e1dc:	df000017 	ldw	fp,0(sp)
8011e1e0:	dec00104 	addi	sp,sp,4
8011e1e4:	f800283a 	ret

8011e1e8 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8011e1e8:	defffd04 	addi	sp,sp,-12
8011e1ec:	de00012e 	bgeu	sp,et,8011e1f4 <vResetMemCCDFEE+0xc>
8011e1f0:	003b68fa 	trap	3
8011e1f4:	df000215 	stw	fp,8(sp)
8011e1f8:	df000204 	addi	fp,sp,8
8011e1fc:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8011e200:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8011e204:	e03ffe05 	stb	zero,-8(fp)
8011e208:	00001b06 	br	8011e278 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8011e20c:	e0bffe03 	ldbu	r2,-8(fp)
8011e210:	e0ffff17 	ldw	r3,-4(fp)
8011e214:	10800624 	muli	r2,r2,24
8011e218:	1885883a 	add	r2,r3,r2
8011e21c:	10800b04 	addi	r2,r2,44
8011e220:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8011e224:	e0bffe03 	ldbu	r2,-8(fp)
8011e228:	e0ffff17 	ldw	r3,-4(fp)
8011e22c:	10800624 	muli	r2,r2,24
8011e230:	1885883a 	add	r2,r3,r2
8011e234:	10800a04 	addi	r2,r2,40
8011e238:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8011e23c:	e0bffe03 	ldbu	r2,-8(fp)
8011e240:	e0ffff17 	ldw	r3,-4(fp)
8011e244:	10800624 	muli	r2,r2,24
8011e248:	1885883a 	add	r2,r3,r2
8011e24c:	10800e04 	addi	r2,r2,56
8011e250:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8011e254:	e0bffe03 	ldbu	r2,-8(fp)
8011e258:	e0ffff17 	ldw	r3,-4(fp)
8011e25c:	10800624 	muli	r2,r2,24
8011e260:	1885883a 	add	r2,r3,r2
8011e264:	10800d04 	addi	r2,r2,52
8011e268:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8011e26c:	e0bffe03 	ldbu	r2,-8(fp)
8011e270:	10800044 	addi	r2,r2,1
8011e274:	e0bffe05 	stb	r2,-8(fp)
8011e278:	e0bffe03 	ldbu	r2,-8(fp)
8011e27c:	10800130 	cmpltui	r2,r2,4
8011e280:	103fe21e 	bne	r2,zero,8011e20c <__reset+0xfa0fe20c>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8011e284:	0001883a 	nop
8011e288:	e037883a 	mov	sp,fp
8011e28c:	df000017 	ldw	fp,0(sp)
8011e290:	dec00104 	addi	sp,sp,4
8011e294:	f800283a 	ret

8011e298 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8011e298:	defffe04 	addi	sp,sp,-8
8011e29c:	de00012e 	bgeu	sp,et,8011e2a4 <vFeeSpwRMAPLoadDefault+0xc>
8011e2a0:	003b68fa 	trap	3
8011e2a4:	df000115 	stw	fp,4(sp)
8011e2a8:	df000104 	addi	fp,sp,4
8011e2ac:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8011e2b0:	0001883a 	nop
8011e2b4:	e037883a 	mov	sp,fp
8011e2b8:	df000017 	ldw	fp,0(sp)
8011e2bc:	dec00104 	addi	sp,sp,4
8011e2c0:	f800283a 	ret

8011e2c4 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8011e2c4:	defffe04 	addi	sp,sp,-8
8011e2c8:	de00012e 	bgeu	sp,et,8011e2d0 <vFeeSpwRMAPChangeConfig+0xc>
8011e2cc:	003b68fa 	trap	3
8011e2d0:	df000115 	stw	fp,4(sp)
8011e2d4:	df000104 	addi	fp,sp,4
8011e2d8:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8011e2dc:	0001883a 	nop
8011e2e0:	e037883a 	mov	sp,fp
8011e2e4:	df000017 	ldw	fp,0(sp)
8011e2e8:	dec00104 	addi	sp,sp,4
8011e2ec:	f800283a 	ret

8011e2f0 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8011e2f0:	defffe04 	addi	sp,sp,-8
8011e2f4:	de00012e 	bgeu	sp,et,8011e2fc <vFeeSpwRMAPChangeDefault+0xc>
8011e2f8:	003b68fa 	trap	3
8011e2fc:	df000115 	stw	fp,4(sp)
8011e300:	df000104 	addi	fp,sp,4
8011e304:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8011e308:	0001883a 	nop
8011e30c:	e037883a 	mov	sp,fp
8011e310:	df000017 	ldw	fp,0(sp)
8011e314:	dec00104 	addi	sp,sp,4
8011e318:	f800283a 	ret

8011e31c <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8011e31c:	defffe04 	addi	sp,sp,-8
8011e320:	de00012e 	bgeu	sp,et,8011e328 <cFeeSpwChannelEnable+0xc>
8011e324:	003b68fa 	trap	3
8011e328:	df000115 	stw	fp,4(sp)
8011e32c:	df000104 	addi	fp,sp,4
8011e330:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8011e334:	0001883a 	nop
8011e338:	e037883a 	mov	sp,fp
8011e33c:	df000017 	ldw	fp,0(sp)
8011e340:	dec00104 	addi	sp,sp,4
8011e344:	f800283a 	ret

8011e348 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8011e348:	defffe04 	addi	sp,sp,-8
8011e34c:	de00012e 	bgeu	sp,et,8011e354 <cFeeSpwChannelDisable+0xc>
8011e350:	003b68fa 	trap	3
8011e354:	df000115 	stw	fp,4(sp)
8011e358:	df000104 	addi	fp,sp,4
8011e35c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8011e360:	0001883a 	nop
8011e364:	e037883a 	mov	sp,fp
8011e368:	df000017 	ldw	fp,0(sp)
8011e36c:	dec00104 	addi	sp,sp,4
8011e370:	f800283a 	ret

8011e374 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8011e374:	defffe04 	addi	sp,sp,-8
8011e378:	de00012e 	bgeu	sp,et,8011e380 <cFeeRMAPDump+0xc>
8011e37c:	003b68fa 	trap	3
8011e380:	df000115 	stw	fp,4(sp)
8011e384:	df000104 	addi	fp,sp,4
8011e388:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8011e38c:	0001883a 	nop
8011e390:	e037883a 	mov	sp,fp
8011e394:	df000017 	ldw	fp,0(sp)
8011e398:	dec00104 	addi	sp,sp,4
8011e39c:	f800283a 	ret

8011e3a0 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8011e3a0:	defffe04 	addi	sp,sp,-8
8011e3a4:	de00012e 	bgeu	sp,et,8011e3ac <cFeeRMAPEchoingEnable+0xc>
8011e3a8:	003b68fa 	trap	3
8011e3ac:	df000115 	stw	fp,4(sp)
8011e3b0:	df000104 	addi	fp,sp,4
8011e3b4:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8011e3b8:	e0bfff17 	ldw	r2,-4(fp)
8011e3bc:	00c00044 	movi	r3,1
8011e3c0:	10c02515 	stw	r3,148(r2)
}
8011e3c4:	0001883a 	nop
8011e3c8:	e037883a 	mov	sp,fp
8011e3cc:	df000017 	ldw	fp,0(sp)
8011e3d0:	dec00104 	addi	sp,sp,4
8011e3d4:	f800283a 	ret

8011e3d8 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8011e3d8:	defffe04 	addi	sp,sp,-8
8011e3dc:	de00012e 	bgeu	sp,et,8011e3e4 <cFeeRMAPEchoingDisable+0xc>
8011e3e0:	003b68fa 	trap	3
8011e3e4:	df000115 	stw	fp,4(sp)
8011e3e8:	df000104 	addi	fp,sp,4
8011e3ec:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8011e3f0:	e0bfff17 	ldw	r2,-4(fp)
8011e3f4:	10002515 	stw	zero,148(r2)
}
8011e3f8:	0001883a 	nop
8011e3fc:	e037883a 	mov	sp,fp
8011e400:	df000017 	ldw	fp,0(sp)
8011e404:	dec00104 	addi	sp,sp,4
8011e408:	f800283a 	ret

8011e40c <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8011e40c:	defffe04 	addi	sp,sp,-8
8011e410:	de00012e 	bgeu	sp,et,8011e418 <cFeeRMAPLogEnable+0xc>
8011e414:	003b68fa 	trap	3
8011e418:	df000115 	stw	fp,4(sp)
8011e41c:	df000104 	addi	fp,sp,4
8011e420:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8011e424:	e0bfff17 	ldw	r2,-4(fp)
8011e428:	00c00044 	movi	r3,1
8011e42c:	10c02415 	stw	r3,144(r2)
}
8011e430:	0001883a 	nop
8011e434:	e037883a 	mov	sp,fp
8011e438:	df000017 	ldw	fp,0(sp)
8011e43c:	dec00104 	addi	sp,sp,4
8011e440:	f800283a 	ret

8011e444 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8011e444:	defffe04 	addi	sp,sp,-8
8011e448:	de00012e 	bgeu	sp,et,8011e450 <cFeeRMAPLogDisable+0xc>
8011e44c:	003b68fa 	trap	3
8011e450:	df000115 	stw	fp,4(sp)
8011e454:	df000104 	addi	fp,sp,4
8011e458:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8011e45c:	e0bfff17 	ldw	r2,-4(fp)
8011e460:	10002415 	stw	zero,144(r2)
}
8011e464:	0001883a 	nop
8011e468:	e037883a 	mov	sp,fp
8011e46c:	df000017 	ldw	fp,0(sp)
8011e470:	dec00104 	addi	sp,sp,4
8011e474:	f800283a 	ret

8011e478 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8011e478:	defffc04 	addi	sp,sp,-16
8011e47c:	de00012e 	bgeu	sp,et,8011e484 <vNFeeControlInit+0xc>
8011e480:	003b68fa 	trap	3
8011e484:	dfc00315 	stw	ra,12(sp)
8011e488:	df000215 	stw	fp,8(sp)
8011e48c:	df000204 	addi	fp,sp,8
8011e490:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8011e494:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8011e498:	e13fff17 	ldw	r4,-4(fp)
8011e49c:	011e5c80 	call	8011e5c8 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8011e4a0:	e13fff17 	ldw	r4,-4(fp)
8011e4a4:	011e5fc0 	call	8011e5fc <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8011e4a8:	e0bfff17 	ldw	r2,-4(fp)
8011e4ac:	10027615 	stw	zero,2520(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8011e4b0:	e03ffe05 	stb	zero,-8(fp)
8011e4b4:	00002b06 	br	8011e564 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8011e4b8:	e0bffe03 	ldbu	r2,-8(fp)
8011e4bc:	10809b24 	muli	r2,r2,620
8011e4c0:	e0ffff17 	ldw	r3,-4(fp)
8011e4c4:	1885883a 	add	r2,r3,r2
8011e4c8:	e0fffe03 	ldbu	r3,-8(fp)
8011e4cc:	180b883a 	mov	r5,r3
8011e4d0:	1009883a 	mov	r4,r2
8011e4d4:	011dcd80 	call	8011dcd8 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8011e4d8:	e0bffe03 	ldbu	r2,-8(fp)
8011e4dc:	e0fffe03 	ldbu	r3,-8(fp)
8011e4e0:	18c09b24 	muli	r3,r3,620
8011e4e4:	18c02104 	addi	r3,r3,132
8011e4e8:	e13fff17 	ldw	r4,-4(fp)
8011e4ec:	20c7883a 	add	r3,r4,r3
8011e4f0:	e13fff17 	ldw	r4,-4(fp)
8011e4f4:	10809b44 	addi	r2,r2,621
8011e4f8:	1085883a 	add	r2,r2,r2
8011e4fc:	1085883a 	add	r2,r2,r2
8011e500:	2085883a 	add	r2,r4,r2
8011e504:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8011e508:	e0bffe03 	ldbu	r2,-8(fp)
8011e50c:	e0fffe03 	ldbu	r3,-8(fp)
8011e510:	18c09b24 	muli	r3,r3,620
8011e514:	18c02704 	addi	r3,r3,156
8011e518:	e13fff17 	ldw	r4,-4(fp)
8011e51c:	20c7883a 	add	r3,r4,r3
8011e520:	e13fff17 	ldw	r4,-4(fp)
8011e524:	10809c44 	addi	r2,r2,625
8011e528:	1085883a 	add	r2,r2,r2
8011e52c:	1085883a 	add	r2,r2,r2
8011e530:	2085883a 	add	r2,r4,r2
8011e534:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8011e538:	e0bffe03 	ldbu	r2,-8(fp)
8011e53c:	e0ffff17 	ldw	r3,-4(fp)
8011e540:	18c26c17 	ldw	r3,2480(r3)
8011e544:	e13fff17 	ldw	r4,-4(fp)
8011e548:	10809b24 	muli	r2,r2,620
8011e54c:	2085883a 	add	r2,r4,r2
8011e550:	10802904 	addi	r2,r2,164
8011e554:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8011e558:	e0bffe03 	ldbu	r2,-8(fp)
8011e55c:	10800044 	addi	r2,r2,1
8011e560:	e0bffe05 	stb	r2,-8(fp)
8011e564:	e0bffe03 	ldbu	r2,-8(fp)
8011e568:	10800130 	cmpltui	r2,r2,4
8011e56c:	103fd21e 	bne	r2,zero,8011e4b8 <__reset+0xfa0fe4b8>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8011e570:	0001883a 	nop
8011e574:	e037883a 	mov	sp,fp
8011e578:	dfc00117 	ldw	ra,4(sp)
8011e57c:	df000017 	ldw	fp,0(sp)
8011e580:	dec00204 	addi	sp,sp,8
8011e584:	f800283a 	ret

8011e588 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8011e588:	defffd04 	addi	sp,sp,-12
8011e58c:	de00012e 	bgeu	sp,et,8011e594 <vSetTimeCode+0xc>
8011e590:	003b68fa 	trap	3
8011e594:	df000215 	stw	fp,8(sp)
8011e598:	df000204 	addi	fp,sp,8
8011e59c:	e13ffe15 	stw	r4,-8(fp)
8011e5a0:	2805883a 	mov	r2,r5
8011e5a4:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8011e5a8:	e0bffe17 	ldw	r2,-8(fp)
8011e5ac:	e0ffff03 	ldbu	r3,-4(fp)
8011e5b0:	10c27505 	stb	r3,2516(r2)
}
8011e5b4:	0001883a 	nop
8011e5b8:	e037883a 	mov	sp,fp
8011e5bc:	df000017 	ldw	fp,0(sp)
8011e5c0:	dec00104 	addi	sp,sp,4
8011e5c4:	f800283a 	ret

8011e5c8 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8011e5c8:	defffe04 	addi	sp,sp,-8
8011e5cc:	de00012e 	bgeu	sp,et,8011e5d4 <vResetTimeCode+0xc>
8011e5d0:	003b68fa 	trap	3
8011e5d4:	df000115 	stw	fp,4(sp)
8011e5d8:	df000104 	addi	fp,sp,4
8011e5dc:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8011e5e0:	e0bfff17 	ldw	r2,-4(fp)
8011e5e4:	10027505 	stb	zero,2516(r2)
}
8011e5e8:	0001883a 	nop
8011e5ec:	e037883a 	mov	sp,fp
8011e5f0:	df000017 	ldw	fp,0(sp)
8011e5f4:	dec00104 	addi	sp,sp,4
8011e5f8:	f800283a 	ret

8011e5fc <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8011e5fc:	defffe04 	addi	sp,sp,-8
8011e600:	de00012e 	bgeu	sp,et,8011e608 <vLoadDefaultIdNFEEMaster+0xc>
8011e604:	003b68fa 	trap	3
8011e608:	df000115 	stw	fp,4(sp)
8011e60c:	df000104 	addi	fp,sp,4
8011e610:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8011e614:	e0bfff17 	ldw	r2,-4(fp)
8011e618:	10027545 	stb	zero,2517(r2)
}
8011e61c:	0001883a 	nop
8011e620:	e037883a 	mov	sp,fp
8011e624:	df000017 	ldw	fp,0(sp)
8011e628:	dec00104 	addi	sp,sp,4
8011e62c:	f800283a 	ret

8011e630 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8011e630:	defffd04 	addi	sp,sp,-12
8011e634:	de00012e 	bgeu	sp,et,8011e63c <vChangeIdNFEEMaster+0xc>
8011e638:	003b68fa 	trap	3
8011e63c:	df000215 	stw	fp,8(sp)
8011e640:	df000204 	addi	fp,sp,8
8011e644:	e13ffe15 	stw	r4,-8(fp)
8011e648:	2805883a 	mov	r2,r5
8011e64c:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8011e650:	e0bffe17 	ldw	r2,-8(fp)
8011e654:	e0ffff03 	ldbu	r3,-4(fp)
8011e658:	10c27545 	stb	r3,2517(r2)
}
8011e65c:	0001883a 	nop
8011e660:	e037883a 	mov	sp,fp
8011e664:	df000017 	ldw	fp,0(sp)
8011e668:	dec00104 	addi	sp,sp,4
8011e66c:	f800283a 	ret

8011e670 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8011e670:	defffd04 	addi	sp,sp,-12
8011e674:	de00012e 	bgeu	sp,et,8011e67c <vChangeDefaultIdNFEEMaster+0xc>
8011e678:	003b68fa 	trap	3
8011e67c:	df000215 	stw	fp,8(sp)
8011e680:	df000204 	addi	fp,sp,8
8011e684:	e13ffe15 	stw	r4,-8(fp)
8011e688:	2805883a 	mov	r2,r5
8011e68c:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8011e690:	0001883a 	nop
8011e694:	e037883a 	mov	sp,fp
8011e698:	df000017 	ldw	fp,0(sp)
8011e69c:	dec00104 	addi	sp,sp,4
8011e6a0:	f800283a 	ret

8011e6a4 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8011e6a4:	defffe04 	addi	sp,sp,-8
8011e6a8:	de00012e 	bgeu	sp,et,8011e6b0 <vInitSimucamBasicHW+0xc>
8011e6ac:	003b68fa 	trap	3
8011e6b0:	dfc00115 	stw	ra,4(sp)
8011e6b4:	df000015 	stw	fp,0(sp)
8011e6b8:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8011e6bc:	01403fc4 	movi	r5,255
8011e6c0:	0009883a 	mov	r4,zero
8011e6c4:	010bae40 	call	8010bae4 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8011e6c8:	01400834 	movhi	r5,32
8011e6cc:	297fffc4 	addi	r5,r5,-1
8011e6d0:	0009883a 	mov	r4,zero
8011e6d4:	010bb640 	call	8010bb64 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8011e6d8:	01400074 	movhi	r5,1
8011e6dc:	01000044 	movi	r4,1
8011e6e0:	010bb640 	call	8010bb64 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8011e6e4:	0009883a 	mov	r4,zero
8011e6e8:	010d0480 	call	8010d048 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8011e6ec:	0009883a 	mov	r4,zero
8011e6f0:	010d1180 	call	8010d118 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8011e6f4:	01008004 	movi	r4,512
8011e6f8:	010cbf80 	call	8010cbf8 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8011e6fc:	01008004 	movi	r4,512
8011e700:	010cb840 	call	8010cb84 <vRstcReleaseDeviceReset>

	bDisableIsoDrivers();
8011e704:	010b1780 	call	8010b178 <bDisableIsoDrivers>
	bDisableLvdsBoard();
8011e708:	010b1f00 	call	8010b1f0 <bDisableLvdsBoard>

	/* Turn on all Panel Leds */
	bSetPainelLeds( LEDS_ON, LEDS_PAINEL_ALL_MASK );
8011e70c:	01400834 	movhi	r5,32
8011e710:	297fffc4 	addi	r5,r5,-1
8011e714:	01000044 	movi	r4,1
8011e718:	010bb640 	call	8010bb64 <bSetPainelLeds>
	usleep(5000000);
8011e71c:	01001334 	movhi	r4,76
8011e720:	2112d004 	addi	r4,r4,19264
8011e724:	01330f80 	call	801330f8 <usleep>
	/* initial values for the Leds */
	bSetPainelLeds( LEDS_OFF, LEDS_PAINEL_ALL_MASK );
8011e728:	01400834 	movhi	r5,32
8011e72c:	297fffc4 	addi	r5,r5,-1
8011e730:	0009883a 	mov	r4,zero
8011e734:	010bb640 	call	8010bb64 <bSetPainelLeds>

	bSetPainelLeds( LEDS_ON, LEDS_R_ALL_MASK | LEDS_POWER_MASK );
8011e738:	014000b4 	movhi	r5,2
8011e73c:	296aaa84 	addi	r5,r5,-21846
8011e740:	01000044 	movi	r4,1
8011e744:	010bb640 	call	8010bb64 <bSetPainelLeds>

}
8011e748:	0001883a 	nop
8011e74c:	e037883a 	mov	sp,fp
8011e750:	dfc00117 	ldw	ra,4(sp)
8011e754:	df000017 	ldw	fp,0(sp)
8011e758:	dec00204 	addi	sp,sp,8
8011e75c:	f800283a 	ret

8011e760 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8011e760:	defffd04 	addi	sp,sp,-12
8011e764:	de00012e 	bgeu	sp,et,8011e76c <bLogWriteSDCard+0xc>
8011e768:	003b68fa 	trap	3
8011e76c:	df000215 	stw	fp,8(sp)
8011e770:	df000204 	addi	fp,sp,8
8011e774:	e13ffe15 	stw	r4,-8(fp)
8011e778:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8011e77c:	00800044 	movi	r2,1
}
8011e780:	e037883a 	mov	sp,fp
8011e784:	df000017 	ldw	fp,0(sp)
8011e788:	dec00104 	addi	sp,sp,4
8011e78c:	f800283a 	ret

8011e790 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8011e790:	deffe004 	addi	sp,sp,-128
8011e794:	de00012e 	bgeu	sp,et,8011e79c <vLogWriteNUC+0xc>
8011e798:	003b68fa 	trap	3
8011e79c:	dfc01f15 	stw	ra,124(sp)
8011e7a0:	df001e15 	stw	fp,120(sp)
8011e7a4:	df001e04 	addi	fp,sp,120
8011e7a8:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8011e7ac:	e03fe215 	stw	zero,-120(fp)
8011e7b0:	e0bfe304 	addi	r2,fp,-116
8011e7b4:	00c01b84 	movi	r3,110
8011e7b8:	180d883a 	mov	r6,r3
8011e7bc:	000b883a 	mov	r5,zero
8011e7c0:	1009883a 	mov	r4,r2
8011e7c4:	01215b40 	call	801215b4 <memset>
	memset(cTemp,0,114);
8011e7c8:	01801c84 	movi	r6,114
8011e7cc:	000b883a 	mov	r5,zero
8011e7d0:	e13fe204 	addi	r4,fp,-120
8011e7d4:	01215b40 	call	801215b4 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8011e7d8:	e13fff17 	ldw	r4,-4(fp)
8011e7dc:	01219540 	call	80121954 <strlen>
8011e7e0:	10801c68 	cmpgeui	r2,r2,113
8011e7e4:	1000031e 	bne	r2,zero,8011e7f4 <vLogWriteNUC+0x64>
8011e7e8:	e13fff17 	ldw	r4,-4(fp)
8011e7ec:	01219540 	call	80121954 <strlen>
8011e7f0:	00000106 	br	8011e7f8 <vLogWriteNUC+0x68>
8011e7f4:	00801c44 	movi	r2,113
8011e7f8:	100d883a 	mov	r6,r2
8011e7fc:	e17fff17 	ldw	r5,-4(fp)
8011e800:	e13fe204 	addi	r4,fp,-120
8011e804:	01214640 	call	80121464 <memcpy>
	vSendLog ( cDataIn );
8011e808:	e13fff17 	ldw	r4,-4(fp)
8011e80c:	011a5800 	call	8011a580 <vSendLog>
}
8011e810:	0001883a 	nop
8011e814:	e037883a 	mov	sp,fp
8011e818:	dfc00117 	ldw	ra,4(sp)
8011e81c:	df000017 	ldw	fp,0(sp)
8011e820:	dec00204 	addi	sp,sp,8
8011e824:	f800283a 	ret

8011e828 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8011e828:	defffd04 	addi	sp,sp,-12
8011e82c:	de00012e 	bgeu	sp,et,8011e834 <vSimucamStructureInit+0xc>
8011e830:	003b68fa 	trap	3
8011e834:	dfc00215 	stw	ra,8(sp)
8011e838:	df000115 	stw	fp,4(sp)
8011e83c:	df000104 	addi	fp,sp,4
8011e840:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8011e844:	e0bfff17 	ldw	r2,-4(fp)
8011e848:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8011e84c:	e0bfff17 	ldw	r2,-4(fp)
8011e850:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8011e854:	e13fff17 	ldw	r4,-4(fp)
8011e858:	011e9140 	call	8011e914 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8011e85c:	e13fff17 	ldw	r4,-4(fp)
8011e860:	011e9b80 	call	8011e9b8 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8011e864:	e13fff17 	ldw	r4,-4(fp)
8011e868:	011ea600 	call	8011ea60 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8011e86c:	e13fff17 	ldw	r4,-4(fp)
8011e870:	011eb000 	call	8011eb00 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8011e874:	e0bfff17 	ldw	r2,-4(fp)
8011e878:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8011e87c:	e0bfff17 	ldw	r2,-4(fp)
8011e880:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8011e884:	e0bfff17 	ldw	r2,-4(fp)
8011e888:	00c07d04 	movi	r3,500
8011e88c:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8011e890:	e0bfff17 	ldw	r2,-4(fp)
8011e894:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8011e898:	e0bfff17 	ldw	r2,-4(fp)
8011e89c:	00c00044 	movi	r3,1
8011e8a0:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8011e8a4:	e0bfff17 	ldw	r2,-4(fp)
8011e8a8:	10c00204 	addi	r3,r2,8
8011e8ac:	e0bfff17 	ldw	r2,-4(fp)
8011e8b0:	10c28715 	stw	r3,2588(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8011e8b4:	e0bfff17 	ldw	r2,-4(fp)
8011e8b8:	10c00244 	addi	r3,r2,9
8011e8bc:	e0bfff17 	ldw	r2,-4(fp)
8011e8c0:	10c01a15 	stw	r3,104(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8011e8c4:	e0bfff17 	ldw	r2,-4(fp)
8011e8c8:	10800017 	ldw	r2,0(r2)
8011e8cc:	10000b1e 	bne	r2,zero,8011e8fc <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8011e8d0:	e0bfff17 	ldw	r2,-4(fp)
8011e8d4:	10801b04 	addi	r2,r2,108
8011e8d8:	1009883a 	mov	r4,r2
8011e8dc:	011e4780 	call	8011e478 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8011e8e0:	e0bfff17 	ldw	r2,-4(fp)
8011e8e4:	10c00a04 	addi	r3,r2,40
8011e8e8:	e0bfff17 	ldw	r2,-4(fp)
8011e8ec:	10801b04 	addi	r2,r2,108
8011e8f0:	100b883a 	mov	r5,r2
8011e8f4:	1809883a 	mov	r4,r3
8011e8f8:	011cd600 	call	8011cd60 <vDataControllerInit>
        /* Are Fast Fee instances */
        /* todo: Not in use yet */
    }

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */
}
8011e8fc:	0001883a 	nop
8011e900:	e037883a 	mov	sp,fp
8011e904:	dfc00117 	ldw	ra,4(sp)
8011e908:	df000017 	ldw	fp,0(sp)
8011e90c:	dec00204 	addi	sp,sp,8
8011e910:	f800283a 	ret

8011e914 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8011e914:	defffe04 	addi	sp,sp,-8
8011e918:	de00012e 	bgeu	sp,et,8011e920 <vLoadDefaultEPValue+0xc>
8011e91c:	003b68fa 	trap	3
8011e920:	df000115 	stw	fp,4(sp)
8011e924:	df000104 	addi	fp,sp,4
8011e928:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8011e92c:	e0bfff17 	ldw	r2,-4(fp)
8011e930:	00d07234 	movhi	r3,16840
8011e934:	10c00315 	stw	r3,12(r2)
}
8011e938:	0001883a 	nop
8011e93c:	e037883a 	mov	sp,fp
8011e940:	df000017 	ldw	fp,0(sp)
8011e944:	dec00104 	addi	sp,sp,4
8011e948:	f800283a 	ret

8011e94c <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8011e94c:	defffd04 	addi	sp,sp,-12
8011e950:	de00012e 	bgeu	sp,et,8011e958 <vChangeEPValue+0xc>
8011e954:	003b68fa 	trap	3
8011e958:	df000215 	stw	fp,8(sp)
8011e95c:	df000204 	addi	fp,sp,8
8011e960:	e13ffe15 	stw	r4,-8(fp)
8011e964:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8011e968:	e0bffe17 	ldw	r2,-8(fp)
8011e96c:	e0ffff17 	ldw	r3,-4(fp)
8011e970:	10c00315 	stw	r3,12(r2)
}
8011e974:	0001883a 	nop
8011e978:	e037883a 	mov	sp,fp
8011e97c:	df000017 	ldw	fp,0(sp)
8011e980:	dec00104 	addi	sp,sp,4
8011e984:	f800283a 	ret

8011e988 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8011e988:	defffd04 	addi	sp,sp,-12
8011e98c:	de00012e 	bgeu	sp,et,8011e994 <vChangeDefaultEPValue+0xc>
8011e990:	003b68fa 	trap	3
8011e994:	df000215 	stw	fp,8(sp)
8011e998:	df000204 	addi	fp,sp,8
8011e99c:	e13ffe15 	stw	r4,-8(fp)
8011e9a0:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8011e9a4:	0001883a 	nop
8011e9a8:	e037883a 	mov	sp,fp
8011e9ac:	df000017 	ldw	fp,0(sp)
8011e9b0:	dec00104 	addi	sp,sp,4
8011e9b4:	f800283a 	ret

8011e9b8 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8011e9b8:	defffe04 	addi	sp,sp,-8
8011e9bc:	de00012e 	bgeu	sp,et,8011e9c4 <vLoadDefaultRTValue+0xc>
8011e9c0:	003b68fa 	trap	3
8011e9c4:	df000115 	stw	fp,4(sp)
8011e9c8:	df000104 	addi	fp,sp,4
8011e9cc:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8011e9d0:	e0ffff17 	ldw	r3,-4(fp)
8011e9d4:	00901eb4 	movhi	r2,16506
8011e9d8:	10a66684 	addi	r2,r2,-26214
8011e9dc:	18800415 	stw	r2,16(r3)
}
8011e9e0:	0001883a 	nop
8011e9e4:	e037883a 	mov	sp,fp
8011e9e8:	df000017 	ldw	fp,0(sp)
8011e9ec:	dec00104 	addi	sp,sp,4
8011e9f0:	f800283a 	ret

8011e9f4 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8011e9f4:	defffd04 	addi	sp,sp,-12
8011e9f8:	de00012e 	bgeu	sp,et,8011ea00 <vChangeRTValue+0xc>
8011e9fc:	003b68fa 	trap	3
8011ea00:	df000215 	stw	fp,8(sp)
8011ea04:	df000204 	addi	fp,sp,8
8011ea08:	e13ffe15 	stw	r4,-8(fp)
8011ea0c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8011ea10:	e0bffe17 	ldw	r2,-8(fp)
8011ea14:	e0ffff17 	ldw	r3,-4(fp)
8011ea18:	10c00415 	stw	r3,16(r2)
}
8011ea1c:	0001883a 	nop
8011ea20:	e037883a 	mov	sp,fp
8011ea24:	df000017 	ldw	fp,0(sp)
8011ea28:	dec00104 	addi	sp,sp,4
8011ea2c:	f800283a 	ret

8011ea30 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8011ea30:	defffd04 	addi	sp,sp,-12
8011ea34:	de00012e 	bgeu	sp,et,8011ea3c <vChangeDefaultRTValue+0xc>
8011ea38:	003b68fa 	trap	3
8011ea3c:	df000215 	stw	fp,8(sp)
8011ea40:	df000204 	addi	fp,sp,8
8011ea44:	e13ffe15 	stw	r4,-8(fp)
8011ea48:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8011ea4c:	0001883a 	nop
8011ea50:	e037883a 	mov	sp,fp
8011ea54:	df000017 	ldw	fp,0(sp)
8011ea58:	dec00104 	addi	sp,sp,4
8011ea5c:	f800283a 	ret

8011ea60 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8011ea60:	defffe04 	addi	sp,sp,-8
8011ea64:	de00012e 	bgeu	sp,et,8011ea6c <vLoadDefaultSyncSource+0xc>
8011ea68:	003b68fa 	trap	3
8011ea6c:	df000115 	stw	fp,4(sp)
8011ea70:	df000104 	addi	fp,sp,4
8011ea74:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8011ea78:	e0bfff17 	ldw	r2,-4(fp)
8011ea7c:	10000815 	stw	zero,32(r2)
}
8011ea80:	0001883a 	nop
8011ea84:	e037883a 	mov	sp,fp
8011ea88:	df000017 	ldw	fp,0(sp)
8011ea8c:	dec00104 	addi	sp,sp,4
8011ea90:	f800283a 	ret

8011ea94 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8011ea94:	defffd04 	addi	sp,sp,-12
8011ea98:	de00012e 	bgeu	sp,et,8011eaa0 <vChangeSyncSource+0xc>
8011ea9c:	003b68fa 	trap	3
8011eaa0:	df000215 	stw	fp,8(sp)
8011eaa4:	df000204 	addi	fp,sp,8
8011eaa8:	e13ffe15 	stw	r4,-8(fp)
8011eaac:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8011eab0:	e0bffe17 	ldw	r2,-8(fp)
8011eab4:	e0ffff17 	ldw	r3,-4(fp)
8011eab8:	10c00815 	stw	r3,32(r2)
}
8011eabc:	0001883a 	nop
8011eac0:	e037883a 	mov	sp,fp
8011eac4:	df000017 	ldw	fp,0(sp)
8011eac8:	dec00104 	addi	sp,sp,4
8011eacc:	f800283a 	ret

8011ead0 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8011ead0:	defffd04 	addi	sp,sp,-12
8011ead4:	de00012e 	bgeu	sp,et,8011eadc <vChangeDefaultSyncSource+0xc>
8011ead8:	003b68fa 	trap	3
8011eadc:	df000215 	stw	fp,8(sp)
8011eae0:	df000204 	addi	fp,sp,8
8011eae4:	e13ffe15 	stw	r4,-8(fp)
8011eae8:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8011eaec:	0001883a 	nop
8011eaf0:	e037883a 	mov	sp,fp
8011eaf4:	df000017 	ldw	fp,0(sp)
8011eaf8:	dec00104 	addi	sp,sp,4
8011eafc:	f800283a 	ret

8011eb00 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8011eb00:	defffe04 	addi	sp,sp,-8
8011eb04:	de00012e 	bgeu	sp,et,8011eb0c <vLoadDefaultAutoResetSync+0xc>
8011eb08:	003b68fa 	trap	3
8011eb0c:	df000115 	stw	fp,4(sp)
8011eb10:	df000104 	addi	fp,sp,4
8011eb14:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8011eb18:	e0bfff17 	ldw	r2,-4(fp)
8011eb1c:	00c00044 	movi	r3,1
8011eb20:	10c00915 	stw	r3,36(r2)
}
8011eb24:	0001883a 	nop
8011eb28:	e037883a 	mov	sp,fp
8011eb2c:	df000017 	ldw	fp,0(sp)
8011eb30:	dec00104 	addi	sp,sp,4
8011eb34:	f800283a 	ret

8011eb38 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8011eb38:	defffd04 	addi	sp,sp,-12
8011eb3c:	de00012e 	bgeu	sp,et,8011eb44 <vChangeAutoResetSync+0xc>
8011eb40:	003b68fa 	trap	3
8011eb44:	df000215 	stw	fp,8(sp)
8011eb48:	df000204 	addi	fp,sp,8
8011eb4c:	e13ffe15 	stw	r4,-8(fp)
8011eb50:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8011eb54:	e0bffe17 	ldw	r2,-8(fp)
8011eb58:	e0ffff17 	ldw	r3,-4(fp)
8011eb5c:	10c00915 	stw	r3,36(r2)
}
8011eb60:	0001883a 	nop
8011eb64:	e037883a 	mov	sp,fp
8011eb68:	df000017 	ldw	fp,0(sp)
8011eb6c:	dec00104 	addi	sp,sp,4
8011eb70:	f800283a 	ret

8011eb74 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8011eb74:	defffd04 	addi	sp,sp,-12
8011eb78:	de00012e 	bgeu	sp,et,8011eb80 <vChangeDefaultAutoResetSync+0xc>
8011eb7c:	003b68fa 	trap	3
8011eb80:	df000215 	stw	fp,8(sp)
8011eb84:	df000204 	addi	fp,sp,8
8011eb88:	e13ffe15 	stw	r4,-8(fp)
8011eb8c:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8011eb90:	0001883a 	nop
8011eb94:	e037883a 	mov	sp,fp
8011eb98:	df000017 	ldw	fp,0(sp)
8011eb9c:	dec00104 	addi	sp,sp,4
8011eba0:	f800283a 	ret

8011eba4 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8011eba4:	defffc04 	addi	sp,sp,-16
8011eba8:	de00012e 	bgeu	sp,et,8011ebb0 <vSyncReset+0xc>
8011ebac:	003b68fa 	trap	3
8011ebb0:	dfc00315 	stw	ra,12(sp)
8011ebb4:	df000215 	stw	fp,8(sp)
8011ebb8:	df000204 	addi	fp,sp,8
8011ebbc:	e13ffe15 	stw	r4,-8(fp)
8011ebc0:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8011ebc4:	e0bffe17 	ldw	r2,-8(fp)
8011ebc8:	10801b04 	addi	r2,r2,108
8011ebcc:	1009883a 	mov	r4,r2
8011ebd0:	011e5c80 	call	8011e5c8 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8011ebd4:	0001883a 	nop
8011ebd8:	e037883a 	mov	sp,fp
8011ebdc:	dfc00117 	ldw	ra,4(sp)
8011ebe0:	df000017 	ldw	fp,0(sp)
8011ebe4:	dec00204 	addi	sp,sp,8
8011ebe8:	f800283a 	ret

8011ebec <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8011ebec:	defff004 	addi	sp,sp,-64
8011ebf0:	de00012e 	bgeu	sp,et,8011ebf8 <pattern_createPattern+0xc>
8011ebf4:	003b68fa 	trap	3
8011ebf8:	dfc00f15 	stw	ra,60(sp)
8011ebfc:	df000e15 	stw	fp,56(sp)
8011ec00:	dcc00d15 	stw	r19,52(sp)
8011ec04:	dc800c15 	stw	r18,48(sp)
8011ec08:	dc400b15 	stw	r17,44(sp)
8011ec0c:	dc000a15 	stw	r16,40(sp)
8011ec10:	df000e04 	addi	fp,sp,56
8011ec14:	e17ff915 	stw	r5,-28(fp)
8011ec18:	3007883a 	mov	r3,r6
8011ec1c:	3805883a 	mov	r2,r7
8011ec20:	e13ff805 	stb	r4,-32(fp)
8011ec24:	e0fffa05 	stb	r3,-24(fp)
8011ec28:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8011ec2c:	e0bff803 	ldbu	r2,-32(fp)
8011ec30:	1009883a 	mov	r4,r2
8011ec34:	01005d40 	call	801005d4 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8011ec38:	e0bff917 	ldw	r2,-28(fp)
8011ec3c:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8011ec40:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8011ec44:	e0bff217 	ldw	r2,-56(fp)
8011ec48:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8011ec4c:	e03ff515 	stw	zero,-44(fp)
8011ec50:	00003606 	br	8011ed2c <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8011ec54:	e03ff615 	stw	zero,-40(fp)
8011ec58:	00002e06 	br	8011ed14 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8011ec5c:	e0bff303 	ldbu	r2,-52(fp)
8011ec60:	10801018 	cmpnei	r2,r2,64
8011ec64:	10000b1e 	bne	r2,zero,8011ec94 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8011ec68:	e0bff417 	ldw	r2,-48(fp)
8011ec6c:	00ffffc4 	movi	r3,-1
8011ec70:	10c02015 	stw	r3,128(r2)
8011ec74:	00ffffc4 	movi	r3,-1
8011ec78:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8011ec7c:	e0bff217 	ldw	r2,-56(fp)
8011ec80:	10802204 	addi	r2,r2,136
8011ec84:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8011ec88:	e0bff217 	ldw	r2,-56(fp)
8011ec8c:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8011ec90:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8011ec94:	e0bff303 	ldbu	r2,-52(fp)
8011ec98:	10c00044 	addi	r3,r2,1
8011ec9c:	e0fff305 	stb	r3,-52(fp)
8011eca0:	10803fcc 	andi	r2,r2,255
8011eca4:	e0fffa03 	ldbu	r3,-24(fp)
8011eca8:	18c000cc 	andi	r3,r3,3
8011ecac:	180692fa 	slli	r3,r3,11
8011ecb0:	1809883a 	mov	r4,r3
8011ecb4:	00f80004 	movi	r3,-8192
8011ecb8:	20c6b03a 	or	r3,r4,r3
8011ecbc:	1809883a 	mov	r4,r3
8011ecc0:	e0fffb03 	ldbu	r3,-20(fp)
8011ecc4:	18c0004c 	andi	r3,r3,1
8011ecc8:	180692ba 	slli	r3,r3,10
8011eccc:	20c6b03a 	or	r3,r4,r3
8011ecd0:	1809883a 	mov	r4,r3
8011ecd4:	e0fff517 	ldw	r3,-44(fp)
8011ecd8:	18c007cc 	andi	r3,r3,31
8011ecdc:	1806917a 	slli	r3,r3,5
8011ece0:	20c6b03a 	or	r3,r4,r3
8011ece4:	1809883a 	mov	r4,r3
8011ece8:	e0fff617 	ldw	r3,-40(fp)
8011ecec:	18c007cc 	andi	r3,r3,31
8011ecf0:	20c6b03a 	or	r3,r4,r3
8011ecf4:	1809883a 	mov	r4,r3
8011ecf8:	e0fff417 	ldw	r3,-48(fp)
8011ecfc:	1085883a 	add	r2,r2,r2
8011ed00:	1885883a 	add	r2,r3,r2
8011ed04:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8011ed08:	e0bff617 	ldw	r2,-40(fp)
8011ed0c:	10800044 	addi	r2,r2,1
8011ed10:	e0bff615 	stw	r2,-40(fp)
8011ed14:	e0fff617 	ldw	r3,-40(fp)
8011ed18:	e0800217 	ldw	r2,8(fp)
8011ed1c:	18bfcf36 	bltu	r3,r2,8011ec5c <__reset+0xfa0fec5c>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8011ed20:	e0bff517 	ldw	r2,-44(fp)
8011ed24:	10800044 	addi	r2,r2,1
8011ed28:	e0bff515 	stw	r2,-44(fp)
8011ed2c:	e0fff517 	ldw	r3,-44(fp)
8011ed30:	e0800317 	ldw	r2,12(fp)
8011ed34:	18bfc736 	bltu	r3,r2,8011ec54 <__reset+0xfa0fec54>
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
8011ed38:	e0bff417 	ldw	r2,-48(fp)
8011ed3c:	10002015 	stw	zero,128(r2)
8011ed40:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8011ed44:	e03ff705 	stb	zero,-36(fp)
8011ed48:	00001c06 	br	8011edbc <pattern_createPattern+0x1d0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
8011ed4c:	e13ff417 	ldw	r4,-48(fp)
8011ed50:	20802017 	ldw	r2,128(r4)
8011ed54:	20c02117 	ldw	r3,132(r4)
8011ed58:	e13ff703 	ldbu	r4,-36(fp)
8011ed5c:	217ff804 	addi	r5,r4,-32
8011ed60:	28000416 	blt	r5,zero,8011ed74 <pattern_createPattern+0x188>
8011ed64:	01200034 	movhi	r4,32768
8011ed68:	2160d83a 	srl	r16,r4,r5
8011ed6c:	0023883a 	mov	r17,zero
8011ed70:	00000a06 	br	8011ed9c <pattern_createPattern+0x1b0>
8011ed74:	01600034 	movhi	r5,32768
8011ed78:	280c907a 	slli	r6,r5,1
8011ed7c:	014007c4 	movi	r5,31
8011ed80:	290bc83a 	sub	r5,r5,r4
8011ed84:	314a983a 	sll	r5,r6,r5
8011ed88:	000d883a 	mov	r6,zero
8011ed8c:	3120d83a 	srl	r16,r6,r4
8011ed90:	2c20b03a 	or	r16,r5,r16
8011ed94:	01600034 	movhi	r5,32768
8011ed98:	2922d83a 	srl	r17,r5,r4
8011ed9c:	1424b03a 	or	r18,r2,r16
8011eda0:	1c66b03a 	or	r19,r3,r17
8011eda4:	e0bff417 	ldw	r2,-48(fp)
8011eda8:	14802015 	stw	r18,128(r2)
8011edac:	14c02115 	stw	r19,132(r2)
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8011edb0:	e0bff703 	ldbu	r2,-36(fp)
8011edb4:	10800044 	addi	r2,r2,1
8011edb8:	e0bff705 	stb	r2,-36(fp)
8011edbc:	e0fff703 	ldbu	r3,-36(fp)
8011edc0:	e0bff303 	ldbu	r2,-52(fp)
8011edc4:	18bfe136 	bltu	r3,r2,8011ed4c <__reset+0xfa0fed4c>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
	}

	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8011edc8:	e0bff217 	ldw	r2,-56(fp)
8011edcc:	10802204 	addi	r2,r2,136
8011edd0:	e0bff215 	stw	r2,-56(fp)
	return offset;
8011edd4:	e0bff217 	ldw	r2,-56(fp)
}
8011edd8:	e6fffc04 	addi	sp,fp,-16
8011eddc:	dfc00517 	ldw	ra,20(sp)
8011ede0:	df000417 	ldw	fp,16(sp)
8011ede4:	dcc00317 	ldw	r19,12(sp)
8011ede8:	dc800217 	ldw	r18,8(sp)
8011edec:	dc400117 	ldw	r17,4(sp)
8011edf0:	dc000017 	ldw	r16,0(sp)
8011edf4:	dec00604 	addi	sp,sp,24
8011edf8:	f800283a 	ret

8011edfc <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8011edfc:	defffe04 	addi	sp,sp,-8
8011ee00:	de00012e 	bgeu	sp,et,8011ee08 <bSDcardIsPresent+0xc>
8011ee04:	003b68fa 	trap	3
8011ee08:	dfc00115 	stw	ra,4(sp)
8011ee0c:	df000015 	stw	fp,0(sp)
8011ee10:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8011ee14:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
}
8011ee18:	e037883a 	mov	sp,fp
8011ee1c:	dfc00117 	ldw	ra,4(sp)
8011ee20:	df000017 	ldw	fp,0(sp)
8011ee24:	dec00204 	addi	sp,sp,8
8011ee28:	f800283a 	ret

8011ee2c <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8011ee2c:	defffe04 	addi	sp,sp,-8
8011ee30:	de00012e 	bgeu	sp,et,8011ee38 <bSDcardFAT16Check+0xc>
8011ee34:	003b68fa 	trap	3
8011ee38:	dfc00115 	stw	ra,4(sp)
8011ee3c:	df000015 	stw	fp,0(sp)
8011ee40:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8011ee44:	01404080 	call	80140408 <alt_up_sd_card_is_FAT16>
}
8011ee48:	e037883a 	mov	sp,fp
8011ee4c:	dfc00117 	ldw	ra,4(sp)
8011ee50:	df000017 	ldw	fp,0(sp)
8011ee54:	dec00204 	addi	sp,sp,8
8011ee58:	f800283a 	ret

8011ee5c <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8011ee5c:	defffd04 	addi	sp,sp,-12
8011ee60:	de00012e 	bgeu	sp,et,8011ee68 <bInitializeSDCard+0xc>
8011ee64:	003b68fa 	trap	3
8011ee68:	dfc00215 	stw	ra,8(sp)
8011ee6c:	df000115 	stw	fp,4(sp)
8011ee70:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8011ee74:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8011ee78:	d0208015 	stw	zero,-32256(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8011ee7c:	01200534 	movhi	r4,32788
8011ee80:	211dd404 	addi	r4,r4,30544
8011ee84:	01402780 	call	80140278 <alt_up_sd_card_open_dev>
8011ee88:	d0a08015 	stw	r2,-32256(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8011ee8c:	d0a08017 	ldw	r2,-32256(gp)
8011ee90:	10000b26 	beq	r2,zero,8011eec0 <bInitializeSDCard+0x64>

		bSucess = bSDcardIsPresent();
8011ee94:	011edfc0 	call	8011edfc <bSDcardIsPresent>
8011ee98:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8011ee9c:	e0bfff17 	ldw	r2,-4(fp)
8011eea0:	10000826 	beq	r2,zero,8011eec4 <bInitializeSDCard+0x68>
			bSucess = bSDcardFAT16Check();
8011eea4:	011ee2c0 	call	8011ee2c <bSDcardFAT16Check>
8011eea8:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8011eeac:	e0bfff17 	ldw	r2,-4(fp)
8011eeb0:	10000426 	beq	r2,zero,8011eec4 <bInitializeSDCard+0x68>
				xSdHandle.connected = TRUE;
8011eeb4:	00800044 	movi	r2,1
8011eeb8:	d0a07f15 	stw	r2,-32260(gp)
8011eebc:	00000106 	br	8011eec4 <bInitializeSDCard+0x68>
			#endif
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8011eec0:	e03fff15 	stw	zero,-4(fp)
		#if DEBUG_ON
			debug(fp, "Unable to open the SDCard device.\r\n");
		#endif
	}

	return bSucess;
8011eec4:	e0bfff17 	ldw	r2,-4(fp)
}
8011eec8:	e037883a 	mov	sp,fp
8011eecc:	dfc00117 	ldw	ra,4(sp)
8011eed0:	df000017 	ldw	fp,0(sp)
8011eed4:	dec00204 	addi	sp,sp,8
8011eed8:	f800283a 	ret

8011eedc <siOpenFile>:

short int siOpenFile( char *filename ) {
8011eedc:	defffd04 	addi	sp,sp,-12
8011eee0:	de00012e 	bgeu	sp,et,8011eee8 <siOpenFile+0xc>
8011eee4:	003b68fa 	trap	3
8011eee8:	dfc00215 	stw	ra,8(sp)
8011eeec:	df000115 	stw	fp,4(sp)
8011eef0:	df000104 	addi	fp,sp,4
8011eef4:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8011eef8:	000b883a 	mov	r5,zero
8011eefc:	e13fff17 	ldw	r4,-4(fp)
8011ef00:	01409140 	call	80140914 <alt_up_sd_card_fopen>
}
8011ef04:	e037883a 	mov	sp,fp
8011ef08:	dfc00117 	ldw	ra,4(sp)
8011ef0c:	df000017 	ldw	fp,0(sp)
8011ef10:	dec00204 	addi	sp,sp,8
8011ef14:	f800283a 	ret

8011ef18 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8011ef18:	defffd04 	addi	sp,sp,-12
8011ef1c:	de00012e 	bgeu	sp,et,8011ef24 <siCloseFile+0xc>
8011ef20:	003b68fa 	trap	3
8011ef24:	dfc00215 	stw	ra,8(sp)
8011ef28:	df000115 	stw	fp,4(sp)
8011ef2c:	df000104 	addi	fp,sp,4
8011ef30:	2005883a 	mov	r2,r4
8011ef34:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8011ef38:	e0bfff0f 	ldh	r2,-4(fp)
8011ef3c:	1009883a 	mov	r4,r2
8011ef40:	01417600 	call	80141760 <alt_up_sd_card_fclose>
}
8011ef44:	e037883a 	mov	sp,fp
8011ef48:	dfc00117 	ldw	ra,4(sp)
8011ef4c:	df000017 	ldw	fp,0(sp)
8011ef50:	dec00204 	addi	sp,sp,8
8011ef54:	f800283a 	ret

8011ef58 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8011ef58:	defffd04 	addi	sp,sp,-12
8011ef5c:	de00012e 	bgeu	sp,et,8011ef64 <cGetNextChar+0xc>
8011ef60:	003b68fa 	trap	3
8011ef64:	dfc00215 	stw	ra,8(sp)
8011ef68:	df000115 	stw	fp,4(sp)
8011ef6c:	df000104 	addi	fp,sp,4
8011ef70:	2005883a 	mov	r2,r4
8011ef74:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8011ef78:	e0bfff0f 	ldh	r2,-4(fp)
8011ef7c:	1009883a 	mov	r4,r2
8011ef80:	0140db80 	call	80140db8 <alt_up_sd_card_read>
}
8011ef84:	e037883a 	mov	sp,fp
8011ef88:	dfc00117 	ldw	ra,4(sp)
8011ef8c:	df000017 	ldw	fp,0(sp)
8011ef90:	dec00204 	addi	sp,sp,8
8011ef94:	f800283a 	ret

8011ef98 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8011ef98:	defffd04 	addi	sp,sp,-12
8011ef9c:	de00012e 	bgeu	sp,et,8011efa4 <bInitSync+0xc>
8011efa0:	003b68fa 	trap	3
8011efa4:	dfc00215 	stw	ra,8(sp)
8011efa8:	df000115 	stw	fp,4(sp)
8011efac:	df000104 	addi	fp,sp,4
	bool	bSuccess;

	vSyncInitIrq();
8011efb0:	010d2c00 	call	8010d2c0 <vSyncInitIrq>
	}
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8011efb4:	01004c74 	movhi	r4,305
8011efb8:	210b4004 	addi	r4,r4,11520
8011efbc:	010d4c80 	call	8010d4c8 <bSyncSetMbt>
8011efc0:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011efc4:	e0bfff17 	ldw	r2,-4(fp)
8011efc8:	1000021e 	bne	r2,zero,8011efd4 <bInitSync+0x3c>
		return bSuccess;
8011efcc:	e0bfff17 	ldw	r2,-4(fp)
8011efd0:	00005b06 	br	8011f140 <bInitSync+0x1a8>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8011efd4:	01002674 	movhi	r4,153
8011efd8:	2125a004 	addi	r4,r4,-27008
8011efdc:	010d5080 	call	8010d508 <bSyncSetBt>
8011efe0:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011efe4:	e0bfff17 	ldw	r2,-4(fp)
8011efe8:	1000021e 	bne	r2,zero,8011eff4 <bInitSync+0x5c>
		return bSuccess;
8011efec:	e0bfff17 	ldw	r2,-4(fp)
8011eff0:	00005306 	br	8011f140 <bInitSync+0x1a8>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
8011eff4:	00a005b4 	movhi	r2,32790
8011eff8:	10ba3604 	addi	r2,r2,-5928
8011effc:	1080038b 	ldhu	r2,14(r2)
8011f000:	10bfffcc 	andi	r2,r2,65535
8011f004:	1009883a 	mov	r4,r2
8011f008:	010e1a00 	call	8010e1a0 <uliPerCalcPeriodMs>
8011f00c:	1009883a 	mov	r4,r2
8011f010:	010d5480 	call	8010d548 <bSyncSetPer>
8011f014:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f018:	e0bfff17 	ldw	r2,-4(fp)
8011f01c:	1000021e 	bne	r2,zero,8011f028 <bInitSync+0x90>
		return bSuccess;
8011f020:	e0bfff17 	ldw	r2,-4(fp)
8011f024:	00004606 	br	8011f140 <bInitSync+0x1a8>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8011f028:	01005f74 	movhi	r4,381
8011f02c:	211e1004 	addi	r4,r4,30784
8011f030:	010d5880 	call	8010d588 <bSyncSetOst>
8011f034:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f038:	e0bfff17 	ldw	r2,-4(fp)
8011f03c:	1000021e 	bne	r2,zero,8011f048 <bInitSync+0xb0>
		return bSuccess;
8011f040:	e0bfff17 	ldw	r2,-4(fp)
8011f044:	00003e06 	br	8011f140 <bInitSync+0x1a8>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8011f048:	0009883a 	mov	r4,zero
8011f04c:	010d5c80 	call	8010d5c8 <bSyncSetPolarity>
8011f050:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f054:	e0bfff17 	ldw	r2,-4(fp)
8011f058:	1000021e 	bne	r2,zero,8011f064 <bInitSync+0xcc>
		return bSuccess;
8011f05c:	e0bfff17 	ldw	r2,-4(fp)
8011f060:	00003706 	br	8011f140 <bInitSync+0x1a8>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8011f064:	01000104 	movi	r4,4
8011f068:	010d63c0 	call	8010d63c <bSyncSetNCycles>
8011f06c:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f070:	e0bfff17 	ldw	r2,-4(fp)
8011f074:	1000021e 	bne	r2,zero,8011f080 <bInitSync+0xe8>
		return bSuccess;
8011f078:	e0bfff17 	ldw	r2,-4(fp)
8011f07c:	00003006 	br	8011f140 <bInitSync+0x1a8>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8011f080:	01000044 	movi	r4,1
8011f084:	010d8180 	call	8010d818 <bSyncCtrExtnIrq>
8011f088:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f08c:	e0bfff17 	ldw	r2,-4(fp)
8011f090:	1000021e 	bne	r2,zero,8011f09c <bInitSync+0x104>
		return bSuccess;
8011f094:	e0bfff17 	ldw	r2,-4(fp)
8011f098:	00002906 	br	8011f140 <bInitSync+0x1a8>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8011f09c:	01000044 	movi	r4,1
8011f0a0:	010d9e00 	call	8010d9e0 <bSyncCtrSyncOutEnable>
8011f0a4:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f0a8:	e0bfff17 	ldw	r2,-4(fp)
8011f0ac:	1000021e 	bne	r2,zero,8011f0b8 <bInitSync+0x120>
		return bSuccess;
8011f0b0:	e0bfff17 	ldw	r2,-4(fp)
8011f0b4:	00002206 	br	8011f140 <bInitSync+0x1a8>
	}


	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8011f0b8:	01000044 	movi	r4,1
8011f0bc:	010da540 	call	8010da54 <bSyncCtrCh1OutEnable>
8011f0c0:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f0c4:	e0bfff17 	ldw	r2,-4(fp)
8011f0c8:	1000021e 	bne	r2,zero,8011f0d4 <bInitSync+0x13c>
		return bSuccess;
8011f0cc:	e0bfff17 	ldw	r2,-4(fp)
8011f0d0:	00001b06 	br	8011f140 <bInitSync+0x1a8>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 2)
	bSuccess = bSyncCtrCh2OutEnable(TRUE);
8011f0d4:	01000044 	movi	r4,1
8011f0d8:	010dac80 	call	8010dac8 <bSyncCtrCh2OutEnable>
8011f0dc:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f0e0:	e0bfff17 	ldw	r2,-4(fp)
8011f0e4:	1000021e 	bne	r2,zero,8011f0f0 <bInitSync+0x158>
		return bSuccess;
8011f0e8:	e0bfff17 	ldw	r2,-4(fp)
8011f0ec:	00001406 	br	8011f140 <bInitSync+0x1a8>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 3)
	bSuccess = bSyncCtrCh3OutEnable(TRUE);
8011f0f0:	01000044 	movi	r4,1
8011f0f4:	010db3c0 	call	8010db3c <bSyncCtrCh3OutEnable>
8011f0f8:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f0fc:	e0bfff17 	ldw	r2,-4(fp)
8011f100:	1000021e 	bne	r2,zero,8011f10c <bInitSync+0x174>
		return bSuccess;
8011f104:	e0bfff17 	ldw	r2,-4(fp)
8011f108:	00000d06 	br	8011f140 <bInitSync+0x1a8>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 4)
	bSuccess = bSyncCtrCh4OutEnable(TRUE);
8011f10c:	01000044 	movi	r4,1
8011f110:	010dbb00 	call	8010dbb0 <bSyncCtrCh4OutEnable>
8011f114:	e0bfff15 	stw	r2,-4(fp)
	if ( bSuccess == FALSE ) {
8011f118:	e0bfff17 	ldw	r2,-4(fp)
8011f11c:	1000021e 	bne	r2,zero,8011f128 <bInitSync+0x190>
		return bSuccess;
8011f120:	e0bfff17 	ldw	r2,-4(fp)
8011f124:	00000606 	br	8011f140 <bInitSync+0x1a8>
	}

	bSuccess = bSyncCtrStart();
8011f128:	010d8900 	call	8010d890 <bSyncCtrStart>
8011f12c:	e0bfff15 	stw	r2,-4(fp)
	bSyncCtrReset();
8011f130:	010d8e40 	call	8010d8e4 <bSyncCtrReset>
	bSyncIrqEnableBlank(TRUE);
8011f134:	01000044 	movi	r4,1
8011f138:	010de680 	call	8010de68 <bSyncIrqEnableBlank>


	return bSuccess;
8011f13c:	e0bfff17 	ldw	r2,-4(fp)
}
8011f140:	e037883a 	mov	sp,fp
8011f144:	dfc00117 	ldw	ra,4(sp)
8011f148:	df000017 	ldw	fp,0(sp)
8011f14c:	dec00204 	addi	sp,sp,8
8011f150:	f800283a 	ret

8011f154 <bStartSync>:


bool bStartSync(void) {
8011f154:	defffd04 	addi	sp,sp,-12
8011f158:	de00012e 	bgeu	sp,et,8011f160 <bStartSync+0xc>
8011f15c:	003b68fa 	trap	3
8011f160:	dfc00215 	stw	ra,8(sp)
8011f164:	df000115 	stw	fp,4(sp)
8011f168:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
8011f16c:	010d8e40 	call	8010d8e4 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
8011f170:	010d8900 	call	8010d890 <bSyncCtrStart>
8011f174:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8011f178:	e0bfff17 	ldw	r2,-4(fp)
}
8011f17c:	e037883a 	mov	sp,fp
8011f180:	dfc00117 	ldw	ra,4(sp)
8011f184:	df000017 	ldw	fp,0(sp)
8011f188:	dec00204 	addi	sp,sp,8
8011f18c:	f800283a 	ret

8011f190 <bStopSync>:

bool bStopSync(void) {
8011f190:	defffe04 	addi	sp,sp,-8
8011f194:	de00012e 	bgeu	sp,et,8011f19c <bStopSync+0xc>
8011f198:	003b68fa 	trap	3
8011f19c:	dfc00115 	stw	ra,4(sp)
8011f1a0:	df000015 	stw	fp,0(sp)
8011f1a4:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8011f1a8:	010d8e40 	call	8010d8e4 <bSyncCtrReset>
}
8011f1ac:	e037883a 	mov	sp,fp
8011f1b0:	dfc00117 	ldw	ra,4(sp)
8011f1b4:	df000017 	ldw	fp,0(sp)
8011f1b8:	dec00204 	addi	sp,sp,8
8011f1bc:	f800283a 	ret

8011f1c0 <bClearCounterSync>:

void bClearCounterSync(void) {
8011f1c0:	defffe04 	addi	sp,sp,-8
8011f1c4:	de00012e 	bgeu	sp,et,8011f1cc <bClearCounterSync+0xc>
8011f1c8:	003b68fa 	trap	3
8011f1cc:	dfc00115 	stw	ra,4(sp)
8011f1d0:	df000015 	stw	fp,0(sp)
8011f1d4:	d839883a 	mov	fp,sp
	vSyncClearCounter();
8011f1d8:	010d2940 	call	8010d294 <vSyncClearCounter>
}
8011f1dc:	0001883a 	nop
8011f1e0:	e037883a 	mov	sp,fp
8011f1e4:	dfc00117 	ldw	ra,4(sp)
8011f1e8:	df000017 	ldw	fp,0(sp)
8011f1ec:	dec00204 	addi	sp,sp,8
8011f1f0:	f800283a 	ret

8011f1f4 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8011f1f4:	defffd04 	addi	sp,sp,-12
8011f1f8:	de00012e 	bgeu	sp,et,8011f200 <bTestSimucamCriticalHW+0xc>
8011f1fc:	003b68fa 	trap	3
8011f200:	dfc00215 	stw	ra,8(sp)
8011f204:	df000115 	stw	fp,4(sp)
8011f208:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8011f20c:	0101e500 	call	80101e50 <bSdmaInitM1Dma>
8011f210:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8011f214:	e0bfff17 	ldw	r2,-4(fp)
8011f218:	1000021e 	bne	r2,zero,8011f224 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8011f21c:	e0bfff17 	ldw	r2,-4(fp)
8011f220:	00000706 	br	8011f240 <bTestSimucamCriticalHW+0x4c>
	}

	bSuccess = bSdmaInitM2Dma();
8011f224:	0101f0c0 	call	80101f0c <bSdmaInitM2Dma>
8011f228:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8011f22c:	e0bfff17 	ldw	r2,-4(fp)
8011f230:	1000021e 	bne	r2,zero,8011f23c <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8011f234:	e0bfff17 	ldw	r2,-4(fp)
8011f238:	00000106 	br	8011f240 <bTestSimucamCriticalHW+0x4c>

	//xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
	//xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;


	return TRUE;
8011f23c:	00800044 	movi	r2,1
}
8011f240:	e037883a 	mov	sp,fp
8011f244:	dfc00117 	ldw	ra,4(sp)
8011f248:	df000017 	ldw	fp,0(sp)
8011f24c:	dec00204 	addi	sp,sp,8
8011f250:	f800283a 	ret

8011f254 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8011f254:	defffc04 	addi	sp,sp,-16
8011f258:	de00012e 	bgeu	sp,et,8011f260 <_reg_write+0xc>
8011f25c:	003b68fa 	trap	3
8011f260:	df000315 	stw	fp,12(sp)
8011f264:	df000304 	addi	fp,sp,12
8011f268:	e13ffd15 	stw	r4,-12(fp)
8011f26c:	e17ffe15 	stw	r5,-8(fp)
8011f270:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8011f274:	e0bffe17 	ldw	r2,-8(fp)
8011f278:	1085883a 	add	r2,r2,r2
8011f27c:	1085883a 	add	r2,r2,r2
8011f280:	1007883a 	mov	r3,r2
8011f284:	e0bffd17 	ldw	r2,-12(fp)
8011f288:	1885883a 	add	r2,r3,r2
8011f28c:	1007883a 	mov	r3,r2
8011f290:	e0bfff17 	ldw	r2,-4(fp)
8011f294:	18800035 	stwio	r2,0(r3)
	return 1;
8011f298:	00800044 	movi	r2,1

}
8011f29c:	e037883a 	mov	sp,fp
8011f2a0:	df000017 	ldw	fp,0(sp)
8011f2a4:	dec00104 	addi	sp,sp,4
8011f2a8:	f800283a 	ret

8011f2ac <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8011f2ac:	defffc04 	addi	sp,sp,-16
8011f2b0:	de00012e 	bgeu	sp,et,8011f2b8 <_reg_read+0xc>
8011f2b4:	003b68fa 	trap	3
8011f2b8:	df000315 	stw	fp,12(sp)
8011f2bc:	df000304 	addi	fp,sp,12
8011f2c0:	e13ffd15 	stw	r4,-12(fp)
8011f2c4:	e17ffe15 	stw	r5,-8(fp)
8011f2c8:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8011f2cc:	e0bffe17 	ldw	r2,-8(fp)
8011f2d0:	1085883a 	add	r2,r2,r2
8011f2d4:	1085883a 	add	r2,r2,r2
8011f2d8:	1007883a 	mov	r3,r2
8011f2dc:	e0bffd17 	ldw	r2,-12(fp)
8011f2e0:	1885883a 	add	r2,r3,r2
8011f2e4:	10c00037 	ldwio	r3,0(r2)
8011f2e8:	e0bfff17 	ldw	r2,-4(fp)
8011f2ec:	10c00015 	stw	r3,0(r2)
	return 1;
8011f2f0:	00800044 	movi	r2,1

}
8011f2f4:	e037883a 	mov	sp,fp
8011f2f8:	df000017 	ldw	fp,0(sp)
8011f2fc:	dec00104 	addi	sp,sp,4
8011f300:	f800283a 	ret

8011f304 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8011f304:	defffb04 	addi	sp,sp,-20
8011f308:	de00012e 	bgeu	sp,et,8011f310 <_print_codec_status+0xc>
8011f30c:	003b68fa 	trap	3
8011f310:	df000415 	stw	fp,16(sp)
8011f314:	df000404 	addi	fp,sp,16
8011f318:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8011f31c:	e0bfff17 	ldw	r2,-4(fp)
8011f320:	1005d1ba 	srai	r2,r2,6
8011f324:	1080004c 	andi	r2,r2,1
8011f328:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8011f32c:	e0bfff17 	ldw	r2,-4(fp)
8011f330:	1005d17a 	srai	r2,r2,5
8011f334:	1080004c 	andi	r2,r2,1
8011f338:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8011f33c:	e0bfff17 	ldw	r2,-4(fp)
8011f340:	1005d13a 	srai	r2,r2,4
8011f344:	1080004c 	andi	r2,r2,1
8011f348:	e0bffe15 	stw	r2,-8(fp)
		debug(fp, cDebugBuffer);
		sprintf(cDebugBuffer, "--------  \n");
		debug(fp, cDebugBuffer);
	}
#endif
}
8011f34c:	0001883a 	nop
8011f350:	e037883a 	mov	sp,fp
8011f354:	df000017 	ldw	fp,0(sp)
8011f358:	dec00104 	addi	sp,sp,4
8011f35c:	f800283a 	ret

8011f360 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8011f360:	defffb04 	addi	sp,sp,-20
8011f364:	de00012e 	bgeu	sp,et,8011f36c <_split_codec_status+0xc>
8011f368:	003b68fa 	trap	3
8011f36c:	df000415 	stw	fp,16(sp)
8011f370:	df000404 	addi	fp,sp,16
8011f374:	e13ffc15 	stw	r4,-16(fp)
8011f378:	e17ffd15 	stw	r5,-12(fp)
8011f37c:	e1bffe15 	stw	r6,-8(fp)
8011f380:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8011f384:	e0bffc17 	ldw	r2,-16(fp)
8011f388:	1005d1ba 	srai	r2,r2,6
8011f38c:	10c0004c 	andi	r3,r2,1
8011f390:	e0bffd17 	ldw	r2,-12(fp)
8011f394:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8011f398:	e0bffc17 	ldw	r2,-16(fp)
8011f39c:	1005d17a 	srai	r2,r2,5
8011f3a0:	10c0004c 	andi	r3,r2,1
8011f3a4:	e0bffe17 	ldw	r2,-8(fp)
8011f3a8:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8011f3ac:	e0bffc17 	ldw	r2,-16(fp)
8011f3b0:	1005d13a 	srai	r2,r2,4
8011f3b4:	10c0004c 	andi	r3,r2,1
8011f3b8:	e0bfff17 	ldw	r2,-4(fp)
8011f3bc:	10c00015 	stw	r3,0(r2)
}
8011f3c0:	0001883a 	nop
8011f3c4:	e037883a 	mov	sp,fp
8011f3c8:	df000017 	ldw	fp,0(sp)
8011f3cc:	dec00104 	addi	sp,sp,4
8011f3d0:	f800283a 	ret

8011f3d4 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8011f3d4:	defffc04 	addi	sp,sp,-16
8011f3d8:	de00012e 	bgeu	sp,et,8011f3e0 <aatoh+0xc>
8011f3dc:	003b68fa 	trap	3
8011f3e0:	df000315 	stw	fp,12(sp)
8011f3e4:	df000304 	addi	fp,sp,12
8011f3e8:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8011f3ec:	e0bfff17 	ldw	r2,-4(fp)
8011f3f0:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8011f3f4:	e0bffd17 	ldw	r2,-12(fp)
8011f3f8:	10c00003 	ldbu	r3,0(r2)
8011f3fc:	e0bffd17 	ldw	r2,-12(fp)
8011f400:	10800003 	ldbu	r2,0(r2)
8011f404:	10803fcc 	andi	r2,r2,255
8011f408:	10800eb0 	cmpltui	r2,r2,58
8011f40c:	1000021e 	bne	r2,zero,8011f418 <aatoh+0x44>
8011f410:	00800dc4 	movi	r2,55
8011f414:	00000106 	br	8011f41c <aatoh+0x48>
8011f418:	00800c04 	movi	r2,48
8011f41c:	1885c83a 	sub	r2,r3,r2
8011f420:	1004913a 	slli	r2,r2,4
8011f424:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8011f428:	e0bffd17 	ldw	r2,-12(fp)
8011f42c:	10800044 	addi	r2,r2,1
8011f430:	10c00003 	ldbu	r3,0(r2)
8011f434:	e0bffd17 	ldw	r2,-12(fp)
8011f438:	10800044 	addi	r2,r2,1
8011f43c:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8011f440:	10803fcc 	andi	r2,r2,255
8011f444:	10800eb0 	cmpltui	r2,r2,58
8011f448:	1000021e 	bne	r2,zero,8011f454 <aatoh+0x80>
8011f44c:	00800dc4 	movi	r2,55
8011f450:	00000106 	br	8011f458 <aatoh+0x84>
8011f454:	00800c04 	movi	r2,48
8011f458:	1885c83a 	sub	r2,r3,r2
8011f45c:	2085883a 	add	r2,r4,r2
8011f460:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8011f464:	e0bffe03 	ldbu	r2,-8(fp)
}
8011f468:	e037883a 	mov	sp,fp
8011f46c:	df000017 	ldw	fp,0(sp)
8011f470:	dec00104 	addi	sp,sp,4
8011f474:	f800283a 	ret

8011f478 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8011f478:	defffe04 	addi	sp,sp,-8
8011f47c:	de00012e 	bgeu	sp,et,8011f484 <Verif_Error+0xc>
8011f480:	003b68fa 	trap	3
8011f484:	df000115 	stw	fp,4(sp)
8011f488:	df000104 	addi	fp,sp,4
8011f48c:	2005883a 	mov	r2,r4
8011f490:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8011f494:	e0bfff03 	ldbu	r2,-4(fp)
8011f498:	1000021e 	bne	r2,zero,8011f4a4 <Verif_Error+0x2c>
#if DEBUG_ON
if ( xDefaults.usiDebugLevel <= dlCriticalOnly ) {
	debug(fp, "ERROR\n\r");
}
#endif
		return 0;
8011f49c:	0005883a 	mov	r2,zero
8011f4a0:	00000106 	br	8011f4a8 <Verif_Error+0x30>
	} else
		return 1;
8011f4a4:	00800044 	movi	r2,1
}
8011f4a8:	e037883a 	mov	sp,fp
8011f4ac:	df000017 	ldw	fp,0(sp)
8011f4b0:	dec00104 	addi	sp,sp,4
8011f4b4:	f800283a 	ret

8011f4b8 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8011f4b8:	defffe04 	addi	sp,sp,-8
8011f4bc:	de00012e 	bgeu	sp,et,8011f4c4 <toInt+0xc>
8011f4c0:	003b68fa 	trap	3
8011f4c4:	df000115 	stw	fp,4(sp)
8011f4c8:	df000104 	addi	fp,sp,4
8011f4cc:	2005883a 	mov	r2,r4
8011f4d0:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8011f4d4:	e0bfff03 	ldbu	r2,-4(fp)
8011f4d8:	10bff404 	addi	r2,r2,-48
}
8011f4dc:	e037883a 	mov	sp,fp
8011f4e0:	df000017 	ldw	fp,0(sp)
8011f4e4:	dec00104 	addi	sp,sp,4
8011f4e8:	f800283a 	ret

8011f4ec <__fixunsdfsi>:
8011f4ec:	defffd04 	addi	sp,sp,-12
8011f4f0:	000d883a 	mov	r6,zero
8011f4f4:	01d07834 	movhi	r7,16864
8011f4f8:	de00012e 	bgeu	sp,et,8011f500 <__fixunsdfsi+0x14>
8011f4fc:	003b68fa 	trap	3
8011f500:	dc400115 	stw	r17,4(sp)
8011f504:	dc000015 	stw	r16,0(sp)
8011f508:	dfc00215 	stw	ra,8(sp)
8011f50c:	2023883a 	mov	r17,r4
8011f510:	2821883a 	mov	r16,r5
8011f514:	011feac0 	call	8011feac <__gedf2>
8011f518:	1000080e 	bge	r2,zero,8011f53c <__fixunsdfsi+0x50>
8011f51c:	8809883a 	mov	r4,r17
8011f520:	800b883a 	mov	r5,r16
8011f524:	0120fac0 	call	80120fac <__fixdfsi>
8011f528:	dfc00217 	ldw	ra,8(sp)
8011f52c:	dc400117 	ldw	r17,4(sp)
8011f530:	dc000017 	ldw	r16,0(sp)
8011f534:	dec00304 	addi	sp,sp,12
8011f538:	f800283a 	ret
8011f53c:	000d883a 	mov	r6,zero
8011f540:	01d07834 	movhi	r7,16864
8011f544:	8809883a 	mov	r4,r17
8011f548:	800b883a 	mov	r5,r16
8011f54c:	01206a80 	call	801206a8 <__subdf3>
8011f550:	180b883a 	mov	r5,r3
8011f554:	1009883a 	mov	r4,r2
8011f558:	0120fac0 	call	80120fac <__fixdfsi>
8011f55c:	00e00034 	movhi	r3,32768
8011f560:	10c5883a 	add	r2,r2,r3
8011f564:	003ff006 	br	8011f528 <__reset+0xfa0ff528>

8011f568 <__divsf3>:
8011f568:	defff504 	addi	sp,sp,-44
8011f56c:	200cd5fa 	srli	r6,r4,23
8011f570:	de00012e 	bgeu	sp,et,8011f578 <__divsf3+0x10>
8011f574:	003b68fa 	trap	3
8011f578:	dcc00415 	stw	r19,16(sp)
8011f57c:	2026d7fa 	srli	r19,r4,31
8011f580:	00c02034 	movhi	r3,128
8011f584:	dd800715 	stw	r22,28(sp)
8011f588:	dd000515 	stw	r20,20(sp)
8011f58c:	dc800315 	stw	r18,12(sp)
8011f590:	18ffffc4 	addi	r3,r3,-1
8011f594:	dfc00a15 	stw	ra,40(sp)
8011f598:	df000915 	stw	fp,36(sp)
8011f59c:	ddc00815 	stw	r23,32(sp)
8011f5a0:	dd400615 	stw	r21,24(sp)
8011f5a4:	dc400215 	stw	r17,8(sp)
8011f5a8:	dc000115 	stw	r16,4(sp)
8011f5ac:	35003fcc 	andi	r20,r6,255
8011f5b0:	1924703a 	and	r18,r3,r4
8011f5b4:	9d803fcc 	andi	r22,r19,255
8011f5b8:	a0005226 	beq	r20,zero,8011f704 <__divsf3+0x19c>
8011f5bc:	00803fc4 	movi	r2,255
8011f5c0:	a0802e26 	beq	r20,r2,8011f67c <__divsf3+0x114>
8011f5c4:	91002034 	orhi	r4,r18,128
8011f5c8:	202490fa 	slli	r18,r4,3
8011f5cc:	a53fe044 	addi	r20,r20,-127
8011f5d0:	0021883a 	mov	r16,zero
8011f5d4:	002f883a 	mov	r23,zero
8011f5d8:	280cd5fa 	srli	r6,r5,23
8011f5dc:	282ad7fa 	srli	r21,r5,31
8011f5e0:	00c02034 	movhi	r3,128
8011f5e4:	18ffffc4 	addi	r3,r3,-1
8011f5e8:	31803fcc 	andi	r6,r6,255
8011f5ec:	1962703a 	and	r17,r3,r5
8011f5f0:	af003fcc 	andi	fp,r21,255
8011f5f4:	30004a26 	beq	r6,zero,8011f720 <__divsf3+0x1b8>
8011f5f8:	00803fc4 	movi	r2,255
8011f5fc:	30804526 	beq	r6,r2,8011f714 <__divsf3+0x1ac>
8011f600:	89402034 	orhi	r5,r17,128
8011f604:	282290fa 	slli	r17,r5,3
8011f608:	31bfe044 	addi	r6,r6,-127
8011f60c:	000b883a 	mov	r5,zero
8011f610:	2c20b03a 	or	r16,r5,r16
8011f614:	802090ba 	slli	r16,r16,2
8011f618:	00a004b4 	movhi	r2,32786
8011f61c:	10bd8f04 	addi	r2,r2,-2500
8011f620:	80a1883a 	add	r16,r16,r2
8011f624:	81000017 	ldw	r4,0(r16)
8011f628:	9d46f03a 	xor	r3,r19,r21
8011f62c:	180f883a 	mov	r7,r3
8011f630:	18803fcc 	andi	r2,r3,255
8011f634:	a18dc83a 	sub	r6,r20,r6
8011f638:	2000683a 	jmp	r4
8011f63c:	8011f820 	cmpeqi	zero,r16,18400
8011f640:	8011f6a4 	muli	zero,r16,18394
8011f644:	8011f814 	ori	zero,r16,18400
8011f648:	8011f690 	cmplti	zero,r16,18394
8011f64c:	8011f814 	ori	zero,r16,18400
8011f650:	8011f7ec 	andhi	zero,r16,18399
8011f654:	8011f814 	ori	zero,r16,18400
8011f658:	8011f690 	cmplti	zero,r16,18394
8011f65c:	8011f6a4 	muli	zero,r16,18394
8011f660:	8011f6a4 	muli	zero,r16,18394
8011f664:	8011f7ec 	andhi	zero,r16,18399
8011f668:	8011f690 	cmplti	zero,r16,18394
8011f66c:	8011f900 	call	88011f90 <__reset+0x1ff1f90>
8011f670:	8011f900 	call	88011f90 <__reset+0x1ff1f90>
8011f674:	8011f900 	call	88011f90 <__reset+0x1ff1f90>
8011f678:	8011f8b4 	orhi	zero,r16,18402
8011f67c:	9000581e 	bne	r18,zero,8011f7e0 <__divsf3+0x278>
8011f680:	04000204 	movi	r16,8
8011f684:	05c00084 	movi	r23,2
8011f688:	003fd306 	br	8011f5d8 <__reset+0xfa0ff5d8>
8011f68c:	0023883a 	mov	r17,zero
8011f690:	e02d883a 	mov	r22,fp
8011f694:	282f883a 	mov	r23,r5
8011f698:	00800084 	movi	r2,2
8011f69c:	b8808f1e 	bne	r23,r2,8011f8dc <__divsf3+0x374>
8011f6a0:	b005883a 	mov	r2,r22
8011f6a4:	11c0004c 	andi	r7,r2,1
8011f6a8:	013fffc4 	movi	r4,-1
8011f6ac:	000d883a 	mov	r6,zero
8011f6b0:	21003fcc 	andi	r4,r4,255
8011f6b4:	200895fa 	slli	r4,r4,23
8011f6b8:	38803fcc 	andi	r2,r7,255
8011f6bc:	00c02034 	movhi	r3,128
8011f6c0:	100497fa 	slli	r2,r2,31
8011f6c4:	18ffffc4 	addi	r3,r3,-1
8011f6c8:	30c6703a 	and	r3,r6,r3
8011f6cc:	1906b03a 	or	r3,r3,r4
8011f6d0:	1884b03a 	or	r2,r3,r2
8011f6d4:	dfc00a17 	ldw	ra,40(sp)
8011f6d8:	df000917 	ldw	fp,36(sp)
8011f6dc:	ddc00817 	ldw	r23,32(sp)
8011f6e0:	dd800717 	ldw	r22,28(sp)
8011f6e4:	dd400617 	ldw	r21,24(sp)
8011f6e8:	dd000517 	ldw	r20,20(sp)
8011f6ec:	dcc00417 	ldw	r19,16(sp)
8011f6f0:	dc800317 	ldw	r18,12(sp)
8011f6f4:	dc400217 	ldw	r17,8(sp)
8011f6f8:	dc000117 	ldw	r16,4(sp)
8011f6fc:	dec00b04 	addi	sp,sp,44
8011f700:	f800283a 	ret
8011f704:	90002b1e 	bne	r18,zero,8011f7b4 <__divsf3+0x24c>
8011f708:	04000104 	movi	r16,4
8011f70c:	05c00044 	movi	r23,1
8011f710:	003fb106 	br	8011f5d8 <__reset+0xfa0ff5d8>
8011f714:	8800251e 	bne	r17,zero,8011f7ac <__divsf3+0x244>
8011f718:	01400084 	movi	r5,2
8011f71c:	00000206 	br	8011f728 <__divsf3+0x1c0>
8011f720:	88001a1e 	bne	r17,zero,8011f78c <__divsf3+0x224>
8011f724:	01400044 	movi	r5,1
8011f728:	8160b03a 	or	r16,r16,r5
8011f72c:	802090ba 	slli	r16,r16,2
8011f730:	00e004b4 	movhi	r3,32786
8011f734:	18fdd304 	addi	r3,r3,-2228
8011f738:	80e1883a 	add	r16,r16,r3
8011f73c:	80c00017 	ldw	r3,0(r16)
8011f740:	9d44f03a 	xor	r2,r19,r21
8011f744:	a18dc83a 	sub	r6,r20,r6
8011f748:	1800683a 	jmp	r3
8011f74c:	8011f6a4 	muli	zero,r16,18394
8011f750:	8011f6a4 	muli	zero,r16,18394
8011f754:	8011f8f0 	cmpltui	zero,r16,18403
8011f758:	8011f68c 	andi	zero,r16,18394
8011f75c:	8011f8f0 	cmpltui	zero,r16,18403
8011f760:	8011f7ec 	andhi	zero,r16,18399
8011f764:	8011f8f0 	cmpltui	zero,r16,18403
8011f768:	8011f68c 	andi	zero,r16,18394
8011f76c:	8011f6a4 	muli	zero,r16,18394
8011f770:	8011f6a4 	muli	zero,r16,18394
8011f774:	8011f7ec 	andhi	zero,r16,18399
8011f778:	8011f68c 	andi	zero,r16,18394
8011f77c:	8011f900 	call	88011f90 <__reset+0x1ff1f90>
8011f780:	8011f900 	call	88011f90 <__reset+0x1ff1f90>
8011f784:	8011f900 	call	88011f90 <__reset+0x1ff1f90>
8011f788:	8011f918 	cmpnei	zero,r16,18404
8011f78c:	8809883a 	mov	r4,r17
8011f790:	01213d00 	call	801213d0 <__clzsi2>
8011f794:	10fffec4 	addi	r3,r2,-5
8011f798:	10801d84 	addi	r2,r2,118
8011f79c:	88e2983a 	sll	r17,r17,r3
8011f7a0:	008dc83a 	sub	r6,zero,r2
8011f7a4:	000b883a 	mov	r5,zero
8011f7a8:	003f9906 	br	8011f610 <__reset+0xfa0ff610>
8011f7ac:	014000c4 	movi	r5,3
8011f7b0:	003f9706 	br	8011f610 <__reset+0xfa0ff610>
8011f7b4:	9009883a 	mov	r4,r18
8011f7b8:	d9400015 	stw	r5,0(sp)
8011f7bc:	01213d00 	call	801213d0 <__clzsi2>
8011f7c0:	10fffec4 	addi	r3,r2,-5
8011f7c4:	11801d84 	addi	r6,r2,118
8011f7c8:	90e4983a 	sll	r18,r18,r3
8011f7cc:	01a9c83a 	sub	r20,zero,r6
8011f7d0:	0021883a 	mov	r16,zero
8011f7d4:	002f883a 	mov	r23,zero
8011f7d8:	d9400017 	ldw	r5,0(sp)
8011f7dc:	003f7e06 	br	8011f5d8 <__reset+0xfa0ff5d8>
8011f7e0:	04000304 	movi	r16,12
8011f7e4:	05c000c4 	movi	r23,3
8011f7e8:	003f7b06 	br	8011f5d8 <__reset+0xfa0ff5d8>
8011f7ec:	01802034 	movhi	r6,128
8011f7f0:	000f883a 	mov	r7,zero
8011f7f4:	31bfffc4 	addi	r6,r6,-1
8011f7f8:	013fffc4 	movi	r4,-1
8011f7fc:	003fac06 	br	8011f6b0 <__reset+0xfa0ff6b0>
8011f800:	01400044 	movi	r5,1
8011f804:	2909c83a 	sub	r4,r5,r4
8011f808:	00c006c4 	movi	r3,27
8011f80c:	19004b0e 	bge	r3,r4,8011f93c <__divsf3+0x3d4>
8011f810:	114e703a 	and	r7,r2,r5
8011f814:	0009883a 	mov	r4,zero
8011f818:	000d883a 	mov	r6,zero
8011f81c:	003fa406 	br	8011f6b0 <__reset+0xfa0ff6b0>
8011f820:	9006917a 	slli	r3,r18,5
8011f824:	8822917a 	slli	r17,r17,5
8011f828:	1c40372e 	bgeu	r3,r17,8011f908 <__divsf3+0x3a0>
8011f82c:	31bfffc4 	addi	r6,r6,-1
8011f830:	010006c4 	movi	r4,27
8011f834:	000b883a 	mov	r5,zero
8011f838:	180f883a 	mov	r7,r3
8011f83c:	294b883a 	add	r5,r5,r5
8011f840:	18c7883a 	add	r3,r3,r3
8011f844:	38000116 	blt	r7,zero,8011f84c <__divsf3+0x2e4>
8011f848:	1c400236 	bltu	r3,r17,8011f854 <__divsf3+0x2ec>
8011f84c:	1c47c83a 	sub	r3,r3,r17
8011f850:	29400054 	ori	r5,r5,1
8011f854:	213fffc4 	addi	r4,r4,-1
8011f858:	203ff71e 	bne	r4,zero,8011f838 <__reset+0xfa0ff838>
8011f85c:	1806c03a 	cmpne	r3,r3,zero
8011f860:	1962b03a 	or	r17,r3,r5
8011f864:	31001fc4 	addi	r4,r6,127
8011f868:	013fe50e 	bge	zero,r4,8011f800 <__reset+0xfa0ff800>
8011f86c:	88c001cc 	andi	r3,r17,7
8011f870:	18000426 	beq	r3,zero,8011f884 <__divsf3+0x31c>
8011f874:	88c003cc 	andi	r3,r17,15
8011f878:	01400104 	movi	r5,4
8011f87c:	19400126 	beq	r3,r5,8011f884 <__divsf3+0x31c>
8011f880:	8963883a 	add	r17,r17,r5
8011f884:	88c2002c 	andhi	r3,r17,2048
8011f888:	18000426 	beq	r3,zero,8011f89c <__divsf3+0x334>
8011f88c:	00fe0034 	movhi	r3,63488
8011f890:	18ffffc4 	addi	r3,r3,-1
8011f894:	31002004 	addi	r4,r6,128
8011f898:	88e2703a 	and	r17,r17,r3
8011f89c:	00c03f84 	movi	r3,254
8011f8a0:	193f8016 	blt	r3,r4,8011f6a4 <__reset+0xfa0ff6a4>
8011f8a4:	880c91ba 	slli	r6,r17,6
8011f8a8:	11c0004c 	andi	r7,r2,1
8011f8ac:	300cd27a 	srli	r6,r6,9
8011f8b0:	003f7f06 	br	8011f6b0 <__reset+0xfa0ff6b0>
8011f8b4:	9080102c 	andhi	r2,r18,64
8011f8b8:	10000226 	beq	r2,zero,8011f8c4 <__divsf3+0x35c>
8011f8bc:	8880102c 	andhi	r2,r17,64
8011f8c0:	10001826 	beq	r2,zero,8011f924 <__divsf3+0x3bc>
8011f8c4:	00802034 	movhi	r2,128
8011f8c8:	91801034 	orhi	r6,r18,64
8011f8cc:	10bfffc4 	addi	r2,r2,-1
8011f8d0:	980f883a 	mov	r7,r19
8011f8d4:	308c703a 	and	r6,r6,r2
8011f8d8:	003fc706 	br	8011f7f8 <__reset+0xfa0ff7f8>
8011f8dc:	008000c4 	movi	r2,3
8011f8e0:	b8802d26 	beq	r23,r2,8011f998 <__divsf3+0x430>
8011f8e4:	00c00044 	movi	r3,1
8011f8e8:	b005883a 	mov	r2,r22
8011f8ec:	b8ffdd1e 	bne	r23,r3,8011f864 <__reset+0xfa0ff864>
8011f8f0:	11c0004c 	andi	r7,r2,1
8011f8f4:	0009883a 	mov	r4,zero
8011f8f8:	000d883a 	mov	r6,zero
8011f8fc:	003f6c06 	br	8011f6b0 <__reset+0xfa0ff6b0>
8011f900:	9023883a 	mov	r17,r18
8011f904:	003f6406 	br	8011f698 <__reset+0xfa0ff698>
8011f908:	1c47c83a 	sub	r3,r3,r17
8011f90c:	01000684 	movi	r4,26
8011f910:	01400044 	movi	r5,1
8011f914:	003fc806 	br	8011f838 <__reset+0xfa0ff838>
8011f918:	9080102c 	andhi	r2,r18,64
8011f91c:	103fe926 	beq	r2,zero,8011f8c4 <__reset+0xfa0ff8c4>
8011f920:	0023883a 	mov	r17,zero
8011f924:	00802034 	movhi	r2,128
8011f928:	89801034 	orhi	r6,r17,64
8011f92c:	10bfffc4 	addi	r2,r2,-1
8011f930:	a80f883a 	mov	r7,r21
8011f934:	308c703a 	and	r6,r6,r2
8011f938:	003faf06 	br	8011f7f8 <__reset+0xfa0ff7f8>
8011f93c:	01c00804 	movi	r7,32
8011f940:	390fc83a 	sub	r7,r7,r4
8011f944:	89ce983a 	sll	r7,r17,r7
8011f948:	890ad83a 	srl	r5,r17,r4
8011f94c:	380ec03a 	cmpne	r7,r7,zero
8011f950:	29cab03a 	or	r5,r5,r7
8011f954:	28c001cc 	andi	r3,r5,7
8011f958:	18000426 	beq	r3,zero,8011f96c <__divsf3+0x404>
8011f95c:	28c003cc 	andi	r3,r5,15
8011f960:	01000104 	movi	r4,4
8011f964:	19000126 	beq	r3,r4,8011f96c <__divsf3+0x404>
8011f968:	290b883a 	add	r5,r5,r4
8011f96c:	28c1002c 	andhi	r3,r5,1024
8011f970:	18000426 	beq	r3,zero,8011f984 <__divsf3+0x41c>
8011f974:	11c0004c 	andi	r7,r2,1
8011f978:	01000044 	movi	r4,1
8011f97c:	000d883a 	mov	r6,zero
8011f980:	003f4b06 	br	8011f6b0 <__reset+0xfa0ff6b0>
8011f984:	280a91ba 	slli	r5,r5,6
8011f988:	11c0004c 	andi	r7,r2,1
8011f98c:	0009883a 	mov	r4,zero
8011f990:	280cd27a 	srli	r6,r5,9
8011f994:	003f4606 	br	8011f6b0 <__reset+0xfa0ff6b0>
8011f998:	00802034 	movhi	r2,128
8011f99c:	89801034 	orhi	r6,r17,64
8011f9a0:	10bfffc4 	addi	r2,r2,-1
8011f9a4:	b00f883a 	mov	r7,r22
8011f9a8:	308c703a 	and	r6,r6,r2
8011f9ac:	003f9206 	br	8011f7f8 <__reset+0xfa0ff7f8>

8011f9b0 <__mulsf3>:
8011f9b0:	defff504 	addi	sp,sp,-44
8011f9b4:	de00012e 	bgeu	sp,et,8011f9bc <__mulsf3+0xc>
8011f9b8:	003b68fa 	trap	3
8011f9bc:	dc000115 	stw	r16,4(sp)
8011f9c0:	2020d5fa 	srli	r16,r4,23
8011f9c4:	dd400615 	stw	r21,24(sp)
8011f9c8:	202ad7fa 	srli	r21,r4,31
8011f9cc:	dc800315 	stw	r18,12(sp)
8011f9d0:	04802034 	movhi	r18,128
8011f9d4:	df000915 	stw	fp,36(sp)
8011f9d8:	dd000515 	stw	r20,20(sp)
8011f9dc:	94bfffc4 	addi	r18,r18,-1
8011f9e0:	dfc00a15 	stw	ra,40(sp)
8011f9e4:	ddc00815 	stw	r23,32(sp)
8011f9e8:	dd800715 	stw	r22,28(sp)
8011f9ec:	dcc00415 	stw	r19,16(sp)
8011f9f0:	dc400215 	stw	r17,8(sp)
8011f9f4:	84003fcc 	andi	r16,r16,255
8011f9f8:	9124703a 	and	r18,r18,r4
8011f9fc:	a829883a 	mov	r20,r21
8011fa00:	af003fcc 	andi	fp,r21,255
8011fa04:	80005426 	beq	r16,zero,8011fb58 <__mulsf3+0x1a8>
8011fa08:	00803fc4 	movi	r2,255
8011fa0c:	80802f26 	beq	r16,r2,8011facc <__mulsf3+0x11c>
8011fa10:	91002034 	orhi	r4,r18,128
8011fa14:	202490fa 	slli	r18,r4,3
8011fa18:	843fe044 	addi	r16,r16,-127
8011fa1c:	0023883a 	mov	r17,zero
8011fa20:	002f883a 	mov	r23,zero
8011fa24:	2804d5fa 	srli	r2,r5,23
8011fa28:	282cd7fa 	srli	r22,r5,31
8011fa2c:	01002034 	movhi	r4,128
8011fa30:	213fffc4 	addi	r4,r4,-1
8011fa34:	10803fcc 	andi	r2,r2,255
8011fa38:	2166703a 	and	r19,r4,r5
8011fa3c:	b1803fcc 	andi	r6,r22,255
8011fa40:	10004c26 	beq	r2,zero,8011fb74 <__mulsf3+0x1c4>
8011fa44:	00c03fc4 	movi	r3,255
8011fa48:	10c04726 	beq	r2,r3,8011fb68 <__mulsf3+0x1b8>
8011fa4c:	99002034 	orhi	r4,r19,128
8011fa50:	202690fa 	slli	r19,r4,3
8011fa54:	10bfe044 	addi	r2,r2,-127
8011fa58:	0007883a 	mov	r3,zero
8011fa5c:	80a1883a 	add	r16,r16,r2
8011fa60:	010003c4 	movi	r4,15
8011fa64:	1c44b03a 	or	r2,r3,r17
8011fa68:	b56af03a 	xor	r21,r22,r21
8011fa6c:	81c00044 	addi	r7,r16,1
8011fa70:	20806b36 	bltu	r4,r2,8011fc20 <__mulsf3+0x270>
8011fa74:	100490ba 	slli	r2,r2,2
8011fa78:	012004b4 	movhi	r4,32786
8011fa7c:	213ea304 	addi	r4,r4,-1396
8011fa80:	1105883a 	add	r2,r2,r4
8011fa84:	10800017 	ldw	r2,0(r2)
8011fa88:	1000683a 	jmp	r2
8011fa8c:	8011fc20 	cmpeqi	zero,r16,18416
8011fa90:	8011fae0 	cmpeqi	zero,r16,18411
8011fa94:	8011fae0 	cmpeqi	zero,r16,18411
8011fa98:	8011fadc 	xori	zero,r16,18411
8011fa9c:	8011fc04 	addi	zero,r16,18416
8011faa0:	8011fc04 	addi	zero,r16,18416
8011faa4:	8011fbf0 	cmpltui	zero,r16,18415
8011faa8:	8011fadc 	xori	zero,r16,18411
8011faac:	8011fc04 	addi	zero,r16,18416
8011fab0:	8011fbf0 	cmpltui	zero,r16,18415
8011fab4:	8011fc04 	addi	zero,r16,18416
8011fab8:	8011fadc 	xori	zero,r16,18411
8011fabc:	8011fc10 	cmplti	zero,r16,18416
8011fac0:	8011fc10 	cmplti	zero,r16,18416
8011fac4:	8011fc10 	cmplti	zero,r16,18416
8011fac8:	8011fcec 	andhi	zero,r16,18419
8011facc:	90003b1e 	bne	r18,zero,8011fbbc <__mulsf3+0x20c>
8011fad0:	04400204 	movi	r17,8
8011fad4:	05c00084 	movi	r23,2
8011fad8:	003fd206 	br	8011fa24 <__reset+0xfa0ffa24>
8011fadc:	302b883a 	mov	r21,r6
8011fae0:	00800084 	movi	r2,2
8011fae4:	18802626 	beq	r3,r2,8011fb80 <__mulsf3+0x1d0>
8011fae8:	008000c4 	movi	r2,3
8011faec:	1880ab26 	beq	r3,r2,8011fd9c <__mulsf3+0x3ec>
8011faf0:	00800044 	movi	r2,1
8011faf4:	1880a21e 	bne	r3,r2,8011fd80 <__mulsf3+0x3d0>
8011faf8:	a829883a 	mov	r20,r21
8011fafc:	0007883a 	mov	r3,zero
8011fb00:	0009883a 	mov	r4,zero
8011fb04:	18803fcc 	andi	r2,r3,255
8011fb08:	100695fa 	slli	r3,r2,23
8011fb0c:	a0803fcc 	andi	r2,r20,255
8011fb10:	100a97fa 	slli	r5,r2,31
8011fb14:	00802034 	movhi	r2,128
8011fb18:	10bfffc4 	addi	r2,r2,-1
8011fb1c:	2084703a 	and	r2,r4,r2
8011fb20:	10c4b03a 	or	r2,r2,r3
8011fb24:	1144b03a 	or	r2,r2,r5
8011fb28:	dfc00a17 	ldw	ra,40(sp)
8011fb2c:	df000917 	ldw	fp,36(sp)
8011fb30:	ddc00817 	ldw	r23,32(sp)
8011fb34:	dd800717 	ldw	r22,28(sp)
8011fb38:	dd400617 	ldw	r21,24(sp)
8011fb3c:	dd000517 	ldw	r20,20(sp)
8011fb40:	dcc00417 	ldw	r19,16(sp)
8011fb44:	dc800317 	ldw	r18,12(sp)
8011fb48:	dc400217 	ldw	r17,8(sp)
8011fb4c:	dc000117 	ldw	r16,4(sp)
8011fb50:	dec00b04 	addi	sp,sp,44
8011fb54:	f800283a 	ret
8011fb58:	90000d1e 	bne	r18,zero,8011fb90 <__mulsf3+0x1e0>
8011fb5c:	04400104 	movi	r17,4
8011fb60:	05c00044 	movi	r23,1
8011fb64:	003faf06 	br	8011fa24 <__reset+0xfa0ffa24>
8011fb68:	9806c03a 	cmpne	r3,r19,zero
8011fb6c:	18c00084 	addi	r3,r3,2
8011fb70:	003fba06 	br	8011fa5c <__reset+0xfa0ffa5c>
8011fb74:	9800141e 	bne	r19,zero,8011fbc8 <__mulsf3+0x218>
8011fb78:	00c00044 	movi	r3,1
8011fb7c:	003fb706 	br	8011fa5c <__reset+0xfa0ffa5c>
8011fb80:	a829883a 	mov	r20,r21
8011fb84:	00ffffc4 	movi	r3,-1
8011fb88:	0009883a 	mov	r4,zero
8011fb8c:	003fdd06 	br	8011fb04 <__reset+0xfa0ffb04>
8011fb90:	9009883a 	mov	r4,r18
8011fb94:	d9400015 	stw	r5,0(sp)
8011fb98:	01213d00 	call	801213d0 <__clzsi2>
8011fb9c:	10fffec4 	addi	r3,r2,-5
8011fba0:	10801d84 	addi	r2,r2,118
8011fba4:	90e4983a 	sll	r18,r18,r3
8011fba8:	00a1c83a 	sub	r16,zero,r2
8011fbac:	0023883a 	mov	r17,zero
8011fbb0:	002f883a 	mov	r23,zero
8011fbb4:	d9400017 	ldw	r5,0(sp)
8011fbb8:	003f9a06 	br	8011fa24 <__reset+0xfa0ffa24>
8011fbbc:	04400304 	movi	r17,12
8011fbc0:	05c000c4 	movi	r23,3
8011fbc4:	003f9706 	br	8011fa24 <__reset+0xfa0ffa24>
8011fbc8:	9809883a 	mov	r4,r19
8011fbcc:	d9800015 	stw	r6,0(sp)
8011fbd0:	01213d00 	call	801213d0 <__clzsi2>
8011fbd4:	10fffec4 	addi	r3,r2,-5
8011fbd8:	10801d84 	addi	r2,r2,118
8011fbdc:	98e6983a 	sll	r19,r19,r3
8011fbe0:	0085c83a 	sub	r2,zero,r2
8011fbe4:	0007883a 	mov	r3,zero
8011fbe8:	d9800017 	ldw	r6,0(sp)
8011fbec:	003f9b06 	br	8011fa5c <__reset+0xfa0ffa5c>
8011fbf0:	01002034 	movhi	r4,128
8011fbf4:	0029883a 	mov	r20,zero
8011fbf8:	213fffc4 	addi	r4,r4,-1
8011fbfc:	00ffffc4 	movi	r3,-1
8011fc00:	003fc006 	br	8011fb04 <__reset+0xfa0ffb04>
8011fc04:	9027883a 	mov	r19,r18
8011fc08:	b807883a 	mov	r3,r23
8011fc0c:	003fb406 	br	8011fae0 <__reset+0xfa0ffae0>
8011fc10:	9027883a 	mov	r19,r18
8011fc14:	e02b883a 	mov	r21,fp
8011fc18:	b807883a 	mov	r3,r23
8011fc1c:	003fb006 	br	8011fae0 <__reset+0xfa0ffae0>
8011fc20:	9004d43a 	srli	r2,r18,16
8011fc24:	9810d43a 	srli	r8,r19,16
8011fc28:	94bfffcc 	andi	r18,r18,65535
8011fc2c:	993fffcc 	andi	r4,r19,65535
8011fc30:	910d383a 	mul	r6,r18,r4
8011fc34:	20a7383a 	mul	r19,r4,r2
8011fc38:	9225383a 	mul	r18,r18,r8
8011fc3c:	3006d43a 	srli	r3,r6,16
8011fc40:	1211383a 	mul	r8,r2,r8
8011fc44:	94e5883a 	add	r18,r18,r19
8011fc48:	1c87883a 	add	r3,r3,r18
8011fc4c:	1cc0022e 	bgeu	r3,r19,8011fc58 <__mulsf3+0x2a8>
8011fc50:	00800074 	movhi	r2,1
8011fc54:	4091883a 	add	r8,r8,r2
8011fc58:	1804943a 	slli	r2,r3,16
8011fc5c:	31bfffcc 	andi	r6,r6,65535
8011fc60:	1806d43a 	srli	r3,r3,16
8011fc64:	1185883a 	add	r2,r2,r6
8011fc68:	102691ba 	slli	r19,r2,6
8011fc6c:	1a07883a 	add	r3,r3,r8
8011fc70:	1004d6ba 	srli	r2,r2,26
8011fc74:	180891ba 	slli	r4,r3,6
8011fc78:	9826c03a 	cmpne	r19,r19,zero
8011fc7c:	9884b03a 	or	r2,r19,r2
8011fc80:	1126b03a 	or	r19,r2,r4
8011fc84:	9882002c 	andhi	r2,r19,2048
8011fc88:	10000426 	beq	r2,zero,8011fc9c <__mulsf3+0x2ec>
8011fc8c:	9804d07a 	srli	r2,r19,1
8011fc90:	9900004c 	andi	r4,r19,1
8011fc94:	3821883a 	mov	r16,r7
8011fc98:	1126b03a 	or	r19,r2,r4
8011fc9c:	80c01fc4 	addi	r3,r16,127
8011fca0:	00c0210e 	bge	zero,r3,8011fd28 <__mulsf3+0x378>
8011fca4:	988001cc 	andi	r2,r19,7
8011fca8:	10000426 	beq	r2,zero,8011fcbc <__mulsf3+0x30c>
8011fcac:	988003cc 	andi	r2,r19,15
8011fcb0:	01000104 	movi	r4,4
8011fcb4:	11000126 	beq	r2,r4,8011fcbc <__mulsf3+0x30c>
8011fcb8:	9927883a 	add	r19,r19,r4
8011fcbc:	9882002c 	andhi	r2,r19,2048
8011fcc0:	10000426 	beq	r2,zero,8011fcd4 <__mulsf3+0x324>
8011fcc4:	00be0034 	movhi	r2,63488
8011fcc8:	10bfffc4 	addi	r2,r2,-1
8011fccc:	80c02004 	addi	r3,r16,128
8011fcd0:	98a6703a 	and	r19,r19,r2
8011fcd4:	00803f84 	movi	r2,254
8011fcd8:	10ffa916 	blt	r2,r3,8011fb80 <__reset+0xfa0ffb80>
8011fcdc:	980891ba 	slli	r4,r19,6
8011fce0:	a829883a 	mov	r20,r21
8011fce4:	2008d27a 	srli	r4,r4,9
8011fce8:	003f8606 	br	8011fb04 <__reset+0xfa0ffb04>
8011fcec:	9080102c 	andhi	r2,r18,64
8011fcf0:	10000826 	beq	r2,zero,8011fd14 <__mulsf3+0x364>
8011fcf4:	9880102c 	andhi	r2,r19,64
8011fcf8:	1000061e 	bne	r2,zero,8011fd14 <__mulsf3+0x364>
8011fcfc:	00802034 	movhi	r2,128
8011fd00:	99001034 	orhi	r4,r19,64
8011fd04:	10bfffc4 	addi	r2,r2,-1
8011fd08:	b029883a 	mov	r20,r22
8011fd0c:	2088703a 	and	r4,r4,r2
8011fd10:	003fba06 	br	8011fbfc <__reset+0xfa0ffbfc>
8011fd14:	00802034 	movhi	r2,128
8011fd18:	91001034 	orhi	r4,r18,64
8011fd1c:	10bfffc4 	addi	r2,r2,-1
8011fd20:	2088703a 	and	r4,r4,r2
8011fd24:	003fb506 	br	8011fbfc <__reset+0xfa0ffbfc>
8011fd28:	00800044 	movi	r2,1
8011fd2c:	10c7c83a 	sub	r3,r2,r3
8011fd30:	008006c4 	movi	r2,27
8011fd34:	10ff7016 	blt	r2,r3,8011faf8 <__reset+0xfa0ffaf8>
8011fd38:	00800804 	movi	r2,32
8011fd3c:	10c5c83a 	sub	r2,r2,r3
8011fd40:	9884983a 	sll	r2,r19,r2
8011fd44:	98c6d83a 	srl	r3,r19,r3
8011fd48:	1004c03a 	cmpne	r2,r2,zero
8011fd4c:	1884b03a 	or	r2,r3,r2
8011fd50:	10c001cc 	andi	r3,r2,7
8011fd54:	18000426 	beq	r3,zero,8011fd68 <__mulsf3+0x3b8>
8011fd58:	10c003cc 	andi	r3,r2,15
8011fd5c:	01000104 	movi	r4,4
8011fd60:	19000126 	beq	r3,r4,8011fd68 <__mulsf3+0x3b8>
8011fd64:	1105883a 	add	r2,r2,r4
8011fd68:	10c1002c 	andhi	r3,r2,1024
8011fd6c:	18000626 	beq	r3,zero,8011fd88 <__mulsf3+0x3d8>
8011fd70:	a829883a 	mov	r20,r21
8011fd74:	00c00044 	movi	r3,1
8011fd78:	0009883a 	mov	r4,zero
8011fd7c:	003f6106 	br	8011fb04 <__reset+0xfa0ffb04>
8011fd80:	3821883a 	mov	r16,r7
8011fd84:	003fc506 	br	8011fc9c <__reset+0xfa0ffc9c>
8011fd88:	100491ba 	slli	r2,r2,6
8011fd8c:	a829883a 	mov	r20,r21
8011fd90:	0007883a 	mov	r3,zero
8011fd94:	1008d27a 	srli	r4,r2,9
8011fd98:	003f5a06 	br	8011fb04 <__reset+0xfa0ffb04>
8011fd9c:	00802034 	movhi	r2,128
8011fda0:	99001034 	orhi	r4,r19,64
8011fda4:	10bfffc4 	addi	r2,r2,-1
8011fda8:	a829883a 	mov	r20,r21
8011fdac:	2088703a 	and	r4,r4,r2
8011fdb0:	003f9206 	br	8011fbfc <__reset+0xfa0ffbfc>

8011fdb4 <__floatunsisf>:
8011fdb4:	defffe04 	addi	sp,sp,-8
8011fdb8:	de00012e 	bgeu	sp,et,8011fdc0 <__floatunsisf+0xc>
8011fdbc:	003b68fa 	trap	3
8011fdc0:	dfc00115 	stw	ra,4(sp)
8011fdc4:	dc000015 	stw	r16,0(sp)
8011fdc8:	20002c26 	beq	r4,zero,8011fe7c <__floatunsisf+0xc8>
8011fdcc:	2021883a 	mov	r16,r4
8011fdd0:	01213d00 	call	801213d0 <__clzsi2>
8011fdd4:	00c02784 	movi	r3,158
8011fdd8:	1887c83a 	sub	r3,r3,r2
8011fddc:	01002584 	movi	r4,150
8011fde0:	20c00f16 	blt	r4,r3,8011fe20 <__floatunsisf+0x6c>
8011fde4:	20c9c83a 	sub	r4,r4,r3
8011fde8:	8108983a 	sll	r4,r16,r4
8011fdec:	00802034 	movhi	r2,128
8011fdf0:	10bfffc4 	addi	r2,r2,-1
8011fdf4:	2088703a 	and	r4,r4,r2
8011fdf8:	18803fcc 	andi	r2,r3,255
8011fdfc:	100695fa 	slli	r3,r2,23
8011fe00:	00802034 	movhi	r2,128
8011fe04:	10bfffc4 	addi	r2,r2,-1
8011fe08:	2084703a 	and	r2,r4,r2
8011fe0c:	10c4b03a 	or	r2,r2,r3
8011fe10:	dfc00117 	ldw	ra,4(sp)
8011fe14:	dc000017 	ldw	r16,0(sp)
8011fe18:	dec00204 	addi	sp,sp,8
8011fe1c:	f800283a 	ret
8011fe20:	01002644 	movi	r4,153
8011fe24:	20c01816 	blt	r4,r3,8011fe88 <__floatunsisf+0xd4>
8011fe28:	20c9c83a 	sub	r4,r4,r3
8011fe2c:	8108983a 	sll	r4,r16,r4
8011fe30:	017f0034 	movhi	r5,64512
8011fe34:	297fffc4 	addi	r5,r5,-1
8011fe38:	218001cc 	andi	r6,r4,7
8011fe3c:	214a703a 	and	r5,r4,r5
8011fe40:	30000426 	beq	r6,zero,8011fe54 <__floatunsisf+0xa0>
8011fe44:	210003cc 	andi	r4,r4,15
8011fe48:	01800104 	movi	r6,4
8011fe4c:	21800126 	beq	r4,r6,8011fe54 <__floatunsisf+0xa0>
8011fe50:	298b883a 	add	r5,r5,r6
8011fe54:	2901002c 	andhi	r4,r5,1024
8011fe58:	20000526 	beq	r4,zero,8011fe70 <__floatunsisf+0xbc>
8011fe5c:	00c027c4 	movi	r3,159
8011fe60:	1887c83a 	sub	r3,r3,r2
8011fe64:	00bf0034 	movhi	r2,64512
8011fe68:	10bfffc4 	addi	r2,r2,-1
8011fe6c:	288a703a 	and	r5,r5,r2
8011fe70:	280891ba 	slli	r4,r5,6
8011fe74:	2008d27a 	srli	r4,r4,9
8011fe78:	003fdf06 	br	8011fdf8 <__reset+0xfa0ffdf8>
8011fe7c:	0007883a 	mov	r3,zero
8011fe80:	0009883a 	mov	r4,zero
8011fe84:	003fdc06 	br	8011fdf8 <__reset+0xfa0ffdf8>
8011fe88:	01402e44 	movi	r5,185
8011fe8c:	28cbc83a 	sub	r5,r5,r3
8011fe90:	01000144 	movi	r4,5
8011fe94:	2089c83a 	sub	r4,r4,r2
8011fe98:	814a983a 	sll	r5,r16,r5
8011fe9c:	8108d83a 	srl	r4,r16,r4
8011fea0:	2820c03a 	cmpne	r16,r5,zero
8011fea4:	2408b03a 	or	r4,r4,r16
8011fea8:	003fe106 	br	8011fe30 <__reset+0xfa0ffe30>

8011feac <__gedf2>:
8011feac:	2804d53a 	srli	r2,r5,20
8011feb0:	3806d53a 	srli	r3,r7,20
8011feb4:	02000434 	movhi	r8,16
8011feb8:	423fffc4 	addi	r8,r8,-1
8011febc:	1081ffcc 	andi	r2,r2,2047
8011fec0:	0241ffc4 	movi	r9,2047
8011fec4:	2a14703a 	and	r10,r5,r8
8011fec8:	18c1ffcc 	andi	r3,r3,2047
8011fecc:	3a10703a 	and	r8,r7,r8
8011fed0:	280ad7fa 	srli	r5,r5,31
8011fed4:	380ed7fa 	srli	r7,r7,31
8011fed8:	12401d26 	beq	r2,r9,8011ff50 <__gedf2+0xa4>
8011fedc:	0241ffc4 	movi	r9,2047
8011fee0:	1a401226 	beq	r3,r9,8011ff2c <__gedf2+0x80>
8011fee4:	1000081e 	bne	r2,zero,8011ff08 <__gedf2+0x5c>
8011fee8:	2296b03a 	or	r11,r4,r10
8011feec:	5813003a 	cmpeq	r9,r11,zero
8011fef0:	1800091e 	bne	r3,zero,8011ff18 <__gedf2+0x6c>
8011fef4:	3218b03a 	or	r12,r6,r8
8011fef8:	6000071e 	bne	r12,zero,8011ff18 <__gedf2+0x6c>
8011fefc:	0005883a 	mov	r2,zero
8011ff00:	5800101e 	bne	r11,zero,8011ff44 <__gedf2+0x98>
8011ff04:	f800283a 	ret
8011ff08:	18000c1e 	bne	r3,zero,8011ff3c <__gedf2+0x90>
8011ff0c:	3212b03a 	or	r9,r6,r8
8011ff10:	48000c26 	beq	r9,zero,8011ff44 <__gedf2+0x98>
8011ff14:	0013883a 	mov	r9,zero
8011ff18:	39c03fcc 	andi	r7,r7,255
8011ff1c:	48000826 	beq	r9,zero,8011ff40 <__gedf2+0x94>
8011ff20:	38000926 	beq	r7,zero,8011ff48 <__gedf2+0x9c>
8011ff24:	00800044 	movi	r2,1
8011ff28:	f800283a 	ret
8011ff2c:	3212b03a 	or	r9,r6,r8
8011ff30:	483fec26 	beq	r9,zero,8011fee4 <__reset+0xfa0ffee4>
8011ff34:	00bfff84 	movi	r2,-2
8011ff38:	f800283a 	ret
8011ff3c:	39c03fcc 	andi	r7,r7,255
8011ff40:	29c00626 	beq	r5,r7,8011ff5c <__gedf2+0xb0>
8011ff44:	283ff726 	beq	r5,zero,8011ff24 <__reset+0xfa0fff24>
8011ff48:	00bfffc4 	movi	r2,-1
8011ff4c:	f800283a 	ret
8011ff50:	2292b03a 	or	r9,r4,r10
8011ff54:	483fe126 	beq	r9,zero,8011fedc <__reset+0xfa0ffedc>
8011ff58:	003ff606 	br	8011ff34 <__reset+0xfa0fff34>
8011ff5c:	18bff916 	blt	r3,r2,8011ff44 <__reset+0xfa0fff44>
8011ff60:	10c00316 	blt	r2,r3,8011ff70 <__gedf2+0xc4>
8011ff64:	42bff736 	bltu	r8,r10,8011ff44 <__reset+0xfa0fff44>
8011ff68:	52000326 	beq	r10,r8,8011ff78 <__gedf2+0xcc>
8011ff6c:	5200042e 	bgeu	r10,r8,8011ff80 <__gedf2+0xd4>
8011ff70:	283fec1e 	bne	r5,zero,8011ff24 <__reset+0xfa0fff24>
8011ff74:	003ff406 	br	8011ff48 <__reset+0xfa0fff48>
8011ff78:	313ff236 	bltu	r6,r4,8011ff44 <__reset+0xfa0fff44>
8011ff7c:	21bffc36 	bltu	r4,r6,8011ff70 <__reset+0xfa0fff70>
8011ff80:	0005883a 	mov	r2,zero
8011ff84:	f800283a 	ret

8011ff88 <__muldf3>:
8011ff88:	defff304 	addi	sp,sp,-52
8011ff8c:	2804d53a 	srli	r2,r5,20
8011ff90:	de00012e 	bgeu	sp,et,8011ff98 <__muldf3+0x10>
8011ff94:	003b68fa 	trap	3
8011ff98:	dd800915 	stw	r22,36(sp)
8011ff9c:	282cd7fa 	srli	r22,r5,31
8011ffa0:	dc000315 	stw	r16,12(sp)
8011ffa4:	04000434 	movhi	r16,16
8011ffa8:	dd400815 	stw	r21,32(sp)
8011ffac:	dc800515 	stw	r18,20(sp)
8011ffb0:	843fffc4 	addi	r16,r16,-1
8011ffb4:	dfc00c15 	stw	ra,48(sp)
8011ffb8:	df000b15 	stw	fp,44(sp)
8011ffbc:	ddc00a15 	stw	r23,40(sp)
8011ffc0:	dd000715 	stw	r20,28(sp)
8011ffc4:	dcc00615 	stw	r19,24(sp)
8011ffc8:	dc400415 	stw	r17,16(sp)
8011ffcc:	1481ffcc 	andi	r18,r2,2047
8011ffd0:	2c20703a 	and	r16,r5,r16
8011ffd4:	b02b883a 	mov	r21,r22
8011ffd8:	b2403fcc 	andi	r9,r22,255
8011ffdc:	90006026 	beq	r18,zero,80120160 <__muldf3+0x1d8>
8011ffe0:	0081ffc4 	movi	r2,2047
8011ffe4:	2029883a 	mov	r20,r4
8011ffe8:	90803626 	beq	r18,r2,801200c4 <__muldf3+0x13c>
8011ffec:	80800434 	orhi	r2,r16,16
8011fff0:	100490fa 	slli	r2,r2,3
8011fff4:	2020d77a 	srli	r16,r4,29
8011fff8:	202890fa 	slli	r20,r4,3
8011fffc:	94bf0044 	addi	r18,r18,-1023
80120000:	80a0b03a 	or	r16,r16,r2
80120004:	0027883a 	mov	r19,zero
80120008:	0039883a 	mov	fp,zero
8012000c:	3804d53a 	srli	r2,r7,20
80120010:	382ed7fa 	srli	r23,r7,31
80120014:	04400434 	movhi	r17,16
80120018:	8c7fffc4 	addi	r17,r17,-1
8012001c:	1081ffcc 	andi	r2,r2,2047
80120020:	3011883a 	mov	r8,r6
80120024:	3c62703a 	and	r17,r7,r17
80120028:	ba803fcc 	andi	r10,r23,255
8012002c:	10006d26 	beq	r2,zero,801201e4 <__muldf3+0x25c>
80120030:	00c1ffc4 	movi	r3,2047
80120034:	10c06526 	beq	r2,r3,801201cc <__muldf3+0x244>
80120038:	88c00434 	orhi	r3,r17,16
8012003c:	180690fa 	slli	r3,r3,3
80120040:	3022d77a 	srli	r17,r6,29
80120044:	301090fa 	slli	r8,r6,3
80120048:	10bf0044 	addi	r2,r2,-1023
8012004c:	88e2b03a 	or	r17,r17,r3
80120050:	000b883a 	mov	r5,zero
80120054:	9085883a 	add	r2,r18,r2
80120058:	2cc8b03a 	or	r4,r5,r19
8012005c:	00c003c4 	movi	r3,15
80120060:	bdacf03a 	xor	r22,r23,r22
80120064:	12c00044 	addi	r11,r2,1
80120068:	19009936 	bltu	r3,r4,801202d0 <__muldf3+0x348>
8012006c:	200890ba 	slli	r4,r4,2
80120070:	00e004b4 	movhi	r3,32786
80120074:	18c02104 	addi	r3,r3,132
80120078:	20c9883a 	add	r4,r4,r3
8012007c:	20c00017 	ldw	r3,0(r4)
80120080:	1800683a 	jmp	r3
80120084:	801202d0 	cmplti	zero,r16,18443
80120088:	801200e4 	muli	zero,r16,18435
8012008c:	801200e4 	muli	zero,r16,18435
80120090:	801200e0 	cmpeqi	zero,r16,18435
80120094:	801202ac 	andhi	zero,r16,18442
80120098:	801202ac 	andhi	zero,r16,18442
8012009c:	80120294 	ori	zero,r16,18442
801200a0:	801200e0 	cmpeqi	zero,r16,18435
801200a4:	801202ac 	andhi	zero,r16,18442
801200a8:	80120294 	ori	zero,r16,18442
801200ac:	801202ac 	andhi	zero,r16,18442
801200b0:	801200e0 	cmpeqi	zero,r16,18435
801200b4:	801202bc 	xorhi	zero,r16,18442
801200b8:	801202bc 	xorhi	zero,r16,18442
801200bc:	801202bc 	xorhi	zero,r16,18442
801200c0:	801204d8 	cmpnei	zero,r16,18451
801200c4:	2404b03a 	or	r2,r4,r16
801200c8:	10006f1e 	bne	r2,zero,80120288 <__muldf3+0x300>
801200cc:	04c00204 	movi	r19,8
801200d0:	0021883a 	mov	r16,zero
801200d4:	0029883a 	mov	r20,zero
801200d8:	07000084 	movi	fp,2
801200dc:	003fcb06 	br	8012000c <__reset+0xfa10000c>
801200e0:	502d883a 	mov	r22,r10
801200e4:	00800084 	movi	r2,2
801200e8:	28805726 	beq	r5,r2,80120248 <__muldf3+0x2c0>
801200ec:	008000c4 	movi	r2,3
801200f0:	28816626 	beq	r5,r2,8012068c <__muldf3+0x704>
801200f4:	00800044 	movi	r2,1
801200f8:	2881411e 	bne	r5,r2,80120600 <__muldf3+0x678>
801200fc:	b02b883a 	mov	r21,r22
80120100:	0005883a 	mov	r2,zero
80120104:	000b883a 	mov	r5,zero
80120108:	0029883a 	mov	r20,zero
8012010c:	1004953a 	slli	r2,r2,20
80120110:	a8c03fcc 	andi	r3,r21,255
80120114:	04400434 	movhi	r17,16
80120118:	8c7fffc4 	addi	r17,r17,-1
8012011c:	180697fa 	slli	r3,r3,31
80120120:	2c4a703a 	and	r5,r5,r17
80120124:	288ab03a 	or	r5,r5,r2
80120128:	28c6b03a 	or	r3,r5,r3
8012012c:	a005883a 	mov	r2,r20
80120130:	dfc00c17 	ldw	ra,48(sp)
80120134:	df000b17 	ldw	fp,44(sp)
80120138:	ddc00a17 	ldw	r23,40(sp)
8012013c:	dd800917 	ldw	r22,36(sp)
80120140:	dd400817 	ldw	r21,32(sp)
80120144:	dd000717 	ldw	r20,28(sp)
80120148:	dcc00617 	ldw	r19,24(sp)
8012014c:	dc800517 	ldw	r18,20(sp)
80120150:	dc400417 	ldw	r17,16(sp)
80120154:	dc000317 	ldw	r16,12(sp)
80120158:	dec00d04 	addi	sp,sp,52
8012015c:	f800283a 	ret
80120160:	2404b03a 	or	r2,r4,r16
80120164:	2027883a 	mov	r19,r4
80120168:	10004226 	beq	r2,zero,80120274 <__muldf3+0x2ec>
8012016c:	8000fc26 	beq	r16,zero,80120560 <__muldf3+0x5d8>
80120170:	8009883a 	mov	r4,r16
80120174:	d9800215 	stw	r6,8(sp)
80120178:	d9c00015 	stw	r7,0(sp)
8012017c:	da400115 	stw	r9,4(sp)
80120180:	01213d00 	call	801213d0 <__clzsi2>
80120184:	d9800217 	ldw	r6,8(sp)
80120188:	d9c00017 	ldw	r7,0(sp)
8012018c:	da400117 	ldw	r9,4(sp)
80120190:	113ffd44 	addi	r4,r2,-11
80120194:	00c00704 	movi	r3,28
80120198:	1900ed16 	blt	r3,r4,80120550 <__muldf3+0x5c8>
8012019c:	00c00744 	movi	r3,29
801201a0:	147ffe04 	addi	r17,r2,-8
801201a4:	1907c83a 	sub	r3,r3,r4
801201a8:	8460983a 	sll	r16,r16,r17
801201ac:	98c6d83a 	srl	r3,r19,r3
801201b0:	9c68983a 	sll	r20,r19,r17
801201b4:	1c20b03a 	or	r16,r3,r16
801201b8:	1080fcc4 	addi	r2,r2,1011
801201bc:	00a5c83a 	sub	r18,zero,r2
801201c0:	0027883a 	mov	r19,zero
801201c4:	0039883a 	mov	fp,zero
801201c8:	003f9006 	br	8012000c <__reset+0xfa10000c>
801201cc:	3446b03a 	or	r3,r6,r17
801201d0:	1800261e 	bne	r3,zero,8012026c <__muldf3+0x2e4>
801201d4:	0023883a 	mov	r17,zero
801201d8:	0011883a 	mov	r8,zero
801201dc:	01400084 	movi	r5,2
801201e0:	003f9c06 	br	80120054 <__reset+0xfa100054>
801201e4:	3446b03a 	or	r3,r6,r17
801201e8:	18001c26 	beq	r3,zero,8012025c <__muldf3+0x2d4>
801201ec:	8800ce26 	beq	r17,zero,80120528 <__muldf3+0x5a0>
801201f0:	8809883a 	mov	r4,r17
801201f4:	d9800215 	stw	r6,8(sp)
801201f8:	da400115 	stw	r9,4(sp)
801201fc:	da800015 	stw	r10,0(sp)
80120200:	01213d00 	call	801213d0 <__clzsi2>
80120204:	d9800217 	ldw	r6,8(sp)
80120208:	da400117 	ldw	r9,4(sp)
8012020c:	da800017 	ldw	r10,0(sp)
80120210:	113ffd44 	addi	r4,r2,-11
80120214:	00c00704 	movi	r3,28
80120218:	1900bf16 	blt	r3,r4,80120518 <__muldf3+0x590>
8012021c:	00c00744 	movi	r3,29
80120220:	123ffe04 	addi	r8,r2,-8
80120224:	1907c83a 	sub	r3,r3,r4
80120228:	8a22983a 	sll	r17,r17,r8
8012022c:	30c6d83a 	srl	r3,r6,r3
80120230:	3210983a 	sll	r8,r6,r8
80120234:	1c62b03a 	or	r17,r3,r17
80120238:	1080fcc4 	addi	r2,r2,1011
8012023c:	0085c83a 	sub	r2,zero,r2
80120240:	000b883a 	mov	r5,zero
80120244:	003f8306 	br	80120054 <__reset+0xfa100054>
80120248:	b02b883a 	mov	r21,r22
8012024c:	0081ffc4 	movi	r2,2047
80120250:	000b883a 	mov	r5,zero
80120254:	0029883a 	mov	r20,zero
80120258:	003fac06 	br	8012010c <__reset+0xfa10010c>
8012025c:	0023883a 	mov	r17,zero
80120260:	0011883a 	mov	r8,zero
80120264:	01400044 	movi	r5,1
80120268:	003f7a06 	br	80120054 <__reset+0xfa100054>
8012026c:	014000c4 	movi	r5,3
80120270:	003f7806 	br	80120054 <__reset+0xfa100054>
80120274:	04c00104 	movi	r19,4
80120278:	0021883a 	mov	r16,zero
8012027c:	0029883a 	mov	r20,zero
80120280:	07000044 	movi	fp,1
80120284:	003f6106 	br	8012000c <__reset+0xfa10000c>
80120288:	04c00304 	movi	r19,12
8012028c:	070000c4 	movi	fp,3
80120290:	003f5e06 	br	8012000c <__reset+0xfa10000c>
80120294:	01400434 	movhi	r5,16
80120298:	002b883a 	mov	r21,zero
8012029c:	297fffc4 	addi	r5,r5,-1
801202a0:	053fffc4 	movi	r20,-1
801202a4:	0081ffc4 	movi	r2,2047
801202a8:	003f9806 	br	8012010c <__reset+0xfa10010c>
801202ac:	8023883a 	mov	r17,r16
801202b0:	a011883a 	mov	r8,r20
801202b4:	e00b883a 	mov	r5,fp
801202b8:	003f8a06 	br	801200e4 <__reset+0xfa1000e4>
801202bc:	8023883a 	mov	r17,r16
801202c0:	a011883a 	mov	r8,r20
801202c4:	482d883a 	mov	r22,r9
801202c8:	e00b883a 	mov	r5,fp
801202cc:	003f8506 	br	801200e4 <__reset+0xfa1000e4>
801202d0:	a00ad43a 	srli	r5,r20,16
801202d4:	401ad43a 	srli	r13,r8,16
801202d8:	a53fffcc 	andi	r20,r20,65535
801202dc:	423fffcc 	andi	r8,r8,65535
801202e0:	4519383a 	mul	r12,r8,r20
801202e4:	4147383a 	mul	r3,r8,r5
801202e8:	6d09383a 	mul	r4,r13,r20
801202ec:	600cd43a 	srli	r6,r12,16
801202f0:	2b5d383a 	mul	r14,r5,r13
801202f4:	20c9883a 	add	r4,r4,r3
801202f8:	310d883a 	add	r6,r6,r4
801202fc:	30c0022e 	bgeu	r6,r3,80120308 <__muldf3+0x380>
80120300:	00c00074 	movhi	r3,1
80120304:	70dd883a 	add	r14,r14,r3
80120308:	8826d43a 	srli	r19,r17,16
8012030c:	8bffffcc 	andi	r15,r17,65535
80120310:	7d23383a 	mul	r17,r15,r20
80120314:	7949383a 	mul	r4,r15,r5
80120318:	9d29383a 	mul	r20,r19,r20
8012031c:	8814d43a 	srli	r10,r17,16
80120320:	3012943a 	slli	r9,r6,16
80120324:	a129883a 	add	r20,r20,r4
80120328:	633fffcc 	andi	r12,r12,65535
8012032c:	5515883a 	add	r10,r10,r20
80120330:	3006d43a 	srli	r3,r6,16
80120334:	4b13883a 	add	r9,r9,r12
80120338:	2ccb383a 	mul	r5,r5,r19
8012033c:	5100022e 	bgeu	r10,r4,80120348 <__muldf3+0x3c0>
80120340:	01000074 	movhi	r4,1
80120344:	290b883a 	add	r5,r5,r4
80120348:	802ad43a 	srli	r21,r16,16
8012034c:	843fffcc 	andi	r16,r16,65535
80120350:	440d383a 	mul	r6,r8,r16
80120354:	4565383a 	mul	r18,r8,r21
80120358:	8349383a 	mul	r4,r16,r13
8012035c:	500e943a 	slli	r7,r10,16
80120360:	3010d43a 	srli	r8,r6,16
80120364:	5028d43a 	srli	r20,r10,16
80120368:	2489883a 	add	r4,r4,r18
8012036c:	8abfffcc 	andi	r10,r17,65535
80120370:	3a95883a 	add	r10,r7,r10
80120374:	4119883a 	add	r12,r8,r4
80120378:	a169883a 	add	r20,r20,r5
8012037c:	1a87883a 	add	r3,r3,r10
80120380:	6d5b383a 	mul	r13,r13,r21
80120384:	6480022e 	bgeu	r12,r18,80120390 <__muldf3+0x408>
80120388:	01000074 	movhi	r4,1
8012038c:	691b883a 	add	r13,r13,r4
80120390:	7c25383a 	mul	r18,r15,r16
80120394:	7d4b383a 	mul	r5,r15,r21
80120398:	84cf383a 	mul	r7,r16,r19
8012039c:	901ed43a 	srli	r15,r18,16
801203a0:	6008d43a 	srli	r4,r12,16
801203a4:	6010943a 	slli	r8,r12,16
801203a8:	394f883a 	add	r7,r7,r5
801203ac:	333fffcc 	andi	r12,r6,65535
801203b0:	79df883a 	add	r15,r15,r7
801203b4:	235b883a 	add	r13,r4,r13
801203b8:	9d63383a 	mul	r17,r19,r21
801203bc:	4309883a 	add	r4,r8,r12
801203c0:	7940022e 	bgeu	r15,r5,801203cc <__muldf3+0x444>
801203c4:	01400074 	movhi	r5,1
801203c8:	8963883a 	add	r17,r17,r5
801203cc:	780a943a 	slli	r5,r15,16
801203d0:	91bfffcc 	andi	r6,r18,65535
801203d4:	70c7883a 	add	r3,r14,r3
801203d8:	298d883a 	add	r6,r5,r6
801203dc:	1a8f803a 	cmpltu	r7,r3,r10
801203e0:	350b883a 	add	r5,r6,r20
801203e4:	20c7883a 	add	r3,r4,r3
801203e8:	3955883a 	add	r10,r7,r5
801203ec:	1909803a 	cmpltu	r4,r3,r4
801203f0:	6a91883a 	add	r8,r13,r10
801203f4:	780cd43a 	srli	r6,r15,16
801203f8:	2219883a 	add	r12,r4,r8
801203fc:	2d0b803a 	cmpltu	r5,r5,r20
80120400:	51cf803a 	cmpltu	r7,r10,r7
80120404:	29ceb03a 	or	r7,r5,r7
80120408:	4351803a 	cmpltu	r8,r8,r13
8012040c:	610b803a 	cmpltu	r5,r12,r4
80120410:	4148b03a 	or	r4,r8,r5
80120414:	398f883a 	add	r7,r7,r6
80120418:	3909883a 	add	r4,r7,r4
8012041c:	1810927a 	slli	r8,r3,9
80120420:	2449883a 	add	r4,r4,r17
80120424:	2008927a 	slli	r4,r4,9
80120428:	6022d5fa 	srli	r17,r12,23
8012042c:	1806d5fa 	srli	r3,r3,23
80120430:	4252b03a 	or	r9,r8,r9
80120434:	600a927a 	slli	r5,r12,9
80120438:	4810c03a 	cmpne	r8,r9,zero
8012043c:	2462b03a 	or	r17,r4,r17
80120440:	40c6b03a 	or	r3,r8,r3
80120444:	8900402c 	andhi	r4,r17,256
80120448:	1950b03a 	or	r8,r3,r5
8012044c:	20000726 	beq	r4,zero,8012046c <__muldf3+0x4e4>
80120450:	4006d07a 	srli	r3,r8,1
80120454:	880497fa 	slli	r2,r17,31
80120458:	4200004c 	andi	r8,r8,1
8012045c:	8822d07a 	srli	r17,r17,1
80120460:	1a10b03a 	or	r8,r3,r8
80120464:	1210b03a 	or	r8,r2,r8
80120468:	5805883a 	mov	r2,r11
8012046c:	1140ffc4 	addi	r5,r2,1023
80120470:	0140440e 	bge	zero,r5,80120584 <__muldf3+0x5fc>
80120474:	40c001cc 	andi	r3,r8,7
80120478:	18000726 	beq	r3,zero,80120498 <__muldf3+0x510>
8012047c:	40c003cc 	andi	r3,r8,15
80120480:	01000104 	movi	r4,4
80120484:	19000426 	beq	r3,r4,80120498 <__muldf3+0x510>
80120488:	4107883a 	add	r3,r8,r4
8012048c:	1a11803a 	cmpltu	r8,r3,r8
80120490:	8a23883a 	add	r17,r17,r8
80120494:	1811883a 	mov	r8,r3
80120498:	88c0402c 	andhi	r3,r17,256
8012049c:	18000426 	beq	r3,zero,801204b0 <__muldf3+0x528>
801204a0:	11410004 	addi	r5,r2,1024
801204a4:	00bfc034 	movhi	r2,65280
801204a8:	10bfffc4 	addi	r2,r2,-1
801204ac:	88a2703a 	and	r17,r17,r2
801204b0:	0081ff84 	movi	r2,2046
801204b4:	117f6416 	blt	r2,r5,80120248 <__reset+0xfa100248>
801204b8:	8828977a 	slli	r20,r17,29
801204bc:	4010d0fa 	srli	r8,r8,3
801204c0:	8822927a 	slli	r17,r17,9
801204c4:	2881ffcc 	andi	r2,r5,2047
801204c8:	a228b03a 	or	r20,r20,r8
801204cc:	880ad33a 	srli	r5,r17,12
801204d0:	b02b883a 	mov	r21,r22
801204d4:	003f0d06 	br	8012010c <__reset+0xfa10010c>
801204d8:	8080022c 	andhi	r2,r16,8
801204dc:	10000926 	beq	r2,zero,80120504 <__muldf3+0x57c>
801204e0:	8880022c 	andhi	r2,r17,8
801204e4:	1000071e 	bne	r2,zero,80120504 <__muldf3+0x57c>
801204e8:	00800434 	movhi	r2,16
801204ec:	89400234 	orhi	r5,r17,8
801204f0:	10bfffc4 	addi	r2,r2,-1
801204f4:	b82b883a 	mov	r21,r23
801204f8:	288a703a 	and	r5,r5,r2
801204fc:	4029883a 	mov	r20,r8
80120500:	003f6806 	br	801202a4 <__reset+0xfa1002a4>
80120504:	00800434 	movhi	r2,16
80120508:	81400234 	orhi	r5,r16,8
8012050c:	10bfffc4 	addi	r2,r2,-1
80120510:	288a703a 	and	r5,r5,r2
80120514:	003f6306 	br	801202a4 <__reset+0xfa1002a4>
80120518:	147ff604 	addi	r17,r2,-40
8012051c:	3462983a 	sll	r17,r6,r17
80120520:	0011883a 	mov	r8,zero
80120524:	003f4406 	br	80120238 <__reset+0xfa100238>
80120528:	3009883a 	mov	r4,r6
8012052c:	d9800215 	stw	r6,8(sp)
80120530:	da400115 	stw	r9,4(sp)
80120534:	da800015 	stw	r10,0(sp)
80120538:	01213d00 	call	801213d0 <__clzsi2>
8012053c:	10800804 	addi	r2,r2,32
80120540:	da800017 	ldw	r10,0(sp)
80120544:	da400117 	ldw	r9,4(sp)
80120548:	d9800217 	ldw	r6,8(sp)
8012054c:	003f3006 	br	80120210 <__reset+0xfa100210>
80120550:	143ff604 	addi	r16,r2,-40
80120554:	9c20983a 	sll	r16,r19,r16
80120558:	0029883a 	mov	r20,zero
8012055c:	003f1606 	br	801201b8 <__reset+0xfa1001b8>
80120560:	d9800215 	stw	r6,8(sp)
80120564:	d9c00015 	stw	r7,0(sp)
80120568:	da400115 	stw	r9,4(sp)
8012056c:	01213d00 	call	801213d0 <__clzsi2>
80120570:	10800804 	addi	r2,r2,32
80120574:	da400117 	ldw	r9,4(sp)
80120578:	d9c00017 	ldw	r7,0(sp)
8012057c:	d9800217 	ldw	r6,8(sp)
80120580:	003f0306 	br	80120190 <__reset+0xfa100190>
80120584:	00c00044 	movi	r3,1
80120588:	1947c83a 	sub	r3,r3,r5
8012058c:	00800e04 	movi	r2,56
80120590:	10feda16 	blt	r2,r3,801200fc <__reset+0xfa1000fc>
80120594:	008007c4 	movi	r2,31
80120598:	10c01b16 	blt	r2,r3,80120608 <__muldf3+0x680>
8012059c:	00800804 	movi	r2,32
801205a0:	10c5c83a 	sub	r2,r2,r3
801205a4:	888a983a 	sll	r5,r17,r2
801205a8:	40c8d83a 	srl	r4,r8,r3
801205ac:	4084983a 	sll	r2,r8,r2
801205b0:	88e2d83a 	srl	r17,r17,r3
801205b4:	2906b03a 	or	r3,r5,r4
801205b8:	1004c03a 	cmpne	r2,r2,zero
801205bc:	1886b03a 	or	r3,r3,r2
801205c0:	188001cc 	andi	r2,r3,7
801205c4:	10000726 	beq	r2,zero,801205e4 <__muldf3+0x65c>
801205c8:	188003cc 	andi	r2,r3,15
801205cc:	01000104 	movi	r4,4
801205d0:	11000426 	beq	r2,r4,801205e4 <__muldf3+0x65c>
801205d4:	1805883a 	mov	r2,r3
801205d8:	10c00104 	addi	r3,r2,4
801205dc:	1885803a 	cmpltu	r2,r3,r2
801205e0:	88a3883a 	add	r17,r17,r2
801205e4:	8880202c 	andhi	r2,r17,128
801205e8:	10001c26 	beq	r2,zero,8012065c <__muldf3+0x6d4>
801205ec:	b02b883a 	mov	r21,r22
801205f0:	00800044 	movi	r2,1
801205f4:	000b883a 	mov	r5,zero
801205f8:	0029883a 	mov	r20,zero
801205fc:	003ec306 	br	8012010c <__reset+0xfa10010c>
80120600:	5805883a 	mov	r2,r11
80120604:	003f9906 	br	8012046c <__reset+0xfa10046c>
80120608:	00bff844 	movi	r2,-31
8012060c:	1145c83a 	sub	r2,r2,r5
80120610:	8888d83a 	srl	r4,r17,r2
80120614:	00800804 	movi	r2,32
80120618:	18801a26 	beq	r3,r2,80120684 <__muldf3+0x6fc>
8012061c:	00801004 	movi	r2,64
80120620:	10c5c83a 	sub	r2,r2,r3
80120624:	8884983a 	sll	r2,r17,r2
80120628:	1204b03a 	or	r2,r2,r8
8012062c:	1004c03a 	cmpne	r2,r2,zero
80120630:	2084b03a 	or	r2,r4,r2
80120634:	144001cc 	andi	r17,r2,7
80120638:	88000d1e 	bne	r17,zero,80120670 <__muldf3+0x6e8>
8012063c:	000b883a 	mov	r5,zero
80120640:	1028d0fa 	srli	r20,r2,3
80120644:	b02b883a 	mov	r21,r22
80120648:	0005883a 	mov	r2,zero
8012064c:	a468b03a 	or	r20,r20,r17
80120650:	003eae06 	br	8012010c <__reset+0xfa10010c>
80120654:	1007883a 	mov	r3,r2
80120658:	0023883a 	mov	r17,zero
8012065c:	880a927a 	slli	r5,r17,9
80120660:	1805883a 	mov	r2,r3
80120664:	8822977a 	slli	r17,r17,29
80120668:	280ad33a 	srli	r5,r5,12
8012066c:	003ff406 	br	80120640 <__reset+0xfa100640>
80120670:	10c003cc 	andi	r3,r2,15
80120674:	01000104 	movi	r4,4
80120678:	193ff626 	beq	r3,r4,80120654 <__reset+0xfa100654>
8012067c:	0023883a 	mov	r17,zero
80120680:	003fd506 	br	801205d8 <__reset+0xfa1005d8>
80120684:	0005883a 	mov	r2,zero
80120688:	003fe706 	br	80120628 <__reset+0xfa100628>
8012068c:	00800434 	movhi	r2,16
80120690:	89400234 	orhi	r5,r17,8
80120694:	10bfffc4 	addi	r2,r2,-1
80120698:	b02b883a 	mov	r21,r22
8012069c:	288a703a 	and	r5,r5,r2
801206a0:	4029883a 	mov	r20,r8
801206a4:	003eff06 	br	801202a4 <__reset+0xfa1002a4>

801206a8 <__subdf3>:
801206a8:	02000434 	movhi	r8,16
801206ac:	423fffc4 	addi	r8,r8,-1
801206b0:	defffb04 	addi	sp,sp,-20
801206b4:	2a14703a 	and	r10,r5,r8
801206b8:	3812d53a 	srli	r9,r7,20
801206bc:	3a10703a 	and	r8,r7,r8
801206c0:	de00012e 	bgeu	sp,et,801206c8 <__subdf3+0x20>
801206c4:	003b68fa 	trap	3
801206c8:	2006d77a 	srli	r3,r4,29
801206cc:	3004d77a 	srli	r2,r6,29
801206d0:	dc000015 	stw	r16,0(sp)
801206d4:	501490fa 	slli	r10,r10,3
801206d8:	2820d53a 	srli	r16,r5,20
801206dc:	401090fa 	slli	r8,r8,3
801206e0:	dc800215 	stw	r18,8(sp)
801206e4:	dc400115 	stw	r17,4(sp)
801206e8:	dfc00415 	stw	ra,16(sp)
801206ec:	202290fa 	slli	r17,r4,3
801206f0:	dcc00315 	stw	r19,12(sp)
801206f4:	4a41ffcc 	andi	r9,r9,2047
801206f8:	0101ffc4 	movi	r4,2047
801206fc:	2824d7fa 	srli	r18,r5,31
80120700:	8401ffcc 	andi	r16,r16,2047
80120704:	50c6b03a 	or	r3,r10,r3
80120708:	380ed7fa 	srli	r7,r7,31
8012070c:	408ab03a 	or	r5,r8,r2
80120710:	300c90fa 	slli	r6,r6,3
80120714:	49009626 	beq	r9,r4,80120970 <__subdf3+0x2c8>
80120718:	39c0005c 	xori	r7,r7,1
8012071c:	8245c83a 	sub	r2,r16,r9
80120720:	3c807426 	beq	r7,r18,801208f4 <__subdf3+0x24c>
80120724:	0080af0e 	bge	zero,r2,801209e4 <__subdf3+0x33c>
80120728:	48002a1e 	bne	r9,zero,801207d4 <__subdf3+0x12c>
8012072c:	2988b03a 	or	r4,r5,r6
80120730:	20009a1e 	bne	r4,zero,8012099c <__subdf3+0x2f4>
80120734:	888001cc 	andi	r2,r17,7
80120738:	10000726 	beq	r2,zero,80120758 <__subdf3+0xb0>
8012073c:	888003cc 	andi	r2,r17,15
80120740:	01000104 	movi	r4,4
80120744:	11000426 	beq	r2,r4,80120758 <__subdf3+0xb0>
80120748:	890b883a 	add	r5,r17,r4
8012074c:	2c63803a 	cmpltu	r17,r5,r17
80120750:	1c47883a 	add	r3,r3,r17
80120754:	2823883a 	mov	r17,r5
80120758:	1880202c 	andhi	r2,r3,128
8012075c:	10005926 	beq	r2,zero,801208c4 <__subdf3+0x21c>
80120760:	84000044 	addi	r16,r16,1
80120764:	0081ffc4 	movi	r2,2047
80120768:	8080be26 	beq	r16,r2,80120a64 <__subdf3+0x3bc>
8012076c:	017fe034 	movhi	r5,65408
80120770:	297fffc4 	addi	r5,r5,-1
80120774:	1946703a 	and	r3,r3,r5
80120778:	1804977a 	slli	r2,r3,29
8012077c:	1806927a 	slli	r3,r3,9
80120780:	8822d0fa 	srli	r17,r17,3
80120784:	8401ffcc 	andi	r16,r16,2047
80120788:	180ad33a 	srli	r5,r3,12
8012078c:	9100004c 	andi	r4,r18,1
80120790:	1444b03a 	or	r2,r2,r17
80120794:	80c1ffcc 	andi	r3,r16,2047
80120798:	1820953a 	slli	r16,r3,20
8012079c:	20c03fcc 	andi	r3,r4,255
801207a0:	180897fa 	slli	r4,r3,31
801207a4:	00c00434 	movhi	r3,16
801207a8:	18ffffc4 	addi	r3,r3,-1
801207ac:	28c6703a 	and	r3,r5,r3
801207b0:	1c06b03a 	or	r3,r3,r16
801207b4:	1906b03a 	or	r3,r3,r4
801207b8:	dfc00417 	ldw	ra,16(sp)
801207bc:	dcc00317 	ldw	r19,12(sp)
801207c0:	dc800217 	ldw	r18,8(sp)
801207c4:	dc400117 	ldw	r17,4(sp)
801207c8:	dc000017 	ldw	r16,0(sp)
801207cc:	dec00504 	addi	sp,sp,20
801207d0:	f800283a 	ret
801207d4:	0101ffc4 	movi	r4,2047
801207d8:	813fd626 	beq	r16,r4,80120734 <__reset+0xfa100734>
801207dc:	29402034 	orhi	r5,r5,128
801207e0:	01000e04 	movi	r4,56
801207e4:	2080a316 	blt	r4,r2,80120a74 <__subdf3+0x3cc>
801207e8:	010007c4 	movi	r4,31
801207ec:	2080c616 	blt	r4,r2,80120b08 <__subdf3+0x460>
801207f0:	01000804 	movi	r4,32
801207f4:	2089c83a 	sub	r4,r4,r2
801207f8:	2910983a 	sll	r8,r5,r4
801207fc:	308ed83a 	srl	r7,r6,r2
80120800:	3108983a 	sll	r4,r6,r4
80120804:	2884d83a 	srl	r2,r5,r2
80120808:	41ccb03a 	or	r6,r8,r7
8012080c:	2008c03a 	cmpne	r4,r4,zero
80120810:	310cb03a 	or	r6,r6,r4
80120814:	898dc83a 	sub	r6,r17,r6
80120818:	89a3803a 	cmpltu	r17,r17,r6
8012081c:	1887c83a 	sub	r3,r3,r2
80120820:	1c47c83a 	sub	r3,r3,r17
80120824:	3023883a 	mov	r17,r6
80120828:	1880202c 	andhi	r2,r3,128
8012082c:	10002326 	beq	r2,zero,801208bc <__subdf3+0x214>
80120830:	04c02034 	movhi	r19,128
80120834:	9cffffc4 	addi	r19,r19,-1
80120838:	1ce6703a 	and	r19,r3,r19
8012083c:	98007a26 	beq	r19,zero,80120a28 <__subdf3+0x380>
80120840:	9809883a 	mov	r4,r19
80120844:	01213d00 	call	801213d0 <__clzsi2>
80120848:	113ffe04 	addi	r4,r2,-8
8012084c:	00c007c4 	movi	r3,31
80120850:	19007b16 	blt	r3,r4,80120a40 <__subdf3+0x398>
80120854:	00800804 	movi	r2,32
80120858:	1105c83a 	sub	r2,r2,r4
8012085c:	8884d83a 	srl	r2,r17,r2
80120860:	9906983a 	sll	r3,r19,r4
80120864:	8922983a 	sll	r17,r17,r4
80120868:	10c4b03a 	or	r2,r2,r3
8012086c:	24007816 	blt	r4,r16,80120a50 <__subdf3+0x3a8>
80120870:	2421c83a 	sub	r16,r4,r16
80120874:	80c00044 	addi	r3,r16,1
80120878:	010007c4 	movi	r4,31
8012087c:	20c09516 	blt	r4,r3,80120ad4 <__subdf3+0x42c>
80120880:	01400804 	movi	r5,32
80120884:	28cbc83a 	sub	r5,r5,r3
80120888:	88c8d83a 	srl	r4,r17,r3
8012088c:	8962983a 	sll	r17,r17,r5
80120890:	114a983a 	sll	r5,r2,r5
80120894:	10c6d83a 	srl	r3,r2,r3
80120898:	8804c03a 	cmpne	r2,r17,zero
8012089c:	290ab03a 	or	r5,r5,r4
801208a0:	28a2b03a 	or	r17,r5,r2
801208a4:	0021883a 	mov	r16,zero
801208a8:	003fa206 	br	80120734 <__reset+0xfa100734>
801208ac:	2090b03a 	or	r8,r4,r2
801208b0:	40018e26 	beq	r8,zero,80120eec <__subdf3+0x844>
801208b4:	1007883a 	mov	r3,r2
801208b8:	2023883a 	mov	r17,r4
801208bc:	888001cc 	andi	r2,r17,7
801208c0:	103f9e1e 	bne	r2,zero,8012073c <__reset+0xfa10073c>
801208c4:	1804977a 	slli	r2,r3,29
801208c8:	8822d0fa 	srli	r17,r17,3
801208cc:	1810d0fa 	srli	r8,r3,3
801208d0:	9100004c 	andi	r4,r18,1
801208d4:	1444b03a 	or	r2,r2,r17
801208d8:	00c1ffc4 	movi	r3,2047
801208dc:	80c02826 	beq	r16,r3,80120980 <__subdf3+0x2d8>
801208e0:	01400434 	movhi	r5,16
801208e4:	297fffc4 	addi	r5,r5,-1
801208e8:	80e0703a 	and	r16,r16,r3
801208ec:	414a703a 	and	r5,r8,r5
801208f0:	003fa806 	br	80120794 <__reset+0xfa100794>
801208f4:	0080630e 	bge	zero,r2,80120a84 <__subdf3+0x3dc>
801208f8:	48003026 	beq	r9,zero,801209bc <__subdf3+0x314>
801208fc:	0101ffc4 	movi	r4,2047
80120900:	813f8c26 	beq	r16,r4,80120734 <__reset+0xfa100734>
80120904:	29402034 	orhi	r5,r5,128
80120908:	01000e04 	movi	r4,56
8012090c:	2080a90e 	bge	r4,r2,80120bb4 <__subdf3+0x50c>
80120910:	298cb03a 	or	r6,r5,r6
80120914:	3012c03a 	cmpne	r9,r6,zero
80120918:	0005883a 	mov	r2,zero
8012091c:	4c53883a 	add	r9,r9,r17
80120920:	4c63803a 	cmpltu	r17,r9,r17
80120924:	10c7883a 	add	r3,r2,r3
80120928:	88c7883a 	add	r3,r17,r3
8012092c:	4823883a 	mov	r17,r9
80120930:	1880202c 	andhi	r2,r3,128
80120934:	1000d026 	beq	r2,zero,80120c78 <__subdf3+0x5d0>
80120938:	84000044 	addi	r16,r16,1
8012093c:	0081ffc4 	movi	r2,2047
80120940:	8080fe26 	beq	r16,r2,80120d3c <__subdf3+0x694>
80120944:	00bfe034 	movhi	r2,65408
80120948:	10bfffc4 	addi	r2,r2,-1
8012094c:	1886703a 	and	r3,r3,r2
80120950:	880ad07a 	srli	r5,r17,1
80120954:	180497fa 	slli	r2,r3,31
80120958:	8900004c 	andi	r4,r17,1
8012095c:	2922b03a 	or	r17,r5,r4
80120960:	1806d07a 	srli	r3,r3,1
80120964:	1462b03a 	or	r17,r2,r17
80120968:	3825883a 	mov	r18,r7
8012096c:	003f7106 	br	80120734 <__reset+0xfa100734>
80120970:	2984b03a 	or	r2,r5,r6
80120974:	103f6826 	beq	r2,zero,80120718 <__reset+0xfa100718>
80120978:	39c03fcc 	andi	r7,r7,255
8012097c:	003f6706 	br	8012071c <__reset+0xfa10071c>
80120980:	4086b03a 	or	r3,r8,r2
80120984:	18015226 	beq	r3,zero,80120ed0 <__subdf3+0x828>
80120988:	00c00434 	movhi	r3,16
8012098c:	41400234 	orhi	r5,r8,8
80120990:	18ffffc4 	addi	r3,r3,-1
80120994:	28ca703a 	and	r5,r5,r3
80120998:	003f7e06 	br	80120794 <__reset+0xfa100794>
8012099c:	10bfffc4 	addi	r2,r2,-1
801209a0:	1000491e 	bne	r2,zero,80120ac8 <__subdf3+0x420>
801209a4:	898fc83a 	sub	r7,r17,r6
801209a8:	89e3803a 	cmpltu	r17,r17,r7
801209ac:	1947c83a 	sub	r3,r3,r5
801209b0:	1c47c83a 	sub	r3,r3,r17
801209b4:	3823883a 	mov	r17,r7
801209b8:	003f9b06 	br	80120828 <__reset+0xfa100828>
801209bc:	2988b03a 	or	r4,r5,r6
801209c0:	203f5c26 	beq	r4,zero,80120734 <__reset+0xfa100734>
801209c4:	10bfffc4 	addi	r2,r2,-1
801209c8:	1000931e 	bne	r2,zero,80120c18 <__subdf3+0x570>
801209cc:	898d883a 	add	r6,r17,r6
801209d0:	3463803a 	cmpltu	r17,r6,r17
801209d4:	1947883a 	add	r3,r3,r5
801209d8:	88c7883a 	add	r3,r17,r3
801209dc:	3023883a 	mov	r17,r6
801209e0:	003fd306 	br	80120930 <__reset+0xfa100930>
801209e4:	1000541e 	bne	r2,zero,80120b38 <__subdf3+0x490>
801209e8:	80800044 	addi	r2,r16,1
801209ec:	1081ffcc 	andi	r2,r2,2047
801209f0:	01000044 	movi	r4,1
801209f4:	2080a20e 	bge	r4,r2,80120c80 <__subdf3+0x5d8>
801209f8:	8989c83a 	sub	r4,r17,r6
801209fc:	8905803a 	cmpltu	r2,r17,r4
80120a00:	1967c83a 	sub	r19,r3,r5
80120a04:	98a7c83a 	sub	r19,r19,r2
80120a08:	9880202c 	andhi	r2,r19,128
80120a0c:	10006326 	beq	r2,zero,80120b9c <__subdf3+0x4f4>
80120a10:	3463c83a 	sub	r17,r6,r17
80120a14:	28c7c83a 	sub	r3,r5,r3
80120a18:	344d803a 	cmpltu	r6,r6,r17
80120a1c:	19a7c83a 	sub	r19,r3,r6
80120a20:	3825883a 	mov	r18,r7
80120a24:	983f861e 	bne	r19,zero,80120840 <__reset+0xfa100840>
80120a28:	8809883a 	mov	r4,r17
80120a2c:	01213d00 	call	801213d0 <__clzsi2>
80120a30:	10800804 	addi	r2,r2,32
80120a34:	113ffe04 	addi	r4,r2,-8
80120a38:	00c007c4 	movi	r3,31
80120a3c:	193f850e 	bge	r3,r4,80120854 <__reset+0xfa100854>
80120a40:	10bff604 	addi	r2,r2,-40
80120a44:	8884983a 	sll	r2,r17,r2
80120a48:	0023883a 	mov	r17,zero
80120a4c:	243f880e 	bge	r4,r16,80120870 <__reset+0xfa100870>
80120a50:	00ffe034 	movhi	r3,65408
80120a54:	18ffffc4 	addi	r3,r3,-1
80120a58:	8121c83a 	sub	r16,r16,r4
80120a5c:	10c6703a 	and	r3,r2,r3
80120a60:	003f3406 	br	80120734 <__reset+0xfa100734>
80120a64:	9100004c 	andi	r4,r18,1
80120a68:	000b883a 	mov	r5,zero
80120a6c:	0005883a 	mov	r2,zero
80120a70:	003f4806 	br	80120794 <__reset+0xfa100794>
80120a74:	298cb03a 	or	r6,r5,r6
80120a78:	300cc03a 	cmpne	r6,r6,zero
80120a7c:	0005883a 	mov	r2,zero
80120a80:	003f6406 	br	80120814 <__reset+0xfa100814>
80120a84:	10009a1e 	bne	r2,zero,80120cf0 <__subdf3+0x648>
80120a88:	82400044 	addi	r9,r16,1
80120a8c:	4881ffcc 	andi	r2,r9,2047
80120a90:	02800044 	movi	r10,1
80120a94:	5080670e 	bge	r10,r2,80120c34 <__subdf3+0x58c>
80120a98:	0081ffc4 	movi	r2,2047
80120a9c:	4880af26 	beq	r9,r2,80120d5c <__subdf3+0x6b4>
80120aa0:	898d883a 	add	r6,r17,r6
80120aa4:	1945883a 	add	r2,r3,r5
80120aa8:	3447803a 	cmpltu	r3,r6,r17
80120aac:	1887883a 	add	r3,r3,r2
80120ab0:	182297fa 	slli	r17,r3,31
80120ab4:	300cd07a 	srli	r6,r6,1
80120ab8:	1806d07a 	srli	r3,r3,1
80120abc:	4821883a 	mov	r16,r9
80120ac0:	89a2b03a 	or	r17,r17,r6
80120ac4:	003f1b06 	br	80120734 <__reset+0xfa100734>
80120ac8:	0101ffc4 	movi	r4,2047
80120acc:	813f441e 	bne	r16,r4,801207e0 <__reset+0xfa1007e0>
80120ad0:	003f1806 	br	80120734 <__reset+0xfa100734>
80120ad4:	843ff844 	addi	r16,r16,-31
80120ad8:	01400804 	movi	r5,32
80120adc:	1408d83a 	srl	r4,r2,r16
80120ae0:	19405026 	beq	r3,r5,80120c24 <__subdf3+0x57c>
80120ae4:	01401004 	movi	r5,64
80120ae8:	28c7c83a 	sub	r3,r5,r3
80120aec:	10c4983a 	sll	r2,r2,r3
80120af0:	88a2b03a 	or	r17,r17,r2
80120af4:	8822c03a 	cmpne	r17,r17,zero
80120af8:	2462b03a 	or	r17,r4,r17
80120afc:	0007883a 	mov	r3,zero
80120b00:	0021883a 	mov	r16,zero
80120b04:	003f6d06 	br	801208bc <__reset+0xfa1008bc>
80120b08:	11fff804 	addi	r7,r2,-32
80120b0c:	01000804 	movi	r4,32
80120b10:	29ced83a 	srl	r7,r5,r7
80120b14:	11004526 	beq	r2,r4,80120c2c <__subdf3+0x584>
80120b18:	01001004 	movi	r4,64
80120b1c:	2089c83a 	sub	r4,r4,r2
80120b20:	2904983a 	sll	r2,r5,r4
80120b24:	118cb03a 	or	r6,r2,r6
80120b28:	300cc03a 	cmpne	r6,r6,zero
80120b2c:	398cb03a 	or	r6,r7,r6
80120b30:	0005883a 	mov	r2,zero
80120b34:	003f3706 	br	80120814 <__reset+0xfa100814>
80120b38:	80002a26 	beq	r16,zero,80120be4 <__subdf3+0x53c>
80120b3c:	0101ffc4 	movi	r4,2047
80120b40:	49006626 	beq	r9,r4,80120cdc <__subdf3+0x634>
80120b44:	0085c83a 	sub	r2,zero,r2
80120b48:	18c02034 	orhi	r3,r3,128
80120b4c:	01000e04 	movi	r4,56
80120b50:	20807e16 	blt	r4,r2,80120d4c <__subdf3+0x6a4>
80120b54:	010007c4 	movi	r4,31
80120b58:	2080e716 	blt	r4,r2,80120ef8 <__subdf3+0x850>
80120b5c:	01000804 	movi	r4,32
80120b60:	2089c83a 	sub	r4,r4,r2
80120b64:	1914983a 	sll	r10,r3,r4
80120b68:	8890d83a 	srl	r8,r17,r2
80120b6c:	8908983a 	sll	r4,r17,r4
80120b70:	1884d83a 	srl	r2,r3,r2
80120b74:	5222b03a 	or	r17,r10,r8
80120b78:	2006c03a 	cmpne	r3,r4,zero
80120b7c:	88e2b03a 	or	r17,r17,r3
80120b80:	3463c83a 	sub	r17,r6,r17
80120b84:	2885c83a 	sub	r2,r5,r2
80120b88:	344d803a 	cmpltu	r6,r6,r17
80120b8c:	1187c83a 	sub	r3,r2,r6
80120b90:	4821883a 	mov	r16,r9
80120b94:	3825883a 	mov	r18,r7
80120b98:	003f2306 	br	80120828 <__reset+0xfa100828>
80120b9c:	24d0b03a 	or	r8,r4,r19
80120ba0:	40001b1e 	bne	r8,zero,80120c10 <__subdf3+0x568>
80120ba4:	0005883a 	mov	r2,zero
80120ba8:	0009883a 	mov	r4,zero
80120bac:	0021883a 	mov	r16,zero
80120bb0:	003f4906 	br	801208d8 <__reset+0xfa1008d8>
80120bb4:	010007c4 	movi	r4,31
80120bb8:	20803a16 	blt	r4,r2,80120ca4 <__subdf3+0x5fc>
80120bbc:	01000804 	movi	r4,32
80120bc0:	2089c83a 	sub	r4,r4,r2
80120bc4:	2912983a 	sll	r9,r5,r4
80120bc8:	3090d83a 	srl	r8,r6,r2
80120bcc:	3108983a 	sll	r4,r6,r4
80120bd0:	2884d83a 	srl	r2,r5,r2
80120bd4:	4a12b03a 	or	r9,r9,r8
80120bd8:	2008c03a 	cmpne	r4,r4,zero
80120bdc:	4912b03a 	or	r9,r9,r4
80120be0:	003f4e06 	br	8012091c <__reset+0xfa10091c>
80120be4:	1c48b03a 	or	r4,r3,r17
80120be8:	20003c26 	beq	r4,zero,80120cdc <__subdf3+0x634>
80120bec:	0084303a 	nor	r2,zero,r2
80120bf0:	1000381e 	bne	r2,zero,80120cd4 <__subdf3+0x62c>
80120bf4:	3463c83a 	sub	r17,r6,r17
80120bf8:	28c5c83a 	sub	r2,r5,r3
80120bfc:	344d803a 	cmpltu	r6,r6,r17
80120c00:	1187c83a 	sub	r3,r2,r6
80120c04:	4821883a 	mov	r16,r9
80120c08:	3825883a 	mov	r18,r7
80120c0c:	003f0606 	br	80120828 <__reset+0xfa100828>
80120c10:	2023883a 	mov	r17,r4
80120c14:	003f0906 	br	8012083c <__reset+0xfa10083c>
80120c18:	0101ffc4 	movi	r4,2047
80120c1c:	813f3a1e 	bne	r16,r4,80120908 <__reset+0xfa100908>
80120c20:	003ec406 	br	80120734 <__reset+0xfa100734>
80120c24:	0005883a 	mov	r2,zero
80120c28:	003fb106 	br	80120af0 <__reset+0xfa100af0>
80120c2c:	0005883a 	mov	r2,zero
80120c30:	003fbc06 	br	80120b24 <__reset+0xfa100b24>
80120c34:	1c44b03a 	or	r2,r3,r17
80120c38:	80008e1e 	bne	r16,zero,80120e74 <__subdf3+0x7cc>
80120c3c:	1000c826 	beq	r2,zero,80120f60 <__subdf3+0x8b8>
80120c40:	2984b03a 	or	r2,r5,r6
80120c44:	103ebb26 	beq	r2,zero,80120734 <__reset+0xfa100734>
80120c48:	8989883a 	add	r4,r17,r6
80120c4c:	1945883a 	add	r2,r3,r5
80120c50:	2447803a 	cmpltu	r3,r4,r17
80120c54:	1887883a 	add	r3,r3,r2
80120c58:	1880202c 	andhi	r2,r3,128
80120c5c:	2023883a 	mov	r17,r4
80120c60:	103f1626 	beq	r2,zero,801208bc <__reset+0xfa1008bc>
80120c64:	00bfe034 	movhi	r2,65408
80120c68:	10bfffc4 	addi	r2,r2,-1
80120c6c:	5021883a 	mov	r16,r10
80120c70:	1886703a 	and	r3,r3,r2
80120c74:	003eaf06 	br	80120734 <__reset+0xfa100734>
80120c78:	3825883a 	mov	r18,r7
80120c7c:	003f0f06 	br	801208bc <__reset+0xfa1008bc>
80120c80:	1c44b03a 	or	r2,r3,r17
80120c84:	8000251e 	bne	r16,zero,80120d1c <__subdf3+0x674>
80120c88:	1000661e 	bne	r2,zero,80120e24 <__subdf3+0x77c>
80120c8c:	2990b03a 	or	r8,r5,r6
80120c90:	40009626 	beq	r8,zero,80120eec <__subdf3+0x844>
80120c94:	2807883a 	mov	r3,r5
80120c98:	3023883a 	mov	r17,r6
80120c9c:	3825883a 	mov	r18,r7
80120ca0:	003ea406 	br	80120734 <__reset+0xfa100734>
80120ca4:	127ff804 	addi	r9,r2,-32
80120ca8:	01000804 	movi	r4,32
80120cac:	2a52d83a 	srl	r9,r5,r9
80120cb0:	11008c26 	beq	r2,r4,80120ee4 <__subdf3+0x83c>
80120cb4:	01001004 	movi	r4,64
80120cb8:	2085c83a 	sub	r2,r4,r2
80120cbc:	2884983a 	sll	r2,r5,r2
80120cc0:	118cb03a 	or	r6,r2,r6
80120cc4:	300cc03a 	cmpne	r6,r6,zero
80120cc8:	4992b03a 	or	r9,r9,r6
80120ccc:	0005883a 	mov	r2,zero
80120cd0:	003f1206 	br	8012091c <__reset+0xfa10091c>
80120cd4:	0101ffc4 	movi	r4,2047
80120cd8:	493f9c1e 	bne	r9,r4,80120b4c <__reset+0xfa100b4c>
80120cdc:	2807883a 	mov	r3,r5
80120ce0:	3023883a 	mov	r17,r6
80120ce4:	4821883a 	mov	r16,r9
80120ce8:	3825883a 	mov	r18,r7
80120cec:	003e9106 	br	80120734 <__reset+0xfa100734>
80120cf0:	80001f1e 	bne	r16,zero,80120d70 <__subdf3+0x6c8>
80120cf4:	1c48b03a 	or	r4,r3,r17
80120cf8:	20005a26 	beq	r4,zero,80120e64 <__subdf3+0x7bc>
80120cfc:	0084303a 	nor	r2,zero,r2
80120d00:	1000561e 	bne	r2,zero,80120e5c <__subdf3+0x7b4>
80120d04:	89a3883a 	add	r17,r17,r6
80120d08:	1945883a 	add	r2,r3,r5
80120d0c:	898d803a 	cmpltu	r6,r17,r6
80120d10:	3087883a 	add	r3,r6,r2
80120d14:	4821883a 	mov	r16,r9
80120d18:	003f0506 	br	80120930 <__reset+0xfa100930>
80120d1c:	10002b1e 	bne	r2,zero,80120dcc <__subdf3+0x724>
80120d20:	2984b03a 	or	r2,r5,r6
80120d24:	10008026 	beq	r2,zero,80120f28 <__subdf3+0x880>
80120d28:	2807883a 	mov	r3,r5
80120d2c:	3023883a 	mov	r17,r6
80120d30:	3825883a 	mov	r18,r7
80120d34:	0401ffc4 	movi	r16,2047
80120d38:	003e7e06 	br	80120734 <__reset+0xfa100734>
80120d3c:	3809883a 	mov	r4,r7
80120d40:	0011883a 	mov	r8,zero
80120d44:	0005883a 	mov	r2,zero
80120d48:	003ee306 	br	801208d8 <__reset+0xfa1008d8>
80120d4c:	1c62b03a 	or	r17,r3,r17
80120d50:	8822c03a 	cmpne	r17,r17,zero
80120d54:	0005883a 	mov	r2,zero
80120d58:	003f8906 	br	80120b80 <__reset+0xfa100b80>
80120d5c:	3809883a 	mov	r4,r7
80120d60:	4821883a 	mov	r16,r9
80120d64:	0011883a 	mov	r8,zero
80120d68:	0005883a 	mov	r2,zero
80120d6c:	003eda06 	br	801208d8 <__reset+0xfa1008d8>
80120d70:	0101ffc4 	movi	r4,2047
80120d74:	49003b26 	beq	r9,r4,80120e64 <__subdf3+0x7bc>
80120d78:	0085c83a 	sub	r2,zero,r2
80120d7c:	18c02034 	orhi	r3,r3,128
80120d80:	01000e04 	movi	r4,56
80120d84:	20806e16 	blt	r4,r2,80120f40 <__subdf3+0x898>
80120d88:	010007c4 	movi	r4,31
80120d8c:	20807716 	blt	r4,r2,80120f6c <__subdf3+0x8c4>
80120d90:	01000804 	movi	r4,32
80120d94:	2089c83a 	sub	r4,r4,r2
80120d98:	1914983a 	sll	r10,r3,r4
80120d9c:	8890d83a 	srl	r8,r17,r2
80120da0:	8908983a 	sll	r4,r17,r4
80120da4:	1884d83a 	srl	r2,r3,r2
80120da8:	5222b03a 	or	r17,r10,r8
80120dac:	2006c03a 	cmpne	r3,r4,zero
80120db0:	88e2b03a 	or	r17,r17,r3
80120db4:	89a3883a 	add	r17,r17,r6
80120db8:	1145883a 	add	r2,r2,r5
80120dbc:	898d803a 	cmpltu	r6,r17,r6
80120dc0:	3087883a 	add	r3,r6,r2
80120dc4:	4821883a 	mov	r16,r9
80120dc8:	003ed906 	br	80120930 <__reset+0xfa100930>
80120dcc:	2984b03a 	or	r2,r5,r6
80120dd0:	10004226 	beq	r2,zero,80120edc <__subdf3+0x834>
80120dd4:	1808d0fa 	srli	r4,r3,3
80120dd8:	8822d0fa 	srli	r17,r17,3
80120ddc:	1806977a 	slli	r3,r3,29
80120de0:	2080022c 	andhi	r2,r4,8
80120de4:	1c62b03a 	or	r17,r3,r17
80120de8:	10000826 	beq	r2,zero,80120e0c <__subdf3+0x764>
80120dec:	2812d0fa 	srli	r9,r5,3
80120df0:	4880022c 	andhi	r2,r9,8
80120df4:	1000051e 	bne	r2,zero,80120e0c <__subdf3+0x764>
80120df8:	300cd0fa 	srli	r6,r6,3
80120dfc:	2804977a 	slli	r2,r5,29
80120e00:	4809883a 	mov	r4,r9
80120e04:	3825883a 	mov	r18,r7
80120e08:	11a2b03a 	or	r17,r2,r6
80120e0c:	8806d77a 	srli	r3,r17,29
80120e10:	200890fa 	slli	r4,r4,3
80120e14:	882290fa 	slli	r17,r17,3
80120e18:	0401ffc4 	movi	r16,2047
80120e1c:	1906b03a 	or	r3,r3,r4
80120e20:	003e4406 	br	80120734 <__reset+0xfa100734>
80120e24:	2984b03a 	or	r2,r5,r6
80120e28:	103e4226 	beq	r2,zero,80120734 <__reset+0xfa100734>
80120e2c:	8989c83a 	sub	r4,r17,r6
80120e30:	8911803a 	cmpltu	r8,r17,r4
80120e34:	1945c83a 	sub	r2,r3,r5
80120e38:	1205c83a 	sub	r2,r2,r8
80120e3c:	1200202c 	andhi	r8,r2,128
80120e40:	403e9a26 	beq	r8,zero,801208ac <__reset+0xfa1008ac>
80120e44:	3463c83a 	sub	r17,r6,r17
80120e48:	28c5c83a 	sub	r2,r5,r3
80120e4c:	344d803a 	cmpltu	r6,r6,r17
80120e50:	1187c83a 	sub	r3,r2,r6
80120e54:	3825883a 	mov	r18,r7
80120e58:	003e3606 	br	80120734 <__reset+0xfa100734>
80120e5c:	0101ffc4 	movi	r4,2047
80120e60:	493fc71e 	bne	r9,r4,80120d80 <__reset+0xfa100d80>
80120e64:	2807883a 	mov	r3,r5
80120e68:	3023883a 	mov	r17,r6
80120e6c:	4821883a 	mov	r16,r9
80120e70:	003e3006 	br	80120734 <__reset+0xfa100734>
80120e74:	10003626 	beq	r2,zero,80120f50 <__subdf3+0x8a8>
80120e78:	2984b03a 	or	r2,r5,r6
80120e7c:	10001726 	beq	r2,zero,80120edc <__subdf3+0x834>
80120e80:	1808d0fa 	srli	r4,r3,3
80120e84:	8822d0fa 	srli	r17,r17,3
80120e88:	1806977a 	slli	r3,r3,29
80120e8c:	2080022c 	andhi	r2,r4,8
80120e90:	1c62b03a 	or	r17,r3,r17
80120e94:	10000726 	beq	r2,zero,80120eb4 <__subdf3+0x80c>
80120e98:	2812d0fa 	srli	r9,r5,3
80120e9c:	4880022c 	andhi	r2,r9,8
80120ea0:	1000041e 	bne	r2,zero,80120eb4 <__subdf3+0x80c>
80120ea4:	300cd0fa 	srli	r6,r6,3
80120ea8:	2804977a 	slli	r2,r5,29
80120eac:	4809883a 	mov	r4,r9
80120eb0:	11a2b03a 	or	r17,r2,r6
80120eb4:	8806d77a 	srli	r3,r17,29
80120eb8:	200890fa 	slli	r4,r4,3
80120ebc:	882290fa 	slli	r17,r17,3
80120ec0:	3825883a 	mov	r18,r7
80120ec4:	1906b03a 	or	r3,r3,r4
80120ec8:	0401ffc4 	movi	r16,2047
80120ecc:	003e1906 	br	80120734 <__reset+0xfa100734>
80120ed0:	000b883a 	mov	r5,zero
80120ed4:	0005883a 	mov	r2,zero
80120ed8:	003e2e06 	br	80120794 <__reset+0xfa100794>
80120edc:	0401ffc4 	movi	r16,2047
80120ee0:	003e1406 	br	80120734 <__reset+0xfa100734>
80120ee4:	0005883a 	mov	r2,zero
80120ee8:	003f7506 	br	80120cc0 <__reset+0xfa100cc0>
80120eec:	0005883a 	mov	r2,zero
80120ef0:	0009883a 	mov	r4,zero
80120ef4:	003e7806 	br	801208d8 <__reset+0xfa1008d8>
80120ef8:	123ff804 	addi	r8,r2,-32
80120efc:	01000804 	movi	r4,32
80120f00:	1a10d83a 	srl	r8,r3,r8
80120f04:	11002526 	beq	r2,r4,80120f9c <__subdf3+0x8f4>
80120f08:	01001004 	movi	r4,64
80120f0c:	2085c83a 	sub	r2,r4,r2
80120f10:	1884983a 	sll	r2,r3,r2
80120f14:	1444b03a 	or	r2,r2,r17
80120f18:	1004c03a 	cmpne	r2,r2,zero
80120f1c:	40a2b03a 	or	r17,r8,r2
80120f20:	0005883a 	mov	r2,zero
80120f24:	003f1606 	br	80120b80 <__reset+0xfa100b80>
80120f28:	02000434 	movhi	r8,16
80120f2c:	0009883a 	mov	r4,zero
80120f30:	423fffc4 	addi	r8,r8,-1
80120f34:	00bfffc4 	movi	r2,-1
80120f38:	0401ffc4 	movi	r16,2047
80120f3c:	003e6606 	br	801208d8 <__reset+0xfa1008d8>
80120f40:	1c62b03a 	or	r17,r3,r17
80120f44:	8822c03a 	cmpne	r17,r17,zero
80120f48:	0005883a 	mov	r2,zero
80120f4c:	003f9906 	br	80120db4 <__reset+0xfa100db4>
80120f50:	2807883a 	mov	r3,r5
80120f54:	3023883a 	mov	r17,r6
80120f58:	0401ffc4 	movi	r16,2047
80120f5c:	003df506 	br	80120734 <__reset+0xfa100734>
80120f60:	2807883a 	mov	r3,r5
80120f64:	3023883a 	mov	r17,r6
80120f68:	003df206 	br	80120734 <__reset+0xfa100734>
80120f6c:	123ff804 	addi	r8,r2,-32
80120f70:	01000804 	movi	r4,32
80120f74:	1a10d83a 	srl	r8,r3,r8
80120f78:	11000a26 	beq	r2,r4,80120fa4 <__subdf3+0x8fc>
80120f7c:	01001004 	movi	r4,64
80120f80:	2085c83a 	sub	r2,r4,r2
80120f84:	1884983a 	sll	r2,r3,r2
80120f88:	1444b03a 	or	r2,r2,r17
80120f8c:	1004c03a 	cmpne	r2,r2,zero
80120f90:	40a2b03a 	or	r17,r8,r2
80120f94:	0005883a 	mov	r2,zero
80120f98:	003f8606 	br	80120db4 <__reset+0xfa100db4>
80120f9c:	0005883a 	mov	r2,zero
80120fa0:	003fdc06 	br	80120f14 <__reset+0xfa100f14>
80120fa4:	0005883a 	mov	r2,zero
80120fa8:	003ff706 	br	80120f88 <__reset+0xfa100f88>

80120fac <__fixdfsi>:
80120fac:	280cd53a 	srli	r6,r5,20
80120fb0:	00c00434 	movhi	r3,16
80120fb4:	18ffffc4 	addi	r3,r3,-1
80120fb8:	3181ffcc 	andi	r6,r6,2047
80120fbc:	01c0ff84 	movi	r7,1022
80120fc0:	28c6703a 	and	r3,r5,r3
80120fc4:	280ad7fa 	srli	r5,r5,31
80120fc8:	3980120e 	bge	r7,r6,80121014 <__fixdfsi+0x68>
80120fcc:	00810744 	movi	r2,1053
80120fd0:	11800c16 	blt	r2,r6,80121004 <__fixdfsi+0x58>
80120fd4:	00810cc4 	movi	r2,1075
80120fd8:	1185c83a 	sub	r2,r2,r6
80120fdc:	01c007c4 	movi	r7,31
80120fe0:	18c00434 	orhi	r3,r3,16
80120fe4:	38800d16 	blt	r7,r2,8012101c <__fixdfsi+0x70>
80120fe8:	31befb44 	addi	r6,r6,-1043
80120fec:	2084d83a 	srl	r2,r4,r2
80120ff0:	1986983a 	sll	r3,r3,r6
80120ff4:	1884b03a 	or	r2,r3,r2
80120ff8:	28000726 	beq	r5,zero,80121018 <__fixdfsi+0x6c>
80120ffc:	0085c83a 	sub	r2,zero,r2
80121000:	f800283a 	ret
80121004:	00a00034 	movhi	r2,32768
80121008:	10bfffc4 	addi	r2,r2,-1
8012100c:	2885883a 	add	r2,r5,r2
80121010:	f800283a 	ret
80121014:	0005883a 	mov	r2,zero
80121018:	f800283a 	ret
8012101c:	008104c4 	movi	r2,1043
80121020:	1185c83a 	sub	r2,r2,r6
80121024:	1884d83a 	srl	r2,r3,r2
80121028:	003ff306 	br	80120ff8 <__reset+0xfa100ff8>

8012102c <__floatsidf>:
8012102c:	defffd04 	addi	sp,sp,-12
80121030:	de00012e 	bgeu	sp,et,80121038 <__floatsidf+0xc>
80121034:	003b68fa 	trap	3
80121038:	dfc00215 	stw	ra,8(sp)
8012103c:	dc400115 	stw	r17,4(sp)
80121040:	dc000015 	stw	r16,0(sp)
80121044:	20002b26 	beq	r4,zero,801210f4 <__floatsidf+0xc8>
80121048:	2023883a 	mov	r17,r4
8012104c:	2020d7fa 	srli	r16,r4,31
80121050:	20002d16 	blt	r4,zero,80121108 <__floatsidf+0xdc>
80121054:	8809883a 	mov	r4,r17
80121058:	01213d00 	call	801213d0 <__clzsi2>
8012105c:	01410784 	movi	r5,1054
80121060:	288bc83a 	sub	r5,r5,r2
80121064:	01010cc4 	movi	r4,1075
80121068:	2149c83a 	sub	r4,r4,r5
8012106c:	00c007c4 	movi	r3,31
80121070:	1900160e 	bge	r3,r4,801210cc <__floatsidf+0xa0>
80121074:	00c104c4 	movi	r3,1043
80121078:	1947c83a 	sub	r3,r3,r5
8012107c:	88c6983a 	sll	r3,r17,r3
80121080:	00800434 	movhi	r2,16
80121084:	10bfffc4 	addi	r2,r2,-1
80121088:	1886703a 	and	r3,r3,r2
8012108c:	2941ffcc 	andi	r5,r5,2047
80121090:	800d883a 	mov	r6,r16
80121094:	0005883a 	mov	r2,zero
80121098:	280a953a 	slli	r5,r5,20
8012109c:	31803fcc 	andi	r6,r6,255
801210a0:	01000434 	movhi	r4,16
801210a4:	300c97fa 	slli	r6,r6,31
801210a8:	213fffc4 	addi	r4,r4,-1
801210ac:	1906703a 	and	r3,r3,r4
801210b0:	1946b03a 	or	r3,r3,r5
801210b4:	1986b03a 	or	r3,r3,r6
801210b8:	dfc00217 	ldw	ra,8(sp)
801210bc:	dc400117 	ldw	r17,4(sp)
801210c0:	dc000017 	ldw	r16,0(sp)
801210c4:	dec00304 	addi	sp,sp,12
801210c8:	f800283a 	ret
801210cc:	00c002c4 	movi	r3,11
801210d0:	1887c83a 	sub	r3,r3,r2
801210d4:	88c6d83a 	srl	r3,r17,r3
801210d8:	8904983a 	sll	r2,r17,r4
801210dc:	01000434 	movhi	r4,16
801210e0:	213fffc4 	addi	r4,r4,-1
801210e4:	2941ffcc 	andi	r5,r5,2047
801210e8:	1906703a 	and	r3,r3,r4
801210ec:	800d883a 	mov	r6,r16
801210f0:	003fe906 	br	80121098 <__reset+0xfa101098>
801210f4:	000d883a 	mov	r6,zero
801210f8:	000b883a 	mov	r5,zero
801210fc:	0007883a 	mov	r3,zero
80121100:	0005883a 	mov	r2,zero
80121104:	003fe406 	br	80121098 <__reset+0xfa101098>
80121108:	0123c83a 	sub	r17,zero,r4
8012110c:	003fd106 	br	80121054 <__reset+0xfa101054>

80121110 <__extendsfdf2>:
80121110:	200ad5fa 	srli	r5,r4,23
80121114:	defffd04 	addi	sp,sp,-12
80121118:	de00012e 	bgeu	sp,et,80121120 <__extendsfdf2+0x10>
8012111c:	003b68fa 	trap	3
80121120:	29403fcc 	andi	r5,r5,255
80121124:	dc400115 	stw	r17,4(sp)
80121128:	29800044 	addi	r6,r5,1
8012112c:	04402034 	movhi	r17,128
80121130:	dc000015 	stw	r16,0(sp)
80121134:	8c7fffc4 	addi	r17,r17,-1
80121138:	dfc00215 	stw	ra,8(sp)
8012113c:	31803fcc 	andi	r6,r6,255
80121140:	00800044 	movi	r2,1
80121144:	8922703a 	and	r17,r17,r4
80121148:	2020d7fa 	srli	r16,r4,31
8012114c:	1180110e 	bge	r2,r6,80121194 <__extendsfdf2+0x84>
80121150:	880cd0fa 	srli	r6,r17,3
80121154:	8822977a 	slli	r17,r17,29
80121158:	2940e004 	addi	r5,r5,896
8012115c:	2941ffcc 	andi	r5,r5,2047
80121160:	2804953a 	slli	r2,r5,20
80121164:	01400434 	movhi	r5,16
80121168:	800697fa 	slli	r3,r16,31
8012116c:	297fffc4 	addi	r5,r5,-1
80121170:	314a703a 	and	r5,r6,r5
80121174:	288ab03a 	or	r5,r5,r2
80121178:	28c6b03a 	or	r3,r5,r3
8012117c:	8805883a 	mov	r2,r17
80121180:	dfc00217 	ldw	ra,8(sp)
80121184:	dc400117 	ldw	r17,4(sp)
80121188:	dc000017 	ldw	r16,0(sp)
8012118c:	dec00304 	addi	sp,sp,12
80121190:	f800283a 	ret
80121194:	2800111e 	bne	r5,zero,801211dc <__extendsfdf2+0xcc>
80121198:	88001c26 	beq	r17,zero,8012120c <__extendsfdf2+0xfc>
8012119c:	8809883a 	mov	r4,r17
801211a0:	01213d00 	call	801213d0 <__clzsi2>
801211a4:	00c00284 	movi	r3,10
801211a8:	18801b16 	blt	r3,r2,80121218 <__extendsfdf2+0x108>
801211ac:	018002c4 	movi	r6,11
801211b0:	308dc83a 	sub	r6,r6,r2
801211b4:	11000544 	addi	r4,r2,21
801211b8:	8986d83a 	srl	r3,r17,r6
801211bc:	8922983a 	sll	r17,r17,r4
801211c0:	0180e244 	movi	r6,905
801211c4:	01400434 	movhi	r5,16
801211c8:	3085c83a 	sub	r2,r6,r2
801211cc:	297fffc4 	addi	r5,r5,-1
801211d0:	194c703a 	and	r6,r3,r5
801211d4:	1141ffcc 	andi	r5,r2,2047
801211d8:	003fe006 	br	8012115c <__reset+0xfa10115c>
801211dc:	88000826 	beq	r17,zero,80121200 <__extendsfdf2+0xf0>
801211e0:	880cd0fa 	srli	r6,r17,3
801211e4:	00800434 	movhi	r2,16
801211e8:	10bfffc4 	addi	r2,r2,-1
801211ec:	31800234 	orhi	r6,r6,8
801211f0:	8822977a 	slli	r17,r17,29
801211f4:	308c703a 	and	r6,r6,r2
801211f8:	0141ffc4 	movi	r5,2047
801211fc:	003fd706 	br	8012115c <__reset+0xfa10115c>
80121200:	0141ffc4 	movi	r5,2047
80121204:	000d883a 	mov	r6,zero
80121208:	003fd406 	br	8012115c <__reset+0xfa10115c>
8012120c:	000b883a 	mov	r5,zero
80121210:	000d883a 	mov	r6,zero
80121214:	003fd106 	br	8012115c <__reset+0xfa10115c>
80121218:	11bffd44 	addi	r6,r2,-11
8012121c:	8986983a 	sll	r3,r17,r6
80121220:	0023883a 	mov	r17,zero
80121224:	003fe606 	br	801211c0 <__reset+0xfa1011c0>

80121228 <__truncdfsf2>:
80121228:	2810d53a 	srli	r8,r5,20
8012122c:	01c00434 	movhi	r7,16
80121230:	39ffffc4 	addi	r7,r7,-1
80121234:	29ce703a 	and	r7,r5,r7
80121238:	4201ffcc 	andi	r8,r8,2047
8012123c:	380e90fa 	slli	r7,r7,3
80121240:	200cd77a 	srli	r6,r4,29
80121244:	42400044 	addi	r9,r8,1
80121248:	4a41ffcc 	andi	r9,r9,2047
8012124c:	00c00044 	movi	r3,1
80121250:	280ad7fa 	srli	r5,r5,31
80121254:	31ceb03a 	or	r7,r6,r7
80121258:	200490fa 	slli	r2,r4,3
8012125c:	1a40230e 	bge	r3,r9,801212ec <__truncdfsf2+0xc4>
80121260:	40ff2004 	addi	r3,r8,-896
80121264:	01803f84 	movi	r6,254
80121268:	30c01516 	blt	r6,r3,801212c0 <__truncdfsf2+0x98>
8012126c:	00c0380e 	bge	zero,r3,80121350 <__truncdfsf2+0x128>
80121270:	200c91ba 	slli	r6,r4,6
80121274:	380e90fa 	slli	r7,r7,3
80121278:	1004d77a 	srli	r2,r2,29
8012127c:	300cc03a 	cmpne	r6,r6,zero
80121280:	31ccb03a 	or	r6,r6,r7
80121284:	308cb03a 	or	r6,r6,r2
80121288:	308001cc 	andi	r2,r6,7
8012128c:	10000426 	beq	r2,zero,801212a0 <__truncdfsf2+0x78>
80121290:	308003cc 	andi	r2,r6,15
80121294:	01000104 	movi	r4,4
80121298:	11000126 	beq	r2,r4,801212a0 <__truncdfsf2+0x78>
8012129c:	31800104 	addi	r6,r6,4
801212a0:	3081002c 	andhi	r2,r6,1024
801212a4:	10001626 	beq	r2,zero,80121300 <__truncdfsf2+0xd8>
801212a8:	18c00044 	addi	r3,r3,1
801212ac:	00803fc4 	movi	r2,255
801212b0:	18800326 	beq	r3,r2,801212c0 <__truncdfsf2+0x98>
801212b4:	300c91ba 	slli	r6,r6,6
801212b8:	300cd27a 	srli	r6,r6,9
801212bc:	00000206 	br	801212c8 <__truncdfsf2+0xa0>
801212c0:	00ffffc4 	movi	r3,-1
801212c4:	000d883a 	mov	r6,zero
801212c8:	18c03fcc 	andi	r3,r3,255
801212cc:	180895fa 	slli	r4,r3,23
801212d0:	00c02034 	movhi	r3,128
801212d4:	280a97fa 	slli	r5,r5,31
801212d8:	18ffffc4 	addi	r3,r3,-1
801212dc:	30c6703a 	and	r3,r6,r3
801212e0:	1906b03a 	or	r3,r3,r4
801212e4:	1944b03a 	or	r2,r3,r5
801212e8:	f800283a 	ret
801212ec:	40000b1e 	bne	r8,zero,8012131c <__truncdfsf2+0xf4>
801212f0:	388cb03a 	or	r6,r7,r2
801212f4:	0007883a 	mov	r3,zero
801212f8:	30000426 	beq	r6,zero,8012130c <__truncdfsf2+0xe4>
801212fc:	01800144 	movi	r6,5
80121300:	00803fc4 	movi	r2,255
80121304:	300cd0fa 	srli	r6,r6,3
80121308:	18800a26 	beq	r3,r2,80121334 <__truncdfsf2+0x10c>
8012130c:	00802034 	movhi	r2,128
80121310:	10bfffc4 	addi	r2,r2,-1
80121314:	308c703a 	and	r6,r6,r2
80121318:	003feb06 	br	801212c8 <__reset+0xfa1012c8>
8012131c:	3888b03a 	or	r4,r7,r2
80121320:	203fe726 	beq	r4,zero,801212c0 <__reset+0xfa1012c0>
80121324:	380c90fa 	slli	r6,r7,3
80121328:	00c03fc4 	movi	r3,255
8012132c:	31808034 	orhi	r6,r6,512
80121330:	003fd506 	br	80121288 <__reset+0xfa101288>
80121334:	303fe226 	beq	r6,zero,801212c0 <__reset+0xfa1012c0>
80121338:	00802034 	movhi	r2,128
8012133c:	31801034 	orhi	r6,r6,64
80121340:	10bfffc4 	addi	r2,r2,-1
80121344:	00ffffc4 	movi	r3,-1
80121348:	308c703a 	and	r6,r6,r2
8012134c:	003fde06 	br	801212c8 <__reset+0xfa1012c8>
80121350:	013ffa44 	movi	r4,-23
80121354:	19000e16 	blt	r3,r4,80121390 <__truncdfsf2+0x168>
80121358:	01000784 	movi	r4,30
8012135c:	20c9c83a 	sub	r4,r4,r3
80121360:	018007c4 	movi	r6,31
80121364:	39c02034 	orhi	r7,r7,128
80121368:	31000b16 	blt	r6,r4,80121398 <__truncdfsf2+0x170>
8012136c:	423f2084 	addi	r8,r8,-894
80121370:	120c983a 	sll	r6,r2,r8
80121374:	3a0e983a 	sll	r7,r7,r8
80121378:	1104d83a 	srl	r2,r2,r4
8012137c:	300cc03a 	cmpne	r6,r6,zero
80121380:	31ceb03a 	or	r7,r6,r7
80121384:	388cb03a 	or	r6,r7,r2
80121388:	0007883a 	mov	r3,zero
8012138c:	003fbe06 	br	80121288 <__reset+0xfa101288>
80121390:	0007883a 	mov	r3,zero
80121394:	003fd906 	br	801212fc <__reset+0xfa1012fc>
80121398:	01bfff84 	movi	r6,-2
8012139c:	30cdc83a 	sub	r6,r6,r3
801213a0:	00c00804 	movi	r3,32
801213a4:	398cd83a 	srl	r6,r7,r6
801213a8:	20c00726 	beq	r4,r3,801213c8 <__truncdfsf2+0x1a0>
801213ac:	423f2884 	addi	r8,r8,-862
801213b0:	3a0e983a 	sll	r7,r7,r8
801213b4:	3884b03a 	or	r2,r7,r2
801213b8:	1004c03a 	cmpne	r2,r2,zero
801213bc:	118cb03a 	or	r6,r2,r6
801213c0:	0007883a 	mov	r3,zero
801213c4:	003fb006 	br	80121288 <__reset+0xfa101288>
801213c8:	000f883a 	mov	r7,zero
801213cc:	003ff906 	br	801213b4 <__reset+0xfa1013b4>

801213d0 <__clzsi2>:
801213d0:	00bfffd4 	movui	r2,65535
801213d4:	11000536 	bltu	r2,r4,801213ec <__clzsi2+0x1c>
801213d8:	00803fc4 	movi	r2,255
801213dc:	11000f36 	bltu	r2,r4,8012141c <__clzsi2+0x4c>
801213e0:	00800804 	movi	r2,32
801213e4:	0007883a 	mov	r3,zero
801213e8:	00000506 	br	80121400 <__clzsi2+0x30>
801213ec:	00804034 	movhi	r2,256
801213f0:	10bfffc4 	addi	r2,r2,-1
801213f4:	11000c2e 	bgeu	r2,r4,80121428 <__clzsi2+0x58>
801213f8:	00800204 	movi	r2,8
801213fc:	00c00604 	movi	r3,24
80121400:	20c8d83a 	srl	r4,r4,r3
80121404:	00e00534 	movhi	r3,32788
80121408:	18ddde84 	addi	r3,r3,30586
8012140c:	1909883a 	add	r4,r3,r4
80121410:	20c00003 	ldbu	r3,0(r4)
80121414:	10c5c83a 	sub	r2,r2,r3
80121418:	f800283a 	ret
8012141c:	00800604 	movi	r2,24
80121420:	00c00204 	movi	r3,8
80121424:	003ff606 	br	80121400 <__reset+0xfa101400>
80121428:	00800404 	movi	r2,16
8012142c:	1007883a 	mov	r3,r2
80121430:	003ff306 	br	80121400 <__reset+0xfa101400>

80121434 <atoi>:
80121434:	01800284 	movi	r6,10
80121438:	000b883a 	mov	r5,zero
8012143c:	0121c701 	jmpi	80121c70 <strtol>

80121440 <_atoi_r>:
80121440:	01c00284 	movi	r7,10
80121444:	000d883a 	mov	r6,zero
80121448:	0121a301 	jmpi	80121a30 <_strtol_r>

8012144c <atoll>:
8012144c:	01800284 	movi	r6,10
80121450:	000b883a 	mov	r5,zero
80121454:	0121c8c1 	jmpi	80121c8c <strtoll>

80121458 <_atoll_r>:
80121458:	01c00284 	movi	r7,10
8012145c:	000d883a 	mov	r6,zero
80121460:	0121ca81 	jmpi	80121ca8 <_strtoll_r>

80121464 <memcpy>:
80121464:	defffd04 	addi	sp,sp,-12
80121468:	de00012e 	bgeu	sp,et,80121470 <memcpy+0xc>
8012146c:	003b68fa 	trap	3
80121470:	00c003c4 	movi	r3,15
80121474:	dfc00215 	stw	ra,8(sp)
80121478:	dc400115 	stw	r17,4(sp)
8012147c:	dc000015 	stw	r16,0(sp)
80121480:	2005883a 	mov	r2,r4
80121484:	1980452e 	bgeu	r3,r6,8012159c <memcpy+0x138>
80121488:	2906b03a 	or	r3,r5,r4
8012148c:	18c000cc 	andi	r3,r3,3
80121490:	1800441e 	bne	r3,zero,801215a4 <memcpy+0x140>
80121494:	347ffc04 	addi	r17,r6,-16
80121498:	8822d13a 	srli	r17,r17,4
8012149c:	28c00104 	addi	r3,r5,4
801214a0:	23400104 	addi	r13,r4,4
801214a4:	8820913a 	slli	r16,r17,4
801214a8:	2b000204 	addi	r12,r5,8
801214ac:	22c00204 	addi	r11,r4,8
801214b0:	84000504 	addi	r16,r16,20
801214b4:	2a800304 	addi	r10,r5,12
801214b8:	22400304 	addi	r9,r4,12
801214bc:	2c21883a 	add	r16,r5,r16
801214c0:	2811883a 	mov	r8,r5
801214c4:	200f883a 	mov	r7,r4
801214c8:	41000017 	ldw	r4,0(r8)
801214cc:	1fc00017 	ldw	ra,0(r3)
801214d0:	63c00017 	ldw	r15,0(r12)
801214d4:	39000015 	stw	r4,0(r7)
801214d8:	53800017 	ldw	r14,0(r10)
801214dc:	6fc00015 	stw	ra,0(r13)
801214e0:	5bc00015 	stw	r15,0(r11)
801214e4:	4b800015 	stw	r14,0(r9)
801214e8:	18c00404 	addi	r3,r3,16
801214ec:	39c00404 	addi	r7,r7,16
801214f0:	42000404 	addi	r8,r8,16
801214f4:	6b400404 	addi	r13,r13,16
801214f8:	63000404 	addi	r12,r12,16
801214fc:	5ac00404 	addi	r11,r11,16
80121500:	52800404 	addi	r10,r10,16
80121504:	4a400404 	addi	r9,r9,16
80121508:	1c3fef1e 	bne	r3,r16,801214c8 <__reset+0xfa1014c8>
8012150c:	89c00044 	addi	r7,r17,1
80121510:	380e913a 	slli	r7,r7,4
80121514:	310003cc 	andi	r4,r6,15
80121518:	02c000c4 	movi	r11,3
8012151c:	11c7883a 	add	r3,r2,r7
80121520:	29cb883a 	add	r5,r5,r7
80121524:	5900212e 	bgeu	r11,r4,801215ac <memcpy+0x148>
80121528:	1813883a 	mov	r9,r3
8012152c:	2811883a 	mov	r8,r5
80121530:	200f883a 	mov	r7,r4
80121534:	42800017 	ldw	r10,0(r8)
80121538:	4a400104 	addi	r9,r9,4
8012153c:	39ffff04 	addi	r7,r7,-4
80121540:	4abfff15 	stw	r10,-4(r9)
80121544:	42000104 	addi	r8,r8,4
80121548:	59fffa36 	bltu	r11,r7,80121534 <__reset+0xfa101534>
8012154c:	213fff04 	addi	r4,r4,-4
80121550:	2008d0ba 	srli	r4,r4,2
80121554:	318000cc 	andi	r6,r6,3
80121558:	21000044 	addi	r4,r4,1
8012155c:	2109883a 	add	r4,r4,r4
80121560:	2109883a 	add	r4,r4,r4
80121564:	1907883a 	add	r3,r3,r4
80121568:	290b883a 	add	r5,r5,r4
8012156c:	30000626 	beq	r6,zero,80121588 <memcpy+0x124>
80121570:	198d883a 	add	r6,r3,r6
80121574:	29c00003 	ldbu	r7,0(r5)
80121578:	18c00044 	addi	r3,r3,1
8012157c:	29400044 	addi	r5,r5,1
80121580:	19ffffc5 	stb	r7,-1(r3)
80121584:	19bffb1e 	bne	r3,r6,80121574 <__reset+0xfa101574>
80121588:	dfc00217 	ldw	ra,8(sp)
8012158c:	dc400117 	ldw	r17,4(sp)
80121590:	dc000017 	ldw	r16,0(sp)
80121594:	dec00304 	addi	sp,sp,12
80121598:	f800283a 	ret
8012159c:	2007883a 	mov	r3,r4
801215a0:	003ff206 	br	8012156c <__reset+0xfa10156c>
801215a4:	2007883a 	mov	r3,r4
801215a8:	003ff106 	br	80121570 <__reset+0xfa101570>
801215ac:	200d883a 	mov	r6,r4
801215b0:	003fee06 	br	8012156c <__reset+0xfa10156c>

801215b4 <memset>:
801215b4:	20c000cc 	andi	r3,r4,3
801215b8:	2005883a 	mov	r2,r4
801215bc:	18004426 	beq	r3,zero,801216d0 <memset+0x11c>
801215c0:	31ffffc4 	addi	r7,r6,-1
801215c4:	30004026 	beq	r6,zero,801216c8 <memset+0x114>
801215c8:	2813883a 	mov	r9,r5
801215cc:	200d883a 	mov	r6,r4
801215d0:	2007883a 	mov	r3,r4
801215d4:	00000406 	br	801215e8 <memset+0x34>
801215d8:	3a3fffc4 	addi	r8,r7,-1
801215dc:	31800044 	addi	r6,r6,1
801215e0:	38003926 	beq	r7,zero,801216c8 <memset+0x114>
801215e4:	400f883a 	mov	r7,r8
801215e8:	18c00044 	addi	r3,r3,1
801215ec:	32400005 	stb	r9,0(r6)
801215f0:	1a0000cc 	andi	r8,r3,3
801215f4:	403ff81e 	bne	r8,zero,801215d8 <__reset+0xfa1015d8>
801215f8:	010000c4 	movi	r4,3
801215fc:	21c02d2e 	bgeu	r4,r7,801216b4 <memset+0x100>
80121600:	29003fcc 	andi	r4,r5,255
80121604:	200c923a 	slli	r6,r4,8
80121608:	3108b03a 	or	r4,r6,r4
8012160c:	200c943a 	slli	r6,r4,16
80121610:	218cb03a 	or	r6,r4,r6
80121614:	010003c4 	movi	r4,15
80121618:	21c0182e 	bgeu	r4,r7,8012167c <memset+0xc8>
8012161c:	3b3ffc04 	addi	r12,r7,-16
80121620:	6018d13a 	srli	r12,r12,4
80121624:	1a000104 	addi	r8,r3,4
80121628:	1ac00204 	addi	r11,r3,8
8012162c:	6008913a 	slli	r4,r12,4
80121630:	1a800304 	addi	r10,r3,12
80121634:	1813883a 	mov	r9,r3
80121638:	21000504 	addi	r4,r4,20
8012163c:	1909883a 	add	r4,r3,r4
80121640:	49800015 	stw	r6,0(r9)
80121644:	41800015 	stw	r6,0(r8)
80121648:	59800015 	stw	r6,0(r11)
8012164c:	51800015 	stw	r6,0(r10)
80121650:	42000404 	addi	r8,r8,16
80121654:	4a400404 	addi	r9,r9,16
80121658:	5ac00404 	addi	r11,r11,16
8012165c:	52800404 	addi	r10,r10,16
80121660:	413ff71e 	bne	r8,r4,80121640 <__reset+0xfa101640>
80121664:	63000044 	addi	r12,r12,1
80121668:	6018913a 	slli	r12,r12,4
8012166c:	39c003cc 	andi	r7,r7,15
80121670:	010000c4 	movi	r4,3
80121674:	1b07883a 	add	r3,r3,r12
80121678:	21c00e2e 	bgeu	r4,r7,801216b4 <memset+0x100>
8012167c:	1813883a 	mov	r9,r3
80121680:	3811883a 	mov	r8,r7
80121684:	010000c4 	movi	r4,3
80121688:	49800015 	stw	r6,0(r9)
8012168c:	423fff04 	addi	r8,r8,-4
80121690:	4a400104 	addi	r9,r9,4
80121694:	223ffc36 	bltu	r4,r8,80121688 <__reset+0xfa101688>
80121698:	393fff04 	addi	r4,r7,-4
8012169c:	2008d0ba 	srli	r4,r4,2
801216a0:	39c000cc 	andi	r7,r7,3
801216a4:	21000044 	addi	r4,r4,1
801216a8:	2109883a 	add	r4,r4,r4
801216ac:	2109883a 	add	r4,r4,r4
801216b0:	1907883a 	add	r3,r3,r4
801216b4:	38000526 	beq	r7,zero,801216cc <memset+0x118>
801216b8:	19cf883a 	add	r7,r3,r7
801216bc:	19400005 	stb	r5,0(r3)
801216c0:	18c00044 	addi	r3,r3,1
801216c4:	38fffd1e 	bne	r7,r3,801216bc <__reset+0xfa1016bc>
801216c8:	f800283a 	ret
801216cc:	f800283a 	ret
801216d0:	2007883a 	mov	r3,r4
801216d4:	300f883a 	mov	r7,r6
801216d8:	003fc706 	br	801215f8 <__reset+0xfa1015f8>

801216dc <_puts_r>:
801216dc:	defff604 	addi	sp,sp,-40
801216e0:	de00012e 	bgeu	sp,et,801216e8 <_puts_r+0xc>
801216e4:	003b68fa 	trap	3
801216e8:	dc000715 	stw	r16,28(sp)
801216ec:	2021883a 	mov	r16,r4
801216f0:	2809883a 	mov	r4,r5
801216f4:	dc400815 	stw	r17,32(sp)
801216f8:	dfc00915 	stw	ra,36(sp)
801216fc:	2823883a 	mov	r17,r5
80121700:	01219540 	call	80121954 <strlen>
80121704:	10c00044 	addi	r3,r2,1
80121708:	d8800115 	stw	r2,4(sp)
8012170c:	00a00534 	movhi	r2,32788
80121710:	109ebf04 	addi	r2,r2,31484
80121714:	d8800215 	stw	r2,8(sp)
80121718:	00800044 	movi	r2,1
8012171c:	d8800315 	stw	r2,12(sp)
80121720:	00800084 	movi	r2,2
80121724:	dc400015 	stw	r17,0(sp)
80121728:	d8c00615 	stw	r3,24(sp)
8012172c:	dec00415 	stw	sp,16(sp)
80121730:	d8800515 	stw	r2,20(sp)
80121734:	80000226 	beq	r16,zero,80121740 <_puts_r+0x64>
80121738:	80800e17 	ldw	r2,56(r16)
8012173c:	10001426 	beq	r2,zero,80121790 <_puts_r+0xb4>
80121740:	81400217 	ldw	r5,8(r16)
80121744:	2880030b 	ldhu	r2,12(r5)
80121748:	10c8000c 	andi	r3,r2,8192
8012174c:	1800061e 	bne	r3,zero,80121768 <_puts_r+0x8c>
80121750:	29001917 	ldw	r4,100(r5)
80121754:	00f7ffc4 	movi	r3,-8193
80121758:	10880014 	ori	r2,r2,8192
8012175c:	20c6703a 	and	r3,r4,r3
80121760:	2880030d 	sth	r2,12(r5)
80121764:	28c01915 	stw	r3,100(r5)
80121768:	d9800404 	addi	r6,sp,16
8012176c:	8009883a 	mov	r4,r16
80121770:	0127d180 	call	80127d18 <__sfvwrite_r>
80121774:	1000091e 	bne	r2,zero,8012179c <_puts_r+0xc0>
80121778:	00800284 	movi	r2,10
8012177c:	dfc00917 	ldw	ra,36(sp)
80121780:	dc400817 	ldw	r17,32(sp)
80121784:	dc000717 	ldw	r16,28(sp)
80121788:	dec00a04 	addi	sp,sp,40
8012178c:	f800283a 	ret
80121790:	8009883a 	mov	r4,r16
80121794:	01276140 	call	80127614 <__sinit>
80121798:	003fe906 	br	80121740 <__reset+0xfa101740>
8012179c:	00bfffc4 	movi	r2,-1
801217a0:	003ff606 	br	8012177c <__reset+0xfa10177c>

801217a4 <puts>:
801217a4:	00a00574 	movhi	r2,32789
801217a8:	10a88704 	addi	r2,r2,-24036
801217ac:	200b883a 	mov	r5,r4
801217b0:	11000017 	ldw	r4,0(r2)
801217b4:	01216dc1 	jmpi	801216dc <_puts_r>

801217b8 <scanf>:
801217b8:	defffc04 	addi	sp,sp,-16
801217bc:	de00012e 	bgeu	sp,et,801217c4 <scanf+0xc>
801217c0:	003b68fa 	trap	3
801217c4:	dfc00015 	stw	ra,0(sp)
801217c8:	d9400115 	stw	r5,4(sp)
801217cc:	d9800215 	stw	r6,8(sp)
801217d0:	d9c00315 	stw	r7,12(sp)
801217d4:	00a00574 	movhi	r2,32789
801217d8:	10a88704 	addi	r2,r2,-24036
801217dc:	200d883a 	mov	r6,r4
801217e0:	11000017 	ldw	r4,0(r2)
801217e4:	d9c00104 	addi	r7,sp,4
801217e8:	21400117 	ldw	r5,4(r4)
801217ec:	01259c00 	call	801259c0 <_vfscanf_r>
801217f0:	dfc00017 	ldw	ra,0(sp)
801217f4:	dec00404 	addi	sp,sp,16
801217f8:	f800283a 	ret

801217fc <_scanf_r>:
801217fc:	defffd04 	addi	sp,sp,-12
80121800:	2805883a 	mov	r2,r5
80121804:	de00012e 	bgeu	sp,et,8012180c <_scanf_r+0x10>
80121808:	003b68fa 	trap	3
8012180c:	dfc00015 	stw	ra,0(sp)
80121810:	d9800115 	stw	r6,4(sp)
80121814:	d9c00215 	stw	r7,8(sp)
80121818:	21400117 	ldw	r5,4(r4)
8012181c:	d9c00104 	addi	r7,sp,4
80121820:	100d883a 	mov	r6,r2
80121824:	01259c00 	call	801259c0 <_vfscanf_r>
80121828:	dfc00017 	ldw	ra,0(sp)
8012182c:	dec00304 	addi	sp,sp,12
80121830:	f800283a 	ret

80121834 <_sprintf_r>:
80121834:	deffe404 	addi	sp,sp,-112
80121838:	2807883a 	mov	r3,r5
8012183c:	de00012e 	bgeu	sp,et,80121844 <_sprintf_r+0x10>
80121840:	003b68fa 	trap	3
80121844:	dfc01a15 	stw	ra,104(sp)
80121848:	d9c01b15 	stw	r7,108(sp)
8012184c:	00a00034 	movhi	r2,32768
80121850:	10bfffc4 	addi	r2,r2,-1
80121854:	02008204 	movi	r8,520
80121858:	d8800215 	stw	r2,8(sp)
8012185c:	d8800515 	stw	r2,20(sp)
80121860:	d9c01b04 	addi	r7,sp,108
80121864:	d80b883a 	mov	r5,sp
80121868:	00bfffc4 	movi	r2,-1
8012186c:	d8c00015 	stw	r3,0(sp)
80121870:	d8c00415 	stw	r3,16(sp)
80121874:	da00030d 	sth	r8,12(sp)
80121878:	d880038d 	sth	r2,14(sp)
8012187c:	0121f900 	call	80121f90 <___svfprintf_internal_r>
80121880:	d8c00017 	ldw	r3,0(sp)
80121884:	18000005 	stb	zero,0(r3)
80121888:	dfc01a17 	ldw	ra,104(sp)
8012188c:	dec01c04 	addi	sp,sp,112
80121890:	f800283a 	ret

80121894 <sprintf>:
80121894:	deffe304 	addi	sp,sp,-116
80121898:	2007883a 	mov	r3,r4
8012189c:	de00012e 	bgeu	sp,et,801218a4 <sprintf+0x10>
801218a0:	003b68fa 	trap	3
801218a4:	dfc01a15 	stw	ra,104(sp)
801218a8:	d9801b15 	stw	r6,108(sp)
801218ac:	d9c01c15 	stw	r7,112(sp)
801218b0:	01200574 	movhi	r4,32789
801218b4:	21288704 	addi	r4,r4,-24036
801218b8:	21000017 	ldw	r4,0(r4)
801218bc:	00a00034 	movhi	r2,32768
801218c0:	10bfffc4 	addi	r2,r2,-1
801218c4:	280d883a 	mov	r6,r5
801218c8:	02008204 	movi	r8,520
801218cc:	d8800215 	stw	r2,8(sp)
801218d0:	d8800515 	stw	r2,20(sp)
801218d4:	d9c01b04 	addi	r7,sp,108
801218d8:	d80b883a 	mov	r5,sp
801218dc:	00bfffc4 	movi	r2,-1
801218e0:	d8c00015 	stw	r3,0(sp)
801218e4:	d8c00415 	stw	r3,16(sp)
801218e8:	da00030d 	sth	r8,12(sp)
801218ec:	d880038d 	sth	r2,14(sp)
801218f0:	0121f900 	call	80121f90 <___svfprintf_internal_r>
801218f4:	d8c00017 	ldw	r3,0(sp)
801218f8:	18000005 	stb	zero,0(r3)
801218fc:	dfc01a17 	ldw	ra,104(sp)
80121900:	dec01d04 	addi	sp,sp,116
80121904:	f800283a 	ret

80121908 <strcspn>:
80121908:	21c00007 	ldb	r7,0(r4)
8012190c:	38000f26 	beq	r7,zero,8012194c <strcspn+0x44>
80121910:	2a000007 	ldb	r8,0(r5)
80121914:	2005883a 	mov	r2,r4
80121918:	40000726 	beq	r8,zero,80121938 <strcspn+0x30>
8012191c:	3a000926 	beq	r7,r8,80121944 <strcspn+0x3c>
80121920:	2807883a 	mov	r3,r5
80121924:	00000106 	br	8012192c <strcspn+0x24>
80121928:	31c00626 	beq	r6,r7,80121944 <strcspn+0x3c>
8012192c:	18c00044 	addi	r3,r3,1
80121930:	19800007 	ldb	r6,0(r3)
80121934:	303ffc1e 	bne	r6,zero,80121928 <__reset+0xfa101928>
80121938:	10800044 	addi	r2,r2,1
8012193c:	11c00007 	ldb	r7,0(r2)
80121940:	383ff51e 	bne	r7,zero,80121918 <__reset+0xfa101918>
80121944:	1105c83a 	sub	r2,r2,r4
80121948:	f800283a 	ret
8012194c:	0005883a 	mov	r2,zero
80121950:	f800283a 	ret

80121954 <strlen>:
80121954:	208000cc 	andi	r2,r4,3
80121958:	10002026 	beq	r2,zero,801219dc <strlen+0x88>
8012195c:	20800007 	ldb	r2,0(r4)
80121960:	10002026 	beq	r2,zero,801219e4 <strlen+0x90>
80121964:	2005883a 	mov	r2,r4
80121968:	00000206 	br	80121974 <strlen+0x20>
8012196c:	10c00007 	ldb	r3,0(r2)
80121970:	18001826 	beq	r3,zero,801219d4 <strlen+0x80>
80121974:	10800044 	addi	r2,r2,1
80121978:	10c000cc 	andi	r3,r2,3
8012197c:	183ffb1e 	bne	r3,zero,8012196c <__reset+0xfa10196c>
80121980:	10c00017 	ldw	r3,0(r2)
80121984:	01ffbff4 	movhi	r7,65279
80121988:	39ffbfc4 	addi	r7,r7,-257
8012198c:	00ca303a 	nor	r5,zero,r3
80121990:	01a02074 	movhi	r6,32897
80121994:	19c7883a 	add	r3,r3,r7
80121998:	31a02004 	addi	r6,r6,-32640
8012199c:	1946703a 	and	r3,r3,r5
801219a0:	1986703a 	and	r3,r3,r6
801219a4:	1800091e 	bne	r3,zero,801219cc <strlen+0x78>
801219a8:	10800104 	addi	r2,r2,4
801219ac:	10c00017 	ldw	r3,0(r2)
801219b0:	19cb883a 	add	r5,r3,r7
801219b4:	00c6303a 	nor	r3,zero,r3
801219b8:	28c6703a 	and	r3,r5,r3
801219bc:	1986703a 	and	r3,r3,r6
801219c0:	183ff926 	beq	r3,zero,801219a8 <__reset+0xfa1019a8>
801219c4:	00000106 	br	801219cc <strlen+0x78>
801219c8:	10800044 	addi	r2,r2,1
801219cc:	10c00007 	ldb	r3,0(r2)
801219d0:	183ffd1e 	bne	r3,zero,801219c8 <__reset+0xfa1019c8>
801219d4:	1105c83a 	sub	r2,r2,r4
801219d8:	f800283a 	ret
801219dc:	2005883a 	mov	r2,r4
801219e0:	003fe706 	br	80121980 <__reset+0xfa101980>
801219e4:	0005883a 	mov	r2,zero
801219e8:	f800283a 	ret

801219ec <strnlen>:
801219ec:	28000e26 	beq	r5,zero,80121a28 <strnlen+0x3c>
801219f0:	20800007 	ldb	r2,0(r4)
801219f4:	10000c26 	beq	r2,zero,80121a28 <strnlen+0x3c>
801219f8:	20c00044 	addi	r3,r4,1
801219fc:	214b883a 	add	r5,r4,r5
80121a00:	28c00526 	beq	r5,r3,80121a18 <strnlen+0x2c>
80121a04:	19800007 	ldb	r6,0(r3)
80121a08:	19c00044 	addi	r7,r3,1
80121a0c:	30000426 	beq	r6,zero,80121a20 <strnlen+0x34>
80121a10:	3807883a 	mov	r3,r7
80121a14:	28fffb1e 	bne	r5,r3,80121a04 <__reset+0xfa101a04>
80121a18:	2905c83a 	sub	r2,r5,r4
80121a1c:	f800283a 	ret
80121a20:	1905c83a 	sub	r2,r3,r4
80121a24:	f800283a 	ret
80121a28:	0005883a 	mov	r2,zero
80121a2c:	f800283a 	ret

80121a30 <_strtol_r>:
80121a30:	00a00574 	movhi	r2,32789
80121a34:	defff404 	addi	sp,sp,-48
80121a38:	10a88504 	addi	r2,r2,-24044
80121a3c:	de00012e 	bgeu	sp,et,80121a44 <_strtol_r+0x14>
80121a40:	003b68fa 	trap	3
80121a44:	dd400715 	stw	r21,28(sp)
80121a48:	15400017 	ldw	r21,0(r2)
80121a4c:	dd800815 	stw	r22,32(sp)
80121a50:	dd000615 	stw	r20,24(sp)
80121a54:	dcc00515 	stw	r19,20(sp)
80121a58:	d9000015 	stw	r4,0(sp)
80121a5c:	dfc00b15 	stw	ra,44(sp)
80121a60:	df000a15 	stw	fp,40(sp)
80121a64:	ddc00915 	stw	r23,36(sp)
80121a68:	dc800415 	stw	r18,16(sp)
80121a6c:	dc400315 	stw	r17,12(sp)
80121a70:	dc000215 	stw	r16,8(sp)
80121a74:	2829883a 	mov	r20,r5
80121a78:	3027883a 	mov	r19,r6
80121a7c:	382d883a 	mov	r22,r7
80121a80:	2809883a 	mov	r4,r5
80121a84:	24000003 	ldbu	r16,0(r4)
80121a88:	24400044 	addi	r17,r4,1
80121a8c:	2007883a 	mov	r3,r4
80121a90:	ac05883a 	add	r2,r21,r16
80121a94:	10800043 	ldbu	r2,1(r2)
80121a98:	8809883a 	mov	r4,r17
80121a9c:	1080020c 	andi	r2,r2,8
80121aa0:	103ff81e 	bne	r2,zero,80121a84 <__reset+0xfa101a84>
80121aa4:	00800b44 	movi	r2,45
80121aa8:	80805826 	beq	r16,r2,80121c0c <_strtol_r+0x1dc>
80121aac:	00800ac4 	movi	r2,43
80121ab0:	80805a26 	beq	r16,r2,80121c1c <_strtol_r+0x1ec>
80121ab4:	0039883a 	mov	fp,zero
80121ab8:	b0004426 	beq	r22,zero,80121bcc <_strtol_r+0x19c>
80121abc:	00800404 	movi	r2,16
80121ac0:	b0806026 	beq	r22,r2,80121c44 <_strtol_r+0x214>
80121ac4:	b02f883a 	mov	r23,r22
80121ac8:	00a00034 	movhi	r2,32768
80121acc:	e025003a 	cmpeq	r18,fp,zero
80121ad0:	14a5c83a 	sub	r18,r2,r18
80121ad4:	b80b883a 	mov	r5,r23
80121ad8:	9009883a 	mov	r4,r18
80121adc:	01302cc0 	call	801302cc <__umodsi3>
80121ae0:	b80b883a 	mov	r5,r23
80121ae4:	9009883a 	mov	r4,r18
80121ae8:	d8800115 	stw	r2,4(sp)
80121aec:	01302680 	call	80130268 <__udivsi3>
80121af0:	ac07883a 	add	r3,r21,r16
80121af4:	18c00043 	ldbu	r3,1(r3)
80121af8:	880b883a 	mov	r5,r17
80121afc:	000d883a 	mov	r6,zero
80121b00:	1a00010c 	andi	r8,r3,4
80121b04:	0009883a 	mov	r4,zero
80121b08:	02800044 	movi	r10,1
80121b0c:	027fffc4 	movi	r9,-1
80121b10:	d9c00117 	ldw	r7,4(sp)
80121b14:	40000e26 	beq	r8,zero,80121b50 <_strtol_r+0x120>
80121b18:	843ff404 	addi	r16,r16,-48
80121b1c:	8580120e 	bge	r16,r22,80121b68 <_strtol_r+0x138>
80121b20:	32400526 	beq	r6,r9,80121b38 <_strtol_r+0x108>
80121b24:	11002536 	bltu	r2,r4,80121bbc <_strtol_r+0x18c>
80121b28:	20802326 	beq	r4,r2,80121bb8 <_strtol_r+0x188>
80121b2c:	25c9383a 	mul	r4,r4,r23
80121b30:	01800044 	movi	r6,1
80121b34:	8109883a 	add	r4,r16,r4
80121b38:	2c000003 	ldbu	r16,0(r5)
80121b3c:	29400044 	addi	r5,r5,1
80121b40:	ac07883a 	add	r3,r21,r16
80121b44:	18c00043 	ldbu	r3,1(r3)
80121b48:	1a00010c 	andi	r8,r3,4
80121b4c:	403ff21e 	bne	r8,zero,80121b18 <__reset+0xfa101b18>
80121b50:	18c000cc 	andi	r3,r3,3
80121b54:	18000426 	beq	r3,zero,80121b68 <_strtol_r+0x138>
80121b58:	1a801a26 	beq	r3,r10,80121bc4 <_strtol_r+0x194>
80121b5c:	00c015c4 	movi	r3,87
80121b60:	80e1c83a 	sub	r16,r16,r3
80121b64:	85bfee16 	blt	r16,r22,80121b20 <__reset+0xfa101b20>
80121b68:	00bfffc4 	movi	r2,-1
80121b6c:	30801e26 	beq	r6,r2,80121be8 <_strtol_r+0x1b8>
80121b70:	e0001b1e 	bne	fp,zero,80121be0 <_strtol_r+0x1b0>
80121b74:	2005883a 	mov	r2,r4
80121b78:	98000326 	beq	r19,zero,80121b88 <_strtol_r+0x158>
80121b7c:	3000211e 	bne	r6,zero,80121c04 <_strtol_r+0x1d4>
80121b80:	a00b883a 	mov	r5,r20
80121b84:	99400015 	stw	r5,0(r19)
80121b88:	dfc00b17 	ldw	ra,44(sp)
80121b8c:	df000a17 	ldw	fp,40(sp)
80121b90:	ddc00917 	ldw	r23,36(sp)
80121b94:	dd800817 	ldw	r22,32(sp)
80121b98:	dd400717 	ldw	r21,28(sp)
80121b9c:	dd000617 	ldw	r20,24(sp)
80121ba0:	dcc00517 	ldw	r19,20(sp)
80121ba4:	dc800417 	ldw	r18,16(sp)
80121ba8:	dc400317 	ldw	r17,12(sp)
80121bac:	dc000217 	ldw	r16,8(sp)
80121bb0:	dec00c04 	addi	sp,sp,48
80121bb4:	f800283a 	ret
80121bb8:	3c3fdc0e 	bge	r7,r16,80121b2c <__reset+0xfa101b2c>
80121bbc:	01bfffc4 	movi	r6,-1
80121bc0:	003fdd06 	br	80121b38 <__reset+0xfa101b38>
80121bc4:	00c00dc4 	movi	r3,55
80121bc8:	003fe506 	br	80121b60 <__reset+0xfa101b60>
80121bcc:	00800c04 	movi	r2,48
80121bd0:	80801626 	beq	r16,r2,80121c2c <_strtol_r+0x1fc>
80121bd4:	05800284 	movi	r22,10
80121bd8:	b02f883a 	mov	r23,r22
80121bdc:	003fba06 	br	80121ac8 <__reset+0xfa101ac8>
80121be0:	0109c83a 	sub	r4,zero,r4
80121be4:	003fe306 	br	80121b74 <__reset+0xfa101b74>
80121be8:	d9000017 	ldw	r4,0(sp)
80121bec:	00c00884 	movi	r3,34
80121bf0:	e005003a 	cmpeq	r2,fp,zero
80121bf4:	20c00015 	stw	r3,0(r4)
80121bf8:	00e00034 	movhi	r3,32768
80121bfc:	1885c83a 	sub	r2,r3,r2
80121c00:	983fe126 	beq	r19,zero,80121b88 <__reset+0xfa101b88>
80121c04:	297fffc4 	addi	r5,r5,-1
80121c08:	003fde06 	br	80121b84 <__reset+0xfa101b84>
80121c0c:	1c400084 	addi	r17,r3,2
80121c10:	1c000043 	ldbu	r16,1(r3)
80121c14:	07000044 	movi	fp,1
80121c18:	003fa706 	br	80121ab8 <__reset+0xfa101ab8>
80121c1c:	1c400084 	addi	r17,r3,2
80121c20:	1c000043 	ldbu	r16,1(r3)
80121c24:	0039883a 	mov	fp,zero
80121c28:	003fa306 	br	80121ab8 <__reset+0xfa101ab8>
80121c2c:	88800003 	ldbu	r2,0(r17)
80121c30:	00c01604 	movi	r3,88
80121c34:	108037cc 	andi	r2,r2,223
80121c38:	10c00826 	beq	r2,r3,80121c5c <_strtol_r+0x22c>
80121c3c:	05800204 	movi	r22,8
80121c40:	003fa006 	br	80121ac4 <__reset+0xfa101ac4>
80121c44:	00800c04 	movi	r2,48
80121c48:	80bf9e1e 	bne	r16,r2,80121ac4 <__reset+0xfa101ac4>
80121c4c:	88800003 	ldbu	r2,0(r17)
80121c50:	00c01604 	movi	r3,88
80121c54:	108037cc 	andi	r2,r2,223
80121c58:	10ff9a1e 	bne	r2,r3,80121ac4 <__reset+0xfa101ac4>
80121c5c:	05c00404 	movi	r23,16
80121c60:	8c000043 	ldbu	r16,1(r17)
80121c64:	b82d883a 	mov	r22,r23
80121c68:	8c400084 	addi	r17,r17,2
80121c6c:	003f9606 	br	80121ac8 <__reset+0xfa101ac8>

80121c70 <strtol>:
80121c70:	00a00574 	movhi	r2,32789
80121c74:	10a88704 	addi	r2,r2,-24036
80121c78:	300f883a 	mov	r7,r6
80121c7c:	280d883a 	mov	r6,r5
80121c80:	200b883a 	mov	r5,r4
80121c84:	11000017 	ldw	r4,0(r2)
80121c88:	0121a301 	jmpi	80121a30 <_strtol_r>

80121c8c <strtoll>:
80121c8c:	00a00574 	movhi	r2,32789
80121c90:	10a88704 	addi	r2,r2,-24036
80121c94:	300f883a 	mov	r7,r6
80121c98:	280d883a 	mov	r6,r5
80121c9c:	200b883a 	mov	r5,r4
80121ca0:	11000017 	ldw	r4,0(r2)
80121ca4:	0121ca81 	jmpi	80121ca8 <_strtoll_r>

80121ca8 <_strtoll_r>:
80121ca8:	00a00574 	movhi	r2,32789
80121cac:	defff304 	addi	sp,sp,-52
80121cb0:	10a88504 	addi	r2,r2,-24044
80121cb4:	de00012e 	bgeu	sp,et,80121cbc <_strtoll_r+0x14>
80121cb8:	003b68fa 	trap	3
80121cbc:	dc800515 	stw	r18,20(sp)
80121cc0:	14800017 	ldw	r18,0(r2)
80121cc4:	dd800915 	stw	r22,36(sp)
80121cc8:	dd400815 	stw	r21,32(sp)
80121ccc:	dcc00615 	stw	r19,24(sp)
80121cd0:	d9000015 	stw	r4,0(sp)
80121cd4:	dfc00c15 	stw	ra,48(sp)
80121cd8:	df000b15 	stw	fp,44(sp)
80121cdc:	ddc00a15 	stw	r23,40(sp)
80121ce0:	dd000715 	stw	r20,28(sp)
80121ce4:	dc400415 	stw	r17,16(sp)
80121ce8:	dc000315 	stw	r16,12(sp)
80121cec:	282d883a 	mov	r22,r5
80121cf0:	302b883a 	mov	r21,r6
80121cf4:	3827883a 	mov	r19,r7
80121cf8:	2809883a 	mov	r4,r5
80121cfc:	24000003 	ldbu	r16,0(r4)
80121d00:	24400044 	addi	r17,r4,1
80121d04:	2007883a 	mov	r3,r4
80121d08:	9405883a 	add	r2,r18,r16
80121d0c:	10800043 	ldbu	r2,1(r2)
80121d10:	8809883a 	mov	r4,r17
80121d14:	1080020c 	andi	r2,r2,8
80121d18:	103ff81e 	bne	r2,zero,80121cfc <__reset+0xfa101cfc>
80121d1c:	00800b44 	movi	r2,45
80121d20:	80807826 	beq	r16,r2,80121f04 <_strtoll_r+0x25c>
80121d24:	00800ac4 	movi	r2,43
80121d28:	80807a26 	beq	r16,r2,80121f14 <_strtoll_r+0x26c>
80121d2c:	0039883a 	mov	fp,zero
80121d30:	98004e26 	beq	r19,zero,80121e6c <_strtoll_r+0x1c4>
80121d34:	00800404 	movi	r2,16
80121d38:	98808226 	beq	r19,r2,80121f44 <_strtoll_r+0x29c>
80121d3c:	982fd7fa 	srai	r23,r19,31
80121d40:	9829883a 	mov	r20,r19
80121d44:	e0004f26 	beq	fp,zero,80121e84 <_strtoll_r+0x1dc>
80121d48:	0017883a 	mov	r11,zero
80121d4c:	02a00034 	movhi	r10,32768
80121d50:	5809883a 	mov	r4,r11
80121d54:	500b883a 	mov	r5,r10
80121d58:	a00d883a 	mov	r6,r20
80121d5c:	b80f883a 	mov	r7,r23
80121d60:	da800215 	stw	r10,8(sp)
80121d64:	dac00115 	stw	r11,4(sp)
80121d68:	012fc300 	call	8012fc30 <__umoddi3>
80121d6c:	dac00117 	ldw	r11,4(sp)
80121d70:	da800217 	ldw	r10,8(sp)
80121d74:	a00d883a 	mov	r6,r20
80121d78:	5809883a 	mov	r4,r11
80121d7c:	500b883a 	mov	r5,r10
80121d80:	b80f883a 	mov	r7,r23
80121d84:	d8800115 	stw	r2,4(sp)
80121d88:	012f6b00 	call	8012f6b0 <__udivdi3>
80121d8c:	9409883a 	add	r4,r18,r16
80121d90:	21000043 	ldbu	r4,1(r4)
80121d94:	1019883a 	mov	r12,r2
80121d98:	880b883a 	mov	r5,r17
80121d9c:	2240010c 	andi	r9,r4,4
80121da0:	0015883a 	mov	r10,zero
80121da4:	000d883a 	mov	r6,zero
80121da8:	000f883a 	mov	r7,zero
80121dac:	03400044 	movi	r13,1
80121db0:	02ffffc4 	movi	r11,-1
80121db4:	da000117 	ldw	r8,4(sp)
80121db8:	48000d26 	beq	r9,zero,80121df0 <_strtoll_r+0x148>
80121dbc:	843ff404 	addi	r16,r16,-48
80121dc0:	84c0110e 	bge	r16,r19,80121e08 <_strtoll_r+0x160>
80121dc4:	52c00426 	beq	r10,r11,80121dd8 <_strtoll_r+0x130>
80121dc8:	19c00236 	bltu	r3,r7,80121dd4 <_strtoll_r+0x12c>
80121dcc:	38c0311e 	bne	r7,r3,80121e94 <_strtoll_r+0x1ec>
80121dd0:	6180302e 	bgeu	r12,r6,80121e94 <_strtoll_r+0x1ec>
80121dd4:	02bfffc4 	movi	r10,-1
80121dd8:	2c000003 	ldbu	r16,0(r5)
80121ddc:	29400044 	addi	r5,r5,1
80121de0:	9409883a 	add	r4,r18,r16
80121de4:	21000043 	ldbu	r4,1(r4)
80121de8:	2240010c 	andi	r9,r4,4
80121dec:	483ff31e 	bne	r9,zero,80121dbc <__reset+0xfa101dbc>
80121df0:	210000cc 	andi	r4,r4,3
80121df4:	20000426 	beq	r4,zero,80121e08 <_strtoll_r+0x160>
80121df8:	23403426 	beq	r4,r13,80121ecc <_strtoll_r+0x224>
80121dfc:	008015c4 	movi	r2,87
80121e00:	80a1c83a 	sub	r16,r16,r2
80121e04:	84ffef16 	blt	r16,r19,80121dc4 <__reset+0xfa101dc4>
80121e08:	00bfffc4 	movi	r2,-1
80121e0c:	50803426 	beq	r10,r2,80121ee0 <_strtoll_r+0x238>
80121e10:	e0000426 	beq	fp,zero,80121e24 <_strtoll_r+0x17c>
80121e14:	018dc83a 	sub	r6,zero,r6
80121e18:	3004c03a 	cmpne	r2,r6,zero
80121e1c:	01e1c83a 	sub	r16,zero,r7
80121e20:	808fc83a 	sub	r7,r16,r2
80121e24:	3005883a 	mov	r2,r6
80121e28:	3807883a 	mov	r3,r7
80121e2c:	a8000326 	beq	r21,zero,80121e3c <_strtoll_r+0x194>
80121e30:	5000321e 	bne	r10,zero,80121efc <_strtoll_r+0x254>
80121e34:	b00b883a 	mov	r5,r22
80121e38:	a9400015 	stw	r5,0(r21)
80121e3c:	dfc00c17 	ldw	ra,48(sp)
80121e40:	df000b17 	ldw	fp,44(sp)
80121e44:	ddc00a17 	ldw	r23,40(sp)
80121e48:	dd800917 	ldw	r22,36(sp)
80121e4c:	dd400817 	ldw	r21,32(sp)
80121e50:	dd000717 	ldw	r20,28(sp)
80121e54:	dcc00617 	ldw	r19,24(sp)
80121e58:	dc800517 	ldw	r18,20(sp)
80121e5c:	dc400417 	ldw	r17,16(sp)
80121e60:	dc000317 	ldw	r16,12(sp)
80121e64:	dec00d04 	addi	sp,sp,52
80121e68:	f800283a 	ret
80121e6c:	00800c04 	movi	r2,48
80121e70:	80802c26 	beq	r16,r2,80121f24 <_strtoll_r+0x27c>
80121e74:	05000284 	movi	r20,10
80121e78:	002f883a 	mov	r23,zero
80121e7c:	a027883a 	mov	r19,r20
80121e80:	e03fb11e 	bne	fp,zero,80121d48 <__reset+0xfa101d48>
80121e84:	02a00034 	movhi	r10,32768
80121e88:	52bfffc4 	addi	r10,r10,-1
80121e8c:	02ffffc4 	movi	r11,-1
80121e90:	003faf06 	br	80121d50 <__reset+0xfa101d50>
80121e94:	33000f26 	beq	r6,r12,80121ed4 <_strtoll_r+0x22c>
80121e98:	b985383a 	mul	r2,r23,r6
80121e9c:	3d0f383a 	mul	r7,r7,r20
80121ea0:	3508383a 	mulxuu	r4,r6,r20
80121ea4:	350d383a 	mul	r6,r6,r20
80121ea8:	8013d7fa 	srai	r9,r16,31
80121eac:	388f883a 	add	r7,r7,r2
80121eb0:	818d883a 	add	r6,r16,r6
80121eb4:	390f883a 	add	r7,r7,r4
80121eb8:	3421803a 	cmpltu	r16,r6,r16
80121ebc:	49cf883a 	add	r7,r9,r7
80121ec0:	81cf883a 	add	r7,r16,r7
80121ec4:	02800044 	movi	r10,1
80121ec8:	003fc306 	br	80121dd8 <__reset+0xfa101dd8>
80121ecc:	00800dc4 	movi	r2,55
80121ed0:	003fcb06 	br	80121e00 <__reset+0xfa101e00>
80121ed4:	38fff01e 	bne	r7,r3,80121e98 <__reset+0xfa101e98>
80121ed8:	443fbe16 	blt	r8,r16,80121dd4 <__reset+0xfa101dd4>
80121edc:	003fee06 	br	80121e98 <__reset+0xfa101e98>
80121ee0:	e0002426 	beq	fp,zero,80121f74 <_strtoll_r+0x2cc>
80121ee4:	0005883a 	mov	r2,zero
80121ee8:	00e00034 	movhi	r3,32768
80121eec:	d9800017 	ldw	r6,0(sp)
80121ef0:	01000884 	movi	r4,34
80121ef4:	31000015 	stw	r4,0(r6)
80121ef8:	a83fd026 	beq	r21,zero,80121e3c <__reset+0xfa101e3c>
80121efc:	297fffc4 	addi	r5,r5,-1
80121f00:	003fcd06 	br	80121e38 <__reset+0xfa101e38>
80121f04:	1c400084 	addi	r17,r3,2
80121f08:	1c000043 	ldbu	r16,1(r3)
80121f0c:	07000044 	movi	fp,1
80121f10:	003f8706 	br	80121d30 <__reset+0xfa101d30>
80121f14:	1c400084 	addi	r17,r3,2
80121f18:	1c000043 	ldbu	r16,1(r3)
80121f1c:	0039883a 	mov	fp,zero
80121f20:	003f8306 	br	80121d30 <__reset+0xfa101d30>
80121f24:	88800003 	ldbu	r2,0(r17)
80121f28:	00c01604 	movi	r3,88
80121f2c:	108037cc 	andi	r2,r2,223
80121f30:	10c00a26 	beq	r2,r3,80121f5c <_strtoll_r+0x2b4>
80121f34:	05000204 	movi	r20,8
80121f38:	002f883a 	mov	r23,zero
80121f3c:	a027883a 	mov	r19,r20
80121f40:	003f8006 	br	80121d44 <__reset+0xfa101d44>
80121f44:	00800c04 	movi	r2,48
80121f48:	80800e1e 	bne	r16,r2,80121f84 <_strtoll_r+0x2dc>
80121f4c:	88800003 	ldbu	r2,0(r17)
80121f50:	00c01604 	movi	r3,88
80121f54:	108037cc 	andi	r2,r2,223
80121f58:	10c00a1e 	bne	r2,r3,80121f84 <_strtoll_r+0x2dc>
80121f5c:	05000404 	movi	r20,16
80121f60:	8c000043 	ldbu	r16,1(r17)
80121f64:	002f883a 	mov	r23,zero
80121f68:	8c400084 	addi	r17,r17,2
80121f6c:	a027883a 	mov	r19,r20
80121f70:	003f7406 	br	80121d44 <__reset+0xfa101d44>
80121f74:	00e00034 	movhi	r3,32768
80121f78:	18ffffc4 	addi	r3,r3,-1
80121f7c:	5005883a 	mov	r2,r10
80121f80:	003fda06 	br	80121eec <__reset+0xfa101eec>
80121f84:	9829883a 	mov	r20,r19
80121f88:	002f883a 	mov	r23,zero
80121f8c:	003f6d06 	br	80121d44 <__reset+0xfa101d44>

80121f90 <___svfprintf_internal_r>:
80121f90:	deffb704 	addi	sp,sp,-292
80121f94:	de00012e 	bgeu	sp,et,80121f9c <___svfprintf_internal_r+0xc>
80121f98:	003b68fa 	trap	3
80121f9c:	dfc04815 	stw	ra,288(sp)
80121fa0:	ddc04615 	stw	r23,280(sp)
80121fa4:	d9402c15 	stw	r5,176(sp)
80121fa8:	d9003915 	stw	r4,228(sp)
80121fac:	302f883a 	mov	r23,r6
80121fb0:	d9c02d15 	stw	r7,180(sp)
80121fb4:	df004715 	stw	fp,284(sp)
80121fb8:	dd804515 	stw	r22,276(sp)
80121fbc:	dd404415 	stw	r21,272(sp)
80121fc0:	dd004315 	stw	r20,268(sp)
80121fc4:	dcc04215 	stw	r19,264(sp)
80121fc8:	dc804115 	stw	r18,260(sp)
80121fcc:	dc404015 	stw	r17,256(sp)
80121fd0:	dc003f15 	stw	r16,252(sp)
80121fd4:	01284580 	call	80128458 <_localeconv_r>
80121fd8:	10800017 	ldw	r2,0(r2)
80121fdc:	1009883a 	mov	r4,r2
80121fe0:	d8803415 	stw	r2,208(sp)
80121fe4:	01219540 	call	80121954 <strlen>
80121fe8:	d8c02c17 	ldw	r3,176(sp)
80121fec:	d8803815 	stw	r2,224(sp)
80121ff0:	1880030b 	ldhu	r2,12(r3)
80121ff4:	1080200c 	andi	r2,r2,128
80121ff8:	10000226 	beq	r2,zero,80122004 <___svfprintf_internal_r+0x74>
80121ffc:	18800417 	ldw	r2,16(r3)
80122000:	10067f26 	beq	r2,zero,80123a00 <___svfprintf_internal_r+0x1a70>
80122004:	dcc03917 	ldw	r19,228(sp)
80122008:	d8c00404 	addi	r3,sp,16
8012200c:	05600534 	movhi	r21,32788
80122010:	d9001e04 	addi	r4,sp,120
80122014:	ad5ed084 	addi	r21,r21,31554
80122018:	d8c01e15 	stw	r3,120(sp)
8012201c:	d8002015 	stw	zero,128(sp)
80122020:	d8001f15 	stw	zero,124(sp)
80122024:	d8003315 	stw	zero,204(sp)
80122028:	d8003615 	stw	zero,216(sp)
8012202c:	d8003715 	stw	zero,220(sp)
80122030:	1811883a 	mov	r8,r3
80122034:	d8003a15 	stw	zero,232(sp)
80122038:	d8003b15 	stw	zero,236(sp)
8012203c:	d8002f15 	stw	zero,188(sp)
80122040:	d9002815 	stw	r4,160(sp)
80122044:	b8800007 	ldb	r2,0(r23)
80122048:	10026726 	beq	r2,zero,801229e8 <___svfprintf_internal_r+0xa58>
8012204c:	00c00944 	movi	r3,37
80122050:	b821883a 	mov	r16,r23
80122054:	10c0021e 	bne	r2,r3,80122060 <___svfprintf_internal_r+0xd0>
80122058:	00001406 	br	801220ac <___svfprintf_internal_r+0x11c>
8012205c:	10c00326 	beq	r2,r3,8012206c <___svfprintf_internal_r+0xdc>
80122060:	84000044 	addi	r16,r16,1
80122064:	80800007 	ldb	r2,0(r16)
80122068:	103ffc1e 	bne	r2,zero,8012205c <__reset+0xfa10205c>
8012206c:	85e3c83a 	sub	r17,r16,r23
80122070:	88000e26 	beq	r17,zero,801220ac <___svfprintf_internal_r+0x11c>
80122074:	d8c02017 	ldw	r3,128(sp)
80122078:	d8801f17 	ldw	r2,124(sp)
8012207c:	45c00015 	stw	r23,0(r8)
80122080:	1c47883a 	add	r3,r3,r17
80122084:	10800044 	addi	r2,r2,1
80122088:	d8c02015 	stw	r3,128(sp)
8012208c:	44400115 	stw	r17,4(r8)
80122090:	d8801f15 	stw	r2,124(sp)
80122094:	00c001c4 	movi	r3,7
80122098:	18809716 	blt	r3,r2,801222f8 <___svfprintf_internal_r+0x368>
8012209c:	42000204 	addi	r8,r8,8
801220a0:	d9402f17 	ldw	r5,188(sp)
801220a4:	2c4b883a 	add	r5,r5,r17
801220a8:	d9402f15 	stw	r5,188(sp)
801220ac:	80800007 	ldb	r2,0(r16)
801220b0:	10009826 	beq	r2,zero,80122314 <___svfprintf_internal_r+0x384>
801220b4:	84400047 	ldb	r17,1(r16)
801220b8:	00bfffc4 	movi	r2,-1
801220bc:	85c00044 	addi	r23,r16,1
801220c0:	d8002785 	stb	zero,158(sp)
801220c4:	0007883a 	mov	r3,zero
801220c8:	000f883a 	mov	r7,zero
801220cc:	d8802915 	stw	r2,164(sp)
801220d0:	d8003115 	stw	zero,196(sp)
801220d4:	0025883a 	mov	r18,zero
801220d8:	01401604 	movi	r5,88
801220dc:	01800244 	movi	r6,9
801220e0:	02800a84 	movi	r10,42
801220e4:	02401b04 	movi	r9,108
801220e8:	bdc00044 	addi	r23,r23,1
801220ec:	88bff804 	addi	r2,r17,-32
801220f0:	2882f036 	bltu	r5,r2,80122cb4 <___svfprintf_internal_r+0xd24>
801220f4:	100490ba 	slli	r2,r2,2
801220f8:	012004b4 	movhi	r4,32786
801220fc:	21084304 	addi	r4,r4,8460
80122100:	1105883a 	add	r2,r2,r4
80122104:	10800017 	ldw	r2,0(r2)
80122108:	1000683a 	jmp	r2
8012210c:	80122c1c 	xori	zero,r16,18608
80122110:	80122cb4 	orhi	zero,r16,18610
80122114:	80122cb4 	orhi	zero,r16,18610
80122118:	80122c10 	cmplti	zero,r16,18608
8012211c:	80122cb4 	orhi	zero,r16,18610
80122120:	80122cb4 	orhi	zero,r16,18610
80122124:	80122cb4 	orhi	zero,r16,18610
80122128:	80122cb4 	orhi	zero,r16,18610
8012212c:	80122cb4 	orhi	zero,r16,18610
80122130:	80122cb4 	orhi	zero,r16,18610
80122134:	80122370 	cmpltui	zero,r16,18573
80122138:	80122b4c 	andi	zero,r16,18605
8012213c:	80122cb4 	orhi	zero,r16,18610
80122140:	80122280 	call	88012228 <__reset+0x1ff2228>
80122144:	80122398 	cmpnei	zero,r16,18574
80122148:	80122cb4 	orhi	zero,r16,18610
8012214c:	8012240c 	andi	zero,r16,18576
80122150:	801223d8 	cmpnei	zero,r16,18575
80122154:	801223d8 	cmpnei	zero,r16,18575
80122158:	801223d8 	cmpnei	zero,r16,18575
8012215c:	801223d8 	cmpnei	zero,r16,18575
80122160:	801223d8 	cmpnei	zero,r16,18575
80122164:	801223d8 	cmpnei	zero,r16,18575
80122168:	801223d8 	cmpnei	zero,r16,18575
8012216c:	801223d8 	cmpnei	zero,r16,18575
80122170:	801223d8 	cmpnei	zero,r16,18575
80122174:	80122cb4 	orhi	zero,r16,18610
80122178:	80122cb4 	orhi	zero,r16,18610
8012217c:	80122cb4 	orhi	zero,r16,18610
80122180:	80122cb4 	orhi	zero,r16,18610
80122184:	80122cb4 	orhi	zero,r16,18610
80122188:	80122cb4 	orhi	zero,r16,18610
8012218c:	80122cb4 	orhi	zero,r16,18610
80122190:	80122cb4 	orhi	zero,r16,18610
80122194:	80122cb4 	orhi	zero,r16,18610
80122198:	80122cb4 	orhi	zero,r16,18610
8012219c:	801224c4 	addi	zero,r16,18579
801221a0:	80122418 	cmpnei	zero,r16,18576
801221a4:	80122cb4 	orhi	zero,r16,18610
801221a8:	80122418 	cmpnei	zero,r16,18576
801221ac:	80122cb4 	orhi	zero,r16,18610
801221b0:	80122cb4 	orhi	zero,r16,18610
801221b4:	80122cb4 	orhi	zero,r16,18610
801221b8:	80122cb4 	orhi	zero,r16,18610
801221bc:	801224b8 	rdprs	zero,r16,18578
801221c0:	80122cb4 	orhi	zero,r16,18610
801221c4:	80122cb4 	orhi	zero,r16,18610
801221c8:	80122580 	call	88012258 <__reset+0x1ff2258>
801221cc:	80122cb4 	orhi	zero,r16,18610
801221d0:	80122cb4 	orhi	zero,r16,18610
801221d4:	80122cb4 	orhi	zero,r16,18610
801221d8:	80122cb4 	orhi	zero,r16,18610
801221dc:	80122cb4 	orhi	zero,r16,18610
801221e0:	801229f0 	cmpltui	zero,r16,18599
801221e4:	80122cb4 	orhi	zero,r16,18610
801221e8:	80122cb4 	orhi	zero,r16,18610
801221ec:	80122a50 	cmplti	zero,r16,18601
801221f0:	80122cb4 	orhi	zero,r16,18610
801221f4:	80122cb4 	orhi	zero,r16,18610
801221f8:	80122cb4 	orhi	zero,r16,18610
801221fc:	80122cb4 	orhi	zero,r16,18610
80122200:	80122cb4 	orhi	zero,r16,18610
80122204:	80122cb4 	orhi	zero,r16,18610
80122208:	80122cb4 	orhi	zero,r16,18610
8012220c:	80122cb4 	orhi	zero,r16,18610
80122210:	80122cb4 	orhi	zero,r16,18610
80122214:	80122cb4 	orhi	zero,r16,18610
80122218:	80122b00 	call	880122b0 <__reset+0x1ff22b0>
8012221c:	80122c3c 	xorhi	zero,r16,18608
80122220:	80122418 	cmpnei	zero,r16,18576
80122224:	80122418 	cmpnei	zero,r16,18576
80122228:	80122418 	cmpnei	zero,r16,18576
8012222c:	80122c90 	cmplti	zero,r16,18610
80122230:	80122c3c 	xorhi	zero,r16,18608
80122234:	80122cb4 	orhi	zero,r16,18610
80122238:	80122cb4 	orhi	zero,r16,18610
8012223c:	80122c4c 	andi	zero,r16,18609
80122240:	80122cb4 	orhi	zero,r16,18610
80122244:	80122c5c 	xori	zero,r16,18609
80122248:	80122b3c 	xorhi	zero,r16,18604
8012224c:	8012228c 	andi	zero,r16,18570
80122250:	80122b5c 	xori	zero,r16,18605
80122254:	80122cb4 	orhi	zero,r16,18610
80122258:	80122b68 	cmpgeui	zero,r16,18605
8012225c:	80122cb4 	orhi	zero,r16,18610
80122260:	80122bc4 	addi	zero,r16,18607
80122264:	80122cb4 	orhi	zero,r16,18610
80122268:	80122cb4 	orhi	zero,r16,18610
8012226c:	80122bd4 	ori	zero,r16,18607
80122270:	d9003117 	ldw	r4,196(sp)
80122274:	d8802d15 	stw	r2,180(sp)
80122278:	0109c83a 	sub	r4,zero,r4
8012227c:	d9003115 	stw	r4,196(sp)
80122280:	94800114 	ori	r18,r18,4
80122284:	bc400007 	ldb	r17,0(r23)
80122288:	003f9706 	br	801220e8 <__reset+0xfa1020e8>
8012228c:	00800c04 	movi	r2,48
80122290:	d9002d17 	ldw	r4,180(sp)
80122294:	d9402917 	ldw	r5,164(sp)
80122298:	d8802705 	stb	r2,156(sp)
8012229c:	00801e04 	movi	r2,120
801222a0:	d8802745 	stb	r2,157(sp)
801222a4:	d8002785 	stb	zero,158(sp)
801222a8:	20c00104 	addi	r3,r4,4
801222ac:	25000017 	ldw	r20,0(r4)
801222b0:	002d883a 	mov	r22,zero
801222b4:	90800094 	ori	r2,r18,2
801222b8:	28028616 	blt	r5,zero,80122cd4 <___svfprintf_internal_r+0xd44>
801222bc:	00bfdfc4 	movi	r2,-129
801222c0:	90a4703a 	and	r18,r18,r2
801222c4:	d8c02d15 	stw	r3,180(sp)
801222c8:	94800094 	ori	r18,r18,2
801222cc:	a002731e 	bne	r20,zero,80122c9c <___svfprintf_internal_r+0xd0c>
801222d0:	00a00534 	movhi	r2,32788
801222d4:	109ec904 	addi	r2,r2,31524
801222d8:	d8803a15 	stw	r2,232(sp)
801222dc:	04401e04 	movi	r17,120
801222e0:	d8c02917 	ldw	r3,164(sp)
801222e4:	0039883a 	mov	fp,zero
801222e8:	1801d526 	beq	r3,zero,80122a40 <___svfprintf_internal_r+0xab0>
801222ec:	0029883a 	mov	r20,zero
801222f0:	002d883a 	mov	r22,zero
801222f4:	0001f106 	br	80122abc <___svfprintf_internal_r+0xb2c>
801222f8:	d9402c17 	ldw	r5,176(sp)
801222fc:	d9801e04 	addi	r6,sp,120
80122300:	9809883a 	mov	r4,r19
80122304:	012c9940 	call	8012c994 <__ssprint_r>
80122308:	1000081e 	bne	r2,zero,8012232c <___svfprintf_internal_r+0x39c>
8012230c:	da000404 	addi	r8,sp,16
80122310:	003f6306 	br	801220a0 <__reset+0xfa1020a0>
80122314:	d8802017 	ldw	r2,128(sp)
80122318:	10000426 	beq	r2,zero,8012232c <___svfprintf_internal_r+0x39c>
8012231c:	d9402c17 	ldw	r5,176(sp)
80122320:	d9003917 	ldw	r4,228(sp)
80122324:	d9801e04 	addi	r6,sp,120
80122328:	012c9940 	call	8012c994 <__ssprint_r>
8012232c:	d8802c17 	ldw	r2,176(sp)
80122330:	10c0030b 	ldhu	r3,12(r2)
80122334:	d8802f17 	ldw	r2,188(sp)
80122338:	18c0100c 	andi	r3,r3,64
8012233c:	1805f51e 	bne	r3,zero,80123b14 <___svfprintf_internal_r+0x1b84>
80122340:	dfc04817 	ldw	ra,288(sp)
80122344:	df004717 	ldw	fp,284(sp)
80122348:	ddc04617 	ldw	r23,280(sp)
8012234c:	dd804517 	ldw	r22,276(sp)
80122350:	dd404417 	ldw	r21,272(sp)
80122354:	dd004317 	ldw	r20,268(sp)
80122358:	dcc04217 	ldw	r19,264(sp)
8012235c:	dc804117 	ldw	r18,260(sp)
80122360:	dc404017 	ldw	r17,256(sp)
80122364:	dc003f17 	ldw	r16,252(sp)
80122368:	dec04904 	addi	sp,sp,292
8012236c:	f800283a 	ret
80122370:	d8802d17 	ldw	r2,180(sp)
80122374:	d9002d17 	ldw	r4,180(sp)
80122378:	10800017 	ldw	r2,0(r2)
8012237c:	d8803115 	stw	r2,196(sp)
80122380:	20800104 	addi	r2,r4,4
80122384:	d9003117 	ldw	r4,196(sp)
80122388:	203fb916 	blt	r4,zero,80122270 <__reset+0xfa102270>
8012238c:	d8802d15 	stw	r2,180(sp)
80122390:	bc400007 	ldb	r17,0(r23)
80122394:	003f5406 	br	801220e8 <__reset+0xfa1020e8>
80122398:	bc400007 	ldb	r17,0(r23)
8012239c:	bac00044 	addi	r11,r23,1
801223a0:	8a873926 	beq	r17,r10,80124088 <___svfprintf_internal_r+0x20f8>
801223a4:	88bff404 	addi	r2,r17,-48
801223a8:	0009883a 	mov	r4,zero
801223ac:	30868836 	bltu	r6,r2,80123dd0 <___svfprintf_internal_r+0x1e40>
801223b0:	5c400007 	ldb	r17,0(r11)
801223b4:	210002a4 	muli	r4,r4,10
801223b8:	5dc00044 	addi	r23,r11,1
801223bc:	b817883a 	mov	r11,r23
801223c0:	2089883a 	add	r4,r4,r2
801223c4:	88bff404 	addi	r2,r17,-48
801223c8:	30bff92e 	bgeu	r6,r2,801223b0 <__reset+0xfa1023b0>
801223cc:	2005d716 	blt	r4,zero,80123b2c <___svfprintf_internal_r+0x1b9c>
801223d0:	d9002915 	stw	r4,164(sp)
801223d4:	003f4506 	br	801220ec <__reset+0xfa1020ec>
801223d8:	b809883a 	mov	r4,r23
801223dc:	d8003115 	stw	zero,196(sp)
801223e0:	88bff404 	addi	r2,r17,-48
801223e4:	0017883a 	mov	r11,zero
801223e8:	24400007 	ldb	r17,0(r4)
801223ec:	5ac002a4 	muli	r11,r11,10
801223f0:	bdc00044 	addi	r23,r23,1
801223f4:	b809883a 	mov	r4,r23
801223f8:	12d7883a 	add	r11,r2,r11
801223fc:	88bff404 	addi	r2,r17,-48
80122400:	30bff92e 	bgeu	r6,r2,801223e8 <__reset+0xfa1023e8>
80122404:	dac03115 	stw	r11,196(sp)
80122408:	003f3806 	br	801220ec <__reset+0xfa1020ec>
8012240c:	94802014 	ori	r18,r18,128
80122410:	bc400007 	ldb	r17,0(r23)
80122414:	003f3406 	br	801220e8 <__reset+0xfa1020e8>
80122418:	18c03fcc 	andi	r3,r3,255
8012241c:	1807471e 	bne	r3,zero,8012413c <___svfprintf_internal_r+0x21ac>
80122420:	9080020c 	andi	r2,r18,8
80122424:	10047d26 	beq	r2,zero,8012361c <___svfprintf_internal_r+0x168c>
80122428:	d8c02d17 	ldw	r3,180(sp)
8012242c:	d9002d17 	ldw	r4,180(sp)
80122430:	d9402d17 	ldw	r5,180(sp)
80122434:	18c00017 	ldw	r3,0(r3)
80122438:	21000117 	ldw	r4,4(r4)
8012243c:	29400204 	addi	r5,r5,8
80122440:	d8c03615 	stw	r3,216(sp)
80122444:	d9003715 	stw	r4,220(sp)
80122448:	d9402d15 	stw	r5,180(sp)
8012244c:	d9003617 	ldw	r4,216(sp)
80122450:	d9403717 	ldw	r5,220(sp)
80122454:	da003e15 	stw	r8,248(sp)
80122458:	04000044 	movi	r16,1
8012245c:	012a8e00 	call	8012a8e0 <__fpclassifyd>
80122460:	da003e17 	ldw	r8,248(sp)
80122464:	14044b1e 	bne	r2,r16,80123594 <___svfprintf_internal_r+0x1604>
80122468:	d9003617 	ldw	r4,216(sp)
8012246c:	d9403717 	ldw	r5,220(sp)
80122470:	000d883a 	mov	r6,zero
80122474:	000f883a 	mov	r7,zero
80122478:	013174c0 	call	8013174c <__ledf2>
8012247c:	da003e17 	ldw	r8,248(sp)
80122480:	1005f316 	blt	r2,zero,80123c50 <___svfprintf_internal_r+0x1cc0>
80122484:	df002783 	ldbu	fp,158(sp)
80122488:	008011c4 	movi	r2,71
8012248c:	1445590e 	bge	r2,r17,801239f4 <___svfprintf_internal_r+0x1a64>
80122490:	04200534 	movhi	r16,32788
80122494:	841ec104 	addi	r16,r16,31492
80122498:	00c000c4 	movi	r3,3
8012249c:	00bfdfc4 	movi	r2,-129
801224a0:	d8c02a15 	stw	r3,168(sp)
801224a4:	90a4703a 	and	r18,r18,r2
801224a8:	d8c02e15 	stw	r3,184(sp)
801224ac:	d8002915 	stw	zero,164(sp)
801224b0:	d8003215 	stw	zero,200(sp)
801224b4:	00006606 	br	80122650 <___svfprintf_internal_r+0x6c0>
801224b8:	94800214 	ori	r18,r18,8
801224bc:	bc400007 	ldb	r17,0(r23)
801224c0:	003f0906 	br	801220e8 <__reset+0xfa1020e8>
801224c4:	18c03fcc 	andi	r3,r3,255
801224c8:	1807181e 	bne	r3,zero,8012412c <___svfprintf_internal_r+0x219c>
801224cc:	94800414 	ori	r18,r18,16
801224d0:	9080080c 	andi	r2,r18,32
801224d4:	10039626 	beq	r2,zero,80123330 <___svfprintf_internal_r+0x13a0>
801224d8:	d9402d17 	ldw	r5,180(sp)
801224dc:	28800117 	ldw	r2,4(r5)
801224e0:	2d000017 	ldw	r20,0(r5)
801224e4:	29400204 	addi	r5,r5,8
801224e8:	d9402d15 	stw	r5,180(sp)
801224ec:	102d883a 	mov	r22,r2
801224f0:	10039816 	blt	r2,zero,80123354 <___svfprintf_internal_r+0x13c4>
801224f4:	d9402917 	ldw	r5,164(sp)
801224f8:	df002783 	ldbu	fp,158(sp)
801224fc:	2803ab16 	blt	r5,zero,801233ac <___svfprintf_internal_r+0x141c>
80122500:	00ffdfc4 	movi	r3,-129
80122504:	a584b03a 	or	r2,r20,r22
80122508:	90e4703a 	and	r18,r18,r3
8012250c:	10014a26 	beq	r2,zero,80122a38 <___svfprintf_internal_r+0xaa8>
80122510:	b0034b26 	beq	r22,zero,80123240 <___svfprintf_internal_r+0x12b0>
80122514:	dc402a15 	stw	r17,168(sp)
80122518:	dc001e04 	addi	r16,sp,120
8012251c:	b023883a 	mov	r17,r22
80122520:	402d883a 	mov	r22,r8
80122524:	a009883a 	mov	r4,r20
80122528:	880b883a 	mov	r5,r17
8012252c:	01800284 	movi	r6,10
80122530:	000f883a 	mov	r7,zero
80122534:	012fc300 	call	8012fc30 <__umoddi3>
80122538:	10800c04 	addi	r2,r2,48
8012253c:	843fffc4 	addi	r16,r16,-1
80122540:	a009883a 	mov	r4,r20
80122544:	880b883a 	mov	r5,r17
80122548:	80800005 	stb	r2,0(r16)
8012254c:	01800284 	movi	r6,10
80122550:	000f883a 	mov	r7,zero
80122554:	012f6b00 	call	8012f6b0 <__udivdi3>
80122558:	1029883a 	mov	r20,r2
8012255c:	10c4b03a 	or	r2,r2,r3
80122560:	1823883a 	mov	r17,r3
80122564:	103fef1e 	bne	r2,zero,80122524 <__reset+0xfa102524>
80122568:	d8c02817 	ldw	r3,160(sp)
8012256c:	dc402a17 	ldw	r17,168(sp)
80122570:	b011883a 	mov	r8,r22
80122574:	1c07c83a 	sub	r3,r3,r16
80122578:	d8c02e15 	stw	r3,184(sp)
8012257c:	00002e06 	br	80122638 <___svfprintf_internal_r+0x6a8>
80122580:	18c03fcc 	andi	r3,r3,255
80122584:	1806e71e 	bne	r3,zero,80124124 <___svfprintf_internal_r+0x2194>
80122588:	94800414 	ori	r18,r18,16
8012258c:	9080080c 	andi	r2,r18,32
80122590:	1002d426 	beq	r2,zero,801230e4 <___svfprintf_internal_r+0x1154>
80122594:	d9402d17 	ldw	r5,180(sp)
80122598:	d8c02917 	ldw	r3,164(sp)
8012259c:	d8002785 	stb	zero,158(sp)
801225a0:	28800204 	addi	r2,r5,8
801225a4:	2d000017 	ldw	r20,0(r5)
801225a8:	2d800117 	ldw	r22,4(r5)
801225ac:	18041516 	blt	r3,zero,80123604 <___svfprintf_internal_r+0x1674>
801225b0:	013fdfc4 	movi	r4,-129
801225b4:	a586b03a 	or	r3,r20,r22
801225b8:	d8802d15 	stw	r2,180(sp)
801225bc:	9124703a 	and	r18,r18,r4
801225c0:	1802d51e 	bne	r3,zero,80123118 <___svfprintf_internal_r+0x1188>
801225c4:	d9402917 	ldw	r5,164(sp)
801225c8:	0039883a 	mov	fp,zero
801225cc:	2806be26 	beq	r5,zero,801240c8 <___svfprintf_internal_r+0x2138>
801225d0:	0029883a 	mov	r20,zero
801225d4:	002d883a 	mov	r22,zero
801225d8:	dc001e04 	addi	r16,sp,120
801225dc:	a006d0fa 	srli	r3,r20,3
801225e0:	b008977a 	slli	r4,r22,29
801225e4:	b02cd0fa 	srli	r22,r22,3
801225e8:	a50001cc 	andi	r20,r20,7
801225ec:	a0800c04 	addi	r2,r20,48
801225f0:	843fffc4 	addi	r16,r16,-1
801225f4:	20e8b03a 	or	r20,r4,r3
801225f8:	80800005 	stb	r2,0(r16)
801225fc:	a586b03a 	or	r3,r20,r22
80122600:	183ff61e 	bne	r3,zero,801225dc <__reset+0xfa1025dc>
80122604:	90c0004c 	andi	r3,r18,1
80122608:	18013926 	beq	r3,zero,80122af0 <___svfprintf_internal_r+0xb60>
8012260c:	10803fcc 	andi	r2,r2,255
80122610:	1080201c 	xori	r2,r2,128
80122614:	10bfe004 	addi	r2,r2,-128
80122618:	00c00c04 	movi	r3,48
8012261c:	10c13426 	beq	r2,r3,80122af0 <___svfprintf_internal_r+0xb60>
80122620:	80ffffc5 	stb	r3,-1(r16)
80122624:	d8c02817 	ldw	r3,160(sp)
80122628:	80bfffc4 	addi	r2,r16,-1
8012262c:	1021883a 	mov	r16,r2
80122630:	1887c83a 	sub	r3,r3,r2
80122634:	d8c02e15 	stw	r3,184(sp)
80122638:	d8802e17 	ldw	r2,184(sp)
8012263c:	d9002917 	ldw	r4,164(sp)
80122640:	1100010e 	bge	r2,r4,80122648 <___svfprintf_internal_r+0x6b8>
80122644:	2005883a 	mov	r2,r4
80122648:	d8802a15 	stw	r2,168(sp)
8012264c:	d8003215 	stw	zero,200(sp)
80122650:	e7003fcc 	andi	fp,fp,255
80122654:	e700201c 	xori	fp,fp,128
80122658:	e73fe004 	addi	fp,fp,-128
8012265c:	e0000326 	beq	fp,zero,8012266c <___svfprintf_internal_r+0x6dc>
80122660:	d8c02a17 	ldw	r3,168(sp)
80122664:	18c00044 	addi	r3,r3,1
80122668:	d8c02a15 	stw	r3,168(sp)
8012266c:	90c0008c 	andi	r3,r18,2
80122670:	d8c02b15 	stw	r3,172(sp)
80122674:	18000326 	beq	r3,zero,80122684 <___svfprintf_internal_r+0x6f4>
80122678:	d8c02a17 	ldw	r3,168(sp)
8012267c:	18c00084 	addi	r3,r3,2
80122680:	d8c02a15 	stw	r3,168(sp)
80122684:	90c0210c 	andi	r3,r18,132
80122688:	d8c03015 	stw	r3,192(sp)
8012268c:	1801a11e 	bne	r3,zero,80122d14 <___svfprintf_internal_r+0xd84>
80122690:	d9003117 	ldw	r4,196(sp)
80122694:	d8c02a17 	ldw	r3,168(sp)
80122698:	20e9c83a 	sub	r20,r4,r3
8012269c:	05019d0e 	bge	zero,r20,80122d14 <___svfprintf_internal_r+0xd84>
801226a0:	02400404 	movi	r9,16
801226a4:	d8c02017 	ldw	r3,128(sp)
801226a8:	d8801f17 	ldw	r2,124(sp)
801226ac:	4d051b0e 	bge	r9,r20,80123b1c <___svfprintf_internal_r+0x1b8c>
801226b0:	01600534 	movhi	r5,32788
801226b4:	295ed484 	addi	r5,r5,31570
801226b8:	dc403c15 	stw	r17,240(sp)
801226bc:	d9403515 	stw	r5,212(sp)
801226c0:	a023883a 	mov	r17,r20
801226c4:	482d883a 	mov	r22,r9
801226c8:	9029883a 	mov	r20,r18
801226cc:	070001c4 	movi	fp,7
801226d0:	8025883a 	mov	r18,r16
801226d4:	dc002c17 	ldw	r16,176(sp)
801226d8:	00000306 	br	801226e8 <___svfprintf_internal_r+0x758>
801226dc:	8c7ffc04 	addi	r17,r17,-16
801226e0:	42000204 	addi	r8,r8,8
801226e4:	b440130e 	bge	r22,r17,80122734 <___svfprintf_internal_r+0x7a4>
801226e8:	01200534 	movhi	r4,32788
801226ec:	18c00404 	addi	r3,r3,16
801226f0:	10800044 	addi	r2,r2,1
801226f4:	211ed484 	addi	r4,r4,31570
801226f8:	41000015 	stw	r4,0(r8)
801226fc:	45800115 	stw	r22,4(r8)
80122700:	d8c02015 	stw	r3,128(sp)
80122704:	d8801f15 	stw	r2,124(sp)
80122708:	e0bff40e 	bge	fp,r2,801226dc <__reset+0xfa1026dc>
8012270c:	d9801e04 	addi	r6,sp,120
80122710:	800b883a 	mov	r5,r16
80122714:	9809883a 	mov	r4,r19
80122718:	012c9940 	call	8012c994 <__ssprint_r>
8012271c:	103f031e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80122720:	8c7ffc04 	addi	r17,r17,-16
80122724:	d8c02017 	ldw	r3,128(sp)
80122728:	d8801f17 	ldw	r2,124(sp)
8012272c:	da000404 	addi	r8,sp,16
80122730:	b47fed16 	blt	r22,r17,801226e8 <__reset+0xfa1026e8>
80122734:	9021883a 	mov	r16,r18
80122738:	a025883a 	mov	r18,r20
8012273c:	8829883a 	mov	r20,r17
80122740:	dc403c17 	ldw	r17,240(sp)
80122744:	d9403517 	ldw	r5,212(sp)
80122748:	a0c7883a 	add	r3,r20,r3
8012274c:	10800044 	addi	r2,r2,1
80122750:	41400015 	stw	r5,0(r8)
80122754:	45000115 	stw	r20,4(r8)
80122758:	d8c02015 	stw	r3,128(sp)
8012275c:	d8801f15 	stw	r2,124(sp)
80122760:	010001c4 	movi	r4,7
80122764:	20829f16 	blt	r4,r2,801231e4 <___svfprintf_internal_r+0x1254>
80122768:	df002787 	ldb	fp,158(sp)
8012276c:	42000204 	addi	r8,r8,8
80122770:	e0000c26 	beq	fp,zero,801227a4 <___svfprintf_internal_r+0x814>
80122774:	d8801f17 	ldw	r2,124(sp)
80122778:	d9002784 	addi	r4,sp,158
8012277c:	18c00044 	addi	r3,r3,1
80122780:	10800044 	addi	r2,r2,1
80122784:	41000015 	stw	r4,0(r8)
80122788:	01000044 	movi	r4,1
8012278c:	41000115 	stw	r4,4(r8)
80122790:	d8c02015 	stw	r3,128(sp)
80122794:	d8801f15 	stw	r2,124(sp)
80122798:	010001c4 	movi	r4,7
8012279c:	20823816 	blt	r4,r2,80123080 <___svfprintf_internal_r+0x10f0>
801227a0:	42000204 	addi	r8,r8,8
801227a4:	d8802b17 	ldw	r2,172(sp)
801227a8:	10000c26 	beq	r2,zero,801227dc <___svfprintf_internal_r+0x84c>
801227ac:	d8801f17 	ldw	r2,124(sp)
801227b0:	d9002704 	addi	r4,sp,156
801227b4:	18c00084 	addi	r3,r3,2
801227b8:	10800044 	addi	r2,r2,1
801227bc:	41000015 	stw	r4,0(r8)
801227c0:	01000084 	movi	r4,2
801227c4:	41000115 	stw	r4,4(r8)
801227c8:	d8c02015 	stw	r3,128(sp)
801227cc:	d8801f15 	stw	r2,124(sp)
801227d0:	010001c4 	movi	r4,7
801227d4:	20823216 	blt	r4,r2,801230a0 <___svfprintf_internal_r+0x1110>
801227d8:	42000204 	addi	r8,r8,8
801227dc:	d9003017 	ldw	r4,192(sp)
801227e0:	00802004 	movi	r2,128
801227e4:	20819726 	beq	r4,r2,80122e44 <___svfprintf_internal_r+0xeb4>
801227e8:	d9402917 	ldw	r5,164(sp)
801227ec:	d8802e17 	ldw	r2,184(sp)
801227f0:	28adc83a 	sub	r22,r5,r2
801227f4:	05802f0e 	bge	zero,r22,801228b4 <___svfprintf_internal_r+0x924>
801227f8:	07000404 	movi	fp,16
801227fc:	d8801f17 	ldw	r2,124(sp)
80122800:	e583c00e 	bge	fp,r22,80123704 <___svfprintf_internal_r+0x1774>
80122804:	01600534 	movhi	r5,32788
80122808:	295ed084 	addi	r5,r5,31554
8012280c:	dc402915 	stw	r17,164(sp)
80122810:	d9402b15 	stw	r5,172(sp)
80122814:	b023883a 	mov	r17,r22
80122818:	050001c4 	movi	r20,7
8012281c:	902d883a 	mov	r22,r18
80122820:	8025883a 	mov	r18,r16
80122824:	dc002c17 	ldw	r16,176(sp)
80122828:	00000306 	br	80122838 <___svfprintf_internal_r+0x8a8>
8012282c:	8c7ffc04 	addi	r17,r17,-16
80122830:	42000204 	addi	r8,r8,8
80122834:	e440110e 	bge	fp,r17,8012287c <___svfprintf_internal_r+0x8ec>
80122838:	18c00404 	addi	r3,r3,16
8012283c:	10800044 	addi	r2,r2,1
80122840:	45400015 	stw	r21,0(r8)
80122844:	47000115 	stw	fp,4(r8)
80122848:	d8c02015 	stw	r3,128(sp)
8012284c:	d8801f15 	stw	r2,124(sp)
80122850:	a0bff60e 	bge	r20,r2,8012282c <__reset+0xfa10282c>
80122854:	d9801e04 	addi	r6,sp,120
80122858:	800b883a 	mov	r5,r16
8012285c:	9809883a 	mov	r4,r19
80122860:	012c9940 	call	8012c994 <__ssprint_r>
80122864:	103eb11e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80122868:	8c7ffc04 	addi	r17,r17,-16
8012286c:	d8c02017 	ldw	r3,128(sp)
80122870:	d8801f17 	ldw	r2,124(sp)
80122874:	da000404 	addi	r8,sp,16
80122878:	e47fef16 	blt	fp,r17,80122838 <__reset+0xfa102838>
8012287c:	9021883a 	mov	r16,r18
80122880:	b025883a 	mov	r18,r22
80122884:	882d883a 	mov	r22,r17
80122888:	dc402917 	ldw	r17,164(sp)
8012288c:	d9002b17 	ldw	r4,172(sp)
80122890:	1d87883a 	add	r3,r3,r22
80122894:	10800044 	addi	r2,r2,1
80122898:	41000015 	stw	r4,0(r8)
8012289c:	45800115 	stw	r22,4(r8)
801228a0:	d8c02015 	stw	r3,128(sp)
801228a4:	d8801f15 	stw	r2,124(sp)
801228a8:	010001c4 	movi	r4,7
801228ac:	2081ec16 	blt	r4,r2,80123060 <___svfprintf_internal_r+0x10d0>
801228b0:	42000204 	addi	r8,r8,8
801228b4:	9080400c 	andi	r2,r18,256
801228b8:	1001181e 	bne	r2,zero,80122d1c <___svfprintf_internal_r+0xd8c>
801228bc:	d9402e17 	ldw	r5,184(sp)
801228c0:	d8801f17 	ldw	r2,124(sp)
801228c4:	44000015 	stw	r16,0(r8)
801228c8:	1947883a 	add	r3,r3,r5
801228cc:	10800044 	addi	r2,r2,1
801228d0:	41400115 	stw	r5,4(r8)
801228d4:	d8c02015 	stw	r3,128(sp)
801228d8:	d8801f15 	stw	r2,124(sp)
801228dc:	010001c4 	movi	r4,7
801228e0:	2081d116 	blt	r4,r2,80123028 <___svfprintf_internal_r+0x1098>
801228e4:	42000204 	addi	r8,r8,8
801228e8:	9480010c 	andi	r18,r18,4
801228ec:	90003226 	beq	r18,zero,801229b8 <___svfprintf_internal_r+0xa28>
801228f0:	d9403117 	ldw	r5,196(sp)
801228f4:	d8802a17 	ldw	r2,168(sp)
801228f8:	28a1c83a 	sub	r16,r5,r2
801228fc:	04002e0e 	bge	zero,r16,801229b8 <___svfprintf_internal_r+0xa28>
80122900:	04400404 	movi	r17,16
80122904:	d8801f17 	ldw	r2,124(sp)
80122908:	8c04b90e 	bge	r17,r16,80123bf0 <___svfprintf_internal_r+0x1c60>
8012290c:	01600534 	movhi	r5,32788
80122910:	295ed484 	addi	r5,r5,31570
80122914:	d9403515 	stw	r5,212(sp)
80122918:	048001c4 	movi	r18,7
8012291c:	dd002c17 	ldw	r20,176(sp)
80122920:	00000306 	br	80122930 <___svfprintf_internal_r+0x9a0>
80122924:	843ffc04 	addi	r16,r16,-16
80122928:	42000204 	addi	r8,r8,8
8012292c:	8c00130e 	bge	r17,r16,8012297c <___svfprintf_internal_r+0x9ec>
80122930:	01200534 	movhi	r4,32788
80122934:	18c00404 	addi	r3,r3,16
80122938:	10800044 	addi	r2,r2,1
8012293c:	211ed484 	addi	r4,r4,31570
80122940:	41000015 	stw	r4,0(r8)
80122944:	44400115 	stw	r17,4(r8)
80122948:	d8c02015 	stw	r3,128(sp)
8012294c:	d8801f15 	stw	r2,124(sp)
80122950:	90bff40e 	bge	r18,r2,80122924 <__reset+0xfa102924>
80122954:	d9801e04 	addi	r6,sp,120
80122958:	a00b883a 	mov	r5,r20
8012295c:	9809883a 	mov	r4,r19
80122960:	012c9940 	call	8012c994 <__ssprint_r>
80122964:	103e711e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80122968:	843ffc04 	addi	r16,r16,-16
8012296c:	d8c02017 	ldw	r3,128(sp)
80122970:	d8801f17 	ldw	r2,124(sp)
80122974:	da000404 	addi	r8,sp,16
80122978:	8c3fed16 	blt	r17,r16,80122930 <__reset+0xfa102930>
8012297c:	d9403517 	ldw	r5,212(sp)
80122980:	1c07883a 	add	r3,r3,r16
80122984:	10800044 	addi	r2,r2,1
80122988:	41400015 	stw	r5,0(r8)
8012298c:	44000115 	stw	r16,4(r8)
80122990:	d8c02015 	stw	r3,128(sp)
80122994:	d8801f15 	stw	r2,124(sp)
80122998:	010001c4 	movi	r4,7
8012299c:	2080060e 	bge	r4,r2,801229b8 <___svfprintf_internal_r+0xa28>
801229a0:	d9402c17 	ldw	r5,176(sp)
801229a4:	d9801e04 	addi	r6,sp,120
801229a8:	9809883a 	mov	r4,r19
801229ac:	012c9940 	call	8012c994 <__ssprint_r>
801229b0:	103e5e1e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
801229b4:	d8c02017 	ldw	r3,128(sp)
801229b8:	d8803117 	ldw	r2,196(sp)
801229bc:	d9002a17 	ldw	r4,168(sp)
801229c0:	1100010e 	bge	r2,r4,801229c8 <___svfprintf_internal_r+0xa38>
801229c4:	2005883a 	mov	r2,r4
801229c8:	d9402f17 	ldw	r5,188(sp)
801229cc:	288b883a 	add	r5,r5,r2
801229d0:	d9402f15 	stw	r5,188(sp)
801229d4:	18019c1e 	bne	r3,zero,80123048 <___svfprintf_internal_r+0x10b8>
801229d8:	b8800007 	ldb	r2,0(r23)
801229dc:	d8001f15 	stw	zero,124(sp)
801229e0:	da000404 	addi	r8,sp,16
801229e4:	103d991e 	bne	r2,zero,8012204c <__reset+0xfa10204c>
801229e8:	b821883a 	mov	r16,r23
801229ec:	003daf06 	br	801220ac <__reset+0xfa1020ac>
801229f0:	18c03fcc 	andi	r3,r3,255
801229f4:	1805c71e 	bne	r3,zero,80124114 <___svfprintf_internal_r+0x2184>
801229f8:	94800414 	ori	r18,r18,16
801229fc:	9080080c 	andi	r2,r18,32
80122a00:	10020126 	beq	r2,zero,80123208 <___svfprintf_internal_r+0x1278>
80122a04:	d8802d17 	ldw	r2,180(sp)
80122a08:	d9002917 	ldw	r4,164(sp)
80122a0c:	d8002785 	stb	zero,158(sp)
80122a10:	10c00204 	addi	r3,r2,8
80122a14:	15000017 	ldw	r20,0(r2)
80122a18:	15800117 	ldw	r22,4(r2)
80122a1c:	20038e16 	blt	r4,zero,80123858 <___svfprintf_internal_r+0x18c8>
80122a20:	013fdfc4 	movi	r4,-129
80122a24:	a584b03a 	or	r2,r20,r22
80122a28:	d8c02d15 	stw	r3,180(sp)
80122a2c:	9124703a 	and	r18,r18,r4
80122a30:	0039883a 	mov	fp,zero
80122a34:	103eb61e 	bne	r2,zero,80122510 <__reset+0xfa102510>
80122a38:	d8802917 	ldw	r2,164(sp)
80122a3c:	1002c81e 	bne	r2,zero,80123560 <___svfprintf_internal_r+0x15d0>
80122a40:	d8002915 	stw	zero,164(sp)
80122a44:	d8002e15 	stw	zero,184(sp)
80122a48:	dc001e04 	addi	r16,sp,120
80122a4c:	003efa06 	br	80122638 <__reset+0xfa102638>
80122a50:	18c03fcc 	andi	r3,r3,255
80122a54:	1805ad1e 	bne	r3,zero,8012410c <___svfprintf_internal_r+0x217c>
80122a58:	01600534 	movhi	r5,32788
80122a5c:	295ec404 	addi	r5,r5,31504
80122a60:	d9403a15 	stw	r5,232(sp)
80122a64:	9080080c 	andi	r2,r18,32
80122a68:	10006126 	beq	r2,zero,80122bf0 <___svfprintf_internal_r+0xc60>
80122a6c:	d8802d17 	ldw	r2,180(sp)
80122a70:	15000017 	ldw	r20,0(r2)
80122a74:	15800117 	ldw	r22,4(r2)
80122a78:	10800204 	addi	r2,r2,8
80122a7c:	d8802d15 	stw	r2,180(sp)
80122a80:	9080004c 	andi	r2,r18,1
80122a84:	10018e26 	beq	r2,zero,801230c0 <___svfprintf_internal_r+0x1130>
80122a88:	a584b03a 	or	r2,r20,r22
80122a8c:	10030926 	beq	r2,zero,801236b4 <___svfprintf_internal_r+0x1724>
80122a90:	d8c02917 	ldw	r3,164(sp)
80122a94:	00800c04 	movi	r2,48
80122a98:	d8802705 	stb	r2,156(sp)
80122a9c:	dc402745 	stb	r17,157(sp)
80122aa0:	d8002785 	stb	zero,158(sp)
80122aa4:	90800094 	ori	r2,r18,2
80122aa8:	18048716 	blt	r3,zero,80123cc8 <___svfprintf_internal_r+0x1d38>
80122aac:	00bfdfc4 	movi	r2,-129
80122ab0:	90a4703a 	and	r18,r18,r2
80122ab4:	94800094 	ori	r18,r18,2
80122ab8:	0039883a 	mov	fp,zero
80122abc:	d9003a17 	ldw	r4,232(sp)
80122ac0:	dc001e04 	addi	r16,sp,120
80122ac4:	a08003cc 	andi	r2,r20,15
80122ac8:	b006973a 	slli	r3,r22,28
80122acc:	2085883a 	add	r2,r4,r2
80122ad0:	a028d13a 	srli	r20,r20,4
80122ad4:	10800003 	ldbu	r2,0(r2)
80122ad8:	b02cd13a 	srli	r22,r22,4
80122adc:	843fffc4 	addi	r16,r16,-1
80122ae0:	1d28b03a 	or	r20,r3,r20
80122ae4:	80800005 	stb	r2,0(r16)
80122ae8:	a584b03a 	or	r2,r20,r22
80122aec:	103ff51e 	bne	r2,zero,80122ac4 <__reset+0xfa102ac4>
80122af0:	d8c02817 	ldw	r3,160(sp)
80122af4:	1c07c83a 	sub	r3,r3,r16
80122af8:	d8c02e15 	stw	r3,184(sp)
80122afc:	003ece06 	br	80122638 <__reset+0xfa102638>
80122b00:	d8c02d17 	ldw	r3,180(sp)
80122b04:	d9002d17 	ldw	r4,180(sp)
80122b08:	d8002785 	stb	zero,158(sp)
80122b0c:	18800017 	ldw	r2,0(r3)
80122b10:	21000104 	addi	r4,r4,4
80122b14:	00c00044 	movi	r3,1
80122b18:	d8c02a15 	stw	r3,168(sp)
80122b1c:	d8801405 	stb	r2,80(sp)
80122b20:	d9002d15 	stw	r4,180(sp)
80122b24:	d8c02e15 	stw	r3,184(sp)
80122b28:	d8002915 	stw	zero,164(sp)
80122b2c:	d8003215 	stw	zero,200(sp)
80122b30:	dc001404 	addi	r16,sp,80
80122b34:	0039883a 	mov	fp,zero
80122b38:	003ecc06 	br	8012266c <__reset+0xfa10266c>
80122b3c:	18c03fcc 	andi	r3,r3,255
80122b40:	183e9226 	beq	r3,zero,8012258c <__reset+0xfa10258c>
80122b44:	d9c02785 	stb	r7,158(sp)
80122b48:	003e9006 	br	8012258c <__reset+0xfa10258c>
80122b4c:	00c00044 	movi	r3,1
80122b50:	01c00ac4 	movi	r7,43
80122b54:	bc400007 	ldb	r17,0(r23)
80122b58:	003d6306 	br	801220e8 <__reset+0xfa1020e8>
80122b5c:	94800814 	ori	r18,r18,32
80122b60:	bc400007 	ldb	r17,0(r23)
80122b64:	003d6006 	br	801220e8 <__reset+0xfa1020e8>
80122b68:	d8c02d17 	ldw	r3,180(sp)
80122b6c:	d8002785 	stb	zero,158(sp)
80122b70:	1c000017 	ldw	r16,0(r3)
80122b74:	1d000104 	addi	r20,r3,4
80122b78:	80040f26 	beq	r16,zero,80123bb8 <___svfprintf_internal_r+0x1c28>
80122b7c:	d9002917 	ldw	r4,164(sp)
80122b80:	2003dc16 	blt	r4,zero,80123af4 <___svfprintf_internal_r+0x1b64>
80122b84:	200d883a 	mov	r6,r4
80122b88:	000b883a 	mov	r5,zero
80122b8c:	8009883a 	mov	r4,r16
80122b90:	da003e15 	stw	r8,248(sp)
80122b94:	0128ee00 	call	80128ee0 <memchr>
80122b98:	da003e17 	ldw	r8,248(sp)
80122b9c:	10045826 	beq	r2,zero,80123d00 <___svfprintf_internal_r+0x1d70>
80122ba0:	1405c83a 	sub	r2,r2,r16
80122ba4:	d8802e15 	stw	r2,184(sp)
80122ba8:	1003d816 	blt	r2,zero,80123b0c <___svfprintf_internal_r+0x1b7c>
80122bac:	df002783 	ldbu	fp,158(sp)
80122bb0:	d8802a15 	stw	r2,168(sp)
80122bb4:	dd002d15 	stw	r20,180(sp)
80122bb8:	d8002915 	stw	zero,164(sp)
80122bbc:	d8003215 	stw	zero,200(sp)
80122bc0:	003ea306 	br	80122650 <__reset+0xfa102650>
80122bc4:	18c03fcc 	andi	r3,r3,255
80122bc8:	183f8c26 	beq	r3,zero,801229fc <__reset+0xfa1029fc>
80122bcc:	d9c02785 	stb	r7,158(sp)
80122bd0:	003f8a06 	br	801229fc <__reset+0xfa1029fc>
80122bd4:	18c03fcc 	andi	r3,r3,255
80122bd8:	1805631e 	bne	r3,zero,80124168 <___svfprintf_internal_r+0x21d8>
80122bdc:	01600534 	movhi	r5,32788
80122be0:	295ec904 	addi	r5,r5,31524
80122be4:	d9403a15 	stw	r5,232(sp)
80122be8:	9080080c 	andi	r2,r18,32
80122bec:	103f9f1e 	bne	r2,zero,80122a6c <__reset+0xfa102a6c>
80122bf0:	9080040c 	andi	r2,r18,16
80122bf4:	10029c26 	beq	r2,zero,80123668 <___svfprintf_internal_r+0x16d8>
80122bf8:	d8c02d17 	ldw	r3,180(sp)
80122bfc:	002d883a 	mov	r22,zero
80122c00:	1d000017 	ldw	r20,0(r3)
80122c04:	18c00104 	addi	r3,r3,4
80122c08:	d8c02d15 	stw	r3,180(sp)
80122c0c:	003f9c06 	br	80122a80 <__reset+0xfa102a80>
80122c10:	94800054 	ori	r18,r18,1
80122c14:	bc400007 	ldb	r17,0(r23)
80122c18:	003d3306 	br	801220e8 <__reset+0xfa1020e8>
80122c1c:	38803fcc 	andi	r2,r7,255
80122c20:	1080201c 	xori	r2,r2,128
80122c24:	10bfe004 	addi	r2,r2,-128
80122c28:	1002971e 	bne	r2,zero,80123688 <___svfprintf_internal_r+0x16f8>
80122c2c:	00c00044 	movi	r3,1
80122c30:	01c00804 	movi	r7,32
80122c34:	bc400007 	ldb	r17,0(r23)
80122c38:	003d2b06 	br	801220e8 <__reset+0xfa1020e8>
80122c3c:	18c03fcc 	andi	r3,r3,255
80122c40:	183e2326 	beq	r3,zero,801224d0 <__reset+0xfa1024d0>
80122c44:	d9c02785 	stb	r7,158(sp)
80122c48:	003e2106 	br	801224d0 <__reset+0xfa1024d0>
80122c4c:	bc400007 	ldb	r17,0(r23)
80122c50:	8a430426 	beq	r17,r9,80123864 <___svfprintf_internal_r+0x18d4>
80122c54:	94800414 	ori	r18,r18,16
80122c58:	003d2306 	br	801220e8 <__reset+0xfa1020e8>
80122c5c:	18c03fcc 	andi	r3,r3,255
80122c60:	18053f1e 	bne	r3,zero,80124160 <___svfprintf_internal_r+0x21d0>
80122c64:	9080080c 	andi	r2,r18,32
80122c68:	10028926 	beq	r2,zero,80123690 <___svfprintf_internal_r+0x1700>
80122c6c:	d9402d17 	ldw	r5,180(sp)
80122c70:	d9002f17 	ldw	r4,188(sp)
80122c74:	28800017 	ldw	r2,0(r5)
80122c78:	2007d7fa 	srai	r3,r4,31
80122c7c:	29400104 	addi	r5,r5,4
80122c80:	d9402d15 	stw	r5,180(sp)
80122c84:	11000015 	stw	r4,0(r2)
80122c88:	10c00115 	stw	r3,4(r2)
80122c8c:	003ced06 	br	80122044 <__reset+0xfa102044>
80122c90:	94801014 	ori	r18,r18,64
80122c94:	bc400007 	ldb	r17,0(r23)
80122c98:	003d1306 	br	801220e8 <__reset+0xfa1020e8>
80122c9c:	01200534 	movhi	r4,32788
80122ca0:	211ec904 	addi	r4,r4,31524
80122ca4:	0039883a 	mov	fp,zero
80122ca8:	d9003a15 	stw	r4,232(sp)
80122cac:	04401e04 	movi	r17,120
80122cb0:	003f8206 	br	80122abc <__reset+0xfa102abc>
80122cb4:	18c03fcc 	andi	r3,r3,255
80122cb8:	1805221e 	bne	r3,zero,80124144 <___svfprintf_internal_r+0x21b4>
80122cbc:	883d9526 	beq	r17,zero,80122314 <__reset+0xfa102314>
80122cc0:	00c00044 	movi	r3,1
80122cc4:	d8c02a15 	stw	r3,168(sp)
80122cc8:	dc401405 	stb	r17,80(sp)
80122ccc:	d8002785 	stb	zero,158(sp)
80122cd0:	003f9406 	br	80122b24 <__reset+0xfa102b24>
80122cd4:	01200534 	movhi	r4,32788
80122cd8:	211ec904 	addi	r4,r4,31524
80122cdc:	d9003a15 	stw	r4,232(sp)
80122ce0:	d8c02d15 	stw	r3,180(sp)
80122ce4:	1025883a 	mov	r18,r2
80122ce8:	04401e04 	movi	r17,120
80122cec:	a584b03a 	or	r2,r20,r22
80122cf0:	1000fa1e 	bne	r2,zero,801230dc <___svfprintf_internal_r+0x114c>
80122cf4:	0039883a 	mov	fp,zero
80122cf8:	00800084 	movi	r2,2
80122cfc:	10803fcc 	andi	r2,r2,255
80122d00:	00c00044 	movi	r3,1
80122d04:	10c21626 	beq	r2,r3,80123560 <___svfprintf_internal_r+0x15d0>
80122d08:	00c00084 	movi	r3,2
80122d0c:	10fe301e 	bne	r2,r3,801225d0 <__reset+0xfa1025d0>
80122d10:	003d7606 	br	801222ec <__reset+0xfa1022ec>
80122d14:	d8c02017 	ldw	r3,128(sp)
80122d18:	003e9506 	br	80122770 <__reset+0xfa102770>
80122d1c:	00801944 	movi	r2,101
80122d20:	14407c0e 	bge	r2,r17,80122f14 <___svfprintf_internal_r+0xf84>
80122d24:	d9003617 	ldw	r4,216(sp)
80122d28:	d9403717 	ldw	r5,220(sp)
80122d2c:	000d883a 	mov	r6,zero
80122d30:	000f883a 	mov	r7,zero
80122d34:	d8c03d15 	stw	r3,244(sp)
80122d38:	da003e15 	stw	r8,248(sp)
80122d3c:	01316c40 	call	801316c4 <__eqdf2>
80122d40:	d8c03d17 	ldw	r3,244(sp)
80122d44:	da003e17 	ldw	r8,248(sp)
80122d48:	1000f51e 	bne	r2,zero,80123120 <___svfprintf_internal_r+0x1190>
80122d4c:	d8801f17 	ldw	r2,124(sp)
80122d50:	01200534 	movhi	r4,32788
80122d54:	211ed004 	addi	r4,r4,31552
80122d58:	18c00044 	addi	r3,r3,1
80122d5c:	10800044 	addi	r2,r2,1
80122d60:	41000015 	stw	r4,0(r8)
80122d64:	01000044 	movi	r4,1
80122d68:	41000115 	stw	r4,4(r8)
80122d6c:	d8c02015 	stw	r3,128(sp)
80122d70:	d8801f15 	stw	r2,124(sp)
80122d74:	010001c4 	movi	r4,7
80122d78:	20826616 	blt	r4,r2,80123714 <___svfprintf_internal_r+0x1784>
80122d7c:	42000204 	addi	r8,r8,8
80122d80:	d8802617 	ldw	r2,152(sp)
80122d84:	d9403317 	ldw	r5,204(sp)
80122d88:	11400216 	blt	r2,r5,80122d94 <___svfprintf_internal_r+0xe04>
80122d8c:	9080004c 	andi	r2,r18,1
80122d90:	103ed526 	beq	r2,zero,801228e8 <__reset+0xfa1028e8>
80122d94:	d8803817 	ldw	r2,224(sp)
80122d98:	d9003417 	ldw	r4,208(sp)
80122d9c:	d9403817 	ldw	r5,224(sp)
80122da0:	1887883a 	add	r3,r3,r2
80122da4:	d8801f17 	ldw	r2,124(sp)
80122da8:	41000015 	stw	r4,0(r8)
80122dac:	41400115 	stw	r5,4(r8)
80122db0:	10800044 	addi	r2,r2,1
80122db4:	d8c02015 	stw	r3,128(sp)
80122db8:	d8801f15 	stw	r2,124(sp)
80122dbc:	010001c4 	movi	r4,7
80122dc0:	2082af16 	blt	r4,r2,80123880 <___svfprintf_internal_r+0x18f0>
80122dc4:	42000204 	addi	r8,r8,8
80122dc8:	d8803317 	ldw	r2,204(sp)
80122dcc:	143fffc4 	addi	r16,r2,-1
80122dd0:	043ec50e 	bge	zero,r16,801228e8 <__reset+0xfa1028e8>
80122dd4:	04400404 	movi	r17,16
80122dd8:	d8801f17 	ldw	r2,124(sp)
80122ddc:	8c00860e 	bge	r17,r16,80122ff8 <___svfprintf_internal_r+0x1068>
80122de0:	01600534 	movhi	r5,32788
80122de4:	295ed084 	addi	r5,r5,31554
80122de8:	d9402b15 	stw	r5,172(sp)
80122dec:	058001c4 	movi	r22,7
80122df0:	dd002c17 	ldw	r20,176(sp)
80122df4:	00000306 	br	80122e04 <___svfprintf_internal_r+0xe74>
80122df8:	42000204 	addi	r8,r8,8
80122dfc:	843ffc04 	addi	r16,r16,-16
80122e00:	8c00800e 	bge	r17,r16,80123004 <___svfprintf_internal_r+0x1074>
80122e04:	18c00404 	addi	r3,r3,16
80122e08:	10800044 	addi	r2,r2,1
80122e0c:	45400015 	stw	r21,0(r8)
80122e10:	44400115 	stw	r17,4(r8)
80122e14:	d8c02015 	stw	r3,128(sp)
80122e18:	d8801f15 	stw	r2,124(sp)
80122e1c:	b0bff60e 	bge	r22,r2,80122df8 <__reset+0xfa102df8>
80122e20:	d9801e04 	addi	r6,sp,120
80122e24:	a00b883a 	mov	r5,r20
80122e28:	9809883a 	mov	r4,r19
80122e2c:	012c9940 	call	8012c994 <__ssprint_r>
80122e30:	103d3e1e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80122e34:	d8c02017 	ldw	r3,128(sp)
80122e38:	d8801f17 	ldw	r2,124(sp)
80122e3c:	da000404 	addi	r8,sp,16
80122e40:	003fee06 	br	80122dfc <__reset+0xfa102dfc>
80122e44:	d9403117 	ldw	r5,196(sp)
80122e48:	d8802a17 	ldw	r2,168(sp)
80122e4c:	28adc83a 	sub	r22,r5,r2
80122e50:	05be650e 	bge	zero,r22,801227e8 <__reset+0xfa1027e8>
80122e54:	07000404 	movi	fp,16
80122e58:	d8801f17 	ldw	r2,124(sp)
80122e5c:	e583a20e 	bge	fp,r22,80123ce8 <___svfprintf_internal_r+0x1d58>
80122e60:	01600534 	movhi	r5,32788
80122e64:	295ed084 	addi	r5,r5,31554
80122e68:	dc403015 	stw	r17,192(sp)
80122e6c:	d9402b15 	stw	r5,172(sp)
80122e70:	b023883a 	mov	r17,r22
80122e74:	050001c4 	movi	r20,7
80122e78:	902d883a 	mov	r22,r18
80122e7c:	8025883a 	mov	r18,r16
80122e80:	dc002c17 	ldw	r16,176(sp)
80122e84:	00000306 	br	80122e94 <___svfprintf_internal_r+0xf04>
80122e88:	8c7ffc04 	addi	r17,r17,-16
80122e8c:	42000204 	addi	r8,r8,8
80122e90:	e440110e 	bge	fp,r17,80122ed8 <___svfprintf_internal_r+0xf48>
80122e94:	18c00404 	addi	r3,r3,16
80122e98:	10800044 	addi	r2,r2,1
80122e9c:	45400015 	stw	r21,0(r8)
80122ea0:	47000115 	stw	fp,4(r8)
80122ea4:	d8c02015 	stw	r3,128(sp)
80122ea8:	d8801f15 	stw	r2,124(sp)
80122eac:	a0bff60e 	bge	r20,r2,80122e88 <__reset+0xfa102e88>
80122eb0:	d9801e04 	addi	r6,sp,120
80122eb4:	800b883a 	mov	r5,r16
80122eb8:	9809883a 	mov	r4,r19
80122ebc:	012c9940 	call	8012c994 <__ssprint_r>
80122ec0:	103d1a1e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80122ec4:	8c7ffc04 	addi	r17,r17,-16
80122ec8:	d8c02017 	ldw	r3,128(sp)
80122ecc:	d8801f17 	ldw	r2,124(sp)
80122ed0:	da000404 	addi	r8,sp,16
80122ed4:	e47fef16 	blt	fp,r17,80122e94 <__reset+0xfa102e94>
80122ed8:	9021883a 	mov	r16,r18
80122edc:	b025883a 	mov	r18,r22
80122ee0:	882d883a 	mov	r22,r17
80122ee4:	dc403017 	ldw	r17,192(sp)
80122ee8:	d9002b17 	ldw	r4,172(sp)
80122eec:	1d87883a 	add	r3,r3,r22
80122ef0:	10800044 	addi	r2,r2,1
80122ef4:	41000015 	stw	r4,0(r8)
80122ef8:	45800115 	stw	r22,4(r8)
80122efc:	d8c02015 	stw	r3,128(sp)
80122f00:	d8801f15 	stw	r2,124(sp)
80122f04:	010001c4 	movi	r4,7
80122f08:	20819a16 	blt	r4,r2,80123574 <___svfprintf_internal_r+0x15e4>
80122f0c:	42000204 	addi	r8,r8,8
80122f10:	003e3506 	br	801227e8 <__reset+0xfa1027e8>
80122f14:	d9403317 	ldw	r5,204(sp)
80122f18:	00800044 	movi	r2,1
80122f1c:	18c00044 	addi	r3,r3,1
80122f20:	1141710e 	bge	r2,r5,801234e8 <___svfprintf_internal_r+0x1558>
80122f24:	dc401f17 	ldw	r17,124(sp)
80122f28:	00800044 	movi	r2,1
80122f2c:	40800115 	stw	r2,4(r8)
80122f30:	8c400044 	addi	r17,r17,1
80122f34:	44000015 	stw	r16,0(r8)
80122f38:	d8c02015 	stw	r3,128(sp)
80122f3c:	dc401f15 	stw	r17,124(sp)
80122f40:	008001c4 	movi	r2,7
80122f44:	14417416 	blt	r2,r17,80123518 <___svfprintf_internal_r+0x1588>
80122f48:	42000204 	addi	r8,r8,8
80122f4c:	d8803817 	ldw	r2,224(sp)
80122f50:	d9003417 	ldw	r4,208(sp)
80122f54:	8c400044 	addi	r17,r17,1
80122f58:	10c7883a 	add	r3,r2,r3
80122f5c:	40800115 	stw	r2,4(r8)
80122f60:	41000015 	stw	r4,0(r8)
80122f64:	d8c02015 	stw	r3,128(sp)
80122f68:	dc401f15 	stw	r17,124(sp)
80122f6c:	008001c4 	movi	r2,7
80122f70:	14417216 	blt	r2,r17,8012353c <___svfprintf_internal_r+0x15ac>
80122f74:	45800204 	addi	r22,r8,8
80122f78:	d9003617 	ldw	r4,216(sp)
80122f7c:	d9403717 	ldw	r5,220(sp)
80122f80:	000d883a 	mov	r6,zero
80122f84:	000f883a 	mov	r7,zero
80122f88:	d8c03d15 	stw	r3,244(sp)
80122f8c:	01316c40 	call	801316c4 <__eqdf2>
80122f90:	d8c03d17 	ldw	r3,244(sp)
80122f94:	1000b326 	beq	r2,zero,80123264 <___svfprintf_internal_r+0x12d4>
80122f98:	d9403317 	ldw	r5,204(sp)
80122f9c:	84000044 	addi	r16,r16,1
80122fa0:	8c400044 	addi	r17,r17,1
80122fa4:	28bfffc4 	addi	r2,r5,-1
80122fa8:	1887883a 	add	r3,r3,r2
80122fac:	b0800115 	stw	r2,4(r22)
80122fb0:	b4000015 	stw	r16,0(r22)
80122fb4:	d8c02015 	stw	r3,128(sp)
80122fb8:	dc401f15 	stw	r17,124(sp)
80122fbc:	008001c4 	movi	r2,7
80122fc0:	1440d216 	blt	r2,r17,8012330c <___svfprintf_internal_r+0x137c>
80122fc4:	b5800204 	addi	r22,r22,8
80122fc8:	d9003b17 	ldw	r4,236(sp)
80122fcc:	df0022c4 	addi	fp,sp,139
80122fd0:	8c400044 	addi	r17,r17,1
80122fd4:	20c7883a 	add	r3,r4,r3
80122fd8:	b7000015 	stw	fp,0(r22)
80122fdc:	b1000115 	stw	r4,4(r22)
80122fe0:	d8c02015 	stw	r3,128(sp)
80122fe4:	dc401f15 	stw	r17,124(sp)
80122fe8:	008001c4 	movi	r2,7
80122fec:	14400e16 	blt	r2,r17,80123028 <___svfprintf_internal_r+0x1098>
80122ff0:	b2000204 	addi	r8,r22,8
80122ff4:	003e3c06 	br	801228e8 <__reset+0xfa1028e8>
80122ff8:	01200534 	movhi	r4,32788
80122ffc:	211ed084 	addi	r4,r4,31554
80123000:	d9002b15 	stw	r4,172(sp)
80123004:	d9002b17 	ldw	r4,172(sp)
80123008:	1c07883a 	add	r3,r3,r16
8012300c:	44000115 	stw	r16,4(r8)
80123010:	41000015 	stw	r4,0(r8)
80123014:	10800044 	addi	r2,r2,1
80123018:	d8c02015 	stw	r3,128(sp)
8012301c:	d8801f15 	stw	r2,124(sp)
80123020:	010001c4 	movi	r4,7
80123024:	20be2f0e 	bge	r4,r2,801228e4 <__reset+0xfa1028e4>
80123028:	d9402c17 	ldw	r5,176(sp)
8012302c:	d9801e04 	addi	r6,sp,120
80123030:	9809883a 	mov	r4,r19
80123034:	012c9940 	call	8012c994 <__ssprint_r>
80123038:	103cbc1e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
8012303c:	d8c02017 	ldw	r3,128(sp)
80123040:	da000404 	addi	r8,sp,16
80123044:	003e2806 	br	801228e8 <__reset+0xfa1028e8>
80123048:	d9402c17 	ldw	r5,176(sp)
8012304c:	d9801e04 	addi	r6,sp,120
80123050:	9809883a 	mov	r4,r19
80123054:	012c9940 	call	8012c994 <__ssprint_r>
80123058:	103e5f26 	beq	r2,zero,801229d8 <__reset+0xfa1029d8>
8012305c:	003cb306 	br	8012232c <__reset+0xfa10232c>
80123060:	d9402c17 	ldw	r5,176(sp)
80123064:	d9801e04 	addi	r6,sp,120
80123068:	9809883a 	mov	r4,r19
8012306c:	012c9940 	call	8012c994 <__ssprint_r>
80123070:	103cae1e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123074:	d8c02017 	ldw	r3,128(sp)
80123078:	da000404 	addi	r8,sp,16
8012307c:	003e0d06 	br	801228b4 <__reset+0xfa1028b4>
80123080:	d9402c17 	ldw	r5,176(sp)
80123084:	d9801e04 	addi	r6,sp,120
80123088:	9809883a 	mov	r4,r19
8012308c:	012c9940 	call	8012c994 <__ssprint_r>
80123090:	103ca61e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123094:	d8c02017 	ldw	r3,128(sp)
80123098:	da000404 	addi	r8,sp,16
8012309c:	003dc106 	br	801227a4 <__reset+0xfa1027a4>
801230a0:	d9402c17 	ldw	r5,176(sp)
801230a4:	d9801e04 	addi	r6,sp,120
801230a8:	9809883a 	mov	r4,r19
801230ac:	012c9940 	call	8012c994 <__ssprint_r>
801230b0:	103c9e1e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
801230b4:	d8c02017 	ldw	r3,128(sp)
801230b8:	da000404 	addi	r8,sp,16
801230bc:	003dc706 	br	801227dc <__reset+0xfa1027dc>
801230c0:	d8802917 	ldw	r2,164(sp)
801230c4:	d8002785 	stb	zero,158(sp)
801230c8:	103f0816 	blt	r2,zero,80122cec <__reset+0xfa102cec>
801230cc:	00ffdfc4 	movi	r3,-129
801230d0:	a584b03a 	or	r2,r20,r22
801230d4:	90e4703a 	and	r18,r18,r3
801230d8:	103c8126 	beq	r2,zero,801222e0 <__reset+0xfa1022e0>
801230dc:	0039883a 	mov	fp,zero
801230e0:	003e7606 	br	80122abc <__reset+0xfa102abc>
801230e4:	9080040c 	andi	r2,r18,16
801230e8:	10013d26 	beq	r2,zero,801235e0 <___svfprintf_internal_r+0x1650>
801230ec:	d9002d17 	ldw	r4,180(sp)
801230f0:	d9402917 	ldw	r5,164(sp)
801230f4:	d8002785 	stb	zero,158(sp)
801230f8:	20800104 	addi	r2,r4,4
801230fc:	25000017 	ldw	r20,0(r4)
80123100:	002d883a 	mov	r22,zero
80123104:	28013f16 	blt	r5,zero,80123604 <___svfprintf_internal_r+0x1674>
80123108:	00ffdfc4 	movi	r3,-129
8012310c:	d8802d15 	stw	r2,180(sp)
80123110:	90e4703a 	and	r18,r18,r3
80123114:	a03d2b26 	beq	r20,zero,801225c4 <__reset+0xfa1025c4>
80123118:	0039883a 	mov	fp,zero
8012311c:	003d2e06 	br	801225d8 <__reset+0xfa1025d8>
80123120:	dc402617 	ldw	r17,152(sp)
80123124:	0441830e 	bge	zero,r17,80123734 <___svfprintf_internal_r+0x17a4>
80123128:	dc403217 	ldw	r17,200(sp)
8012312c:	d8803317 	ldw	r2,204(sp)
80123130:	1440010e 	bge	r2,r17,80123138 <___svfprintf_internal_r+0x11a8>
80123134:	1023883a 	mov	r17,r2
80123138:	04400a0e 	bge	zero,r17,80123164 <___svfprintf_internal_r+0x11d4>
8012313c:	d8801f17 	ldw	r2,124(sp)
80123140:	1c47883a 	add	r3,r3,r17
80123144:	44000015 	stw	r16,0(r8)
80123148:	10800044 	addi	r2,r2,1
8012314c:	44400115 	stw	r17,4(r8)
80123150:	d8c02015 	stw	r3,128(sp)
80123154:	d8801f15 	stw	r2,124(sp)
80123158:	010001c4 	movi	r4,7
8012315c:	20827516 	blt	r4,r2,80123b34 <___svfprintf_internal_r+0x1ba4>
80123160:	42000204 	addi	r8,r8,8
80123164:	88027b16 	blt	r17,zero,80123b54 <___svfprintf_internal_r+0x1bc4>
80123168:	d9003217 	ldw	r4,200(sp)
8012316c:	2463c83a 	sub	r17,r4,r17
80123170:	0440990e 	bge	zero,r17,801233d8 <___svfprintf_internal_r+0x1448>
80123174:	05800404 	movi	r22,16
80123178:	d8801f17 	ldw	r2,124(sp)
8012317c:	b441530e 	bge	r22,r17,801236cc <___svfprintf_internal_r+0x173c>
80123180:	01200534 	movhi	r4,32788
80123184:	211ed084 	addi	r4,r4,31554
80123188:	d9002b15 	stw	r4,172(sp)
8012318c:	070001c4 	movi	fp,7
80123190:	dd002c17 	ldw	r20,176(sp)
80123194:	00000306 	br	801231a4 <___svfprintf_internal_r+0x1214>
80123198:	42000204 	addi	r8,r8,8
8012319c:	8c7ffc04 	addi	r17,r17,-16
801231a0:	b4414d0e 	bge	r22,r17,801236d8 <___svfprintf_internal_r+0x1748>
801231a4:	18c00404 	addi	r3,r3,16
801231a8:	10800044 	addi	r2,r2,1
801231ac:	45400015 	stw	r21,0(r8)
801231b0:	45800115 	stw	r22,4(r8)
801231b4:	d8c02015 	stw	r3,128(sp)
801231b8:	d8801f15 	stw	r2,124(sp)
801231bc:	e0bff60e 	bge	fp,r2,80123198 <__reset+0xfa103198>
801231c0:	d9801e04 	addi	r6,sp,120
801231c4:	a00b883a 	mov	r5,r20
801231c8:	9809883a 	mov	r4,r19
801231cc:	012c9940 	call	8012c994 <__ssprint_r>
801231d0:	103c561e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
801231d4:	d8c02017 	ldw	r3,128(sp)
801231d8:	d8801f17 	ldw	r2,124(sp)
801231dc:	da000404 	addi	r8,sp,16
801231e0:	003fee06 	br	8012319c <__reset+0xfa10319c>
801231e4:	d9402c17 	ldw	r5,176(sp)
801231e8:	d9801e04 	addi	r6,sp,120
801231ec:	9809883a 	mov	r4,r19
801231f0:	012c9940 	call	8012c994 <__ssprint_r>
801231f4:	103c4d1e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
801231f8:	d8c02017 	ldw	r3,128(sp)
801231fc:	df002787 	ldb	fp,158(sp)
80123200:	da000404 	addi	r8,sp,16
80123204:	003d5a06 	br	80122770 <__reset+0xfa102770>
80123208:	9080040c 	andi	r2,r18,16
8012320c:	10005c26 	beq	r2,zero,80123380 <___svfprintf_internal_r+0x13f0>
80123210:	d9402d17 	ldw	r5,180(sp)
80123214:	d8c02917 	ldw	r3,164(sp)
80123218:	d8002785 	stb	zero,158(sp)
8012321c:	28800104 	addi	r2,r5,4
80123220:	2d000017 	ldw	r20,0(r5)
80123224:	002d883a 	mov	r22,zero
80123228:	18005e16 	blt	r3,zero,801233a4 <___svfprintf_internal_r+0x1414>
8012322c:	00ffdfc4 	movi	r3,-129
80123230:	d8802d15 	stw	r2,180(sp)
80123234:	90e4703a 	and	r18,r18,r3
80123238:	0039883a 	mov	fp,zero
8012323c:	a03dfe26 	beq	r20,zero,80122a38 <__reset+0xfa102a38>
80123240:	00800244 	movi	r2,9
80123244:	153cb336 	bltu	r2,r20,80122514 <__reset+0xfa102514>
80123248:	a5000c04 	addi	r20,r20,48
8012324c:	dc001dc4 	addi	r16,sp,119
80123250:	dd001dc5 	stb	r20,119(sp)
80123254:	d8c02817 	ldw	r3,160(sp)
80123258:	1c07c83a 	sub	r3,r3,r16
8012325c:	d8c02e15 	stw	r3,184(sp)
80123260:	003cf506 	br	80122638 <__reset+0xfa102638>
80123264:	d8803317 	ldw	r2,204(sp)
80123268:	143fffc4 	addi	r16,r2,-1
8012326c:	043f560e 	bge	zero,r16,80122fc8 <__reset+0xfa102fc8>
80123270:	07000404 	movi	fp,16
80123274:	e403530e 	bge	fp,r16,80123fc4 <___svfprintf_internal_r+0x2034>
80123278:	01600534 	movhi	r5,32788
8012327c:	295ed084 	addi	r5,r5,31554
80123280:	d9402b15 	stw	r5,172(sp)
80123284:	01c001c4 	movi	r7,7
80123288:	dd002c17 	ldw	r20,176(sp)
8012328c:	00000306 	br	8012329c <___svfprintf_internal_r+0x130c>
80123290:	843ffc04 	addi	r16,r16,-16
80123294:	b5800204 	addi	r22,r22,8
80123298:	e400130e 	bge	fp,r16,801232e8 <___svfprintf_internal_r+0x1358>
8012329c:	18c00404 	addi	r3,r3,16
801232a0:	8c400044 	addi	r17,r17,1
801232a4:	b5400015 	stw	r21,0(r22)
801232a8:	b7000115 	stw	fp,4(r22)
801232ac:	d8c02015 	stw	r3,128(sp)
801232b0:	dc401f15 	stw	r17,124(sp)
801232b4:	3c7ff60e 	bge	r7,r17,80123290 <__reset+0xfa103290>
801232b8:	d9801e04 	addi	r6,sp,120
801232bc:	a00b883a 	mov	r5,r20
801232c0:	9809883a 	mov	r4,r19
801232c4:	d9c03d15 	stw	r7,244(sp)
801232c8:	012c9940 	call	8012c994 <__ssprint_r>
801232cc:	d9c03d17 	ldw	r7,244(sp)
801232d0:	103c161e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
801232d4:	843ffc04 	addi	r16,r16,-16
801232d8:	d8c02017 	ldw	r3,128(sp)
801232dc:	dc401f17 	ldw	r17,124(sp)
801232e0:	dd800404 	addi	r22,sp,16
801232e4:	e43fed16 	blt	fp,r16,8012329c <__reset+0xfa10329c>
801232e8:	d8802b17 	ldw	r2,172(sp)
801232ec:	1c07883a 	add	r3,r3,r16
801232f0:	8c400044 	addi	r17,r17,1
801232f4:	b0800015 	stw	r2,0(r22)
801232f8:	b4000115 	stw	r16,4(r22)
801232fc:	d8c02015 	stw	r3,128(sp)
80123300:	dc401f15 	stw	r17,124(sp)
80123304:	008001c4 	movi	r2,7
80123308:	147f2e0e 	bge	r2,r17,80122fc4 <__reset+0xfa102fc4>
8012330c:	d9402c17 	ldw	r5,176(sp)
80123310:	d9801e04 	addi	r6,sp,120
80123314:	9809883a 	mov	r4,r19
80123318:	012c9940 	call	8012c994 <__ssprint_r>
8012331c:	103c031e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123320:	d8c02017 	ldw	r3,128(sp)
80123324:	dc401f17 	ldw	r17,124(sp)
80123328:	dd800404 	addi	r22,sp,16
8012332c:	003f2606 	br	80122fc8 <__reset+0xfa102fc8>
80123330:	9080040c 	andi	r2,r18,16
80123334:	1000c326 	beq	r2,zero,80123644 <___svfprintf_internal_r+0x16b4>
80123338:	d8802d17 	ldw	r2,180(sp)
8012333c:	15000017 	ldw	r20,0(r2)
80123340:	10800104 	addi	r2,r2,4
80123344:	d8802d15 	stw	r2,180(sp)
80123348:	a02dd7fa 	srai	r22,r20,31
8012334c:	b005883a 	mov	r2,r22
80123350:	103c680e 	bge	r2,zero,801224f4 <__reset+0xfa1024f4>
80123354:	0529c83a 	sub	r20,zero,r20
80123358:	a004c03a 	cmpne	r2,r20,zero
8012335c:	05adc83a 	sub	r22,zero,r22
80123360:	b0adc83a 	sub	r22,r22,r2
80123364:	d8802917 	ldw	r2,164(sp)
80123368:	07000b44 	movi	fp,45
8012336c:	df002785 	stb	fp,158(sp)
80123370:	10022e16 	blt	r2,zero,80123c2c <___svfprintf_internal_r+0x1c9c>
80123374:	00bfdfc4 	movi	r2,-129
80123378:	90a4703a 	and	r18,r18,r2
8012337c:	003c6406 	br	80122510 <__reset+0xfa102510>
80123380:	9080100c 	andi	r2,r18,64
80123384:	d8002785 	stb	zero,158(sp)
80123388:	10012526 	beq	r2,zero,80123820 <___svfprintf_internal_r+0x1890>
8012338c:	d9002d17 	ldw	r4,180(sp)
80123390:	d9402917 	ldw	r5,164(sp)
80123394:	002d883a 	mov	r22,zero
80123398:	20800104 	addi	r2,r4,4
8012339c:	2500000b 	ldhu	r20,0(r4)
801233a0:	283fa20e 	bge	r5,zero,8012322c <__reset+0xfa10322c>
801233a4:	d8802d15 	stw	r2,180(sp)
801233a8:	0039883a 	mov	fp,zero
801233ac:	a584b03a 	or	r2,r20,r22
801233b0:	103c571e 	bne	r2,zero,80122510 <__reset+0xfa102510>
801233b4:	00800044 	movi	r2,1
801233b8:	003e5006 	br	80122cfc <__reset+0xfa102cfc>
801233bc:	d9402c17 	ldw	r5,176(sp)
801233c0:	d9801e04 	addi	r6,sp,120
801233c4:	9809883a 	mov	r4,r19
801233c8:	012c9940 	call	8012c994 <__ssprint_r>
801233cc:	103bd71e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
801233d0:	d8c02017 	ldw	r3,128(sp)
801233d4:	da000404 	addi	r8,sp,16
801233d8:	d9003217 	ldw	r4,200(sp)
801233dc:	d8802617 	ldw	r2,152(sp)
801233e0:	d9403317 	ldw	r5,204(sp)
801233e4:	8123883a 	add	r17,r16,r4
801233e8:	11400216 	blt	r2,r5,801233f4 <___svfprintf_internal_r+0x1464>
801233ec:	9100004c 	andi	r4,r18,1
801233f0:	20000d26 	beq	r4,zero,80123428 <___svfprintf_internal_r+0x1498>
801233f4:	d9003817 	ldw	r4,224(sp)
801233f8:	d9403417 	ldw	r5,208(sp)
801233fc:	1907883a 	add	r3,r3,r4
80123400:	d9001f17 	ldw	r4,124(sp)
80123404:	41400015 	stw	r5,0(r8)
80123408:	d9403817 	ldw	r5,224(sp)
8012340c:	21000044 	addi	r4,r4,1
80123410:	d8c02015 	stw	r3,128(sp)
80123414:	41400115 	stw	r5,4(r8)
80123418:	d9001f15 	stw	r4,124(sp)
8012341c:	014001c4 	movi	r5,7
80123420:	2901dc16 	blt	r5,r4,80123b94 <___svfprintf_internal_r+0x1c04>
80123424:	42000204 	addi	r8,r8,8
80123428:	d9003317 	ldw	r4,204(sp)
8012342c:	8121883a 	add	r16,r16,r4
80123430:	2085c83a 	sub	r2,r4,r2
80123434:	8461c83a 	sub	r16,r16,r17
80123438:	1400010e 	bge	r2,r16,80123440 <___svfprintf_internal_r+0x14b0>
8012343c:	1021883a 	mov	r16,r2
80123440:	04000a0e 	bge	zero,r16,8012346c <___svfprintf_internal_r+0x14dc>
80123444:	d9001f17 	ldw	r4,124(sp)
80123448:	1c07883a 	add	r3,r3,r16
8012344c:	44400015 	stw	r17,0(r8)
80123450:	21000044 	addi	r4,r4,1
80123454:	44000115 	stw	r16,4(r8)
80123458:	d8c02015 	stw	r3,128(sp)
8012345c:	d9001f15 	stw	r4,124(sp)
80123460:	014001c4 	movi	r5,7
80123464:	2901e616 	blt	r5,r4,80123c00 <___svfprintf_internal_r+0x1c70>
80123468:	42000204 	addi	r8,r8,8
8012346c:	8001f616 	blt	r16,zero,80123c48 <___svfprintf_internal_r+0x1cb8>
80123470:	1421c83a 	sub	r16,r2,r16
80123474:	043d1c0e 	bge	zero,r16,801228e8 <__reset+0xfa1028e8>
80123478:	04400404 	movi	r17,16
8012347c:	d8801f17 	ldw	r2,124(sp)
80123480:	8c3edd0e 	bge	r17,r16,80122ff8 <__reset+0xfa102ff8>
80123484:	01600534 	movhi	r5,32788
80123488:	295ed084 	addi	r5,r5,31554
8012348c:	d9402b15 	stw	r5,172(sp)
80123490:	058001c4 	movi	r22,7
80123494:	dd002c17 	ldw	r20,176(sp)
80123498:	00000306 	br	801234a8 <___svfprintf_internal_r+0x1518>
8012349c:	42000204 	addi	r8,r8,8
801234a0:	843ffc04 	addi	r16,r16,-16
801234a4:	8c3ed70e 	bge	r17,r16,80123004 <__reset+0xfa103004>
801234a8:	18c00404 	addi	r3,r3,16
801234ac:	10800044 	addi	r2,r2,1
801234b0:	45400015 	stw	r21,0(r8)
801234b4:	44400115 	stw	r17,4(r8)
801234b8:	d8c02015 	stw	r3,128(sp)
801234bc:	d8801f15 	stw	r2,124(sp)
801234c0:	b0bff60e 	bge	r22,r2,8012349c <__reset+0xfa10349c>
801234c4:	d9801e04 	addi	r6,sp,120
801234c8:	a00b883a 	mov	r5,r20
801234cc:	9809883a 	mov	r4,r19
801234d0:	012c9940 	call	8012c994 <__ssprint_r>
801234d4:	103b951e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
801234d8:	d8c02017 	ldw	r3,128(sp)
801234dc:	d8801f17 	ldw	r2,124(sp)
801234e0:	da000404 	addi	r8,sp,16
801234e4:	003fee06 	br	801234a0 <__reset+0xfa1034a0>
801234e8:	9088703a 	and	r4,r18,r2
801234ec:	203e8d1e 	bne	r4,zero,80122f24 <__reset+0xfa102f24>
801234f0:	dc401f17 	ldw	r17,124(sp)
801234f4:	40800115 	stw	r2,4(r8)
801234f8:	44000015 	stw	r16,0(r8)
801234fc:	8c400044 	addi	r17,r17,1
80123500:	d8c02015 	stw	r3,128(sp)
80123504:	dc401f15 	stw	r17,124(sp)
80123508:	008001c4 	movi	r2,7
8012350c:	147f7f16 	blt	r2,r17,8012330c <__reset+0xfa10330c>
80123510:	45800204 	addi	r22,r8,8
80123514:	003eac06 	br	80122fc8 <__reset+0xfa102fc8>
80123518:	d9402c17 	ldw	r5,176(sp)
8012351c:	d9801e04 	addi	r6,sp,120
80123520:	9809883a 	mov	r4,r19
80123524:	012c9940 	call	8012c994 <__ssprint_r>
80123528:	103b801e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
8012352c:	d8c02017 	ldw	r3,128(sp)
80123530:	dc401f17 	ldw	r17,124(sp)
80123534:	da000404 	addi	r8,sp,16
80123538:	003e8406 	br	80122f4c <__reset+0xfa102f4c>
8012353c:	d9402c17 	ldw	r5,176(sp)
80123540:	d9801e04 	addi	r6,sp,120
80123544:	9809883a 	mov	r4,r19
80123548:	012c9940 	call	8012c994 <__ssprint_r>
8012354c:	103b771e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123550:	d8c02017 	ldw	r3,128(sp)
80123554:	dc401f17 	ldw	r17,124(sp)
80123558:	dd800404 	addi	r22,sp,16
8012355c:	003e8606 	br	80122f78 <__reset+0xfa102f78>
80123560:	0029883a 	mov	r20,zero
80123564:	a5000c04 	addi	r20,r20,48
80123568:	dc001dc4 	addi	r16,sp,119
8012356c:	dd001dc5 	stb	r20,119(sp)
80123570:	003f3806 	br	80123254 <__reset+0xfa103254>
80123574:	d9402c17 	ldw	r5,176(sp)
80123578:	d9801e04 	addi	r6,sp,120
8012357c:	9809883a 	mov	r4,r19
80123580:	012c9940 	call	8012c994 <__ssprint_r>
80123584:	103b691e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123588:	d8c02017 	ldw	r3,128(sp)
8012358c:	da000404 	addi	r8,sp,16
80123590:	003c9506 	br	801227e8 <__reset+0xfa1027e8>
80123594:	d9003617 	ldw	r4,216(sp)
80123598:	d9403717 	ldw	r5,220(sp)
8012359c:	da003e15 	stw	r8,248(sp)
801235a0:	012a8e00 	call	8012a8e0 <__fpclassifyd>
801235a4:	da003e17 	ldw	r8,248(sp)
801235a8:	1000bd1e 	bne	r2,zero,801238a0 <___svfprintf_internal_r+0x1910>
801235ac:	008011c4 	movi	r2,71
801235b0:	14411e0e 	bge	r2,r17,80123a2c <___svfprintf_internal_r+0x1a9c>
801235b4:	04200534 	movhi	r16,32788
801235b8:	841ec304 	addi	r16,r16,31500
801235bc:	00c000c4 	movi	r3,3
801235c0:	00bfdfc4 	movi	r2,-129
801235c4:	d8c02a15 	stw	r3,168(sp)
801235c8:	90a4703a 	and	r18,r18,r2
801235cc:	df002783 	ldbu	fp,158(sp)
801235d0:	d8c02e15 	stw	r3,184(sp)
801235d4:	d8002915 	stw	zero,164(sp)
801235d8:	d8003215 	stw	zero,200(sp)
801235dc:	003c1c06 	br	80122650 <__reset+0xfa102650>
801235e0:	9080100c 	andi	r2,r18,64
801235e4:	d8002785 	stb	zero,158(sp)
801235e8:	10009426 	beq	r2,zero,8012383c <___svfprintf_internal_r+0x18ac>
801235ec:	d8c02d17 	ldw	r3,180(sp)
801235f0:	d9002917 	ldw	r4,164(sp)
801235f4:	002d883a 	mov	r22,zero
801235f8:	18800104 	addi	r2,r3,4
801235fc:	1d00000b 	ldhu	r20,0(r3)
80123600:	203ec10e 	bge	r4,zero,80123108 <__reset+0xfa103108>
80123604:	a586b03a 	or	r3,r20,r22
80123608:	d8802d15 	stw	r2,180(sp)
8012360c:	183ec21e 	bne	r3,zero,80123118 <__reset+0xfa103118>
80123610:	0039883a 	mov	fp,zero
80123614:	0005883a 	mov	r2,zero
80123618:	003db806 	br	80122cfc <__reset+0xfa102cfc>
8012361c:	d8802d17 	ldw	r2,180(sp)
80123620:	d8c02d17 	ldw	r3,180(sp)
80123624:	d9002d17 	ldw	r4,180(sp)
80123628:	10800017 	ldw	r2,0(r2)
8012362c:	18c00117 	ldw	r3,4(r3)
80123630:	21000204 	addi	r4,r4,8
80123634:	d8803615 	stw	r2,216(sp)
80123638:	d8c03715 	stw	r3,220(sp)
8012363c:	d9002d15 	stw	r4,180(sp)
80123640:	003b8206 	br	8012244c <__reset+0xfa10244c>
80123644:	9080100c 	andi	r2,r18,64
80123648:	10010726 	beq	r2,zero,80123a68 <___svfprintf_internal_r+0x1ad8>
8012364c:	d8c02d17 	ldw	r3,180(sp)
80123650:	1d00000f 	ldh	r20,0(r3)
80123654:	18c00104 	addi	r3,r3,4
80123658:	d8c02d15 	stw	r3,180(sp)
8012365c:	a02dd7fa 	srai	r22,r20,31
80123660:	b005883a 	mov	r2,r22
80123664:	003ba206 	br	801224f0 <__reset+0xfa1024f0>
80123668:	9080100c 	andi	r2,r18,64
8012366c:	10010526 	beq	r2,zero,80123a84 <___svfprintf_internal_r+0x1af4>
80123670:	d9002d17 	ldw	r4,180(sp)
80123674:	002d883a 	mov	r22,zero
80123678:	2500000b 	ldhu	r20,0(r4)
8012367c:	21000104 	addi	r4,r4,4
80123680:	d9002d15 	stw	r4,180(sp)
80123684:	003cfe06 	br	80122a80 <__reset+0xfa102a80>
80123688:	bc400007 	ldb	r17,0(r23)
8012368c:	003a9606 	br	801220e8 <__reset+0xfa1020e8>
80123690:	9080040c 	andi	r2,r18,16
80123694:	10010126 	beq	r2,zero,80123a9c <___svfprintf_internal_r+0x1b0c>
80123698:	d9402d17 	ldw	r5,180(sp)
8012369c:	d8c02f17 	ldw	r3,188(sp)
801236a0:	28800017 	ldw	r2,0(r5)
801236a4:	29400104 	addi	r5,r5,4
801236a8:	d9402d15 	stw	r5,180(sp)
801236ac:	10c00015 	stw	r3,0(r2)
801236b0:	003a6406 	br	80122044 <__reset+0xfa102044>
801236b4:	d9002917 	ldw	r4,164(sp)
801236b8:	d8002785 	stb	zero,158(sp)
801236bc:	203d8d16 	blt	r4,zero,80122cf4 <__reset+0xfa102cf4>
801236c0:	00bfdfc4 	movi	r2,-129
801236c4:	90a4703a 	and	r18,r18,r2
801236c8:	003b0506 	br	801222e0 <__reset+0xfa1022e0>
801236cc:	01600534 	movhi	r5,32788
801236d0:	295ed084 	addi	r5,r5,31554
801236d4:	d9402b15 	stw	r5,172(sp)
801236d8:	d9402b17 	ldw	r5,172(sp)
801236dc:	1c47883a 	add	r3,r3,r17
801236e0:	10800044 	addi	r2,r2,1
801236e4:	41400015 	stw	r5,0(r8)
801236e8:	44400115 	stw	r17,4(r8)
801236ec:	d8c02015 	stw	r3,128(sp)
801236f0:	d8801f15 	stw	r2,124(sp)
801236f4:	010001c4 	movi	r4,7
801236f8:	20bf3016 	blt	r4,r2,801233bc <__reset+0xfa1033bc>
801236fc:	42000204 	addi	r8,r8,8
80123700:	003f3506 	br	801233d8 <__reset+0xfa1033d8>
80123704:	01200534 	movhi	r4,32788
80123708:	211ed084 	addi	r4,r4,31554
8012370c:	d9002b15 	stw	r4,172(sp)
80123710:	003c5e06 	br	8012288c <__reset+0xfa10288c>
80123714:	d9402c17 	ldw	r5,176(sp)
80123718:	d9801e04 	addi	r6,sp,120
8012371c:	9809883a 	mov	r4,r19
80123720:	012c9940 	call	8012c994 <__ssprint_r>
80123724:	103b011e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123728:	d8c02017 	ldw	r3,128(sp)
8012372c:	da000404 	addi	r8,sp,16
80123730:	003d9306 	br	80122d80 <__reset+0xfa102d80>
80123734:	d8801f17 	ldw	r2,124(sp)
80123738:	01600534 	movhi	r5,32788
8012373c:	01000044 	movi	r4,1
80123740:	18c00044 	addi	r3,r3,1
80123744:	10800044 	addi	r2,r2,1
80123748:	295ed004 	addi	r5,r5,31552
8012374c:	41000115 	stw	r4,4(r8)
80123750:	41400015 	stw	r5,0(r8)
80123754:	d8c02015 	stw	r3,128(sp)
80123758:	d8801f15 	stw	r2,124(sp)
8012375c:	010001c4 	movi	r4,7
80123760:	2080b516 	blt	r4,r2,80123a38 <___svfprintf_internal_r+0x1aa8>
80123764:	42000204 	addi	r8,r8,8
80123768:	8800041e 	bne	r17,zero,8012377c <___svfprintf_internal_r+0x17ec>
8012376c:	d8803317 	ldw	r2,204(sp)
80123770:	1000021e 	bne	r2,zero,8012377c <___svfprintf_internal_r+0x17ec>
80123774:	9080004c 	andi	r2,r18,1
80123778:	103c5b26 	beq	r2,zero,801228e8 <__reset+0xfa1028e8>
8012377c:	d9003817 	ldw	r4,224(sp)
80123780:	d8801f17 	ldw	r2,124(sp)
80123784:	d9403417 	ldw	r5,208(sp)
80123788:	20c7883a 	add	r3,r4,r3
8012378c:	10800044 	addi	r2,r2,1
80123790:	41000115 	stw	r4,4(r8)
80123794:	41400015 	stw	r5,0(r8)
80123798:	d8c02015 	stw	r3,128(sp)
8012379c:	d8801f15 	stw	r2,124(sp)
801237a0:	010001c4 	movi	r4,7
801237a4:	20818016 	blt	r4,r2,80123da8 <___svfprintf_internal_r+0x1e18>
801237a8:	42000204 	addi	r8,r8,8
801237ac:	0463c83a 	sub	r17,zero,r17
801237b0:	0440cb0e 	bge	zero,r17,80123ae0 <___svfprintf_internal_r+0x1b50>
801237b4:	05800404 	movi	r22,16
801237b8:	b440e80e 	bge	r22,r17,80123b5c <___svfprintf_internal_r+0x1bcc>
801237bc:	01600534 	movhi	r5,32788
801237c0:	295ed084 	addi	r5,r5,31554
801237c4:	d9402b15 	stw	r5,172(sp)
801237c8:	070001c4 	movi	fp,7
801237cc:	dd002c17 	ldw	r20,176(sp)
801237d0:	00000306 	br	801237e0 <___svfprintf_internal_r+0x1850>
801237d4:	42000204 	addi	r8,r8,8
801237d8:	8c7ffc04 	addi	r17,r17,-16
801237dc:	b440e20e 	bge	r22,r17,80123b68 <___svfprintf_internal_r+0x1bd8>
801237e0:	18c00404 	addi	r3,r3,16
801237e4:	10800044 	addi	r2,r2,1
801237e8:	45400015 	stw	r21,0(r8)
801237ec:	45800115 	stw	r22,4(r8)
801237f0:	d8c02015 	stw	r3,128(sp)
801237f4:	d8801f15 	stw	r2,124(sp)
801237f8:	e0bff60e 	bge	fp,r2,801237d4 <__reset+0xfa1037d4>
801237fc:	d9801e04 	addi	r6,sp,120
80123800:	a00b883a 	mov	r5,r20
80123804:	9809883a 	mov	r4,r19
80123808:	012c9940 	call	8012c994 <__ssprint_r>
8012380c:	103ac71e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123810:	d8c02017 	ldw	r3,128(sp)
80123814:	d8801f17 	ldw	r2,124(sp)
80123818:	da000404 	addi	r8,sp,16
8012381c:	003fee06 	br	801237d8 <__reset+0xfa1037d8>
80123820:	d8c02d17 	ldw	r3,180(sp)
80123824:	d9002917 	ldw	r4,164(sp)
80123828:	002d883a 	mov	r22,zero
8012382c:	18800104 	addi	r2,r3,4
80123830:	1d000017 	ldw	r20,0(r3)
80123834:	203e7d0e 	bge	r4,zero,8012322c <__reset+0xfa10322c>
80123838:	003eda06 	br	801233a4 <__reset+0xfa1033a4>
8012383c:	d9402d17 	ldw	r5,180(sp)
80123840:	d8c02917 	ldw	r3,164(sp)
80123844:	002d883a 	mov	r22,zero
80123848:	28800104 	addi	r2,r5,4
8012384c:	2d000017 	ldw	r20,0(r5)
80123850:	183e2d0e 	bge	r3,zero,80123108 <__reset+0xfa103108>
80123854:	003f6b06 	br	80123604 <__reset+0xfa103604>
80123858:	d8c02d15 	stw	r3,180(sp)
8012385c:	0039883a 	mov	fp,zero
80123860:	003ed206 	br	801233ac <__reset+0xfa1033ac>
80123864:	bc400043 	ldbu	r17,1(r23)
80123868:	94800814 	ori	r18,r18,32
8012386c:	bdc00044 	addi	r23,r23,1
80123870:	8c403fcc 	andi	r17,r17,255
80123874:	8c40201c 	xori	r17,r17,128
80123878:	8c7fe004 	addi	r17,r17,-128
8012387c:	003a1a06 	br	801220e8 <__reset+0xfa1020e8>
80123880:	d9402c17 	ldw	r5,176(sp)
80123884:	d9801e04 	addi	r6,sp,120
80123888:	9809883a 	mov	r4,r19
8012388c:	012c9940 	call	8012c994 <__ssprint_r>
80123890:	103aa61e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123894:	d8c02017 	ldw	r3,128(sp)
80123898:	da000404 	addi	r8,sp,16
8012389c:	003d4a06 	br	80122dc8 <__reset+0xfa102dc8>
801238a0:	d9002917 	ldw	r4,164(sp)
801238a4:	05bff7c4 	movi	r22,-33
801238a8:	00bfffc4 	movi	r2,-1
801238ac:	8dac703a 	and	r22,r17,r22
801238b0:	20806a26 	beq	r4,r2,80123a5c <___svfprintf_internal_r+0x1acc>
801238b4:	008011c4 	movi	r2,71
801238b8:	b0813726 	beq	r22,r2,80123d98 <___svfprintf_internal_r+0x1e08>
801238bc:	d9003717 	ldw	r4,220(sp)
801238c0:	90c04014 	ori	r3,r18,256
801238c4:	d8c02b15 	stw	r3,172(sp)
801238c8:	20015d16 	blt	r4,zero,80123e40 <___svfprintf_internal_r+0x1eb0>
801238cc:	dd003717 	ldw	r20,220(sp)
801238d0:	d8002a05 	stb	zero,168(sp)
801238d4:	00801984 	movi	r2,102
801238d8:	88814026 	beq	r17,r2,80123ddc <___svfprintf_internal_r+0x1e4c>
801238dc:	00801184 	movi	r2,70
801238e0:	88817126 	beq	r17,r2,80123ea8 <___svfprintf_internal_r+0x1f18>
801238e4:	00801144 	movi	r2,69
801238e8:	b0816226 	beq	r22,r2,80123e74 <___svfprintf_internal_r+0x1ee4>
801238ec:	d8c02917 	ldw	r3,164(sp)
801238f0:	d8802104 	addi	r2,sp,132
801238f4:	d8800315 	stw	r2,12(sp)
801238f8:	d9403617 	ldw	r5,216(sp)
801238fc:	d8802504 	addi	r2,sp,148
80123900:	d8800215 	stw	r2,8(sp)
80123904:	d8802604 	addi	r2,sp,152
80123908:	d8c00015 	stw	r3,0(sp)
8012390c:	d8800115 	stw	r2,4(sp)
80123910:	01c00084 	movi	r7,2
80123914:	a00d883a 	mov	r6,r20
80123918:	9809883a 	mov	r4,r19
8012391c:	d8c03d15 	stw	r3,244(sp)
80123920:	da003e15 	stw	r8,248(sp)
80123924:	0125c1c0 	call	80125c1c <_dtoa_r>
80123928:	1021883a 	mov	r16,r2
8012392c:	008019c4 	movi	r2,103
80123930:	d8c03d17 	ldw	r3,244(sp)
80123934:	da003e17 	ldw	r8,248(sp)
80123938:	8880e726 	beq	r17,r2,80123cd8 <___svfprintf_internal_r+0x1d48>
8012393c:	008011c4 	movi	r2,71
80123940:	8880d426 	beq	r17,r2,80123c94 <___svfprintf_internal_r+0x1d04>
80123944:	80f9883a 	add	fp,r16,r3
80123948:	d9003617 	ldw	r4,216(sp)
8012394c:	000d883a 	mov	r6,zero
80123950:	000f883a 	mov	r7,zero
80123954:	a00b883a 	mov	r5,r20
80123958:	da003e15 	stw	r8,248(sp)
8012395c:	01316c40 	call	801316c4 <__eqdf2>
80123960:	da003e17 	ldw	r8,248(sp)
80123964:	1000e426 	beq	r2,zero,80123cf8 <___svfprintf_internal_r+0x1d68>
80123968:	d8802117 	ldw	r2,132(sp)
8012396c:	1700062e 	bgeu	r2,fp,80123988 <___svfprintf_internal_r+0x19f8>
80123970:	01000c04 	movi	r4,48
80123974:	10c00044 	addi	r3,r2,1
80123978:	d8c02115 	stw	r3,132(sp)
8012397c:	11000005 	stb	r4,0(r2)
80123980:	d8802117 	ldw	r2,132(sp)
80123984:	173ffb36 	bltu	r2,fp,80123974 <__reset+0xfa103974>
80123988:	1405c83a 	sub	r2,r2,r16
8012398c:	d8803315 	stw	r2,204(sp)
80123990:	008011c4 	movi	r2,71
80123994:	b080c526 	beq	r22,r2,80123cac <___svfprintf_internal_r+0x1d1c>
80123998:	00801944 	movi	r2,101
8012399c:	1441d90e 	bge	r2,r17,80124104 <___svfprintf_internal_r+0x2174>
801239a0:	d8c02617 	ldw	r3,152(sp)
801239a4:	00801984 	movi	r2,102
801239a8:	d8c03215 	stw	r3,200(sp)
801239ac:	88813426 	beq	r17,r2,80123e80 <___svfprintf_internal_r+0x1ef0>
801239b0:	d8c03217 	ldw	r3,200(sp)
801239b4:	d9003317 	ldw	r4,204(sp)
801239b8:	19012516 	blt	r3,r4,80123e50 <___svfprintf_internal_r+0x1ec0>
801239bc:	9480004c 	andi	r18,r18,1
801239c0:	9001841e 	bne	r18,zero,80123fd4 <___svfprintf_internal_r+0x2044>
801239c4:	1805883a 	mov	r2,r3
801239c8:	1801cc16 	blt	r3,zero,801240fc <___svfprintf_internal_r+0x216c>
801239cc:	d8c03217 	ldw	r3,200(sp)
801239d0:	044019c4 	movi	r17,103
801239d4:	d8c02e15 	stw	r3,184(sp)
801239d8:	df002a07 	ldb	fp,168(sp)
801239dc:	e000a61e 	bne	fp,zero,80123c78 <___svfprintf_internal_r+0x1ce8>
801239e0:	df002783 	ldbu	fp,158(sp)
801239e4:	d8802a15 	stw	r2,168(sp)
801239e8:	dc802b17 	ldw	r18,172(sp)
801239ec:	d8002915 	stw	zero,164(sp)
801239f0:	003b1706 	br	80122650 <__reset+0xfa102650>
801239f4:	04200534 	movhi	r16,32788
801239f8:	841ec004 	addi	r16,r16,31488
801239fc:	003aa606 	br	80122498 <__reset+0xfa102498>
80123a00:	d9003917 	ldw	r4,228(sp)
80123a04:	04001004 	movi	r16,64
80123a08:	800b883a 	mov	r5,r16
80123a0c:	01284880 	call	80128488 <_malloc_r>
80123a10:	d9002c17 	ldw	r4,176(sp)
80123a14:	20800015 	stw	r2,0(r4)
80123a18:	20800415 	stw	r2,16(r4)
80123a1c:	1001cb26 	beq	r2,zero,8012414c <___svfprintf_internal_r+0x21bc>
80123a20:	d8802c17 	ldw	r2,176(sp)
80123a24:	14000515 	stw	r16,20(r2)
80123a28:	00397606 	br	80122004 <__reset+0xfa102004>
80123a2c:	04200534 	movhi	r16,32788
80123a30:	841ec204 	addi	r16,r16,31496
80123a34:	003ee106 	br	801235bc <__reset+0xfa1035bc>
80123a38:	d9402c17 	ldw	r5,176(sp)
80123a3c:	d9801e04 	addi	r6,sp,120
80123a40:	9809883a 	mov	r4,r19
80123a44:	012c9940 	call	8012c994 <__ssprint_r>
80123a48:	103a381e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123a4c:	dc402617 	ldw	r17,152(sp)
80123a50:	d8c02017 	ldw	r3,128(sp)
80123a54:	da000404 	addi	r8,sp,16
80123a58:	003f4306 	br	80123768 <__reset+0xfa103768>
80123a5c:	01400184 	movi	r5,6
80123a60:	d9402915 	stw	r5,164(sp)
80123a64:	003f9506 	br	801238bc <__reset+0xfa1038bc>
80123a68:	d9002d17 	ldw	r4,180(sp)
80123a6c:	25000017 	ldw	r20,0(r4)
80123a70:	21000104 	addi	r4,r4,4
80123a74:	d9002d15 	stw	r4,180(sp)
80123a78:	a02dd7fa 	srai	r22,r20,31
80123a7c:	b005883a 	mov	r2,r22
80123a80:	003a9b06 	br	801224f0 <__reset+0xfa1024f0>
80123a84:	d9402d17 	ldw	r5,180(sp)
80123a88:	002d883a 	mov	r22,zero
80123a8c:	2d000017 	ldw	r20,0(r5)
80123a90:	29400104 	addi	r5,r5,4
80123a94:	d9402d15 	stw	r5,180(sp)
80123a98:	003bf906 	br	80122a80 <__reset+0xfa102a80>
80123a9c:	9480100c 	andi	r18,r18,64
80123aa0:	90006e26 	beq	r18,zero,80123c5c <___svfprintf_internal_r+0x1ccc>
80123aa4:	d9002d17 	ldw	r4,180(sp)
80123aa8:	d9402f17 	ldw	r5,188(sp)
80123aac:	20800017 	ldw	r2,0(r4)
80123ab0:	21000104 	addi	r4,r4,4
80123ab4:	d9002d15 	stw	r4,180(sp)
80123ab8:	1140000d 	sth	r5,0(r2)
80123abc:	00396106 	br	80122044 <__reset+0xfa102044>
80123ac0:	d9402c17 	ldw	r5,176(sp)
80123ac4:	d9801e04 	addi	r6,sp,120
80123ac8:	9809883a 	mov	r4,r19
80123acc:	012c9940 	call	8012c994 <__ssprint_r>
80123ad0:	103a161e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123ad4:	d8c02017 	ldw	r3,128(sp)
80123ad8:	d8801f17 	ldw	r2,124(sp)
80123adc:	da000404 	addi	r8,sp,16
80123ae0:	d9403317 	ldw	r5,204(sp)
80123ae4:	10800044 	addi	r2,r2,1
80123ae8:	44000015 	stw	r16,0(r8)
80123aec:	28c7883a 	add	r3,r5,r3
80123af0:	003b7706 	br	801228d0 <__reset+0xfa1028d0>
80123af4:	8009883a 	mov	r4,r16
80123af8:	da003e15 	stw	r8,248(sp)
80123afc:	01219540 	call	80121954 <strlen>
80123b00:	d8802e15 	stw	r2,184(sp)
80123b04:	da003e17 	ldw	r8,248(sp)
80123b08:	103c280e 	bge	r2,zero,80122bac <__reset+0xfa102bac>
80123b0c:	0005883a 	mov	r2,zero
80123b10:	003c2606 	br	80122bac <__reset+0xfa102bac>
80123b14:	00bfffc4 	movi	r2,-1
80123b18:	003a0906 	br	80122340 <__reset+0xfa102340>
80123b1c:	01200534 	movhi	r4,32788
80123b20:	211ed484 	addi	r4,r4,31570
80123b24:	d9003515 	stw	r4,212(sp)
80123b28:	003b0606 	br	80122744 <__reset+0xfa102744>
80123b2c:	013fffc4 	movi	r4,-1
80123b30:	003a2706 	br	801223d0 <__reset+0xfa1023d0>
80123b34:	d9402c17 	ldw	r5,176(sp)
80123b38:	d9801e04 	addi	r6,sp,120
80123b3c:	9809883a 	mov	r4,r19
80123b40:	012c9940 	call	8012c994 <__ssprint_r>
80123b44:	1039f91e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123b48:	d8c02017 	ldw	r3,128(sp)
80123b4c:	da000404 	addi	r8,sp,16
80123b50:	003d8406 	br	80123164 <__reset+0xfa103164>
80123b54:	0023883a 	mov	r17,zero
80123b58:	003d8306 	br	80123168 <__reset+0xfa103168>
80123b5c:	01200534 	movhi	r4,32788
80123b60:	211ed084 	addi	r4,r4,31554
80123b64:	d9002b15 	stw	r4,172(sp)
80123b68:	d9002b17 	ldw	r4,172(sp)
80123b6c:	1c47883a 	add	r3,r3,r17
80123b70:	10800044 	addi	r2,r2,1
80123b74:	41000015 	stw	r4,0(r8)
80123b78:	44400115 	stw	r17,4(r8)
80123b7c:	d8c02015 	stw	r3,128(sp)
80123b80:	d8801f15 	stw	r2,124(sp)
80123b84:	010001c4 	movi	r4,7
80123b88:	20bfcd16 	blt	r4,r2,80123ac0 <__reset+0xfa103ac0>
80123b8c:	42000204 	addi	r8,r8,8
80123b90:	003fd306 	br	80123ae0 <__reset+0xfa103ae0>
80123b94:	d9402c17 	ldw	r5,176(sp)
80123b98:	d9801e04 	addi	r6,sp,120
80123b9c:	9809883a 	mov	r4,r19
80123ba0:	012c9940 	call	8012c994 <__ssprint_r>
80123ba4:	1039e11e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123ba8:	d8802617 	ldw	r2,152(sp)
80123bac:	d8c02017 	ldw	r3,128(sp)
80123bb0:	da000404 	addi	r8,sp,16
80123bb4:	003e1c06 	br	80123428 <__reset+0xfa103428>
80123bb8:	d8802917 	ldw	r2,164(sp)
80123bbc:	00c00184 	movi	r3,6
80123bc0:	1880012e 	bgeu	r3,r2,80123bc8 <___svfprintf_internal_r+0x1c38>
80123bc4:	1805883a 	mov	r2,r3
80123bc8:	d8802e15 	stw	r2,184(sp)
80123bcc:	1000f316 	blt	r2,zero,80123f9c <___svfprintf_internal_r+0x200c>
80123bd0:	04200534 	movhi	r16,32788
80123bd4:	d8802a15 	stw	r2,168(sp)
80123bd8:	dd002d15 	stw	r20,180(sp)
80123bdc:	d8002915 	stw	zero,164(sp)
80123be0:	d8003215 	stw	zero,200(sp)
80123be4:	841ece04 	addi	r16,r16,31544
80123be8:	0039883a 	mov	fp,zero
80123bec:	003a9f06 	br	8012266c <__reset+0xfa10266c>
80123bf0:	01200534 	movhi	r4,32788
80123bf4:	211ed484 	addi	r4,r4,31570
80123bf8:	d9003515 	stw	r4,212(sp)
80123bfc:	003b5f06 	br	8012297c <__reset+0xfa10297c>
80123c00:	d9402c17 	ldw	r5,176(sp)
80123c04:	d9801e04 	addi	r6,sp,120
80123c08:	9809883a 	mov	r4,r19
80123c0c:	012c9940 	call	8012c994 <__ssprint_r>
80123c10:	1039c61e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123c14:	d8802617 	ldw	r2,152(sp)
80123c18:	d9403317 	ldw	r5,204(sp)
80123c1c:	d8c02017 	ldw	r3,128(sp)
80123c20:	da000404 	addi	r8,sp,16
80123c24:	2885c83a 	sub	r2,r5,r2
80123c28:	003e1006 	br	8012346c <__reset+0xfa10346c>
80123c2c:	00800044 	movi	r2,1
80123c30:	10803fcc 	andi	r2,r2,255
80123c34:	00c00044 	movi	r3,1
80123c38:	10fa3526 	beq	r2,r3,80122510 <__reset+0xfa102510>
80123c3c:	00c00084 	movi	r3,2
80123c40:	10fb9e26 	beq	r2,r3,80122abc <__reset+0xfa102abc>
80123c44:	003a6406 	br	801225d8 <__reset+0xfa1025d8>
80123c48:	0021883a 	mov	r16,zero
80123c4c:	003e0806 	br	80123470 <__reset+0xfa103470>
80123c50:	07000b44 	movi	fp,45
80123c54:	df002785 	stb	fp,158(sp)
80123c58:	003a0b06 	br	80122488 <__reset+0xfa102488>
80123c5c:	d8c02d17 	ldw	r3,180(sp)
80123c60:	d9002f17 	ldw	r4,188(sp)
80123c64:	18800017 	ldw	r2,0(r3)
80123c68:	18c00104 	addi	r3,r3,4
80123c6c:	d8c02d15 	stw	r3,180(sp)
80123c70:	11000015 	stw	r4,0(r2)
80123c74:	0038f306 	br	80122044 <__reset+0xfa102044>
80123c78:	00c00b44 	movi	r3,45
80123c7c:	d8c02785 	stb	r3,158(sp)
80123c80:	d8802a15 	stw	r2,168(sp)
80123c84:	dc802b17 	ldw	r18,172(sp)
80123c88:	d8002915 	stw	zero,164(sp)
80123c8c:	07000b44 	movi	fp,45
80123c90:	003a7306 	br	80122660 <__reset+0xfa102660>
80123c94:	9080004c 	andi	r2,r18,1
80123c98:	1000941e 	bne	r2,zero,80123eec <___svfprintf_internal_r+0x1f5c>
80123c9c:	d8802117 	ldw	r2,132(sp)
80123ca0:	1405c83a 	sub	r2,r2,r16
80123ca4:	d8803315 	stw	r2,204(sp)
80123ca8:	b441161e 	bne	r22,r17,80124104 <___svfprintf_internal_r+0x2174>
80123cac:	dd802617 	ldw	r22,152(sp)
80123cb0:	00bfff44 	movi	r2,-3
80123cb4:	b0801a16 	blt	r22,r2,80123d20 <___svfprintf_internal_r+0x1d90>
80123cb8:	d9402917 	ldw	r5,164(sp)
80123cbc:	2d801816 	blt	r5,r22,80123d20 <___svfprintf_internal_r+0x1d90>
80123cc0:	dd803215 	stw	r22,200(sp)
80123cc4:	003f3a06 	br	801239b0 <__reset+0xfa1039b0>
80123cc8:	1025883a 	mov	r18,r2
80123ccc:	0039883a 	mov	fp,zero
80123cd0:	00800084 	movi	r2,2
80123cd4:	003fd606 	br	80123c30 <__reset+0xfa103c30>
80123cd8:	9080004c 	andi	r2,r18,1
80123cdc:	103f191e 	bne	r2,zero,80123944 <__reset+0xfa103944>
80123ce0:	d8802117 	ldw	r2,132(sp)
80123ce4:	003f2806 	br	80123988 <__reset+0xfa103988>
80123ce8:	01200534 	movhi	r4,32788
80123cec:	211ed084 	addi	r4,r4,31554
80123cf0:	d9002b15 	stw	r4,172(sp)
80123cf4:	003c7c06 	br	80122ee8 <__reset+0xfa102ee8>
80123cf8:	e005883a 	mov	r2,fp
80123cfc:	003f2206 	br	80123988 <__reset+0xfa103988>
80123d00:	d9402917 	ldw	r5,164(sp)
80123d04:	df002783 	ldbu	fp,158(sp)
80123d08:	dd002d15 	stw	r20,180(sp)
80123d0c:	d9402a15 	stw	r5,168(sp)
80123d10:	d9402e15 	stw	r5,184(sp)
80123d14:	d8002915 	stw	zero,164(sp)
80123d18:	d8003215 	stw	zero,200(sp)
80123d1c:	003a4c06 	br	80122650 <__reset+0xfa102650>
80123d20:	8c7fff84 	addi	r17,r17,-2
80123d24:	b5bfffc4 	addi	r22,r22,-1
80123d28:	dd802615 	stw	r22,152(sp)
80123d2c:	dc4022c5 	stb	r17,139(sp)
80123d30:	b000c316 	blt	r22,zero,80124040 <___svfprintf_internal_r+0x20b0>
80123d34:	00800ac4 	movi	r2,43
80123d38:	d8802305 	stb	r2,140(sp)
80123d3c:	00800244 	movi	r2,9
80123d40:	15806e16 	blt	r2,r22,80123efc <___svfprintf_internal_r+0x1f6c>
80123d44:	00800c04 	movi	r2,48
80123d48:	b5800c04 	addi	r22,r22,48
80123d4c:	d8802345 	stb	r2,141(sp)
80123d50:	dd802385 	stb	r22,142(sp)
80123d54:	d88023c4 	addi	r2,sp,143
80123d58:	df0022c4 	addi	fp,sp,139
80123d5c:	d8c03317 	ldw	r3,204(sp)
80123d60:	1739c83a 	sub	fp,r2,fp
80123d64:	d9003317 	ldw	r4,204(sp)
80123d68:	e0c7883a 	add	r3,fp,r3
80123d6c:	df003b15 	stw	fp,236(sp)
80123d70:	d8c02e15 	stw	r3,184(sp)
80123d74:	00800044 	movi	r2,1
80123d78:	1100b70e 	bge	r2,r4,80124058 <___svfprintf_internal_r+0x20c8>
80123d7c:	d8c02e17 	ldw	r3,184(sp)
80123d80:	18c00044 	addi	r3,r3,1
80123d84:	d8c02e15 	stw	r3,184(sp)
80123d88:	1805883a 	mov	r2,r3
80123d8c:	1800b016 	blt	r3,zero,80124050 <___svfprintf_internal_r+0x20c0>
80123d90:	d8003215 	stw	zero,200(sp)
80123d94:	003f1006 	br	801239d8 <__reset+0xfa1039d8>
80123d98:	d8802917 	ldw	r2,164(sp)
80123d9c:	103ec71e 	bne	r2,zero,801238bc <__reset+0xfa1038bc>
80123da0:	dc002915 	stw	r16,164(sp)
80123da4:	003ec506 	br	801238bc <__reset+0xfa1038bc>
80123da8:	d9402c17 	ldw	r5,176(sp)
80123dac:	d9801e04 	addi	r6,sp,120
80123db0:	9809883a 	mov	r4,r19
80123db4:	012c9940 	call	8012c994 <__ssprint_r>
80123db8:	10395c1e 	bne	r2,zero,8012232c <__reset+0xfa10232c>
80123dbc:	dc402617 	ldw	r17,152(sp)
80123dc0:	d8c02017 	ldw	r3,128(sp)
80123dc4:	d8801f17 	ldw	r2,124(sp)
80123dc8:	da000404 	addi	r8,sp,16
80123dcc:	003e7706 	br	801237ac <__reset+0xfa1037ac>
80123dd0:	582f883a 	mov	r23,r11
80123dd4:	d8002915 	stw	zero,164(sp)
80123dd8:	0038c406 	br	801220ec <__reset+0xfa1020ec>
80123ddc:	d8c02917 	ldw	r3,164(sp)
80123de0:	d8802104 	addi	r2,sp,132
80123de4:	d8800315 	stw	r2,12(sp)
80123de8:	d9403617 	ldw	r5,216(sp)
80123dec:	d8802504 	addi	r2,sp,148
80123df0:	d8800215 	stw	r2,8(sp)
80123df4:	d8802604 	addi	r2,sp,152
80123df8:	d8c00015 	stw	r3,0(sp)
80123dfc:	9809883a 	mov	r4,r19
80123e00:	d8800115 	stw	r2,4(sp)
80123e04:	01c000c4 	movi	r7,3
80123e08:	a00d883a 	mov	r6,r20
80123e0c:	da003e15 	stw	r8,248(sp)
80123e10:	0125c1c0 	call	80125c1c <_dtoa_r>
80123e14:	d9002917 	ldw	r4,164(sp)
80123e18:	da003e17 	ldw	r8,248(sp)
80123e1c:	1021883a 	mov	r16,r2
80123e20:	1139883a 	add	fp,r2,r4
80123e24:	2007883a 	mov	r3,r4
80123e28:	81000007 	ldb	r4,0(r16)
80123e2c:	00800c04 	movi	r2,48
80123e30:	20806f26 	beq	r4,r2,80123ff0 <___svfprintf_internal_r+0x2060>
80123e34:	d8c02617 	ldw	r3,152(sp)
80123e38:	e0f9883a 	add	fp,fp,r3
80123e3c:	003ec206 	br	80123948 <__reset+0xfa103948>
80123e40:	00c00b44 	movi	r3,45
80123e44:	2520003c 	xorhi	r20,r4,32768
80123e48:	d8c02a05 	stb	r3,168(sp)
80123e4c:	003ea106 	br	801238d4 <__reset+0xfa1038d4>
80123e50:	d8c03217 	ldw	r3,200(sp)
80123e54:	00c0890e 	bge	zero,r3,8012407c <___svfprintf_internal_r+0x20ec>
80123e58:	00800044 	movi	r2,1
80123e5c:	d9003317 	ldw	r4,204(sp)
80123e60:	1105883a 	add	r2,r2,r4
80123e64:	d8802e15 	stw	r2,184(sp)
80123e68:	10005f16 	blt	r2,zero,80123fe8 <___svfprintf_internal_r+0x2058>
80123e6c:	044019c4 	movi	r17,103
80123e70:	003ed906 	br	801239d8 <__reset+0xfa1039d8>
80123e74:	d9002917 	ldw	r4,164(sp)
80123e78:	20c00044 	addi	r3,r4,1
80123e7c:	003e9c06 	br	801238f0 <__reset+0xfa1038f0>
80123e80:	d9002917 	ldw	r4,164(sp)
80123e84:	00c0680e 	bge	zero,r3,80124028 <___svfprintf_internal_r+0x2098>
80123e88:	2000461e 	bne	r4,zero,80123fa4 <___svfprintf_internal_r+0x2014>
80123e8c:	9480004c 	andi	r18,r18,1
80123e90:	9000441e 	bne	r18,zero,80123fa4 <___svfprintf_internal_r+0x2014>
80123e94:	1805883a 	mov	r2,r3
80123e98:	1800a016 	blt	r3,zero,8012411c <___svfprintf_internal_r+0x218c>
80123e9c:	d8c03217 	ldw	r3,200(sp)
80123ea0:	d8c02e15 	stw	r3,184(sp)
80123ea4:	003ecc06 	br	801239d8 <__reset+0xfa1039d8>
80123ea8:	d9402917 	ldw	r5,164(sp)
80123eac:	d8802104 	addi	r2,sp,132
80123eb0:	d8800315 	stw	r2,12(sp)
80123eb4:	d9400015 	stw	r5,0(sp)
80123eb8:	d8802504 	addi	r2,sp,148
80123ebc:	d9403617 	ldw	r5,216(sp)
80123ec0:	d8800215 	stw	r2,8(sp)
80123ec4:	d8802604 	addi	r2,sp,152
80123ec8:	d8800115 	stw	r2,4(sp)
80123ecc:	01c000c4 	movi	r7,3
80123ed0:	a00d883a 	mov	r6,r20
80123ed4:	9809883a 	mov	r4,r19
80123ed8:	da003e15 	stw	r8,248(sp)
80123edc:	0125c1c0 	call	80125c1c <_dtoa_r>
80123ee0:	d8c02917 	ldw	r3,164(sp)
80123ee4:	da003e17 	ldw	r8,248(sp)
80123ee8:	1021883a 	mov	r16,r2
80123eec:	00801184 	movi	r2,70
80123ef0:	80f9883a 	add	fp,r16,r3
80123ef4:	88bfcc26 	beq	r17,r2,80123e28 <__reset+0xfa103e28>
80123ef8:	003e9306 	br	80123948 <__reset+0xfa103948>
80123efc:	df0022c4 	addi	fp,sp,139
80123f00:	dc002915 	stw	r16,164(sp)
80123f04:	9829883a 	mov	r20,r19
80123f08:	e021883a 	mov	r16,fp
80123f0c:	4027883a 	mov	r19,r8
80123f10:	b009883a 	mov	r4,r22
80123f14:	01400284 	movi	r5,10
80123f18:	01301f40 	call	801301f4 <__modsi3>
80123f1c:	10800c04 	addi	r2,r2,48
80123f20:	843fffc4 	addi	r16,r16,-1
80123f24:	b009883a 	mov	r4,r22
80123f28:	01400284 	movi	r5,10
80123f2c:	80800005 	stb	r2,0(r16)
80123f30:	01301700 	call	80130170 <__divsi3>
80123f34:	102d883a 	mov	r22,r2
80123f38:	00800244 	movi	r2,9
80123f3c:	15bff416 	blt	r2,r22,80123f10 <__reset+0xfa103f10>
80123f40:	9811883a 	mov	r8,r19
80123f44:	b0800c04 	addi	r2,r22,48
80123f48:	a027883a 	mov	r19,r20
80123f4c:	8029883a 	mov	r20,r16
80123f50:	a17fffc4 	addi	r5,r20,-1
80123f54:	a0bfffc5 	stb	r2,-1(r20)
80123f58:	dc002917 	ldw	r16,164(sp)
80123f5c:	2f00752e 	bgeu	r5,fp,80124134 <___svfprintf_internal_r+0x21a4>
80123f60:	d9c02384 	addi	r7,sp,142
80123f64:	3d0fc83a 	sub	r7,r7,r20
80123f68:	d9002344 	addi	r4,sp,141
80123f6c:	e1cf883a 	add	r7,fp,r7
80123f70:	00000106 	br	80123f78 <___svfprintf_internal_r+0x1fe8>
80123f74:	28800003 	ldbu	r2,0(r5)
80123f78:	20800005 	stb	r2,0(r4)
80123f7c:	21000044 	addi	r4,r4,1
80123f80:	29400044 	addi	r5,r5,1
80123f84:	21fffb1e 	bne	r4,r7,80123f74 <__reset+0xfa103f74>
80123f88:	d8802304 	addi	r2,sp,140
80123f8c:	1505c83a 	sub	r2,r2,r20
80123f90:	d8c02344 	addi	r3,sp,141
80123f94:	1885883a 	add	r2,r3,r2
80123f98:	003f7006 	br	80123d5c <__reset+0xfa103d5c>
80123f9c:	0005883a 	mov	r2,zero
80123fa0:	003f0b06 	br	80123bd0 <__reset+0xfa103bd0>
80123fa4:	d9002917 	ldw	r4,164(sp)
80123fa8:	d8c03217 	ldw	r3,200(sp)
80123fac:	20800044 	addi	r2,r4,1
80123fb0:	1885883a 	add	r2,r3,r2
80123fb4:	d8802e15 	stw	r2,184(sp)
80123fb8:	103e870e 	bge	r2,zero,801239d8 <__reset+0xfa1039d8>
80123fbc:	0005883a 	mov	r2,zero
80123fc0:	003e8506 	br	801239d8 <__reset+0xfa1039d8>
80123fc4:	01200534 	movhi	r4,32788
80123fc8:	211ed084 	addi	r4,r4,31554
80123fcc:	d9002b15 	stw	r4,172(sp)
80123fd0:	003cc506 	br	801232e8 <__reset+0xfa1032e8>
80123fd4:	d8c03217 	ldw	r3,200(sp)
80123fd8:	18c00044 	addi	r3,r3,1
80123fdc:	d8c02e15 	stw	r3,184(sp)
80123fe0:	1805883a 	mov	r2,r3
80123fe4:	183fa10e 	bge	r3,zero,80123e6c <__reset+0xfa103e6c>
80123fe8:	0005883a 	mov	r2,zero
80123fec:	003f9f06 	br	80123e6c <__reset+0xfa103e6c>
80123ff0:	d9003617 	ldw	r4,216(sp)
80123ff4:	000d883a 	mov	r6,zero
80123ff8:	000f883a 	mov	r7,zero
80123ffc:	a00b883a 	mov	r5,r20
80124000:	d8c03d15 	stw	r3,244(sp)
80124004:	da003e15 	stw	r8,248(sp)
80124008:	01316c40 	call	801316c4 <__eqdf2>
8012400c:	d8c03d17 	ldw	r3,244(sp)
80124010:	da003e17 	ldw	r8,248(sp)
80124014:	103f8726 	beq	r2,zero,80123e34 <__reset+0xfa103e34>
80124018:	00800044 	movi	r2,1
8012401c:	10c7c83a 	sub	r3,r2,r3
80124020:	d8c02615 	stw	r3,152(sp)
80124024:	003f8406 	br	80123e38 <__reset+0xfa103e38>
80124028:	20000e1e 	bne	r4,zero,80124064 <___svfprintf_internal_r+0x20d4>
8012402c:	9480004c 	andi	r18,r18,1
80124030:	90000c1e 	bne	r18,zero,80124064 <___svfprintf_internal_r+0x20d4>
80124034:	00800044 	movi	r2,1
80124038:	d8802e15 	stw	r2,184(sp)
8012403c:	003e6606 	br	801239d8 <__reset+0xfa1039d8>
80124040:	00800b44 	movi	r2,45
80124044:	05adc83a 	sub	r22,zero,r22
80124048:	d8802305 	stb	r2,140(sp)
8012404c:	003f3b06 	br	80123d3c <__reset+0xfa103d3c>
80124050:	0005883a 	mov	r2,zero
80124054:	003f4e06 	br	80123d90 <__reset+0xfa103d90>
80124058:	90a4703a 	and	r18,r18,r2
8012405c:	903f4a26 	beq	r18,zero,80123d88 <__reset+0xfa103d88>
80124060:	003f4606 	br	80123d7c <__reset+0xfa103d7c>
80124064:	d8c02917 	ldw	r3,164(sp)
80124068:	18c00084 	addi	r3,r3,2
8012406c:	d8c02e15 	stw	r3,184(sp)
80124070:	1805883a 	mov	r2,r3
80124074:	183e580e 	bge	r3,zero,801239d8 <__reset+0xfa1039d8>
80124078:	003fd006 	br	80123fbc <__reset+0xfa103fbc>
8012407c:	00800084 	movi	r2,2
80124080:	10c5c83a 	sub	r2,r2,r3
80124084:	003f7506 	br	80123e5c <__reset+0xfa103e5c>
80124088:	d8802d17 	ldw	r2,180(sp)
8012408c:	d9002d17 	ldw	r4,180(sp)
80124090:	bc400043 	ldbu	r17,1(r23)
80124094:	10800017 	ldw	r2,0(r2)
80124098:	582f883a 	mov	r23,r11
8012409c:	d8802915 	stw	r2,164(sp)
801240a0:	20800104 	addi	r2,r4,4
801240a4:	d9002917 	ldw	r4,164(sp)
801240a8:	d8802d15 	stw	r2,180(sp)
801240ac:	203df00e 	bge	r4,zero,80123870 <__reset+0xfa103870>
801240b0:	8c403fcc 	andi	r17,r17,255
801240b4:	00bfffc4 	movi	r2,-1
801240b8:	8c40201c 	xori	r17,r17,128
801240bc:	d8802915 	stw	r2,164(sp)
801240c0:	8c7fe004 	addi	r17,r17,-128
801240c4:	00380806 	br	801220e8 <__reset+0xfa1020e8>
801240c8:	9080004c 	andi	r2,r18,1
801240cc:	0039883a 	mov	fp,zero
801240d0:	10000726 	beq	r2,zero,801240f0 <___svfprintf_internal_r+0x2160>
801240d4:	d8c02817 	ldw	r3,160(sp)
801240d8:	dc001dc4 	addi	r16,sp,119
801240dc:	00800c04 	movi	r2,48
801240e0:	1c07c83a 	sub	r3,r3,r16
801240e4:	d8801dc5 	stb	r2,119(sp)
801240e8:	d8c02e15 	stw	r3,184(sp)
801240ec:	00395206 	br	80122638 <__reset+0xfa102638>
801240f0:	d8002e15 	stw	zero,184(sp)
801240f4:	dc001e04 	addi	r16,sp,120
801240f8:	00394f06 	br	80122638 <__reset+0xfa102638>
801240fc:	0005883a 	mov	r2,zero
80124100:	003e3206 	br	801239cc <__reset+0xfa1039cc>
80124104:	dd802617 	ldw	r22,152(sp)
80124108:	003f0606 	br	80123d24 <__reset+0xfa103d24>
8012410c:	d9c02785 	stb	r7,158(sp)
80124110:	003a5106 	br	80122a58 <__reset+0xfa102a58>
80124114:	d9c02785 	stb	r7,158(sp)
80124118:	003a3706 	br	801229f8 <__reset+0xfa1029f8>
8012411c:	0005883a 	mov	r2,zero
80124120:	003f5e06 	br	80123e9c <__reset+0xfa103e9c>
80124124:	d9c02785 	stb	r7,158(sp)
80124128:	00391706 	br	80122588 <__reset+0xfa102588>
8012412c:	d9c02785 	stb	r7,158(sp)
80124130:	0038e606 	br	801224cc <__reset+0xfa1024cc>
80124134:	d8802344 	addi	r2,sp,141
80124138:	003f0806 	br	80123d5c <__reset+0xfa103d5c>
8012413c:	d9c02785 	stb	r7,158(sp)
80124140:	0038b706 	br	80122420 <__reset+0xfa102420>
80124144:	d9c02785 	stb	r7,158(sp)
80124148:	003adc06 	br	80122cbc <__reset+0xfa102cbc>
8012414c:	d9403917 	ldw	r5,228(sp)
80124150:	00800304 	movi	r2,12
80124154:	28800015 	stw	r2,0(r5)
80124158:	00bfffc4 	movi	r2,-1
8012415c:	00387806 	br	80122340 <__reset+0xfa102340>
80124160:	d9c02785 	stb	r7,158(sp)
80124164:	003abf06 	br	80122c64 <__reset+0xfa102c64>
80124168:	d9c02785 	stb	r7,158(sp)
8012416c:	003a9b06 	br	80122bdc <__reset+0xfa102bdc>

80124170 <__svfscanf_r>:
80124170:	deff4b04 	addi	sp,sp,-724
80124174:	de00012e 	bgeu	sp,et,8012417c <__svfscanf_r+0xc>
80124178:	003b68fa 	trap	3
8012417c:	2880030b 	ldhu	r2,12(r5)
80124180:	df00b315 	stw	fp,716(sp)
80124184:	dd80b115 	stw	r22,708(sp)
80124188:	dfc0b415 	stw	ra,720(sp)
8012418c:	ddc0b215 	stw	r23,712(sp)
80124190:	dd40b015 	stw	r21,704(sp)
80124194:	dd00af15 	stw	r20,700(sp)
80124198:	dcc0ae15 	stw	r19,696(sp)
8012419c:	dc80ad15 	stw	r18,692(sp)
801241a0:	dc40ac15 	stw	r17,688(sp)
801241a4:	dc00ab15 	stw	r16,684(sp)
801241a8:	10c8000c 	andi	r3,r2,8192
801241ac:	d9c09c15 	stw	r7,624(sp)
801241b0:	2839883a 	mov	fp,r5
801241b4:	202d883a 	mov	r22,r4
801241b8:	1800061e 	bne	r3,zero,801241d4 <__svfscanf_r+0x64>
801241bc:	29001917 	ldw	r4,100(r5)
801241c0:	00f7ffc4 	movi	r3,-8193
801241c4:	10880014 	ori	r2,r2,8192
801241c8:	20c6703a 	and	r3,r4,r3
801241cc:	2880030d 	sth	r2,12(r5)
801241d0:	28c01915 	stw	r3,100(r5)
801241d4:	30800003 	ldbu	r2,0(r6)
801241d8:	0021883a 	mov	r16,zero
801241dc:	05e00574 	movhi	r23,32789
801241e0:	d800a115 	stw	zero,644(sp)
801241e4:	d8009e15 	stw	zero,632(sp)
801241e8:	d800a015 	stw	zero,640(sp)
801241ec:	d8809b15 	stw	r2,620(sp)
801241f0:	bde88504 	addi	r23,r23,-24044
801241f4:	8025883a 	mov	r18,r16
801241f8:	35000044 	addi	r20,r6,1
801241fc:	10001e26 	beq	r2,zero,80124278 <__svfscanf_r+0x108>
80124200:	b9c00017 	ldw	r7,0(r23)
80124204:	3887883a 	add	r3,r7,r2
80124208:	18c00043 	ldbu	r3,1(r3)
8012420c:	18c0020c 	andi	r3,r3,8
80124210:	18001b26 	beq	r3,zero,80124280 <__svfscanf_r+0x110>
80124214:	e0800117 	ldw	r2,4(fp)
80124218:	00800e0e 	bge	zero,r2,80124254 <__svfscanf_r+0xe4>
8012421c:	e0c00017 	ldw	r3,0(fp)
80124220:	b9000017 	ldw	r4,0(r23)
80124224:	18800003 	ldbu	r2,0(r3)
80124228:	2085883a 	add	r2,r4,r2
8012422c:	10800043 	ldbu	r2,1(r2)
80124230:	1080020c 	andi	r2,r2,8
80124234:	10000b26 	beq	r2,zero,80124264 <__svfscanf_r+0xf4>
80124238:	e0800117 	ldw	r2,4(fp)
8012423c:	18c00044 	addi	r3,r3,1
80124240:	e0c00015 	stw	r3,0(fp)
80124244:	10bfffc4 	addi	r2,r2,-1
80124248:	e0800115 	stw	r2,4(fp)
8012424c:	94800044 	addi	r18,r18,1
80124250:	00bff216 	blt	zero,r2,8012421c <__reset+0xfa10421c>
80124254:	e00b883a 	mov	r5,fp
80124258:	b009883a 	mov	r4,r22
8012425c:	012a7040 	call	8012a704 <__srefill_r>
80124260:	103fee26 	beq	r2,zero,8012421c <__reset+0xfa10421c>
80124264:	a00d883a 	mov	r6,r20
80124268:	30800003 	ldbu	r2,0(r6)
8012426c:	35000044 	addi	r20,r6,1
80124270:	d8809b15 	stw	r2,620(sp)
80124274:	103fe21e 	bne	r2,zero,80124200 <__reset+0xfa104200>
80124278:	d880a017 	ldw	r2,640(sp)
8012427c:	00009906 	br	801244e4 <__svfscanf_r+0x374>
80124280:	00c00944 	movi	r3,37
80124284:	10c0881e 	bne	r2,r3,801244a8 <__svfscanf_r+0x338>
80124288:	30c00043 	ldbu	r3,1(r6)
8012428c:	0023883a 	mov	r17,zero
80124290:	0027883a 	mov	r19,zero
80124294:	01001e04 	movi	r4,120
80124298:	01401b04 	movi	r5,108
8012429c:	a1800044 	addi	r6,r20,1
801242a0:	20c0a236 	bltu	r4,r3,8012452c <__svfscanf_r+0x3bc>
801242a4:	180490ba 	slli	r2,r3,2
801242a8:	022004b4 	movhi	r8,32786
801242ac:	4210af04 	addi	r8,r8,17084
801242b0:	1205883a 	add	r2,r2,r8
801242b4:	10800017 	ldw	r2,0(r2)
801242b8:	1000683a 	jmp	r2
801242bc:	801244e0 	cmpeqi	zero,r16,18707
801242c0:	8012452c 	andhi	zero,r16,18708
801242c4:	8012452c 	andhi	zero,r16,18708
801242c8:	8012452c 	andhi	zero,r16,18708
801242cc:	8012452c 	andhi	zero,r16,18708
801242d0:	8012452c 	andhi	zero,r16,18708
801242d4:	8012452c 	andhi	zero,r16,18708
801242d8:	8012452c 	andhi	zero,r16,18708
801242dc:	8012452c 	andhi	zero,r16,18708
801242e0:	8012452c 	andhi	zero,r16,18708
801242e4:	8012452c 	andhi	zero,r16,18708
801242e8:	8012452c 	andhi	zero,r16,18708
801242ec:	8012452c 	andhi	zero,r16,18708
801242f0:	8012452c 	andhi	zero,r16,18708
801242f4:	8012452c 	andhi	zero,r16,18708
801242f8:	8012452c 	andhi	zero,r16,18708
801242fc:	8012452c 	andhi	zero,r16,18708
80124300:	8012452c 	andhi	zero,r16,18708
80124304:	8012452c 	andhi	zero,r16,18708
80124308:	8012452c 	andhi	zero,r16,18708
8012430c:	8012452c 	andhi	zero,r16,18708
80124310:	8012452c 	andhi	zero,r16,18708
80124314:	8012452c 	andhi	zero,r16,18708
80124318:	8012452c 	andhi	zero,r16,18708
8012431c:	8012452c 	andhi	zero,r16,18708
80124320:	8012452c 	andhi	zero,r16,18708
80124324:	8012452c 	andhi	zero,r16,18708
80124328:	8012452c 	andhi	zero,r16,18708
8012432c:	8012452c 	andhi	zero,r16,18708
80124330:	8012452c 	andhi	zero,r16,18708
80124334:	8012452c 	andhi	zero,r16,18708
80124338:	8012452c 	andhi	zero,r16,18708
8012433c:	8012452c 	andhi	zero,r16,18708
80124340:	8012452c 	andhi	zero,r16,18708
80124344:	8012452c 	andhi	zero,r16,18708
80124348:	8012452c 	andhi	zero,r16,18708
8012434c:	8012452c 	andhi	zero,r16,18708
80124350:	801244a0 	cmpeqi	zero,r16,18706
80124354:	8012452c 	andhi	zero,r16,18708
80124358:	8012452c 	andhi	zero,r16,18708
8012435c:	8012452c 	andhi	zero,r16,18708
80124360:	8012452c 	andhi	zero,r16,18708
80124364:	80124514 	ori	zero,r16,18708
80124368:	8012452c 	andhi	zero,r16,18708
8012436c:	8012452c 	andhi	zero,r16,18708
80124370:	8012452c 	andhi	zero,r16,18708
80124374:	8012452c 	andhi	zero,r16,18708
80124378:	8012452c 	andhi	zero,r16,18708
8012437c:	80124648 	cmpgei	zero,r16,18713
80124380:	80124648 	cmpgei	zero,r16,18713
80124384:	80124648 	cmpgei	zero,r16,18713
80124388:	80124648 	cmpgei	zero,r16,18713
8012438c:	80124648 	cmpgei	zero,r16,18713
80124390:	80124648 	cmpgei	zero,r16,18713
80124394:	80124648 	cmpgei	zero,r16,18713
80124398:	80124648 	cmpgei	zero,r16,18713
8012439c:	80124648 	cmpgei	zero,r16,18713
801243a0:	80124648 	cmpgei	zero,r16,18713
801243a4:	8012452c 	andhi	zero,r16,18708
801243a8:	8012452c 	andhi	zero,r16,18708
801243ac:	8012452c 	andhi	zero,r16,18708
801243b0:	8012452c 	andhi	zero,r16,18708
801243b4:	8012452c 	andhi	zero,r16,18708
801243b8:	8012452c 	andhi	zero,r16,18708
801243bc:	8012452c 	andhi	zero,r16,18708
801243c0:	8012452c 	andhi	zero,r16,18708
801243c4:	8012452c 	andhi	zero,r16,18708
801243c8:	8012452c 	andhi	zero,r16,18708
801243cc:	8012461c 	xori	zero,r16,18712
801243d0:	801246cc 	andi	zero,r16,18715
801243d4:	8012452c 	andhi	zero,r16,18708
801243d8:	801246cc 	andi	zero,r16,18715
801243dc:	8012452c 	andhi	zero,r16,18708
801243e0:	8012452c 	andhi	zero,r16,18708
801243e4:	8012452c 	andhi	zero,r16,18708
801243e8:	8012452c 	andhi	zero,r16,18708
801243ec:	801246b8 	rdprs	zero,r16,18714
801243f0:	8012452c 	andhi	zero,r16,18708
801243f4:	8012452c 	andhi	zero,r16,18708
801243f8:	8012468c 	andi	zero,r16,18714
801243fc:	8012452c 	andhi	zero,r16,18708
80124400:	8012452c 	andhi	zero,r16,18708
80124404:	8012452c 	andhi	zero,r16,18708
80124408:	8012452c 	andhi	zero,r16,18708
8012440c:	8012452c 	andhi	zero,r16,18708
80124410:	8012452c 	andhi	zero,r16,18708
80124414:	8012452c 	andhi	zero,r16,18708
80124418:	8012452c 	andhi	zero,r16,18708
8012441c:	80124664 	muli	zero,r16,18713
80124420:	8012452c 	andhi	zero,r16,18708
80124424:	8012452c 	andhi	zero,r16,18708
80124428:	80124800 	call	88012480 <__reset+0x1ff2480>
8012442c:	8012452c 	andhi	zero,r16,18708
80124430:	8012452c 	andhi	zero,r16,18708
80124434:	8012452c 	andhi	zero,r16,18708
80124438:	8012452c 	andhi	zero,r16,18708
8012443c:	8012452c 	andhi	zero,r16,18708
80124440:	8012452c 	andhi	zero,r16,18708
80124444:	8012452c 	andhi	zero,r16,18708
80124448:	80124784 	addi	zero,r16,18718
8012444c:	8012475c 	xori	zero,r16,18717
80124450:	801246cc 	andi	zero,r16,18715
80124454:	801246cc 	andi	zero,r16,18715
80124458:	801246cc 	andi	zero,r16,18715
8012445c:	80124748 	cmpgei	zero,r16,18717
80124460:	8012488c 	andi	zero,r16,18722
80124464:	8012452c 	andhi	zero,r16,18708
80124468:	8012452c 	andhi	zero,r16,18708
8012446c:	80124734 	orhi	zero,r16,18716
80124470:	8012452c 	andhi	zero,r16,18708
80124474:	80124704 	addi	zero,r16,18716
80124478:	801246e0 	cmpeqi	zero,r16,18715
8012447c:	801245f0 	cmpltui	zero,r16,18711
80124480:	8012452c 	andhi	zero,r16,18708
80124484:	8012452c 	andhi	zero,r16,18708
80124488:	801245dc 	xori	zero,r16,18711
8012448c:	8012452c 	andhi	zero,r16,18708
80124490:	80124564 	muli	zero,r16,18709
80124494:	8012452c 	andhi	zero,r16,18708
80124498:	8012452c 	andhi	zero,r16,18708
8012449c:	80124664 	muli	zero,r16,18713
801244a0:	d9809d15 	stw	r6,628(sp)
801244a4:	3029883a 	mov	r20,r6
801244a8:	e0800117 	ldw	r2,4(fp)
801244ac:	0081aa0e 	bge	zero,r2,80124b58 <__svfscanf_r+0x9e8>
801244b0:	e0800017 	ldw	r2,0(fp)
801244b4:	a0ffffc3 	ldbu	r3,-1(r20)
801244b8:	11000003 	ldbu	r4,0(r2)
801244bc:	20ff6e1e 	bne	r4,r3,80124278 <__reset+0xfa104278>
801244c0:	e0c00117 	ldw	r3,4(fp)
801244c4:	10800044 	addi	r2,r2,1
801244c8:	e0800015 	stw	r2,0(fp)
801244cc:	18bfffc4 	addi	r2,r3,-1
801244d0:	e0800115 	stw	r2,4(fp)
801244d4:	94800044 	addi	r18,r18,1
801244d8:	a00d883a 	mov	r6,r20
801244dc:	003f6206 	br	80124268 <__reset+0xfa104268>
801244e0:	00bfffc4 	movi	r2,-1
801244e4:	dfc0b417 	ldw	ra,720(sp)
801244e8:	df00b317 	ldw	fp,716(sp)
801244ec:	ddc0b217 	ldw	r23,712(sp)
801244f0:	dd80b117 	ldw	r22,708(sp)
801244f4:	dd40b017 	ldw	r21,704(sp)
801244f8:	dd00af17 	ldw	r20,700(sp)
801244fc:	dcc0ae17 	ldw	r19,696(sp)
80124500:	dc80ad17 	ldw	r18,692(sp)
80124504:	dc40ac17 	ldw	r17,688(sp)
80124508:	dc00ab17 	ldw	r16,684(sp)
8012450c:	dec0b504 	addi	sp,sp,724
80124510:	f800283a 	ret
80124514:	a0800043 	ldbu	r2,1(r20)
80124518:	3029883a 	mov	r20,r6
8012451c:	8c400414 	ori	r17,r17,16
80124520:	10c03fcc 	andi	r3,r2,255
80124524:	a1800044 	addi	r6,r20,1
80124528:	20ff5e2e 	bgeu	r4,r3,801242a4 <__reset+0xfa1042a4>
8012452c:	38c7883a 	add	r3,r7,r3
80124530:	18800043 	ldbu	r2,1(r3)
80124534:	d9809d15 	stw	r6,628(sp)
80124538:	00c00044 	movi	r3,1
8012453c:	108000cc 	andi	r2,r2,3
80124540:	10c18f26 	beq	r2,r3,80124b80 <__svfscanf_r+0xa10>
80124544:	e0800117 	ldw	r2,4(fp)
80124548:	00808716 	blt	zero,r2,80124768 <__svfscanf_r+0x5f8>
8012454c:	e00b883a 	mov	r5,fp
80124550:	b009883a 	mov	r4,r22
80124554:	012a7040 	call	8012a704 <__srefill_r>
80124558:	1001431e 	bne	r2,zero,80124a68 <__svfscanf_r+0x8f8>
8012455c:	b9c00017 	ldw	r7,0(r23)
80124560:	00008106 	br	80124768 <__svfscanf_r+0x5f8>
80124564:	e0800117 	ldw	r2,4(fp)
80124568:	d9809d15 	stw	r6,628(sp)
8012456c:	0081a30e 	bge	zero,r2,80124bfc <__svfscanf_r+0xa8c>
80124570:	00a004f4 	movhi	r2,32787
80124574:	10b11104 	addi	r2,r2,-15292
80124578:	02000284 	movi	r8,10
8012457c:	d880a115 	stw	r2,644(sp)
80124580:	da009e15 	stw	r8,632(sp)
80124584:	050000c4 	movi	r20,3
80124588:	e0c00017 	ldw	r3,0(fp)
8012458c:	00000206 	br	80124598 <__svfscanf_r+0x428>
80124590:	18c00044 	addi	r3,r3,1
80124594:	e0c00015 	stw	r3,0(fp)
80124598:	19000003 	ldbu	r4,0(r3)
8012459c:	20803fcc 	andi	r2,r4,255
801245a0:	3885883a 	add	r2,r7,r2
801245a4:	10800043 	ldbu	r2,1(r2)
801245a8:	1140020c 	andi	r5,r2,8
801245ac:	2801ab26 	beq	r5,zero,80124c5c <__svfscanf_r+0xaec>
801245b0:	e0800117 	ldw	r2,4(fp)
801245b4:	94800044 	addi	r18,r18,1
801245b8:	10bfffc4 	addi	r2,r2,-1
801245bc:	e0800115 	stw	r2,4(fp)
801245c0:	00bff316 	blt	zero,r2,80124590 <__reset+0xfa104590>
801245c4:	e00b883a 	mov	r5,fp
801245c8:	b009883a 	mov	r4,r22
801245cc:	012a7040 	call	8012a704 <__srefill_r>
801245d0:	1001251e 	bne	r2,zero,80124a68 <__svfscanf_r+0x8f8>
801245d4:	b9c00017 	ldw	r7,0(r23)
801245d8:	003feb06 	br	80124588 <__reset+0xfa104588>
801245dc:	e0800117 	ldw	r2,4(fp)
801245e0:	d9809d15 	stw	r6,628(sp)
801245e4:	00818b0e 	bge	zero,r2,80124c14 <__svfscanf_r+0xaa4>
801245e8:	05000084 	movi	r20,2
801245ec:	003fe606 	br	80124588 <__reset+0xfa104588>
801245f0:	e0800117 	ldw	r2,4(fp)
801245f4:	d9809d15 	stw	r6,628(sp)
801245f8:	8c408814 	ori	r17,r17,544
801245fc:	00801d0e 	bge	zero,r2,80124674 <__svfscanf_r+0x504>
80124600:	00a004f4 	movhi	r2,32787
80124604:	10b11104 	addi	r2,r2,-15292
80124608:	02000404 	movi	r8,16
8012460c:	d880a115 	stw	r2,644(sp)
80124610:	da009e15 	stw	r8,632(sp)
80124614:	050000c4 	movi	r20,3
80124618:	003fdb06 	br	80124588 <__reset+0xfa104588>
8012461c:	e0800117 	ldw	r2,4(fp)
80124620:	d9809d15 	stw	r6,628(sp)
80124624:	8c400054 	ori	r17,r17,1
80124628:	00bfc80e 	bge	zero,r2,8012454c <__reset+0xfa10454c>
8012462c:	00e004b4 	movhi	r3,32786
80124630:	18c68c04 	addi	r3,r3,6704
80124634:	02000284 	movi	r8,10
80124638:	d8c0a115 	stw	r3,644(sp)
8012463c:	da009e15 	stw	r8,632(sp)
80124640:	050000c4 	movi	r20,3
80124644:	003fd006 	br	80124588 <__reset+0xfa104588>
80124648:	9cc002a4 	muli	r19,r19,10
8012464c:	a0800043 	ldbu	r2,1(r20)
80124650:	3029883a 	mov	r20,r6
80124654:	98e7883a 	add	r19,r19,r3
80124658:	9cfff404 	addi	r19,r19,-48
8012465c:	10c03fcc 	andi	r3,r2,255
80124660:	003f0e06 	br	8012429c <__reset+0xfa10429c>
80124664:	e0800117 	ldw	r2,4(fp)
80124668:	d9809d15 	stw	r6,628(sp)
8012466c:	8c408014 	ori	r17,r17,512
80124670:	00bfe316 	blt	zero,r2,80124600 <__reset+0xfa104600>
80124674:	e00b883a 	mov	r5,fp
80124678:	b009883a 	mov	r4,r22
8012467c:	012a7040 	call	8012a704 <__srefill_r>
80124680:	1000f91e 	bne	r2,zero,80124a68 <__svfscanf_r+0x8f8>
80124684:	b9c00017 	ldw	r7,0(r23)
80124688:	003fdd06 	br	80124600 <__reset+0xfa104600>
8012468c:	e0800117 	ldw	r2,4(fp)
80124690:	d9809d15 	stw	r6,628(sp)
80124694:	8c400054 	ori	r17,r17,1
80124698:	0080140e 	bge	zero,r2,801246ec <__svfscanf_r+0x57c>
8012469c:	00a004f4 	movhi	r2,32787
801246a0:	10b11104 	addi	r2,r2,-15292
801246a4:	02000204 	movi	r8,8
801246a8:	d880a115 	stw	r2,644(sp)
801246ac:	da009e15 	stw	r8,632(sp)
801246b0:	050000c4 	movi	r20,3
801246b4:	003fb406 	br	80124588 <__reset+0xfa104588>
801246b8:	a0800043 	ldbu	r2,1(r20)
801246bc:	8c400094 	ori	r17,r17,2
801246c0:	3029883a 	mov	r20,r6
801246c4:	10c03fcc 	andi	r3,r2,255
801246c8:	003ef406 	br	8012429c <__reset+0xfa10429c>
801246cc:	e0800117 	ldw	r2,4(fp)
801246d0:	d9809d15 	stw	r6,628(sp)
801246d4:	0081420e 	bge	zero,r2,80124be0 <__svfscanf_r+0xa70>
801246d8:	05000104 	movi	r20,4
801246dc:	003faa06 	br	80124588 <__reset+0xfa104588>
801246e0:	e0800117 	ldw	r2,4(fp)
801246e4:	d9809d15 	stw	r6,628(sp)
801246e8:	00bfec16 	blt	zero,r2,8012469c <__reset+0xfa10469c>
801246ec:	e00b883a 	mov	r5,fp
801246f0:	b009883a 	mov	r4,r22
801246f4:	012a7040 	call	8012a704 <__srefill_r>
801246f8:	1000db1e 	bne	r2,zero,80124a68 <__svfscanf_r+0x8f8>
801246fc:	b9c00017 	ldw	r7,0(r23)
80124700:	003fe606 	br	8012469c <__reset+0xfa10469c>
80124704:	d9809d15 	stw	r6,628(sp)
80124708:	8880040c 	andi	r2,r17,16
8012470c:	10009c1e 	bne	r2,zero,80124980 <__svfscanf_r+0x810>
80124710:	8880010c 	andi	r2,r17,4
80124714:	10011e26 	beq	r2,zero,80124b90 <__svfscanf_r+0xa20>
80124718:	da009c17 	ldw	r8,624(sp)
8012471c:	3029883a 	mov	r20,r6
80124720:	40800017 	ldw	r2,0(r8)
80124724:	42000104 	addi	r8,r8,4
80124728:	da009c15 	stw	r8,624(sp)
8012472c:	1480000d 	sth	r18,0(r2)
80124730:	003ecc06 	br	80124264 <__reset+0xfa104264>
80124734:	a0c00043 	ldbu	r3,1(r20)
80124738:	19410c26 	beq	r3,r5,80124b6c <__svfscanf_r+0x9fc>
8012473c:	8c400054 	ori	r17,r17,1
80124740:	3029883a 	mov	r20,r6
80124744:	003ed506 	br	8012429c <__reset+0xfa10429c>
80124748:	a0800043 	ldbu	r2,1(r20)
8012474c:	8c400114 	ori	r17,r17,4
80124750:	3029883a 	mov	r20,r6
80124754:	10c03fcc 	andi	r3,r2,255
80124758:	003ed006 	br	8012429c <__reset+0xfa10429c>
8012475c:	e0800117 	ldw	r2,4(fp)
80124760:	d9809d15 	stw	r6,628(sp)
80124764:	00bf790e 	bge	zero,r2,8012454c <__reset+0xfa10454c>
80124768:	00a004b4 	movhi	r2,32786
8012476c:	10868c04 	addi	r2,r2,6704
80124770:	02000284 	movi	r8,10
80124774:	d880a115 	stw	r2,644(sp)
80124778:	da009e15 	stw	r8,632(sp)
8012477c:	050000c4 	movi	r20,3
80124780:	003f8106 	br	80124588 <__reset+0xfa104588>
80124784:	e0800117 	ldw	r2,4(fp)
80124788:	d9809d15 	stw	r6,628(sp)
8012478c:	0080c40e 	bge	zero,r2,80124aa0 <__svfscanf_r+0x930>
80124790:	9800011e 	bne	r19,zero,80124798 <__svfscanf_r+0x628>
80124794:	04c00044 	movi	r19,1
80124798:	8880004c 	andi	r2,r17,1
8012479c:	1000441e 	bne	r2,zero,801248b0 <__svfscanf_r+0x740>
801247a0:	8c40040c 	andi	r17,r17,16
801247a4:	8800da26 	beq	r17,zero,80124b10 <__svfscanf_r+0x9a0>
801247a8:	0021883a 	mov	r16,zero
801247ac:	00000806 	br	801247d0 <__svfscanf_r+0x660>
801247b0:	1887883a 	add	r3,r3,r2
801247b4:	e00b883a 	mov	r5,fp
801247b8:	b009883a 	mov	r4,r22
801247bc:	e0c00015 	stw	r3,0(fp)
801247c0:	80a1883a 	add	r16,r16,r2
801247c4:	98a7c83a 	sub	r19,r19,r2
801247c8:	012a7040 	call	8012a704 <__srefill_r>
801247cc:	1000ca1e 	bne	r2,zero,80124af8 <__svfscanf_r+0x988>
801247d0:	e0800117 	ldw	r2,4(fp)
801247d4:	e0c00017 	ldw	r3,0(fp)
801247d8:	14fff516 	blt	r2,r19,801247b0 <__reset+0xfa1047b0>
801247dc:	14c5c83a 	sub	r2,r2,r19
801247e0:	1cd5883a 	add	r10,r3,r19
801247e4:	84e1883a 	add	r16,r16,r19
801247e8:	e0800115 	stw	r2,4(fp)
801247ec:	e2800015 	stw	r10,0(fp)
801247f0:	dd009d17 	ldw	r20,628(sp)
801247f4:	9425883a 	add	r18,r18,r16
801247f8:	a00d883a 	mov	r6,r20
801247fc:	003e9a06 	br	80124268 <__reset+0xfa104268>
80124800:	300b883a 	mov	r5,r6
80124804:	d9005884 	addi	r4,sp,354
80124808:	d9809d15 	stw	r6,628(sp)
8012480c:	012a9b00 	call	8012a9b0 <__sccl>
80124810:	1029883a 	mov	r20,r2
80124814:	e0800117 	ldw	r2,4(fp)
80124818:	0081050e 	bge	zero,r2,80124c30 <__svfscanf_r+0xac0>
8012481c:	e1000017 	ldw	r4,0(fp)
80124820:	20800003 	ldbu	r2,0(r4)
80124824:	98005926 	beq	r19,zero,8012498c <__svfscanf_r+0x81c>
80124828:	8c40040c 	andi	r17,r17,16
8012482c:	88005a26 	beq	r17,zero,80124998 <__svfscanf_r+0x828>
80124830:	9823883a 	mov	r17,r19
80124834:	0021883a 	mov	r16,zero
80124838:	00000106 	br	80124840 <__svfscanf_r+0x6d0>
8012483c:	20800003 	ldbu	r2,0(r4)
80124840:	10803fcc 	andi	r2,r2,255
80124844:	d8c05884 	addi	r3,sp,354
80124848:	1885883a 	add	r2,r3,r2
8012484c:	10800007 	ldb	r2,0(r2)
80124850:	1000ad26 	beq	r2,zero,80124b08 <__svfscanf_r+0x998>
80124854:	e0800117 	ldw	r2,4(fp)
80124858:	21000044 	addi	r4,r4,1
8012485c:	84000044 	addi	r16,r16,1
80124860:	10bfffc4 	addi	r2,r2,-1
80124864:	e0800115 	stw	r2,4(fp)
80124868:	e1000015 	stw	r4,0(fp)
8012486c:	84c0a026 	beq	r16,r19,80124af0 <__svfscanf_r+0x980>
80124870:	00bff216 	blt	zero,r2,8012483c <__reset+0xfa10483c>
80124874:	e00b883a 	mov	r5,fp
80124878:	b009883a 	mov	r4,r22
8012487c:	012a7040 	call	8012a704 <__srefill_r>
80124880:	10009a1e 	bne	r2,zero,80124aec <__svfscanf_r+0x97c>
80124884:	e1000017 	ldw	r4,0(fp)
80124888:	003fec06 	br	8012483c <__reset+0xfa10483c>
8012488c:	e0800117 	ldw	r2,4(fp)
80124890:	d9809d15 	stw	r6,628(sp)
80124894:	0080eb0e 	bge	zero,r2,80124c44 <__svfscanf_r+0xad4>
80124898:	00a004b4 	movhi	r2,32786
8012489c:	10868c04 	addi	r2,r2,6704
801248a0:	d880a115 	stw	r2,644(sp)
801248a4:	d8009e15 	stw	zero,632(sp)
801248a8:	050000c4 	movi	r20,3
801248ac:	003f3606 	br	80124588 <__reset+0xfa104588>
801248b0:	dd409904 	addi	r21,sp,612
801248b4:	8c40040c 	andi	r17,r17,16
801248b8:	01800204 	movi	r6,8
801248bc:	000b883a 	mov	r5,zero
801248c0:	a809883a 	mov	r4,r21
801248c4:	dc409f15 	stw	r17,636(sp)
801248c8:	01215b40 	call	801215b4 <memset>
801248cc:	dc409f17 	ldw	r17,636(sp)
801248d0:	88006e26 	beq	r17,zero,80124a8c <__svfscanf_r+0x91c>
801248d4:	0029883a 	mov	r20,zero
801248d8:	0023883a 	mov	r17,zero
801248dc:	01284340 	call	80128434 <__locale_mb_cur_max>
801248e0:	14406126 	beq	r2,r17,80124a68 <__svfscanf_r+0x8f8>
801248e4:	e0800017 	ldw	r2,0(fp)
801248e8:	e0c00117 	ldw	r3,4(fp)
801248ec:	d9000104 	addi	r4,sp,4
801248f0:	12000003 	ldbu	r8,0(r2)
801248f4:	18ffffc4 	addi	r3,r3,-1
801248f8:	10800044 	addi	r2,r2,1
801248fc:	e0c00115 	stw	r3,4(fp)
80124900:	e0800015 	stw	r2,0(fp)
80124904:	8c000044 	addi	r16,r17,1
80124908:	dd400015 	stw	r21,0(sp)
8012490c:	2463883a 	add	r17,r4,r17
80124910:	200d883a 	mov	r6,r4
80124914:	a00b883a 	mov	r5,r20
80124918:	800f883a 	mov	r7,r16
8012491c:	b009883a 	mov	r4,r22
80124920:	8a000005 	stb	r8,0(r17)
80124924:	0128c9c0 	call	80128c9c <_mbrtowc_r>
80124928:	017fffc4 	movi	r5,-1
8012492c:	11404e26 	beq	r2,r5,80124a68 <__svfscanf_r+0x8f8>
80124930:	1000601e 	bne	r2,zero,80124ab4 <__svfscanf_r+0x944>
80124934:	da009f17 	ldw	r8,636(sp)
80124938:	4000641e 	bne	r8,zero,80124acc <__svfscanf_r+0x95c>
8012493c:	a0000015 	stw	zero,0(r20)
80124940:	9425883a 	add	r18,r18,r16
80124944:	9967883a 	add	r19,r19,r5
80124948:	a5000104 	addi	r20,r20,4
8012494c:	e0800117 	ldw	r2,4(fp)
80124950:	0023883a 	mov	r17,zero
80124954:	00804b16 	blt	zero,r2,80124a84 <__svfscanf_r+0x914>
80124958:	e00b883a 	mov	r5,fp
8012495c:	b009883a 	mov	r4,r22
80124960:	012a7040 	call	8012a704 <__srefill_r>
80124964:	10004726 	beq	r2,zero,80124a84 <__svfscanf_r+0x914>
80124968:	88003f1e 	bne	r17,zero,80124a68 <__svfscanf_r+0x8f8>
8012496c:	d8c09f17 	ldw	r3,636(sp)
80124970:	1800031e 	bne	r3,zero,80124980 <__svfscanf_r+0x810>
80124974:	da00a017 	ldw	r8,640(sp)
80124978:	42000044 	addi	r8,r8,1
8012497c:	da00a015 	stw	r8,640(sp)
80124980:	dd009d17 	ldw	r20,628(sp)
80124984:	a00d883a 	mov	r6,r20
80124988:	003e3706 	br	80124268 <__reset+0xfa104268>
8012498c:	8c40040c 	andi	r17,r17,16
80124990:	04ffffc4 	movi	r19,-1
80124994:	883fa61e 	bne	r17,zero,80124830 <__reset+0xfa104830>
80124998:	da009c17 	ldw	r8,624(sp)
8012499c:	9abfffc4 	addi	r10,r19,-1
801249a0:	44000017 	ldw	r16,0(r8)
801249a4:	44400104 	addi	r17,r8,4
801249a8:	8007883a 	mov	r3,r16
801249ac:	82ab883a 	add	r21,r16,r10
801249b0:	00000306 	br	801249c0 <__svfscanf_r+0x850>
801249b4:	e1000017 	ldw	r4,0(fp)
801249b8:	9807883a 	mov	r3,r19
801249bc:	20800003 	ldbu	r2,0(r4)
801249c0:	10803fcc 	andi	r2,r2,255
801249c4:	d9405884 	addi	r5,sp,354
801249c8:	2885883a 	add	r2,r5,r2
801249cc:	10800007 	ldb	r2,0(r2)
801249d0:	10004b26 	beq	r2,zero,80124b00 <__svfscanf_r+0x990>
801249d4:	e0800117 	ldw	r2,4(fp)
801249d8:	21400044 	addi	r5,r4,1
801249dc:	e1400015 	stw	r5,0(fp)
801249e0:	10bfffc4 	addi	r2,r2,-1
801249e4:	e0800115 	stw	r2,4(fp)
801249e8:	20800003 	ldbu	r2,0(r4)
801249ec:	1cc00044 	addi	r19,r3,1
801249f0:	18800005 	stb	r2,0(r3)
801249f4:	1d400726 	beq	r3,r21,80124a14 <__svfscanf_r+0x8a4>
801249f8:	e0800117 	ldw	r2,4(fp)
801249fc:	00bfed16 	blt	zero,r2,801249b4 <__reset+0xfa1049b4>
80124a00:	e00b883a 	mov	r5,fp
80124a04:	b009883a 	mov	r4,r22
80124a08:	012a7040 	call	8012a704 <__srefill_r>
80124a0c:	103fe926 	beq	r2,zero,801249b4 <__reset+0xfa1049b4>
80124a10:	84c01526 	beq	r16,r19,80124a68 <__svfscanf_r+0x8f8>
80124a14:	9c21c83a 	sub	r16,r19,r16
80124a18:	803e1726 	beq	r16,zero,80124278 <__reset+0xfa104278>
80124a1c:	da00a017 	ldw	r8,640(sp)
80124a20:	98000005 	stb	zero,0(r19)
80124a24:	dc409c15 	stw	r17,624(sp)
80124a28:	42000044 	addi	r8,r8,1
80124a2c:	da00a015 	stw	r8,640(sp)
80124a30:	9425883a 	add	r18,r18,r16
80124a34:	a00d883a 	mov	r6,r20
80124a38:	003e0b06 	br	80124268 <__reset+0xfa104268>
80124a3c:	017fff84 	movi	r5,-2
80124a40:	11439b1e 	bne	r2,r5,801258b0 <__svfscanf_r+0x1740>
80124a44:	8821883a 	mov	r16,r17
80124a48:	e0800117 	ldw	r2,4(fp)
80124a4c:	0082e516 	blt	zero,r2,801255e4 <__svfscanf_r+0x1474>
80124a50:	e00b883a 	mov	r5,fp
80124a54:	b009883a 	mov	r4,r22
80124a58:	012a7040 	call	8012a704 <__srefill_r>
80124a5c:	1002e126 	beq	r2,zero,801255e4 <__svfscanf_r+0x1474>
80124a60:	dc409f17 	ldw	r17,636(sp)
80124a64:	8002e826 	beq	r16,zero,80125608 <__svfscanf_r+0x1498>
80124a68:	da00a017 	ldw	r8,640(sp)
80124a6c:	403e9c26 	beq	r8,zero,801244e0 <__reset+0xfa1044e0>
80124a70:	e080030b 	ldhu	r2,12(fp)
80124a74:	1080100c 	andi	r2,r2,64
80124a78:	103e991e 	bne	r2,zero,801244e0 <__reset+0xfa1044e0>
80124a7c:	4005883a 	mov	r2,r8
80124a80:	003e9806 	br	801244e4 <__reset+0xfa1044e4>
80124a84:	983f951e 	bne	r19,zero,801248dc <__reset+0xfa1048dc>
80124a88:	003fb806 	br	8012496c <__reset+0xfa10496c>
80124a8c:	da009c17 	ldw	r8,624(sp)
80124a90:	45000017 	ldw	r20,0(r8)
80124a94:	42000104 	addi	r8,r8,4
80124a98:	da009c15 	stw	r8,624(sp)
80124a9c:	003f8e06 	br	801248d8 <__reset+0xfa1048d8>
80124aa0:	e00b883a 	mov	r5,fp
80124aa4:	b009883a 	mov	r4,r22
80124aa8:	012a7040 	call	8012a704 <__srefill_r>
80124aac:	103f3826 	beq	r2,zero,80124790 <__reset+0xfa104790>
80124ab0:	003fed06 	br	80124a68 <__reset+0xfa104a68>
80124ab4:	00ffff84 	movi	r3,-2
80124ab8:	10c0071e 	bne	r2,r3,80124ad8 <__svfscanf_r+0x968>
80124abc:	e0800117 	ldw	r2,4(fp)
80124ac0:	8023883a 	mov	r17,r16
80124ac4:	00bf8516 	blt	zero,r2,801248dc <__reset+0xfa1048dc>
80124ac8:	003fa306 	br	80124958 <__reset+0xfa104958>
80124acc:	9425883a 	add	r18,r18,r16
80124ad0:	9cffffc4 	addi	r19,r19,-1
80124ad4:	003f9d06 	br	8012494c <__reset+0xfa10494c>
80124ad8:	da009f17 	ldw	r8,636(sp)
80124adc:	9425883a 	add	r18,r18,r16
80124ae0:	9cffffc4 	addi	r19,r19,-1
80124ae4:	403f9826 	beq	r8,zero,80124948 <__reset+0xfa104948>
80124ae8:	003f9806 	br	8012494c <__reset+0xfa10494c>
80124aec:	8023883a 	mov	r17,r16
80124af0:	8821883a 	mov	r16,r17
80124af4:	003fce06 	br	80124a30 <__reset+0xfa104a30>
80124af8:	803f3d1e 	bne	r16,zero,801247f0 <__reset+0xfa1047f0>
80124afc:	003fda06 	br	80124a68 <__reset+0xfa104a68>
80124b00:	1827883a 	mov	r19,r3
80124b04:	003fc306 	br	80124a14 <__reset+0xfa104a14>
80124b08:	803fc91e 	bne	r16,zero,80124a30 <__reset+0xfa104a30>
80124b0c:	003dda06 	br	80124278 <__reset+0xfa104278>
80124b10:	da009c17 	ldw	r8,624(sp)
80124b14:	df000015 	stw	fp,0(sp)
80124b18:	980f883a 	mov	r7,r19
80124b1c:	41400017 	ldw	r5,0(r8)
80124b20:	01800044 	movi	r6,1
80124b24:	b009883a 	mov	r4,r22
80124b28:	01276640 	call	80127664 <_fread_r>
80124b2c:	da009c17 	ldw	r8,624(sp)
80124b30:	40c00104 	addi	r3,r8,4
80124b34:	103fcc26 	beq	r2,zero,80124a68 <__reset+0xfa104a68>
80124b38:	da00a017 	ldw	r8,640(sp)
80124b3c:	dd009d17 	ldw	r20,628(sp)
80124b40:	90a5883a 	add	r18,r18,r2
80124b44:	42000044 	addi	r8,r8,1
80124b48:	da00a015 	stw	r8,640(sp)
80124b4c:	d8c09c15 	stw	r3,624(sp)
80124b50:	a00d883a 	mov	r6,r20
80124b54:	003dc406 	br	80124268 <__reset+0xfa104268>
80124b58:	e00b883a 	mov	r5,fp
80124b5c:	b009883a 	mov	r4,r22
80124b60:	012a7040 	call	8012a704 <__srefill_r>
80124b64:	103e5226 	beq	r2,zero,801244b0 <__reset+0xfa1044b0>
80124b68:	003fbf06 	br	80124a68 <__reset+0xfa104a68>
80124b6c:	a0800083 	ldbu	r2,2(r20)
80124b70:	8c400094 	ori	r17,r17,2
80124b74:	a5000084 	addi	r20,r20,2
80124b78:	10c03fcc 	andi	r3,r2,255
80124b7c:	003dc706 	br	8012429c <__reset+0xfa10429c>
80124b80:	e0800117 	ldw	r2,4(fp)
80124b84:	88e2b03a 	or	r17,r17,r3
80124b88:	00bef716 	blt	zero,r2,80124768 <__reset+0xfa104768>
80124b8c:	003e6f06 	br	8012454c <__reset+0xfa10454c>
80124b90:	8880004c 	andi	r2,r17,1
80124b94:	10000b1e 	bne	r2,zero,80124bc4 <__svfscanf_r+0xa54>
80124b98:	8c40008c 	andi	r17,r17,2
80124b9c:	88000926 	beq	r17,zero,80124bc4 <__svfscanf_r+0xa54>
80124ba0:	da009c17 	ldw	r8,624(sp)
80124ba4:	9007d7fa 	srai	r3,r18,31
80124ba8:	dd009d17 	ldw	r20,628(sp)
80124bac:	40800017 	ldw	r2,0(r8)
80124bb0:	42000104 	addi	r8,r8,4
80124bb4:	da009c15 	stw	r8,624(sp)
80124bb8:	14800015 	stw	r18,0(r2)
80124bbc:	10c00115 	stw	r3,4(r2)
80124bc0:	003da806 	br	80124264 <__reset+0xfa104264>
80124bc4:	da009c17 	ldw	r8,624(sp)
80124bc8:	dd009d17 	ldw	r20,628(sp)
80124bcc:	40800017 	ldw	r2,0(r8)
80124bd0:	42000104 	addi	r8,r8,4
80124bd4:	da009c15 	stw	r8,624(sp)
80124bd8:	14800015 	stw	r18,0(r2)
80124bdc:	003da106 	br	80124264 <__reset+0xfa104264>
80124be0:	e00b883a 	mov	r5,fp
80124be4:	b009883a 	mov	r4,r22
80124be8:	012a7040 	call	8012a704 <__srefill_r>
80124bec:	103f9e1e 	bne	r2,zero,80124a68 <__reset+0xfa104a68>
80124bf0:	b9c00017 	ldw	r7,0(r23)
80124bf4:	05000104 	movi	r20,4
80124bf8:	003e6306 	br	80124588 <__reset+0xfa104588>
80124bfc:	e00b883a 	mov	r5,fp
80124c00:	b009883a 	mov	r4,r22
80124c04:	012a7040 	call	8012a704 <__srefill_r>
80124c08:	103f971e 	bne	r2,zero,80124a68 <__reset+0xfa104a68>
80124c0c:	b9c00017 	ldw	r7,0(r23)
80124c10:	003e5706 	br	80124570 <__reset+0xfa104570>
80124c14:	e00b883a 	mov	r5,fp
80124c18:	b009883a 	mov	r4,r22
80124c1c:	012a7040 	call	8012a704 <__srefill_r>
80124c20:	103f911e 	bne	r2,zero,80124a68 <__reset+0xfa104a68>
80124c24:	b9c00017 	ldw	r7,0(r23)
80124c28:	05000084 	movi	r20,2
80124c2c:	003e5606 	br	80124588 <__reset+0xfa104588>
80124c30:	e00b883a 	mov	r5,fp
80124c34:	b009883a 	mov	r4,r22
80124c38:	012a7040 	call	8012a704 <__srefill_r>
80124c3c:	103ef726 	beq	r2,zero,8012481c <__reset+0xfa10481c>
80124c40:	003f8906 	br	80124a68 <__reset+0xfa104a68>
80124c44:	e00b883a 	mov	r5,fp
80124c48:	b009883a 	mov	r4,r22
80124c4c:	012a7040 	call	8012a704 <__srefill_r>
80124c50:	103f851e 	bne	r2,zero,80124a68 <__reset+0xfa104a68>
80124c54:	b9c00017 	ldw	r7,0(r23)
80124c58:	003f0f06 	br	80124898 <__reset+0xfa104898>
80124c5c:	014000c4 	movi	r5,3
80124c60:	a1414a26 	beq	r20,r5,8012518c <__svfscanf_r+0x101c>
80124c64:	01000104 	movi	r4,4
80124c68:	a101f11e 	bne	r20,r4,80125430 <__svfscanf_r+0x12c0>
80124c6c:	b009883a 	mov	r4,r22
80124c70:	01284580 	call	80128458 <_localeconv_r>
80124c74:	10800017 	ldw	r2,0(r2)
80124c78:	98ffffc4 	addi	r3,r19,-1
80124c7c:	d880a315 	stw	r2,652(sp)
80124c80:	00805704 	movi	r2,348
80124c84:	10c21e2e 	bgeu	r2,r3,80125500 <__svfscanf_r+0x1390>
80124c88:	9cffa8c4 	addi	r19,r19,-349
80124c8c:	dcc0a215 	stw	r19,648(sp)
80124c90:	04c05744 	movi	r19,349
80124c94:	8d01e014 	ori	r20,r17,1920
80124c98:	0023883a 	mov	r17,zero
80124c9c:	dc000104 	addi	r16,sp,4
80124ca0:	8805883a 	mov	r2,r17
80124ca4:	0019883a 	mov	r12,zero
80124ca8:	8023883a 	mov	r17,r16
80124cac:	b007883a 	mov	r3,r22
80124cb0:	9821883a 	mov	r16,r19
80124cb4:	002b883a 	mov	r21,zero
80124cb8:	d800a515 	stw	zero,660(sp)
80124cbc:	d800a415 	stw	zero,656(sp)
80124cc0:	d8009f15 	stw	zero,636(sp)
80124cc4:	01c01384 	movi	r7,78
80124cc8:	602d883a 	mov	r22,r12
80124ccc:	1027883a 	mov	r19,r2
80124cd0:	e1000017 	ldw	r4,0(fp)
80124cd4:	21400003 	ldbu	r5,0(r4)
80124cd8:	28bff544 	addi	r2,r5,-43
80124cdc:	10803fcc 	andi	r2,r2,255
80124ce0:	38810e36 	bltu	r7,r2,8012511c <__svfscanf_r+0xfac>
80124ce4:	100490ba 	slli	r2,r2,2
80124ce8:	01a004b4 	movhi	r6,32786
80124cec:	31933f04 	addi	r6,r6,19708
80124cf0:	1185883a 	add	r2,r2,r6
80124cf4:	10800017 	ldw	r2,0(r2)
80124cf8:	1000683a 	jmp	r2
80124cfc:	80124ff4 	orhi	zero,r16,18751
80124d00:	8012511c 	xori	zero,r16,18756
80124d04:	80124ff4 	orhi	zero,r16,18751
80124d08:	8012511c 	xori	zero,r16,18756
80124d0c:	8012511c 	xori	zero,r16,18756
80124d10:	80124fc8 	cmpgei	zero,r16,18751
80124d14:	80124e38 	rdprs	zero,r16,18744
80124d18:	80124e38 	rdprs	zero,r16,18744
80124d1c:	80124e38 	rdprs	zero,r16,18744
80124d20:	80124e38 	rdprs	zero,r16,18744
80124d24:	80124e38 	rdprs	zero,r16,18744
80124d28:	80124e38 	rdprs	zero,r16,18744
80124d2c:	80124e38 	rdprs	zero,r16,18744
80124d30:	80124e38 	rdprs	zero,r16,18744
80124d34:	80124e38 	rdprs	zero,r16,18744
80124d38:	8012511c 	xori	zero,r16,18756
80124d3c:	8012511c 	xori	zero,r16,18756
80124d40:	8012511c 	xori	zero,r16,18756
80124d44:	8012511c 	xori	zero,r16,18756
80124d48:	8012511c 	xori	zero,r16,18756
80124d4c:	8012511c 	xori	zero,r16,18756
80124d50:	8012511c 	xori	zero,r16,18756
80124d54:	8012510c 	andi	zero,r16,18756
80124d58:	8012511c 	xori	zero,r16,18756
80124d5c:	8012511c 	xori	zero,r16,18756
80124d60:	8012511c 	xori	zero,r16,18756
80124d64:	801250c8 	cmpgei	zero,r16,18755
80124d68:	801250ac 	andhi	zero,r16,18754
80124d6c:	8012511c 	xori	zero,r16,18756
80124d70:	8012511c 	xori	zero,r16,18756
80124d74:	80125078 	rdprs	zero,r16,18753
80124d78:	8012511c 	xori	zero,r16,18756
80124d7c:	8012511c 	xori	zero,r16,18756
80124d80:	8012511c 	xori	zero,r16,18756
80124d84:	8012511c 	xori	zero,r16,18756
80124d88:	80125040 	call	88012504 <__reset+0x1ff2504>
80124d8c:	8012511c 	xori	zero,r16,18756
80124d90:	8012511c 	xori	zero,r16,18756
80124d94:	8012511c 	xori	zero,r16,18756
80124d98:	8012511c 	xori	zero,r16,18756
80124d9c:	8012511c 	xori	zero,r16,18756
80124da0:	80125024 	muli	zero,r16,18752
80124da4:	8012511c 	xori	zero,r16,18756
80124da8:	8012511c 	xori	zero,r16,18756
80124dac:	8012511c 	xori	zero,r16,18756
80124db0:	8012511c 	xori	zero,r16,18756
80124db4:	80125008 	cmpgei	zero,r16,18752
80124db8:	8012511c 	xori	zero,r16,18756
80124dbc:	8012511c 	xori	zero,r16,18756
80124dc0:	8012511c 	xori	zero,r16,18756
80124dc4:	8012511c 	xori	zero,r16,18756
80124dc8:	8012511c 	xori	zero,r16,18756
80124dcc:	8012511c 	xori	zero,r16,18756
80124dd0:	8012511c 	xori	zero,r16,18756
80124dd4:	8012510c 	andi	zero,r16,18756
80124dd8:	8012511c 	xori	zero,r16,18756
80124ddc:	8012511c 	xori	zero,r16,18756
80124de0:	8012511c 	xori	zero,r16,18756
80124de4:	801250c8 	cmpgei	zero,r16,18755
80124de8:	801250ac 	andhi	zero,r16,18754
80124dec:	8012511c 	xori	zero,r16,18756
80124df0:	8012511c 	xori	zero,r16,18756
80124df4:	80125078 	rdprs	zero,r16,18753
80124df8:	8012511c 	xori	zero,r16,18756
80124dfc:	8012511c 	xori	zero,r16,18756
80124e00:	8012511c 	xori	zero,r16,18756
80124e04:	8012511c 	xori	zero,r16,18756
80124e08:	80125040 	call	88012504 <__reset+0x1ff2504>
80124e0c:	8012511c 	xori	zero,r16,18756
80124e10:	8012511c 	xori	zero,r16,18756
80124e14:	8012511c 	xori	zero,r16,18756
80124e18:	8012511c 	xori	zero,r16,18756
80124e1c:	8012511c 	xori	zero,r16,18756
80124e20:	80125024 	muli	zero,r16,18752
80124e24:	8012511c 	xori	zero,r16,18756
80124e28:	8012511c 	xori	zero,r16,18756
80124e2c:	8012511c 	xori	zero,r16,18756
80124e30:	8012511c 	xori	zero,r16,18756
80124e34:	80125008 	cmpgei	zero,r16,18752
80124e38:	a8803fcc 	andi	r2,r21,255
80124e3c:	1080201c 	xori	r2,r2,128
80124e40:	10bfe004 	addi	r2,r2,-128
80124e44:	b085883a 	add	r2,r22,r2
80124e48:	10000d1e 	bne	r2,zero,80124e80 <__svfscanf_r+0xd10>
80124e4c:	00bf9fc4 	movi	r2,-385
80124e50:	a0a8703a 	and	r20,r20,r2
80124e54:	89400005 	stb	r5,0(r17)
80124e58:	8c400044 	addi	r17,r17,1
80124e5c:	e0800117 	ldw	r2,4(fp)
80124e60:	843fffc4 	addi	r16,r16,-1
80124e64:	94800044 	addi	r18,r18,1
80124e68:	10bfffc4 	addi	r2,r2,-1
80124e6c:	e0800115 	stw	r2,4(fp)
80124e70:	0080b40e 	bge	zero,r2,80125144 <__svfscanf_r+0xfd4>
80124e74:	21000044 	addi	r4,r4,1
80124e78:	e1000015 	stw	r4,0(fp)
80124e7c:	803f941e 	bne	r16,zero,80124cd0 <__reset+0xfa104cd0>
80124e80:	8821883a 	mov	r16,r17
80124e84:	b019883a 	mov	r12,r22
80124e88:	9823883a 	mov	r17,r19
80124e8c:	182d883a 	mov	r22,r3
80124e90:	9801961e 	bne	r19,zero,801254ec <__svfscanf_r+0x137c>
80124e94:	633fffc4 	addi	r12,r12,-1
80124e98:	00800044 	movi	r2,1
80124e9c:	1302882e 	bgeu	r2,r12,801258c0 <__svfscanf_r+0x1750>
80124ea0:	a8803fcc 	andi	r2,r21,255
80124ea4:	1080201c 	xori	r2,r2,128
80124ea8:	10bfe004 	addi	r2,r2,-128
80124eac:	113fffc4 	addi	r4,r2,-1
80124eb0:	01400184 	movi	r5,6
80124eb4:	29001136 	bltu	r5,r4,80124efc <__svfscanf_r+0xd8c>
80124eb8:	01000084 	movi	r4,2
80124ebc:	2082900e 	bge	r4,r2,80125900 <__svfscanf_r+0x1790>
80124ec0:	00c000c4 	movi	r3,3
80124ec4:	10c00d26 	beq	r2,r3,80124efc <__svfscanf_r+0xd8c>
80124ec8:	9425c83a 	sub	r18,r18,r16
80124ecc:	1827883a 	mov	r19,r3
80124ed0:	843fffc4 	addi	r16,r16,-1
80124ed4:	81400007 	ldb	r5,0(r16)
80124ed8:	e00d883a 	mov	r6,fp
80124edc:	b009883a 	mov	r4,r22
80124ee0:	012de8c0 	call	8012de8c <_ungetc_r>
80124ee4:	a8bfffc4 	addi	r2,r21,-1
80124ee8:	10c03fcc 	andi	r3,r2,255
80124eec:	8493883a 	add	r9,r16,r18
80124ef0:	102b883a 	mov	r21,r2
80124ef4:	98fff636 	bltu	r19,r3,80124ed0 <__reset+0xfa104ed0>
80124ef8:	4825883a 	mov	r18,r9
80124efc:	a080400c 	andi	r2,r20,256
80124f00:	10001426 	beq	r2,zero,80124f54 <__svfscanf_r+0xde4>
80124f04:	a081000c 	andi	r2,r20,1024
80124f08:	1002571e 	bne	r2,zero,80125868 <__svfscanf_r+0x16f8>
80124f0c:	817fffc7 	ldb	r5,-1(r16)
80124f10:	00801944 	movi	r2,101
80124f14:	84ffffc4 	addi	r19,r16,-1
80124f18:	957fffc4 	addi	r21,r18,-1
80124f1c:	28800826 	beq	r5,r2,80124f40 <__svfscanf_r+0xdd0>
80124f20:	00801144 	movi	r2,69
80124f24:	28800626 	beq	r5,r2,80124f40 <__svfscanf_r+0xdd0>
80124f28:	e00d883a 	mov	r6,fp
80124f2c:	b009883a 	mov	r4,r22
80124f30:	012de8c0 	call	8012de8c <_ungetc_r>
80124f34:	817fff87 	ldb	r5,-2(r16)
80124f38:	84ffff84 	addi	r19,r16,-2
80124f3c:	957fff84 	addi	r21,r18,-2
80124f40:	e00d883a 	mov	r6,fp
80124f44:	b009883a 	mov	r4,r22
80124f48:	012de8c0 	call	8012de8c <_ungetc_r>
80124f4c:	a825883a 	mov	r18,r21
80124f50:	9821883a 	mov	r16,r19
80124f54:	a080040c 	andi	r2,r20,16
80124f58:	103e891e 	bne	r2,zero,80124980 <__reset+0xfa104980>
80124f5c:	80000005 	stb	zero,0(r16)
80124f60:	a081800c 	andi	r2,r20,1536
80124f64:	01010004 	movi	r4,1024
80124f68:	1101dd26 	beq	r2,r4,801256e0 <__svfscanf_r+0x1570>
80124f6c:	da00a417 	ldw	r8,656(sp)
80124f70:	4001e71e 	bne	r8,zero,80125710 <__svfscanf_r+0x15a0>
80124f74:	000d883a 	mov	r6,zero
80124f78:	d9400104 	addi	r5,sp,4
80124f7c:	b009883a 	mov	r4,r22
80124f80:	012ad240 	call	8012ad24 <_strtod_r>
80124f84:	1021883a 	mov	r16,r2
80124f88:	a080004c 	andi	r2,r20,1
80124f8c:	1000021e 	bne	r2,zero,80124f98 <__svfscanf_r+0xe28>
80124f90:	a2c0008c 	andi	r11,r20,2
80124f94:	5801e826 	beq	r11,zero,80125738 <__svfscanf_r+0x15c8>
80124f98:	da009c17 	ldw	r8,624(sp)
80124f9c:	40800017 	ldw	r2,0(r8)
80124fa0:	42000104 	addi	r8,r8,4
80124fa4:	da009c15 	stw	r8,624(sp)
80124fa8:	14000015 	stw	r16,0(r2)
80124fac:	10c00115 	stw	r3,4(r2)
80124fb0:	da00a017 	ldw	r8,640(sp)
80124fb4:	dd009d17 	ldw	r20,628(sp)
80124fb8:	42000044 	addi	r8,r8,1
80124fbc:	da00a015 	stw	r8,640(sp)
80124fc0:	a00d883a 	mov	r6,r20
80124fc4:	003ca806 	br	80124268 <__reset+0xfa104268>
80124fc8:	a080400c 	andi	r2,r20,256
80124fcc:	103f9a26 	beq	r2,zero,80124e38 <__reset+0xfa104e38>
80124fd0:	da00a217 	ldw	r8,648(sp)
80124fd4:	00bfdfc4 	movi	r2,-129
80124fd8:	a0a8703a 	and	r20,r20,r2
80124fdc:	9cc00044 	addi	r19,r19,1
80124fe0:	403f9e26 	beq	r8,zero,80124e5c <__reset+0xfa104e5c>
80124fe4:	423fffc4 	addi	r8,r8,-1
80124fe8:	da00a215 	stw	r8,648(sp)
80124fec:	84000044 	addi	r16,r16,1
80124ff0:	003f9a06 	br	80124e5c <__reset+0xfa104e5c>
80124ff4:	a080200c 	andi	r2,r20,128
80124ff8:	103fa126 	beq	r2,zero,80124e80 <__reset+0xfa104e80>
80124ffc:	00bfdfc4 	movi	r2,-129
80125000:	a0a8703a 	and	r20,r20,r2
80125004:	003f9306 	br	80124e54 <__reset+0xfa104e54>
80125008:	a8803fcc 	andi	r2,r21,255
8012500c:	1080201c 	xori	r2,r2,128
80125010:	10bfe004 	addi	r2,r2,-128
80125014:	020001c4 	movi	r8,7
80125018:	123f991e 	bne	r2,r8,80124e80 <__reset+0xfa104e80>
8012501c:	05400204 	movi	r21,8
80125020:	003f8c06 	br	80124e54 <__reset+0xfa104e54>
80125024:	a8803fcc 	andi	r2,r21,255
80125028:	1080201c 	xori	r2,r2,128
8012502c:	10bfe004 	addi	r2,r2,-128
80125030:	01800184 	movi	r6,6
80125034:	11bf921e 	bne	r2,r6,80124e80 <__reset+0xfa104e80>
80125038:	054001c4 	movi	r21,7
8012503c:	003f8506 	br	80124e54 <__reset+0xfa104e54>
80125040:	b000491e 	bne	r22,zero,80125168 <__svfscanf_r+0xff8>
80125044:	9800031e 	bne	r19,zero,80125054 <__svfscanf_r+0xee4>
80125048:	a081c00c 	andi	r2,r20,1792
8012504c:	0181c004 	movi	r6,1792
80125050:	11819f26 	beq	r2,r6,801256d0 <__svfscanf_r+0x1560>
80125054:	a8803fcc 	andi	r2,r21,255
80125058:	1080201c 	xori	r2,r2,128
8012505c:	10bfe004 	addi	r2,r2,-128
80125060:	01800044 	movi	r6,1
80125064:	11800226 	beq	r2,r6,80125070 <__svfscanf_r+0xf00>
80125068:	01800104 	movi	r6,4
8012506c:	11bf841e 	bne	r2,r6,80124e80 <__reset+0xfa104e80>
80125070:	ad400044 	addi	r21,r21,1
80125074:	003f7706 	br	80124e54 <__reset+0xfa104e54>
80125078:	a8803fcc 	andi	r2,r21,255
8012507c:	1080201c 	xori	r2,r2,128
80125080:	10bfe004 	addi	r2,r2,-128
80125084:	10003c1e 	bne	r2,zero,80125178 <__svfscanf_r+0x1008>
80125088:	9801141e 	bne	r19,zero,801254dc <__svfscanf_r+0x136c>
8012508c:	a081c00c 	andi	r2,r20,1792
80125090:	0181c004 	movi	r6,1792
80125094:	11818226 	beq	r2,r6,801256a0 <__svfscanf_r+0x1530>
80125098:	8821883a 	mov	r16,r17
8012509c:	b019883a 	mov	r12,r22
801250a0:	9823883a 	mov	r17,r19
801250a4:	182d883a 	mov	r22,r3
801250a8:	003f7a06 	br	80124e94 <__reset+0xfa104e94>
801250ac:	a8803fcc 	andi	r2,r21,255
801250b0:	1080201c 	xori	r2,r2,128
801250b4:	10bfe004 	addi	r2,r2,-128
801250b8:	01800084 	movi	r6,2
801250bc:	11bf701e 	bne	r2,r6,80124e80 <__reset+0xfa104e80>
801250c0:	054000c4 	movi	r21,3
801250c4:	003f6306 	br	80124e54 <__reset+0xfa104e54>
801250c8:	a081400c 	andi	r2,r20,1280
801250cc:	01810004 	movi	r6,1024
801250d0:	11800326 	beq	r2,r6,801250e0 <__svfscanf_r+0xf70>
801250d4:	a184703a 	and	r2,r20,r6
801250d8:	103f6926 	beq	r2,zero,80124e80 <__reset+0xfa104e80>
801250dc:	983fee26 	beq	r19,zero,80125098 <__reset+0xfa105098>
801250e0:	a080800c 	andi	r2,r20,512
801250e4:	1000041e 	bne	r2,zero,801250f8 <__svfscanf_r+0xf88>
801250e8:	da009f17 	ldw	r8,636(sp)
801250ec:	dc40a515 	stw	r17,660(sp)
801250f0:	9a27c83a 	sub	r19,r19,r8
801250f4:	dcc0a415 	stw	r19,656(sp)
801250f8:	00be1fc4 	movi	r2,-1921
801250fc:	a0a8703a 	and	r20,r20,r2
80125100:	a5006014 	ori	r20,r20,384
80125104:	0027883a 	mov	r19,zero
80125108:	003f5206 	br	80124e54 <__reset+0xfa104e54>
8012510c:	00800044 	movi	r2,1
80125110:	b0bf5b1e 	bne	r22,r2,80124e80 <__reset+0xfa104e80>
80125114:	05800084 	movi	r22,2
80125118:	003f4e06 	br	80124e54 <__reset+0xfa104e54>
8012511c:	d980a317 	ldw	r6,652(sp)
80125120:	30800003 	ldbu	r2,0(r6)
80125124:	29803fcc 	andi	r6,r5,255
80125128:	30bf551e 	bne	r6,r2,80124e80 <__reset+0xfa104e80>
8012512c:	a080800c 	andi	r2,r20,512
80125130:	103f5326 	beq	r2,zero,80124e80 <__reset+0xfa104e80>
80125134:	023f5fc4 	movi	r8,-641
80125138:	a228703a 	and	r20,r20,r8
8012513c:	dcc09f15 	stw	r19,636(sp)
80125140:	003f4406 	br	80124e54 <__reset+0xfa104e54>
80125144:	1809883a 	mov	r4,r3
80125148:	e00b883a 	mov	r5,fp
8012514c:	d8c0a615 	stw	r3,664(sp)
80125150:	d9c0aa15 	stw	r7,680(sp)
80125154:	012a7040 	call	8012a704 <__srefill_r>
80125158:	d8c0a617 	ldw	r3,664(sp)
8012515c:	d9c0aa17 	ldw	r7,680(sp)
80125160:	103f4626 	beq	r2,zero,80124e7c <__reset+0xfa104e7c>
80125164:	003f4606 	br	80124e80 <__reset+0xfa104e80>
80125168:	00800084 	movi	r2,2
8012516c:	b0bfb91e 	bne	r22,r2,80125054 <__reset+0xfa105054>
80125170:	058000c4 	movi	r22,3
80125174:	003f3706 	br	80124e54 <__reset+0xfa104e54>
80125178:	018000c4 	movi	r6,3
8012517c:	11bfbc26 	beq	r2,r6,80125070 <__reset+0xfa105070>
80125180:	01800144 	movi	r6,5
80125184:	11bfba26 	beq	r2,r6,80125070 <__reset+0xfa105070>
80125188:	003f3d06 	br	80124e80 <__reset+0xfa104e80>
8012518c:	98bfffc4 	addi	r2,r19,-1
80125190:	01405704 	movi	r5,348
80125194:	2880d82e 	bgeu	r5,r2,801254f8 <__svfscanf_r+0x1388>
80125198:	99ffa8c4 	addi	r7,r19,-349
8012519c:	04c05744 	movi	r19,349
801251a0:	8c436014 	ori	r17,r17,3456
801251a4:	9013883a 	mov	r9,r18
801251a8:	8825883a 	mov	r18,r17
801251ac:	dc409e17 	ldw	r17,632(sp)
801251b0:	0029883a 	mov	r20,zero
801251b4:	dc000104 	addi	r16,sp,4
801251b8:	05401344 	movi	r21,77
801251bc:	02c08004 	movi	r11,512
801251c0:	01bf7fc4 	movi	r6,-513
801251c4:	023fdfc4 	movi	r8,-129
801251c8:	20bff544 	addi	r2,r4,-43
801251cc:	10803fcc 	andi	r2,r2,255
801251d0:	a8807236 	bltu	r21,r2,8012539c <__svfscanf_r+0x122c>
801251d4:	100490ba 	slli	r2,r2,2
801251d8:	016004b4 	movhi	r5,32786
801251dc:	29547b04 	addi	r5,r5,20972
801251e0:	1145883a 	add	r2,r2,r5
801251e4:	10800017 	ldw	r2,0(r2)
801251e8:	1000683a 	jmp	r2
801251ec:	80125420 	cmpeqi	zero,r16,18768
801251f0:	8012539c 	xori	zero,r16,18766
801251f4:	80125420 	cmpeqi	zero,r16,18768
801251f8:	8012539c 	xori	zero,r16,18766
801251fc:	8012539c 	xori	zero,r16,18766
80125200:	801253f8 	rdprs	zero,r16,18767
80125204:	801253d8 	cmpnei	zero,r16,18767
80125208:	801253d8 	cmpnei	zero,r16,18767
8012520c:	801253d8 	cmpnei	zero,r16,18767
80125210:	801253d8 	cmpnei	zero,r16,18767
80125214:	801253d8 	cmpnei	zero,r16,18767
80125218:	801253d8 	cmpnei	zero,r16,18767
8012521c:	801253d8 	cmpnei	zero,r16,18767
80125220:	80125380 	call	88012538 <__reset+0x1ff2538>
80125224:	80125380 	call	88012538 <__reset+0x1ff2538>
80125228:	8012539c 	xori	zero,r16,18766
8012522c:	8012539c 	xori	zero,r16,18766
80125230:	8012539c 	xori	zero,r16,18766
80125234:	8012539c 	xori	zero,r16,18766
80125238:	8012539c 	xori	zero,r16,18766
8012523c:	8012539c 	xori	zero,r16,18766
80125240:	8012539c 	xori	zero,r16,18766
80125244:	8012536c 	andhi	zero,r16,18765
80125248:	8012536c 	andhi	zero,r16,18765
8012524c:	8012536c 	andhi	zero,r16,18765
80125250:	8012536c 	andhi	zero,r16,18765
80125254:	8012536c 	andhi	zero,r16,18765
80125258:	8012536c 	andhi	zero,r16,18765
8012525c:	8012539c 	xori	zero,r16,18766
80125260:	8012539c 	xori	zero,r16,18766
80125264:	8012539c 	xori	zero,r16,18766
80125268:	8012539c 	xori	zero,r16,18766
8012526c:	8012539c 	xori	zero,r16,18766
80125270:	8012539c 	xori	zero,r16,18766
80125274:	8012539c 	xori	zero,r16,18766
80125278:	8012539c 	xori	zero,r16,18766
8012527c:	8012539c 	xori	zero,r16,18766
80125280:	8012539c 	xori	zero,r16,18766
80125284:	8012539c 	xori	zero,r16,18766
80125288:	8012539c 	xori	zero,r16,18766
8012528c:	8012539c 	xori	zero,r16,18766
80125290:	8012539c 	xori	zero,r16,18766
80125294:	8012539c 	xori	zero,r16,18766
80125298:	8012539c 	xori	zero,r16,18766
8012529c:	8012539c 	xori	zero,r16,18766
801252a0:	80125324 	muli	zero,r16,18764
801252a4:	8012539c 	xori	zero,r16,18766
801252a8:	8012539c 	xori	zero,r16,18766
801252ac:	8012539c 	xori	zero,r16,18766
801252b0:	8012539c 	xori	zero,r16,18766
801252b4:	8012539c 	xori	zero,r16,18766
801252b8:	8012539c 	xori	zero,r16,18766
801252bc:	8012539c 	xori	zero,r16,18766
801252c0:	8012539c 	xori	zero,r16,18766
801252c4:	8012536c 	andhi	zero,r16,18765
801252c8:	8012536c 	andhi	zero,r16,18765
801252cc:	8012536c 	andhi	zero,r16,18765
801252d0:	8012536c 	andhi	zero,r16,18765
801252d4:	8012536c 	andhi	zero,r16,18765
801252d8:	8012536c 	andhi	zero,r16,18765
801252dc:	8012539c 	xori	zero,r16,18766
801252e0:	8012539c 	xori	zero,r16,18766
801252e4:	8012539c 	xori	zero,r16,18766
801252e8:	8012539c 	xori	zero,r16,18766
801252ec:	8012539c 	xori	zero,r16,18766
801252f0:	8012539c 	xori	zero,r16,18766
801252f4:	8012539c 	xori	zero,r16,18766
801252f8:	8012539c 	xori	zero,r16,18766
801252fc:	8012539c 	xori	zero,r16,18766
80125300:	8012539c 	xori	zero,r16,18766
80125304:	8012539c 	xori	zero,r16,18766
80125308:	8012539c 	xori	zero,r16,18766
8012530c:	8012539c 	xori	zero,r16,18766
80125310:	8012539c 	xori	zero,r16,18766
80125314:	8012539c 	xori	zero,r16,18766
80125318:	8012539c 	xori	zero,r16,18766
8012531c:	8012539c 	xori	zero,r16,18766
80125320:	80125324 	muli	zero,r16,18764
80125324:	9081800c 	andi	r2,r18,1536
80125328:	12c01c1e 	bne	r2,r11,8012539c <__svfscanf_r+0x122c>
8012532c:	91a4703a 	and	r18,r18,r6
80125330:	94814014 	ori	r18,r18,1280
80125334:	04400404 	movi	r17,16
80125338:	81000005 	stb	r4,0(r16)
8012533c:	84000044 	addi	r16,r16,1
80125340:	e0800117 	ldw	r2,4(fp)
80125344:	10bfffc4 	addi	r2,r2,-1
80125348:	e0800115 	stw	r2,4(fp)
8012534c:	0080540e 	bge	zero,r2,801254a0 <__svfscanf_r+0x1330>
80125350:	18c00044 	addi	r3,r3,1
80125354:	e0c00015 	stw	r3,0(fp)
80125358:	9cffffc4 	addi	r19,r19,-1
8012535c:	98000f26 	beq	r19,zero,8012539c <__svfscanf_r+0x122c>
80125360:	e0c00017 	ldw	r3,0(fp)
80125364:	19000003 	ldbu	r4,0(r3)
80125368:	003f9706 	br	801251c8 <__reset+0xfa1051c8>
8012536c:	00800284 	movi	r2,10
80125370:	14400a0e 	bge	r2,r17,8012539c <__svfscanf_r+0x122c>
80125374:	00bd1fc4 	movi	r2,-2945
80125378:	90a4703a 	and	r18,r18,r2
8012537c:	003fee06 	br	80125338 <__reset+0xfa105338>
80125380:	01600534 	movhi	r5,32788
80125384:	8c63883a 	add	r17,r17,r17
80125388:	295eda84 	addi	r5,r5,31594
8012538c:	2c45883a 	add	r2,r5,r17
80125390:	1440000f 	ldh	r17,0(r2)
80125394:	00800204 	movi	r2,8
80125398:	147ff616 	blt	r2,r17,80125374 <__reset+0xfa105374>
8012539c:	dc409e15 	stw	r17,632(sp)
801253a0:	9023883a 	mov	r17,r18
801253a4:	8880400c 	andi	r2,r17,256
801253a8:	4825883a 	mov	r18,r9
801253ac:	10000426 	beq	r2,zero,801253c0 <__svfscanf_r+0x1250>
801253b0:	d9800104 	addi	r6,sp,4
801253b4:	3400be36 	bltu	r6,r16,801256b0 <__svfscanf_r+0x1540>
801253b8:	da000104 	addi	r8,sp,4
801253bc:	443bae26 	beq	r8,r16,80124278 <__reset+0xfa104278>
801253c0:	8880040c 	andi	r2,r17,16
801253c4:	10009326 	beq	r2,zero,80125614 <__svfscanf_r+0x14a4>
801253c8:	d8800104 	addi	r2,sp,4
801253cc:	80a1c83a 	sub	r16,r16,r2
801253d0:	8521883a 	add	r16,r16,r20
801253d4:	003d0606 	br	801247f0 <__reset+0xfa1047f0>
801253d8:	01600534 	movhi	r5,32788
801253dc:	8c63883a 	add	r17,r17,r17
801253e0:	295eda84 	addi	r5,r5,31594
801253e4:	2c45883a 	add	r2,r5,r17
801253e8:	1440000f 	ldh	r17,0(r2)
801253ec:	00bd1fc4 	movi	r2,-2945
801253f0:	90a4703a 	and	r18,r18,r2
801253f4:	003fd006 	br	80125338 <__reset+0xfa105338>
801253f8:	9082000c 	andi	r2,r18,2048
801253fc:	103fce26 	beq	r2,zero,80125338 <__reset+0xfa105338>
80125400:	8800021e 	bne	r17,zero,8012540c <__svfscanf_r+0x129c>
80125404:	94808014 	ori	r18,r18,512
80125408:	04400204 	movi	r17,8
8012540c:	9081000c 	andi	r2,r18,1024
80125410:	10009426 	beq	r2,zero,80125664 <__svfscanf_r+0x14f4>
80125414:	00be9fc4 	movi	r2,-1409
80125418:	90a4703a 	and	r18,r18,r2
8012541c:	003fc606 	br	80125338 <__reset+0xfa105338>
80125420:	9080200c 	andi	r2,r18,128
80125424:	103fdd26 	beq	r2,zero,8012539c <__reset+0xfa10539c>
80125428:	9224703a 	and	r18,r18,r8
8012542c:	003fc206 	br	80125338 <__reset+0xfa105338>
80125430:	9800011e 	bne	r19,zero,80125438 <__svfscanf_r+0x12c8>
80125434:	04ffffc4 	movi	r19,-1
80125438:	8900004c 	andi	r4,r17,1
8012543c:	20005b1e 	bne	r4,zero,801255ac <__svfscanf_r+0x143c>
80125440:	8c40040c 	andi	r17,r17,16
80125444:	88003026 	beq	r17,zero,80125508 <__svfscanf_r+0x1398>
80125448:	0021883a 	mov	r16,zero
8012544c:	00000306 	br	8012545c <__svfscanf_r+0x12ec>
80125450:	18800003 	ldbu	r2,0(r3)
80125454:	3885883a 	add	r2,r7,r2
80125458:	10800043 	ldbu	r2,1(r2)
8012545c:	1080020c 	andi	r2,r2,8
80125460:	103ce31e 	bne	r2,zero,801247f0 <__reset+0xfa1047f0>
80125464:	e0800117 	ldw	r2,4(fp)
80125468:	18c00044 	addi	r3,r3,1
8012546c:	84000044 	addi	r16,r16,1
80125470:	10bfffc4 	addi	r2,r2,-1
80125474:	e0800115 	stw	r2,4(fp)
80125478:	e0c00015 	stw	r3,0(fp)
8012547c:	84fcdc26 	beq	r16,r19,801247f0 <__reset+0xfa1047f0>
80125480:	00bff316 	blt	zero,r2,80125450 <__reset+0xfa105450>
80125484:	e00b883a 	mov	r5,fp
80125488:	b009883a 	mov	r4,r22
8012548c:	012a7040 	call	8012a704 <__srefill_r>
80125490:	103cd71e 	bne	r2,zero,801247f0 <__reset+0xfa1047f0>
80125494:	b9c00017 	ldw	r7,0(r23)
80125498:	e0c00017 	ldw	r3,0(fp)
8012549c:	003fec06 	br	80125450 <__reset+0xfa105450>
801254a0:	e00b883a 	mov	r5,fp
801254a4:	b009883a 	mov	r4,r22
801254a8:	d980a715 	stw	r6,668(sp)
801254ac:	d9c0aa15 	stw	r7,680(sp)
801254b0:	da00a815 	stw	r8,672(sp)
801254b4:	da40a915 	stw	r9,676(sp)
801254b8:	dac0a615 	stw	r11,664(sp)
801254bc:	012a7040 	call	8012a704 <__srefill_r>
801254c0:	d980a717 	ldw	r6,668(sp)
801254c4:	d9c0aa17 	ldw	r7,680(sp)
801254c8:	da00a817 	ldw	r8,672(sp)
801254cc:	da40a917 	ldw	r9,676(sp)
801254d0:	dac0a617 	ldw	r11,664(sp)
801254d4:	103fa026 	beq	r2,zero,80125358 <__reset+0xfa105358>
801254d8:	003fb006 	br	8012539c <__reset+0xfa10539c>
801254dc:	8821883a 	mov	r16,r17
801254e0:	b019883a 	mov	r12,r22
801254e4:	9823883a 	mov	r17,r19
801254e8:	182d883a 	mov	r22,r3
801254ec:	00bfbfc4 	movi	r2,-257
801254f0:	a0a8703a 	and	r20,r20,r2
801254f4:	003e6706 	br	80124e94 <__reset+0xfa104e94>
801254f8:	000f883a 	mov	r7,zero
801254fc:	003f2806 	br	801251a0 <__reset+0xfa1051a0>
80125500:	d800a215 	stw	zero,648(sp)
80125504:	003de306 	br	80124c94 <__reset+0xfa104c94>
80125508:	da009c17 	ldw	r8,624(sp)
8012550c:	9abfffc4 	addi	r10,r19,-1
80125510:	44400017 	ldw	r17,0(r8)
80125514:	44000104 	addi	r16,r8,4
80125518:	880b883a 	mov	r5,r17
8012551c:	8aa9883a 	add	r20,r17,r10
80125520:	00000606 	br	8012553c <__svfscanf_r+0x13cc>
80125524:	e0c00017 	ldw	r3,0(fp)
80125528:	b9000017 	ldw	r4,0(r23)
8012552c:	a80b883a 	mov	r5,r21
80125530:	18800003 	ldbu	r2,0(r3)
80125534:	2085883a 	add	r2,r4,r2
80125538:	10800043 	ldbu	r2,1(r2)
8012553c:	1080020c 	andi	r2,r2,8
80125540:	1000551e 	bne	r2,zero,80125698 <__svfscanf_r+0x1528>
80125544:	e0800117 	ldw	r2,4(fp)
80125548:	19000044 	addi	r4,r3,1
8012554c:	e1000015 	stw	r4,0(fp)
80125550:	10bfffc4 	addi	r2,r2,-1
80125554:	e0800115 	stw	r2,4(fp)
80125558:	18800003 	ldbu	r2,0(r3)
8012555c:	2d400044 	addi	r21,r5,1
80125560:	a827883a 	mov	r19,r21
80125564:	28800005 	stb	r2,0(r5)
80125568:	2d000626 	beq	r5,r20,80125584 <__svfscanf_r+0x1414>
8012556c:	e0800117 	ldw	r2,4(fp)
80125570:	00bfec16 	blt	zero,r2,80125524 <__reset+0xfa105524>
80125574:	e00b883a 	mov	r5,fp
80125578:	b009883a 	mov	r4,r22
8012557c:	012a7040 	call	8012a704 <__srefill_r>
80125580:	103fe826 	beq	r2,zero,80125524 <__reset+0xfa105524>
80125584:	da00a017 	ldw	r8,640(sp)
80125588:	dd009d17 	ldw	r20,628(sp)
8012558c:	9c63c83a 	sub	r17,r19,r17
80125590:	42000044 	addi	r8,r8,1
80125594:	98000005 	stb	zero,0(r19)
80125598:	9465883a 	add	r18,r18,r17
8012559c:	da00a015 	stw	r8,640(sp)
801255a0:	dc009c15 	stw	r16,624(sp)
801255a4:	a00d883a 	mov	r6,r20
801255a8:	003b2f06 	br	80124268 <__reset+0xfa104268>
801255ac:	dd409904 	addi	r21,sp,612
801255b0:	8c40040c 	andi	r17,r17,16
801255b4:	01800204 	movi	r6,8
801255b8:	000b883a 	mov	r5,zero
801255bc:	a809883a 	mov	r4,r21
801255c0:	01215b40 	call	801215b4 <memset>
801255c4:	8800401e 	bne	r17,zero,801256c8 <__svfscanf_r+0x1558>
801255c8:	da009c17 	ldw	r8,624(sp)
801255cc:	45000017 	ldw	r20,0(r8)
801255d0:	42000104 	addi	r8,r8,4
801255d4:	da009c15 	stw	r8,624(sp)
801255d8:	000d883a 	mov	r6,zero
801255dc:	3021883a 	mov	r16,r6
801255e0:	dc409f15 	stw	r17,636(sp)
801255e4:	e0800017 	ldw	r2,0(fp)
801255e8:	b8c00017 	ldw	r3,0(r23)
801255ec:	10800003 	ldbu	r2,0(r2)
801255f0:	1885883a 	add	r2,r3,r2
801255f4:	10800043 	ldbu	r2,1(r2)
801255f8:	1080020c 	andi	r2,r2,8
801255fc:	1000011e 	bne	r2,zero,80125604 <__svfscanf_r+0x1494>
80125600:	9800701e 	bne	r19,zero,801257c4 <__svfscanf_r+0x1654>
80125604:	dc409f17 	ldw	r17,636(sp)
80125608:	883cdd1e 	bne	r17,zero,80124980 <__reset+0xfa104980>
8012560c:	a0000015 	stw	zero,0(r20)
80125610:	003cd806 	br	80124974 <__reset+0xfa104974>
80125614:	d9c09e17 	ldw	r7,632(sp)
80125618:	da00a117 	ldw	r8,644(sp)
8012561c:	000d883a 	mov	r6,zero
80125620:	d9400104 	addi	r5,sp,4
80125624:	b009883a 	mov	r4,r22
80125628:	80000005 	stb	zero,0(r16)
8012562c:	403ee83a 	callr	r8
80125630:	88c0080c 	andi	r3,r17,32
80125634:	1800121e 	bne	r3,zero,80125680 <__svfscanf_r+0x1510>
80125638:	88c0010c 	andi	r3,r17,4
8012563c:	18004d26 	beq	r3,zero,80125774 <__svfscanf_r+0x1604>
80125640:	da009c17 	ldw	r8,624(sp)
80125644:	40c00017 	ldw	r3,0(r8)
80125648:	42000104 	addi	r8,r8,4
8012564c:	da009c15 	stw	r8,624(sp)
80125650:	1880000d 	sth	r2,0(r3)
80125654:	da00a017 	ldw	r8,640(sp)
80125658:	42000044 	addi	r8,r8,1
8012565c:	da00a015 	stw	r8,640(sp)
80125660:	003f5906 	br	801253c8 <__reset+0xfa1053c8>
80125664:	00bf1fc4 	movi	r2,-897
80125668:	90a4703a 	and	r18,r18,r2
8012566c:	38000226 	beq	r7,zero,80125678 <__svfscanf_r+0x1508>
80125670:	39ffffc4 	addi	r7,r7,-1
80125674:	9cc00044 	addi	r19,r19,1
80125678:	a5000044 	addi	r20,r20,1
8012567c:	003f3006 	br	80125340 <__reset+0xfa105340>
80125680:	da009c17 	ldw	r8,624(sp)
80125684:	40c00017 	ldw	r3,0(r8)
80125688:	42000104 	addi	r8,r8,4
8012568c:	da009c15 	stw	r8,624(sp)
80125690:	18800015 	stw	r2,0(r3)
80125694:	003fef06 	br	80125654 <__reset+0xfa105654>
80125698:	2827883a 	mov	r19,r5
8012569c:	003fb906 	br	80125584 <__reset+0xfa105584>
801256a0:	01be1fc4 	movi	r6,-1921
801256a4:	a1a8703a 	and	r20,r20,r6
801256a8:	05400044 	movi	r21,1
801256ac:	003de906 	br	80124e54 <__reset+0xfa104e54>
801256b0:	817fffc7 	ldb	r5,-1(r16)
801256b4:	e00d883a 	mov	r6,fp
801256b8:	b009883a 	mov	r4,r22
801256bc:	843fffc4 	addi	r16,r16,-1
801256c0:	012de8c0 	call	8012de8c <_ungetc_r>
801256c4:	003f3c06 	br	801253b8 <__reset+0xfa1053b8>
801256c8:	dd009b04 	addi	r20,sp,620
801256cc:	003fc206 	br	801255d8 <__reset+0xfa1055d8>
801256d0:	00be1fc4 	movi	r2,-1921
801256d4:	a0a8703a 	and	r20,r20,r2
801256d8:	05800044 	movi	r22,1
801256dc:	003ddd06 	br	80124e54 <__reset+0xfa104e54>
801256e0:	d8c09f17 	ldw	r3,636(sp)
801256e4:	88e3c83a 	sub	r17,r17,r3
801256e8:	044dc83a 	sub	r6,zero,r17
801256ec:	883e2126 	beq	r17,zero,80124f74 <__reset+0xfa104f74>
801256f0:	d88055c4 	addi	r2,sp,343
801256f4:	80800136 	bltu	r16,r2,801256fc <__svfscanf_r+0x158c>
801256f8:	dc005584 	addi	r16,sp,342
801256fc:	01600534 	movhi	r5,32788
80125700:	295ed904 	addi	r5,r5,31588
80125704:	8009883a 	mov	r4,r16
80125708:	01218940 	call	80121894 <sprintf>
8012570c:	003e1906 	br	80124f74 <__reset+0xfa104f74>
80125710:	d8c0a517 	ldw	r3,660(sp)
80125714:	000d883a 	mov	r6,zero
80125718:	01c00284 	movi	r7,10
8012571c:	19400044 	addi	r5,r3,1
80125720:	b009883a 	mov	r4,r22
80125724:	0121a300 	call	80121a30 <_strtol_r>
80125728:	da00a417 	ldw	r8,656(sp)
8012572c:	dc00a517 	ldw	r16,660(sp)
80125730:	120dc83a 	sub	r6,r2,r8
80125734:	003fee06 	br	801256f0 <__reset+0xfa1056f0>
80125738:	da009c17 	ldw	r8,624(sp)
8012573c:	180b883a 	mov	r5,r3
80125740:	8009883a 	mov	r4,r16
80125744:	45000017 	ldw	r20,0(r8)
80125748:	44400104 	addi	r17,r8,4
8012574c:	d8c0a615 	stw	r3,664(sp)
80125750:	012a8e00 	call	8012a8e0 <__fpclassifyd>
80125754:	d8c0a617 	ldw	r3,664(sp)
80125758:	10006426 	beq	r2,zero,801258ec <__svfscanf_r+0x177c>
8012575c:	8009883a 	mov	r4,r16
80125760:	180b883a 	mov	r5,r3
80125764:	01212280 	call	80121228 <__truncdfsf2>
80125768:	a0800015 	stw	r2,0(r20)
8012576c:	dc409c15 	stw	r17,624(sp)
80125770:	003e0f06 	br	80124fb0 <__reset+0xfa104fb0>
80125774:	88c0004c 	andi	r3,r17,1
80125778:	183fc11e 	bne	r3,zero,80125680 <__reset+0xfa105680>
8012577c:	8c40008c 	andi	r17,r17,2
80125780:	883fbf26 	beq	r17,zero,80125680 <__reset+0xfa105680>
80125784:	da00a117 	ldw	r8,644(sp)
80125788:	00a004f4 	movhi	r2,32787
8012578c:	10b11104 	addi	r2,r2,-15292
80125790:	d9c09e17 	ldw	r7,632(sp)
80125794:	000d883a 	mov	r6,zero
80125798:	d9400104 	addi	r5,sp,4
8012579c:	b009883a 	mov	r4,r22
801257a0:	40806226 	beq	r8,r2,8012592c <__svfscanf_r+0x17bc>
801257a4:	0121ca80 	call	80121ca8 <_strtoll_r>
801257a8:	da009c17 	ldw	r8,624(sp)
801257ac:	41000017 	ldw	r4,0(r8)
801257b0:	42000104 	addi	r8,r8,4
801257b4:	da009c15 	stw	r8,624(sp)
801257b8:	20800015 	stw	r2,0(r4)
801257bc:	20c00115 	stw	r3,4(r4)
801257c0:	003fa406 	br	80125654 <__reset+0xfa105654>
801257c4:	01284340 	call	80128434 <__locale_mb_cur_max>
801257c8:	80bca726 	beq	r16,r2,80124a68 <__reset+0xfa104a68>
801257cc:	e0800017 	ldw	r2,0(fp)
801257d0:	e1000117 	ldw	r4,4(fp)
801257d4:	d8c00104 	addi	r3,sp,4
801257d8:	12000003 	ldbu	r8,0(r2)
801257dc:	213fffc4 	addi	r4,r4,-1
801257e0:	10800044 	addi	r2,r2,1
801257e4:	e1000115 	stw	r4,4(fp)
801257e8:	e0800015 	stw	r2,0(fp)
801257ec:	84400044 	addi	r17,r16,1
801257f0:	dd400015 	stw	r21,0(sp)
801257f4:	1c21883a 	add	r16,r3,r16
801257f8:	b009883a 	mov	r4,r22
801257fc:	880f883a 	mov	r7,r17
80125800:	180d883a 	mov	r6,r3
80125804:	a00b883a 	mov	r5,r20
80125808:	82000005 	stb	r8,0(r16)
8012580c:	0128c9c0 	call	80128c9c <_mbrtowc_r>
80125810:	013fffc4 	movi	r4,-1
80125814:	113c9426 	beq	r2,r4,80124a68 <__reset+0xfa104a68>
80125818:	103c881e 	bne	r2,zero,80124a3c <__reset+0xfa104a3c>
8012581c:	a0000015 	stw	zero,0(r20)
80125820:	0009883a 	mov	r4,zero
80125824:	01283740 	call	80128374 <iswspace>
80125828:	10001a26 	beq	r2,zero,80125894 <__svfscanf_r+0x1724>
8012582c:	8821883a 	mov	r16,r17
80125830:	dc409f17 	ldw	r17,636(sp)
80125834:	803f7426 	beq	r16,zero,80125608 <__reset+0xfa105608>
80125838:	843fffc4 	addi	r16,r16,-1
8012583c:	d9800104 	addi	r6,sp,4
80125840:	342b883a 	add	r21,r6,r16
80125844:	00000106 	br	8012584c <__svfscanf_r+0x16dc>
80125848:	843fffc4 	addi	r16,r16,-1
8012584c:	a9400003 	ldbu	r5,0(r21)
80125850:	e00d883a 	mov	r6,fp
80125854:	b009883a 	mov	r4,r22
80125858:	012de8c0 	call	8012de8c <_ungetc_r>
8012585c:	ad7fffc4 	addi	r21,r21,-1
80125860:	803ff91e 	bne	r16,zero,80125848 <__reset+0xfa105848>
80125864:	003f6806 	br	80125608 <__reset+0xfa105608>
80125868:	d9800104 	addi	r6,sp,4
8012586c:	802b883a 	mov	r21,r16
80125870:	343a812e 	bgeu	r6,r16,80124278 <__reset+0xfa104278>
80125874:	ad7fffc4 	addi	r21,r21,-1
80125878:	a9400007 	ldb	r5,0(r21)
8012587c:	e00d883a 	mov	r6,fp
80125880:	b009883a 	mov	r4,r22
80125884:	012de8c0 	call	8012de8c <_ungetc_r>
80125888:	da000104 	addi	r8,sp,4
8012588c:	457ff91e 	bne	r8,r21,80125874 <__reset+0xfa105874>
80125890:	003a7906 	br	80124278 <__reset+0xfa104278>
80125894:	da009f17 	ldw	r8,636(sp)
80125898:	9465883a 	add	r18,r18,r17
8012589c:	9cffffc4 	addi	r19,r19,-1
801258a0:	4000051e 	bne	r8,zero,801258b8 <__svfscanf_r+0x1748>
801258a4:	a5000104 	addi	r20,r20,4
801258a8:	0021883a 	mov	r16,zero
801258ac:	003c6606 	br	80124a48 <__reset+0xfa104a48>
801258b0:	a1000017 	ldw	r4,0(r20)
801258b4:	003fdb06 	br	80125824 <__reset+0xfa105824>
801258b8:	0021883a 	mov	r16,zero
801258bc:	003c6206 	br	80124a48 <__reset+0xfa104a48>
801258c0:	d8800104 	addi	r2,sp,4
801258c4:	802b883a 	mov	r21,r16
801258c8:	143a6b2e 	bgeu	r2,r16,80124278 <__reset+0xfa104278>
801258cc:	ad7fffc4 	addi	r21,r21,-1
801258d0:	a9400007 	ldb	r5,0(r21)
801258d4:	e00d883a 	mov	r6,fp
801258d8:	b009883a 	mov	r4,r22
801258dc:	012de8c0 	call	8012de8c <_ungetc_r>
801258e0:	d8c00104 	addi	r3,sp,4
801258e4:	1d7ff91e 	bne	r3,r21,801258cc <__reset+0xfa1058cc>
801258e8:	003a6306 	br	80124278 <__reset+0xfa104278>
801258ec:	0009883a 	mov	r4,zero
801258f0:	012aa800 	call	8012aa80 <nanf>
801258f4:	a0800015 	stw	r2,0(r20)
801258f8:	dc409c15 	stw	r17,624(sp)
801258fc:	003dac06 	br	80124fb0 <__reset+0xfa104fb0>
80125900:	d9000104 	addi	r4,sp,4
80125904:	802b883a 	mov	r21,r16
80125908:	243a5b2e 	bgeu	r4,r16,80124278 <__reset+0xfa104278>
8012590c:	ad7fffc4 	addi	r21,r21,-1
80125910:	a9400007 	ldb	r5,0(r21)
80125914:	e00d883a 	mov	r6,fp
80125918:	b009883a 	mov	r4,r22
8012591c:	012de8c0 	call	8012de8c <_ungetc_r>
80125920:	d9400104 	addi	r5,sp,4
80125924:	2d7ff91e 	bne	r5,r21,8012590c <__reset+0xfa10590c>
80125928:	003a5306 	br	80124278 <__reset+0xfa104278>
8012592c:	012c6b40 	call	8012c6b4 <_strtoull_r>
80125930:	003f9d06 	br	801257a8 <__reset+0xfa1057a8>

80125934 <vfscanf>:
80125934:	00a00574 	movhi	r2,32789
80125938:	defffb04 	addi	sp,sp,-20
8012593c:	10a88704 	addi	r2,r2,-24036
80125940:	de00012e 	bgeu	sp,et,80125948 <vfscanf+0x14>
80125944:	003b68fa 	trap	3
80125948:	dc000215 	stw	r16,8(sp)
8012594c:	14000017 	ldw	r16,0(r2)
80125950:	dc400315 	stw	r17,12(sp)
80125954:	dfc00415 	stw	ra,16(sp)
80125958:	2023883a 	mov	r17,r4
8012595c:	80000826 	beq	r16,zero,80125980 <vfscanf+0x4c>
80125960:	80800e17 	ldw	r2,56(r16)
80125964:	1000061e 	bne	r2,zero,80125980 <vfscanf+0x4c>
80125968:	8009883a 	mov	r4,r16
8012596c:	d9400015 	stw	r5,0(sp)
80125970:	d9800115 	stw	r6,4(sp)
80125974:	01276140 	call	80127614 <__sinit>
80125978:	d9800117 	ldw	r6,4(sp)
8012597c:	d9400017 	ldw	r5,0(sp)
80125980:	300f883a 	mov	r7,r6
80125984:	8009883a 	mov	r4,r16
80125988:	280d883a 	mov	r6,r5
8012598c:	880b883a 	mov	r5,r17
80125990:	dfc00417 	ldw	ra,16(sp)
80125994:	dc400317 	ldw	r17,12(sp)
80125998:	dc000217 	ldw	r16,8(sp)
8012599c:	dec00504 	addi	sp,sp,20
801259a0:	01241701 	jmpi	80124170 <__svfscanf_r>

801259a4 <__svfscanf>:
801259a4:	00a00574 	movhi	r2,32789
801259a8:	10a88704 	addi	r2,r2,-24036
801259ac:	300f883a 	mov	r7,r6
801259b0:	280d883a 	mov	r6,r5
801259b4:	200b883a 	mov	r5,r4
801259b8:	11000017 	ldw	r4,0(r2)
801259bc:	01241701 	jmpi	80124170 <__svfscanf_r>

801259c0 <_vfscanf_r>:
801259c0:	defffb04 	addi	sp,sp,-20
801259c4:	de00012e 	bgeu	sp,et,801259cc <_vfscanf_r+0xc>
801259c8:	003b68fa 	trap	3
801259cc:	dc000315 	stw	r16,12(sp)
801259d0:	dfc00415 	stw	ra,16(sp)
801259d4:	2021883a 	mov	r16,r4
801259d8:	20000926 	beq	r4,zero,80125a00 <_vfscanf_r+0x40>
801259dc:	20800e17 	ldw	r2,56(r4)
801259e0:	1000071e 	bne	r2,zero,80125a00 <_vfscanf_r+0x40>
801259e4:	d9400015 	stw	r5,0(sp)
801259e8:	d9800115 	stw	r6,4(sp)
801259ec:	d9c00215 	stw	r7,8(sp)
801259f0:	01276140 	call	80127614 <__sinit>
801259f4:	d9c00217 	ldw	r7,8(sp)
801259f8:	d9800117 	ldw	r6,4(sp)
801259fc:	d9400017 	ldw	r5,0(sp)
80125a00:	8009883a 	mov	r4,r16
80125a04:	dfc00417 	ldw	ra,16(sp)
80125a08:	dc000317 	ldw	r16,12(sp)
80125a0c:	dec00504 	addi	sp,sp,20
80125a10:	01241701 	jmpi	80124170 <__svfscanf_r>

80125a14 <quorem>:
80125a14:	defff704 	addi	sp,sp,-36
80125a18:	de00012e 	bgeu	sp,et,80125a20 <quorem+0xc>
80125a1c:	003b68fa 	trap	3
80125a20:	dc800215 	stw	r18,8(sp)
80125a24:	20800417 	ldw	r2,16(r4)
80125a28:	2c800417 	ldw	r18,16(r5)
80125a2c:	dfc00815 	stw	ra,32(sp)
80125a30:	ddc00715 	stw	r23,28(sp)
80125a34:	dd800615 	stw	r22,24(sp)
80125a38:	dd400515 	stw	r21,20(sp)
80125a3c:	dd000415 	stw	r20,16(sp)
80125a40:	dcc00315 	stw	r19,12(sp)
80125a44:	dc400115 	stw	r17,4(sp)
80125a48:	dc000015 	stw	r16,0(sp)
80125a4c:	14807116 	blt	r2,r18,80125c14 <quorem+0x200>
80125a50:	94bfffc4 	addi	r18,r18,-1
80125a54:	94ad883a 	add	r22,r18,r18
80125a58:	b5ad883a 	add	r22,r22,r22
80125a5c:	2c400504 	addi	r17,r5,20
80125a60:	8da9883a 	add	r20,r17,r22
80125a64:	25400504 	addi	r21,r4,20
80125a68:	282f883a 	mov	r23,r5
80125a6c:	adad883a 	add	r22,r21,r22
80125a70:	a1400017 	ldw	r5,0(r20)
80125a74:	2021883a 	mov	r16,r4
80125a78:	b1000017 	ldw	r4,0(r22)
80125a7c:	29400044 	addi	r5,r5,1
80125a80:	01302680 	call	80130268 <__udivsi3>
80125a84:	1027883a 	mov	r19,r2
80125a88:	10002c26 	beq	r2,zero,80125b3c <quorem+0x128>
80125a8c:	a813883a 	mov	r9,r21
80125a90:	880b883a 	mov	r5,r17
80125a94:	0009883a 	mov	r4,zero
80125a98:	000d883a 	mov	r6,zero
80125a9c:	2a000017 	ldw	r8,0(r5)
80125aa0:	49c00017 	ldw	r7,0(r9)
80125aa4:	29400104 	addi	r5,r5,4
80125aa8:	40bfffcc 	andi	r2,r8,65535
80125aac:	14c5383a 	mul	r2,r2,r19
80125ab0:	4010d43a 	srli	r8,r8,16
80125ab4:	38ffffcc 	andi	r3,r7,65535
80125ab8:	1105883a 	add	r2,r2,r4
80125abc:	1008d43a 	srli	r4,r2,16
80125ac0:	44d1383a 	mul	r8,r8,r19
80125ac4:	198d883a 	add	r6,r3,r6
80125ac8:	10ffffcc 	andi	r3,r2,65535
80125acc:	30c7c83a 	sub	r3,r6,r3
80125ad0:	380ed43a 	srli	r7,r7,16
80125ad4:	4105883a 	add	r2,r8,r4
80125ad8:	180dd43a 	srai	r6,r3,16
80125adc:	113fffcc 	andi	r4,r2,65535
80125ae0:	390fc83a 	sub	r7,r7,r4
80125ae4:	398d883a 	add	r6,r7,r6
80125ae8:	300e943a 	slli	r7,r6,16
80125aec:	18ffffcc 	andi	r3,r3,65535
80125af0:	1008d43a 	srli	r4,r2,16
80125af4:	38ceb03a 	or	r7,r7,r3
80125af8:	49c00015 	stw	r7,0(r9)
80125afc:	300dd43a 	srai	r6,r6,16
80125b00:	4a400104 	addi	r9,r9,4
80125b04:	a17fe52e 	bgeu	r20,r5,80125a9c <__reset+0xfa105a9c>
80125b08:	b0800017 	ldw	r2,0(r22)
80125b0c:	10000b1e 	bne	r2,zero,80125b3c <quorem+0x128>
80125b10:	b0bfff04 	addi	r2,r22,-4
80125b14:	a880082e 	bgeu	r21,r2,80125b38 <quorem+0x124>
80125b18:	b0ffff17 	ldw	r3,-4(r22)
80125b1c:	18000326 	beq	r3,zero,80125b2c <quorem+0x118>
80125b20:	00000506 	br	80125b38 <quorem+0x124>
80125b24:	10c00017 	ldw	r3,0(r2)
80125b28:	1800031e 	bne	r3,zero,80125b38 <quorem+0x124>
80125b2c:	10bfff04 	addi	r2,r2,-4
80125b30:	94bfffc4 	addi	r18,r18,-1
80125b34:	a8bffb36 	bltu	r21,r2,80125b24 <__reset+0xfa105b24>
80125b38:	84800415 	stw	r18,16(r16)
80125b3c:	b80b883a 	mov	r5,r23
80125b40:	8009883a 	mov	r4,r16
80125b44:	0129a200 	call	80129a20 <__mcmp>
80125b48:	10002616 	blt	r2,zero,80125be4 <quorem+0x1d0>
80125b4c:	9cc00044 	addi	r19,r19,1
80125b50:	a805883a 	mov	r2,r21
80125b54:	000b883a 	mov	r5,zero
80125b58:	11000017 	ldw	r4,0(r2)
80125b5c:	89800017 	ldw	r6,0(r17)
80125b60:	10800104 	addi	r2,r2,4
80125b64:	20ffffcc 	andi	r3,r4,65535
80125b68:	194b883a 	add	r5,r3,r5
80125b6c:	30ffffcc 	andi	r3,r6,65535
80125b70:	28c7c83a 	sub	r3,r5,r3
80125b74:	300cd43a 	srli	r6,r6,16
80125b78:	2008d43a 	srli	r4,r4,16
80125b7c:	180bd43a 	srai	r5,r3,16
80125b80:	18ffffcc 	andi	r3,r3,65535
80125b84:	2189c83a 	sub	r4,r4,r6
80125b88:	2149883a 	add	r4,r4,r5
80125b8c:	200c943a 	slli	r6,r4,16
80125b90:	8c400104 	addi	r17,r17,4
80125b94:	200bd43a 	srai	r5,r4,16
80125b98:	30c6b03a 	or	r3,r6,r3
80125b9c:	10ffff15 	stw	r3,-4(r2)
80125ba0:	a47fed2e 	bgeu	r20,r17,80125b58 <__reset+0xfa105b58>
80125ba4:	9485883a 	add	r2,r18,r18
80125ba8:	1085883a 	add	r2,r2,r2
80125bac:	a887883a 	add	r3,r21,r2
80125bb0:	18800017 	ldw	r2,0(r3)
80125bb4:	10000b1e 	bne	r2,zero,80125be4 <quorem+0x1d0>
80125bb8:	18bfff04 	addi	r2,r3,-4
80125bbc:	a880082e 	bgeu	r21,r2,80125be0 <quorem+0x1cc>
80125bc0:	18ffff17 	ldw	r3,-4(r3)
80125bc4:	18000326 	beq	r3,zero,80125bd4 <quorem+0x1c0>
80125bc8:	00000506 	br	80125be0 <quorem+0x1cc>
80125bcc:	10c00017 	ldw	r3,0(r2)
80125bd0:	1800031e 	bne	r3,zero,80125be0 <quorem+0x1cc>
80125bd4:	10bfff04 	addi	r2,r2,-4
80125bd8:	94bfffc4 	addi	r18,r18,-1
80125bdc:	a8bffb36 	bltu	r21,r2,80125bcc <__reset+0xfa105bcc>
80125be0:	84800415 	stw	r18,16(r16)
80125be4:	9805883a 	mov	r2,r19
80125be8:	dfc00817 	ldw	ra,32(sp)
80125bec:	ddc00717 	ldw	r23,28(sp)
80125bf0:	dd800617 	ldw	r22,24(sp)
80125bf4:	dd400517 	ldw	r21,20(sp)
80125bf8:	dd000417 	ldw	r20,16(sp)
80125bfc:	dcc00317 	ldw	r19,12(sp)
80125c00:	dc800217 	ldw	r18,8(sp)
80125c04:	dc400117 	ldw	r17,4(sp)
80125c08:	dc000017 	ldw	r16,0(sp)
80125c0c:	dec00904 	addi	sp,sp,36
80125c10:	f800283a 	ret
80125c14:	0005883a 	mov	r2,zero
80125c18:	003ff306 	br	80125be8 <__reset+0xfa105be8>

80125c1c <_dtoa_r>:
80125c1c:	deffde04 	addi	sp,sp,-136
80125c20:	de00012e 	bgeu	sp,et,80125c28 <_dtoa_r+0xc>
80125c24:	003b68fa 	trap	3
80125c28:	20801017 	ldw	r2,64(r4)
80125c2c:	df002015 	stw	fp,128(sp)
80125c30:	dcc01b15 	stw	r19,108(sp)
80125c34:	dc801a15 	stw	r18,104(sp)
80125c38:	dc401915 	stw	r17,100(sp)
80125c3c:	dc001815 	stw	r16,96(sp)
80125c40:	dfc02115 	stw	ra,132(sp)
80125c44:	ddc01f15 	stw	r23,124(sp)
80125c48:	dd801e15 	stw	r22,120(sp)
80125c4c:	dd401d15 	stw	r21,116(sp)
80125c50:	dd001c15 	stw	r20,112(sp)
80125c54:	d9c00315 	stw	r7,12(sp)
80125c58:	2039883a 	mov	fp,r4
80125c5c:	3023883a 	mov	r17,r6
80125c60:	2825883a 	mov	r18,r5
80125c64:	dc002417 	ldw	r16,144(sp)
80125c68:	3027883a 	mov	r19,r6
80125c6c:	10000826 	beq	r2,zero,80125c90 <_dtoa_r+0x74>
80125c70:	21801117 	ldw	r6,68(r4)
80125c74:	00c00044 	movi	r3,1
80125c78:	100b883a 	mov	r5,r2
80125c7c:	1986983a 	sll	r3,r3,r6
80125c80:	11800115 	stw	r6,4(r2)
80125c84:	10c00215 	stw	r3,8(r2)
80125c88:	01291d00 	call	801291d0 <_Bfree>
80125c8c:	e0001015 	stw	zero,64(fp)
80125c90:	88002e16 	blt	r17,zero,80125d4c <_dtoa_r+0x130>
80125c94:	80000015 	stw	zero,0(r16)
80125c98:	889ffc2c 	andhi	r2,r17,32752
80125c9c:	00dffc34 	movhi	r3,32752
80125ca0:	10c01c26 	beq	r2,r3,80125d14 <_dtoa_r+0xf8>
80125ca4:	000d883a 	mov	r6,zero
80125ca8:	000f883a 	mov	r7,zero
80125cac:	9009883a 	mov	r4,r18
80125cb0:	980b883a 	mov	r5,r19
80125cb4:	01316c40 	call	801316c4 <__eqdf2>
80125cb8:	10002b1e 	bne	r2,zero,80125d68 <_dtoa_r+0x14c>
80125cbc:	d9c02317 	ldw	r7,140(sp)
80125cc0:	00800044 	movi	r2,1
80125cc4:	38800015 	stw	r2,0(r7)
80125cc8:	d8802517 	ldw	r2,148(sp)
80125ccc:	10019e26 	beq	r2,zero,80126348 <_dtoa_r+0x72c>
80125cd0:	d8c02517 	ldw	r3,148(sp)
80125cd4:	00a00534 	movhi	r2,32788
80125cd8:	109ed044 	addi	r2,r2,31553
80125cdc:	18800015 	stw	r2,0(r3)
80125ce0:	10bfffc4 	addi	r2,r2,-1
80125ce4:	dfc02117 	ldw	ra,132(sp)
80125ce8:	df002017 	ldw	fp,128(sp)
80125cec:	ddc01f17 	ldw	r23,124(sp)
80125cf0:	dd801e17 	ldw	r22,120(sp)
80125cf4:	dd401d17 	ldw	r21,116(sp)
80125cf8:	dd001c17 	ldw	r20,112(sp)
80125cfc:	dcc01b17 	ldw	r19,108(sp)
80125d00:	dc801a17 	ldw	r18,104(sp)
80125d04:	dc401917 	ldw	r17,100(sp)
80125d08:	dc001817 	ldw	r16,96(sp)
80125d0c:	dec02204 	addi	sp,sp,136
80125d10:	f800283a 	ret
80125d14:	d8c02317 	ldw	r3,140(sp)
80125d18:	0089c3c4 	movi	r2,9999
80125d1c:	18800015 	stw	r2,0(r3)
80125d20:	90017726 	beq	r18,zero,80126300 <_dtoa_r+0x6e4>
80125d24:	00a00534 	movhi	r2,32788
80125d28:	109ee604 	addi	r2,r2,31640
80125d2c:	d9002517 	ldw	r4,148(sp)
80125d30:	203fec26 	beq	r4,zero,80125ce4 <__reset+0xfa105ce4>
80125d34:	10c000c7 	ldb	r3,3(r2)
80125d38:	1801781e 	bne	r3,zero,8012631c <_dtoa_r+0x700>
80125d3c:	10c000c4 	addi	r3,r2,3
80125d40:	d9802517 	ldw	r6,148(sp)
80125d44:	30c00015 	stw	r3,0(r6)
80125d48:	003fe606 	br	80125ce4 <__reset+0xfa105ce4>
80125d4c:	04e00034 	movhi	r19,32768
80125d50:	9cffffc4 	addi	r19,r19,-1
80125d54:	00800044 	movi	r2,1
80125d58:	8ce6703a 	and	r19,r17,r19
80125d5c:	80800015 	stw	r2,0(r16)
80125d60:	9823883a 	mov	r17,r19
80125d64:	003fcc06 	br	80125c98 <__reset+0xfa105c98>
80125d68:	d8800204 	addi	r2,sp,8
80125d6c:	d8800015 	stw	r2,0(sp)
80125d70:	d9c00104 	addi	r7,sp,4
80125d74:	900b883a 	mov	r5,r18
80125d78:	980d883a 	mov	r6,r19
80125d7c:	e009883a 	mov	r4,fp
80125d80:	8820d53a 	srli	r16,r17,20
80125d84:	0129dfc0 	call	80129dfc <__d2b>
80125d88:	d8800915 	stw	r2,36(sp)
80125d8c:	8001651e 	bne	r16,zero,80126324 <_dtoa_r+0x708>
80125d90:	dd800217 	ldw	r22,8(sp)
80125d94:	dc000117 	ldw	r16,4(sp)
80125d98:	00800804 	movi	r2,32
80125d9c:	b421883a 	add	r16,r22,r16
80125da0:	80c10c84 	addi	r3,r16,1074
80125da4:	10c2d10e 	bge	r2,r3,801268ec <_dtoa_r+0xcd0>
80125da8:	00801004 	movi	r2,64
80125dac:	81010484 	addi	r4,r16,1042
80125db0:	10c7c83a 	sub	r3,r2,r3
80125db4:	9108d83a 	srl	r4,r18,r4
80125db8:	88e2983a 	sll	r17,r17,r3
80125dbc:	2448b03a 	or	r4,r4,r17
80125dc0:	01318400 	call	80131840 <__floatunsidf>
80125dc4:	017f8434 	movhi	r5,65040
80125dc8:	01800044 	movi	r6,1
80125dcc:	1009883a 	mov	r4,r2
80125dd0:	194b883a 	add	r5,r3,r5
80125dd4:	843fffc4 	addi	r16,r16,-1
80125dd8:	d9801115 	stw	r6,68(sp)
80125ddc:	000d883a 	mov	r6,zero
80125de0:	01cffe34 	movhi	r7,16376
80125de4:	01206a80 	call	801206a8 <__subdf3>
80125de8:	0198dbf4 	movhi	r6,25455
80125dec:	01cff4f4 	movhi	r7,16339
80125df0:	3190d844 	addi	r6,r6,17249
80125df4:	39e1e9c4 	addi	r7,r7,-30809
80125df8:	1009883a 	mov	r4,r2
80125dfc:	180b883a 	mov	r5,r3
80125e00:	011ff880 	call	8011ff88 <__muldf3>
80125e04:	01a2d874 	movhi	r6,35681
80125e08:	01cff1f4 	movhi	r7,16327
80125e0c:	31b22cc4 	addi	r6,r6,-14157
80125e10:	39e28a04 	addi	r7,r7,-30168
80125e14:	180b883a 	mov	r5,r3
80125e18:	1009883a 	mov	r4,r2
80125e1c:	01305200 	call	80130520 <__adddf3>
80125e20:	8009883a 	mov	r4,r16
80125e24:	1029883a 	mov	r20,r2
80125e28:	1823883a 	mov	r17,r3
80125e2c:	012102c0 	call	8012102c <__floatsidf>
80125e30:	019427f4 	movhi	r6,20639
80125e34:	01cff4f4 	movhi	r7,16339
80125e38:	319e7ec4 	addi	r6,r6,31227
80125e3c:	39d104c4 	addi	r7,r7,17427
80125e40:	1009883a 	mov	r4,r2
80125e44:	180b883a 	mov	r5,r3
80125e48:	011ff880 	call	8011ff88 <__muldf3>
80125e4c:	100d883a 	mov	r6,r2
80125e50:	180f883a 	mov	r7,r3
80125e54:	a009883a 	mov	r4,r20
80125e58:	880b883a 	mov	r5,r17
80125e5c:	01305200 	call	80130520 <__adddf3>
80125e60:	1009883a 	mov	r4,r2
80125e64:	180b883a 	mov	r5,r3
80125e68:	1029883a 	mov	r20,r2
80125e6c:	1823883a 	mov	r17,r3
80125e70:	0120fac0 	call	80120fac <__fixdfsi>
80125e74:	000d883a 	mov	r6,zero
80125e78:	000f883a 	mov	r7,zero
80125e7c:	a009883a 	mov	r4,r20
80125e80:	880b883a 	mov	r5,r17
80125e84:	d8800515 	stw	r2,20(sp)
80125e88:	013174c0 	call	8013174c <__ledf2>
80125e8c:	10028716 	blt	r2,zero,801268ac <_dtoa_r+0xc90>
80125e90:	d8c00517 	ldw	r3,20(sp)
80125e94:	00800584 	movi	r2,22
80125e98:	10c27536 	bltu	r2,r3,80126870 <_dtoa_r+0xc54>
80125e9c:	180490fa 	slli	r2,r3,3
80125ea0:	00e00534 	movhi	r3,32788
80125ea4:	18df0204 	addi	r3,r3,31752
80125ea8:	1885883a 	add	r2,r3,r2
80125eac:	11000017 	ldw	r4,0(r2)
80125eb0:	11400117 	ldw	r5,4(r2)
80125eb4:	900d883a 	mov	r6,r18
80125eb8:	980f883a 	mov	r7,r19
80125ebc:	011feac0 	call	8011feac <__gedf2>
80125ec0:	00828d0e 	bge	zero,r2,801268f8 <_dtoa_r+0xcdc>
80125ec4:	d9000517 	ldw	r4,20(sp)
80125ec8:	d8000e15 	stw	zero,56(sp)
80125ecc:	213fffc4 	addi	r4,r4,-1
80125ed0:	d9000515 	stw	r4,20(sp)
80125ed4:	b42dc83a 	sub	r22,r22,r16
80125ed8:	b5bfffc4 	addi	r22,r22,-1
80125edc:	b0026f16 	blt	r22,zero,8012689c <_dtoa_r+0xc80>
80125ee0:	d8000815 	stw	zero,32(sp)
80125ee4:	d9c00517 	ldw	r7,20(sp)
80125ee8:	38026416 	blt	r7,zero,8012687c <_dtoa_r+0xc60>
80125eec:	b1ed883a 	add	r22,r22,r7
80125ef0:	d9c00d15 	stw	r7,52(sp)
80125ef4:	d8000a15 	stw	zero,40(sp)
80125ef8:	d9800317 	ldw	r6,12(sp)
80125efc:	00800244 	movi	r2,9
80125f00:	11811436 	bltu	r2,r6,80126354 <_dtoa_r+0x738>
80125f04:	00800144 	movi	r2,5
80125f08:	1184e10e 	bge	r2,r6,80127290 <_dtoa_r+0x1674>
80125f0c:	31bfff04 	addi	r6,r6,-4
80125f10:	d9800315 	stw	r6,12(sp)
80125f14:	0023883a 	mov	r17,zero
80125f18:	d9800317 	ldw	r6,12(sp)
80125f1c:	008000c4 	movi	r2,3
80125f20:	30836726 	beq	r6,r2,80126cc0 <_dtoa_r+0x10a4>
80125f24:	1183410e 	bge	r2,r6,80126c2c <_dtoa_r+0x1010>
80125f28:	d9c00317 	ldw	r7,12(sp)
80125f2c:	00800104 	movi	r2,4
80125f30:	38827c26 	beq	r7,r2,80126924 <_dtoa_r+0xd08>
80125f34:	00800144 	movi	r2,5
80125f38:	3884c41e 	bne	r7,r2,8012724c <_dtoa_r+0x1630>
80125f3c:	00800044 	movi	r2,1
80125f40:	d8800b15 	stw	r2,44(sp)
80125f44:	d8c00517 	ldw	r3,20(sp)
80125f48:	d9002217 	ldw	r4,136(sp)
80125f4c:	1907883a 	add	r3,r3,r4
80125f50:	19800044 	addi	r6,r3,1
80125f54:	d8c00c15 	stw	r3,48(sp)
80125f58:	d9800615 	stw	r6,24(sp)
80125f5c:	0183a40e 	bge	zero,r6,80126df0 <_dtoa_r+0x11d4>
80125f60:	d9800617 	ldw	r6,24(sp)
80125f64:	3021883a 	mov	r16,r6
80125f68:	e0001115 	stw	zero,68(fp)
80125f6c:	008005c4 	movi	r2,23
80125f70:	1184c92e 	bgeu	r2,r6,80127298 <_dtoa_r+0x167c>
80125f74:	00c00044 	movi	r3,1
80125f78:	00800104 	movi	r2,4
80125f7c:	1085883a 	add	r2,r2,r2
80125f80:	11000504 	addi	r4,r2,20
80125f84:	180b883a 	mov	r5,r3
80125f88:	18c00044 	addi	r3,r3,1
80125f8c:	313ffb2e 	bgeu	r6,r4,80125f7c <__reset+0xfa105f7c>
80125f90:	e1401115 	stw	r5,68(fp)
80125f94:	e009883a 	mov	r4,fp
80125f98:	01291200 	call	80129120 <_Balloc>
80125f9c:	d8800715 	stw	r2,28(sp)
80125fa0:	e0801015 	stw	r2,64(fp)
80125fa4:	00800384 	movi	r2,14
80125fa8:	1400f736 	bltu	r2,r16,80126388 <_dtoa_r+0x76c>
80125fac:	8800f626 	beq	r17,zero,80126388 <_dtoa_r+0x76c>
80125fb0:	d9c00517 	ldw	r7,20(sp)
80125fb4:	01c39a0e 	bge	zero,r7,80126e20 <_dtoa_r+0x1204>
80125fb8:	388003cc 	andi	r2,r7,15
80125fbc:	100490fa 	slli	r2,r2,3
80125fc0:	382bd13a 	srai	r21,r7,4
80125fc4:	00e00534 	movhi	r3,32788
80125fc8:	18df0204 	addi	r3,r3,31752
80125fcc:	1885883a 	add	r2,r3,r2
80125fd0:	a8c0040c 	andi	r3,r21,16
80125fd4:	12400017 	ldw	r9,0(r2)
80125fd8:	12000117 	ldw	r8,4(r2)
80125fdc:	18037926 	beq	r3,zero,80126dc4 <_dtoa_r+0x11a8>
80125fe0:	00a00534 	movhi	r2,32788
80125fe4:	109ef804 	addi	r2,r2,31712
80125fe8:	11800817 	ldw	r6,32(r2)
80125fec:	11c00917 	ldw	r7,36(r2)
80125ff0:	9009883a 	mov	r4,r18
80125ff4:	980b883a 	mov	r5,r19
80125ff8:	da001715 	stw	r8,92(sp)
80125ffc:	da401615 	stw	r9,88(sp)
80126000:	0130dd40 	call	80130dd4 <__divdf3>
80126004:	da001717 	ldw	r8,92(sp)
80126008:	da401617 	ldw	r9,88(sp)
8012600c:	ad4003cc 	andi	r21,r21,15
80126010:	040000c4 	movi	r16,3
80126014:	1023883a 	mov	r17,r2
80126018:	1829883a 	mov	r20,r3
8012601c:	a8001126 	beq	r21,zero,80126064 <_dtoa_r+0x448>
80126020:	05e00534 	movhi	r23,32788
80126024:	bddef804 	addi	r23,r23,31712
80126028:	4805883a 	mov	r2,r9
8012602c:	4007883a 	mov	r3,r8
80126030:	a980004c 	andi	r6,r21,1
80126034:	1009883a 	mov	r4,r2
80126038:	a82bd07a 	srai	r21,r21,1
8012603c:	180b883a 	mov	r5,r3
80126040:	30000426 	beq	r6,zero,80126054 <_dtoa_r+0x438>
80126044:	b9800017 	ldw	r6,0(r23)
80126048:	b9c00117 	ldw	r7,4(r23)
8012604c:	84000044 	addi	r16,r16,1
80126050:	011ff880 	call	8011ff88 <__muldf3>
80126054:	bdc00204 	addi	r23,r23,8
80126058:	a83ff51e 	bne	r21,zero,80126030 <__reset+0xfa106030>
8012605c:	1013883a 	mov	r9,r2
80126060:	1811883a 	mov	r8,r3
80126064:	480d883a 	mov	r6,r9
80126068:	400f883a 	mov	r7,r8
8012606c:	8809883a 	mov	r4,r17
80126070:	a00b883a 	mov	r5,r20
80126074:	0130dd40 	call	80130dd4 <__divdf3>
80126078:	d8800f15 	stw	r2,60(sp)
8012607c:	d8c01015 	stw	r3,64(sp)
80126080:	d8c00e17 	ldw	r3,56(sp)
80126084:	18000626 	beq	r3,zero,801260a0 <_dtoa_r+0x484>
80126088:	d9000f17 	ldw	r4,60(sp)
8012608c:	d9401017 	ldw	r5,64(sp)
80126090:	000d883a 	mov	r6,zero
80126094:	01cffc34 	movhi	r7,16368
80126098:	013174c0 	call	8013174c <__ledf2>
8012609c:	10040b16 	blt	r2,zero,801270cc <_dtoa_r+0x14b0>
801260a0:	8009883a 	mov	r4,r16
801260a4:	012102c0 	call	8012102c <__floatsidf>
801260a8:	d9800f17 	ldw	r6,60(sp)
801260ac:	d9c01017 	ldw	r7,64(sp)
801260b0:	1009883a 	mov	r4,r2
801260b4:	180b883a 	mov	r5,r3
801260b8:	011ff880 	call	8011ff88 <__muldf3>
801260bc:	000d883a 	mov	r6,zero
801260c0:	01d00734 	movhi	r7,16412
801260c4:	1009883a 	mov	r4,r2
801260c8:	180b883a 	mov	r5,r3
801260cc:	01305200 	call	80130520 <__adddf3>
801260d0:	1021883a 	mov	r16,r2
801260d4:	d8800617 	ldw	r2,24(sp)
801260d8:	047f3034 	movhi	r17,64704
801260dc:	1c63883a 	add	r17,r3,r17
801260e0:	10031826 	beq	r2,zero,80126d44 <_dtoa_r+0x1128>
801260e4:	d8c00517 	ldw	r3,20(sp)
801260e8:	db000617 	ldw	r12,24(sp)
801260ec:	d8c01315 	stw	r3,76(sp)
801260f0:	d9000b17 	ldw	r4,44(sp)
801260f4:	20038f26 	beq	r4,zero,80126f34 <_dtoa_r+0x1318>
801260f8:	60bfffc4 	addi	r2,r12,-1
801260fc:	100490fa 	slli	r2,r2,3
80126100:	00e00534 	movhi	r3,32788
80126104:	18df0204 	addi	r3,r3,31752
80126108:	1885883a 	add	r2,r3,r2
8012610c:	11800017 	ldw	r6,0(r2)
80126110:	11c00117 	ldw	r7,4(r2)
80126114:	d8800717 	ldw	r2,28(sp)
80126118:	0009883a 	mov	r4,zero
8012611c:	014ff834 	movhi	r5,16352
80126120:	db001615 	stw	r12,88(sp)
80126124:	15c00044 	addi	r23,r2,1
80126128:	0130dd40 	call	80130dd4 <__divdf3>
8012612c:	800d883a 	mov	r6,r16
80126130:	880f883a 	mov	r7,r17
80126134:	1009883a 	mov	r4,r2
80126138:	180b883a 	mov	r5,r3
8012613c:	01206a80 	call	801206a8 <__subdf3>
80126140:	d9401017 	ldw	r5,64(sp)
80126144:	d9000f17 	ldw	r4,60(sp)
80126148:	102b883a 	mov	r21,r2
8012614c:	d8c01215 	stw	r3,72(sp)
80126150:	0120fac0 	call	80120fac <__fixdfsi>
80126154:	1009883a 	mov	r4,r2
80126158:	1029883a 	mov	r20,r2
8012615c:	012102c0 	call	8012102c <__floatsidf>
80126160:	d9000f17 	ldw	r4,60(sp)
80126164:	d9401017 	ldw	r5,64(sp)
80126168:	100d883a 	mov	r6,r2
8012616c:	180f883a 	mov	r7,r3
80126170:	01206a80 	call	801206a8 <__subdf3>
80126174:	1823883a 	mov	r17,r3
80126178:	d8c00717 	ldw	r3,28(sp)
8012617c:	d9401217 	ldw	r5,72(sp)
80126180:	a2000c04 	addi	r8,r20,48
80126184:	1021883a 	mov	r16,r2
80126188:	1a000005 	stb	r8,0(r3)
8012618c:	800d883a 	mov	r6,r16
80126190:	880f883a 	mov	r7,r17
80126194:	a809883a 	mov	r4,r21
80126198:	4029883a 	mov	r20,r8
8012619c:	011feac0 	call	8011feac <__gedf2>
801261a0:	00841d16 	blt	zero,r2,80127218 <_dtoa_r+0x15fc>
801261a4:	800d883a 	mov	r6,r16
801261a8:	880f883a 	mov	r7,r17
801261ac:	0009883a 	mov	r4,zero
801261b0:	014ffc34 	movhi	r5,16368
801261b4:	01206a80 	call	801206a8 <__subdf3>
801261b8:	d9401217 	ldw	r5,72(sp)
801261bc:	100d883a 	mov	r6,r2
801261c0:	180f883a 	mov	r7,r3
801261c4:	a809883a 	mov	r4,r21
801261c8:	011feac0 	call	8011feac <__gedf2>
801261cc:	db001617 	ldw	r12,88(sp)
801261d0:	00840e16 	blt	zero,r2,8012720c <_dtoa_r+0x15f0>
801261d4:	00800044 	movi	r2,1
801261d8:	13006b0e 	bge	r2,r12,80126388 <_dtoa_r+0x76c>
801261dc:	d9000717 	ldw	r4,28(sp)
801261e0:	dd800f15 	stw	r22,60(sp)
801261e4:	dcc01015 	stw	r19,64(sp)
801261e8:	2319883a 	add	r12,r4,r12
801261ec:	dcc01217 	ldw	r19,72(sp)
801261f0:	602d883a 	mov	r22,r12
801261f4:	dc801215 	stw	r18,72(sp)
801261f8:	b825883a 	mov	r18,r23
801261fc:	00000906 	br	80126224 <_dtoa_r+0x608>
80126200:	01206a80 	call	801206a8 <__subdf3>
80126204:	a80d883a 	mov	r6,r21
80126208:	980f883a 	mov	r7,r19
8012620c:	1009883a 	mov	r4,r2
80126210:	180b883a 	mov	r5,r3
80126214:	013174c0 	call	8013174c <__ledf2>
80126218:	1003e816 	blt	r2,zero,801271bc <_dtoa_r+0x15a0>
8012621c:	b825883a 	mov	r18,r23
80126220:	bd83e926 	beq	r23,r22,801271c8 <_dtoa_r+0x15ac>
80126224:	a809883a 	mov	r4,r21
80126228:	980b883a 	mov	r5,r19
8012622c:	000d883a 	mov	r6,zero
80126230:	01d00934 	movhi	r7,16420
80126234:	011ff880 	call	8011ff88 <__muldf3>
80126238:	000d883a 	mov	r6,zero
8012623c:	01d00934 	movhi	r7,16420
80126240:	8009883a 	mov	r4,r16
80126244:	880b883a 	mov	r5,r17
80126248:	102b883a 	mov	r21,r2
8012624c:	1827883a 	mov	r19,r3
80126250:	011ff880 	call	8011ff88 <__muldf3>
80126254:	180b883a 	mov	r5,r3
80126258:	1009883a 	mov	r4,r2
8012625c:	1821883a 	mov	r16,r3
80126260:	1023883a 	mov	r17,r2
80126264:	0120fac0 	call	80120fac <__fixdfsi>
80126268:	1009883a 	mov	r4,r2
8012626c:	1029883a 	mov	r20,r2
80126270:	012102c0 	call	8012102c <__floatsidf>
80126274:	8809883a 	mov	r4,r17
80126278:	800b883a 	mov	r5,r16
8012627c:	100d883a 	mov	r6,r2
80126280:	180f883a 	mov	r7,r3
80126284:	01206a80 	call	801206a8 <__subdf3>
80126288:	a5000c04 	addi	r20,r20,48
8012628c:	a80d883a 	mov	r6,r21
80126290:	980f883a 	mov	r7,r19
80126294:	1009883a 	mov	r4,r2
80126298:	180b883a 	mov	r5,r3
8012629c:	95000005 	stb	r20,0(r18)
801262a0:	1021883a 	mov	r16,r2
801262a4:	1823883a 	mov	r17,r3
801262a8:	013174c0 	call	8013174c <__ledf2>
801262ac:	bdc00044 	addi	r23,r23,1
801262b0:	800d883a 	mov	r6,r16
801262b4:	880f883a 	mov	r7,r17
801262b8:	0009883a 	mov	r4,zero
801262bc:	014ffc34 	movhi	r5,16368
801262c0:	103fcf0e 	bge	r2,zero,80126200 <__reset+0xfa106200>
801262c4:	d8c01317 	ldw	r3,76(sp)
801262c8:	d8c00515 	stw	r3,20(sp)
801262cc:	d9400917 	ldw	r5,36(sp)
801262d0:	e009883a 	mov	r4,fp
801262d4:	01291d00 	call	801291d0 <_Bfree>
801262d8:	d9000517 	ldw	r4,20(sp)
801262dc:	d9802317 	ldw	r6,140(sp)
801262e0:	d9c02517 	ldw	r7,148(sp)
801262e4:	b8000005 	stb	zero,0(r23)
801262e8:	20800044 	addi	r2,r4,1
801262ec:	30800015 	stw	r2,0(r6)
801262f0:	3802aa26 	beq	r7,zero,80126d9c <_dtoa_r+0x1180>
801262f4:	3dc00015 	stw	r23,0(r7)
801262f8:	d8800717 	ldw	r2,28(sp)
801262fc:	003e7906 	br	80125ce4 <__reset+0xfa105ce4>
80126300:	00800434 	movhi	r2,16
80126304:	10bfffc4 	addi	r2,r2,-1
80126308:	88a2703a 	and	r17,r17,r2
8012630c:	883e851e 	bne	r17,zero,80125d24 <__reset+0xfa105d24>
80126310:	00a00534 	movhi	r2,32788
80126314:	109ee304 	addi	r2,r2,31628
80126318:	003e8406 	br	80125d2c <__reset+0xfa105d2c>
8012631c:	10c00204 	addi	r3,r2,8
80126320:	003e8706 	br	80125d40 <__reset+0xfa105d40>
80126324:	01400434 	movhi	r5,16
80126328:	297fffc4 	addi	r5,r5,-1
8012632c:	994a703a 	and	r5,r19,r5
80126330:	9009883a 	mov	r4,r18
80126334:	843f0044 	addi	r16,r16,-1023
80126338:	294ffc34 	orhi	r5,r5,16368
8012633c:	dd800217 	ldw	r22,8(sp)
80126340:	d8001115 	stw	zero,68(sp)
80126344:	003ea506 	br	80125ddc <__reset+0xfa105ddc>
80126348:	00a00534 	movhi	r2,32788
8012634c:	109ed004 	addi	r2,r2,31552
80126350:	003e6406 	br	80125ce4 <__reset+0xfa105ce4>
80126354:	e0001115 	stw	zero,68(fp)
80126358:	000b883a 	mov	r5,zero
8012635c:	e009883a 	mov	r4,fp
80126360:	01291200 	call	80129120 <_Balloc>
80126364:	01bfffc4 	movi	r6,-1
80126368:	01c00044 	movi	r7,1
8012636c:	d8800715 	stw	r2,28(sp)
80126370:	d9800c15 	stw	r6,48(sp)
80126374:	e0801015 	stw	r2,64(fp)
80126378:	d8000315 	stw	zero,12(sp)
8012637c:	d9c00b15 	stw	r7,44(sp)
80126380:	d9800615 	stw	r6,24(sp)
80126384:	d8002215 	stw	zero,136(sp)
80126388:	d8800117 	ldw	r2,4(sp)
8012638c:	10008916 	blt	r2,zero,801265b4 <_dtoa_r+0x998>
80126390:	d9000517 	ldw	r4,20(sp)
80126394:	00c00384 	movi	r3,14
80126398:	19008616 	blt	r3,r4,801265b4 <_dtoa_r+0x998>
8012639c:	200490fa 	slli	r2,r4,3
801263a0:	00e00534 	movhi	r3,32788
801263a4:	d9802217 	ldw	r6,136(sp)
801263a8:	18df0204 	addi	r3,r3,31752
801263ac:	1885883a 	add	r2,r3,r2
801263b0:	14000017 	ldw	r16,0(r2)
801263b4:	14400117 	ldw	r17,4(r2)
801263b8:	30016316 	blt	r6,zero,80126948 <_dtoa_r+0xd2c>
801263bc:	800d883a 	mov	r6,r16
801263c0:	880f883a 	mov	r7,r17
801263c4:	9009883a 	mov	r4,r18
801263c8:	980b883a 	mov	r5,r19
801263cc:	0130dd40 	call	80130dd4 <__divdf3>
801263d0:	180b883a 	mov	r5,r3
801263d4:	1009883a 	mov	r4,r2
801263d8:	0120fac0 	call	80120fac <__fixdfsi>
801263dc:	1009883a 	mov	r4,r2
801263e0:	102b883a 	mov	r21,r2
801263e4:	012102c0 	call	8012102c <__floatsidf>
801263e8:	800d883a 	mov	r6,r16
801263ec:	880f883a 	mov	r7,r17
801263f0:	1009883a 	mov	r4,r2
801263f4:	180b883a 	mov	r5,r3
801263f8:	011ff880 	call	8011ff88 <__muldf3>
801263fc:	100d883a 	mov	r6,r2
80126400:	180f883a 	mov	r7,r3
80126404:	9009883a 	mov	r4,r18
80126408:	980b883a 	mov	r5,r19
8012640c:	01206a80 	call	801206a8 <__subdf3>
80126410:	d9c00717 	ldw	r7,28(sp)
80126414:	1009883a 	mov	r4,r2
80126418:	a8800c04 	addi	r2,r21,48
8012641c:	38800005 	stb	r2,0(r7)
80126420:	3dc00044 	addi	r23,r7,1
80126424:	d9c00617 	ldw	r7,24(sp)
80126428:	01800044 	movi	r6,1
8012642c:	180b883a 	mov	r5,r3
80126430:	2005883a 	mov	r2,r4
80126434:	39803826 	beq	r7,r6,80126518 <_dtoa_r+0x8fc>
80126438:	000d883a 	mov	r6,zero
8012643c:	01d00934 	movhi	r7,16420
80126440:	011ff880 	call	8011ff88 <__muldf3>
80126444:	000d883a 	mov	r6,zero
80126448:	000f883a 	mov	r7,zero
8012644c:	1009883a 	mov	r4,r2
80126450:	180b883a 	mov	r5,r3
80126454:	1025883a 	mov	r18,r2
80126458:	1827883a 	mov	r19,r3
8012645c:	01316c40 	call	801316c4 <__eqdf2>
80126460:	103f9a26 	beq	r2,zero,801262cc <__reset+0xfa1062cc>
80126464:	d9c00617 	ldw	r7,24(sp)
80126468:	d8c00717 	ldw	r3,28(sp)
8012646c:	b829883a 	mov	r20,r23
80126470:	38bfffc4 	addi	r2,r7,-1
80126474:	18ad883a 	add	r22,r3,r2
80126478:	00000a06 	br	801264a4 <_dtoa_r+0x888>
8012647c:	011ff880 	call	8011ff88 <__muldf3>
80126480:	000d883a 	mov	r6,zero
80126484:	000f883a 	mov	r7,zero
80126488:	1009883a 	mov	r4,r2
8012648c:	180b883a 	mov	r5,r3
80126490:	1025883a 	mov	r18,r2
80126494:	1827883a 	mov	r19,r3
80126498:	b829883a 	mov	r20,r23
8012649c:	01316c40 	call	801316c4 <__eqdf2>
801264a0:	103f8a26 	beq	r2,zero,801262cc <__reset+0xfa1062cc>
801264a4:	800d883a 	mov	r6,r16
801264a8:	880f883a 	mov	r7,r17
801264ac:	9009883a 	mov	r4,r18
801264b0:	980b883a 	mov	r5,r19
801264b4:	0130dd40 	call	80130dd4 <__divdf3>
801264b8:	180b883a 	mov	r5,r3
801264bc:	1009883a 	mov	r4,r2
801264c0:	0120fac0 	call	80120fac <__fixdfsi>
801264c4:	1009883a 	mov	r4,r2
801264c8:	102b883a 	mov	r21,r2
801264cc:	012102c0 	call	8012102c <__floatsidf>
801264d0:	800d883a 	mov	r6,r16
801264d4:	880f883a 	mov	r7,r17
801264d8:	1009883a 	mov	r4,r2
801264dc:	180b883a 	mov	r5,r3
801264e0:	011ff880 	call	8011ff88 <__muldf3>
801264e4:	100d883a 	mov	r6,r2
801264e8:	180f883a 	mov	r7,r3
801264ec:	9009883a 	mov	r4,r18
801264f0:	980b883a 	mov	r5,r19
801264f4:	01206a80 	call	801206a8 <__subdf3>
801264f8:	aa000c04 	addi	r8,r21,48
801264fc:	a2000005 	stb	r8,0(r20)
80126500:	000d883a 	mov	r6,zero
80126504:	01d00934 	movhi	r7,16420
80126508:	1009883a 	mov	r4,r2
8012650c:	180b883a 	mov	r5,r3
80126510:	a5c00044 	addi	r23,r20,1
80126514:	b53fd91e 	bne	r22,r20,8012647c <__reset+0xfa10647c>
80126518:	100d883a 	mov	r6,r2
8012651c:	180f883a 	mov	r7,r3
80126520:	1009883a 	mov	r4,r2
80126524:	180b883a 	mov	r5,r3
80126528:	01305200 	call	80130520 <__adddf3>
8012652c:	100d883a 	mov	r6,r2
80126530:	180f883a 	mov	r7,r3
80126534:	8009883a 	mov	r4,r16
80126538:	880b883a 	mov	r5,r17
8012653c:	1027883a 	mov	r19,r2
80126540:	1825883a 	mov	r18,r3
80126544:	013174c0 	call	8013174c <__ledf2>
80126548:	10000816 	blt	r2,zero,8012656c <_dtoa_r+0x950>
8012654c:	980d883a 	mov	r6,r19
80126550:	900f883a 	mov	r7,r18
80126554:	8009883a 	mov	r4,r16
80126558:	880b883a 	mov	r5,r17
8012655c:	01316c40 	call	801316c4 <__eqdf2>
80126560:	103f5a1e 	bne	r2,zero,801262cc <__reset+0xfa1062cc>
80126564:	ad40004c 	andi	r21,r21,1
80126568:	a83f5826 	beq	r21,zero,801262cc <__reset+0xfa1062cc>
8012656c:	bd3fffc3 	ldbu	r20,-1(r23)
80126570:	b8bfffc4 	addi	r2,r23,-1
80126574:	1007883a 	mov	r3,r2
80126578:	01400e44 	movi	r5,57
8012657c:	d9800717 	ldw	r6,28(sp)
80126580:	00000506 	br	80126598 <_dtoa_r+0x97c>
80126584:	18ffffc4 	addi	r3,r3,-1
80126588:	11824726 	beq	r2,r6,80126ea8 <_dtoa_r+0x128c>
8012658c:	1d000003 	ldbu	r20,0(r3)
80126590:	102f883a 	mov	r23,r2
80126594:	10bfffc4 	addi	r2,r2,-1
80126598:	a1003fcc 	andi	r4,r20,255
8012659c:	2100201c 	xori	r4,r4,128
801265a0:	213fe004 	addi	r4,r4,-128
801265a4:	217ff726 	beq	r4,r5,80126584 <__reset+0xfa106584>
801265a8:	a2000044 	addi	r8,r20,1
801265ac:	12000005 	stb	r8,0(r2)
801265b0:	003f4606 	br	801262cc <__reset+0xfa1062cc>
801265b4:	d9000b17 	ldw	r4,44(sp)
801265b8:	2000c826 	beq	r4,zero,801268dc <_dtoa_r+0xcc0>
801265bc:	d9800317 	ldw	r6,12(sp)
801265c0:	00c00044 	movi	r3,1
801265c4:	1980f90e 	bge	r3,r6,801269ac <_dtoa_r+0xd90>
801265c8:	d8800617 	ldw	r2,24(sp)
801265cc:	d8c00a17 	ldw	r3,40(sp)
801265d0:	157fffc4 	addi	r21,r2,-1
801265d4:	1d41f316 	blt	r3,r21,80126da4 <_dtoa_r+0x1188>
801265d8:	1d6bc83a 	sub	r21,r3,r21
801265dc:	d9c00617 	ldw	r7,24(sp)
801265e0:	3802aa16 	blt	r7,zero,8012708c <_dtoa_r+0x1470>
801265e4:	dd000817 	ldw	r20,32(sp)
801265e8:	d8800617 	ldw	r2,24(sp)
801265ec:	d8c00817 	ldw	r3,32(sp)
801265f0:	01400044 	movi	r5,1
801265f4:	e009883a 	mov	r4,fp
801265f8:	1887883a 	add	r3,r3,r2
801265fc:	d8c00815 	stw	r3,32(sp)
80126600:	b0ad883a 	add	r22,r22,r2
80126604:	01295440 	call	80129544 <__i2b>
80126608:	1023883a 	mov	r17,r2
8012660c:	a0000826 	beq	r20,zero,80126630 <_dtoa_r+0xa14>
80126610:	0580070e 	bge	zero,r22,80126630 <_dtoa_r+0xa14>
80126614:	a005883a 	mov	r2,r20
80126618:	b500b916 	blt	r22,r20,80126900 <_dtoa_r+0xce4>
8012661c:	d9000817 	ldw	r4,32(sp)
80126620:	a0a9c83a 	sub	r20,r20,r2
80126624:	b0adc83a 	sub	r22,r22,r2
80126628:	2089c83a 	sub	r4,r4,r2
8012662c:	d9000815 	stw	r4,32(sp)
80126630:	d9800a17 	ldw	r6,40(sp)
80126634:	0181810e 	bge	zero,r6,80126c3c <_dtoa_r+0x1020>
80126638:	d9c00b17 	ldw	r7,44(sp)
8012663c:	3800b326 	beq	r7,zero,8012690c <_dtoa_r+0xcf0>
80126640:	a800b226 	beq	r21,zero,8012690c <_dtoa_r+0xcf0>
80126644:	880b883a 	mov	r5,r17
80126648:	a80d883a 	mov	r6,r21
8012664c:	e009883a 	mov	r4,fp
80126650:	01297880 	call	80129788 <__pow5mult>
80126654:	d9800917 	ldw	r6,36(sp)
80126658:	100b883a 	mov	r5,r2
8012665c:	e009883a 	mov	r4,fp
80126660:	1023883a 	mov	r17,r2
80126664:	01295880 	call	80129588 <__multiply>
80126668:	1021883a 	mov	r16,r2
8012666c:	d8800a17 	ldw	r2,40(sp)
80126670:	d9400917 	ldw	r5,36(sp)
80126674:	e009883a 	mov	r4,fp
80126678:	1545c83a 	sub	r2,r2,r21
8012667c:	d8800a15 	stw	r2,40(sp)
80126680:	01291d00 	call	801291d0 <_Bfree>
80126684:	d8c00a17 	ldw	r3,40(sp)
80126688:	18009f1e 	bne	r3,zero,80126908 <_dtoa_r+0xcec>
8012668c:	05c00044 	movi	r23,1
80126690:	e009883a 	mov	r4,fp
80126694:	b80b883a 	mov	r5,r23
80126698:	01295440 	call	80129544 <__i2b>
8012669c:	d9000d17 	ldw	r4,52(sp)
801266a0:	102b883a 	mov	r21,r2
801266a4:	2000ce26 	beq	r4,zero,801269e0 <_dtoa_r+0xdc4>
801266a8:	200d883a 	mov	r6,r4
801266ac:	100b883a 	mov	r5,r2
801266b0:	e009883a 	mov	r4,fp
801266b4:	01297880 	call	80129788 <__pow5mult>
801266b8:	d9800317 	ldw	r6,12(sp)
801266bc:	102b883a 	mov	r21,r2
801266c0:	b981810e 	bge	r23,r6,80126cc8 <_dtoa_r+0x10ac>
801266c4:	0027883a 	mov	r19,zero
801266c8:	a8800417 	ldw	r2,16(r21)
801266cc:	05c00804 	movi	r23,32
801266d0:	10800104 	addi	r2,r2,4
801266d4:	1085883a 	add	r2,r2,r2
801266d8:	1085883a 	add	r2,r2,r2
801266dc:	a885883a 	add	r2,r21,r2
801266e0:	11000017 	ldw	r4,0(r2)
801266e4:	012942c0 	call	8012942c <__hi0bits>
801266e8:	b885c83a 	sub	r2,r23,r2
801266ec:	1585883a 	add	r2,r2,r22
801266f0:	108007cc 	andi	r2,r2,31
801266f4:	1000b326 	beq	r2,zero,801269c4 <_dtoa_r+0xda8>
801266f8:	00c00804 	movi	r3,32
801266fc:	1887c83a 	sub	r3,r3,r2
80126700:	01000104 	movi	r4,4
80126704:	20c2cd0e 	bge	r4,r3,8012723c <_dtoa_r+0x1620>
80126708:	00c00704 	movi	r3,28
8012670c:	1885c83a 	sub	r2,r3,r2
80126710:	d8c00817 	ldw	r3,32(sp)
80126714:	a0a9883a 	add	r20,r20,r2
80126718:	b0ad883a 	add	r22,r22,r2
8012671c:	1887883a 	add	r3,r3,r2
80126720:	d8c00815 	stw	r3,32(sp)
80126724:	d9800817 	ldw	r6,32(sp)
80126728:	0180040e 	bge	zero,r6,8012673c <_dtoa_r+0xb20>
8012672c:	800b883a 	mov	r5,r16
80126730:	e009883a 	mov	r4,fp
80126734:	01298d00 	call	801298d0 <__lshift>
80126738:	1021883a 	mov	r16,r2
8012673c:	0580050e 	bge	zero,r22,80126754 <_dtoa_r+0xb38>
80126740:	a80b883a 	mov	r5,r21
80126744:	b00d883a 	mov	r6,r22
80126748:	e009883a 	mov	r4,fp
8012674c:	01298d00 	call	801298d0 <__lshift>
80126750:	102b883a 	mov	r21,r2
80126754:	d9c00e17 	ldw	r7,56(sp)
80126758:	3801211e 	bne	r7,zero,80126be0 <_dtoa_r+0xfc4>
8012675c:	d9800617 	ldw	r6,24(sp)
80126760:	0181380e 	bge	zero,r6,80126c44 <_dtoa_r+0x1028>
80126764:	d8c00b17 	ldw	r3,44(sp)
80126768:	1800ab1e 	bne	r3,zero,80126a18 <_dtoa_r+0xdfc>
8012676c:	dc800717 	ldw	r18,28(sp)
80126770:	dcc00617 	ldw	r19,24(sp)
80126774:	9029883a 	mov	r20,r18
80126778:	00000206 	br	80126784 <_dtoa_r+0xb68>
8012677c:	01291f80 	call	801291f8 <__multadd>
80126780:	1021883a 	mov	r16,r2
80126784:	a80b883a 	mov	r5,r21
80126788:	8009883a 	mov	r4,r16
8012678c:	0125a140 	call	80125a14 <quorem>
80126790:	10800c04 	addi	r2,r2,48
80126794:	90800005 	stb	r2,0(r18)
80126798:	94800044 	addi	r18,r18,1
8012679c:	9507c83a 	sub	r3,r18,r20
801267a0:	000f883a 	mov	r7,zero
801267a4:	01800284 	movi	r6,10
801267a8:	800b883a 	mov	r5,r16
801267ac:	e009883a 	mov	r4,fp
801267b0:	1cfff216 	blt	r3,r19,8012677c <__reset+0xfa10677c>
801267b4:	1011883a 	mov	r8,r2
801267b8:	d8800617 	ldw	r2,24(sp)
801267bc:	0082370e 	bge	zero,r2,8012709c <_dtoa_r+0x1480>
801267c0:	d9000717 	ldw	r4,28(sp)
801267c4:	0025883a 	mov	r18,zero
801267c8:	20af883a 	add	r23,r4,r2
801267cc:	01800044 	movi	r6,1
801267d0:	800b883a 	mov	r5,r16
801267d4:	e009883a 	mov	r4,fp
801267d8:	da001715 	stw	r8,92(sp)
801267dc:	01298d00 	call	801298d0 <__lshift>
801267e0:	a80b883a 	mov	r5,r21
801267e4:	1009883a 	mov	r4,r2
801267e8:	d8800915 	stw	r2,36(sp)
801267ec:	0129a200 	call	80129a20 <__mcmp>
801267f0:	da001717 	ldw	r8,92(sp)
801267f4:	0081800e 	bge	zero,r2,80126df8 <_dtoa_r+0x11dc>
801267f8:	b93fffc3 	ldbu	r4,-1(r23)
801267fc:	b8bfffc4 	addi	r2,r23,-1
80126800:	1007883a 	mov	r3,r2
80126804:	01800e44 	movi	r6,57
80126808:	d9c00717 	ldw	r7,28(sp)
8012680c:	00000506 	br	80126824 <_dtoa_r+0xc08>
80126810:	18ffffc4 	addi	r3,r3,-1
80126814:	11c12326 	beq	r2,r7,80126ca4 <_dtoa_r+0x1088>
80126818:	19000003 	ldbu	r4,0(r3)
8012681c:	102f883a 	mov	r23,r2
80126820:	10bfffc4 	addi	r2,r2,-1
80126824:	21403fcc 	andi	r5,r4,255
80126828:	2940201c 	xori	r5,r5,128
8012682c:	297fe004 	addi	r5,r5,-128
80126830:	29bff726 	beq	r5,r6,80126810 <__reset+0xfa106810>
80126834:	21000044 	addi	r4,r4,1
80126838:	11000005 	stb	r4,0(r2)
8012683c:	a80b883a 	mov	r5,r21
80126840:	e009883a 	mov	r4,fp
80126844:	01291d00 	call	801291d0 <_Bfree>
80126848:	883ea026 	beq	r17,zero,801262cc <__reset+0xfa1062cc>
8012684c:	90000426 	beq	r18,zero,80126860 <_dtoa_r+0xc44>
80126850:	94400326 	beq	r18,r17,80126860 <_dtoa_r+0xc44>
80126854:	900b883a 	mov	r5,r18
80126858:	e009883a 	mov	r4,fp
8012685c:	01291d00 	call	801291d0 <_Bfree>
80126860:	880b883a 	mov	r5,r17
80126864:	e009883a 	mov	r4,fp
80126868:	01291d00 	call	801291d0 <_Bfree>
8012686c:	003e9706 	br	801262cc <__reset+0xfa1062cc>
80126870:	01800044 	movi	r6,1
80126874:	d9800e15 	stw	r6,56(sp)
80126878:	003d9606 	br	80125ed4 <__reset+0xfa105ed4>
8012687c:	d8800817 	ldw	r2,32(sp)
80126880:	d8c00517 	ldw	r3,20(sp)
80126884:	d8000d15 	stw	zero,52(sp)
80126888:	10c5c83a 	sub	r2,r2,r3
8012688c:	00c9c83a 	sub	r4,zero,r3
80126890:	d8800815 	stw	r2,32(sp)
80126894:	d9000a15 	stw	r4,40(sp)
80126898:	003d9706 	br	80125ef8 <__reset+0xfa105ef8>
8012689c:	05adc83a 	sub	r22,zero,r22
801268a0:	dd800815 	stw	r22,32(sp)
801268a4:	002d883a 	mov	r22,zero
801268a8:	003d8e06 	br	80125ee4 <__reset+0xfa105ee4>
801268ac:	d9000517 	ldw	r4,20(sp)
801268b0:	012102c0 	call	8012102c <__floatsidf>
801268b4:	100d883a 	mov	r6,r2
801268b8:	180f883a 	mov	r7,r3
801268bc:	a009883a 	mov	r4,r20
801268c0:	880b883a 	mov	r5,r17
801268c4:	01316c40 	call	801316c4 <__eqdf2>
801268c8:	103d7126 	beq	r2,zero,80125e90 <__reset+0xfa105e90>
801268cc:	d9c00517 	ldw	r7,20(sp)
801268d0:	39ffffc4 	addi	r7,r7,-1
801268d4:	d9c00515 	stw	r7,20(sp)
801268d8:	003d6d06 	br	80125e90 <__reset+0xfa105e90>
801268dc:	dd400a17 	ldw	r21,40(sp)
801268e0:	dd000817 	ldw	r20,32(sp)
801268e4:	0023883a 	mov	r17,zero
801268e8:	003f4806 	br	8012660c <__reset+0xfa10660c>
801268ec:	10e3c83a 	sub	r17,r2,r3
801268f0:	9448983a 	sll	r4,r18,r17
801268f4:	003d3206 	br	80125dc0 <__reset+0xfa105dc0>
801268f8:	d8000e15 	stw	zero,56(sp)
801268fc:	003d7506 	br	80125ed4 <__reset+0xfa105ed4>
80126900:	b005883a 	mov	r2,r22
80126904:	003f4506 	br	8012661c <__reset+0xfa10661c>
80126908:	dc000915 	stw	r16,36(sp)
8012690c:	d9800a17 	ldw	r6,40(sp)
80126910:	d9400917 	ldw	r5,36(sp)
80126914:	e009883a 	mov	r4,fp
80126918:	01297880 	call	80129788 <__pow5mult>
8012691c:	1021883a 	mov	r16,r2
80126920:	003f5a06 	br	8012668c <__reset+0xfa10668c>
80126924:	01c00044 	movi	r7,1
80126928:	d9c00b15 	stw	r7,44(sp)
8012692c:	d8802217 	ldw	r2,136(sp)
80126930:	0081280e 	bge	zero,r2,80126dd4 <_dtoa_r+0x11b8>
80126934:	100d883a 	mov	r6,r2
80126938:	1021883a 	mov	r16,r2
8012693c:	d8800c15 	stw	r2,48(sp)
80126940:	d8800615 	stw	r2,24(sp)
80126944:	003d8806 	br	80125f68 <__reset+0xfa105f68>
80126948:	d8800617 	ldw	r2,24(sp)
8012694c:	00be9b16 	blt	zero,r2,801263bc <__reset+0xfa1063bc>
80126950:	10010f1e 	bne	r2,zero,80126d90 <_dtoa_r+0x1174>
80126954:	880b883a 	mov	r5,r17
80126958:	000d883a 	mov	r6,zero
8012695c:	01d00534 	movhi	r7,16404
80126960:	8009883a 	mov	r4,r16
80126964:	011ff880 	call	8011ff88 <__muldf3>
80126968:	900d883a 	mov	r6,r18
8012696c:	980f883a 	mov	r7,r19
80126970:	1009883a 	mov	r4,r2
80126974:	180b883a 	mov	r5,r3
80126978:	011feac0 	call	8011feac <__gedf2>
8012697c:	002b883a 	mov	r21,zero
80126980:	0023883a 	mov	r17,zero
80126984:	1000bf16 	blt	r2,zero,80126c84 <_dtoa_r+0x1068>
80126988:	d9802217 	ldw	r6,136(sp)
8012698c:	ddc00717 	ldw	r23,28(sp)
80126990:	018c303a 	nor	r6,zero,r6
80126994:	d9800515 	stw	r6,20(sp)
80126998:	a80b883a 	mov	r5,r21
8012699c:	e009883a 	mov	r4,fp
801269a0:	01291d00 	call	801291d0 <_Bfree>
801269a4:	883e4926 	beq	r17,zero,801262cc <__reset+0xfa1062cc>
801269a8:	003fad06 	br	80126860 <__reset+0xfa106860>
801269ac:	d9c01117 	ldw	r7,68(sp)
801269b0:	3801bc26 	beq	r7,zero,801270a4 <_dtoa_r+0x1488>
801269b4:	10810cc4 	addi	r2,r2,1075
801269b8:	dd400a17 	ldw	r21,40(sp)
801269bc:	dd000817 	ldw	r20,32(sp)
801269c0:	003f0a06 	br	801265ec <__reset+0xfa1065ec>
801269c4:	00800704 	movi	r2,28
801269c8:	d9000817 	ldw	r4,32(sp)
801269cc:	a0a9883a 	add	r20,r20,r2
801269d0:	b0ad883a 	add	r22,r22,r2
801269d4:	2089883a 	add	r4,r4,r2
801269d8:	d9000815 	stw	r4,32(sp)
801269dc:	003f5106 	br	80126724 <__reset+0xfa106724>
801269e0:	d8c00317 	ldw	r3,12(sp)
801269e4:	b8c1fc0e 	bge	r23,r3,801271d8 <_dtoa_r+0x15bc>
801269e8:	0027883a 	mov	r19,zero
801269ec:	b805883a 	mov	r2,r23
801269f0:	003f3e06 	br	801266ec <__reset+0xfa1066ec>
801269f4:	880b883a 	mov	r5,r17
801269f8:	e009883a 	mov	r4,fp
801269fc:	000f883a 	mov	r7,zero
80126a00:	01800284 	movi	r6,10
80126a04:	01291f80 	call	801291f8 <__multadd>
80126a08:	d9000c17 	ldw	r4,48(sp)
80126a0c:	1023883a 	mov	r17,r2
80126a10:	0102040e 	bge	zero,r4,80127224 <_dtoa_r+0x1608>
80126a14:	d9000615 	stw	r4,24(sp)
80126a18:	0500050e 	bge	zero,r20,80126a30 <_dtoa_r+0xe14>
80126a1c:	880b883a 	mov	r5,r17
80126a20:	a00d883a 	mov	r6,r20
80126a24:	e009883a 	mov	r4,fp
80126a28:	01298d00 	call	801298d0 <__lshift>
80126a2c:	1023883a 	mov	r17,r2
80126a30:	9801241e 	bne	r19,zero,80126ec4 <_dtoa_r+0x12a8>
80126a34:	8829883a 	mov	r20,r17
80126a38:	d9000617 	ldw	r4,24(sp)
80126a3c:	dcc00717 	ldw	r19,28(sp)
80126a40:	9480004c 	andi	r18,r18,1
80126a44:	20bfffc4 	addi	r2,r4,-1
80126a48:	9885883a 	add	r2,r19,r2
80126a4c:	d8800415 	stw	r2,16(sp)
80126a50:	dc800615 	stw	r18,24(sp)
80126a54:	a80b883a 	mov	r5,r21
80126a58:	8009883a 	mov	r4,r16
80126a5c:	0125a140 	call	80125a14 <quorem>
80126a60:	880b883a 	mov	r5,r17
80126a64:	8009883a 	mov	r4,r16
80126a68:	102f883a 	mov	r23,r2
80126a6c:	0129a200 	call	80129a20 <__mcmp>
80126a70:	a80b883a 	mov	r5,r21
80126a74:	a00d883a 	mov	r6,r20
80126a78:	e009883a 	mov	r4,fp
80126a7c:	102d883a 	mov	r22,r2
80126a80:	0129a800 	call	80129a80 <__mdiff>
80126a84:	1007883a 	mov	r3,r2
80126a88:	10800317 	ldw	r2,12(r2)
80126a8c:	bc800c04 	addi	r18,r23,48
80126a90:	180b883a 	mov	r5,r3
80126a94:	10004e1e 	bne	r2,zero,80126bd0 <_dtoa_r+0xfb4>
80126a98:	8009883a 	mov	r4,r16
80126a9c:	d8c01615 	stw	r3,88(sp)
80126aa0:	0129a200 	call	80129a20 <__mcmp>
80126aa4:	d8c01617 	ldw	r3,88(sp)
80126aa8:	e009883a 	mov	r4,fp
80126aac:	d8801615 	stw	r2,88(sp)
80126ab0:	180b883a 	mov	r5,r3
80126ab4:	01291d00 	call	801291d0 <_Bfree>
80126ab8:	d8801617 	ldw	r2,88(sp)
80126abc:	1000041e 	bne	r2,zero,80126ad0 <_dtoa_r+0xeb4>
80126ac0:	d9800317 	ldw	r6,12(sp)
80126ac4:	3000021e 	bne	r6,zero,80126ad0 <_dtoa_r+0xeb4>
80126ac8:	d8c00617 	ldw	r3,24(sp)
80126acc:	18003726 	beq	r3,zero,80126bac <_dtoa_r+0xf90>
80126ad0:	b0002016 	blt	r22,zero,80126b54 <_dtoa_r+0xf38>
80126ad4:	b000041e 	bne	r22,zero,80126ae8 <_dtoa_r+0xecc>
80126ad8:	d9000317 	ldw	r4,12(sp)
80126adc:	2000021e 	bne	r4,zero,80126ae8 <_dtoa_r+0xecc>
80126ae0:	d8c00617 	ldw	r3,24(sp)
80126ae4:	18001b26 	beq	r3,zero,80126b54 <_dtoa_r+0xf38>
80126ae8:	00810716 	blt	zero,r2,80126f08 <_dtoa_r+0x12ec>
80126aec:	d8c00417 	ldw	r3,16(sp)
80126af0:	9d800044 	addi	r22,r19,1
80126af4:	9c800005 	stb	r18,0(r19)
80126af8:	b02f883a 	mov	r23,r22
80126afc:	98c10626 	beq	r19,r3,80126f18 <_dtoa_r+0x12fc>
80126b00:	800b883a 	mov	r5,r16
80126b04:	000f883a 	mov	r7,zero
80126b08:	01800284 	movi	r6,10
80126b0c:	e009883a 	mov	r4,fp
80126b10:	01291f80 	call	801291f8 <__multadd>
80126b14:	1021883a 	mov	r16,r2
80126b18:	000f883a 	mov	r7,zero
80126b1c:	01800284 	movi	r6,10
80126b20:	880b883a 	mov	r5,r17
80126b24:	e009883a 	mov	r4,fp
80126b28:	8d002526 	beq	r17,r20,80126bc0 <_dtoa_r+0xfa4>
80126b2c:	01291f80 	call	801291f8 <__multadd>
80126b30:	a00b883a 	mov	r5,r20
80126b34:	000f883a 	mov	r7,zero
80126b38:	01800284 	movi	r6,10
80126b3c:	e009883a 	mov	r4,fp
80126b40:	1023883a 	mov	r17,r2
80126b44:	01291f80 	call	801291f8 <__multadd>
80126b48:	1029883a 	mov	r20,r2
80126b4c:	b027883a 	mov	r19,r22
80126b50:	003fc006 	br	80126a54 <__reset+0xfa106a54>
80126b54:	9011883a 	mov	r8,r18
80126b58:	00800e0e 	bge	zero,r2,80126b94 <_dtoa_r+0xf78>
80126b5c:	800b883a 	mov	r5,r16
80126b60:	01800044 	movi	r6,1
80126b64:	e009883a 	mov	r4,fp
80126b68:	da001715 	stw	r8,92(sp)
80126b6c:	01298d00 	call	801298d0 <__lshift>
80126b70:	a80b883a 	mov	r5,r21
80126b74:	1009883a 	mov	r4,r2
80126b78:	1021883a 	mov	r16,r2
80126b7c:	0129a200 	call	80129a20 <__mcmp>
80126b80:	da001717 	ldw	r8,92(sp)
80126b84:	0081960e 	bge	zero,r2,801271e0 <_dtoa_r+0x15c4>
80126b88:	00800e44 	movi	r2,57
80126b8c:	40817026 	beq	r8,r2,80127150 <_dtoa_r+0x1534>
80126b90:	ba000c44 	addi	r8,r23,49
80126b94:	8825883a 	mov	r18,r17
80126b98:	9dc00044 	addi	r23,r19,1
80126b9c:	9a000005 	stb	r8,0(r19)
80126ba0:	a023883a 	mov	r17,r20
80126ba4:	dc000915 	stw	r16,36(sp)
80126ba8:	003f2406 	br	8012683c <__reset+0xfa10683c>
80126bac:	00800e44 	movi	r2,57
80126bb0:	9011883a 	mov	r8,r18
80126bb4:	90816626 	beq	r18,r2,80127150 <_dtoa_r+0x1534>
80126bb8:	05bff516 	blt	zero,r22,80126b90 <__reset+0xfa106b90>
80126bbc:	003ff506 	br	80126b94 <__reset+0xfa106b94>
80126bc0:	01291f80 	call	801291f8 <__multadd>
80126bc4:	1023883a 	mov	r17,r2
80126bc8:	1029883a 	mov	r20,r2
80126bcc:	003fdf06 	br	80126b4c <__reset+0xfa106b4c>
80126bd0:	e009883a 	mov	r4,fp
80126bd4:	01291d00 	call	801291d0 <_Bfree>
80126bd8:	00800044 	movi	r2,1
80126bdc:	003fbc06 	br	80126ad0 <__reset+0xfa106ad0>
80126be0:	a80b883a 	mov	r5,r21
80126be4:	8009883a 	mov	r4,r16
80126be8:	0129a200 	call	80129a20 <__mcmp>
80126bec:	103edb0e 	bge	r2,zero,8012675c <__reset+0xfa10675c>
80126bf0:	800b883a 	mov	r5,r16
80126bf4:	000f883a 	mov	r7,zero
80126bf8:	01800284 	movi	r6,10
80126bfc:	e009883a 	mov	r4,fp
80126c00:	01291f80 	call	801291f8 <__multadd>
80126c04:	1021883a 	mov	r16,r2
80126c08:	d8800517 	ldw	r2,20(sp)
80126c0c:	d8c00b17 	ldw	r3,44(sp)
80126c10:	10bfffc4 	addi	r2,r2,-1
80126c14:	d8800515 	stw	r2,20(sp)
80126c18:	183f761e 	bne	r3,zero,801269f4 <__reset+0xfa1069f4>
80126c1c:	d9000c17 	ldw	r4,48(sp)
80126c20:	0101730e 	bge	zero,r4,801271f0 <_dtoa_r+0x15d4>
80126c24:	d9000615 	stw	r4,24(sp)
80126c28:	003ed006 	br	8012676c <__reset+0xfa10676c>
80126c2c:	00800084 	movi	r2,2
80126c30:	3081861e 	bne	r6,r2,8012724c <_dtoa_r+0x1630>
80126c34:	d8000b15 	stw	zero,44(sp)
80126c38:	003f3c06 	br	8012692c <__reset+0xfa10692c>
80126c3c:	dc000917 	ldw	r16,36(sp)
80126c40:	003e9206 	br	8012668c <__reset+0xfa10668c>
80126c44:	d9c00317 	ldw	r7,12(sp)
80126c48:	00800084 	movi	r2,2
80126c4c:	11fec50e 	bge	r2,r7,80126764 <__reset+0xfa106764>
80126c50:	d9000617 	ldw	r4,24(sp)
80126c54:	20013c1e 	bne	r4,zero,80127148 <_dtoa_r+0x152c>
80126c58:	a80b883a 	mov	r5,r21
80126c5c:	000f883a 	mov	r7,zero
80126c60:	01800144 	movi	r6,5
80126c64:	e009883a 	mov	r4,fp
80126c68:	01291f80 	call	801291f8 <__multadd>
80126c6c:	100b883a 	mov	r5,r2
80126c70:	8009883a 	mov	r4,r16
80126c74:	102b883a 	mov	r21,r2
80126c78:	0129a200 	call	80129a20 <__mcmp>
80126c7c:	dc000915 	stw	r16,36(sp)
80126c80:	00bf410e 	bge	zero,r2,80126988 <__reset+0xfa106988>
80126c84:	d9c00717 	ldw	r7,28(sp)
80126c88:	00800c44 	movi	r2,49
80126c8c:	38800005 	stb	r2,0(r7)
80126c90:	d8800517 	ldw	r2,20(sp)
80126c94:	3dc00044 	addi	r23,r7,1
80126c98:	10800044 	addi	r2,r2,1
80126c9c:	d8800515 	stw	r2,20(sp)
80126ca0:	003f3d06 	br	80126998 <__reset+0xfa106998>
80126ca4:	d9800517 	ldw	r6,20(sp)
80126ca8:	d9c00717 	ldw	r7,28(sp)
80126cac:	00800c44 	movi	r2,49
80126cb0:	31800044 	addi	r6,r6,1
80126cb4:	d9800515 	stw	r6,20(sp)
80126cb8:	38800005 	stb	r2,0(r7)
80126cbc:	003edf06 	br	8012683c <__reset+0xfa10683c>
80126cc0:	d8000b15 	stw	zero,44(sp)
80126cc4:	003c9f06 	br	80125f44 <__reset+0xfa105f44>
80126cc8:	903e7e1e 	bne	r18,zero,801266c4 <__reset+0xfa1066c4>
80126ccc:	00800434 	movhi	r2,16
80126cd0:	10bfffc4 	addi	r2,r2,-1
80126cd4:	9884703a 	and	r2,r19,r2
80126cd8:	1000ea1e 	bne	r2,zero,80127084 <_dtoa_r+0x1468>
80126cdc:	9cdffc2c 	andhi	r19,r19,32752
80126ce0:	9800e826 	beq	r19,zero,80127084 <_dtoa_r+0x1468>
80126ce4:	d9c00817 	ldw	r7,32(sp)
80126ce8:	b5800044 	addi	r22,r22,1
80126cec:	04c00044 	movi	r19,1
80126cf0:	39c00044 	addi	r7,r7,1
80126cf4:	d9c00815 	stw	r7,32(sp)
80126cf8:	d8800d17 	ldw	r2,52(sp)
80126cfc:	103e721e 	bne	r2,zero,801266c8 <__reset+0xfa1066c8>
80126d00:	00800044 	movi	r2,1
80126d04:	003e7906 	br	801266ec <__reset+0xfa1066ec>
80126d08:	8009883a 	mov	r4,r16
80126d0c:	012102c0 	call	8012102c <__floatsidf>
80126d10:	d9800f17 	ldw	r6,60(sp)
80126d14:	d9c01017 	ldw	r7,64(sp)
80126d18:	1009883a 	mov	r4,r2
80126d1c:	180b883a 	mov	r5,r3
80126d20:	011ff880 	call	8011ff88 <__muldf3>
80126d24:	000d883a 	mov	r6,zero
80126d28:	01d00734 	movhi	r7,16412
80126d2c:	1009883a 	mov	r4,r2
80126d30:	180b883a 	mov	r5,r3
80126d34:	01305200 	call	80130520 <__adddf3>
80126d38:	047f3034 	movhi	r17,64704
80126d3c:	1021883a 	mov	r16,r2
80126d40:	1c63883a 	add	r17,r3,r17
80126d44:	d9000f17 	ldw	r4,60(sp)
80126d48:	d9401017 	ldw	r5,64(sp)
80126d4c:	000d883a 	mov	r6,zero
80126d50:	01d00534 	movhi	r7,16404
80126d54:	01206a80 	call	801206a8 <__subdf3>
80126d58:	800d883a 	mov	r6,r16
80126d5c:	880f883a 	mov	r7,r17
80126d60:	1009883a 	mov	r4,r2
80126d64:	180b883a 	mov	r5,r3
80126d68:	102b883a 	mov	r21,r2
80126d6c:	1829883a 	mov	r20,r3
80126d70:	011feac0 	call	8011feac <__gedf2>
80126d74:	00806c16 	blt	zero,r2,80126f28 <_dtoa_r+0x130c>
80126d78:	89e0003c 	xorhi	r7,r17,32768
80126d7c:	800d883a 	mov	r6,r16
80126d80:	a809883a 	mov	r4,r21
80126d84:	a00b883a 	mov	r5,r20
80126d88:	013174c0 	call	8013174c <__ledf2>
80126d8c:	103d7e0e 	bge	r2,zero,80126388 <__reset+0xfa106388>
80126d90:	002b883a 	mov	r21,zero
80126d94:	0023883a 	mov	r17,zero
80126d98:	003efb06 	br	80126988 <__reset+0xfa106988>
80126d9c:	d8800717 	ldw	r2,28(sp)
80126da0:	003bd006 	br	80125ce4 <__reset+0xfa105ce4>
80126da4:	d9000a17 	ldw	r4,40(sp)
80126da8:	d9800d17 	ldw	r6,52(sp)
80126dac:	dd400a15 	stw	r21,40(sp)
80126db0:	a905c83a 	sub	r2,r21,r4
80126db4:	308d883a 	add	r6,r6,r2
80126db8:	d9800d15 	stw	r6,52(sp)
80126dbc:	002b883a 	mov	r21,zero
80126dc0:	003e0606 	br	801265dc <__reset+0xfa1065dc>
80126dc4:	9023883a 	mov	r17,r18
80126dc8:	9829883a 	mov	r20,r19
80126dcc:	04000084 	movi	r16,2
80126dd0:	003c9206 	br	8012601c <__reset+0xfa10601c>
80126dd4:	04000044 	movi	r16,1
80126dd8:	dc000c15 	stw	r16,48(sp)
80126ddc:	dc000615 	stw	r16,24(sp)
80126de0:	dc002215 	stw	r16,136(sp)
80126de4:	e0001115 	stw	zero,68(fp)
80126de8:	000b883a 	mov	r5,zero
80126dec:	003c6906 	br	80125f94 <__reset+0xfa105f94>
80126df0:	3021883a 	mov	r16,r6
80126df4:	003ffb06 	br	80126de4 <__reset+0xfa106de4>
80126df8:	1000021e 	bne	r2,zero,80126e04 <_dtoa_r+0x11e8>
80126dfc:	4200004c 	andi	r8,r8,1
80126e00:	403e7d1e 	bne	r8,zero,801267f8 <__reset+0xfa1067f8>
80126e04:	01000c04 	movi	r4,48
80126e08:	00000106 	br	80126e10 <_dtoa_r+0x11f4>
80126e0c:	102f883a 	mov	r23,r2
80126e10:	b8bfffc4 	addi	r2,r23,-1
80126e14:	10c00007 	ldb	r3,0(r2)
80126e18:	193ffc26 	beq	r3,r4,80126e0c <__reset+0xfa106e0c>
80126e1c:	003e8706 	br	8012683c <__reset+0xfa10683c>
80126e20:	d8800517 	ldw	r2,20(sp)
80126e24:	00a3c83a 	sub	r17,zero,r2
80126e28:	8800a426 	beq	r17,zero,801270bc <_dtoa_r+0x14a0>
80126e2c:	888003cc 	andi	r2,r17,15
80126e30:	100490fa 	slli	r2,r2,3
80126e34:	00e00534 	movhi	r3,32788
80126e38:	18df0204 	addi	r3,r3,31752
80126e3c:	1885883a 	add	r2,r3,r2
80126e40:	11800017 	ldw	r6,0(r2)
80126e44:	11c00117 	ldw	r7,4(r2)
80126e48:	9009883a 	mov	r4,r18
80126e4c:	980b883a 	mov	r5,r19
80126e50:	8823d13a 	srai	r17,r17,4
80126e54:	011ff880 	call	8011ff88 <__muldf3>
80126e58:	d8800f15 	stw	r2,60(sp)
80126e5c:	d8c01015 	stw	r3,64(sp)
80126e60:	8800e826 	beq	r17,zero,80127204 <_dtoa_r+0x15e8>
80126e64:	05200534 	movhi	r20,32788
80126e68:	a51ef804 	addi	r20,r20,31712
80126e6c:	04000084 	movi	r16,2
80126e70:	8980004c 	andi	r6,r17,1
80126e74:	1009883a 	mov	r4,r2
80126e78:	8823d07a 	srai	r17,r17,1
80126e7c:	180b883a 	mov	r5,r3
80126e80:	30000426 	beq	r6,zero,80126e94 <_dtoa_r+0x1278>
80126e84:	a1800017 	ldw	r6,0(r20)
80126e88:	a1c00117 	ldw	r7,4(r20)
80126e8c:	84000044 	addi	r16,r16,1
80126e90:	011ff880 	call	8011ff88 <__muldf3>
80126e94:	a5000204 	addi	r20,r20,8
80126e98:	883ff51e 	bne	r17,zero,80126e70 <__reset+0xfa106e70>
80126e9c:	d8800f15 	stw	r2,60(sp)
80126ea0:	d8c01015 	stw	r3,64(sp)
80126ea4:	003c7606 	br	80126080 <__reset+0xfa106080>
80126ea8:	00c00c04 	movi	r3,48
80126eac:	10c00005 	stb	r3,0(r2)
80126eb0:	d8c00517 	ldw	r3,20(sp)
80126eb4:	bd3fffc3 	ldbu	r20,-1(r23)
80126eb8:	18c00044 	addi	r3,r3,1
80126ebc:	d8c00515 	stw	r3,20(sp)
80126ec0:	003db906 	br	801265a8 <__reset+0xfa1065a8>
80126ec4:	89400117 	ldw	r5,4(r17)
80126ec8:	e009883a 	mov	r4,fp
80126ecc:	01291200 	call	80129120 <_Balloc>
80126ed0:	89800417 	ldw	r6,16(r17)
80126ed4:	89400304 	addi	r5,r17,12
80126ed8:	11000304 	addi	r4,r2,12
80126edc:	31800084 	addi	r6,r6,2
80126ee0:	318d883a 	add	r6,r6,r6
80126ee4:	318d883a 	add	r6,r6,r6
80126ee8:	1027883a 	mov	r19,r2
80126eec:	01214640 	call	80121464 <memcpy>
80126ef0:	01800044 	movi	r6,1
80126ef4:	980b883a 	mov	r5,r19
80126ef8:	e009883a 	mov	r4,fp
80126efc:	01298d00 	call	801298d0 <__lshift>
80126f00:	1029883a 	mov	r20,r2
80126f04:	003ecc06 	br	80126a38 <__reset+0xfa106a38>
80126f08:	00800e44 	movi	r2,57
80126f0c:	90809026 	beq	r18,r2,80127150 <_dtoa_r+0x1534>
80126f10:	92000044 	addi	r8,r18,1
80126f14:	003f1f06 	br	80126b94 <__reset+0xfa106b94>
80126f18:	9011883a 	mov	r8,r18
80126f1c:	8825883a 	mov	r18,r17
80126f20:	a023883a 	mov	r17,r20
80126f24:	003e2906 	br	801267cc <__reset+0xfa1067cc>
80126f28:	002b883a 	mov	r21,zero
80126f2c:	0023883a 	mov	r17,zero
80126f30:	003f5406 	br	80126c84 <__reset+0xfa106c84>
80126f34:	61bfffc4 	addi	r6,r12,-1
80126f38:	300490fa 	slli	r2,r6,3
80126f3c:	00e00534 	movhi	r3,32788
80126f40:	18df0204 	addi	r3,r3,31752
80126f44:	1885883a 	add	r2,r3,r2
80126f48:	11000017 	ldw	r4,0(r2)
80126f4c:	11400117 	ldw	r5,4(r2)
80126f50:	d8800717 	ldw	r2,28(sp)
80126f54:	880f883a 	mov	r7,r17
80126f58:	d9801215 	stw	r6,72(sp)
80126f5c:	800d883a 	mov	r6,r16
80126f60:	db001615 	stw	r12,88(sp)
80126f64:	15c00044 	addi	r23,r2,1
80126f68:	011ff880 	call	8011ff88 <__muldf3>
80126f6c:	d9401017 	ldw	r5,64(sp)
80126f70:	d9000f17 	ldw	r4,60(sp)
80126f74:	d8c01515 	stw	r3,84(sp)
80126f78:	d8801415 	stw	r2,80(sp)
80126f7c:	0120fac0 	call	80120fac <__fixdfsi>
80126f80:	1009883a 	mov	r4,r2
80126f84:	1021883a 	mov	r16,r2
80126f88:	012102c0 	call	8012102c <__floatsidf>
80126f8c:	d9000f17 	ldw	r4,60(sp)
80126f90:	d9401017 	ldw	r5,64(sp)
80126f94:	100d883a 	mov	r6,r2
80126f98:	180f883a 	mov	r7,r3
80126f9c:	01206a80 	call	801206a8 <__subdf3>
80126fa0:	1829883a 	mov	r20,r3
80126fa4:	d8c00717 	ldw	r3,28(sp)
80126fa8:	84000c04 	addi	r16,r16,48
80126fac:	1023883a 	mov	r17,r2
80126fb0:	1c000005 	stb	r16,0(r3)
80126fb4:	db001617 	ldw	r12,88(sp)
80126fb8:	00800044 	movi	r2,1
80126fbc:	60802226 	beq	r12,r2,80127048 <_dtoa_r+0x142c>
80126fc0:	d9c00717 	ldw	r7,28(sp)
80126fc4:	8805883a 	mov	r2,r17
80126fc8:	b82b883a 	mov	r21,r23
80126fcc:	3b19883a 	add	r12,r7,r12
80126fd0:	6023883a 	mov	r17,r12
80126fd4:	a007883a 	mov	r3,r20
80126fd8:	dc800f15 	stw	r18,60(sp)
80126fdc:	000d883a 	mov	r6,zero
80126fe0:	01d00934 	movhi	r7,16420
80126fe4:	1009883a 	mov	r4,r2
80126fe8:	180b883a 	mov	r5,r3
80126fec:	011ff880 	call	8011ff88 <__muldf3>
80126ff0:	180b883a 	mov	r5,r3
80126ff4:	1009883a 	mov	r4,r2
80126ff8:	1829883a 	mov	r20,r3
80126ffc:	1025883a 	mov	r18,r2
80127000:	0120fac0 	call	80120fac <__fixdfsi>
80127004:	1009883a 	mov	r4,r2
80127008:	1021883a 	mov	r16,r2
8012700c:	012102c0 	call	8012102c <__floatsidf>
80127010:	100d883a 	mov	r6,r2
80127014:	180f883a 	mov	r7,r3
80127018:	9009883a 	mov	r4,r18
8012701c:	a00b883a 	mov	r5,r20
80127020:	84000c04 	addi	r16,r16,48
80127024:	01206a80 	call	801206a8 <__subdf3>
80127028:	ad400044 	addi	r21,r21,1
8012702c:	ac3fffc5 	stb	r16,-1(r21)
80127030:	ac7fea1e 	bne	r21,r17,80126fdc <__reset+0xfa106fdc>
80127034:	1023883a 	mov	r17,r2
80127038:	d8801217 	ldw	r2,72(sp)
8012703c:	dc800f17 	ldw	r18,60(sp)
80127040:	1829883a 	mov	r20,r3
80127044:	b8af883a 	add	r23,r23,r2
80127048:	d9001417 	ldw	r4,80(sp)
8012704c:	d9401517 	ldw	r5,84(sp)
80127050:	000d883a 	mov	r6,zero
80127054:	01cff834 	movhi	r7,16352
80127058:	01305200 	call	80130520 <__adddf3>
8012705c:	880d883a 	mov	r6,r17
80127060:	a00f883a 	mov	r7,r20
80127064:	1009883a 	mov	r4,r2
80127068:	180b883a 	mov	r5,r3
8012706c:	013174c0 	call	8013174c <__ledf2>
80127070:	10003e0e 	bge	r2,zero,8012716c <_dtoa_r+0x1550>
80127074:	d9001317 	ldw	r4,76(sp)
80127078:	bd3fffc3 	ldbu	r20,-1(r23)
8012707c:	d9000515 	stw	r4,20(sp)
80127080:	003d3b06 	br	80126570 <__reset+0xfa106570>
80127084:	0027883a 	mov	r19,zero
80127088:	003f1b06 	br	80126cf8 <__reset+0xfa106cf8>
8012708c:	d8800817 	ldw	r2,32(sp)
80127090:	11e9c83a 	sub	r20,r2,r7
80127094:	0005883a 	mov	r2,zero
80127098:	003d5406 	br	801265ec <__reset+0xfa1065ec>
8012709c:	00800044 	movi	r2,1
801270a0:	003dc706 	br	801267c0 <__reset+0xfa1067c0>
801270a4:	d8c00217 	ldw	r3,8(sp)
801270a8:	00800d84 	movi	r2,54
801270ac:	dd400a17 	ldw	r21,40(sp)
801270b0:	10c5c83a 	sub	r2,r2,r3
801270b4:	dd000817 	ldw	r20,32(sp)
801270b8:	003d4c06 	br	801265ec <__reset+0xfa1065ec>
801270bc:	dc800f15 	stw	r18,60(sp)
801270c0:	dcc01015 	stw	r19,64(sp)
801270c4:	04000084 	movi	r16,2
801270c8:	003bed06 	br	80126080 <__reset+0xfa106080>
801270cc:	d9000617 	ldw	r4,24(sp)
801270d0:	203f0d26 	beq	r4,zero,80126d08 <__reset+0xfa106d08>
801270d4:	d9800c17 	ldw	r6,48(sp)
801270d8:	01bcab0e 	bge	zero,r6,80126388 <__reset+0xfa106388>
801270dc:	d9401017 	ldw	r5,64(sp)
801270e0:	d9000f17 	ldw	r4,60(sp)
801270e4:	000d883a 	mov	r6,zero
801270e8:	01d00934 	movhi	r7,16420
801270ec:	011ff880 	call	8011ff88 <__muldf3>
801270f0:	81000044 	addi	r4,r16,1
801270f4:	d8800f15 	stw	r2,60(sp)
801270f8:	d8c01015 	stw	r3,64(sp)
801270fc:	012102c0 	call	8012102c <__floatsidf>
80127100:	d9800f17 	ldw	r6,60(sp)
80127104:	d9c01017 	ldw	r7,64(sp)
80127108:	1009883a 	mov	r4,r2
8012710c:	180b883a 	mov	r5,r3
80127110:	011ff880 	call	8011ff88 <__muldf3>
80127114:	01d00734 	movhi	r7,16412
80127118:	000d883a 	mov	r6,zero
8012711c:	1009883a 	mov	r4,r2
80127120:	180b883a 	mov	r5,r3
80127124:	01305200 	call	80130520 <__adddf3>
80127128:	d9c00517 	ldw	r7,20(sp)
8012712c:	047f3034 	movhi	r17,64704
80127130:	1021883a 	mov	r16,r2
80127134:	39ffffc4 	addi	r7,r7,-1
80127138:	d9c01315 	stw	r7,76(sp)
8012713c:	1c63883a 	add	r17,r3,r17
80127140:	db000c17 	ldw	r12,48(sp)
80127144:	003bea06 	br	801260f0 <__reset+0xfa1060f0>
80127148:	dc000915 	stw	r16,36(sp)
8012714c:	003e0e06 	br	80126988 <__reset+0xfa106988>
80127150:	01000e44 	movi	r4,57
80127154:	8825883a 	mov	r18,r17
80127158:	9dc00044 	addi	r23,r19,1
8012715c:	99000005 	stb	r4,0(r19)
80127160:	a023883a 	mov	r17,r20
80127164:	dc000915 	stw	r16,36(sp)
80127168:	003da406 	br	801267fc <__reset+0xfa1067fc>
8012716c:	d9801417 	ldw	r6,80(sp)
80127170:	d9c01517 	ldw	r7,84(sp)
80127174:	0009883a 	mov	r4,zero
80127178:	014ff834 	movhi	r5,16352
8012717c:	01206a80 	call	801206a8 <__subdf3>
80127180:	880d883a 	mov	r6,r17
80127184:	a00f883a 	mov	r7,r20
80127188:	1009883a 	mov	r4,r2
8012718c:	180b883a 	mov	r5,r3
80127190:	011feac0 	call	8011feac <__gedf2>
80127194:	00bc7c0e 	bge	zero,r2,80126388 <__reset+0xfa106388>
80127198:	01000c04 	movi	r4,48
8012719c:	00000106 	br	801271a4 <_dtoa_r+0x1588>
801271a0:	102f883a 	mov	r23,r2
801271a4:	b8bfffc4 	addi	r2,r23,-1
801271a8:	10c00007 	ldb	r3,0(r2)
801271ac:	193ffc26 	beq	r3,r4,801271a0 <__reset+0xfa1071a0>
801271b0:	d9801317 	ldw	r6,76(sp)
801271b4:	d9800515 	stw	r6,20(sp)
801271b8:	003c4406 	br	801262cc <__reset+0xfa1062cc>
801271bc:	d9801317 	ldw	r6,76(sp)
801271c0:	d9800515 	stw	r6,20(sp)
801271c4:	003cea06 	br	80126570 <__reset+0xfa106570>
801271c8:	dd800f17 	ldw	r22,60(sp)
801271cc:	dcc01017 	ldw	r19,64(sp)
801271d0:	dc801217 	ldw	r18,72(sp)
801271d4:	003c6c06 	br	80126388 <__reset+0xfa106388>
801271d8:	903e031e 	bne	r18,zero,801269e8 <__reset+0xfa1069e8>
801271dc:	003ebb06 	br	80126ccc <__reset+0xfa106ccc>
801271e0:	103e6c1e 	bne	r2,zero,80126b94 <__reset+0xfa106b94>
801271e4:	4080004c 	andi	r2,r8,1
801271e8:	103e6a26 	beq	r2,zero,80126b94 <__reset+0xfa106b94>
801271ec:	003e6606 	br	80126b88 <__reset+0xfa106b88>
801271f0:	d8c00317 	ldw	r3,12(sp)
801271f4:	00800084 	movi	r2,2
801271f8:	10c02916 	blt	r2,r3,801272a0 <_dtoa_r+0x1684>
801271fc:	d9000c17 	ldw	r4,48(sp)
80127200:	003e8806 	br	80126c24 <__reset+0xfa106c24>
80127204:	04000084 	movi	r16,2
80127208:	003b9d06 	br	80126080 <__reset+0xfa106080>
8012720c:	d9001317 	ldw	r4,76(sp)
80127210:	d9000515 	stw	r4,20(sp)
80127214:	003cd606 	br	80126570 <__reset+0xfa106570>
80127218:	d8801317 	ldw	r2,76(sp)
8012721c:	d8800515 	stw	r2,20(sp)
80127220:	003c2a06 	br	801262cc <__reset+0xfa1062cc>
80127224:	d9800317 	ldw	r6,12(sp)
80127228:	00800084 	movi	r2,2
8012722c:	11801516 	blt	r2,r6,80127284 <_dtoa_r+0x1668>
80127230:	d9c00c17 	ldw	r7,48(sp)
80127234:	d9c00615 	stw	r7,24(sp)
80127238:	003df706 	br	80126a18 <__reset+0xfa106a18>
8012723c:	193d3926 	beq	r3,r4,80126724 <__reset+0xfa106724>
80127240:	00c00f04 	movi	r3,60
80127244:	1885c83a 	sub	r2,r3,r2
80127248:	003ddf06 	br	801269c8 <__reset+0xfa1069c8>
8012724c:	e009883a 	mov	r4,fp
80127250:	e0001115 	stw	zero,68(fp)
80127254:	000b883a 	mov	r5,zero
80127258:	01291200 	call	80129120 <_Balloc>
8012725c:	d8800715 	stw	r2,28(sp)
80127260:	d8c00717 	ldw	r3,28(sp)
80127264:	00bfffc4 	movi	r2,-1
80127268:	01000044 	movi	r4,1
8012726c:	d8800c15 	stw	r2,48(sp)
80127270:	e0c01015 	stw	r3,64(fp)
80127274:	d9000b15 	stw	r4,44(sp)
80127278:	d8800615 	stw	r2,24(sp)
8012727c:	d8002215 	stw	zero,136(sp)
80127280:	003c4106 	br	80126388 <__reset+0xfa106388>
80127284:	d8c00c17 	ldw	r3,48(sp)
80127288:	d8c00615 	stw	r3,24(sp)
8012728c:	003e7006 	br	80126c50 <__reset+0xfa106c50>
80127290:	04400044 	movi	r17,1
80127294:	003b2006 	br	80125f18 <__reset+0xfa105f18>
80127298:	000b883a 	mov	r5,zero
8012729c:	003b3d06 	br	80125f94 <__reset+0xfa105f94>
801272a0:	d8800c17 	ldw	r2,48(sp)
801272a4:	d8800615 	stw	r2,24(sp)
801272a8:	003e6906 	br	80126c50 <__reset+0xfa106c50>

801272ac <__fp_unlock>:
801272ac:	0005883a 	mov	r2,zero
801272b0:	f800283a 	ret

801272b4 <_cleanup_r>:
801272b4:	016004f4 	movhi	r5,32787
801272b8:	2978cb04 	addi	r5,r5,-7380
801272bc:	01282a81 	jmpi	801282a8 <_fwalk_reent>

801272c0 <__sinit.part.1>:
801272c0:	defff704 	addi	sp,sp,-36
801272c4:	00e004b4 	movhi	r3,32786
801272c8:	de00012e 	bgeu	sp,et,801272d0 <__sinit.part.1+0x10>
801272cc:	003b68fa 	trap	3
801272d0:	18dcad04 	addi	r3,r3,29364
801272d4:	dfc00815 	stw	ra,32(sp)
801272d8:	ddc00715 	stw	r23,28(sp)
801272dc:	dd800615 	stw	r22,24(sp)
801272e0:	dd400515 	stw	r21,20(sp)
801272e4:	dd000415 	stw	r20,16(sp)
801272e8:	dcc00315 	stw	r19,12(sp)
801272ec:	dc800215 	stw	r18,8(sp)
801272f0:	dc400115 	stw	r17,4(sp)
801272f4:	dc000015 	stw	r16,0(sp)
801272f8:	24000117 	ldw	r16,4(r4)
801272fc:	20c00f15 	stw	r3,60(r4)
80127300:	2080bb04 	addi	r2,r4,748
80127304:	00c000c4 	movi	r3,3
80127308:	20c0b915 	stw	r3,740(r4)
8012730c:	2080ba15 	stw	r2,744(r4)
80127310:	2000b815 	stw	zero,736(r4)
80127314:	05c00204 	movi	r23,8
80127318:	00800104 	movi	r2,4
8012731c:	2025883a 	mov	r18,r4
80127320:	b80d883a 	mov	r6,r23
80127324:	81001704 	addi	r4,r16,92
80127328:	000b883a 	mov	r5,zero
8012732c:	80000015 	stw	zero,0(r16)
80127330:	80000115 	stw	zero,4(r16)
80127334:	80000215 	stw	zero,8(r16)
80127338:	8080030d 	sth	r2,12(r16)
8012733c:	80001915 	stw	zero,100(r16)
80127340:	8000038d 	sth	zero,14(r16)
80127344:	80000415 	stw	zero,16(r16)
80127348:	80000515 	stw	zero,20(r16)
8012734c:	80000615 	stw	zero,24(r16)
80127350:	01215b40 	call	801215b4 <memset>
80127354:	05a004f4 	movhi	r22,32787
80127358:	94400217 	ldw	r17,8(r18)
8012735c:	056004f4 	movhi	r21,32787
80127360:	052004f4 	movhi	r20,32787
80127364:	04e004f4 	movhi	r19,32787
80127368:	b5aaa204 	addi	r22,r22,-21880
8012736c:	ad6abb04 	addi	r21,r21,-21780
80127370:	a52adc04 	addi	r20,r20,-21648
80127374:	9ceaf504 	addi	r19,r19,-21548
80127378:	85800815 	stw	r22,32(r16)
8012737c:	85400915 	stw	r21,36(r16)
80127380:	85000a15 	stw	r20,40(r16)
80127384:	84c00b15 	stw	r19,44(r16)
80127388:	84000715 	stw	r16,28(r16)
8012738c:	00800284 	movi	r2,10
80127390:	8880030d 	sth	r2,12(r17)
80127394:	00800044 	movi	r2,1
80127398:	b80d883a 	mov	r6,r23
8012739c:	89001704 	addi	r4,r17,92
801273a0:	000b883a 	mov	r5,zero
801273a4:	88000015 	stw	zero,0(r17)
801273a8:	88000115 	stw	zero,4(r17)
801273ac:	88000215 	stw	zero,8(r17)
801273b0:	88001915 	stw	zero,100(r17)
801273b4:	8880038d 	sth	r2,14(r17)
801273b8:	88000415 	stw	zero,16(r17)
801273bc:	88000515 	stw	zero,20(r17)
801273c0:	88000615 	stw	zero,24(r17)
801273c4:	01215b40 	call	801215b4 <memset>
801273c8:	94000317 	ldw	r16,12(r18)
801273cc:	00800484 	movi	r2,18
801273d0:	8c400715 	stw	r17,28(r17)
801273d4:	8d800815 	stw	r22,32(r17)
801273d8:	8d400915 	stw	r21,36(r17)
801273dc:	8d000a15 	stw	r20,40(r17)
801273e0:	8cc00b15 	stw	r19,44(r17)
801273e4:	8080030d 	sth	r2,12(r16)
801273e8:	00800084 	movi	r2,2
801273ec:	80000015 	stw	zero,0(r16)
801273f0:	80000115 	stw	zero,4(r16)
801273f4:	80000215 	stw	zero,8(r16)
801273f8:	80001915 	stw	zero,100(r16)
801273fc:	8080038d 	sth	r2,14(r16)
80127400:	80000415 	stw	zero,16(r16)
80127404:	80000515 	stw	zero,20(r16)
80127408:	80000615 	stw	zero,24(r16)
8012740c:	b80d883a 	mov	r6,r23
80127410:	000b883a 	mov	r5,zero
80127414:	81001704 	addi	r4,r16,92
80127418:	01215b40 	call	801215b4 <memset>
8012741c:	00800044 	movi	r2,1
80127420:	84000715 	stw	r16,28(r16)
80127424:	85800815 	stw	r22,32(r16)
80127428:	85400915 	stw	r21,36(r16)
8012742c:	85000a15 	stw	r20,40(r16)
80127430:	84c00b15 	stw	r19,44(r16)
80127434:	90800e15 	stw	r2,56(r18)
80127438:	dfc00817 	ldw	ra,32(sp)
8012743c:	ddc00717 	ldw	r23,28(sp)
80127440:	dd800617 	ldw	r22,24(sp)
80127444:	dd400517 	ldw	r21,20(sp)
80127448:	dd000417 	ldw	r20,16(sp)
8012744c:	dcc00317 	ldw	r19,12(sp)
80127450:	dc800217 	ldw	r18,8(sp)
80127454:	dc400117 	ldw	r17,4(sp)
80127458:	dc000017 	ldw	r16,0(sp)
8012745c:	dec00904 	addi	sp,sp,36
80127460:	f800283a 	ret

80127464 <__fp_lock>:
80127464:	0005883a 	mov	r2,zero
80127468:	f800283a 	ret

8012746c <__sfmoreglue>:
8012746c:	defffc04 	addi	sp,sp,-16
80127470:	de00012e 	bgeu	sp,et,80127478 <__sfmoreglue+0xc>
80127474:	003b68fa 	trap	3
80127478:	dc400115 	stw	r17,4(sp)
8012747c:	2c7fffc4 	addi	r17,r5,-1
80127480:	8c401a24 	muli	r17,r17,104
80127484:	dc800215 	stw	r18,8(sp)
80127488:	2825883a 	mov	r18,r5
8012748c:	89401d04 	addi	r5,r17,116
80127490:	dc000015 	stw	r16,0(sp)
80127494:	dfc00315 	stw	ra,12(sp)
80127498:	01284880 	call	80128488 <_malloc_r>
8012749c:	1021883a 	mov	r16,r2
801274a0:	10000726 	beq	r2,zero,801274c0 <__sfmoreglue+0x54>
801274a4:	11000304 	addi	r4,r2,12
801274a8:	10000015 	stw	zero,0(r2)
801274ac:	14800115 	stw	r18,4(r2)
801274b0:	11000215 	stw	r4,8(r2)
801274b4:	89801a04 	addi	r6,r17,104
801274b8:	000b883a 	mov	r5,zero
801274bc:	01215b40 	call	801215b4 <memset>
801274c0:	8005883a 	mov	r2,r16
801274c4:	dfc00317 	ldw	ra,12(sp)
801274c8:	dc800217 	ldw	r18,8(sp)
801274cc:	dc400117 	ldw	r17,4(sp)
801274d0:	dc000017 	ldw	r16,0(sp)
801274d4:	dec00404 	addi	sp,sp,16
801274d8:	f800283a 	ret

801274dc <__sfp>:
801274dc:	defffb04 	addi	sp,sp,-20
801274e0:	de00012e 	bgeu	sp,et,801274e8 <__sfp+0xc>
801274e4:	003b68fa 	trap	3
801274e8:	dc000015 	stw	r16,0(sp)
801274ec:	04200574 	movhi	r16,32789
801274f0:	84288604 	addi	r16,r16,-24040
801274f4:	dcc00315 	stw	r19,12(sp)
801274f8:	2027883a 	mov	r19,r4
801274fc:	81000017 	ldw	r4,0(r16)
80127500:	dfc00415 	stw	ra,16(sp)
80127504:	dc800215 	stw	r18,8(sp)
80127508:	20800e17 	ldw	r2,56(r4)
8012750c:	dc400115 	stw	r17,4(sp)
80127510:	1000021e 	bne	r2,zero,8012751c <__sfp+0x40>
80127514:	01272c00 	call	801272c0 <__sinit.part.1>
80127518:	81000017 	ldw	r4,0(r16)
8012751c:	2480b804 	addi	r18,r4,736
80127520:	047fffc4 	movi	r17,-1
80127524:	91000117 	ldw	r4,4(r18)
80127528:	94000217 	ldw	r16,8(r18)
8012752c:	213fffc4 	addi	r4,r4,-1
80127530:	20000a16 	blt	r4,zero,8012755c <__sfp+0x80>
80127534:	8080030f 	ldh	r2,12(r16)
80127538:	10000c26 	beq	r2,zero,8012756c <__sfp+0x90>
8012753c:	80c01d04 	addi	r3,r16,116
80127540:	00000206 	br	8012754c <__sfp+0x70>
80127544:	18bfe60f 	ldh	r2,-104(r3)
80127548:	10000826 	beq	r2,zero,8012756c <__sfp+0x90>
8012754c:	213fffc4 	addi	r4,r4,-1
80127550:	1c3ffd04 	addi	r16,r3,-12
80127554:	18c01a04 	addi	r3,r3,104
80127558:	247ffa1e 	bne	r4,r17,80127544 <__reset+0xfa107544>
8012755c:	90800017 	ldw	r2,0(r18)
80127560:	10001d26 	beq	r2,zero,801275d8 <__sfp+0xfc>
80127564:	1025883a 	mov	r18,r2
80127568:	003fee06 	br	80127524 <__reset+0xfa107524>
8012756c:	00bfffc4 	movi	r2,-1
80127570:	8080038d 	sth	r2,14(r16)
80127574:	00800044 	movi	r2,1
80127578:	8080030d 	sth	r2,12(r16)
8012757c:	80001915 	stw	zero,100(r16)
80127580:	80000015 	stw	zero,0(r16)
80127584:	80000215 	stw	zero,8(r16)
80127588:	80000115 	stw	zero,4(r16)
8012758c:	80000415 	stw	zero,16(r16)
80127590:	80000515 	stw	zero,20(r16)
80127594:	80000615 	stw	zero,24(r16)
80127598:	01800204 	movi	r6,8
8012759c:	000b883a 	mov	r5,zero
801275a0:	81001704 	addi	r4,r16,92
801275a4:	01215b40 	call	801215b4 <memset>
801275a8:	8005883a 	mov	r2,r16
801275ac:	80000c15 	stw	zero,48(r16)
801275b0:	80000d15 	stw	zero,52(r16)
801275b4:	80001115 	stw	zero,68(r16)
801275b8:	80001215 	stw	zero,72(r16)
801275bc:	dfc00417 	ldw	ra,16(sp)
801275c0:	dcc00317 	ldw	r19,12(sp)
801275c4:	dc800217 	ldw	r18,8(sp)
801275c8:	dc400117 	ldw	r17,4(sp)
801275cc:	dc000017 	ldw	r16,0(sp)
801275d0:	dec00504 	addi	sp,sp,20
801275d4:	f800283a 	ret
801275d8:	01400104 	movi	r5,4
801275dc:	9809883a 	mov	r4,r19
801275e0:	012746c0 	call	8012746c <__sfmoreglue>
801275e4:	90800015 	stw	r2,0(r18)
801275e8:	103fde1e 	bne	r2,zero,80127564 <__reset+0xfa107564>
801275ec:	00800304 	movi	r2,12
801275f0:	98800015 	stw	r2,0(r19)
801275f4:	0005883a 	mov	r2,zero
801275f8:	003ff006 	br	801275bc <__reset+0xfa1075bc>

801275fc <_cleanup>:
801275fc:	00a00574 	movhi	r2,32789
80127600:	10a88604 	addi	r2,r2,-24040
80127604:	11000017 	ldw	r4,0(r2)
80127608:	016004f4 	movhi	r5,32787
8012760c:	2978cb04 	addi	r5,r5,-7380
80127610:	01282a81 	jmpi	801282a8 <_fwalk_reent>

80127614 <__sinit>:
80127614:	20800e17 	ldw	r2,56(r4)
80127618:	10000126 	beq	r2,zero,80127620 <__sinit+0xc>
8012761c:	f800283a 	ret
80127620:	01272c01 	jmpi	801272c0 <__sinit.part.1>

80127624 <__sfp_lock_acquire>:
80127624:	f800283a 	ret

80127628 <__sfp_lock_release>:
80127628:	f800283a 	ret

8012762c <__sinit_lock_acquire>:
8012762c:	f800283a 	ret

80127630 <__sinit_lock_release>:
80127630:	f800283a 	ret

80127634 <__fp_lock_all>:
80127634:	00a00574 	movhi	r2,32789
80127638:	10a88704 	addi	r2,r2,-24036
8012763c:	11000017 	ldw	r4,0(r2)
80127640:	016004b4 	movhi	r5,32786
80127644:	295d1904 	addi	r5,r5,29796
80127648:	01281dc1 	jmpi	801281dc <_fwalk>

8012764c <__fp_unlock_all>:
8012764c:	00a00574 	movhi	r2,32789
80127650:	10a88704 	addi	r2,r2,-24036
80127654:	11000017 	ldw	r4,0(r2)
80127658:	016004b4 	movhi	r5,32786
8012765c:	295cab04 	addi	r5,r5,29356
80127660:	01281dc1 	jmpi	801281dc <_fwalk>

80127664 <_fread_r>:
80127664:	defff404 	addi	sp,sp,-48
80127668:	de00012e 	bgeu	sp,et,80127670 <_fread_r+0xc>
8012766c:	003b68fa 	trap	3
80127670:	dd800815 	stw	r22,32(sp)
80127674:	39ad383a 	mul	r22,r7,r6
80127678:	dc000215 	stw	r16,8(sp)
8012767c:	dfc00b15 	stw	ra,44(sp)
80127680:	df000a15 	stw	fp,40(sp)
80127684:	ddc00915 	stw	r23,36(sp)
80127688:	dd400715 	stw	r21,28(sp)
8012768c:	dd000615 	stw	r20,24(sp)
80127690:	dcc00515 	stw	r19,20(sp)
80127694:	dc800415 	stw	r18,16(sp)
80127698:	dc400315 	stw	r17,12(sp)
8012769c:	dc000c17 	ldw	r16,48(sp)
801276a0:	b0003b26 	beq	r22,zero,80127790 <_fread_r+0x12c>
801276a4:	302f883a 	mov	r23,r6
801276a8:	382b883a 	mov	r21,r7
801276ac:	2029883a 	mov	r20,r4
801276b0:	2827883a 	mov	r19,r5
801276b4:	20000226 	beq	r4,zero,801276c0 <_fread_r+0x5c>
801276b8:	20800e17 	ldw	r2,56(r4)
801276bc:	10006e26 	beq	r2,zero,80127878 <_fread_r+0x214>
801276c0:	8080030b 	ldhu	r2,12(r16)
801276c4:	10c8000c 	andi	r3,r2,8192
801276c8:	1800061e 	bne	r3,zero,801276e4 <_fread_r+0x80>
801276cc:	81001917 	ldw	r4,100(r16)
801276d0:	00f7ffc4 	movi	r3,-8193
801276d4:	10880014 	ori	r2,r2,8192
801276d8:	20c6703a 	and	r3,r4,r3
801276dc:	8080030d 	sth	r2,12(r16)
801276e0:	80c01915 	stw	r3,100(r16)
801276e4:	84400117 	ldw	r17,4(r16)
801276e8:	88005f16 	blt	r17,zero,80127868 <_fread_r+0x204>
801276ec:	8809883a 	mov	r4,r17
801276f0:	1080008c 	andi	r2,r2,2
801276f4:	1000281e 	bne	r2,zero,80127798 <_fread_r+0x134>
801276f8:	b025883a 	mov	r18,r22
801276fc:	00000b06 	br	8012772c <_fread_r+0xc8>
80127700:	01214640 	call	80121464 <memcpy>
80127704:	80800017 	ldw	r2,0(r16)
80127708:	9c67883a 	add	r19,r19,r17
8012770c:	9465c83a 	sub	r18,r18,r17
80127710:	1463883a 	add	r17,r2,r17
80127714:	800b883a 	mov	r5,r16
80127718:	a009883a 	mov	r4,r20
8012771c:	84400015 	stw	r17,0(r16)
80127720:	012a7040 	call	8012a704 <__srefill_r>
80127724:	10004c1e 	bne	r2,zero,80127858 <_fread_r+0x1f4>
80127728:	84400117 	ldw	r17,4(r16)
8012772c:	880d883a 	mov	r6,r17
80127730:	9809883a 	mov	r4,r19
80127734:	81400017 	ldw	r5,0(r16)
80127738:	8cbff136 	bltu	r17,r18,80127700 <__reset+0xfa107700>
8012773c:	900d883a 	mov	r6,r18
80127740:	01214640 	call	80121464 <memcpy>
80127744:	80c00117 	ldw	r3,4(r16)
80127748:	81000017 	ldw	r4,0(r16)
8012774c:	a805883a 	mov	r2,r21
80127750:	1c87c83a 	sub	r3,r3,r18
80127754:	24a5883a 	add	r18,r4,r18
80127758:	80c00115 	stw	r3,4(r16)
8012775c:	84800015 	stw	r18,0(r16)
80127760:	dfc00b17 	ldw	ra,44(sp)
80127764:	df000a17 	ldw	fp,40(sp)
80127768:	ddc00917 	ldw	r23,36(sp)
8012776c:	dd800817 	ldw	r22,32(sp)
80127770:	dd400717 	ldw	r21,28(sp)
80127774:	dd000617 	ldw	r20,24(sp)
80127778:	dcc00517 	ldw	r19,20(sp)
8012777c:	dc800417 	ldw	r18,16(sp)
80127780:	dc400317 	ldw	r17,12(sp)
80127784:	dc000217 	ldw	r16,8(sp)
80127788:	dec00c04 	addi	sp,sp,48
8012778c:	f800283a 	ret
80127790:	0005883a 	mov	r2,zero
80127794:	003ff206 	br	80127760 <__reset+0xfa107760>
80127798:	b007883a 	mov	r3,r22
8012779c:	2580012e 	bgeu	r4,r22,801277a4 <_fread_r+0x140>
801277a0:	2007883a 	mov	r3,r4
801277a4:	81400017 	ldw	r5,0(r16)
801277a8:	180d883a 	mov	r6,r3
801277ac:	9809883a 	mov	r4,r19
801277b0:	d8c00115 	stw	r3,4(sp)
801277b4:	01214640 	call	80121464 <memcpy>
801277b8:	d8c00117 	ldw	r3,4(sp)
801277bc:	84400017 	ldw	r17,0(r16)
801277c0:	80800117 	ldw	r2,4(r16)
801277c4:	81400c17 	ldw	r5,48(r16)
801277c8:	88e3883a 	add	r17,r17,r3
801277cc:	10c5c83a 	sub	r2,r2,r3
801277d0:	84400015 	stw	r17,0(r16)
801277d4:	80800115 	stw	r2,4(r16)
801277d8:	b0e5c83a 	sub	r18,r22,r3
801277dc:	28002b26 	beq	r5,zero,8012788c <_fread_r+0x228>
801277e0:	90002b26 	beq	r18,zero,80127890 <_fread_r+0x22c>
801277e4:	80801004 	addi	r2,r16,64
801277e8:	28800526 	beq	r5,r2,80127800 <_fread_r+0x19c>
801277ec:	a009883a 	mov	r4,r20
801277f0:	d8c00115 	stw	r3,4(sp)
801277f4:	0127a000 	call	80127a00 <_free_r>
801277f8:	d8c00117 	ldw	r3,4(sp)
801277fc:	84400017 	ldw	r17,0(r16)
80127800:	80000c15 	stw	zero,48(r16)
80127804:	80800517 	ldw	r2,20(r16)
80127808:	87000417 	ldw	fp,16(r16)
8012780c:	98e7883a 	add	r19,r19,r3
80127810:	d8800015 	stw	r2,0(sp)
80127814:	00000106 	br	8012781c <_fread_r+0x1b8>
80127818:	90001d26 	beq	r18,zero,80127890 <_fread_r+0x22c>
8012781c:	84c00415 	stw	r19,16(r16)
80127820:	84800515 	stw	r18,20(r16)
80127824:	84c00015 	stw	r19,0(r16)
80127828:	a009883a 	mov	r4,r20
8012782c:	800b883a 	mov	r5,r16
80127830:	012a7040 	call	8012a704 <__srefill_r>
80127834:	d9000017 	ldw	r4,0(sp)
80127838:	80c00117 	ldw	r3,4(r16)
8012783c:	87000415 	stw	fp,16(r16)
80127840:	81000515 	stw	r4,20(r16)
80127844:	84400015 	stw	r17,0(r16)
80127848:	80000115 	stw	zero,4(r16)
8012784c:	90e5c83a 	sub	r18,r18,r3
80127850:	98e7883a 	add	r19,r19,r3
80127854:	103ff026 	beq	r2,zero,80127818 <__reset+0xfa107818>
80127858:	b80b883a 	mov	r5,r23
8012785c:	b489c83a 	sub	r4,r22,r18
80127860:	01302680 	call	80130268 <__udivsi3>
80127864:	003fbe06 	br	80127760 <__reset+0xfa107760>
80127868:	80000115 	stw	zero,4(r16)
8012786c:	0009883a 	mov	r4,zero
80127870:	0023883a 	mov	r17,zero
80127874:	003f9e06 	br	801276f0 <__reset+0xfa1076f0>
80127878:	01276140 	call	80127614 <__sinit>
8012787c:	8080030b 	ldhu	r2,12(r16)
80127880:	10c8000c 	andi	r3,r2,8192
80127884:	183f971e 	bne	r3,zero,801276e4 <__reset+0xfa1076e4>
80127888:	003f9006 	br	801276cc <__reset+0xfa1076cc>
8012788c:	903fdd1e 	bne	r18,zero,80127804 <__reset+0xfa107804>
80127890:	a805883a 	mov	r2,r21
80127894:	003fb206 	br	80127760 <__reset+0xfa107760>

80127898 <fread>:
80127898:	defffe04 	addi	sp,sp,-8
8012789c:	00a00574 	movhi	r2,32789
801278a0:	de00012e 	bgeu	sp,et,801278a8 <fread+0x10>
801278a4:	003b68fa 	trap	3
801278a8:	10a88704 	addi	r2,r2,-24036
801278ac:	d9c00015 	stw	r7,0(sp)
801278b0:	300f883a 	mov	r7,r6
801278b4:	280d883a 	mov	r6,r5
801278b8:	200b883a 	mov	r5,r4
801278bc:	11000017 	ldw	r4,0(r2)
801278c0:	dfc00115 	stw	ra,4(sp)
801278c4:	01276640 	call	80127664 <_fread_r>
801278c8:	dfc00117 	ldw	ra,4(sp)
801278cc:	dec00204 	addi	sp,sp,8
801278d0:	f800283a 	ret

801278d4 <_malloc_trim_r>:
801278d4:	defffb04 	addi	sp,sp,-20
801278d8:	de00012e 	bgeu	sp,et,801278e0 <_malloc_trim_r+0xc>
801278dc:	003b68fa 	trap	3
801278e0:	dcc00315 	stw	r19,12(sp)
801278e4:	04e00574 	movhi	r19,32789
801278e8:	dc800215 	stw	r18,8(sp)
801278ec:	dc400115 	stw	r17,4(sp)
801278f0:	dc000015 	stw	r16,0(sp)
801278f4:	dfc00415 	stw	ra,16(sp)
801278f8:	2821883a 	mov	r16,r5
801278fc:	9ce26304 	addi	r19,r19,-30324
80127900:	2025883a 	mov	r18,r4
80127904:	01334b80 	call	801334b8 <__malloc_lock>
80127908:	98800217 	ldw	r2,8(r19)
8012790c:	14400117 	ldw	r17,4(r2)
80127910:	00bfff04 	movi	r2,-4
80127914:	88a2703a 	and	r17,r17,r2
80127918:	8c21c83a 	sub	r16,r17,r16
8012791c:	8403fbc4 	addi	r16,r16,4079
80127920:	8020d33a 	srli	r16,r16,12
80127924:	0083ffc4 	movi	r2,4095
80127928:	843fffc4 	addi	r16,r16,-1
8012792c:	8020933a 	slli	r16,r16,12
80127930:	1400060e 	bge	r2,r16,8012794c <_malloc_trim_r+0x78>
80127934:	000b883a 	mov	r5,zero
80127938:	9009883a 	mov	r4,r18
8012793c:	012a9540 	call	8012a954 <_sbrk_r>
80127940:	98c00217 	ldw	r3,8(r19)
80127944:	1c47883a 	add	r3,r3,r17
80127948:	10c00a26 	beq	r2,r3,80127974 <_malloc_trim_r+0xa0>
8012794c:	9009883a 	mov	r4,r18
80127950:	01335e00 	call	801335e0 <__malloc_unlock>
80127954:	0005883a 	mov	r2,zero
80127958:	dfc00417 	ldw	ra,16(sp)
8012795c:	dcc00317 	ldw	r19,12(sp)
80127960:	dc800217 	ldw	r18,8(sp)
80127964:	dc400117 	ldw	r17,4(sp)
80127968:	dc000017 	ldw	r16,0(sp)
8012796c:	dec00504 	addi	sp,sp,20
80127970:	f800283a 	ret
80127974:	040bc83a 	sub	r5,zero,r16
80127978:	9009883a 	mov	r4,r18
8012797c:	012a9540 	call	8012a954 <_sbrk_r>
80127980:	00ffffc4 	movi	r3,-1
80127984:	10c00d26 	beq	r2,r3,801279bc <_malloc_trim_r+0xe8>
80127988:	00e00574 	movhi	r3,32789
8012798c:	18e99304 	addi	r3,r3,-22964
80127990:	18800017 	ldw	r2,0(r3)
80127994:	99000217 	ldw	r4,8(r19)
80127998:	8c23c83a 	sub	r17,r17,r16
8012799c:	8c400054 	ori	r17,r17,1
801279a0:	1421c83a 	sub	r16,r2,r16
801279a4:	24400115 	stw	r17,4(r4)
801279a8:	9009883a 	mov	r4,r18
801279ac:	1c000015 	stw	r16,0(r3)
801279b0:	01335e00 	call	801335e0 <__malloc_unlock>
801279b4:	00800044 	movi	r2,1
801279b8:	003fe706 	br	80127958 <__reset+0xfa107958>
801279bc:	000b883a 	mov	r5,zero
801279c0:	9009883a 	mov	r4,r18
801279c4:	012a9540 	call	8012a954 <_sbrk_r>
801279c8:	99000217 	ldw	r4,8(r19)
801279cc:	014003c4 	movi	r5,15
801279d0:	1107c83a 	sub	r3,r2,r4
801279d4:	28ffdd0e 	bge	r5,r3,8012794c <__reset+0xfa10794c>
801279d8:	01600574 	movhi	r5,32789
801279dc:	29688904 	addi	r5,r5,-24028
801279e0:	29400017 	ldw	r5,0(r5)
801279e4:	18c00054 	ori	r3,r3,1
801279e8:	20c00115 	stw	r3,4(r4)
801279ec:	00e00574 	movhi	r3,32789
801279f0:	1145c83a 	sub	r2,r2,r5
801279f4:	18e99304 	addi	r3,r3,-22964
801279f8:	18800015 	stw	r2,0(r3)
801279fc:	003fd306 	br	8012794c <__reset+0xfa10794c>

80127a00 <_free_r>:
80127a00:	28004326 	beq	r5,zero,80127b10 <_free_r+0x110>
80127a04:	defffd04 	addi	sp,sp,-12
80127a08:	de00012e 	bgeu	sp,et,80127a10 <_free_r+0x10>
80127a0c:	003b68fa 	trap	3
80127a10:	dc400115 	stw	r17,4(sp)
80127a14:	dc000015 	stw	r16,0(sp)
80127a18:	2023883a 	mov	r17,r4
80127a1c:	2821883a 	mov	r16,r5
80127a20:	dfc00215 	stw	ra,8(sp)
80127a24:	01334b80 	call	801334b8 <__malloc_lock>
80127a28:	81ffff17 	ldw	r7,-4(r16)
80127a2c:	00bfff84 	movi	r2,-2
80127a30:	01200574 	movhi	r4,32789
80127a34:	81bffe04 	addi	r6,r16,-8
80127a38:	3884703a 	and	r2,r7,r2
80127a3c:	21226304 	addi	r4,r4,-30324
80127a40:	308b883a 	add	r5,r6,r2
80127a44:	2a400117 	ldw	r9,4(r5)
80127a48:	22000217 	ldw	r8,8(r4)
80127a4c:	00ffff04 	movi	r3,-4
80127a50:	48c6703a 	and	r3,r9,r3
80127a54:	2a005726 	beq	r5,r8,80127bb4 <_free_r+0x1b4>
80127a58:	28c00115 	stw	r3,4(r5)
80127a5c:	39c0004c 	andi	r7,r7,1
80127a60:	3800091e 	bne	r7,zero,80127a88 <_free_r+0x88>
80127a64:	823ffe17 	ldw	r8,-8(r16)
80127a68:	22400204 	addi	r9,r4,8
80127a6c:	320dc83a 	sub	r6,r6,r8
80127a70:	31c00217 	ldw	r7,8(r6)
80127a74:	1205883a 	add	r2,r2,r8
80127a78:	3a406526 	beq	r7,r9,80127c10 <_free_r+0x210>
80127a7c:	32000317 	ldw	r8,12(r6)
80127a80:	3a000315 	stw	r8,12(r7)
80127a84:	41c00215 	stw	r7,8(r8)
80127a88:	28cf883a 	add	r7,r5,r3
80127a8c:	39c00117 	ldw	r7,4(r7)
80127a90:	39c0004c 	andi	r7,r7,1
80127a94:	38003a26 	beq	r7,zero,80127b80 <_free_r+0x180>
80127a98:	10c00054 	ori	r3,r2,1
80127a9c:	30c00115 	stw	r3,4(r6)
80127aa0:	3087883a 	add	r3,r6,r2
80127aa4:	18800015 	stw	r2,0(r3)
80127aa8:	00c07fc4 	movi	r3,511
80127aac:	18801936 	bltu	r3,r2,80127b14 <_free_r+0x114>
80127ab0:	1004d0fa 	srli	r2,r2,3
80127ab4:	01c00044 	movi	r7,1
80127ab8:	21400117 	ldw	r5,4(r4)
80127abc:	10c00044 	addi	r3,r2,1
80127ac0:	18c7883a 	add	r3,r3,r3
80127ac4:	1005d0ba 	srai	r2,r2,2
80127ac8:	18c7883a 	add	r3,r3,r3
80127acc:	18c7883a 	add	r3,r3,r3
80127ad0:	1907883a 	add	r3,r3,r4
80127ad4:	3884983a 	sll	r2,r7,r2
80127ad8:	19c00017 	ldw	r7,0(r3)
80127adc:	1a3ffe04 	addi	r8,r3,-8
80127ae0:	1144b03a 	or	r2,r2,r5
80127ae4:	32000315 	stw	r8,12(r6)
80127ae8:	31c00215 	stw	r7,8(r6)
80127aec:	20800115 	stw	r2,4(r4)
80127af0:	19800015 	stw	r6,0(r3)
80127af4:	39800315 	stw	r6,12(r7)
80127af8:	8809883a 	mov	r4,r17
80127afc:	dfc00217 	ldw	ra,8(sp)
80127b00:	dc400117 	ldw	r17,4(sp)
80127b04:	dc000017 	ldw	r16,0(sp)
80127b08:	dec00304 	addi	sp,sp,12
80127b0c:	01335e01 	jmpi	801335e0 <__malloc_unlock>
80127b10:	f800283a 	ret
80127b14:	100ad27a 	srli	r5,r2,9
80127b18:	00c00104 	movi	r3,4
80127b1c:	19404a36 	bltu	r3,r5,80127c48 <_free_r+0x248>
80127b20:	100ad1ba 	srli	r5,r2,6
80127b24:	28c00e44 	addi	r3,r5,57
80127b28:	18c7883a 	add	r3,r3,r3
80127b2c:	29400e04 	addi	r5,r5,56
80127b30:	18c7883a 	add	r3,r3,r3
80127b34:	18c7883a 	add	r3,r3,r3
80127b38:	1909883a 	add	r4,r3,r4
80127b3c:	20c00017 	ldw	r3,0(r4)
80127b40:	01e00574 	movhi	r7,32789
80127b44:	213ffe04 	addi	r4,r4,-8
80127b48:	39e26304 	addi	r7,r7,-30324
80127b4c:	20c04426 	beq	r4,r3,80127c60 <_free_r+0x260>
80127b50:	01ffff04 	movi	r7,-4
80127b54:	19400117 	ldw	r5,4(r3)
80127b58:	29ca703a 	and	r5,r5,r7
80127b5c:	1140022e 	bgeu	r2,r5,80127b68 <_free_r+0x168>
80127b60:	18c00217 	ldw	r3,8(r3)
80127b64:	20fffb1e 	bne	r4,r3,80127b54 <__reset+0xfa107b54>
80127b68:	19000317 	ldw	r4,12(r3)
80127b6c:	31000315 	stw	r4,12(r6)
80127b70:	30c00215 	stw	r3,8(r6)
80127b74:	21800215 	stw	r6,8(r4)
80127b78:	19800315 	stw	r6,12(r3)
80127b7c:	003fde06 	br	80127af8 <__reset+0xfa107af8>
80127b80:	29c00217 	ldw	r7,8(r5)
80127b84:	10c5883a 	add	r2,r2,r3
80127b88:	00e00574 	movhi	r3,32789
80127b8c:	18e26504 	addi	r3,r3,-30316
80127b90:	38c03b26 	beq	r7,r3,80127c80 <_free_r+0x280>
80127b94:	2a000317 	ldw	r8,12(r5)
80127b98:	11400054 	ori	r5,r2,1
80127b9c:	3087883a 	add	r3,r6,r2
80127ba0:	3a000315 	stw	r8,12(r7)
80127ba4:	41c00215 	stw	r7,8(r8)
80127ba8:	31400115 	stw	r5,4(r6)
80127bac:	18800015 	stw	r2,0(r3)
80127bb0:	003fbd06 	br	80127aa8 <__reset+0xfa107aa8>
80127bb4:	39c0004c 	andi	r7,r7,1
80127bb8:	10c5883a 	add	r2,r2,r3
80127bbc:	3800071e 	bne	r7,zero,80127bdc <_free_r+0x1dc>
80127bc0:	81fffe17 	ldw	r7,-8(r16)
80127bc4:	31cdc83a 	sub	r6,r6,r7
80127bc8:	30c00317 	ldw	r3,12(r6)
80127bcc:	31400217 	ldw	r5,8(r6)
80127bd0:	11c5883a 	add	r2,r2,r7
80127bd4:	28c00315 	stw	r3,12(r5)
80127bd8:	19400215 	stw	r5,8(r3)
80127bdc:	10c00054 	ori	r3,r2,1
80127be0:	30c00115 	stw	r3,4(r6)
80127be4:	00e00574 	movhi	r3,32789
80127be8:	18e88a04 	addi	r3,r3,-24024
80127bec:	18c00017 	ldw	r3,0(r3)
80127bf0:	21800215 	stw	r6,8(r4)
80127bf4:	10ffc036 	bltu	r2,r3,80127af8 <__reset+0xfa107af8>
80127bf8:	00a00574 	movhi	r2,32789
80127bfc:	10a90804 	addi	r2,r2,-23520
80127c00:	11400017 	ldw	r5,0(r2)
80127c04:	8809883a 	mov	r4,r17
80127c08:	01278d40 	call	801278d4 <_malloc_trim_r>
80127c0c:	003fba06 	br	80127af8 <__reset+0xfa107af8>
80127c10:	28c9883a 	add	r4,r5,r3
80127c14:	21000117 	ldw	r4,4(r4)
80127c18:	2100004c 	andi	r4,r4,1
80127c1c:	2000391e 	bne	r4,zero,80127d04 <_free_r+0x304>
80127c20:	29c00217 	ldw	r7,8(r5)
80127c24:	29000317 	ldw	r4,12(r5)
80127c28:	1885883a 	add	r2,r3,r2
80127c2c:	10c00054 	ori	r3,r2,1
80127c30:	39000315 	stw	r4,12(r7)
80127c34:	21c00215 	stw	r7,8(r4)
80127c38:	30c00115 	stw	r3,4(r6)
80127c3c:	308d883a 	add	r6,r6,r2
80127c40:	30800015 	stw	r2,0(r6)
80127c44:	003fac06 	br	80127af8 <__reset+0xfa107af8>
80127c48:	00c00504 	movi	r3,20
80127c4c:	19401536 	bltu	r3,r5,80127ca4 <_free_r+0x2a4>
80127c50:	28c01704 	addi	r3,r5,92
80127c54:	18c7883a 	add	r3,r3,r3
80127c58:	294016c4 	addi	r5,r5,91
80127c5c:	003fb406 	br	80127b30 <__reset+0xfa107b30>
80127c60:	280bd0ba 	srai	r5,r5,2
80127c64:	00c00044 	movi	r3,1
80127c68:	38800117 	ldw	r2,4(r7)
80127c6c:	194a983a 	sll	r5,r3,r5
80127c70:	2007883a 	mov	r3,r4
80127c74:	2884b03a 	or	r2,r5,r2
80127c78:	38800115 	stw	r2,4(r7)
80127c7c:	003fbb06 	br	80127b6c <__reset+0xfa107b6c>
80127c80:	21800515 	stw	r6,20(r4)
80127c84:	21800415 	stw	r6,16(r4)
80127c88:	10c00054 	ori	r3,r2,1
80127c8c:	31c00315 	stw	r7,12(r6)
80127c90:	31c00215 	stw	r7,8(r6)
80127c94:	30c00115 	stw	r3,4(r6)
80127c98:	308d883a 	add	r6,r6,r2
80127c9c:	30800015 	stw	r2,0(r6)
80127ca0:	003f9506 	br	80127af8 <__reset+0xfa107af8>
80127ca4:	00c01504 	movi	r3,84
80127ca8:	19400536 	bltu	r3,r5,80127cc0 <_free_r+0x2c0>
80127cac:	100ad33a 	srli	r5,r2,12
80127cb0:	28c01bc4 	addi	r3,r5,111
80127cb4:	18c7883a 	add	r3,r3,r3
80127cb8:	29401b84 	addi	r5,r5,110
80127cbc:	003f9c06 	br	80127b30 <__reset+0xfa107b30>
80127cc0:	00c05504 	movi	r3,340
80127cc4:	19400536 	bltu	r3,r5,80127cdc <_free_r+0x2dc>
80127cc8:	100ad3fa 	srli	r5,r2,15
80127ccc:	28c01e04 	addi	r3,r5,120
80127cd0:	18c7883a 	add	r3,r3,r3
80127cd4:	29401dc4 	addi	r5,r5,119
80127cd8:	003f9506 	br	80127b30 <__reset+0xfa107b30>
80127cdc:	00c15504 	movi	r3,1364
80127ce0:	19400536 	bltu	r3,r5,80127cf8 <_free_r+0x2f8>
80127ce4:	100ad4ba 	srli	r5,r2,18
80127ce8:	28c01f44 	addi	r3,r5,125
80127cec:	18c7883a 	add	r3,r3,r3
80127cf0:	29401f04 	addi	r5,r5,124
80127cf4:	003f8e06 	br	80127b30 <__reset+0xfa107b30>
80127cf8:	00c03f84 	movi	r3,254
80127cfc:	01401f84 	movi	r5,126
80127d00:	003f8b06 	br	80127b30 <__reset+0xfa107b30>
80127d04:	10c00054 	ori	r3,r2,1
80127d08:	30c00115 	stw	r3,4(r6)
80127d0c:	308d883a 	add	r6,r6,r2
80127d10:	30800015 	stw	r2,0(r6)
80127d14:	003f7806 	br	80127af8 <__reset+0xfa107af8>

80127d18 <__sfvwrite_r>:
80127d18:	30800217 	ldw	r2,8(r6)
80127d1c:	10006926 	beq	r2,zero,80127ec4 <__sfvwrite_r+0x1ac>
80127d20:	defff404 	addi	sp,sp,-48
80127d24:	de00012e 	bgeu	sp,et,80127d2c <__sfvwrite_r+0x14>
80127d28:	003b68fa 	trap	3
80127d2c:	28c0030b 	ldhu	r3,12(r5)
80127d30:	dd400715 	stw	r21,28(sp)
80127d34:	dd000615 	stw	r20,24(sp)
80127d38:	dc000215 	stw	r16,8(sp)
80127d3c:	dfc00b15 	stw	ra,44(sp)
80127d40:	df000a15 	stw	fp,40(sp)
80127d44:	ddc00915 	stw	r23,36(sp)
80127d48:	dd800815 	stw	r22,32(sp)
80127d4c:	dcc00515 	stw	r19,20(sp)
80127d50:	dc800415 	stw	r18,16(sp)
80127d54:	dc400315 	stw	r17,12(sp)
80127d58:	1880020c 	andi	r2,r3,8
80127d5c:	2821883a 	mov	r16,r5
80127d60:	202b883a 	mov	r21,r4
80127d64:	3029883a 	mov	r20,r6
80127d68:	10002726 	beq	r2,zero,80127e08 <__sfvwrite_r+0xf0>
80127d6c:	28800417 	ldw	r2,16(r5)
80127d70:	10002526 	beq	r2,zero,80127e08 <__sfvwrite_r+0xf0>
80127d74:	1880008c 	andi	r2,r3,2
80127d78:	a4400017 	ldw	r17,0(r20)
80127d7c:	10002a26 	beq	r2,zero,80127e28 <__sfvwrite_r+0x110>
80127d80:	05a00034 	movhi	r22,32768
80127d84:	0027883a 	mov	r19,zero
80127d88:	0025883a 	mov	r18,zero
80127d8c:	b5bf0004 	addi	r22,r22,-1024
80127d90:	980d883a 	mov	r6,r19
80127d94:	a809883a 	mov	r4,r21
80127d98:	90004626 	beq	r18,zero,80127eb4 <__sfvwrite_r+0x19c>
80127d9c:	900f883a 	mov	r7,r18
80127da0:	b480022e 	bgeu	r22,r18,80127dac <__sfvwrite_r+0x94>
80127da4:	01e00034 	movhi	r7,32768
80127da8:	39ff0004 	addi	r7,r7,-1024
80127dac:	80800917 	ldw	r2,36(r16)
80127db0:	81400717 	ldw	r5,28(r16)
80127db4:	103ee83a 	callr	r2
80127db8:	0080570e 	bge	zero,r2,80127f18 <__sfvwrite_r+0x200>
80127dbc:	a0c00217 	ldw	r3,8(r20)
80127dc0:	98a7883a 	add	r19,r19,r2
80127dc4:	90a5c83a 	sub	r18,r18,r2
80127dc8:	1885c83a 	sub	r2,r3,r2
80127dcc:	a0800215 	stw	r2,8(r20)
80127dd0:	103fef1e 	bne	r2,zero,80127d90 <__reset+0xfa107d90>
80127dd4:	0005883a 	mov	r2,zero
80127dd8:	dfc00b17 	ldw	ra,44(sp)
80127ddc:	df000a17 	ldw	fp,40(sp)
80127de0:	ddc00917 	ldw	r23,36(sp)
80127de4:	dd800817 	ldw	r22,32(sp)
80127de8:	dd400717 	ldw	r21,28(sp)
80127dec:	dd000617 	ldw	r20,24(sp)
80127df0:	dcc00517 	ldw	r19,20(sp)
80127df4:	dc800417 	ldw	r18,16(sp)
80127df8:	dc400317 	ldw	r17,12(sp)
80127dfc:	dc000217 	ldw	r16,8(sp)
80127e00:	dec00c04 	addi	sp,sp,48
80127e04:	f800283a 	ret
80127e08:	800b883a 	mov	r5,r16
80127e0c:	a809883a 	mov	r4,r21
80127e10:	012e0a80 	call	8012e0a8 <__swsetup_r>
80127e14:	1000eb1e 	bne	r2,zero,801281c4 <__sfvwrite_r+0x4ac>
80127e18:	80c0030b 	ldhu	r3,12(r16)
80127e1c:	a4400017 	ldw	r17,0(r20)
80127e20:	1880008c 	andi	r2,r3,2
80127e24:	103fd61e 	bne	r2,zero,80127d80 <__reset+0xfa107d80>
80127e28:	1880004c 	andi	r2,r3,1
80127e2c:	10003f1e 	bne	r2,zero,80127f2c <__sfvwrite_r+0x214>
80127e30:	0039883a 	mov	fp,zero
80127e34:	0025883a 	mov	r18,zero
80127e38:	90001a26 	beq	r18,zero,80127ea4 <__sfvwrite_r+0x18c>
80127e3c:	1880800c 	andi	r2,r3,512
80127e40:	84c00217 	ldw	r19,8(r16)
80127e44:	10002126 	beq	r2,zero,80127ecc <__sfvwrite_r+0x1b4>
80127e48:	982f883a 	mov	r23,r19
80127e4c:	94c09336 	bltu	r18,r19,8012809c <__sfvwrite_r+0x384>
80127e50:	1881200c 	andi	r2,r3,1152
80127e54:	10009e1e 	bne	r2,zero,801280d0 <__sfvwrite_r+0x3b8>
80127e58:	81000017 	ldw	r4,0(r16)
80127e5c:	b80d883a 	mov	r6,r23
80127e60:	e00b883a 	mov	r5,fp
80127e64:	0128fc40 	call	80128fc4 <memmove>
80127e68:	80c00217 	ldw	r3,8(r16)
80127e6c:	81000017 	ldw	r4,0(r16)
80127e70:	9005883a 	mov	r2,r18
80127e74:	1ce7c83a 	sub	r19,r3,r19
80127e78:	25cf883a 	add	r7,r4,r23
80127e7c:	84c00215 	stw	r19,8(r16)
80127e80:	81c00015 	stw	r7,0(r16)
80127e84:	a0c00217 	ldw	r3,8(r20)
80127e88:	e0b9883a 	add	fp,fp,r2
80127e8c:	90a5c83a 	sub	r18,r18,r2
80127e90:	18a7c83a 	sub	r19,r3,r2
80127e94:	a4c00215 	stw	r19,8(r20)
80127e98:	983fce26 	beq	r19,zero,80127dd4 <__reset+0xfa107dd4>
80127e9c:	80c0030b 	ldhu	r3,12(r16)
80127ea0:	903fe61e 	bne	r18,zero,80127e3c <__reset+0xfa107e3c>
80127ea4:	8f000017 	ldw	fp,0(r17)
80127ea8:	8c800117 	ldw	r18,4(r17)
80127eac:	8c400204 	addi	r17,r17,8
80127eb0:	003fe106 	br	80127e38 <__reset+0xfa107e38>
80127eb4:	8cc00017 	ldw	r19,0(r17)
80127eb8:	8c800117 	ldw	r18,4(r17)
80127ebc:	8c400204 	addi	r17,r17,8
80127ec0:	003fb306 	br	80127d90 <__reset+0xfa107d90>
80127ec4:	0005883a 	mov	r2,zero
80127ec8:	f800283a 	ret
80127ecc:	81000017 	ldw	r4,0(r16)
80127ed0:	80800417 	ldw	r2,16(r16)
80127ed4:	11005736 	bltu	r2,r4,80128034 <__sfvwrite_r+0x31c>
80127ed8:	85c00517 	ldw	r23,20(r16)
80127edc:	95c05536 	bltu	r18,r23,80128034 <__sfvwrite_r+0x31c>
80127ee0:	00a00034 	movhi	r2,32768
80127ee4:	10bfffc4 	addi	r2,r2,-1
80127ee8:	9009883a 	mov	r4,r18
80127eec:	1480012e 	bgeu	r2,r18,80127ef4 <__sfvwrite_r+0x1dc>
80127ef0:	1009883a 	mov	r4,r2
80127ef4:	b80b883a 	mov	r5,r23
80127ef8:	01301700 	call	80130170 <__divsi3>
80127efc:	15cf383a 	mul	r7,r2,r23
80127f00:	81400717 	ldw	r5,28(r16)
80127f04:	80800917 	ldw	r2,36(r16)
80127f08:	e00d883a 	mov	r6,fp
80127f0c:	a809883a 	mov	r4,r21
80127f10:	103ee83a 	callr	r2
80127f14:	00bfdb16 	blt	zero,r2,80127e84 <__reset+0xfa107e84>
80127f18:	8080030b 	ldhu	r2,12(r16)
80127f1c:	10801014 	ori	r2,r2,64
80127f20:	8080030d 	sth	r2,12(r16)
80127f24:	00bfffc4 	movi	r2,-1
80127f28:	003fab06 	br	80127dd8 <__reset+0xfa107dd8>
80127f2c:	0027883a 	mov	r19,zero
80127f30:	0011883a 	mov	r8,zero
80127f34:	0039883a 	mov	fp,zero
80127f38:	0025883a 	mov	r18,zero
80127f3c:	90001f26 	beq	r18,zero,80127fbc <__sfvwrite_r+0x2a4>
80127f40:	40005a26 	beq	r8,zero,801280ac <__sfvwrite_r+0x394>
80127f44:	982d883a 	mov	r22,r19
80127f48:	94c0012e 	bgeu	r18,r19,80127f50 <__sfvwrite_r+0x238>
80127f4c:	902d883a 	mov	r22,r18
80127f50:	81000017 	ldw	r4,0(r16)
80127f54:	80800417 	ldw	r2,16(r16)
80127f58:	b02f883a 	mov	r23,r22
80127f5c:	81c00517 	ldw	r7,20(r16)
80127f60:	1100032e 	bgeu	r2,r4,80127f70 <__sfvwrite_r+0x258>
80127f64:	80c00217 	ldw	r3,8(r16)
80127f68:	38c7883a 	add	r3,r7,r3
80127f6c:	1d801816 	blt	r3,r22,80127fd0 <__sfvwrite_r+0x2b8>
80127f70:	b1c03e16 	blt	r22,r7,8012806c <__sfvwrite_r+0x354>
80127f74:	80800917 	ldw	r2,36(r16)
80127f78:	81400717 	ldw	r5,28(r16)
80127f7c:	e00d883a 	mov	r6,fp
80127f80:	da000115 	stw	r8,4(sp)
80127f84:	a809883a 	mov	r4,r21
80127f88:	103ee83a 	callr	r2
80127f8c:	102f883a 	mov	r23,r2
80127f90:	da000117 	ldw	r8,4(sp)
80127f94:	00bfe00e 	bge	zero,r2,80127f18 <__reset+0xfa107f18>
80127f98:	9de7c83a 	sub	r19,r19,r23
80127f9c:	98001f26 	beq	r19,zero,8012801c <__sfvwrite_r+0x304>
80127fa0:	a0800217 	ldw	r2,8(r20)
80127fa4:	e5f9883a 	add	fp,fp,r23
80127fa8:	95e5c83a 	sub	r18,r18,r23
80127fac:	15efc83a 	sub	r23,r2,r23
80127fb0:	a5c00215 	stw	r23,8(r20)
80127fb4:	b83f8726 	beq	r23,zero,80127dd4 <__reset+0xfa107dd4>
80127fb8:	903fe11e 	bne	r18,zero,80127f40 <__reset+0xfa107f40>
80127fbc:	8f000017 	ldw	fp,0(r17)
80127fc0:	8c800117 	ldw	r18,4(r17)
80127fc4:	0011883a 	mov	r8,zero
80127fc8:	8c400204 	addi	r17,r17,8
80127fcc:	003fdb06 	br	80127f3c <__reset+0xfa107f3c>
80127fd0:	180d883a 	mov	r6,r3
80127fd4:	e00b883a 	mov	r5,fp
80127fd8:	da000115 	stw	r8,4(sp)
80127fdc:	d8c00015 	stw	r3,0(sp)
80127fe0:	0128fc40 	call	80128fc4 <memmove>
80127fe4:	d8c00017 	ldw	r3,0(sp)
80127fe8:	80800017 	ldw	r2,0(r16)
80127fec:	800b883a 	mov	r5,r16
80127ff0:	a809883a 	mov	r4,r21
80127ff4:	10c5883a 	add	r2,r2,r3
80127ff8:	80800015 	stw	r2,0(r16)
80127ffc:	d8c00015 	stw	r3,0(sp)
80128000:	012e65c0 	call	8012e65c <_fflush_r>
80128004:	d8c00017 	ldw	r3,0(sp)
80128008:	da000117 	ldw	r8,4(sp)
8012800c:	103fc21e 	bne	r2,zero,80127f18 <__reset+0xfa107f18>
80128010:	182f883a 	mov	r23,r3
80128014:	9de7c83a 	sub	r19,r19,r23
80128018:	983fe11e 	bne	r19,zero,80127fa0 <__reset+0xfa107fa0>
8012801c:	800b883a 	mov	r5,r16
80128020:	a809883a 	mov	r4,r21
80128024:	012e65c0 	call	8012e65c <_fflush_r>
80128028:	103fbb1e 	bne	r2,zero,80127f18 <__reset+0xfa107f18>
8012802c:	0011883a 	mov	r8,zero
80128030:	003fdb06 	br	80127fa0 <__reset+0xfa107fa0>
80128034:	94c0012e 	bgeu	r18,r19,8012803c <__sfvwrite_r+0x324>
80128038:	9027883a 	mov	r19,r18
8012803c:	980d883a 	mov	r6,r19
80128040:	e00b883a 	mov	r5,fp
80128044:	0128fc40 	call	80128fc4 <memmove>
80128048:	80800217 	ldw	r2,8(r16)
8012804c:	80c00017 	ldw	r3,0(r16)
80128050:	14c5c83a 	sub	r2,r2,r19
80128054:	1cc7883a 	add	r3,r3,r19
80128058:	80800215 	stw	r2,8(r16)
8012805c:	80c00015 	stw	r3,0(r16)
80128060:	10004326 	beq	r2,zero,80128170 <__sfvwrite_r+0x458>
80128064:	9805883a 	mov	r2,r19
80128068:	003f8606 	br	80127e84 <__reset+0xfa107e84>
8012806c:	b00d883a 	mov	r6,r22
80128070:	e00b883a 	mov	r5,fp
80128074:	da000115 	stw	r8,4(sp)
80128078:	0128fc40 	call	80128fc4 <memmove>
8012807c:	80800217 	ldw	r2,8(r16)
80128080:	80c00017 	ldw	r3,0(r16)
80128084:	da000117 	ldw	r8,4(sp)
80128088:	1585c83a 	sub	r2,r2,r22
8012808c:	1dad883a 	add	r22,r3,r22
80128090:	80800215 	stw	r2,8(r16)
80128094:	85800015 	stw	r22,0(r16)
80128098:	003fbf06 	br	80127f98 <__reset+0xfa107f98>
8012809c:	81000017 	ldw	r4,0(r16)
801280a0:	9027883a 	mov	r19,r18
801280a4:	902f883a 	mov	r23,r18
801280a8:	003f6c06 	br	80127e5c <__reset+0xfa107e5c>
801280ac:	900d883a 	mov	r6,r18
801280b0:	01400284 	movi	r5,10
801280b4:	e009883a 	mov	r4,fp
801280b8:	0128ee00 	call	80128ee0 <memchr>
801280bc:	10003e26 	beq	r2,zero,801281b8 <__sfvwrite_r+0x4a0>
801280c0:	10800044 	addi	r2,r2,1
801280c4:	1727c83a 	sub	r19,r2,fp
801280c8:	02000044 	movi	r8,1
801280cc:	003f9d06 	br	80127f44 <__reset+0xfa107f44>
801280d0:	80800517 	ldw	r2,20(r16)
801280d4:	81400417 	ldw	r5,16(r16)
801280d8:	81c00017 	ldw	r7,0(r16)
801280dc:	10a7883a 	add	r19,r2,r2
801280e0:	9885883a 	add	r2,r19,r2
801280e4:	1026d7fa 	srli	r19,r2,31
801280e8:	396dc83a 	sub	r22,r7,r5
801280ec:	b1000044 	addi	r4,r22,1
801280f0:	9885883a 	add	r2,r19,r2
801280f4:	1027d07a 	srai	r19,r2,1
801280f8:	2485883a 	add	r2,r4,r18
801280fc:	980d883a 	mov	r6,r19
80128100:	9880022e 	bgeu	r19,r2,8012810c <__sfvwrite_r+0x3f4>
80128104:	1027883a 	mov	r19,r2
80128108:	100d883a 	mov	r6,r2
8012810c:	18c1000c 	andi	r3,r3,1024
80128110:	18001c26 	beq	r3,zero,80128184 <__sfvwrite_r+0x46c>
80128114:	300b883a 	mov	r5,r6
80128118:	a809883a 	mov	r4,r21
8012811c:	01284880 	call	80128488 <_malloc_r>
80128120:	102f883a 	mov	r23,r2
80128124:	10002926 	beq	r2,zero,801281cc <__sfvwrite_r+0x4b4>
80128128:	81400417 	ldw	r5,16(r16)
8012812c:	b00d883a 	mov	r6,r22
80128130:	1009883a 	mov	r4,r2
80128134:	01214640 	call	80121464 <memcpy>
80128138:	8080030b 	ldhu	r2,12(r16)
8012813c:	00fedfc4 	movi	r3,-1153
80128140:	10c4703a 	and	r2,r2,r3
80128144:	10802014 	ori	r2,r2,128
80128148:	8080030d 	sth	r2,12(r16)
8012814c:	bd89883a 	add	r4,r23,r22
80128150:	9d8fc83a 	sub	r7,r19,r22
80128154:	85c00415 	stw	r23,16(r16)
80128158:	84c00515 	stw	r19,20(r16)
8012815c:	81000015 	stw	r4,0(r16)
80128160:	9027883a 	mov	r19,r18
80128164:	81c00215 	stw	r7,8(r16)
80128168:	902f883a 	mov	r23,r18
8012816c:	003f3b06 	br	80127e5c <__reset+0xfa107e5c>
80128170:	800b883a 	mov	r5,r16
80128174:	a809883a 	mov	r4,r21
80128178:	012e65c0 	call	8012e65c <_fflush_r>
8012817c:	103fb926 	beq	r2,zero,80128064 <__reset+0xfa108064>
80128180:	003f6506 	br	80127f18 <__reset+0xfa107f18>
80128184:	a809883a 	mov	r4,r21
80128188:	012a17c0 	call	8012a17c <_realloc_r>
8012818c:	102f883a 	mov	r23,r2
80128190:	103fee1e 	bne	r2,zero,8012814c <__reset+0xfa10814c>
80128194:	81400417 	ldw	r5,16(r16)
80128198:	a809883a 	mov	r4,r21
8012819c:	0127a000 	call	80127a00 <_free_r>
801281a0:	8080030b 	ldhu	r2,12(r16)
801281a4:	00ffdfc4 	movi	r3,-129
801281a8:	1884703a 	and	r2,r3,r2
801281ac:	00c00304 	movi	r3,12
801281b0:	a8c00015 	stw	r3,0(r21)
801281b4:	003f5906 	br	80127f1c <__reset+0xfa107f1c>
801281b8:	94c00044 	addi	r19,r18,1
801281bc:	02000044 	movi	r8,1
801281c0:	003f6006 	br	80127f44 <__reset+0xfa107f44>
801281c4:	00bfffc4 	movi	r2,-1
801281c8:	003f0306 	br	80127dd8 <__reset+0xfa107dd8>
801281cc:	00800304 	movi	r2,12
801281d0:	a8800015 	stw	r2,0(r21)
801281d4:	8080030b 	ldhu	r2,12(r16)
801281d8:	003f5006 	br	80127f1c <__reset+0xfa107f1c>

801281dc <_fwalk>:
801281dc:	defff704 	addi	sp,sp,-36
801281e0:	de00012e 	bgeu	sp,et,801281e8 <_fwalk+0xc>
801281e4:	003b68fa 	trap	3
801281e8:	dd000415 	stw	r20,16(sp)
801281ec:	dfc00815 	stw	ra,32(sp)
801281f0:	ddc00715 	stw	r23,28(sp)
801281f4:	dd800615 	stw	r22,24(sp)
801281f8:	dd400515 	stw	r21,20(sp)
801281fc:	dcc00315 	stw	r19,12(sp)
80128200:	dc800215 	stw	r18,8(sp)
80128204:	dc400115 	stw	r17,4(sp)
80128208:	dc000015 	stw	r16,0(sp)
8012820c:	2500b804 	addi	r20,r4,736
80128210:	a0002326 	beq	r20,zero,801282a0 <_fwalk+0xc4>
80128214:	282b883a 	mov	r21,r5
80128218:	002f883a 	mov	r23,zero
8012821c:	05800044 	movi	r22,1
80128220:	04ffffc4 	movi	r19,-1
80128224:	a4400117 	ldw	r17,4(r20)
80128228:	a4800217 	ldw	r18,8(r20)
8012822c:	8c7fffc4 	addi	r17,r17,-1
80128230:	88000d16 	blt	r17,zero,80128268 <_fwalk+0x8c>
80128234:	94000304 	addi	r16,r18,12
80128238:	94800384 	addi	r18,r18,14
8012823c:	8080000b 	ldhu	r2,0(r16)
80128240:	8c7fffc4 	addi	r17,r17,-1
80128244:	813ffd04 	addi	r4,r16,-12
80128248:	b080042e 	bgeu	r22,r2,8012825c <_fwalk+0x80>
8012824c:	9080000f 	ldh	r2,0(r18)
80128250:	14c00226 	beq	r2,r19,8012825c <_fwalk+0x80>
80128254:	a83ee83a 	callr	r21
80128258:	b8aeb03a 	or	r23,r23,r2
8012825c:	84001a04 	addi	r16,r16,104
80128260:	94801a04 	addi	r18,r18,104
80128264:	8cfff51e 	bne	r17,r19,8012823c <__reset+0xfa10823c>
80128268:	a5000017 	ldw	r20,0(r20)
8012826c:	a03fed1e 	bne	r20,zero,80128224 <__reset+0xfa108224>
80128270:	b805883a 	mov	r2,r23
80128274:	dfc00817 	ldw	ra,32(sp)
80128278:	ddc00717 	ldw	r23,28(sp)
8012827c:	dd800617 	ldw	r22,24(sp)
80128280:	dd400517 	ldw	r21,20(sp)
80128284:	dd000417 	ldw	r20,16(sp)
80128288:	dcc00317 	ldw	r19,12(sp)
8012828c:	dc800217 	ldw	r18,8(sp)
80128290:	dc400117 	ldw	r17,4(sp)
80128294:	dc000017 	ldw	r16,0(sp)
80128298:	dec00904 	addi	sp,sp,36
8012829c:	f800283a 	ret
801282a0:	002f883a 	mov	r23,zero
801282a4:	003ff206 	br	80128270 <__reset+0xfa108270>

801282a8 <_fwalk_reent>:
801282a8:	defff704 	addi	sp,sp,-36
801282ac:	de00012e 	bgeu	sp,et,801282b4 <_fwalk_reent+0xc>
801282b0:	003b68fa 	trap	3
801282b4:	dd000415 	stw	r20,16(sp)
801282b8:	dfc00815 	stw	ra,32(sp)
801282bc:	ddc00715 	stw	r23,28(sp)
801282c0:	dd800615 	stw	r22,24(sp)
801282c4:	dd400515 	stw	r21,20(sp)
801282c8:	dcc00315 	stw	r19,12(sp)
801282cc:	dc800215 	stw	r18,8(sp)
801282d0:	dc400115 	stw	r17,4(sp)
801282d4:	dc000015 	stw	r16,0(sp)
801282d8:	2500b804 	addi	r20,r4,736
801282dc:	a0002326 	beq	r20,zero,8012836c <_fwalk_reent+0xc4>
801282e0:	282b883a 	mov	r21,r5
801282e4:	2027883a 	mov	r19,r4
801282e8:	002f883a 	mov	r23,zero
801282ec:	05800044 	movi	r22,1
801282f0:	04bfffc4 	movi	r18,-1
801282f4:	a4400117 	ldw	r17,4(r20)
801282f8:	a4000217 	ldw	r16,8(r20)
801282fc:	8c7fffc4 	addi	r17,r17,-1
80128300:	88000c16 	blt	r17,zero,80128334 <_fwalk_reent+0x8c>
80128304:	84000304 	addi	r16,r16,12
80128308:	8080000b 	ldhu	r2,0(r16)
8012830c:	8c7fffc4 	addi	r17,r17,-1
80128310:	817ffd04 	addi	r5,r16,-12
80128314:	b080052e 	bgeu	r22,r2,8012832c <_fwalk_reent+0x84>
80128318:	8080008f 	ldh	r2,2(r16)
8012831c:	9809883a 	mov	r4,r19
80128320:	14800226 	beq	r2,r18,8012832c <_fwalk_reent+0x84>
80128324:	a83ee83a 	callr	r21
80128328:	b8aeb03a 	or	r23,r23,r2
8012832c:	84001a04 	addi	r16,r16,104
80128330:	8cbff51e 	bne	r17,r18,80128308 <__reset+0xfa108308>
80128334:	a5000017 	ldw	r20,0(r20)
80128338:	a03fee1e 	bne	r20,zero,801282f4 <__reset+0xfa1082f4>
8012833c:	b805883a 	mov	r2,r23
80128340:	dfc00817 	ldw	ra,32(sp)
80128344:	ddc00717 	ldw	r23,28(sp)
80128348:	dd800617 	ldw	r22,24(sp)
8012834c:	dd400517 	ldw	r21,20(sp)
80128350:	dd000417 	ldw	r20,16(sp)
80128354:	dcc00317 	ldw	r19,12(sp)
80128358:	dc800217 	ldw	r18,8(sp)
8012835c:	dc400117 	ldw	r17,4(sp)
80128360:	dc000017 	ldw	r16,0(sp)
80128364:	dec00904 	addi	sp,sp,36
80128368:	f800283a 	ret
8012836c:	002f883a 	mov	r23,zero
80128370:	003ff206 	br	8012833c <__reset+0xfa10833c>

80128374 <iswspace>:
80128374:	00803fc4 	movi	r2,255
80128378:	11000836 	bltu	r2,r4,8012839c <iswspace+0x28>
8012837c:	00a00574 	movhi	r2,32789
80128380:	10a88504 	addi	r2,r2,-24044
80128384:	10800017 	ldw	r2,0(r2)
80128388:	1109883a 	add	r4,r2,r4
8012838c:	20800043 	ldbu	r2,1(r4)
80128390:	1080020c 	andi	r2,r2,8
80128394:	10803fcc 	andi	r2,r2,255
80128398:	f800283a 	ret
8012839c:	0005883a 	mov	r2,zero
801283a0:	f800283a 	ret

801283a4 <_setlocale_r>:
801283a4:	30001d26 	beq	r6,zero,8012841c <_setlocale_r+0x78>
801283a8:	01600534 	movhi	r5,32788
801283ac:	defffe04 	addi	sp,sp,-8
801283b0:	295ee804 	addi	r5,r5,31648
801283b4:	3009883a 	mov	r4,r6
801283b8:	de00012e 	bgeu	sp,et,801283c0 <_setlocale_r+0x1c>
801283bc:	003b68fa 	trap	3
801283c0:	dc000015 	stw	r16,0(sp)
801283c4:	dfc00115 	stw	ra,4(sp)
801283c8:	3021883a 	mov	r16,r6
801283cc:	012abdc0 	call	8012abdc <strcmp>
801283d0:	1000061e 	bne	r2,zero,801283ec <_setlocale_r+0x48>
801283d4:	00a00534 	movhi	r2,32788
801283d8:	109ee704 	addi	r2,r2,31644
801283dc:	dfc00117 	ldw	ra,4(sp)
801283e0:	dc000017 	ldw	r16,0(sp)
801283e4:	dec00204 	addi	sp,sp,8
801283e8:	f800283a 	ret
801283ec:	01600534 	movhi	r5,32788
801283f0:	295ee704 	addi	r5,r5,31644
801283f4:	8009883a 	mov	r4,r16
801283f8:	012abdc0 	call	8012abdc <strcmp>
801283fc:	103ff526 	beq	r2,zero,801283d4 <__reset+0xfa1083d4>
80128400:	01600534 	movhi	r5,32788
80128404:	295ec804 	addi	r5,r5,31520
80128408:	8009883a 	mov	r4,r16
8012840c:	012abdc0 	call	8012abdc <strcmp>
80128410:	103ff026 	beq	r2,zero,801283d4 <__reset+0xfa1083d4>
80128414:	0005883a 	mov	r2,zero
80128418:	003ff006 	br	801283dc <__reset+0xfa1083dc>
8012841c:	00a00534 	movhi	r2,32788
80128420:	109ee704 	addi	r2,r2,31644
80128424:	f800283a 	ret

80128428 <__locale_charset>:
80128428:	00a00574 	movhi	r2,32789
8012842c:	10a24d04 	addi	r2,r2,-30412
80128430:	f800283a 	ret

80128434 <__locale_mb_cur_max>:
80128434:	00a00574 	movhi	r2,32789
80128438:	10a88804 	addi	r2,r2,-24032
8012843c:	10800017 	ldw	r2,0(r2)
80128440:	f800283a 	ret

80128444 <__locale_msgcharset>:
80128444:	00a00574 	movhi	r2,32789
80128448:	10a24504 	addi	r2,r2,-30444
8012844c:	f800283a 	ret

80128450 <__locale_cjk_lang>:
80128450:	0005883a 	mov	r2,zero
80128454:	f800283a 	ret

80128458 <_localeconv_r>:
80128458:	00a00574 	movhi	r2,32789
8012845c:	10a25504 	addi	r2,r2,-30380
80128460:	f800283a 	ret

80128464 <setlocale>:
80128464:	00a00574 	movhi	r2,32789
80128468:	10a88704 	addi	r2,r2,-24036
8012846c:	280d883a 	mov	r6,r5
80128470:	200b883a 	mov	r5,r4
80128474:	11000017 	ldw	r4,0(r2)
80128478:	01283a41 	jmpi	801283a4 <_setlocale_r>

8012847c <localeconv>:
8012847c:	00a00574 	movhi	r2,32789
80128480:	10a25504 	addi	r2,r2,-30380
80128484:	f800283a 	ret

80128488 <_malloc_r>:
80128488:	defff504 	addi	sp,sp,-44
8012848c:	de00012e 	bgeu	sp,et,80128494 <_malloc_r+0xc>
80128490:	003b68fa 	trap	3
80128494:	288002c4 	addi	r2,r5,11
80128498:	dc800315 	stw	r18,12(sp)
8012849c:	dfc00a15 	stw	ra,40(sp)
801284a0:	df000915 	stw	fp,36(sp)
801284a4:	ddc00815 	stw	r23,32(sp)
801284a8:	dd800715 	stw	r22,28(sp)
801284ac:	dd400615 	stw	r21,24(sp)
801284b0:	dd000515 	stw	r20,20(sp)
801284b4:	dcc00415 	stw	r19,16(sp)
801284b8:	dc400215 	stw	r17,8(sp)
801284bc:	dc000115 	stw	r16,4(sp)
801284c0:	00c00584 	movi	r3,22
801284c4:	2025883a 	mov	r18,r4
801284c8:	18807f2e 	bgeu	r3,r2,801286c8 <_malloc_r+0x240>
801284cc:	047ffe04 	movi	r17,-8
801284d0:	1462703a 	and	r17,r2,r17
801284d4:	8800a316 	blt	r17,zero,80128764 <_malloc_r+0x2dc>
801284d8:	8940a236 	bltu	r17,r5,80128764 <_malloc_r+0x2dc>
801284dc:	01334b80 	call	801334b8 <__malloc_lock>
801284e0:	00807dc4 	movi	r2,503
801284e4:	1441e92e 	bgeu	r2,r17,80128c8c <_malloc_r+0x804>
801284e8:	8804d27a 	srli	r2,r17,9
801284ec:	1000a126 	beq	r2,zero,80128774 <_malloc_r+0x2ec>
801284f0:	00c00104 	movi	r3,4
801284f4:	18811e36 	bltu	r3,r2,80128970 <_malloc_r+0x4e8>
801284f8:	8804d1ba 	srli	r2,r17,6
801284fc:	12000e44 	addi	r8,r2,57
80128500:	11c00e04 	addi	r7,r2,56
80128504:	4209883a 	add	r4,r8,r8
80128508:	04e00574 	movhi	r19,32789
8012850c:	2109883a 	add	r4,r4,r4
80128510:	9ce26304 	addi	r19,r19,-30324
80128514:	2109883a 	add	r4,r4,r4
80128518:	9909883a 	add	r4,r19,r4
8012851c:	24000117 	ldw	r16,4(r4)
80128520:	213ffe04 	addi	r4,r4,-8
80128524:	24009726 	beq	r4,r16,80128784 <_malloc_r+0x2fc>
80128528:	80800117 	ldw	r2,4(r16)
8012852c:	01bfff04 	movi	r6,-4
80128530:	014003c4 	movi	r5,15
80128534:	1184703a 	and	r2,r2,r6
80128538:	1447c83a 	sub	r3,r2,r17
8012853c:	28c00716 	blt	r5,r3,8012855c <_malloc_r+0xd4>
80128540:	1800920e 	bge	r3,zero,8012878c <_malloc_r+0x304>
80128544:	84000317 	ldw	r16,12(r16)
80128548:	24008e26 	beq	r4,r16,80128784 <_malloc_r+0x2fc>
8012854c:	80800117 	ldw	r2,4(r16)
80128550:	1184703a 	and	r2,r2,r6
80128554:	1447c83a 	sub	r3,r2,r17
80128558:	28fff90e 	bge	r5,r3,80128540 <__reset+0xfa108540>
8012855c:	3809883a 	mov	r4,r7
80128560:	01a00574 	movhi	r6,32789
80128564:	9c000417 	ldw	r16,16(r19)
80128568:	31a26304 	addi	r6,r6,-30324
8012856c:	32000204 	addi	r8,r6,8
80128570:	82013426 	beq	r16,r8,80128a44 <_malloc_r+0x5bc>
80128574:	80c00117 	ldw	r3,4(r16)
80128578:	00bfff04 	movi	r2,-4
8012857c:	188e703a 	and	r7,r3,r2
80128580:	3c45c83a 	sub	r2,r7,r17
80128584:	00c003c4 	movi	r3,15
80128588:	18811f16 	blt	r3,r2,80128a08 <_malloc_r+0x580>
8012858c:	32000515 	stw	r8,20(r6)
80128590:	32000415 	stw	r8,16(r6)
80128594:	10007f0e 	bge	r2,zero,80128794 <_malloc_r+0x30c>
80128598:	00807fc4 	movi	r2,511
8012859c:	11c0fd36 	bltu	r2,r7,80128994 <_malloc_r+0x50c>
801285a0:	3806d0fa 	srli	r3,r7,3
801285a4:	01c00044 	movi	r7,1
801285a8:	30800117 	ldw	r2,4(r6)
801285ac:	19400044 	addi	r5,r3,1
801285b0:	294b883a 	add	r5,r5,r5
801285b4:	1807d0ba 	srai	r3,r3,2
801285b8:	294b883a 	add	r5,r5,r5
801285bc:	294b883a 	add	r5,r5,r5
801285c0:	298b883a 	add	r5,r5,r6
801285c4:	38c6983a 	sll	r3,r7,r3
801285c8:	29c00017 	ldw	r7,0(r5)
801285cc:	2a7ffe04 	addi	r9,r5,-8
801285d0:	1886b03a 	or	r3,r3,r2
801285d4:	82400315 	stw	r9,12(r16)
801285d8:	81c00215 	stw	r7,8(r16)
801285dc:	30c00115 	stw	r3,4(r6)
801285e0:	2c000015 	stw	r16,0(r5)
801285e4:	3c000315 	stw	r16,12(r7)
801285e8:	2005d0ba 	srai	r2,r4,2
801285ec:	01400044 	movi	r5,1
801285f0:	288a983a 	sll	r5,r5,r2
801285f4:	19406f36 	bltu	r3,r5,801287b4 <_malloc_r+0x32c>
801285f8:	28c4703a 	and	r2,r5,r3
801285fc:	10000a1e 	bne	r2,zero,80128628 <_malloc_r+0x1a0>
80128600:	00bfff04 	movi	r2,-4
80128604:	294b883a 	add	r5,r5,r5
80128608:	2088703a 	and	r4,r4,r2
8012860c:	28c4703a 	and	r2,r5,r3
80128610:	21000104 	addi	r4,r4,4
80128614:	1000041e 	bne	r2,zero,80128628 <_malloc_r+0x1a0>
80128618:	294b883a 	add	r5,r5,r5
8012861c:	28c4703a 	and	r2,r5,r3
80128620:	21000104 	addi	r4,r4,4
80128624:	103ffc26 	beq	r2,zero,80128618 <__reset+0xfa108618>
80128628:	02bfff04 	movi	r10,-4
8012862c:	024003c4 	movi	r9,15
80128630:	21800044 	addi	r6,r4,1
80128634:	318d883a 	add	r6,r6,r6
80128638:	318d883a 	add	r6,r6,r6
8012863c:	318d883a 	add	r6,r6,r6
80128640:	998d883a 	add	r6,r19,r6
80128644:	333ffe04 	addi	r12,r6,-8
80128648:	2017883a 	mov	r11,r4
8012864c:	31800104 	addi	r6,r6,4
80128650:	34000017 	ldw	r16,0(r6)
80128654:	31fffd04 	addi	r7,r6,-12
80128658:	81c0041e 	bne	r16,r7,8012866c <_malloc_r+0x1e4>
8012865c:	0000fb06 	br	80128a4c <_malloc_r+0x5c4>
80128660:	1801030e 	bge	r3,zero,80128a70 <_malloc_r+0x5e8>
80128664:	84000317 	ldw	r16,12(r16)
80128668:	81c0f826 	beq	r16,r7,80128a4c <_malloc_r+0x5c4>
8012866c:	80800117 	ldw	r2,4(r16)
80128670:	1284703a 	and	r2,r2,r10
80128674:	1447c83a 	sub	r3,r2,r17
80128678:	48fff90e 	bge	r9,r3,80128660 <__reset+0xfa108660>
8012867c:	80800317 	ldw	r2,12(r16)
80128680:	81000217 	ldw	r4,8(r16)
80128684:	89400054 	ori	r5,r17,1
80128688:	81400115 	stw	r5,4(r16)
8012868c:	20800315 	stw	r2,12(r4)
80128690:	11000215 	stw	r4,8(r2)
80128694:	8463883a 	add	r17,r16,r17
80128698:	9c400515 	stw	r17,20(r19)
8012869c:	9c400415 	stw	r17,16(r19)
801286a0:	18800054 	ori	r2,r3,1
801286a4:	88800115 	stw	r2,4(r17)
801286a8:	8a000315 	stw	r8,12(r17)
801286ac:	8a000215 	stw	r8,8(r17)
801286b0:	88e3883a 	add	r17,r17,r3
801286b4:	88c00015 	stw	r3,0(r17)
801286b8:	9009883a 	mov	r4,r18
801286bc:	01335e00 	call	801335e0 <__malloc_unlock>
801286c0:	80800204 	addi	r2,r16,8
801286c4:	00001b06 	br	80128734 <_malloc_r+0x2ac>
801286c8:	04400404 	movi	r17,16
801286cc:	89402536 	bltu	r17,r5,80128764 <_malloc_r+0x2dc>
801286d0:	01334b80 	call	801334b8 <__malloc_lock>
801286d4:	00800184 	movi	r2,6
801286d8:	01000084 	movi	r4,2
801286dc:	04e00574 	movhi	r19,32789
801286e0:	1085883a 	add	r2,r2,r2
801286e4:	9ce26304 	addi	r19,r19,-30324
801286e8:	1085883a 	add	r2,r2,r2
801286ec:	9885883a 	add	r2,r19,r2
801286f0:	14000117 	ldw	r16,4(r2)
801286f4:	10fffe04 	addi	r3,r2,-8
801286f8:	80c0d926 	beq	r16,r3,80128a60 <_malloc_r+0x5d8>
801286fc:	80c00117 	ldw	r3,4(r16)
80128700:	81000317 	ldw	r4,12(r16)
80128704:	00bfff04 	movi	r2,-4
80128708:	1884703a 	and	r2,r3,r2
8012870c:	81400217 	ldw	r5,8(r16)
80128710:	8085883a 	add	r2,r16,r2
80128714:	10c00117 	ldw	r3,4(r2)
80128718:	29000315 	stw	r4,12(r5)
8012871c:	21400215 	stw	r5,8(r4)
80128720:	18c00054 	ori	r3,r3,1
80128724:	10c00115 	stw	r3,4(r2)
80128728:	9009883a 	mov	r4,r18
8012872c:	01335e00 	call	801335e0 <__malloc_unlock>
80128730:	80800204 	addi	r2,r16,8
80128734:	dfc00a17 	ldw	ra,40(sp)
80128738:	df000917 	ldw	fp,36(sp)
8012873c:	ddc00817 	ldw	r23,32(sp)
80128740:	dd800717 	ldw	r22,28(sp)
80128744:	dd400617 	ldw	r21,24(sp)
80128748:	dd000517 	ldw	r20,20(sp)
8012874c:	dcc00417 	ldw	r19,16(sp)
80128750:	dc800317 	ldw	r18,12(sp)
80128754:	dc400217 	ldw	r17,8(sp)
80128758:	dc000117 	ldw	r16,4(sp)
8012875c:	dec00b04 	addi	sp,sp,44
80128760:	f800283a 	ret
80128764:	00800304 	movi	r2,12
80128768:	90800015 	stw	r2,0(r18)
8012876c:	0005883a 	mov	r2,zero
80128770:	003ff006 	br	80128734 <__reset+0xfa108734>
80128774:	01002004 	movi	r4,128
80128778:	02001004 	movi	r8,64
8012877c:	01c00fc4 	movi	r7,63
80128780:	003f6106 	br	80128508 <__reset+0xfa108508>
80128784:	4009883a 	mov	r4,r8
80128788:	003f7506 	br	80128560 <__reset+0xfa108560>
8012878c:	81000317 	ldw	r4,12(r16)
80128790:	003fde06 	br	8012870c <__reset+0xfa10870c>
80128794:	81c5883a 	add	r2,r16,r7
80128798:	11400117 	ldw	r5,4(r2)
8012879c:	9009883a 	mov	r4,r18
801287a0:	29400054 	ori	r5,r5,1
801287a4:	11400115 	stw	r5,4(r2)
801287a8:	01335e00 	call	801335e0 <__malloc_unlock>
801287ac:	80800204 	addi	r2,r16,8
801287b0:	003fe006 	br	80128734 <__reset+0xfa108734>
801287b4:	9c000217 	ldw	r16,8(r19)
801287b8:	00bfff04 	movi	r2,-4
801287bc:	85800117 	ldw	r22,4(r16)
801287c0:	b0ac703a 	and	r22,r22,r2
801287c4:	b4400336 	bltu	r22,r17,801287d4 <_malloc_r+0x34c>
801287c8:	b445c83a 	sub	r2,r22,r17
801287cc:	00c003c4 	movi	r3,15
801287d0:	18805d16 	blt	r3,r2,80128948 <_malloc_r+0x4c0>
801287d4:	05e00574 	movhi	r23,32789
801287d8:	00a00574 	movhi	r2,32789
801287dc:	10a90804 	addi	r2,r2,-23520
801287e0:	bde88904 	addi	r23,r23,-24028
801287e4:	15400017 	ldw	r21,0(r2)
801287e8:	b8c00017 	ldw	r3,0(r23)
801287ec:	00bfffc4 	movi	r2,-1
801287f0:	858d883a 	add	r6,r16,r22
801287f4:	8d6b883a 	add	r21,r17,r21
801287f8:	1880ea26 	beq	r3,r2,80128ba4 <_malloc_r+0x71c>
801287fc:	ad4403c4 	addi	r21,r21,4111
80128800:	00bc0004 	movi	r2,-4096
80128804:	a8aa703a 	and	r21,r21,r2
80128808:	a80b883a 	mov	r5,r21
8012880c:	9009883a 	mov	r4,r18
80128810:	d9800015 	stw	r6,0(sp)
80128814:	012a9540 	call	8012a954 <_sbrk_r>
80128818:	1029883a 	mov	r20,r2
8012881c:	00bfffc4 	movi	r2,-1
80128820:	d9800017 	ldw	r6,0(sp)
80128824:	a080e826 	beq	r20,r2,80128bc8 <_malloc_r+0x740>
80128828:	a180a636 	bltu	r20,r6,80128ac4 <_malloc_r+0x63c>
8012882c:	07200574 	movhi	fp,32789
80128830:	e7299304 	addi	fp,fp,-22964
80128834:	e0800017 	ldw	r2,0(fp)
80128838:	a887883a 	add	r3,r21,r2
8012883c:	e0c00015 	stw	r3,0(fp)
80128840:	3500e626 	beq	r6,r20,80128bdc <_malloc_r+0x754>
80128844:	b9000017 	ldw	r4,0(r23)
80128848:	00bfffc4 	movi	r2,-1
8012884c:	2080ee26 	beq	r4,r2,80128c08 <_malloc_r+0x780>
80128850:	a185c83a 	sub	r2,r20,r6
80128854:	10c5883a 	add	r2,r2,r3
80128858:	e0800015 	stw	r2,0(fp)
8012885c:	a0c001cc 	andi	r3,r20,7
80128860:	1800bc26 	beq	r3,zero,80128b54 <_malloc_r+0x6cc>
80128864:	a0e9c83a 	sub	r20,r20,r3
80128868:	00840204 	movi	r2,4104
8012886c:	a5000204 	addi	r20,r20,8
80128870:	10c7c83a 	sub	r3,r2,r3
80128874:	a545883a 	add	r2,r20,r21
80128878:	1083ffcc 	andi	r2,r2,4095
8012887c:	18abc83a 	sub	r21,r3,r2
80128880:	a80b883a 	mov	r5,r21
80128884:	9009883a 	mov	r4,r18
80128888:	012a9540 	call	8012a954 <_sbrk_r>
8012888c:	00ffffc4 	movi	r3,-1
80128890:	10c0e126 	beq	r2,r3,80128c18 <_malloc_r+0x790>
80128894:	1505c83a 	sub	r2,r2,r20
80128898:	1545883a 	add	r2,r2,r21
8012889c:	10800054 	ori	r2,r2,1
801288a0:	e0c00017 	ldw	r3,0(fp)
801288a4:	9d000215 	stw	r20,8(r19)
801288a8:	a0800115 	stw	r2,4(r20)
801288ac:	a8c7883a 	add	r3,r21,r3
801288b0:	e0c00015 	stw	r3,0(fp)
801288b4:	84c00e26 	beq	r16,r19,801288f0 <_malloc_r+0x468>
801288b8:	018003c4 	movi	r6,15
801288bc:	3580a72e 	bgeu	r6,r22,80128b5c <_malloc_r+0x6d4>
801288c0:	81400117 	ldw	r5,4(r16)
801288c4:	013ffe04 	movi	r4,-8
801288c8:	b0bffd04 	addi	r2,r22,-12
801288cc:	1104703a 	and	r2,r2,r4
801288d0:	2900004c 	andi	r4,r5,1
801288d4:	2088b03a 	or	r4,r4,r2
801288d8:	81000115 	stw	r4,4(r16)
801288dc:	01400144 	movi	r5,5
801288e0:	8089883a 	add	r4,r16,r2
801288e4:	21400115 	stw	r5,4(r4)
801288e8:	21400215 	stw	r5,8(r4)
801288ec:	3080cd36 	bltu	r6,r2,80128c24 <_malloc_r+0x79c>
801288f0:	00a00574 	movhi	r2,32789
801288f4:	10a90704 	addi	r2,r2,-23524
801288f8:	11000017 	ldw	r4,0(r2)
801288fc:	20c0012e 	bgeu	r4,r3,80128904 <_malloc_r+0x47c>
80128900:	10c00015 	stw	r3,0(r2)
80128904:	00a00574 	movhi	r2,32789
80128908:	10a90604 	addi	r2,r2,-23528
8012890c:	11000017 	ldw	r4,0(r2)
80128910:	9c000217 	ldw	r16,8(r19)
80128914:	20c0012e 	bgeu	r4,r3,8012891c <_malloc_r+0x494>
80128918:	10c00015 	stw	r3,0(r2)
8012891c:	80c00117 	ldw	r3,4(r16)
80128920:	00bfff04 	movi	r2,-4
80128924:	1886703a 	and	r3,r3,r2
80128928:	1c45c83a 	sub	r2,r3,r17
8012892c:	1c400236 	bltu	r3,r17,80128938 <_malloc_r+0x4b0>
80128930:	00c003c4 	movi	r3,15
80128934:	18800416 	blt	r3,r2,80128948 <_malloc_r+0x4c0>
80128938:	9009883a 	mov	r4,r18
8012893c:	01335e00 	call	801335e0 <__malloc_unlock>
80128940:	0005883a 	mov	r2,zero
80128944:	003f7b06 	br	80128734 <__reset+0xfa108734>
80128948:	88c00054 	ori	r3,r17,1
8012894c:	80c00115 	stw	r3,4(r16)
80128950:	8463883a 	add	r17,r16,r17
80128954:	10800054 	ori	r2,r2,1
80128958:	9c400215 	stw	r17,8(r19)
8012895c:	88800115 	stw	r2,4(r17)
80128960:	9009883a 	mov	r4,r18
80128964:	01335e00 	call	801335e0 <__malloc_unlock>
80128968:	80800204 	addi	r2,r16,8
8012896c:	003f7106 	br	80128734 <__reset+0xfa108734>
80128970:	00c00504 	movi	r3,20
80128974:	18804a2e 	bgeu	r3,r2,80128aa0 <_malloc_r+0x618>
80128978:	00c01504 	movi	r3,84
8012897c:	18806e36 	bltu	r3,r2,80128b38 <_malloc_r+0x6b0>
80128980:	8804d33a 	srli	r2,r17,12
80128984:	12001bc4 	addi	r8,r2,111
80128988:	11c01b84 	addi	r7,r2,110
8012898c:	4209883a 	add	r4,r8,r8
80128990:	003edd06 	br	80128508 <__reset+0xfa108508>
80128994:	3804d27a 	srli	r2,r7,9
80128998:	00c00104 	movi	r3,4
8012899c:	1880442e 	bgeu	r3,r2,80128ab0 <_malloc_r+0x628>
801289a0:	00c00504 	movi	r3,20
801289a4:	18808136 	bltu	r3,r2,80128bac <_malloc_r+0x724>
801289a8:	11401704 	addi	r5,r2,92
801289ac:	10c016c4 	addi	r3,r2,91
801289b0:	294b883a 	add	r5,r5,r5
801289b4:	294b883a 	add	r5,r5,r5
801289b8:	294b883a 	add	r5,r5,r5
801289bc:	994b883a 	add	r5,r19,r5
801289c0:	28800017 	ldw	r2,0(r5)
801289c4:	01a00574 	movhi	r6,32789
801289c8:	297ffe04 	addi	r5,r5,-8
801289cc:	31a26304 	addi	r6,r6,-30324
801289d0:	28806526 	beq	r5,r2,80128b68 <_malloc_r+0x6e0>
801289d4:	01bfff04 	movi	r6,-4
801289d8:	10c00117 	ldw	r3,4(r2)
801289dc:	1986703a 	and	r3,r3,r6
801289e0:	38c0022e 	bgeu	r7,r3,801289ec <_malloc_r+0x564>
801289e4:	10800217 	ldw	r2,8(r2)
801289e8:	28bffb1e 	bne	r5,r2,801289d8 <__reset+0xfa1089d8>
801289ec:	11400317 	ldw	r5,12(r2)
801289f0:	98c00117 	ldw	r3,4(r19)
801289f4:	81400315 	stw	r5,12(r16)
801289f8:	80800215 	stw	r2,8(r16)
801289fc:	2c000215 	stw	r16,8(r5)
80128a00:	14000315 	stw	r16,12(r2)
80128a04:	003ef806 	br	801285e8 <__reset+0xfa1085e8>
80128a08:	88c00054 	ori	r3,r17,1
80128a0c:	80c00115 	stw	r3,4(r16)
80128a10:	8463883a 	add	r17,r16,r17
80128a14:	34400515 	stw	r17,20(r6)
80128a18:	34400415 	stw	r17,16(r6)
80128a1c:	10c00054 	ori	r3,r2,1
80128a20:	8a000315 	stw	r8,12(r17)
80128a24:	8a000215 	stw	r8,8(r17)
80128a28:	88c00115 	stw	r3,4(r17)
80128a2c:	88a3883a 	add	r17,r17,r2
80128a30:	88800015 	stw	r2,0(r17)
80128a34:	9009883a 	mov	r4,r18
80128a38:	01335e00 	call	801335e0 <__malloc_unlock>
80128a3c:	80800204 	addi	r2,r16,8
80128a40:	003f3c06 	br	80128734 <__reset+0xfa108734>
80128a44:	30c00117 	ldw	r3,4(r6)
80128a48:	003ee706 	br	801285e8 <__reset+0xfa1085e8>
80128a4c:	5ac00044 	addi	r11,r11,1
80128a50:	588000cc 	andi	r2,r11,3
80128a54:	31800204 	addi	r6,r6,8
80128a58:	103efd1e 	bne	r2,zero,80128650 <__reset+0xfa108650>
80128a5c:	00002406 	br	80128af0 <_malloc_r+0x668>
80128a60:	14000317 	ldw	r16,12(r2)
80128a64:	143f251e 	bne	r2,r16,801286fc <__reset+0xfa1086fc>
80128a68:	21000084 	addi	r4,r4,2
80128a6c:	003ebc06 	br	80128560 <__reset+0xfa108560>
80128a70:	8085883a 	add	r2,r16,r2
80128a74:	10c00117 	ldw	r3,4(r2)
80128a78:	81000317 	ldw	r4,12(r16)
80128a7c:	81400217 	ldw	r5,8(r16)
80128a80:	18c00054 	ori	r3,r3,1
80128a84:	10c00115 	stw	r3,4(r2)
80128a88:	29000315 	stw	r4,12(r5)
80128a8c:	21400215 	stw	r5,8(r4)
80128a90:	9009883a 	mov	r4,r18
80128a94:	01335e00 	call	801335e0 <__malloc_unlock>
80128a98:	80800204 	addi	r2,r16,8
80128a9c:	003f2506 	br	80128734 <__reset+0xfa108734>
80128aa0:	12001704 	addi	r8,r2,92
80128aa4:	11c016c4 	addi	r7,r2,91
80128aa8:	4209883a 	add	r4,r8,r8
80128aac:	003e9606 	br	80128508 <__reset+0xfa108508>
80128ab0:	3804d1ba 	srli	r2,r7,6
80128ab4:	11400e44 	addi	r5,r2,57
80128ab8:	10c00e04 	addi	r3,r2,56
80128abc:	294b883a 	add	r5,r5,r5
80128ac0:	003fbc06 	br	801289b4 <__reset+0xfa1089b4>
80128ac4:	84ff5926 	beq	r16,r19,8012882c <__reset+0xfa10882c>
80128ac8:	00a00574 	movhi	r2,32789
80128acc:	10a26304 	addi	r2,r2,-30324
80128ad0:	14000217 	ldw	r16,8(r2)
80128ad4:	00bfff04 	movi	r2,-4
80128ad8:	80c00117 	ldw	r3,4(r16)
80128adc:	1886703a 	and	r3,r3,r2
80128ae0:	003f9106 	br	80128928 <__reset+0xfa108928>
80128ae4:	60800217 	ldw	r2,8(r12)
80128ae8:	213fffc4 	addi	r4,r4,-1
80128aec:	1300651e 	bne	r2,r12,80128c84 <_malloc_r+0x7fc>
80128af0:	208000cc 	andi	r2,r4,3
80128af4:	633ffe04 	addi	r12,r12,-8
80128af8:	103ffa1e 	bne	r2,zero,80128ae4 <__reset+0xfa108ae4>
80128afc:	98800117 	ldw	r2,4(r19)
80128b00:	0146303a 	nor	r3,zero,r5
80128b04:	1884703a 	and	r2,r3,r2
80128b08:	98800115 	stw	r2,4(r19)
80128b0c:	294b883a 	add	r5,r5,r5
80128b10:	117f2836 	bltu	r2,r5,801287b4 <__reset+0xfa1087b4>
80128b14:	283f2726 	beq	r5,zero,801287b4 <__reset+0xfa1087b4>
80128b18:	2886703a 	and	r3,r5,r2
80128b1c:	5809883a 	mov	r4,r11
80128b20:	183ec31e 	bne	r3,zero,80128630 <__reset+0xfa108630>
80128b24:	294b883a 	add	r5,r5,r5
80128b28:	2886703a 	and	r3,r5,r2
80128b2c:	21000104 	addi	r4,r4,4
80128b30:	183ffc26 	beq	r3,zero,80128b24 <__reset+0xfa108b24>
80128b34:	003ebe06 	br	80128630 <__reset+0xfa108630>
80128b38:	00c05504 	movi	r3,340
80128b3c:	18801236 	bltu	r3,r2,80128b88 <_malloc_r+0x700>
80128b40:	8804d3fa 	srli	r2,r17,15
80128b44:	12001e04 	addi	r8,r2,120
80128b48:	11c01dc4 	addi	r7,r2,119
80128b4c:	4209883a 	add	r4,r8,r8
80128b50:	003e6d06 	br	80128508 <__reset+0xfa108508>
80128b54:	00c40004 	movi	r3,4096
80128b58:	003f4606 	br	80128874 <__reset+0xfa108874>
80128b5c:	00800044 	movi	r2,1
80128b60:	a0800115 	stw	r2,4(r20)
80128b64:	003f7406 	br	80128938 <__reset+0xfa108938>
80128b68:	1805d0ba 	srai	r2,r3,2
80128b6c:	01c00044 	movi	r7,1
80128b70:	30c00117 	ldw	r3,4(r6)
80128b74:	388e983a 	sll	r7,r7,r2
80128b78:	2805883a 	mov	r2,r5
80128b7c:	38c6b03a 	or	r3,r7,r3
80128b80:	30c00115 	stw	r3,4(r6)
80128b84:	003f9b06 	br	801289f4 <__reset+0xfa1089f4>
80128b88:	00c15504 	movi	r3,1364
80128b8c:	18801a36 	bltu	r3,r2,80128bf8 <_malloc_r+0x770>
80128b90:	8804d4ba 	srli	r2,r17,18
80128b94:	12001f44 	addi	r8,r2,125
80128b98:	11c01f04 	addi	r7,r2,124
80128b9c:	4209883a 	add	r4,r8,r8
80128ba0:	003e5906 	br	80128508 <__reset+0xfa108508>
80128ba4:	ad400404 	addi	r21,r21,16
80128ba8:	003f1706 	br	80128808 <__reset+0xfa108808>
80128bac:	00c01504 	movi	r3,84
80128bb0:	18802336 	bltu	r3,r2,80128c40 <_malloc_r+0x7b8>
80128bb4:	3804d33a 	srli	r2,r7,12
80128bb8:	11401bc4 	addi	r5,r2,111
80128bbc:	10c01b84 	addi	r3,r2,110
80128bc0:	294b883a 	add	r5,r5,r5
80128bc4:	003f7b06 	br	801289b4 <__reset+0xfa1089b4>
80128bc8:	9c000217 	ldw	r16,8(r19)
80128bcc:	00bfff04 	movi	r2,-4
80128bd0:	80c00117 	ldw	r3,4(r16)
80128bd4:	1886703a 	and	r3,r3,r2
80128bd8:	003f5306 	br	80128928 <__reset+0xfa108928>
80128bdc:	3083ffcc 	andi	r2,r6,4095
80128be0:	103f181e 	bne	r2,zero,80128844 <__reset+0xfa108844>
80128be4:	99000217 	ldw	r4,8(r19)
80128be8:	b545883a 	add	r2,r22,r21
80128bec:	10800054 	ori	r2,r2,1
80128bf0:	20800115 	stw	r2,4(r4)
80128bf4:	003f3e06 	br	801288f0 <__reset+0xfa1088f0>
80128bf8:	01003f84 	movi	r4,254
80128bfc:	02001fc4 	movi	r8,127
80128c00:	01c01f84 	movi	r7,126
80128c04:	003e4006 	br	80128508 <__reset+0xfa108508>
80128c08:	00a00574 	movhi	r2,32789
80128c0c:	10a88904 	addi	r2,r2,-24028
80128c10:	15000015 	stw	r20,0(r2)
80128c14:	003f1106 	br	8012885c <__reset+0xfa10885c>
80128c18:	00800044 	movi	r2,1
80128c1c:	002b883a 	mov	r21,zero
80128c20:	003f1f06 	br	801288a0 <__reset+0xfa1088a0>
80128c24:	81400204 	addi	r5,r16,8
80128c28:	9009883a 	mov	r4,r18
80128c2c:	0127a000 	call	80127a00 <_free_r>
80128c30:	00a00574 	movhi	r2,32789
80128c34:	10a99304 	addi	r2,r2,-22964
80128c38:	10c00017 	ldw	r3,0(r2)
80128c3c:	003f2c06 	br	801288f0 <__reset+0xfa1088f0>
80128c40:	00c05504 	movi	r3,340
80128c44:	18800536 	bltu	r3,r2,80128c5c <_malloc_r+0x7d4>
80128c48:	3804d3fa 	srli	r2,r7,15
80128c4c:	11401e04 	addi	r5,r2,120
80128c50:	10c01dc4 	addi	r3,r2,119
80128c54:	294b883a 	add	r5,r5,r5
80128c58:	003f5606 	br	801289b4 <__reset+0xfa1089b4>
80128c5c:	00c15504 	movi	r3,1364
80128c60:	18800536 	bltu	r3,r2,80128c78 <_malloc_r+0x7f0>
80128c64:	3804d4ba 	srli	r2,r7,18
80128c68:	11401f44 	addi	r5,r2,125
80128c6c:	10c01f04 	addi	r3,r2,124
80128c70:	294b883a 	add	r5,r5,r5
80128c74:	003f4f06 	br	801289b4 <__reset+0xfa1089b4>
80128c78:	01403f84 	movi	r5,254
80128c7c:	00c01f84 	movi	r3,126
80128c80:	003f4c06 	br	801289b4 <__reset+0xfa1089b4>
80128c84:	98800117 	ldw	r2,4(r19)
80128c88:	003fa006 	br	80128b0c <__reset+0xfa108b0c>
80128c8c:	8808d0fa 	srli	r4,r17,3
80128c90:	20800044 	addi	r2,r4,1
80128c94:	1085883a 	add	r2,r2,r2
80128c98:	003e9006 	br	801286dc <__reset+0xfa1086dc>

80128c9c <_mbrtowc_r>:
80128c9c:	defff704 	addi	sp,sp,-36
80128ca0:	00a00574 	movhi	r2,32789
80128ca4:	de00012e 	bgeu	sp,et,80128cac <_mbrtowc_r+0x10>
80128ca8:	003b68fa 	trap	3
80128cac:	10a88b04 	addi	r2,r2,-24020
80128cb0:	dc800715 	stw	r18,28(sp)
80128cb4:	dc400615 	stw	r17,24(sp)
80128cb8:	dc000515 	stw	r16,20(sp)
80128cbc:	dfc00815 	stw	ra,32(sp)
80128cc0:	2021883a 	mov	r16,r4
80128cc4:	dc400917 	ldw	r17,36(sp)
80128cc8:	14800017 	ldw	r18,0(r2)
80128ccc:	30001626 	beq	r6,zero,80128d28 <_mbrtowc_r+0x8c>
80128cd0:	d9400215 	stw	r5,8(sp)
80128cd4:	d9800315 	stw	r6,12(sp)
80128cd8:	d9c00415 	stw	r7,16(sp)
80128cdc:	01284280 	call	80128428 <__locale_charset>
80128ce0:	d9c00417 	ldw	r7,16(sp)
80128ce4:	d9800317 	ldw	r6,12(sp)
80128ce8:	d9400217 	ldw	r5,8(sp)
80128cec:	d8800015 	stw	r2,0(sp)
80128cf0:	dc400115 	stw	r17,4(sp)
80128cf4:	8009883a 	mov	r4,r16
80128cf8:	903ee83a 	callr	r18
80128cfc:	00ffffc4 	movi	r3,-1
80128d00:	10c0031e 	bne	r2,r3,80128d10 <_mbrtowc_r+0x74>
80128d04:	88000015 	stw	zero,0(r17)
80128d08:	00c02284 	movi	r3,138
80128d0c:	80c00015 	stw	r3,0(r16)
80128d10:	dfc00817 	ldw	ra,32(sp)
80128d14:	dc800717 	ldw	r18,28(sp)
80128d18:	dc400617 	ldw	r17,24(sp)
80128d1c:	dc000517 	ldw	r16,20(sp)
80128d20:	dec00904 	addi	sp,sp,36
80128d24:	f800283a 	ret
80128d28:	01284280 	call	80128428 <__locale_charset>
80128d2c:	01a00534 	movhi	r6,32788
80128d30:	319ec804 	addi	r6,r6,31520
80128d34:	dc400115 	stw	r17,4(sp)
80128d38:	d8800015 	stw	r2,0(sp)
80128d3c:	01c00044 	movi	r7,1
80128d40:	000b883a 	mov	r5,zero
80128d44:	8009883a 	mov	r4,r16
80128d48:	903ee83a 	callr	r18
80128d4c:	003feb06 	br	80128cfc <__reset+0xfa108cfc>

80128d50 <mbrtowc>:
80128d50:	defff704 	addi	sp,sp,-36
80128d54:	00a00574 	movhi	r2,32789
80128d58:	de00012e 	bgeu	sp,et,80128d60 <mbrtowc+0x10>
80128d5c:	003b68fa 	trap	3
80128d60:	10a88704 	addi	r2,r2,-24036
80128d64:	dc800415 	stw	r18,16(sp)
80128d68:	dc400315 	stw	r17,12(sp)
80128d6c:	dfc00815 	stw	ra,32(sp)
80128d70:	dd400715 	stw	r21,28(sp)
80128d74:	dd000615 	stw	r20,24(sp)
80128d78:	dcc00515 	stw	r19,20(sp)
80128d7c:	dc000215 	stw	r16,8(sp)
80128d80:	3825883a 	mov	r18,r7
80128d84:	14400017 	ldw	r17,0(r2)
80128d88:	28001c26 	beq	r5,zero,80128dfc <mbrtowc+0xac>
80128d8c:	00a00574 	movhi	r2,32789
80128d90:	10a88b04 	addi	r2,r2,-24020
80128d94:	15400017 	ldw	r21,0(r2)
80128d98:	2821883a 	mov	r16,r5
80128d9c:	2027883a 	mov	r19,r4
80128da0:	3029883a 	mov	r20,r6
80128da4:	01284280 	call	80128428 <__locale_charset>
80128da8:	d8800015 	stw	r2,0(sp)
80128dac:	dc800115 	stw	r18,4(sp)
80128db0:	a00f883a 	mov	r7,r20
80128db4:	800d883a 	mov	r6,r16
80128db8:	980b883a 	mov	r5,r19
80128dbc:	8809883a 	mov	r4,r17
80128dc0:	a83ee83a 	callr	r21
80128dc4:	00ffffc4 	movi	r3,-1
80128dc8:	10c0031e 	bne	r2,r3,80128dd8 <mbrtowc+0x88>
80128dcc:	90000015 	stw	zero,0(r18)
80128dd0:	00c02284 	movi	r3,138
80128dd4:	88c00015 	stw	r3,0(r17)
80128dd8:	dfc00817 	ldw	ra,32(sp)
80128ddc:	dd400717 	ldw	r21,28(sp)
80128de0:	dd000617 	ldw	r20,24(sp)
80128de4:	dcc00517 	ldw	r19,20(sp)
80128de8:	dc800417 	ldw	r18,16(sp)
80128dec:	dc400317 	ldw	r17,12(sp)
80128df0:	dc000217 	ldw	r16,8(sp)
80128df4:	dec00904 	addi	sp,sp,36
80128df8:	f800283a 	ret
80128dfc:	00a00574 	movhi	r2,32789
80128e00:	10a88b04 	addi	r2,r2,-24020
80128e04:	14000017 	ldw	r16,0(r2)
80128e08:	01284280 	call	80128428 <__locale_charset>
80128e0c:	01a00534 	movhi	r6,32788
80128e10:	319ec804 	addi	r6,r6,31520
80128e14:	dc800115 	stw	r18,4(sp)
80128e18:	d8800015 	stw	r2,0(sp)
80128e1c:	01c00044 	movi	r7,1
80128e20:	000b883a 	mov	r5,zero
80128e24:	8809883a 	mov	r4,r17
80128e28:	803ee83a 	callr	r16
80128e2c:	003fe506 	br	80128dc4 <__reset+0xfa108dc4>

80128e30 <__ascii_mbtowc>:
80128e30:	deffff04 	addi	sp,sp,-4
80128e34:	de00012e 	bgeu	sp,et,80128e3c <__ascii_mbtowc+0xc>
80128e38:	003b68fa 	trap	3
80128e3c:	28000826 	beq	r5,zero,80128e60 <__ascii_mbtowc+0x30>
80128e40:	30000926 	beq	r6,zero,80128e68 <__ascii_mbtowc+0x38>
80128e44:	38000b26 	beq	r7,zero,80128e74 <__ascii_mbtowc+0x44>
80128e48:	30800003 	ldbu	r2,0(r6)
80128e4c:	28800015 	stw	r2,0(r5)
80128e50:	30800003 	ldbu	r2,0(r6)
80128e54:	1004c03a 	cmpne	r2,r2,zero
80128e58:	dec00104 	addi	sp,sp,4
80128e5c:	f800283a 	ret
80128e60:	d80b883a 	mov	r5,sp
80128e64:	303ff71e 	bne	r6,zero,80128e44 <__reset+0xfa108e44>
80128e68:	0005883a 	mov	r2,zero
80128e6c:	dec00104 	addi	sp,sp,4
80128e70:	f800283a 	ret
80128e74:	00bfff84 	movi	r2,-2
80128e78:	003ff706 	br	80128e58 <__reset+0xfa108e58>

80128e7c <_mbtowc_r>:
80128e7c:	00a00574 	movhi	r2,32789
80128e80:	defff804 	addi	sp,sp,-32
80128e84:	10a88b04 	addi	r2,r2,-24020
80128e88:	de00012e 	bgeu	sp,et,80128e90 <_mbtowc_r+0x14>
80128e8c:	003b68fa 	trap	3
80128e90:	dfc00715 	stw	ra,28(sp)
80128e94:	dc000615 	stw	r16,24(sp)
80128e98:	14000017 	ldw	r16,0(r2)
80128e9c:	d9000215 	stw	r4,8(sp)
80128ea0:	d9400315 	stw	r5,12(sp)
80128ea4:	d9800415 	stw	r6,16(sp)
80128ea8:	d9c00515 	stw	r7,20(sp)
80128eac:	01284280 	call	80128428 <__locale_charset>
80128eb0:	d8800015 	stw	r2,0(sp)
80128eb4:	d8800817 	ldw	r2,32(sp)
80128eb8:	d9c00517 	ldw	r7,20(sp)
80128ebc:	d9800417 	ldw	r6,16(sp)
80128ec0:	d9400317 	ldw	r5,12(sp)
80128ec4:	d9000217 	ldw	r4,8(sp)
80128ec8:	d8800115 	stw	r2,4(sp)
80128ecc:	803ee83a 	callr	r16
80128ed0:	dfc00717 	ldw	ra,28(sp)
80128ed4:	dc000617 	ldw	r16,24(sp)
80128ed8:	dec00804 	addi	sp,sp,32
80128edc:	f800283a 	ret

80128ee0 <memchr>:
80128ee0:	208000cc 	andi	r2,r4,3
80128ee4:	280f883a 	mov	r7,r5
80128ee8:	10003426 	beq	r2,zero,80128fbc <memchr+0xdc>
80128eec:	30bfffc4 	addi	r2,r6,-1
80128ef0:	30001a26 	beq	r6,zero,80128f5c <memchr+0x7c>
80128ef4:	20c00003 	ldbu	r3,0(r4)
80128ef8:	29803fcc 	andi	r6,r5,255
80128efc:	30c0051e 	bne	r6,r3,80128f14 <memchr+0x34>
80128f00:	00001806 	br	80128f64 <memchr+0x84>
80128f04:	10001526 	beq	r2,zero,80128f5c <memchr+0x7c>
80128f08:	20c00003 	ldbu	r3,0(r4)
80128f0c:	10bfffc4 	addi	r2,r2,-1
80128f10:	30c01426 	beq	r6,r3,80128f64 <memchr+0x84>
80128f14:	21000044 	addi	r4,r4,1
80128f18:	20c000cc 	andi	r3,r4,3
80128f1c:	183ff91e 	bne	r3,zero,80128f04 <__reset+0xfa108f04>
80128f20:	020000c4 	movi	r8,3
80128f24:	40801136 	bltu	r8,r2,80128f6c <memchr+0x8c>
80128f28:	10000c26 	beq	r2,zero,80128f5c <memchr+0x7c>
80128f2c:	20c00003 	ldbu	r3,0(r4)
80128f30:	29403fcc 	andi	r5,r5,255
80128f34:	28c00b26 	beq	r5,r3,80128f64 <memchr+0x84>
80128f38:	20c00044 	addi	r3,r4,1
80128f3c:	39803fcc 	andi	r6,r7,255
80128f40:	2089883a 	add	r4,r4,r2
80128f44:	00000306 	br	80128f54 <memchr+0x74>
80128f48:	18c00044 	addi	r3,r3,1
80128f4c:	197fffc3 	ldbu	r5,-1(r3)
80128f50:	31400526 	beq	r6,r5,80128f68 <memchr+0x88>
80128f54:	1805883a 	mov	r2,r3
80128f58:	20fffb1e 	bne	r4,r3,80128f48 <__reset+0xfa108f48>
80128f5c:	0005883a 	mov	r2,zero
80128f60:	f800283a 	ret
80128f64:	2005883a 	mov	r2,r4
80128f68:	f800283a 	ret
80128f6c:	28c03fcc 	andi	r3,r5,255
80128f70:	1812923a 	slli	r9,r3,8
80128f74:	02ffbff4 	movhi	r11,65279
80128f78:	02a02074 	movhi	r10,32897
80128f7c:	48d2b03a 	or	r9,r9,r3
80128f80:	4806943a 	slli	r3,r9,16
80128f84:	5affbfc4 	addi	r11,r11,-257
80128f88:	52a02004 	addi	r10,r10,-32640
80128f8c:	48d2b03a 	or	r9,r9,r3
80128f90:	20c00017 	ldw	r3,0(r4)
80128f94:	48c6f03a 	xor	r3,r9,r3
80128f98:	1acd883a 	add	r6,r3,r11
80128f9c:	00c6303a 	nor	r3,zero,r3
80128fa0:	30c6703a 	and	r3,r6,r3
80128fa4:	1a86703a 	and	r3,r3,r10
80128fa8:	183fe01e 	bne	r3,zero,80128f2c <__reset+0xfa108f2c>
80128fac:	10bfff04 	addi	r2,r2,-4
80128fb0:	21000104 	addi	r4,r4,4
80128fb4:	40bff636 	bltu	r8,r2,80128f90 <__reset+0xfa108f90>
80128fb8:	003fdb06 	br	80128f28 <__reset+0xfa108f28>
80128fbc:	3005883a 	mov	r2,r6
80128fc0:	003fd706 	br	80128f20 <__reset+0xfa108f20>

80128fc4 <memmove>:
80128fc4:	2005883a 	mov	r2,r4
80128fc8:	29000b2e 	bgeu	r5,r4,80128ff8 <memmove+0x34>
80128fcc:	298f883a 	add	r7,r5,r6
80128fd0:	21c0092e 	bgeu	r4,r7,80128ff8 <memmove+0x34>
80128fd4:	2187883a 	add	r3,r4,r6
80128fd8:	198bc83a 	sub	r5,r3,r6
80128fdc:	30004826 	beq	r6,zero,80129100 <memmove+0x13c>
80128fe0:	39ffffc4 	addi	r7,r7,-1
80128fe4:	39000003 	ldbu	r4,0(r7)
80128fe8:	18ffffc4 	addi	r3,r3,-1
80128fec:	19000005 	stb	r4,0(r3)
80128ff0:	28fffb1e 	bne	r5,r3,80128fe0 <__reset+0xfa108fe0>
80128ff4:	f800283a 	ret
80128ff8:	00c003c4 	movi	r3,15
80128ffc:	1980412e 	bgeu	r3,r6,80129104 <memmove+0x140>
80129000:	2886b03a 	or	r3,r5,r2
80129004:	18c000cc 	andi	r3,r3,3
80129008:	1800401e 	bne	r3,zero,8012910c <memmove+0x148>
8012900c:	33fffc04 	addi	r15,r6,-16
80129010:	781ed13a 	srli	r15,r15,4
80129014:	28c00104 	addi	r3,r5,4
80129018:	13400104 	addi	r13,r2,4
8012901c:	781c913a 	slli	r14,r15,4
80129020:	2b000204 	addi	r12,r5,8
80129024:	12c00204 	addi	r11,r2,8
80129028:	73800504 	addi	r14,r14,20
8012902c:	2a800304 	addi	r10,r5,12
80129030:	12400304 	addi	r9,r2,12
80129034:	2b9d883a 	add	r14,r5,r14
80129038:	2811883a 	mov	r8,r5
8012903c:	100f883a 	mov	r7,r2
80129040:	41000017 	ldw	r4,0(r8)
80129044:	39c00404 	addi	r7,r7,16
80129048:	18c00404 	addi	r3,r3,16
8012904c:	393ffc15 	stw	r4,-16(r7)
80129050:	193ffc17 	ldw	r4,-16(r3)
80129054:	6b400404 	addi	r13,r13,16
80129058:	5ac00404 	addi	r11,r11,16
8012905c:	693ffc15 	stw	r4,-16(r13)
80129060:	61000017 	ldw	r4,0(r12)
80129064:	4a400404 	addi	r9,r9,16
80129068:	42000404 	addi	r8,r8,16
8012906c:	593ffc15 	stw	r4,-16(r11)
80129070:	51000017 	ldw	r4,0(r10)
80129074:	63000404 	addi	r12,r12,16
80129078:	52800404 	addi	r10,r10,16
8012907c:	493ffc15 	stw	r4,-16(r9)
80129080:	1bbfef1e 	bne	r3,r14,80129040 <__reset+0xfa109040>
80129084:	79000044 	addi	r4,r15,1
80129088:	2008913a 	slli	r4,r4,4
8012908c:	328003cc 	andi	r10,r6,15
80129090:	02c000c4 	movi	r11,3
80129094:	1107883a 	add	r3,r2,r4
80129098:	290b883a 	add	r5,r5,r4
8012909c:	5a801e2e 	bgeu	r11,r10,80129118 <memmove+0x154>
801290a0:	1813883a 	mov	r9,r3
801290a4:	2811883a 	mov	r8,r5
801290a8:	500f883a 	mov	r7,r10
801290ac:	41000017 	ldw	r4,0(r8)
801290b0:	4a400104 	addi	r9,r9,4
801290b4:	39ffff04 	addi	r7,r7,-4
801290b8:	493fff15 	stw	r4,-4(r9)
801290bc:	42000104 	addi	r8,r8,4
801290c0:	59fffa36 	bltu	r11,r7,801290ac <__reset+0xfa1090ac>
801290c4:	513fff04 	addi	r4,r10,-4
801290c8:	2008d0ba 	srli	r4,r4,2
801290cc:	318000cc 	andi	r6,r6,3
801290d0:	21000044 	addi	r4,r4,1
801290d4:	2109883a 	add	r4,r4,r4
801290d8:	2109883a 	add	r4,r4,r4
801290dc:	1907883a 	add	r3,r3,r4
801290e0:	290b883a 	add	r5,r5,r4
801290e4:	30000b26 	beq	r6,zero,80129114 <memmove+0x150>
801290e8:	198d883a 	add	r6,r3,r6
801290ec:	29c00003 	ldbu	r7,0(r5)
801290f0:	18c00044 	addi	r3,r3,1
801290f4:	29400044 	addi	r5,r5,1
801290f8:	19ffffc5 	stb	r7,-1(r3)
801290fc:	19bffb1e 	bne	r3,r6,801290ec <__reset+0xfa1090ec>
80129100:	f800283a 	ret
80129104:	1007883a 	mov	r3,r2
80129108:	003ff606 	br	801290e4 <__reset+0xfa1090e4>
8012910c:	1007883a 	mov	r3,r2
80129110:	003ff506 	br	801290e8 <__reset+0xfa1090e8>
80129114:	f800283a 	ret
80129118:	500d883a 	mov	r6,r10
8012911c:	003ff106 	br	801290e4 <__reset+0xfa1090e4>

80129120 <_Balloc>:
80129120:	defffc04 	addi	sp,sp,-16
80129124:	de00012e 	bgeu	sp,et,8012912c <_Balloc+0xc>
80129128:	003b68fa 	trap	3
8012912c:	20801317 	ldw	r2,76(r4)
80129130:	dc400115 	stw	r17,4(sp)
80129134:	dc000015 	stw	r16,0(sp)
80129138:	dfc00315 	stw	ra,12(sp)
8012913c:	dc800215 	stw	r18,8(sp)
80129140:	2023883a 	mov	r17,r4
80129144:	2821883a 	mov	r16,r5
80129148:	10000f26 	beq	r2,zero,80129188 <_Balloc+0x68>
8012914c:	8407883a 	add	r3,r16,r16
80129150:	18c7883a 	add	r3,r3,r3
80129154:	10c7883a 	add	r3,r2,r3
80129158:	18800017 	ldw	r2,0(r3)
8012915c:	10001126 	beq	r2,zero,801291a4 <_Balloc+0x84>
80129160:	11000017 	ldw	r4,0(r2)
80129164:	19000015 	stw	r4,0(r3)
80129168:	10000415 	stw	zero,16(r2)
8012916c:	10000315 	stw	zero,12(r2)
80129170:	dfc00317 	ldw	ra,12(sp)
80129174:	dc800217 	ldw	r18,8(sp)
80129178:	dc400117 	ldw	r17,4(sp)
8012917c:	dc000017 	ldw	r16,0(sp)
80129180:	dec00404 	addi	sp,sp,16
80129184:	f800283a 	ret
80129188:	01800844 	movi	r6,33
8012918c:	01400104 	movi	r5,4
80129190:	012e2600 	call	8012e260 <_calloc_r>
80129194:	88801315 	stw	r2,76(r17)
80129198:	103fec1e 	bne	r2,zero,8012914c <__reset+0xfa10914c>
8012919c:	0005883a 	mov	r2,zero
801291a0:	003ff306 	br	80129170 <__reset+0xfa109170>
801291a4:	01400044 	movi	r5,1
801291a8:	2c24983a 	sll	r18,r5,r16
801291ac:	8809883a 	mov	r4,r17
801291b0:	91800144 	addi	r6,r18,5
801291b4:	318d883a 	add	r6,r6,r6
801291b8:	318d883a 	add	r6,r6,r6
801291bc:	012e2600 	call	8012e260 <_calloc_r>
801291c0:	103ff626 	beq	r2,zero,8012919c <__reset+0xfa10919c>
801291c4:	14000115 	stw	r16,4(r2)
801291c8:	14800215 	stw	r18,8(r2)
801291cc:	003fe606 	br	80129168 <__reset+0xfa109168>

801291d0 <_Bfree>:
801291d0:	28000826 	beq	r5,zero,801291f4 <_Bfree+0x24>
801291d4:	28c00117 	ldw	r3,4(r5)
801291d8:	20801317 	ldw	r2,76(r4)
801291dc:	18c7883a 	add	r3,r3,r3
801291e0:	18c7883a 	add	r3,r3,r3
801291e4:	10c5883a 	add	r2,r2,r3
801291e8:	10c00017 	ldw	r3,0(r2)
801291ec:	28c00015 	stw	r3,0(r5)
801291f0:	11400015 	stw	r5,0(r2)
801291f4:	f800283a 	ret

801291f8 <__multadd>:
801291f8:	defffa04 	addi	sp,sp,-24
801291fc:	de00012e 	bgeu	sp,et,80129204 <__multadd+0xc>
80129200:	003b68fa 	trap	3
80129204:	0011883a 	mov	r8,zero
80129208:	dc800315 	stw	r18,12(sp)
8012920c:	dc400215 	stw	r17,8(sp)
80129210:	dc000115 	stw	r16,4(sp)
80129214:	2823883a 	mov	r17,r5
80129218:	2c000417 	ldw	r16,16(r5)
8012921c:	dfc00515 	stw	ra,20(sp)
80129220:	dcc00415 	stw	r19,16(sp)
80129224:	2025883a 	mov	r18,r4
80129228:	29400504 	addi	r5,r5,20
8012922c:	28c00017 	ldw	r3,0(r5)
80129230:	29400104 	addi	r5,r5,4
80129234:	42000044 	addi	r8,r8,1
80129238:	18bfffcc 	andi	r2,r3,65535
8012923c:	1185383a 	mul	r2,r2,r6
80129240:	1806d43a 	srli	r3,r3,16
80129244:	11cf883a 	add	r7,r2,r7
80129248:	3808d43a 	srli	r4,r7,16
8012924c:	1987383a 	mul	r3,r3,r6
80129250:	38bfffcc 	andi	r2,r7,65535
80129254:	1907883a 	add	r3,r3,r4
80129258:	1808943a 	slli	r4,r3,16
8012925c:	180ed43a 	srli	r7,r3,16
80129260:	2085883a 	add	r2,r4,r2
80129264:	28bfff15 	stw	r2,-4(r5)
80129268:	443ff016 	blt	r8,r16,8012922c <__reset+0xfa10922c>
8012926c:	38000926 	beq	r7,zero,80129294 <__multadd+0x9c>
80129270:	88800217 	ldw	r2,8(r17)
80129274:	80800f0e 	bge	r16,r2,801292b4 <__multadd+0xbc>
80129278:	80800144 	addi	r2,r16,5
8012927c:	1085883a 	add	r2,r2,r2
80129280:	1085883a 	add	r2,r2,r2
80129284:	8885883a 	add	r2,r17,r2
80129288:	11c00015 	stw	r7,0(r2)
8012928c:	84000044 	addi	r16,r16,1
80129290:	8c000415 	stw	r16,16(r17)
80129294:	8805883a 	mov	r2,r17
80129298:	dfc00517 	ldw	ra,20(sp)
8012929c:	dcc00417 	ldw	r19,16(sp)
801292a0:	dc800317 	ldw	r18,12(sp)
801292a4:	dc400217 	ldw	r17,8(sp)
801292a8:	dc000117 	ldw	r16,4(sp)
801292ac:	dec00604 	addi	sp,sp,24
801292b0:	f800283a 	ret
801292b4:	89400117 	ldw	r5,4(r17)
801292b8:	9009883a 	mov	r4,r18
801292bc:	d9c00015 	stw	r7,0(sp)
801292c0:	29400044 	addi	r5,r5,1
801292c4:	01291200 	call	80129120 <_Balloc>
801292c8:	89800417 	ldw	r6,16(r17)
801292cc:	89400304 	addi	r5,r17,12
801292d0:	11000304 	addi	r4,r2,12
801292d4:	31800084 	addi	r6,r6,2
801292d8:	318d883a 	add	r6,r6,r6
801292dc:	318d883a 	add	r6,r6,r6
801292e0:	1027883a 	mov	r19,r2
801292e4:	01214640 	call	80121464 <memcpy>
801292e8:	d9c00017 	ldw	r7,0(sp)
801292ec:	88000a26 	beq	r17,zero,80129318 <__multadd+0x120>
801292f0:	88c00117 	ldw	r3,4(r17)
801292f4:	90801317 	ldw	r2,76(r18)
801292f8:	18c7883a 	add	r3,r3,r3
801292fc:	18c7883a 	add	r3,r3,r3
80129300:	10c5883a 	add	r2,r2,r3
80129304:	10c00017 	ldw	r3,0(r2)
80129308:	88c00015 	stw	r3,0(r17)
8012930c:	14400015 	stw	r17,0(r2)
80129310:	9823883a 	mov	r17,r19
80129314:	003fd806 	br	80129278 <__reset+0xfa109278>
80129318:	9823883a 	mov	r17,r19
8012931c:	003fd606 	br	80129278 <__reset+0xfa109278>

80129320 <__s2b>:
80129320:	defff904 	addi	sp,sp,-28
80129324:	de00012e 	bgeu	sp,et,8012932c <__s2b+0xc>
80129328:	003b68fa 	trap	3
8012932c:	dc400115 	stw	r17,4(sp)
80129330:	dc000015 	stw	r16,0(sp)
80129334:	2023883a 	mov	r17,r4
80129338:	2821883a 	mov	r16,r5
8012933c:	39000204 	addi	r4,r7,8
80129340:	01400244 	movi	r5,9
80129344:	dcc00315 	stw	r19,12(sp)
80129348:	dc800215 	stw	r18,8(sp)
8012934c:	dfc00615 	stw	ra,24(sp)
80129350:	dd400515 	stw	r21,20(sp)
80129354:	dd000415 	stw	r20,16(sp)
80129358:	3825883a 	mov	r18,r7
8012935c:	3027883a 	mov	r19,r6
80129360:	01301700 	call	80130170 <__divsi3>
80129364:	00c00044 	movi	r3,1
80129368:	000b883a 	mov	r5,zero
8012936c:	1880030e 	bge	r3,r2,8012937c <__s2b+0x5c>
80129370:	18c7883a 	add	r3,r3,r3
80129374:	29400044 	addi	r5,r5,1
80129378:	18bffd16 	blt	r3,r2,80129370 <__reset+0xfa109370>
8012937c:	8809883a 	mov	r4,r17
80129380:	01291200 	call	80129120 <_Balloc>
80129384:	d8c00717 	ldw	r3,28(sp)
80129388:	10c00515 	stw	r3,20(r2)
8012938c:	00c00044 	movi	r3,1
80129390:	10c00415 	stw	r3,16(r2)
80129394:	00c00244 	movi	r3,9
80129398:	1cc0210e 	bge	r3,r19,80129420 <__s2b+0x100>
8012939c:	80eb883a 	add	r21,r16,r3
801293a0:	a829883a 	mov	r20,r21
801293a4:	84e1883a 	add	r16,r16,r19
801293a8:	a1c00007 	ldb	r7,0(r20)
801293ac:	01800284 	movi	r6,10
801293b0:	a5000044 	addi	r20,r20,1
801293b4:	100b883a 	mov	r5,r2
801293b8:	39fff404 	addi	r7,r7,-48
801293bc:	8809883a 	mov	r4,r17
801293c0:	01291f80 	call	801291f8 <__multadd>
801293c4:	a43ff81e 	bne	r20,r16,801293a8 <__reset+0xfa1093a8>
801293c8:	ace1883a 	add	r16,r21,r19
801293cc:	843ffe04 	addi	r16,r16,-8
801293d0:	9c800a0e 	bge	r19,r18,801293fc <__s2b+0xdc>
801293d4:	94e5c83a 	sub	r18,r18,r19
801293d8:	84a5883a 	add	r18,r16,r18
801293dc:	81c00007 	ldb	r7,0(r16)
801293e0:	01800284 	movi	r6,10
801293e4:	84000044 	addi	r16,r16,1
801293e8:	100b883a 	mov	r5,r2
801293ec:	39fff404 	addi	r7,r7,-48
801293f0:	8809883a 	mov	r4,r17
801293f4:	01291f80 	call	801291f8 <__multadd>
801293f8:	84bff81e 	bne	r16,r18,801293dc <__reset+0xfa1093dc>
801293fc:	dfc00617 	ldw	ra,24(sp)
80129400:	dd400517 	ldw	r21,20(sp)
80129404:	dd000417 	ldw	r20,16(sp)
80129408:	dcc00317 	ldw	r19,12(sp)
8012940c:	dc800217 	ldw	r18,8(sp)
80129410:	dc400117 	ldw	r17,4(sp)
80129414:	dc000017 	ldw	r16,0(sp)
80129418:	dec00704 	addi	sp,sp,28
8012941c:	f800283a 	ret
80129420:	84000284 	addi	r16,r16,10
80129424:	1827883a 	mov	r19,r3
80129428:	003fe906 	br	801293d0 <__reset+0xfa1093d0>

8012942c <__hi0bits>:
8012942c:	20bfffec 	andhi	r2,r4,65535
80129430:	1000141e 	bne	r2,zero,80129484 <__hi0bits+0x58>
80129434:	2008943a 	slli	r4,r4,16
80129438:	00800404 	movi	r2,16
8012943c:	20ffc02c 	andhi	r3,r4,65280
80129440:	1800021e 	bne	r3,zero,8012944c <__hi0bits+0x20>
80129444:	2008923a 	slli	r4,r4,8
80129448:	10800204 	addi	r2,r2,8
8012944c:	20fc002c 	andhi	r3,r4,61440
80129450:	1800021e 	bne	r3,zero,8012945c <__hi0bits+0x30>
80129454:	2008913a 	slli	r4,r4,4
80129458:	10800104 	addi	r2,r2,4
8012945c:	20f0002c 	andhi	r3,r4,49152
80129460:	1800031e 	bne	r3,zero,80129470 <__hi0bits+0x44>
80129464:	2109883a 	add	r4,r4,r4
80129468:	10800084 	addi	r2,r2,2
8012946c:	2109883a 	add	r4,r4,r4
80129470:	20000316 	blt	r4,zero,80129480 <__hi0bits+0x54>
80129474:	2110002c 	andhi	r4,r4,16384
80129478:	2000041e 	bne	r4,zero,8012948c <__hi0bits+0x60>
8012947c:	00800804 	movi	r2,32
80129480:	f800283a 	ret
80129484:	0005883a 	mov	r2,zero
80129488:	003fec06 	br	8012943c <__reset+0xfa10943c>
8012948c:	10800044 	addi	r2,r2,1
80129490:	f800283a 	ret

80129494 <__lo0bits>:
80129494:	20c00017 	ldw	r3,0(r4)
80129498:	188001cc 	andi	r2,r3,7
8012949c:	10000826 	beq	r2,zero,801294c0 <__lo0bits+0x2c>
801294a0:	1880004c 	andi	r2,r3,1
801294a4:	1000211e 	bne	r2,zero,8012952c <__lo0bits+0x98>
801294a8:	1880008c 	andi	r2,r3,2
801294ac:	1000211e 	bne	r2,zero,80129534 <__lo0bits+0xa0>
801294b0:	1806d0ba 	srli	r3,r3,2
801294b4:	00800084 	movi	r2,2
801294b8:	20c00015 	stw	r3,0(r4)
801294bc:	f800283a 	ret
801294c0:	18bfffcc 	andi	r2,r3,65535
801294c4:	10001326 	beq	r2,zero,80129514 <__lo0bits+0x80>
801294c8:	0005883a 	mov	r2,zero
801294cc:	19403fcc 	andi	r5,r3,255
801294d0:	2800021e 	bne	r5,zero,801294dc <__lo0bits+0x48>
801294d4:	1806d23a 	srli	r3,r3,8
801294d8:	10800204 	addi	r2,r2,8
801294dc:	194003cc 	andi	r5,r3,15
801294e0:	2800021e 	bne	r5,zero,801294ec <__lo0bits+0x58>
801294e4:	1806d13a 	srli	r3,r3,4
801294e8:	10800104 	addi	r2,r2,4
801294ec:	194000cc 	andi	r5,r3,3
801294f0:	2800021e 	bne	r5,zero,801294fc <__lo0bits+0x68>
801294f4:	1806d0ba 	srli	r3,r3,2
801294f8:	10800084 	addi	r2,r2,2
801294fc:	1940004c 	andi	r5,r3,1
80129500:	2800081e 	bne	r5,zero,80129524 <__lo0bits+0x90>
80129504:	1806d07a 	srli	r3,r3,1
80129508:	1800051e 	bne	r3,zero,80129520 <__lo0bits+0x8c>
8012950c:	00800804 	movi	r2,32
80129510:	f800283a 	ret
80129514:	1806d43a 	srli	r3,r3,16
80129518:	00800404 	movi	r2,16
8012951c:	003feb06 	br	801294cc <__reset+0xfa1094cc>
80129520:	10800044 	addi	r2,r2,1
80129524:	20c00015 	stw	r3,0(r4)
80129528:	f800283a 	ret
8012952c:	0005883a 	mov	r2,zero
80129530:	f800283a 	ret
80129534:	1806d07a 	srli	r3,r3,1
80129538:	00800044 	movi	r2,1
8012953c:	20c00015 	stw	r3,0(r4)
80129540:	f800283a 	ret

80129544 <__i2b>:
80129544:	defffd04 	addi	sp,sp,-12
80129548:	de00012e 	bgeu	sp,et,80129550 <__i2b+0xc>
8012954c:	003b68fa 	trap	3
80129550:	dc000015 	stw	r16,0(sp)
80129554:	04000044 	movi	r16,1
80129558:	dc400115 	stw	r17,4(sp)
8012955c:	2823883a 	mov	r17,r5
80129560:	800b883a 	mov	r5,r16
80129564:	dfc00215 	stw	ra,8(sp)
80129568:	01291200 	call	80129120 <_Balloc>
8012956c:	14400515 	stw	r17,20(r2)
80129570:	14000415 	stw	r16,16(r2)
80129574:	dfc00217 	ldw	ra,8(sp)
80129578:	dc400117 	ldw	r17,4(sp)
8012957c:	dc000017 	ldw	r16,0(sp)
80129580:	dec00304 	addi	sp,sp,12
80129584:	f800283a 	ret

80129588 <__multiply>:
80129588:	defffa04 	addi	sp,sp,-24
8012958c:	de00012e 	bgeu	sp,et,80129594 <__multiply+0xc>
80129590:	003b68fa 	trap	3
80129594:	dcc00315 	stw	r19,12(sp)
80129598:	dc800215 	stw	r18,8(sp)
8012959c:	34c00417 	ldw	r19,16(r6)
801295a0:	2c800417 	ldw	r18,16(r5)
801295a4:	dd000415 	stw	r20,16(sp)
801295a8:	dc400115 	stw	r17,4(sp)
801295ac:	dfc00515 	stw	ra,20(sp)
801295b0:	dc000015 	stw	r16,0(sp)
801295b4:	2829883a 	mov	r20,r5
801295b8:	3023883a 	mov	r17,r6
801295bc:	94c0050e 	bge	r18,r19,801295d4 <__multiply+0x4c>
801295c0:	9007883a 	mov	r3,r18
801295c4:	3029883a 	mov	r20,r6
801295c8:	9825883a 	mov	r18,r19
801295cc:	2823883a 	mov	r17,r5
801295d0:	1827883a 	mov	r19,r3
801295d4:	a0800217 	ldw	r2,8(r20)
801295d8:	94e1883a 	add	r16,r18,r19
801295dc:	a1400117 	ldw	r5,4(r20)
801295e0:	1400010e 	bge	r2,r16,801295e8 <__multiply+0x60>
801295e4:	29400044 	addi	r5,r5,1
801295e8:	01291200 	call	80129120 <_Balloc>
801295ec:	8415883a 	add	r10,r16,r16
801295f0:	12c00504 	addi	r11,r2,20
801295f4:	5295883a 	add	r10,r10,r10
801295f8:	5a95883a 	add	r10,r11,r10
801295fc:	5807883a 	mov	r3,r11
80129600:	5a80032e 	bgeu	r11,r10,80129610 <__multiply+0x88>
80129604:	18000015 	stw	zero,0(r3)
80129608:	18c00104 	addi	r3,r3,4
8012960c:	1abffd36 	bltu	r3,r10,80129604 <__reset+0xfa109604>
80129610:	9ce7883a 	add	r19,r19,r19
80129614:	94a5883a 	add	r18,r18,r18
80129618:	89800504 	addi	r6,r17,20
8012961c:	9ce7883a 	add	r19,r19,r19
80129620:	a3400504 	addi	r13,r20,20
80129624:	94a5883a 	add	r18,r18,r18
80129628:	34d9883a 	add	r12,r6,r19
8012962c:	6c93883a 	add	r9,r13,r18
80129630:	3300422e 	bgeu	r6,r12,8012973c <__multiply+0x1b4>
80129634:	37c00017 	ldw	ra,0(r6)
80129638:	fbffffcc 	andi	r15,ra,65535
8012963c:	78001b26 	beq	r15,zero,801296ac <__multiply+0x124>
80129640:	5811883a 	mov	r8,r11
80129644:	681d883a 	mov	r14,r13
80129648:	000f883a 	mov	r7,zero
8012964c:	71000017 	ldw	r4,0(r14)
80129650:	40c00017 	ldw	r3,0(r8)
80129654:	73800104 	addi	r14,r14,4
80129658:	217fffcc 	andi	r5,r4,65535
8012965c:	2bcb383a 	mul	r5,r5,r15
80129660:	2008d43a 	srli	r4,r4,16
80129664:	1c7fffcc 	andi	r17,r3,65535
80129668:	2c4b883a 	add	r5,r5,r17
8012966c:	29cb883a 	add	r5,r5,r7
80129670:	23c9383a 	mul	r4,r4,r15
80129674:	1806d43a 	srli	r3,r3,16
80129678:	280ed43a 	srli	r7,r5,16
8012967c:	297fffcc 	andi	r5,r5,65535
80129680:	20c7883a 	add	r3,r4,r3
80129684:	19c7883a 	add	r3,r3,r7
80129688:	1808943a 	slli	r4,r3,16
8012968c:	4023883a 	mov	r17,r8
80129690:	180ed43a 	srli	r7,r3,16
80129694:	214ab03a 	or	r5,r4,r5
80129698:	41400015 	stw	r5,0(r8)
8012969c:	42000104 	addi	r8,r8,4
801296a0:	727fea36 	bltu	r14,r9,8012964c <__reset+0xfa10964c>
801296a4:	89c00115 	stw	r7,4(r17)
801296a8:	37c00017 	ldw	ra,0(r6)
801296ac:	f83ed43a 	srli	ra,ra,16
801296b0:	f8001f26 	beq	ra,zero,80129730 <__multiply+0x1a8>
801296b4:	58c00017 	ldw	r3,0(r11)
801296b8:	681d883a 	mov	r14,r13
801296bc:	581f883a 	mov	r15,r11
801296c0:	1811883a 	mov	r8,r3
801296c4:	5825883a 	mov	r18,r11
801296c8:	000f883a 	mov	r7,zero
801296cc:	00000106 	br	801296d4 <__multiply+0x14c>
801296d0:	8825883a 	mov	r18,r17
801296d4:	7140000b 	ldhu	r5,0(r14)
801296d8:	4010d43a 	srli	r8,r8,16
801296dc:	193fffcc 	andi	r4,r3,65535
801296e0:	2fcb383a 	mul	r5,r5,ra
801296e4:	7bc00104 	addi	r15,r15,4
801296e8:	73800104 	addi	r14,r14,4
801296ec:	2a0b883a 	add	r5,r5,r8
801296f0:	29cb883a 	add	r5,r5,r7
801296f4:	2806943a 	slli	r3,r5,16
801296f8:	94400104 	addi	r17,r18,4
801296fc:	280ad43a 	srli	r5,r5,16
80129700:	1908b03a 	or	r4,r3,r4
80129704:	793fff15 	stw	r4,-4(r15)
80129708:	70ffff17 	ldw	r3,-4(r14)
8012970c:	8a000017 	ldw	r8,0(r17)
80129710:	1806d43a 	srli	r3,r3,16
80129714:	413fffcc 	andi	r4,r8,65535
80129718:	1fc7383a 	mul	r3,r3,ra
8012971c:	1907883a 	add	r3,r3,r4
80129720:	1947883a 	add	r3,r3,r5
80129724:	180ed43a 	srli	r7,r3,16
80129728:	727fe936 	bltu	r14,r9,801296d0 <__reset+0xfa1096d0>
8012972c:	90c00115 	stw	r3,4(r18)
80129730:	31800104 	addi	r6,r6,4
80129734:	5ac00104 	addi	r11,r11,4
80129738:	333fbe36 	bltu	r6,r12,80129634 <__reset+0xfa109634>
8012973c:	0400090e 	bge	zero,r16,80129764 <__multiply+0x1dc>
80129740:	50ffff17 	ldw	r3,-4(r10)
80129744:	52bfff04 	addi	r10,r10,-4
80129748:	18000326 	beq	r3,zero,80129758 <__multiply+0x1d0>
8012974c:	00000506 	br	80129764 <__multiply+0x1dc>
80129750:	50c00017 	ldw	r3,0(r10)
80129754:	1800031e 	bne	r3,zero,80129764 <__multiply+0x1dc>
80129758:	843fffc4 	addi	r16,r16,-1
8012975c:	52bfff04 	addi	r10,r10,-4
80129760:	803ffb1e 	bne	r16,zero,80129750 <__reset+0xfa109750>
80129764:	14000415 	stw	r16,16(r2)
80129768:	dfc00517 	ldw	ra,20(sp)
8012976c:	dd000417 	ldw	r20,16(sp)
80129770:	dcc00317 	ldw	r19,12(sp)
80129774:	dc800217 	ldw	r18,8(sp)
80129778:	dc400117 	ldw	r17,4(sp)
8012977c:	dc000017 	ldw	r16,0(sp)
80129780:	dec00604 	addi	sp,sp,24
80129784:	f800283a 	ret

80129788 <__pow5mult>:
80129788:	defffa04 	addi	sp,sp,-24
8012978c:	de00012e 	bgeu	sp,et,80129794 <__pow5mult+0xc>
80129790:	003b68fa 	trap	3
80129794:	308000cc 	andi	r2,r6,3
80129798:	dcc00315 	stw	r19,12(sp)
8012979c:	dc000015 	stw	r16,0(sp)
801297a0:	dfc00515 	stw	ra,20(sp)
801297a4:	dd000415 	stw	r20,16(sp)
801297a8:	dc800215 	stw	r18,8(sp)
801297ac:	dc400115 	stw	r17,4(sp)
801297b0:	3021883a 	mov	r16,r6
801297b4:	2027883a 	mov	r19,r4
801297b8:	10002f1e 	bne	r2,zero,80129878 <__pow5mult+0xf0>
801297bc:	2825883a 	mov	r18,r5
801297c0:	8021d0ba 	srai	r16,r16,2
801297c4:	80001a26 	beq	r16,zero,80129830 <__pow5mult+0xa8>
801297c8:	9c401217 	ldw	r17,72(r19)
801297cc:	8800061e 	bne	r17,zero,801297e8 <__pow5mult+0x60>
801297d0:	00003406 	br	801298a4 <__pow5mult+0x11c>
801297d4:	8021d07a 	srai	r16,r16,1
801297d8:	80001526 	beq	r16,zero,80129830 <__pow5mult+0xa8>
801297dc:	88800017 	ldw	r2,0(r17)
801297e0:	10001c26 	beq	r2,zero,80129854 <__pow5mult+0xcc>
801297e4:	1023883a 	mov	r17,r2
801297e8:	8080004c 	andi	r2,r16,1
801297ec:	103ff926 	beq	r2,zero,801297d4 <__reset+0xfa1097d4>
801297f0:	880d883a 	mov	r6,r17
801297f4:	900b883a 	mov	r5,r18
801297f8:	9809883a 	mov	r4,r19
801297fc:	01295880 	call	80129588 <__multiply>
80129800:	90001b26 	beq	r18,zero,80129870 <__pow5mult+0xe8>
80129804:	91000117 	ldw	r4,4(r18)
80129808:	98c01317 	ldw	r3,76(r19)
8012980c:	8021d07a 	srai	r16,r16,1
80129810:	2109883a 	add	r4,r4,r4
80129814:	2109883a 	add	r4,r4,r4
80129818:	1907883a 	add	r3,r3,r4
8012981c:	19000017 	ldw	r4,0(r3)
80129820:	91000015 	stw	r4,0(r18)
80129824:	1c800015 	stw	r18,0(r3)
80129828:	1025883a 	mov	r18,r2
8012982c:	803feb1e 	bne	r16,zero,801297dc <__reset+0xfa1097dc>
80129830:	9005883a 	mov	r2,r18
80129834:	dfc00517 	ldw	ra,20(sp)
80129838:	dd000417 	ldw	r20,16(sp)
8012983c:	dcc00317 	ldw	r19,12(sp)
80129840:	dc800217 	ldw	r18,8(sp)
80129844:	dc400117 	ldw	r17,4(sp)
80129848:	dc000017 	ldw	r16,0(sp)
8012984c:	dec00604 	addi	sp,sp,24
80129850:	f800283a 	ret
80129854:	880d883a 	mov	r6,r17
80129858:	880b883a 	mov	r5,r17
8012985c:	9809883a 	mov	r4,r19
80129860:	01295880 	call	80129588 <__multiply>
80129864:	88800015 	stw	r2,0(r17)
80129868:	10000015 	stw	zero,0(r2)
8012986c:	003fdd06 	br	801297e4 <__reset+0xfa1097e4>
80129870:	1025883a 	mov	r18,r2
80129874:	003fd706 	br	801297d4 <__reset+0xfa1097d4>
80129878:	10bfffc4 	addi	r2,r2,-1
8012987c:	1085883a 	add	r2,r2,r2
80129880:	00e00534 	movhi	r3,32788
80129884:	18deeb04 	addi	r3,r3,31660
80129888:	1085883a 	add	r2,r2,r2
8012988c:	1885883a 	add	r2,r3,r2
80129890:	11800017 	ldw	r6,0(r2)
80129894:	000f883a 	mov	r7,zero
80129898:	01291f80 	call	801291f8 <__multadd>
8012989c:	1025883a 	mov	r18,r2
801298a0:	003fc706 	br	801297c0 <__reset+0xfa1097c0>
801298a4:	05000044 	movi	r20,1
801298a8:	a00b883a 	mov	r5,r20
801298ac:	9809883a 	mov	r4,r19
801298b0:	01291200 	call	80129120 <_Balloc>
801298b4:	1023883a 	mov	r17,r2
801298b8:	00809c44 	movi	r2,625
801298bc:	88800515 	stw	r2,20(r17)
801298c0:	8d000415 	stw	r20,16(r17)
801298c4:	9c401215 	stw	r17,72(r19)
801298c8:	88000015 	stw	zero,0(r17)
801298cc:	003fc606 	br	801297e8 <__reset+0xfa1097e8>

801298d0 <__lshift>:
801298d0:	defff904 	addi	sp,sp,-28
801298d4:	de00012e 	bgeu	sp,et,801298dc <__lshift+0xc>
801298d8:	003b68fa 	trap	3
801298dc:	dd400515 	stw	r21,20(sp)
801298e0:	dcc00315 	stw	r19,12(sp)
801298e4:	302bd17a 	srai	r21,r6,5
801298e8:	2cc00417 	ldw	r19,16(r5)
801298ec:	28800217 	ldw	r2,8(r5)
801298f0:	dd000415 	stw	r20,16(sp)
801298f4:	ace7883a 	add	r19,r21,r19
801298f8:	dc800215 	stw	r18,8(sp)
801298fc:	dc400115 	stw	r17,4(sp)
80129900:	dc000015 	stw	r16,0(sp)
80129904:	dfc00615 	stw	ra,24(sp)
80129908:	9c000044 	addi	r16,r19,1
8012990c:	2823883a 	mov	r17,r5
80129910:	3029883a 	mov	r20,r6
80129914:	2025883a 	mov	r18,r4
80129918:	29400117 	ldw	r5,4(r5)
8012991c:	1400030e 	bge	r2,r16,8012992c <__lshift+0x5c>
80129920:	1085883a 	add	r2,r2,r2
80129924:	29400044 	addi	r5,r5,1
80129928:	143ffd16 	blt	r2,r16,80129920 <__reset+0xfa109920>
8012992c:	9009883a 	mov	r4,r18
80129930:	01291200 	call	80129120 <_Balloc>
80129934:	10c00504 	addi	r3,r2,20
80129938:	0540070e 	bge	zero,r21,80129958 <__lshift+0x88>
8012993c:	ad6b883a 	add	r21,r21,r21
80129940:	ad6b883a 	add	r21,r21,r21
80129944:	1809883a 	mov	r4,r3
80129948:	1d47883a 	add	r3,r3,r21
8012994c:	20000015 	stw	zero,0(r4)
80129950:	21000104 	addi	r4,r4,4
80129954:	193ffd1e 	bne	r3,r4,8012994c <__reset+0xfa10994c>
80129958:	8a000417 	ldw	r8,16(r17)
8012995c:	89000504 	addi	r4,r17,20
80129960:	a18007cc 	andi	r6,r20,31
80129964:	4211883a 	add	r8,r8,r8
80129968:	4211883a 	add	r8,r8,r8
8012996c:	2211883a 	add	r8,r4,r8
80129970:	30002326 	beq	r6,zero,80129a00 <__lshift+0x130>
80129974:	02400804 	movi	r9,32
80129978:	4993c83a 	sub	r9,r9,r6
8012997c:	000b883a 	mov	r5,zero
80129980:	21c00017 	ldw	r7,0(r4)
80129984:	1815883a 	mov	r10,r3
80129988:	18c00104 	addi	r3,r3,4
8012998c:	398e983a 	sll	r7,r7,r6
80129990:	21000104 	addi	r4,r4,4
80129994:	394ab03a 	or	r5,r7,r5
80129998:	197fff15 	stw	r5,-4(r3)
8012999c:	217fff17 	ldw	r5,-4(r4)
801299a0:	2a4ad83a 	srl	r5,r5,r9
801299a4:	223ff636 	bltu	r4,r8,80129980 <__reset+0xfa109980>
801299a8:	51400115 	stw	r5,4(r10)
801299ac:	28001a1e 	bne	r5,zero,80129a18 <__lshift+0x148>
801299b0:	843fffc4 	addi	r16,r16,-1
801299b4:	14000415 	stw	r16,16(r2)
801299b8:	88000826 	beq	r17,zero,801299dc <__lshift+0x10c>
801299bc:	89000117 	ldw	r4,4(r17)
801299c0:	90c01317 	ldw	r3,76(r18)
801299c4:	2109883a 	add	r4,r4,r4
801299c8:	2109883a 	add	r4,r4,r4
801299cc:	1907883a 	add	r3,r3,r4
801299d0:	19000017 	ldw	r4,0(r3)
801299d4:	89000015 	stw	r4,0(r17)
801299d8:	1c400015 	stw	r17,0(r3)
801299dc:	dfc00617 	ldw	ra,24(sp)
801299e0:	dd400517 	ldw	r21,20(sp)
801299e4:	dd000417 	ldw	r20,16(sp)
801299e8:	dcc00317 	ldw	r19,12(sp)
801299ec:	dc800217 	ldw	r18,8(sp)
801299f0:	dc400117 	ldw	r17,4(sp)
801299f4:	dc000017 	ldw	r16,0(sp)
801299f8:	dec00704 	addi	sp,sp,28
801299fc:	f800283a 	ret
80129a00:	21400017 	ldw	r5,0(r4)
80129a04:	18c00104 	addi	r3,r3,4
80129a08:	21000104 	addi	r4,r4,4
80129a0c:	197fff15 	stw	r5,-4(r3)
80129a10:	223ffb36 	bltu	r4,r8,80129a00 <__reset+0xfa109a00>
80129a14:	003fe606 	br	801299b0 <__reset+0xfa1099b0>
80129a18:	9c000084 	addi	r16,r19,2
80129a1c:	003fe406 	br	801299b0 <__reset+0xfa1099b0>

80129a20 <__mcmp>:
80129a20:	20800417 	ldw	r2,16(r4)
80129a24:	28c00417 	ldw	r3,16(r5)
80129a28:	10c5c83a 	sub	r2,r2,r3
80129a2c:	1000111e 	bne	r2,zero,80129a74 <__mcmp+0x54>
80129a30:	18c7883a 	add	r3,r3,r3
80129a34:	18c7883a 	add	r3,r3,r3
80129a38:	21000504 	addi	r4,r4,20
80129a3c:	29400504 	addi	r5,r5,20
80129a40:	20c5883a 	add	r2,r4,r3
80129a44:	28cb883a 	add	r5,r5,r3
80129a48:	00000106 	br	80129a50 <__mcmp+0x30>
80129a4c:	20800a2e 	bgeu	r4,r2,80129a78 <__mcmp+0x58>
80129a50:	10bfff04 	addi	r2,r2,-4
80129a54:	297fff04 	addi	r5,r5,-4
80129a58:	11800017 	ldw	r6,0(r2)
80129a5c:	28c00017 	ldw	r3,0(r5)
80129a60:	30fffa26 	beq	r6,r3,80129a4c <__reset+0xfa109a4c>
80129a64:	30c00236 	bltu	r6,r3,80129a70 <__mcmp+0x50>
80129a68:	00800044 	movi	r2,1
80129a6c:	f800283a 	ret
80129a70:	00bfffc4 	movi	r2,-1
80129a74:	f800283a 	ret
80129a78:	0005883a 	mov	r2,zero
80129a7c:	f800283a 	ret

80129a80 <__mdiff>:
80129a80:	defffa04 	addi	sp,sp,-24
80129a84:	de00012e 	bgeu	sp,et,80129a8c <__mdiff+0xc>
80129a88:	003b68fa 	trap	3
80129a8c:	28c00417 	ldw	r3,16(r5)
80129a90:	30800417 	ldw	r2,16(r6)
80129a94:	dcc00315 	stw	r19,12(sp)
80129a98:	dc800215 	stw	r18,8(sp)
80129a9c:	dfc00515 	stw	ra,20(sp)
80129aa0:	dd000415 	stw	r20,16(sp)
80129aa4:	dc400115 	stw	r17,4(sp)
80129aa8:	dc000015 	stw	r16,0(sp)
80129aac:	1887c83a 	sub	r3,r3,r2
80129ab0:	2825883a 	mov	r18,r5
80129ab4:	3027883a 	mov	r19,r6
80129ab8:	1800141e 	bne	r3,zero,80129b0c <__mdiff+0x8c>
80129abc:	1085883a 	add	r2,r2,r2
80129ac0:	1085883a 	add	r2,r2,r2
80129ac4:	2a000504 	addi	r8,r5,20
80129ac8:	34000504 	addi	r16,r6,20
80129acc:	4087883a 	add	r3,r8,r2
80129ad0:	8085883a 	add	r2,r16,r2
80129ad4:	00000106 	br	80129adc <__mdiff+0x5c>
80129ad8:	40c0592e 	bgeu	r8,r3,80129c40 <__mdiff+0x1c0>
80129adc:	18ffff04 	addi	r3,r3,-4
80129ae0:	10bfff04 	addi	r2,r2,-4
80129ae4:	19c00017 	ldw	r7,0(r3)
80129ae8:	11400017 	ldw	r5,0(r2)
80129aec:	397ffa26 	beq	r7,r5,80129ad8 <__reset+0xfa109ad8>
80129af0:	3940592e 	bgeu	r7,r5,80129c58 <__mdiff+0x1d8>
80129af4:	9005883a 	mov	r2,r18
80129af8:	4023883a 	mov	r17,r8
80129afc:	9825883a 	mov	r18,r19
80129b00:	05000044 	movi	r20,1
80129b04:	1027883a 	mov	r19,r2
80129b08:	00000406 	br	80129b1c <__mdiff+0x9c>
80129b0c:	18005616 	blt	r3,zero,80129c68 <__mdiff+0x1e8>
80129b10:	34400504 	addi	r17,r6,20
80129b14:	2c000504 	addi	r16,r5,20
80129b18:	0029883a 	mov	r20,zero
80129b1c:	91400117 	ldw	r5,4(r18)
80129b20:	01291200 	call	80129120 <_Balloc>
80129b24:	92400417 	ldw	r9,16(r18)
80129b28:	9b000417 	ldw	r12,16(r19)
80129b2c:	12c00504 	addi	r11,r2,20
80129b30:	4a51883a 	add	r8,r9,r9
80129b34:	6319883a 	add	r12,r12,r12
80129b38:	4211883a 	add	r8,r8,r8
80129b3c:	6319883a 	add	r12,r12,r12
80129b40:	15000315 	stw	r20,12(r2)
80129b44:	8211883a 	add	r8,r16,r8
80129b48:	8b19883a 	add	r12,r17,r12
80129b4c:	0007883a 	mov	r3,zero
80129b50:	81400017 	ldw	r5,0(r16)
80129b54:	89c00017 	ldw	r7,0(r17)
80129b58:	59800104 	addi	r6,r11,4
80129b5c:	293fffcc 	andi	r4,r5,65535
80129b60:	20c7883a 	add	r3,r4,r3
80129b64:	393fffcc 	andi	r4,r7,65535
80129b68:	1909c83a 	sub	r4,r3,r4
80129b6c:	280ad43a 	srli	r5,r5,16
80129b70:	380ed43a 	srli	r7,r7,16
80129b74:	2007d43a 	srai	r3,r4,16
80129b78:	213fffcc 	andi	r4,r4,65535
80129b7c:	29cbc83a 	sub	r5,r5,r7
80129b80:	28c7883a 	add	r3,r5,r3
80129b84:	180a943a 	slli	r5,r3,16
80129b88:	8c400104 	addi	r17,r17,4
80129b8c:	84000104 	addi	r16,r16,4
80129b90:	2908b03a 	or	r4,r5,r4
80129b94:	59000015 	stw	r4,0(r11)
80129b98:	1807d43a 	srai	r3,r3,16
80129b9c:	3015883a 	mov	r10,r6
80129ba0:	3017883a 	mov	r11,r6
80129ba4:	8b3fea36 	bltu	r17,r12,80129b50 <__reset+0xfa109b50>
80129ba8:	8200162e 	bgeu	r16,r8,80129c04 <__mdiff+0x184>
80129bac:	8017883a 	mov	r11,r16
80129bb0:	59400017 	ldw	r5,0(r11)
80129bb4:	31800104 	addi	r6,r6,4
80129bb8:	5ac00104 	addi	r11,r11,4
80129bbc:	293fffcc 	andi	r4,r5,65535
80129bc0:	20c7883a 	add	r3,r4,r3
80129bc4:	280ed43a 	srli	r7,r5,16
80129bc8:	180bd43a 	srai	r5,r3,16
80129bcc:	193fffcc 	andi	r4,r3,65535
80129bd0:	3947883a 	add	r3,r7,r5
80129bd4:	180a943a 	slli	r5,r3,16
80129bd8:	1807d43a 	srai	r3,r3,16
80129bdc:	2908b03a 	or	r4,r5,r4
80129be0:	313fff15 	stw	r4,-4(r6)
80129be4:	5a3ff236 	bltu	r11,r8,80129bb0 <__reset+0xfa109bb0>
80129be8:	0406303a 	nor	r3,zero,r16
80129bec:	1a07883a 	add	r3,r3,r8
80129bf0:	1806d0ba 	srli	r3,r3,2
80129bf4:	18c00044 	addi	r3,r3,1
80129bf8:	18c7883a 	add	r3,r3,r3
80129bfc:	18c7883a 	add	r3,r3,r3
80129c00:	50d5883a 	add	r10,r10,r3
80129c04:	50ffff04 	addi	r3,r10,-4
80129c08:	2000041e 	bne	r4,zero,80129c1c <__mdiff+0x19c>
80129c0c:	18ffff04 	addi	r3,r3,-4
80129c10:	19000017 	ldw	r4,0(r3)
80129c14:	4a7fffc4 	addi	r9,r9,-1
80129c18:	203ffc26 	beq	r4,zero,80129c0c <__reset+0xfa109c0c>
80129c1c:	12400415 	stw	r9,16(r2)
80129c20:	dfc00517 	ldw	ra,20(sp)
80129c24:	dd000417 	ldw	r20,16(sp)
80129c28:	dcc00317 	ldw	r19,12(sp)
80129c2c:	dc800217 	ldw	r18,8(sp)
80129c30:	dc400117 	ldw	r17,4(sp)
80129c34:	dc000017 	ldw	r16,0(sp)
80129c38:	dec00604 	addi	sp,sp,24
80129c3c:	f800283a 	ret
80129c40:	000b883a 	mov	r5,zero
80129c44:	01291200 	call	80129120 <_Balloc>
80129c48:	00c00044 	movi	r3,1
80129c4c:	10c00415 	stw	r3,16(r2)
80129c50:	10000515 	stw	zero,20(r2)
80129c54:	003ff206 	br	80129c20 <__reset+0xfa109c20>
80129c58:	8023883a 	mov	r17,r16
80129c5c:	0029883a 	mov	r20,zero
80129c60:	4021883a 	mov	r16,r8
80129c64:	003fad06 	br	80129b1c <__reset+0xfa109b1c>
80129c68:	9005883a 	mov	r2,r18
80129c6c:	94400504 	addi	r17,r18,20
80129c70:	9c000504 	addi	r16,r19,20
80129c74:	9825883a 	mov	r18,r19
80129c78:	05000044 	movi	r20,1
80129c7c:	1027883a 	mov	r19,r2
80129c80:	003fa606 	br	80129b1c <__reset+0xfa109b1c>

80129c84 <__ulp>:
80129c84:	295ffc2c 	andhi	r5,r5,32752
80129c88:	00bf3034 	movhi	r2,64704
80129c8c:	2887883a 	add	r3,r5,r2
80129c90:	00c0020e 	bge	zero,r3,80129c9c <__ulp+0x18>
80129c94:	0005883a 	mov	r2,zero
80129c98:	f800283a 	ret
80129c9c:	00c7c83a 	sub	r3,zero,r3
80129ca0:	1807d53a 	srai	r3,r3,20
80129ca4:	008004c4 	movi	r2,19
80129ca8:	10c00b0e 	bge	r2,r3,80129cd8 <__ulp+0x54>
80129cac:	18bffb04 	addi	r2,r3,-20
80129cb0:	01000784 	movi	r4,30
80129cb4:	0007883a 	mov	r3,zero
80129cb8:	20800516 	blt	r4,r2,80129cd0 <__ulp+0x4c>
80129cbc:	010007c4 	movi	r4,31
80129cc0:	2089c83a 	sub	r4,r4,r2
80129cc4:	00800044 	movi	r2,1
80129cc8:	1104983a 	sll	r2,r2,r4
80129ccc:	f800283a 	ret
80129cd0:	00800044 	movi	r2,1
80129cd4:	f800283a 	ret
80129cd8:	01400234 	movhi	r5,8
80129cdc:	28c7d83a 	sra	r3,r5,r3
80129ce0:	0005883a 	mov	r2,zero
80129ce4:	f800283a 	ret

80129ce8 <__b2d>:
80129ce8:	defffa04 	addi	sp,sp,-24
80129cec:	de00012e 	bgeu	sp,et,80129cf4 <__b2d+0xc>
80129cf0:	003b68fa 	trap	3
80129cf4:	dc000015 	stw	r16,0(sp)
80129cf8:	24000417 	ldw	r16,16(r4)
80129cfc:	dc400115 	stw	r17,4(sp)
80129d00:	24400504 	addi	r17,r4,20
80129d04:	8421883a 	add	r16,r16,r16
80129d08:	8421883a 	add	r16,r16,r16
80129d0c:	8c21883a 	add	r16,r17,r16
80129d10:	dc800215 	stw	r18,8(sp)
80129d14:	84bfff17 	ldw	r18,-4(r16)
80129d18:	dd000415 	stw	r20,16(sp)
80129d1c:	dcc00315 	stw	r19,12(sp)
80129d20:	9009883a 	mov	r4,r18
80129d24:	2829883a 	mov	r20,r5
80129d28:	dfc00515 	stw	ra,20(sp)
80129d2c:	012942c0 	call	8012942c <__hi0bits>
80129d30:	00c00804 	movi	r3,32
80129d34:	1889c83a 	sub	r4,r3,r2
80129d38:	a1000015 	stw	r4,0(r20)
80129d3c:	01000284 	movi	r4,10
80129d40:	84ffff04 	addi	r19,r16,-4
80129d44:	20801216 	blt	r4,r2,80129d90 <__b2d+0xa8>
80129d48:	018002c4 	movi	r6,11
80129d4c:	308dc83a 	sub	r6,r6,r2
80129d50:	9186d83a 	srl	r3,r18,r6
80129d54:	18cffc34 	orhi	r3,r3,16368
80129d58:	8cc0212e 	bgeu	r17,r19,80129de0 <__b2d+0xf8>
80129d5c:	813ffe17 	ldw	r4,-8(r16)
80129d60:	218cd83a 	srl	r6,r4,r6
80129d64:	10800544 	addi	r2,r2,21
80129d68:	9084983a 	sll	r2,r18,r2
80129d6c:	1184b03a 	or	r2,r2,r6
80129d70:	dfc00517 	ldw	ra,20(sp)
80129d74:	dd000417 	ldw	r20,16(sp)
80129d78:	dcc00317 	ldw	r19,12(sp)
80129d7c:	dc800217 	ldw	r18,8(sp)
80129d80:	dc400117 	ldw	r17,4(sp)
80129d84:	dc000017 	ldw	r16,0(sp)
80129d88:	dec00604 	addi	sp,sp,24
80129d8c:	f800283a 	ret
80129d90:	8cc00f2e 	bgeu	r17,r19,80129dd0 <__b2d+0xe8>
80129d94:	117ffd44 	addi	r5,r2,-11
80129d98:	80bffe17 	ldw	r2,-8(r16)
80129d9c:	28000e26 	beq	r5,zero,80129dd8 <__b2d+0xf0>
80129da0:	1949c83a 	sub	r4,r3,r5
80129da4:	9164983a 	sll	r18,r18,r5
80129da8:	1106d83a 	srl	r3,r2,r4
80129dac:	81bffe04 	addi	r6,r16,-8
80129db0:	948ffc34 	orhi	r18,r18,16368
80129db4:	90c6b03a 	or	r3,r18,r3
80129db8:	89800e2e 	bgeu	r17,r6,80129df4 <__b2d+0x10c>
80129dbc:	81bffd17 	ldw	r6,-12(r16)
80129dc0:	1144983a 	sll	r2,r2,r5
80129dc4:	310ad83a 	srl	r5,r6,r4
80129dc8:	2884b03a 	or	r2,r5,r2
80129dcc:	003fe806 	br	80129d70 <__reset+0xfa109d70>
80129dd0:	10bffd44 	addi	r2,r2,-11
80129dd4:	1000041e 	bne	r2,zero,80129de8 <__b2d+0x100>
80129dd8:	90cffc34 	orhi	r3,r18,16368
80129ddc:	003fe406 	br	80129d70 <__reset+0xfa109d70>
80129de0:	000d883a 	mov	r6,zero
80129de4:	003fdf06 	br	80129d64 <__reset+0xfa109d64>
80129de8:	90a4983a 	sll	r18,r18,r2
80129dec:	0005883a 	mov	r2,zero
80129df0:	003ff906 	br	80129dd8 <__reset+0xfa109dd8>
80129df4:	1144983a 	sll	r2,r2,r5
80129df8:	003fdd06 	br	80129d70 <__reset+0xfa109d70>

80129dfc <__d2b>:
80129dfc:	defff804 	addi	sp,sp,-32
80129e00:	de00012e 	bgeu	sp,et,80129e08 <__d2b+0xc>
80129e04:	003b68fa 	trap	3
80129e08:	dc000215 	stw	r16,8(sp)
80129e0c:	3021883a 	mov	r16,r6
80129e10:	dc400315 	stw	r17,12(sp)
80129e14:	8022907a 	slli	r17,r16,1
80129e18:	dd000615 	stw	r20,24(sp)
80129e1c:	2829883a 	mov	r20,r5
80129e20:	01400044 	movi	r5,1
80129e24:	dcc00515 	stw	r19,20(sp)
80129e28:	dc800415 	stw	r18,16(sp)
80129e2c:	dfc00715 	stw	ra,28(sp)
80129e30:	3825883a 	mov	r18,r7
80129e34:	8822d57a 	srli	r17,r17,21
80129e38:	01291200 	call	80129120 <_Balloc>
80129e3c:	1027883a 	mov	r19,r2
80129e40:	00800434 	movhi	r2,16
80129e44:	10bfffc4 	addi	r2,r2,-1
80129e48:	808c703a 	and	r6,r16,r2
80129e4c:	88000126 	beq	r17,zero,80129e54 <__d2b+0x58>
80129e50:	31800434 	orhi	r6,r6,16
80129e54:	d9800015 	stw	r6,0(sp)
80129e58:	a0002426 	beq	r20,zero,80129eec <__d2b+0xf0>
80129e5c:	d9000104 	addi	r4,sp,4
80129e60:	dd000115 	stw	r20,4(sp)
80129e64:	01294940 	call	80129494 <__lo0bits>
80129e68:	d8c00017 	ldw	r3,0(sp)
80129e6c:	10002f1e 	bne	r2,zero,80129f2c <__d2b+0x130>
80129e70:	d9000117 	ldw	r4,4(sp)
80129e74:	99000515 	stw	r4,20(r19)
80129e78:	1821003a 	cmpeq	r16,r3,zero
80129e7c:	01000084 	movi	r4,2
80129e80:	2421c83a 	sub	r16,r4,r16
80129e84:	98c00615 	stw	r3,24(r19)
80129e88:	9c000415 	stw	r16,16(r19)
80129e8c:	88001f1e 	bne	r17,zero,80129f0c <__d2b+0x110>
80129e90:	10bef384 	addi	r2,r2,-1074
80129e94:	90800015 	stw	r2,0(r18)
80129e98:	00900034 	movhi	r2,16384
80129e9c:	10bfffc4 	addi	r2,r2,-1
80129ea0:	8085883a 	add	r2,r16,r2
80129ea4:	1085883a 	add	r2,r2,r2
80129ea8:	1085883a 	add	r2,r2,r2
80129eac:	9885883a 	add	r2,r19,r2
80129eb0:	11000517 	ldw	r4,20(r2)
80129eb4:	8020917a 	slli	r16,r16,5
80129eb8:	012942c0 	call	8012942c <__hi0bits>
80129ebc:	d8c00817 	ldw	r3,32(sp)
80129ec0:	8085c83a 	sub	r2,r16,r2
80129ec4:	18800015 	stw	r2,0(r3)
80129ec8:	9805883a 	mov	r2,r19
80129ecc:	dfc00717 	ldw	ra,28(sp)
80129ed0:	dd000617 	ldw	r20,24(sp)
80129ed4:	dcc00517 	ldw	r19,20(sp)
80129ed8:	dc800417 	ldw	r18,16(sp)
80129edc:	dc400317 	ldw	r17,12(sp)
80129ee0:	dc000217 	ldw	r16,8(sp)
80129ee4:	dec00804 	addi	sp,sp,32
80129ee8:	f800283a 	ret
80129eec:	d809883a 	mov	r4,sp
80129ef0:	01294940 	call	80129494 <__lo0bits>
80129ef4:	d8c00017 	ldw	r3,0(sp)
80129ef8:	04000044 	movi	r16,1
80129efc:	9c000415 	stw	r16,16(r19)
80129f00:	98c00515 	stw	r3,20(r19)
80129f04:	10800804 	addi	r2,r2,32
80129f08:	883fe126 	beq	r17,zero,80129e90 <__reset+0xfa109e90>
80129f0c:	00c00d44 	movi	r3,53
80129f10:	8c7ef344 	addi	r17,r17,-1075
80129f14:	88a3883a 	add	r17,r17,r2
80129f18:	1885c83a 	sub	r2,r3,r2
80129f1c:	d8c00817 	ldw	r3,32(sp)
80129f20:	94400015 	stw	r17,0(r18)
80129f24:	18800015 	stw	r2,0(r3)
80129f28:	003fe706 	br	80129ec8 <__reset+0xfa109ec8>
80129f2c:	01000804 	movi	r4,32
80129f30:	2089c83a 	sub	r4,r4,r2
80129f34:	1908983a 	sll	r4,r3,r4
80129f38:	d9400117 	ldw	r5,4(sp)
80129f3c:	1886d83a 	srl	r3,r3,r2
80129f40:	2148b03a 	or	r4,r4,r5
80129f44:	99000515 	stw	r4,20(r19)
80129f48:	d8c00015 	stw	r3,0(sp)
80129f4c:	003fca06 	br	80129e78 <__reset+0xfa109e78>

80129f50 <__ratio>:
80129f50:	defff904 	addi	sp,sp,-28
80129f54:	de00012e 	bgeu	sp,et,80129f5c <__ratio+0xc>
80129f58:	003b68fa 	trap	3
80129f5c:	dc400315 	stw	r17,12(sp)
80129f60:	2823883a 	mov	r17,r5
80129f64:	d9400104 	addi	r5,sp,4
80129f68:	dfc00615 	stw	ra,24(sp)
80129f6c:	dcc00515 	stw	r19,20(sp)
80129f70:	dc800415 	stw	r18,16(sp)
80129f74:	2027883a 	mov	r19,r4
80129f78:	dc000215 	stw	r16,8(sp)
80129f7c:	0129ce80 	call	80129ce8 <__b2d>
80129f80:	d80b883a 	mov	r5,sp
80129f84:	8809883a 	mov	r4,r17
80129f88:	1025883a 	mov	r18,r2
80129f8c:	1821883a 	mov	r16,r3
80129f90:	0129ce80 	call	80129ce8 <__b2d>
80129f94:	8a000417 	ldw	r8,16(r17)
80129f98:	99000417 	ldw	r4,16(r19)
80129f9c:	d9400117 	ldw	r5,4(sp)
80129fa0:	2209c83a 	sub	r4,r4,r8
80129fa4:	2010917a 	slli	r8,r4,5
80129fa8:	d9000017 	ldw	r4,0(sp)
80129fac:	2909c83a 	sub	r4,r5,r4
80129fb0:	4109883a 	add	r4,r8,r4
80129fb4:	01000e0e 	bge	zero,r4,80129ff0 <__ratio+0xa0>
80129fb8:	2008953a 	slli	r4,r4,20
80129fbc:	2421883a 	add	r16,r4,r16
80129fc0:	100d883a 	mov	r6,r2
80129fc4:	180f883a 	mov	r7,r3
80129fc8:	9009883a 	mov	r4,r18
80129fcc:	800b883a 	mov	r5,r16
80129fd0:	0130dd40 	call	80130dd4 <__divdf3>
80129fd4:	dfc00617 	ldw	ra,24(sp)
80129fd8:	dcc00517 	ldw	r19,20(sp)
80129fdc:	dc800417 	ldw	r18,16(sp)
80129fe0:	dc400317 	ldw	r17,12(sp)
80129fe4:	dc000217 	ldw	r16,8(sp)
80129fe8:	dec00704 	addi	sp,sp,28
80129fec:	f800283a 	ret
80129ff0:	2008953a 	slli	r4,r4,20
80129ff4:	1907c83a 	sub	r3,r3,r4
80129ff8:	003ff106 	br	80129fc0 <__reset+0xfa109fc0>

80129ffc <_mprec_log10>:
80129ffc:	defffe04 	addi	sp,sp,-8
8012a000:	de00012e 	bgeu	sp,et,8012a008 <_mprec_log10+0xc>
8012a004:	003b68fa 	trap	3
8012a008:	008005c4 	movi	r2,23
8012a00c:	dc000015 	stw	r16,0(sp)
8012a010:	dfc00115 	stw	ra,4(sp)
8012a014:	2021883a 	mov	r16,r4
8012a018:	11000d0e 	bge	r2,r4,8012a050 <_mprec_log10+0x54>
8012a01c:	0005883a 	mov	r2,zero
8012a020:	00cffc34 	movhi	r3,16368
8012a024:	843fffc4 	addi	r16,r16,-1
8012a028:	000d883a 	mov	r6,zero
8012a02c:	01d00934 	movhi	r7,16420
8012a030:	1009883a 	mov	r4,r2
8012a034:	180b883a 	mov	r5,r3
8012a038:	011ff880 	call	8011ff88 <__muldf3>
8012a03c:	803ff91e 	bne	r16,zero,8012a024 <__reset+0xfa10a024>
8012a040:	dfc00117 	ldw	ra,4(sp)
8012a044:	dc000017 	ldw	r16,0(sp)
8012a048:	dec00204 	addi	sp,sp,8
8012a04c:	f800283a 	ret
8012a050:	202090fa 	slli	r16,r4,3
8012a054:	00a00534 	movhi	r2,32788
8012a058:	109f0204 	addi	r2,r2,31752
8012a05c:	1421883a 	add	r16,r2,r16
8012a060:	80800017 	ldw	r2,0(r16)
8012a064:	80c00117 	ldw	r3,4(r16)
8012a068:	dfc00117 	ldw	ra,4(sp)
8012a06c:	dc000017 	ldw	r16,0(sp)
8012a070:	dec00204 	addi	sp,sp,8
8012a074:	f800283a 	ret

8012a078 <__copybits>:
8012a078:	297fffc4 	addi	r5,r5,-1
8012a07c:	280fd17a 	srai	r7,r5,5
8012a080:	30c00417 	ldw	r3,16(r6)
8012a084:	30800504 	addi	r2,r6,20
8012a088:	39c00044 	addi	r7,r7,1
8012a08c:	18c7883a 	add	r3,r3,r3
8012a090:	39cf883a 	add	r7,r7,r7
8012a094:	18c7883a 	add	r3,r3,r3
8012a098:	39cf883a 	add	r7,r7,r7
8012a09c:	10c7883a 	add	r3,r2,r3
8012a0a0:	21cf883a 	add	r7,r4,r7
8012a0a4:	10c00d2e 	bgeu	r2,r3,8012a0dc <__copybits+0x64>
8012a0a8:	200b883a 	mov	r5,r4
8012a0ac:	12000017 	ldw	r8,0(r2)
8012a0b0:	29400104 	addi	r5,r5,4
8012a0b4:	10800104 	addi	r2,r2,4
8012a0b8:	2a3fff15 	stw	r8,-4(r5)
8012a0bc:	10fffb36 	bltu	r2,r3,8012a0ac <__reset+0xfa10a0ac>
8012a0c0:	1985c83a 	sub	r2,r3,r6
8012a0c4:	10bffac4 	addi	r2,r2,-21
8012a0c8:	1004d0ba 	srli	r2,r2,2
8012a0cc:	10800044 	addi	r2,r2,1
8012a0d0:	1085883a 	add	r2,r2,r2
8012a0d4:	1085883a 	add	r2,r2,r2
8012a0d8:	2089883a 	add	r4,r4,r2
8012a0dc:	21c0032e 	bgeu	r4,r7,8012a0ec <__copybits+0x74>
8012a0e0:	20000015 	stw	zero,0(r4)
8012a0e4:	21000104 	addi	r4,r4,4
8012a0e8:	21fffd36 	bltu	r4,r7,8012a0e0 <__reset+0xfa10a0e0>
8012a0ec:	f800283a 	ret

8012a0f0 <__any_on>:
8012a0f0:	20c00417 	ldw	r3,16(r4)
8012a0f4:	2805d17a 	srai	r2,r5,5
8012a0f8:	21000504 	addi	r4,r4,20
8012a0fc:	18800d0e 	bge	r3,r2,8012a134 <__any_on+0x44>
8012a100:	18c7883a 	add	r3,r3,r3
8012a104:	18c7883a 	add	r3,r3,r3
8012a108:	20c7883a 	add	r3,r4,r3
8012a10c:	20c0192e 	bgeu	r4,r3,8012a174 <__any_on+0x84>
8012a110:	18bfff17 	ldw	r2,-4(r3)
8012a114:	18ffff04 	addi	r3,r3,-4
8012a118:	1000041e 	bne	r2,zero,8012a12c <__any_on+0x3c>
8012a11c:	20c0142e 	bgeu	r4,r3,8012a170 <__any_on+0x80>
8012a120:	18ffff04 	addi	r3,r3,-4
8012a124:	19400017 	ldw	r5,0(r3)
8012a128:	283ffc26 	beq	r5,zero,8012a11c <__reset+0xfa10a11c>
8012a12c:	00800044 	movi	r2,1
8012a130:	f800283a 	ret
8012a134:	10c00a0e 	bge	r2,r3,8012a160 <__any_on+0x70>
8012a138:	1085883a 	add	r2,r2,r2
8012a13c:	1085883a 	add	r2,r2,r2
8012a140:	294007cc 	andi	r5,r5,31
8012a144:	2087883a 	add	r3,r4,r2
8012a148:	283ff026 	beq	r5,zero,8012a10c <__reset+0xfa10a10c>
8012a14c:	19800017 	ldw	r6,0(r3)
8012a150:	3144d83a 	srl	r2,r6,r5
8012a154:	114a983a 	sll	r5,r2,r5
8012a158:	317ff41e 	bne	r6,r5,8012a12c <__reset+0xfa10a12c>
8012a15c:	003feb06 	br	8012a10c <__reset+0xfa10a10c>
8012a160:	1085883a 	add	r2,r2,r2
8012a164:	1085883a 	add	r2,r2,r2
8012a168:	2087883a 	add	r3,r4,r2
8012a16c:	003fe706 	br	8012a10c <__reset+0xfa10a10c>
8012a170:	f800283a 	ret
8012a174:	0005883a 	mov	r2,zero
8012a178:	f800283a 	ret

8012a17c <_realloc_r>:
8012a17c:	defff604 	addi	sp,sp,-40
8012a180:	de00012e 	bgeu	sp,et,8012a188 <_realloc_r+0xc>
8012a184:	003b68fa 	trap	3
8012a188:	dc800215 	stw	r18,8(sp)
8012a18c:	dfc00915 	stw	ra,36(sp)
8012a190:	df000815 	stw	fp,32(sp)
8012a194:	ddc00715 	stw	r23,28(sp)
8012a198:	dd800615 	stw	r22,24(sp)
8012a19c:	dd400515 	stw	r21,20(sp)
8012a1a0:	dd000415 	stw	r20,16(sp)
8012a1a4:	dcc00315 	stw	r19,12(sp)
8012a1a8:	dc400115 	stw	r17,4(sp)
8012a1ac:	dc000015 	stw	r16,0(sp)
8012a1b0:	3025883a 	mov	r18,r6
8012a1b4:	2800b726 	beq	r5,zero,8012a494 <_realloc_r+0x318>
8012a1b8:	282b883a 	mov	r21,r5
8012a1bc:	2029883a 	mov	r20,r4
8012a1c0:	01334b80 	call	801334b8 <__malloc_lock>
8012a1c4:	a8bfff17 	ldw	r2,-4(r21)
8012a1c8:	043fff04 	movi	r16,-4
8012a1cc:	90c002c4 	addi	r3,r18,11
8012a1d0:	01000584 	movi	r4,22
8012a1d4:	acfffe04 	addi	r19,r21,-8
8012a1d8:	1420703a 	and	r16,r2,r16
8012a1dc:	20c0332e 	bgeu	r4,r3,8012a2ac <_realloc_r+0x130>
8012a1e0:	047ffe04 	movi	r17,-8
8012a1e4:	1c62703a 	and	r17,r3,r17
8012a1e8:	8807883a 	mov	r3,r17
8012a1ec:	88005816 	blt	r17,zero,8012a350 <_realloc_r+0x1d4>
8012a1f0:	8c805736 	bltu	r17,r18,8012a350 <_realloc_r+0x1d4>
8012a1f4:	80c0300e 	bge	r16,r3,8012a2b8 <_realloc_r+0x13c>
8012a1f8:	07200574 	movhi	fp,32789
8012a1fc:	e7226304 	addi	fp,fp,-30324
8012a200:	e1c00217 	ldw	r7,8(fp)
8012a204:	9c09883a 	add	r4,r19,r16
8012a208:	22000117 	ldw	r8,4(r4)
8012a20c:	21c06326 	beq	r4,r7,8012a39c <_realloc_r+0x220>
8012a210:	017fff84 	movi	r5,-2
8012a214:	414a703a 	and	r5,r8,r5
8012a218:	214b883a 	add	r5,r4,r5
8012a21c:	29800117 	ldw	r6,4(r5)
8012a220:	3180004c 	andi	r6,r6,1
8012a224:	30003f26 	beq	r6,zero,8012a324 <_realloc_r+0x1a8>
8012a228:	1080004c 	andi	r2,r2,1
8012a22c:	10008326 	beq	r2,zero,8012a43c <_realloc_r+0x2c0>
8012a230:	900b883a 	mov	r5,r18
8012a234:	a009883a 	mov	r4,r20
8012a238:	01284880 	call	80128488 <_malloc_r>
8012a23c:	1025883a 	mov	r18,r2
8012a240:	10011e26 	beq	r2,zero,8012a6bc <_realloc_r+0x540>
8012a244:	a93fff17 	ldw	r4,-4(r21)
8012a248:	10fffe04 	addi	r3,r2,-8
8012a24c:	00bfff84 	movi	r2,-2
8012a250:	2084703a 	and	r2,r4,r2
8012a254:	9885883a 	add	r2,r19,r2
8012a258:	1880ee26 	beq	r3,r2,8012a614 <_realloc_r+0x498>
8012a25c:	81bfff04 	addi	r6,r16,-4
8012a260:	00800904 	movi	r2,36
8012a264:	1180b836 	bltu	r2,r6,8012a548 <_realloc_r+0x3cc>
8012a268:	00c004c4 	movi	r3,19
8012a26c:	19809636 	bltu	r3,r6,8012a4c8 <_realloc_r+0x34c>
8012a270:	9005883a 	mov	r2,r18
8012a274:	a807883a 	mov	r3,r21
8012a278:	19000017 	ldw	r4,0(r3)
8012a27c:	11000015 	stw	r4,0(r2)
8012a280:	19000117 	ldw	r4,4(r3)
8012a284:	11000115 	stw	r4,4(r2)
8012a288:	18c00217 	ldw	r3,8(r3)
8012a28c:	10c00215 	stw	r3,8(r2)
8012a290:	a80b883a 	mov	r5,r21
8012a294:	a009883a 	mov	r4,r20
8012a298:	0127a000 	call	80127a00 <_free_r>
8012a29c:	a009883a 	mov	r4,r20
8012a2a0:	01335e00 	call	801335e0 <__malloc_unlock>
8012a2a4:	9005883a 	mov	r2,r18
8012a2a8:	00001206 	br	8012a2f4 <_realloc_r+0x178>
8012a2ac:	00c00404 	movi	r3,16
8012a2b0:	1823883a 	mov	r17,r3
8012a2b4:	003fce06 	br	8012a1f0 <__reset+0xfa10a1f0>
8012a2b8:	a825883a 	mov	r18,r21
8012a2bc:	8445c83a 	sub	r2,r16,r17
8012a2c0:	00c003c4 	movi	r3,15
8012a2c4:	18802636 	bltu	r3,r2,8012a360 <_realloc_r+0x1e4>
8012a2c8:	99800117 	ldw	r6,4(r19)
8012a2cc:	9c07883a 	add	r3,r19,r16
8012a2d0:	3180004c 	andi	r6,r6,1
8012a2d4:	3420b03a 	or	r16,r6,r16
8012a2d8:	9c000115 	stw	r16,4(r19)
8012a2dc:	18800117 	ldw	r2,4(r3)
8012a2e0:	10800054 	ori	r2,r2,1
8012a2e4:	18800115 	stw	r2,4(r3)
8012a2e8:	a009883a 	mov	r4,r20
8012a2ec:	01335e00 	call	801335e0 <__malloc_unlock>
8012a2f0:	9005883a 	mov	r2,r18
8012a2f4:	dfc00917 	ldw	ra,36(sp)
8012a2f8:	df000817 	ldw	fp,32(sp)
8012a2fc:	ddc00717 	ldw	r23,28(sp)
8012a300:	dd800617 	ldw	r22,24(sp)
8012a304:	dd400517 	ldw	r21,20(sp)
8012a308:	dd000417 	ldw	r20,16(sp)
8012a30c:	dcc00317 	ldw	r19,12(sp)
8012a310:	dc800217 	ldw	r18,8(sp)
8012a314:	dc400117 	ldw	r17,4(sp)
8012a318:	dc000017 	ldw	r16,0(sp)
8012a31c:	dec00a04 	addi	sp,sp,40
8012a320:	f800283a 	ret
8012a324:	017fff04 	movi	r5,-4
8012a328:	414a703a 	and	r5,r8,r5
8012a32c:	814d883a 	add	r6,r16,r5
8012a330:	30c01f16 	blt	r6,r3,8012a3b0 <_realloc_r+0x234>
8012a334:	20800317 	ldw	r2,12(r4)
8012a338:	20c00217 	ldw	r3,8(r4)
8012a33c:	a825883a 	mov	r18,r21
8012a340:	3021883a 	mov	r16,r6
8012a344:	18800315 	stw	r2,12(r3)
8012a348:	10c00215 	stw	r3,8(r2)
8012a34c:	003fdb06 	br	8012a2bc <__reset+0xfa10a2bc>
8012a350:	00800304 	movi	r2,12
8012a354:	a0800015 	stw	r2,0(r20)
8012a358:	0005883a 	mov	r2,zero
8012a35c:	003fe506 	br	8012a2f4 <__reset+0xfa10a2f4>
8012a360:	98c00117 	ldw	r3,4(r19)
8012a364:	9c4b883a 	add	r5,r19,r17
8012a368:	11000054 	ori	r4,r2,1
8012a36c:	18c0004c 	andi	r3,r3,1
8012a370:	1c62b03a 	or	r17,r3,r17
8012a374:	9c400115 	stw	r17,4(r19)
8012a378:	29000115 	stw	r4,4(r5)
8012a37c:	2885883a 	add	r2,r5,r2
8012a380:	10c00117 	ldw	r3,4(r2)
8012a384:	29400204 	addi	r5,r5,8
8012a388:	a009883a 	mov	r4,r20
8012a38c:	18c00054 	ori	r3,r3,1
8012a390:	10c00115 	stw	r3,4(r2)
8012a394:	0127a000 	call	80127a00 <_free_r>
8012a398:	003fd306 	br	8012a2e8 <__reset+0xfa10a2e8>
8012a39c:	017fff04 	movi	r5,-4
8012a3a0:	414a703a 	and	r5,r8,r5
8012a3a4:	89800404 	addi	r6,r17,16
8012a3a8:	8151883a 	add	r8,r16,r5
8012a3ac:	4180590e 	bge	r8,r6,8012a514 <_realloc_r+0x398>
8012a3b0:	1080004c 	andi	r2,r2,1
8012a3b4:	103f9e1e 	bne	r2,zero,8012a230 <__reset+0xfa10a230>
8012a3b8:	adbffe17 	ldw	r22,-8(r21)
8012a3bc:	00bfff04 	movi	r2,-4
8012a3c0:	9dadc83a 	sub	r22,r19,r22
8012a3c4:	b1800117 	ldw	r6,4(r22)
8012a3c8:	3084703a 	and	r2,r6,r2
8012a3cc:	20002026 	beq	r4,zero,8012a450 <_realloc_r+0x2d4>
8012a3d0:	80af883a 	add	r23,r16,r2
8012a3d4:	b96f883a 	add	r23,r23,r5
8012a3d8:	21c05f26 	beq	r4,r7,8012a558 <_realloc_r+0x3dc>
8012a3dc:	b8c01c16 	blt	r23,r3,8012a450 <_realloc_r+0x2d4>
8012a3e0:	20800317 	ldw	r2,12(r4)
8012a3e4:	20c00217 	ldw	r3,8(r4)
8012a3e8:	81bfff04 	addi	r6,r16,-4
8012a3ec:	01000904 	movi	r4,36
8012a3f0:	18800315 	stw	r2,12(r3)
8012a3f4:	10c00215 	stw	r3,8(r2)
8012a3f8:	b0c00217 	ldw	r3,8(r22)
8012a3fc:	b0800317 	ldw	r2,12(r22)
8012a400:	b4800204 	addi	r18,r22,8
8012a404:	18800315 	stw	r2,12(r3)
8012a408:	10c00215 	stw	r3,8(r2)
8012a40c:	21801b36 	bltu	r4,r6,8012a47c <_realloc_r+0x300>
8012a410:	008004c4 	movi	r2,19
8012a414:	1180352e 	bgeu	r2,r6,8012a4ec <_realloc_r+0x370>
8012a418:	a8800017 	ldw	r2,0(r21)
8012a41c:	b0800215 	stw	r2,8(r22)
8012a420:	a8800117 	ldw	r2,4(r21)
8012a424:	b0800315 	stw	r2,12(r22)
8012a428:	008006c4 	movi	r2,27
8012a42c:	11807f36 	bltu	r2,r6,8012a62c <_realloc_r+0x4b0>
8012a430:	b0800404 	addi	r2,r22,16
8012a434:	ad400204 	addi	r21,r21,8
8012a438:	00002d06 	br	8012a4f0 <_realloc_r+0x374>
8012a43c:	adbffe17 	ldw	r22,-8(r21)
8012a440:	00bfff04 	movi	r2,-4
8012a444:	9dadc83a 	sub	r22,r19,r22
8012a448:	b1000117 	ldw	r4,4(r22)
8012a44c:	2084703a 	and	r2,r4,r2
8012a450:	b03f7726 	beq	r22,zero,8012a230 <__reset+0xfa10a230>
8012a454:	80af883a 	add	r23,r16,r2
8012a458:	b8ff7516 	blt	r23,r3,8012a230 <__reset+0xfa10a230>
8012a45c:	b0800317 	ldw	r2,12(r22)
8012a460:	b0c00217 	ldw	r3,8(r22)
8012a464:	81bfff04 	addi	r6,r16,-4
8012a468:	01000904 	movi	r4,36
8012a46c:	18800315 	stw	r2,12(r3)
8012a470:	10c00215 	stw	r3,8(r2)
8012a474:	b4800204 	addi	r18,r22,8
8012a478:	21bfe52e 	bgeu	r4,r6,8012a410 <__reset+0xfa10a410>
8012a47c:	a80b883a 	mov	r5,r21
8012a480:	9009883a 	mov	r4,r18
8012a484:	0128fc40 	call	80128fc4 <memmove>
8012a488:	b821883a 	mov	r16,r23
8012a48c:	b027883a 	mov	r19,r22
8012a490:	003f8a06 	br	8012a2bc <__reset+0xfa10a2bc>
8012a494:	300b883a 	mov	r5,r6
8012a498:	dfc00917 	ldw	ra,36(sp)
8012a49c:	df000817 	ldw	fp,32(sp)
8012a4a0:	ddc00717 	ldw	r23,28(sp)
8012a4a4:	dd800617 	ldw	r22,24(sp)
8012a4a8:	dd400517 	ldw	r21,20(sp)
8012a4ac:	dd000417 	ldw	r20,16(sp)
8012a4b0:	dcc00317 	ldw	r19,12(sp)
8012a4b4:	dc800217 	ldw	r18,8(sp)
8012a4b8:	dc400117 	ldw	r17,4(sp)
8012a4bc:	dc000017 	ldw	r16,0(sp)
8012a4c0:	dec00a04 	addi	sp,sp,40
8012a4c4:	01284881 	jmpi	80128488 <_malloc_r>
8012a4c8:	a8c00017 	ldw	r3,0(r21)
8012a4cc:	90c00015 	stw	r3,0(r18)
8012a4d0:	a8c00117 	ldw	r3,4(r21)
8012a4d4:	90c00115 	stw	r3,4(r18)
8012a4d8:	00c006c4 	movi	r3,27
8012a4dc:	19804536 	bltu	r3,r6,8012a5f4 <_realloc_r+0x478>
8012a4e0:	90800204 	addi	r2,r18,8
8012a4e4:	a8c00204 	addi	r3,r21,8
8012a4e8:	003f6306 	br	8012a278 <__reset+0xfa10a278>
8012a4ec:	9005883a 	mov	r2,r18
8012a4f0:	a8c00017 	ldw	r3,0(r21)
8012a4f4:	b821883a 	mov	r16,r23
8012a4f8:	b027883a 	mov	r19,r22
8012a4fc:	10c00015 	stw	r3,0(r2)
8012a500:	a8c00117 	ldw	r3,4(r21)
8012a504:	10c00115 	stw	r3,4(r2)
8012a508:	a8c00217 	ldw	r3,8(r21)
8012a50c:	10c00215 	stw	r3,8(r2)
8012a510:	003f6a06 	br	8012a2bc <__reset+0xfa10a2bc>
8012a514:	9c67883a 	add	r19,r19,r17
8012a518:	4445c83a 	sub	r2,r8,r17
8012a51c:	e4c00215 	stw	r19,8(fp)
8012a520:	10800054 	ori	r2,r2,1
8012a524:	98800115 	stw	r2,4(r19)
8012a528:	a8bfff17 	ldw	r2,-4(r21)
8012a52c:	a009883a 	mov	r4,r20
8012a530:	1080004c 	andi	r2,r2,1
8012a534:	1462b03a 	or	r17,r2,r17
8012a538:	ac7fff15 	stw	r17,-4(r21)
8012a53c:	01335e00 	call	801335e0 <__malloc_unlock>
8012a540:	a805883a 	mov	r2,r21
8012a544:	003f6b06 	br	8012a2f4 <__reset+0xfa10a2f4>
8012a548:	a80b883a 	mov	r5,r21
8012a54c:	9009883a 	mov	r4,r18
8012a550:	0128fc40 	call	80128fc4 <memmove>
8012a554:	003f4e06 	br	8012a290 <__reset+0xfa10a290>
8012a558:	89000404 	addi	r4,r17,16
8012a55c:	b93fbc16 	blt	r23,r4,8012a450 <__reset+0xfa10a450>
8012a560:	b0800317 	ldw	r2,12(r22)
8012a564:	b0c00217 	ldw	r3,8(r22)
8012a568:	81bfff04 	addi	r6,r16,-4
8012a56c:	01000904 	movi	r4,36
8012a570:	18800315 	stw	r2,12(r3)
8012a574:	10c00215 	stw	r3,8(r2)
8012a578:	b4800204 	addi	r18,r22,8
8012a57c:	21804336 	bltu	r4,r6,8012a68c <_realloc_r+0x510>
8012a580:	008004c4 	movi	r2,19
8012a584:	11803f2e 	bgeu	r2,r6,8012a684 <_realloc_r+0x508>
8012a588:	a8800017 	ldw	r2,0(r21)
8012a58c:	b0800215 	stw	r2,8(r22)
8012a590:	a8800117 	ldw	r2,4(r21)
8012a594:	b0800315 	stw	r2,12(r22)
8012a598:	008006c4 	movi	r2,27
8012a59c:	11803f36 	bltu	r2,r6,8012a69c <_realloc_r+0x520>
8012a5a0:	b0800404 	addi	r2,r22,16
8012a5a4:	ad400204 	addi	r21,r21,8
8012a5a8:	a8c00017 	ldw	r3,0(r21)
8012a5ac:	10c00015 	stw	r3,0(r2)
8012a5b0:	a8c00117 	ldw	r3,4(r21)
8012a5b4:	10c00115 	stw	r3,4(r2)
8012a5b8:	a8c00217 	ldw	r3,8(r21)
8012a5bc:	10c00215 	stw	r3,8(r2)
8012a5c0:	b447883a 	add	r3,r22,r17
8012a5c4:	bc45c83a 	sub	r2,r23,r17
8012a5c8:	e0c00215 	stw	r3,8(fp)
8012a5cc:	10800054 	ori	r2,r2,1
8012a5d0:	18800115 	stw	r2,4(r3)
8012a5d4:	b0800117 	ldw	r2,4(r22)
8012a5d8:	a009883a 	mov	r4,r20
8012a5dc:	1080004c 	andi	r2,r2,1
8012a5e0:	1462b03a 	or	r17,r2,r17
8012a5e4:	b4400115 	stw	r17,4(r22)
8012a5e8:	01335e00 	call	801335e0 <__malloc_unlock>
8012a5ec:	9005883a 	mov	r2,r18
8012a5f0:	003f4006 	br	8012a2f4 <__reset+0xfa10a2f4>
8012a5f4:	a8c00217 	ldw	r3,8(r21)
8012a5f8:	90c00215 	stw	r3,8(r18)
8012a5fc:	a8c00317 	ldw	r3,12(r21)
8012a600:	90c00315 	stw	r3,12(r18)
8012a604:	30801126 	beq	r6,r2,8012a64c <_realloc_r+0x4d0>
8012a608:	90800404 	addi	r2,r18,16
8012a60c:	a8c00404 	addi	r3,r21,16
8012a610:	003f1906 	br	8012a278 <__reset+0xfa10a278>
8012a614:	90ffff17 	ldw	r3,-4(r18)
8012a618:	00bfff04 	movi	r2,-4
8012a61c:	a825883a 	mov	r18,r21
8012a620:	1884703a 	and	r2,r3,r2
8012a624:	80a1883a 	add	r16,r16,r2
8012a628:	003f2406 	br	8012a2bc <__reset+0xfa10a2bc>
8012a62c:	a8800217 	ldw	r2,8(r21)
8012a630:	b0800415 	stw	r2,16(r22)
8012a634:	a8800317 	ldw	r2,12(r21)
8012a638:	b0800515 	stw	r2,20(r22)
8012a63c:	31000a26 	beq	r6,r4,8012a668 <_realloc_r+0x4ec>
8012a640:	b0800604 	addi	r2,r22,24
8012a644:	ad400404 	addi	r21,r21,16
8012a648:	003fa906 	br	8012a4f0 <__reset+0xfa10a4f0>
8012a64c:	a9000417 	ldw	r4,16(r21)
8012a650:	90800604 	addi	r2,r18,24
8012a654:	a8c00604 	addi	r3,r21,24
8012a658:	91000415 	stw	r4,16(r18)
8012a65c:	a9000517 	ldw	r4,20(r21)
8012a660:	91000515 	stw	r4,20(r18)
8012a664:	003f0406 	br	8012a278 <__reset+0xfa10a278>
8012a668:	a8c00417 	ldw	r3,16(r21)
8012a66c:	ad400604 	addi	r21,r21,24
8012a670:	b0800804 	addi	r2,r22,32
8012a674:	b0c00615 	stw	r3,24(r22)
8012a678:	a8ffff17 	ldw	r3,-4(r21)
8012a67c:	b0c00715 	stw	r3,28(r22)
8012a680:	003f9b06 	br	8012a4f0 <__reset+0xfa10a4f0>
8012a684:	9005883a 	mov	r2,r18
8012a688:	003fc706 	br	8012a5a8 <__reset+0xfa10a5a8>
8012a68c:	a80b883a 	mov	r5,r21
8012a690:	9009883a 	mov	r4,r18
8012a694:	0128fc40 	call	80128fc4 <memmove>
8012a698:	003fc906 	br	8012a5c0 <__reset+0xfa10a5c0>
8012a69c:	a8800217 	ldw	r2,8(r21)
8012a6a0:	b0800415 	stw	r2,16(r22)
8012a6a4:	a8800317 	ldw	r2,12(r21)
8012a6a8:	b0800515 	stw	r2,20(r22)
8012a6ac:	31000726 	beq	r6,r4,8012a6cc <_realloc_r+0x550>
8012a6b0:	b0800604 	addi	r2,r22,24
8012a6b4:	ad400404 	addi	r21,r21,16
8012a6b8:	003fbb06 	br	8012a5a8 <__reset+0xfa10a5a8>
8012a6bc:	a009883a 	mov	r4,r20
8012a6c0:	01335e00 	call	801335e0 <__malloc_unlock>
8012a6c4:	0005883a 	mov	r2,zero
8012a6c8:	003f0a06 	br	8012a2f4 <__reset+0xfa10a2f4>
8012a6cc:	a8c00417 	ldw	r3,16(r21)
8012a6d0:	ad400604 	addi	r21,r21,24
8012a6d4:	b0800804 	addi	r2,r22,32
8012a6d8:	b0c00615 	stw	r3,24(r22)
8012a6dc:	a8ffff17 	ldw	r3,-4(r21)
8012a6e0:	b0c00715 	stw	r3,28(r22)
8012a6e4:	003fb006 	br	8012a5a8 <__reset+0xfa10a5a8>

8012a6e8 <lflush>:
8012a6e8:	2080030b 	ldhu	r2,12(r4)
8012a6ec:	00c00244 	movi	r3,9
8012a6f0:	1080024c 	andi	r2,r2,9
8012a6f4:	10c00226 	beq	r2,r3,8012a700 <lflush+0x18>
8012a6f8:	0005883a 	mov	r2,zero
8012a6fc:	f800283a 	ret
8012a700:	012e6c01 	jmpi	8012e6c0 <fflush>

8012a704 <__srefill_r>:
8012a704:	defffc04 	addi	sp,sp,-16
8012a708:	de00012e 	bgeu	sp,et,8012a710 <__srefill_r+0xc>
8012a70c:	003b68fa 	trap	3
8012a710:	dc400115 	stw	r17,4(sp)
8012a714:	dc000015 	stw	r16,0(sp)
8012a718:	dfc00315 	stw	ra,12(sp)
8012a71c:	dc800215 	stw	r18,8(sp)
8012a720:	2023883a 	mov	r17,r4
8012a724:	2821883a 	mov	r16,r5
8012a728:	20000226 	beq	r4,zero,8012a734 <__srefill_r+0x30>
8012a72c:	20800e17 	ldw	r2,56(r4)
8012a730:	10003c26 	beq	r2,zero,8012a824 <__srefill_r+0x120>
8012a734:	80c0030b 	ldhu	r3,12(r16)
8012a738:	1908000c 	andi	r4,r3,8192
8012a73c:	1805883a 	mov	r2,r3
8012a740:	2000071e 	bne	r4,zero,8012a760 <__srefill_r+0x5c>
8012a744:	81001917 	ldw	r4,100(r16)
8012a748:	18880014 	ori	r2,r3,8192
8012a74c:	00f7ffc4 	movi	r3,-8193
8012a750:	20c8703a 	and	r4,r4,r3
8012a754:	8080030d 	sth	r2,12(r16)
8012a758:	1007883a 	mov	r3,r2
8012a75c:	81001915 	stw	r4,100(r16)
8012a760:	80000115 	stw	zero,4(r16)
8012a764:	1100080c 	andi	r4,r2,32
8012a768:	2000571e 	bne	r4,zero,8012a8c8 <__srefill_r+0x1c4>
8012a76c:	1100010c 	andi	r4,r2,4
8012a770:	20001f26 	beq	r4,zero,8012a7f0 <__srefill_r+0xec>
8012a774:	81400c17 	ldw	r5,48(r16)
8012a778:	28000826 	beq	r5,zero,8012a79c <__srefill_r+0x98>
8012a77c:	80801004 	addi	r2,r16,64
8012a780:	28800226 	beq	r5,r2,8012a78c <__srefill_r+0x88>
8012a784:	8809883a 	mov	r4,r17
8012a788:	0127a000 	call	80127a00 <_free_r>
8012a78c:	80800f17 	ldw	r2,60(r16)
8012a790:	80000c15 	stw	zero,48(r16)
8012a794:	80800115 	stw	r2,4(r16)
8012a798:	1000391e 	bne	r2,zero,8012a880 <__srefill_r+0x17c>
8012a79c:	80800417 	ldw	r2,16(r16)
8012a7a0:	10004b26 	beq	r2,zero,8012a8d0 <__srefill_r+0x1cc>
8012a7a4:	8480030b 	ldhu	r18,12(r16)
8012a7a8:	908000cc 	andi	r2,r18,3
8012a7ac:	10001f1e 	bne	r2,zero,8012a82c <__srefill_r+0x128>
8012a7b0:	81800417 	ldw	r6,16(r16)
8012a7b4:	80800817 	ldw	r2,32(r16)
8012a7b8:	81c00517 	ldw	r7,20(r16)
8012a7bc:	81400717 	ldw	r5,28(r16)
8012a7c0:	81800015 	stw	r6,0(r16)
8012a7c4:	8809883a 	mov	r4,r17
8012a7c8:	103ee83a 	callr	r2
8012a7cc:	80800115 	stw	r2,4(r16)
8012a7d0:	00800e0e 	bge	zero,r2,8012a80c <__srefill_r+0x108>
8012a7d4:	0005883a 	mov	r2,zero
8012a7d8:	dfc00317 	ldw	ra,12(sp)
8012a7dc:	dc800217 	ldw	r18,8(sp)
8012a7e0:	dc400117 	ldw	r17,4(sp)
8012a7e4:	dc000017 	ldw	r16,0(sp)
8012a7e8:	dec00404 	addi	sp,sp,16
8012a7ec:	f800283a 	ret
8012a7f0:	1100040c 	andi	r4,r2,16
8012a7f4:	20003026 	beq	r4,zero,8012a8b8 <__srefill_r+0x1b4>
8012a7f8:	1080020c 	andi	r2,r2,8
8012a7fc:	1000241e 	bne	r2,zero,8012a890 <__srefill_r+0x18c>
8012a800:	18c00114 	ori	r3,r3,4
8012a804:	80c0030d 	sth	r3,12(r16)
8012a808:	003fe406 	br	8012a79c <__reset+0xfa10a79c>
8012a80c:	80c0030b 	ldhu	r3,12(r16)
8012a810:	1000161e 	bne	r2,zero,8012a86c <__srefill_r+0x168>
8012a814:	18c00814 	ori	r3,r3,32
8012a818:	00bfffc4 	movi	r2,-1
8012a81c:	80c0030d 	sth	r3,12(r16)
8012a820:	003fed06 	br	8012a7d8 <__reset+0xfa10a7d8>
8012a824:	01276140 	call	80127614 <__sinit>
8012a828:	003fc206 	br	8012a734 <__reset+0xfa10a734>
8012a82c:	00a00574 	movhi	r2,32789
8012a830:	10a88604 	addi	r2,r2,-24040
8012a834:	11000017 	ldw	r4,0(r2)
8012a838:	016004f4 	movhi	r5,32787
8012a83c:	00800044 	movi	r2,1
8012a840:	2969ba04 	addi	r5,r5,-22808
8012a844:	8080030d 	sth	r2,12(r16)
8012a848:	01281dc0 	call	801281dc <_fwalk>
8012a84c:	00800244 	movi	r2,9
8012a850:	8480030d 	sth	r18,12(r16)
8012a854:	9480024c 	andi	r18,r18,9
8012a858:	90bfd51e 	bne	r18,r2,8012a7b0 <__reset+0xfa10a7b0>
8012a85c:	800b883a 	mov	r5,r16
8012a860:	8809883a 	mov	r4,r17
8012a864:	012e4380 	call	8012e438 <__sflush_r>
8012a868:	003fd106 	br	8012a7b0 <__reset+0xfa10a7b0>
8012a86c:	18c01014 	ori	r3,r3,64
8012a870:	80000115 	stw	zero,4(r16)
8012a874:	00bfffc4 	movi	r2,-1
8012a878:	80c0030d 	sth	r3,12(r16)
8012a87c:	003fd606 	br	8012a7d8 <__reset+0xfa10a7d8>
8012a880:	80c00e17 	ldw	r3,56(r16)
8012a884:	0005883a 	mov	r2,zero
8012a888:	80c00015 	stw	r3,0(r16)
8012a88c:	003fd206 	br	8012a7d8 <__reset+0xfa10a7d8>
8012a890:	800b883a 	mov	r5,r16
8012a894:	8809883a 	mov	r4,r17
8012a898:	012e65c0 	call	8012e65c <_fflush_r>
8012a89c:	10000a1e 	bne	r2,zero,8012a8c8 <__srefill_r+0x1c4>
8012a8a0:	8080030b 	ldhu	r2,12(r16)
8012a8a4:	00fffdc4 	movi	r3,-9
8012a8a8:	80000215 	stw	zero,8(r16)
8012a8ac:	1886703a 	and	r3,r3,r2
8012a8b0:	80000615 	stw	zero,24(r16)
8012a8b4:	003fd206 	br	8012a800 <__reset+0xfa10a800>
8012a8b8:	00800244 	movi	r2,9
8012a8bc:	88800015 	stw	r2,0(r17)
8012a8c0:	18c01014 	ori	r3,r3,64
8012a8c4:	80c0030d 	sth	r3,12(r16)
8012a8c8:	00bfffc4 	movi	r2,-1
8012a8cc:	003fc206 	br	8012a7d8 <__reset+0xfa10a7d8>
8012a8d0:	800b883a 	mov	r5,r16
8012a8d4:	8809883a 	mov	r4,r17
8012a8d8:	012f2f40 	call	8012f2f4 <__smakebuf_r>
8012a8dc:	003fb106 	br	8012a7a4 <__reset+0xfa10a7a4>

8012a8e0 <__fpclassifyd>:
8012a8e0:	00a00034 	movhi	r2,32768
8012a8e4:	10bfffc4 	addi	r2,r2,-1
8012a8e8:	2884703a 	and	r2,r5,r2
8012a8ec:	10000726 	beq	r2,zero,8012a90c <__fpclassifyd+0x2c>
8012a8f0:	00fffc34 	movhi	r3,65520
8012a8f4:	019ff834 	movhi	r6,32736
8012a8f8:	28c7883a 	add	r3,r5,r3
8012a8fc:	31bfffc4 	addi	r6,r6,-1
8012a900:	30c00536 	bltu	r6,r3,8012a918 <__fpclassifyd+0x38>
8012a904:	00800104 	movi	r2,4
8012a908:	f800283a 	ret
8012a90c:	2000021e 	bne	r4,zero,8012a918 <__fpclassifyd+0x38>
8012a910:	00800084 	movi	r2,2
8012a914:	f800283a 	ret
8012a918:	00dffc34 	movhi	r3,32752
8012a91c:	019ff834 	movhi	r6,32736
8012a920:	28cb883a 	add	r5,r5,r3
8012a924:	31bfffc4 	addi	r6,r6,-1
8012a928:	317ff62e 	bgeu	r6,r5,8012a904 <__reset+0xfa10a904>
8012a92c:	01400434 	movhi	r5,16
8012a930:	297fffc4 	addi	r5,r5,-1
8012a934:	28800236 	bltu	r5,r2,8012a940 <__fpclassifyd+0x60>
8012a938:	008000c4 	movi	r2,3
8012a93c:	f800283a 	ret
8012a940:	10c00226 	beq	r2,r3,8012a94c <__fpclassifyd+0x6c>
8012a944:	0005883a 	mov	r2,zero
8012a948:	f800283a 	ret
8012a94c:	2005003a 	cmpeq	r2,r4,zero
8012a950:	f800283a 	ret

8012a954 <_sbrk_r>:
8012a954:	defffd04 	addi	sp,sp,-12
8012a958:	de00012e 	bgeu	sp,et,8012a960 <_sbrk_r+0xc>
8012a95c:	003b68fa 	trap	3
8012a960:	dc000015 	stw	r16,0(sp)
8012a964:	04200574 	movhi	r16,32789
8012a968:	dc400115 	stw	r17,4(sp)
8012a96c:	84290904 	addi	r16,r16,-23516
8012a970:	2023883a 	mov	r17,r4
8012a974:	2809883a 	mov	r4,r5
8012a978:	dfc00215 	stw	ra,8(sp)
8012a97c:	80000015 	stw	zero,0(r16)
8012a980:	0132e480 	call	80132e48 <sbrk>
8012a984:	00ffffc4 	movi	r3,-1
8012a988:	10c00526 	beq	r2,r3,8012a9a0 <_sbrk_r+0x4c>
8012a98c:	dfc00217 	ldw	ra,8(sp)
8012a990:	dc400117 	ldw	r17,4(sp)
8012a994:	dc000017 	ldw	r16,0(sp)
8012a998:	dec00304 	addi	sp,sp,12
8012a99c:	f800283a 	ret
8012a9a0:	80c00017 	ldw	r3,0(r16)
8012a9a4:	183ff926 	beq	r3,zero,8012a98c <__reset+0xfa10a98c>
8012a9a8:	88c00015 	stw	r3,0(r17)
8012a9ac:	003ff706 	br	8012a98c <__reset+0xfa10a98c>

8012a9b0 <__sccl>:
8012a9b0:	2a000003 	ldbu	r8,0(r5)
8012a9b4:	00801784 	movi	r2,94
8012a9b8:	40802a26 	beq	r8,r2,8012aa64 <__sccl+0xb4>
8012a9bc:	29400044 	addi	r5,r5,1
8012a9c0:	000f883a 	mov	r7,zero
8012a9c4:	0013883a 	mov	r9,zero
8012a9c8:	2007883a 	mov	r3,r4
8012a9cc:	21804004 	addi	r6,r4,256
8012a9d0:	19c00005 	stb	r7,0(r3)
8012a9d4:	18c00044 	addi	r3,r3,1
8012a9d8:	19bffd1e 	bne	r3,r6,8012a9d0 <__reset+0xfa10a9d0>
8012a9dc:	40001126 	beq	r8,zero,8012aa24 <__sccl+0x74>
8012a9e0:	00800044 	movi	r2,1
8012a9e4:	124fc83a 	sub	r7,r2,r9
8012a9e8:	02800b44 	movi	r10,45
8012a9ec:	02c01744 	movi	r11,93
8012a9f0:	2205883a 	add	r2,r4,r8
8012a9f4:	11c00005 	stb	r7,0(r2)
8012a9f8:	28800044 	addi	r2,r5,1
8012a9fc:	28c00003 	ldbu	r3,0(r5)
8012aa00:	1a800a26 	beq	r3,r10,8012aa2c <__sccl+0x7c>
8012aa04:	1ac00426 	beq	r3,r11,8012aa18 <__sccl+0x68>
8012aa08:	18000426 	beq	r3,zero,8012aa1c <__sccl+0x6c>
8012aa0c:	1811883a 	mov	r8,r3
8012aa10:	100b883a 	mov	r5,r2
8012aa14:	003ff606 	br	8012a9f0 <__reset+0xfa10a9f0>
8012aa18:	f800283a 	ret
8012aa1c:	2805883a 	mov	r2,r5
8012aa20:	f800283a 	ret
8012aa24:	28bfffc4 	addi	r2,r5,-1
8012aa28:	f800283a 	ret
8012aa2c:	12400003 	ldbu	r9,0(r2)
8012aa30:	4ac01126 	beq	r9,r11,8012aa78 <__sccl+0xc8>
8012aa34:	4a001016 	blt	r9,r8,8012aa78 <__sccl+0xc8>
8012aa38:	41800044 	addi	r6,r8,1
8012aa3c:	29400084 	addi	r5,r5,2
8012aa40:	2187883a 	add	r3,r4,r6
8012aa44:	00000106 	br	8012aa4c <__sccl+0x9c>
8012aa48:	31800044 	addi	r6,r6,1
8012aa4c:	19c00005 	stb	r7,0(r3)
8012aa50:	3011883a 	mov	r8,r6
8012aa54:	18c00044 	addi	r3,r3,1
8012aa58:	327ffb16 	blt	r6,r9,8012aa48 <__reset+0xfa10aa48>
8012aa5c:	10800084 	addi	r2,r2,2
8012aa60:	003fe606 	br	8012a9fc <__reset+0xfa10a9fc>
8012aa64:	2a000043 	ldbu	r8,1(r5)
8012aa68:	01c00044 	movi	r7,1
8012aa6c:	29400084 	addi	r5,r5,2
8012aa70:	02400044 	movi	r9,1
8012aa74:	003fd406 	br	8012a9c8 <__reset+0xfa10a9c8>
8012aa78:	5011883a 	mov	r8,r10
8012aa7c:	003fe406 	br	8012aa10 <__reset+0xfa10aa10>

8012aa80 <nanf>:
8012aa80:	009ff034 	movhi	r2,32704
8012aa84:	f800283a 	ret

8012aa88 <__sread>:
8012aa88:	defffe04 	addi	sp,sp,-8
8012aa8c:	de00012e 	bgeu	sp,et,8012aa94 <__sread+0xc>
8012aa90:	003b68fa 	trap	3
8012aa94:	dc000015 	stw	r16,0(sp)
8012aa98:	2821883a 	mov	r16,r5
8012aa9c:	2940038f 	ldh	r5,14(r5)
8012aaa0:	dfc00115 	stw	ra,4(sp)
8012aaa4:	012f4b80 	call	8012f4b8 <_read_r>
8012aaa8:	10000716 	blt	r2,zero,8012aac8 <__sread+0x40>
8012aaac:	80c01417 	ldw	r3,80(r16)
8012aab0:	1887883a 	add	r3,r3,r2
8012aab4:	80c01415 	stw	r3,80(r16)
8012aab8:	dfc00117 	ldw	ra,4(sp)
8012aabc:	dc000017 	ldw	r16,0(sp)
8012aac0:	dec00204 	addi	sp,sp,8
8012aac4:	f800283a 	ret
8012aac8:	80c0030b 	ldhu	r3,12(r16)
8012aacc:	18fbffcc 	andi	r3,r3,61439
8012aad0:	80c0030d 	sth	r3,12(r16)
8012aad4:	dfc00117 	ldw	ra,4(sp)
8012aad8:	dc000017 	ldw	r16,0(sp)
8012aadc:	dec00204 	addi	sp,sp,8
8012aae0:	f800283a 	ret

8012aae4 <__seofread>:
8012aae4:	0005883a 	mov	r2,zero
8012aae8:	f800283a 	ret

8012aaec <__swrite>:
8012aaec:	defffb04 	addi	sp,sp,-20
8012aaf0:	de00012e 	bgeu	sp,et,8012aaf8 <__swrite+0xc>
8012aaf4:	003b68fa 	trap	3
8012aaf8:	2880030b 	ldhu	r2,12(r5)
8012aafc:	dcc00315 	stw	r19,12(sp)
8012ab00:	dc800215 	stw	r18,8(sp)
8012ab04:	dc400115 	stw	r17,4(sp)
8012ab08:	dc000015 	stw	r16,0(sp)
8012ab0c:	dfc00415 	stw	ra,16(sp)
8012ab10:	10c0400c 	andi	r3,r2,256
8012ab14:	2821883a 	mov	r16,r5
8012ab18:	2023883a 	mov	r17,r4
8012ab1c:	3025883a 	mov	r18,r6
8012ab20:	3827883a 	mov	r19,r7
8012ab24:	18000526 	beq	r3,zero,8012ab3c <__swrite+0x50>
8012ab28:	2940038f 	ldh	r5,14(r5)
8012ab2c:	01c00084 	movi	r7,2
8012ab30:	000d883a 	mov	r6,zero
8012ab34:	012f28c0 	call	8012f28c <_lseek_r>
8012ab38:	8080030b 	ldhu	r2,12(r16)
8012ab3c:	8140038f 	ldh	r5,14(r16)
8012ab40:	10bbffcc 	andi	r2,r2,61439
8012ab44:	980f883a 	mov	r7,r19
8012ab48:	900d883a 	mov	r6,r18
8012ab4c:	8809883a 	mov	r4,r17
8012ab50:	8080030d 	sth	r2,12(r16)
8012ab54:	dfc00417 	ldw	ra,16(sp)
8012ab58:	dcc00317 	ldw	r19,12(sp)
8012ab5c:	dc800217 	ldw	r18,8(sp)
8012ab60:	dc400117 	ldw	r17,4(sp)
8012ab64:	dc000017 	ldw	r16,0(sp)
8012ab68:	dec00504 	addi	sp,sp,20
8012ab6c:	012e0401 	jmpi	8012e040 <_write_r>

8012ab70 <__sseek>:
8012ab70:	defffe04 	addi	sp,sp,-8
8012ab74:	de00012e 	bgeu	sp,et,8012ab7c <__sseek+0xc>
8012ab78:	003b68fa 	trap	3
8012ab7c:	dc000015 	stw	r16,0(sp)
8012ab80:	2821883a 	mov	r16,r5
8012ab84:	2940038f 	ldh	r5,14(r5)
8012ab88:	dfc00115 	stw	ra,4(sp)
8012ab8c:	012f28c0 	call	8012f28c <_lseek_r>
8012ab90:	00ffffc4 	movi	r3,-1
8012ab94:	10c00826 	beq	r2,r3,8012abb8 <__sseek+0x48>
8012ab98:	80c0030b 	ldhu	r3,12(r16)
8012ab9c:	80801415 	stw	r2,80(r16)
8012aba0:	18c40014 	ori	r3,r3,4096
8012aba4:	80c0030d 	sth	r3,12(r16)
8012aba8:	dfc00117 	ldw	ra,4(sp)
8012abac:	dc000017 	ldw	r16,0(sp)
8012abb0:	dec00204 	addi	sp,sp,8
8012abb4:	f800283a 	ret
8012abb8:	80c0030b 	ldhu	r3,12(r16)
8012abbc:	18fbffcc 	andi	r3,r3,61439
8012abc0:	80c0030d 	sth	r3,12(r16)
8012abc4:	dfc00117 	ldw	ra,4(sp)
8012abc8:	dc000017 	ldw	r16,0(sp)
8012abcc:	dec00204 	addi	sp,sp,8
8012abd0:	f800283a 	ret

8012abd4 <__sclose>:
8012abd4:	2940038f 	ldh	r5,14(r5)
8012abd8:	012e2041 	jmpi	8012e204 <_close_r>

8012abdc <strcmp>:
8012abdc:	2144b03a 	or	r2,r4,r5
8012abe0:	108000cc 	andi	r2,r2,3
8012abe4:	1000171e 	bne	r2,zero,8012ac44 <strcmp+0x68>
8012abe8:	20800017 	ldw	r2,0(r4)
8012abec:	28c00017 	ldw	r3,0(r5)
8012abf0:	10c0141e 	bne	r2,r3,8012ac44 <strcmp+0x68>
8012abf4:	027fbff4 	movhi	r9,65279
8012abf8:	4a7fbfc4 	addi	r9,r9,-257
8012abfc:	0086303a 	nor	r3,zero,r2
8012ac00:	02202074 	movhi	r8,32897
8012ac04:	1245883a 	add	r2,r2,r9
8012ac08:	42202004 	addi	r8,r8,-32640
8012ac0c:	10c4703a 	and	r2,r2,r3
8012ac10:	1204703a 	and	r2,r2,r8
8012ac14:	10000226 	beq	r2,zero,8012ac20 <strcmp+0x44>
8012ac18:	00002306 	br	8012aca8 <strcmp+0xcc>
8012ac1c:	1000221e 	bne	r2,zero,8012aca8 <strcmp+0xcc>
8012ac20:	21000104 	addi	r4,r4,4
8012ac24:	20c00017 	ldw	r3,0(r4)
8012ac28:	29400104 	addi	r5,r5,4
8012ac2c:	29800017 	ldw	r6,0(r5)
8012ac30:	1a4f883a 	add	r7,r3,r9
8012ac34:	00c4303a 	nor	r2,zero,r3
8012ac38:	3884703a 	and	r2,r7,r2
8012ac3c:	1204703a 	and	r2,r2,r8
8012ac40:	19bff626 	beq	r3,r6,8012ac1c <__reset+0xfa10ac1c>
8012ac44:	20800003 	ldbu	r2,0(r4)
8012ac48:	10c03fcc 	andi	r3,r2,255
8012ac4c:	18c0201c 	xori	r3,r3,128
8012ac50:	18ffe004 	addi	r3,r3,-128
8012ac54:	18000c26 	beq	r3,zero,8012ac88 <strcmp+0xac>
8012ac58:	29800007 	ldb	r6,0(r5)
8012ac5c:	19800326 	beq	r3,r6,8012ac6c <strcmp+0x90>
8012ac60:	00001306 	br	8012acb0 <strcmp+0xd4>
8012ac64:	29800007 	ldb	r6,0(r5)
8012ac68:	11800b1e 	bne	r2,r6,8012ac98 <strcmp+0xbc>
8012ac6c:	21000044 	addi	r4,r4,1
8012ac70:	20c00003 	ldbu	r3,0(r4)
8012ac74:	29400044 	addi	r5,r5,1
8012ac78:	18803fcc 	andi	r2,r3,255
8012ac7c:	1080201c 	xori	r2,r2,128
8012ac80:	10bfe004 	addi	r2,r2,-128
8012ac84:	103ff71e 	bne	r2,zero,8012ac64 <__reset+0xfa10ac64>
8012ac88:	0007883a 	mov	r3,zero
8012ac8c:	28800003 	ldbu	r2,0(r5)
8012ac90:	1885c83a 	sub	r2,r3,r2
8012ac94:	f800283a 	ret
8012ac98:	28800003 	ldbu	r2,0(r5)
8012ac9c:	18c03fcc 	andi	r3,r3,255
8012aca0:	1885c83a 	sub	r2,r3,r2
8012aca4:	f800283a 	ret
8012aca8:	0005883a 	mov	r2,zero
8012acac:	f800283a 	ret
8012acb0:	10c03fcc 	andi	r3,r2,255
8012acb4:	003ff506 	br	8012ac8c <__reset+0xfa10ac8c>

8012acb8 <sulp>:
8012acb8:	defffd04 	addi	sp,sp,-12
8012acbc:	de00012e 	bgeu	sp,et,8012acc4 <sulp+0xc>
8012acc0:	003b68fa 	trap	3
8012acc4:	dc400115 	stw	r17,4(sp)
8012acc8:	3023883a 	mov	r17,r6
8012accc:	dc000015 	stw	r16,0(sp)
8012acd0:	dfc00215 	stw	ra,8(sp)
8012acd4:	2821883a 	mov	r16,r5
8012acd8:	0129c840 	call	80129c84 <__ulp>
8012acdc:	88000c26 	beq	r17,zero,8012ad10 <sulp+0x58>
8012ace0:	841ffc2c 	andhi	r16,r16,32752
8012ace4:	8020d53a 	srli	r16,r16,20
8012ace8:	01c01ac4 	movi	r7,107
8012acec:	3c21c83a 	sub	r16,r7,r16
8012acf0:	0400070e 	bge	zero,r16,8012ad10 <sulp+0x58>
8012acf4:	8020953a 	slli	r16,r16,20
8012acf8:	01cffc34 	movhi	r7,16368
8012acfc:	000d883a 	mov	r6,zero
8012ad00:	81cf883a 	add	r7,r16,r7
8012ad04:	1009883a 	mov	r4,r2
8012ad08:	180b883a 	mov	r5,r3
8012ad0c:	011ff880 	call	8011ff88 <__muldf3>
8012ad10:	dfc00217 	ldw	ra,8(sp)
8012ad14:	dc400117 	ldw	r17,4(sp)
8012ad18:	dc000017 	ldw	r16,0(sp)
8012ad1c:	dec00304 	addi	sp,sp,12
8012ad20:	f800283a 	ret

8012ad24 <_strtod_r>:
8012ad24:	deffe204 	addi	sp,sp,-120
8012ad28:	de00012e 	bgeu	sp,et,8012ad30 <_strtod_r+0xc>
8012ad2c:	003b68fa 	trap	3
8012ad30:	ddc01b15 	stw	r23,108(sp)
8012ad34:	dd001815 	stw	r20,96(sp)
8012ad38:	dc801615 	stw	r18,88(sp)
8012ad3c:	dc401515 	stw	r17,84(sp)
8012ad40:	dc001415 	stw	r16,80(sp)
8012ad44:	d9400615 	stw	r5,24(sp)
8012ad48:	dfc01d15 	stw	ra,116(sp)
8012ad4c:	df001c15 	stw	fp,112(sp)
8012ad50:	dd801a15 	stw	r22,104(sp)
8012ad54:	dd401915 	stw	r21,100(sp)
8012ad58:	dcc01715 	stw	r19,92(sp)
8012ad5c:	2021883a 	mov	r16,r4
8012ad60:	d8000515 	stw	zero,20(sp)
8012ad64:	2809883a 	mov	r4,r5
8012ad68:	20800003 	ldbu	r2,0(r4)
8012ad6c:	01e004f4 	movhi	r7,32787
8012ad70:	282f883a 	mov	r23,r5
8012ad74:	10c03fcc 	andi	r3,r2,255
8012ad78:	01400b44 	movi	r5,45
8012ad7c:	39eb6804 	addi	r7,r7,-21088
8012ad80:	3029883a 	mov	r20,r6
8012ad84:	0025883a 	mov	r18,zero
8012ad88:	0023883a 	mov	r17,zero
8012ad8c:	28c0ba36 	bltu	r5,r3,8012b078 <_strtod_r+0x354>
8012ad90:	180690ba 	slli	r3,r3,2
8012ad94:	19c7883a 	add	r3,r3,r7
8012ad98:	18c00017 	ldw	r3,0(r3)
8012ad9c:	1800683a 	jmp	r3
8012ada0:	8012ae60 	cmpeqi	zero,r16,19129
8012ada4:	8012b078 	rdprs	zero,r16,19137
8012ada8:	8012b078 	rdprs	zero,r16,19137
8012adac:	8012b078 	rdprs	zero,r16,19137
8012adb0:	8012b078 	rdprs	zero,r16,19137
8012adb4:	8012b078 	rdprs	zero,r16,19137
8012adb8:	8012b078 	rdprs	zero,r16,19137
8012adbc:	8012b078 	rdprs	zero,r16,19137
8012adc0:	8012b078 	rdprs	zero,r16,19137
8012adc4:	8012b064 	muli	zero,r16,19137
8012adc8:	8012b064 	muli	zero,r16,19137
8012adcc:	8012b064 	muli	zero,r16,19137
8012add0:	8012b064 	muli	zero,r16,19137
8012add4:	8012b064 	muli	zero,r16,19137
8012add8:	8012b078 	rdprs	zero,r16,19137
8012addc:	8012b078 	rdprs	zero,r16,19137
8012ade0:	8012b078 	rdprs	zero,r16,19137
8012ade4:	8012b078 	rdprs	zero,r16,19137
8012ade8:	8012b078 	rdprs	zero,r16,19137
8012adec:	8012b078 	rdprs	zero,r16,19137
8012adf0:	8012b078 	rdprs	zero,r16,19137
8012adf4:	8012b078 	rdprs	zero,r16,19137
8012adf8:	8012b078 	rdprs	zero,r16,19137
8012adfc:	8012b078 	rdprs	zero,r16,19137
8012ae00:	8012b078 	rdprs	zero,r16,19137
8012ae04:	8012b078 	rdprs	zero,r16,19137
8012ae08:	8012b078 	rdprs	zero,r16,19137
8012ae0c:	8012b078 	rdprs	zero,r16,19137
8012ae10:	8012b078 	rdprs	zero,r16,19137
8012ae14:	8012b078 	rdprs	zero,r16,19137
8012ae18:	8012b078 	rdprs	zero,r16,19137
8012ae1c:	8012b078 	rdprs	zero,r16,19137
8012ae20:	8012b064 	muli	zero,r16,19137
8012ae24:	8012b078 	rdprs	zero,r16,19137
8012ae28:	8012b078 	rdprs	zero,r16,19137
8012ae2c:	8012b078 	rdprs	zero,r16,19137
8012ae30:	8012b078 	rdprs	zero,r16,19137
8012ae34:	8012b078 	rdprs	zero,r16,19137
8012ae38:	8012b078 	rdprs	zero,r16,19137
8012ae3c:	8012b078 	rdprs	zero,r16,19137
8012ae40:	8012b078 	rdprs	zero,r16,19137
8012ae44:	8012b078 	rdprs	zero,r16,19137
8012ae48:	8012b078 	rdprs	zero,r16,19137
8012ae4c:	8012aeb8 	rdprs	zero,r16,19130
8012ae50:	8012b078 	rdprs	zero,r16,19137
8012ae54:	8012b058 	cmpnei	zero,r16,19137
8012ae58:	00801244 	movi	r2,73
8012ae5c:	88843526 	beq	r17,r2,8012bf34 <_strtod_r+0x1210>
8012ae60:	002b883a 	mov	r21,zero
8012ae64:	002d883a 	mov	r22,zero
8012ae68:	a0000526 	beq	r20,zero,8012ae80 <_strtod_r+0x15c>
8012ae6c:	d8000715 	stw	zero,28(sp)
8012ae70:	a5c00015 	stw	r23,0(r20)
8012ae74:	d9000717 	ldw	r4,28(sp)
8012ae78:	20000126 	beq	r4,zero,8012ae80 <_strtod_r+0x15c>
8012ae7c:	b5a0003c 	xorhi	r22,r22,32768
8012ae80:	a805883a 	mov	r2,r21
8012ae84:	b007883a 	mov	r3,r22
8012ae88:	dfc01d17 	ldw	ra,116(sp)
8012ae8c:	df001c17 	ldw	fp,112(sp)
8012ae90:	ddc01b17 	ldw	r23,108(sp)
8012ae94:	dd801a17 	ldw	r22,104(sp)
8012ae98:	dd401917 	ldw	r21,100(sp)
8012ae9c:	dd001817 	ldw	r20,96(sp)
8012aea0:	dcc01717 	ldw	r19,92(sp)
8012aea4:	dc801617 	ldw	r18,88(sp)
8012aea8:	dc401517 	ldw	r17,84(sp)
8012aeac:	dc001417 	ldw	r16,80(sp)
8012aeb0:	dec01e04 	addi	sp,sp,120
8012aeb4:	f800283a 	ret
8012aeb8:	d8000715 	stw	zero,28(sp)
8012aebc:	24c00044 	addi	r19,r4,1
8012aec0:	dcc00615 	stw	r19,24(sp)
8012aec4:	20800043 	ldbu	r2,1(r4)
8012aec8:	10c03fcc 	andi	r3,r2,255
8012aecc:	18c0201c 	xori	r3,r3,128
8012aed0:	18ffe004 	addi	r3,r3,-128
8012aed4:	183fe226 	beq	r3,zero,8012ae60 <__reset+0xfa10ae60>
8012aed8:	11403fcc 	andi	r5,r2,255
8012aedc:	2940201c 	xori	r5,r5,128
8012aee0:	297fe004 	addi	r5,r5,-128
8012aee4:	00c00c04 	movi	r3,48
8012aee8:	28c0e526 	beq	r5,r3,8012b280 <_strtod_r+0x55c>
8012aeec:	dcc00815 	stw	r19,32(sp)
8012aef0:	0025883a 	mov	r18,zero
8012aef4:	10fff404 	addi	r3,r2,-48
8012aef8:	18c03fcc 	andi	r3,r3,255
8012aefc:	01000244 	movi	r4,9
8012af00:	20c37536 	bltu	r4,r3,8012bcd8 <_strtod_r+0xfb4>
8012af04:	dd400817 	ldw	r21,32(sp)
8012af08:	0027883a 	mov	r19,zero
8012af0c:	0039883a 	mov	fp,zero
8012af10:	002d883a 	mov	r22,zero
8012af14:	01400204 	movi	r5,8
8012af18:	2d805a16 	blt	r5,r22,8012b084 <_strtod_r+0x360>
8012af1c:	e70002a4 	muli	fp,fp,10
8012af20:	10c03fcc 	andi	r3,r2,255
8012af24:	18c0201c 	xori	r3,r3,128
8012af28:	18ffe004 	addi	r3,r3,-128
8012af2c:	e0f9883a 	add	fp,fp,r3
8012af30:	e73ff404 	addi	fp,fp,-48
8012af34:	ad400044 	addi	r21,r21,1
8012af38:	dd400615 	stw	r21,24(sp)
8012af3c:	a8800003 	ldbu	r2,0(r21)
8012af40:	b5800044 	addi	r22,r22,1
8012af44:	10fff404 	addi	r3,r2,-48
8012af48:	18c03fcc 	andi	r3,r3,255
8012af4c:	20fff22e 	bgeu	r4,r3,8012af18 <__reset+0xfa10af18>
8012af50:	14403fcc 	andi	r17,r2,255
8012af54:	8c40201c 	xori	r17,r17,128
8012af58:	8c7fe004 	addi	r17,r17,-128
8012af5c:	8009883a 	mov	r4,r16
8012af60:	01284580 	call	80128458 <_localeconv_r>
8012af64:	11400017 	ldw	r5,0(r2)
8012af68:	8009883a 	mov	r4,r16
8012af6c:	d9401315 	stw	r5,76(sp)
8012af70:	01284580 	call	80128458 <_localeconv_r>
8012af74:	11000017 	ldw	r4,0(r2)
8012af78:	01219540 	call	80121954 <strlen>
8012af7c:	d9401317 	ldw	r5,76(sp)
8012af80:	100d883a 	mov	r6,r2
8012af84:	a809883a 	mov	r4,r21
8012af88:	012f5200 	call	8012f520 <strncmp>
8012af8c:	1000ce26 	beq	r2,zero,8012b2c8 <_strtod_r+0x5a4>
8012af90:	b013883a 	mov	r9,r22
8012af94:	000b883a 	mov	r5,zero
8012af98:	0015883a 	mov	r10,zero
8012af9c:	0017883a 	mov	r11,zero
8012afa0:	00801944 	movi	r2,101
8012afa4:	88807826 	beq	r17,r2,8012b188 <_strtod_r+0x464>
8012afa8:	00801144 	movi	r2,69
8012afac:	88807626 	beq	r17,r2,8012b188 <_strtod_r+0x464>
8012afb0:	002b883a 	mov	r21,zero
8012afb4:	48003d1e 	bne	r9,zero,8012b0ac <_strtod_r+0x388>
8012afb8:	2800391e 	bne	r5,zero,8012b0a0 <_strtod_r+0x37c>
8012afbc:	9000381e 	bne	r18,zero,8012b0a0 <_strtod_r+0x37c>
8012afc0:	583fa71e 	bne	r11,zero,8012ae60 <__reset+0xfa10ae60>
8012afc4:	00801384 	movi	r2,78
8012afc8:	88800526 	beq	r17,r2,8012afe0 <_strtod_r+0x2bc>
8012afcc:	147fa20e 	bge	r2,r17,8012ae58 <__reset+0xfa10ae58>
8012afd0:	00801a44 	movi	r2,105
8012afd4:	8883d726 	beq	r17,r2,8012bf34 <_strtod_r+0x1210>
8012afd8:	00801b84 	movi	r2,110
8012afdc:	88bfa01e 	bne	r17,r2,8012ae60 <__reset+0xfa10ae60>
8012afe0:	01600534 	movhi	r5,32788
8012afe4:	d9000617 	ldw	r4,24(sp)
8012afe8:	295f3704 	addi	r5,r5,31964
8012afec:	01c00644 	movi	r7,25
8012aff0:	00000b06 	br	8012b020 <_strtod_r+0x2fc>
8012aff4:	21000044 	addi	r4,r4,1
8012aff8:	20800003 	ldbu	r2,0(r4)
8012affc:	10ffefc4 	addi	r3,r2,-65
8012b000:	10803fcc 	andi	r2,r2,255
8012b004:	1080201c 	xori	r2,r2,128
8012b008:	18c03fcc 	andi	r3,r3,255
8012b00c:	10bfe004 	addi	r2,r2,-128
8012b010:	38c00136 	bltu	r7,r3,8012b018 <_strtod_r+0x2f4>
8012b014:	10800804 	addi	r2,r2,32
8012b018:	29400044 	addi	r5,r5,1
8012b01c:	11bf901e 	bne	r2,r6,8012ae60 <__reset+0xfa10ae60>
8012b020:	29800007 	ldb	r6,0(r5)
8012b024:	303ff31e 	bne	r6,zero,8012aff4 <__reset+0xfa10aff4>
8012b028:	20800044 	addi	r2,r4,1
8012b02c:	d8800615 	stw	r2,24(sp)
8012b030:	20c00047 	ldb	r3,1(r4)
8012b034:	00800a04 	movi	r2,40
8012b038:	18849d26 	beq	r3,r2,8012c2b0 <_strtod_r+0x158c>
8012b03c:	047ffe34 	movhi	r17,65528
8012b040:	0025883a 	mov	r18,zero
8012b044:	902b883a 	mov	r21,r18
8012b048:	882d883a 	mov	r22,r17
8012b04c:	a03f8926 	beq	r20,zero,8012ae74 <__reset+0xfa10ae74>
8012b050:	ddc00617 	ldw	r23,24(sp)
8012b054:	003f8606 	br	8012ae70 <__reset+0xfa10ae70>
8012b058:	00800044 	movi	r2,1
8012b05c:	d8800715 	stw	r2,28(sp)
8012b060:	003f9606 	br	8012aebc <__reset+0xfa10aebc>
8012b064:	21000044 	addi	r4,r4,1
8012b068:	d9000615 	stw	r4,24(sp)
8012b06c:	20800003 	ldbu	r2,0(r4)
8012b070:	10c03fcc 	andi	r3,r2,255
8012b074:	28ff462e 	bgeu	r5,r3,8012ad90 <__reset+0xfa10ad90>
8012b078:	2027883a 	mov	r19,r4
8012b07c:	d8000715 	stw	zero,28(sp)
8012b080:	003f9506 	br	8012aed8 <__reset+0xfa10aed8>
8012b084:	9cc002a4 	muli	r19,r19,10
8012b088:	10803fcc 	andi	r2,r2,255
8012b08c:	1080201c 	xori	r2,r2,128
8012b090:	10bfe004 	addi	r2,r2,-128
8012b094:	9885883a 	add	r2,r19,r2
8012b098:	14fff404 	addi	r19,r2,-48
8012b09c:	003fa506 	br	8012af34 <__reset+0xfa10af34>
8012b0a0:	002b883a 	mov	r21,zero
8012b0a4:	002d883a 	mov	r22,zero
8012b0a8:	003fe806 	br	8012b04c <__reset+0xfa10b04c>
8012b0ac:	aaabc83a 	sub	r21,r21,r10
8012b0b0:	b000011e 	bne	r22,zero,8012b0b8 <_strtod_r+0x394>
8012b0b4:	482d883a 	mov	r22,r9
8012b0b8:	00800404 	movi	r2,16
8012b0bc:	482f883a 	mov	r23,r9
8012b0c0:	1240010e 	bge	r2,r9,8012b0c8 <_strtod_r+0x3a4>
8012b0c4:	102f883a 	mov	r23,r2
8012b0c8:	e009883a 	mov	r4,fp
8012b0cc:	da401315 	stw	r9,76(sp)
8012b0d0:	01318400 	call	80131840 <__floatunsidf>
8012b0d4:	1025883a 	mov	r18,r2
8012b0d8:	00800244 	movi	r2,9
8012b0dc:	1823883a 	mov	r17,r3
8012b0e0:	da401317 	ldw	r9,76(sp)
8012b0e4:	15c0160e 	bge	r2,r23,8012b140 <_strtod_r+0x41c>
8012b0e8:	b8bffdc4 	addi	r2,r23,-9
8012b0ec:	100490fa 	slli	r2,r2,3
8012b0f0:	180b883a 	mov	r5,r3
8012b0f4:	00e00534 	movhi	r3,32788
8012b0f8:	18df0204 	addi	r3,r3,31752
8012b0fc:	1885883a 	add	r2,r3,r2
8012b100:	11800017 	ldw	r6,0(r2)
8012b104:	11c00117 	ldw	r7,4(r2)
8012b108:	9009883a 	mov	r4,r18
8012b10c:	011ff880 	call	8011ff88 <__muldf3>
8012b110:	9809883a 	mov	r4,r19
8012b114:	1025883a 	mov	r18,r2
8012b118:	1823883a 	mov	r17,r3
8012b11c:	01318400 	call	80131840 <__floatunsidf>
8012b120:	9009883a 	mov	r4,r18
8012b124:	880b883a 	mov	r5,r17
8012b128:	100d883a 	mov	r6,r2
8012b12c:	180f883a 	mov	r7,r3
8012b130:	01305200 	call	80130520 <__adddf3>
8012b134:	da401317 	ldw	r9,76(sp)
8012b138:	1025883a 	mov	r18,r2
8012b13c:	1823883a 	mov	r17,r3
8012b140:	008003c4 	movi	r2,15
8012b144:	12407b16 	blt	r2,r9,8012b334 <_strtod_r+0x610>
8012b148:	a83fbe26 	beq	r21,zero,8012b044 <__reset+0xfa10b044>
8012b14c:	0543670e 	bge	zero,r21,8012beec <_strtod_r+0x11c8>
8012b150:	00c00584 	movi	r3,22
8012b154:	1d42e816 	blt	r3,r21,8012bcf8 <_strtod_r+0xfd4>
8012b158:	a82a90fa 	slli	r21,r21,3
8012b15c:	00a00534 	movhi	r2,32788
8012b160:	109f0204 	addi	r2,r2,31752
8012b164:	1545883a 	add	r2,r2,r21
8012b168:	11000017 	ldw	r4,0(r2)
8012b16c:	11400117 	ldw	r5,4(r2)
8012b170:	900d883a 	mov	r6,r18
8012b174:	880f883a 	mov	r7,r17
8012b178:	011ff880 	call	8011ff88 <__muldf3>
8012b17c:	102b883a 	mov	r21,r2
8012b180:	182d883a 	mov	r22,r3
8012b184:	003fb106 	br	8012b04c <__reset+0xfa10b04c>
8012b188:	4801b526 	beq	r9,zero,8012b860 <_strtod_r+0xb3c>
8012b18c:	ddc00617 	ldw	r23,24(sp)
8012b190:	00c00ac4 	movi	r3,43
8012b194:	b8800044 	addi	r2,r23,1
8012b198:	d8800615 	stw	r2,24(sp)
8012b19c:	b8800047 	ldb	r2,1(r23)
8012b1a0:	10c1e926 	beq	r2,r3,8012b948 <_strtod_r+0xc24>
8012b1a4:	00c00b44 	movi	r3,45
8012b1a8:	10c1ec26 	beq	r2,r3,8012b95c <_strtod_r+0xc38>
8012b1ac:	1023883a 	mov	r17,r2
8012b1b0:	0019883a 	mov	r12,zero
8012b1b4:	88bff404 	addi	r2,r17,-48
8012b1b8:	00c00244 	movi	r3,9
8012b1bc:	1881b736 	bltu	r3,r2,8012b89c <_strtod_r+0xb78>
8012b1c0:	00800c04 	movi	r2,48
8012b1c4:	8880071e 	bne	r17,r2,8012b1e4 <_strtod_r+0x4c0>
8012b1c8:	d8800617 	ldw	r2,24(sp)
8012b1cc:	8807883a 	mov	r3,r17
8012b1d0:	10800044 	addi	r2,r2,1
8012b1d4:	d8800615 	stw	r2,24(sp)
8012b1d8:	14400007 	ldb	r17,0(r2)
8012b1dc:	10800044 	addi	r2,r2,1
8012b1e0:	88fffc26 	beq	r17,r3,8012b1d4 <__reset+0xfa10b1d4>
8012b1e4:	88bff3c4 	addi	r2,r17,-49
8012b1e8:	00c00204 	movi	r3,8
8012b1ec:	18bf7036 	bltu	r3,r2,8012afb0 <__reset+0xfa10afb0>
8012b1f0:	db800617 	ldw	r14,24(sp)
8012b1f4:	88bff404 	addi	r2,r17,-48
8012b1f8:	03400244 	movi	r13,9
8012b1fc:	71c00044 	addi	r7,r14,1
8012b200:	d9c00615 	stw	r7,24(sp)
8012b204:	74400043 	ldbu	r17,1(r14)
8012b208:	88fff404 	addi	r3,r17,-48
8012b20c:	8c403fcc 	andi	r17,r17,255
8012b210:	8c40201c 	xori	r17,r17,128
8012b214:	18c03fcc 	andi	r3,r3,255
8012b218:	8c7fe004 	addi	r17,r17,-128
8012b21c:	68c00e36 	bltu	r13,r3,8012b258 <_strtod_r+0x534>
8012b220:	71000084 	addi	r4,r14,2
8012b224:	d9000615 	stw	r4,24(sp)
8012b228:	108002a4 	muli	r2,r2,10
8012b22c:	21800003 	ldbu	r6,0(r4)
8012b230:	200f883a 	mov	r7,r4
8012b234:	1463883a 	add	r17,r2,r17
8012b238:	30fff404 	addi	r3,r6,-48
8012b23c:	88bff404 	addi	r2,r17,-48
8012b240:	34403fcc 	andi	r17,r6,255
8012b244:	8c40201c 	xori	r17,r17,128
8012b248:	18c03fcc 	andi	r3,r3,255
8012b24c:	8c7fe004 	addi	r17,r17,-128
8012b250:	21000044 	addi	r4,r4,1
8012b254:	68fff32e 	bgeu	r13,r3,8012b224 <__reset+0xfa10b224>
8012b258:	3b8fc83a 	sub	r7,r7,r14
8012b25c:	00c00204 	movi	r3,8
8012b260:	19c29716 	blt	r3,r7,8012bcc0 <_strtod_r+0xf9c>
8012b264:	102b883a 	mov	r21,r2
8012b268:	009387c4 	movi	r2,19999
8012b26c:	1540010e 	bge	r2,r21,8012b274 <_strtod_r+0x550>
8012b270:	102b883a 	mov	r21,r2
8012b274:	603f4f26 	beq	r12,zero,8012afb4 <__reset+0xfa10afb4>
8012b278:	056bc83a 	sub	r21,zero,r21
8012b27c:	003f4d06 	br	8012afb4 <__reset+0xfa10afb4>
8012b280:	98800047 	ldb	r2,1(r19)
8012b284:	00c01604 	movi	r3,88
8012b288:	10c1de26 	beq	r2,r3,8012ba04 <_strtod_r+0xce0>
8012b28c:	00c01e04 	movi	r3,120
8012b290:	10c1dc26 	beq	r2,r3,8012ba04 <_strtod_r+0xce0>
8012b294:	98c00044 	addi	r3,r19,1
8012b298:	1827883a 	mov	r19,r3
8012b29c:	d8c00615 	stw	r3,24(sp)
8012b2a0:	18c00044 	addi	r3,r3,1
8012b2a4:	18bfffc3 	ldbu	r2,-1(r3)
8012b2a8:	11003fcc 	andi	r4,r2,255
8012b2ac:	2100201c 	xori	r4,r4,128
8012b2b0:	213fe004 	addi	r4,r4,-128
8012b2b4:	217ff826 	beq	r4,r5,8012b298 <__reset+0xfa10b298>
8012b2b8:	203f7926 	beq	r4,zero,8012b0a0 <__reset+0xfa10b0a0>
8012b2bc:	dcc00815 	stw	r19,32(sp)
8012b2c0:	04800044 	movi	r18,1
8012b2c4:	003f0b06 	br	8012aef4 <__reset+0xfa10aef4>
8012b2c8:	8009883a 	mov	r4,r16
8012b2cc:	01284580 	call	80128458 <_localeconv_r>
8012b2d0:	11000017 	ldw	r4,0(r2)
8012b2d4:	01219540 	call	80121954 <strlen>
8012b2d8:	d8c00617 	ldw	r3,24(sp)
8012b2dc:	1885883a 	add	r2,r3,r2
8012b2e0:	d8800615 	stw	r2,24(sp)
8012b2e4:	14400007 	ldb	r17,0(r2)
8012b2e8:	b001881e 	bne	r22,zero,8012b90c <_strtod_r+0xbe8>
8012b2ec:	00c00c04 	movi	r3,48
8012b2f0:	88c3391e 	bne	r17,r3,8012bfd8 <_strtod_r+0x12b4>
8012b2f4:	10c00044 	addi	r3,r2,1
8012b2f8:	8809883a 	mov	r4,r17
8012b2fc:	d8c00615 	stw	r3,24(sp)
8012b300:	1c400007 	ldb	r17,0(r3)
8012b304:	188bc83a 	sub	r5,r3,r2
8012b308:	18c00044 	addi	r3,r3,1
8012b30c:	893ffb26 	beq	r17,r4,8012b2fc <__reset+0xfa10b2fc>
8012b310:	88bff3c4 	addi	r2,r17,-49
8012b314:	00c00204 	movi	r3,8
8012b318:	1882e72e 	bgeu	r3,r2,8012beb8 <_strtod_r+0x1194>
8012b31c:	00801944 	movi	r2,101
8012b320:	88814d26 	beq	r17,r2,8012b858 <_strtod_r+0xb34>
8012b324:	0013883a 	mov	r9,zero
8012b328:	0015883a 	mov	r10,zero
8012b32c:	02c00044 	movi	r11,1
8012b330:	003f1d06 	br	8012afa8 <__reset+0xfa10afa8>
8012b334:	4defc83a 	sub	r23,r9,r23
8012b338:	bd6f883a 	add	r23,r23,r21
8012b33c:	05c21e0e 	bge	zero,r23,8012bbb8 <_strtod_r+0xe94>
8012b340:	b88003cc 	andi	r2,r23,15
8012b344:	10000d26 	beq	r2,zero,8012b37c <_strtod_r+0x658>
8012b348:	100490fa 	slli	r2,r2,3
8012b34c:	00e00534 	movhi	r3,32788
8012b350:	18df0204 	addi	r3,r3,31752
8012b354:	1885883a 	add	r2,r3,r2
8012b358:	11000017 	ldw	r4,0(r2)
8012b35c:	11400117 	ldw	r5,4(r2)
8012b360:	900d883a 	mov	r6,r18
8012b364:	880f883a 	mov	r7,r17
8012b368:	da401315 	stw	r9,76(sp)
8012b36c:	011ff880 	call	8011ff88 <__muldf3>
8012b370:	da401317 	ldw	r9,76(sp)
8012b374:	1025883a 	mov	r18,r2
8012b378:	1823883a 	mov	r17,r3
8012b37c:	023ffc04 	movi	r8,-16
8012b380:	ba10703a 	and	r8,r23,r8
8012b384:	40003c26 	beq	r8,zero,8012b478 <_strtod_r+0x754>
8012b388:	00804d04 	movi	r2,308
8012b38c:	1201cd16 	blt	r2,r8,8012bac4 <_strtod_r+0xda0>
8012b390:	4011d13a 	srai	r8,r8,4
8012b394:	03000044 	movi	r12,1
8012b398:	62037c0e 	bge	r12,r8,8012c18c <_strtod_r+0x1468>
8012b39c:	01200534 	movhi	r4,32788
8012b3a0:	211ef804 	addi	r4,r4,31712
8012b3a4:	2015883a 	mov	r10,r4
8012b3a8:	0027883a 	mov	r19,zero
8012b3ac:	d9000915 	stw	r4,36(sp)
8012b3b0:	9005883a 	mov	r2,r18
8012b3b4:	8807883a 	mov	r3,r17
8012b3b8:	dc000c15 	stw	r16,48(sp)
8012b3bc:	dc800e15 	stw	r18,56(sp)
8012b3c0:	9821883a 	mov	r16,r19
8012b3c4:	0009883a 	mov	r4,zero
8012b3c8:	8827883a 	mov	r19,r17
8012b3cc:	602f883a 	mov	r23,r12
8012b3d0:	da400a15 	stw	r9,40(sp)
8012b3d4:	5025883a 	mov	r18,r10
8012b3d8:	4023883a 	mov	r17,r8
8012b3dc:	8980004c 	andi	r6,r17,1
8012b3e0:	30000626 	beq	r6,zero,8012b3fc <_strtod_r+0x6d8>
8012b3e4:	91800017 	ldw	r6,0(r18)
8012b3e8:	91c00117 	ldw	r7,4(r18)
8012b3ec:	1009883a 	mov	r4,r2
8012b3f0:	180b883a 	mov	r5,r3
8012b3f4:	011ff880 	call	8011ff88 <__muldf3>
8012b3f8:	01000044 	movi	r4,1
8012b3fc:	8823d07a 	srai	r17,r17,1
8012b400:	84000044 	addi	r16,r16,1
8012b404:	94800204 	addi	r18,r18,8
8012b408:	8dfff41e 	bne	r17,r23,8012b3dc <__reset+0xfa10b3dc>
8012b40c:	21003fcc 	andi	r4,r4,255
8012b410:	9823883a 	mov	r17,r19
8012b414:	da400a17 	ldw	r9,40(sp)
8012b418:	8027883a 	mov	r19,r16
8012b41c:	dc800e17 	ldw	r18,56(sp)
8012b420:	dc000c17 	ldw	r16,48(sp)
8012b424:	2003b11e 	bne	r4,zero,8012c2ec <_strtod_r+0x15c8>
8012b428:	981690fa 	slli	r11,r19,3
8012b42c:	d8800917 	ldw	r2,36(sp)
8012b430:	01ff2c34 	movhi	r7,64688
8012b434:	900d883a 	mov	r6,r18
8012b438:	12ef883a 	add	r23,r2,r11
8012b43c:	b9000017 	ldw	r4,0(r23)
8012b440:	b9400117 	ldw	r5,4(r23)
8012b444:	89cf883a 	add	r7,r17,r7
8012b448:	da401315 	stw	r9,76(sp)
8012b44c:	011ff880 	call	8011ff88 <__muldf3>
8012b450:	1025883a 	mov	r18,r2
8012b454:	011f2834 	movhi	r4,31904
8012b458:	189ffc2c 	andhi	r2,r3,32752
8012b45c:	da401317 	ldw	r9,76(sp)
8012b460:	20819836 	bltu	r4,r2,8012bac4 <_strtod_r+0xda0>
8012b464:	011f2434 	movhi	r4,31888
8012b468:	2083382e 	bgeu	r4,r2,8012c14c <_strtod_r+0x1428>
8012b46c:	045ffc34 	movhi	r17,32752
8012b470:	8c7fffc4 	addi	r17,r17,-1
8012b474:	04bfffc4 	movi	r18,-1
8012b478:	d8000915 	stw	zero,36(sp)
8012b47c:	d9400817 	ldw	r5,32(sp)
8012b480:	df000015 	stw	fp,0(sp)
8012b484:	480f883a 	mov	r7,r9
8012b488:	b00d883a 	mov	r6,r22
8012b48c:	8009883a 	mov	r4,r16
8012b490:	01293200 	call	80129320 <__s2b>
8012b494:	d8800815 	stw	r2,32(sp)
8012b498:	10018a26 	beq	r2,zero,8012bac4 <_strtod_r+0xda0>
8012b49c:	a807d7fa 	srai	r3,r21,31
8012b4a0:	0545c83a 	sub	r2,zero,r21
8012b4a4:	dd400a15 	stw	r21,40(sp)
8012b4a8:	1886703a 	and	r3,r3,r2
8012b4ac:	d8c00c15 	stw	r3,48(sp)
8012b4b0:	a8013516 	blt	r21,zero,8012b988 <_strtod_r+0xc64>
8012b4b4:	d9400817 	ldw	r5,32(sp)
8012b4b8:	0011883a 	mov	r8,zero
8012b4bc:	0027883a 	mov	r19,zero
8012b4c0:	29400304 	addi	r5,r5,12
8012b4c4:	d9400f15 	stw	r5,60(sp)
8012b4c8:	402b883a 	mov	r21,r8
8012b4cc:	dd001215 	stw	r20,72(sp)
8012b4d0:	d8800817 	ldw	r2,32(sp)
8012b4d4:	8009883a 	mov	r4,r16
8012b4d8:	11400117 	ldw	r5,4(r2)
8012b4dc:	01291200 	call	80129120 <_Balloc>
8012b4e0:	1029883a 	mov	r20,r2
8012b4e4:	10012d26 	beq	r2,zero,8012b99c <_strtod_r+0xc78>
8012b4e8:	d8c00817 	ldw	r3,32(sp)
8012b4ec:	d9400f17 	ldw	r5,60(sp)
8012b4f0:	11000304 	addi	r4,r2,12
8012b4f4:	19800417 	ldw	r6,16(r3)
8012b4f8:	31800084 	addi	r6,r6,2
8012b4fc:	318d883a 	add	r6,r6,r6
8012b500:	318d883a 	add	r6,r6,r6
8012b504:	01214640 	call	80121464 <memcpy>
8012b508:	d9000204 	addi	r4,sp,8
8012b50c:	d9000015 	stw	r4,0(sp)
8012b510:	d9c00404 	addi	r7,sp,16
8012b514:	900b883a 	mov	r5,r18
8012b518:	880d883a 	mov	r6,r17
8012b51c:	8009883a 	mov	r4,r16
8012b520:	0129dfc0 	call	80129dfc <__d2b>
8012b524:	d8800515 	stw	r2,20(sp)
8012b528:	dc801115 	stw	r18,68(sp)
8012b52c:	dc401015 	stw	r17,64(sp)
8012b530:	10027c26 	beq	r2,zero,8012bf24 <_strtod_r+0x1200>
8012b534:	01400044 	movi	r5,1
8012b538:	8009883a 	mov	r4,r16
8012b53c:	01295440 	call	80129544 <__i2b>
8012b540:	1027883a 	mov	r19,r2
8012b544:	10011526 	beq	r2,zero,8012b99c <_strtod_r+0xc78>
8012b548:	d8800417 	ldw	r2,16(sp)
8012b54c:	1000c816 	blt	r2,zero,8012b870 <_strtod_r+0xb4c>
8012b550:	d9400c17 	ldw	r5,48(sp)
8012b554:	d9000a17 	ldw	r4,40(sp)
8012b558:	28ad883a 	add	r22,r5,r2
8012b55c:	d9400917 	ldw	r5,36(sp)
8012b560:	df000217 	ldw	fp,8(sp)
8012b564:	05ff0084 	movi	r23,-1022
8012b568:	1147c83a 	sub	r3,r2,r5
8012b56c:	1f07883a 	add	r3,r3,fp
8012b570:	00800d84 	movi	r2,54
8012b574:	18ffffc4 	addi	r3,r3,-1
8012b578:	1739c83a 	sub	fp,r2,fp
8012b57c:	1dc0a50e 	bge	r3,r23,8012b814 <_strtod_r+0xaf0>
8012b580:	b8efc83a 	sub	r23,r23,r3
8012b584:	008007c4 	movi	r2,31
8012b588:	e5f9c83a 	sub	fp,fp,r23
8012b58c:	15c0bc16 	blt	r2,r23,8012b880 <_strtod_r+0xb5c>
8012b590:	00800044 	movi	r2,1
8012b594:	15c4983a 	sll	r2,r2,r23
8012b598:	d8000b15 	stw	zero,44(sp)
8012b59c:	d8800d15 	stw	r2,52(sp)
8012b5a0:	2707883a 	add	r3,r4,fp
8012b5a4:	d9000917 	ldw	r4,36(sp)
8012b5a8:	b739883a 	add	fp,r22,fp
8012b5ac:	20ef883a 	add	r23,r4,r3
8012b5b0:	b009883a 	mov	r4,r22
8012b5b4:	e580010e 	bge	fp,r22,8012b5bc <_strtod_r+0x898>
8012b5b8:	e009883a 	mov	r4,fp
8012b5bc:	b805883a 	mov	r2,r23
8012b5c0:	25c0010e 	bge	r4,r23,8012b5c8 <_strtod_r+0x8a4>
8012b5c4:	2005883a 	mov	r2,r4
8012b5c8:	0080030e 	bge	zero,r2,8012b5d8 <_strtod_r+0x8b4>
8012b5cc:	e0b9c83a 	sub	fp,fp,r2
8012b5d0:	b8afc83a 	sub	r23,r23,r2
8012b5d4:	b0adc83a 	sub	r22,r22,r2
8012b5d8:	d9400c17 	ldw	r5,48(sp)
8012b5dc:	28001126 	beq	r5,zero,8012b624 <_strtod_r+0x900>
8012b5e0:	280d883a 	mov	r6,r5
8012b5e4:	8009883a 	mov	r4,r16
8012b5e8:	980b883a 	mov	r5,r19
8012b5ec:	01297880 	call	80129788 <__pow5mult>
8012b5f0:	1027883a 	mov	r19,r2
8012b5f4:	1000e926 	beq	r2,zero,8012b99c <_strtod_r+0xc78>
8012b5f8:	d9800517 	ldw	r6,20(sp)
8012b5fc:	100b883a 	mov	r5,r2
8012b600:	8009883a 	mov	r4,r16
8012b604:	01295880 	call	80129588 <__multiply>
8012b608:	1000e426 	beq	r2,zero,8012b99c <_strtod_r+0xc78>
8012b60c:	d9400517 	ldw	r5,20(sp)
8012b610:	8009883a 	mov	r4,r16
8012b614:	d8801315 	stw	r2,76(sp)
8012b618:	01291d00 	call	801291d0 <_Bfree>
8012b61c:	d8801317 	ldw	r2,76(sp)
8012b620:	d8800515 	stw	r2,20(sp)
8012b624:	0700060e 	bge	zero,fp,8012b640 <_strtod_r+0x91c>
8012b628:	d9400517 	ldw	r5,20(sp)
8012b62c:	e00d883a 	mov	r6,fp
8012b630:	8009883a 	mov	r4,r16
8012b634:	01298d00 	call	801298d0 <__lshift>
8012b638:	d8800515 	stw	r2,20(sp)
8012b63c:	10023926 	beq	r2,zero,8012bf24 <_strtod_r+0x1200>
8012b640:	d8800a17 	ldw	r2,40(sp)
8012b644:	10000626 	beq	r2,zero,8012b660 <_strtod_r+0x93c>
8012b648:	d9800a17 	ldw	r6,40(sp)
8012b64c:	a00b883a 	mov	r5,r20
8012b650:	8009883a 	mov	r4,r16
8012b654:	01297880 	call	80129788 <__pow5mult>
8012b658:	1029883a 	mov	r20,r2
8012b65c:	1000cf26 	beq	r2,zero,8012b99c <_strtod_r+0xc78>
8012b660:	05c0060e 	bge	zero,r23,8012b67c <_strtod_r+0x958>
8012b664:	a00b883a 	mov	r5,r20
8012b668:	b80d883a 	mov	r6,r23
8012b66c:	8009883a 	mov	r4,r16
8012b670:	01298d00 	call	801298d0 <__lshift>
8012b674:	1029883a 	mov	r20,r2
8012b678:	1000c826 	beq	r2,zero,8012b99c <_strtod_r+0xc78>
8012b67c:	0580060e 	bge	zero,r22,8012b698 <_strtod_r+0x974>
8012b680:	980b883a 	mov	r5,r19
8012b684:	b00d883a 	mov	r6,r22
8012b688:	8009883a 	mov	r4,r16
8012b68c:	01298d00 	call	801298d0 <__lshift>
8012b690:	1027883a 	mov	r19,r2
8012b694:	1000c126 	beq	r2,zero,8012b99c <_strtod_r+0xc78>
8012b698:	d9400517 	ldw	r5,20(sp)
8012b69c:	a00d883a 	mov	r6,r20
8012b6a0:	8009883a 	mov	r4,r16
8012b6a4:	0129a800 	call	80129a80 <__mdiff>
8012b6a8:	102b883a 	mov	r21,r2
8012b6ac:	1000bb26 	beq	r2,zero,8012b99c <_strtod_r+0xc78>
8012b6b0:	10c00317 	ldw	r3,12(r2)
8012b6b4:	980b883a 	mov	r5,r19
8012b6b8:	10000315 	stw	zero,12(r2)
8012b6bc:	1009883a 	mov	r4,r2
8012b6c0:	d8c00e15 	stw	r3,56(sp)
8012b6c4:	0129a200 	call	80129a20 <__mcmp>
8012b6c8:	10027616 	blt	r2,zero,8012c0a4 <_strtod_r+0x1380>
8012b6cc:	10024426 	beq	r2,zero,8012bfe0 <_strtod_r+0x12bc>
8012b6d0:	980b883a 	mov	r5,r19
8012b6d4:	a809883a 	mov	r4,r21
8012b6d8:	0129f500 	call	80129f50 <__ratio>
8012b6dc:	000d883a 	mov	r6,zero
8012b6e0:	01d00034 	movhi	r7,16384
8012b6e4:	1009883a 	mov	r4,r2
8012b6e8:	180b883a 	mov	r5,r3
8012b6ec:	102f883a 	mov	r23,r2
8012b6f0:	182d883a 	mov	r22,r3
8012b6f4:	013174c0 	call	8013174c <__ledf2>
8012b6f8:	00804a16 	blt	zero,r2,8012b824 <_strtod_r+0xb00>
8012b6fc:	d9400e17 	ldw	r5,56(sp)
8012b700:	28006b26 	beq	r5,zero,8012b8b0 <_strtod_r+0xb8c>
8012b704:	058ffc34 	movhi	r22,16368
8012b708:	d8000b15 	stw	zero,44(sp)
8012b70c:	d8000d15 	stw	zero,52(sp)
8012b710:	b02f883a 	mov	r23,r22
8012b714:	8f1ffc2c 	andhi	fp,r17,32752
8012b718:	009ff834 	movhi	r2,32736
8012b71c:	e080cd26 	beq	fp,r2,8012ba54 <_strtod_r+0xd30>
8012b720:	d9400917 	ldw	r5,36(sp)
8012b724:	28001a26 	beq	r5,zero,8012b790 <_strtod_r+0xa6c>
8012b728:	0081a834 	movhi	r2,1696
8012b72c:	17001836 	bltu	r2,fp,8012b790 <_strtod_r+0xa6c>
8012b730:	d9000d17 	ldw	r4,52(sp)
8012b734:	01d07834 	movhi	r7,16864
8012b738:	39ffffc4 	addi	r7,r7,-1
8012b73c:	01bff034 	movhi	r6,65472
8012b740:	b80b883a 	mov	r5,r23
8012b744:	013174c0 	call	8013174c <__ledf2>
8012b748:	00800e16 	blt	zero,r2,8012b784 <_strtod_r+0xa60>
8012b74c:	d9000d17 	ldw	r4,52(sp)
8012b750:	b80b883a 	mov	r5,r23
8012b754:	011f4ec0 	call	8011f4ec <__fixunsdfsi>
8012b758:	10018126 	beq	r2,zero,8012bd60 <_strtod_r+0x103c>
8012b75c:	1009883a 	mov	r4,r2
8012b760:	01318400 	call	80131840 <__floatunsidf>
8012b764:	d8800d15 	stw	r2,52(sp)
8012b768:	182f883a 	mov	r23,r3
8012b76c:	d8800e17 	ldw	r2,56(sp)
8012b770:	1001791e 	bne	r2,zero,8012bd58 <_strtod_r+0x1034>
8012b774:	ba20003c 	xorhi	r8,r23,32768
8012b778:	d8c00d17 	ldw	r3,52(sp)
8012b77c:	402d883a 	mov	r22,r8
8012b780:	d8c00b15 	stw	r3,44(sp)
8012b784:	0081ac34 	movhi	r2,1712
8012b788:	b091883a 	add	r8,r22,r2
8012b78c:	472dc83a 	sub	r22,r8,fp
8012b790:	9009883a 	mov	r4,r18
8012b794:	880b883a 	mov	r5,r17
8012b798:	0129c840 	call	80129c84 <__ulp>
8012b79c:	d9000b17 	ldw	r4,44(sp)
8012b7a0:	b00b883a 	mov	r5,r22
8012b7a4:	100d883a 	mov	r6,r2
8012b7a8:	180f883a 	mov	r7,r3
8012b7ac:	011ff880 	call	8011ff88 <__muldf3>
8012b7b0:	900d883a 	mov	r6,r18
8012b7b4:	880f883a 	mov	r7,r17
8012b7b8:	1009883a 	mov	r4,r2
8012b7bc:	180b883a 	mov	r5,r3
8012b7c0:	01305200 	call	80130520 <__adddf3>
8012b7c4:	1025883a 	mov	r18,r2
8012b7c8:	1823883a 	mov	r17,r3
8012b7cc:	182d883a 	mov	r22,r3
8012b7d0:	d9000917 	ldw	r4,36(sp)
8012b7d4:	2000021e 	bne	r4,zero,8012b7e0 <_strtod_r+0xabc>
8012b7d8:	b09ffc2c 	andhi	r2,r22,32752
8012b7dc:	e080be26 	beq	fp,r2,8012bad8 <_strtod_r+0xdb4>
8012b7e0:	d9400517 	ldw	r5,20(sp)
8012b7e4:	8009883a 	mov	r4,r16
8012b7e8:	01291d00 	call	801291d0 <_Bfree>
8012b7ec:	a00b883a 	mov	r5,r20
8012b7f0:	8009883a 	mov	r4,r16
8012b7f4:	01291d00 	call	801291d0 <_Bfree>
8012b7f8:	980b883a 	mov	r5,r19
8012b7fc:	8009883a 	mov	r4,r16
8012b800:	01291d00 	call	801291d0 <_Bfree>
8012b804:	a80b883a 	mov	r5,r21
8012b808:	8009883a 	mov	r4,r16
8012b80c:	01291d00 	call	801291d0 <_Bfree>
8012b810:	003f2f06 	br	8012b4d0 <__reset+0xfa10b4d0>
8012b814:	00c00044 	movi	r3,1
8012b818:	d8000b15 	stw	zero,44(sp)
8012b81c:	d8c00d15 	stw	r3,52(sp)
8012b820:	003f5f06 	br	8012b5a0 <__reset+0xfa10b5a0>
8012b824:	b809883a 	mov	r4,r23
8012b828:	000d883a 	mov	r6,zero
8012b82c:	01cff834 	movhi	r7,16352
8012b830:	b00b883a 	mov	r5,r22
8012b834:	011ff880 	call	8011ff88 <__muldf3>
8012b838:	d9000e17 	ldw	r4,56(sp)
8012b83c:	d8800d15 	stw	r2,52(sp)
8012b840:	182f883a 	mov	r23,r3
8012b844:	2000181e 	bne	r4,zero,8012b8a8 <_strtod_r+0xb84>
8012b848:	1a20003c 	xorhi	r8,r3,32768
8012b84c:	d8800b15 	stw	r2,44(sp)
8012b850:	402d883a 	mov	r22,r8
8012b854:	003faf06 	br	8012b714 <__reset+0xfa10b714>
8012b858:	0015883a 	mov	r10,zero
8012b85c:	02c00044 	movi	r11,1
8012b860:	2800011e 	bne	r5,zero,8012b868 <_strtod_r+0xb44>
8012b864:	903d7e26 	beq	r18,zero,8012ae60 <__reset+0xfa10ae60>
8012b868:	0013883a 	mov	r9,zero
8012b86c:	003e4706 	br	8012b18c <__reset+0xfa10b18c>
8012b870:	d8c00a17 	ldw	r3,40(sp)
8012b874:	dd800c17 	ldw	r22,48(sp)
8012b878:	1889c83a 	sub	r4,r3,r2
8012b87c:	003f3706 	br	8012b55c <__reset+0xfa10b55c>
8012b880:	00bef884 	movi	r2,-1054
8012b884:	05c00044 	movi	r23,1
8012b888:	10c5c83a 	sub	r2,r2,r3
8012b88c:	b884983a 	sll	r2,r23,r2
8012b890:	ddc00d15 	stw	r23,52(sp)
8012b894:	d8800b15 	stw	r2,44(sp)
8012b898:	003f4106 	br	8012b5a0 <__reset+0xfa10b5a0>
8012b89c:	ddc00615 	stw	r23,24(sp)
8012b8a0:	002b883a 	mov	r21,zero
8012b8a4:	003dc306 	br	8012afb4 <__reset+0xfa10afb4>
8012b8a8:	1811883a 	mov	r8,r3
8012b8ac:	003fe706 	br	8012b84c <__reset+0xfa10b84c>
8012b8b0:	90002e1e 	bne	r18,zero,8012b96c <_strtod_r+0xc48>
8012b8b4:	00c00434 	movhi	r3,16
8012b8b8:	18ffffc4 	addi	r3,r3,-1
8012b8bc:	88c4703a 	and	r2,r17,r3
8012b8c0:	10002c1e 	bne	r2,zero,8012b974 <_strtod_r+0xc50>
8012b8c4:	000d883a 	mov	r6,zero
8012b8c8:	01cffc34 	movhi	r7,16368
8012b8cc:	b809883a 	mov	r4,r23
8012b8d0:	b00b883a 	mov	r5,r22
8012b8d4:	013174c0 	call	8013174c <__ledf2>
8012b8d8:	10021716 	blt	r2,zero,8012c138 <_strtod_r+0x1414>
8012b8dc:	b809883a 	mov	r4,r23
8012b8e0:	b00b883a 	mov	r5,r22
8012b8e4:	000d883a 	mov	r6,zero
8012b8e8:	01cff834 	movhi	r7,16352
8012b8ec:	011ff880 	call	8011ff88 <__muldf3>
8012b8f0:	d8800d15 	stw	r2,52(sp)
8012b8f4:	182f883a 	mov	r23,r3
8012b8f8:	102d883a 	mov	r22,r2
8012b8fc:	1a20003c 	xorhi	r8,r3,32768
8012b900:	dd800b15 	stw	r22,44(sp)
8012b904:	402d883a 	mov	r22,r8
8012b908:	003f8206 	br	8012b714 <__reset+0xfa10b714>
8012b90c:	b013883a 	mov	r9,r22
8012b910:	000b883a 	mov	r5,zero
8012b914:	0015883a 	mov	r10,zero
8012b918:	893ff404 	addi	r4,r17,-48
8012b91c:	00800244 	movi	r2,9
8012b920:	11001036 	bltu	r2,r4,8012b964 <_strtod_r+0xc40>
8012b924:	28c00044 	addi	r3,r5,1
8012b928:	2023883a 	mov	r17,r4
8012b92c:	20014d1e 	bne	r4,zero,8012be64 <_strtod_r+0x1140>
8012b930:	d9800617 	ldw	r6,24(sp)
8012b934:	180b883a 	mov	r5,r3
8012b938:	30800044 	addi	r2,r6,1
8012b93c:	d8800615 	stw	r2,24(sp)
8012b940:	34400047 	ldb	r17,1(r6)
8012b944:	003ff406 	br	8012b918 <__reset+0xfa10b918>
8012b948:	0019883a 	mov	r12,zero
8012b94c:	b8800084 	addi	r2,r23,2
8012b950:	d8800615 	stw	r2,24(sp)
8012b954:	bc400087 	ldb	r17,2(r23)
8012b958:	003e1606 	br	8012b1b4 <__reset+0xfa10b1b4>
8012b95c:	03000044 	movi	r12,1
8012b960:	003ffa06 	br	8012b94c <__reset+0xfa10b94c>
8012b964:	02c00044 	movi	r11,1
8012b968:	003d8d06 	br	8012afa0 <__reset+0xfa10afa0>
8012b96c:	00800044 	movi	r2,1
8012b970:	9080fe26 	beq	r18,r2,8012bd6c <_strtod_r+0x1048>
8012b974:	d8000b15 	stw	zero,44(sp)
8012b978:	05affc34 	movhi	r22,49136
8012b97c:	d8000d15 	stw	zero,52(sp)
8012b980:	05cffc34 	movhi	r23,16368
8012b984:	003f6306 	br	8012b714 <__reset+0xfa10b714>
8012b988:	d8000a15 	stw	zero,40(sp)
8012b98c:	003ec906 	br	8012b4b4 <__reset+0xfa10b4b4>
8012b990:	d9001117 	ldw	r4,68(sp)
8012b994:	00bfffc4 	movi	r2,-1
8012b998:	2080461e 	bne	r4,r2,8012bab4 <_strtod_r+0xd90>
8012b99c:	dd000a15 	stw	r20,40(sp)
8012b9a0:	dd001217 	ldw	r20,72(sp)
8012b9a4:	a811883a 	mov	r8,r21
8012b9a8:	d8800517 	ldw	r2,20(sp)
8012b9ac:	00c00884 	movi	r3,34
8012b9b0:	80c00015 	stw	r3,0(r16)
8012b9b4:	002b883a 	mov	r21,zero
8012b9b8:	059ffc34 	movhi	r22,32752
8012b9bc:	100b883a 	mov	r5,r2
8012b9c0:	8009883a 	mov	r4,r16
8012b9c4:	da001315 	stw	r8,76(sp)
8012b9c8:	01291d00 	call	801291d0 <_Bfree>
8012b9cc:	d9400a17 	ldw	r5,40(sp)
8012b9d0:	8009883a 	mov	r4,r16
8012b9d4:	01291d00 	call	801291d0 <_Bfree>
8012b9d8:	980b883a 	mov	r5,r19
8012b9dc:	8009883a 	mov	r4,r16
8012b9e0:	01291d00 	call	801291d0 <_Bfree>
8012b9e4:	d9400817 	ldw	r5,32(sp)
8012b9e8:	8009883a 	mov	r4,r16
8012b9ec:	01291d00 	call	801291d0 <_Bfree>
8012b9f0:	da001317 	ldw	r8,76(sp)
8012b9f4:	8009883a 	mov	r4,r16
8012b9f8:	400b883a 	mov	r5,r8
8012b9fc:	01291d00 	call	801291d0 <_Bfree>
8012ba00:	003d9206 	br	8012b04c <__reset+0xfa10b04c>
8012ba04:	d8c00717 	ldw	r3,28(sp)
8012ba08:	d8800504 	addi	r2,sp,20
8012ba0c:	01a00534 	movhi	r6,32788
8012ba10:	319f3d04 	addi	r6,r6,31988
8012ba14:	d8c00115 	stw	r3,4(sp)
8012ba18:	d8800015 	stw	r2,0(sp)
8012ba1c:	d9c00404 	addi	r7,sp,16
8012ba20:	d9400604 	addi	r5,sp,24
8012ba24:	8009883a 	mov	r4,r16
8012ba28:	012e7f00 	call	8012e7f0 <__gethex>
8012ba2c:	154001cc 	andi	r21,r2,7
8012ba30:	a83d9b26 	beq	r21,zero,8012b0a0 <__reset+0xfa10b0a0>
8012ba34:	00c00184 	movi	r3,6
8012ba38:	a8c0d61e 	bne	r21,r3,8012bd94 <_strtod_r+0x1070>
8012ba3c:	9cc00044 	addi	r19,r19,1
8012ba40:	dcc00615 	stw	r19,24(sp)
8012ba44:	002b883a 	mov	r21,zero
8012ba48:	002d883a 	mov	r22,zero
8012ba4c:	d8000715 	stw	zero,28(sp)
8012ba50:	003d7e06 	br	8012b04c <__reset+0xfa10b04c>
8012ba54:	00bf2c34 	movhi	r2,64688
8012ba58:	88a3883a 	add	r17,r17,r2
8012ba5c:	9009883a 	mov	r4,r18
8012ba60:	880b883a 	mov	r5,r17
8012ba64:	0129c840 	call	80129c84 <__ulp>
8012ba68:	d9000b17 	ldw	r4,44(sp)
8012ba6c:	100d883a 	mov	r6,r2
8012ba70:	180f883a 	mov	r7,r3
8012ba74:	b00b883a 	mov	r5,r22
8012ba78:	011ff880 	call	8011ff88 <__muldf3>
8012ba7c:	900d883a 	mov	r6,r18
8012ba80:	180b883a 	mov	r5,r3
8012ba84:	880f883a 	mov	r7,r17
8012ba88:	1009883a 	mov	r4,r2
8012ba8c:	01305200 	call	80130520 <__adddf3>
8012ba90:	015f2834 	movhi	r5,31904
8012ba94:	1025883a 	mov	r18,r2
8012ba98:	297fffc4 	addi	r5,r5,-1
8012ba9c:	189ffc2c 	andhi	r2,r3,32752
8012baa0:	2880892e 	bgeu	r5,r2,8012bcc8 <_strtod_r+0xfa4>
8012baa4:	d8801017 	ldw	r2,64(sp)
8012baa8:	00dffc34 	movhi	r3,32752
8012baac:	18ffffc4 	addi	r3,r3,-1
8012bab0:	10ffb726 	beq	r2,r3,8012b990 <__reset+0xfa10b990>
8012bab4:	045ffc34 	movhi	r17,32752
8012bab8:	8c7fffc4 	addi	r17,r17,-1
8012babc:	04bfffc4 	movi	r18,-1
8012bac0:	003f4706 	br	8012b7e0 <__reset+0xfa10b7e0>
8012bac4:	00800884 	movi	r2,34
8012bac8:	80800015 	stw	r2,0(r16)
8012bacc:	002b883a 	mov	r21,zero
8012bad0:	059ffc34 	movhi	r22,32752
8012bad4:	003d5d06 	br	8012b04c <__reset+0xfa10b04c>
8012bad8:	d9000d17 	ldw	r4,52(sp)
8012badc:	b80b883a 	mov	r5,r23
8012bae0:	0120fac0 	call	80120fac <__fixdfsi>
8012bae4:	1009883a 	mov	r4,r2
8012bae8:	012102c0 	call	8012102c <__floatsidf>
8012baec:	d9000d17 	ldw	r4,52(sp)
8012baf0:	b80b883a 	mov	r5,r23
8012baf4:	100d883a 	mov	r6,r2
8012baf8:	180f883a 	mov	r7,r3
8012bafc:	01206a80 	call	801206a8 <__subdf3>
8012bb00:	d9400e17 	ldw	r5,56(sp)
8012bb04:	1039883a 	mov	fp,r2
8012bb08:	182f883a 	mov	r23,r3
8012bb0c:	2800141e 	bne	r5,zero,8012bb60 <_strtod_r+0xe3c>
8012bb10:	9000131e 	bne	r18,zero,8012bb60 <_strtod_r+0xe3c>
8012bb14:	00800434 	movhi	r2,16
8012bb18:	10bfffc4 	addi	r2,r2,-1
8012bb1c:	b0ac703a 	and	r22,r22,r2
8012bb20:	b0000f1e 	bne	r22,zero,8012bb60 <_strtod_r+0xe3c>
8012bb24:	01a52834 	movhi	r6,38048
8012bb28:	01cff434 	movhi	r7,16336
8012bb2c:	318d6544 	addi	r6,r6,13717
8012bb30:	39ffffc4 	addi	r7,r7,-1
8012bb34:	e009883a 	mov	r4,fp
8012bb38:	180b883a 	mov	r5,r3
8012bb3c:	013174c0 	call	8013174c <__ledf2>
8012bb40:	103f270e 	bge	r2,zero,8012b7e0 <__reset+0xfa10b7e0>
8012bb44:	dd000a15 	stw	r20,40(sp)
8012bb48:	a811883a 	mov	r8,r21
8012bb4c:	dd001217 	ldw	r20,72(sp)
8012bb50:	d8800517 	ldw	r2,20(sp)
8012bb54:	002b883a 	mov	r21,zero
8012bb58:	882d883a 	mov	r22,r17
8012bb5c:	003f9706 	br	8012b9bc <__reset+0xfa10b9bc>
8012bb60:	01a52834 	movhi	r6,38048
8012bb64:	01cff834 	movhi	r7,16352
8012bb68:	318d6544 	addi	r6,r6,13717
8012bb6c:	39ffffc4 	addi	r7,r7,-1
8012bb70:	e009883a 	mov	r4,fp
8012bb74:	b80b883a 	mov	r5,r23
8012bb78:	013174c0 	call	8013174c <__ledf2>
8012bb7c:	10000716 	blt	r2,zero,8012bb9c <_strtod_r+0xe78>
8012bb80:	018d6c34 	movhi	r6,13744
8012bb84:	31b94d44 	addi	r6,r6,-6859
8012bb88:	01cff834 	movhi	r7,16352
8012bb8c:	e009883a 	mov	r4,fp
8012bb90:	b80b883a 	mov	r5,r23
8012bb94:	011feac0 	call	8011feac <__gedf2>
8012bb98:	00bf110e 	bge	zero,r2,8012b7e0 <__reset+0xfa10b7e0>
8012bb9c:	dd000a15 	stw	r20,40(sp)
8012bba0:	a811883a 	mov	r8,r21
8012bba4:	dd001217 	ldw	r20,72(sp)
8012bba8:	d8800517 	ldw	r2,20(sp)
8012bbac:	902b883a 	mov	r21,r18
8012bbb0:	882d883a 	mov	r22,r17
8012bbb4:	003f8106 	br	8012b9bc <__reset+0xfa10b9bc>
8012bbb8:	b83e2f26 	beq	r23,zero,8012b478 <__reset+0xfa10b478>
8012bbbc:	05efc83a 	sub	r23,zero,r23
8012bbc0:	b88003cc 	andi	r2,r23,15
8012bbc4:	10000d26 	beq	r2,zero,8012bbfc <_strtod_r+0xed8>
8012bbc8:	100490fa 	slli	r2,r2,3
8012bbcc:	00e00534 	movhi	r3,32788
8012bbd0:	18df0204 	addi	r3,r3,31752
8012bbd4:	1885883a 	add	r2,r3,r2
8012bbd8:	11800017 	ldw	r6,0(r2)
8012bbdc:	11c00117 	ldw	r7,4(r2)
8012bbe0:	9009883a 	mov	r4,r18
8012bbe4:	880b883a 	mov	r5,r17
8012bbe8:	da401315 	stw	r9,76(sp)
8012bbec:	0130dd40 	call	80130dd4 <__divdf3>
8012bbf0:	da401317 	ldw	r9,76(sp)
8012bbf4:	1025883a 	mov	r18,r2
8012bbf8:	1823883a 	mov	r17,r3
8012bbfc:	b82fd13a 	srai	r23,r23,4
8012bc00:	b83e1d26 	beq	r23,zero,8012b478 <__reset+0xfa10b478>
8012bc04:	008007c4 	movi	r2,31
8012bc08:	15c02816 	blt	r2,r23,8012bcac <_strtod_r+0xf88>
8012bc0c:	b880040c 	andi	r2,r23,16
8012bc10:	10019726 	beq	r2,zero,8012c270 <_strtod_r+0x154c>
8012bc14:	05c1880e 	bge	zero,r23,8012c238 <_strtod_r+0x1514>
8012bc18:	00c01a84 	movi	r3,106
8012bc1c:	d8c00915 	stw	r3,36(sp)
8012bc20:	04e00534 	movhi	r19,32788
8012bc24:	9cdf4204 	addi	r19,r19,32008
8012bc28:	8807883a 	mov	r3,r17
8012bc2c:	9005883a 	mov	r2,r18
8012bc30:	8023883a 	mov	r17,r16
8012bc34:	0009883a 	mov	r4,zero
8012bc38:	9821883a 	mov	r16,r19
8012bc3c:	da400a15 	stw	r9,40(sp)
8012bc40:	1827883a 	mov	r19,r3
8012bc44:	b980004c 	andi	r6,r23,1
8012bc48:	30000626 	beq	r6,zero,8012bc64 <_strtod_r+0xf40>
8012bc4c:	81800017 	ldw	r6,0(r16)
8012bc50:	81c00117 	ldw	r7,4(r16)
8012bc54:	1009883a 	mov	r4,r2
8012bc58:	180b883a 	mov	r5,r3
8012bc5c:	011ff880 	call	8011ff88 <__muldf3>
8012bc60:	01000044 	movi	r4,1
8012bc64:	b82fd07a 	srai	r23,r23,1
8012bc68:	84000204 	addi	r16,r16,8
8012bc6c:	b83ff51e 	bne	r23,zero,8012bc44 <__reset+0xfa10bc44>
8012bc70:	21003fcc 	andi	r4,r4,255
8012bc74:	8821883a 	mov	r16,r17
8012bc78:	da400a17 	ldw	r9,40(sp)
8012bc7c:	9823883a 	mov	r17,r19
8012bc80:	2001a51e 	bne	r4,zero,8012c318 <_strtod_r+0x15f4>
8012bc84:	d9000917 	ldw	r4,36(sp)
8012bc88:	20016d1e 	bne	r4,zero,8012c240 <_strtod_r+0x151c>
8012bc8c:	000d883a 	mov	r6,zero
8012bc90:	000f883a 	mov	r7,zero
8012bc94:	9009883a 	mov	r4,r18
8012bc98:	880b883a 	mov	r5,r17
8012bc9c:	da401315 	stw	r9,76(sp)
8012bca0:	01316c40 	call	801316c4 <__eqdf2>
8012bca4:	da401317 	ldw	r9,76(sp)
8012bca8:	103df41e 	bne	r2,zero,8012b47c <__reset+0xfa10b47c>
8012bcac:	00800884 	movi	r2,34
8012bcb0:	80800015 	stw	r2,0(r16)
8012bcb4:	002b883a 	mov	r21,zero
8012bcb8:	002d883a 	mov	r22,zero
8012bcbc:	003ce306 	br	8012b04c <__reset+0xfa10b04c>
8012bcc0:	055387c4 	movi	r21,19999
8012bcc4:	003d6b06 	br	8012b274 <__reset+0xfa10b274>
8012bcc8:	0440d434 	movhi	r17,848
8012bccc:	1c63883a 	add	r17,r3,r17
8012bcd0:	882d883a 	mov	r22,r17
8012bcd4:	003ebe06 	br	8012b7d0 <__reset+0xfa10b7d0>
8012bcd8:	14403fcc 	andi	r17,r2,255
8012bcdc:	8c40201c 	xori	r17,r17,128
8012bce0:	8c7fe004 	addi	r17,r17,-128
8012bce4:	dd400817 	ldw	r21,32(sp)
8012bce8:	0027883a 	mov	r19,zero
8012bcec:	0039883a 	mov	fp,zero
8012bcf0:	002d883a 	mov	r22,zero
8012bcf4:	003c9906 	br	8012af5c <__reset+0xfa10af5c>
8012bcf8:	00c00944 	movi	r3,37
8012bcfc:	1a47c83a 	sub	r3,r3,r9
8012bd00:	1d7d8c16 	blt	r3,r21,8012b334 <__reset+0xfa10b334>
8012bd04:	1261c83a 	sub	r16,r2,r9
8012bd08:	800490fa 	slli	r2,r16,3
8012bd0c:	04e00534 	movhi	r19,32788
8012bd10:	9cdf0204 	addi	r19,r19,31752
8012bd14:	9885883a 	add	r2,r19,r2
8012bd18:	11000017 	ldw	r4,0(r2)
8012bd1c:	11400117 	ldw	r5,4(r2)
8012bd20:	900d883a 	mov	r6,r18
8012bd24:	880f883a 	mov	r7,r17
8012bd28:	011ff880 	call	8011ff88 <__muldf3>
8012bd2c:	ac0dc83a 	sub	r6,r21,r16
8012bd30:	300c90fa 	slli	r6,r6,3
8012bd34:	1009883a 	mov	r4,r2
8012bd38:	180b883a 	mov	r5,r3
8012bd3c:	9985883a 	add	r2,r19,r6
8012bd40:	11800017 	ldw	r6,0(r2)
8012bd44:	11c00117 	ldw	r7,4(r2)
8012bd48:	011ff880 	call	8011ff88 <__muldf3>
8012bd4c:	102b883a 	mov	r21,r2
8012bd50:	182d883a 	mov	r22,r3
8012bd54:	003cbd06 	br	8012b04c <__reset+0xfa10b04c>
8012bd58:	b811883a 	mov	r8,r23
8012bd5c:	003e8606 	br	8012b778 <__reset+0xfa10b778>
8012bd60:	d8000d15 	stw	zero,52(sp)
8012bd64:	05cffc34 	movhi	r23,16368
8012bd68:	003e8006 	br	8012b76c <__reset+0xfa10b76c>
8012bd6c:	883f011e 	bne	r17,zero,8012b974 <__reset+0xfa10b974>
8012bd70:	dd000a15 	stw	r20,40(sp)
8012bd74:	dd001217 	ldw	r20,72(sp)
8012bd78:	a811883a 	mov	r8,r21
8012bd7c:	00800884 	movi	r2,34
8012bd80:	80800015 	stw	r2,0(r16)
8012bd84:	002b883a 	mov	r21,zero
8012bd88:	d8800517 	ldw	r2,20(sp)
8012bd8c:	002d883a 	mov	r22,zero
8012bd90:	003f0a06 	br	8012b9bc <__reset+0xfa10b9bc>
8012bd94:	d9800517 	ldw	r6,20(sp)
8012bd98:	30000826 	beq	r6,zero,8012bdbc <_strtod_r+0x1098>
8012bd9c:	01400d44 	movi	r5,53
8012bda0:	d9000204 	addi	r4,sp,8
8012bda4:	d8801315 	stw	r2,76(sp)
8012bda8:	012a0780 	call	8012a078 <__copybits>
8012bdac:	d9400517 	ldw	r5,20(sp)
8012bdb0:	8009883a 	mov	r4,r16
8012bdb4:	01291d00 	call	801291d0 <_Bfree>
8012bdb8:	d8801317 	ldw	r2,76(sp)
8012bdbc:	00c00184 	movi	r3,6
8012bdc0:	1d400f36 	bltu	r3,r21,8012be00 <_strtod_r+0x10dc>
8012bdc4:	a82a90ba 	slli	r21,r21,2
8012bdc8:	00e004f4 	movhi	r3,32787
8012bdcc:	18ef7704 	addi	r3,r3,-16932
8012bdd0:	a8eb883a 	add	r21,r21,r3
8012bdd4:	a8c00017 	ldw	r3,0(r21)
8012bdd8:	1800683a 	jmp	r3
8012bddc:	8012be58 	cmpnei	zero,r16,19193
8012bde0:	8012be30 	cmpltui	zero,r16,19192
8012bde4:	8012be14 	ori	zero,r16,19192
8012bde8:	8012bdf8 	rdprs	zero,r16,19191
8012bdec:	8012be20 	cmpeqi	zero,r16,19192
8012bdf0:	8012be30 	cmpltui	zero,r16,19192
8012bdf4:	8012be58 	cmpnei	zero,r16,19193
8012bdf8:	045ffc34 	movhi	r17,32752
8012bdfc:	0025883a 	mov	r18,zero
8012be00:	1080020c 	andi	r2,r2,8
8012be04:	902b883a 	mov	r21,r18
8012be08:	103c8f26 	beq	r2,zero,8012b048 <__reset+0xfa10b048>
8012be0c:	8da00034 	orhi	r22,r17,32768
8012be10:	003c8e06 	br	8012b04c <__reset+0xfa10b04c>
8012be14:	dc800217 	ldw	r18,8(sp)
8012be18:	dc400317 	ldw	r17,12(sp)
8012be1c:	003ff806 	br	8012be00 <__reset+0xfa10be00>
8012be20:	04600034 	movhi	r17,32768
8012be24:	8c7fffc4 	addi	r17,r17,-1
8012be28:	04bfffc4 	movi	r18,-1
8012be2c:	003ff406 	br	8012be00 <__reset+0xfa10be00>
8012be30:	d8c00417 	ldw	r3,16(sp)
8012be34:	dc400317 	ldw	r17,12(sp)
8012be38:	013ffc34 	movhi	r4,65520
8012be3c:	18c10cc4 	addi	r3,r3,1075
8012be40:	1806953a 	slli	r3,r3,20
8012be44:	213fffc4 	addi	r4,r4,-1
8012be48:	8922703a 	and	r17,r17,r4
8012be4c:	dc800217 	ldw	r18,8(sp)
8012be50:	88e2b03a 	or	r17,r17,r3
8012be54:	003fea06 	br	8012be00 <__reset+0xfa10be00>
8012be58:	0023883a 	mov	r17,zero
8012be5c:	0025883a 	mov	r18,zero
8012be60:	003fe706 	br	8012be00 <__reset+0xfa10be00>
8012be64:	01800044 	movi	r6,1
8012be68:	50d5883a 	add	r10,r10,r3
8012be6c:	2a4b883a 	add	r5,r5,r9
8012be70:	19811a26 	beq	r3,r6,8012c2dc <_strtod_r+0x15b8>
8012be74:	01800204 	movi	r6,8
8012be78:	01c00404 	movi	r7,16
8012be7c:	4a400044 	addi	r9,r9,1
8012be80:	48bfffc4 	addi	r2,r9,-1
8012be84:	30801616 	blt	r6,r2,8012bee0 <_strtod_r+0x11bc>
8012be88:	e70002a4 	muli	fp,fp,10
8012be8c:	497ffb1e 	bne	r9,r5,8012be7c <__reset+0xfa10be7c>
8012be90:	d9800617 	ldw	r6,24(sp)
8012be94:	4a400044 	addi	r9,r9,1
8012be98:	00c00204 	movi	r3,8
8012be9c:	19400c0e 	bge	r3,r5,8012bed0 <_strtod_r+0x11ac>
8012bea0:	00800404 	movi	r2,16
8012bea4:	000b883a 	mov	r5,zero
8012bea8:	127ea316 	blt	r2,r9,8012b938 <__reset+0xfa10b938>
8012beac:	988002a4 	muli	r2,r19,10
8012beb0:	20a7883a 	add	r19,r4,r2
8012beb4:	003ea006 	br	8012b938 <__reset+0xfa10b938>
8012beb8:	d8800617 	ldw	r2,24(sp)
8012bebc:	8c7ff404 	addi	r17,r17,-48
8012bec0:	2a800044 	addi	r10,r5,1
8012bec4:	d8800815 	stw	r2,32(sp)
8012bec8:	100d883a 	mov	r6,r2
8012becc:	02400044 	movi	r9,1
8012bed0:	e08002a4 	muli	r2,fp,10
8012bed4:	000b883a 	mov	r5,zero
8012bed8:	88b9883a 	add	fp,r17,r2
8012bedc:	003e9606 	br	8012b938 <__reset+0xfa10b938>
8012bee0:	3a7fea16 	blt	r7,r9,8012be8c <__reset+0xfa10be8c>
8012bee4:	9cc002a4 	muli	r19,r19,10
8012bee8:	003fe806 	br	8012be8c <__reset+0xfa10be8c>
8012beec:	00bffa84 	movi	r2,-22
8012bef0:	a8bd1016 	blt	r21,r2,8012b334 <__reset+0xfa10b334>
8012bef4:	a82a90fa 	slli	r21,r21,3
8012bef8:	00a00534 	movhi	r2,32788
8012befc:	109f0204 	addi	r2,r2,31752
8012bf00:	1545c83a 	sub	r2,r2,r21
8012bf04:	11800017 	ldw	r6,0(r2)
8012bf08:	11c00117 	ldw	r7,4(r2)
8012bf0c:	9009883a 	mov	r4,r18
8012bf10:	880b883a 	mov	r5,r17
8012bf14:	0130dd40 	call	80130dd4 <__divdf3>
8012bf18:	102b883a 	mov	r21,r2
8012bf1c:	182d883a 	mov	r22,r3
8012bf20:	003c4a06 	br	8012b04c <__reset+0xfa10b04c>
8012bf24:	dd000a15 	stw	r20,40(sp)
8012bf28:	a811883a 	mov	r8,r21
8012bf2c:	dd001217 	ldw	r20,72(sp)
8012bf30:	003e9e06 	br	8012b9ac <__reset+0xfa10b9ac>
8012bf34:	01600534 	movhi	r5,32788
8012bf38:	d9000617 	ldw	r4,24(sp)
8012bf3c:	295f3404 	addi	r5,r5,31952
8012bf40:	01c00644 	movi	r7,25
8012bf44:	00000b06 	br	8012bf74 <_strtod_r+0x1250>
8012bf48:	21000044 	addi	r4,r4,1
8012bf4c:	20800003 	ldbu	r2,0(r4)
8012bf50:	10ffefc4 	addi	r3,r2,-65
8012bf54:	10803fcc 	andi	r2,r2,255
8012bf58:	1080201c 	xori	r2,r2,128
8012bf5c:	18c03fcc 	andi	r3,r3,255
8012bf60:	10bfe004 	addi	r2,r2,-128
8012bf64:	38c00136 	bltu	r7,r3,8012bf6c <_strtod_r+0x1248>
8012bf68:	10800804 	addi	r2,r2,32
8012bf6c:	29400044 	addi	r5,r5,1
8012bf70:	11bbbb1e 	bne	r2,r6,8012ae60 <__reset+0xfa10ae60>
8012bf74:	29800007 	ldb	r6,0(r5)
8012bf78:	303ff31e 	bne	r6,zero,8012bf48 <__reset+0xfa10bf48>
8012bf7c:	01a00534 	movhi	r6,32788
8012bf80:	d9000615 	stw	r4,24(sp)
8012bf84:	319f3504 	addi	r6,r6,31956
8012bf88:	200b883a 	mov	r5,r4
8012bf8c:	02000644 	movi	r8,25
8012bf90:	00000a06 	br	8012bfbc <_strtod_r+0x1298>
8012bf94:	28800003 	ldbu	r2,0(r5)
8012bf98:	10ffefc4 	addi	r3,r2,-65
8012bf9c:	10803fcc 	andi	r2,r2,255
8012bfa0:	1080201c 	xori	r2,r2,128
8012bfa4:	18c03fcc 	andi	r3,r3,255
8012bfa8:	10bfe004 	addi	r2,r2,-128
8012bfac:	40c00136 	bltu	r8,r3,8012bfb4 <_strtod_r+0x1290>
8012bfb0:	10800804 	addi	r2,r2,32
8012bfb4:	31800044 	addi	r6,r6,1
8012bfb8:	11c0711e 	bne	r2,r7,8012c180 <_strtod_r+0x145c>
8012bfbc:	31c00007 	ldb	r7,0(r6)
8012bfc0:	29400044 	addi	r5,r5,1
8012bfc4:	383ff31e 	bne	r7,zero,8012bf94 <__reset+0xfa10bf94>
8012bfc8:	d9400615 	stw	r5,24(sp)
8012bfcc:	045ffc34 	movhi	r17,32752
8012bfd0:	0025883a 	mov	r18,zero
8012bfd4:	003c1b06 	br	8012b044 <__reset+0xfa10b044>
8012bfd8:	000b883a 	mov	r5,zero
8012bfdc:	003ccc06 	br	8012b310 <__reset+0xfa10b310>
8012bfe0:	d9400e17 	ldw	r5,56(sp)
8012bfe4:	dd000a15 	stw	r20,40(sp)
8012bfe8:	00800434 	movhi	r2,16
8012bfec:	a811883a 	mov	r8,r21
8012bff0:	dd001217 	ldw	r20,72(sp)
8012bff4:	dd401117 	ldw	r21,68(sp)
8012bff8:	dd801017 	ldw	r22,64(sp)
8012bffc:	10bfffc4 	addi	r2,r2,-1
8012c000:	28005626 	beq	r5,zero,8012c15c <_strtod_r+0x1438>
8012c004:	8886703a 	and	r3,r17,r2
8012c008:	18807826 	beq	r3,r2,8012c1ec <_strtod_r+0x14c8>
8012c00c:	d8c00b17 	ldw	r3,44(sp)
8012c010:	18005726 	beq	r3,zero,8012c170 <_strtod_r+0x144c>
8012c014:	1c44703a 	and	r2,r3,r17
8012c018:	10000f26 	beq	r2,zero,8012c058 <_strtod_r+0x1334>
8012c01c:	d9000e17 	ldw	r4,56(sp)
8012c020:	d9800917 	ldw	r6,36(sp)
8012c024:	20005e26 	beq	r4,zero,8012c1a0 <_strtod_r+0x147c>
8012c028:	9009883a 	mov	r4,r18
8012c02c:	880b883a 	mov	r5,r17
8012c030:	da001315 	stw	r8,76(sp)
8012c034:	012acb80 	call	8012acb8 <sulp>
8012c038:	100d883a 	mov	r6,r2
8012c03c:	180f883a 	mov	r7,r3
8012c040:	9009883a 	mov	r4,r18
8012c044:	880b883a 	mov	r5,r17
8012c048:	01305200 	call	80130520 <__adddf3>
8012c04c:	da001317 	ldw	r8,76(sp)
8012c050:	102b883a 	mov	r21,r2
8012c054:	182d883a 	mov	r22,r3
8012c058:	d8c00917 	ldw	r3,36(sp)
8012c05c:	18000f26 	beq	r3,zero,8012c09c <_strtod_r+0x1378>
8012c060:	a809883a 	mov	r4,r21
8012c064:	b00b883a 	mov	r5,r22
8012c068:	000d883a 	mov	r6,zero
8012c06c:	01ce5434 	movhi	r7,14672
8012c070:	da001315 	stw	r8,76(sp)
8012c074:	011ff880 	call	8011ff88 <__muldf3>
8012c078:	102b883a 	mov	r21,r2
8012c07c:	182d883a 	mov	r22,r3
8012c080:	da001317 	ldw	r8,76(sp)
8012c084:	1800051e 	bne	r3,zero,8012c09c <_strtod_r+0x1378>
8012c088:	d8800517 	ldw	r2,20(sp)
8012c08c:	a83e4b1e 	bne	r21,zero,8012b9bc <__reset+0xfa10b9bc>
8012c090:	00c00884 	movi	r3,34
8012c094:	80c00015 	stw	r3,0(r16)
8012c098:	003e4806 	br	8012b9bc <__reset+0xfa10b9bc>
8012c09c:	d8800517 	ldw	r2,20(sp)
8012c0a0:	003e4606 	br	8012b9bc <__reset+0xfa10b9bc>
8012c0a4:	d9000e17 	ldw	r4,56(sp)
8012c0a8:	dd000a15 	stw	r20,40(sp)
8012c0ac:	a811883a 	mov	r8,r21
8012c0b0:	dd001217 	ldw	r20,72(sp)
8012c0b4:	dd401117 	ldw	r21,68(sp)
8012c0b8:	dd801017 	ldw	r22,64(sp)
8012c0bc:	203fe61e 	bne	r4,zero,8012c058 <__reset+0xfa10c058>
8012c0c0:	903fe51e 	bne	r18,zero,8012c058 <__reset+0xfa10c058>
8012c0c4:	00800434 	movhi	r2,16
8012c0c8:	10bfffc4 	addi	r2,r2,-1
8012c0cc:	8884703a 	and	r2,r17,r2
8012c0d0:	103fe11e 	bne	r2,zero,8012c058 <__reset+0xfa10c058>
8012c0d4:	8ddffc2c 	andhi	r23,r17,32752
8012c0d8:	0081ac34 	movhi	r2,1712
8012c0dc:	15ffde2e 	bgeu	r2,r23,8012c058 <__reset+0xfa10c058>
8012c0e0:	40800517 	ldw	r2,20(r8)
8012c0e4:	1000031e 	bne	r2,zero,8012c0f4 <_strtod_r+0x13d0>
8012c0e8:	40800417 	ldw	r2,16(r8)
8012c0ec:	00c00044 	movi	r3,1
8012c0f0:	18bfd90e 	bge	r3,r2,8012c058 <__reset+0xfa10c058>
8012c0f4:	400b883a 	mov	r5,r8
8012c0f8:	01800044 	movi	r6,1
8012c0fc:	8009883a 	mov	r4,r16
8012c100:	01298d00 	call	801298d0 <__lshift>
8012c104:	980b883a 	mov	r5,r19
8012c108:	1009883a 	mov	r4,r2
8012c10c:	d8801315 	stw	r2,76(sp)
8012c110:	0129a200 	call	80129a20 <__mcmp>
8012c114:	da001317 	ldw	r8,76(sp)
8012c118:	00bfcf0e 	bge	zero,r2,8012c058 <__reset+0xfa10c058>
8012c11c:	d8c00917 	ldw	r3,36(sp)
8012c120:	18005c26 	beq	r3,zero,8012c294 <_strtod_r+0x1570>
8012c124:	0081ac34 	movhi	r2,1712
8012c128:	15c05a16 	blt	r2,r23,8012c294 <_strtod_r+0x1570>
8012c12c:	0080dc34 	movhi	r2,880
8012c130:	15ffcb16 	blt	r2,r23,8012c060 <__reset+0xfa10c060>
8012c134:	003f1106 	br	8012bd7c <__reset+0xfa10bd7c>
8012c138:	002d883a 	mov	r22,zero
8012c13c:	022ff834 	movhi	r8,49120
8012c140:	d8000d15 	stw	zero,52(sp)
8012c144:	05cff834 	movhi	r23,16352
8012c148:	003ded06 	br	8012b900 <__reset+0xfa10b900>
8012c14c:	0440d434 	movhi	r17,848
8012c150:	1c63883a 	add	r17,r3,r17
8012c154:	d8000915 	stw	zero,36(sp)
8012c158:	003cc806 	br	8012b47c <__reset+0xfa10b47c>
8012c15c:	8884703a 	and	r2,r17,r2
8012c160:	103faa1e 	bne	r2,zero,8012c00c <__reset+0xfa10c00c>
8012c164:	903fa91e 	bne	r18,zero,8012c00c <__reset+0xfa10c00c>
8012c168:	8ddffc2c 	andhi	r23,r17,32752
8012c16c:	003feb06 	br	8012c11c <__reset+0xfa10c11c>
8012c170:	d8c00d17 	ldw	r3,52(sp)
8012c174:	1cae703a 	and	r23,r3,r18
8012c178:	b83fb726 	beq	r23,zero,8012c058 <__reset+0xfa10c058>
8012c17c:	003fa706 	br	8012c01c <__reset+0xfa10c01c>
8012c180:	21000044 	addi	r4,r4,1
8012c184:	d9000615 	stw	r4,24(sp)
8012c188:	003f9006 	br	8012bfcc <__reset+0xfa10bfcc>
8012c18c:	01600534 	movhi	r5,32788
8012c190:	295ef804 	addi	r5,r5,31712
8012c194:	d9400915 	stw	r5,36(sp)
8012c198:	0027883a 	mov	r19,zero
8012c19c:	003ca206 	br	8012b428 <__reset+0xfa10b428>
8012c1a0:	9009883a 	mov	r4,r18
8012c1a4:	880b883a 	mov	r5,r17
8012c1a8:	da001315 	stw	r8,76(sp)
8012c1ac:	012acb80 	call	8012acb8 <sulp>
8012c1b0:	100d883a 	mov	r6,r2
8012c1b4:	180f883a 	mov	r7,r3
8012c1b8:	9009883a 	mov	r4,r18
8012c1bc:	880b883a 	mov	r5,r17
8012c1c0:	01206a80 	call	801206a8 <__subdf3>
8012c1c4:	000d883a 	mov	r6,zero
8012c1c8:	000f883a 	mov	r7,zero
8012c1cc:	1009883a 	mov	r4,r2
8012c1d0:	180b883a 	mov	r5,r3
8012c1d4:	102b883a 	mov	r21,r2
8012c1d8:	182d883a 	mov	r22,r3
8012c1dc:	01316c40 	call	801316c4 <__eqdf2>
8012c1e0:	da001317 	ldw	r8,76(sp)
8012c1e4:	103ee526 	beq	r2,zero,8012bd7c <__reset+0xfa10bd7c>
8012c1e8:	003f9b06 	br	8012c058 <__reset+0xfa10c058>
8012c1ec:	d8800917 	ldw	r2,36(sp)
8012c1f0:	10002226 	beq	r2,zero,8012c27c <_strtod_r+0x1558>
8012c1f4:	889ffc2c 	andhi	r2,r17,32752
8012c1f8:	00c1a834 	movhi	r3,1696
8012c1fc:	18801f36 	bltu	r3,r2,8012c27c <_strtod_r+0x1558>
8012c200:	1004d53a 	srli	r2,r2,20
8012c204:	00c01ac4 	movi	r3,107
8012c208:	1887c83a 	sub	r3,r3,r2
8012c20c:	00bfffc4 	movi	r2,-1
8012c210:	10c4983a 	sll	r2,r2,r3
8012c214:	14bf7d1e 	bne	r2,r18,8012c00c <__reset+0xfa10c00c>
8012c218:	00dffc34 	movhi	r3,32752
8012c21c:	18ffffc4 	addi	r3,r3,-1
8012c220:	88c03526 	beq	r17,r3,8012c2f8 <_strtod_r+0x15d4>
8012c224:	8c5ffc2c 	andhi	r17,r17,32752
8012c228:	00800434 	movhi	r2,16
8012c22c:	002b883a 	mov	r21,zero
8012c230:	88ad883a 	add	r22,r17,r2
8012c234:	003f8806 	br	8012c058 <__reset+0xfa10c058>
8012c238:	01401a84 	movi	r5,106
8012c23c:	d9400915 	stw	r5,36(sp)
8012c240:	8ddffc2c 	andhi	r23,r17,32752
8012c244:	b82ed53a 	srli	r23,r23,20
8012c248:	00801ac4 	movi	r2,107
8012c24c:	15c5c83a 	sub	r2,r2,r23
8012c250:	00be8e0e 	bge	zero,r2,8012bc8c <__reset+0xfa10bc8c>
8012c254:	00c007c4 	movi	r3,31
8012c258:	18800a0e 	bge	r3,r2,8012c284 <_strtod_r+0x1560>
8012c25c:	00c00d04 	movi	r3,52
8012c260:	0025883a 	mov	r18,zero
8012c264:	1880270e 	bge	r3,r2,8012c304 <_strtod_r+0x15e0>
8012c268:	0440dc34 	movhi	r17,880
8012c26c:	003e8706 	br	8012bc8c <__reset+0xfa10bc8c>
8012c270:	d8000915 	stw	zero,36(sp)
8012c274:	05fe6a16 	blt	zero,r23,8012bc20 <__reset+0xfa10bc20>
8012c278:	003e8406 	br	8012bc8c <__reset+0xfa10bc8c>
8012c27c:	00bfffc4 	movi	r2,-1
8012c280:	003fe406 	br	8012c214 <__reset+0xfa10c214>
8012c284:	00ffffc4 	movi	r3,-1
8012c288:	1884983a 	sll	r2,r3,r2
8012c28c:	14a4703a 	and	r18,r2,r18
8012c290:	003e7e06 	br	8012bc8c <__reset+0xfa10bc8c>
8012c294:	00bffc34 	movhi	r2,65520
8012c298:	b8af883a 	add	r23,r23,r2
8012c29c:	057fffc4 	movi	r21,-1
8012c2a0:	00800434 	movhi	r2,16
8012c2a4:	1545883a 	add	r2,r2,r21
8012c2a8:	b8acb03a 	or	r22,r23,r2
8012c2ac:	003f6a06 	br	8012c058 <__reset+0xfa10c058>
8012c2b0:	01600534 	movhi	r5,32788
8012c2b4:	295f3804 	addi	r5,r5,31968
8012c2b8:	d9800204 	addi	r6,sp,8
8012c2bc:	d9000604 	addi	r4,sp,24
8012c2c0:	012f0280 	call	8012f028 <__hexnan>
8012c2c4:	00c00144 	movi	r3,5
8012c2c8:	10fb5c1e 	bne	r2,r3,8012b03c <__reset+0xfa10b03c>
8012c2cc:	dc400317 	ldw	r17,12(sp)
8012c2d0:	dc800217 	ldw	r18,8(sp)
8012c2d4:	8c5ffc34 	orhi	r17,r17,32752
8012c2d8:	003b5a06 	br	8012b044 <__reset+0xfa10b044>
8012c2dc:	480b883a 	mov	r5,r9
8012c2e0:	d9800617 	ldw	r6,24(sp)
8012c2e4:	4a400044 	addi	r9,r9,1
8012c2e8:	003eeb06 	br	8012be98 <__reset+0xfa10be98>
8012c2ec:	1025883a 	mov	r18,r2
8012c2f0:	1823883a 	mov	r17,r3
8012c2f4:	003c4c06 	br	8012b428 <__reset+0xfa10b428>
8012c2f8:	00ffffc4 	movi	r3,-1
8012c2fc:	10ffc91e 	bne	r2,r3,8012c224 <__reset+0xfa10c224>
8012c300:	003da906 	br	8012b9a8 <__reset+0xfa10b9a8>
8012c304:	10bff804 	addi	r2,r2,-32
8012c308:	00ffffc4 	movi	r3,-1
8012c30c:	1884983a 	sll	r2,r3,r2
8012c310:	1462703a 	and	r17,r2,r17
8012c314:	003e5d06 	br	8012bc8c <__reset+0xfa10bc8c>
8012c318:	1025883a 	mov	r18,r2
8012c31c:	1823883a 	mov	r17,r3
8012c320:	003e5806 	br	8012bc84 <__reset+0xfa10bc84>

8012c324 <strtod>:
8012c324:	00a00574 	movhi	r2,32789
8012c328:	10a88704 	addi	r2,r2,-24036
8012c32c:	280d883a 	mov	r6,r5
8012c330:	200b883a 	mov	r5,r4
8012c334:	11000017 	ldw	r4,0(r2)
8012c338:	012ad241 	jmpi	8012ad24 <_strtod_r>

8012c33c <strtof>:
8012c33c:	defffb04 	addi	sp,sp,-20
8012c340:	de00012e 	bgeu	sp,et,8012c348 <strtof+0xc>
8012c344:	003b68fa 	trap	3
8012c348:	dcc00315 	stw	r19,12(sp)
8012c34c:	04e00574 	movhi	r19,32789
8012c350:	9ce88704 	addi	r19,r19,-24036
8012c354:	280d883a 	mov	r6,r5
8012c358:	200b883a 	mov	r5,r4
8012c35c:	99000017 	ldw	r4,0(r19)
8012c360:	dfc00415 	stw	ra,16(sp)
8012c364:	dc800215 	stw	r18,8(sp)
8012c368:	dc400115 	stw	r17,4(sp)
8012c36c:	dc000015 	stw	r16,0(sp)
8012c370:	012ad240 	call	8012ad24 <_strtod_r>
8012c374:	1009883a 	mov	r4,r2
8012c378:	180b883a 	mov	r5,r3
8012c37c:	1025883a 	mov	r18,r2
8012c380:	1823883a 	mov	r17,r3
8012c384:	01212280 	call	80121228 <__truncdfsf2>
8012c388:	000b883a 	mov	r5,zero
8012c38c:	1009883a 	mov	r4,r2
8012c390:	1021883a 	mov	r16,r2
8012c394:	01303240 	call	80130324 <__eqsf2>
8012c398:	1000111e 	bne	r2,zero,8012c3e0 <strtof+0xa4>
8012c39c:	000d883a 	mov	r6,zero
8012c3a0:	000f883a 	mov	r7,zero
8012c3a4:	9009883a 	mov	r4,r18
8012c3a8:	880b883a 	mov	r5,r17
8012c3ac:	01316c40 	call	801316c4 <__eqdf2>
8012c3b0:	10000b26 	beq	r2,zero,8012c3e0 <strtof+0xa4>
8012c3b4:	98800017 	ldw	r2,0(r19)
8012c3b8:	00c00884 	movi	r3,34
8012c3bc:	10c00015 	stw	r3,0(r2)
8012c3c0:	8005883a 	mov	r2,r16
8012c3c4:	dfc00417 	ldw	ra,16(sp)
8012c3c8:	dcc00317 	ldw	r19,12(sp)
8012c3cc:	dc800217 	ldw	r18,8(sp)
8012c3d0:	dc400117 	ldw	r17,4(sp)
8012c3d4:	dc000017 	ldw	r16,0(sp)
8012c3d8:	dec00504 	addi	sp,sp,20
8012c3dc:	f800283a 	ret
8012c3e0:	015fe034 	movhi	r5,32640
8012c3e4:	297fffc4 	addi	r5,r5,-1
8012c3e8:	8009883a 	mov	r4,r16
8012c3ec:	013039c0 	call	8013039c <__gesf2>
8012c3f0:	0080070e 	bge	zero,r2,8012c410 <strtof+0xd4>
8012c3f4:	01dffc34 	movhi	r7,32752
8012c3f8:	39ffffc4 	addi	r7,r7,-1
8012c3fc:	01bfffc4 	movi	r6,-1
8012c400:	9009883a 	mov	r4,r18
8012c404:	880b883a 	mov	r5,r17
8012c408:	011feac0 	call	8011feac <__gedf2>
8012c40c:	00bfe90e 	bge	zero,r2,8012c3b4 <__reset+0xfa10c3b4>
8012c410:	017fe034 	movhi	r5,65408
8012c414:	297fffc4 	addi	r5,r5,-1
8012c418:	8009883a 	mov	r4,r16
8012c41c:	01304580 	call	80130458 <__lesf2>
8012c420:	103fe70e 	bge	r2,zero,8012c3c0 <__reset+0xfa10c3c0>
8012c424:	01fffc34 	movhi	r7,65520
8012c428:	39ffffc4 	addi	r7,r7,-1
8012c42c:	01bfffc4 	movi	r6,-1
8012c430:	9009883a 	mov	r4,r18
8012c434:	880b883a 	mov	r5,r17
8012c438:	013174c0 	call	8013174c <__ledf2>
8012c43c:	103fdd0e 	bge	r2,zero,8012c3b4 <__reset+0xfa10c3b4>
8012c440:	003fdf06 	br	8012c3c0 <__reset+0xfa10c3c0>

8012c444 <_strtoul_r>:
8012c444:	00a00574 	movhi	r2,32789
8012c448:	defff604 	addi	sp,sp,-40
8012c44c:	10a88504 	addi	r2,r2,-24044
8012c450:	de00012e 	bgeu	sp,et,8012c458 <_strtoul_r+0x14>
8012c454:	003b68fa 	trap	3
8012c458:	dc800315 	stw	r18,12(sp)
8012c45c:	14800017 	ldw	r18,0(r2)
8012c460:	dd400615 	stw	r21,24(sp)
8012c464:	dd000515 	stw	r20,20(sp)
8012c468:	dcc00415 	stw	r19,16(sp)
8012c46c:	2029883a 	mov	r20,r4
8012c470:	dfc00915 	stw	ra,36(sp)
8012c474:	ddc00815 	stw	r23,32(sp)
8012c478:	dd800715 	stw	r22,28(sp)
8012c47c:	dc400215 	stw	r17,8(sp)
8012c480:	dc000115 	stw	r16,4(sp)
8012c484:	2827883a 	mov	r19,r5
8012c488:	382b883a 	mov	r21,r7
8012c48c:	2809883a 	mov	r4,r5
8012c490:	24000003 	ldbu	r16,0(r4)
8012c494:	24400044 	addi	r17,r4,1
8012c498:	2007883a 	mov	r3,r4
8012c49c:	9405883a 	add	r2,r18,r16
8012c4a0:	10800043 	ldbu	r2,1(r2)
8012c4a4:	8809883a 	mov	r4,r17
8012c4a8:	1080020c 	andi	r2,r2,8
8012c4ac:	103ff81e 	bne	r2,zero,8012c490 <__reset+0xfa10c490>
8012c4b0:	00800b44 	movi	r2,45
8012c4b4:	80805326 	beq	r16,r2,8012c604 <_strtoul_r+0x1c0>
8012c4b8:	00800ac4 	movi	r2,43
8012c4bc:	80805526 	beq	r16,r2,8012c614 <_strtoul_r+0x1d0>
8012c4c0:	002f883a 	mov	r23,zero
8012c4c4:	a8000f26 	beq	r21,zero,8012c504 <_strtoul_r+0xc0>
8012c4c8:	00800404 	movi	r2,16
8012c4cc:	a8805f26 	beq	r21,r2,8012c64c <_strtoul_r+0x208>
8012c4d0:	013fffc4 	movi	r4,-1
8012c4d4:	a80b883a 	mov	r5,r21
8012c4d8:	d9800015 	stw	r6,0(sp)
8012c4dc:	01302680 	call	80130268 <__udivsi3>
8012c4e0:	a80b883a 	mov	r5,r21
8012c4e4:	013fffc4 	movi	r4,-1
8012c4e8:	102d883a 	mov	r22,r2
8012c4ec:	01302cc0 	call	801302cc <__umodsi3>
8012c4f0:	d9800017 	ldw	r6,0(sp)
8012c4f4:	1019883a 	mov	r12,r2
8012c4f8:	a817883a 	mov	r11,r21
8012c4fc:	b00f883a 	mov	r7,r22
8012c500:	00000706 	br	8012c520 <_strtoul_r+0xdc>
8012c504:	00800c04 	movi	r2,48
8012c508:	80804626 	beq	r16,r2,8012c624 <_strtoul_r+0x1e0>
8012c50c:	05400284 	movi	r21,10
8012c510:	01c666b4 	movhi	r7,6554
8012c514:	03000144 	movi	r12,5
8012c518:	39e66644 	addi	r7,r7,-26215
8012c51c:	a817883a 	mov	r11,r21
8012c520:	9407883a 	add	r3,r18,r16
8012c524:	18c00043 	ldbu	r3,1(r3)
8012c528:	8809883a 	mov	r4,r17
8012c52c:	0011883a 	mov	r8,zero
8012c530:	1940010c 	andi	r5,r3,4
8012c534:	0005883a 	mov	r2,zero
8012c538:	02800044 	movi	r10,1
8012c53c:	027fffc4 	movi	r9,-1
8012c540:	28000e26 	beq	r5,zero,8012c57c <_strtoul_r+0x138>
8012c544:	843ff404 	addi	r16,r16,-48
8012c548:	8540120e 	bge	r16,r21,8012c594 <_strtoul_r+0x150>
8012c54c:	42400526 	beq	r8,r9,8012c564 <_strtoul_r+0x120>
8012c550:	38802236 	bltu	r7,r2,8012c5dc <_strtoul_r+0x198>
8012c554:	11c02026 	beq	r2,r7,8012c5d8 <_strtoul_r+0x194>
8012c558:	12c5383a 	mul	r2,r2,r11
8012c55c:	02000044 	movi	r8,1
8012c560:	8085883a 	add	r2,r16,r2
8012c564:	24000003 	ldbu	r16,0(r4)
8012c568:	21000044 	addi	r4,r4,1
8012c56c:	9407883a 	add	r3,r18,r16
8012c570:	18c00043 	ldbu	r3,1(r3)
8012c574:	1940010c 	andi	r5,r3,4
8012c578:	283ff21e 	bne	r5,zero,8012c544 <__reset+0xfa10c544>
8012c57c:	18c000cc 	andi	r3,r3,3
8012c580:	18000426 	beq	r3,zero,8012c594 <_strtoul_r+0x150>
8012c584:	1a801726 	beq	r3,r10,8012c5e4 <_strtoul_r+0x1a0>
8012c588:	00c015c4 	movi	r3,87
8012c58c:	80e1c83a 	sub	r16,r16,r3
8012c590:	857fee16 	blt	r16,r21,8012c54c <__reset+0xfa10c54c>
8012c594:	40001516 	blt	r8,zero,8012c5ec <_strtoul_r+0x1a8>
8012c598:	b8000126 	beq	r23,zero,8012c5a0 <_strtoul_r+0x15c>
8012c59c:	0085c83a 	sub	r2,zero,r2
8012c5a0:	30000226 	beq	r6,zero,8012c5ac <_strtoul_r+0x168>
8012c5a4:	4000151e 	bne	r8,zero,8012c5fc <_strtoul_r+0x1b8>
8012c5a8:	34c00015 	stw	r19,0(r6)
8012c5ac:	dfc00917 	ldw	ra,36(sp)
8012c5b0:	ddc00817 	ldw	r23,32(sp)
8012c5b4:	dd800717 	ldw	r22,28(sp)
8012c5b8:	dd400617 	ldw	r21,24(sp)
8012c5bc:	dd000517 	ldw	r20,20(sp)
8012c5c0:	dcc00417 	ldw	r19,16(sp)
8012c5c4:	dc800317 	ldw	r18,12(sp)
8012c5c8:	dc400217 	ldw	r17,8(sp)
8012c5cc:	dc000117 	ldw	r16,4(sp)
8012c5d0:	dec00a04 	addi	sp,sp,40
8012c5d4:	f800283a 	ret
8012c5d8:	643fdf0e 	bge	r12,r16,8012c558 <__reset+0xfa10c558>
8012c5dc:	023fffc4 	movi	r8,-1
8012c5e0:	003fe006 	br	8012c564 <__reset+0xfa10c564>
8012c5e4:	00c00dc4 	movi	r3,55
8012c5e8:	003fe806 	br	8012c58c <__reset+0xfa10c58c>
8012c5ec:	00800884 	movi	r2,34
8012c5f0:	a0800015 	stw	r2,0(r20)
8012c5f4:	00bfffc4 	movi	r2,-1
8012c5f8:	303fec26 	beq	r6,zero,8012c5ac <__reset+0xfa10c5ac>
8012c5fc:	24ffffc4 	addi	r19,r4,-1
8012c600:	003fe906 	br	8012c5a8 <__reset+0xfa10c5a8>
8012c604:	1c400084 	addi	r17,r3,2
8012c608:	1c000043 	ldbu	r16,1(r3)
8012c60c:	05c00044 	movi	r23,1
8012c610:	003fac06 	br	8012c4c4 <__reset+0xfa10c4c4>
8012c614:	1c400084 	addi	r17,r3,2
8012c618:	1c000043 	ldbu	r16,1(r3)
8012c61c:	002f883a 	mov	r23,zero
8012c620:	003fa806 	br	8012c4c4 <__reset+0xfa10c4c4>
8012c624:	88800003 	ldbu	r2,0(r17)
8012c628:	00c01604 	movi	r3,88
8012c62c:	108037cc 	andi	r2,r2,223
8012c630:	10c00c26 	beq	r2,r3,8012c664 <_strtoul_r+0x220>
8012c634:	05400204 	movi	r21,8
8012c638:	01c80034 	movhi	r7,8192
8012c63c:	030001c4 	movi	r12,7
8012c640:	39ffffc4 	addi	r7,r7,-1
8012c644:	a817883a 	mov	r11,r21
8012c648:	003fb506 	br	8012c520 <__reset+0xfa10c520>
8012c64c:	00800c04 	movi	r2,48
8012c650:	80800c1e 	bne	r16,r2,8012c684 <_strtoul_r+0x240>
8012c654:	88800003 	ldbu	r2,0(r17)
8012c658:	00c01604 	movi	r3,88
8012c65c:	108037cc 	andi	r2,r2,223
8012c660:	10c0081e 	bne	r2,r3,8012c684 <_strtoul_r+0x240>
8012c664:	02c00404 	movi	r11,16
8012c668:	05840034 	movhi	r22,4096
8012c66c:	8c000043 	ldbu	r16,1(r17)
8012c670:	030003c4 	movi	r12,15
8012c674:	8c400084 	addi	r17,r17,2
8012c678:	b5bfffc4 	addi	r22,r22,-1
8012c67c:	582b883a 	mov	r21,r11
8012c680:	003f9e06 	br	8012c4fc <__reset+0xfa10c4fc>
8012c684:	01c40034 	movhi	r7,4096
8012c688:	030003c4 	movi	r12,15
8012c68c:	39ffffc4 	addi	r7,r7,-1
8012c690:	a817883a 	mov	r11,r21
8012c694:	003fa206 	br	8012c520 <__reset+0xfa10c520>

8012c698 <strtoul>:
8012c698:	00a00574 	movhi	r2,32789
8012c69c:	10a88704 	addi	r2,r2,-24036
8012c6a0:	300f883a 	mov	r7,r6
8012c6a4:	280d883a 	mov	r6,r5
8012c6a8:	200b883a 	mov	r5,r4
8012c6ac:	11000017 	ldw	r4,0(r2)
8012c6b0:	012c4441 	jmpi	8012c444 <_strtoul_r>

8012c6b4 <_strtoull_r>:
8012c6b4:	00a00574 	movhi	r2,32789
8012c6b8:	defff404 	addi	sp,sp,-48
8012c6bc:	10a88504 	addi	r2,r2,-24044
8012c6c0:	de00012e 	bgeu	sp,et,8012c6c8 <_strtoull_r+0x14>
8012c6c4:	003b68fa 	trap	3
8012c6c8:	dc400315 	stw	r17,12(sp)
8012c6cc:	14400017 	ldw	r17,0(r2)
8012c6d0:	dd400715 	stw	r21,28(sp)
8012c6d4:	dd000615 	stw	r20,24(sp)
8012c6d8:	dcc00515 	stw	r19,20(sp)
8012c6dc:	dc800415 	stw	r18,16(sp)
8012c6e0:	dfc00b15 	stw	ra,44(sp)
8012c6e4:	df000a15 	stw	fp,40(sp)
8012c6e8:	ddc00915 	stw	r23,36(sp)
8012c6ec:	dd800815 	stw	r22,32(sp)
8012c6f0:	dc000215 	stw	r16,8(sp)
8012c6f4:	2827883a 	mov	r19,r5
8012c6f8:	202b883a 	mov	r21,r4
8012c6fc:	3029883a 	mov	r20,r6
8012c700:	3825883a 	mov	r18,r7
8012c704:	2807883a 	mov	r3,r5
8012c708:	1c000003 	ldbu	r16,0(r3)
8012c70c:	1f000044 	addi	fp,r3,1
8012c710:	1809883a 	mov	r4,r3
8012c714:	8c05883a 	add	r2,r17,r16
8012c718:	10800043 	ldbu	r2,1(r2)
8012c71c:	e007883a 	mov	r3,fp
8012c720:	1080020c 	andi	r2,r2,8
8012c724:	103ff81e 	bne	r2,zero,8012c708 <__reset+0xfa10c708>
8012c728:	00800b44 	movi	r2,45
8012c72c:	80806e26 	beq	r16,r2,8012c8e8 <_strtoull_r+0x234>
8012c730:	00800ac4 	movi	r2,43
8012c734:	80807026 	beq	r16,r2,8012c8f8 <_strtoull_r+0x244>
8012c738:	002f883a 	mov	r23,zero
8012c73c:	90001426 	beq	r18,zero,8012c790 <_strtoull_r+0xdc>
8012c740:	00800404 	movi	r2,16
8012c744:	90807c26 	beq	r18,r2,8012c938 <_strtoull_r+0x284>
8012c748:	902dd7fa 	srai	r22,r18,31
8012c74c:	013fffc4 	movi	r4,-1
8012c750:	200b883a 	mov	r5,r4
8012c754:	900d883a 	mov	r6,r18
8012c758:	b00f883a 	mov	r7,r22
8012c75c:	012f6b00 	call	8012f6b0 <__udivdi3>
8012c760:	013fffc4 	movi	r4,-1
8012c764:	900d883a 	mov	r6,r18
8012c768:	b00f883a 	mov	r7,r22
8012c76c:	200b883a 	mov	r5,r4
8012c770:	d8c00115 	stw	r3,4(sp)
8012c774:	d8800015 	stw	r2,0(sp)
8012c778:	012fc300 	call	8012fc30 <__umoddi3>
8012c77c:	101b883a 	mov	r13,r2
8012c780:	9015883a 	mov	r10,r18
8012c784:	dac00017 	ldw	r11,0(sp)
8012c788:	da000117 	ldw	r8,4(sp)
8012c78c:	00000a06 	br	8012c7b8 <_strtoull_r+0x104>
8012c790:	00800c04 	movi	r2,48
8012c794:	80805c26 	beq	r16,r2,8012c908 <_strtoull_r+0x254>
8012c798:	02800284 	movi	r10,10
8012c79c:	02e666b4 	movhi	r11,39322
8012c7a0:	020666b4 	movhi	r8,6554
8012c7a4:	03400144 	movi	r13,5
8012c7a8:	5ae66644 	addi	r11,r11,-26215
8012c7ac:	42266644 	addi	r8,r8,-26215
8012c7b0:	002d883a 	mov	r22,zero
8012c7b4:	5025883a 	mov	r18,r10
8012c7b8:	8c0b883a 	add	r5,r17,r16
8012c7bc:	29400043 	ldbu	r5,1(r5)
8012c7c0:	e009883a 	mov	r4,fp
8012c7c4:	000f883a 	mov	r7,zero
8012c7c8:	2980010c 	andi	r6,r5,4
8012c7cc:	0005883a 	mov	r2,zero
8012c7d0:	0007883a 	mov	r3,zero
8012c7d4:	03000044 	movi	r12,1
8012c7d8:	027fffc4 	movi	r9,-1
8012c7dc:	30000d26 	beq	r6,zero,8012c814 <_strtoull_r+0x160>
8012c7e0:	843ff404 	addi	r16,r16,-48
8012c7e4:	8480110e 	bge	r16,r18,8012c82c <_strtoull_r+0x178>
8012c7e8:	3a400426 	beq	r7,r9,8012c7fc <_strtoull_r+0x148>
8012c7ec:	40c00236 	bltu	r8,r3,8012c7f8 <_strtoull_r+0x144>
8012c7f0:	1a00231e 	bne	r3,r8,8012c880 <_strtoull_r+0x1cc>
8012c7f4:	5880222e 	bgeu	r11,r2,8012c880 <_strtoull_r+0x1cc>
8012c7f8:	01ffffc4 	movi	r7,-1
8012c7fc:	24000003 	ldbu	r16,0(r4)
8012c800:	21000044 	addi	r4,r4,1
8012c804:	8c0b883a 	add	r5,r17,r16
8012c808:	29400043 	ldbu	r5,1(r5)
8012c80c:	2980010c 	andi	r6,r5,4
8012c810:	303ff31e 	bne	r6,zero,8012c7e0 <__reset+0xfa10c7e0>
8012c814:	294000cc 	andi	r5,r5,3
8012c818:	28000426 	beq	r5,zero,8012c82c <_strtoull_r+0x178>
8012c81c:	2b002626 	beq	r5,r12,8012c8b8 <_strtoull_r+0x204>
8012c820:	014015c4 	movi	r5,87
8012c824:	8161c83a 	sub	r16,r16,r5
8012c828:	84bfef16 	blt	r16,r18,8012c7e8 <__reset+0xfa10c7e8>
8012c82c:	38002716 	blt	r7,zero,8012c8cc <_strtoull_r+0x218>
8012c830:	b8000426 	beq	r23,zero,8012c844 <_strtoull_r+0x190>
8012c834:	0085c83a 	sub	r2,zero,r2
8012c838:	100ac03a 	cmpne	r5,r2,zero
8012c83c:	00e1c83a 	sub	r16,zero,r3
8012c840:	8147c83a 	sub	r3,r16,r5
8012c844:	a0000226 	beq	r20,zero,8012c850 <_strtoull_r+0x19c>
8012c848:	3800251e 	bne	r7,zero,8012c8e0 <_strtoull_r+0x22c>
8012c84c:	a4c00015 	stw	r19,0(r20)
8012c850:	dfc00b17 	ldw	ra,44(sp)
8012c854:	df000a17 	ldw	fp,40(sp)
8012c858:	ddc00917 	ldw	r23,36(sp)
8012c85c:	dd800817 	ldw	r22,32(sp)
8012c860:	dd400717 	ldw	r21,28(sp)
8012c864:	dd000617 	ldw	r20,24(sp)
8012c868:	dcc00517 	ldw	r19,20(sp)
8012c86c:	dc800417 	ldw	r18,16(sp)
8012c870:	dc400317 	ldw	r17,12(sp)
8012c874:	dc000217 	ldw	r16,8(sp)
8012c878:	dec00c04 	addi	sp,sp,48
8012c87c:	f800283a 	ret
8012c880:	12c00f26 	beq	r2,r11,8012c8c0 <_strtoull_r+0x20c>
8012c884:	b08d383a 	mul	r6,r22,r2
8012c888:	1a87383a 	mul	r3,r3,r10
8012c88c:	128a383a 	mulxuu	r5,r2,r10
8012c890:	1285383a 	mul	r2,r2,r10
8012c894:	800fd7fa 	srai	r7,r16,31
8012c898:	1987883a 	add	r3,r3,r6
8012c89c:	8085883a 	add	r2,r16,r2
8012c8a0:	1947883a 	add	r3,r3,r5
8012c8a4:	38c7883a 	add	r3,r7,r3
8012c8a8:	1421803a 	cmpltu	r16,r2,r16
8012c8ac:	80c7883a 	add	r3,r16,r3
8012c8b0:	01c00044 	movi	r7,1
8012c8b4:	003fd106 	br	8012c7fc <__reset+0xfa10c7fc>
8012c8b8:	01400dc4 	movi	r5,55
8012c8bc:	003fd906 	br	8012c824 <__reset+0xfa10c824>
8012c8c0:	1a3ff01e 	bne	r3,r8,8012c884 <__reset+0xfa10c884>
8012c8c4:	6c3fcc16 	blt	r13,r16,8012c7f8 <__reset+0xfa10c7f8>
8012c8c8:	003fee06 	br	8012c884 <__reset+0xfa10c884>
8012c8cc:	00800884 	movi	r2,34
8012c8d0:	a8800015 	stw	r2,0(r21)
8012c8d4:	00bfffc4 	movi	r2,-1
8012c8d8:	1007883a 	mov	r3,r2
8012c8dc:	a03fdc26 	beq	r20,zero,8012c850 <__reset+0xfa10c850>
8012c8e0:	24ffffc4 	addi	r19,r4,-1
8012c8e4:	003fd906 	br	8012c84c <__reset+0xfa10c84c>
8012c8e8:	27000084 	addi	fp,r4,2
8012c8ec:	24000043 	ldbu	r16,1(r4)
8012c8f0:	05c00044 	movi	r23,1
8012c8f4:	003f9106 	br	8012c73c <__reset+0xfa10c73c>
8012c8f8:	27000084 	addi	fp,r4,2
8012c8fc:	24000043 	ldbu	r16,1(r4)
8012c900:	002f883a 	mov	r23,zero
8012c904:	003f8d06 	br	8012c73c <__reset+0xfa10c73c>
8012c908:	e0800003 	ldbu	r2,0(fp)
8012c90c:	00c01604 	movi	r3,88
8012c910:	108037cc 	andi	r2,r2,223
8012c914:	10c00e26 	beq	r2,r3,8012c950 <_strtoull_r+0x29c>
8012c918:	02800204 	movi	r10,8
8012c91c:	02ffffc4 	movi	r11,-1
8012c920:	02080034 	movhi	r8,8192
8012c924:	034001c4 	movi	r13,7
8012c928:	42d1883a 	add	r8,r8,r11
8012c92c:	002d883a 	mov	r22,zero
8012c930:	5025883a 	mov	r18,r10
8012c934:	003fa006 	br	8012c7b8 <__reset+0xfa10c7b8>
8012c938:	00800c04 	movi	r2,48
8012c93c:	80800e1e 	bne	r16,r2,8012c978 <_strtoull_r+0x2c4>
8012c940:	e0800003 	ldbu	r2,0(fp)
8012c944:	00c01604 	movi	r3,88
8012c948:	108037cc 	andi	r2,r2,223
8012c94c:	10c00a1e 	bne	r2,r3,8012c978 <_strtoull_r+0x2c4>
8012c950:	02800404 	movi	r10,16
8012c954:	02ffffc4 	movi	r11,-1
8012c958:	02040034 	movhi	r8,4096
8012c95c:	e4000043 	ldbu	r16,1(fp)
8012c960:	034003c4 	movi	r13,15
8012c964:	e7000084 	addi	fp,fp,2
8012c968:	42d1883a 	add	r8,r8,r11
8012c96c:	002d883a 	mov	r22,zero
8012c970:	5025883a 	mov	r18,r10
8012c974:	003f9006 	br	8012c7b8 <__reset+0xfa10c7b8>
8012c978:	02ffffc4 	movi	r11,-1
8012c97c:	02040034 	movhi	r8,4096
8012c980:	034003c4 	movi	r13,15
8012c984:	42d1883a 	add	r8,r8,r11
8012c988:	9015883a 	mov	r10,r18
8012c98c:	002d883a 	mov	r22,zero
8012c990:	003f8906 	br	8012c7b8 <__reset+0xfa10c7b8>

8012c994 <__ssprint_r>:
8012c994:	defff604 	addi	sp,sp,-40
8012c998:	de00012e 	bgeu	sp,et,8012c9a0 <__ssprint_r+0xc>
8012c99c:	003b68fa 	trap	3
8012c9a0:	30800217 	ldw	r2,8(r6)
8012c9a4:	dc800215 	stw	r18,8(sp)
8012c9a8:	dfc00915 	stw	ra,36(sp)
8012c9ac:	df000815 	stw	fp,32(sp)
8012c9b0:	ddc00715 	stw	r23,28(sp)
8012c9b4:	dd800615 	stw	r22,24(sp)
8012c9b8:	dd400515 	stw	r21,20(sp)
8012c9bc:	dd000415 	stw	r20,16(sp)
8012c9c0:	dcc00315 	stw	r19,12(sp)
8012c9c4:	dc400115 	stw	r17,4(sp)
8012c9c8:	dc000015 	stw	r16,0(sp)
8012c9cc:	3025883a 	mov	r18,r6
8012c9d0:	10005826 	beq	r2,zero,8012cb34 <__ssprint_r+0x1a0>
8012c9d4:	2027883a 	mov	r19,r4
8012c9d8:	35c00017 	ldw	r23,0(r6)
8012c9dc:	29000017 	ldw	r4,0(r5)
8012c9e0:	28800217 	ldw	r2,8(r5)
8012c9e4:	2823883a 	mov	r17,r5
8012c9e8:	0039883a 	mov	fp,zero
8012c9ec:	0021883a 	mov	r16,zero
8012c9f0:	80003926 	beq	r16,zero,8012cad8 <__ssprint_r+0x144>
8012c9f4:	102b883a 	mov	r21,r2
8012c9f8:	102d883a 	mov	r22,r2
8012c9fc:	80803a36 	bltu	r16,r2,8012cae8 <__ssprint_r+0x154>
8012ca00:	88c0030b 	ldhu	r3,12(r17)
8012ca04:	1881200c 	andi	r2,r3,1152
8012ca08:	10002626 	beq	r2,zero,8012caa4 <__ssprint_r+0x110>
8012ca0c:	88800517 	ldw	r2,20(r17)
8012ca10:	89400417 	ldw	r5,16(r17)
8012ca14:	81800044 	addi	r6,r16,1
8012ca18:	108f883a 	add	r7,r2,r2
8012ca1c:	3885883a 	add	r2,r7,r2
8012ca20:	100ed7fa 	srli	r7,r2,31
8012ca24:	216dc83a 	sub	r22,r4,r5
8012ca28:	3589883a 	add	r4,r6,r22
8012ca2c:	3885883a 	add	r2,r7,r2
8012ca30:	102bd07a 	srai	r21,r2,1
8012ca34:	a80d883a 	mov	r6,r21
8012ca38:	a900022e 	bgeu	r21,r4,8012ca44 <__ssprint_r+0xb0>
8012ca3c:	202b883a 	mov	r21,r4
8012ca40:	200d883a 	mov	r6,r4
8012ca44:	18c1000c 	andi	r3,r3,1024
8012ca48:	18002a26 	beq	r3,zero,8012caf4 <__ssprint_r+0x160>
8012ca4c:	300b883a 	mov	r5,r6
8012ca50:	9809883a 	mov	r4,r19
8012ca54:	01284880 	call	80128488 <_malloc_r>
8012ca58:	1029883a 	mov	r20,r2
8012ca5c:	10002c26 	beq	r2,zero,8012cb10 <__ssprint_r+0x17c>
8012ca60:	89400417 	ldw	r5,16(r17)
8012ca64:	b00d883a 	mov	r6,r22
8012ca68:	1009883a 	mov	r4,r2
8012ca6c:	01214640 	call	80121464 <memcpy>
8012ca70:	8880030b 	ldhu	r2,12(r17)
8012ca74:	00fedfc4 	movi	r3,-1153
8012ca78:	10c4703a 	and	r2,r2,r3
8012ca7c:	10802014 	ori	r2,r2,128
8012ca80:	8880030d 	sth	r2,12(r17)
8012ca84:	a589883a 	add	r4,r20,r22
8012ca88:	adadc83a 	sub	r22,r21,r22
8012ca8c:	8d400515 	stw	r21,20(r17)
8012ca90:	8d800215 	stw	r22,8(r17)
8012ca94:	8d000415 	stw	r20,16(r17)
8012ca98:	89000015 	stw	r4,0(r17)
8012ca9c:	802b883a 	mov	r21,r16
8012caa0:	802d883a 	mov	r22,r16
8012caa4:	b00d883a 	mov	r6,r22
8012caa8:	e00b883a 	mov	r5,fp
8012caac:	0128fc40 	call	80128fc4 <memmove>
8012cab0:	88800217 	ldw	r2,8(r17)
8012cab4:	89000017 	ldw	r4,0(r17)
8012cab8:	90c00217 	ldw	r3,8(r18)
8012cabc:	1545c83a 	sub	r2,r2,r21
8012cac0:	2589883a 	add	r4,r4,r22
8012cac4:	88800215 	stw	r2,8(r17)
8012cac8:	89000015 	stw	r4,0(r17)
8012cacc:	1c21c83a 	sub	r16,r3,r16
8012cad0:	94000215 	stw	r16,8(r18)
8012cad4:	80001726 	beq	r16,zero,8012cb34 <__ssprint_r+0x1a0>
8012cad8:	bf000017 	ldw	fp,0(r23)
8012cadc:	bc000117 	ldw	r16,4(r23)
8012cae0:	bdc00204 	addi	r23,r23,8
8012cae4:	003fc206 	br	8012c9f0 <__reset+0xfa10c9f0>
8012cae8:	802b883a 	mov	r21,r16
8012caec:	802d883a 	mov	r22,r16
8012caf0:	003fec06 	br	8012caa4 <__reset+0xfa10caa4>
8012caf4:	9809883a 	mov	r4,r19
8012caf8:	012a17c0 	call	8012a17c <_realloc_r>
8012cafc:	1029883a 	mov	r20,r2
8012cb00:	103fe01e 	bne	r2,zero,8012ca84 <__reset+0xfa10ca84>
8012cb04:	89400417 	ldw	r5,16(r17)
8012cb08:	9809883a 	mov	r4,r19
8012cb0c:	0127a000 	call	80127a00 <_free_r>
8012cb10:	88c0030b 	ldhu	r3,12(r17)
8012cb14:	00800304 	movi	r2,12
8012cb18:	98800015 	stw	r2,0(r19)
8012cb1c:	18c01014 	ori	r3,r3,64
8012cb20:	88c0030d 	sth	r3,12(r17)
8012cb24:	00bfffc4 	movi	r2,-1
8012cb28:	90000215 	stw	zero,8(r18)
8012cb2c:	90000115 	stw	zero,4(r18)
8012cb30:	00000206 	br	8012cb3c <__ssprint_r+0x1a8>
8012cb34:	90000115 	stw	zero,4(r18)
8012cb38:	0005883a 	mov	r2,zero
8012cb3c:	dfc00917 	ldw	ra,36(sp)
8012cb40:	df000817 	ldw	fp,32(sp)
8012cb44:	ddc00717 	ldw	r23,28(sp)
8012cb48:	dd800617 	ldw	r22,24(sp)
8012cb4c:	dd400517 	ldw	r21,20(sp)
8012cb50:	dd000417 	ldw	r20,16(sp)
8012cb54:	dcc00317 	ldw	r19,12(sp)
8012cb58:	dc800217 	ldw	r18,8(sp)
8012cb5c:	dc400117 	ldw	r17,4(sp)
8012cb60:	dc000017 	ldw	r16,0(sp)
8012cb64:	dec00a04 	addi	sp,sp,40
8012cb68:	f800283a 	ret

8012cb6c <___svfiprintf_internal_r>:
8012cb6c:	deffc804 	addi	sp,sp,-224
8012cb70:	de00012e 	bgeu	sp,et,8012cb78 <___svfiprintf_internal_r+0xc>
8012cb74:	003b68fa 	trap	3
8012cb78:	2880030b 	ldhu	r2,12(r5)
8012cb7c:	dcc03115 	stw	r19,196(sp)
8012cb80:	dfc03715 	stw	ra,220(sp)
8012cb84:	df003615 	stw	fp,216(sp)
8012cb88:	ddc03515 	stw	r23,212(sp)
8012cb8c:	dd803415 	stw	r22,208(sp)
8012cb90:	dd403315 	stw	r21,204(sp)
8012cb94:	dd003215 	stw	r20,200(sp)
8012cb98:	dc803015 	stw	r18,192(sp)
8012cb9c:	dc402f15 	stw	r17,188(sp)
8012cba0:	dc002e15 	stw	r16,184(sp)
8012cba4:	d9402715 	stw	r5,156(sp)
8012cba8:	d9002a15 	stw	r4,168(sp)
8012cbac:	1080200c 	andi	r2,r2,128
8012cbb0:	d9c02315 	stw	r7,140(sp)
8012cbb4:	3027883a 	mov	r19,r6
8012cbb8:	10000226 	beq	r2,zero,8012cbc4 <___svfiprintf_internal_r+0x58>
8012cbbc:	28800417 	ldw	r2,16(r5)
8012cbc0:	10041d26 	beq	r2,zero,8012dc38 <___svfiprintf_internal_r+0x10cc>
8012cbc4:	dac01a04 	addi	r11,sp,104
8012cbc8:	dac01e15 	stw	r11,120(sp)
8012cbcc:	d8801e17 	ldw	r2,120(sp)
8012cbd0:	dac019c4 	addi	r11,sp,103
8012cbd4:	dd402a17 	ldw	r21,168(sp)
8012cbd8:	ddc02717 	ldw	r23,156(sp)
8012cbdc:	05a00534 	movhi	r22,32788
8012cbe0:	05200534 	movhi	r20,32788
8012cbe4:	dac01f15 	stw	r11,124(sp)
8012cbe8:	12d7c83a 	sub	r11,r2,r11
8012cbec:	b59f5004 	addi	r22,r22,32064
8012cbf0:	a51f4c04 	addi	r20,r20,32048
8012cbf4:	dec01a15 	stw	sp,104(sp)
8012cbf8:	d8001c15 	stw	zero,112(sp)
8012cbfc:	d8001b15 	stw	zero,108(sp)
8012cc00:	d811883a 	mov	r8,sp
8012cc04:	d8002915 	stw	zero,164(sp)
8012cc08:	d8002515 	stw	zero,148(sp)
8012cc0c:	dac02b15 	stw	r11,172(sp)
8012cc10:	98800007 	ldb	r2,0(r19)
8012cc14:	1002dd26 	beq	r2,zero,8012d78c <___svfiprintf_internal_r+0xc20>
8012cc18:	00c00944 	movi	r3,37
8012cc1c:	9823883a 	mov	r17,r19
8012cc20:	10c0021e 	bne	r2,r3,8012cc2c <___svfiprintf_internal_r+0xc0>
8012cc24:	00001406 	br	8012cc78 <___svfiprintf_internal_r+0x10c>
8012cc28:	10c00326 	beq	r2,r3,8012cc38 <___svfiprintf_internal_r+0xcc>
8012cc2c:	8c400044 	addi	r17,r17,1
8012cc30:	88800007 	ldb	r2,0(r17)
8012cc34:	103ffc1e 	bne	r2,zero,8012cc28 <__reset+0xfa10cc28>
8012cc38:	8ce1c83a 	sub	r16,r17,r19
8012cc3c:	80000e26 	beq	r16,zero,8012cc78 <___svfiprintf_internal_r+0x10c>
8012cc40:	d8c01c17 	ldw	r3,112(sp)
8012cc44:	d8801b17 	ldw	r2,108(sp)
8012cc48:	44c00015 	stw	r19,0(r8)
8012cc4c:	1c07883a 	add	r3,r3,r16
8012cc50:	10800044 	addi	r2,r2,1
8012cc54:	d8c01c15 	stw	r3,112(sp)
8012cc58:	44000115 	stw	r16,4(r8)
8012cc5c:	d8801b15 	stw	r2,108(sp)
8012cc60:	00c001c4 	movi	r3,7
8012cc64:	18831e16 	blt	r3,r2,8012d8e0 <___svfiprintf_internal_r+0xd74>
8012cc68:	42000204 	addi	r8,r8,8
8012cc6c:	dac02517 	ldw	r11,148(sp)
8012cc70:	5c17883a 	add	r11,r11,r16
8012cc74:	dac02515 	stw	r11,148(sp)
8012cc78:	88800007 	ldb	r2,0(r17)
8012cc7c:	1002c526 	beq	r2,zero,8012d794 <___svfiprintf_internal_r+0xc28>
8012cc80:	88c00047 	ldb	r3,1(r17)
8012cc84:	8cc00044 	addi	r19,r17,1
8012cc88:	d8001d85 	stb	zero,118(sp)
8012cc8c:	0009883a 	mov	r4,zero
8012cc90:	000f883a 	mov	r7,zero
8012cc94:	043fffc4 	movi	r16,-1
8012cc98:	d8002415 	stw	zero,144(sp)
8012cc9c:	0025883a 	mov	r18,zero
8012cca0:	01401604 	movi	r5,88
8012cca4:	01800244 	movi	r6,9
8012cca8:	02800a84 	movi	r10,42
8012ccac:	02401b04 	movi	r9,108
8012ccb0:	9cc00044 	addi	r19,r19,1
8012ccb4:	18bff804 	addi	r2,r3,-32
8012ccb8:	2881dd36 	bltu	r5,r2,8012d430 <___svfiprintf_internal_r+0x8c4>
8012ccbc:	100490ba 	slli	r2,r2,2
8012ccc0:	02e004f4 	movhi	r11,32787
8012ccc4:	5af33504 	addi	r11,r11,-13100
8012ccc8:	12c5883a 	add	r2,r2,r11
8012cccc:	10800017 	ldw	r2,0(r2)
8012ccd0:	1000683a 	jmp	r2
8012ccd4:	8012ced0 	cmplti	zero,r16,19259
8012ccd8:	8012d430 	cmpltui	zero,r16,19280
8012ccdc:	8012d430 	cmpltui	zero,r16,19280
8012cce0:	8012cec4 	addi	zero,r16,19259
8012cce4:	8012d430 	cmpltui	zero,r16,19280
8012cce8:	8012d430 	cmpltui	zero,r16,19280
8012ccec:	8012d430 	cmpltui	zero,r16,19280
8012ccf0:	8012d430 	cmpltui	zero,r16,19280
8012ccf4:	8012d430 	cmpltui	zero,r16,19280
8012ccf8:	8012d430 	cmpltui	zero,r16,19280
8012ccfc:	8012ce38 	rdprs	zero,r16,19256
8012cd00:	8012d014 	ori	zero,r16,19264
8012cd04:	8012d430 	cmpltui	zero,r16,19280
8012cd08:	8012ce64 	muli	zero,r16,19257
8012cd0c:	8012d464 	muli	zero,r16,19281
8012cd10:	8012d430 	cmpltui	zero,r16,19280
8012cd14:	8012d458 	cmpnei	zero,r16,19281
8012cd18:	8012d3f8 	rdprs	zero,r16,19279
8012cd1c:	8012d3f8 	rdprs	zero,r16,19279
8012cd20:	8012d3f8 	rdprs	zero,r16,19279
8012cd24:	8012d3f8 	rdprs	zero,r16,19279
8012cd28:	8012d3f8 	rdprs	zero,r16,19279
8012cd2c:	8012d3f8 	rdprs	zero,r16,19279
8012cd30:	8012d3f8 	rdprs	zero,r16,19279
8012cd34:	8012d3f8 	rdprs	zero,r16,19279
8012cd38:	8012d3f8 	rdprs	zero,r16,19279
8012cd3c:	8012d430 	cmpltui	zero,r16,19280
8012cd40:	8012d430 	cmpltui	zero,r16,19280
8012cd44:	8012d430 	cmpltui	zero,r16,19280
8012cd48:	8012d430 	cmpltui	zero,r16,19280
8012cd4c:	8012d430 	cmpltui	zero,r16,19280
8012cd50:	8012d430 	cmpltui	zero,r16,19280
8012cd54:	8012d430 	cmpltui	zero,r16,19280
8012cd58:	8012d430 	cmpltui	zero,r16,19280
8012cd5c:	8012d430 	cmpltui	zero,r16,19280
8012cd60:	8012d430 	cmpltui	zero,r16,19280
8012cd64:	8012d394 	ori	zero,r16,19278
8012cd68:	8012d430 	cmpltui	zero,r16,19280
8012cd6c:	8012d430 	cmpltui	zero,r16,19280
8012cd70:	8012d430 	cmpltui	zero,r16,19280
8012cd74:	8012d430 	cmpltui	zero,r16,19280
8012cd78:	8012d430 	cmpltui	zero,r16,19280
8012cd7c:	8012d430 	cmpltui	zero,r16,19280
8012cd80:	8012d430 	cmpltui	zero,r16,19280
8012cd84:	8012d430 	cmpltui	zero,r16,19280
8012cd88:	8012d430 	cmpltui	zero,r16,19280
8012cd8c:	8012d430 	cmpltui	zero,r16,19280
8012cd90:	8012d50c 	andi	zero,r16,19284
8012cd94:	8012d430 	cmpltui	zero,r16,19280
8012cd98:	8012d430 	cmpltui	zero,r16,19280
8012cd9c:	8012d430 	cmpltui	zero,r16,19280
8012cda0:	8012d430 	cmpltui	zero,r16,19280
8012cda4:	8012d430 	cmpltui	zero,r16,19280
8012cda8:	8012d4a4 	muli	zero,r16,19282
8012cdac:	8012d430 	cmpltui	zero,r16,19280
8012cdb0:	8012d430 	cmpltui	zero,r16,19280
8012cdb4:	8012d1d8 	cmpnei	zero,r16,19271
8012cdb8:	8012d430 	cmpltui	zero,r16,19280
8012cdbc:	8012d430 	cmpltui	zero,r16,19280
8012cdc0:	8012d430 	cmpltui	zero,r16,19280
8012cdc4:	8012d430 	cmpltui	zero,r16,19280
8012cdc8:	8012d430 	cmpltui	zero,r16,19280
8012cdcc:	8012d430 	cmpltui	zero,r16,19280
8012cdd0:	8012d430 	cmpltui	zero,r16,19280
8012cdd4:	8012d430 	cmpltui	zero,r16,19280
8012cdd8:	8012d430 	cmpltui	zero,r16,19280
8012cddc:	8012d430 	cmpltui	zero,r16,19280
8012cde0:	8012d0c8 	cmpgei	zero,r16,19267
8012cde4:	8012d274 	orhi	zero,r16,19273
8012cde8:	8012d430 	cmpltui	zero,r16,19280
8012cdec:	8012d430 	cmpltui	zero,r16,19280
8012cdf0:	8012d430 	cmpltui	zero,r16,19280
8012cdf4:	8012d268 	cmpgeui	zero,r16,19273
8012cdf8:	8012d274 	orhi	zero,r16,19273
8012cdfc:	8012d430 	cmpltui	zero,r16,19280
8012ce00:	8012d430 	cmpltui	zero,r16,19280
8012ce04:	8012d258 	cmpnei	zero,r16,19273
8012ce08:	8012d430 	cmpltui	zero,r16,19280
8012ce0c:	8012d21c 	xori	zero,r16,19272
8012ce10:	8012d024 	muli	zero,r16,19264
8012ce14:	8012ce70 	cmpltui	zero,r16,19257
8012ce18:	8012d388 	cmpgei	zero,r16,19278
8012ce1c:	8012d430 	cmpltui	zero,r16,19280
8012ce20:	8012d33c 	xorhi	zero,r16,19276
8012ce24:	8012d430 	cmpltui	zero,r16,19280
8012ce28:	8012cf94 	ori	zero,r16,19262
8012ce2c:	8012d430 	cmpltui	zero,r16,19280
8012ce30:	8012d430 	cmpltui	zero,r16,19280
8012ce34:	8012cef0 	cmpltui	zero,r16,19259
8012ce38:	dac02317 	ldw	r11,140(sp)
8012ce3c:	5ac00017 	ldw	r11,0(r11)
8012ce40:	dac02415 	stw	r11,144(sp)
8012ce44:	dac02317 	ldw	r11,140(sp)
8012ce48:	58800104 	addi	r2,r11,4
8012ce4c:	dac02417 	ldw	r11,144(sp)
8012ce50:	5802e90e 	bge	r11,zero,8012d9f8 <___svfiprintf_internal_r+0xe8c>
8012ce54:	dac02417 	ldw	r11,144(sp)
8012ce58:	d8802315 	stw	r2,140(sp)
8012ce5c:	02d7c83a 	sub	r11,zero,r11
8012ce60:	dac02415 	stw	r11,144(sp)
8012ce64:	94800114 	ori	r18,r18,4
8012ce68:	98c00007 	ldb	r3,0(r19)
8012ce6c:	003f9006 	br	8012ccb0 <__reset+0xfa10ccb0>
8012ce70:	00800c04 	movi	r2,48
8012ce74:	dac02317 	ldw	r11,140(sp)
8012ce78:	d8801d05 	stb	r2,116(sp)
8012ce7c:	00801e04 	movi	r2,120
8012ce80:	d8801d45 	stb	r2,117(sp)
8012ce84:	d8001d85 	stb	zero,118(sp)
8012ce88:	58c00104 	addi	r3,r11,4
8012ce8c:	5f000017 	ldw	fp,0(r11)
8012ce90:	0013883a 	mov	r9,zero
8012ce94:	90800094 	ori	r2,r18,2
8012ce98:	80032b16 	blt	r16,zero,8012db48 <___svfiprintf_internal_r+0xfdc>
8012ce9c:	00bfdfc4 	movi	r2,-129
8012cea0:	90a4703a 	and	r18,r18,r2
8012cea4:	d8c02315 	stw	r3,140(sp)
8012cea8:	94800094 	ori	r18,r18,2
8012ceac:	e002dc26 	beq	fp,zero,8012da20 <___svfiprintf_internal_r+0xeb4>
8012ceb0:	01200534 	movhi	r4,32788
8012ceb4:	211ec904 	addi	r4,r4,31524
8012ceb8:	0015883a 	mov	r10,zero
8012cebc:	d9002915 	stw	r4,164(sp)
8012cec0:	00002306 	br	8012cf50 <___svfiprintf_internal_r+0x3e4>
8012cec4:	94800054 	ori	r18,r18,1
8012cec8:	98c00007 	ldb	r3,0(r19)
8012cecc:	003f7806 	br	8012ccb0 <__reset+0xfa10ccb0>
8012ced0:	38803fcc 	andi	r2,r7,255
8012ced4:	1080201c 	xori	r2,r2,128
8012ced8:	10bfe004 	addi	r2,r2,-128
8012cedc:	1002f31e 	bne	r2,zero,8012daac <___svfiprintf_internal_r+0xf40>
8012cee0:	01000044 	movi	r4,1
8012cee4:	01c00804 	movi	r7,32
8012cee8:	98c00007 	ldb	r3,0(r19)
8012ceec:	003f7006 	br	8012ccb0 <__reset+0xfa10ccb0>
8012cef0:	21003fcc 	andi	r4,r4,255
8012cef4:	2003aa1e 	bne	r4,zero,8012dda0 <___svfiprintf_internal_r+0x1234>
8012cef8:	00a00534 	movhi	r2,32788
8012cefc:	109ec904 	addi	r2,r2,31524
8012cf00:	d8802915 	stw	r2,164(sp)
8012cf04:	9080080c 	andi	r2,r18,32
8012cf08:	1000ba26 	beq	r2,zero,8012d1f4 <___svfiprintf_internal_r+0x688>
8012cf0c:	dac02317 	ldw	r11,140(sp)
8012cf10:	5f000017 	ldw	fp,0(r11)
8012cf14:	5a400117 	ldw	r9,4(r11)
8012cf18:	5ac00204 	addi	r11,r11,8
8012cf1c:	dac02315 	stw	r11,140(sp)
8012cf20:	9080004c 	andi	r2,r18,1
8012cf24:	10029026 	beq	r2,zero,8012d968 <___svfiprintf_internal_r+0xdfc>
8012cf28:	e244b03a 	or	r2,fp,r9
8012cf2c:	1002d41e 	bne	r2,zero,8012da80 <___svfiprintf_internal_r+0xf14>
8012cf30:	d8001d85 	stb	zero,118(sp)
8012cf34:	80030b16 	blt	r16,zero,8012db64 <___svfiprintf_internal_r+0xff8>
8012cf38:	00bfdfc4 	movi	r2,-129
8012cf3c:	90a4703a 	and	r18,r18,r2
8012cf40:	0015883a 	mov	r10,zero
8012cf44:	80002426 	beq	r16,zero,8012cfd8 <___svfiprintf_internal_r+0x46c>
8012cf48:	0039883a 	mov	fp,zero
8012cf4c:	0013883a 	mov	r9,zero
8012cf50:	d9002917 	ldw	r4,164(sp)
8012cf54:	dc401a04 	addi	r17,sp,104
8012cf58:	e08003cc 	andi	r2,fp,15
8012cf5c:	4806973a 	slli	r3,r9,28
8012cf60:	2085883a 	add	r2,r4,r2
8012cf64:	e038d13a 	srli	fp,fp,4
8012cf68:	10800003 	ldbu	r2,0(r2)
8012cf6c:	4812d13a 	srli	r9,r9,4
8012cf70:	8c7fffc4 	addi	r17,r17,-1
8012cf74:	1f38b03a 	or	fp,r3,fp
8012cf78:	88800005 	stb	r2,0(r17)
8012cf7c:	e244b03a 	or	r2,fp,r9
8012cf80:	103ff51e 	bne	r2,zero,8012cf58 <__reset+0xfa10cf58>
8012cf84:	dac01e17 	ldw	r11,120(sp)
8012cf88:	5c57c83a 	sub	r11,r11,r17
8012cf8c:	dac02115 	stw	r11,132(sp)
8012cf90:	00001406 	br	8012cfe4 <___svfiprintf_internal_r+0x478>
8012cf94:	21003fcc 	andi	r4,r4,255
8012cf98:	2003741e 	bne	r4,zero,8012dd6c <___svfiprintf_internal_r+0x1200>
8012cf9c:	9080080c 	andi	r2,r18,32
8012cfa0:	10014526 	beq	r2,zero,8012d4b8 <___svfiprintf_internal_r+0x94c>
8012cfa4:	dac02317 	ldw	r11,140(sp)
8012cfa8:	d8001d85 	stb	zero,118(sp)
8012cfac:	58c00204 	addi	r3,r11,8
8012cfb0:	5f000017 	ldw	fp,0(r11)
8012cfb4:	5a400117 	ldw	r9,4(r11)
8012cfb8:	8002d916 	blt	r16,zero,8012db20 <___svfiprintf_internal_r+0xfb4>
8012cfbc:	013fdfc4 	movi	r4,-129
8012cfc0:	e244b03a 	or	r2,fp,r9
8012cfc4:	d8c02315 	stw	r3,140(sp)
8012cfc8:	9124703a 	and	r18,r18,r4
8012cfcc:	0015883a 	mov	r10,zero
8012cfd0:	1000b91e 	bne	r2,zero,8012d2b8 <___svfiprintf_internal_r+0x74c>
8012cfd4:	8002e61e 	bne	r16,zero,8012db70 <___svfiprintf_internal_r+0x1004>
8012cfd8:	0021883a 	mov	r16,zero
8012cfdc:	d8002115 	stw	zero,132(sp)
8012cfe0:	dc401a04 	addi	r17,sp,104
8012cfe4:	d8c02117 	ldw	r3,132(sp)
8012cfe8:	dc002015 	stw	r16,128(sp)
8012cfec:	80c0010e 	bge	r16,r3,8012cff4 <___svfiprintf_internal_r+0x488>
8012cff0:	d8c02015 	stw	r3,128(sp)
8012cff4:	52803fcc 	andi	r10,r10,255
8012cff8:	5280201c 	xori	r10,r10,128
8012cffc:	52bfe004 	addi	r10,r10,-128
8012d000:	50003c26 	beq	r10,zero,8012d0f4 <___svfiprintf_internal_r+0x588>
8012d004:	dac02017 	ldw	r11,128(sp)
8012d008:	5ac00044 	addi	r11,r11,1
8012d00c:	dac02015 	stw	r11,128(sp)
8012d010:	00003806 	br	8012d0f4 <___svfiprintf_internal_r+0x588>
8012d014:	01000044 	movi	r4,1
8012d018:	01c00ac4 	movi	r7,43
8012d01c:	98c00007 	ldb	r3,0(r19)
8012d020:	003f2306 	br	8012ccb0 <__reset+0xfa10ccb0>
8012d024:	21003fcc 	andi	r4,r4,255
8012d028:	2003481e 	bne	r4,zero,8012dd4c <___svfiprintf_internal_r+0x11e0>
8012d02c:	9080080c 	andi	r2,r18,32
8012d030:	10013b26 	beq	r2,zero,8012d520 <___svfiprintf_internal_r+0x9b4>
8012d034:	dac02317 	ldw	r11,140(sp)
8012d038:	d8001d85 	stb	zero,118(sp)
8012d03c:	58800204 	addi	r2,r11,8
8012d040:	5f000017 	ldw	fp,0(r11)
8012d044:	5a400117 	ldw	r9,4(r11)
8012d048:	8002a816 	blt	r16,zero,8012daec <___svfiprintf_internal_r+0xf80>
8012d04c:	013fdfc4 	movi	r4,-129
8012d050:	e246b03a 	or	r3,fp,r9
8012d054:	d8802315 	stw	r2,140(sp)
8012d058:	9124703a 	and	r18,r18,r4
8012d05c:	18013c26 	beq	r3,zero,8012d550 <___svfiprintf_internal_r+0x9e4>
8012d060:	0015883a 	mov	r10,zero
8012d064:	dc401a04 	addi	r17,sp,104
8012d068:	e006d0fa 	srli	r3,fp,3
8012d06c:	4808977a 	slli	r4,r9,29
8012d070:	4812d0fa 	srli	r9,r9,3
8012d074:	e70001cc 	andi	fp,fp,7
8012d078:	e0800c04 	addi	r2,fp,48
8012d07c:	8c7fffc4 	addi	r17,r17,-1
8012d080:	20f8b03a 	or	fp,r4,r3
8012d084:	88800005 	stb	r2,0(r17)
8012d088:	e246b03a 	or	r3,fp,r9
8012d08c:	183ff61e 	bne	r3,zero,8012d068 <__reset+0xfa10d068>
8012d090:	90c0004c 	andi	r3,r18,1
8012d094:	1800a526 	beq	r3,zero,8012d32c <___svfiprintf_internal_r+0x7c0>
8012d098:	10803fcc 	andi	r2,r2,255
8012d09c:	1080201c 	xori	r2,r2,128
8012d0a0:	10bfe004 	addi	r2,r2,-128
8012d0a4:	00c00c04 	movi	r3,48
8012d0a8:	10ffb626 	beq	r2,r3,8012cf84 <__reset+0xfa10cf84>
8012d0ac:	88ffffc5 	stb	r3,-1(r17)
8012d0b0:	d8c01e17 	ldw	r3,120(sp)
8012d0b4:	88bfffc4 	addi	r2,r17,-1
8012d0b8:	1023883a 	mov	r17,r2
8012d0bc:	1887c83a 	sub	r3,r3,r2
8012d0c0:	d8c02115 	stw	r3,132(sp)
8012d0c4:	003fc706 	br	8012cfe4 <__reset+0xfa10cfe4>
8012d0c8:	dac02317 	ldw	r11,140(sp)
8012d0cc:	00c00044 	movi	r3,1
8012d0d0:	d8c02015 	stw	r3,128(sp)
8012d0d4:	58800017 	ldw	r2,0(r11)
8012d0d8:	5ac00104 	addi	r11,r11,4
8012d0dc:	d8001d85 	stb	zero,118(sp)
8012d0e0:	d8801005 	stb	r2,64(sp)
8012d0e4:	dac02315 	stw	r11,140(sp)
8012d0e8:	d8c02115 	stw	r3,132(sp)
8012d0ec:	dc401004 	addi	r17,sp,64
8012d0f0:	0021883a 	mov	r16,zero
8012d0f4:	90c0008c 	andi	r3,r18,2
8012d0f8:	d8c02215 	stw	r3,136(sp)
8012d0fc:	18000326 	beq	r3,zero,8012d10c <___svfiprintf_internal_r+0x5a0>
8012d100:	dac02017 	ldw	r11,128(sp)
8012d104:	5ac00084 	addi	r11,r11,2
8012d108:	dac02015 	stw	r11,128(sp)
8012d10c:	90c0210c 	andi	r3,r18,132
8012d110:	d8c02615 	stw	r3,152(sp)
8012d114:	1801131e 	bne	r3,zero,8012d564 <___svfiprintf_internal_r+0x9f8>
8012d118:	dac02417 	ldw	r11,144(sp)
8012d11c:	d8c02017 	ldw	r3,128(sp)
8012d120:	58f9c83a 	sub	fp,r11,r3
8012d124:	07010f0e 	bge	zero,fp,8012d564 <___svfiprintf_internal_r+0x9f8>
8012d128:	02400404 	movi	r9,16
8012d12c:	d8c01c17 	ldw	r3,112(sp)
8012d130:	d8801b17 	ldw	r2,108(sp)
8012d134:	4f02d60e 	bge	r9,fp,8012dc90 <___svfiprintf_internal_r+0x1124>
8012d138:	01600534 	movhi	r5,32788
8012d13c:	295f5004 	addi	r5,r5,32064
8012d140:	d9402815 	stw	r5,160(sp)
8012d144:	028001c4 	movi	r10,7
8012d148:	00000306 	br	8012d158 <___svfiprintf_internal_r+0x5ec>
8012d14c:	e73ffc04 	addi	fp,fp,-16
8012d150:	42000204 	addi	r8,r8,8
8012d154:	4f00150e 	bge	r9,fp,8012d1ac <___svfiprintf_internal_r+0x640>
8012d158:	18c00404 	addi	r3,r3,16
8012d15c:	10800044 	addi	r2,r2,1
8012d160:	45800015 	stw	r22,0(r8)
8012d164:	42400115 	stw	r9,4(r8)
8012d168:	d8c01c15 	stw	r3,112(sp)
8012d16c:	d8801b15 	stw	r2,108(sp)
8012d170:	50bff60e 	bge	r10,r2,8012d14c <__reset+0xfa10d14c>
8012d174:	d9801a04 	addi	r6,sp,104
8012d178:	b80b883a 	mov	r5,r23
8012d17c:	a809883a 	mov	r4,r21
8012d180:	da402c15 	stw	r9,176(sp)
8012d184:	da802d15 	stw	r10,180(sp)
8012d188:	012c9940 	call	8012c994 <__ssprint_r>
8012d18c:	da402c17 	ldw	r9,176(sp)
8012d190:	da802d17 	ldw	r10,180(sp)
8012d194:	1001851e 	bne	r2,zero,8012d7ac <___svfiprintf_internal_r+0xc40>
8012d198:	e73ffc04 	addi	fp,fp,-16
8012d19c:	d8c01c17 	ldw	r3,112(sp)
8012d1a0:	d8801b17 	ldw	r2,108(sp)
8012d1a4:	d811883a 	mov	r8,sp
8012d1a8:	4f3feb16 	blt	r9,fp,8012d158 <__reset+0xfa10d158>
8012d1ac:	dac02817 	ldw	r11,160(sp)
8012d1b0:	e0c7883a 	add	r3,fp,r3
8012d1b4:	10800044 	addi	r2,r2,1
8012d1b8:	42c00015 	stw	r11,0(r8)
8012d1bc:	47000115 	stw	fp,4(r8)
8012d1c0:	d8c01c15 	stw	r3,112(sp)
8012d1c4:	d8801b15 	stw	r2,108(sp)
8012d1c8:	010001c4 	movi	r4,7
8012d1cc:	2081ee16 	blt	r4,r2,8012d988 <___svfiprintf_internal_r+0xe1c>
8012d1d0:	42000204 	addi	r8,r8,8
8012d1d4:	0000e506 	br	8012d56c <___svfiprintf_internal_r+0xa00>
8012d1d8:	21003fcc 	andi	r4,r4,255
8012d1dc:	2002dd1e 	bne	r4,zero,8012dd54 <___svfiprintf_internal_r+0x11e8>
8012d1e0:	00a00534 	movhi	r2,32788
8012d1e4:	109ec404 	addi	r2,r2,31504
8012d1e8:	d8802915 	stw	r2,164(sp)
8012d1ec:	9080080c 	andi	r2,r18,32
8012d1f0:	103f461e 	bne	r2,zero,8012cf0c <__reset+0xfa10cf0c>
8012d1f4:	9080040c 	andi	r2,r18,16
8012d1f8:	10022e1e 	bne	r2,zero,8012dab4 <___svfiprintf_internal_r+0xf48>
8012d1fc:	9080100c 	andi	r2,r18,64
8012d200:	dac02317 	ldw	r11,140(sp)
8012d204:	10027326 	beq	r2,zero,8012dbd4 <___svfiprintf_internal_r+0x1068>
8012d208:	5f00000b 	ldhu	fp,0(r11)
8012d20c:	5ac00104 	addi	r11,r11,4
8012d210:	0013883a 	mov	r9,zero
8012d214:	dac02315 	stw	r11,140(sp)
8012d218:	003f4106 	br	8012cf20 <__reset+0xfa10cf20>
8012d21c:	21003fcc 	andi	r4,r4,255
8012d220:	2002e11e 	bne	r4,zero,8012dda8 <___svfiprintf_internal_r+0x123c>
8012d224:	9080080c 	andi	r2,r18,32
8012d228:	1002011e 	bne	r2,zero,8012da30 <___svfiprintf_internal_r+0xec4>
8012d22c:	9080040c 	andi	r2,r18,16
8012d230:	10023e1e 	bne	r2,zero,8012db2c <___svfiprintf_internal_r+0xfc0>
8012d234:	9480100c 	andi	r18,r18,64
8012d238:	90023c26 	beq	r18,zero,8012db2c <___svfiprintf_internal_r+0xfc0>
8012d23c:	dac02317 	ldw	r11,140(sp)
8012d240:	58800017 	ldw	r2,0(r11)
8012d244:	5ac00104 	addi	r11,r11,4
8012d248:	dac02315 	stw	r11,140(sp)
8012d24c:	dac02517 	ldw	r11,148(sp)
8012d250:	12c0000d 	sth	r11,0(r2)
8012d254:	003e6e06 	br	8012cc10 <__reset+0xfa10cc10>
8012d258:	98c00007 	ldb	r3,0(r19)
8012d25c:	1a422926 	beq	r3,r9,8012db04 <___svfiprintf_internal_r+0xf98>
8012d260:	94800414 	ori	r18,r18,16
8012d264:	003e9206 	br	8012ccb0 <__reset+0xfa10ccb0>
8012d268:	94801014 	ori	r18,r18,64
8012d26c:	98c00007 	ldb	r3,0(r19)
8012d270:	003e8f06 	br	8012ccb0 <__reset+0xfa10ccb0>
8012d274:	21003fcc 	andi	r4,r4,255
8012d278:	2002c71e 	bne	r4,zero,8012dd98 <___svfiprintf_internal_r+0x122c>
8012d27c:	9080080c 	andi	r2,r18,32
8012d280:	10004926 	beq	r2,zero,8012d3a8 <___svfiprintf_internal_r+0x83c>
8012d284:	dac02317 	ldw	r11,140(sp)
8012d288:	58800117 	ldw	r2,4(r11)
8012d28c:	5f000017 	ldw	fp,0(r11)
8012d290:	5ac00204 	addi	r11,r11,8
8012d294:	dac02315 	stw	r11,140(sp)
8012d298:	1013883a 	mov	r9,r2
8012d29c:	10004b16 	blt	r2,zero,8012d3cc <___svfiprintf_internal_r+0x860>
8012d2a0:	da801d83 	ldbu	r10,118(sp)
8012d2a4:	8001cb16 	blt	r16,zero,8012d9d4 <___svfiprintf_internal_r+0xe68>
8012d2a8:	00ffdfc4 	movi	r3,-129
8012d2ac:	e244b03a 	or	r2,fp,r9
8012d2b0:	90e4703a 	and	r18,r18,r3
8012d2b4:	103f4726 	beq	r2,zero,8012cfd4 <__reset+0xfa10cfd4>
8012d2b8:	48008c26 	beq	r9,zero,8012d4ec <___svfiprintf_internal_r+0x980>
8012d2bc:	dc802015 	stw	r18,128(sp)
8012d2c0:	dc002115 	stw	r16,132(sp)
8012d2c4:	dc401a04 	addi	r17,sp,104
8012d2c8:	e021883a 	mov	r16,fp
8012d2cc:	da002215 	stw	r8,136(sp)
8012d2d0:	5039883a 	mov	fp,r10
8012d2d4:	4825883a 	mov	r18,r9
8012d2d8:	8009883a 	mov	r4,r16
8012d2dc:	900b883a 	mov	r5,r18
8012d2e0:	01800284 	movi	r6,10
8012d2e4:	000f883a 	mov	r7,zero
8012d2e8:	012fc300 	call	8012fc30 <__umoddi3>
8012d2ec:	10800c04 	addi	r2,r2,48
8012d2f0:	8c7fffc4 	addi	r17,r17,-1
8012d2f4:	8009883a 	mov	r4,r16
8012d2f8:	900b883a 	mov	r5,r18
8012d2fc:	88800005 	stb	r2,0(r17)
8012d300:	01800284 	movi	r6,10
8012d304:	000f883a 	mov	r7,zero
8012d308:	012f6b00 	call	8012f6b0 <__udivdi3>
8012d30c:	1021883a 	mov	r16,r2
8012d310:	10c4b03a 	or	r2,r2,r3
8012d314:	1825883a 	mov	r18,r3
8012d318:	103fef1e 	bne	r2,zero,8012d2d8 <__reset+0xfa10d2d8>
8012d31c:	dc802017 	ldw	r18,128(sp)
8012d320:	dc002117 	ldw	r16,132(sp)
8012d324:	da002217 	ldw	r8,136(sp)
8012d328:	e015883a 	mov	r10,fp
8012d32c:	d8c01e17 	ldw	r3,120(sp)
8012d330:	1c47c83a 	sub	r3,r3,r17
8012d334:	d8c02115 	stw	r3,132(sp)
8012d338:	003f2a06 	br	8012cfe4 <__reset+0xfa10cfe4>
8012d33c:	dac02317 	ldw	r11,140(sp)
8012d340:	d8001d85 	stb	zero,118(sp)
8012d344:	5c400017 	ldw	r17,0(r11)
8012d348:	5f000104 	addi	fp,r11,4
8012d34c:	88022f26 	beq	r17,zero,8012dc0c <___svfiprintf_internal_r+0x10a0>
8012d350:	80022516 	blt	r16,zero,8012dbe8 <___svfiprintf_internal_r+0x107c>
8012d354:	800d883a 	mov	r6,r16
8012d358:	000b883a 	mov	r5,zero
8012d35c:	8809883a 	mov	r4,r17
8012d360:	da002c15 	stw	r8,176(sp)
8012d364:	0128ee00 	call	80128ee0 <memchr>
8012d368:	da002c17 	ldw	r8,176(sp)
8012d36c:	10026426 	beq	r2,zero,8012dd00 <___svfiprintf_internal_r+0x1194>
8012d370:	1445c83a 	sub	r2,r2,r17
8012d374:	d8802115 	stw	r2,132(sp)
8012d378:	da801d83 	ldbu	r10,118(sp)
8012d37c:	df002315 	stw	fp,140(sp)
8012d380:	0021883a 	mov	r16,zero
8012d384:	003f1706 	br	8012cfe4 <__reset+0xfa10cfe4>
8012d388:	94800814 	ori	r18,r18,32
8012d38c:	98c00007 	ldb	r3,0(r19)
8012d390:	003e4706 	br	8012ccb0 <__reset+0xfa10ccb0>
8012d394:	21003fcc 	andi	r4,r4,255
8012d398:	2002701e 	bne	r4,zero,8012dd5c <___svfiprintf_internal_r+0x11f0>
8012d39c:	94800414 	ori	r18,r18,16
8012d3a0:	9080080c 	andi	r2,r18,32
8012d3a4:	103fb71e 	bne	r2,zero,8012d284 <__reset+0xfa10d284>
8012d3a8:	9080040c 	andi	r2,r18,16
8012d3ac:	1001ab26 	beq	r2,zero,8012da5c <___svfiprintf_internal_r+0xef0>
8012d3b0:	dac02317 	ldw	r11,140(sp)
8012d3b4:	5f000017 	ldw	fp,0(r11)
8012d3b8:	5ac00104 	addi	r11,r11,4
8012d3bc:	dac02315 	stw	r11,140(sp)
8012d3c0:	e013d7fa 	srai	r9,fp,31
8012d3c4:	4805883a 	mov	r2,r9
8012d3c8:	103fb50e 	bge	r2,zero,8012d2a0 <__reset+0xfa10d2a0>
8012d3cc:	0739c83a 	sub	fp,zero,fp
8012d3d0:	02800b44 	movi	r10,45
8012d3d4:	e004c03a 	cmpne	r2,fp,zero
8012d3d8:	0253c83a 	sub	r9,zero,r9
8012d3dc:	da801d85 	stb	r10,118(sp)
8012d3e0:	4893c83a 	sub	r9,r9,r2
8012d3e4:	80023016 	blt	r16,zero,8012dca8 <___svfiprintf_internal_r+0x113c>
8012d3e8:	00bfdfc4 	movi	r2,-129
8012d3ec:	90a4703a 	and	r18,r18,r2
8012d3f0:	483fb21e 	bne	r9,zero,8012d2bc <__reset+0xfa10d2bc>
8012d3f4:	00003d06 	br	8012d4ec <___svfiprintf_internal_r+0x980>
8012d3f8:	9817883a 	mov	r11,r19
8012d3fc:	d8002415 	stw	zero,144(sp)
8012d400:	18bff404 	addi	r2,r3,-48
8012d404:	0019883a 	mov	r12,zero
8012d408:	58c00007 	ldb	r3,0(r11)
8012d40c:	630002a4 	muli	r12,r12,10
8012d410:	9cc00044 	addi	r19,r19,1
8012d414:	9817883a 	mov	r11,r19
8012d418:	1319883a 	add	r12,r2,r12
8012d41c:	18bff404 	addi	r2,r3,-48
8012d420:	30bff92e 	bgeu	r6,r2,8012d408 <__reset+0xfa10d408>
8012d424:	db002415 	stw	r12,144(sp)
8012d428:	18bff804 	addi	r2,r3,-32
8012d42c:	28be232e 	bgeu	r5,r2,8012ccbc <__reset+0xfa10ccbc>
8012d430:	21003fcc 	andi	r4,r4,255
8012d434:	20024b1e 	bne	r4,zero,8012dd64 <___svfiprintf_internal_r+0x11f8>
8012d438:	1800d626 	beq	r3,zero,8012d794 <___svfiprintf_internal_r+0xc28>
8012d43c:	02c00044 	movi	r11,1
8012d440:	dac02015 	stw	r11,128(sp)
8012d444:	d8c01005 	stb	r3,64(sp)
8012d448:	d8001d85 	stb	zero,118(sp)
8012d44c:	dac02115 	stw	r11,132(sp)
8012d450:	dc401004 	addi	r17,sp,64
8012d454:	003f2606 	br	8012d0f0 <__reset+0xfa10d0f0>
8012d458:	94802014 	ori	r18,r18,128
8012d45c:	98c00007 	ldb	r3,0(r19)
8012d460:	003e1306 	br	8012ccb0 <__reset+0xfa10ccb0>
8012d464:	98c00007 	ldb	r3,0(r19)
8012d468:	9ac00044 	addi	r11,r19,1
8012d46c:	1a822b26 	beq	r3,r10,8012dd1c <___svfiprintf_internal_r+0x11b0>
8012d470:	18bff404 	addi	r2,r3,-48
8012d474:	0021883a 	mov	r16,zero
8012d478:	30821e36 	bltu	r6,r2,8012dcf4 <___svfiprintf_internal_r+0x1188>
8012d47c:	58c00007 	ldb	r3,0(r11)
8012d480:	840002a4 	muli	r16,r16,10
8012d484:	5cc00044 	addi	r19,r11,1
8012d488:	9817883a 	mov	r11,r19
8012d48c:	80a1883a 	add	r16,r16,r2
8012d490:	18bff404 	addi	r2,r3,-48
8012d494:	30bff92e 	bgeu	r6,r2,8012d47c <__reset+0xfa10d47c>
8012d498:	803e060e 	bge	r16,zero,8012ccb4 <__reset+0xfa10ccb4>
8012d49c:	043fffc4 	movi	r16,-1
8012d4a0:	003e0406 	br	8012ccb4 <__reset+0xfa10ccb4>
8012d4a4:	21003fcc 	andi	r4,r4,255
8012d4a8:	2002371e 	bne	r4,zero,8012dd88 <___svfiprintf_internal_r+0x121c>
8012d4ac:	94800414 	ori	r18,r18,16
8012d4b0:	9080080c 	andi	r2,r18,32
8012d4b4:	103ebb1e 	bne	r2,zero,8012cfa4 <__reset+0xfa10cfa4>
8012d4b8:	9080040c 	andi	r2,r18,16
8012d4bc:	10013b26 	beq	r2,zero,8012d9ac <___svfiprintf_internal_r+0xe40>
8012d4c0:	dac02317 	ldw	r11,140(sp)
8012d4c4:	d8001d85 	stb	zero,118(sp)
8012d4c8:	0013883a 	mov	r9,zero
8012d4cc:	58800104 	addi	r2,r11,4
8012d4d0:	5f000017 	ldw	fp,0(r11)
8012d4d4:	80013d16 	blt	r16,zero,8012d9cc <___svfiprintf_internal_r+0xe60>
8012d4d8:	00ffdfc4 	movi	r3,-129
8012d4dc:	d8802315 	stw	r2,140(sp)
8012d4e0:	90e4703a 	and	r18,r18,r3
8012d4e4:	0015883a 	mov	r10,zero
8012d4e8:	e03eba26 	beq	fp,zero,8012cfd4 <__reset+0xfa10cfd4>
8012d4ec:	00800244 	movi	r2,9
8012d4f0:	173f7236 	bltu	r2,fp,8012d2bc <__reset+0xfa10d2bc>
8012d4f4:	dac02b17 	ldw	r11,172(sp)
8012d4f8:	e7000c04 	addi	fp,fp,48
8012d4fc:	df0019c5 	stb	fp,103(sp)
8012d500:	dac02115 	stw	r11,132(sp)
8012d504:	dc4019c4 	addi	r17,sp,103
8012d508:	003eb606 	br	8012cfe4 <__reset+0xfa10cfe4>
8012d50c:	21003fcc 	andi	r4,r4,255
8012d510:	20021f1e 	bne	r4,zero,8012dd90 <___svfiprintf_internal_r+0x1224>
8012d514:	94800414 	ori	r18,r18,16
8012d518:	9080080c 	andi	r2,r18,32
8012d51c:	103ec51e 	bne	r2,zero,8012d034 <__reset+0xfa10d034>
8012d520:	9080040c 	andi	r2,r18,16
8012d524:	10016926 	beq	r2,zero,8012dacc <___svfiprintf_internal_r+0xf60>
8012d528:	dac02317 	ldw	r11,140(sp)
8012d52c:	d8001d85 	stb	zero,118(sp)
8012d530:	0013883a 	mov	r9,zero
8012d534:	58800104 	addi	r2,r11,4
8012d538:	5f000017 	ldw	fp,0(r11)
8012d53c:	80016b16 	blt	r16,zero,8012daec <___svfiprintf_internal_r+0xf80>
8012d540:	00ffdfc4 	movi	r3,-129
8012d544:	d8802315 	stw	r2,140(sp)
8012d548:	90e4703a 	and	r18,r18,r3
8012d54c:	e03ec41e 	bne	fp,zero,8012d060 <__reset+0xfa10d060>
8012d550:	0015883a 	mov	r10,zero
8012d554:	8001c226 	beq	r16,zero,8012dc60 <___svfiprintf_internal_r+0x10f4>
8012d558:	0039883a 	mov	fp,zero
8012d55c:	0013883a 	mov	r9,zero
8012d560:	003ec006 	br	8012d064 <__reset+0xfa10d064>
8012d564:	d8c01c17 	ldw	r3,112(sp)
8012d568:	d8801b17 	ldw	r2,108(sp)
8012d56c:	d9001d87 	ldb	r4,118(sp)
8012d570:	20000b26 	beq	r4,zero,8012d5a0 <___svfiprintf_internal_r+0xa34>
8012d574:	d9001d84 	addi	r4,sp,118
8012d578:	18c00044 	addi	r3,r3,1
8012d57c:	10800044 	addi	r2,r2,1
8012d580:	41000015 	stw	r4,0(r8)
8012d584:	01000044 	movi	r4,1
8012d588:	41000115 	stw	r4,4(r8)
8012d58c:	d8c01c15 	stw	r3,112(sp)
8012d590:	d8801b15 	stw	r2,108(sp)
8012d594:	010001c4 	movi	r4,7
8012d598:	2080e116 	blt	r4,r2,8012d920 <___svfiprintf_internal_r+0xdb4>
8012d59c:	42000204 	addi	r8,r8,8
8012d5a0:	dac02217 	ldw	r11,136(sp)
8012d5a4:	58000b26 	beq	r11,zero,8012d5d4 <___svfiprintf_internal_r+0xa68>
8012d5a8:	d9001d04 	addi	r4,sp,116
8012d5ac:	18c00084 	addi	r3,r3,2
8012d5b0:	10800044 	addi	r2,r2,1
8012d5b4:	41000015 	stw	r4,0(r8)
8012d5b8:	01000084 	movi	r4,2
8012d5bc:	41000115 	stw	r4,4(r8)
8012d5c0:	d8c01c15 	stw	r3,112(sp)
8012d5c4:	d8801b15 	stw	r2,108(sp)
8012d5c8:	010001c4 	movi	r4,7
8012d5cc:	2080dd16 	blt	r4,r2,8012d944 <___svfiprintf_internal_r+0xdd8>
8012d5d0:	42000204 	addi	r8,r8,8
8012d5d4:	dac02617 	ldw	r11,152(sp)
8012d5d8:	01002004 	movi	r4,128
8012d5dc:	59008426 	beq	r11,r4,8012d7f0 <___svfiprintf_internal_r+0xc84>
8012d5e0:	dac02117 	ldw	r11,132(sp)
8012d5e4:	82e1c83a 	sub	r16,r16,r11
8012d5e8:	0400270e 	bge	zero,r16,8012d688 <___svfiprintf_internal_r+0xb1c>
8012d5ec:	01c00404 	movi	r7,16
8012d5f0:	3c016a0e 	bge	r7,r16,8012db9c <___svfiprintf_internal_r+0x1030>
8012d5f4:	01600534 	movhi	r5,32788
8012d5f8:	295f4c04 	addi	r5,r5,32048
8012d5fc:	d9402215 	stw	r5,136(sp)
8012d600:	070001c4 	movi	fp,7
8012d604:	00000306 	br	8012d614 <___svfiprintf_internal_r+0xaa8>
8012d608:	843ffc04 	addi	r16,r16,-16
8012d60c:	42000204 	addi	r8,r8,8
8012d610:	3c00130e 	bge	r7,r16,8012d660 <___svfiprintf_internal_r+0xaf4>
8012d614:	18c00404 	addi	r3,r3,16
8012d618:	10800044 	addi	r2,r2,1
8012d61c:	45000015 	stw	r20,0(r8)
8012d620:	41c00115 	stw	r7,4(r8)
8012d624:	d8c01c15 	stw	r3,112(sp)
8012d628:	d8801b15 	stw	r2,108(sp)
8012d62c:	e0bff60e 	bge	fp,r2,8012d608 <__reset+0xfa10d608>
8012d630:	d9801a04 	addi	r6,sp,104
8012d634:	b80b883a 	mov	r5,r23
8012d638:	a809883a 	mov	r4,r21
8012d63c:	d9c02c15 	stw	r7,176(sp)
8012d640:	012c9940 	call	8012c994 <__ssprint_r>
8012d644:	d9c02c17 	ldw	r7,176(sp)
8012d648:	1000581e 	bne	r2,zero,8012d7ac <___svfiprintf_internal_r+0xc40>
8012d64c:	843ffc04 	addi	r16,r16,-16
8012d650:	d8c01c17 	ldw	r3,112(sp)
8012d654:	d8801b17 	ldw	r2,108(sp)
8012d658:	d811883a 	mov	r8,sp
8012d65c:	3c3fed16 	blt	r7,r16,8012d614 <__reset+0xfa10d614>
8012d660:	dac02217 	ldw	r11,136(sp)
8012d664:	1c07883a 	add	r3,r3,r16
8012d668:	10800044 	addi	r2,r2,1
8012d66c:	42c00015 	stw	r11,0(r8)
8012d670:	44000115 	stw	r16,4(r8)
8012d674:	d8c01c15 	stw	r3,112(sp)
8012d678:	d8801b15 	stw	r2,108(sp)
8012d67c:	010001c4 	movi	r4,7
8012d680:	20809e16 	blt	r4,r2,8012d8fc <___svfiprintf_internal_r+0xd90>
8012d684:	42000204 	addi	r8,r8,8
8012d688:	dac02117 	ldw	r11,132(sp)
8012d68c:	10800044 	addi	r2,r2,1
8012d690:	44400015 	stw	r17,0(r8)
8012d694:	58c7883a 	add	r3,r11,r3
8012d698:	42c00115 	stw	r11,4(r8)
8012d69c:	d8c01c15 	stw	r3,112(sp)
8012d6a0:	d8801b15 	stw	r2,108(sp)
8012d6a4:	010001c4 	movi	r4,7
8012d6a8:	20807f16 	blt	r4,r2,8012d8a8 <___svfiprintf_internal_r+0xd3c>
8012d6ac:	42000204 	addi	r8,r8,8
8012d6b0:	9480010c 	andi	r18,r18,4
8012d6b4:	90002926 	beq	r18,zero,8012d75c <___svfiprintf_internal_r+0xbf0>
8012d6b8:	dac02417 	ldw	r11,144(sp)
8012d6bc:	d8802017 	ldw	r2,128(sp)
8012d6c0:	58a1c83a 	sub	r16,r11,r2
8012d6c4:	0400250e 	bge	zero,r16,8012d75c <___svfiprintf_internal_r+0xbf0>
8012d6c8:	04400404 	movi	r17,16
8012d6cc:	d8801b17 	ldw	r2,108(sp)
8012d6d0:	8c017c0e 	bge	r17,r16,8012dcc4 <___svfiprintf_internal_r+0x1158>
8012d6d4:	01600534 	movhi	r5,32788
8012d6d8:	295f5004 	addi	r5,r5,32064
8012d6dc:	d9402815 	stw	r5,160(sp)
8012d6e0:	048001c4 	movi	r18,7
8012d6e4:	00000306 	br	8012d6f4 <___svfiprintf_internal_r+0xb88>
8012d6e8:	843ffc04 	addi	r16,r16,-16
8012d6ec:	42000204 	addi	r8,r8,8
8012d6f0:	8c00110e 	bge	r17,r16,8012d738 <___svfiprintf_internal_r+0xbcc>
8012d6f4:	18c00404 	addi	r3,r3,16
8012d6f8:	10800044 	addi	r2,r2,1
8012d6fc:	45800015 	stw	r22,0(r8)
8012d700:	44400115 	stw	r17,4(r8)
8012d704:	d8c01c15 	stw	r3,112(sp)
8012d708:	d8801b15 	stw	r2,108(sp)
8012d70c:	90bff60e 	bge	r18,r2,8012d6e8 <__reset+0xfa10d6e8>
8012d710:	d9801a04 	addi	r6,sp,104
8012d714:	b80b883a 	mov	r5,r23
8012d718:	a809883a 	mov	r4,r21
8012d71c:	012c9940 	call	8012c994 <__ssprint_r>
8012d720:	1000221e 	bne	r2,zero,8012d7ac <___svfiprintf_internal_r+0xc40>
8012d724:	843ffc04 	addi	r16,r16,-16
8012d728:	d8c01c17 	ldw	r3,112(sp)
8012d72c:	d8801b17 	ldw	r2,108(sp)
8012d730:	d811883a 	mov	r8,sp
8012d734:	8c3fef16 	blt	r17,r16,8012d6f4 <__reset+0xfa10d6f4>
8012d738:	dac02817 	ldw	r11,160(sp)
8012d73c:	1c07883a 	add	r3,r3,r16
8012d740:	10800044 	addi	r2,r2,1
8012d744:	42c00015 	stw	r11,0(r8)
8012d748:	44000115 	stw	r16,4(r8)
8012d74c:	d8c01c15 	stw	r3,112(sp)
8012d750:	d8801b15 	stw	r2,108(sp)
8012d754:	010001c4 	movi	r4,7
8012d758:	2080aa16 	blt	r4,r2,8012da04 <___svfiprintf_internal_r+0xe98>
8012d75c:	d8802417 	ldw	r2,144(sp)
8012d760:	dac02017 	ldw	r11,128(sp)
8012d764:	12c0010e 	bge	r2,r11,8012d76c <___svfiprintf_internal_r+0xc00>
8012d768:	5805883a 	mov	r2,r11
8012d76c:	dac02517 	ldw	r11,148(sp)
8012d770:	5897883a 	add	r11,r11,r2
8012d774:	dac02515 	stw	r11,148(sp)
8012d778:	1800531e 	bne	r3,zero,8012d8c8 <___svfiprintf_internal_r+0xd5c>
8012d77c:	98800007 	ldb	r2,0(r19)
8012d780:	d8001b15 	stw	zero,108(sp)
8012d784:	d811883a 	mov	r8,sp
8012d788:	103d231e 	bne	r2,zero,8012cc18 <__reset+0xfa10cc18>
8012d78c:	9823883a 	mov	r17,r19
8012d790:	003d3906 	br	8012cc78 <__reset+0xfa10cc78>
8012d794:	d8801c17 	ldw	r2,112(sp)
8012d798:	10000426 	beq	r2,zero,8012d7ac <___svfiprintf_internal_r+0xc40>
8012d79c:	d9402717 	ldw	r5,156(sp)
8012d7a0:	d9002a17 	ldw	r4,168(sp)
8012d7a4:	d9801a04 	addi	r6,sp,104
8012d7a8:	012c9940 	call	8012c994 <__ssprint_r>
8012d7ac:	dac02717 	ldw	r11,156(sp)
8012d7b0:	d8802517 	ldw	r2,148(sp)
8012d7b4:	58c0030b 	ldhu	r3,12(r11)
8012d7b8:	18c0100c 	andi	r3,r3,64
8012d7bc:	1801381e 	bne	r3,zero,8012dca0 <___svfiprintf_internal_r+0x1134>
8012d7c0:	dfc03717 	ldw	ra,220(sp)
8012d7c4:	df003617 	ldw	fp,216(sp)
8012d7c8:	ddc03517 	ldw	r23,212(sp)
8012d7cc:	dd803417 	ldw	r22,208(sp)
8012d7d0:	dd403317 	ldw	r21,204(sp)
8012d7d4:	dd003217 	ldw	r20,200(sp)
8012d7d8:	dcc03117 	ldw	r19,196(sp)
8012d7dc:	dc803017 	ldw	r18,192(sp)
8012d7e0:	dc402f17 	ldw	r17,188(sp)
8012d7e4:	dc002e17 	ldw	r16,184(sp)
8012d7e8:	dec03804 	addi	sp,sp,224
8012d7ec:	f800283a 	ret
8012d7f0:	dac02417 	ldw	r11,144(sp)
8012d7f4:	d9002017 	ldw	r4,128(sp)
8012d7f8:	5939c83a 	sub	fp,r11,r4
8012d7fc:	073f780e 	bge	zero,fp,8012d5e0 <__reset+0xfa10d5e0>
8012d800:	02400404 	movi	r9,16
8012d804:	4f01370e 	bge	r9,fp,8012dce4 <___svfiprintf_internal_r+0x1178>
8012d808:	02e00534 	movhi	r11,32788
8012d80c:	5adf4c04 	addi	r11,r11,32048
8012d810:	dac02215 	stw	r11,136(sp)
8012d814:	028001c4 	movi	r10,7
8012d818:	00000306 	br	8012d828 <___svfiprintf_internal_r+0xcbc>
8012d81c:	e73ffc04 	addi	fp,fp,-16
8012d820:	42000204 	addi	r8,r8,8
8012d824:	4f00150e 	bge	r9,fp,8012d87c <___svfiprintf_internal_r+0xd10>
8012d828:	18c00404 	addi	r3,r3,16
8012d82c:	10800044 	addi	r2,r2,1
8012d830:	45000015 	stw	r20,0(r8)
8012d834:	42400115 	stw	r9,4(r8)
8012d838:	d8c01c15 	stw	r3,112(sp)
8012d83c:	d8801b15 	stw	r2,108(sp)
8012d840:	50bff60e 	bge	r10,r2,8012d81c <__reset+0xfa10d81c>
8012d844:	d9801a04 	addi	r6,sp,104
8012d848:	b80b883a 	mov	r5,r23
8012d84c:	a809883a 	mov	r4,r21
8012d850:	da402c15 	stw	r9,176(sp)
8012d854:	da802d15 	stw	r10,180(sp)
8012d858:	012c9940 	call	8012c994 <__ssprint_r>
8012d85c:	da402c17 	ldw	r9,176(sp)
8012d860:	da802d17 	ldw	r10,180(sp)
8012d864:	103fd11e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012d868:	e73ffc04 	addi	fp,fp,-16
8012d86c:	d8c01c17 	ldw	r3,112(sp)
8012d870:	d8801b17 	ldw	r2,108(sp)
8012d874:	d811883a 	mov	r8,sp
8012d878:	4f3feb16 	blt	r9,fp,8012d828 <__reset+0xfa10d828>
8012d87c:	dac02217 	ldw	r11,136(sp)
8012d880:	1f07883a 	add	r3,r3,fp
8012d884:	10800044 	addi	r2,r2,1
8012d888:	42c00015 	stw	r11,0(r8)
8012d88c:	47000115 	stw	fp,4(r8)
8012d890:	d8c01c15 	stw	r3,112(sp)
8012d894:	d8801b15 	stw	r2,108(sp)
8012d898:	010001c4 	movi	r4,7
8012d89c:	2080b616 	blt	r4,r2,8012db78 <___svfiprintf_internal_r+0x100c>
8012d8a0:	42000204 	addi	r8,r8,8
8012d8a4:	003f4e06 	br	8012d5e0 <__reset+0xfa10d5e0>
8012d8a8:	d9801a04 	addi	r6,sp,104
8012d8ac:	b80b883a 	mov	r5,r23
8012d8b0:	a809883a 	mov	r4,r21
8012d8b4:	012c9940 	call	8012c994 <__ssprint_r>
8012d8b8:	103fbc1e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012d8bc:	d8c01c17 	ldw	r3,112(sp)
8012d8c0:	d811883a 	mov	r8,sp
8012d8c4:	003f7a06 	br	8012d6b0 <__reset+0xfa10d6b0>
8012d8c8:	d9801a04 	addi	r6,sp,104
8012d8cc:	b80b883a 	mov	r5,r23
8012d8d0:	a809883a 	mov	r4,r21
8012d8d4:	012c9940 	call	8012c994 <__ssprint_r>
8012d8d8:	103fa826 	beq	r2,zero,8012d77c <__reset+0xfa10d77c>
8012d8dc:	003fb306 	br	8012d7ac <__reset+0xfa10d7ac>
8012d8e0:	d9801a04 	addi	r6,sp,104
8012d8e4:	b80b883a 	mov	r5,r23
8012d8e8:	a809883a 	mov	r4,r21
8012d8ec:	012c9940 	call	8012c994 <__ssprint_r>
8012d8f0:	103fae1e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012d8f4:	d811883a 	mov	r8,sp
8012d8f8:	003cdc06 	br	8012cc6c <__reset+0xfa10cc6c>
8012d8fc:	d9801a04 	addi	r6,sp,104
8012d900:	b80b883a 	mov	r5,r23
8012d904:	a809883a 	mov	r4,r21
8012d908:	012c9940 	call	8012c994 <__ssprint_r>
8012d90c:	103fa71e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012d910:	d8c01c17 	ldw	r3,112(sp)
8012d914:	d8801b17 	ldw	r2,108(sp)
8012d918:	d811883a 	mov	r8,sp
8012d91c:	003f5a06 	br	8012d688 <__reset+0xfa10d688>
8012d920:	d9801a04 	addi	r6,sp,104
8012d924:	b80b883a 	mov	r5,r23
8012d928:	a809883a 	mov	r4,r21
8012d92c:	012c9940 	call	8012c994 <__ssprint_r>
8012d930:	103f9e1e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012d934:	d8c01c17 	ldw	r3,112(sp)
8012d938:	d8801b17 	ldw	r2,108(sp)
8012d93c:	d811883a 	mov	r8,sp
8012d940:	003f1706 	br	8012d5a0 <__reset+0xfa10d5a0>
8012d944:	d9801a04 	addi	r6,sp,104
8012d948:	b80b883a 	mov	r5,r23
8012d94c:	a809883a 	mov	r4,r21
8012d950:	012c9940 	call	8012c994 <__ssprint_r>
8012d954:	103f951e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012d958:	d8c01c17 	ldw	r3,112(sp)
8012d95c:	d8801b17 	ldw	r2,108(sp)
8012d960:	d811883a 	mov	r8,sp
8012d964:	003f1b06 	br	8012d5d4 <__reset+0xfa10d5d4>
8012d968:	d8001d85 	stb	zero,118(sp)
8012d96c:	80007b16 	blt	r16,zero,8012db5c <___svfiprintf_internal_r+0xff0>
8012d970:	00ffdfc4 	movi	r3,-129
8012d974:	e244b03a 	or	r2,fp,r9
8012d978:	90e4703a 	and	r18,r18,r3
8012d97c:	103d7026 	beq	r2,zero,8012cf40 <__reset+0xfa10cf40>
8012d980:	0015883a 	mov	r10,zero
8012d984:	003d7206 	br	8012cf50 <__reset+0xfa10cf50>
8012d988:	d9801a04 	addi	r6,sp,104
8012d98c:	b80b883a 	mov	r5,r23
8012d990:	a809883a 	mov	r4,r21
8012d994:	012c9940 	call	8012c994 <__ssprint_r>
8012d998:	103f841e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012d99c:	d8c01c17 	ldw	r3,112(sp)
8012d9a0:	d8801b17 	ldw	r2,108(sp)
8012d9a4:	d811883a 	mov	r8,sp
8012d9a8:	003ef006 	br	8012d56c <__reset+0xfa10d56c>
8012d9ac:	9080100c 	andi	r2,r18,64
8012d9b0:	d8001d85 	stb	zero,118(sp)
8012d9b4:	dac02317 	ldw	r11,140(sp)
8012d9b8:	10008126 	beq	r2,zero,8012dbc0 <___svfiprintf_internal_r+0x1054>
8012d9bc:	58800104 	addi	r2,r11,4
8012d9c0:	5f00000b 	ldhu	fp,0(r11)
8012d9c4:	0013883a 	mov	r9,zero
8012d9c8:	803ec30e 	bge	r16,zero,8012d4d8 <__reset+0xfa10d4d8>
8012d9cc:	d8802315 	stw	r2,140(sp)
8012d9d0:	0015883a 	mov	r10,zero
8012d9d4:	e244b03a 	or	r2,fp,r9
8012d9d8:	103e371e 	bne	r2,zero,8012d2b8 <__reset+0xfa10d2b8>
8012d9dc:	00800044 	movi	r2,1
8012d9e0:	10803fcc 	andi	r2,r2,255
8012d9e4:	00c00044 	movi	r3,1
8012d9e8:	10c06126 	beq	r2,r3,8012db70 <___svfiprintf_internal_r+0x1004>
8012d9ec:	00c00084 	movi	r3,2
8012d9f0:	10fd5526 	beq	r2,r3,8012cf48 <__reset+0xfa10cf48>
8012d9f4:	003ed806 	br	8012d558 <__reset+0xfa10d558>
8012d9f8:	d8802315 	stw	r2,140(sp)
8012d9fc:	98c00007 	ldb	r3,0(r19)
8012da00:	003cab06 	br	8012ccb0 <__reset+0xfa10ccb0>
8012da04:	d9801a04 	addi	r6,sp,104
8012da08:	b80b883a 	mov	r5,r23
8012da0c:	a809883a 	mov	r4,r21
8012da10:	012c9940 	call	8012c994 <__ssprint_r>
8012da14:	103f651e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012da18:	d8c01c17 	ldw	r3,112(sp)
8012da1c:	003f4f06 	br	8012d75c <__reset+0xfa10d75c>
8012da20:	00a00534 	movhi	r2,32788
8012da24:	109ec904 	addi	r2,r2,31524
8012da28:	d8802915 	stw	r2,164(sp)
8012da2c:	003d4406 	br	8012cf40 <__reset+0xfa10cf40>
8012da30:	dac02317 	ldw	r11,140(sp)
8012da34:	58800017 	ldw	r2,0(r11)
8012da38:	dac02517 	ldw	r11,148(sp)
8012da3c:	5807d7fa 	srai	r3,r11,31
8012da40:	dac02317 	ldw	r11,140(sp)
8012da44:	10c00115 	stw	r3,4(r2)
8012da48:	5ac00104 	addi	r11,r11,4
8012da4c:	dac02315 	stw	r11,140(sp)
8012da50:	dac02517 	ldw	r11,148(sp)
8012da54:	12c00015 	stw	r11,0(r2)
8012da58:	003c6d06 	br	8012cc10 <__reset+0xfa10cc10>
8012da5c:	9080100c 	andi	r2,r18,64
8012da60:	dac02317 	ldw	r11,140(sp)
8012da64:	103e5326 	beq	r2,zero,8012d3b4 <__reset+0xfa10d3b4>
8012da68:	5f00000f 	ldh	fp,0(r11)
8012da6c:	5ac00104 	addi	r11,r11,4
8012da70:	dac02315 	stw	r11,140(sp)
8012da74:	e013d7fa 	srai	r9,fp,31
8012da78:	4805883a 	mov	r2,r9
8012da7c:	003e0706 	br	8012d29c <__reset+0xfa10d29c>
8012da80:	00800c04 	movi	r2,48
8012da84:	d8801d05 	stb	r2,116(sp)
8012da88:	d8c01d45 	stb	r3,117(sp)
8012da8c:	d8001d85 	stb	zero,118(sp)
8012da90:	90800094 	ori	r2,r18,2
8012da94:	80008f16 	blt	r16,zero,8012dcd4 <___svfiprintf_internal_r+0x1168>
8012da98:	00bfdfc4 	movi	r2,-129
8012da9c:	90a4703a 	and	r18,r18,r2
8012daa0:	94800094 	ori	r18,r18,2
8012daa4:	0015883a 	mov	r10,zero
8012daa8:	003d2906 	br	8012cf50 <__reset+0xfa10cf50>
8012daac:	98c00007 	ldb	r3,0(r19)
8012dab0:	003c7f06 	br	8012ccb0 <__reset+0xfa10ccb0>
8012dab4:	dac02317 	ldw	r11,140(sp)
8012dab8:	0013883a 	mov	r9,zero
8012dabc:	5f000017 	ldw	fp,0(r11)
8012dac0:	5ac00104 	addi	r11,r11,4
8012dac4:	dac02315 	stw	r11,140(sp)
8012dac8:	003d1506 	br	8012cf20 <__reset+0xfa10cf20>
8012dacc:	9080100c 	andi	r2,r18,64
8012dad0:	d8001d85 	stb	zero,118(sp)
8012dad4:	dac02317 	ldw	r11,140(sp)
8012dad8:	10003426 	beq	r2,zero,8012dbac <___svfiprintf_internal_r+0x1040>
8012dadc:	58800104 	addi	r2,r11,4
8012dae0:	5f00000b 	ldhu	fp,0(r11)
8012dae4:	0013883a 	mov	r9,zero
8012dae8:	803e950e 	bge	r16,zero,8012d540 <__reset+0xfa10d540>
8012daec:	e246b03a 	or	r3,fp,r9
8012daf0:	d8802315 	stw	r2,140(sp)
8012daf4:	183d5a1e 	bne	r3,zero,8012d060 <__reset+0xfa10d060>
8012daf8:	0015883a 	mov	r10,zero
8012dafc:	0005883a 	mov	r2,zero
8012db00:	003fb706 	br	8012d9e0 <__reset+0xfa10d9e0>
8012db04:	98c00043 	ldbu	r3,1(r19)
8012db08:	94800814 	ori	r18,r18,32
8012db0c:	9cc00044 	addi	r19,r19,1
8012db10:	18c03fcc 	andi	r3,r3,255
8012db14:	18c0201c 	xori	r3,r3,128
8012db18:	18ffe004 	addi	r3,r3,-128
8012db1c:	003c6406 	br	8012ccb0 <__reset+0xfa10ccb0>
8012db20:	d8c02315 	stw	r3,140(sp)
8012db24:	0015883a 	mov	r10,zero
8012db28:	003faa06 	br	8012d9d4 <__reset+0xfa10d9d4>
8012db2c:	dac02317 	ldw	r11,140(sp)
8012db30:	58800017 	ldw	r2,0(r11)
8012db34:	5ac00104 	addi	r11,r11,4
8012db38:	dac02315 	stw	r11,140(sp)
8012db3c:	dac02517 	ldw	r11,148(sp)
8012db40:	12c00015 	stw	r11,0(r2)
8012db44:	003c3206 	br	8012cc10 <__reset+0xfa10cc10>
8012db48:	01200534 	movhi	r4,32788
8012db4c:	211ec904 	addi	r4,r4,31524
8012db50:	d9002915 	stw	r4,164(sp)
8012db54:	d8c02315 	stw	r3,140(sp)
8012db58:	1025883a 	mov	r18,r2
8012db5c:	e244b03a 	or	r2,fp,r9
8012db60:	103f871e 	bne	r2,zero,8012d980 <__reset+0xfa10d980>
8012db64:	0015883a 	mov	r10,zero
8012db68:	00800084 	movi	r2,2
8012db6c:	003f9c06 	br	8012d9e0 <__reset+0xfa10d9e0>
8012db70:	0039883a 	mov	fp,zero
8012db74:	003e5f06 	br	8012d4f4 <__reset+0xfa10d4f4>
8012db78:	d9801a04 	addi	r6,sp,104
8012db7c:	b80b883a 	mov	r5,r23
8012db80:	a809883a 	mov	r4,r21
8012db84:	012c9940 	call	8012c994 <__ssprint_r>
8012db88:	103f081e 	bne	r2,zero,8012d7ac <__reset+0xfa10d7ac>
8012db8c:	d8c01c17 	ldw	r3,112(sp)
8012db90:	d8801b17 	ldw	r2,108(sp)
8012db94:	d811883a 	mov	r8,sp
8012db98:	003e9106 	br	8012d5e0 <__reset+0xfa10d5e0>
8012db9c:	01200534 	movhi	r4,32788
8012dba0:	211f4c04 	addi	r4,r4,32048
8012dba4:	d9002215 	stw	r4,136(sp)
8012dba8:	003ead06 	br	8012d660 <__reset+0xfa10d660>
8012dbac:	58800104 	addi	r2,r11,4
8012dbb0:	5f000017 	ldw	fp,0(r11)
8012dbb4:	0013883a 	mov	r9,zero
8012dbb8:	803e610e 	bge	r16,zero,8012d540 <__reset+0xfa10d540>
8012dbbc:	003fcb06 	br	8012daec <__reset+0xfa10daec>
8012dbc0:	58800104 	addi	r2,r11,4
8012dbc4:	5f000017 	ldw	fp,0(r11)
8012dbc8:	0013883a 	mov	r9,zero
8012dbcc:	803e420e 	bge	r16,zero,8012d4d8 <__reset+0xfa10d4d8>
8012dbd0:	003f7e06 	br	8012d9cc <__reset+0xfa10d9cc>
8012dbd4:	5f000017 	ldw	fp,0(r11)
8012dbd8:	5ac00104 	addi	r11,r11,4
8012dbdc:	0013883a 	mov	r9,zero
8012dbe0:	dac02315 	stw	r11,140(sp)
8012dbe4:	003cce06 	br	8012cf20 <__reset+0xfa10cf20>
8012dbe8:	8809883a 	mov	r4,r17
8012dbec:	da002c15 	stw	r8,176(sp)
8012dbf0:	01219540 	call	80121954 <strlen>
8012dbf4:	d8802115 	stw	r2,132(sp)
8012dbf8:	da801d83 	ldbu	r10,118(sp)
8012dbfc:	df002315 	stw	fp,140(sp)
8012dc00:	0021883a 	mov	r16,zero
8012dc04:	da002c17 	ldw	r8,176(sp)
8012dc08:	003cf606 	br	8012cfe4 <__reset+0xfa10cfe4>
8012dc0c:	00800184 	movi	r2,6
8012dc10:	1400012e 	bgeu	r2,r16,8012dc18 <___svfiprintf_internal_r+0x10ac>
8012dc14:	1021883a 	mov	r16,r2
8012dc18:	dc002115 	stw	r16,132(sp)
8012dc1c:	8005883a 	mov	r2,r16
8012dc20:	80003c16 	blt	r16,zero,8012dd14 <___svfiprintf_internal_r+0x11a8>
8012dc24:	04600534 	movhi	r17,32788
8012dc28:	d8802015 	stw	r2,128(sp)
8012dc2c:	df002315 	stw	fp,140(sp)
8012dc30:	8c5ece04 	addi	r17,r17,31544
8012dc34:	003d2e06 	br	8012d0f0 <__reset+0xfa10d0f0>
8012dc38:	04001004 	movi	r16,64
8012dc3c:	800b883a 	mov	r5,r16
8012dc40:	01284880 	call	80128488 <_malloc_r>
8012dc44:	dac02717 	ldw	r11,156(sp)
8012dc48:	58800015 	stw	r2,0(r11)
8012dc4c:	58800415 	stw	r2,16(r11)
8012dc50:	10004826 	beq	r2,zero,8012dd74 <___svfiprintf_internal_r+0x1208>
8012dc54:	dac02717 	ldw	r11,156(sp)
8012dc58:	5c000515 	stw	r16,20(r11)
8012dc5c:	003bd906 	br	8012cbc4 <__reset+0xfa10cbc4>
8012dc60:	9080004c 	andi	r2,r18,1
8012dc64:	0015883a 	mov	r10,zero
8012dc68:	10000626 	beq	r2,zero,8012dc84 <___svfiprintf_internal_r+0x1118>
8012dc6c:	dac02b17 	ldw	r11,172(sp)
8012dc70:	00800c04 	movi	r2,48
8012dc74:	d88019c5 	stb	r2,103(sp)
8012dc78:	dac02115 	stw	r11,132(sp)
8012dc7c:	dc4019c4 	addi	r17,sp,103
8012dc80:	003cd806 	br	8012cfe4 <__reset+0xfa10cfe4>
8012dc84:	d8002115 	stw	zero,132(sp)
8012dc88:	dc401a04 	addi	r17,sp,104
8012dc8c:	003cd506 	br	8012cfe4 <__reset+0xfa10cfe4>
8012dc90:	01200534 	movhi	r4,32788
8012dc94:	211f5004 	addi	r4,r4,32064
8012dc98:	d9002815 	stw	r4,160(sp)
8012dc9c:	003d4306 	br	8012d1ac <__reset+0xfa10d1ac>
8012dca0:	00bfffc4 	movi	r2,-1
8012dca4:	003ec606 	br	8012d7c0 <__reset+0xfa10d7c0>
8012dca8:	00800044 	movi	r2,1
8012dcac:	10803fcc 	andi	r2,r2,255
8012dcb0:	00c00044 	movi	r3,1
8012dcb4:	10fd8026 	beq	r2,r3,8012d2b8 <__reset+0xfa10d2b8>
8012dcb8:	00c00084 	movi	r3,2
8012dcbc:	10fca426 	beq	r2,r3,8012cf50 <__reset+0xfa10cf50>
8012dcc0:	003ce806 	br	8012d064 <__reset+0xfa10d064>
8012dcc4:	01200534 	movhi	r4,32788
8012dcc8:	211f5004 	addi	r4,r4,32064
8012dccc:	d9002815 	stw	r4,160(sp)
8012dcd0:	003e9906 	br	8012d738 <__reset+0xfa10d738>
8012dcd4:	1025883a 	mov	r18,r2
8012dcd8:	0015883a 	mov	r10,zero
8012dcdc:	00800084 	movi	r2,2
8012dce0:	003ff206 	br	8012dcac <__reset+0xfa10dcac>
8012dce4:	01600534 	movhi	r5,32788
8012dce8:	295f4c04 	addi	r5,r5,32048
8012dcec:	d9402215 	stw	r5,136(sp)
8012dcf0:	003ee206 	br	8012d87c <__reset+0xfa10d87c>
8012dcf4:	5827883a 	mov	r19,r11
8012dcf8:	0021883a 	mov	r16,zero
8012dcfc:	003bed06 	br	8012ccb4 <__reset+0xfa10ccb4>
8012dd00:	dc002115 	stw	r16,132(sp)
8012dd04:	da801d83 	ldbu	r10,118(sp)
8012dd08:	df002315 	stw	fp,140(sp)
8012dd0c:	0021883a 	mov	r16,zero
8012dd10:	003cb406 	br	8012cfe4 <__reset+0xfa10cfe4>
8012dd14:	0005883a 	mov	r2,zero
8012dd18:	003fc206 	br	8012dc24 <__reset+0xfa10dc24>
8012dd1c:	d8802317 	ldw	r2,140(sp)
8012dd20:	98c00043 	ldbu	r3,1(r19)
8012dd24:	5827883a 	mov	r19,r11
8012dd28:	14000017 	ldw	r16,0(r2)
8012dd2c:	10800104 	addi	r2,r2,4
8012dd30:	d8802315 	stw	r2,140(sp)
8012dd34:	803f760e 	bge	r16,zero,8012db10 <__reset+0xfa10db10>
8012dd38:	18c03fcc 	andi	r3,r3,255
8012dd3c:	18c0201c 	xori	r3,r3,128
8012dd40:	043fffc4 	movi	r16,-1
8012dd44:	18ffe004 	addi	r3,r3,-128
8012dd48:	003bd906 	br	8012ccb0 <__reset+0xfa10ccb0>
8012dd4c:	d9c01d85 	stb	r7,118(sp)
8012dd50:	003cb606 	br	8012d02c <__reset+0xfa10d02c>
8012dd54:	d9c01d85 	stb	r7,118(sp)
8012dd58:	003d2106 	br	8012d1e0 <__reset+0xfa10d1e0>
8012dd5c:	d9c01d85 	stb	r7,118(sp)
8012dd60:	003d8e06 	br	8012d39c <__reset+0xfa10d39c>
8012dd64:	d9c01d85 	stb	r7,118(sp)
8012dd68:	003db306 	br	8012d438 <__reset+0xfa10d438>
8012dd6c:	d9c01d85 	stb	r7,118(sp)
8012dd70:	003c8a06 	br	8012cf9c <__reset+0xfa10cf9c>
8012dd74:	dac02a17 	ldw	r11,168(sp)
8012dd78:	00800304 	movi	r2,12
8012dd7c:	58800015 	stw	r2,0(r11)
8012dd80:	00bfffc4 	movi	r2,-1
8012dd84:	003e8e06 	br	8012d7c0 <__reset+0xfa10d7c0>
8012dd88:	d9c01d85 	stb	r7,118(sp)
8012dd8c:	003dc706 	br	8012d4ac <__reset+0xfa10d4ac>
8012dd90:	d9c01d85 	stb	r7,118(sp)
8012dd94:	003ddf06 	br	8012d514 <__reset+0xfa10d514>
8012dd98:	d9c01d85 	stb	r7,118(sp)
8012dd9c:	003d3706 	br	8012d27c <__reset+0xfa10d27c>
8012dda0:	d9c01d85 	stb	r7,118(sp)
8012dda4:	003c5406 	br	8012cef8 <__reset+0xfa10cef8>
8012dda8:	d9c01d85 	stb	r7,118(sp)
8012ddac:	003d1d06 	br	8012d224 <__reset+0xfa10d224>

8012ddb0 <__submore>:
8012ddb0:	defffa04 	addi	sp,sp,-24
8012ddb4:	de00012e 	bgeu	sp,et,8012ddbc <__submore+0xc>
8012ddb8:	003b68fa 	trap	3
8012ddbc:	dc000015 	stw	r16,0(sp)
8012ddc0:	2821883a 	mov	r16,r5
8012ddc4:	29400c17 	ldw	r5,48(r5)
8012ddc8:	dfc00515 	stw	ra,20(sp)
8012ddcc:	dd000415 	stw	r20,16(sp)
8012ddd0:	dcc00315 	stw	r19,12(sp)
8012ddd4:	dc800215 	stw	r18,8(sp)
8012ddd8:	dc400115 	stw	r17,4(sp)
8012dddc:	80801004 	addi	r2,r16,64
8012dde0:	28801726 	beq	r5,r2,8012de40 <__submore+0x90>
8012dde4:	84400d17 	ldw	r17,52(r16)
8012dde8:	8c67883a 	add	r19,r17,r17
8012ddec:	980d883a 	mov	r6,r19
8012ddf0:	012a17c0 	call	8012a17c <_realloc_r>
8012ddf4:	1025883a 	mov	r18,r2
8012ddf8:	10002226 	beq	r2,zero,8012de84 <__submore+0xd4>
8012ddfc:	1469883a 	add	r20,r2,r17
8012de00:	880d883a 	mov	r6,r17
8012de04:	100b883a 	mov	r5,r2
8012de08:	a009883a 	mov	r4,r20
8012de0c:	01214640 	call	80121464 <memcpy>
8012de10:	0005883a 	mov	r2,zero
8012de14:	85000015 	stw	r20,0(r16)
8012de18:	84800c15 	stw	r18,48(r16)
8012de1c:	84c00d15 	stw	r19,52(r16)
8012de20:	dfc00517 	ldw	ra,20(sp)
8012de24:	dd000417 	ldw	r20,16(sp)
8012de28:	dcc00317 	ldw	r19,12(sp)
8012de2c:	dc800217 	ldw	r18,8(sp)
8012de30:	dc400117 	ldw	r17,4(sp)
8012de34:	dc000017 	ldw	r16,0(sp)
8012de38:	dec00604 	addi	sp,sp,24
8012de3c:	f800283a 	ret
8012de40:	04410004 	movi	r17,1024
8012de44:	880b883a 	mov	r5,r17
8012de48:	01284880 	call	80128488 <_malloc_r>
8012de4c:	1007883a 	mov	r3,r2
8012de50:	10000c26 	beq	r2,zero,8012de84 <__submore+0xd4>
8012de54:	80801083 	ldbu	r2,66(r16)
8012de58:	80c00c15 	stw	r3,48(r16)
8012de5c:	84400d15 	stw	r17,52(r16)
8012de60:	1880ffc5 	stb	r2,1023(r3)
8012de64:	81401043 	ldbu	r5,65(r16)
8012de68:	1900ff44 	addi	r4,r3,1021
8012de6c:	0005883a 	mov	r2,zero
8012de70:	1940ff85 	stb	r5,1022(r3)
8012de74:	81401003 	ldbu	r5,64(r16)
8012de78:	1940ff45 	stb	r5,1021(r3)
8012de7c:	81000015 	stw	r4,0(r16)
8012de80:	003fe706 	br	8012de20 <__reset+0xfa10de20>
8012de84:	00bfffc4 	movi	r2,-1
8012de88:	003fe506 	br	8012de20 <__reset+0xfa10de20>

8012de8c <_ungetc_r>:
8012de8c:	00bfffc4 	movi	r2,-1
8012de90:	28806326 	beq	r5,r2,8012e020 <_ungetc_r+0x194>
8012de94:	defffb04 	addi	sp,sp,-20
8012de98:	de00012e 	bgeu	sp,et,8012dea0 <_ungetc_r+0x14>
8012de9c:	003b68fa 	trap	3
8012dea0:	dcc00315 	stw	r19,12(sp)
8012dea4:	dc400115 	stw	r17,4(sp)
8012dea8:	dc000015 	stw	r16,0(sp)
8012deac:	dfc00415 	stw	ra,16(sp)
8012deb0:	dc800215 	stw	r18,8(sp)
8012deb4:	2023883a 	mov	r17,r4
8012deb8:	3021883a 	mov	r16,r6
8012debc:	2827883a 	mov	r19,r5
8012dec0:	20000226 	beq	r4,zero,8012decc <_ungetc_r+0x40>
8012dec4:	20800e17 	ldw	r2,56(r4)
8012dec8:	10002e26 	beq	r2,zero,8012df84 <_ungetc_r+0xf8>
8012decc:	80c0030b 	ldhu	r3,12(r16)
8012ded0:	1888000c 	andi	r2,r3,8192
8012ded4:	1000051e 	bne	r2,zero,8012deec <_ungetc_r+0x60>
8012ded8:	81001917 	ldw	r4,100(r16)
8012dedc:	00b7ffc4 	movi	r2,-8193
8012dee0:	18c80014 	ori	r3,r3,8192
8012dee4:	2084703a 	and	r2,r4,r2
8012dee8:	80801915 	stw	r2,100(r16)
8012deec:	00bff7c4 	movi	r2,-33
8012def0:	1884703a 	and	r2,r3,r2
8012def4:	8080030d 	sth	r2,12(r16)
8012def8:	1900010c 	andi	r4,r3,4
8012defc:	2000061e 	bne	r4,zero,8012df18 <_ungetc_r+0x8c>
8012df00:	1900040c 	andi	r4,r3,16
8012df04:	20001d26 	beq	r4,zero,8012df7c <_ungetc_r+0xf0>
8012df08:	18c0020c 	andi	r3,r3,8
8012df0c:	1800331e 	bne	r3,zero,8012dfdc <_ungetc_r+0x150>
8012df10:	10800114 	ori	r2,r2,4
8012df14:	8080030d 	sth	r2,12(r16)
8012df18:	80800c17 	ldw	r2,48(r16)
8012df1c:	9c803fcc 	andi	r18,r19,255
8012df20:	10001a26 	beq	r2,zero,8012df8c <_ungetc_r+0x100>
8012df24:	80c00117 	ldw	r3,4(r16)
8012df28:	80800d17 	ldw	r2,52(r16)
8012df2c:	18800f0e 	bge	r3,r2,8012df6c <_ungetc_r+0xe0>
8012df30:	80c00017 	ldw	r3,0(r16)
8012df34:	9005883a 	mov	r2,r18
8012df38:	193fffc4 	addi	r4,r3,-1
8012df3c:	81000015 	stw	r4,0(r16)
8012df40:	1cffffc5 	stb	r19,-1(r3)
8012df44:	80c00117 	ldw	r3,4(r16)
8012df48:	18c00044 	addi	r3,r3,1
8012df4c:	80c00115 	stw	r3,4(r16)
8012df50:	dfc00417 	ldw	ra,16(sp)
8012df54:	dcc00317 	ldw	r19,12(sp)
8012df58:	dc800217 	ldw	r18,8(sp)
8012df5c:	dc400117 	ldw	r17,4(sp)
8012df60:	dc000017 	ldw	r16,0(sp)
8012df64:	dec00504 	addi	sp,sp,20
8012df68:	f800283a 	ret
8012df6c:	800b883a 	mov	r5,r16
8012df70:	8809883a 	mov	r4,r17
8012df74:	012ddb00 	call	8012ddb0 <__submore>
8012df78:	103fed26 	beq	r2,zero,8012df30 <__reset+0xfa10df30>
8012df7c:	00bfffc4 	movi	r2,-1
8012df80:	003ff306 	br	8012df50 <__reset+0xfa10df50>
8012df84:	01276140 	call	80127614 <__sinit>
8012df88:	003fd006 	br	8012decc <__reset+0xfa10decc>
8012df8c:	80c00417 	ldw	r3,16(r16)
8012df90:	80800017 	ldw	r2,0(r16)
8012df94:	18000326 	beq	r3,zero,8012dfa4 <_ungetc_r+0x118>
8012df98:	1880022e 	bgeu	r3,r2,8012dfa4 <_ungetc_r+0x118>
8012df9c:	10ffffc3 	ldbu	r3,-1(r2)
8012dfa0:	90c01826 	beq	r18,r3,8012e004 <_ungetc_r+0x178>
8012dfa4:	81400117 	ldw	r5,4(r16)
8012dfa8:	80800e15 	stw	r2,56(r16)
8012dfac:	008000c4 	movi	r2,3
8012dfb0:	81001004 	addi	r4,r16,64
8012dfb4:	80c01084 	addi	r3,r16,66
8012dfb8:	80800d15 	stw	r2,52(r16)
8012dfbc:	00800044 	movi	r2,1
8012dfc0:	80800115 	stw	r2,4(r16)
8012dfc4:	81400f15 	stw	r5,60(r16)
8012dfc8:	81000c15 	stw	r4,48(r16)
8012dfcc:	84c01085 	stb	r19,66(r16)
8012dfd0:	80c00015 	stw	r3,0(r16)
8012dfd4:	9005883a 	mov	r2,r18
8012dfd8:	003fdd06 	br	8012df50 <__reset+0xfa10df50>
8012dfdc:	800b883a 	mov	r5,r16
8012dfe0:	8809883a 	mov	r4,r17
8012dfe4:	012e65c0 	call	8012e65c <_fflush_r>
8012dfe8:	103fe41e 	bne	r2,zero,8012df7c <__reset+0xfa10df7c>
8012dfec:	8080030b 	ldhu	r2,12(r16)
8012dff0:	00fffdc4 	movi	r3,-9
8012dff4:	80000215 	stw	zero,8(r16)
8012dff8:	1884703a 	and	r2,r3,r2
8012dffc:	80000615 	stw	zero,24(r16)
8012e000:	003fc306 	br	8012df10 <__reset+0xfa10df10>
8012e004:	80c00117 	ldw	r3,4(r16)
8012e008:	10bfffc4 	addi	r2,r2,-1
8012e00c:	80800015 	stw	r2,0(r16)
8012e010:	18800044 	addi	r2,r3,1
8012e014:	80800115 	stw	r2,4(r16)
8012e018:	9005883a 	mov	r2,r18
8012e01c:	003fcc06 	br	8012df50 <__reset+0xfa10df50>
8012e020:	00bfffc4 	movi	r2,-1
8012e024:	f800283a 	ret

8012e028 <ungetc>:
8012e028:	00a00574 	movhi	r2,32789
8012e02c:	10a88704 	addi	r2,r2,-24036
8012e030:	280d883a 	mov	r6,r5
8012e034:	200b883a 	mov	r5,r4
8012e038:	11000017 	ldw	r4,0(r2)
8012e03c:	012de8c1 	jmpi	8012de8c <_ungetc_r>

8012e040 <_write_r>:
8012e040:	defffd04 	addi	sp,sp,-12
8012e044:	de00012e 	bgeu	sp,et,8012e04c <_write_r+0xc>
8012e048:	003b68fa 	trap	3
8012e04c:	2805883a 	mov	r2,r5
8012e050:	dc000015 	stw	r16,0(sp)
8012e054:	04200574 	movhi	r16,32789
8012e058:	dc400115 	stw	r17,4(sp)
8012e05c:	300b883a 	mov	r5,r6
8012e060:	84290904 	addi	r16,r16,-23516
8012e064:	2023883a 	mov	r17,r4
8012e068:	380d883a 	mov	r6,r7
8012e06c:	1009883a 	mov	r4,r2
8012e070:	dfc00215 	stw	ra,8(sp)
8012e074:	80000015 	stw	zero,0(r16)
8012e078:	01332780 	call	80133278 <write>
8012e07c:	00ffffc4 	movi	r3,-1
8012e080:	10c00526 	beq	r2,r3,8012e098 <_write_r+0x58>
8012e084:	dfc00217 	ldw	ra,8(sp)
8012e088:	dc400117 	ldw	r17,4(sp)
8012e08c:	dc000017 	ldw	r16,0(sp)
8012e090:	dec00304 	addi	sp,sp,12
8012e094:	f800283a 	ret
8012e098:	80c00017 	ldw	r3,0(r16)
8012e09c:	183ff926 	beq	r3,zero,8012e084 <__reset+0xfa10e084>
8012e0a0:	88c00015 	stw	r3,0(r17)
8012e0a4:	003ff706 	br	8012e084 <__reset+0xfa10e084>

8012e0a8 <__swsetup_r>:
8012e0a8:	00a00574 	movhi	r2,32789
8012e0ac:	defffd04 	addi	sp,sp,-12
8012e0b0:	10a88704 	addi	r2,r2,-24036
8012e0b4:	de00012e 	bgeu	sp,et,8012e0bc <__swsetup_r+0x14>
8012e0b8:	003b68fa 	trap	3
8012e0bc:	dc400115 	stw	r17,4(sp)
8012e0c0:	2023883a 	mov	r17,r4
8012e0c4:	11000017 	ldw	r4,0(r2)
8012e0c8:	dc000015 	stw	r16,0(sp)
8012e0cc:	dfc00215 	stw	ra,8(sp)
8012e0d0:	2821883a 	mov	r16,r5
8012e0d4:	20000226 	beq	r4,zero,8012e0e0 <__swsetup_r+0x38>
8012e0d8:	20800e17 	ldw	r2,56(r4)
8012e0dc:	10003126 	beq	r2,zero,8012e1a4 <__swsetup_r+0xfc>
8012e0e0:	8080030b 	ldhu	r2,12(r16)
8012e0e4:	10c0020c 	andi	r3,r2,8
8012e0e8:	1009883a 	mov	r4,r2
8012e0ec:	18000f26 	beq	r3,zero,8012e12c <__swsetup_r+0x84>
8012e0f0:	80c00417 	ldw	r3,16(r16)
8012e0f4:	18001526 	beq	r3,zero,8012e14c <__swsetup_r+0xa4>
8012e0f8:	1100004c 	andi	r4,r2,1
8012e0fc:	20001c1e 	bne	r4,zero,8012e170 <__swsetup_r+0xc8>
8012e100:	1080008c 	andi	r2,r2,2
8012e104:	1000291e 	bne	r2,zero,8012e1ac <__swsetup_r+0x104>
8012e108:	80800517 	ldw	r2,20(r16)
8012e10c:	80800215 	stw	r2,8(r16)
8012e110:	18001c26 	beq	r3,zero,8012e184 <__swsetup_r+0xdc>
8012e114:	0005883a 	mov	r2,zero
8012e118:	dfc00217 	ldw	ra,8(sp)
8012e11c:	dc400117 	ldw	r17,4(sp)
8012e120:	dc000017 	ldw	r16,0(sp)
8012e124:	dec00304 	addi	sp,sp,12
8012e128:	f800283a 	ret
8012e12c:	2080040c 	andi	r2,r4,16
8012e130:	10002e26 	beq	r2,zero,8012e1ec <__swsetup_r+0x144>
8012e134:	2080010c 	andi	r2,r4,4
8012e138:	10001e1e 	bne	r2,zero,8012e1b4 <__swsetup_r+0x10c>
8012e13c:	80c00417 	ldw	r3,16(r16)
8012e140:	20800214 	ori	r2,r4,8
8012e144:	8080030d 	sth	r2,12(r16)
8012e148:	183feb1e 	bne	r3,zero,8012e0f8 <__reset+0xfa10e0f8>
8012e14c:	1100a00c 	andi	r4,r2,640
8012e150:	01408004 	movi	r5,512
8012e154:	217fe826 	beq	r4,r5,8012e0f8 <__reset+0xfa10e0f8>
8012e158:	800b883a 	mov	r5,r16
8012e15c:	8809883a 	mov	r4,r17
8012e160:	012f2f40 	call	8012f2f4 <__smakebuf_r>
8012e164:	8080030b 	ldhu	r2,12(r16)
8012e168:	80c00417 	ldw	r3,16(r16)
8012e16c:	003fe206 	br	8012e0f8 <__reset+0xfa10e0f8>
8012e170:	80800517 	ldw	r2,20(r16)
8012e174:	80000215 	stw	zero,8(r16)
8012e178:	0085c83a 	sub	r2,zero,r2
8012e17c:	80800615 	stw	r2,24(r16)
8012e180:	183fe41e 	bne	r3,zero,8012e114 <__reset+0xfa10e114>
8012e184:	80c0030b 	ldhu	r3,12(r16)
8012e188:	0005883a 	mov	r2,zero
8012e18c:	1900200c 	andi	r4,r3,128
8012e190:	203fe126 	beq	r4,zero,8012e118 <__reset+0xfa10e118>
8012e194:	18c01014 	ori	r3,r3,64
8012e198:	80c0030d 	sth	r3,12(r16)
8012e19c:	00bfffc4 	movi	r2,-1
8012e1a0:	003fdd06 	br	8012e118 <__reset+0xfa10e118>
8012e1a4:	01276140 	call	80127614 <__sinit>
8012e1a8:	003fcd06 	br	8012e0e0 <__reset+0xfa10e0e0>
8012e1ac:	0005883a 	mov	r2,zero
8012e1b0:	003fd606 	br	8012e10c <__reset+0xfa10e10c>
8012e1b4:	81400c17 	ldw	r5,48(r16)
8012e1b8:	28000626 	beq	r5,zero,8012e1d4 <__swsetup_r+0x12c>
8012e1bc:	80801004 	addi	r2,r16,64
8012e1c0:	28800326 	beq	r5,r2,8012e1d0 <__swsetup_r+0x128>
8012e1c4:	8809883a 	mov	r4,r17
8012e1c8:	0127a000 	call	80127a00 <_free_r>
8012e1cc:	8100030b 	ldhu	r4,12(r16)
8012e1d0:	80000c15 	stw	zero,48(r16)
8012e1d4:	80c00417 	ldw	r3,16(r16)
8012e1d8:	00bff6c4 	movi	r2,-37
8012e1dc:	1108703a 	and	r4,r2,r4
8012e1e0:	80000115 	stw	zero,4(r16)
8012e1e4:	80c00015 	stw	r3,0(r16)
8012e1e8:	003fd506 	br	8012e140 <__reset+0xfa10e140>
8012e1ec:	00800244 	movi	r2,9
8012e1f0:	88800015 	stw	r2,0(r17)
8012e1f4:	20801014 	ori	r2,r4,64
8012e1f8:	8080030d 	sth	r2,12(r16)
8012e1fc:	00bfffc4 	movi	r2,-1
8012e200:	003fc506 	br	8012e118 <__reset+0xfa10e118>

8012e204 <_close_r>:
8012e204:	defffd04 	addi	sp,sp,-12
8012e208:	de00012e 	bgeu	sp,et,8012e210 <_close_r+0xc>
8012e20c:	003b68fa 	trap	3
8012e210:	dc000015 	stw	r16,0(sp)
8012e214:	04200574 	movhi	r16,32789
8012e218:	dc400115 	stw	r17,4(sp)
8012e21c:	84290904 	addi	r16,r16,-23516
8012e220:	2023883a 	mov	r17,r4
8012e224:	2809883a 	mov	r4,r5
8012e228:	dfc00215 	stw	ra,8(sp)
8012e22c:	80000015 	stw	zero,0(r16)
8012e230:	0131a640 	call	80131a64 <close>
8012e234:	00ffffc4 	movi	r3,-1
8012e238:	10c00526 	beq	r2,r3,8012e250 <_close_r+0x4c>
8012e23c:	dfc00217 	ldw	ra,8(sp)
8012e240:	dc400117 	ldw	r17,4(sp)
8012e244:	dc000017 	ldw	r16,0(sp)
8012e248:	dec00304 	addi	sp,sp,12
8012e24c:	f800283a 	ret
8012e250:	80c00017 	ldw	r3,0(r16)
8012e254:	183ff926 	beq	r3,zero,8012e23c <__reset+0xfa10e23c>
8012e258:	88c00015 	stw	r3,0(r17)
8012e25c:	003ff706 	br	8012e23c <__reset+0xfa10e23c>

8012e260 <_calloc_r>:
8012e260:	298b383a 	mul	r5,r5,r6
8012e264:	defffe04 	addi	sp,sp,-8
8012e268:	de00012e 	bgeu	sp,et,8012e270 <_calloc_r+0x10>
8012e26c:	003b68fa 	trap	3
8012e270:	dfc00115 	stw	ra,4(sp)
8012e274:	dc000015 	stw	r16,0(sp)
8012e278:	01284880 	call	80128488 <_malloc_r>
8012e27c:	10002926 	beq	r2,zero,8012e324 <_calloc_r+0xc4>
8012e280:	11bfff17 	ldw	r6,-4(r2)
8012e284:	1021883a 	mov	r16,r2
8012e288:	00bfff04 	movi	r2,-4
8012e28c:	308c703a 	and	r6,r6,r2
8012e290:	00c00904 	movi	r3,36
8012e294:	308d883a 	add	r6,r6,r2
8012e298:	19801636 	bltu	r3,r6,8012e2f4 <_calloc_r+0x94>
8012e29c:	008004c4 	movi	r2,19
8012e2a0:	11800b2e 	bgeu	r2,r6,8012e2d0 <_calloc_r+0x70>
8012e2a4:	80000015 	stw	zero,0(r16)
8012e2a8:	80000115 	stw	zero,4(r16)
8012e2ac:	008006c4 	movi	r2,27
8012e2b0:	11801a2e 	bgeu	r2,r6,8012e31c <_calloc_r+0xbc>
8012e2b4:	80000215 	stw	zero,8(r16)
8012e2b8:	80000315 	stw	zero,12(r16)
8012e2bc:	30c0151e 	bne	r6,r3,8012e314 <_calloc_r+0xb4>
8012e2c0:	80000415 	stw	zero,16(r16)
8012e2c4:	80800604 	addi	r2,r16,24
8012e2c8:	80000515 	stw	zero,20(r16)
8012e2cc:	00000106 	br	8012e2d4 <_calloc_r+0x74>
8012e2d0:	8005883a 	mov	r2,r16
8012e2d4:	10000015 	stw	zero,0(r2)
8012e2d8:	10000115 	stw	zero,4(r2)
8012e2dc:	10000215 	stw	zero,8(r2)
8012e2e0:	8005883a 	mov	r2,r16
8012e2e4:	dfc00117 	ldw	ra,4(sp)
8012e2e8:	dc000017 	ldw	r16,0(sp)
8012e2ec:	dec00204 	addi	sp,sp,8
8012e2f0:	f800283a 	ret
8012e2f4:	000b883a 	mov	r5,zero
8012e2f8:	8009883a 	mov	r4,r16
8012e2fc:	01215b40 	call	801215b4 <memset>
8012e300:	8005883a 	mov	r2,r16
8012e304:	dfc00117 	ldw	ra,4(sp)
8012e308:	dc000017 	ldw	r16,0(sp)
8012e30c:	dec00204 	addi	sp,sp,8
8012e310:	f800283a 	ret
8012e314:	80800404 	addi	r2,r16,16
8012e318:	003fee06 	br	8012e2d4 <__reset+0xfa10e2d4>
8012e31c:	80800204 	addi	r2,r16,8
8012e320:	003fec06 	br	8012e2d4 <__reset+0xfa10e2d4>
8012e324:	0005883a 	mov	r2,zero
8012e328:	003fee06 	br	8012e2e4 <__reset+0xfa10e2e4>

8012e32c <_fclose_r>:
8012e32c:	28003b26 	beq	r5,zero,8012e41c <_fclose_r+0xf0>
8012e330:	defffc04 	addi	sp,sp,-16
8012e334:	de00012e 	bgeu	sp,et,8012e33c <_fclose_r+0x10>
8012e338:	003b68fa 	trap	3
8012e33c:	dc400115 	stw	r17,4(sp)
8012e340:	dc000015 	stw	r16,0(sp)
8012e344:	dfc00315 	stw	ra,12(sp)
8012e348:	dc800215 	stw	r18,8(sp)
8012e34c:	2023883a 	mov	r17,r4
8012e350:	2821883a 	mov	r16,r5
8012e354:	20000226 	beq	r4,zero,8012e360 <_fclose_r+0x34>
8012e358:	20800e17 	ldw	r2,56(r4)
8012e35c:	10002726 	beq	r2,zero,8012e3fc <_fclose_r+0xd0>
8012e360:	8080030f 	ldh	r2,12(r16)
8012e364:	1000071e 	bne	r2,zero,8012e384 <_fclose_r+0x58>
8012e368:	0005883a 	mov	r2,zero
8012e36c:	dfc00317 	ldw	ra,12(sp)
8012e370:	dc800217 	ldw	r18,8(sp)
8012e374:	dc400117 	ldw	r17,4(sp)
8012e378:	dc000017 	ldw	r16,0(sp)
8012e37c:	dec00404 	addi	sp,sp,16
8012e380:	f800283a 	ret
8012e384:	800b883a 	mov	r5,r16
8012e388:	8809883a 	mov	r4,r17
8012e38c:	012e4380 	call	8012e438 <__sflush_r>
8012e390:	1025883a 	mov	r18,r2
8012e394:	80800b17 	ldw	r2,44(r16)
8012e398:	10000426 	beq	r2,zero,8012e3ac <_fclose_r+0x80>
8012e39c:	81400717 	ldw	r5,28(r16)
8012e3a0:	8809883a 	mov	r4,r17
8012e3a4:	103ee83a 	callr	r2
8012e3a8:	10001616 	blt	r2,zero,8012e404 <_fclose_r+0xd8>
8012e3ac:	8080030b 	ldhu	r2,12(r16)
8012e3b0:	1080200c 	andi	r2,r2,128
8012e3b4:	1000151e 	bne	r2,zero,8012e40c <_fclose_r+0xe0>
8012e3b8:	81400c17 	ldw	r5,48(r16)
8012e3bc:	28000526 	beq	r5,zero,8012e3d4 <_fclose_r+0xa8>
8012e3c0:	80801004 	addi	r2,r16,64
8012e3c4:	28800226 	beq	r5,r2,8012e3d0 <_fclose_r+0xa4>
8012e3c8:	8809883a 	mov	r4,r17
8012e3cc:	0127a000 	call	80127a00 <_free_r>
8012e3d0:	80000c15 	stw	zero,48(r16)
8012e3d4:	81401117 	ldw	r5,68(r16)
8012e3d8:	28000326 	beq	r5,zero,8012e3e8 <_fclose_r+0xbc>
8012e3dc:	8809883a 	mov	r4,r17
8012e3e0:	0127a000 	call	80127a00 <_free_r>
8012e3e4:	80001115 	stw	zero,68(r16)
8012e3e8:	01276240 	call	80127624 <__sfp_lock_acquire>
8012e3ec:	8000030d 	sth	zero,12(r16)
8012e3f0:	01276280 	call	80127628 <__sfp_lock_release>
8012e3f4:	9005883a 	mov	r2,r18
8012e3f8:	003fdc06 	br	8012e36c <__reset+0xfa10e36c>
8012e3fc:	01276140 	call	80127614 <__sinit>
8012e400:	003fd706 	br	8012e360 <__reset+0xfa10e360>
8012e404:	04bfffc4 	movi	r18,-1
8012e408:	003fe806 	br	8012e3ac <__reset+0xfa10e3ac>
8012e40c:	81400417 	ldw	r5,16(r16)
8012e410:	8809883a 	mov	r4,r17
8012e414:	0127a000 	call	80127a00 <_free_r>
8012e418:	003fe706 	br	8012e3b8 <__reset+0xfa10e3b8>
8012e41c:	0005883a 	mov	r2,zero
8012e420:	f800283a 	ret

8012e424 <fclose>:
8012e424:	00a00574 	movhi	r2,32789
8012e428:	10a88704 	addi	r2,r2,-24036
8012e42c:	200b883a 	mov	r5,r4
8012e430:	11000017 	ldw	r4,0(r2)
8012e434:	012e32c1 	jmpi	8012e32c <_fclose_r>

8012e438 <__sflush_r>:
8012e438:	defffb04 	addi	sp,sp,-20
8012e43c:	de00012e 	bgeu	sp,et,8012e444 <__sflush_r+0xc>
8012e440:	003b68fa 	trap	3
8012e444:	2880030b 	ldhu	r2,12(r5)
8012e448:	dcc00315 	stw	r19,12(sp)
8012e44c:	dc400115 	stw	r17,4(sp)
8012e450:	dfc00415 	stw	ra,16(sp)
8012e454:	dc800215 	stw	r18,8(sp)
8012e458:	dc000015 	stw	r16,0(sp)
8012e45c:	10c0020c 	andi	r3,r2,8
8012e460:	2823883a 	mov	r17,r5
8012e464:	2027883a 	mov	r19,r4
8012e468:	1800311e 	bne	r3,zero,8012e530 <__sflush_r+0xf8>
8012e46c:	28c00117 	ldw	r3,4(r5)
8012e470:	10820014 	ori	r2,r2,2048
8012e474:	2880030d 	sth	r2,12(r5)
8012e478:	00c04b0e 	bge	zero,r3,8012e5a8 <__sflush_r+0x170>
8012e47c:	8a000a17 	ldw	r8,40(r17)
8012e480:	40002326 	beq	r8,zero,8012e510 <__sflush_r+0xd8>
8012e484:	9c000017 	ldw	r16,0(r19)
8012e488:	10c4000c 	andi	r3,r2,4096
8012e48c:	98000015 	stw	zero,0(r19)
8012e490:	18004826 	beq	r3,zero,8012e5b4 <__sflush_r+0x17c>
8012e494:	89801417 	ldw	r6,80(r17)
8012e498:	10c0010c 	andi	r3,r2,4
8012e49c:	18000626 	beq	r3,zero,8012e4b8 <__sflush_r+0x80>
8012e4a0:	88c00117 	ldw	r3,4(r17)
8012e4a4:	88800c17 	ldw	r2,48(r17)
8012e4a8:	30cdc83a 	sub	r6,r6,r3
8012e4ac:	10000226 	beq	r2,zero,8012e4b8 <__sflush_r+0x80>
8012e4b0:	88800f17 	ldw	r2,60(r17)
8012e4b4:	308dc83a 	sub	r6,r6,r2
8012e4b8:	89400717 	ldw	r5,28(r17)
8012e4bc:	000f883a 	mov	r7,zero
8012e4c0:	9809883a 	mov	r4,r19
8012e4c4:	403ee83a 	callr	r8
8012e4c8:	00ffffc4 	movi	r3,-1
8012e4cc:	10c04426 	beq	r2,r3,8012e5e0 <__sflush_r+0x1a8>
8012e4d0:	88c0030b 	ldhu	r3,12(r17)
8012e4d4:	89000417 	ldw	r4,16(r17)
8012e4d8:	88000115 	stw	zero,4(r17)
8012e4dc:	197dffcc 	andi	r5,r3,63487
8012e4e0:	8940030d 	sth	r5,12(r17)
8012e4e4:	89000015 	stw	r4,0(r17)
8012e4e8:	18c4000c 	andi	r3,r3,4096
8012e4ec:	18002c1e 	bne	r3,zero,8012e5a0 <__sflush_r+0x168>
8012e4f0:	89400c17 	ldw	r5,48(r17)
8012e4f4:	9c000015 	stw	r16,0(r19)
8012e4f8:	28000526 	beq	r5,zero,8012e510 <__sflush_r+0xd8>
8012e4fc:	88801004 	addi	r2,r17,64
8012e500:	28800226 	beq	r5,r2,8012e50c <__sflush_r+0xd4>
8012e504:	9809883a 	mov	r4,r19
8012e508:	0127a000 	call	80127a00 <_free_r>
8012e50c:	88000c15 	stw	zero,48(r17)
8012e510:	0005883a 	mov	r2,zero
8012e514:	dfc00417 	ldw	ra,16(sp)
8012e518:	dcc00317 	ldw	r19,12(sp)
8012e51c:	dc800217 	ldw	r18,8(sp)
8012e520:	dc400117 	ldw	r17,4(sp)
8012e524:	dc000017 	ldw	r16,0(sp)
8012e528:	dec00504 	addi	sp,sp,20
8012e52c:	f800283a 	ret
8012e530:	2c800417 	ldw	r18,16(r5)
8012e534:	903ff626 	beq	r18,zero,8012e510 <__reset+0xfa10e510>
8012e538:	2c000017 	ldw	r16,0(r5)
8012e53c:	108000cc 	andi	r2,r2,3
8012e540:	2c800015 	stw	r18,0(r5)
8012e544:	84a1c83a 	sub	r16,r16,r18
8012e548:	1000131e 	bne	r2,zero,8012e598 <__sflush_r+0x160>
8012e54c:	28800517 	ldw	r2,20(r5)
8012e550:	88800215 	stw	r2,8(r17)
8012e554:	04000316 	blt	zero,r16,8012e564 <__sflush_r+0x12c>
8012e558:	003fed06 	br	8012e510 <__reset+0xfa10e510>
8012e55c:	90a5883a 	add	r18,r18,r2
8012e560:	043feb0e 	bge	zero,r16,8012e510 <__reset+0xfa10e510>
8012e564:	88800917 	ldw	r2,36(r17)
8012e568:	89400717 	ldw	r5,28(r17)
8012e56c:	800f883a 	mov	r7,r16
8012e570:	900d883a 	mov	r6,r18
8012e574:	9809883a 	mov	r4,r19
8012e578:	103ee83a 	callr	r2
8012e57c:	80a1c83a 	sub	r16,r16,r2
8012e580:	00bff616 	blt	zero,r2,8012e55c <__reset+0xfa10e55c>
8012e584:	88c0030b 	ldhu	r3,12(r17)
8012e588:	00bfffc4 	movi	r2,-1
8012e58c:	18c01014 	ori	r3,r3,64
8012e590:	88c0030d 	sth	r3,12(r17)
8012e594:	003fdf06 	br	8012e514 <__reset+0xfa10e514>
8012e598:	0005883a 	mov	r2,zero
8012e59c:	003fec06 	br	8012e550 <__reset+0xfa10e550>
8012e5a0:	88801415 	stw	r2,80(r17)
8012e5a4:	003fd206 	br	8012e4f0 <__reset+0xfa10e4f0>
8012e5a8:	28c00f17 	ldw	r3,60(r5)
8012e5ac:	00ffb316 	blt	zero,r3,8012e47c <__reset+0xfa10e47c>
8012e5b0:	003fd706 	br	8012e510 <__reset+0xfa10e510>
8012e5b4:	89400717 	ldw	r5,28(r17)
8012e5b8:	000d883a 	mov	r6,zero
8012e5bc:	01c00044 	movi	r7,1
8012e5c0:	9809883a 	mov	r4,r19
8012e5c4:	403ee83a 	callr	r8
8012e5c8:	100d883a 	mov	r6,r2
8012e5cc:	00bfffc4 	movi	r2,-1
8012e5d0:	30801426 	beq	r6,r2,8012e624 <__sflush_r+0x1ec>
8012e5d4:	8880030b 	ldhu	r2,12(r17)
8012e5d8:	8a000a17 	ldw	r8,40(r17)
8012e5dc:	003fae06 	br	8012e498 <__reset+0xfa10e498>
8012e5e0:	98c00017 	ldw	r3,0(r19)
8012e5e4:	183fba26 	beq	r3,zero,8012e4d0 <__reset+0xfa10e4d0>
8012e5e8:	01000744 	movi	r4,29
8012e5ec:	19000626 	beq	r3,r4,8012e608 <__sflush_r+0x1d0>
8012e5f0:	01000584 	movi	r4,22
8012e5f4:	19000426 	beq	r3,r4,8012e608 <__sflush_r+0x1d0>
8012e5f8:	88c0030b 	ldhu	r3,12(r17)
8012e5fc:	18c01014 	ori	r3,r3,64
8012e600:	88c0030d 	sth	r3,12(r17)
8012e604:	003fc306 	br	8012e514 <__reset+0xfa10e514>
8012e608:	8880030b 	ldhu	r2,12(r17)
8012e60c:	88c00417 	ldw	r3,16(r17)
8012e610:	88000115 	stw	zero,4(r17)
8012e614:	10bdffcc 	andi	r2,r2,63487
8012e618:	8880030d 	sth	r2,12(r17)
8012e61c:	88c00015 	stw	r3,0(r17)
8012e620:	003fb306 	br	8012e4f0 <__reset+0xfa10e4f0>
8012e624:	98800017 	ldw	r2,0(r19)
8012e628:	103fea26 	beq	r2,zero,8012e5d4 <__reset+0xfa10e5d4>
8012e62c:	00c00744 	movi	r3,29
8012e630:	10c00226 	beq	r2,r3,8012e63c <__sflush_r+0x204>
8012e634:	00c00584 	movi	r3,22
8012e638:	10c0031e 	bne	r2,r3,8012e648 <__sflush_r+0x210>
8012e63c:	9c000015 	stw	r16,0(r19)
8012e640:	0005883a 	mov	r2,zero
8012e644:	003fb306 	br	8012e514 <__reset+0xfa10e514>
8012e648:	88c0030b 	ldhu	r3,12(r17)
8012e64c:	3005883a 	mov	r2,r6
8012e650:	18c01014 	ori	r3,r3,64
8012e654:	88c0030d 	sth	r3,12(r17)
8012e658:	003fae06 	br	8012e514 <__reset+0xfa10e514>

8012e65c <_fflush_r>:
8012e65c:	defffd04 	addi	sp,sp,-12
8012e660:	de00012e 	bgeu	sp,et,8012e668 <_fflush_r+0xc>
8012e664:	003b68fa 	trap	3
8012e668:	dc000115 	stw	r16,4(sp)
8012e66c:	dfc00215 	stw	ra,8(sp)
8012e670:	2021883a 	mov	r16,r4
8012e674:	20000226 	beq	r4,zero,8012e680 <_fflush_r+0x24>
8012e678:	20800e17 	ldw	r2,56(r4)
8012e67c:	10000c26 	beq	r2,zero,8012e6b0 <_fflush_r+0x54>
8012e680:	2880030f 	ldh	r2,12(r5)
8012e684:	1000051e 	bne	r2,zero,8012e69c <_fflush_r+0x40>
8012e688:	0005883a 	mov	r2,zero
8012e68c:	dfc00217 	ldw	ra,8(sp)
8012e690:	dc000117 	ldw	r16,4(sp)
8012e694:	dec00304 	addi	sp,sp,12
8012e698:	f800283a 	ret
8012e69c:	8009883a 	mov	r4,r16
8012e6a0:	dfc00217 	ldw	ra,8(sp)
8012e6a4:	dc000117 	ldw	r16,4(sp)
8012e6a8:	dec00304 	addi	sp,sp,12
8012e6ac:	012e4381 	jmpi	8012e438 <__sflush_r>
8012e6b0:	d9400015 	stw	r5,0(sp)
8012e6b4:	01276140 	call	80127614 <__sinit>
8012e6b8:	d9400017 	ldw	r5,0(sp)
8012e6bc:	003ff006 	br	8012e680 <__reset+0xfa10e680>

8012e6c0 <fflush>:
8012e6c0:	20000526 	beq	r4,zero,8012e6d8 <fflush+0x18>
8012e6c4:	00a00574 	movhi	r2,32789
8012e6c8:	10a88704 	addi	r2,r2,-24036
8012e6cc:	200b883a 	mov	r5,r4
8012e6d0:	11000017 	ldw	r4,0(r2)
8012e6d4:	012e65c1 	jmpi	8012e65c <_fflush_r>
8012e6d8:	00a00574 	movhi	r2,32789
8012e6dc:	10a88604 	addi	r2,r2,-24040
8012e6e0:	11000017 	ldw	r4,0(r2)
8012e6e4:	016004f4 	movhi	r5,32787
8012e6e8:	29799704 	addi	r5,r5,-6564
8012e6ec:	01282a81 	jmpi	801282a8 <_fwalk_reent>

8012e6f0 <rshift>:
8012e6f0:	2807d17a 	srai	r3,r5,5
8012e6f4:	20800417 	ldw	r2,16(r4)
8012e6f8:	22000504 	addi	r8,r4,20
8012e6fc:	1880250e 	bge	r3,r2,8012e794 <rshift+0xa4>
8012e700:	1085883a 	add	r2,r2,r2
8012e704:	18c7883a 	add	r3,r3,r3
8012e708:	1085883a 	add	r2,r2,r2
8012e70c:	18c7883a 	add	r3,r3,r3
8012e710:	294007cc 	andi	r5,r5,31
8012e714:	4085883a 	add	r2,r8,r2
8012e718:	40c7883a 	add	r3,r8,r3
8012e71c:	28002026 	beq	r5,zero,8012e7a0 <rshift+0xb0>
8012e720:	19800017 	ldw	r6,0(r3)
8012e724:	02c00804 	movi	r11,32
8012e728:	19c00104 	addi	r7,r3,4
8012e72c:	5957c83a 	sub	r11,r11,r5
8012e730:	314cd83a 	srl	r6,r6,r5
8012e734:	38802c2e 	bgeu	r7,r2,8012e7e8 <rshift+0xf8>
8012e738:	4015883a 	mov	r10,r8
8012e73c:	3a400017 	ldw	r9,0(r7)
8012e740:	52800104 	addi	r10,r10,4
8012e744:	39c00104 	addi	r7,r7,4
8012e748:	4ad2983a 	sll	r9,r9,r11
8012e74c:	498cb03a 	or	r6,r9,r6
8012e750:	51bfff15 	stw	r6,-4(r10)
8012e754:	39bfff17 	ldw	r6,-4(r7)
8012e758:	314cd83a 	srl	r6,r6,r5
8012e75c:	38bff736 	bltu	r7,r2,8012e73c <__reset+0xfa10e73c>
8012e760:	10c7c83a 	sub	r3,r2,r3
8012e764:	18fffec4 	addi	r3,r3,-5
8012e768:	1806d0ba 	srli	r3,r3,2
8012e76c:	18c00044 	addi	r3,r3,1
8012e770:	18c7883a 	add	r3,r3,r3
8012e774:	18c7883a 	add	r3,r3,r3
8012e778:	40c7883a 	add	r3,r8,r3
8012e77c:	19800015 	stw	r6,0(r3)
8012e780:	30000126 	beq	r6,zero,8012e788 <rshift+0x98>
8012e784:	18c00104 	addi	r3,r3,4
8012e788:	1a05c83a 	sub	r2,r3,r8
8012e78c:	1005d0ba 	srai	r2,r2,2
8012e790:	00001206 	br	8012e7dc <rshift+0xec>
8012e794:	20000415 	stw	zero,16(r4)
8012e798:	20000515 	stw	zero,20(r4)
8012e79c:	f800283a 	ret
8012e7a0:	18bffc2e 	bgeu	r3,r2,8012e794 <__reset+0xfa10e794>
8012e7a4:	180d883a 	mov	r6,r3
8012e7a8:	400b883a 	mov	r5,r8
8012e7ac:	31c00017 	ldw	r7,0(r6)
8012e7b0:	29400104 	addi	r5,r5,4
8012e7b4:	31800104 	addi	r6,r6,4
8012e7b8:	29ffff15 	stw	r7,-4(r5)
8012e7bc:	30bffb36 	bltu	r6,r2,8012e7ac <__reset+0xfa10e7ac>
8012e7c0:	00c6303a 	nor	r3,zero,r3
8012e7c4:	1885883a 	add	r2,r3,r2
8012e7c8:	1004d0ba 	srli	r2,r2,2
8012e7cc:	10800044 	addi	r2,r2,1
8012e7d0:	1085883a 	add	r2,r2,r2
8012e7d4:	1085883a 	add	r2,r2,r2
8012e7d8:	1005d0ba 	srai	r2,r2,2
8012e7dc:	20800415 	stw	r2,16(r4)
8012e7e0:	103fed26 	beq	r2,zero,8012e798 <__reset+0xfa10e798>
8012e7e4:	f800283a 	ret
8012e7e8:	4007883a 	mov	r3,r8
8012e7ec:	003fe306 	br	8012e77c <__reset+0xfa10e77c>

8012e7f0 <__gethex>:
8012e7f0:	deffeb04 	addi	sp,sp,-84
8012e7f4:	de00012e 	bgeu	sp,et,8012e7fc <__gethex+0xc>
8012e7f8:	003b68fa 	trap	3
8012e7fc:	dfc01415 	stw	ra,80(sp)
8012e800:	dd801115 	stw	r22,68(sp)
8012e804:	dcc00e15 	stw	r19,56(sp)
8012e808:	dc800d15 	stw	r18,52(sp)
8012e80c:	2827883a 	mov	r19,r5
8012e810:	d9000115 	stw	r4,4(sp)
8012e814:	d9800015 	stw	r6,0(sp)
8012e818:	d9c00415 	stw	r7,16(sp)
8012e81c:	df001315 	stw	fp,76(sp)
8012e820:	ddc01215 	stw	r23,72(sp)
8012e824:	dd401015 	stw	r21,64(sp)
8012e828:	dd000f15 	stw	r20,60(sp)
8012e82c:	dc400c15 	stw	r17,48(sp)
8012e830:	dc000b15 	stw	r16,44(sp)
8012e834:	01284580 	call	80128458 <_localeconv_r>
8012e838:	14800017 	ldw	r18,0(r2)
8012e83c:	9009883a 	mov	r4,r18
8012e840:	01219540 	call	80121954 <strlen>
8012e844:	98c00017 	ldw	r3,0(r19)
8012e848:	102d883a 	mov	r22,r2
8012e84c:	9085883a 	add	r2,r18,r2
8012e850:	10bfffc3 	ldbu	r2,-1(r2)
8012e854:	19000083 	ldbu	r4,2(r3)
8012e858:	d8800305 	stb	r2,12(sp)
8012e85c:	00800c04 	movi	r2,48
8012e860:	2081521e 	bne	r4,r2,8012edac <__gethex+0x5bc>
8012e864:	017fff84 	movi	r5,-2
8012e868:	188000c4 	addi	r2,r3,3
8012e86c:	28cbc83a 	sub	r5,r5,r3
8012e870:	200d883a 	mov	r6,r4
8012e874:	28a3883a 	add	r17,r5,r2
8012e878:	102b883a 	mov	r21,r2
8012e87c:	10800044 	addi	r2,r2,1
8012e880:	113fffc3 	ldbu	r4,-1(r2)
8012e884:	21bffb26 	beq	r4,r6,8012e874 <__reset+0xfa10e874>
8012e888:	05200534 	movhi	r20,32788
8012e88c:	a51f5404 	addi	r20,r20,32080
8012e890:	a109883a 	add	r4,r20,r4
8012e894:	20800003 	ldbu	r2,0(r4)
8012e898:	10008826 	beq	r2,zero,8012eabc <__gethex+0x2cc>
8012e89c:	a8800003 	ldbu	r2,0(r21)
8012e8a0:	0015883a 	mov	r10,zero
8012e8a4:	002f883a 	mov	r23,zero
8012e8a8:	a085883a 	add	r2,r20,r2
8012e8ac:	10800003 	ldbu	r2,0(r2)
8012e8b0:	a821883a 	mov	r16,r21
8012e8b4:	10000526 	beq	r2,zero,8012e8cc <__gethex+0xdc>
8012e8b8:	84000044 	addi	r16,r16,1
8012e8bc:	80800003 	ldbu	r2,0(r16)
8012e8c0:	a085883a 	add	r2,r20,r2
8012e8c4:	10800003 	ldbu	r2,0(r2)
8012e8c8:	103ffb1e 	bne	r2,zero,8012e8b8 <__reset+0xfa10e8b8>
8012e8cc:	b00d883a 	mov	r6,r22
8012e8d0:	900b883a 	mov	r5,r18
8012e8d4:	8009883a 	mov	r4,r16
8012e8d8:	da800a15 	stw	r10,40(sp)
8012e8dc:	012f5200 	call	8012f520 <strncmp>
8012e8e0:	da800a17 	ldw	r10,40(sp)
8012e8e4:	1000031e 	bne	r2,zero,8012e8f4 <__gethex+0x104>
8012e8e8:	b8015226 	beq	r23,zero,8012ee34 <__gethex+0x644>
8012e8ec:	80800003 	ldbu	r2,0(r16)
8012e8f0:	00000206 	br	8012e8fc <__gethex+0x10c>
8012e8f4:	80800003 	ldbu	r2,0(r16)
8012e8f8:	b8011f26 	beq	r23,zero,8012ed78 <__gethex+0x588>
8012e8fc:	85efc83a 	sub	r23,r16,r23
8012e900:	bdef883a 	add	r23,r23,r23
8012e904:	bdef883a 	add	r23,r23,r23
8012e908:	05efc83a 	sub	r23,zero,r23
8012e90c:	10803fcc 	andi	r2,r2,255
8012e910:	01001404 	movi	r4,80
8012e914:	11008626 	beq	r2,r4,8012eb30 <__gethex+0x340>
8012e918:	01001c04 	movi	r4,112
8012e91c:	11008426 	beq	r2,r4,8012eb30 <__gethex+0x340>
8012e920:	8039883a 	mov	fp,r16
8012e924:	9c000015 	stw	r16,0(r19)
8012e928:	5000711e 	bne	r10,zero,8012eaf0 <__gethex+0x300>
8012e92c:	e545c83a 	sub	r2,fp,r21
8012e930:	10bfffc4 	addi	r2,r2,-1
8012e934:	010001c4 	movi	r4,7
8012e938:	000b883a 	mov	r5,zero
8012e93c:	2080030e 	bge	r4,r2,8012e94c <__gethex+0x15c>
8012e940:	1005d07a 	srai	r2,r2,1
8012e944:	29400044 	addi	r5,r5,1
8012e948:	20bffd16 	blt	r4,r2,8012e940 <__reset+0xfa10e940>
8012e94c:	d9000117 	ldw	r4,4(sp)
8012e950:	01291200 	call	80129120 <_Balloc>
8012e954:	10c00504 	addi	r3,r2,20
8012e958:	d8c00215 	stw	r3,8(sp)
8012e95c:	1021883a 	mov	r16,r2
8012e960:	af01732e 	bgeu	r21,fp,8012ef30 <__gethex+0x740>
8012e964:	dc400303 	ldbu	r17,12(sp)
8012e968:	03400044 	movi	r13,1
8012e96c:	1815883a 	mov	r10,r3
8012e970:	0013883a 	mov	r9,zero
8012e974:	0027883a 	mov	r19,zero
8012e978:	6d9bc83a 	sub	r13,r13,r22
8012e97c:	02c00804 	movi	r11,32
8012e980:	e0bfffc3 	ldbu	r2,-1(fp)
8012e984:	e3bfffc4 	addi	r14,fp,-1
8012e988:	88803026 	beq	r17,r2,8012ea4c <__gethex+0x25c>
8012e98c:	9ac04526 	beq	r19,r11,8012eaa4 <__gethex+0x2b4>
8012e990:	980b883a 	mov	r5,r19
8012e994:	9cc00104 	addi	r19,r19,4
8012e998:	e13fffc3 	ldbu	r4,-1(fp)
8012e99c:	7039883a 	mov	fp,r14
8012e9a0:	a109883a 	add	r4,r20,r4
8012e9a4:	20800003 	ldbu	r2,0(r4)
8012e9a8:	108003cc 	andi	r2,r2,15
8012e9ac:	1144983a 	sll	r2,r2,r5
8012e9b0:	4892b03a 	or	r9,r9,r2
8012e9b4:	af3ff236 	bltu	r21,fp,8012e980 <__reset+0xfa10e980>
8012e9b8:	d8c00217 	ldw	r3,8(sp)
8012e9bc:	50800104 	addi	r2,r10,4
8012e9c0:	52400015 	stw	r9,0(r10)
8012e9c4:	10c5c83a 	sub	r2,r2,r3
8012e9c8:	1005d0ba 	srai	r2,r2,2
8012e9cc:	4809883a 	mov	r4,r9
8012e9d0:	80800415 	stw	r2,16(r16)
8012e9d4:	1022917a 	slli	r17,r2,5
8012e9d8:	012942c0 	call	8012942c <__hi0bits>
8012e9dc:	d8c00017 	ldw	r3,0(sp)
8012e9e0:	8885c83a 	sub	r2,r17,r2
8012e9e4:	1c800017 	ldw	r18,0(r3)
8012e9e8:	9080c716 	blt	r18,r2,8012ed08 <__gethex+0x518>
8012e9ec:	1480e416 	blt	r2,r18,8012ed80 <__gethex+0x590>
8012e9f0:	0027883a 	mov	r19,zero
8012e9f4:	d8c00017 	ldw	r3,0(sp)
8012e9f8:	18800217 	ldw	r2,8(r3)
8012e9fc:	15c08d16 	blt	r2,r23,8012ec34 <__gethex+0x444>
8012ea00:	d8c00017 	ldw	r3,0(sp)
8012ea04:	18800117 	ldw	r2,4(r3)
8012ea08:	b880aa0e 	bge	r23,r2,8012ecb4 <__gethex+0x4c4>
8012ea0c:	15efc83a 	sub	r23,r2,r23
8012ea10:	bc80ed16 	blt	r23,r18,8012edc8 <__gethex+0x5d8>
8012ea14:	18c00317 	ldw	r3,12(r3)
8012ea18:	01000084 	movi	r4,2
8012ea1c:	19014926 	beq	r3,r4,8012ef44 <__gethex+0x754>
8012ea20:	010000c4 	movi	r4,3
8012ea24:	19012e26 	beq	r3,r4,8012eee0 <__gethex+0x6f0>
8012ea28:	01000044 	movi	r4,1
8012ea2c:	19014826 	beq	r3,r4,8012ef50 <__gethex+0x760>
8012ea30:	d9000117 	ldw	r4,4(sp)
8012ea34:	800b883a 	mov	r5,r16
8012ea38:	01291d00 	call	801291d0 <_Bfree>
8012ea3c:	d8801517 	ldw	r2,84(sp)
8012ea40:	10000015 	stw	zero,0(r2)
8012ea44:	00801404 	movi	r2,80
8012ea48:	00002b06 	br	8012eaf8 <__gethex+0x308>
8012ea4c:	735f883a 	add	r15,r14,r13
8012ea50:	7d7fce36 	bltu	r15,r21,8012e98c <__reset+0xfa10e98c>
8012ea54:	7809883a 	mov	r4,r15
8012ea58:	b00d883a 	mov	r6,r22
8012ea5c:	900b883a 	mov	r5,r18
8012ea60:	da400515 	stw	r9,20(sp)
8012ea64:	da800a15 	stw	r10,40(sp)
8012ea68:	dac00915 	stw	r11,36(sp)
8012ea6c:	db400815 	stw	r13,32(sp)
8012ea70:	db800615 	stw	r14,24(sp)
8012ea74:	dbc00715 	stw	r15,28(sp)
8012ea78:	012f5200 	call	8012f520 <strncmp>
8012ea7c:	da400517 	ldw	r9,20(sp)
8012ea80:	da800a17 	ldw	r10,40(sp)
8012ea84:	dac00917 	ldw	r11,36(sp)
8012ea88:	db400817 	ldw	r13,32(sp)
8012ea8c:	db800617 	ldw	r14,24(sp)
8012ea90:	dbc00717 	ldw	r15,28(sp)
8012ea94:	103fbd1e 	bne	r2,zero,8012e98c <__reset+0xfa10e98c>
8012ea98:	7839883a 	mov	fp,r15
8012ea9c:	af3fb836 	bltu	r21,fp,8012e980 <__reset+0xfa10e980>
8012eaa0:	003fc506 	br	8012e9b8 <__reset+0xfa10e9b8>
8012eaa4:	04c00104 	movi	r19,4
8012eaa8:	52400015 	stw	r9,0(r10)
8012eaac:	000b883a 	mov	r5,zero
8012eab0:	54d5883a 	add	r10,r10,r19
8012eab4:	0013883a 	mov	r9,zero
8012eab8:	003fb706 	br	8012e998 <__reset+0xfa10e998>
8012eabc:	b00d883a 	mov	r6,r22
8012eac0:	900b883a 	mov	r5,r18
8012eac4:	a809883a 	mov	r4,r21
8012eac8:	012f5200 	call	8012f520 <strncmp>
8012eacc:	10006426 	beq	r2,zero,8012ec60 <__gethex+0x470>
8012ead0:	a8800003 	ldbu	r2,0(r21)
8012ead4:	a821883a 	mov	r16,r21
8012ead8:	10803fcc 	andi	r2,r2,255
8012eadc:	01001404 	movi	r4,80
8012eae0:	11001126 	beq	r2,r4,8012eb28 <__gethex+0x338>
8012eae4:	01001c04 	movi	r4,112
8012eae8:	11000f26 	beq	r2,r4,8012eb28 <__gethex+0x338>
8012eaec:	9c000015 	stw	r16,0(r19)
8012eaf0:	8800831e 	bne	r17,zero,8012ed00 <__gethex+0x510>
8012eaf4:	00800184 	movi	r2,6
8012eaf8:	dfc01417 	ldw	ra,80(sp)
8012eafc:	df001317 	ldw	fp,76(sp)
8012eb00:	ddc01217 	ldw	r23,72(sp)
8012eb04:	dd801117 	ldw	r22,68(sp)
8012eb08:	dd401017 	ldw	r21,64(sp)
8012eb0c:	dd000f17 	ldw	r20,60(sp)
8012eb10:	dcc00e17 	ldw	r19,56(sp)
8012eb14:	dc800d17 	ldw	r18,52(sp)
8012eb18:	dc400c17 	ldw	r17,48(sp)
8012eb1c:	dc000b17 	ldw	r16,44(sp)
8012eb20:	dec01504 	addi	sp,sp,84
8012eb24:	f800283a 	ret
8012eb28:	002f883a 	mov	r23,zero
8012eb2c:	02800044 	movi	r10,1
8012eb30:	80800043 	ldbu	r2,1(r16)
8012eb34:	01400ac4 	movi	r5,43
8012eb38:	11003fcc 	andi	r4,r2,255
8012eb3c:	21406e26 	beq	r4,r5,8012ecf8 <__gethex+0x508>
8012eb40:	01400b44 	movi	r5,45
8012eb44:	21404226 	beq	r4,r5,8012ec50 <__gethex+0x460>
8012eb48:	81400044 	addi	r5,r16,1
8012eb4c:	000d883a 	mov	r6,zero
8012eb50:	10803fcc 	andi	r2,r2,255
8012eb54:	a085883a 	add	r2,r20,r2
8012eb58:	11000003 	ldbu	r4,0(r2)
8012eb5c:	03000604 	movi	r12,24
8012eb60:	20bfffc4 	addi	r2,r4,-1
8012eb64:	10803fcc 	andi	r2,r2,255
8012eb68:	60bf6d36 	bltu	r12,r2,8012e920 <__reset+0xfa10e920>
8012eb6c:	2ac00043 	ldbu	r11,1(r5)
8012eb70:	20803fcc 	andi	r2,r4,255
8012eb74:	01200534 	movhi	r4,32788
8012eb78:	211f5404 	addi	r4,r4,32080
8012eb7c:	22c9883a 	add	r4,r4,r11
8012eb80:	23400003 	ldbu	r13,0(r4)
8012eb84:	10bffc04 	addi	r2,r2,-16
8012eb88:	29400044 	addi	r5,r5,1
8012eb8c:	693fffc4 	addi	r4,r13,-1
8012eb90:	21003fcc 	andi	r4,r4,255
8012eb94:	6b403fcc 	andi	r13,r13,255
8012eb98:	61000b36 	bltu	r12,r4,8012ebc8 <__gethex+0x3d8>
8012eb9c:	29400044 	addi	r5,r5,1
8012eba0:	29000003 	ldbu	r4,0(r5)
8012eba4:	108002a4 	muli	r2,r2,10
8012eba8:	a109883a 	add	r4,r20,r4
8012ebac:	22c00003 	ldbu	r11,0(r4)
8012ebb0:	1345883a 	add	r2,r2,r13
8012ebb4:	10bffc04 	addi	r2,r2,-16
8012ebb8:	593fffc4 	addi	r4,r11,-1
8012ebbc:	21003fcc 	andi	r4,r4,255
8012ebc0:	5b403fcc 	andi	r13,r11,255
8012ebc4:	613ff52e 	bgeu	r12,r4,8012eb9c <__reset+0xfa10eb9c>
8012ebc8:	30000126 	beq	r6,zero,8012ebd0 <__gethex+0x3e0>
8012ebcc:	0085c83a 	sub	r2,zero,r2
8012ebd0:	8039883a 	mov	fp,r16
8012ebd4:	b8af883a 	add	r23,r23,r2
8012ebd8:	2821883a 	mov	r16,r5
8012ebdc:	003f5106 	br	8012e924 <__reset+0xfa10e924>
8012ebe0:	80800217 	ldw	r2,8(r16)
8012ebe4:	e080f00e 	bge	fp,r2,8012efa8 <__gethex+0x7b8>
8012ebe8:	e007883a 	mov	r3,fp
8012ebec:	18800144 	addi	r2,r3,5
8012ebf0:	1085883a 	add	r2,r2,r2
8012ebf4:	18c00044 	addi	r3,r3,1
8012ebf8:	1085883a 	add	r2,r2,r2
8012ebfc:	8085883a 	add	r2,r16,r2
8012ec00:	80c00415 	stw	r3,16(r16)
8012ec04:	01000044 	movi	r4,1
8012ec08:	11000015 	stw	r4,0(r2)
8012ec0c:	00800084 	movi	r2,2
8012ec10:	8880d826 	beq	r17,r2,8012ef74 <__gethex+0x784>
8012ec14:	e0c0ac0e 	bge	fp,r3,8012eec8 <__gethex+0x6d8>
8012ec18:	01400044 	movi	r5,1
8012ec1c:	8009883a 	mov	r4,r16
8012ec20:	012e6f00 	call	8012e6f0 <rshift>
8012ec24:	d8c00017 	ldw	r3,0(sp)
8012ec28:	bdc00044 	addi	r23,r23,1
8012ec2c:	18800217 	ldw	r2,8(r3)
8012ec30:	15c0a70e 	bge	r2,r23,8012eed0 <__gethex+0x6e0>
8012ec34:	d9000117 	ldw	r4,4(sp)
8012ec38:	800b883a 	mov	r5,r16
8012ec3c:	01291d00 	call	801291d0 <_Bfree>
8012ec40:	d9001517 	ldw	r4,84(sp)
8012ec44:	008028c4 	movi	r2,163
8012ec48:	20000015 	stw	zero,0(r4)
8012ec4c:	003faa06 	br	8012eaf8 <__reset+0xfa10eaf8>
8012ec50:	01800044 	movi	r6,1
8012ec54:	80800083 	ldbu	r2,2(r16)
8012ec58:	81400084 	addi	r5,r16,2
8012ec5c:	003fbc06 	br	8012eb50 <__reset+0xfa10eb50>
8012ec60:	ada1883a 	add	r16,r21,r22
8012ec64:	81000003 	ldbu	r4,0(r16)
8012ec68:	21403fcc 	andi	r5,r4,255
8012ec6c:	a145883a 	add	r2,r20,r5
8012ec70:	10800003 	ldbu	r2,0(r2)
8012ec74:	11803fcc 	andi	r6,r2,255
8012ec78:	30004f26 	beq	r6,zero,8012edb8 <__gethex+0x5c8>
8012ec7c:	00c00c04 	movi	r3,48
8012ec80:	802b883a 	mov	r21,r16
8012ec84:	28c0061e 	bne	r5,r3,8012eca0 <__gethex+0x4b0>
8012ec88:	2809883a 	mov	r4,r5
8012ec8c:	ad400044 	addi	r21,r21,1
8012ec90:	a8800003 	ldbu	r2,0(r21)
8012ec94:	113ffd26 	beq	r2,r4,8012ec8c <__reset+0xfa10ec8c>
8012ec98:	a085883a 	add	r2,r20,r2
8012ec9c:	10800003 	ldbu	r2,0(r2)
8012eca0:	10803fcc 	andi	r2,r2,255
8012eca4:	1015003a 	cmpeq	r10,r2,zero
8012eca8:	802f883a 	mov	r23,r16
8012ecac:	04400044 	movi	r17,1
8012ecb0:	003eff06 	br	8012e8b0 <__reset+0xfa10e8b0>
8012ecb4:	04400044 	movi	r17,1
8012ecb8:	98000926 	beq	r19,zero,8012ece0 <__gethex+0x4f0>
8012ecbc:	d8c00017 	ldw	r3,0(sp)
8012ecc0:	18800317 	ldw	r2,12(r3)
8012ecc4:	00c00084 	movi	r3,2
8012ecc8:	10c06826 	beq	r2,r3,8012ee6c <__gethex+0x67c>
8012eccc:	00c000c4 	movi	r3,3
8012ecd0:	10c06a26 	beq	r2,r3,8012ee7c <__gethex+0x68c>
8012ecd4:	00c00044 	movi	r3,1
8012ecd8:	10c08d26 	beq	r2,r3,8012ef10 <__gethex+0x720>
8012ecdc:	8c400414 	ori	r17,r17,16
8012ece0:	d9001517 	ldw	r4,84(sp)
8012ece4:	d8c00417 	ldw	r3,16(sp)
8012ece8:	8805883a 	mov	r2,r17
8012ecec:	24000015 	stw	r16,0(r4)
8012ecf0:	1dc00015 	stw	r23,0(r3)
8012ecf4:	003f8006 	br	8012eaf8 <__reset+0xfa10eaf8>
8012ecf8:	000d883a 	mov	r6,zero
8012ecfc:	003fd506 	br	8012ec54 <__reset+0xfa10ec54>
8012ed00:	0005883a 	mov	r2,zero
8012ed04:	003f7c06 	br	8012eaf8 <__reset+0xfa10eaf8>
8012ed08:	14a3c83a 	sub	r17,r2,r18
8012ed0c:	880b883a 	mov	r5,r17
8012ed10:	8009883a 	mov	r4,r16
8012ed14:	012a0f00 	call	8012a0f0 <__any_on>
8012ed18:	10002926 	beq	r2,zero,8012edc0 <__gethex+0x5d0>
8012ed1c:	897fffc4 	addi	r5,r17,-1
8012ed20:	2807d17a 	srai	r3,r5,5
8012ed24:	d8800217 	ldw	r2,8(sp)
8012ed28:	290007cc 	andi	r4,r5,31
8012ed2c:	18c7883a 	add	r3,r3,r3
8012ed30:	18c7883a 	add	r3,r3,r3
8012ed34:	04c00044 	movi	r19,1
8012ed38:	10c7883a 	add	r3,r2,r3
8012ed3c:	9908983a 	sll	r4,r19,r4
8012ed40:	18c00017 	ldw	r3,0(r3)
8012ed44:	20c6703a 	and	r3,r4,r3
8012ed48:	18000626 	beq	r3,zero,8012ed64 <__gethex+0x574>
8012ed4c:	99407b0e 	bge	r19,r5,8012ef3c <__gethex+0x74c>
8012ed50:	897fff84 	addi	r5,r17,-2
8012ed54:	8009883a 	mov	r4,r16
8012ed58:	012a0f00 	call	8012a0f0 <__any_on>
8012ed5c:	10007726 	beq	r2,zero,8012ef3c <__gethex+0x74c>
8012ed60:	04c000c4 	movi	r19,3
8012ed64:	880b883a 	mov	r5,r17
8012ed68:	8009883a 	mov	r4,r16
8012ed6c:	012e6f00 	call	8012e6f0 <rshift>
8012ed70:	bc6f883a 	add	r23,r23,r17
8012ed74:	003f1f06 	br	8012e9f4 <__reset+0xfa10e9f4>
8012ed78:	002f883a 	mov	r23,zero
8012ed7c:	003ee306 	br	8012e90c <__reset+0xfa10e90c>
8012ed80:	d9000117 	ldw	r4,4(sp)
8012ed84:	90a3c83a 	sub	r17,r18,r2
8012ed88:	800b883a 	mov	r5,r16
8012ed8c:	880d883a 	mov	r6,r17
8012ed90:	01298d00 	call	801298d0 <__lshift>
8012ed94:	10c00504 	addi	r3,r2,20
8012ed98:	1021883a 	mov	r16,r2
8012ed9c:	bc6fc83a 	sub	r23,r23,r17
8012eda0:	d8c00215 	stw	r3,8(sp)
8012eda4:	0027883a 	mov	r19,zero
8012eda8:	003f1206 	br	8012e9f4 <__reset+0xfa10e9f4>
8012edac:	1d400084 	addi	r21,r3,2
8012edb0:	0023883a 	mov	r17,zero
8012edb4:	003eb406 	br	8012e888 <__reset+0xfa10e888>
8012edb8:	2005883a 	mov	r2,r4
8012edbc:	003f4606 	br	8012ead8 <__reset+0xfa10ead8>
8012edc0:	0027883a 	mov	r19,zero
8012edc4:	003fe706 	br	8012ed64 <__reset+0xfa10ed64>
8012edc8:	bc7fffc4 	addi	r17,r23,-1
8012edcc:	9800421e 	bne	r19,zero,8012eed8 <__gethex+0x6e8>
8012edd0:	88000426 	beq	r17,zero,8012ede4 <__gethex+0x5f4>
8012edd4:	880b883a 	mov	r5,r17
8012edd8:	8009883a 	mov	r4,r16
8012eddc:	012a0f00 	call	8012a0f0 <__any_on>
8012ede0:	1027883a 	mov	r19,r2
8012ede4:	8805d17a 	srai	r2,r17,5
8012ede8:	d8c00217 	ldw	r3,8(sp)
8012edec:	8c4007cc 	andi	r17,r17,31
8012edf0:	1085883a 	add	r2,r2,r2
8012edf4:	1085883a 	add	r2,r2,r2
8012edf8:	1885883a 	add	r2,r3,r2
8012edfc:	00c00044 	movi	r3,1
8012ee00:	1c62983a 	sll	r17,r3,r17
8012ee04:	10800017 	ldw	r2,0(r2)
8012ee08:	8884703a 	and	r2,r17,r2
8012ee0c:	10000126 	beq	r2,zero,8012ee14 <__gethex+0x624>
8012ee10:	9cc00094 	ori	r19,r19,2
8012ee14:	b80b883a 	mov	r5,r23
8012ee18:	8009883a 	mov	r4,r16
8012ee1c:	012e6f00 	call	8012e6f0 <rshift>
8012ee20:	d8c00017 	ldw	r3,0(sp)
8012ee24:	95e5c83a 	sub	r18,r18,r23
8012ee28:	04400084 	movi	r17,2
8012ee2c:	1dc00117 	ldw	r23,4(r3)
8012ee30:	003fa106 	br	8012ecb8 <__reset+0xfa10ecb8>
8012ee34:	85af883a 	add	r23,r16,r22
8012ee38:	b8800003 	ldbu	r2,0(r23)
8012ee3c:	b821883a 	mov	r16,r23
8012ee40:	11003fcc 	andi	r4,r2,255
8012ee44:	a109883a 	add	r4,r20,r4
8012ee48:	21000003 	ldbu	r4,0(r4)
8012ee4c:	203eaa26 	beq	r4,zero,8012e8f8 <__reset+0xfa10e8f8>
8012ee50:	84000044 	addi	r16,r16,1
8012ee54:	80800003 	ldbu	r2,0(r16)
8012ee58:	11003fcc 	andi	r4,r2,255
8012ee5c:	a109883a 	add	r4,r20,r4
8012ee60:	21000003 	ldbu	r4,0(r4)
8012ee64:	203ffa1e 	bne	r4,zero,8012ee50 <__reset+0xfa10ee50>
8012ee68:	003ea306 	br	8012e8f8 <__reset+0xfa10e8f8>
8012ee6c:	d9001617 	ldw	r4,88(sp)
8012ee70:	00800044 	movi	r2,1
8012ee74:	1109c83a 	sub	r4,r2,r4
8012ee78:	d9001615 	stw	r4,88(sp)
8012ee7c:	d8801617 	ldw	r2,88(sp)
8012ee80:	103f9626 	beq	r2,zero,8012ecdc <__reset+0xfa10ecdc>
8012ee84:	87000417 	ldw	fp,16(r16)
8012ee88:	d9800217 	ldw	r6,8(sp)
8012ee8c:	013fffc4 	movi	r4,-1
8012ee90:	e727883a 	add	r19,fp,fp
8012ee94:	9ce7883a 	add	r19,r19,r19
8012ee98:	3005883a 	mov	r2,r6
8012ee9c:	34cb883a 	add	r5,r6,r19
8012eea0:	00000306 	br	8012eeb0 <__gethex+0x6c0>
8012eea4:	10000015 	stw	zero,0(r2)
8012eea8:	10800104 	addi	r2,r2,4
8012eeac:	117f4c2e 	bgeu	r2,r5,8012ebe0 <__reset+0xfa10ebe0>
8012eeb0:	10c00017 	ldw	r3,0(r2)
8012eeb4:	193ffb26 	beq	r3,r4,8012eea4 <__reset+0xfa10eea4>
8012eeb8:	18c00044 	addi	r3,r3,1
8012eebc:	10c00015 	stw	r3,0(r2)
8012eec0:	00800084 	movi	r2,2
8012eec4:	88802b26 	beq	r17,r2,8012ef74 <__gethex+0x784>
8012eec8:	948007cc 	andi	r18,r18,31
8012eecc:	90002f1e 	bne	r18,zero,8012ef8c <__gethex+0x79c>
8012eed0:	04400844 	movi	r17,33
8012eed4:	003f8206 	br	8012ece0 <__reset+0xfa10ece0>
8012eed8:	04c00044 	movi	r19,1
8012eedc:	003fc106 	br	8012ede4 <__reset+0xfa10ede4>
8012eee0:	d8c01617 	ldw	r3,88(sp)
8012eee4:	183ed226 	beq	r3,zero,8012ea30 <__reset+0xfa10ea30>
8012eee8:	d8c00417 	ldw	r3,16(sp)
8012eeec:	d9001517 	ldw	r4,84(sp)
8012eef0:	18800015 	stw	r2,0(r3)
8012eef4:	d8c00217 	ldw	r3,8(sp)
8012eef8:	00800044 	movi	r2,1
8012eefc:	80800415 	stw	r2,16(r16)
8012ef00:	18800015 	stw	r2,0(r3)
8012ef04:	24000015 	stw	r16,0(r4)
8012ef08:	00801884 	movi	r2,98
8012ef0c:	003efa06 	br	8012eaf8 <__reset+0xfa10eaf8>
8012ef10:	9880008c 	andi	r2,r19,2
8012ef14:	103f7126 	beq	r2,zero,8012ecdc <__reset+0xfa10ecdc>
8012ef18:	d8c00217 	ldw	r3,8(sp)
8012ef1c:	18800017 	ldw	r2,0(r3)
8012ef20:	9884b03a 	or	r2,r19,r2
8012ef24:	1080004c 	andi	r2,r2,1
8012ef28:	103fd61e 	bne	r2,zero,8012ee84 <__reset+0xfa10ee84>
8012ef2c:	003f6b06 	br	8012ecdc <__reset+0xfa10ecdc>
8012ef30:	da800217 	ldw	r10,8(sp)
8012ef34:	0013883a 	mov	r9,zero
8012ef38:	003e9f06 	br	8012e9b8 <__reset+0xfa10e9b8>
8012ef3c:	04c00084 	movi	r19,2
8012ef40:	003f8806 	br	8012ed64 <__reset+0xfa10ed64>
8012ef44:	d9001617 	ldw	r4,88(sp)
8012ef48:	203fe726 	beq	r4,zero,8012eee8 <__reset+0xfa10eee8>
8012ef4c:	003eb806 	br	8012ea30 <__reset+0xfa10ea30>
8012ef50:	95feb71e 	bne	r18,r23,8012ea30 <__reset+0xfa10ea30>
8012ef54:	1cbfe40e 	bge	r3,r18,8012eee8 <__reset+0xfa10eee8>
8012ef58:	917fffc4 	addi	r5,r18,-1
8012ef5c:	8009883a 	mov	r4,r16
8012ef60:	012a0f00 	call	8012a0f0 <__any_on>
8012ef64:	103eb226 	beq	r2,zero,8012ea30 <__reset+0xfa10ea30>
8012ef68:	d8c00017 	ldw	r3,0(sp)
8012ef6c:	18800117 	ldw	r2,4(r3)
8012ef70:	003fdd06 	br	8012eee8 <__reset+0xfa10eee8>
8012ef74:	d8c00017 	ldw	r3,0(sp)
8012ef78:	18800017 	ldw	r2,0(r3)
8012ef7c:	10bfffc4 	addi	r2,r2,-1
8012ef80:	90801c26 	beq	r18,r2,8012eff4 <__gethex+0x804>
8012ef84:	04400884 	movi	r17,34
8012ef88:	003f5506 	br	8012ece0 <__reset+0xfa10ece0>
8012ef8c:	34c5883a 	add	r2,r6,r19
8012ef90:	113fff17 	ldw	r4,-4(r2)
8012ef94:	012942c0 	call	8012942c <__hi0bits>
8012ef98:	00c00804 	movi	r3,32
8012ef9c:	1ca5c83a 	sub	r18,r3,r18
8012efa0:	14bfcb0e 	bge	r2,r18,8012eed0 <__reset+0xfa10eed0>
8012efa4:	003f1c06 	br	8012ec18 <__reset+0xfa10ec18>
8012efa8:	81400117 	ldw	r5,4(r16)
8012efac:	d9000117 	ldw	r4,4(sp)
8012efb0:	29400044 	addi	r5,r5,1
8012efb4:	01291200 	call	80129120 <_Balloc>
8012efb8:	81800417 	ldw	r6,16(r16)
8012efbc:	81400304 	addi	r5,r16,12
8012efc0:	11000304 	addi	r4,r2,12
8012efc4:	31800084 	addi	r6,r6,2
8012efc8:	318d883a 	add	r6,r6,r6
8012efcc:	318d883a 	add	r6,r6,r6
8012efd0:	1029883a 	mov	r20,r2
8012efd4:	01214640 	call	80121464 <memcpy>
8012efd8:	d9000117 	ldw	r4,4(sp)
8012efdc:	800b883a 	mov	r5,r16
8012efe0:	a021883a 	mov	r16,r20
8012efe4:	01291d00 	call	801291d0 <_Bfree>
8012efe8:	a0c00417 	ldw	r3,16(r20)
8012efec:	a1800504 	addi	r6,r20,20
8012eff0:	003efe06 	br	8012ebec <__reset+0xfa10ebec>
8012eff4:	9005d17a 	srai	r2,r18,5
8012eff8:	944007cc 	andi	r17,r18,31
8012effc:	1085883a 	add	r2,r2,r2
8012f000:	1085883a 	add	r2,r2,r2
8012f004:	3087883a 	add	r3,r6,r2
8012f008:	00800044 	movi	r2,1
8012f00c:	1462983a 	sll	r17,r2,r17
8012f010:	18800017 	ldw	r2,0(r3)
8012f014:	8884703a 	and	r2,r17,r2
8012f018:	1022c03a 	cmpne	r17,r2,zero
8012f01c:	00800884 	movi	r2,34
8012f020:	1463c83a 	sub	r17,r2,r17
8012f024:	003f2e06 	br	8012ece0 <__reset+0xfa10ece0>

8012f028 <__hexnan>:
8012f028:	defff904 	addi	sp,sp,-28
8012f02c:	de00012e 	bgeu	sp,et,8012f034 <__hexnan+0xc>
8012f030:	003b68fa 	trap	3
8012f034:	dc800215 	stw	r18,8(sp)
8012f038:	2c800017 	ldw	r18,0(r5)
8012f03c:	dfc00615 	stw	ra,24(sp)
8012f040:	dd400515 	stw	r21,20(sp)
8012f044:	901fd17a 	srai	r15,r18,5
8012f048:	dd000415 	stw	r20,16(sp)
8012f04c:	dcc00315 	stw	r19,12(sp)
8012f050:	7bdf883a 	add	r15,r15,r15
8012f054:	7bdf883a 	add	r15,r15,r15
8012f058:	dc400115 	stw	r17,4(sp)
8012f05c:	dc000015 	stw	r16,0(sp)
8012f060:	948007cc 	andi	r18,r18,31
8012f064:	33df883a 	add	r15,r6,r15
8012f068:	90000126 	beq	r18,zero,8012f070 <__hexnan+0x48>
8012f06c:	7bc00104 	addi	r15,r15,4
8012f070:	22000017 	ldw	r8,0(r4)
8012f074:	7affff04 	addi	r11,r15,-4
8012f078:	03a00534 	movhi	r14,32788
8012f07c:	783fff15 	stw	zero,-4(r15)
8012f080:	581b883a 	mov	r13,r11
8012f084:	580b883a 	mov	r5,r11
8012f088:	000f883a 	mov	r7,zero
8012f08c:	003f883a 	mov	ra,zero
8012f090:	0019883a 	mov	r12,zero
8012f094:	739f5404 	addi	r14,r14,32080
8012f098:	04400204 	movi	r17,8
8012f09c:	04000804 	movi	r16,32
8012f0a0:	04c001c4 	movi	r19,7
8012f0a4:	42000044 	addi	r8,r8,1
8012f0a8:	40c00003 	ldbu	r3,0(r8)
8012f0ac:	18001d26 	beq	r3,zero,8012f124 <__hexnan+0xfc>
8012f0b0:	70c5883a 	add	r2,r14,r3
8012f0b4:	10800003 	ldbu	r2,0(r2)
8012f0b8:	12403fcc 	andi	r9,r2,255
8012f0bc:	4800301e 	bne	r9,zero,8012f180 <__hexnan+0x158>
8012f0c0:	80c04236 	bltu	r16,r3,8012f1cc <__hexnan+0x1a4>
8012f0c4:	fb3ff70e 	bge	ra,r12,8012f0a4 <__reset+0xfa10f0a4>
8012f0c8:	2b40112e 	bgeu	r5,r13,8012f110 <__hexnan+0xe8>
8012f0cc:	99c01016 	blt	r19,r7,8012f110 <__hexnan+0xe8>
8012f0d0:	89e9c83a 	sub	r20,r17,r7
8012f0d4:	a529883a 	add	r20,r20,r20
8012f0d8:	2a800017 	ldw	r10,0(r5)
8012f0dc:	a529883a 	add	r20,r20,r20
8012f0e0:	852bc83a 	sub	r21,r16,r20
8012f0e4:	28c00104 	addi	r3,r5,4
8012f0e8:	2805883a 	mov	r2,r5
8012f0ec:	19c00017 	ldw	r7,0(r3)
8012f0f0:	10800104 	addi	r2,r2,4
8012f0f4:	18c00104 	addi	r3,r3,4
8012f0f8:	3d52983a 	sll	r9,r7,r21
8012f0fc:	4a92b03a 	or	r9,r9,r10
8012f100:	3d14d83a 	srl	r10,r7,r20
8012f104:	127fff15 	stw	r9,-4(r2)
8012f108:	1abfff15 	stw	r10,-4(r3)
8012f10c:	137ff736 	bltu	r2,r13,8012f0ec <__reset+0xfa10f0ec>
8012f110:	31402836 	bltu	r6,r5,8012f1b4 <__hexnan+0x18c>
8012f114:	42000044 	addi	r8,r8,1
8012f118:	40c00003 	ldbu	r3,0(r8)
8012f11c:	01c00204 	movi	r7,8
8012f120:	183fe31e 	bne	r3,zero,8012f0b0 <__reset+0xfa10f0b0>
8012f124:	60002b26 	beq	r12,zero,8012f1d4 <__hexnan+0x1ac>
8012f128:	2b40022e 	bgeu	r5,r13,8012f134 <__hexnan+0x10c>
8012f12c:	008001c4 	movi	r2,7
8012f130:	11c0430e 	bge	r2,r7,8012f240 <__hexnan+0x218>
8012f134:	3140312e 	bgeu	r6,r5,8012f1fc <__hexnan+0x1d4>
8012f138:	3007883a 	mov	r3,r6
8012f13c:	29000017 	ldw	r4,0(r5)
8012f140:	18800104 	addi	r2,r3,4
8012f144:	29400104 	addi	r5,r5,4
8012f148:	19000015 	stw	r4,0(r3)
8012f14c:	1007883a 	mov	r3,r2
8012f150:	597ffa2e 	bgeu	r11,r5,8012f13c <__reset+0xfa10f13c>
8012f154:	10000015 	stw	zero,0(r2)
8012f158:	10800104 	addi	r2,r2,4
8012f15c:	58bffd2e 	bgeu	r11,r2,8012f154 <__reset+0xfa10f154>
8012f160:	78bfff17 	ldw	r2,-4(r15)
8012f164:	1000041e 	bne	r2,zero,8012f178 <__hexnan+0x150>
8012f168:	32c02d26 	beq	r6,r11,8012f220 <__hexnan+0x1f8>
8012f16c:	5affff04 	addi	r11,r11,-4
8012f170:	58800017 	ldw	r2,0(r11)
8012f174:	103ffc26 	beq	r2,zero,8012f168 <__reset+0xfa10f168>
8012f178:	00800144 	movi	r2,5
8012f17c:	00001606 	br	8012f1d8 <__hexnan+0x1b0>
8012f180:	39c00044 	addi	r7,r7,1
8012f184:	63000044 	addi	r12,r12,1
8012f188:	89c0040e 	bge	r17,r7,8012f19c <__hexnan+0x174>
8012f18c:	317fc52e 	bgeu	r6,r5,8012f0a4 <__reset+0xfa10f0a4>
8012f190:	283fff15 	stw	zero,-4(r5)
8012f194:	01c00044 	movi	r7,1
8012f198:	297fff04 	addi	r5,r5,-4
8012f19c:	28c00017 	ldw	r3,0(r5)
8012f1a0:	108003cc 	andi	r2,r2,15
8012f1a4:	1806913a 	slli	r3,r3,4
8012f1a8:	1884b03a 	or	r2,r3,r2
8012f1ac:	28800015 	stw	r2,0(r5)
8012f1b0:	003fbc06 	br	8012f0a4 <__reset+0xfa10f0a4>
8012f1b4:	2b7fff04 	addi	r13,r5,-4
8012f1b8:	283fff15 	stw	zero,-4(r5)
8012f1bc:	603f883a 	mov	ra,r12
8012f1c0:	680b883a 	mov	r5,r13
8012f1c4:	000f883a 	mov	r7,zero
8012f1c8:	003fb606 	br	8012f0a4 <__reset+0xfa10f0a4>
8012f1cc:	00800a44 	movi	r2,41
8012f1d0:	18801726 	beq	r3,r2,8012f230 <__hexnan+0x208>
8012f1d4:	00800104 	movi	r2,4
8012f1d8:	dfc00617 	ldw	ra,24(sp)
8012f1dc:	dd400517 	ldw	r21,20(sp)
8012f1e0:	dd000417 	ldw	r20,16(sp)
8012f1e4:	dcc00317 	ldw	r19,12(sp)
8012f1e8:	dc800217 	ldw	r18,8(sp)
8012f1ec:	dc400117 	ldw	r17,4(sp)
8012f1f0:	dc000017 	ldw	r16,0(sp)
8012f1f4:	dec00704 	addi	sp,sp,28
8012f1f8:	f800283a 	ret
8012f1fc:	903fd826 	beq	r18,zero,8012f160 <__reset+0xfa10f160>
8012f200:	00c00804 	movi	r3,32
8012f204:	1ca5c83a 	sub	r18,r3,r18
8012f208:	00ffffc4 	movi	r3,-1
8012f20c:	78bfff17 	ldw	r2,-4(r15)
8012f210:	1c86d83a 	srl	r3,r3,r18
8012f214:	1884703a 	and	r2,r3,r2
8012f218:	78bfff15 	stw	r2,-4(r15)
8012f21c:	003fd106 	br	8012f164 <__reset+0xfa10f164>
8012f220:	00800044 	movi	r2,1
8012f224:	58800015 	stw	r2,0(r11)
8012f228:	00800144 	movi	r2,5
8012f22c:	003fea06 	br	8012f1d8 <__reset+0xfa10f1d8>
8012f230:	42000044 	addi	r8,r8,1
8012f234:	22000015 	stw	r8,0(r4)
8012f238:	603fbb1e 	bne	r12,zero,8012f128 <__reset+0xfa10f128>
8012f23c:	003fe506 	br	8012f1d4 <__reset+0xfa10f1d4>
8012f240:	02400204 	movi	r9,8
8012f244:	49d3c83a 	sub	r9,r9,r7
8012f248:	4a53883a 	add	r9,r9,r9
8012f24c:	2a000017 	ldw	r8,0(r5)
8012f250:	4a53883a 	add	r9,r9,r9
8012f254:	02800804 	movi	r10,32
8012f258:	5255c83a 	sub	r10,r10,r9
8012f25c:	28c00104 	addi	r3,r5,4
8012f260:	2805883a 	mov	r2,r5
8012f264:	19c00017 	ldw	r7,0(r3)
8012f268:	10800104 	addi	r2,r2,4
8012f26c:	18c00104 	addi	r3,r3,4
8012f270:	3a88983a 	sll	r4,r7,r10
8012f274:	2208b03a 	or	r4,r4,r8
8012f278:	3a50d83a 	srl	r8,r7,r9
8012f27c:	113fff15 	stw	r4,-4(r2)
8012f280:	1a3fff15 	stw	r8,-4(r3)
8012f284:	137ff736 	bltu	r2,r13,8012f264 <__reset+0xfa10f264>
8012f288:	003faa06 	br	8012f134 <__reset+0xfa10f134>

8012f28c <_lseek_r>:
8012f28c:	defffd04 	addi	sp,sp,-12
8012f290:	de00012e 	bgeu	sp,et,8012f298 <_lseek_r+0xc>
8012f294:	003b68fa 	trap	3
8012f298:	2805883a 	mov	r2,r5
8012f29c:	dc000015 	stw	r16,0(sp)
8012f2a0:	04200574 	movhi	r16,32789
8012f2a4:	dc400115 	stw	r17,4(sp)
8012f2a8:	300b883a 	mov	r5,r6
8012f2ac:	84290904 	addi	r16,r16,-23516
8012f2b0:	2023883a 	mov	r17,r4
8012f2b4:	380d883a 	mov	r6,r7
8012f2b8:	1009883a 	mov	r4,r2
8012f2bc:	dfc00215 	stw	ra,8(sp)
8012f2c0:	80000015 	stw	zero,0(r16)
8012f2c4:	0132a5c0 	call	80132a5c <lseek>
8012f2c8:	00ffffc4 	movi	r3,-1
8012f2cc:	10c00526 	beq	r2,r3,8012f2e4 <_lseek_r+0x58>
8012f2d0:	dfc00217 	ldw	ra,8(sp)
8012f2d4:	dc400117 	ldw	r17,4(sp)
8012f2d8:	dc000017 	ldw	r16,0(sp)
8012f2dc:	dec00304 	addi	sp,sp,12
8012f2e0:	f800283a 	ret
8012f2e4:	80c00017 	ldw	r3,0(r16)
8012f2e8:	183ff926 	beq	r3,zero,8012f2d0 <__reset+0xfa10f2d0>
8012f2ec:	88c00015 	stw	r3,0(r17)
8012f2f0:	003ff706 	br	8012f2d0 <__reset+0xfa10f2d0>

8012f2f4 <__smakebuf_r>:
8012f2f4:	2880030b 	ldhu	r2,12(r5)
8012f2f8:	10c0008c 	andi	r3,r2,2
8012f2fc:	1800431e 	bne	r3,zero,8012f40c <__smakebuf_r+0x118>
8012f300:	deffec04 	addi	sp,sp,-80
8012f304:	de00012e 	bgeu	sp,et,8012f30c <__smakebuf_r+0x18>
8012f308:	003b68fa 	trap	3
8012f30c:	dc000f15 	stw	r16,60(sp)
8012f310:	2821883a 	mov	r16,r5
8012f314:	2940038f 	ldh	r5,14(r5)
8012f318:	dc401015 	stw	r17,64(sp)
8012f31c:	dfc01315 	stw	ra,76(sp)
8012f320:	dcc01215 	stw	r19,72(sp)
8012f324:	dc801115 	stw	r18,68(sp)
8012f328:	2023883a 	mov	r17,r4
8012f32c:	28001c16 	blt	r5,zero,8012f3a0 <__smakebuf_r+0xac>
8012f330:	d80d883a 	mov	r6,sp
8012f334:	012f5f00 	call	8012f5f0 <_fstat_r>
8012f338:	10001816 	blt	r2,zero,8012f39c <__smakebuf_r+0xa8>
8012f33c:	d8800117 	ldw	r2,4(sp)
8012f340:	00e00014 	movui	r3,32768
8012f344:	10bc000c 	andi	r2,r2,61440
8012f348:	14c80020 	cmpeqi	r19,r2,8192
8012f34c:	10c03726 	beq	r2,r3,8012f42c <__smakebuf_r+0x138>
8012f350:	80c0030b 	ldhu	r3,12(r16)
8012f354:	18c20014 	ori	r3,r3,2048
8012f358:	80c0030d 	sth	r3,12(r16)
8012f35c:	00c80004 	movi	r3,8192
8012f360:	10c0521e 	bne	r2,r3,8012f4ac <__smakebuf_r+0x1b8>
8012f364:	8140038f 	ldh	r5,14(r16)
8012f368:	8809883a 	mov	r4,r17
8012f36c:	012f6540 	call	8012f654 <_isatty_r>
8012f370:	10004c26 	beq	r2,zero,8012f4a4 <__smakebuf_r+0x1b0>
8012f374:	8080030b 	ldhu	r2,12(r16)
8012f378:	80c010c4 	addi	r3,r16,67
8012f37c:	80c00015 	stw	r3,0(r16)
8012f380:	10800054 	ori	r2,r2,1
8012f384:	8080030d 	sth	r2,12(r16)
8012f388:	00800044 	movi	r2,1
8012f38c:	80c00415 	stw	r3,16(r16)
8012f390:	80800515 	stw	r2,20(r16)
8012f394:	04810004 	movi	r18,1024
8012f398:	00000706 	br	8012f3b8 <__smakebuf_r+0xc4>
8012f39c:	8080030b 	ldhu	r2,12(r16)
8012f3a0:	10c0200c 	andi	r3,r2,128
8012f3a4:	18001f1e 	bne	r3,zero,8012f424 <__smakebuf_r+0x130>
8012f3a8:	04810004 	movi	r18,1024
8012f3ac:	10820014 	ori	r2,r2,2048
8012f3b0:	8080030d 	sth	r2,12(r16)
8012f3b4:	0027883a 	mov	r19,zero
8012f3b8:	900b883a 	mov	r5,r18
8012f3bc:	8809883a 	mov	r4,r17
8012f3c0:	01284880 	call	80128488 <_malloc_r>
8012f3c4:	10002c26 	beq	r2,zero,8012f478 <__smakebuf_r+0x184>
8012f3c8:	80c0030b 	ldhu	r3,12(r16)
8012f3cc:	012004b4 	movhi	r4,32786
8012f3d0:	211cad04 	addi	r4,r4,29364
8012f3d4:	89000f15 	stw	r4,60(r17)
8012f3d8:	18c02014 	ori	r3,r3,128
8012f3dc:	80c0030d 	sth	r3,12(r16)
8012f3e0:	80800015 	stw	r2,0(r16)
8012f3e4:	80800415 	stw	r2,16(r16)
8012f3e8:	84800515 	stw	r18,20(r16)
8012f3ec:	98001a1e 	bne	r19,zero,8012f458 <__smakebuf_r+0x164>
8012f3f0:	dfc01317 	ldw	ra,76(sp)
8012f3f4:	dcc01217 	ldw	r19,72(sp)
8012f3f8:	dc801117 	ldw	r18,68(sp)
8012f3fc:	dc401017 	ldw	r17,64(sp)
8012f400:	dc000f17 	ldw	r16,60(sp)
8012f404:	dec01404 	addi	sp,sp,80
8012f408:	f800283a 	ret
8012f40c:	288010c4 	addi	r2,r5,67
8012f410:	28800015 	stw	r2,0(r5)
8012f414:	28800415 	stw	r2,16(r5)
8012f418:	00800044 	movi	r2,1
8012f41c:	28800515 	stw	r2,20(r5)
8012f420:	f800283a 	ret
8012f424:	04801004 	movi	r18,64
8012f428:	003fe006 	br	8012f3ac <__reset+0xfa10f3ac>
8012f42c:	81000a17 	ldw	r4,40(r16)
8012f430:	00e004f4 	movhi	r3,32787
8012f434:	18eadc04 	addi	r3,r3,-21648
8012f438:	20ffc51e 	bne	r4,r3,8012f350 <__reset+0xfa10f350>
8012f43c:	8080030b 	ldhu	r2,12(r16)
8012f440:	04810004 	movi	r18,1024
8012f444:	84801315 	stw	r18,76(r16)
8012f448:	1484b03a 	or	r2,r2,r18
8012f44c:	8080030d 	sth	r2,12(r16)
8012f450:	0027883a 	mov	r19,zero
8012f454:	003fd806 	br	8012f3b8 <__reset+0xfa10f3b8>
8012f458:	8140038f 	ldh	r5,14(r16)
8012f45c:	8809883a 	mov	r4,r17
8012f460:	012f6540 	call	8012f654 <_isatty_r>
8012f464:	103fe226 	beq	r2,zero,8012f3f0 <__reset+0xfa10f3f0>
8012f468:	8080030b 	ldhu	r2,12(r16)
8012f46c:	10800054 	ori	r2,r2,1
8012f470:	8080030d 	sth	r2,12(r16)
8012f474:	003fde06 	br	8012f3f0 <__reset+0xfa10f3f0>
8012f478:	8080030b 	ldhu	r2,12(r16)
8012f47c:	10c0800c 	andi	r3,r2,512
8012f480:	183fdb1e 	bne	r3,zero,8012f3f0 <__reset+0xfa10f3f0>
8012f484:	10800094 	ori	r2,r2,2
8012f488:	80c010c4 	addi	r3,r16,67
8012f48c:	8080030d 	sth	r2,12(r16)
8012f490:	00800044 	movi	r2,1
8012f494:	80c00015 	stw	r3,0(r16)
8012f498:	80c00415 	stw	r3,16(r16)
8012f49c:	80800515 	stw	r2,20(r16)
8012f4a0:	003fd306 	br	8012f3f0 <__reset+0xfa10f3f0>
8012f4a4:	04810004 	movi	r18,1024
8012f4a8:	003fc306 	br	8012f3b8 <__reset+0xfa10f3b8>
8012f4ac:	0027883a 	mov	r19,zero
8012f4b0:	04810004 	movi	r18,1024
8012f4b4:	003fc006 	br	8012f3b8 <__reset+0xfa10f3b8>

8012f4b8 <_read_r>:
8012f4b8:	defffd04 	addi	sp,sp,-12
8012f4bc:	de00012e 	bgeu	sp,et,8012f4c4 <_read_r+0xc>
8012f4c0:	003b68fa 	trap	3
8012f4c4:	2805883a 	mov	r2,r5
8012f4c8:	dc000015 	stw	r16,0(sp)
8012f4cc:	04200574 	movhi	r16,32789
8012f4d0:	dc400115 	stw	r17,4(sp)
8012f4d4:	300b883a 	mov	r5,r6
8012f4d8:	84290904 	addi	r16,r16,-23516
8012f4dc:	2023883a 	mov	r17,r4
8012f4e0:	380d883a 	mov	r6,r7
8012f4e4:	1009883a 	mov	r4,r2
8012f4e8:	dfc00215 	stw	ra,8(sp)
8012f4ec:	80000015 	stw	zero,0(r16)
8012f4f0:	0132cd80 	call	80132cd8 <read>
8012f4f4:	00ffffc4 	movi	r3,-1
8012f4f8:	10c00526 	beq	r2,r3,8012f510 <_read_r+0x58>
8012f4fc:	dfc00217 	ldw	ra,8(sp)
8012f500:	dc400117 	ldw	r17,4(sp)
8012f504:	dc000017 	ldw	r16,0(sp)
8012f508:	dec00304 	addi	sp,sp,12
8012f50c:	f800283a 	ret
8012f510:	80c00017 	ldw	r3,0(r16)
8012f514:	183ff926 	beq	r3,zero,8012f4fc <__reset+0xfa10f4fc>
8012f518:	88c00015 	stw	r3,0(r17)
8012f51c:	003ff706 	br	8012f4fc <__reset+0xfa10f4fc>

8012f520 <strncmp>:
8012f520:	30003126 	beq	r6,zero,8012f5e8 <strncmp+0xc8>
8012f524:	2144b03a 	or	r2,r4,r5
8012f528:	108000cc 	andi	r2,r2,3
8012f52c:	10001e1e 	bne	r2,zero,8012f5a8 <strncmp+0x88>
8012f530:	024000c4 	movi	r9,3
8012f534:	49801c2e 	bgeu	r9,r6,8012f5a8 <strncmp+0x88>
8012f538:	20800017 	ldw	r2,0(r4)
8012f53c:	28c00017 	ldw	r3,0(r5)
8012f540:	10c0191e 	bne	r2,r3,8012f5a8 <strncmp+0x88>
8012f544:	31bfff04 	addi	r6,r6,-4
8012f548:	30002726 	beq	r6,zero,8012f5e8 <strncmp+0xc8>
8012f54c:	02ffbff4 	movhi	r11,65279
8012f550:	5affbfc4 	addi	r11,r11,-257
8012f554:	0086303a 	nor	r3,zero,r2
8012f558:	02a02074 	movhi	r10,32897
8012f55c:	12c5883a 	add	r2,r2,r11
8012f560:	52a02004 	addi	r10,r10,-32640
8012f564:	10c4703a 	and	r2,r2,r3
8012f568:	1284703a 	and	r2,r2,r10
8012f56c:	10000b26 	beq	r2,zero,8012f59c <strncmp+0x7c>
8012f570:	00001d06 	br	8012f5e8 <strncmp+0xc8>
8012f574:	20c00017 	ldw	r3,0(r4)
8012f578:	29c00017 	ldw	r7,0(r5)
8012f57c:	1ad1883a 	add	r8,r3,r11
8012f580:	00c4303a 	nor	r2,zero,r3
8012f584:	4084703a 	and	r2,r8,r2
8012f588:	1284703a 	and	r2,r2,r10
8012f58c:	19c0061e 	bne	r3,r7,8012f5a8 <strncmp+0x88>
8012f590:	31bfff04 	addi	r6,r6,-4
8012f594:	30001426 	beq	r6,zero,8012f5e8 <strncmp+0xc8>
8012f598:	1000131e 	bne	r2,zero,8012f5e8 <strncmp+0xc8>
8012f59c:	21000104 	addi	r4,r4,4
8012f5a0:	29400104 	addi	r5,r5,4
8012f5a4:	49bff336 	bltu	r9,r6,8012f574 <__reset+0xfa10f574>
8012f5a8:	28800007 	ldb	r2,0(r5)
8012f5ac:	20c00007 	ldb	r3,0(r4)
8012f5b0:	31bfffc4 	addi	r6,r6,-1
8012f5b4:	10c0081e 	bne	r2,r3,8012f5d8 <strncmp+0xb8>
8012f5b8:	30000b26 	beq	r6,zero,8012f5e8 <strncmp+0xc8>
8012f5bc:	10000a26 	beq	r2,zero,8012f5e8 <strncmp+0xc8>
8012f5c0:	21000044 	addi	r4,r4,1
8012f5c4:	29400044 	addi	r5,r5,1
8012f5c8:	20800007 	ldb	r2,0(r4)
8012f5cc:	28c00007 	ldb	r3,0(r5)
8012f5d0:	31bfffc4 	addi	r6,r6,-1
8012f5d4:	10fff826 	beq	r2,r3,8012f5b8 <__reset+0xfa10f5b8>
8012f5d8:	20800003 	ldbu	r2,0(r4)
8012f5dc:	28c00003 	ldbu	r3,0(r5)
8012f5e0:	10c5c83a 	sub	r2,r2,r3
8012f5e4:	f800283a 	ret
8012f5e8:	0005883a 	mov	r2,zero
8012f5ec:	f800283a 	ret

8012f5f0 <_fstat_r>:
8012f5f0:	defffd04 	addi	sp,sp,-12
8012f5f4:	de00012e 	bgeu	sp,et,8012f5fc <_fstat_r+0xc>
8012f5f8:	003b68fa 	trap	3
8012f5fc:	2805883a 	mov	r2,r5
8012f600:	dc000015 	stw	r16,0(sp)
8012f604:	04200574 	movhi	r16,32789
8012f608:	dc400115 	stw	r17,4(sp)
8012f60c:	84290904 	addi	r16,r16,-23516
8012f610:	2023883a 	mov	r17,r4
8012f614:	300b883a 	mov	r5,r6
8012f618:	1009883a 	mov	r4,r2
8012f61c:	dfc00215 	stw	ra,8(sp)
8012f620:	80000015 	stw	zero,0(r16)
8012f624:	0131bdc0 	call	80131bdc <fstat>
8012f628:	00ffffc4 	movi	r3,-1
8012f62c:	10c00526 	beq	r2,r3,8012f644 <_fstat_r+0x54>
8012f630:	dfc00217 	ldw	ra,8(sp)
8012f634:	dc400117 	ldw	r17,4(sp)
8012f638:	dc000017 	ldw	r16,0(sp)
8012f63c:	dec00304 	addi	sp,sp,12
8012f640:	f800283a 	ret
8012f644:	80c00017 	ldw	r3,0(r16)
8012f648:	183ff926 	beq	r3,zero,8012f630 <__reset+0xfa10f630>
8012f64c:	88c00015 	stw	r3,0(r17)
8012f650:	003ff706 	br	8012f630 <__reset+0xfa10f630>

8012f654 <_isatty_r>:
8012f654:	defffd04 	addi	sp,sp,-12
8012f658:	de00012e 	bgeu	sp,et,8012f660 <_isatty_r+0xc>
8012f65c:	003b68fa 	trap	3
8012f660:	dc000015 	stw	r16,0(sp)
8012f664:	04200574 	movhi	r16,32789
8012f668:	dc400115 	stw	r17,4(sp)
8012f66c:	84290904 	addi	r16,r16,-23516
8012f670:	2023883a 	mov	r17,r4
8012f674:	2809883a 	mov	r4,r5
8012f678:	dfc00215 	stw	ra,8(sp)
8012f67c:	80000015 	stw	zero,0(r16)
8012f680:	0131e600 	call	80131e60 <isatty>
8012f684:	00ffffc4 	movi	r3,-1
8012f688:	10c00526 	beq	r2,r3,8012f6a0 <_isatty_r+0x4c>
8012f68c:	dfc00217 	ldw	ra,8(sp)
8012f690:	dc400117 	ldw	r17,4(sp)
8012f694:	dc000017 	ldw	r16,0(sp)
8012f698:	dec00304 	addi	sp,sp,12
8012f69c:	f800283a 	ret
8012f6a0:	80c00017 	ldw	r3,0(r16)
8012f6a4:	183ff926 	beq	r3,zero,8012f68c <__reset+0xfa10f68c>
8012f6a8:	88c00015 	stw	r3,0(r17)
8012f6ac:	003ff706 	br	8012f68c <__reset+0xfa10f68c>

8012f6b0 <__udivdi3>:
8012f6b0:	defff504 	addi	sp,sp,-44
8012f6b4:	de00012e 	bgeu	sp,et,8012f6bc <__udivdi3+0xc>
8012f6b8:	003b68fa 	trap	3
8012f6bc:	dcc00415 	stw	r19,16(sp)
8012f6c0:	dc000115 	stw	r16,4(sp)
8012f6c4:	dfc00a15 	stw	ra,40(sp)
8012f6c8:	df000915 	stw	fp,36(sp)
8012f6cc:	ddc00815 	stw	r23,32(sp)
8012f6d0:	dd800715 	stw	r22,28(sp)
8012f6d4:	dd400615 	stw	r21,24(sp)
8012f6d8:	dd000515 	stw	r20,20(sp)
8012f6dc:	dc800315 	stw	r18,12(sp)
8012f6e0:	dc400215 	stw	r17,8(sp)
8012f6e4:	2027883a 	mov	r19,r4
8012f6e8:	2821883a 	mov	r16,r5
8012f6ec:	3800411e 	bne	r7,zero,8012f7f4 <__udivdi3+0x144>
8012f6f0:	3023883a 	mov	r17,r6
8012f6f4:	2025883a 	mov	r18,r4
8012f6f8:	2980522e 	bgeu	r5,r6,8012f844 <__udivdi3+0x194>
8012f6fc:	00bfffd4 	movui	r2,65535
8012f700:	282d883a 	mov	r22,r5
8012f704:	1180a836 	bltu	r2,r6,8012f9a8 <__udivdi3+0x2f8>
8012f708:	00803fc4 	movi	r2,255
8012f70c:	1185803a 	cmpltu	r2,r2,r6
8012f710:	100490fa 	slli	r2,r2,3
8012f714:	3086d83a 	srl	r3,r6,r2
8012f718:	01200534 	movhi	r4,32788
8012f71c:	211dde84 	addi	r4,r4,30586
8012f720:	20c7883a 	add	r3,r4,r3
8012f724:	18c00003 	ldbu	r3,0(r3)
8012f728:	1885883a 	add	r2,r3,r2
8012f72c:	00c00804 	movi	r3,32
8012f730:	1887c83a 	sub	r3,r3,r2
8012f734:	18000526 	beq	r3,zero,8012f74c <__udivdi3+0x9c>
8012f738:	80e0983a 	sll	r16,r16,r3
8012f73c:	9884d83a 	srl	r2,r19,r2
8012f740:	30e2983a 	sll	r17,r6,r3
8012f744:	98e4983a 	sll	r18,r19,r3
8012f748:	142cb03a 	or	r22,r2,r16
8012f74c:	882ad43a 	srli	r21,r17,16
8012f750:	b009883a 	mov	r4,r22
8012f754:	8d3fffcc 	andi	r20,r17,65535
8012f758:	a80b883a 	mov	r5,r21
8012f75c:	01302cc0 	call	801302cc <__umodsi3>
8012f760:	b009883a 	mov	r4,r22
8012f764:	a80b883a 	mov	r5,r21
8012f768:	1027883a 	mov	r19,r2
8012f76c:	01302680 	call	80130268 <__udivsi3>
8012f770:	102d883a 	mov	r22,r2
8012f774:	9826943a 	slli	r19,r19,16
8012f778:	9004d43a 	srli	r2,r18,16
8012f77c:	a5a1383a 	mul	r16,r20,r22
8012f780:	14c4b03a 	or	r2,r2,r19
8012f784:	1400052e 	bgeu	r2,r16,8012f79c <__udivdi3+0xec>
8012f788:	1445883a 	add	r2,r2,r17
8012f78c:	b0ffffc4 	addi	r3,r22,-1
8012f790:	14400136 	bltu	r2,r17,8012f798 <__udivdi3+0xe8>
8012f794:	14012336 	bltu	r2,r16,8012fc24 <__udivdi3+0x574>
8012f798:	182d883a 	mov	r22,r3
8012f79c:	1421c83a 	sub	r16,r2,r16
8012f7a0:	a80b883a 	mov	r5,r21
8012f7a4:	8009883a 	mov	r4,r16
8012f7a8:	01302cc0 	call	801302cc <__umodsi3>
8012f7ac:	1027883a 	mov	r19,r2
8012f7b0:	a80b883a 	mov	r5,r21
8012f7b4:	8009883a 	mov	r4,r16
8012f7b8:	01302680 	call	80130268 <__udivsi3>
8012f7bc:	9826943a 	slli	r19,r19,16
8012f7c0:	a0a9383a 	mul	r20,r20,r2
8012f7c4:	94bfffcc 	andi	r18,r18,65535
8012f7c8:	94e4b03a 	or	r18,r18,r19
8012f7cc:	9500052e 	bgeu	r18,r20,8012f7e4 <__udivdi3+0x134>
8012f7d0:	8ca5883a 	add	r18,r17,r18
8012f7d4:	10ffffc4 	addi	r3,r2,-1
8012f7d8:	9440f136 	bltu	r18,r17,8012fba0 <__udivdi3+0x4f0>
8012f7dc:	9500f02e 	bgeu	r18,r20,8012fba0 <__udivdi3+0x4f0>
8012f7e0:	10bfff84 	addi	r2,r2,-2
8012f7e4:	b00c943a 	slli	r6,r22,16
8012f7e8:	0007883a 	mov	r3,zero
8012f7ec:	3084b03a 	or	r2,r6,r2
8012f7f0:	00005906 	br	8012f958 <__udivdi3+0x2a8>
8012f7f4:	29c05636 	bltu	r5,r7,8012f950 <__udivdi3+0x2a0>
8012f7f8:	00bfffd4 	movui	r2,65535
8012f7fc:	11c0622e 	bgeu	r2,r7,8012f988 <__udivdi3+0x2d8>
8012f800:	00804034 	movhi	r2,256
8012f804:	10bfffc4 	addi	r2,r2,-1
8012f808:	11c0ee36 	bltu	r2,r7,8012fbc4 <__udivdi3+0x514>
8012f80c:	00800404 	movi	r2,16
8012f810:	3886d83a 	srl	r3,r7,r2
8012f814:	01200534 	movhi	r4,32788
8012f818:	211dde84 	addi	r4,r4,30586
8012f81c:	20c7883a 	add	r3,r4,r3
8012f820:	18c00003 	ldbu	r3,0(r3)
8012f824:	05400804 	movi	r21,32
8012f828:	1885883a 	add	r2,r3,r2
8012f82c:	a8abc83a 	sub	r21,r21,r2
8012f830:	a800621e 	bne	r21,zero,8012f9bc <__udivdi3+0x30c>
8012f834:	3c00e936 	bltu	r7,r16,8012fbdc <__udivdi3+0x52c>
8012f838:	9985403a 	cmpgeu	r2,r19,r6
8012f83c:	0007883a 	mov	r3,zero
8012f840:	00004506 	br	8012f958 <__udivdi3+0x2a8>
8012f844:	3000041e 	bne	r6,zero,8012f858 <__udivdi3+0x1a8>
8012f848:	000b883a 	mov	r5,zero
8012f84c:	01000044 	movi	r4,1
8012f850:	01302680 	call	80130268 <__udivsi3>
8012f854:	1023883a 	mov	r17,r2
8012f858:	00bfffd4 	movui	r2,65535
8012f85c:	14404e2e 	bgeu	r2,r17,8012f998 <__udivdi3+0x2e8>
8012f860:	00804034 	movhi	r2,256
8012f864:	10bfffc4 	addi	r2,r2,-1
8012f868:	1440d836 	bltu	r2,r17,8012fbcc <__udivdi3+0x51c>
8012f86c:	00800404 	movi	r2,16
8012f870:	8886d83a 	srl	r3,r17,r2
8012f874:	01200534 	movhi	r4,32788
8012f878:	211dde84 	addi	r4,r4,30586
8012f87c:	20c7883a 	add	r3,r4,r3
8012f880:	18c00003 	ldbu	r3,0(r3)
8012f884:	1885883a 	add	r2,r3,r2
8012f888:	00c00804 	movi	r3,32
8012f88c:	1887c83a 	sub	r3,r3,r2
8012f890:	18008f1e 	bne	r3,zero,8012fad0 <__udivdi3+0x420>
8012f894:	882ad43a 	srli	r21,r17,16
8012f898:	8461c83a 	sub	r16,r16,r17
8012f89c:	8d3fffcc 	andi	r20,r17,65535
8012f8a0:	00c00044 	movi	r3,1
8012f8a4:	8009883a 	mov	r4,r16
8012f8a8:	a80b883a 	mov	r5,r21
8012f8ac:	d8c00015 	stw	r3,0(sp)
8012f8b0:	01302cc0 	call	801302cc <__umodsi3>
8012f8b4:	8009883a 	mov	r4,r16
8012f8b8:	a80b883a 	mov	r5,r21
8012f8bc:	1027883a 	mov	r19,r2
8012f8c0:	01302680 	call	80130268 <__udivsi3>
8012f8c4:	9826943a 	slli	r19,r19,16
8012f8c8:	9008d43a 	srli	r4,r18,16
8012f8cc:	1521383a 	mul	r16,r2,r20
8012f8d0:	102d883a 	mov	r22,r2
8012f8d4:	24c8b03a 	or	r4,r4,r19
8012f8d8:	d8c00017 	ldw	r3,0(sp)
8012f8dc:	2400052e 	bgeu	r4,r16,8012f8f4 <__udivdi3+0x244>
8012f8e0:	2449883a 	add	r4,r4,r17
8012f8e4:	b0bfffc4 	addi	r2,r22,-1
8012f8e8:	24400136 	bltu	r4,r17,8012f8f0 <__udivdi3+0x240>
8012f8ec:	2400ca36 	bltu	r4,r16,8012fc18 <__udivdi3+0x568>
8012f8f0:	102d883a 	mov	r22,r2
8012f8f4:	2421c83a 	sub	r16,r4,r16
8012f8f8:	a80b883a 	mov	r5,r21
8012f8fc:	8009883a 	mov	r4,r16
8012f900:	d8c00015 	stw	r3,0(sp)
8012f904:	01302cc0 	call	801302cc <__umodsi3>
8012f908:	1027883a 	mov	r19,r2
8012f90c:	a80b883a 	mov	r5,r21
8012f910:	8009883a 	mov	r4,r16
8012f914:	01302680 	call	80130268 <__udivsi3>
8012f918:	9826943a 	slli	r19,r19,16
8012f91c:	1529383a 	mul	r20,r2,r20
8012f920:	94bfffcc 	andi	r18,r18,65535
8012f924:	94e4b03a 	or	r18,r18,r19
8012f928:	d8c00017 	ldw	r3,0(sp)
8012f92c:	9500052e 	bgeu	r18,r20,8012f944 <__udivdi3+0x294>
8012f930:	8ca5883a 	add	r18,r17,r18
8012f934:	113fffc4 	addi	r4,r2,-1
8012f938:	94409736 	bltu	r18,r17,8012fb98 <__udivdi3+0x4e8>
8012f93c:	9500962e 	bgeu	r18,r20,8012fb98 <__udivdi3+0x4e8>
8012f940:	10bfff84 	addi	r2,r2,-2
8012f944:	b00c943a 	slli	r6,r22,16
8012f948:	3084b03a 	or	r2,r6,r2
8012f94c:	00000206 	br	8012f958 <__udivdi3+0x2a8>
8012f950:	0007883a 	mov	r3,zero
8012f954:	0005883a 	mov	r2,zero
8012f958:	dfc00a17 	ldw	ra,40(sp)
8012f95c:	df000917 	ldw	fp,36(sp)
8012f960:	ddc00817 	ldw	r23,32(sp)
8012f964:	dd800717 	ldw	r22,28(sp)
8012f968:	dd400617 	ldw	r21,24(sp)
8012f96c:	dd000517 	ldw	r20,20(sp)
8012f970:	dcc00417 	ldw	r19,16(sp)
8012f974:	dc800317 	ldw	r18,12(sp)
8012f978:	dc400217 	ldw	r17,8(sp)
8012f97c:	dc000117 	ldw	r16,4(sp)
8012f980:	dec00b04 	addi	sp,sp,44
8012f984:	f800283a 	ret
8012f988:	00803fc4 	movi	r2,255
8012f98c:	11c5803a 	cmpltu	r2,r2,r7
8012f990:	100490fa 	slli	r2,r2,3
8012f994:	003f9e06 	br	8012f810 <__reset+0xfa10f810>
8012f998:	00803fc4 	movi	r2,255
8012f99c:	1445803a 	cmpltu	r2,r2,r17
8012f9a0:	100490fa 	slli	r2,r2,3
8012f9a4:	003fb206 	br	8012f870 <__reset+0xfa10f870>
8012f9a8:	00804034 	movhi	r2,256
8012f9ac:	10bfffc4 	addi	r2,r2,-1
8012f9b0:	11808836 	bltu	r2,r6,8012fbd4 <__udivdi3+0x524>
8012f9b4:	00800404 	movi	r2,16
8012f9b8:	003f5606 	br	8012f714 <__reset+0xfa10f714>
8012f9bc:	30aed83a 	srl	r23,r6,r2
8012f9c0:	3d4e983a 	sll	r7,r7,r21
8012f9c4:	80acd83a 	srl	r22,r16,r2
8012f9c8:	9884d83a 	srl	r2,r19,r2
8012f9cc:	3deeb03a 	or	r23,r7,r23
8012f9d0:	b824d43a 	srli	r18,r23,16
8012f9d4:	8560983a 	sll	r16,r16,r21
8012f9d8:	b009883a 	mov	r4,r22
8012f9dc:	900b883a 	mov	r5,r18
8012f9e0:	3568983a 	sll	r20,r6,r21
8012f9e4:	1420b03a 	or	r16,r2,r16
8012f9e8:	01302cc0 	call	801302cc <__umodsi3>
8012f9ec:	b009883a 	mov	r4,r22
8012f9f0:	900b883a 	mov	r5,r18
8012f9f4:	1023883a 	mov	r17,r2
8012f9f8:	01302680 	call	80130268 <__udivsi3>
8012f9fc:	8808943a 	slli	r4,r17,16
8012fa00:	bf3fffcc 	andi	fp,r23,65535
8012fa04:	8006d43a 	srli	r3,r16,16
8012fa08:	e0a3383a 	mul	r17,fp,r2
8012fa0c:	100d883a 	mov	r6,r2
8012fa10:	1906b03a 	or	r3,r3,r4
8012fa14:	1c40042e 	bgeu	r3,r17,8012fa28 <__udivdi3+0x378>
8012fa18:	1dc7883a 	add	r3,r3,r23
8012fa1c:	10bfffc4 	addi	r2,r2,-1
8012fa20:	1dc0752e 	bgeu	r3,r23,8012fbf8 <__udivdi3+0x548>
8012fa24:	100d883a 	mov	r6,r2
8012fa28:	1c63c83a 	sub	r17,r3,r17
8012fa2c:	900b883a 	mov	r5,r18
8012fa30:	8809883a 	mov	r4,r17
8012fa34:	d9800015 	stw	r6,0(sp)
8012fa38:	01302cc0 	call	801302cc <__umodsi3>
8012fa3c:	102d883a 	mov	r22,r2
8012fa40:	8809883a 	mov	r4,r17
8012fa44:	900b883a 	mov	r5,r18
8012fa48:	01302680 	call	80130268 <__udivsi3>
8012fa4c:	b02c943a 	slli	r22,r22,16
8012fa50:	e089383a 	mul	r4,fp,r2
8012fa54:	843fffcc 	andi	r16,r16,65535
8012fa58:	85a0b03a 	or	r16,r16,r22
8012fa5c:	d9800017 	ldw	r6,0(sp)
8012fa60:	8100042e 	bgeu	r16,r4,8012fa74 <__udivdi3+0x3c4>
8012fa64:	85e1883a 	add	r16,r16,r23
8012fa68:	10ffffc4 	addi	r3,r2,-1
8012fa6c:	85c05e2e 	bgeu	r16,r23,8012fbe8 <__udivdi3+0x538>
8012fa70:	1805883a 	mov	r2,r3
8012fa74:	300c943a 	slli	r6,r6,16
8012fa78:	a17fffcc 	andi	r5,r20,65535
8012fa7c:	a028d43a 	srli	r20,r20,16
8012fa80:	3084b03a 	or	r2,r6,r2
8012fa84:	10ffffcc 	andi	r3,r2,65535
8012fa88:	100cd43a 	srli	r6,r2,16
8012fa8c:	194f383a 	mul	r7,r3,r5
8012fa90:	1d07383a 	mul	r3,r3,r20
8012fa94:	314b383a 	mul	r5,r6,r5
8012fa98:	3810d43a 	srli	r8,r7,16
8012fa9c:	8121c83a 	sub	r16,r16,r4
8012faa0:	1947883a 	add	r3,r3,r5
8012faa4:	40c7883a 	add	r3,r8,r3
8012faa8:	350d383a 	mul	r6,r6,r20
8012faac:	1940022e 	bgeu	r3,r5,8012fab8 <__udivdi3+0x408>
8012fab0:	01000074 	movhi	r4,1
8012fab4:	310d883a 	add	r6,r6,r4
8012fab8:	1828d43a 	srli	r20,r3,16
8012fabc:	a18d883a 	add	r6,r20,r6
8012fac0:	81803e36 	bltu	r16,r6,8012fbbc <__udivdi3+0x50c>
8012fac4:	81803826 	beq	r16,r6,8012fba8 <__udivdi3+0x4f8>
8012fac8:	0007883a 	mov	r3,zero
8012facc:	003fa206 	br	8012f958 <__reset+0xfa10f958>
8012fad0:	88e2983a 	sll	r17,r17,r3
8012fad4:	80a8d83a 	srl	r20,r16,r2
8012fad8:	80e0983a 	sll	r16,r16,r3
8012fadc:	882ad43a 	srli	r21,r17,16
8012fae0:	9884d83a 	srl	r2,r19,r2
8012fae4:	a009883a 	mov	r4,r20
8012fae8:	a80b883a 	mov	r5,r21
8012faec:	142eb03a 	or	r23,r2,r16
8012faf0:	98e4983a 	sll	r18,r19,r3
8012faf4:	01302cc0 	call	801302cc <__umodsi3>
8012faf8:	a009883a 	mov	r4,r20
8012fafc:	a80b883a 	mov	r5,r21
8012fb00:	1021883a 	mov	r16,r2
8012fb04:	01302680 	call	80130268 <__udivsi3>
8012fb08:	1039883a 	mov	fp,r2
8012fb0c:	8d3fffcc 	andi	r20,r17,65535
8012fb10:	8020943a 	slli	r16,r16,16
8012fb14:	b804d43a 	srli	r2,r23,16
8012fb18:	a72d383a 	mul	r22,r20,fp
8012fb1c:	1404b03a 	or	r2,r2,r16
8012fb20:	1580062e 	bgeu	r2,r22,8012fb3c <__udivdi3+0x48c>
8012fb24:	1445883a 	add	r2,r2,r17
8012fb28:	e0ffffc4 	addi	r3,fp,-1
8012fb2c:	14403836 	bltu	r2,r17,8012fc10 <__udivdi3+0x560>
8012fb30:	1580372e 	bgeu	r2,r22,8012fc10 <__udivdi3+0x560>
8012fb34:	e73fff84 	addi	fp,fp,-2
8012fb38:	1445883a 	add	r2,r2,r17
8012fb3c:	15adc83a 	sub	r22,r2,r22
8012fb40:	a80b883a 	mov	r5,r21
8012fb44:	b009883a 	mov	r4,r22
8012fb48:	01302cc0 	call	801302cc <__umodsi3>
8012fb4c:	1027883a 	mov	r19,r2
8012fb50:	b009883a 	mov	r4,r22
8012fb54:	a80b883a 	mov	r5,r21
8012fb58:	01302680 	call	80130268 <__udivsi3>
8012fb5c:	9826943a 	slli	r19,r19,16
8012fb60:	a0a1383a 	mul	r16,r20,r2
8012fb64:	b93fffcc 	andi	r4,r23,65535
8012fb68:	24c8b03a 	or	r4,r4,r19
8012fb6c:	2400062e 	bgeu	r4,r16,8012fb88 <__udivdi3+0x4d8>
8012fb70:	2449883a 	add	r4,r4,r17
8012fb74:	10ffffc4 	addi	r3,r2,-1
8012fb78:	24402336 	bltu	r4,r17,8012fc08 <__udivdi3+0x558>
8012fb7c:	2400222e 	bgeu	r4,r16,8012fc08 <__udivdi3+0x558>
8012fb80:	10bfff84 	addi	r2,r2,-2
8012fb84:	2449883a 	add	r4,r4,r17
8012fb88:	e038943a 	slli	fp,fp,16
8012fb8c:	2421c83a 	sub	r16,r4,r16
8012fb90:	e086b03a 	or	r3,fp,r2
8012fb94:	003f4306 	br	8012f8a4 <__reset+0xfa10f8a4>
8012fb98:	2005883a 	mov	r2,r4
8012fb9c:	003f6906 	br	8012f944 <__reset+0xfa10f944>
8012fba0:	1805883a 	mov	r2,r3
8012fba4:	003f0f06 	br	8012f7e4 <__reset+0xfa10f7e4>
8012fba8:	1806943a 	slli	r3,r3,16
8012fbac:	9d66983a 	sll	r19,r19,r21
8012fbb0:	39ffffcc 	andi	r7,r7,65535
8012fbb4:	19c7883a 	add	r3,r3,r7
8012fbb8:	98ffc32e 	bgeu	r19,r3,8012fac8 <__reset+0xfa10fac8>
8012fbbc:	10bfffc4 	addi	r2,r2,-1
8012fbc0:	003fc106 	br	8012fac8 <__reset+0xfa10fac8>
8012fbc4:	00800604 	movi	r2,24
8012fbc8:	003f1106 	br	8012f810 <__reset+0xfa10f810>
8012fbcc:	00800604 	movi	r2,24
8012fbd0:	003f2706 	br	8012f870 <__reset+0xfa10f870>
8012fbd4:	00800604 	movi	r2,24
8012fbd8:	003ece06 	br	8012f714 <__reset+0xfa10f714>
8012fbdc:	0007883a 	mov	r3,zero
8012fbe0:	00800044 	movi	r2,1
8012fbe4:	003f5c06 	br	8012f958 <__reset+0xfa10f958>
8012fbe8:	813fa12e 	bgeu	r16,r4,8012fa70 <__reset+0xfa10fa70>
8012fbec:	10bfff84 	addi	r2,r2,-2
8012fbf0:	85e1883a 	add	r16,r16,r23
8012fbf4:	003f9f06 	br	8012fa74 <__reset+0xfa10fa74>
8012fbf8:	1c7f8a2e 	bgeu	r3,r17,8012fa24 <__reset+0xfa10fa24>
8012fbfc:	31bfff84 	addi	r6,r6,-2
8012fc00:	1dc7883a 	add	r3,r3,r23
8012fc04:	003f8806 	br	8012fa28 <__reset+0xfa10fa28>
8012fc08:	1805883a 	mov	r2,r3
8012fc0c:	003fde06 	br	8012fb88 <__reset+0xfa10fb88>
8012fc10:	1839883a 	mov	fp,r3
8012fc14:	003fc906 	br	8012fb3c <__reset+0xfa10fb3c>
8012fc18:	b5bfff84 	addi	r22,r22,-2
8012fc1c:	2449883a 	add	r4,r4,r17
8012fc20:	003f3406 	br	8012f8f4 <__reset+0xfa10f8f4>
8012fc24:	b5bfff84 	addi	r22,r22,-2
8012fc28:	1445883a 	add	r2,r2,r17
8012fc2c:	003edb06 	br	8012f79c <__reset+0xfa10f79c>

8012fc30 <__umoddi3>:
8012fc30:	defff404 	addi	sp,sp,-48
8012fc34:	de00012e 	bgeu	sp,et,8012fc3c <__umoddi3+0xc>
8012fc38:	003b68fa 	trap	3
8012fc3c:	df000a15 	stw	fp,40(sp)
8012fc40:	dc400315 	stw	r17,12(sp)
8012fc44:	dc000215 	stw	r16,8(sp)
8012fc48:	dfc00b15 	stw	ra,44(sp)
8012fc4c:	ddc00915 	stw	r23,36(sp)
8012fc50:	dd800815 	stw	r22,32(sp)
8012fc54:	dd400715 	stw	r21,28(sp)
8012fc58:	dd000615 	stw	r20,24(sp)
8012fc5c:	dcc00515 	stw	r19,20(sp)
8012fc60:	dc800415 	stw	r18,16(sp)
8012fc64:	2021883a 	mov	r16,r4
8012fc68:	2823883a 	mov	r17,r5
8012fc6c:	2839883a 	mov	fp,r5
8012fc70:	38003c1e 	bne	r7,zero,8012fd64 <__umoddi3+0x134>
8012fc74:	3027883a 	mov	r19,r6
8012fc78:	2029883a 	mov	r20,r4
8012fc7c:	2980512e 	bgeu	r5,r6,8012fdc4 <__umoddi3+0x194>
8012fc80:	00bfffd4 	movui	r2,65535
8012fc84:	11809a36 	bltu	r2,r6,8012fef0 <__umoddi3+0x2c0>
8012fc88:	01003fc4 	movi	r4,255
8012fc8c:	2189803a 	cmpltu	r4,r4,r6
8012fc90:	200890fa 	slli	r4,r4,3
8012fc94:	3104d83a 	srl	r2,r6,r4
8012fc98:	00e00534 	movhi	r3,32788
8012fc9c:	18ddde84 	addi	r3,r3,30586
8012fca0:	1885883a 	add	r2,r3,r2
8012fca4:	10c00003 	ldbu	r3,0(r2)
8012fca8:	00800804 	movi	r2,32
8012fcac:	1909883a 	add	r4,r3,r4
8012fcb0:	1125c83a 	sub	r18,r2,r4
8012fcb4:	90000526 	beq	r18,zero,8012fccc <__umoddi3+0x9c>
8012fcb8:	8ca2983a 	sll	r17,r17,r18
8012fcbc:	8108d83a 	srl	r4,r16,r4
8012fcc0:	34a6983a 	sll	r19,r6,r18
8012fcc4:	84a8983a 	sll	r20,r16,r18
8012fcc8:	2478b03a 	or	fp,r4,r17
8012fccc:	982ed43a 	srli	r23,r19,16
8012fcd0:	e009883a 	mov	r4,fp
8012fcd4:	9dbfffcc 	andi	r22,r19,65535
8012fcd8:	b80b883a 	mov	r5,r23
8012fcdc:	01302cc0 	call	801302cc <__umodsi3>
8012fce0:	e009883a 	mov	r4,fp
8012fce4:	b80b883a 	mov	r5,r23
8012fce8:	102b883a 	mov	r21,r2
8012fcec:	01302680 	call	80130268 <__udivsi3>
8012fcf0:	a806943a 	slli	r3,r21,16
8012fcf4:	a008d43a 	srli	r4,r20,16
8012fcf8:	b085383a 	mul	r2,r22,r2
8012fcfc:	20c8b03a 	or	r4,r4,r3
8012fd00:	2080032e 	bgeu	r4,r2,8012fd10 <__umoddi3+0xe0>
8012fd04:	24c9883a 	add	r4,r4,r19
8012fd08:	24c00136 	bltu	r4,r19,8012fd10 <__umoddi3+0xe0>
8012fd0c:	20811036 	bltu	r4,r2,80130150 <__umoddi3+0x520>
8012fd10:	20abc83a 	sub	r21,r4,r2
8012fd14:	b80b883a 	mov	r5,r23
8012fd18:	a809883a 	mov	r4,r21
8012fd1c:	01302cc0 	call	801302cc <__umodsi3>
8012fd20:	1023883a 	mov	r17,r2
8012fd24:	b80b883a 	mov	r5,r23
8012fd28:	a809883a 	mov	r4,r21
8012fd2c:	01302680 	call	80130268 <__udivsi3>
8012fd30:	8822943a 	slli	r17,r17,16
8012fd34:	b085383a 	mul	r2,r22,r2
8012fd38:	a0ffffcc 	andi	r3,r20,65535
8012fd3c:	1c46b03a 	or	r3,r3,r17
8012fd40:	1880042e 	bgeu	r3,r2,8012fd54 <__umoddi3+0x124>
8012fd44:	1cc7883a 	add	r3,r3,r19
8012fd48:	1cc00236 	bltu	r3,r19,8012fd54 <__umoddi3+0x124>
8012fd4c:	1880012e 	bgeu	r3,r2,8012fd54 <__umoddi3+0x124>
8012fd50:	1cc7883a 	add	r3,r3,r19
8012fd54:	1885c83a 	sub	r2,r3,r2
8012fd58:	1484d83a 	srl	r2,r2,r18
8012fd5c:	0007883a 	mov	r3,zero
8012fd60:	00004f06 	br	8012fea0 <__umoddi3+0x270>
8012fd64:	29c04c36 	bltu	r5,r7,8012fe98 <__umoddi3+0x268>
8012fd68:	00bfffd4 	movui	r2,65535
8012fd6c:	11c0582e 	bgeu	r2,r7,8012fed0 <__umoddi3+0x2a0>
8012fd70:	00804034 	movhi	r2,256
8012fd74:	10bfffc4 	addi	r2,r2,-1
8012fd78:	11c0e736 	bltu	r2,r7,80130118 <__umoddi3+0x4e8>
8012fd7c:	01000404 	movi	r4,16
8012fd80:	3904d83a 	srl	r2,r7,r4
8012fd84:	00e00534 	movhi	r3,32788
8012fd88:	18ddde84 	addi	r3,r3,30586
8012fd8c:	1885883a 	add	r2,r3,r2
8012fd90:	14c00003 	ldbu	r19,0(r2)
8012fd94:	00c00804 	movi	r3,32
8012fd98:	9927883a 	add	r19,r19,r4
8012fd9c:	1ce9c83a 	sub	r20,r3,r19
8012fda0:	a000581e 	bne	r20,zero,8012ff04 <__umoddi3+0x2d4>
8012fda4:	3c400136 	bltu	r7,r17,8012fdac <__umoddi3+0x17c>
8012fda8:	8180eb36 	bltu	r16,r6,80130158 <__umoddi3+0x528>
8012fdac:	8185c83a 	sub	r2,r16,r6
8012fdb0:	89e3c83a 	sub	r17,r17,r7
8012fdb4:	8089803a 	cmpltu	r4,r16,r2
8012fdb8:	8939c83a 	sub	fp,r17,r4
8012fdbc:	e007883a 	mov	r3,fp
8012fdc0:	00003706 	br	8012fea0 <__umoddi3+0x270>
8012fdc4:	3000041e 	bne	r6,zero,8012fdd8 <__umoddi3+0x1a8>
8012fdc8:	000b883a 	mov	r5,zero
8012fdcc:	01000044 	movi	r4,1
8012fdd0:	01302680 	call	80130268 <__udivsi3>
8012fdd4:	1027883a 	mov	r19,r2
8012fdd8:	00bfffd4 	movui	r2,65535
8012fddc:	14c0402e 	bgeu	r2,r19,8012fee0 <__umoddi3+0x2b0>
8012fde0:	00804034 	movhi	r2,256
8012fde4:	10bfffc4 	addi	r2,r2,-1
8012fde8:	14c0cd36 	bltu	r2,r19,80130120 <__umoddi3+0x4f0>
8012fdec:	00800404 	movi	r2,16
8012fdf0:	9886d83a 	srl	r3,r19,r2
8012fdf4:	01200534 	movhi	r4,32788
8012fdf8:	211dde84 	addi	r4,r4,30586
8012fdfc:	20c7883a 	add	r3,r4,r3
8012fe00:	18c00003 	ldbu	r3,0(r3)
8012fe04:	1887883a 	add	r3,r3,r2
8012fe08:	00800804 	movi	r2,32
8012fe0c:	10e5c83a 	sub	r18,r2,r3
8012fe10:	9000901e 	bne	r18,zero,80130054 <__umoddi3+0x424>
8012fe14:	982cd43a 	srli	r22,r19,16
8012fe18:	8ce3c83a 	sub	r17,r17,r19
8012fe1c:	9d7fffcc 	andi	r21,r19,65535
8012fe20:	b00b883a 	mov	r5,r22
8012fe24:	8809883a 	mov	r4,r17
8012fe28:	01302cc0 	call	801302cc <__umodsi3>
8012fe2c:	8809883a 	mov	r4,r17
8012fe30:	b00b883a 	mov	r5,r22
8012fe34:	1021883a 	mov	r16,r2
8012fe38:	01302680 	call	80130268 <__udivsi3>
8012fe3c:	8006943a 	slli	r3,r16,16
8012fe40:	a008d43a 	srli	r4,r20,16
8012fe44:	1545383a 	mul	r2,r2,r21
8012fe48:	20c8b03a 	or	r4,r4,r3
8012fe4c:	2080042e 	bgeu	r4,r2,8012fe60 <__umoddi3+0x230>
8012fe50:	24c9883a 	add	r4,r4,r19
8012fe54:	24c00236 	bltu	r4,r19,8012fe60 <__umoddi3+0x230>
8012fe58:	2080012e 	bgeu	r4,r2,8012fe60 <__umoddi3+0x230>
8012fe5c:	24c9883a 	add	r4,r4,r19
8012fe60:	20a1c83a 	sub	r16,r4,r2
8012fe64:	b00b883a 	mov	r5,r22
8012fe68:	8009883a 	mov	r4,r16
8012fe6c:	01302cc0 	call	801302cc <__umodsi3>
8012fe70:	1023883a 	mov	r17,r2
8012fe74:	b00b883a 	mov	r5,r22
8012fe78:	8009883a 	mov	r4,r16
8012fe7c:	01302680 	call	80130268 <__udivsi3>
8012fe80:	8822943a 	slli	r17,r17,16
8012fe84:	1545383a 	mul	r2,r2,r21
8012fe88:	a53fffcc 	andi	r20,r20,65535
8012fe8c:	a446b03a 	or	r3,r20,r17
8012fe90:	18bfb02e 	bgeu	r3,r2,8012fd54 <__reset+0xfa10fd54>
8012fe94:	003fab06 	br	8012fd44 <__reset+0xfa10fd44>
8012fe98:	2005883a 	mov	r2,r4
8012fe9c:	2807883a 	mov	r3,r5
8012fea0:	dfc00b17 	ldw	ra,44(sp)
8012fea4:	df000a17 	ldw	fp,40(sp)
8012fea8:	ddc00917 	ldw	r23,36(sp)
8012feac:	dd800817 	ldw	r22,32(sp)
8012feb0:	dd400717 	ldw	r21,28(sp)
8012feb4:	dd000617 	ldw	r20,24(sp)
8012feb8:	dcc00517 	ldw	r19,20(sp)
8012febc:	dc800417 	ldw	r18,16(sp)
8012fec0:	dc400317 	ldw	r17,12(sp)
8012fec4:	dc000217 	ldw	r16,8(sp)
8012fec8:	dec00c04 	addi	sp,sp,48
8012fecc:	f800283a 	ret
8012fed0:	04c03fc4 	movi	r19,255
8012fed4:	99c9803a 	cmpltu	r4,r19,r7
8012fed8:	200890fa 	slli	r4,r4,3
8012fedc:	003fa806 	br	8012fd80 <__reset+0xfa10fd80>
8012fee0:	00803fc4 	movi	r2,255
8012fee4:	14c5803a 	cmpltu	r2,r2,r19
8012fee8:	100490fa 	slli	r2,r2,3
8012feec:	003fc006 	br	8012fdf0 <__reset+0xfa10fdf0>
8012fef0:	00804034 	movhi	r2,256
8012fef4:	10bfffc4 	addi	r2,r2,-1
8012fef8:	11808b36 	bltu	r2,r6,80130128 <__umoddi3+0x4f8>
8012fefc:	01000404 	movi	r4,16
8012ff00:	003f6406 	br	8012fc94 <__reset+0xfa10fc94>
8012ff04:	34c4d83a 	srl	r2,r6,r19
8012ff08:	3d0e983a 	sll	r7,r7,r20
8012ff0c:	8cf8d83a 	srl	fp,r17,r19
8012ff10:	8d10983a 	sll	r8,r17,r20
8012ff14:	38aab03a 	or	r21,r7,r2
8012ff18:	a82cd43a 	srli	r22,r21,16
8012ff1c:	84e2d83a 	srl	r17,r16,r19
8012ff20:	e009883a 	mov	r4,fp
8012ff24:	b00b883a 	mov	r5,r22
8012ff28:	8a22b03a 	or	r17,r17,r8
8012ff2c:	3524983a 	sll	r18,r6,r20
8012ff30:	01302cc0 	call	801302cc <__umodsi3>
8012ff34:	e009883a 	mov	r4,fp
8012ff38:	b00b883a 	mov	r5,r22
8012ff3c:	102f883a 	mov	r23,r2
8012ff40:	01302680 	call	80130268 <__udivsi3>
8012ff44:	100d883a 	mov	r6,r2
8012ff48:	b808943a 	slli	r4,r23,16
8012ff4c:	aa3fffcc 	andi	r8,r21,65535
8012ff50:	8804d43a 	srli	r2,r17,16
8012ff54:	41af383a 	mul	r23,r8,r6
8012ff58:	8520983a 	sll	r16,r16,r20
8012ff5c:	1104b03a 	or	r2,r2,r4
8012ff60:	15c0042e 	bgeu	r2,r23,8012ff74 <__umoddi3+0x344>
8012ff64:	1545883a 	add	r2,r2,r21
8012ff68:	30ffffc4 	addi	r3,r6,-1
8012ff6c:	1540742e 	bgeu	r2,r21,80130140 <__umoddi3+0x510>
8012ff70:	180d883a 	mov	r6,r3
8012ff74:	15efc83a 	sub	r23,r2,r23
8012ff78:	b00b883a 	mov	r5,r22
8012ff7c:	b809883a 	mov	r4,r23
8012ff80:	d9800115 	stw	r6,4(sp)
8012ff84:	da000015 	stw	r8,0(sp)
8012ff88:	01302cc0 	call	801302cc <__umodsi3>
8012ff8c:	b00b883a 	mov	r5,r22
8012ff90:	b809883a 	mov	r4,r23
8012ff94:	1039883a 	mov	fp,r2
8012ff98:	01302680 	call	80130268 <__udivsi3>
8012ff9c:	da000017 	ldw	r8,0(sp)
8012ffa0:	e038943a 	slli	fp,fp,16
8012ffa4:	100b883a 	mov	r5,r2
8012ffa8:	4089383a 	mul	r4,r8,r2
8012ffac:	8a3fffcc 	andi	r8,r17,65535
8012ffb0:	4710b03a 	or	r8,r8,fp
8012ffb4:	d9800117 	ldw	r6,4(sp)
8012ffb8:	4100042e 	bgeu	r8,r4,8012ffcc <__umoddi3+0x39c>
8012ffbc:	4551883a 	add	r8,r8,r21
8012ffc0:	10bfffc4 	addi	r2,r2,-1
8012ffc4:	45405a2e 	bgeu	r8,r21,80130130 <__umoddi3+0x500>
8012ffc8:	100b883a 	mov	r5,r2
8012ffcc:	300c943a 	slli	r6,r6,16
8012ffd0:	91ffffcc 	andi	r7,r18,65535
8012ffd4:	9004d43a 	srli	r2,r18,16
8012ffd8:	314cb03a 	or	r6,r6,r5
8012ffdc:	317fffcc 	andi	r5,r6,65535
8012ffe0:	300cd43a 	srli	r6,r6,16
8012ffe4:	29d3383a 	mul	r9,r5,r7
8012ffe8:	288b383a 	mul	r5,r5,r2
8012ffec:	31cf383a 	mul	r7,r6,r7
8012fff0:	4806d43a 	srli	r3,r9,16
8012fff4:	4111c83a 	sub	r8,r8,r4
8012fff8:	29cb883a 	add	r5,r5,r7
8012fffc:	194b883a 	add	r5,r3,r5
80130000:	3085383a 	mul	r2,r6,r2
80130004:	29c0022e 	bgeu	r5,r7,80130010 <__umoddi3+0x3e0>
80130008:	00c00074 	movhi	r3,1
8013000c:	10c5883a 	add	r2,r2,r3
80130010:	2808d43a 	srli	r4,r5,16
80130014:	280a943a 	slli	r5,r5,16
80130018:	4a7fffcc 	andi	r9,r9,65535
8013001c:	2085883a 	add	r2,r4,r2
80130020:	2a4b883a 	add	r5,r5,r9
80130024:	40803636 	bltu	r8,r2,80130100 <__umoddi3+0x4d0>
80130028:	40804d26 	beq	r8,r2,80130160 <__umoddi3+0x530>
8013002c:	4089c83a 	sub	r4,r8,r2
80130030:	280f883a 	mov	r7,r5
80130034:	81cfc83a 	sub	r7,r16,r7
80130038:	81c7803a 	cmpltu	r3,r16,r7
8013003c:	20c7c83a 	sub	r3,r4,r3
80130040:	1cc4983a 	sll	r2,r3,r19
80130044:	3d0ed83a 	srl	r7,r7,r20
80130048:	1d06d83a 	srl	r3,r3,r20
8013004c:	11c4b03a 	or	r2,r2,r7
80130050:	003f9306 	br	8012fea0 <__reset+0xfa10fea0>
80130054:	9ca6983a 	sll	r19,r19,r18
80130058:	88e8d83a 	srl	r20,r17,r3
8013005c:	80c4d83a 	srl	r2,r16,r3
80130060:	982cd43a 	srli	r22,r19,16
80130064:	8ca2983a 	sll	r17,r17,r18
80130068:	a009883a 	mov	r4,r20
8013006c:	b00b883a 	mov	r5,r22
80130070:	1478b03a 	or	fp,r2,r17
80130074:	01302cc0 	call	801302cc <__umodsi3>
80130078:	a009883a 	mov	r4,r20
8013007c:	b00b883a 	mov	r5,r22
80130080:	1023883a 	mov	r17,r2
80130084:	01302680 	call	80130268 <__udivsi3>
80130088:	9d7fffcc 	andi	r21,r19,65535
8013008c:	880a943a 	slli	r5,r17,16
80130090:	e008d43a 	srli	r4,fp,16
80130094:	a885383a 	mul	r2,r21,r2
80130098:	84a8983a 	sll	r20,r16,r18
8013009c:	2148b03a 	or	r4,r4,r5
801300a0:	2080042e 	bgeu	r4,r2,801300b4 <__umoddi3+0x484>
801300a4:	24c9883a 	add	r4,r4,r19
801300a8:	24c00236 	bltu	r4,r19,801300b4 <__umoddi3+0x484>
801300ac:	2080012e 	bgeu	r4,r2,801300b4 <__umoddi3+0x484>
801300b0:	24c9883a 	add	r4,r4,r19
801300b4:	20a3c83a 	sub	r17,r4,r2
801300b8:	b00b883a 	mov	r5,r22
801300bc:	8809883a 	mov	r4,r17
801300c0:	01302cc0 	call	801302cc <__umodsi3>
801300c4:	102f883a 	mov	r23,r2
801300c8:	8809883a 	mov	r4,r17
801300cc:	b00b883a 	mov	r5,r22
801300d0:	01302680 	call	80130268 <__udivsi3>
801300d4:	b82e943a 	slli	r23,r23,16
801300d8:	a885383a 	mul	r2,r21,r2
801300dc:	e13fffcc 	andi	r4,fp,65535
801300e0:	25c8b03a 	or	r4,r4,r23
801300e4:	2080042e 	bgeu	r4,r2,801300f8 <__umoddi3+0x4c8>
801300e8:	24c9883a 	add	r4,r4,r19
801300ec:	24c00236 	bltu	r4,r19,801300f8 <__umoddi3+0x4c8>
801300f0:	2080012e 	bgeu	r4,r2,801300f8 <__umoddi3+0x4c8>
801300f4:	24c9883a 	add	r4,r4,r19
801300f8:	20a3c83a 	sub	r17,r4,r2
801300fc:	003f4806 	br	8012fe20 <__reset+0xfa10fe20>
80130100:	2c8fc83a 	sub	r7,r5,r18
80130104:	1545c83a 	sub	r2,r2,r21
80130108:	29cb803a 	cmpltu	r5,r5,r7
8013010c:	1145c83a 	sub	r2,r2,r5
80130110:	4089c83a 	sub	r4,r8,r2
80130114:	003fc706 	br	80130034 <__reset+0xfa110034>
80130118:	01000604 	movi	r4,24
8013011c:	003f1806 	br	8012fd80 <__reset+0xfa10fd80>
80130120:	00800604 	movi	r2,24
80130124:	003f3206 	br	8012fdf0 <__reset+0xfa10fdf0>
80130128:	01000604 	movi	r4,24
8013012c:	003ed906 	br	8012fc94 <__reset+0xfa10fc94>
80130130:	413fa52e 	bgeu	r8,r4,8012ffc8 <__reset+0xfa10ffc8>
80130134:	297fff84 	addi	r5,r5,-2
80130138:	4551883a 	add	r8,r8,r21
8013013c:	003fa306 	br	8012ffcc <__reset+0xfa10ffcc>
80130140:	15ff8b2e 	bgeu	r2,r23,8012ff70 <__reset+0xfa10ff70>
80130144:	31bfff84 	addi	r6,r6,-2
80130148:	1545883a 	add	r2,r2,r21
8013014c:	003f8906 	br	8012ff74 <__reset+0xfa10ff74>
80130150:	24c9883a 	add	r4,r4,r19
80130154:	003eee06 	br	8012fd10 <__reset+0xfa10fd10>
80130158:	8005883a 	mov	r2,r16
8013015c:	003f1706 	br	8012fdbc <__reset+0xfa10fdbc>
80130160:	817fe736 	bltu	r16,r5,80130100 <__reset+0xfa110100>
80130164:	280f883a 	mov	r7,r5
80130168:	0009883a 	mov	r4,zero
8013016c:	003fb106 	br	80130034 <__reset+0xfa110034>

80130170 <__divsi3>:
80130170:	20001b16 	blt	r4,zero,801301e0 <__divsi3+0x70>
80130174:	000f883a 	mov	r7,zero
80130178:	28001616 	blt	r5,zero,801301d4 <__divsi3+0x64>
8013017c:	200d883a 	mov	r6,r4
80130180:	29001a2e 	bgeu	r5,r4,801301ec <__divsi3+0x7c>
80130184:	00800804 	movi	r2,32
80130188:	00c00044 	movi	r3,1
8013018c:	00000106 	br	80130194 <__divsi3+0x24>
80130190:	10000d26 	beq	r2,zero,801301c8 <__divsi3+0x58>
80130194:	294b883a 	add	r5,r5,r5
80130198:	10bfffc4 	addi	r2,r2,-1
8013019c:	18c7883a 	add	r3,r3,r3
801301a0:	293ffb36 	bltu	r5,r4,80130190 <__reset+0xfa110190>
801301a4:	0005883a 	mov	r2,zero
801301a8:	18000726 	beq	r3,zero,801301c8 <__divsi3+0x58>
801301ac:	0005883a 	mov	r2,zero
801301b0:	31400236 	bltu	r6,r5,801301bc <__divsi3+0x4c>
801301b4:	314dc83a 	sub	r6,r6,r5
801301b8:	10c4b03a 	or	r2,r2,r3
801301bc:	1806d07a 	srli	r3,r3,1
801301c0:	280ad07a 	srli	r5,r5,1
801301c4:	183ffa1e 	bne	r3,zero,801301b0 <__reset+0xfa1101b0>
801301c8:	38000126 	beq	r7,zero,801301d0 <__divsi3+0x60>
801301cc:	0085c83a 	sub	r2,zero,r2
801301d0:	f800283a 	ret
801301d4:	014bc83a 	sub	r5,zero,r5
801301d8:	39c0005c 	xori	r7,r7,1
801301dc:	003fe706 	br	8013017c <__reset+0xfa11017c>
801301e0:	0109c83a 	sub	r4,zero,r4
801301e4:	01c00044 	movi	r7,1
801301e8:	003fe306 	br	80130178 <__reset+0xfa110178>
801301ec:	00c00044 	movi	r3,1
801301f0:	003fee06 	br	801301ac <__reset+0xfa1101ac>

801301f4 <__modsi3>:
801301f4:	20001716 	blt	r4,zero,80130254 <__modsi3+0x60>
801301f8:	000f883a 	mov	r7,zero
801301fc:	2005883a 	mov	r2,r4
80130200:	28001216 	blt	r5,zero,8013024c <__modsi3+0x58>
80130204:	2900162e 	bgeu	r5,r4,80130260 <__modsi3+0x6c>
80130208:	01800804 	movi	r6,32
8013020c:	00c00044 	movi	r3,1
80130210:	00000106 	br	80130218 <__modsi3+0x24>
80130214:	30000a26 	beq	r6,zero,80130240 <__modsi3+0x4c>
80130218:	294b883a 	add	r5,r5,r5
8013021c:	31bfffc4 	addi	r6,r6,-1
80130220:	18c7883a 	add	r3,r3,r3
80130224:	293ffb36 	bltu	r5,r4,80130214 <__reset+0xfa110214>
80130228:	18000526 	beq	r3,zero,80130240 <__modsi3+0x4c>
8013022c:	1806d07a 	srli	r3,r3,1
80130230:	11400136 	bltu	r2,r5,80130238 <__modsi3+0x44>
80130234:	1145c83a 	sub	r2,r2,r5
80130238:	280ad07a 	srli	r5,r5,1
8013023c:	183ffb1e 	bne	r3,zero,8013022c <__reset+0xfa11022c>
80130240:	38000126 	beq	r7,zero,80130248 <__modsi3+0x54>
80130244:	0085c83a 	sub	r2,zero,r2
80130248:	f800283a 	ret
8013024c:	014bc83a 	sub	r5,zero,r5
80130250:	003fec06 	br	80130204 <__reset+0xfa110204>
80130254:	0109c83a 	sub	r4,zero,r4
80130258:	01c00044 	movi	r7,1
8013025c:	003fe706 	br	801301fc <__reset+0xfa1101fc>
80130260:	00c00044 	movi	r3,1
80130264:	003ff106 	br	8013022c <__reset+0xfa11022c>

80130268 <__udivsi3>:
80130268:	200d883a 	mov	r6,r4
8013026c:	2900152e 	bgeu	r5,r4,801302c4 <__udivsi3+0x5c>
80130270:	28001416 	blt	r5,zero,801302c4 <__udivsi3+0x5c>
80130274:	00800804 	movi	r2,32
80130278:	00c00044 	movi	r3,1
8013027c:	00000206 	br	80130288 <__udivsi3+0x20>
80130280:	10000e26 	beq	r2,zero,801302bc <__udivsi3+0x54>
80130284:	28000516 	blt	r5,zero,8013029c <__udivsi3+0x34>
80130288:	294b883a 	add	r5,r5,r5
8013028c:	10bfffc4 	addi	r2,r2,-1
80130290:	18c7883a 	add	r3,r3,r3
80130294:	293ffa36 	bltu	r5,r4,80130280 <__reset+0xfa110280>
80130298:	18000826 	beq	r3,zero,801302bc <__udivsi3+0x54>
8013029c:	0005883a 	mov	r2,zero
801302a0:	31400236 	bltu	r6,r5,801302ac <__udivsi3+0x44>
801302a4:	314dc83a 	sub	r6,r6,r5
801302a8:	10c4b03a 	or	r2,r2,r3
801302ac:	1806d07a 	srli	r3,r3,1
801302b0:	280ad07a 	srli	r5,r5,1
801302b4:	183ffa1e 	bne	r3,zero,801302a0 <__reset+0xfa1102a0>
801302b8:	f800283a 	ret
801302bc:	0005883a 	mov	r2,zero
801302c0:	f800283a 	ret
801302c4:	00c00044 	movi	r3,1
801302c8:	003ff406 	br	8013029c <__reset+0xfa11029c>

801302cc <__umodsi3>:
801302cc:	2005883a 	mov	r2,r4
801302d0:	2900122e 	bgeu	r5,r4,8013031c <__umodsi3+0x50>
801302d4:	28001116 	blt	r5,zero,8013031c <__umodsi3+0x50>
801302d8:	01800804 	movi	r6,32
801302dc:	00c00044 	movi	r3,1
801302e0:	00000206 	br	801302ec <__umodsi3+0x20>
801302e4:	30000c26 	beq	r6,zero,80130318 <__umodsi3+0x4c>
801302e8:	28000516 	blt	r5,zero,80130300 <__umodsi3+0x34>
801302ec:	294b883a 	add	r5,r5,r5
801302f0:	31bfffc4 	addi	r6,r6,-1
801302f4:	18c7883a 	add	r3,r3,r3
801302f8:	293ffa36 	bltu	r5,r4,801302e4 <__reset+0xfa1102e4>
801302fc:	18000626 	beq	r3,zero,80130318 <__umodsi3+0x4c>
80130300:	1806d07a 	srli	r3,r3,1
80130304:	11400136 	bltu	r2,r5,8013030c <__umodsi3+0x40>
80130308:	1145c83a 	sub	r2,r2,r5
8013030c:	280ad07a 	srli	r5,r5,1
80130310:	183ffb1e 	bne	r3,zero,80130300 <__reset+0xfa110300>
80130314:	f800283a 	ret
80130318:	f800283a 	ret
8013031c:	00c00044 	movi	r3,1
80130320:	003ff706 	br	80130300 <__reset+0xfa110300>

80130324 <__eqsf2>:
80130324:	2006d5fa 	srli	r3,r4,23
80130328:	280cd5fa 	srli	r6,r5,23
8013032c:	01c02034 	movhi	r7,128
80130330:	39ffffc4 	addi	r7,r7,-1
80130334:	18c03fcc 	andi	r3,r3,255
80130338:	02003fc4 	movi	r8,255
8013033c:	3904703a 	and	r2,r7,r4
80130340:	31803fcc 	andi	r6,r6,255
80130344:	394e703a 	and	r7,r7,r5
80130348:	2008d7fa 	srli	r4,r4,31
8013034c:	280ad7fa 	srli	r5,r5,31
80130350:	1a000d26 	beq	r3,r8,80130388 <__eqsf2+0x64>
80130354:	02003fc4 	movi	r8,255
80130358:	32000826 	beq	r6,r8,8013037c <__eqsf2+0x58>
8013035c:	19800226 	beq	r3,r6,80130368 <__eqsf2+0x44>
80130360:	00800044 	movi	r2,1
80130364:	f800283a 	ret
80130368:	11fffd1e 	bne	r2,r7,80130360 <__reset+0xfa110360>
8013036c:	21400926 	beq	r4,r5,80130394 <__eqsf2+0x70>
80130370:	183ffb1e 	bne	r3,zero,80130360 <__reset+0xfa110360>
80130374:	1004c03a 	cmpne	r2,r2,zero
80130378:	f800283a 	ret
8013037c:	383ff726 	beq	r7,zero,8013035c <__reset+0xfa11035c>
80130380:	00800044 	movi	r2,1
80130384:	f800283a 	ret
80130388:	103ff226 	beq	r2,zero,80130354 <__reset+0xfa110354>
8013038c:	00800044 	movi	r2,1
80130390:	f800283a 	ret
80130394:	0005883a 	mov	r2,zero
80130398:	f800283a 	ret

8013039c <__gesf2>:
8013039c:	2004d5fa 	srli	r2,r4,23
801303a0:	2806d5fa 	srli	r3,r5,23
801303a4:	01802034 	movhi	r6,128
801303a8:	31bfffc4 	addi	r6,r6,-1
801303ac:	10803fcc 	andi	r2,r2,255
801303b0:	01c03fc4 	movi	r7,255
801303b4:	3110703a 	and	r8,r6,r4
801303b8:	18c03fcc 	andi	r3,r3,255
801303bc:	314c703a 	and	r6,r6,r5
801303c0:	2008d7fa 	srli	r4,r4,31
801303c4:	280ad7fa 	srli	r5,r5,31
801303c8:	11c01926 	beq	r2,r7,80130430 <__gesf2+0x94>
801303cc:	01c03fc4 	movi	r7,255
801303d0:	19c00f26 	beq	r3,r7,80130410 <__gesf2+0x74>
801303d4:	1000061e 	bne	r2,zero,801303f0 <__gesf2+0x54>
801303d8:	400f003a 	cmpeq	r7,r8,zero
801303dc:	1800071e 	bne	r3,zero,801303fc <__gesf2+0x60>
801303e0:	3000061e 	bne	r6,zero,801303fc <__gesf2+0x60>
801303e4:	0005883a 	mov	r2,zero
801303e8:	40000e1e 	bne	r8,zero,80130424 <__gesf2+0x88>
801303ec:	f800283a 	ret
801303f0:	18000a1e 	bne	r3,zero,8013041c <__gesf2+0x80>
801303f4:	30000b26 	beq	r6,zero,80130424 <__gesf2+0x88>
801303f8:	000f883a 	mov	r7,zero
801303fc:	29403fcc 	andi	r5,r5,255
80130400:	38000726 	beq	r7,zero,80130420 <__gesf2+0x84>
80130404:	28000826 	beq	r5,zero,80130428 <__gesf2+0x8c>
80130408:	00800044 	movi	r2,1
8013040c:	f800283a 	ret
80130410:	303ff026 	beq	r6,zero,801303d4 <__reset+0xfa1103d4>
80130414:	00bfff84 	movi	r2,-2
80130418:	f800283a 	ret
8013041c:	29403fcc 	andi	r5,r5,255
80130420:	21400526 	beq	r4,r5,80130438 <__gesf2+0x9c>
80130424:	203ff826 	beq	r4,zero,80130408 <__reset+0xfa110408>
80130428:	00bfffc4 	movi	r2,-1
8013042c:	f800283a 	ret
80130430:	403fe626 	beq	r8,zero,801303cc <__reset+0xfa1103cc>
80130434:	003ff706 	br	80130414 <__reset+0xfa110414>
80130438:	18bffa16 	blt	r3,r2,80130424 <__reset+0xfa110424>
8013043c:	10c00216 	blt	r2,r3,80130448 <__gesf2+0xac>
80130440:	323ff836 	bltu	r6,r8,80130424 <__reset+0xfa110424>
80130444:	4180022e 	bgeu	r8,r6,80130450 <__gesf2+0xb4>
80130448:	203fef1e 	bne	r4,zero,80130408 <__reset+0xfa110408>
8013044c:	003ff606 	br	80130428 <__reset+0xfa110428>
80130450:	0005883a 	mov	r2,zero
80130454:	f800283a 	ret

80130458 <__lesf2>:
80130458:	2004d5fa 	srli	r2,r4,23
8013045c:	280cd5fa 	srli	r6,r5,23
80130460:	00c02034 	movhi	r3,128
80130464:	18ffffc4 	addi	r3,r3,-1
80130468:	10803fcc 	andi	r2,r2,255
8013046c:	01c03fc4 	movi	r7,255
80130470:	1910703a 	and	r8,r3,r4
80130474:	31803fcc 	andi	r6,r6,255
80130478:	1946703a 	and	r3,r3,r5
8013047c:	2008d7fa 	srli	r4,r4,31
80130480:	280ad7fa 	srli	r5,r5,31
80130484:	11c01b26 	beq	r2,r7,801304f4 <__lesf2+0x9c>
80130488:	01c03fc4 	movi	r7,255
8013048c:	31c01126 	beq	r6,r7,801304d4 <__lesf2+0x7c>
80130490:	1000071e 	bne	r2,zero,801304b0 <__lesf2+0x58>
80130494:	400f003a 	cmpeq	r7,r8,zero
80130498:	21003fcc 	andi	r4,r4,255
8013049c:	3000081e 	bne	r6,zero,801304c0 <__lesf2+0x68>
801304a0:	1800071e 	bne	r3,zero,801304c0 <__lesf2+0x68>
801304a4:	0005883a 	mov	r2,zero
801304a8:	40000f1e 	bne	r8,zero,801304e8 <__lesf2+0x90>
801304ac:	f800283a 	ret
801304b0:	21003fcc 	andi	r4,r4,255
801304b4:	30000a1e 	bne	r6,zero,801304e0 <__lesf2+0x88>
801304b8:	18000b26 	beq	r3,zero,801304e8 <__lesf2+0x90>
801304bc:	000f883a 	mov	r7,zero
801304c0:	29403fcc 	andi	r5,r5,255
801304c4:	38000726 	beq	r7,zero,801304e4 <__lesf2+0x8c>
801304c8:	28000826 	beq	r5,zero,801304ec <__lesf2+0x94>
801304cc:	00800044 	movi	r2,1
801304d0:	f800283a 	ret
801304d4:	183fee26 	beq	r3,zero,80130490 <__reset+0xfa110490>
801304d8:	00800084 	movi	r2,2
801304dc:	f800283a 	ret
801304e0:	29403fcc 	andi	r5,r5,255
801304e4:	21400626 	beq	r4,r5,80130500 <__lesf2+0xa8>
801304e8:	203ff826 	beq	r4,zero,801304cc <__reset+0xfa1104cc>
801304ec:	00bfffc4 	movi	r2,-1
801304f0:	f800283a 	ret
801304f4:	403fe426 	beq	r8,zero,80130488 <__reset+0xfa110488>
801304f8:	00800084 	movi	r2,2
801304fc:	f800283a 	ret
80130500:	30bff916 	blt	r6,r2,801304e8 <__reset+0xfa1104e8>
80130504:	11800216 	blt	r2,r6,80130510 <__lesf2+0xb8>
80130508:	1a3ff736 	bltu	r3,r8,801304e8 <__reset+0xfa1104e8>
8013050c:	40c0022e 	bgeu	r8,r3,80130518 <__lesf2+0xc0>
80130510:	203fee1e 	bne	r4,zero,801304cc <__reset+0xfa1104cc>
80130514:	003ff506 	br	801304ec <__reset+0xfa1104ec>
80130518:	0005883a 	mov	r2,zero
8013051c:	f800283a 	ret

80130520 <__adddf3>:
80130520:	02c00434 	movhi	r11,16
80130524:	5affffc4 	addi	r11,r11,-1
80130528:	2806d7fa 	srli	r3,r5,31
8013052c:	2ad4703a 	and	r10,r5,r11
80130530:	3ad2703a 	and	r9,r7,r11
80130534:	3804d53a 	srli	r2,r7,20
80130538:	3018d77a 	srli	r12,r6,29
8013053c:	280ad53a 	srli	r5,r5,20
80130540:	501490fa 	slli	r10,r10,3
80130544:	2010d77a 	srli	r8,r4,29
80130548:	481290fa 	slli	r9,r9,3
8013054c:	380ed7fa 	srli	r7,r7,31
80130550:	defffb04 	addi	sp,sp,-20
80130554:	de00012e 	bgeu	sp,et,8013055c <__adddf3+0x3c>
80130558:	003b68fa 	trap	3
8013055c:	dc800215 	stw	r18,8(sp)
80130560:	dc400115 	stw	r17,4(sp)
80130564:	dc000015 	stw	r16,0(sp)
80130568:	dfc00415 	stw	ra,16(sp)
8013056c:	dcc00315 	stw	r19,12(sp)
80130570:	1c803fcc 	andi	r18,r3,255
80130574:	2c01ffcc 	andi	r16,r5,2047
80130578:	5210b03a 	or	r8,r10,r8
8013057c:	202290fa 	slli	r17,r4,3
80130580:	1081ffcc 	andi	r2,r2,2047
80130584:	4b12b03a 	or	r9,r9,r12
80130588:	300c90fa 	slli	r6,r6,3
8013058c:	91c07526 	beq	r18,r7,80130764 <__adddf3+0x244>
80130590:	8087c83a 	sub	r3,r16,r2
80130594:	00c0ab0e 	bge	zero,r3,80130844 <__adddf3+0x324>
80130598:	10002a1e 	bne	r2,zero,80130644 <__adddf3+0x124>
8013059c:	4984b03a 	or	r2,r9,r6
801305a0:	1000961e 	bne	r2,zero,801307fc <__adddf3+0x2dc>
801305a4:	888001cc 	andi	r2,r17,7
801305a8:	10000726 	beq	r2,zero,801305c8 <__adddf3+0xa8>
801305ac:	888003cc 	andi	r2,r17,15
801305b0:	00c00104 	movi	r3,4
801305b4:	10c00426 	beq	r2,r3,801305c8 <__adddf3+0xa8>
801305b8:	88c7883a 	add	r3,r17,r3
801305bc:	1c63803a 	cmpltu	r17,r3,r17
801305c0:	4451883a 	add	r8,r8,r17
801305c4:	1823883a 	mov	r17,r3
801305c8:	4080202c 	andhi	r2,r8,128
801305cc:	10005926 	beq	r2,zero,80130734 <__adddf3+0x214>
801305d0:	84000044 	addi	r16,r16,1
801305d4:	0081ffc4 	movi	r2,2047
801305d8:	8080ba26 	beq	r16,r2,801308c4 <__adddf3+0x3a4>
801305dc:	00bfe034 	movhi	r2,65408
801305e0:	10bfffc4 	addi	r2,r2,-1
801305e4:	4090703a 	and	r8,r8,r2
801305e8:	4004977a 	slli	r2,r8,29
801305ec:	4010927a 	slli	r8,r8,9
801305f0:	8822d0fa 	srli	r17,r17,3
801305f4:	8401ffcc 	andi	r16,r16,2047
801305f8:	4010d33a 	srli	r8,r8,12
801305fc:	9007883a 	mov	r3,r18
80130600:	1444b03a 	or	r2,r2,r17
80130604:	8401ffcc 	andi	r16,r16,2047
80130608:	8020953a 	slli	r16,r16,20
8013060c:	18c03fcc 	andi	r3,r3,255
80130610:	01000434 	movhi	r4,16
80130614:	213fffc4 	addi	r4,r4,-1
80130618:	180697fa 	slli	r3,r3,31
8013061c:	4110703a 	and	r8,r8,r4
80130620:	4410b03a 	or	r8,r8,r16
80130624:	40c6b03a 	or	r3,r8,r3
80130628:	dfc00417 	ldw	ra,16(sp)
8013062c:	dcc00317 	ldw	r19,12(sp)
80130630:	dc800217 	ldw	r18,8(sp)
80130634:	dc400117 	ldw	r17,4(sp)
80130638:	dc000017 	ldw	r16,0(sp)
8013063c:	dec00504 	addi	sp,sp,20
80130640:	f800283a 	ret
80130644:	0081ffc4 	movi	r2,2047
80130648:	80bfd626 	beq	r16,r2,801305a4 <__reset+0xfa1105a4>
8013064c:	4a402034 	orhi	r9,r9,128
80130650:	00800e04 	movi	r2,56
80130654:	10c09f16 	blt	r2,r3,801308d4 <__adddf3+0x3b4>
80130658:	008007c4 	movi	r2,31
8013065c:	10c0c216 	blt	r2,r3,80130968 <__adddf3+0x448>
80130660:	00800804 	movi	r2,32
80130664:	10c5c83a 	sub	r2,r2,r3
80130668:	488a983a 	sll	r5,r9,r2
8013066c:	30c8d83a 	srl	r4,r6,r3
80130670:	3084983a 	sll	r2,r6,r2
80130674:	48c6d83a 	srl	r3,r9,r3
80130678:	290cb03a 	or	r6,r5,r4
8013067c:	1004c03a 	cmpne	r2,r2,zero
80130680:	308cb03a 	or	r6,r6,r2
80130684:	898dc83a 	sub	r6,r17,r6
80130688:	89a3803a 	cmpltu	r17,r17,r6
8013068c:	40d1c83a 	sub	r8,r8,r3
80130690:	4451c83a 	sub	r8,r8,r17
80130694:	3023883a 	mov	r17,r6
80130698:	4080202c 	andhi	r2,r8,128
8013069c:	10002326 	beq	r2,zero,8013072c <__adddf3+0x20c>
801306a0:	04c02034 	movhi	r19,128
801306a4:	9cffffc4 	addi	r19,r19,-1
801306a8:	44e6703a 	and	r19,r8,r19
801306ac:	98007626 	beq	r19,zero,80130888 <__adddf3+0x368>
801306b0:	9809883a 	mov	r4,r19
801306b4:	01213d00 	call	801213d0 <__clzsi2>
801306b8:	10fffe04 	addi	r3,r2,-8
801306bc:	010007c4 	movi	r4,31
801306c0:	20c07716 	blt	r4,r3,801308a0 <__adddf3+0x380>
801306c4:	00800804 	movi	r2,32
801306c8:	10c5c83a 	sub	r2,r2,r3
801306cc:	8884d83a 	srl	r2,r17,r2
801306d0:	98d0983a 	sll	r8,r19,r3
801306d4:	88e2983a 	sll	r17,r17,r3
801306d8:	1204b03a 	or	r2,r2,r8
801306dc:	1c007416 	blt	r3,r16,801308b0 <__adddf3+0x390>
801306e0:	1c21c83a 	sub	r16,r3,r16
801306e4:	82000044 	addi	r8,r16,1
801306e8:	00c007c4 	movi	r3,31
801306ec:	1a009116 	blt	r3,r8,80130934 <__adddf3+0x414>
801306f0:	00c00804 	movi	r3,32
801306f4:	1a07c83a 	sub	r3,r3,r8
801306f8:	8a08d83a 	srl	r4,r17,r8
801306fc:	88e2983a 	sll	r17,r17,r3
80130700:	10c6983a 	sll	r3,r2,r3
80130704:	1210d83a 	srl	r8,r2,r8
80130708:	8804c03a 	cmpne	r2,r17,zero
8013070c:	1906b03a 	or	r3,r3,r4
80130710:	18a2b03a 	or	r17,r3,r2
80130714:	0021883a 	mov	r16,zero
80130718:	003fa206 	br	801305a4 <__reset+0xfa1105a4>
8013071c:	1890b03a 	or	r8,r3,r2
80130720:	40017d26 	beq	r8,zero,80130d18 <__adddf3+0x7f8>
80130724:	1011883a 	mov	r8,r2
80130728:	1823883a 	mov	r17,r3
8013072c:	888001cc 	andi	r2,r17,7
80130730:	103f9e1e 	bne	r2,zero,801305ac <__reset+0xfa1105ac>
80130734:	4004977a 	slli	r2,r8,29
80130738:	8822d0fa 	srli	r17,r17,3
8013073c:	4010d0fa 	srli	r8,r8,3
80130740:	9007883a 	mov	r3,r18
80130744:	1444b03a 	or	r2,r2,r17
80130748:	0101ffc4 	movi	r4,2047
8013074c:	81002426 	beq	r16,r4,801307e0 <__adddf3+0x2c0>
80130750:	8120703a 	and	r16,r16,r4
80130754:	01000434 	movhi	r4,16
80130758:	213fffc4 	addi	r4,r4,-1
8013075c:	4110703a 	and	r8,r8,r4
80130760:	003fa806 	br	80130604 <__reset+0xfa110604>
80130764:	8089c83a 	sub	r4,r16,r2
80130768:	01005e0e 	bge	zero,r4,801308e4 <__adddf3+0x3c4>
8013076c:	10002b26 	beq	r2,zero,8013081c <__adddf3+0x2fc>
80130770:	0081ffc4 	movi	r2,2047
80130774:	80bf8b26 	beq	r16,r2,801305a4 <__reset+0xfa1105a4>
80130778:	4a402034 	orhi	r9,r9,128
8013077c:	00800e04 	movi	r2,56
80130780:	1100a40e 	bge	r2,r4,80130a14 <__adddf3+0x4f4>
80130784:	498cb03a 	or	r6,r9,r6
80130788:	300ac03a 	cmpne	r5,r6,zero
8013078c:	0013883a 	mov	r9,zero
80130790:	2c4b883a 	add	r5,r5,r17
80130794:	2c63803a 	cmpltu	r17,r5,r17
80130798:	4a11883a 	add	r8,r9,r8
8013079c:	8a11883a 	add	r8,r17,r8
801307a0:	2823883a 	mov	r17,r5
801307a4:	4080202c 	andhi	r2,r8,128
801307a8:	103fe026 	beq	r2,zero,8013072c <__reset+0xfa11072c>
801307ac:	84000044 	addi	r16,r16,1
801307b0:	0081ffc4 	movi	r2,2047
801307b4:	8080d226 	beq	r16,r2,80130b00 <__adddf3+0x5e0>
801307b8:	00bfe034 	movhi	r2,65408
801307bc:	10bfffc4 	addi	r2,r2,-1
801307c0:	4090703a 	and	r8,r8,r2
801307c4:	880ad07a 	srli	r5,r17,1
801307c8:	400897fa 	slli	r4,r8,31
801307cc:	88c0004c 	andi	r3,r17,1
801307d0:	28e2b03a 	or	r17,r5,r3
801307d4:	4010d07a 	srli	r8,r8,1
801307d8:	2462b03a 	or	r17,r4,r17
801307dc:	003f7106 	br	801305a4 <__reset+0xfa1105a4>
801307e0:	4088b03a 	or	r4,r8,r2
801307e4:	20014526 	beq	r4,zero,80130cfc <__adddf3+0x7dc>
801307e8:	01000434 	movhi	r4,16
801307ec:	42000234 	orhi	r8,r8,8
801307f0:	213fffc4 	addi	r4,r4,-1
801307f4:	4110703a 	and	r8,r8,r4
801307f8:	003f8206 	br	80130604 <__reset+0xfa110604>
801307fc:	18ffffc4 	addi	r3,r3,-1
80130800:	1800491e 	bne	r3,zero,80130928 <__adddf3+0x408>
80130804:	898bc83a 	sub	r5,r17,r6
80130808:	8963803a 	cmpltu	r17,r17,r5
8013080c:	4251c83a 	sub	r8,r8,r9
80130810:	4451c83a 	sub	r8,r8,r17
80130814:	2823883a 	mov	r17,r5
80130818:	003f9f06 	br	80130698 <__reset+0xfa110698>
8013081c:	4984b03a 	or	r2,r9,r6
80130820:	103f6026 	beq	r2,zero,801305a4 <__reset+0xfa1105a4>
80130824:	213fffc4 	addi	r4,r4,-1
80130828:	2000931e 	bne	r4,zero,80130a78 <__adddf3+0x558>
8013082c:	898d883a 	add	r6,r17,r6
80130830:	3463803a 	cmpltu	r17,r6,r17
80130834:	4251883a 	add	r8,r8,r9
80130838:	8a11883a 	add	r8,r17,r8
8013083c:	3023883a 	mov	r17,r6
80130840:	003fd806 	br	801307a4 <__reset+0xfa1107a4>
80130844:	1800541e 	bne	r3,zero,80130998 <__adddf3+0x478>
80130848:	80800044 	addi	r2,r16,1
8013084c:	1081ffcc 	andi	r2,r2,2047
80130850:	00c00044 	movi	r3,1
80130854:	1880a00e 	bge	r3,r2,80130ad8 <__adddf3+0x5b8>
80130858:	8989c83a 	sub	r4,r17,r6
8013085c:	8905803a 	cmpltu	r2,r17,r4
80130860:	4267c83a 	sub	r19,r8,r9
80130864:	98a7c83a 	sub	r19,r19,r2
80130868:	9880202c 	andhi	r2,r19,128
8013086c:	10006326 	beq	r2,zero,801309fc <__adddf3+0x4dc>
80130870:	3463c83a 	sub	r17,r6,r17
80130874:	4a07c83a 	sub	r3,r9,r8
80130878:	344d803a 	cmpltu	r6,r6,r17
8013087c:	19a7c83a 	sub	r19,r3,r6
80130880:	3825883a 	mov	r18,r7
80130884:	983f8a1e 	bne	r19,zero,801306b0 <__reset+0xfa1106b0>
80130888:	8809883a 	mov	r4,r17
8013088c:	01213d00 	call	801213d0 <__clzsi2>
80130890:	10800804 	addi	r2,r2,32
80130894:	10fffe04 	addi	r3,r2,-8
80130898:	010007c4 	movi	r4,31
8013089c:	20ff890e 	bge	r4,r3,801306c4 <__reset+0xfa1106c4>
801308a0:	10bff604 	addi	r2,r2,-40
801308a4:	8884983a 	sll	r2,r17,r2
801308a8:	0023883a 	mov	r17,zero
801308ac:	1c3f8c0e 	bge	r3,r16,801306e0 <__reset+0xfa1106e0>
801308b0:	023fe034 	movhi	r8,65408
801308b4:	423fffc4 	addi	r8,r8,-1
801308b8:	80e1c83a 	sub	r16,r16,r3
801308bc:	1210703a 	and	r8,r2,r8
801308c0:	003f3806 	br	801305a4 <__reset+0xfa1105a4>
801308c4:	9007883a 	mov	r3,r18
801308c8:	0011883a 	mov	r8,zero
801308cc:	0005883a 	mov	r2,zero
801308d0:	003f4c06 	br	80130604 <__reset+0xfa110604>
801308d4:	498cb03a 	or	r6,r9,r6
801308d8:	300cc03a 	cmpne	r6,r6,zero
801308dc:	0007883a 	mov	r3,zero
801308e0:	003f6806 	br	80130684 <__reset+0xfa110684>
801308e4:	20009c1e 	bne	r4,zero,80130b58 <__adddf3+0x638>
801308e8:	80800044 	addi	r2,r16,1
801308ec:	1141ffcc 	andi	r5,r2,2047
801308f0:	01000044 	movi	r4,1
801308f4:	2140670e 	bge	r4,r5,80130a94 <__adddf3+0x574>
801308f8:	0101ffc4 	movi	r4,2047
801308fc:	11007f26 	beq	r2,r4,80130afc <__adddf3+0x5dc>
80130900:	898d883a 	add	r6,r17,r6
80130904:	4247883a 	add	r3,r8,r9
80130908:	3451803a 	cmpltu	r8,r6,r17
8013090c:	40d1883a 	add	r8,r8,r3
80130910:	402297fa 	slli	r17,r8,31
80130914:	300cd07a 	srli	r6,r6,1
80130918:	4010d07a 	srli	r8,r8,1
8013091c:	1021883a 	mov	r16,r2
80130920:	89a2b03a 	or	r17,r17,r6
80130924:	003f1f06 	br	801305a4 <__reset+0xfa1105a4>
80130928:	0081ffc4 	movi	r2,2047
8013092c:	80bf481e 	bne	r16,r2,80130650 <__reset+0xfa110650>
80130930:	003f1c06 	br	801305a4 <__reset+0xfa1105a4>
80130934:	843ff844 	addi	r16,r16,-31
80130938:	01000804 	movi	r4,32
8013093c:	1406d83a 	srl	r3,r2,r16
80130940:	41005026 	beq	r8,r4,80130a84 <__adddf3+0x564>
80130944:	01001004 	movi	r4,64
80130948:	2211c83a 	sub	r8,r4,r8
8013094c:	1204983a 	sll	r2,r2,r8
80130950:	88a2b03a 	or	r17,r17,r2
80130954:	8822c03a 	cmpne	r17,r17,zero
80130958:	1c62b03a 	or	r17,r3,r17
8013095c:	0011883a 	mov	r8,zero
80130960:	0021883a 	mov	r16,zero
80130964:	003f7106 	br	8013072c <__reset+0xfa11072c>
80130968:	193ff804 	addi	r4,r3,-32
8013096c:	00800804 	movi	r2,32
80130970:	4908d83a 	srl	r4,r9,r4
80130974:	18804526 	beq	r3,r2,80130a8c <__adddf3+0x56c>
80130978:	00801004 	movi	r2,64
8013097c:	10c5c83a 	sub	r2,r2,r3
80130980:	4886983a 	sll	r3,r9,r2
80130984:	198cb03a 	or	r6,r3,r6
80130988:	300cc03a 	cmpne	r6,r6,zero
8013098c:	218cb03a 	or	r6,r4,r6
80130990:	0007883a 	mov	r3,zero
80130994:	003f3b06 	br	80130684 <__reset+0xfa110684>
80130998:	80002a26 	beq	r16,zero,80130a44 <__adddf3+0x524>
8013099c:	0101ffc4 	movi	r4,2047
801309a0:	11006826 	beq	r2,r4,80130b44 <__adddf3+0x624>
801309a4:	00c7c83a 	sub	r3,zero,r3
801309a8:	42002034 	orhi	r8,r8,128
801309ac:	01000e04 	movi	r4,56
801309b0:	20c07c16 	blt	r4,r3,80130ba4 <__adddf3+0x684>
801309b4:	010007c4 	movi	r4,31
801309b8:	20c0da16 	blt	r4,r3,80130d24 <__adddf3+0x804>
801309bc:	01000804 	movi	r4,32
801309c0:	20c9c83a 	sub	r4,r4,r3
801309c4:	4114983a 	sll	r10,r8,r4
801309c8:	88cad83a 	srl	r5,r17,r3
801309cc:	8908983a 	sll	r4,r17,r4
801309d0:	40c6d83a 	srl	r3,r8,r3
801309d4:	5162b03a 	or	r17,r10,r5
801309d8:	2008c03a 	cmpne	r4,r4,zero
801309dc:	8922b03a 	or	r17,r17,r4
801309e0:	3463c83a 	sub	r17,r6,r17
801309e4:	48c7c83a 	sub	r3,r9,r3
801309e8:	344d803a 	cmpltu	r6,r6,r17
801309ec:	1991c83a 	sub	r8,r3,r6
801309f0:	1021883a 	mov	r16,r2
801309f4:	3825883a 	mov	r18,r7
801309f8:	003f2706 	br	80130698 <__reset+0xfa110698>
801309fc:	24d0b03a 	or	r8,r4,r19
80130a00:	40001b1e 	bne	r8,zero,80130a70 <__adddf3+0x550>
80130a04:	0005883a 	mov	r2,zero
80130a08:	0007883a 	mov	r3,zero
80130a0c:	0021883a 	mov	r16,zero
80130a10:	003f4d06 	br	80130748 <__reset+0xfa110748>
80130a14:	008007c4 	movi	r2,31
80130a18:	11003c16 	blt	r2,r4,80130b0c <__adddf3+0x5ec>
80130a1c:	00800804 	movi	r2,32
80130a20:	1105c83a 	sub	r2,r2,r4
80130a24:	488e983a 	sll	r7,r9,r2
80130a28:	310ad83a 	srl	r5,r6,r4
80130a2c:	3084983a 	sll	r2,r6,r2
80130a30:	4912d83a 	srl	r9,r9,r4
80130a34:	394ab03a 	or	r5,r7,r5
80130a38:	1004c03a 	cmpne	r2,r2,zero
80130a3c:	288ab03a 	or	r5,r5,r2
80130a40:	003f5306 	br	80130790 <__reset+0xfa110790>
80130a44:	4448b03a 	or	r4,r8,r17
80130a48:	20003e26 	beq	r4,zero,80130b44 <__adddf3+0x624>
80130a4c:	00c6303a 	nor	r3,zero,r3
80130a50:	18003a1e 	bne	r3,zero,80130b3c <__adddf3+0x61c>
80130a54:	3463c83a 	sub	r17,r6,r17
80130a58:	4a07c83a 	sub	r3,r9,r8
80130a5c:	344d803a 	cmpltu	r6,r6,r17
80130a60:	1991c83a 	sub	r8,r3,r6
80130a64:	1021883a 	mov	r16,r2
80130a68:	3825883a 	mov	r18,r7
80130a6c:	003f0a06 	br	80130698 <__reset+0xfa110698>
80130a70:	2023883a 	mov	r17,r4
80130a74:	003f0d06 	br	801306ac <__reset+0xfa1106ac>
80130a78:	0081ffc4 	movi	r2,2047
80130a7c:	80bf3f1e 	bne	r16,r2,8013077c <__reset+0xfa11077c>
80130a80:	003ec806 	br	801305a4 <__reset+0xfa1105a4>
80130a84:	0005883a 	mov	r2,zero
80130a88:	003fb106 	br	80130950 <__reset+0xfa110950>
80130a8c:	0007883a 	mov	r3,zero
80130a90:	003fbc06 	br	80130984 <__reset+0xfa110984>
80130a94:	4444b03a 	or	r2,r8,r17
80130a98:	8000871e 	bne	r16,zero,80130cb8 <__adddf3+0x798>
80130a9c:	1000ba26 	beq	r2,zero,80130d88 <__adddf3+0x868>
80130aa0:	4984b03a 	or	r2,r9,r6
80130aa4:	103ebf26 	beq	r2,zero,801305a4 <__reset+0xfa1105a4>
80130aa8:	8985883a 	add	r2,r17,r6
80130aac:	4247883a 	add	r3,r8,r9
80130ab0:	1451803a 	cmpltu	r8,r2,r17
80130ab4:	40d1883a 	add	r8,r8,r3
80130ab8:	40c0202c 	andhi	r3,r8,128
80130abc:	1023883a 	mov	r17,r2
80130ac0:	183f1a26 	beq	r3,zero,8013072c <__reset+0xfa11072c>
80130ac4:	00bfe034 	movhi	r2,65408
80130ac8:	10bfffc4 	addi	r2,r2,-1
80130acc:	2021883a 	mov	r16,r4
80130ad0:	4090703a 	and	r8,r8,r2
80130ad4:	003eb306 	br	801305a4 <__reset+0xfa1105a4>
80130ad8:	4444b03a 	or	r2,r8,r17
80130adc:	8000291e 	bne	r16,zero,80130b84 <__adddf3+0x664>
80130ae0:	10004b1e 	bne	r2,zero,80130c10 <__adddf3+0x6f0>
80130ae4:	4990b03a 	or	r8,r9,r6
80130ae8:	40008b26 	beq	r8,zero,80130d18 <__adddf3+0x7f8>
80130aec:	4811883a 	mov	r8,r9
80130af0:	3023883a 	mov	r17,r6
80130af4:	3825883a 	mov	r18,r7
80130af8:	003eaa06 	br	801305a4 <__reset+0xfa1105a4>
80130afc:	1021883a 	mov	r16,r2
80130b00:	0011883a 	mov	r8,zero
80130b04:	0005883a 	mov	r2,zero
80130b08:	003f0f06 	br	80130748 <__reset+0xfa110748>
80130b0c:	217ff804 	addi	r5,r4,-32
80130b10:	00800804 	movi	r2,32
80130b14:	494ad83a 	srl	r5,r9,r5
80130b18:	20807d26 	beq	r4,r2,80130d10 <__adddf3+0x7f0>
80130b1c:	00801004 	movi	r2,64
80130b20:	1109c83a 	sub	r4,r2,r4
80130b24:	4912983a 	sll	r9,r9,r4
80130b28:	498cb03a 	or	r6,r9,r6
80130b2c:	300cc03a 	cmpne	r6,r6,zero
80130b30:	298ab03a 	or	r5,r5,r6
80130b34:	0013883a 	mov	r9,zero
80130b38:	003f1506 	br	80130790 <__reset+0xfa110790>
80130b3c:	0101ffc4 	movi	r4,2047
80130b40:	113f9a1e 	bne	r2,r4,801309ac <__reset+0xfa1109ac>
80130b44:	4811883a 	mov	r8,r9
80130b48:	3023883a 	mov	r17,r6
80130b4c:	1021883a 	mov	r16,r2
80130b50:	3825883a 	mov	r18,r7
80130b54:	003e9306 	br	801305a4 <__reset+0xfa1105a4>
80130b58:	8000161e 	bne	r16,zero,80130bb4 <__adddf3+0x694>
80130b5c:	444ab03a 	or	r5,r8,r17
80130b60:	28005126 	beq	r5,zero,80130ca8 <__adddf3+0x788>
80130b64:	0108303a 	nor	r4,zero,r4
80130b68:	20004d1e 	bne	r4,zero,80130ca0 <__adddf3+0x780>
80130b6c:	89a3883a 	add	r17,r17,r6
80130b70:	4253883a 	add	r9,r8,r9
80130b74:	898d803a 	cmpltu	r6,r17,r6
80130b78:	3251883a 	add	r8,r6,r9
80130b7c:	1021883a 	mov	r16,r2
80130b80:	003f0806 	br	801307a4 <__reset+0xfa1107a4>
80130b84:	1000301e 	bne	r2,zero,80130c48 <__adddf3+0x728>
80130b88:	4984b03a 	or	r2,r9,r6
80130b8c:	10007126 	beq	r2,zero,80130d54 <__adddf3+0x834>
80130b90:	4811883a 	mov	r8,r9
80130b94:	3023883a 	mov	r17,r6
80130b98:	3825883a 	mov	r18,r7
80130b9c:	0401ffc4 	movi	r16,2047
80130ba0:	003e8006 	br	801305a4 <__reset+0xfa1105a4>
80130ba4:	4462b03a 	or	r17,r8,r17
80130ba8:	8822c03a 	cmpne	r17,r17,zero
80130bac:	0007883a 	mov	r3,zero
80130bb0:	003f8b06 	br	801309e0 <__reset+0xfa1109e0>
80130bb4:	0141ffc4 	movi	r5,2047
80130bb8:	11403b26 	beq	r2,r5,80130ca8 <__adddf3+0x788>
80130bbc:	0109c83a 	sub	r4,zero,r4
80130bc0:	42002034 	orhi	r8,r8,128
80130bc4:	01400e04 	movi	r5,56
80130bc8:	29006716 	blt	r5,r4,80130d68 <__adddf3+0x848>
80130bcc:	014007c4 	movi	r5,31
80130bd0:	29007016 	blt	r5,r4,80130d94 <__adddf3+0x874>
80130bd4:	01400804 	movi	r5,32
80130bd8:	290bc83a 	sub	r5,r5,r4
80130bdc:	4154983a 	sll	r10,r8,r5
80130be0:	890ed83a 	srl	r7,r17,r4
80130be4:	894a983a 	sll	r5,r17,r5
80130be8:	4108d83a 	srl	r4,r8,r4
80130bec:	51e2b03a 	or	r17,r10,r7
80130bf0:	280ac03a 	cmpne	r5,r5,zero
80130bf4:	8962b03a 	or	r17,r17,r5
80130bf8:	89a3883a 	add	r17,r17,r6
80130bfc:	2253883a 	add	r9,r4,r9
80130c00:	898d803a 	cmpltu	r6,r17,r6
80130c04:	3251883a 	add	r8,r6,r9
80130c08:	1021883a 	mov	r16,r2
80130c0c:	003ee506 	br	801307a4 <__reset+0xfa1107a4>
80130c10:	4984b03a 	or	r2,r9,r6
80130c14:	103e6326 	beq	r2,zero,801305a4 <__reset+0xfa1105a4>
80130c18:	8987c83a 	sub	r3,r17,r6
80130c1c:	88c9803a 	cmpltu	r4,r17,r3
80130c20:	4245c83a 	sub	r2,r8,r9
80130c24:	1105c83a 	sub	r2,r2,r4
80130c28:	1100202c 	andhi	r4,r2,128
80130c2c:	203ebb26 	beq	r4,zero,8013071c <__reset+0xfa11071c>
80130c30:	3463c83a 	sub	r17,r6,r17
80130c34:	4a07c83a 	sub	r3,r9,r8
80130c38:	344d803a 	cmpltu	r6,r6,r17
80130c3c:	1991c83a 	sub	r8,r3,r6
80130c40:	3825883a 	mov	r18,r7
80130c44:	003e5706 	br	801305a4 <__reset+0xfa1105a4>
80130c48:	4984b03a 	or	r2,r9,r6
80130c4c:	10002e26 	beq	r2,zero,80130d08 <__adddf3+0x7e8>
80130c50:	4004d0fa 	srli	r2,r8,3
80130c54:	8822d0fa 	srli	r17,r17,3
80130c58:	4010977a 	slli	r8,r8,29
80130c5c:	10c0022c 	andhi	r3,r2,8
80130c60:	4462b03a 	or	r17,r8,r17
80130c64:	18000826 	beq	r3,zero,80130c88 <__adddf3+0x768>
80130c68:	4808d0fa 	srli	r4,r9,3
80130c6c:	20c0022c 	andhi	r3,r4,8
80130c70:	1800051e 	bne	r3,zero,80130c88 <__adddf3+0x768>
80130c74:	300cd0fa 	srli	r6,r6,3
80130c78:	4806977a 	slli	r3,r9,29
80130c7c:	2005883a 	mov	r2,r4
80130c80:	3825883a 	mov	r18,r7
80130c84:	19a2b03a 	or	r17,r3,r6
80130c88:	8810d77a 	srli	r8,r17,29
80130c8c:	100490fa 	slli	r2,r2,3
80130c90:	882290fa 	slli	r17,r17,3
80130c94:	0401ffc4 	movi	r16,2047
80130c98:	4090b03a 	or	r8,r8,r2
80130c9c:	003e4106 	br	801305a4 <__reset+0xfa1105a4>
80130ca0:	0141ffc4 	movi	r5,2047
80130ca4:	117fc71e 	bne	r2,r5,80130bc4 <__reset+0xfa110bc4>
80130ca8:	4811883a 	mov	r8,r9
80130cac:	3023883a 	mov	r17,r6
80130cb0:	1021883a 	mov	r16,r2
80130cb4:	003e3b06 	br	801305a4 <__reset+0xfa1105a4>
80130cb8:	10002f26 	beq	r2,zero,80130d78 <__adddf3+0x858>
80130cbc:	4984b03a 	or	r2,r9,r6
80130cc0:	10001126 	beq	r2,zero,80130d08 <__adddf3+0x7e8>
80130cc4:	4004d0fa 	srli	r2,r8,3
80130cc8:	8822d0fa 	srli	r17,r17,3
80130ccc:	4010977a 	slli	r8,r8,29
80130cd0:	10c0022c 	andhi	r3,r2,8
80130cd4:	4462b03a 	or	r17,r8,r17
80130cd8:	183feb26 	beq	r3,zero,80130c88 <__reset+0xfa110c88>
80130cdc:	4808d0fa 	srli	r4,r9,3
80130ce0:	20c0022c 	andhi	r3,r4,8
80130ce4:	183fe81e 	bne	r3,zero,80130c88 <__reset+0xfa110c88>
80130ce8:	300cd0fa 	srli	r6,r6,3
80130cec:	4806977a 	slli	r3,r9,29
80130cf0:	2005883a 	mov	r2,r4
80130cf4:	19a2b03a 	or	r17,r3,r6
80130cf8:	003fe306 	br	80130c88 <__reset+0xfa110c88>
80130cfc:	0011883a 	mov	r8,zero
80130d00:	0005883a 	mov	r2,zero
80130d04:	003e3f06 	br	80130604 <__reset+0xfa110604>
80130d08:	0401ffc4 	movi	r16,2047
80130d0c:	003e2506 	br	801305a4 <__reset+0xfa1105a4>
80130d10:	0013883a 	mov	r9,zero
80130d14:	003f8406 	br	80130b28 <__reset+0xfa110b28>
80130d18:	0005883a 	mov	r2,zero
80130d1c:	0007883a 	mov	r3,zero
80130d20:	003e8906 	br	80130748 <__reset+0xfa110748>
80130d24:	197ff804 	addi	r5,r3,-32
80130d28:	01000804 	movi	r4,32
80130d2c:	414ad83a 	srl	r5,r8,r5
80130d30:	19002426 	beq	r3,r4,80130dc4 <__adddf3+0x8a4>
80130d34:	01001004 	movi	r4,64
80130d38:	20c7c83a 	sub	r3,r4,r3
80130d3c:	40c6983a 	sll	r3,r8,r3
80130d40:	1c46b03a 	or	r3,r3,r17
80130d44:	1806c03a 	cmpne	r3,r3,zero
80130d48:	28e2b03a 	or	r17,r5,r3
80130d4c:	0007883a 	mov	r3,zero
80130d50:	003f2306 	br	801309e0 <__reset+0xfa1109e0>
80130d54:	0007883a 	mov	r3,zero
80130d58:	5811883a 	mov	r8,r11
80130d5c:	00bfffc4 	movi	r2,-1
80130d60:	0401ffc4 	movi	r16,2047
80130d64:	003e7806 	br	80130748 <__reset+0xfa110748>
80130d68:	4462b03a 	or	r17,r8,r17
80130d6c:	8822c03a 	cmpne	r17,r17,zero
80130d70:	0009883a 	mov	r4,zero
80130d74:	003fa006 	br	80130bf8 <__reset+0xfa110bf8>
80130d78:	4811883a 	mov	r8,r9
80130d7c:	3023883a 	mov	r17,r6
80130d80:	0401ffc4 	movi	r16,2047
80130d84:	003e0706 	br	801305a4 <__reset+0xfa1105a4>
80130d88:	4811883a 	mov	r8,r9
80130d8c:	3023883a 	mov	r17,r6
80130d90:	003e0406 	br	801305a4 <__reset+0xfa1105a4>
80130d94:	21fff804 	addi	r7,r4,-32
80130d98:	01400804 	movi	r5,32
80130d9c:	41ced83a 	srl	r7,r8,r7
80130da0:	21400a26 	beq	r4,r5,80130dcc <__adddf3+0x8ac>
80130da4:	01401004 	movi	r5,64
80130da8:	2909c83a 	sub	r4,r5,r4
80130dac:	4108983a 	sll	r4,r8,r4
80130db0:	2448b03a 	or	r4,r4,r17
80130db4:	2008c03a 	cmpne	r4,r4,zero
80130db8:	3922b03a 	or	r17,r7,r4
80130dbc:	0009883a 	mov	r4,zero
80130dc0:	003f8d06 	br	80130bf8 <__reset+0xfa110bf8>
80130dc4:	0007883a 	mov	r3,zero
80130dc8:	003fdd06 	br	80130d40 <__reset+0xfa110d40>
80130dcc:	0009883a 	mov	r4,zero
80130dd0:	003ff706 	br	80130db0 <__reset+0xfa110db0>

80130dd4 <__divdf3>:
80130dd4:	defff204 	addi	sp,sp,-56
80130dd8:	de00012e 	bgeu	sp,et,80130de0 <__divdf3+0xc>
80130ddc:	003b68fa 	trap	3
80130de0:	dd400915 	stw	r21,36(sp)
80130de4:	282ad53a 	srli	r21,r5,20
80130de8:	dd000815 	stw	r20,32(sp)
80130dec:	2828d7fa 	srli	r20,r5,31
80130df0:	dc000415 	stw	r16,16(sp)
80130df4:	04000434 	movhi	r16,16
80130df8:	df000c15 	stw	fp,48(sp)
80130dfc:	843fffc4 	addi	r16,r16,-1
80130e00:	dfc00d15 	stw	ra,52(sp)
80130e04:	ddc00b15 	stw	r23,44(sp)
80130e08:	dd800a15 	stw	r22,40(sp)
80130e0c:	dcc00715 	stw	r19,28(sp)
80130e10:	dc800615 	stw	r18,24(sp)
80130e14:	dc400515 	stw	r17,20(sp)
80130e18:	ad41ffcc 	andi	r21,r21,2047
80130e1c:	2c20703a 	and	r16,r5,r16
80130e20:	a7003fcc 	andi	fp,r20,255
80130e24:	a8006126 	beq	r21,zero,80130fac <__divdf3+0x1d8>
80130e28:	0081ffc4 	movi	r2,2047
80130e2c:	2025883a 	mov	r18,r4
80130e30:	a8803726 	beq	r21,r2,80130f10 <__divdf3+0x13c>
80130e34:	80800434 	orhi	r2,r16,16
80130e38:	100490fa 	slli	r2,r2,3
80130e3c:	2020d77a 	srli	r16,r4,29
80130e40:	202490fa 	slli	r18,r4,3
80130e44:	ad7f0044 	addi	r21,r21,-1023
80130e48:	80a0b03a 	or	r16,r16,r2
80130e4c:	0027883a 	mov	r19,zero
80130e50:	0013883a 	mov	r9,zero
80130e54:	3804d53a 	srli	r2,r7,20
80130e58:	382cd7fa 	srli	r22,r7,31
80130e5c:	04400434 	movhi	r17,16
80130e60:	8c7fffc4 	addi	r17,r17,-1
80130e64:	1081ffcc 	andi	r2,r2,2047
80130e68:	3011883a 	mov	r8,r6
80130e6c:	3c62703a 	and	r17,r7,r17
80130e70:	b5c03fcc 	andi	r23,r22,255
80130e74:	10006c26 	beq	r2,zero,80131028 <__divdf3+0x254>
80130e78:	00c1ffc4 	movi	r3,2047
80130e7c:	10c06426 	beq	r2,r3,80131010 <__divdf3+0x23c>
80130e80:	88c00434 	orhi	r3,r17,16
80130e84:	180690fa 	slli	r3,r3,3
80130e88:	3022d77a 	srli	r17,r6,29
80130e8c:	301090fa 	slli	r8,r6,3
80130e90:	10bf0044 	addi	r2,r2,-1023
80130e94:	88e2b03a 	or	r17,r17,r3
80130e98:	000f883a 	mov	r7,zero
80130e9c:	a58cf03a 	xor	r6,r20,r22
80130ea0:	3cc8b03a 	or	r4,r7,r19
80130ea4:	a8abc83a 	sub	r21,r21,r2
80130ea8:	008003c4 	movi	r2,15
80130eac:	3007883a 	mov	r3,r6
80130eb0:	34c03fcc 	andi	r19,r6,255
80130eb4:	11009036 	bltu	r2,r4,801310f8 <__divdf3+0x324>
80130eb8:	200890ba 	slli	r4,r4,2
80130ebc:	00a004f4 	movhi	r2,32787
80130ec0:	1083b404 	addi	r2,r2,3792
80130ec4:	2089883a 	add	r4,r4,r2
80130ec8:	20800017 	ldw	r2,0(r4)
80130ecc:	1000683a 	jmp	r2
80130ed0:	801310f8 	rdprs	zero,r16,19523
80130ed4:	80130f48 	cmpgei	zero,r16,19517
80130ed8:	801310e8 	cmpgeui	zero,r16,19523
80130edc:	80130f3c 	xorhi	zero,r16,19516
80130ee0:	801310e8 	cmpgeui	zero,r16,19523
80130ee4:	801310bc 	xorhi	zero,r16,19522
80130ee8:	801310e8 	cmpgeui	zero,r16,19523
80130eec:	80130f3c 	xorhi	zero,r16,19516
80130ef0:	80130f48 	cmpgei	zero,r16,19517
80130ef4:	80130f48 	cmpgei	zero,r16,19517
80130ef8:	801310bc 	xorhi	zero,r16,19522
80130efc:	80130f3c 	xorhi	zero,r16,19516
80130f00:	80130f2c 	andhi	zero,r16,19516
80130f04:	80130f2c 	andhi	zero,r16,19516
80130f08:	80130f2c 	andhi	zero,r16,19516
80130f0c:	801313dc 	xori	zero,r16,19535
80130f10:	2404b03a 	or	r2,r4,r16
80130f14:	1000661e 	bne	r2,zero,801310b0 <__divdf3+0x2dc>
80130f18:	04c00204 	movi	r19,8
80130f1c:	0021883a 	mov	r16,zero
80130f20:	0025883a 	mov	r18,zero
80130f24:	02400084 	movi	r9,2
80130f28:	003fca06 	br	80130e54 <__reset+0xfa110e54>
80130f2c:	8023883a 	mov	r17,r16
80130f30:	9011883a 	mov	r8,r18
80130f34:	e02f883a 	mov	r23,fp
80130f38:	480f883a 	mov	r7,r9
80130f3c:	00800084 	movi	r2,2
80130f40:	3881311e 	bne	r7,r2,80131408 <__divdf3+0x634>
80130f44:	b827883a 	mov	r19,r23
80130f48:	98c0004c 	andi	r3,r19,1
80130f4c:	0081ffc4 	movi	r2,2047
80130f50:	000b883a 	mov	r5,zero
80130f54:	0025883a 	mov	r18,zero
80130f58:	1004953a 	slli	r2,r2,20
80130f5c:	18c03fcc 	andi	r3,r3,255
80130f60:	04400434 	movhi	r17,16
80130f64:	8c7fffc4 	addi	r17,r17,-1
80130f68:	180697fa 	slli	r3,r3,31
80130f6c:	2c4a703a 	and	r5,r5,r17
80130f70:	288ab03a 	or	r5,r5,r2
80130f74:	28c6b03a 	or	r3,r5,r3
80130f78:	9005883a 	mov	r2,r18
80130f7c:	dfc00d17 	ldw	ra,52(sp)
80130f80:	df000c17 	ldw	fp,48(sp)
80130f84:	ddc00b17 	ldw	r23,44(sp)
80130f88:	dd800a17 	ldw	r22,40(sp)
80130f8c:	dd400917 	ldw	r21,36(sp)
80130f90:	dd000817 	ldw	r20,32(sp)
80130f94:	dcc00717 	ldw	r19,28(sp)
80130f98:	dc800617 	ldw	r18,24(sp)
80130f9c:	dc400517 	ldw	r17,20(sp)
80130fa0:	dc000417 	ldw	r16,16(sp)
80130fa4:	dec00e04 	addi	sp,sp,56
80130fa8:	f800283a 	ret
80130fac:	2404b03a 	or	r2,r4,r16
80130fb0:	2027883a 	mov	r19,r4
80130fb4:	10003926 	beq	r2,zero,8013109c <__divdf3+0x2c8>
80130fb8:	80012e26 	beq	r16,zero,80131474 <__divdf3+0x6a0>
80130fbc:	8009883a 	mov	r4,r16
80130fc0:	d9800315 	stw	r6,12(sp)
80130fc4:	d9c00215 	stw	r7,8(sp)
80130fc8:	01213d00 	call	801213d0 <__clzsi2>
80130fcc:	d9800317 	ldw	r6,12(sp)
80130fd0:	d9c00217 	ldw	r7,8(sp)
80130fd4:	113ffd44 	addi	r4,r2,-11
80130fd8:	00c00704 	movi	r3,28
80130fdc:	19012116 	blt	r3,r4,80131464 <__divdf3+0x690>
80130fe0:	00c00744 	movi	r3,29
80130fe4:	147ffe04 	addi	r17,r2,-8
80130fe8:	1907c83a 	sub	r3,r3,r4
80130fec:	8460983a 	sll	r16,r16,r17
80130ff0:	98c6d83a 	srl	r3,r19,r3
80130ff4:	9c64983a 	sll	r18,r19,r17
80130ff8:	1c20b03a 	or	r16,r3,r16
80130ffc:	1080fcc4 	addi	r2,r2,1011
80131000:	00abc83a 	sub	r21,zero,r2
80131004:	0027883a 	mov	r19,zero
80131008:	0013883a 	mov	r9,zero
8013100c:	003f9106 	br	80130e54 <__reset+0xfa110e54>
80131010:	3446b03a 	or	r3,r6,r17
80131014:	18001f1e 	bne	r3,zero,80131094 <__divdf3+0x2c0>
80131018:	0023883a 	mov	r17,zero
8013101c:	0011883a 	mov	r8,zero
80131020:	01c00084 	movi	r7,2
80131024:	003f9d06 	br	80130e9c <__reset+0xfa110e9c>
80131028:	3446b03a 	or	r3,r6,r17
8013102c:	18001526 	beq	r3,zero,80131084 <__divdf3+0x2b0>
80131030:	88011b26 	beq	r17,zero,801314a0 <__divdf3+0x6cc>
80131034:	8809883a 	mov	r4,r17
80131038:	d9800315 	stw	r6,12(sp)
8013103c:	da400115 	stw	r9,4(sp)
80131040:	01213d00 	call	801213d0 <__clzsi2>
80131044:	d9800317 	ldw	r6,12(sp)
80131048:	da400117 	ldw	r9,4(sp)
8013104c:	113ffd44 	addi	r4,r2,-11
80131050:	00c00704 	movi	r3,28
80131054:	19010e16 	blt	r3,r4,80131490 <__divdf3+0x6bc>
80131058:	00c00744 	movi	r3,29
8013105c:	123ffe04 	addi	r8,r2,-8
80131060:	1907c83a 	sub	r3,r3,r4
80131064:	8a22983a 	sll	r17,r17,r8
80131068:	30c6d83a 	srl	r3,r6,r3
8013106c:	3210983a 	sll	r8,r6,r8
80131070:	1c62b03a 	or	r17,r3,r17
80131074:	1080fcc4 	addi	r2,r2,1011
80131078:	0085c83a 	sub	r2,zero,r2
8013107c:	000f883a 	mov	r7,zero
80131080:	003f8606 	br	80130e9c <__reset+0xfa110e9c>
80131084:	0023883a 	mov	r17,zero
80131088:	0011883a 	mov	r8,zero
8013108c:	01c00044 	movi	r7,1
80131090:	003f8206 	br	80130e9c <__reset+0xfa110e9c>
80131094:	01c000c4 	movi	r7,3
80131098:	003f8006 	br	80130e9c <__reset+0xfa110e9c>
8013109c:	04c00104 	movi	r19,4
801310a0:	0021883a 	mov	r16,zero
801310a4:	0025883a 	mov	r18,zero
801310a8:	02400044 	movi	r9,1
801310ac:	003f6906 	br	80130e54 <__reset+0xfa110e54>
801310b0:	04c00304 	movi	r19,12
801310b4:	024000c4 	movi	r9,3
801310b8:	003f6606 	br	80130e54 <__reset+0xfa110e54>
801310bc:	01400434 	movhi	r5,16
801310c0:	0007883a 	mov	r3,zero
801310c4:	297fffc4 	addi	r5,r5,-1
801310c8:	04bfffc4 	movi	r18,-1
801310cc:	0081ffc4 	movi	r2,2047
801310d0:	003fa106 	br	80130f58 <__reset+0xfa110f58>
801310d4:	00c00044 	movi	r3,1
801310d8:	1887c83a 	sub	r3,r3,r2
801310dc:	01000e04 	movi	r4,56
801310e0:	20c1210e 	bge	r4,r3,80131568 <__divdf3+0x794>
801310e4:	98c0004c 	andi	r3,r19,1
801310e8:	0005883a 	mov	r2,zero
801310ec:	000b883a 	mov	r5,zero
801310f0:	0025883a 	mov	r18,zero
801310f4:	003f9806 	br	80130f58 <__reset+0xfa110f58>
801310f8:	8c00fd36 	bltu	r17,r16,801314f0 <__divdf3+0x71c>
801310fc:	8440fb26 	beq	r16,r17,801314ec <__divdf3+0x718>
80131100:	8007883a 	mov	r3,r16
80131104:	ad7fffc4 	addi	r21,r21,-1
80131108:	0021883a 	mov	r16,zero
8013110c:	4004d63a 	srli	r2,r8,24
80131110:	8822923a 	slli	r17,r17,8
80131114:	1809883a 	mov	r4,r3
80131118:	402c923a 	slli	r22,r8,8
8013111c:	88b8b03a 	or	fp,r17,r2
80131120:	e028d43a 	srli	r20,fp,16
80131124:	d8c00015 	stw	r3,0(sp)
80131128:	e5ffffcc 	andi	r23,fp,65535
8013112c:	a00b883a 	mov	r5,r20
80131130:	01302680 	call	80130268 <__udivsi3>
80131134:	d8c00017 	ldw	r3,0(sp)
80131138:	a00b883a 	mov	r5,r20
8013113c:	d8800315 	stw	r2,12(sp)
80131140:	1809883a 	mov	r4,r3
80131144:	01302cc0 	call	801302cc <__umodsi3>
80131148:	d9800317 	ldw	r6,12(sp)
8013114c:	1006943a 	slli	r3,r2,16
80131150:	9004d43a 	srli	r2,r18,16
80131154:	b9a3383a 	mul	r17,r23,r6
80131158:	10c4b03a 	or	r2,r2,r3
8013115c:	1440062e 	bgeu	r2,r17,80131178 <__divdf3+0x3a4>
80131160:	1705883a 	add	r2,r2,fp
80131164:	30ffffc4 	addi	r3,r6,-1
80131168:	1700ee36 	bltu	r2,fp,80131524 <__divdf3+0x750>
8013116c:	1440ed2e 	bgeu	r2,r17,80131524 <__divdf3+0x750>
80131170:	31bfff84 	addi	r6,r6,-2
80131174:	1705883a 	add	r2,r2,fp
80131178:	1463c83a 	sub	r17,r2,r17
8013117c:	a00b883a 	mov	r5,r20
80131180:	8809883a 	mov	r4,r17
80131184:	d9800315 	stw	r6,12(sp)
80131188:	01302680 	call	80130268 <__udivsi3>
8013118c:	a00b883a 	mov	r5,r20
80131190:	8809883a 	mov	r4,r17
80131194:	d8800215 	stw	r2,8(sp)
80131198:	01302cc0 	call	801302cc <__umodsi3>
8013119c:	d9c00217 	ldw	r7,8(sp)
801311a0:	1004943a 	slli	r2,r2,16
801311a4:	94bfffcc 	andi	r18,r18,65535
801311a8:	b9d1383a 	mul	r8,r23,r7
801311ac:	90a4b03a 	or	r18,r18,r2
801311b0:	d9800317 	ldw	r6,12(sp)
801311b4:	9200062e 	bgeu	r18,r8,801311d0 <__divdf3+0x3fc>
801311b8:	9725883a 	add	r18,r18,fp
801311bc:	38bfffc4 	addi	r2,r7,-1
801311c0:	9700d636 	bltu	r18,fp,8013151c <__divdf3+0x748>
801311c4:	9200d52e 	bgeu	r18,r8,8013151c <__divdf3+0x748>
801311c8:	39ffff84 	addi	r7,r7,-2
801311cc:	9725883a 	add	r18,r18,fp
801311d0:	3004943a 	slli	r2,r6,16
801311d4:	b012d43a 	srli	r9,r22,16
801311d8:	b1bfffcc 	andi	r6,r22,65535
801311dc:	11e2b03a 	or	r17,r2,r7
801311e0:	8806d43a 	srli	r3,r17,16
801311e4:	893fffcc 	andi	r4,r17,65535
801311e8:	218b383a 	mul	r5,r4,r6
801311ec:	30c5383a 	mul	r2,r6,r3
801311f0:	2249383a 	mul	r4,r4,r9
801311f4:	280ed43a 	srli	r7,r5,16
801311f8:	9225c83a 	sub	r18,r18,r8
801311fc:	2089883a 	add	r4,r4,r2
80131200:	3909883a 	add	r4,r7,r4
80131204:	1a47383a 	mul	r3,r3,r9
80131208:	2080022e 	bgeu	r4,r2,80131214 <__divdf3+0x440>
8013120c:	00800074 	movhi	r2,1
80131210:	1887883a 	add	r3,r3,r2
80131214:	2004d43a 	srli	r2,r4,16
80131218:	2008943a 	slli	r4,r4,16
8013121c:	297fffcc 	andi	r5,r5,65535
80131220:	10c7883a 	add	r3,r2,r3
80131224:	2149883a 	add	r4,r4,r5
80131228:	90c0a536 	bltu	r18,r3,801314c0 <__divdf3+0x6ec>
8013122c:	90c0bf26 	beq	r18,r3,8013152c <__divdf3+0x758>
80131230:	90c7c83a 	sub	r3,r18,r3
80131234:	810fc83a 	sub	r7,r16,r4
80131238:	81e5803a 	cmpltu	r18,r16,r7
8013123c:	1ca5c83a 	sub	r18,r3,r18
80131240:	e480c126 	beq	fp,r18,80131548 <__divdf3+0x774>
80131244:	a00b883a 	mov	r5,r20
80131248:	9009883a 	mov	r4,r18
8013124c:	d9800315 	stw	r6,12(sp)
80131250:	d9c00215 	stw	r7,8(sp)
80131254:	da400115 	stw	r9,4(sp)
80131258:	01302680 	call	80130268 <__udivsi3>
8013125c:	a00b883a 	mov	r5,r20
80131260:	9009883a 	mov	r4,r18
80131264:	d8800015 	stw	r2,0(sp)
80131268:	01302cc0 	call	801302cc <__umodsi3>
8013126c:	d9c00217 	ldw	r7,8(sp)
80131270:	da000017 	ldw	r8,0(sp)
80131274:	1006943a 	slli	r3,r2,16
80131278:	3804d43a 	srli	r2,r7,16
8013127c:	ba21383a 	mul	r16,r23,r8
80131280:	d9800317 	ldw	r6,12(sp)
80131284:	10c4b03a 	or	r2,r2,r3
80131288:	da400117 	ldw	r9,4(sp)
8013128c:	1400062e 	bgeu	r2,r16,801312a8 <__divdf3+0x4d4>
80131290:	1705883a 	add	r2,r2,fp
80131294:	40ffffc4 	addi	r3,r8,-1
80131298:	1700ad36 	bltu	r2,fp,80131550 <__divdf3+0x77c>
8013129c:	1400ac2e 	bgeu	r2,r16,80131550 <__divdf3+0x77c>
801312a0:	423fff84 	addi	r8,r8,-2
801312a4:	1705883a 	add	r2,r2,fp
801312a8:	1421c83a 	sub	r16,r2,r16
801312ac:	a00b883a 	mov	r5,r20
801312b0:	8009883a 	mov	r4,r16
801312b4:	d9800315 	stw	r6,12(sp)
801312b8:	d9c00215 	stw	r7,8(sp)
801312bc:	da000015 	stw	r8,0(sp)
801312c0:	da400115 	stw	r9,4(sp)
801312c4:	01302680 	call	80130268 <__udivsi3>
801312c8:	8009883a 	mov	r4,r16
801312cc:	a00b883a 	mov	r5,r20
801312d0:	1025883a 	mov	r18,r2
801312d4:	01302cc0 	call	801302cc <__umodsi3>
801312d8:	d9c00217 	ldw	r7,8(sp)
801312dc:	1004943a 	slli	r2,r2,16
801312e0:	bcaf383a 	mul	r23,r23,r18
801312e4:	393fffcc 	andi	r4,r7,65535
801312e8:	2088b03a 	or	r4,r4,r2
801312ec:	d9800317 	ldw	r6,12(sp)
801312f0:	da000017 	ldw	r8,0(sp)
801312f4:	da400117 	ldw	r9,4(sp)
801312f8:	25c0062e 	bgeu	r4,r23,80131314 <__divdf3+0x540>
801312fc:	2709883a 	add	r4,r4,fp
80131300:	90bfffc4 	addi	r2,r18,-1
80131304:	27009436 	bltu	r4,fp,80131558 <__divdf3+0x784>
80131308:	25c0932e 	bgeu	r4,r23,80131558 <__divdf3+0x784>
8013130c:	94bfff84 	addi	r18,r18,-2
80131310:	2709883a 	add	r4,r4,fp
80131314:	4004943a 	slli	r2,r8,16
80131318:	25efc83a 	sub	r23,r4,r23
8013131c:	1490b03a 	or	r8,r2,r18
80131320:	4008d43a 	srli	r4,r8,16
80131324:	40ffffcc 	andi	r3,r8,65535
80131328:	30c5383a 	mul	r2,r6,r3
8013132c:	1a47383a 	mul	r3,r3,r9
80131330:	310d383a 	mul	r6,r6,r4
80131334:	100ad43a 	srli	r5,r2,16
80131338:	4913383a 	mul	r9,r9,r4
8013133c:	1987883a 	add	r3,r3,r6
80131340:	28c7883a 	add	r3,r5,r3
80131344:	1980022e 	bgeu	r3,r6,80131350 <__divdf3+0x57c>
80131348:	01000074 	movhi	r4,1
8013134c:	4913883a 	add	r9,r9,r4
80131350:	1808d43a 	srli	r4,r3,16
80131354:	1806943a 	slli	r3,r3,16
80131358:	10bfffcc 	andi	r2,r2,65535
8013135c:	2253883a 	add	r9,r4,r9
80131360:	1887883a 	add	r3,r3,r2
80131364:	ba403836 	bltu	r23,r9,80131448 <__divdf3+0x674>
80131368:	ba403626 	beq	r23,r9,80131444 <__divdf3+0x670>
8013136c:	42000054 	ori	r8,r8,1
80131370:	a880ffc4 	addi	r2,r21,1023
80131374:	00bf570e 	bge	zero,r2,801310d4 <__reset+0xfa1110d4>
80131378:	40c001cc 	andi	r3,r8,7
8013137c:	18000726 	beq	r3,zero,8013139c <__divdf3+0x5c8>
80131380:	40c003cc 	andi	r3,r8,15
80131384:	01000104 	movi	r4,4
80131388:	19000426 	beq	r3,r4,8013139c <__divdf3+0x5c8>
8013138c:	4107883a 	add	r3,r8,r4
80131390:	1a11803a 	cmpltu	r8,r3,r8
80131394:	8a23883a 	add	r17,r17,r8
80131398:	1811883a 	mov	r8,r3
8013139c:	88c0402c 	andhi	r3,r17,256
801313a0:	18000426 	beq	r3,zero,801313b4 <__divdf3+0x5e0>
801313a4:	00ffc034 	movhi	r3,65280
801313a8:	18ffffc4 	addi	r3,r3,-1
801313ac:	a8810004 	addi	r2,r21,1024
801313b0:	88e2703a 	and	r17,r17,r3
801313b4:	00c1ff84 	movi	r3,2046
801313b8:	18bee316 	blt	r3,r2,80130f48 <__reset+0xfa110f48>
801313bc:	8824977a 	slli	r18,r17,29
801313c0:	4010d0fa 	srli	r8,r8,3
801313c4:	8822927a 	slli	r17,r17,9
801313c8:	1081ffcc 	andi	r2,r2,2047
801313cc:	9224b03a 	or	r18,r18,r8
801313d0:	880ad33a 	srli	r5,r17,12
801313d4:	98c0004c 	andi	r3,r19,1
801313d8:	003edf06 	br	80130f58 <__reset+0xfa110f58>
801313dc:	8080022c 	andhi	r2,r16,8
801313e0:	10001226 	beq	r2,zero,8013142c <__divdf3+0x658>
801313e4:	8880022c 	andhi	r2,r17,8
801313e8:	1000101e 	bne	r2,zero,8013142c <__divdf3+0x658>
801313ec:	00800434 	movhi	r2,16
801313f0:	89400234 	orhi	r5,r17,8
801313f4:	10bfffc4 	addi	r2,r2,-1
801313f8:	b007883a 	mov	r3,r22
801313fc:	288a703a 	and	r5,r5,r2
80131400:	4025883a 	mov	r18,r8
80131404:	003f3106 	br	801310cc <__reset+0xfa1110cc>
80131408:	008000c4 	movi	r2,3
8013140c:	3880a626 	beq	r7,r2,801316a8 <__divdf3+0x8d4>
80131410:	00800044 	movi	r2,1
80131414:	3880521e 	bne	r7,r2,80131560 <__divdf3+0x78c>
80131418:	b807883a 	mov	r3,r23
8013141c:	0005883a 	mov	r2,zero
80131420:	000b883a 	mov	r5,zero
80131424:	0025883a 	mov	r18,zero
80131428:	003ecb06 	br	80130f58 <__reset+0xfa110f58>
8013142c:	00800434 	movhi	r2,16
80131430:	81400234 	orhi	r5,r16,8
80131434:	10bfffc4 	addi	r2,r2,-1
80131438:	a007883a 	mov	r3,r20
8013143c:	288a703a 	and	r5,r5,r2
80131440:	003f2206 	br	801310cc <__reset+0xfa1110cc>
80131444:	183fca26 	beq	r3,zero,80131370 <__reset+0xfa111370>
80131448:	e5ef883a 	add	r23,fp,r23
8013144c:	40bfffc4 	addi	r2,r8,-1
80131450:	bf00392e 	bgeu	r23,fp,80131538 <__divdf3+0x764>
80131454:	1011883a 	mov	r8,r2
80131458:	ba7fc41e 	bne	r23,r9,8013136c <__reset+0xfa11136c>
8013145c:	b0ffc31e 	bne	r22,r3,8013136c <__reset+0xfa11136c>
80131460:	003fc306 	br	80131370 <__reset+0xfa111370>
80131464:	143ff604 	addi	r16,r2,-40
80131468:	9c20983a 	sll	r16,r19,r16
8013146c:	0025883a 	mov	r18,zero
80131470:	003ee206 	br	80130ffc <__reset+0xfa110ffc>
80131474:	d9800315 	stw	r6,12(sp)
80131478:	d9c00215 	stw	r7,8(sp)
8013147c:	01213d00 	call	801213d0 <__clzsi2>
80131480:	10800804 	addi	r2,r2,32
80131484:	d9c00217 	ldw	r7,8(sp)
80131488:	d9800317 	ldw	r6,12(sp)
8013148c:	003ed106 	br	80130fd4 <__reset+0xfa110fd4>
80131490:	147ff604 	addi	r17,r2,-40
80131494:	3462983a 	sll	r17,r6,r17
80131498:	0011883a 	mov	r8,zero
8013149c:	003ef506 	br	80131074 <__reset+0xfa111074>
801314a0:	3009883a 	mov	r4,r6
801314a4:	d9800315 	stw	r6,12(sp)
801314a8:	da400115 	stw	r9,4(sp)
801314ac:	01213d00 	call	801213d0 <__clzsi2>
801314b0:	10800804 	addi	r2,r2,32
801314b4:	da400117 	ldw	r9,4(sp)
801314b8:	d9800317 	ldw	r6,12(sp)
801314bc:	003ee306 	br	8013104c <__reset+0xfa11104c>
801314c0:	85a1883a 	add	r16,r16,r22
801314c4:	8585803a 	cmpltu	r2,r16,r22
801314c8:	1705883a 	add	r2,r2,fp
801314cc:	14a5883a 	add	r18,r2,r18
801314d0:	88bfffc4 	addi	r2,r17,-1
801314d4:	e4800c2e 	bgeu	fp,r18,80131508 <__divdf3+0x734>
801314d8:	90c03e36 	bltu	r18,r3,801315d4 <__divdf3+0x800>
801314dc:	1c806926 	beq	r3,r18,80131684 <__divdf3+0x8b0>
801314e0:	90c7c83a 	sub	r3,r18,r3
801314e4:	1023883a 	mov	r17,r2
801314e8:	003f5206 	br	80131234 <__reset+0xfa111234>
801314ec:	923f0436 	bltu	r18,r8,80131100 <__reset+0xfa111100>
801314f0:	800897fa 	slli	r4,r16,31
801314f4:	9004d07a 	srli	r2,r18,1
801314f8:	8006d07a 	srli	r3,r16,1
801314fc:	902097fa 	slli	r16,r18,31
80131500:	20a4b03a 	or	r18,r4,r2
80131504:	003f0106 	br	8013110c <__reset+0xfa11110c>
80131508:	e4bff51e 	bne	fp,r18,801314e0 <__reset+0xfa1114e0>
8013150c:	85bff22e 	bgeu	r16,r22,801314d8 <__reset+0xfa1114d8>
80131510:	e0c7c83a 	sub	r3,fp,r3
80131514:	1023883a 	mov	r17,r2
80131518:	003f4606 	br	80131234 <__reset+0xfa111234>
8013151c:	100f883a 	mov	r7,r2
80131520:	003f2b06 	br	801311d0 <__reset+0xfa1111d0>
80131524:	180d883a 	mov	r6,r3
80131528:	003f1306 	br	80131178 <__reset+0xfa111178>
8013152c:	813fe436 	bltu	r16,r4,801314c0 <__reset+0xfa1114c0>
80131530:	0007883a 	mov	r3,zero
80131534:	003f3f06 	br	80131234 <__reset+0xfa111234>
80131538:	ba402c36 	bltu	r23,r9,801315ec <__divdf3+0x818>
8013153c:	4dc05426 	beq	r9,r23,80131690 <__divdf3+0x8bc>
80131540:	1011883a 	mov	r8,r2
80131544:	003f8906 	br	8013136c <__reset+0xfa11136c>
80131548:	023fffc4 	movi	r8,-1
8013154c:	003f8806 	br	80131370 <__reset+0xfa111370>
80131550:	1811883a 	mov	r8,r3
80131554:	003f5406 	br	801312a8 <__reset+0xfa1112a8>
80131558:	1025883a 	mov	r18,r2
8013155c:	003f6d06 	br	80131314 <__reset+0xfa111314>
80131560:	b827883a 	mov	r19,r23
80131564:	003f8206 	br	80131370 <__reset+0xfa111370>
80131568:	010007c4 	movi	r4,31
8013156c:	20c02616 	blt	r4,r3,80131608 <__divdf3+0x834>
80131570:	00800804 	movi	r2,32
80131574:	10c5c83a 	sub	r2,r2,r3
80131578:	888a983a 	sll	r5,r17,r2
8013157c:	40c8d83a 	srl	r4,r8,r3
80131580:	4084983a 	sll	r2,r8,r2
80131584:	88e2d83a 	srl	r17,r17,r3
80131588:	2906b03a 	or	r3,r5,r4
8013158c:	1004c03a 	cmpne	r2,r2,zero
80131590:	1886b03a 	or	r3,r3,r2
80131594:	188001cc 	andi	r2,r3,7
80131598:	10000726 	beq	r2,zero,801315b8 <__divdf3+0x7e4>
8013159c:	188003cc 	andi	r2,r3,15
801315a0:	01000104 	movi	r4,4
801315a4:	11000426 	beq	r2,r4,801315b8 <__divdf3+0x7e4>
801315a8:	1805883a 	mov	r2,r3
801315ac:	10c00104 	addi	r3,r2,4
801315b0:	1885803a 	cmpltu	r2,r3,r2
801315b4:	88a3883a 	add	r17,r17,r2
801315b8:	8880202c 	andhi	r2,r17,128
801315bc:	10002726 	beq	r2,zero,8013165c <__divdf3+0x888>
801315c0:	98c0004c 	andi	r3,r19,1
801315c4:	00800044 	movi	r2,1
801315c8:	000b883a 	mov	r5,zero
801315cc:	0025883a 	mov	r18,zero
801315d0:	003e6106 	br	80130f58 <__reset+0xfa110f58>
801315d4:	85a1883a 	add	r16,r16,r22
801315d8:	8585803a 	cmpltu	r2,r16,r22
801315dc:	1705883a 	add	r2,r2,fp
801315e0:	14a5883a 	add	r18,r2,r18
801315e4:	8c7fff84 	addi	r17,r17,-2
801315e8:	003f1106 	br	80131230 <__reset+0xfa111230>
801315ec:	b589883a 	add	r4,r22,r22
801315f0:	25ad803a 	cmpltu	r22,r4,r22
801315f4:	b739883a 	add	fp,r22,fp
801315f8:	40bfff84 	addi	r2,r8,-2
801315fc:	bf2f883a 	add	r23,r23,fp
80131600:	202d883a 	mov	r22,r4
80131604:	003f9306 	br	80131454 <__reset+0xfa111454>
80131608:	013ff844 	movi	r4,-31
8013160c:	2085c83a 	sub	r2,r4,r2
80131610:	8888d83a 	srl	r4,r17,r2
80131614:	00800804 	movi	r2,32
80131618:	18802126 	beq	r3,r2,801316a0 <__divdf3+0x8cc>
8013161c:	00801004 	movi	r2,64
80131620:	10c5c83a 	sub	r2,r2,r3
80131624:	8884983a 	sll	r2,r17,r2
80131628:	1204b03a 	or	r2,r2,r8
8013162c:	1004c03a 	cmpne	r2,r2,zero
80131630:	2084b03a 	or	r2,r4,r2
80131634:	144001cc 	andi	r17,r2,7
80131638:	88000d1e 	bne	r17,zero,80131670 <__divdf3+0x89c>
8013163c:	000b883a 	mov	r5,zero
80131640:	1024d0fa 	srli	r18,r2,3
80131644:	98c0004c 	andi	r3,r19,1
80131648:	0005883a 	mov	r2,zero
8013164c:	9464b03a 	or	r18,r18,r17
80131650:	003e4106 	br	80130f58 <__reset+0xfa110f58>
80131654:	1007883a 	mov	r3,r2
80131658:	0023883a 	mov	r17,zero
8013165c:	880a927a 	slli	r5,r17,9
80131660:	1805883a 	mov	r2,r3
80131664:	8822977a 	slli	r17,r17,29
80131668:	280ad33a 	srli	r5,r5,12
8013166c:	003ff406 	br	80131640 <__reset+0xfa111640>
80131670:	10c003cc 	andi	r3,r2,15
80131674:	01000104 	movi	r4,4
80131678:	193ff626 	beq	r3,r4,80131654 <__reset+0xfa111654>
8013167c:	0023883a 	mov	r17,zero
80131680:	003fca06 	br	801315ac <__reset+0xfa1115ac>
80131684:	813fd336 	bltu	r16,r4,801315d4 <__reset+0xfa1115d4>
80131688:	1023883a 	mov	r17,r2
8013168c:	003fa806 	br	80131530 <__reset+0xfa111530>
80131690:	b0ffd636 	bltu	r22,r3,801315ec <__reset+0xfa1115ec>
80131694:	1011883a 	mov	r8,r2
80131698:	b0ff341e 	bne	r22,r3,8013136c <__reset+0xfa11136c>
8013169c:	003f3406 	br	80131370 <__reset+0xfa111370>
801316a0:	0005883a 	mov	r2,zero
801316a4:	003fe006 	br	80131628 <__reset+0xfa111628>
801316a8:	00800434 	movhi	r2,16
801316ac:	89400234 	orhi	r5,r17,8
801316b0:	10bfffc4 	addi	r2,r2,-1
801316b4:	b807883a 	mov	r3,r23
801316b8:	288a703a 	and	r5,r5,r2
801316bc:	4025883a 	mov	r18,r8
801316c0:	003e8206 	br	801310cc <__reset+0xfa1110cc>

801316c4 <__eqdf2>:
801316c4:	2804d53a 	srli	r2,r5,20
801316c8:	3806d53a 	srli	r3,r7,20
801316cc:	02000434 	movhi	r8,16
801316d0:	423fffc4 	addi	r8,r8,-1
801316d4:	1081ffcc 	andi	r2,r2,2047
801316d8:	0281ffc4 	movi	r10,2047
801316dc:	2a12703a 	and	r9,r5,r8
801316e0:	18c1ffcc 	andi	r3,r3,2047
801316e4:	3a10703a 	and	r8,r7,r8
801316e8:	280ad7fa 	srli	r5,r5,31
801316ec:	380ed7fa 	srli	r7,r7,31
801316f0:	12801026 	beq	r2,r10,80131734 <__eqdf2+0x70>
801316f4:	0281ffc4 	movi	r10,2047
801316f8:	1a800a26 	beq	r3,r10,80131724 <__eqdf2+0x60>
801316fc:	10c00226 	beq	r2,r3,80131708 <__eqdf2+0x44>
80131700:	00800044 	movi	r2,1
80131704:	f800283a 	ret
80131708:	4a3ffd1e 	bne	r9,r8,80131700 <__reset+0xfa111700>
8013170c:	21bffc1e 	bne	r4,r6,80131700 <__reset+0xfa111700>
80131710:	29c00c26 	beq	r5,r7,80131744 <__eqdf2+0x80>
80131714:	103ffa1e 	bne	r2,zero,80131700 <__reset+0xfa111700>
80131718:	2244b03a 	or	r2,r4,r9
8013171c:	1004c03a 	cmpne	r2,r2,zero
80131720:	f800283a 	ret
80131724:	3214b03a 	or	r10,r6,r8
80131728:	503ff426 	beq	r10,zero,801316fc <__reset+0xfa1116fc>
8013172c:	00800044 	movi	r2,1
80131730:	f800283a 	ret
80131734:	2254b03a 	or	r10,r4,r9
80131738:	503fee26 	beq	r10,zero,801316f4 <__reset+0xfa1116f4>
8013173c:	00800044 	movi	r2,1
80131740:	f800283a 	ret
80131744:	0005883a 	mov	r2,zero
80131748:	f800283a 	ret

8013174c <__ledf2>:
8013174c:	2804d53a 	srli	r2,r5,20
80131750:	3810d53a 	srli	r8,r7,20
80131754:	00c00434 	movhi	r3,16
80131758:	18ffffc4 	addi	r3,r3,-1
8013175c:	1081ffcc 	andi	r2,r2,2047
80131760:	0241ffc4 	movi	r9,2047
80131764:	28d4703a 	and	r10,r5,r3
80131768:	4201ffcc 	andi	r8,r8,2047
8013176c:	38c6703a 	and	r3,r7,r3
80131770:	280ad7fa 	srli	r5,r5,31
80131774:	380ed7fa 	srli	r7,r7,31
80131778:	12401f26 	beq	r2,r9,801317f8 <__ledf2+0xac>
8013177c:	0241ffc4 	movi	r9,2047
80131780:	42401426 	beq	r8,r9,801317d4 <__ledf2+0x88>
80131784:	1000091e 	bne	r2,zero,801317ac <__ledf2+0x60>
80131788:	2296b03a 	or	r11,r4,r10
8013178c:	5813003a 	cmpeq	r9,r11,zero
80131790:	29403fcc 	andi	r5,r5,255
80131794:	40000a1e 	bne	r8,zero,801317c0 <__ledf2+0x74>
80131798:	30d8b03a 	or	r12,r6,r3
8013179c:	6000081e 	bne	r12,zero,801317c0 <__ledf2+0x74>
801317a0:	0005883a 	mov	r2,zero
801317a4:	5800111e 	bne	r11,zero,801317ec <__ledf2+0xa0>
801317a8:	f800283a 	ret
801317ac:	29403fcc 	andi	r5,r5,255
801317b0:	40000c1e 	bne	r8,zero,801317e4 <__ledf2+0x98>
801317b4:	30d2b03a 	or	r9,r6,r3
801317b8:	48000c26 	beq	r9,zero,801317ec <__ledf2+0xa0>
801317bc:	0013883a 	mov	r9,zero
801317c0:	39c03fcc 	andi	r7,r7,255
801317c4:	48000826 	beq	r9,zero,801317e8 <__ledf2+0x9c>
801317c8:	38001126 	beq	r7,zero,80131810 <__ledf2+0xc4>
801317cc:	00800044 	movi	r2,1
801317d0:	f800283a 	ret
801317d4:	30d2b03a 	or	r9,r6,r3
801317d8:	483fea26 	beq	r9,zero,80131784 <__reset+0xfa111784>
801317dc:	00800084 	movi	r2,2
801317e0:	f800283a 	ret
801317e4:	39c03fcc 	andi	r7,r7,255
801317e8:	39400726 	beq	r7,r5,80131808 <__ledf2+0xbc>
801317ec:	2800081e 	bne	r5,zero,80131810 <__ledf2+0xc4>
801317f0:	00800044 	movi	r2,1
801317f4:	f800283a 	ret
801317f8:	2292b03a 	or	r9,r4,r10
801317fc:	483fdf26 	beq	r9,zero,8013177c <__reset+0xfa11177c>
80131800:	00800084 	movi	r2,2
80131804:	f800283a 	ret
80131808:	4080030e 	bge	r8,r2,80131818 <__ledf2+0xcc>
8013180c:	383fef26 	beq	r7,zero,801317cc <__reset+0xfa1117cc>
80131810:	00bfffc4 	movi	r2,-1
80131814:	f800283a 	ret
80131818:	123feb16 	blt	r2,r8,801317c8 <__reset+0xfa1117c8>
8013181c:	1abff336 	bltu	r3,r10,801317ec <__reset+0xfa1117ec>
80131820:	50c00326 	beq	r10,r3,80131830 <__ledf2+0xe4>
80131824:	50c0042e 	bgeu	r10,r3,80131838 <__ledf2+0xec>
80131828:	283fe81e 	bne	r5,zero,801317cc <__reset+0xfa1117cc>
8013182c:	003ff806 	br	80131810 <__reset+0xfa111810>
80131830:	313fee36 	bltu	r6,r4,801317ec <__reset+0xfa1117ec>
80131834:	21bffc36 	bltu	r4,r6,80131828 <__reset+0xfa111828>
80131838:	0005883a 	mov	r2,zero
8013183c:	f800283a 	ret

80131840 <__floatunsidf>:
80131840:	defffe04 	addi	sp,sp,-8
80131844:	de00012e 	bgeu	sp,et,8013184c <__floatunsidf+0xc>
80131848:	003b68fa 	trap	3
8013184c:	dc000015 	stw	r16,0(sp)
80131850:	dfc00115 	stw	ra,4(sp)
80131854:	2021883a 	mov	r16,r4
80131858:	20002226 	beq	r4,zero,801318e4 <__floatunsidf+0xa4>
8013185c:	01213d00 	call	801213d0 <__clzsi2>
80131860:	01010784 	movi	r4,1054
80131864:	2089c83a 	sub	r4,r4,r2
80131868:	01810cc4 	movi	r6,1075
8013186c:	310dc83a 	sub	r6,r6,r4
80131870:	00c007c4 	movi	r3,31
80131874:	1980120e 	bge	r3,r6,801318c0 <__floatunsidf+0x80>
80131878:	00c104c4 	movi	r3,1043
8013187c:	1907c83a 	sub	r3,r3,r4
80131880:	80ca983a 	sll	r5,r16,r3
80131884:	00800434 	movhi	r2,16
80131888:	10bfffc4 	addi	r2,r2,-1
8013188c:	2101ffcc 	andi	r4,r4,2047
80131890:	0021883a 	mov	r16,zero
80131894:	288a703a 	and	r5,r5,r2
80131898:	2008953a 	slli	r4,r4,20
8013189c:	00c00434 	movhi	r3,16
801318a0:	18ffffc4 	addi	r3,r3,-1
801318a4:	28c6703a 	and	r3,r5,r3
801318a8:	8005883a 	mov	r2,r16
801318ac:	1906b03a 	or	r3,r3,r4
801318b0:	dfc00117 	ldw	ra,4(sp)
801318b4:	dc000017 	ldw	r16,0(sp)
801318b8:	dec00204 	addi	sp,sp,8
801318bc:	f800283a 	ret
801318c0:	00c002c4 	movi	r3,11
801318c4:	188bc83a 	sub	r5,r3,r2
801318c8:	814ad83a 	srl	r5,r16,r5
801318cc:	00c00434 	movhi	r3,16
801318d0:	18ffffc4 	addi	r3,r3,-1
801318d4:	81a0983a 	sll	r16,r16,r6
801318d8:	2101ffcc 	andi	r4,r4,2047
801318dc:	28ca703a 	and	r5,r5,r3
801318e0:	003fed06 	br	80131898 <__reset+0xfa111898>
801318e4:	0009883a 	mov	r4,zero
801318e8:	000b883a 	mov	r5,zero
801318ec:	003fea06 	br	80131898 <__reset+0xfa111898>

801318f0 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
801318f0:	defffb04 	addi	sp,sp,-20
801318f4:	de00012e 	bgeu	sp,et,801318fc <alt_busy_sleep+0xc>
801318f8:	003b68fa 	trap	3
801318fc:	df000415 	stw	fp,16(sp)
80131900:	df000404 	addi	fp,sp,16
80131904:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
80131908:	008000c4 	movi	r2,3
8013190c:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
80131910:	e0fffd17 	ldw	r3,-12(fp)
80131914:	008003f4 	movhi	r2,15
80131918:	10909004 	addi	r2,r2,16960
8013191c:	1887383a 	mul	r3,r3,r2
80131920:	0082fb34 	movhi	r2,3052
80131924:	10b08004 	addi	r2,r2,-15872
80131928:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
8013192c:	00a00034 	movhi	r2,32768
80131930:	10bfffc4 	addi	r2,r2,-1
80131934:	10c5203a 	divu	r2,r2,r3
80131938:	e0ffff17 	ldw	r3,-4(fp)
8013193c:	1885203a 	divu	r2,r3,r2
80131940:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
80131944:	e0bffe17 	ldw	r2,-8(fp)
80131948:	10002526 	beq	r2,zero,801319e0 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
8013194c:	e03ffc15 	stw	zero,-16(fp)
80131950:	00001406 	br	801319a4 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
80131954:	00a00034 	movhi	r2,32768
80131958:	10bfffc4 	addi	r2,r2,-1
8013195c:	10bfffc4 	addi	r2,r2,-1
80131960:	103ffe1e 	bne	r2,zero,8013195c <__reset+0xfa11195c>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
80131964:	e0fffd17 	ldw	r3,-12(fp)
80131968:	008003f4 	movhi	r2,15
8013196c:	10909004 	addi	r2,r2,16960
80131970:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
80131974:	0082fb34 	movhi	r2,3052
80131978:	10b08004 	addi	r2,r2,-15872
8013197c:	10c7203a 	divu	r3,r2,r3
80131980:	00a00034 	movhi	r2,32768
80131984:	10bfffc4 	addi	r2,r2,-1
80131988:	10c5203a 	divu	r2,r2,r3
8013198c:	e0ffff17 	ldw	r3,-4(fp)
80131990:	1885c83a 	sub	r2,r3,r2
80131994:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
80131998:	e0bffc17 	ldw	r2,-16(fp)
8013199c:	10800044 	addi	r2,r2,1
801319a0:	e0bffc15 	stw	r2,-16(fp)
801319a4:	e0fffc17 	ldw	r3,-16(fp)
801319a8:	e0bffe17 	ldw	r2,-8(fp)
801319ac:	18bfe916 	blt	r3,r2,80131954 <__reset+0xfa111954>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
801319b0:	e0fffd17 	ldw	r3,-12(fp)
801319b4:	008003f4 	movhi	r2,15
801319b8:	10909004 	addi	r2,r2,16960
801319bc:	1887383a 	mul	r3,r3,r2
801319c0:	0082fb34 	movhi	r2,3052
801319c4:	10b08004 	addi	r2,r2,-15872
801319c8:	10c7203a 	divu	r3,r2,r3
801319cc:	e0bfff17 	ldw	r2,-4(fp)
801319d0:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
801319d4:	10bfffc4 	addi	r2,r2,-1
801319d8:	103ffe1e 	bne	r2,zero,801319d4 <__reset+0xfa1119d4>
801319dc:	00000b06 	br	80131a0c <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
801319e0:	e0fffd17 	ldw	r3,-12(fp)
801319e4:	008003f4 	movhi	r2,15
801319e8:	10909004 	addi	r2,r2,16960
801319ec:	1887383a 	mul	r3,r3,r2
801319f0:	0082fb34 	movhi	r2,3052
801319f4:	10b08004 	addi	r2,r2,-15872
801319f8:	10c7203a 	divu	r3,r2,r3
801319fc:	e0bfff17 	ldw	r2,-4(fp)
80131a00:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
80131a04:	10bfffc4 	addi	r2,r2,-1
80131a08:	00bffe16 	blt	zero,r2,80131a04 <__reset+0xfa111a04>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
80131a0c:	0005883a 	mov	r2,zero
}
80131a10:	e037883a 	mov	sp,fp
80131a14:	df000017 	ldw	fp,0(sp)
80131a18:	dec00104 	addi	sp,sp,4
80131a1c:	f800283a 	ret

80131a20 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80131a20:	defffe04 	addi	sp,sp,-8
80131a24:	de00012e 	bgeu	sp,et,80131a2c <alt_get_errno+0xc>
80131a28:	003b68fa 	trap	3
80131a2c:	dfc00115 	stw	ra,4(sp)
80131a30:	df000015 	stw	fp,0(sp)
80131a34:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
80131a38:	d0a00f17 	ldw	r2,-32708(gp)
80131a3c:	10000326 	beq	r2,zero,80131a4c <alt_get_errno+0x2c>
80131a40:	d0a00f17 	ldw	r2,-32708(gp)
80131a44:	103ee83a 	callr	r2
80131a48:	00000106 	br	80131a50 <alt_get_errno+0x30>
80131a4c:	d0a08704 	addi	r2,gp,-32228
}
80131a50:	e037883a 	mov	sp,fp
80131a54:	dfc00117 	ldw	ra,4(sp)
80131a58:	df000017 	ldw	fp,0(sp)
80131a5c:	dec00204 	addi	sp,sp,8
80131a60:	f800283a 	ret

80131a64 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
80131a64:	defffb04 	addi	sp,sp,-20
80131a68:	de00012e 	bgeu	sp,et,80131a70 <close+0xc>
80131a6c:	003b68fa 	trap	3
80131a70:	dfc00415 	stw	ra,16(sp)
80131a74:	df000315 	stw	fp,12(sp)
80131a78:	df000304 	addi	fp,sp,12
80131a7c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
80131a80:	e0bfff17 	ldw	r2,-4(fp)
80131a84:	10000616 	blt	r2,zero,80131aa0 <close+0x3c>
80131a88:	e0bfff17 	ldw	r2,-4(fp)
80131a8c:	10c00324 	muli	r3,r2,12
80131a90:	00a00574 	movhi	r2,32789
80131a94:	10a36f04 	addi	r2,r2,-29252
80131a98:	1885883a 	add	r2,r3,r2
80131a9c:	00000106 	br	80131aa4 <close+0x40>
80131aa0:	0005883a 	mov	r2,zero
80131aa4:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
80131aa8:	e0bffd17 	ldw	r2,-12(fp)
80131aac:	10001926 	beq	r2,zero,80131b14 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
80131ab0:	e0bffd17 	ldw	r2,-12(fp)
80131ab4:	10800017 	ldw	r2,0(r2)
80131ab8:	10800417 	ldw	r2,16(r2)
80131abc:	10000626 	beq	r2,zero,80131ad8 <close+0x74>
80131ac0:	e0bffd17 	ldw	r2,-12(fp)
80131ac4:	10800017 	ldw	r2,0(r2)
80131ac8:	10800417 	ldw	r2,16(r2)
80131acc:	e13ffd17 	ldw	r4,-12(fp)
80131ad0:	103ee83a 	callr	r2
80131ad4:	00000106 	br	80131adc <close+0x78>
80131ad8:	0005883a 	mov	r2,zero
80131adc:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
80131ae0:	e13fff17 	ldw	r4,-4(fp)
80131ae4:	0132ddc0 	call	80132ddc <alt_release_fd>
    if (rval < 0)
80131ae8:	e0bffe17 	ldw	r2,-8(fp)
80131aec:	1000070e 	bge	r2,zero,80131b0c <close+0xa8>
    {
      ALT_ERRNO = -rval;
80131af0:	0131a200 	call	80131a20 <alt_get_errno>
80131af4:	1007883a 	mov	r3,r2
80131af8:	e0bffe17 	ldw	r2,-8(fp)
80131afc:	0085c83a 	sub	r2,zero,r2
80131b00:	18800015 	stw	r2,0(r3)
      return -1;
80131b04:	00bfffc4 	movi	r2,-1
80131b08:	00000706 	br	80131b28 <close+0xc4>
    }
    return 0;
80131b0c:	0005883a 	mov	r2,zero
80131b10:	00000506 	br	80131b28 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
80131b14:	0131a200 	call	80131a20 <alt_get_errno>
80131b18:	1007883a 	mov	r3,r2
80131b1c:	00801444 	movi	r2,81
80131b20:	18800015 	stw	r2,0(r3)
    return -1;
80131b24:	00bfffc4 	movi	r2,-1
  }
}
80131b28:	e037883a 	mov	sp,fp
80131b2c:	dfc00117 	ldw	ra,4(sp)
80131b30:	df000017 	ldw	fp,0(sp)
80131b34:	dec00204 	addi	sp,sp,8
80131b38:	f800283a 	ret

80131b3c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
80131b3c:	deffff04 	addi	sp,sp,-4
80131b40:	de00012e 	bgeu	sp,et,80131b48 <alt_dcache_flush_all+0xc>
80131b44:	003b68fa 	trap	3
80131b48:	df000015 	stw	fp,0(sp)
80131b4c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
80131b50:	0001883a 	nop
80131b54:	e037883a 	mov	sp,fp
80131b58:	df000017 	ldw	fp,0(sp)
80131b5c:	dec00104 	addi	sp,sp,4
80131b60:	f800283a 	ret

80131b64 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
80131b64:	defffc04 	addi	sp,sp,-16
80131b68:	de00012e 	bgeu	sp,et,80131b70 <alt_dev_null_write+0xc>
80131b6c:	003b68fa 	trap	3
80131b70:	df000315 	stw	fp,12(sp)
80131b74:	df000304 	addi	fp,sp,12
80131b78:	e13ffd15 	stw	r4,-12(fp)
80131b7c:	e17ffe15 	stw	r5,-8(fp)
80131b80:	e1bfff15 	stw	r6,-4(fp)
  return len;
80131b84:	e0bfff17 	ldw	r2,-4(fp)
}
80131b88:	e037883a 	mov	sp,fp
80131b8c:	df000017 	ldw	fp,0(sp)
80131b90:	dec00104 	addi	sp,sp,4
80131b94:	f800283a 	ret

80131b98 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80131b98:	defffe04 	addi	sp,sp,-8
80131b9c:	de00012e 	bgeu	sp,et,80131ba4 <alt_get_errno+0xc>
80131ba0:	003b68fa 	trap	3
80131ba4:	dfc00115 	stw	ra,4(sp)
80131ba8:	df000015 	stw	fp,0(sp)
80131bac:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
80131bb0:	d0a00f17 	ldw	r2,-32708(gp)
80131bb4:	10000326 	beq	r2,zero,80131bc4 <alt_get_errno+0x2c>
80131bb8:	d0a00f17 	ldw	r2,-32708(gp)
80131bbc:	103ee83a 	callr	r2
80131bc0:	00000106 	br	80131bc8 <alt_get_errno+0x30>
80131bc4:	d0a08704 	addi	r2,gp,-32228
}
80131bc8:	e037883a 	mov	sp,fp
80131bcc:	dfc00117 	ldw	ra,4(sp)
80131bd0:	df000017 	ldw	fp,0(sp)
80131bd4:	dec00204 	addi	sp,sp,8
80131bd8:	f800283a 	ret

80131bdc <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
80131bdc:	defffb04 	addi	sp,sp,-20
80131be0:	de00012e 	bgeu	sp,et,80131be8 <fstat+0xc>
80131be4:	003b68fa 	trap	3
80131be8:	dfc00415 	stw	ra,16(sp)
80131bec:	df000315 	stw	fp,12(sp)
80131bf0:	df000304 	addi	fp,sp,12
80131bf4:	e13ffe15 	stw	r4,-8(fp)
80131bf8:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
80131bfc:	e0bffe17 	ldw	r2,-8(fp)
80131c00:	10000616 	blt	r2,zero,80131c1c <fstat+0x40>
80131c04:	e0bffe17 	ldw	r2,-8(fp)
80131c08:	10c00324 	muli	r3,r2,12
80131c0c:	00a00574 	movhi	r2,32789
80131c10:	10a36f04 	addi	r2,r2,-29252
80131c14:	1885883a 	add	r2,r3,r2
80131c18:	00000106 	br	80131c20 <fstat+0x44>
80131c1c:	0005883a 	mov	r2,zero
80131c20:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
80131c24:	e0bffd17 	ldw	r2,-12(fp)
80131c28:	10001026 	beq	r2,zero,80131c6c <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
80131c2c:	e0bffd17 	ldw	r2,-12(fp)
80131c30:	10800017 	ldw	r2,0(r2)
80131c34:	10800817 	ldw	r2,32(r2)
80131c38:	10000726 	beq	r2,zero,80131c58 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
80131c3c:	e0bffd17 	ldw	r2,-12(fp)
80131c40:	10800017 	ldw	r2,0(r2)
80131c44:	10800817 	ldw	r2,32(r2)
80131c48:	e17fff17 	ldw	r5,-4(fp)
80131c4c:	e13ffd17 	ldw	r4,-12(fp)
80131c50:	103ee83a 	callr	r2
80131c54:	00000a06 	br	80131c80 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
80131c58:	e0bfff17 	ldw	r2,-4(fp)
80131c5c:	00c80004 	movi	r3,8192
80131c60:	10c00115 	stw	r3,4(r2)
      return 0;
80131c64:	0005883a 	mov	r2,zero
80131c68:	00000506 	br	80131c80 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
80131c6c:	0131b980 	call	80131b98 <alt_get_errno>
80131c70:	1007883a 	mov	r3,r2
80131c74:	00801444 	movi	r2,81
80131c78:	18800015 	stw	r2,0(r3)
    return -1;
80131c7c:	00bfffc4 	movi	r2,-1
  }
}
80131c80:	e037883a 	mov	sp,fp
80131c84:	dfc00117 	ldw	ra,4(sp)
80131c88:	df000017 	ldw	fp,0(sp)
80131c8c:	dec00204 	addi	sp,sp,8
80131c90:	f800283a 	ret

80131c94 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
80131c94:	defff004 	addi	sp,sp,-64
80131c98:	de00012e 	bgeu	sp,et,80131ca0 <alt_irq_register+0xc>
80131c9c:	003b68fa 	trap	3
80131ca0:	df000f15 	stw	fp,60(sp)
80131ca4:	df000f04 	addi	fp,sp,60
80131ca8:	e13ffd15 	stw	r4,-12(fp)
80131cac:	e17ffe15 	stw	r5,-8(fp)
80131cb0:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
80131cb4:	00bffa84 	movi	r2,-22
80131cb8:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
80131cbc:	e0bffd17 	ldw	r2,-12(fp)
80131cc0:	10800828 	cmpgeui	r2,r2,32
80131cc4:	1000501e 	bne	r2,zero,80131e08 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80131cc8:	0005303a 	rdctl	r2,status
80131ccc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80131cd0:	e0fff617 	ldw	r3,-40(fp)
80131cd4:	00bfff84 	movi	r2,-2
80131cd8:	1884703a 	and	r2,r3,r2
80131cdc:	1001703a 	wrctl	status,r2
  
  return context;
80131ce0:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
80131ce4:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
80131ce8:	00a005b4 	movhi	r2,32790
80131cec:	1093d004 	addi	r2,r2,20288
80131cf0:	e0fffd17 	ldw	r3,-12(fp)
80131cf4:	180690fa 	slli	r3,r3,3
80131cf8:	10c5883a 	add	r2,r2,r3
80131cfc:	e0ffff17 	ldw	r3,-4(fp)
80131d00:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
80131d04:	00a005b4 	movhi	r2,32790
80131d08:	1093d004 	addi	r2,r2,20288
80131d0c:	e0fffd17 	ldw	r3,-12(fp)
80131d10:	180690fa 	slli	r3,r3,3
80131d14:	10c5883a 	add	r2,r2,r3
80131d18:	10800104 	addi	r2,r2,4
80131d1c:	e0fffe17 	ldw	r3,-8(fp)
80131d20:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
80131d24:	e0bfff17 	ldw	r2,-4(fp)
80131d28:	10001926 	beq	r2,zero,80131d90 <alt_irq_register+0xfc>
80131d2c:	e0bffd17 	ldw	r2,-12(fp)
80131d30:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80131d34:	0005303a 	rdctl	r2,status
80131d38:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80131d3c:	e0fff717 	ldw	r3,-36(fp)
80131d40:	00bfff84 	movi	r2,-2
80131d44:	1884703a 	and	r2,r3,r2
80131d48:	1001703a 	wrctl	status,r2
  
  return context;
80131d4c:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
80131d50:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
80131d54:	00c00044 	movi	r3,1
80131d58:	e0bff217 	ldw	r2,-56(fp)
80131d5c:	1884983a 	sll	r2,r3,r2
80131d60:	1007883a 	mov	r3,r2
80131d64:	d0a08917 	ldw	r2,-32220(gp)
80131d68:	1884b03a 	or	r2,r3,r2
80131d6c:	d0a08915 	stw	r2,-32220(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
80131d70:	d0a08917 	ldw	r2,-32220(gp)
80131d74:	100170fa 	wrctl	ienable,r2
80131d78:	e0bff817 	ldw	r2,-32(fp)
80131d7c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80131d80:	e0bff917 	ldw	r2,-28(fp)
80131d84:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
80131d88:	0005883a 	mov	r2,zero
80131d8c:	00001906 	br	80131df4 <alt_irq_register+0x160>
80131d90:	e0bffd17 	ldw	r2,-12(fp)
80131d94:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80131d98:	0005303a 	rdctl	r2,status
80131d9c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80131da0:	e0fffa17 	ldw	r3,-24(fp)
80131da4:	00bfff84 	movi	r2,-2
80131da8:	1884703a 	and	r2,r3,r2
80131dac:	1001703a 	wrctl	status,r2
  
  return context;
80131db0:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
80131db4:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
80131db8:	00c00044 	movi	r3,1
80131dbc:	e0bff417 	ldw	r2,-48(fp)
80131dc0:	1884983a 	sll	r2,r3,r2
80131dc4:	0084303a 	nor	r2,zero,r2
80131dc8:	1007883a 	mov	r3,r2
80131dcc:	d0a08917 	ldw	r2,-32220(gp)
80131dd0:	1884703a 	and	r2,r3,r2
80131dd4:	d0a08915 	stw	r2,-32220(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
80131dd8:	d0a08917 	ldw	r2,-32220(gp)
80131ddc:	100170fa 	wrctl	ienable,r2
80131de0:	e0bffb17 	ldw	r2,-20(fp)
80131de4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80131de8:	e0bffc17 	ldw	r2,-16(fp)
80131dec:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
80131df0:	0005883a 	mov	r2,zero
80131df4:	e0bff115 	stw	r2,-60(fp)
80131df8:	e0bff317 	ldw	r2,-52(fp)
80131dfc:	e0bff515 	stw	r2,-44(fp)
80131e00:	e0bff517 	ldw	r2,-44(fp)
80131e04:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
80131e08:	e0bff117 	ldw	r2,-60(fp)
}
80131e0c:	e037883a 	mov	sp,fp
80131e10:	df000017 	ldw	fp,0(sp)
80131e14:	dec00104 	addi	sp,sp,4
80131e18:	f800283a 	ret

80131e1c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80131e1c:	defffe04 	addi	sp,sp,-8
80131e20:	de00012e 	bgeu	sp,et,80131e28 <alt_get_errno+0xc>
80131e24:	003b68fa 	trap	3
80131e28:	dfc00115 	stw	ra,4(sp)
80131e2c:	df000015 	stw	fp,0(sp)
80131e30:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
80131e34:	d0a00f17 	ldw	r2,-32708(gp)
80131e38:	10000326 	beq	r2,zero,80131e48 <alt_get_errno+0x2c>
80131e3c:	d0a00f17 	ldw	r2,-32708(gp)
80131e40:	103ee83a 	callr	r2
80131e44:	00000106 	br	80131e4c <alt_get_errno+0x30>
80131e48:	d0a08704 	addi	r2,gp,-32228
}
80131e4c:	e037883a 	mov	sp,fp
80131e50:	dfc00117 	ldw	ra,4(sp)
80131e54:	df000017 	ldw	fp,0(sp)
80131e58:	dec00204 	addi	sp,sp,8
80131e5c:	f800283a 	ret

80131e60 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
80131e60:	deffed04 	addi	sp,sp,-76
80131e64:	de00012e 	bgeu	sp,et,80131e6c <isatty+0xc>
80131e68:	003b68fa 	trap	3
80131e6c:	dfc01215 	stw	ra,72(sp)
80131e70:	df001115 	stw	fp,68(sp)
80131e74:	df001104 	addi	fp,sp,68
80131e78:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
80131e7c:	e0bfff17 	ldw	r2,-4(fp)
80131e80:	10000616 	blt	r2,zero,80131e9c <isatty+0x3c>
80131e84:	e0bfff17 	ldw	r2,-4(fp)
80131e88:	10c00324 	muli	r3,r2,12
80131e8c:	00a00574 	movhi	r2,32789
80131e90:	10a36f04 	addi	r2,r2,-29252
80131e94:	1885883a 	add	r2,r3,r2
80131e98:	00000106 	br	80131ea0 <isatty+0x40>
80131e9c:	0005883a 	mov	r2,zero
80131ea0:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
80131ea4:	e0bfef17 	ldw	r2,-68(fp)
80131ea8:	10000e26 	beq	r2,zero,80131ee4 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
80131eac:	e0bfef17 	ldw	r2,-68(fp)
80131eb0:	10800017 	ldw	r2,0(r2)
80131eb4:	10800817 	ldw	r2,32(r2)
80131eb8:	1000021e 	bne	r2,zero,80131ec4 <isatty+0x64>
    {
      return 1;
80131ebc:	00800044 	movi	r2,1
80131ec0:	00000d06 	br	80131ef8 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
80131ec4:	e0bff004 	addi	r2,fp,-64
80131ec8:	100b883a 	mov	r5,r2
80131ecc:	e13fff17 	ldw	r4,-4(fp)
80131ed0:	0131bdc0 	call	80131bdc <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
80131ed4:	e0bff117 	ldw	r2,-60(fp)
80131ed8:	10880020 	cmpeqi	r2,r2,8192
80131edc:	10803fcc 	andi	r2,r2,255
80131ee0:	00000506 	br	80131ef8 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
80131ee4:	0131e1c0 	call	80131e1c <alt_get_errno>
80131ee8:	1007883a 	mov	r3,r2
80131eec:	00801444 	movi	r2,81
80131ef0:	18800015 	stw	r2,0(r3)
    return 0;
80131ef4:	0005883a 	mov	r2,zero
  }
}
80131ef8:	e037883a 	mov	sp,fp
80131efc:	dfc00117 	ldw	ra,4(sp)
80131f00:	df000017 	ldw	fp,0(sp)
80131f04:	dec00204 	addi	sp,sp,8
80131f08:	f800283a 	ret

80131f0c <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
80131f0c:	01a00834 	movhi	r6,32800
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
80131f10:	31840004 	addi	r6,r6,4096

80131f14 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
80131f14:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
80131f18:	01c00826 	beq	zero,r7,80131f3c <end_tx>

80131f1c <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
80131f1c:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
80131f20:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
80131f24:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
80131f28:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
80131f2c:	283ffb26 	beq	r5,zero,80131f1c <__reset+0xfa111f1c>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
80131f30:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
80131f34:	21000044 	addi	r4,r4,1
	br tx_next_char
80131f38:	003ff606 	br	80131f14 <__reset+0xfa111f14>

80131f3c <end_tx>:
end_tx:	
        ret
80131f3c:	f800283a 	ret

80131f40 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
80131f40:	defffd04 	addi	sp,sp,-12
80131f44:	de00012e 	bgeu	sp,et,80131f4c <alt_log_txchar+0xc>
80131f48:	003b68fa 	trap	3
80131f4c:	df000215 	stw	fp,8(sp)
80131f50:	df000204 	addi	fp,sp,8
80131f54:	e13ffe15 	stw	r4,-8(fp)
80131f58:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
80131f5c:	0001883a 	nop
80131f60:	e0bfff17 	ldw	r2,-4(fp)
80131f64:	10800104 	addi	r2,r2,4
80131f68:	10800037 	ldwio	r2,0(r2)
80131f6c:	10bfffec 	andhi	r2,r2,65535
80131f70:	103ffb26 	beq	r2,zero,80131f60 <__reset+0xfa111f60>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
80131f74:	e0bfff17 	ldw	r2,-4(fp)
80131f78:	e0fffe17 	ldw	r3,-8(fp)
80131f7c:	10c00035 	stwio	r3,0(r2)
}
80131f80:	0001883a 	nop
80131f84:	e037883a 	mov	sp,fp
80131f88:	df000017 	ldw	fp,0(sp)
80131f8c:	dec00104 	addi	sp,sp,4
80131f90:	f800283a 	ret

80131f94 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
80131f94:	defffb04 	addi	sp,sp,-20
80131f98:	de00012e 	bgeu	sp,et,80131fa0 <alt_log_repchar+0xc>
80131f9c:	003b68fa 	trap	3
80131fa0:	dfc00415 	stw	ra,16(sp)
80131fa4:	df000315 	stw	fp,12(sp)
80131fa8:	df000304 	addi	fp,sp,12
80131fac:	2005883a 	mov	r2,r4
80131fb0:	e17ffe15 	stw	r5,-8(fp)
80131fb4:	e1bfff15 	stw	r6,-4(fp)
80131fb8:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
80131fbc:	00000506 	br	80131fd4 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
80131fc0:	e0bffd07 	ldb	r2,-12(fp)
80131fc4:	e0ffff17 	ldw	r3,-4(fp)
80131fc8:	180b883a 	mov	r5,r3
80131fcc:	1009883a 	mov	r4,r2
80131fd0:	0131f400 	call	80131f40 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
80131fd4:	e0bffe17 	ldw	r2,-8(fp)
80131fd8:	10ffffc4 	addi	r3,r2,-1
80131fdc:	e0fffe15 	stw	r3,-8(fp)
80131fe0:	00bff716 	blt	zero,r2,80131fc0 <__reset+0xfa111fc0>
    alt_log_txchar(c,(char*) base);
}
80131fe4:	0001883a 	nop
80131fe8:	e037883a 	mov	sp,fp
80131fec:	dfc00117 	ldw	ra,4(sp)
80131ff0:	df000017 	ldw	fp,0(sp)
80131ff4:	dec00204 	addi	sp,sp,8
80131ff8:	f800283a 	ret

80131ffc <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
80131ffc:	deffe904 	addi	sp,sp,-92
80132000:	de00012e 	bgeu	sp,et,80132008 <alt_log_private_printf+0xc>
80132004:	003b68fa 	trap	3
80132008:	dfc01615 	stw	ra,88(sp)
8013200c:	df001515 	stw	fp,84(sp)
80132010:	dc001415 	stw	r16,80(sp)
80132014:	df001504 	addi	fp,sp,84
80132018:	e13ffc15 	stw	r4,-16(fp)
8013201c:	e17ffd15 	stw	r5,-12(fp)
80132020:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
80132024:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
80132028:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
8013202c:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
80132030:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
80132034:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
80132038:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
8013203c:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
80132040:	e0bffc17 	ldw	r2,-16(fp)
80132044:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
80132048:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
8013204c:	00014b06 	br	8013257c <alt_log_private_printf+0x580>
    {
    switch(state)
80132050:	e0bfec17 	ldw	r2,-80(fp)
80132054:	10c00060 	cmpeqi	r3,r2,1
80132058:	18001b1e 	bne	r3,zero,801320c8 <alt_log_private_printf+0xcc>
8013205c:	10c000a0 	cmpeqi	r3,r2,2
80132060:	18002d1e 	bne	r3,zero,80132118 <alt_log_private_printf+0x11c>
80132064:	10000126 	beq	r2,zero,8013206c <alt_log_private_printf+0x70>
80132068:	00014406 	br	8013257c <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
8013206c:	e0bffb07 	ldb	r2,-20(fp)
80132070:	10800958 	cmpnei	r2,r2,37
80132074:	10000e1e 	bne	r2,zero,801320b0 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
80132078:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
8013207c:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
80132080:	00800284 	movi	r2,10
80132084:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
80132088:	00800044 	movi	r2,1
8013208c:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
80132090:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
80132094:	00bfffc4 	movi	r2,-1
80132098:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
8013209c:	00bfffc4 	movi	r2,-1
801320a0:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
801320a4:	00800044 	movi	r2,1
801320a8:	e0bfec15 	stw	r2,-80(fp)
801320ac:	00013306 	br	8013257c <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
801320b0:	e0bffb07 	ldb	r2,-20(fp)
801320b4:	e0fffd17 	ldw	r3,-12(fp)
801320b8:	180b883a 	mov	r5,r3
801320bc:	1009883a 	mov	r4,r2
801320c0:	0131f400 	call	80131f40 <alt_log_txchar>
        }
        break;
801320c4:	00012d06 	br	8013257c <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
801320c8:	e0bffb07 	ldb	r2,-20(fp)
801320cc:	10800c18 	cmpnei	r2,r2,48
801320d0:	1000051e 	bne	r2,zero,801320e8 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
801320d4:	00800044 	movi	r2,1
801320d8:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
801320dc:	00800084 	movi	r2,2
801320e0:	e0bfec15 	stw	r2,-80(fp)
801320e4:	00012506 	br	8013257c <alt_log_private_printf+0x580>
        }
        else if(c == '%')
801320e8:	e0bffb07 	ldb	r2,-20(fp)
801320ec:	10800958 	cmpnei	r2,r2,37
801320f0:	1000071e 	bne	r2,zero,80132110 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
801320f4:	e0bffb07 	ldb	r2,-20(fp)
801320f8:	e0fffd17 	ldw	r3,-12(fp)
801320fc:	180b883a 	mov	r5,r3
80132100:	1009883a 	mov	r4,r2
80132104:	0131f400 	call	80131f40 <alt_log_txchar>
          state = pfState_chars;
80132108:	e03fec15 	stw	zero,-80(fp)
8013210c:	00011b06 	br	8013257c <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
80132110:	00800084 	movi	r2,2
80132114:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
80132118:	e0bffb07 	ldb	r2,-20(fp)
8013211c:	10800b98 	cmpnei	r2,r2,46
80132120:	1000021e 	bne	r2,zero,8013212c <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
80132124:	e03ff015 	stw	zero,-64(fp)
80132128:	00011306 	br	80132578 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
8013212c:	e0bffb07 	ldb	r2,-20(fp)
80132130:	10800c10 	cmplti	r2,r2,48
80132134:	10001a1e 	bne	r2,zero,801321a0 <alt_log_private_printf+0x1a4>
80132138:	e0bffb07 	ldb	r2,-20(fp)
8013213c:	10800e88 	cmpgei	r2,r2,58
80132140:	1000171e 	bne	r2,zero,801321a0 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
80132144:	e0bffb03 	ldbu	r2,-20(fp)
80132148:	10bff404 	addi	r2,r2,-48
8013214c:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
80132150:	e0bff017 	ldw	r2,-64(fp)
80132154:	10000c0e 	bge	r2,zero,80132188 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
80132158:	e0bfef17 	ldw	r2,-68(fp)
8013215c:	1000020e 	bge	r2,zero,80132168 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
80132160:	e03fef15 	stw	zero,-68(fp)
80132164:	00000306 	br	80132174 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
80132168:	e0bfef17 	ldw	r2,-68(fp)
8013216c:	108002a4 	muli	r2,r2,10
80132170:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
80132174:	e0bffb07 	ldb	r2,-20(fp)
80132178:	e0ffef17 	ldw	r3,-68(fp)
8013217c:	1885883a 	add	r2,r3,r2
80132180:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
80132184:	0000fc06 	br	80132578 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
80132188:	e0bff017 	ldw	r2,-64(fp)
8013218c:	10c002a4 	muli	r3,r2,10
80132190:	e0bffb07 	ldb	r2,-20(fp)
80132194:	1885883a 	add	r2,r3,r2
80132198:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8013219c:	0000f606 	br	80132578 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
801321a0:	e0bffb07 	ldb	r2,-20(fp)
801321a4:	10801b18 	cmpnei	r2,r2,108
801321a8:	1000031e 	bne	r2,zero,801321b8 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
801321ac:	00800044 	movi	r2,1
801321b0:	e0bfee15 	stw	r2,-72(fp)
801321b4:	0000f006 	br	80132578 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
801321b8:	e0bffb07 	ldb	r2,-20(fp)
801321bc:	10bfea04 	addi	r2,r2,-88
801321c0:	10c00868 	cmpgeui	r3,r2,33
801321c4:	1800eb1e 	bne	r3,zero,80132574 <alt_log_private_printf+0x578>
801321c8:	100690ba 	slli	r3,r2,2
801321cc:	00a004f4 	movhi	r2,32787
801321d0:	10887804 	addi	r2,r2,8672
801321d4:	1885883a 	add	r2,r3,r2
801321d8:	10800017 	ldw	r2,0(r2)
801321dc:	1000683a 	jmp	r2
801321e0:	801324a0 	cmpeqi	zero,r16,19602
801321e4:	80132574 	orhi	zero,r16,19605
801321e8:	80132574 	orhi	zero,r16,19605
801321ec:	80132574 	orhi	zero,r16,19605
801321f0:	80132574 	orhi	zero,r16,19605
801321f4:	80132574 	orhi	zero,r16,19605
801321f8:	80132574 	orhi	zero,r16,19605
801321fc:	80132574 	orhi	zero,r16,19605
80132200:	80132574 	orhi	zero,r16,19605
80132204:	80132574 	orhi	zero,r16,19605
80132208:	80132574 	orhi	zero,r16,19605
8013220c:	801324b8 	rdprs	zero,r16,19602
80132210:	80132264 	muli	zero,r16,19593
80132214:	80132574 	orhi	zero,r16,19605
80132218:	80132574 	orhi	zero,r16,19605
8013221c:	80132574 	orhi	zero,r16,19605
80132220:	80132574 	orhi	zero,r16,19605
80132224:	80132264 	muli	zero,r16,19593
80132228:	80132574 	orhi	zero,r16,19605
8013222c:	80132574 	orhi	zero,r16,19605
80132230:	80132574 	orhi	zero,r16,19605
80132234:	80132574 	orhi	zero,r16,19605
80132238:	80132574 	orhi	zero,r16,19605
8013223c:	80132480 	call	88013248 <__reset+0x1ff3248>
80132240:	80132574 	orhi	zero,r16,19605
80132244:	80132574 	orhi	zero,r16,19605
80132248:	80132574 	orhi	zero,r16,19605
8013224c:	801324f4 	orhi	zero,r16,19603
80132250:	80132574 	orhi	zero,r16,19605
80132254:	80132478 	rdprs	zero,r16,19601
80132258:	80132574 	orhi	zero,r16,19605
8013225c:	80132574 	orhi	zero,r16,19605
80132260:	80132490 	cmplti	zero,r16,19602
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
80132264:	e0bfee17 	ldw	r2,-72(fp)
80132268:	10000e26 	beq	r2,zero,801322a4 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
8013226c:	e0bff217 	ldw	r2,-56(fp)
80132270:	10000626 	beq	r2,zero,8013228c <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
80132274:	e0bffe17 	ldw	r2,-8(fp)
80132278:	10c00104 	addi	r3,r2,4
8013227c:	e0fffe15 	stw	r3,-8(fp)
80132280:	10800017 	ldw	r2,0(r2)
80132284:	e0bff415 	stw	r2,-48(fp)
80132288:	00001306 	br	801322d8 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
8013228c:	e0bffe17 	ldw	r2,-8(fp)
80132290:	10c00104 	addi	r3,r2,4
80132294:	e0fffe15 	stw	r3,-8(fp)
80132298:	10800017 	ldw	r2,0(r2)
8013229c:	e0bff415 	stw	r2,-48(fp)
801322a0:	00000d06 	br	801322d8 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
801322a4:	e0bff217 	ldw	r2,-56(fp)
801322a8:	10000626 	beq	r2,zero,801322c4 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
801322ac:	e0bffe17 	ldw	r2,-8(fp)
801322b0:	10c00104 	addi	r3,r2,4
801322b4:	e0fffe15 	stw	r3,-8(fp)
801322b8:	10800017 	ldw	r2,0(r2)
801322bc:	e0bff415 	stw	r2,-48(fp)
801322c0:	00000506 	br	801322d8 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
801322c4:	e0bffe17 	ldw	r2,-8(fp)
801322c8:	10c00104 	addi	r3,r2,4
801322cc:	e0fffe15 	stw	r3,-8(fp)
801322d0:	10800017 	ldw	r2,0(r2)
801322d4:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
801322d8:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
801322dc:	e0bff217 	ldw	r2,-56(fp)
801322e0:	10000726 	beq	r2,zero,80132300 <alt_log_private_printf+0x304>
801322e4:	e0bff417 	ldw	r2,-48(fp)
801322e8:	1000050e 	bge	r2,zero,80132300 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
801322ec:	e0bff417 	ldw	r2,-48(fp)
801322f0:	0085c83a 	sub	r2,zero,r2
801322f4:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
801322f8:	00800044 	movi	r2,1
801322fc:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
80132300:	e0bff417 	ldw	r2,-48(fp)
80132304:	e0bff615 	stw	r2,-40(fp)
                p = 1;
80132308:	00800044 	movi	r2,1
8013230c:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
80132310:	00800044 	movi	r2,1
80132314:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
80132318:	00000706 	br	80132338 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
8013231c:	e0bff817 	ldw	r2,-32(fp)
80132320:	10800044 	addi	r2,r2,1
80132324:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
80132328:	e0bff117 	ldw	r2,-60(fp)
8013232c:	e0fff517 	ldw	r3,-44(fp)
80132330:	1885383a 	mul	r2,r3,r2
80132334:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
80132338:	e0bff117 	ldw	r2,-60(fp)
8013233c:	e0fff617 	ldw	r3,-40(fp)
80132340:	1885203a 	divu	r2,r3,r2
80132344:	e0bff615 	stw	r2,-40(fp)
80132348:	e0bff617 	ldw	r2,-40(fp)
8013234c:	103ff31e 	bne	r2,zero,8013231c <__reset+0xfa11231c>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
80132350:	e0ffef17 	ldw	r3,-68(fp)
80132354:	e0bff817 	ldw	r2,-32(fp)
80132358:	1885c83a 	sub	r2,r3,r2
8013235c:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
80132360:	e0bfed17 	ldw	r2,-76(fp)
80132364:	10000e26 	beq	r2,zero,801323a0 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
80132368:	e0bff717 	ldw	r2,-36(fp)
8013236c:	10000726 	beq	r2,zero,8013238c <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
80132370:	e0bffd17 	ldw	r2,-12(fp)
80132374:	100b883a 	mov	r5,r2
80132378:	01000b44 	movi	r4,45
8013237c:	0131f400 	call	80131f40 <alt_log_txchar>
                    fmtBeforeDecimal--;
80132380:	e0bfef17 	ldw	r2,-68(fp)
80132384:	10bfffc4 	addi	r2,r2,-1
80132388:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
8013238c:	e1bffd17 	ldw	r6,-12(fp)
80132390:	e17fef17 	ldw	r5,-68(fp)
80132394:	01000c04 	movi	r4,48
80132398:	0131f940 	call	80131f94 <alt_log_repchar>
8013239c:	00003206 	br	80132468 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
801323a0:	e0bff717 	ldw	r2,-36(fp)
801323a4:	10000326 	beq	r2,zero,801323b4 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
801323a8:	e0bfef17 	ldw	r2,-68(fp)
801323ac:	10bfffc4 	addi	r2,r2,-1
801323b0:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
801323b4:	e1bffd17 	ldw	r6,-12(fp)
801323b8:	e17fef17 	ldw	r5,-68(fp)
801323bc:	01000804 	movi	r4,32
801323c0:	0131f940 	call	80131f94 <alt_log_repchar>
                    if(sign)
801323c4:	e0bff717 	ldw	r2,-36(fp)
801323c8:	10002726 	beq	r2,zero,80132468 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
801323cc:	e0bffd17 	ldw	r2,-12(fp)
801323d0:	100b883a 	mov	r5,r2
801323d4:	01000b44 	movi	r4,45
801323d8:	0131f400 	call	80131f40 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
801323dc:	00002206 	br	80132468 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
801323e0:	e0fff417 	ldw	r3,-48(fp)
801323e4:	e0bff517 	ldw	r2,-44(fp)
801323e8:	1885203a 	divu	r2,r3,r2
801323ec:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
801323f0:	e0bff903 	ldbu	r2,-28(fp)
801323f4:	10800c04 	addi	r2,r2,48
801323f8:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
801323fc:	e0bff903 	ldbu	r2,-28(fp)
80132400:	10800eb0 	cmpltui	r2,r2,58
80132404:	1000081e 	bne	r2,zero,80132428 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
80132408:	e0bff317 	ldw	r2,-52(fp)
8013240c:	10000226 	beq	r2,zero,80132418 <alt_log_private_printf+0x41c>
80132410:	008001c4 	movi	r2,7
80132414:	00000106 	br	8013241c <alt_log_private_printf+0x420>
80132418:	008009c4 	movi	r2,39
8013241c:	e0fff903 	ldbu	r3,-28(fp)
80132420:	10c5883a 	add	r2,r2,r3
80132424:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
80132428:	e0bff903 	ldbu	r2,-28(fp)
8013242c:	e0fffd17 	ldw	r3,-12(fp)
80132430:	180b883a 	mov	r5,r3
80132434:	1009883a 	mov	r4,r2
80132438:	0131f400 	call	80131f40 <alt_log_txchar>

                  v = v % p;
8013243c:	e0bff417 	ldw	r2,-48(fp)
80132440:	e0fff517 	ldw	r3,-44(fp)
80132444:	10c9203a 	divu	r4,r2,r3
80132448:	e0fff517 	ldw	r3,-44(fp)
8013244c:	20c7383a 	mul	r3,r4,r3
80132450:	10c5c83a 	sub	r2,r2,r3
80132454:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
80132458:	e0bff117 	ldw	r2,-60(fp)
8013245c:	e0fff517 	ldw	r3,-44(fp)
80132460:	1885203a 	divu	r2,r3,r2
80132464:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
80132468:	e0bff517 	ldw	r2,-44(fp)
8013246c:	103fdc1e 	bne	r2,zero,801323e0 <__reset+0xfa1123e0>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
80132470:	e03fec15 	stw	zero,-80(fp)
              break;
80132474:	00003f06 	br	80132574 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
80132478:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
8013247c:	003f7906 	br	80132264 <__reset+0xfa112264>
            case 'o':
              fmtSigned = 0;
80132480:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
80132484:	00800204 	movi	r2,8
80132488:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8013248c:	003f7506 	br	80132264 <__reset+0xfa112264>
            case 'x':
              fmtSigned = 0;
80132490:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
80132494:	00800404 	movi	r2,16
80132498:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8013249c:	003f7106 	br	80132264 <__reset+0xfa112264>
            case 'X':
              fmtSigned = 0;
801324a0:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
801324a4:	00800404 	movi	r2,16
801324a8:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
801324ac:	00800044 	movi	r2,1
801324b0:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
801324b4:	003f6b06 	br	80132264 <__reset+0xfa112264>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
801324b8:	e0bfef17 	ldw	r2,-68(fp)
801324bc:	10bfffc4 	addi	r2,r2,-1
801324c0:	e1bffd17 	ldw	r6,-12(fp)
801324c4:	100b883a 	mov	r5,r2
801324c8:	01000804 	movi	r4,32
801324cc:	0131f940 	call	80131f94 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
801324d0:	e0bffe17 	ldw	r2,-8(fp)
801324d4:	10c00104 	addi	r3,r2,4
801324d8:	e0fffe15 	stw	r3,-8(fp)
801324dc:	10800017 	ldw	r2,0(r2)
801324e0:	e0fffd17 	ldw	r3,-12(fp)
801324e4:	180b883a 	mov	r5,r3
801324e8:	1009883a 	mov	r4,r2
801324ec:	0131f400 	call	80131f40 <alt_log_txchar>
              break;
801324f0:	00002006 	br	80132574 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
801324f4:	e0bffe17 	ldw	r2,-8(fp)
801324f8:	10c00104 	addi	r3,r2,4
801324fc:	e0fffe15 	stw	r3,-8(fp)
80132500:	10800017 	ldw	r2,0(r2)
80132504:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
80132508:	e43fef17 	ldw	r16,-68(fp)
8013250c:	e13ffa17 	ldw	r4,-24(fp)
80132510:	01219540 	call	80121954 <strlen>
80132514:	8085c83a 	sub	r2,r16,r2
80132518:	e1bffd17 	ldw	r6,-12(fp)
8013251c:	100b883a 	mov	r5,r2
80132520:	01000804 	movi	r4,32
80132524:	0131f940 	call	80131f94 <alt_log_repchar>

                while(*s)
80132528:	00000b06 	br	80132558 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
8013252c:	e0bffa17 	ldw	r2,-24(fp)
80132530:	10c00044 	addi	r3,r2,1
80132534:	e0fffa15 	stw	r3,-24(fp)
80132538:	10800003 	ldbu	r2,0(r2)
8013253c:	10803fcc 	andi	r2,r2,255
80132540:	1080201c 	xori	r2,r2,128
80132544:	10bfe004 	addi	r2,r2,-128
80132548:	e0fffd17 	ldw	r3,-12(fp)
8013254c:	180b883a 	mov	r5,r3
80132550:	1009883a 	mov	r4,r2
80132554:	0131f400 	call	80131f40 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
80132558:	e0bffa17 	ldw	r2,-24(fp)
8013255c:	10800003 	ldbu	r2,0(r2)
80132560:	10803fcc 	andi	r2,r2,255
80132564:	1080201c 	xori	r2,r2,128
80132568:	10bfe004 	addi	r2,r2,-128
8013256c:	103fef1e 	bne	r2,zero,8013252c <__reset+0xfa11252c>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
80132570:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
80132574:	e03fec15 	stw	zero,-80(fp)
          }
        break;
80132578:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
8013257c:	e0bfeb17 	ldw	r2,-84(fp)
80132580:	10c00044 	addi	r3,r2,1
80132584:	e0ffeb15 	stw	r3,-84(fp)
80132588:	10800003 	ldbu	r2,0(r2)
8013258c:	e0bffb05 	stb	r2,-20(fp)
80132590:	e0bffb07 	ldb	r2,-20(fp)
80132594:	103eae1e 	bne	r2,zero,80132050 <__reset+0xfa112050>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
80132598:	0001883a 	nop
8013259c:	e6ffff04 	addi	sp,fp,-4
801325a0:	dfc00217 	ldw	ra,8(sp)
801325a4:	df000117 	ldw	fp,4(sp)
801325a8:	dc000017 	ldw	r16,0(sp)
801325ac:	dec00304 	addi	sp,sp,12
801325b0:	f800283a 	ret

801325b4 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
801325b4:	defff904 	addi	sp,sp,-28
801325b8:	de00012e 	bgeu	sp,et,801325c0 <alt_log_printf_proc+0xc>
801325bc:	003b68fa 	trap	3
801325c0:	dfc00315 	stw	ra,12(sp)
801325c4:	df000215 	stw	fp,8(sp)
801325c8:	df000204 	addi	fp,sp,8
801325cc:	e13fff15 	stw	r4,-4(fp)
801325d0:	e1400215 	stw	r5,8(fp)
801325d4:	e1800315 	stw	r6,12(fp)
801325d8:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
801325dc:	e0800204 	addi	r2,fp,8
801325e0:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
801325e4:	e0bffe17 	ldw	r2,-8(fp)
801325e8:	100d883a 	mov	r6,r2
801325ec:	01600834 	movhi	r5,32800
801325f0:	29440004 	addi	r5,r5,4096
801325f4:	e13fff17 	ldw	r4,-4(fp)
801325f8:	0131ffc0 	call	80131ffc <alt_log_private_printf>
    return (0);
801325fc:	0005883a 	mov	r2,zero
}
80132600:	e037883a 	mov	sp,fp
80132604:	dfc00117 	ldw	ra,4(sp)
80132608:	df000017 	ldw	fp,0(sp)
8013260c:	dec00504 	addi	sp,sp,20
80132610:	f800283a 	ret

80132614 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
80132614:	defff904 	addi	sp,sp,-28
80132618:	de00012e 	bgeu	sp,et,80132620 <altera_avalon_jtag_uart_report_log+0xc>
8013261c:	003b68fa 	trap	3
80132620:	dfc00615 	stw	ra,24(sp)
80132624:	df000515 	stw	fp,20(sp)
80132628:	dc400415 	stw	r17,16(sp)
8013262c:	dc000315 	stw	r16,12(sp)
80132630:	df000504 	addi	fp,sp,20
80132634:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
80132638:	d0a08a83 	ldbu	r2,-32214(gp)
8013263c:	10803fcc 	andi	r2,r2,255
80132640:	10001426 	beq	r2,zero,80132694 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
80132644:	e0bffd17 	ldw	r2,-12(fp)
80132648:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
8013264c:	00a00534 	movhi	r2,32788
80132650:	109f9704 	addi	r2,r2,32348
80132654:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
80132658:	e0bffb17 	ldw	r2,-20(fp)
8013265c:	10800017 	ldw	r2,0(r2)
80132660:	e1bffc17 	ldw	r6,-16(fp)
80132664:	100b883a 	mov	r5,r2
80132668:	e13ffb17 	ldw	r4,-20(fp)
8013266c:	01326b40 	call	801326b4 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
80132670:	d0e09117 	ldw	r3,-32188(gp)
        return ALT_LOG_JTAG_UART_TICKS;
80132674:	00b33374 	movhi	r2,52429
80132678:	10b33344 	addi	r2,r2,-13107
8013267c:	1888383a 	mulxuu	r4,r3,r2
80132680:	1885383a 	mul	r2,r3,r2
80132684:	1021883a 	mov	r16,r2
80132688:	2023883a 	mov	r17,r4
8013268c:	8804d0fa 	srli	r2,r17,3
80132690:	00000106 	br	80132698 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
80132694:	0005883a 	mov	r2,zero
    }
}
80132698:	e6fffe04 	addi	sp,fp,-8
8013269c:	dfc00317 	ldw	ra,12(sp)
801326a0:	df000217 	ldw	fp,8(sp)
801326a4:	dc400117 	ldw	r17,4(sp)
801326a8:	dc000017 	ldw	r16,0(sp)
801326ac:	dec00404 	addi	sp,sp,16
801326b0:	f800283a 	ret

801326b4 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
801326b4:	deffef04 	addi	sp,sp,-68
801326b8:	de00012e 	bgeu	sp,et,801326c0 <alt_log_jtag_uart_print_control_reg+0xc>
801326bc:	003b68fa 	trap	3
801326c0:	dfc01015 	stw	ra,64(sp)
801326c4:	df000f15 	stw	fp,60(sp)
801326c8:	df000f04 	addi	fp,sp,60
801326cc:	e13ffd15 	stw	r4,-12(fp)
801326d0:	e17ffe15 	stw	r5,-8(fp)
801326d4:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
801326d8:	e0bffe17 	ldw	r2,-8(fp)
801326dc:	10800104 	addi	r2,r2,4
801326e0:	10800037 	ldwio	r2,0(r2)
801326e4:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
801326e8:	e0bff617 	ldw	r2,-40(fp)
801326ec:	1004d43a 	srli	r2,r2,16
801326f0:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
801326f4:	e0bff617 	ldw	r2,-40(fp)
801326f8:	1080008c 	andi	r2,r2,2
801326fc:	1004d07a 	srli	r2,r2,1
80132700:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
80132704:	e0bff617 	ldw	r2,-40(fp)
80132708:	1080004c 	andi	r2,r2,1
8013270c:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
80132710:	e0bff617 	ldw	r2,-40(fp)
80132714:	1080400c 	andi	r2,r2,256
80132718:	1004d23a 	srli	r2,r2,8
8013271c:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
80132720:	e0bff617 	ldw	r2,-40(fp)
80132724:	1080800c 	andi	r2,r2,512
80132728:	1004d27a 	srli	r2,r2,9
8013272c:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
80132730:	e0bff617 	ldw	r2,-40(fp)
80132734:	1081000c 	andi	r2,r2,1024
80132738:	1004d2ba 	srli	r2,r2,10
8013273c:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
80132740:	e0bffd17 	ldw	r2,-12(fp)
80132744:	10c01017 	ldw	r3,64(r2)
80132748:	e0bffd17 	ldw	r2,-12(fp)
8013274c:	10800f17 	ldw	r2,60(r2)
80132750:	1887c83a 	sub	r3,r3,r2
80132754:	e0bff917 	ldw	r2,-28(fp)
80132758:	d8800415 	stw	r2,16(sp)
8013275c:	e0bff817 	ldw	r2,-32(fp)
80132760:	d8800315 	stw	r2,12(sp)
80132764:	e0bffa17 	ldw	r2,-24(fp)
80132768:	d8800215 	stw	r2,8(sp)
8013276c:	e0bffb17 	ldw	r2,-20(fp)
80132770:	d8800115 	stw	r2,4(sp)
80132774:	e0bffc17 	ldw	r2,-16(fp)
80132778:	d8800015 	stw	r2,0(sp)
8013277c:	e1fff717 	ldw	r7,-36(fp)
80132780:	180d883a 	mov	r6,r3
80132784:	e17fff17 	ldw	r5,-4(fp)
80132788:	01200534 	movhi	r4,32788
8013278c:	211f9a04 	addi	r4,r4,32360
80132790:	01325b40 	call	801325b4 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
80132794:	0001883a 	nop

}
80132798:	e037883a 	mov	sp,fp
8013279c:	dfc00117 	ldw	ra,4(sp)
801327a0:	df000017 	ldw	fp,0(sp)
801327a4:	dec00204 	addi	sp,sp,8
801327a8:	f800283a 	ret

801327ac <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
801327ac:	defffb04 	addi	sp,sp,-20
801327b0:	de00012e 	bgeu	sp,et,801327b8 <alt_log_jtag_uart_startup_info+0xc>
801327b4:	003b68fa 	trap	3
801327b8:	dfc00415 	stw	ra,16(sp)
801327bc:	df000315 	stw	fp,12(sp)
801327c0:	df000304 	addi	fp,sp,12
801327c4:	e13ffe15 	stw	r4,-8(fp)
801327c8:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
801327cc:	00a00534 	movhi	r2,32788
801327d0:	109fac04 	addi	r2,r2,32432
801327d4:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
801327d8:	e1bffd17 	ldw	r6,-12(fp)
801327dc:	e17fff17 	ldw	r5,-4(fp)
801327e0:	e13ffe17 	ldw	r4,-8(fp)
801327e4:	01326b40 	call	801326b4 <alt_log_jtag_uart_print_control_reg>
     return;
801327e8:	0001883a 	nop
}
801327ec:	e037883a 	mov	sp,fp
801327f0:	dfc00117 	ldw	ra,4(sp)
801327f4:	df000017 	ldw	fp,0(sp)
801327f8:	dec00204 	addi	sp,sp,8
801327fc:	f800283a 	ret

80132800 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
80132800:	defffb04 	addi	sp,sp,-20
80132804:	de00012e 	bgeu	sp,et,8013280c <alt_log_jtag_uart_isr_proc+0xc>
80132808:	003b68fa 	trap	3
8013280c:	dfc00415 	stw	ra,16(sp)
80132810:	df000315 	stw	fp,12(sp)
80132814:	df000304 	addi	fp,sp,12
80132818:	e13ffe15 	stw	r4,-8(fp)
8013281c:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
80132820:	d0a08ac3 	ldbu	r2,-32213(gp)
80132824:	10803fcc 	andi	r2,r2,255
80132828:	10000826 	beq	r2,zero,8013284c <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
8013282c:	00a00534 	movhi	r2,32788
80132830:	109fb104 	addi	r2,r2,32452
80132834:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
80132838:	e1bffd17 	ldw	r6,-12(fp)
8013283c:	e17ffe17 	ldw	r5,-8(fp)
80132840:	e13fff17 	ldw	r4,-4(fp)
80132844:	01326b40 	call	801326b4 <alt_log_jtag_uart_print_control_reg>
    }
    return;
80132848:	0001883a 	nop
8013284c:	0001883a 	nop
}
80132850:	e037883a 	mov	sp,fp
80132854:	dfc00117 	ldw	ra,4(sp)
80132858:	df000017 	ldw	fp,0(sp)
8013285c:	dec00204 	addi	sp,sp,8
80132860:	f800283a 	ret

80132864 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
80132864:	defffa04 	addi	sp,sp,-24
80132868:	de00012e 	bgeu	sp,et,80132870 <alt_log_write+0xc>
8013286c:	003b68fa 	trap	3
80132870:	dfc00515 	stw	ra,20(sp)
80132874:	df000415 	stw	fp,16(sp)
80132878:	df000404 	addi	fp,sp,16
8013287c:	e13ffe15 	stw	r4,-8(fp)
80132880:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
80132884:	d0a08a03 	ldbu	r2,-32216(gp)
80132888:	10803fcc 	andi	r2,r2,255
8013288c:	10004026 	beq	r2,zero,80132990 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
80132890:	e0bfff17 	ldw	r2,-4(fp)
80132894:	10c00430 	cmpltui	r3,r2,16
80132898:	1800011e 	bne	r3,zero,801328a0 <alt_log_write+0x3c>
8013289c:	008003c4 	movi	r2,15
801328a0:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
801328a4:	e0bffd17 	ldw	r2,-12(fp)
801328a8:	10800088 	cmpgei	r2,r2,2
801328ac:	10003726 	beq	r2,zero,8013298c <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
801328b0:	e0bffd17 	ldw	r2,-12(fp)
801328b4:	100d883a 	mov	r6,r2
801328b8:	e17ffe17 	ldw	r5,-8(fp)
801328bc:	012005b4 	movhi	r4,32790
801328c0:	213a4a04 	addi	r4,r4,-5848
801328c4:	01469a80 	call	801469a8 <strncpy>
    alt_log_write_buf[length-1]='\n';
801328c8:	e0bffd17 	ldw	r2,-12(fp)
801328cc:	10ffffc4 	addi	r3,r2,-1
801328d0:	00a005b4 	movhi	r2,32790
801328d4:	10ba4a04 	addi	r2,r2,-5848
801328d8:	10c5883a 	add	r2,r2,r3
801328dc:	00c00284 	movi	r3,10
801328e0:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
801328e4:	00a005b4 	movhi	r2,32790
801328e8:	10ba4a04 	addi	r2,r2,-5848
801328ec:	e0fffd17 	ldw	r3,-12(fp)
801328f0:	10c5883a 	add	r2,r2,r3
801328f4:	00c00344 	movi	r3,13
801328f8:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
801328fc:	e0bffd17 	ldw	r2,-12(fp)
80132900:	10c00044 	addi	r3,r2,1
80132904:	00a005b4 	movhi	r2,32790
80132908:	10ba4a04 	addi	r2,r2,-5848
8013290c:	10c5883a 	add	r2,r2,r3
80132910:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
80132914:	e03ffc15 	stw	zero,-16(fp)
80132918:	00001306 	br	80132968 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
8013291c:	00a005b4 	movhi	r2,32790
80132920:	10ba4a04 	addi	r2,r2,-5848
80132924:	e0fffc17 	ldw	r3,-16(fp)
80132928:	10c5883a 	add	r2,r2,r3
8013292c:	10800003 	ldbu	r2,0(r2)
80132930:	10803fcc 	andi	r2,r2,255
80132934:	1080201c 	xori	r2,r2,128
80132938:	10bfe004 	addi	r2,r2,-128
8013293c:	10800118 	cmpnei	r2,r2,4
80132940:	1000061e 	bne	r2,zero,8013295c <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
80132944:	00a005b4 	movhi	r2,32790
80132948:	10ba4a04 	addi	r2,r2,-5848
8013294c:	e0fffc17 	ldw	r3,-16(fp)
80132950:	10c5883a 	add	r2,r2,r3
80132954:	00c01104 	movi	r3,68
80132958:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8013295c:	e0bffc17 	ldw	r2,-16(fp)
80132960:	10800044 	addi	r2,r2,1
80132964:	e0bffc15 	stw	r2,-16(fp)
80132968:	e0fffc17 	ldw	r3,-16(fp)
8013296c:	e0bffd17 	ldw	r2,-12(fp)
80132970:	18bfea16 	blt	r3,r2,8013291c <__reset+0xfa11291c>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
80132974:	016005b4 	movhi	r5,32790
80132978:	297a4a04 	addi	r5,r5,-5848
8013297c:	01200534 	movhi	r4,32788
80132980:	211fb404 	addi	r4,r4,32464
80132984:	01325b40 	call	801325b4 <alt_log_printf_proc>
80132988:	00000106 	br	80132990 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
8013298c:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
80132990:	e037883a 	mov	sp,fp
80132994:	dfc00117 	ldw	ra,4(sp)
80132998:	df000017 	ldw	fp,0(sp)
8013299c:	dec00204 	addi	sp,sp,8
801329a0:	f800283a 	ret

801329a4 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
801329a4:	defffe04 	addi	sp,sp,-8
801329a8:	de00012e 	bgeu	sp,et,801329b0 <alt_log_system_clock+0xc>
801329ac:	003b68fa 	trap	3
801329b0:	dfc00115 	stw	ra,4(sp)
801329b4:	df000015 	stw	fp,0(sp)
801329b8:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
801329bc:	d0a08a43 	ldbu	r2,-32215(gp)
801329c0:	10803fcc 	andi	r2,r2,255
801329c4:	10000e26 	beq	r2,zero,80132a00 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
801329c8:	d0a08d17 	ldw	r2,-32204(gp)
801329cc:	10800044 	addi	r2,r2,1
801329d0:	d0a08d15 	stw	r2,-32204(gp)
801329d4:	d0a09117 	ldw	r2,-32188(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
801329d8:	d0e08d17 	ldw	r3,-32204(gp)
801329dc:	10c0082e 	bgeu	r2,r3,80132a00 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
801329e0:	d0208d15 	stw	zero,-32204(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
801329e4:	d0a08c17 	ldw	r2,-32208(gp)
801329e8:	10c00044 	addi	r3,r2,1
801329ec:	d0e08c15 	stw	r3,-32208(gp)
801329f0:	100b883a 	mov	r5,r2
801329f4:	01200534 	movhi	r4,32788
801329f8:	211fb804 	addi	r4,r4,32480
801329fc:	01325b40 	call	801325b4 <alt_log_printf_proc>
        }
    }
}
80132a00:	0001883a 	nop
80132a04:	e037883a 	mov	sp,fp
80132a08:	dfc00117 	ldw	ra,4(sp)
80132a0c:	df000017 	ldw	fp,0(sp)
80132a10:	dec00204 	addi	sp,sp,8
80132a14:	f800283a 	ret

80132a18 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80132a18:	defffe04 	addi	sp,sp,-8
80132a1c:	de00012e 	bgeu	sp,et,80132a24 <alt_get_errno+0xc>
80132a20:	003b68fa 	trap	3
80132a24:	dfc00115 	stw	ra,4(sp)
80132a28:	df000015 	stw	fp,0(sp)
80132a2c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
80132a30:	d0a00f17 	ldw	r2,-32708(gp)
80132a34:	10000326 	beq	r2,zero,80132a44 <alt_get_errno+0x2c>
80132a38:	d0a00f17 	ldw	r2,-32708(gp)
80132a3c:	103ee83a 	callr	r2
80132a40:	00000106 	br	80132a48 <alt_get_errno+0x30>
80132a44:	d0a08704 	addi	r2,gp,-32228
}
80132a48:	e037883a 	mov	sp,fp
80132a4c:	dfc00117 	ldw	ra,4(sp)
80132a50:	df000017 	ldw	fp,0(sp)
80132a54:	dec00204 	addi	sp,sp,8
80132a58:	f800283a 	ret

80132a5c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
80132a5c:	defff904 	addi	sp,sp,-28
80132a60:	de00012e 	bgeu	sp,et,80132a68 <lseek+0xc>
80132a64:	003b68fa 	trap	3
80132a68:	dfc00615 	stw	ra,24(sp)
80132a6c:	df000515 	stw	fp,20(sp)
80132a70:	df000504 	addi	fp,sp,20
80132a74:	e13ffd15 	stw	r4,-12(fp)
80132a78:	e17ffe15 	stw	r5,-8(fp)
80132a7c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
80132a80:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
80132a84:	e0bffd17 	ldw	r2,-12(fp)
80132a88:	10000616 	blt	r2,zero,80132aa4 <lseek+0x48>
80132a8c:	e0bffd17 	ldw	r2,-12(fp)
80132a90:	10c00324 	muli	r3,r2,12
80132a94:	00a00574 	movhi	r2,32789
80132a98:	10a36f04 	addi	r2,r2,-29252
80132a9c:	1885883a 	add	r2,r3,r2
80132aa0:	00000106 	br	80132aa8 <lseek+0x4c>
80132aa4:	0005883a 	mov	r2,zero
80132aa8:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
80132aac:	e0bffc17 	ldw	r2,-16(fp)
80132ab0:	10001026 	beq	r2,zero,80132af4 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
80132ab4:	e0bffc17 	ldw	r2,-16(fp)
80132ab8:	10800017 	ldw	r2,0(r2)
80132abc:	10800717 	ldw	r2,28(r2)
80132ac0:	10000926 	beq	r2,zero,80132ae8 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
80132ac4:	e0bffc17 	ldw	r2,-16(fp)
80132ac8:	10800017 	ldw	r2,0(r2)
80132acc:	10800717 	ldw	r2,28(r2)
80132ad0:	e1bfff17 	ldw	r6,-4(fp)
80132ad4:	e17ffe17 	ldw	r5,-8(fp)
80132ad8:	e13ffc17 	ldw	r4,-16(fp)
80132adc:	103ee83a 	callr	r2
80132ae0:	e0bffb15 	stw	r2,-20(fp)
80132ae4:	00000506 	br	80132afc <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
80132ae8:	00bfde84 	movi	r2,-134
80132aec:	e0bffb15 	stw	r2,-20(fp)
80132af0:	00000206 	br	80132afc <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
80132af4:	00bfebc4 	movi	r2,-81
80132af8:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
80132afc:	e0bffb17 	ldw	r2,-20(fp)
80132b00:	1000070e 	bge	r2,zero,80132b20 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
80132b04:	0132a180 	call	80132a18 <alt_get_errno>
80132b08:	1007883a 	mov	r3,r2
80132b0c:	e0bffb17 	ldw	r2,-20(fp)
80132b10:	0085c83a 	sub	r2,zero,r2
80132b14:	18800015 	stw	r2,0(r3)
    rc = -1;
80132b18:	00bfffc4 	movi	r2,-1
80132b1c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
80132b20:	e0bffb17 	ldw	r2,-20(fp)
}
80132b24:	e037883a 	mov	sp,fp
80132b28:	dfc00117 	ldw	ra,4(sp)
80132b2c:	df000017 	ldw	fp,0(sp)
80132b30:	dec00204 	addi	sp,sp,8
80132b34:	f800283a 	ret

80132b38 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
80132b38:	defff904 	addi	sp,sp,-28
80132b3c:	de00012e 	bgeu	sp,et,80132b44 <alt_main+0xc>
80132b40:	003b68fa 	trap	3
80132b44:	dfc00615 	stw	ra,24(sp)
80132b48:	df000515 	stw	fp,20(sp)
80132b4c:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
80132b50:	d0a01117 	ldw	r2,-32700(gp)
80132b54:	10800058 	cmpnei	r2,r2,1
80132b58:	1000031e 	bne	r2,zero,80132b68 <alt_main+0x30>
80132b5c:	01200534 	movhi	r4,32788
80132b60:	211fbe04 	addi	r4,r4,32504
80132b64:	01325b40 	call	801325b4 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
80132b68:	0009883a 	mov	r4,zero
80132b6c:	013d4240 	call	8013d424 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
80132b70:	d0a01117 	ldw	r2,-32700(gp)
80132b74:	10800058 	cmpnei	r2,r2,1
80132b78:	1000031e 	bne	r2,zero,80132b88 <alt_main+0x50>
80132b7c:	01200534 	movhi	r4,32788
80132b80:	211fcc04 	addi	r4,r4,32560
80132b84:	01325b40 	call	801325b4 <alt_log_printf_proc>
  ALT_OS_INIT();
80132b88:	0133eb80 	call	80133eb8 <OSInit>
80132b8c:	01000044 	movi	r4,1
80132b90:	0139bd40 	call	80139bd4 <OSSemCreate>
80132b94:	d0a09415 	stw	r2,-32176(gp)
80132b98:	01000044 	movi	r4,1
80132b9c:	0139bd40 	call	80139bd4 <OSSemCreate>
80132ba0:	d0a09615 	stw	r2,-32168(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
80132ba4:	d0a01117 	ldw	r2,-32700(gp)
80132ba8:	10800058 	cmpnei	r2,r2,1
80132bac:	1000031e 	bne	r2,zero,80132bbc <alt_main+0x84>
80132bb0:	01200534 	movhi	r4,32788
80132bb4:	211fda04 	addi	r4,r4,32616
80132bb8:	01325b40 	call	801325b4 <alt_log_printf_proc>
80132bbc:	d0a08804 	addi	r2,gp,-32224
80132bc0:	e0bffc15 	stw	r2,-16(fp)
80132bc4:	00800044 	movi	r2,1
80132bc8:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
80132bcc:	e0bffd0b 	ldhu	r2,-12(fp)
80132bd0:	1009883a 	mov	r4,r2
80132bd4:	0139bd40 	call	80139bd4 <OSSemCreate>
80132bd8:	1007883a 	mov	r3,r2
80132bdc:	e0bffc17 	ldw	r2,-16(fp)
80132be0:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
80132be4:	d0a01117 	ldw	r2,-32700(gp)
80132be8:	10800058 	cmpnei	r2,r2,1
80132bec:	1000031e 	bne	r2,zero,80132bfc <alt_main+0xc4>
80132bf0:	01200534 	movhi	r4,32788
80132bf4:	211fe804 	addi	r4,r4,32672
80132bf8:	01325b40 	call	801325b4 <alt_log_printf_proc>
  alt_sys_init();
80132bfc:	013d4640 	call	8013d464 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
80132c00:	d0a01117 	ldw	r2,-32700(gp)
80132c04:	10800058 	cmpnei	r2,r2,1
80132c08:	1000031e 	bne	r2,zero,80132c18 <alt_main+0xe0>
80132c0c:	01200534 	movhi	r4,32788
80132c10:	211ff204 	addi	r4,r4,32712
80132c14:	01325b40 	call	801325b4 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
80132c18:	d0a01117 	ldw	r2,-32700(gp)
80132c1c:	10800058 	cmpnei	r2,r2,1
80132c20:	1000031e 	bne	r2,zero,80132c30 <alt_main+0xf8>
80132c24:	01200534 	movhi	r4,32788
80132c28:	211ffb04 	addi	r4,r4,32748
80132c2c:	01325b40 	call	801325b4 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
80132c30:	01a00574 	movhi	r6,32789
80132c34:	31a00304 	addi	r6,r6,-32756
80132c38:	01600574 	movhi	r5,32789
80132c3c:	29600604 	addi	r5,r5,-32744
80132c40:	01200574 	movhi	r4,32789
80132c44:	21200604 	addi	r4,r4,-32744
80132c48:	0145b600 	call	80145b60 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
80132c4c:	d0a01117 	ldw	r2,-32700(gp)
80132c50:	10800058 	cmpnei	r2,r2,1
80132c54:	1000031e 	bne	r2,zero,80132c64 <alt_main+0x12c>
80132c58:	01200574 	movhi	r4,32789
80132c5c:	21200a04 	addi	r4,r4,-32728
80132c60:	01325b40 	call	801325b4 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
80132c64:	d0a08e17 	ldw	r2,-32200(gp)
80132c68:	d0e08f17 	ldw	r3,-32196(gp)
80132c6c:	d1209017 	ldw	r4,-32192(gp)
80132c70:	200d883a 	mov	r6,r4
80132c74:	180b883a 	mov	r5,r3
80132c78:	1009883a 	mov	r4,r2
80132c7c:	01193d00 	call	801193d0 <main>
80132c80:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
80132c84:	01000044 	movi	r4,1
80132c88:	0131a640 	call	80131a64 <close>
  exit (result);
80132c8c:	e13ffb17 	ldw	r4,-20(fp)
80132c90:	01467740 	call	80146774 <exit>

80132c94 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80132c94:	defffe04 	addi	sp,sp,-8
80132c98:	de00012e 	bgeu	sp,et,80132ca0 <alt_get_errno+0xc>
80132c9c:	003b68fa 	trap	3
80132ca0:	dfc00115 	stw	ra,4(sp)
80132ca4:	df000015 	stw	fp,0(sp)
80132ca8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
80132cac:	d0a00f17 	ldw	r2,-32708(gp)
80132cb0:	10000326 	beq	r2,zero,80132cc0 <alt_get_errno+0x2c>
80132cb4:	d0a00f17 	ldw	r2,-32708(gp)
80132cb8:	103ee83a 	callr	r2
80132cbc:	00000106 	br	80132cc4 <alt_get_errno+0x30>
80132cc0:	d0a08704 	addi	r2,gp,-32228
}
80132cc4:	e037883a 	mov	sp,fp
80132cc8:	dfc00117 	ldw	ra,4(sp)
80132ccc:	df000017 	ldw	fp,0(sp)
80132cd0:	dec00204 	addi	sp,sp,8
80132cd4:	f800283a 	ret

80132cd8 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
80132cd8:	defff904 	addi	sp,sp,-28
80132cdc:	de00012e 	bgeu	sp,et,80132ce4 <read+0xc>
80132ce0:	003b68fa 	trap	3
80132ce4:	dfc00615 	stw	ra,24(sp)
80132ce8:	df000515 	stw	fp,20(sp)
80132cec:	df000504 	addi	fp,sp,20
80132cf0:	e13ffd15 	stw	r4,-12(fp)
80132cf4:	e17ffe15 	stw	r5,-8(fp)
80132cf8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
80132cfc:	e0bffd17 	ldw	r2,-12(fp)
80132d00:	10000616 	blt	r2,zero,80132d1c <read+0x44>
80132d04:	e0bffd17 	ldw	r2,-12(fp)
80132d08:	10c00324 	muli	r3,r2,12
80132d0c:	00a00574 	movhi	r2,32789
80132d10:	10a36f04 	addi	r2,r2,-29252
80132d14:	1885883a 	add	r2,r3,r2
80132d18:	00000106 	br	80132d20 <read+0x48>
80132d1c:	0005883a 	mov	r2,zero
80132d20:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
80132d24:	e0bffb17 	ldw	r2,-20(fp)
80132d28:	10002226 	beq	r2,zero,80132db4 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
80132d2c:	e0bffb17 	ldw	r2,-20(fp)
80132d30:	10800217 	ldw	r2,8(r2)
80132d34:	108000cc 	andi	r2,r2,3
80132d38:	10800060 	cmpeqi	r2,r2,1
80132d3c:	1000181e 	bne	r2,zero,80132da0 <read+0xc8>
        (fd->dev->read))
80132d40:	e0bffb17 	ldw	r2,-20(fp)
80132d44:	10800017 	ldw	r2,0(r2)
80132d48:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
80132d4c:	10001426 	beq	r2,zero,80132da0 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
80132d50:	e0bffb17 	ldw	r2,-20(fp)
80132d54:	10800017 	ldw	r2,0(r2)
80132d58:	10800517 	ldw	r2,20(r2)
80132d5c:	e0ffff17 	ldw	r3,-4(fp)
80132d60:	180d883a 	mov	r6,r3
80132d64:	e17ffe17 	ldw	r5,-8(fp)
80132d68:	e13ffb17 	ldw	r4,-20(fp)
80132d6c:	103ee83a 	callr	r2
80132d70:	e0bffc15 	stw	r2,-16(fp)
80132d74:	e0bffc17 	ldw	r2,-16(fp)
80132d78:	1000070e 	bge	r2,zero,80132d98 <read+0xc0>
        {
          ALT_ERRNO = -rval;
80132d7c:	0132c940 	call	80132c94 <alt_get_errno>
80132d80:	1007883a 	mov	r3,r2
80132d84:	e0bffc17 	ldw	r2,-16(fp)
80132d88:	0085c83a 	sub	r2,zero,r2
80132d8c:	18800015 	stw	r2,0(r3)
          return -1;
80132d90:	00bfffc4 	movi	r2,-1
80132d94:	00000c06 	br	80132dc8 <read+0xf0>
        }
        return rval;
80132d98:	e0bffc17 	ldw	r2,-16(fp)
80132d9c:	00000a06 	br	80132dc8 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
80132da0:	0132c940 	call	80132c94 <alt_get_errno>
80132da4:	1007883a 	mov	r3,r2
80132da8:	00800344 	movi	r2,13
80132dac:	18800015 	stw	r2,0(r3)
80132db0:	00000406 	br	80132dc4 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
80132db4:	0132c940 	call	80132c94 <alt_get_errno>
80132db8:	1007883a 	mov	r3,r2
80132dbc:	00801444 	movi	r2,81
80132dc0:	18800015 	stw	r2,0(r3)
  }
  return -1;
80132dc4:	00bfffc4 	movi	r2,-1
}
80132dc8:	e037883a 	mov	sp,fp
80132dcc:	dfc00117 	ldw	ra,4(sp)
80132dd0:	df000017 	ldw	fp,0(sp)
80132dd4:	dec00204 	addi	sp,sp,8
80132dd8:	f800283a 	ret

80132ddc <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
80132ddc:	defffe04 	addi	sp,sp,-8
80132de0:	de00012e 	bgeu	sp,et,80132de8 <alt_release_fd+0xc>
80132de4:	003b68fa 	trap	3
80132de8:	df000115 	stw	fp,4(sp)
80132dec:	df000104 	addi	fp,sp,4
80132df0:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
80132df4:	e0bfff17 	ldw	r2,-4(fp)
80132df8:	108000d0 	cmplti	r2,r2,3
80132dfc:	10000d1e 	bne	r2,zero,80132e34 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
80132e00:	00a00574 	movhi	r2,32789
80132e04:	10a36f04 	addi	r2,r2,-29252
80132e08:	e0ffff17 	ldw	r3,-4(fp)
80132e0c:	18c00324 	muli	r3,r3,12
80132e10:	10c5883a 	add	r2,r2,r3
80132e14:	10800204 	addi	r2,r2,8
80132e18:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
80132e1c:	00a00574 	movhi	r2,32789
80132e20:	10a36f04 	addi	r2,r2,-29252
80132e24:	e0ffff17 	ldw	r3,-4(fp)
80132e28:	18c00324 	muli	r3,r3,12
80132e2c:	10c5883a 	add	r2,r2,r3
80132e30:	10000015 	stw	zero,0(r2)
  }
}
80132e34:	0001883a 	nop
80132e38:	e037883a 	mov	sp,fp
80132e3c:	df000017 	ldw	fp,0(sp)
80132e40:	dec00104 	addi	sp,sp,4
80132e44:	f800283a 	ret

80132e48 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
80132e48:	defff604 	addi	sp,sp,-40
80132e4c:	de00012e 	bgeu	sp,et,80132e54 <sbrk+0xc>
80132e50:	003b68fa 	trap	3
80132e54:	df000915 	stw	fp,36(sp)
80132e58:	df000904 	addi	fp,sp,36
80132e5c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80132e60:	0005303a 	rdctl	r2,status
80132e64:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80132e68:	e0fffe17 	ldw	r3,-8(fp)
80132e6c:	00bfff84 	movi	r2,-2
80132e70:	1884703a 	and	r2,r3,r2
80132e74:	1001703a 	wrctl	status,r2
  
  return context;
80132e78:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
80132e7c:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
80132e80:	d0a01217 	ldw	r2,-32696(gp)
80132e84:	10c000c4 	addi	r3,r2,3
80132e88:	00bfff04 	movi	r2,-4
80132e8c:	1884703a 	and	r2,r3,r2
80132e90:	d0a01215 	stw	r2,-32696(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
80132e94:	d0e01217 	ldw	r3,-32696(gp)
80132e98:	e0bfff17 	ldw	r2,-4(fp)
80132e9c:	1887883a 	add	r3,r3,r2
80132ea0:	00a007b4 	movhi	r2,32798
80132ea4:	10800004 	addi	r2,r2,0
80132ea8:	10c0062e 	bgeu	r2,r3,80132ec4 <sbrk+0x7c>
80132eac:	e0bff817 	ldw	r2,-32(fp)
80132eb0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80132eb4:	e0bff717 	ldw	r2,-36(fp)
80132eb8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
80132ebc:	00bfffc4 	movi	r2,-1
80132ec0:	00001c06 	br	80132f34 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
80132ec4:	d0a01217 	ldw	r2,-32696(gp)
80132ec8:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
80132ecc:	d0e01217 	ldw	r3,-32696(gp)
80132ed0:	e0bfff17 	ldw	r2,-4(fp)
80132ed4:	1885883a 	add	r2,r3,r2
80132ed8:	d0a01215 	stw	r2,-32696(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
80132edc:	c005883a 	mov	r2,et
80132ee0:	e0bff915 	stw	r2,-28(fp)

  return limit; 
80132ee4:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
80132ee8:	e0bffa17 	ldw	r2,-24(fp)
80132eec:	18800c1e 	bne	r3,r2,80132f20 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
80132ef0:	d805883a 	mov	r2,sp
80132ef4:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
80132ef8:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
80132efc:	d0e01217 	ldw	r3,-32696(gp)
80132f00:	18800136 	bltu	r3,r2,80132f08 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
80132f04:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
80132f08:	d0a01217 	ldw	r2,-32696(gp)
80132f0c:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
80132f10:	e0bffc17 	ldw	r2,-16(fp)
80132f14:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
80132f18:	e0bffc17 	ldw	r2,-16(fp)
80132f1c:	1031883a 	mov	et,r2
80132f20:	e0bff817 	ldw	r2,-32(fp)
80132f24:	e0bffd15 	stw	r2,-12(fp)
80132f28:	e0bffd17 	ldw	r2,-12(fp)
80132f2c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
80132f30:	e0bffa17 	ldw	r2,-24(fp)
} 
80132f34:	e037883a 	mov	sp,fp
80132f38:	df000017 	ldw	fp,0(sp)
80132f3c:	dec00104 	addi	sp,sp,4
80132f40:	f800283a 	ret

80132f44 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
80132f44:	defffa04 	addi	sp,sp,-24
80132f48:	de00012e 	bgeu	sp,et,80132f50 <alt_alarm_stop+0xc>
80132f4c:	003b68fa 	trap	3
80132f50:	df000515 	stw	fp,20(sp)
80132f54:	df000504 	addi	fp,sp,20
80132f58:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80132f5c:	0005303a 	rdctl	r2,status
80132f60:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80132f64:	e0fffc17 	ldw	r3,-16(fp)
80132f68:	00bfff84 	movi	r2,-2
80132f6c:	1884703a 	and	r2,r3,r2
80132f70:	1001703a 	wrctl	status,r2
  
  return context;
80132f74:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
80132f78:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
80132f7c:	e0bfff17 	ldw	r2,-4(fp)
80132f80:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
80132f84:	e0bffd17 	ldw	r2,-12(fp)
80132f88:	10800017 	ldw	r2,0(r2)
80132f8c:	e0fffd17 	ldw	r3,-12(fp)
80132f90:	18c00117 	ldw	r3,4(r3)
80132f94:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
80132f98:	e0bffd17 	ldw	r2,-12(fp)
80132f9c:	10800117 	ldw	r2,4(r2)
80132fa0:	e0fffd17 	ldw	r3,-12(fp)
80132fa4:	18c00017 	ldw	r3,0(r3)
80132fa8:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
80132fac:	e0bffd17 	ldw	r2,-12(fp)
80132fb0:	e0fffd17 	ldw	r3,-12(fp)
80132fb4:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
80132fb8:	e0bffd17 	ldw	r2,-12(fp)
80132fbc:	e0fffd17 	ldw	r3,-12(fp)
80132fc0:	10c00015 	stw	r3,0(r2)
80132fc4:	e0bffb17 	ldw	r2,-20(fp)
80132fc8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80132fcc:	e0bffe17 	ldw	r2,-8(fp)
80132fd0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
80132fd4:	0001883a 	nop
80132fd8:	e037883a 	mov	sp,fp
80132fdc:	df000017 	ldw	fp,0(sp)
80132fe0:	dec00104 	addi	sp,sp,4
80132fe4:	f800283a 	ret

80132fe8 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
80132fe8:	defffb04 	addi	sp,sp,-20
80132fec:	de00012e 	bgeu	sp,et,80132ff4 <alt_tick+0xc>
80132ff0:	003b68fa 	trap	3
80132ff4:	dfc00415 	stw	ra,16(sp)
80132ff8:	df000315 	stw	fp,12(sp)
80132ffc:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
80133000:	d0a01317 	ldw	r2,-32692(gp)
80133004:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
80133008:	d0a09217 	ldw	r2,-32184(gp)
8013300c:	10800044 	addi	r2,r2,1
80133010:	d0a09215 	stw	r2,-32184(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
80133014:	00002e06 	br	801330d0 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
80133018:	e0bffd17 	ldw	r2,-12(fp)
8013301c:	10800017 	ldw	r2,0(r2)
80133020:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
80133024:	e0bffd17 	ldw	r2,-12(fp)
80133028:	10800403 	ldbu	r2,16(r2)
8013302c:	10803fcc 	andi	r2,r2,255
80133030:	10000426 	beq	r2,zero,80133044 <alt_tick+0x5c>
80133034:	d0a09217 	ldw	r2,-32184(gp)
80133038:	1000021e 	bne	r2,zero,80133044 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
8013303c:	e0bffd17 	ldw	r2,-12(fp)
80133040:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
80133044:	e0bffd17 	ldw	r2,-12(fp)
80133048:	10800217 	ldw	r2,8(r2)
8013304c:	d0e09217 	ldw	r3,-32184(gp)
80133050:	18801d36 	bltu	r3,r2,801330c8 <alt_tick+0xe0>
80133054:	e0bffd17 	ldw	r2,-12(fp)
80133058:	10800403 	ldbu	r2,16(r2)
8013305c:	10803fcc 	andi	r2,r2,255
80133060:	1000191e 	bne	r2,zero,801330c8 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
80133064:	e0bffd17 	ldw	r2,-12(fp)
80133068:	10800317 	ldw	r2,12(r2)
8013306c:	e0fffd17 	ldw	r3,-12(fp)
80133070:	18c00517 	ldw	r3,20(r3)
80133074:	1809883a 	mov	r4,r3
80133078:	103ee83a 	callr	r2
8013307c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
80133080:	e0bfff17 	ldw	r2,-4(fp)
80133084:	1000031e 	bne	r2,zero,80133094 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
80133088:	e13ffd17 	ldw	r4,-12(fp)
8013308c:	0132f440 	call	80132f44 <alt_alarm_stop>
80133090:	00000d06 	br	801330c8 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
80133094:	e0bffd17 	ldw	r2,-12(fp)
80133098:	10c00217 	ldw	r3,8(r2)
8013309c:	e0bfff17 	ldw	r2,-4(fp)
801330a0:	1887883a 	add	r3,r3,r2
801330a4:	e0bffd17 	ldw	r2,-12(fp)
801330a8:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
801330ac:	e0bffd17 	ldw	r2,-12(fp)
801330b0:	10c00217 	ldw	r3,8(r2)
801330b4:	d0a09217 	ldw	r2,-32184(gp)
801330b8:	1880032e 	bgeu	r3,r2,801330c8 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
801330bc:	e0bffd17 	ldw	r2,-12(fp)
801330c0:	00c00044 	movi	r3,1
801330c4:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
801330c8:	e0bffe17 	ldw	r2,-8(fp)
801330cc:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
801330d0:	e0fffd17 	ldw	r3,-12(fp)
801330d4:	d0a01304 	addi	r2,gp,-32692
801330d8:	18bfcf1e 	bne	r3,r2,80133018 <__reset+0xfa113018>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
801330dc:	01343180 	call	80134318 <OSTimeTick>
}
801330e0:	0001883a 	nop
801330e4:	e037883a 	mov	sp,fp
801330e8:	dfc00117 	ldw	ra,4(sp)
801330ec:	df000017 	ldw	fp,0(sp)
801330f0:	dec00204 	addi	sp,sp,8
801330f4:	f800283a 	ret

801330f8 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
801330f8:	defffb04 	addi	sp,sp,-20
801330fc:	de00012e 	bgeu	sp,et,80133104 <usleep+0xc>
80133100:	003b68fa 	trap	3
80133104:	dfc00415 	stw	ra,16(sp)
80133108:	df000315 	stw	fp,12(sp)
8013310c:	df000304 	addi	fp,sp,12
80133110:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
80133114:	d0a09a03 	ldbu	r2,-32152(gp)
80133118:	10803fcc 	andi	r2,r2,255
8013311c:	1000031e 	bne	r2,zero,8013312c <usleep+0x34>
  {
    return alt_busy_sleep (us);
80133120:	e13fff17 	ldw	r4,-4(fp)
80133124:	01318f00 	call	801318f0 <alt_busy_sleep>
80133128:	00003d06 	br	80133220 <usleep+0x128>
8013312c:	d0a09117 	ldw	r2,-32188(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
80133130:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
80133134:	e0ffff17 	ldw	r3,-4(fp)
80133138:	0090c734 	movhi	r2,17180
8013313c:	10b7a0c4 	addi	r2,r2,-8573
80133140:	1888383a 	mulxuu	r4,r3,r2
80133144:	1885383a 	mul	r2,r3,r2
80133148:	1013883a 	mov	r9,r2
8013314c:	2015883a 	mov	r10,r4
80133150:	5006d4ba 	srli	r3,r10,18
80133154:	e0bffe17 	ldw	r2,-8(fp)
80133158:	1893383a 	mul	r9,r3,r2
8013315c:	e0ffff17 	ldw	r3,-4(fp)
80133160:	0090c734 	movhi	r2,17180
80133164:	10b7a0c4 	addi	r2,r2,-8573
80133168:	1888383a 	mulxuu	r4,r3,r2
8013316c:	1885383a 	mul	r2,r3,r2
80133170:	100f883a 	mov	r7,r2
80133174:	2011883a 	mov	r8,r4
80133178:	4004d4ba 	srli	r2,r8,18
8013317c:	010003f4 	movhi	r4,15
80133180:	21109004 	addi	r4,r4,16960
80133184:	1105383a 	mul	r2,r2,r4
80133188:	1885c83a 	sub	r2,r3,r2
8013318c:	e0fffe17 	ldw	r3,-8(fp)
80133190:	10c7383a 	mul	r3,r2,r3
80133194:	0090c734 	movhi	r2,17180
80133198:	10b7a0c4 	addi	r2,r2,-8573
8013319c:	1888383a 	mulxuu	r4,r3,r2
801331a0:	1885383a 	mul	r2,r3,r2
801331a4:	100b883a 	mov	r5,r2
801331a8:	200d883a 	mov	r6,r4
801331ac:	3004d4ba 	srli	r2,r6,18
801331b0:	4885883a 	add	r2,r9,r2
801331b4:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
801331b8:	00000706 	br	801331d8 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
801331bc:	013fffd4 	movui	r4,65535
801331c0:	013bd880 	call	8013bd88 <OSTimeDly>
    ticks -= 0xffff;
801331c4:	e0fffd17 	ldw	r3,-12(fp)
801331c8:	00bffff4 	movhi	r2,65535
801331cc:	10800044 	addi	r2,r2,1
801331d0:	1885883a 	add	r2,r3,r2
801331d4:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
801331d8:	e0bffd17 	ldw	r2,-12(fp)
801331dc:	00ffffd4 	movui	r3,65535
801331e0:	18bff636 	bltu	r3,r2,801331bc <__reset+0xfa1131bc>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
801331e4:	e0bffd17 	ldw	r2,-12(fp)
801331e8:	10bfffcc 	andi	r2,r2,65535
801331ec:	1009883a 	mov	r4,r2
801331f0:	013bd880 	call	8013bd88 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
801331f4:	008003f4 	movhi	r2,15
801331f8:	10909004 	addi	r2,r2,16960
801331fc:	e0fffe17 	ldw	r3,-8(fp)
80133200:	10c7203a 	divu	r3,r2,r3
80133204:	e0bfff17 	ldw	r2,-4(fp)
80133208:	10c9203a 	divu	r4,r2,r3
8013320c:	20c7383a 	mul	r3,r4,r3
80133210:	10c5c83a 	sub	r2,r2,r3
80133214:	1009883a 	mov	r4,r2
80133218:	01318f00 	call	801318f0 <alt_busy_sleep>

  return 0;  
8013321c:	0005883a 	mov	r2,zero
}
80133220:	e037883a 	mov	sp,fp
80133224:	dfc00117 	ldw	ra,4(sp)
80133228:	df000017 	ldw	fp,0(sp)
8013322c:	dec00204 	addi	sp,sp,8
80133230:	f800283a 	ret

80133234 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80133234:	defffe04 	addi	sp,sp,-8
80133238:	de00012e 	bgeu	sp,et,80133240 <alt_get_errno+0xc>
8013323c:	003b68fa 	trap	3
80133240:	dfc00115 	stw	ra,4(sp)
80133244:	df000015 	stw	fp,0(sp)
80133248:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8013324c:	d0a00f17 	ldw	r2,-32708(gp)
80133250:	10000326 	beq	r2,zero,80133260 <alt_get_errno+0x2c>
80133254:	d0a00f17 	ldw	r2,-32708(gp)
80133258:	103ee83a 	callr	r2
8013325c:	00000106 	br	80133264 <alt_get_errno+0x30>
80133260:	d0a08704 	addi	r2,gp,-32228
}
80133264:	e037883a 	mov	sp,fp
80133268:	dfc00117 	ldw	ra,4(sp)
8013326c:	df000017 	ldw	fp,0(sp)
80133270:	dec00204 	addi	sp,sp,8
80133274:	f800283a 	ret

80133278 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
80133278:	defff904 	addi	sp,sp,-28
8013327c:	de00012e 	bgeu	sp,et,80133284 <write+0xc>
80133280:	003b68fa 	trap	3
80133284:	dfc00615 	stw	ra,24(sp)
80133288:	df000515 	stw	fp,20(sp)
8013328c:	df000504 	addi	fp,sp,20
80133290:	e13ffd15 	stw	r4,-12(fp)
80133294:	e17ffe15 	stw	r5,-8(fp)
80133298:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8013329c:	e0bffd17 	ldw	r2,-12(fp)
801332a0:	10000616 	blt	r2,zero,801332bc <write+0x44>
801332a4:	e0bffd17 	ldw	r2,-12(fp)
801332a8:	10c00324 	muli	r3,r2,12
801332ac:	00a00574 	movhi	r2,32789
801332b0:	10a36f04 	addi	r2,r2,-29252
801332b4:	1885883a 	add	r2,r3,r2
801332b8:	00000106 	br	801332c0 <write+0x48>
801332bc:	0005883a 	mov	r2,zero
801332c0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
801332c4:	e0bffb17 	ldw	r2,-20(fp)
801332c8:	10002426 	beq	r2,zero,8013335c <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
801332cc:	e0bffb17 	ldw	r2,-20(fp)
801332d0:	10800217 	ldw	r2,8(r2)
801332d4:	108000cc 	andi	r2,r2,3
801332d8:	10001b26 	beq	r2,zero,80133348 <write+0xd0>
801332dc:	e0bffb17 	ldw	r2,-20(fp)
801332e0:	10800017 	ldw	r2,0(r2)
801332e4:	10800617 	ldw	r2,24(r2)
801332e8:	10001726 	beq	r2,zero,80133348 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
801332ec:	e17fff17 	ldw	r5,-4(fp)
801332f0:	e13ffe17 	ldw	r4,-8(fp)
801332f4:	01328640 	call	80132864 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
801332f8:	e0bffb17 	ldw	r2,-20(fp)
801332fc:	10800017 	ldw	r2,0(r2)
80133300:	10800617 	ldw	r2,24(r2)
80133304:	e0ffff17 	ldw	r3,-4(fp)
80133308:	180d883a 	mov	r6,r3
8013330c:	e17ffe17 	ldw	r5,-8(fp)
80133310:	e13ffb17 	ldw	r4,-20(fp)
80133314:	103ee83a 	callr	r2
80133318:	e0bffc15 	stw	r2,-16(fp)
8013331c:	e0bffc17 	ldw	r2,-16(fp)
80133320:	1000070e 	bge	r2,zero,80133340 <write+0xc8>
      {
        ALT_ERRNO = -rval;
80133324:	01332340 	call	80133234 <alt_get_errno>
80133328:	1007883a 	mov	r3,r2
8013332c:	e0bffc17 	ldw	r2,-16(fp)
80133330:	0085c83a 	sub	r2,zero,r2
80133334:	18800015 	stw	r2,0(r3)
        return -1;
80133338:	00bfffc4 	movi	r2,-1
8013333c:	00000c06 	br	80133370 <write+0xf8>
      }
      return rval;
80133340:	e0bffc17 	ldw	r2,-16(fp)
80133344:	00000a06 	br	80133370 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
80133348:	01332340 	call	80133234 <alt_get_errno>
8013334c:	1007883a 	mov	r3,r2
80133350:	00800344 	movi	r2,13
80133354:	18800015 	stw	r2,0(r3)
80133358:	00000406 	br	8013336c <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
8013335c:	01332340 	call	80133234 <alt_get_errno>
80133360:	1007883a 	mov	r3,r2
80133364:	00801444 	movi	r2,81
80133368:	18800015 	stw	r2,0(r3)
  }
  return -1;
8013336c:	00bfffc4 	movi	r2,-1
}
80133370:	e037883a 	mov	sp,fp
80133374:	dfc00117 	ldw	ra,4(sp)
80133378:	df000017 	ldw	fp,0(sp)
8013337c:	dec00204 	addi	sp,sp,8
80133380:	f800283a 	ret

80133384 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
80133384:	deffde04 	addi	sp,sp,-136
80133388:	de00012e 	bgeu	sp,et,80133390 <__env_lock+0xc>
8013338c:	003b68fa 	trap	3
80133390:	dfc02115 	stw	ra,132(sp)
80133394:	df002015 	stw	fp,128(sp)
80133398:	df002004 	addi	fp,sp,128
8013339c:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
801333a0:	e0bfe104 	addi	r2,fp,-124
801333a4:	100b883a 	mov	r5,r2
801333a8:	01003fc4 	movi	r4,255
801333ac:	013bbe40 	call	8013bbe4 <OSTaskQuery>
801333b0:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
801333b4:	e0bffe83 	ldbu	r2,-6(fp)
801333b8:	10803fcc 	andi	r2,r2,255
801333bc:	10001e1e 	bne	r2,zero,80133438 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
801333c0:	e0bfed83 	ldbu	r2,-74(fp)
801333c4:	10803fcc 	andi	r2,r2,255
801333c8:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
801333cc:	d0a09417 	ldw	r2,-32176(gp)
801333d0:	e0fffc04 	addi	r3,fp,-16
801333d4:	180b883a 	mov	r5,r3
801333d8:	1009883a 	mov	r4,r2
801333dc:	013a39c0 	call	8013a39c <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
801333e0:	e0bffe03 	ldbu	r2,-8(fp)
801333e4:	10803fcc 	andi	r2,r2,255
801333e8:	10000726 	beq	r2,zero,80133408 <__env_lock+0x84>
801333ec:	d0a01517 	ldw	r2,-32684(gp)
801333f0:	e0ffe017 	ldw	r3,-128(fp)
801333f4:	1880041e 	bne	r3,r2,80133408 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
801333f8:	d0a09317 	ldw	r2,-32180(gp)
801333fc:	10800044 	addi	r2,r2,1
80133400:	d0a09315 	stw	r2,-32180(gp)
80133404:	00000a06 	br	80133430 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
80133408:	d0a09417 	ldw	r2,-32176(gp)
8013340c:	e0fffe84 	addi	r3,fp,-6
80133410:	180d883a 	mov	r6,r3
80133414:	000b883a 	mov	r5,zero
80133418:	1009883a 	mov	r4,r2
8013341c:	0139efc0 	call	80139efc <OSSemPend>
    locks  = 1;
80133420:	00800044 	movi	r2,1
80133424:	d0a09315 	stw	r2,-32180(gp)
    lockid = id;
80133428:	e0bfe017 	ldw	r2,-128(fp)
8013342c:	d0a01515 	stw	r2,-32684(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
80133430:	0001883a 	nop
80133434:	00000106 	br	8013343c <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
80133438:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8013343c:	e037883a 	mov	sp,fp
80133440:	dfc00117 	ldw	ra,4(sp)
80133444:	df000017 	ldw	fp,0(sp)
80133448:	dec00204 	addi	sp,sp,8
8013344c:	f800283a 	ret

80133450 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
80133450:	defffd04 	addi	sp,sp,-12
80133454:	de00012e 	bgeu	sp,et,8013345c <__env_unlock+0xc>
80133458:	003b68fa 	trap	3
8013345c:	dfc00215 	stw	ra,8(sp)
80133460:	df000115 	stw	fp,4(sp)
80133464:	df000104 	addi	fp,sp,4
80133468:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
8013346c:	d0a09317 	ldw	r2,-32180(gp)
80133470:	10000b26 	beq	r2,zero,801334a0 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
80133474:	d0a09317 	ldw	r2,-32180(gp)
80133478:	10bfffc4 	addi	r2,r2,-1
8013347c:	d0a09315 	stw	r2,-32180(gp)
80133480:	d0a09317 	ldw	r2,-32180(gp)
80133484:	1000071e 	bne	r2,zero,801334a4 <__env_unlock+0x54>
  {
    lockid = -1;
80133488:	00bfffc4 	movi	r2,-1
8013348c:	d0a01515 	stw	r2,-32684(gp)
    OSSemPost( alt_envsem );
80133490:	d0a09417 	ldw	r2,-32176(gp)
80133494:	1009883a 	mov	r4,r2
80133498:	013a2840 	call	8013a284 <OSSemPost>
8013349c:	00000106 	br	801334a4 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
801334a0:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
801334a4:	e037883a 	mov	sp,fp
801334a8:	dfc00117 	ldw	ra,4(sp)
801334ac:	df000017 	ldw	fp,0(sp)
801334b0:	dec00204 	addi	sp,sp,8
801334b4:	f800283a 	ret

801334b8 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
801334b8:	deffda04 	addi	sp,sp,-152
801334bc:	de00012e 	bgeu	sp,et,801334c4 <__malloc_lock+0xc>
801334c0:	003b68fa 	trap	3
801334c4:	dfc02515 	stw	ra,148(sp)
801334c8:	df002415 	stw	fp,144(sp)
801334cc:	df002404 	addi	fp,sp,144
801334d0:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801334d4:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
801334d8:	d0a09a03 	ldbu	r2,-32152(gp)
801334dc:	10803fcc 	andi	r2,r2,255
801334e0:	10800060 	cmpeqi	r2,r2,1
801334e4:	10003626 	beq	r2,zero,801335c0 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
801334e8:	e0bfe104 	addi	r2,fp,-124
801334ec:	100b883a 	mov	r5,r2
801334f0:	01003fc4 	movi	r4,255
801334f4:	013bbe40 	call	8013bbe4 <OSTaskQuery>
801334f8:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
801334fc:	e0bffe83 	ldbu	r2,-6(fp)
80133500:	10803fcc 	andi	r2,r2,255
80133504:	1000301e 	bne	r2,zero,801335c8 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
80133508:	e0bfed83 	ldbu	r2,-74(fp)
8013350c:	10803fcc 	andi	r2,r2,255
80133510:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
80133514:	d0a09617 	ldw	r2,-32168(gp)
80133518:	e0fffc04 	addi	r3,fp,-16
8013351c:	180b883a 	mov	r5,r3
80133520:	1009883a 	mov	r4,r2
80133524:	013a39c0 	call	8013a39c <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80133528:	0005303a 	rdctl	r2,status
8013352c:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80133530:	e0ffe017 	ldw	r3,-128(fp)
80133534:	00bfff84 	movi	r2,-2
80133538:	1884703a 	and	r2,r3,r2
8013353c:	1001703a 	wrctl	status,r2
  
  return context;
80133540:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
80133544:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
80133548:	e0bffc0b 	ldhu	r2,-16(fp)
8013354c:	10bfffcc 	andi	r2,r2,65535
80133550:	10000b1e 	bne	r2,zero,80133580 <__malloc_lock+0xc8>
80133554:	d0a01617 	ldw	r2,-32680(gp)
80133558:	e0ffdd17 	ldw	r3,-140(fp)
8013355c:	1880081e 	bne	r3,r2,80133580 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
80133560:	d0a09517 	ldw	r2,-32172(gp)
80133564:	10800044 	addi	r2,r2,1
80133568:	d0a09515 	stw	r2,-32172(gp)
8013356c:	e0bfdc17 	ldw	r2,-144(fp)
80133570:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80133574:	e0bfde17 	ldw	r2,-136(fp)
80133578:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
8013357c:	00000e06 	br	801335b8 <__malloc_lock+0x100>
80133580:	e0bfdc17 	ldw	r2,-144(fp)
80133584:	e0bfdf15 	stw	r2,-132(fp)
80133588:	e0bfdf17 	ldw	r2,-132(fp)
8013358c:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
80133590:	d0a09617 	ldw	r2,-32168(gp)
80133594:	e0fffe84 	addi	r3,fp,-6
80133598:	180d883a 	mov	r6,r3
8013359c:	000b883a 	mov	r5,zero
801335a0:	1009883a 	mov	r4,r2
801335a4:	0139efc0 	call	80139efc <OSSemPend>
    locks  = 1;
801335a8:	00800044 	movi	r2,1
801335ac:	d0a09515 	stw	r2,-32172(gp)
    lockid = id;
801335b0:	e0bfdd17 	ldw	r2,-140(fp)
801335b4:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
801335b8:	0001883a 	nop
801335bc:	00000306 	br	801335cc <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
801335c0:	0001883a 	nop
801335c4:	00000106 	br	801335cc <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
801335c8:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
801335cc:	e037883a 	mov	sp,fp
801335d0:	dfc00117 	ldw	ra,4(sp)
801335d4:	df000017 	ldw	fp,0(sp)
801335d8:	dec00204 	addi	sp,sp,8
801335dc:	f800283a 	ret

801335e0 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
801335e0:	defff804 	addi	sp,sp,-32
801335e4:	de00012e 	bgeu	sp,et,801335ec <__malloc_unlock+0xc>
801335e8:	003b68fa 	trap	3
801335ec:	dfc00715 	stw	ra,28(sp)
801335f0:	df000615 	stw	fp,24(sp)
801335f4:	df000604 	addi	fp,sp,24
801335f8:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801335fc:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
80133600:	d0a09a03 	ldbu	r2,-32152(gp)
80133604:	10803fcc 	andi	r2,r2,255
80133608:	10800060 	cmpeqi	r2,r2,1
8013360c:	10002326 	beq	r2,zero,8013369c <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80133610:	0005303a 	rdctl	r2,status
80133614:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80133618:	e0fffe17 	ldw	r3,-8(fp)
8013361c:	00bfff84 	movi	r2,-2
80133620:	1884703a 	and	r2,r3,r2
80133624:	1001703a 	wrctl	status,r2
  
  return context;
80133628:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
8013362c:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
80133630:	d0a09517 	ldw	r2,-32172(gp)
80133634:	1000051e 	bne	r2,zero,8013364c <__malloc_unlock+0x6c>
80133638:	e0bffa17 	ldw	r2,-24(fp)
8013363c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80133640:	e0bffb17 	ldw	r2,-20(fp)
80133644:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
80133648:	00001506 	br	801336a0 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
8013364c:	d0a09517 	ldw	r2,-32172(gp)
80133650:	10bfffc4 	addi	r2,r2,-1
80133654:	d0a09515 	stw	r2,-32172(gp)
80133658:	d0a09517 	ldw	r2,-32172(gp)
8013365c:	10000a1e 	bne	r2,zero,80133688 <__malloc_unlock+0xa8>
  {
    lockid = -1;
80133660:	00bfffc4 	movi	r2,-1
80133664:	d0a01615 	stw	r2,-32680(gp)
80133668:	e0bffa17 	ldw	r2,-24(fp)
8013366c:	e0bffc15 	stw	r2,-16(fp)
80133670:	e0bffc17 	ldw	r2,-16(fp)
80133674:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
80133678:	d0a09617 	ldw	r2,-32168(gp)
8013367c:	1009883a 	mov	r4,r2
80133680:	013a2840 	call	8013a284 <OSSemPost>
80133684:	00000606 	br	801336a0 <__malloc_unlock+0xc0>
80133688:	e0bffa17 	ldw	r2,-24(fp)
8013368c:	e0bffd15 	stw	r2,-12(fp)
80133690:	e0bffd17 	ldw	r2,-12(fp)
80133694:	1001703a 	wrctl	status,r2
80133698:	00000106 	br	801336a0 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
8013369c:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
801336a0:	e037883a 	mov	sp,fp
801336a4:	dfc00117 	ldw	ra,4(sp)
801336a8:	df000017 	ldw	fp,0(sp)
801336ac:	dec00204 	addi	sp,sp,8
801336b0:	f800283a 	ret

801336b4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
801336b4:	defff704 	addi	sp,sp,-36
801336b8:	de00012e 	bgeu	sp,et,801336c0 <OSEventNameGet+0xc>
801336bc:	003b68fa 	trap	3
801336c0:	dfc00815 	stw	ra,32(sp)
801336c4:	df000715 	stw	fp,28(sp)
801336c8:	df000704 	addi	fp,sp,28
801336cc:	e13ffd15 	stw	r4,-12(fp)
801336d0:	e17ffe15 	stw	r5,-8(fp)
801336d4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801336d8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
801336dc:	e0bfff17 	ldw	r2,-4(fp)
801336e0:	1000021e 	bne	r2,zero,801336ec <OSEventNameGet+0x38>
        return (0);
801336e4:	0005883a 	mov	r2,zero
801336e8:	00003706 	br	801337c8 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
801336ec:	e0bffd17 	ldw	r2,-12(fp)
801336f0:	1000051e 	bne	r2,zero,80133708 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
801336f4:	e0bfff17 	ldw	r2,-4(fp)
801336f8:	00c00104 	movi	r3,4
801336fc:	10c00005 	stb	r3,0(r2)
        return (0);
80133700:	0005883a 	mov	r2,zero
80133704:	00003006 	br	801337c8 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
80133708:	e0bffe17 	ldw	r2,-8(fp)
8013370c:	1000051e 	bne	r2,zero,80133724 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
80133710:	e0bfff17 	ldw	r2,-4(fp)
80133714:	00c00304 	movi	r3,12
80133718:	10c00005 	stb	r3,0(r2)
        return (0);
8013371c:	0005883a 	mov	r2,zero
80133720:	00002906 	br	801337c8 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
80133724:	d0a0aa03 	ldbu	r2,-32088(gp)
80133728:	10803fcc 	andi	r2,r2,255
8013372c:	10000526 	beq	r2,zero,80133744 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
80133730:	e0bfff17 	ldw	r2,-4(fp)
80133734:	00c00444 	movi	r3,17
80133738:	10c00005 	stb	r3,0(r2)
        return (0);
8013373c:	0005883a 	mov	r2,zero
80133740:	00002106 	br	801337c8 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
80133744:	e0bffd17 	ldw	r2,-12(fp)
80133748:	10800003 	ldbu	r2,0(r2)
8013374c:	10803fcc 	andi	r2,r2,255
80133750:	10bfffc4 	addi	r2,r2,-1
80133754:	10800128 	cmpgeui	r2,r2,4
80133758:	10000526 	beq	r2,zero,80133770 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8013375c:	e0bfff17 	ldw	r2,-4(fp)
80133760:	00c00044 	movi	r3,1
80133764:	10c00005 	stb	r3,0(r2)
             return (0);
80133768:	0005883a 	mov	r2,zero
8013376c:	00001606 	br	801337c8 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
80133770:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80133774:	0005303a 	rdctl	r2,status
80133778:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013377c:	e0fffb17 	ldw	r3,-20(fp)
80133780:	00bfff84 	movi	r2,-2
80133784:	1884703a 	and	r2,r3,r2
80133788:	1001703a 	wrctl	status,r2
  
  return context;
8013378c:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
80133790:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
80133794:	e0bffd17 	ldw	r2,-12(fp)
80133798:	10800444 	addi	r2,r2,17
8013379c:	100b883a 	mov	r5,r2
801337a0:	e13ffe17 	ldw	r4,-8(fp)
801337a4:	01351a00 	call	801351a0 <OS_StrCopy>
801337a8:	e0bffa05 	stb	r2,-24(fp)
801337ac:	e0bff917 	ldw	r2,-28(fp)
801337b0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801337b4:	e0bffc17 	ldw	r2,-16(fp)
801337b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
801337bc:	e0bfff17 	ldw	r2,-4(fp)
801337c0:	10000005 	stb	zero,0(r2)
    return (len);
801337c4:	e0bffa03 	ldbu	r2,-24(fp)
}
801337c8:	e037883a 	mov	sp,fp
801337cc:	dfc00117 	ldw	ra,4(sp)
801337d0:	df000017 	ldw	fp,0(sp)
801337d4:	dec00204 	addi	sp,sp,8
801337d8:	f800283a 	ret

801337dc <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
801337dc:	defff604 	addi	sp,sp,-40
801337e0:	de00012e 	bgeu	sp,et,801337e8 <OSEventNameSet+0xc>
801337e4:	003b68fa 	trap	3
801337e8:	dfc00915 	stw	ra,36(sp)
801337ec:	df000815 	stw	fp,32(sp)
801337f0:	df000804 	addi	fp,sp,32
801337f4:	e13ffd15 	stw	r4,-12(fp)
801337f8:	e17ffe15 	stw	r5,-8(fp)
801337fc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
80133800:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
80133804:	e0bfff17 	ldw	r2,-4(fp)
80133808:	10004026 	beq	r2,zero,8013390c <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8013380c:	e0bffd17 	ldw	r2,-12(fp)
80133810:	1000041e 	bne	r2,zero,80133824 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
80133814:	e0bfff17 	ldw	r2,-4(fp)
80133818:	00c00104 	movi	r3,4
8013381c:	10c00005 	stb	r3,0(r2)
        return;
80133820:	00003b06 	br	80133910 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
80133824:	e0bffe17 	ldw	r2,-8(fp)
80133828:	1000041e 	bne	r2,zero,8013383c <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8013382c:	e0bfff17 	ldw	r2,-4(fp)
80133830:	00c00304 	movi	r3,12
80133834:	10c00005 	stb	r3,0(r2)
        return;
80133838:	00003506 	br	80133910 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8013383c:	d0a0aa03 	ldbu	r2,-32088(gp)
80133840:	10803fcc 	andi	r2,r2,255
80133844:	10000426 	beq	r2,zero,80133858 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
80133848:	e0bfff17 	ldw	r2,-4(fp)
8013384c:	00c00484 	movi	r3,18
80133850:	10c00005 	stb	r3,0(r2)
        return;
80133854:	00002e06 	br	80133910 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
80133858:	e0bffd17 	ldw	r2,-12(fp)
8013385c:	10800003 	ldbu	r2,0(r2)
80133860:	10803fcc 	andi	r2,r2,255
80133864:	10bfffc4 	addi	r2,r2,-1
80133868:	10800128 	cmpgeui	r2,r2,4
8013386c:	10000426 	beq	r2,zero,80133880 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
80133870:	e0bfff17 	ldw	r2,-4(fp)
80133874:	00c00044 	movi	r3,1
80133878:	10c00005 	stb	r3,0(r2)
             return;
8013387c:	00002406 	br	80133910 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
80133880:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80133884:	0005303a 	rdctl	r2,status
80133888:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013388c:	e0fffc17 	ldw	r3,-16(fp)
80133890:	00bfff84 	movi	r2,-2
80133894:	1884703a 	and	r2,r3,r2
80133898:	1001703a 	wrctl	status,r2
  
  return context;
8013389c:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
801338a0:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
801338a4:	e13ffe17 	ldw	r4,-8(fp)
801338a8:	013521c0 	call	8013521c <OS_StrLen>
801338ac:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
801338b0:	e0bffa03 	ldbu	r2,-24(fp)
801338b4:	10800830 	cmpltui	r2,r2,32
801338b8:	1000081e 	bne	r2,zero,801338dc <OSEventNameSet+0x100>
801338bc:	e0bff817 	ldw	r2,-32(fp)
801338c0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801338c4:	e0bff917 	ldw	r2,-28(fp)
801338c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
801338cc:	e0bfff17 	ldw	r2,-4(fp)
801338d0:	00c002c4 	movi	r3,11
801338d4:	10c00005 	stb	r3,0(r2)
        return;
801338d8:	00000d06 	br	80133910 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
801338dc:	e0bffd17 	ldw	r2,-12(fp)
801338e0:	10800444 	addi	r2,r2,17
801338e4:	e17ffe17 	ldw	r5,-8(fp)
801338e8:	1009883a 	mov	r4,r2
801338ec:	01351a00 	call	801351a0 <OS_StrCopy>
801338f0:	e0bff817 	ldw	r2,-32(fp)
801338f4:	e0bffb15 	stw	r2,-20(fp)
801338f8:	e0bffb17 	ldw	r2,-20(fp)
801338fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
80133900:	e0bfff17 	ldw	r2,-4(fp)
80133904:	10000005 	stb	zero,0(r2)
80133908:	00000106 	br	80133910 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8013390c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
80133910:	e037883a 	mov	sp,fp
80133914:	dfc00117 	ldw	ra,4(sp)
80133918:	df000017 	ldw	fp,0(sp)
8013391c:	dec00204 	addi	sp,sp,8
80133920:	f800283a 	ret

80133924 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
80133924:	deffed04 	addi	sp,sp,-76
80133928:	de00012e 	bgeu	sp,et,80133930 <OSEventPendMulti+0xc>
8013392c:	003b68fa 	trap	3
80133930:	dfc01215 	stw	ra,72(sp)
80133934:	df001115 	stw	fp,68(sp)
80133938:	df001104 	addi	fp,sp,68
8013393c:	e13ffc15 	stw	r4,-16(fp)
80133940:	e17ffd15 	stw	r5,-12(fp)
80133944:	e1bffe15 	stw	r6,-8(fp)
80133948:	3805883a 	mov	r2,r7
8013394c:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
80133950:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
80133954:	e0800217 	ldw	r2,8(fp)
80133958:	1000021e 	bne	r2,zero,80133964 <OSEventPendMulti+0x40>
        return (0);
8013395c:	0005883a 	mov	r2,zero
80133960:	00015006 	br	80133ea4 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
80133964:	e0bffc17 	ldw	r2,-16(fp)
80133968:	1000051e 	bne	r2,zero,80133980 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
8013396c:	e0800217 	ldw	r2,8(fp)
80133970:	00c00104 	movi	r3,4
80133974:	10c00005 	stb	r3,0(r2)
        return (0);
80133978:	0005883a 	mov	r2,zero
8013397c:	00014906 	br	80133ea4 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
80133980:	e0bffd17 	ldw	r2,-12(fp)
80133984:	1000051e 	bne	r2,zero,8013399c <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
80133988:	e0800217 	ldw	r2,8(fp)
8013398c:	00c00104 	movi	r3,4
80133990:	10c00005 	stb	r3,0(r2)
        return (0);
80133994:	0005883a 	mov	r2,zero
80133998:	00014206 	br	80133ea4 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
8013399c:	e0bffe17 	ldw	r2,-8(fp)
801339a0:	1000051e 	bne	r2,zero,801339b8 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
801339a4:	e0800217 	ldw	r2,8(fp)
801339a8:	00c00104 	movi	r3,4
801339ac:	10c00005 	stb	r3,0(r2)
        return (0);
801339b0:	0005883a 	mov	r2,zero
801339b4:	00013b06 	br	80133ea4 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
801339b8:	e0bffd17 	ldw	r2,-12(fp)
801339bc:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
801339c0:	e0bffc17 	ldw	r2,-16(fp)
801339c4:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
801339c8:	e0bfef17 	ldw	r2,-68(fp)
801339cc:	10800017 	ldw	r2,0(r2)
801339d0:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
801339d4:	00001506 	br	80133a2c <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
801339d8:	e0bff017 	ldw	r2,-64(fp)
801339dc:	10800003 	ldbu	r2,0(r2)
801339e0:	10803fcc 	andi	r2,r2,255
801339e4:	10c000a0 	cmpeqi	r3,r2,2
801339e8:	1800071e 	bne	r3,zero,80133a08 <OSEventPendMulti+0xe4>
801339ec:	108000e0 	cmpeqi	r2,r2,3
801339f0:	1000071e 	bne	r2,zero,80133a10 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
801339f4:	e0800217 	ldw	r2,8(fp)
801339f8:	00c00044 	movi	r3,1
801339fc:	10c00005 	stb	r3,0(r2)
                 return (0);
80133a00:	0005883a 	mov	r2,zero
80133a04:	00012706 	br	80133ea4 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
80133a08:	0001883a 	nop
80133a0c:	00000106 	br	80133a14 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
80133a10:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
80133a14:	e0bfef17 	ldw	r2,-68(fp)
80133a18:	10800104 	addi	r2,r2,4
80133a1c:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
80133a20:	e0bfef17 	ldw	r2,-68(fp)
80133a24:	10800017 	ldw	r2,0(r2)
80133a28:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
80133a2c:	e0bff017 	ldw	r2,-64(fp)
80133a30:	103fe91e 	bne	r2,zero,801339d8 <__reset+0xfa1139d8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
80133a34:	d0a0aa03 	ldbu	r2,-32088(gp)
80133a38:	10803fcc 	andi	r2,r2,255
80133a3c:	10000526 	beq	r2,zero,80133a54 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
80133a40:	e0800217 	ldw	r2,8(fp)
80133a44:	00c00084 	movi	r3,2
80133a48:	10c00005 	stb	r3,0(r2)
        return (0);
80133a4c:	0005883a 	mov	r2,zero
80133a50:	00011406 	br	80133ea4 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
80133a54:	d0a09803 	ldbu	r2,-32160(gp)
80133a58:	10803fcc 	andi	r2,r2,255
80133a5c:	10000526 	beq	r2,zero,80133a74 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
80133a60:	e0800217 	ldw	r2,8(fp)
80133a64:	00c00344 	movi	r3,13
80133a68:	10c00005 	stb	r3,0(r2)
        return (0);
80133a6c:	0005883a 	mov	r2,zero
80133a70:	00010c06 	br	80133ea4 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80133a74:	0005303a 	rdctl	r2,status
80133a78:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80133a7c:	e0fffb17 	ldw	r3,-20(fp)
80133a80:	00bfff84 	movi	r2,-2
80133a84:	1884703a 	and	r2,r3,r2
80133a88:	1001703a 	wrctl	status,r2
  
  return context;
80133a8c:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
80133a90:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
80133a94:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
80133a98:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
80133a9c:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
80133aa0:	e0bffc17 	ldw	r2,-16(fp)
80133aa4:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
80133aa8:	e0bfef17 	ldw	r2,-68(fp)
80133aac:	10800017 	ldw	r2,0(r2)
80133ab0:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
80133ab4:	00006406 	br	80133c48 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
80133ab8:	e0bff017 	ldw	r2,-64(fp)
80133abc:	10800003 	ldbu	r2,0(r2)
80133ac0:	10803fcc 	andi	r2,r2,255
80133ac4:	10c000a0 	cmpeqi	r3,r2,2
80133ac8:	18001f1e 	bne	r3,zero,80133b48 <OSEventPendMulti+0x224>
80133acc:	108000e0 	cmpeqi	r2,r2,3
80133ad0:	10004c26 	beq	r2,zero,80133c04 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
80133ad4:	e0bff017 	ldw	r2,-64(fp)
80133ad8:	1080020b 	ldhu	r2,8(r2)
80133adc:	10bfffcc 	andi	r2,r2,65535
80133ae0:	10001526 	beq	r2,zero,80133b38 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
80133ae4:	e0bff017 	ldw	r2,-64(fp)
80133ae8:	1080020b 	ldhu	r2,8(r2)
80133aec:	10bfffc4 	addi	r2,r2,-1
80133af0:	1007883a 	mov	r3,r2
80133af4:	e0bff017 	ldw	r2,-64(fp)
80133af8:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
80133afc:	e0bffd17 	ldw	r2,-12(fp)
80133b00:	10c00104 	addi	r3,r2,4
80133b04:	e0fffd15 	stw	r3,-12(fp)
80133b08:	e0fff017 	ldw	r3,-64(fp)
80133b0c:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
80133b10:	00800044 	movi	r2,1
80133b14:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
80133b18:	e0bffe17 	ldw	r2,-8(fp)
80133b1c:	10c00104 	addi	r3,r2,4
80133b20:	e0fffe15 	stw	r3,-8(fp)
80133b24:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
80133b28:	e0bff18b 	ldhu	r2,-58(fp)
80133b2c:	10800044 	addi	r2,r2,1
80133b30:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
80133b34:	00003e06 	br	80133c30 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
80133b38:	e0bff203 	ldbu	r2,-56(fp)
80133b3c:	10800054 	ori	r2,r2,1
80133b40:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
80133b44:	00003a06 	br	80133c30 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
80133b48:	e0bff017 	ldw	r2,-64(fp)
80133b4c:	10800117 	ldw	r2,4(r2)
80133b50:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
80133b54:	e0bff517 	ldw	r2,-44(fp)
80133b58:	1080058b 	ldhu	r2,22(r2)
80133b5c:	10bfffcc 	andi	r2,r2,65535
80133b60:	10002426 	beq	r2,zero,80133bf4 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
80133b64:	e0bffe17 	ldw	r2,-8(fp)
80133b68:	10c00104 	addi	r3,r2,4
80133b6c:	e0fffe15 	stw	r3,-8(fp)
80133b70:	e0fff517 	ldw	r3,-44(fp)
80133b74:	18c00417 	ldw	r3,16(r3)
80133b78:	19400104 	addi	r5,r3,4
80133b7c:	e13ff517 	ldw	r4,-44(fp)
80133b80:	21400415 	stw	r5,16(r4)
80133b84:	18c00017 	ldw	r3,0(r3)
80133b88:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
80133b8c:	e0bff517 	ldw	r2,-44(fp)
80133b90:	10c00417 	ldw	r3,16(r2)
80133b94:	e0bff517 	ldw	r2,-44(fp)
80133b98:	10800217 	ldw	r2,8(r2)
80133b9c:	1880041e 	bne	r3,r2,80133bb0 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
80133ba0:	e0bff517 	ldw	r2,-44(fp)
80133ba4:	10c00117 	ldw	r3,4(r2)
80133ba8:	e0bff517 	ldw	r2,-44(fp)
80133bac:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
80133bb0:	e0bff517 	ldw	r2,-44(fp)
80133bb4:	1080058b 	ldhu	r2,22(r2)
80133bb8:	10bfffc4 	addi	r2,r2,-1
80133bbc:	1007883a 	mov	r3,r2
80133bc0:	e0bff517 	ldw	r2,-44(fp)
80133bc4:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
80133bc8:	e0bffd17 	ldw	r2,-12(fp)
80133bcc:	10c00104 	addi	r3,r2,4
80133bd0:	e0fffd15 	stw	r3,-12(fp)
80133bd4:	e0fff017 	ldw	r3,-64(fp)
80133bd8:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
80133bdc:	00800044 	movi	r2,1
80133be0:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
80133be4:	e0bff18b 	ldhu	r2,-58(fp)
80133be8:	10800044 	addi	r2,r2,1
80133bec:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
80133bf0:	00000f06 	br	80133c30 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
80133bf4:	e0bff203 	ldbu	r2,-56(fp)
80133bf8:	10800114 	ori	r2,r2,4
80133bfc:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
80133c00:	00000b06 	br	80133c30 <OSEventPendMulti+0x30c>
80133c04:	e0bff317 	ldw	r2,-52(fp)
80133c08:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80133c0c:	e0bff417 	ldw	r2,-48(fp)
80133c10:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
80133c14:	e0bffd17 	ldw	r2,-12(fp)
80133c18:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
80133c1c:	e0800217 	ldw	r2,8(fp)
80133c20:	00c00044 	movi	r3,1
80133c24:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
80133c28:	e0bff18b 	ldhu	r2,-58(fp)
80133c2c:	00009d06 	br	80133ea4 <OSEventPendMulti+0x580>
        }
        pevents++;
80133c30:	e0bfef17 	ldw	r2,-68(fp)
80133c34:	10800104 	addi	r2,r2,4
80133c38:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
80133c3c:	e0bfef17 	ldw	r2,-68(fp)
80133c40:	10800017 	ldw	r2,0(r2)
80133c44:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
80133c48:	e0bff017 	ldw	r2,-64(fp)
80133c4c:	103f9a1e 	bne	r2,zero,80133ab8 <__reset+0xfa113ab8>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
80133c50:	e0bff103 	ldbu	r2,-60(fp)
80133c54:	10800058 	cmpnei	r2,r2,1
80133c58:	10000a1e 	bne	r2,zero,80133c84 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
80133c5c:	e0bffd17 	ldw	r2,-12(fp)
80133c60:	10000015 	stw	zero,0(r2)
80133c64:	e0bff317 	ldw	r2,-52(fp)
80133c68:	e0bff615 	stw	r2,-40(fp)
80133c6c:	e0bff617 	ldw	r2,-40(fp)
80133c70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
80133c74:	e0800217 	ldw	r2,8(fp)
80133c78:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
80133c7c:	e0bff18b 	ldhu	r2,-58(fp)
80133c80:	00008806 	br	80133ea4 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
80133c84:	d0a0ab17 	ldw	r2,-32084(gp)
80133c88:	d0e0ab17 	ldw	r3,-32084(gp)
80133c8c:	19000c03 	ldbu	r4,48(r3)
80133c90:	e0fff203 	ldbu	r3,-56(fp)
80133c94:	20c6b03a 	or	r3,r4,r3
80133c98:	1809883a 	mov	r4,r3
80133c9c:	00ffe004 	movi	r3,-128
80133ca0:	20c6b03a 	or	r3,r4,r3
80133ca4:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
80133ca8:	d0a0ab17 	ldw	r2,-32084(gp)
80133cac:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
80133cb0:	d0a0ab17 	ldw	r2,-32084(gp)
80133cb4:	e0ffff0b 	ldhu	r3,-4(fp)
80133cb8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
80133cbc:	e13ffc17 	ldw	r4,-16(fp)
80133cc0:	01348480 	call	80134848 <OS_EventTaskWaitMulti>
80133cc4:	e0bff317 	ldw	r2,-52(fp)
80133cc8:	e0bff915 	stw	r2,-28(fp)
80133ccc:	e0bff917 	ldw	r2,-28(fp)
80133cd0:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
80133cd4:	013504c0 	call	8013504c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80133cd8:	0005303a 	rdctl	r2,status
80133cdc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80133ce0:	e0fff717 	ldw	r3,-36(fp)
80133ce4:	00bfff84 	movi	r2,-2
80133ce8:	1884703a 	and	r2,r3,r2
80133cec:	1001703a 	wrctl	status,r2
  
  return context;
80133cf0:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
80133cf4:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
80133cf8:	d0a0ab17 	ldw	r2,-32084(gp)
80133cfc:	10800c43 	ldbu	r2,49(r2)
80133d00:	10803fcc 	andi	r2,r2,255
80133d04:	10000226 	beq	r2,zero,80133d10 <OSEventPendMulti+0x3ec>
80133d08:	108000a0 	cmpeqi	r2,r2,2
80133d0c:	10001826 	beq	r2,zero,80133d70 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
80133d10:	d0a0ab17 	ldw	r2,-32084(gp)
80133d14:	10800717 	ldw	r2,28(r2)
80133d18:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
80133d1c:	e0bff017 	ldw	r2,-64(fp)
80133d20:	10000b26 	beq	r2,zero,80133d50 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
80133d24:	e0bffd17 	ldw	r2,-12(fp)
80133d28:	10c00104 	addi	r3,r2,4
80133d2c:	e0fffd15 	stw	r3,-12(fp)
80133d30:	e0fff017 	ldw	r3,-64(fp)
80133d34:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
80133d38:	e0bffd17 	ldw	r2,-12(fp)
80133d3c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
80133d40:	e0bff18b 	ldhu	r2,-58(fp)
80133d44:	10800044 	addi	r2,r2,1
80133d48:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
80133d4c:	00000d06 	br	80133d84 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
80133d50:	d0a0ab17 	ldw	r2,-32084(gp)
80133d54:	00c00044 	movi	r3,1
80133d58:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
80133d5c:	d0a0ab17 	ldw	r2,-32084(gp)
80133d60:	e17ffc17 	ldw	r5,-16(fp)
80133d64:	1009883a 	mov	r4,r2
80133d68:	0134a600 	call	80134a60 <OS_EventTaskRemoveMulti>
             }
			 break;
80133d6c:	00000506 	br	80133d84 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
80133d70:	d0a0ab17 	ldw	r2,-32084(gp)
80133d74:	e17ffc17 	ldw	r5,-16(fp)
80133d78:	1009883a 	mov	r4,r2
80133d7c:	0134a600 	call	80134a60 <OS_EventTaskRemoveMulti>
             break;
80133d80:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
80133d84:	d0a0ab17 	ldw	r2,-32084(gp)
80133d88:	10800c43 	ldbu	r2,49(r2)
80133d8c:	10803fcc 	andi	r2,r2,255
80133d90:	10000326 	beq	r2,zero,80133da0 <OSEventPendMulti+0x47c>
80133d94:	108000a0 	cmpeqi	r2,r2,2
80133d98:	1000231e 	bne	r2,zero,80133e28 <OSEventPendMulti+0x504>
80133d9c:	00002a06 	br	80133e48 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
80133da0:	e0bff017 	ldw	r2,-64(fp)
80133da4:	10800003 	ldbu	r2,0(r2)
80133da8:	10803fcc 	andi	r2,r2,255
80133dac:	0080100e 	bge	zero,r2,80133df0 <OSEventPendMulti+0x4cc>
80133db0:	10c000d0 	cmplti	r3,r2,3
80133db4:	1800071e 	bne	r3,zero,80133dd4 <OSEventPendMulti+0x4b0>
80133db8:	108000e0 	cmpeqi	r2,r2,3
80133dbc:	10000c26 	beq	r2,zero,80133df0 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
80133dc0:	e0bffe17 	ldw	r2,-8(fp)
80133dc4:	10c00104 	addi	r3,r2,4
80133dc8:	e0fffe15 	stw	r3,-8(fp)
80133dcc:	10000015 	stw	zero,0(r2)
                      break;
80133dd0:	00001206 	br	80133e1c <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
80133dd4:	e0bffe17 	ldw	r2,-8(fp)
80133dd8:	10c00104 	addi	r3,r2,4
80133ddc:	e0fffe15 	stw	r3,-8(fp)
80133de0:	d0e0ab17 	ldw	r3,-32084(gp)
80133de4:	18c00917 	ldw	r3,36(r3)
80133de8:	10c00015 	stw	r3,0(r2)
                      break;
80133dec:	00000b06 	br	80133e1c <OSEventPendMulti+0x4f8>
80133df0:	e0bff317 	ldw	r2,-52(fp)
80133df4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80133df8:	e0bff817 	ldw	r2,-32(fp)
80133dfc:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
80133e00:	e0bffd17 	ldw	r2,-12(fp)
80133e04:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
80133e08:	e0800217 	ldw	r2,8(fp)
80133e0c:	00c00044 	movi	r3,1
80133e10:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
80133e14:	e0bff18b 	ldhu	r2,-58(fp)
80133e18:	00002206 	br	80133ea4 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
80133e1c:	e0800217 	ldw	r2,8(fp)
80133e20:	10000005 	stb	zero,0(r2)
             break;
80133e24:	00001006 	br	80133e68 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
80133e28:	e0bffe17 	ldw	r2,-8(fp)
80133e2c:	10c00104 	addi	r3,r2,4
80133e30:	e0fffe15 	stw	r3,-8(fp)
80133e34:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
80133e38:	e0800217 	ldw	r2,8(fp)
80133e3c:	00c00384 	movi	r3,14
80133e40:	10c00005 	stb	r3,0(r2)
             break;
80133e44:	00000806 	br	80133e68 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
80133e48:	e0bffe17 	ldw	r2,-8(fp)
80133e4c:	10c00104 	addi	r3,r2,4
80133e50:	e0fffe15 	stw	r3,-8(fp)
80133e54:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
80133e58:	e0800217 	ldw	r2,8(fp)
80133e5c:	00c00284 	movi	r3,10
80133e60:	10c00005 	stb	r3,0(r2)
             break;
80133e64:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
80133e68:	d0a0ab17 	ldw	r2,-32084(gp)
80133e6c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
80133e70:	d0a0ab17 	ldw	r2,-32084(gp)
80133e74:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
80133e78:	d0a0ab17 	ldw	r2,-32084(gp)
80133e7c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
80133e80:	d0a0ab17 	ldw	r2,-32084(gp)
80133e84:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
80133e88:	d0a0ab17 	ldw	r2,-32084(gp)
80133e8c:	10000915 	stw	zero,36(r2)
80133e90:	e0bff317 	ldw	r2,-52(fp)
80133e94:	e0bffa15 	stw	r2,-24(fp)
80133e98:	e0bffa17 	ldw	r2,-24(fp)
80133e9c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
80133ea0:	e0bff18b 	ldhu	r2,-58(fp)
}
80133ea4:	e037883a 	mov	sp,fp
80133ea8:	dfc00117 	ldw	ra,4(sp)
80133eac:	df000017 	ldw	fp,0(sp)
80133eb0:	dec00204 	addi	sp,sp,8
80133eb4:	f800283a 	ret

80133eb8 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
80133eb8:	defffe04 	addi	sp,sp,-8
80133ebc:	de00012e 	bgeu	sp,et,80133ec4 <OSInit+0xc>
80133ec0:	003b68fa 	trap	3
80133ec4:	dfc00115 	stw	ra,4(sp)
80133ec8:	df000015 	stw	fp,0(sp)
80133ecc:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
80133ed0:	01464340 	call	80146434 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
80133ed4:	0134cc00 	call	80134cc0 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
80133ed8:	0134d100 	call	80134d10 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
80133edc:	0134e940 	call	80134e94 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
80133ee0:	0134bd80 	call	80134bd8 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
80133ee4:	0136e540 	call	80136e54 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
80133ee8:	013779c0 	call	8013779c <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
80133eec:	0139a6c0 	call	80139a6c <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
80133ef0:	0134d840 	call	80134d84 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
80133ef4:	0134e0c0 	call	80134e0c <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
80133ef8:	013ce100 	call	8013ce10 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
80133efc:	01464600 	call	80146460 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
80133f00:	01357700 	call	80135770 <OSDebugInit>
#endif
}
80133f04:	0001883a 	nop
80133f08:	e037883a 	mov	sp,fp
80133f0c:	dfc00117 	ldw	ra,4(sp)
80133f10:	df000017 	ldw	fp,0(sp)
80133f14:	dec00204 	addi	sp,sp,8
80133f18:	f800283a 	ret

80133f1c <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
80133f1c:	deffff04 	addi	sp,sp,-4
80133f20:	de00012e 	bgeu	sp,et,80133f28 <OSIntEnter+0xc>
80133f24:	003b68fa 	trap	3
80133f28:	df000015 	stw	fp,0(sp)
80133f2c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
80133f30:	d0a09a03 	ldbu	r2,-32152(gp)
80133f34:	10803fcc 	andi	r2,r2,255
80133f38:	10800058 	cmpnei	r2,r2,1
80133f3c:	1000071e 	bne	r2,zero,80133f5c <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
80133f40:	d0a0aa03 	ldbu	r2,-32088(gp)
80133f44:	10803fcc 	andi	r2,r2,255
80133f48:	10803fe0 	cmpeqi	r2,r2,255
80133f4c:	1000031e 	bne	r2,zero,80133f5c <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
80133f50:	d0a0aa03 	ldbu	r2,-32088(gp)
80133f54:	10800044 	addi	r2,r2,1
80133f58:	d0a0aa05 	stb	r2,-32088(gp)
        }
    }
}
80133f5c:	0001883a 	nop
80133f60:	e037883a 	mov	sp,fp
80133f64:	df000017 	ldw	fp,0(sp)
80133f68:	dec00104 	addi	sp,sp,4
80133f6c:	f800283a 	ret

80133f70 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
80133f70:	defffb04 	addi	sp,sp,-20
80133f74:	de00012e 	bgeu	sp,et,80133f7c <OSIntExit+0xc>
80133f78:	003b68fa 	trap	3
80133f7c:	dfc00415 	stw	ra,16(sp)
80133f80:	df000315 	stw	fp,12(sp)
80133f84:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
80133f88:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
80133f8c:	d0a09a03 	ldbu	r2,-32152(gp)
80133f90:	10803fcc 	andi	r2,r2,255
80133f94:	10800058 	cmpnei	r2,r2,1
80133f98:	10002f1e 	bne	r2,zero,80134058 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80133f9c:	0005303a 	rdctl	r2,status
80133fa0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80133fa4:	e0ffff17 	ldw	r3,-4(fp)
80133fa8:	00bfff84 	movi	r2,-2
80133fac:	1884703a 	and	r2,r3,r2
80133fb0:	1001703a 	wrctl	status,r2
  
  return context;
80133fb4:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
80133fb8:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
80133fbc:	d0a0aa03 	ldbu	r2,-32088(gp)
80133fc0:	10803fcc 	andi	r2,r2,255
80133fc4:	10000326 	beq	r2,zero,80133fd4 <OSIntExit+0x64>
            OSIntNesting--;
80133fc8:	d0a0aa03 	ldbu	r2,-32088(gp)
80133fcc:	10bfffc4 	addi	r2,r2,-1
80133fd0:	d0a0aa05 	stb	r2,-32088(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
80133fd4:	d0a0aa03 	ldbu	r2,-32088(gp)
80133fd8:	10803fcc 	andi	r2,r2,255
80133fdc:	10001a1e 	bne	r2,zero,80134048 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
80133fe0:	d0a09803 	ldbu	r2,-32160(gp)
80133fe4:	10803fcc 	andi	r2,r2,255
80133fe8:	1000171e 	bne	r2,zero,80134048 <OSIntExit+0xd8>
                OS_SchedNew();
80133fec:	01351240 	call	80135124 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
80133ff0:	d0e09c83 	ldbu	r3,-32142(gp)
80133ff4:	d0a09cc3 	ldbu	r2,-32141(gp)
80133ff8:	18c03fcc 	andi	r3,r3,255
80133ffc:	10803fcc 	andi	r2,r2,255
80134000:	18801126 	beq	r3,r2,80134048 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
80134004:	d0a09c83 	ldbu	r2,-32142(gp)
80134008:	10c03fcc 	andi	r3,r2,255
8013400c:	00a005b4 	movhi	r2,32790
80134010:	10924b04 	addi	r2,r2,18732
80134014:	18c7883a 	add	r3,r3,r3
80134018:	18c7883a 	add	r3,r3,r3
8013401c:	10c5883a 	add	r2,r2,r3
80134020:	10800017 	ldw	r2,0(r2)
80134024:	d0a0a515 	stw	r2,-32108(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
80134028:	d0a0a517 	ldw	r2,-32108(gp)
8013402c:	10c00e17 	ldw	r3,56(r2)
80134030:	18c00044 	addi	r3,r3,1
80134034:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
80134038:	d0a09f17 	ldw	r2,-32132(gp)
8013403c:	10800044 	addi	r2,r2,1
80134040:	d0a09f15 	stw	r2,-32132(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
80134044:	01460f40 	call	801460f4 <OSCtxSw>
80134048:	e0bffd17 	ldw	r2,-12(fp)
8013404c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80134050:	e0bffe17 	ldw	r2,-8(fp)
80134054:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
80134058:	0001883a 	nop
8013405c:	e037883a 	mov	sp,fp
80134060:	dfc00117 	ldw	ra,4(sp)
80134064:	df000017 	ldw	fp,0(sp)
80134068:	dec00204 	addi	sp,sp,8
8013406c:	f800283a 	ret

80134070 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
80134070:	defffc04 	addi	sp,sp,-16
80134074:	de00012e 	bgeu	sp,et,8013407c <OSSchedLock+0xc>
80134078:	003b68fa 	trap	3
8013407c:	df000315 	stw	fp,12(sp)
80134080:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
80134084:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
80134088:	d0a09a03 	ldbu	r2,-32152(gp)
8013408c:	10803fcc 	andi	r2,r2,255
80134090:	10800058 	cmpnei	r2,r2,1
80134094:	1000161e 	bne	r2,zero,801340f0 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80134098:	0005303a 	rdctl	r2,status
8013409c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801340a0:	e0ffff17 	ldw	r3,-4(fp)
801340a4:	00bfff84 	movi	r2,-2
801340a8:	1884703a 	and	r2,r3,r2
801340ac:	1001703a 	wrctl	status,r2
  
  return context;
801340b0:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
801340b4:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
801340b8:	d0a0aa03 	ldbu	r2,-32088(gp)
801340bc:	10803fcc 	andi	r2,r2,255
801340c0:	1000071e 	bne	r2,zero,801340e0 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
801340c4:	d0a09803 	ldbu	r2,-32160(gp)
801340c8:	10803fcc 	andi	r2,r2,255
801340cc:	10803fe0 	cmpeqi	r2,r2,255
801340d0:	1000031e 	bne	r2,zero,801340e0 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
801340d4:	d0a09803 	ldbu	r2,-32160(gp)
801340d8:	10800044 	addi	r2,r2,1
801340dc:	d0a09805 	stb	r2,-32160(gp)
801340e0:	e0bffd17 	ldw	r2,-12(fp)
801340e4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801340e8:	e0bffe17 	ldw	r2,-8(fp)
801340ec:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
801340f0:	0001883a 	nop
801340f4:	e037883a 	mov	sp,fp
801340f8:	df000017 	ldw	fp,0(sp)
801340fc:	dec00104 	addi	sp,sp,4
80134100:	f800283a 	ret

80134104 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
80134104:	defff804 	addi	sp,sp,-32
80134108:	de00012e 	bgeu	sp,et,80134110 <OSSchedUnlock+0xc>
8013410c:	003b68fa 	trap	3
80134110:	dfc00715 	stw	ra,28(sp)
80134114:	df000615 	stw	fp,24(sp)
80134118:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8013411c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
80134120:	d0a09a03 	ldbu	r2,-32152(gp)
80134124:	10803fcc 	andi	r2,r2,255
80134128:	10800058 	cmpnei	r2,r2,1
8013412c:	1000281e 	bne	r2,zero,801341d0 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80134130:	0005303a 	rdctl	r2,status
80134134:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80134138:	e0ffff17 	ldw	r3,-4(fp)
8013413c:	00bfff84 	movi	r2,-2
80134140:	1884703a 	and	r2,r3,r2
80134144:	1001703a 	wrctl	status,r2
  
  return context;
80134148:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
8013414c:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
80134150:	d0a09803 	ldbu	r2,-32160(gp)
80134154:	10803fcc 	andi	r2,r2,255
80134158:	10001926 	beq	r2,zero,801341c0 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
8013415c:	d0a09803 	ldbu	r2,-32160(gp)
80134160:	10bfffc4 	addi	r2,r2,-1
80134164:	d0a09805 	stb	r2,-32160(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
80134168:	d0a09803 	ldbu	r2,-32160(gp)
8013416c:	10803fcc 	andi	r2,r2,255
80134170:	10000e1e 	bne	r2,zero,801341ac <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
80134174:	d0a0aa03 	ldbu	r2,-32088(gp)
80134178:	10803fcc 	andi	r2,r2,255
8013417c:	1000061e 	bne	r2,zero,80134198 <OSSchedUnlock+0x94>
80134180:	e0bffa17 	ldw	r2,-24(fp)
80134184:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80134188:	e0bffb17 	ldw	r2,-20(fp)
8013418c:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
80134190:	013504c0 	call	8013504c <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
80134194:	00000e06 	br	801341d0 <OSSchedUnlock+0xcc>
80134198:	e0bffa17 	ldw	r2,-24(fp)
8013419c:	e0bffc15 	stw	r2,-16(fp)
801341a0:	e0bffc17 	ldw	r2,-16(fp)
801341a4:	1001703a 	wrctl	status,r2
801341a8:	00000906 	br	801341d0 <OSSchedUnlock+0xcc>
801341ac:	e0bffa17 	ldw	r2,-24(fp)
801341b0:	e0bffd15 	stw	r2,-12(fp)
801341b4:	e0bffd17 	ldw	r2,-12(fp)
801341b8:	1001703a 	wrctl	status,r2
801341bc:	00000406 	br	801341d0 <OSSchedUnlock+0xcc>
801341c0:	e0bffa17 	ldw	r2,-24(fp)
801341c4:	e0bffe15 	stw	r2,-8(fp)
801341c8:	e0bffe17 	ldw	r2,-8(fp)
801341cc:	1001703a 	wrctl	status,r2
801341d0:	0001883a 	nop
801341d4:	e037883a 	mov	sp,fp
801341d8:	dfc00117 	ldw	ra,4(sp)
801341dc:	df000017 	ldw	fp,0(sp)
801341e0:	dec00204 	addi	sp,sp,8
801341e4:	f800283a 	ret

801341e8 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
801341e8:	defffe04 	addi	sp,sp,-8
801341ec:	de00012e 	bgeu	sp,et,801341f4 <OSStart+0xc>
801341f0:	003b68fa 	trap	3
801341f4:	dfc00115 	stw	ra,4(sp)
801341f8:	df000015 	stw	fp,0(sp)
801341fc:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
80134200:	d0a09a03 	ldbu	r2,-32152(gp)
80134204:	10803fcc 	andi	r2,r2,255
80134208:	10000f1e 	bne	r2,zero,80134248 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
8013420c:	01351240 	call	80135124 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
80134210:	d0a09c83 	ldbu	r2,-32142(gp)
80134214:	d0a09cc5 	stb	r2,-32141(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
80134218:	d0a09c83 	ldbu	r2,-32142(gp)
8013421c:	10c03fcc 	andi	r3,r2,255
80134220:	00a005b4 	movhi	r2,32790
80134224:	10924b04 	addi	r2,r2,18732
80134228:	18c7883a 	add	r3,r3,r3
8013422c:	18c7883a 	add	r3,r3,r3
80134230:	10c5883a 	add	r2,r2,r3
80134234:	10800017 	ldw	r2,0(r2)
80134238:	d0a0a515 	stw	r2,-32108(gp)
        OSTCBCur      = OSTCBHighRdy;
8013423c:	d0a0a517 	ldw	r2,-32108(gp)
80134240:	d0a0ab15 	stw	r2,-32084(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
80134244:	01461900 	call	80146190 <OSStartHighRdy>
    }
}
80134248:	0001883a 	nop
8013424c:	e037883a 	mov	sp,fp
80134250:	dfc00117 	ldw	ra,4(sp)
80134254:	df000017 	ldw	fp,0(sp)
80134258:	dec00204 	addi	sp,sp,8
8013425c:	f800283a 	ret

80134260 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
80134260:	defff904 	addi	sp,sp,-28
80134264:	de00012e 	bgeu	sp,et,8013426c <OSStatInit+0xc>
80134268:	003b68fa 	trap	3
8013426c:	dfc00615 	stw	ra,24(sp)
80134270:	df000515 	stw	fp,20(sp)
80134274:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
80134278:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
8013427c:	01000084 	movi	r4,2
80134280:	013bd880 	call	8013bd88 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80134284:	0005303a 	rdctl	r2,status
80134288:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013428c:	e0fffc17 	ldw	r3,-16(fp)
80134290:	00bfff84 	movi	r2,-2
80134294:	1884703a 	and	r2,r3,r2
80134298:	1001703a 	wrctl	status,r2
  
  return context;
8013429c:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
801342a0:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
801342a4:	d0209b15 	stw	zero,-32148(gp)
801342a8:	e0bffb17 	ldw	r2,-20(fp)
801342ac:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801342b0:	e0bffd17 	ldw	r2,-12(fp)
801342b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
801342b8:	01001904 	movi	r4,100
801342bc:	013bd880 	call	8013bd88 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801342c0:	0005303a 	rdctl	r2,status
801342c4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801342c8:	e0fffe17 	ldw	r3,-8(fp)
801342cc:	00bfff84 	movi	r2,-2
801342d0:	1884703a 	and	r2,r3,r2
801342d4:	1001703a 	wrctl	status,r2
  
  return context;
801342d8:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
801342dc:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
801342e0:	d0a09b17 	ldw	r2,-32148(gp)
801342e4:	d0a0a115 	stw	r2,-32124(gp)
    OSStatRdy    = OS_TRUE;
801342e8:	00800044 	movi	r2,1
801342ec:	d0a0b005 	stb	r2,-32064(gp)
801342f0:	e0bffb17 	ldw	r2,-20(fp)
801342f4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801342f8:	e0bfff17 	ldw	r2,-4(fp)
801342fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
80134300:	0001883a 	nop
80134304:	e037883a 	mov	sp,fp
80134308:	dfc00117 	ldw	ra,4(sp)
8013430c:	df000017 	ldw	fp,0(sp)
80134310:	dec00204 	addi	sp,sp,8
80134314:	f800283a 	ret

80134318 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
80134318:	defff704 	addi	sp,sp,-36
8013431c:	de00012e 	bgeu	sp,et,80134324 <OSTimeTick+0xc>
80134320:	003b68fa 	trap	3
80134324:	dfc00815 	stw	ra,32(sp)
80134328:	df000715 	stw	fp,28(sp)
8013432c:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
80134330:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
80134334:	01463e00 	call	801463e0 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80134338:	0005303a 	rdctl	r2,status
8013433c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80134340:	e0fffd17 	ldw	r3,-12(fp)
80134344:	00bfff84 	movi	r2,-2
80134348:	1884703a 	and	r2,r3,r2
8013434c:	1001703a 	wrctl	status,r2
  
  return context;
80134350:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
80134354:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
80134358:	d0a0ad17 	ldw	r2,-32076(gp)
8013435c:	10800044 	addi	r2,r2,1
80134360:	d0a0ad15 	stw	r2,-32076(gp)
80134364:	e0bffb17 	ldw	r2,-20(fp)
80134368:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013436c:	e0bfff17 	ldw	r2,-4(fp)
80134370:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
80134374:	d0a09a03 	ldbu	r2,-32152(gp)
80134378:	10803fcc 	andi	r2,r2,255
8013437c:	10800058 	cmpnei	r2,r2,1
80134380:	10006a1e 	bne	r2,zero,8013452c <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
80134384:	d0a09e03 	ldbu	r2,-32136(gp)
80134388:	10803fcc 	andi	r2,r2,255
8013438c:	10c00060 	cmpeqi	r3,r2,1
80134390:	1800061e 	bne	r3,zero,801343ac <OSTimeTick+0x94>
80134394:	10c000a0 	cmpeqi	r3,r2,2
80134398:	1800061e 	bne	r3,zero,801343b4 <OSTimeTick+0x9c>
8013439c:	10000a1e 	bne	r2,zero,801343c8 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
801343a0:	00800044 	movi	r2,1
801343a4:	e0bffa05 	stb	r2,-24(fp)
                 break;
801343a8:	00000b06 	br	801343d8 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
801343ac:	e03ffa05 	stb	zero,-24(fp)
                 break;
801343b0:	00000906 	br	801343d8 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
801343b4:	00800044 	movi	r2,1
801343b8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
801343bc:	00800044 	movi	r2,1
801343c0:	d0a09e05 	stb	r2,-32136(gp)
                 break;
801343c4:	00000406 	br	801343d8 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
801343c8:	00800044 	movi	r2,1
801343cc:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
801343d0:	d0209e05 	stb	zero,-32136(gp)
                 break;
801343d4:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
801343d8:	e0bffa03 	ldbu	r2,-24(fp)
801343dc:	10005226 	beq	r2,zero,80134528 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
801343e0:	d0a09d17 	ldw	r2,-32140(gp)
801343e4:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
801343e8:	00004906 	br	80134510 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801343ec:	0005303a 	rdctl	r2,status
801343f0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801343f4:	e0fffc17 	ldw	r3,-16(fp)
801343f8:	00bfff84 	movi	r2,-2
801343fc:	1884703a 	and	r2,r3,r2
80134400:	1001703a 	wrctl	status,r2
  
  return context;
80134404:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
80134408:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
8013440c:	e0bff917 	ldw	r2,-28(fp)
80134410:	10800b8b 	ldhu	r2,46(r2)
80134414:	10bfffcc 	andi	r2,r2,65535
80134418:	10003626 	beq	r2,zero,801344f4 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
8013441c:	e0bff917 	ldw	r2,-28(fp)
80134420:	10800b8b 	ldhu	r2,46(r2)
80134424:	10bfffc4 	addi	r2,r2,-1
80134428:	1007883a 	mov	r3,r2
8013442c:	e0bff917 	ldw	r2,-28(fp)
80134430:	10c00b8d 	sth	r3,46(r2)
80134434:	e0bff917 	ldw	r2,-28(fp)
80134438:	10800b8b 	ldhu	r2,46(r2)
8013443c:	10bfffcc 	andi	r2,r2,65535
80134440:	10002c1e 	bne	r2,zero,801344f4 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
80134444:	e0bff917 	ldw	r2,-28(fp)
80134448:	10800c03 	ldbu	r2,48(r2)
8013444c:	10803fcc 	andi	r2,r2,255
80134450:	10800dcc 	andi	r2,r2,55
80134454:	10000b26 	beq	r2,zero,80134484 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
80134458:	e0bff917 	ldw	r2,-28(fp)
8013445c:	10c00c03 	ldbu	r3,48(r2)
80134460:	00bff204 	movi	r2,-56
80134464:	1884703a 	and	r2,r3,r2
80134468:	1007883a 	mov	r3,r2
8013446c:	e0bff917 	ldw	r2,-28(fp)
80134470:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
80134474:	e0bff917 	ldw	r2,-28(fp)
80134478:	00c00044 	movi	r3,1
8013447c:	10c00c45 	stb	r3,49(r2)
80134480:	00000206 	br	8013448c <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
80134484:	e0bff917 	ldw	r2,-28(fp)
80134488:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
8013448c:	e0bff917 	ldw	r2,-28(fp)
80134490:	10800c03 	ldbu	r2,48(r2)
80134494:	10803fcc 	andi	r2,r2,255
80134498:	1080020c 	andi	r2,r2,8
8013449c:	1000151e 	bne	r2,zero,801344f4 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
801344a0:	e0bff917 	ldw	r2,-28(fp)
801344a4:	10c00d83 	ldbu	r3,54(r2)
801344a8:	d0a0a703 	ldbu	r2,-32100(gp)
801344ac:	1884b03a 	or	r2,r3,r2
801344b0:	d0a0a705 	stb	r2,-32100(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
801344b4:	e0bff917 	ldw	r2,-28(fp)
801344b8:	10800d03 	ldbu	r2,52(r2)
801344bc:	10c03fcc 	andi	r3,r2,255
801344c0:	e0bff917 	ldw	r2,-28(fp)
801344c4:	10800d03 	ldbu	r2,52(r2)
801344c8:	11003fcc 	andi	r4,r2,255
801344cc:	d0a0a744 	addi	r2,gp,-32099
801344d0:	2085883a 	add	r2,r4,r2
801344d4:	11000003 	ldbu	r4,0(r2)
801344d8:	e0bff917 	ldw	r2,-28(fp)
801344dc:	10800d43 	ldbu	r2,53(r2)
801344e0:	2084b03a 	or	r2,r4,r2
801344e4:	1009883a 	mov	r4,r2
801344e8:	d0a0a744 	addi	r2,gp,-32099
801344ec:	1885883a 	add	r2,r3,r2
801344f0:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
801344f4:	e0bff917 	ldw	r2,-28(fp)
801344f8:	10800517 	ldw	r2,20(r2)
801344fc:	e0bff915 	stw	r2,-28(fp)
80134500:	e0bffb17 	ldw	r2,-20(fp)
80134504:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80134508:	e0bffe17 	ldw	r2,-8(fp)
8013450c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
80134510:	e0bff917 	ldw	r2,-28(fp)
80134514:	10800c83 	ldbu	r2,50(r2)
80134518:	10803fcc 	andi	r2,r2,255
8013451c:	10800a98 	cmpnei	r2,r2,42
80134520:	103fb21e 	bne	r2,zero,801343ec <__reset+0xfa1143ec>
80134524:	00000106 	br	8013452c <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
80134528:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8013452c:	e037883a 	mov	sp,fp
80134530:	dfc00117 	ldw	ra,4(sp)
80134534:	df000017 	ldw	fp,0(sp)
80134538:	dec00204 	addi	sp,sp,8
8013453c:	f800283a 	ret

80134540 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
80134540:	deffff04 	addi	sp,sp,-4
80134544:	de00012e 	bgeu	sp,et,8013454c <OSVersion+0xc>
80134548:	003b68fa 	trap	3
8013454c:	df000015 	stw	fp,0(sp)
80134550:	d839883a 	mov	fp,sp
    return (OS_VERSION);
80134554:	00804784 	movi	r2,286
}
80134558:	e037883a 	mov	sp,fp
8013455c:	df000017 	ldw	fp,0(sp)
80134560:	dec00104 	addi	sp,sp,4
80134564:	f800283a 	ret

80134568 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
80134568:	deffff04 	addi	sp,sp,-4
8013456c:	de00012e 	bgeu	sp,et,80134574 <OS_Dummy+0xc>
80134570:	003b68fa 	trap	3
80134574:	df000015 	stw	fp,0(sp)
80134578:	d839883a 	mov	fp,sp
}
8013457c:	0001883a 	nop
80134580:	e037883a 	mov	sp,fp
80134584:	df000017 	ldw	fp,0(sp)
80134588:	dec00104 	addi	sp,sp,4
8013458c:	f800283a 	ret

80134590 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
80134590:	defff804 	addi	sp,sp,-32
80134594:	de00012e 	bgeu	sp,et,8013459c <OS_EventTaskRdy+0xc>
80134598:	003b68fa 	trap	3
8013459c:	dfc00715 	stw	ra,28(sp)
801345a0:	df000615 	stw	fp,24(sp)
801345a4:	df000604 	addi	fp,sp,24
801345a8:	e13ffc15 	stw	r4,-16(fp)
801345ac:	e17ffd15 	stw	r5,-12(fp)
801345b0:	3007883a 	mov	r3,r6
801345b4:	3805883a 	mov	r2,r7
801345b8:	e0fffe05 	stb	r3,-8(fp)
801345bc:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
801345c0:	e0bffc17 	ldw	r2,-16(fp)
801345c4:	10800283 	ldbu	r2,10(r2)
801345c8:	10c03fcc 	andi	r3,r2,255
801345cc:	00a00574 	movhi	r2,32789
801345d0:	10a01204 	addi	r2,r2,-32696
801345d4:	10c5883a 	add	r2,r2,r3
801345d8:	10800003 	ldbu	r2,0(r2)
801345dc:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
801345e0:	e0bffa03 	ldbu	r2,-24(fp)
801345e4:	e0fffc17 	ldw	r3,-16(fp)
801345e8:	1885883a 	add	r2,r3,r2
801345ec:	108002c4 	addi	r2,r2,11
801345f0:	10800003 	ldbu	r2,0(r2)
801345f4:	10c03fcc 	andi	r3,r2,255
801345f8:	00a00574 	movhi	r2,32789
801345fc:	10a01204 	addi	r2,r2,-32696
80134600:	10c5883a 	add	r2,r2,r3
80134604:	10800003 	ldbu	r2,0(r2)
80134608:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8013460c:	e0bffa03 	ldbu	r2,-24(fp)
80134610:	100490fa 	slli	r2,r2,3
80134614:	1007883a 	mov	r3,r2
80134618:	e0bffa43 	ldbu	r2,-23(fp)
8013461c:	1885883a 	add	r2,r3,r2
80134620:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
80134624:	e0fffa83 	ldbu	r3,-22(fp)
80134628:	00a005b4 	movhi	r2,32790
8013462c:	10924b04 	addi	r2,r2,18732
80134630:	18c7883a 	add	r3,r3,r3
80134634:	18c7883a 	add	r3,r3,r3
80134638:	10c5883a 	add	r2,r2,r3
8013463c:	10800017 	ldw	r2,0(r2)
80134640:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
80134644:	e0bffb17 	ldw	r2,-20(fp)
80134648:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8013464c:	e0bffb17 	ldw	r2,-20(fp)
80134650:	e0fffd17 	ldw	r3,-12(fp)
80134654:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
80134658:	e0bffb17 	ldw	r2,-20(fp)
8013465c:	10800c03 	ldbu	r2,48(r2)
80134660:	1007883a 	mov	r3,r2
80134664:	e0bffe03 	ldbu	r2,-8(fp)
80134668:	0084303a 	nor	r2,zero,r2
8013466c:	1884703a 	and	r2,r3,r2
80134670:	1007883a 	mov	r3,r2
80134674:	e0bffb17 	ldw	r2,-20(fp)
80134678:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
8013467c:	e0bffb17 	ldw	r2,-20(fp)
80134680:	e0ffff03 	ldbu	r3,-4(fp)
80134684:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
80134688:	e0bffb17 	ldw	r2,-20(fp)
8013468c:	10800c03 	ldbu	r2,48(r2)
80134690:	10803fcc 	andi	r2,r2,255
80134694:	1080020c 	andi	r2,r2,8
80134698:	1000111e 	bne	r2,zero,801346e0 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
8013469c:	e0bffb17 	ldw	r2,-20(fp)
801346a0:	10c00d83 	ldbu	r3,54(r2)
801346a4:	d0a0a703 	ldbu	r2,-32100(gp)
801346a8:	1884b03a 	or	r2,r3,r2
801346ac:	d0a0a705 	stb	r2,-32100(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
801346b0:	e0fffa03 	ldbu	r3,-24(fp)
801346b4:	e13ffa03 	ldbu	r4,-24(fp)
801346b8:	d0a0a744 	addi	r2,gp,-32099
801346bc:	2085883a 	add	r2,r4,r2
801346c0:	11000003 	ldbu	r4,0(r2)
801346c4:	e0bffb17 	ldw	r2,-20(fp)
801346c8:	10800d43 	ldbu	r2,53(r2)
801346cc:	2084b03a 	or	r2,r4,r2
801346d0:	1009883a 	mov	r4,r2
801346d4:	d0a0a744 	addi	r2,gp,-32099
801346d8:	1885883a 	add	r2,r3,r2
801346dc:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
801346e0:	e17ffc17 	ldw	r5,-16(fp)
801346e4:	e13ffb17 	ldw	r4,-20(fp)
801346e8:	01349a00 	call	801349a0 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
801346ec:	e0bffb17 	ldw	r2,-20(fp)
801346f0:	10800817 	ldw	r2,32(r2)
801346f4:	10000826 	beq	r2,zero,80134718 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
801346f8:	e0bffb17 	ldw	r2,-20(fp)
801346fc:	10800817 	ldw	r2,32(r2)
80134700:	100b883a 	mov	r5,r2
80134704:	e13ffb17 	ldw	r4,-20(fp)
80134708:	0134a600 	call	80134a60 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8013470c:	e0bffb17 	ldw	r2,-20(fp)
80134710:	e0fffc17 	ldw	r3,-16(fp)
80134714:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
80134718:	e0bffa83 	ldbu	r2,-22(fp)
}
8013471c:	e037883a 	mov	sp,fp
80134720:	dfc00117 	ldw	ra,4(sp)
80134724:	df000017 	ldw	fp,0(sp)
80134728:	dec00204 	addi	sp,sp,8
8013472c:	f800283a 	ret

80134730 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
80134730:	defffd04 	addi	sp,sp,-12
80134734:	de00012e 	bgeu	sp,et,8013473c <OS_EventTaskWait+0xc>
80134738:	003b68fa 	trap	3
8013473c:	df000215 	stw	fp,8(sp)
80134740:	df000204 	addi	fp,sp,8
80134744:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
80134748:	d0a0ab17 	ldw	r2,-32084(gp)
8013474c:	e0ffff17 	ldw	r3,-4(fp)
80134750:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
80134754:	d0a0ab17 	ldw	r2,-32084(gp)
80134758:	10800d03 	ldbu	r2,52(r2)
8013475c:	10803fcc 	andi	r2,r2,255
80134760:	d0e0ab17 	ldw	r3,-32084(gp)
80134764:	18c00d03 	ldbu	r3,52(r3)
80134768:	18c03fcc 	andi	r3,r3,255
8013476c:	e13fff17 	ldw	r4,-4(fp)
80134770:	20c7883a 	add	r3,r4,r3
80134774:	18c002c4 	addi	r3,r3,11
80134778:	19000003 	ldbu	r4,0(r3)
8013477c:	d0e0ab17 	ldw	r3,-32084(gp)
80134780:	18c00d43 	ldbu	r3,53(r3)
80134784:	20c6b03a 	or	r3,r4,r3
80134788:	1809883a 	mov	r4,r3
8013478c:	e0ffff17 	ldw	r3,-4(fp)
80134790:	1885883a 	add	r2,r3,r2
80134794:	108002c4 	addi	r2,r2,11
80134798:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
8013479c:	e0bfff17 	ldw	r2,-4(fp)
801347a0:	10c00283 	ldbu	r3,10(r2)
801347a4:	d0a0ab17 	ldw	r2,-32084(gp)
801347a8:	10800d83 	ldbu	r2,54(r2)
801347ac:	1884b03a 	or	r2,r3,r2
801347b0:	1007883a 	mov	r3,r2
801347b4:	e0bfff17 	ldw	r2,-4(fp)
801347b8:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
801347bc:	d0a0ab17 	ldw	r2,-32084(gp)
801347c0:	10800d03 	ldbu	r2,52(r2)
801347c4:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
801347c8:	e0fffe03 	ldbu	r3,-8(fp)
801347cc:	e13ffe03 	ldbu	r4,-8(fp)
801347d0:	d0a0a744 	addi	r2,gp,-32099
801347d4:	2085883a 	add	r2,r4,r2
801347d8:	10800003 	ldbu	r2,0(r2)
801347dc:	1009883a 	mov	r4,r2
801347e0:	d0a0ab17 	ldw	r2,-32084(gp)
801347e4:	10800d43 	ldbu	r2,53(r2)
801347e8:	0084303a 	nor	r2,zero,r2
801347ec:	2084703a 	and	r2,r4,r2
801347f0:	1009883a 	mov	r4,r2
801347f4:	d0a0a744 	addi	r2,gp,-32099
801347f8:	1885883a 	add	r2,r3,r2
801347fc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
80134800:	e0fffe03 	ldbu	r3,-8(fp)
80134804:	d0a0a744 	addi	r2,gp,-32099
80134808:	1885883a 	add	r2,r3,r2
8013480c:	10800003 	ldbu	r2,0(r2)
80134810:	10803fcc 	andi	r2,r2,255
80134814:	1000071e 	bne	r2,zero,80134834 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
80134818:	d0a0ab17 	ldw	r2,-32084(gp)
8013481c:	10800d83 	ldbu	r2,54(r2)
80134820:	0084303a 	nor	r2,zero,r2
80134824:	1007883a 	mov	r3,r2
80134828:	d0a0a703 	ldbu	r2,-32100(gp)
8013482c:	1884703a 	and	r2,r3,r2
80134830:	d0a0a705 	stb	r2,-32100(gp)
    }
}
80134834:	0001883a 	nop
80134838:	e037883a 	mov	sp,fp
8013483c:	df000017 	ldw	fp,0(sp)
80134840:	dec00104 	addi	sp,sp,4
80134844:	f800283a 	ret

80134848 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
80134848:	defffb04 	addi	sp,sp,-20
8013484c:	de00012e 	bgeu	sp,et,80134854 <OS_EventTaskWaitMulti+0xc>
80134850:	003b68fa 	trap	3
80134854:	df000415 	stw	fp,16(sp)
80134858:	df000404 	addi	fp,sp,16
8013485c:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
80134860:	d0a0ab17 	ldw	r2,-32084(gp)
80134864:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
80134868:	d0a0ab17 	ldw	r2,-32084(gp)
8013486c:	e0ffff17 	ldw	r3,-4(fp)
80134870:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
80134874:	e0bfff17 	ldw	r2,-4(fp)
80134878:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
8013487c:	e0bffc17 	ldw	r2,-16(fp)
80134880:	10800017 	ldw	r2,0(r2)
80134884:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
80134888:	00002006 	br	8013490c <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
8013488c:	d0a0ab17 	ldw	r2,-32084(gp)
80134890:	10800d03 	ldbu	r2,52(r2)
80134894:	10803fcc 	andi	r2,r2,255
80134898:	d0e0ab17 	ldw	r3,-32084(gp)
8013489c:	18c00d03 	ldbu	r3,52(r3)
801348a0:	18c03fcc 	andi	r3,r3,255
801348a4:	e13ffd17 	ldw	r4,-12(fp)
801348a8:	20c7883a 	add	r3,r4,r3
801348ac:	18c002c4 	addi	r3,r3,11
801348b0:	19000003 	ldbu	r4,0(r3)
801348b4:	d0e0ab17 	ldw	r3,-32084(gp)
801348b8:	18c00d43 	ldbu	r3,53(r3)
801348bc:	20c6b03a 	or	r3,r4,r3
801348c0:	1809883a 	mov	r4,r3
801348c4:	e0fffd17 	ldw	r3,-12(fp)
801348c8:	1885883a 	add	r2,r3,r2
801348cc:	108002c4 	addi	r2,r2,11
801348d0:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
801348d4:	e0bffd17 	ldw	r2,-12(fp)
801348d8:	10c00283 	ldbu	r3,10(r2)
801348dc:	d0a0ab17 	ldw	r2,-32084(gp)
801348e0:	10800d83 	ldbu	r2,54(r2)
801348e4:	1884b03a 	or	r2,r3,r2
801348e8:	1007883a 	mov	r3,r2
801348ec:	e0bffd17 	ldw	r2,-12(fp)
801348f0:	10c00285 	stb	r3,10(r2)
        pevents++;
801348f4:	e0bffc17 	ldw	r2,-16(fp)
801348f8:	10800104 	addi	r2,r2,4
801348fc:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
80134900:	e0bffc17 	ldw	r2,-16(fp)
80134904:	10800017 	ldw	r2,0(r2)
80134908:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8013490c:	e0bffd17 	ldw	r2,-12(fp)
80134910:	103fde1e 	bne	r2,zero,8013488c <__reset+0xfa11488c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
80134914:	d0a0ab17 	ldw	r2,-32084(gp)
80134918:	10800d03 	ldbu	r2,52(r2)
8013491c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
80134920:	e0fffe03 	ldbu	r3,-8(fp)
80134924:	e13ffe03 	ldbu	r4,-8(fp)
80134928:	d0a0a744 	addi	r2,gp,-32099
8013492c:	2085883a 	add	r2,r4,r2
80134930:	10800003 	ldbu	r2,0(r2)
80134934:	1009883a 	mov	r4,r2
80134938:	d0a0ab17 	ldw	r2,-32084(gp)
8013493c:	10800d43 	ldbu	r2,53(r2)
80134940:	0084303a 	nor	r2,zero,r2
80134944:	2084703a 	and	r2,r4,r2
80134948:	1009883a 	mov	r4,r2
8013494c:	d0a0a744 	addi	r2,gp,-32099
80134950:	1885883a 	add	r2,r3,r2
80134954:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
80134958:	e0fffe03 	ldbu	r3,-8(fp)
8013495c:	d0a0a744 	addi	r2,gp,-32099
80134960:	1885883a 	add	r2,r3,r2
80134964:	10800003 	ldbu	r2,0(r2)
80134968:	10803fcc 	andi	r2,r2,255
8013496c:	1000071e 	bne	r2,zero,8013498c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
80134970:	d0a0ab17 	ldw	r2,-32084(gp)
80134974:	10800d83 	ldbu	r2,54(r2)
80134978:	0084303a 	nor	r2,zero,r2
8013497c:	1007883a 	mov	r3,r2
80134980:	d0a0a703 	ldbu	r2,-32100(gp)
80134984:	1884703a 	and	r2,r3,r2
80134988:	d0a0a705 	stb	r2,-32100(gp)
    }
}
8013498c:	0001883a 	nop
80134990:	e037883a 	mov	sp,fp
80134994:	df000017 	ldw	fp,0(sp)
80134998:	dec00104 	addi	sp,sp,4
8013499c:	f800283a 	ret

801349a0 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
801349a0:	defffc04 	addi	sp,sp,-16
801349a4:	de00012e 	bgeu	sp,et,801349ac <OS_EventTaskRemove+0xc>
801349a8:	003b68fa 	trap	3
801349ac:	df000315 	stw	fp,12(sp)
801349b0:	df000304 	addi	fp,sp,12
801349b4:	e13ffe15 	stw	r4,-8(fp)
801349b8:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
801349bc:	e0bffe17 	ldw	r2,-8(fp)
801349c0:	10800d03 	ldbu	r2,52(r2)
801349c4:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
801349c8:	e0bffd03 	ldbu	r2,-12(fp)
801349cc:	e0fffd03 	ldbu	r3,-12(fp)
801349d0:	e13fff17 	ldw	r4,-4(fp)
801349d4:	20c7883a 	add	r3,r4,r3
801349d8:	18c002c4 	addi	r3,r3,11
801349dc:	18c00003 	ldbu	r3,0(r3)
801349e0:	1809883a 	mov	r4,r3
801349e4:	e0fffe17 	ldw	r3,-8(fp)
801349e8:	18c00d43 	ldbu	r3,53(r3)
801349ec:	00c6303a 	nor	r3,zero,r3
801349f0:	20c6703a 	and	r3,r4,r3
801349f4:	1809883a 	mov	r4,r3
801349f8:	e0ffff17 	ldw	r3,-4(fp)
801349fc:	1885883a 	add	r2,r3,r2
80134a00:	108002c4 	addi	r2,r2,11
80134a04:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
80134a08:	e0bffd03 	ldbu	r2,-12(fp)
80134a0c:	e0ffff17 	ldw	r3,-4(fp)
80134a10:	1885883a 	add	r2,r3,r2
80134a14:	108002c4 	addi	r2,r2,11
80134a18:	10800003 	ldbu	r2,0(r2)
80134a1c:	10803fcc 	andi	r2,r2,255
80134a20:	10000a1e 	bne	r2,zero,80134a4c <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
80134a24:	e0bfff17 	ldw	r2,-4(fp)
80134a28:	10800283 	ldbu	r2,10(r2)
80134a2c:	1007883a 	mov	r3,r2
80134a30:	e0bffe17 	ldw	r2,-8(fp)
80134a34:	10800d83 	ldbu	r2,54(r2)
80134a38:	0084303a 	nor	r2,zero,r2
80134a3c:	1884703a 	and	r2,r3,r2
80134a40:	1007883a 	mov	r3,r2
80134a44:	e0bfff17 	ldw	r2,-4(fp)
80134a48:	10c00285 	stb	r3,10(r2)
    }
}
80134a4c:	0001883a 	nop
80134a50:	e037883a 	mov	sp,fp
80134a54:	df000017 	ldw	fp,0(sp)
80134a58:	dec00104 	addi	sp,sp,4
80134a5c:	f800283a 	ret

80134a60 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
80134a60:	defffa04 	addi	sp,sp,-24
80134a64:	de00012e 	bgeu	sp,et,80134a6c <OS_EventTaskRemoveMulti+0xc>
80134a68:	003b68fa 	trap	3
80134a6c:	df000515 	stw	fp,20(sp)
80134a70:	df000504 	addi	fp,sp,20
80134a74:	e13ffe15 	stw	r4,-8(fp)
80134a78:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
80134a7c:	e0bffe17 	ldw	r2,-8(fp)
80134a80:	10800d03 	ldbu	r2,52(r2)
80134a84:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
80134a88:	e0bffe17 	ldw	r2,-8(fp)
80134a8c:	10800d83 	ldbu	r2,54(r2)
80134a90:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
80134a94:	e0bffe17 	ldw	r2,-8(fp)
80134a98:	10800d43 	ldbu	r2,53(r2)
80134a9c:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
80134aa0:	e0bfff17 	ldw	r2,-4(fp)
80134aa4:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
80134aa8:	e0bffb17 	ldw	r2,-20(fp)
80134aac:	10800017 	ldw	r2,0(r2)
80134ab0:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
80134ab4:	00002506 	br	80134b4c <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
80134ab8:	e0bffd03 	ldbu	r2,-12(fp)
80134abc:	e0fffd03 	ldbu	r3,-12(fp)
80134ac0:	e13ffc17 	ldw	r4,-16(fp)
80134ac4:	20c7883a 	add	r3,r4,r3
80134ac8:	18c002c4 	addi	r3,r3,11
80134acc:	18c00003 	ldbu	r3,0(r3)
80134ad0:	1809883a 	mov	r4,r3
80134ad4:	e0fffd83 	ldbu	r3,-10(fp)
80134ad8:	00c6303a 	nor	r3,zero,r3
80134adc:	20c6703a 	and	r3,r4,r3
80134ae0:	1809883a 	mov	r4,r3
80134ae4:	e0fffc17 	ldw	r3,-16(fp)
80134ae8:	1885883a 	add	r2,r3,r2
80134aec:	108002c4 	addi	r2,r2,11
80134af0:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
80134af4:	e0bffd03 	ldbu	r2,-12(fp)
80134af8:	e0fffc17 	ldw	r3,-16(fp)
80134afc:	1885883a 	add	r2,r3,r2
80134b00:	108002c4 	addi	r2,r2,11
80134b04:	10800003 	ldbu	r2,0(r2)
80134b08:	10803fcc 	andi	r2,r2,255
80134b0c:	1000091e 	bne	r2,zero,80134b34 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
80134b10:	e0bffc17 	ldw	r2,-16(fp)
80134b14:	10800283 	ldbu	r2,10(r2)
80134b18:	1007883a 	mov	r3,r2
80134b1c:	e0bffd43 	ldbu	r2,-11(fp)
80134b20:	0084303a 	nor	r2,zero,r2
80134b24:	1884703a 	and	r2,r3,r2
80134b28:	1007883a 	mov	r3,r2
80134b2c:	e0bffc17 	ldw	r2,-16(fp)
80134b30:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
80134b34:	e0bffb17 	ldw	r2,-20(fp)
80134b38:	10800104 	addi	r2,r2,4
80134b3c:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
80134b40:	e0bffb17 	ldw	r2,-20(fp)
80134b44:	10800017 	ldw	r2,0(r2)
80134b48:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
80134b4c:	e0bffc17 	ldw	r2,-16(fp)
80134b50:	103fd91e 	bne	r2,zero,80134ab8 <__reset+0xfa114ab8>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
80134b54:	0001883a 	nop
80134b58:	e037883a 	mov	sp,fp
80134b5c:	df000017 	ldw	fp,0(sp)
80134b60:	dec00104 	addi	sp,sp,4
80134b64:	f800283a 	ret

80134b68 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
80134b68:	defffc04 	addi	sp,sp,-16
80134b6c:	de00012e 	bgeu	sp,et,80134b74 <OS_EventWaitListInit+0xc>
80134b70:	003b68fa 	trap	3
80134b74:	df000315 	stw	fp,12(sp)
80134b78:	df000304 	addi	fp,sp,12
80134b7c:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
80134b80:	e0bfff17 	ldw	r2,-4(fp)
80134b84:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
80134b88:	e0bfff17 	ldw	r2,-4(fp)
80134b8c:	108002c4 	addi	r2,r2,11
80134b90:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
80134b94:	e03ffe05 	stb	zero,-8(fp)
80134b98:	00000706 	br	80134bb8 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
80134b9c:	e0bffd17 	ldw	r2,-12(fp)
80134ba0:	10c00044 	addi	r3,r2,1
80134ba4:	e0fffd15 	stw	r3,-12(fp)
80134ba8:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
80134bac:	e0bffe03 	ldbu	r2,-8(fp)
80134bb0:	10800044 	addi	r2,r2,1
80134bb4:	e0bffe05 	stb	r2,-8(fp)
80134bb8:	e0bffe03 	ldbu	r2,-8(fp)
80134bbc:	108001b0 	cmpltui	r2,r2,6
80134bc0:	103ff61e 	bne	r2,zero,80134b9c <__reset+0xfa114b9c>
        *ptbl++ = 0;
    }
}
80134bc4:	0001883a 	nop
80134bc8:	e037883a 	mov	sp,fp
80134bcc:	df000017 	ldw	fp,0(sp)
80134bd0:	dec00104 	addi	sp,sp,4
80134bd4:	f800283a 	ret

80134bd8 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
80134bd8:	defffb04 	addi	sp,sp,-20
80134bdc:	de00012e 	bgeu	sp,et,80134be4 <OS_InitEventList+0xc>
80134be0:	003b68fa 	trap	3
80134be4:	dfc00415 	stw	ra,16(sp)
80134be8:	df000315 	stw	fp,12(sp)
80134bec:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
80134bf0:	01434004 	movi	r5,3328
80134bf4:	012005b4 	movhi	r4,32790
80134bf8:	210a9d04 	addi	r4,r4,10868
80134bfc:	0134f800 	call	80134f80 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
80134c00:	00a005b4 	movhi	r2,32790
80134c04:	108a9d04 	addi	r2,r2,10868
80134c08:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
80134c0c:	00a005b4 	movhi	r2,32790
80134c10:	108aaa04 	addi	r2,r2,10920
80134c14:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
80134c18:	e03ffd0d 	sth	zero,-12(fp)
80134c1c:	00001306 	br	80134c6c <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
80134c20:	e0bffe17 	ldw	r2,-8(fp)
80134c24:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
80134c28:	e0bffe17 	ldw	r2,-8(fp)
80134c2c:	e0ffff17 	ldw	r3,-4(fp)
80134c30:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
80134c34:	e0bffe17 	ldw	r2,-8(fp)
80134c38:	00c00fc4 	movi	r3,63
80134c3c:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
80134c40:	e0bffe17 	ldw	r2,-8(fp)
80134c44:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
80134c48:	e0bffe17 	ldw	r2,-8(fp)
80134c4c:	10800d04 	addi	r2,r2,52
80134c50:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
80134c54:	e0bfff17 	ldw	r2,-4(fp)
80134c58:	10800d04 	addi	r2,r2,52
80134c5c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
80134c60:	e0bffd0b 	ldhu	r2,-12(fp)
80134c64:	10800044 	addi	r2,r2,1
80134c68:	e0bffd0d 	sth	r2,-12(fp)
80134c6c:	e0bffd0b 	ldhu	r2,-12(fp)
80134c70:	10800ff0 	cmpltui	r2,r2,63
80134c74:	103fea1e 	bne	r2,zero,80134c20 <__reset+0xfa114c20>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
80134c78:	e0bffe17 	ldw	r2,-8(fp)
80134c7c:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
80134c80:	e0bffe17 	ldw	r2,-8(fp)
80134c84:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
80134c88:	e0bffe17 	ldw	r2,-8(fp)
80134c8c:	00c00fc4 	movi	r3,63
80134c90:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
80134c94:	e0bffe17 	ldw	r2,-8(fp)
80134c98:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
80134c9c:	00a005b4 	movhi	r2,32790
80134ca0:	108a9d04 	addi	r2,r2,10868
80134ca4:	d0a0a915 	stw	r2,-32092(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
80134ca8:	0001883a 	nop
80134cac:	e037883a 	mov	sp,fp
80134cb0:	dfc00117 	ldw	ra,4(sp)
80134cb4:	df000017 	ldw	fp,0(sp)
80134cb8:	dec00204 	addi	sp,sp,8
80134cbc:	f800283a 	ret

80134cc0 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
80134cc0:	deffff04 	addi	sp,sp,-4
80134cc4:	de00012e 	bgeu	sp,et,80134ccc <OS_InitMisc+0xc>
80134cc8:	003b68fa 	trap	3
80134ccc:	df000015 	stw	fp,0(sp)
80134cd0:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
80134cd4:	d020ad15 	stw	zero,-32076(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
80134cd8:	d020aa05 	stb	zero,-32088(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
80134cdc:	d0209805 	stb	zero,-32160(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
80134ce0:	d020a345 	stb	zero,-32115(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
80134ce4:	d0209a05 	stb	zero,-32152(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
80134ce8:	d0209f15 	stw	zero,-32132(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
80134cec:	d0209b15 	stw	zero,-32148(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
80134cf0:	d020b115 	stw	zero,-32060(gp)
    OSIdleCtrMax  = 0L;
80134cf4:	d020a115 	stw	zero,-32124(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
80134cf8:	d020b005 	stb	zero,-32064(gp)
#endif
}
80134cfc:	0001883a 	nop
80134d00:	e037883a 	mov	sp,fp
80134d04:	df000017 	ldw	fp,0(sp)
80134d08:	dec00104 	addi	sp,sp,4
80134d0c:	f800283a 	ret

80134d10 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
80134d10:	defffd04 	addi	sp,sp,-12
80134d14:	de00012e 	bgeu	sp,et,80134d1c <OS_InitRdyList+0xc>
80134d18:	003b68fa 	trap	3
80134d1c:	df000215 	stw	fp,8(sp)
80134d20:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
80134d24:	d020a705 	stb	zero,-32100(gp)
    prdytbl       = &OSRdyTbl[0];
80134d28:	d0a0a744 	addi	r2,gp,-32099
80134d2c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
80134d30:	e03ffe05 	stb	zero,-8(fp)
80134d34:	00000706 	br	80134d54 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
80134d38:	e0bfff17 	ldw	r2,-4(fp)
80134d3c:	10c00044 	addi	r3,r2,1
80134d40:	e0ffff15 	stw	r3,-4(fp)
80134d44:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
80134d48:	e0bffe03 	ldbu	r2,-8(fp)
80134d4c:	10800044 	addi	r2,r2,1
80134d50:	e0bffe05 	stb	r2,-8(fp)
80134d54:	e0bffe03 	ldbu	r2,-8(fp)
80134d58:	108001b0 	cmpltui	r2,r2,6
80134d5c:	103ff61e 	bne	r2,zero,80134d38 <__reset+0xfa114d38>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
80134d60:	d0209cc5 	stb	zero,-32141(gp)
    OSPrioHighRdy = 0;
80134d64:	d0209c85 	stb	zero,-32142(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
80134d68:	d020a515 	stw	zero,-32108(gp)
    OSTCBCur      = (OS_TCB *)0;
80134d6c:	d020ab15 	stw	zero,-32084(gp)
}
80134d70:	0001883a 	nop
80134d74:	e037883a 	mov	sp,fp
80134d78:	df000017 	ldw	fp,0(sp)
80134d7c:	dec00104 	addi	sp,sp,4
80134d80:	f800283a 	ret

80134d84 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
80134d84:	defff804 	addi	sp,sp,-32
80134d88:	de00012e 	bgeu	sp,et,80134d90 <OS_InitTaskIdle+0xc>
80134d8c:	003b68fa 	trap	3
80134d90:	dfc00715 	stw	ra,28(sp)
80134d94:	df000615 	stw	fp,24(sp)
80134d98:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
80134d9c:	008000c4 	movi	r2,3
80134da0:	d8800415 	stw	r2,16(sp)
80134da4:	d8000315 	stw	zero,12(sp)
80134da8:	00810004 	movi	r2,1024
80134dac:	d8800215 	stw	r2,8(sp)
80134db0:	00a005b4 	movhi	r2,32790
80134db4:	10869d04 	addi	r2,r2,6772
80134db8:	d8800115 	stw	r2,4(sp)
80134dbc:	00bfffd4 	movui	r2,65535
80134dc0:	d8800015 	stw	r2,0(sp)
80134dc4:	01c00a84 	movi	r7,42
80134dc8:	01a005b4 	movhi	r6,32790
80134dcc:	318a9c04 	addi	r6,r6,10864
80134dd0:	000b883a 	mov	r5,zero
80134dd4:	012004f4 	movhi	r4,32787
80134dd8:	21149e04 	addi	r4,r4,21112
80134ddc:	013ac680 	call	8013ac68 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
80134de0:	e1bfff04 	addi	r6,fp,-4
80134de4:	01600574 	movhi	r5,32789
80134de8:	29605204 	addi	r5,r5,-32440
80134dec:	01000a84 	movi	r4,42
80134df0:	013b4980 	call	8013b498 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
80134df4:	0001883a 	nop
80134df8:	e037883a 	mov	sp,fp
80134dfc:	dfc00117 	ldw	ra,4(sp)
80134e00:	df000017 	ldw	fp,0(sp)
80134e04:	dec00204 	addi	sp,sp,8
80134e08:	f800283a 	ret

80134e0c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
80134e0c:	defff804 	addi	sp,sp,-32
80134e10:	de00012e 	bgeu	sp,et,80134e18 <OS_InitTaskStat+0xc>
80134e14:	003b68fa 	trap	3
80134e18:	dfc00715 	stw	ra,28(sp)
80134e1c:	df000615 	stw	fp,24(sp)
80134e20:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
80134e24:	008000c4 	movi	r2,3
80134e28:	d8800415 	stw	r2,16(sp)
80134e2c:	d8000315 	stw	zero,12(sp)
80134e30:	00810004 	movi	r2,1024
80134e34:	d8800215 	stw	r2,8(sp)
80134e38:	00a005b4 	movhi	r2,32790
80134e3c:	10bfdd04 	addi	r2,r2,-140
80134e40:	d8800115 	stw	r2,4(sp)
80134e44:	00bfff94 	movui	r2,65534
80134e48:	d8800015 	stw	r2,0(sp)
80134e4c:	01c00a44 	movi	r7,41
80134e50:	01a005b4 	movhi	r6,32790
80134e54:	3183dc04 	addi	r6,r6,3952
80134e58:	000b883a 	mov	r5,zero
80134e5c:	012004f4 	movhi	r4,32787
80134e60:	2114b704 	addi	r4,r4,21212
80134e64:	013ac680 	call	8013ac68 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
80134e68:	e1bfff04 	addi	r6,fp,-4
80134e6c:	01600574 	movhi	r5,32789
80134e70:	29605604 	addi	r5,r5,-32424
80134e74:	01000a44 	movi	r4,41
80134e78:	013b4980 	call	8013b498 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
80134e7c:	0001883a 	nop
80134e80:	e037883a 	mov	sp,fp
80134e84:	dfc00117 	ldw	ra,4(sp)
80134e88:	df000017 	ldw	fp,0(sp)
80134e8c:	dec00204 	addi	sp,sp,8
80134e90:	f800283a 	ret

80134e94 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
80134e94:	defffb04 	addi	sp,sp,-20
80134e98:	de00012e 	bgeu	sp,et,80134ea0 <OS_InitTCBList+0xc>
80134e9c:	003b68fa 	trap	3
80134ea0:	dfc00415 	stw	ra,16(sp)
80134ea4:	df000315 	stw	fp,12(sp)
80134ea8:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
80134eac:	01446e04 	movi	r5,4536
80134eb0:	012005b4 	movhi	r4,32790
80134eb4:	210ddd04 	addi	r4,r4,14196
80134eb8:	0134f800 	call	80134f80 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
80134ebc:	01402b04 	movi	r5,172
80134ec0:	012005b4 	movhi	r4,32790
80134ec4:	21124b04 	addi	r4,r4,18732
80134ec8:	0134f800 	call	80134f80 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
80134ecc:	00a005b4 	movhi	r2,32790
80134ed0:	108ddd04 	addi	r2,r2,14196
80134ed4:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
80134ed8:	00a005b4 	movhi	r2,32790
80134edc:	108df804 	addi	r2,r2,14304
80134ee0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
80134ee4:	e03ffd05 	stb	zero,-12(fp)
80134ee8:	00001106 	br	80134f30 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
80134eec:	e0bffe17 	ldw	r2,-8(fp)
80134ef0:	e0ffff17 	ldw	r3,-4(fp)
80134ef4:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
80134ef8:	e0bffe17 	ldw	r2,-8(fp)
80134efc:	00c00fc4 	movi	r3,63
80134f00:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
80134f04:	e0bffe17 	ldw	r2,-8(fp)
80134f08:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
80134f0c:	e0bffe17 	ldw	r2,-8(fp)
80134f10:	10801b04 	addi	r2,r2,108
80134f14:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
80134f18:	e0bfff17 	ldw	r2,-4(fp)
80134f1c:	10801b04 	addi	r2,r2,108
80134f20:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
80134f24:	e0bffd03 	ldbu	r2,-12(fp)
80134f28:	10800044 	addi	r2,r2,1
80134f2c:	e0bffd05 	stb	r2,-12(fp)
80134f30:	e0bffd03 	ldbu	r2,-12(fp)
80134f34:	10800a70 	cmpltui	r2,r2,41
80134f38:	103fec1e 	bne	r2,zero,80134eec <__reset+0xfa114eec>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
80134f3c:	e0bffe17 	ldw	r2,-8(fp)
80134f40:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
80134f44:	e0bffe17 	ldw	r2,-8(fp)
80134f48:	00c00fc4 	movi	r3,63
80134f4c:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
80134f50:	e0bffe17 	ldw	r2,-8(fp)
80134f54:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
80134f58:	d0209d15 	stw	zero,-32140(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
80134f5c:	00a005b4 	movhi	r2,32790
80134f60:	108ddd04 	addi	r2,r2,14196
80134f64:	d0a0a215 	stw	r2,-32120(gp)
}
80134f68:	0001883a 	nop
80134f6c:	e037883a 	mov	sp,fp
80134f70:	dfc00117 	ldw	ra,4(sp)
80134f74:	df000017 	ldw	fp,0(sp)
80134f78:	dec00204 	addi	sp,sp,8
80134f7c:	f800283a 	ret

80134f80 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
80134f80:	defffd04 	addi	sp,sp,-12
80134f84:	de00012e 	bgeu	sp,et,80134f8c <OS_MemClr+0xc>
80134f88:	003b68fa 	trap	3
80134f8c:	df000215 	stw	fp,8(sp)
80134f90:	df000204 	addi	fp,sp,8
80134f94:	e13ffe15 	stw	r4,-8(fp)
80134f98:	2805883a 	mov	r2,r5
80134f9c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
80134fa0:	00000706 	br	80134fc0 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
80134fa4:	e0bffe17 	ldw	r2,-8(fp)
80134fa8:	10c00044 	addi	r3,r2,1
80134fac:	e0fffe15 	stw	r3,-8(fp)
80134fb0:	10000005 	stb	zero,0(r2)
        size--;
80134fb4:	e0bfff0b 	ldhu	r2,-4(fp)
80134fb8:	10bfffc4 	addi	r2,r2,-1
80134fbc:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
80134fc0:	e0bfff0b 	ldhu	r2,-4(fp)
80134fc4:	103ff71e 	bne	r2,zero,80134fa4 <__reset+0xfa114fa4>
        *pdest++ = (INT8U)0;
        size--;
    }
}
80134fc8:	0001883a 	nop
80134fcc:	e037883a 	mov	sp,fp
80134fd0:	df000017 	ldw	fp,0(sp)
80134fd4:	dec00104 	addi	sp,sp,4
80134fd8:	f800283a 	ret

80134fdc <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
80134fdc:	defffc04 	addi	sp,sp,-16
80134fe0:	de00012e 	bgeu	sp,et,80134fe8 <OS_MemCopy+0xc>
80134fe4:	003b68fa 	trap	3
80134fe8:	df000315 	stw	fp,12(sp)
80134fec:	df000304 	addi	fp,sp,12
80134ff0:	e13ffd15 	stw	r4,-12(fp)
80134ff4:	e17ffe15 	stw	r5,-8(fp)
80134ff8:	3005883a 	mov	r2,r6
80134ffc:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
80135000:	00000b06 	br	80135030 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
80135004:	e0bffd17 	ldw	r2,-12(fp)
80135008:	10c00044 	addi	r3,r2,1
8013500c:	e0fffd15 	stw	r3,-12(fp)
80135010:	e0fffe17 	ldw	r3,-8(fp)
80135014:	19000044 	addi	r4,r3,1
80135018:	e13ffe15 	stw	r4,-8(fp)
8013501c:	18c00003 	ldbu	r3,0(r3)
80135020:	10c00005 	stb	r3,0(r2)
        size--;
80135024:	e0bfff0b 	ldhu	r2,-4(fp)
80135028:	10bfffc4 	addi	r2,r2,-1
8013502c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
80135030:	e0bfff0b 	ldhu	r2,-4(fp)
80135034:	103ff31e 	bne	r2,zero,80135004 <__reset+0xfa115004>
        *pdest++ = *psrc++;
        size--;
    }
}
80135038:	0001883a 	nop
8013503c:	e037883a 	mov	sp,fp
80135040:	df000017 	ldw	fp,0(sp)
80135044:	dec00104 	addi	sp,sp,4
80135048:	f800283a 	ret

8013504c <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
8013504c:	defffb04 	addi	sp,sp,-20
80135050:	de00012e 	bgeu	sp,et,80135058 <OS_Sched+0xc>
80135054:	003b68fa 	trap	3
80135058:	dfc00415 	stw	ra,16(sp)
8013505c:	df000315 	stw	fp,12(sp)
80135060:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
80135064:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80135068:	0005303a 	rdctl	r2,status
8013506c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80135070:	e0ffff17 	ldw	r3,-4(fp)
80135074:	00bfff84 	movi	r2,-2
80135078:	1884703a 	and	r2,r3,r2
8013507c:	1001703a 	wrctl	status,r2
  
  return context;
80135080:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
80135084:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
80135088:	d0a0aa03 	ldbu	r2,-32088(gp)
8013508c:	10803fcc 	andi	r2,r2,255
80135090:	10001a1e 	bne	r2,zero,801350fc <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
80135094:	d0a09803 	ldbu	r2,-32160(gp)
80135098:	10803fcc 	andi	r2,r2,255
8013509c:	1000171e 	bne	r2,zero,801350fc <OS_Sched+0xb0>
            OS_SchedNew();
801350a0:	01351240 	call	80135124 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
801350a4:	d0e09c83 	ldbu	r3,-32142(gp)
801350a8:	d0a09cc3 	ldbu	r2,-32141(gp)
801350ac:	18c03fcc 	andi	r3,r3,255
801350b0:	10803fcc 	andi	r2,r2,255
801350b4:	18801126 	beq	r3,r2,801350fc <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
801350b8:	d0a09c83 	ldbu	r2,-32142(gp)
801350bc:	10c03fcc 	andi	r3,r2,255
801350c0:	00a005b4 	movhi	r2,32790
801350c4:	10924b04 	addi	r2,r2,18732
801350c8:	18c7883a 	add	r3,r3,r3
801350cc:	18c7883a 	add	r3,r3,r3
801350d0:	10c5883a 	add	r2,r2,r3
801350d4:	10800017 	ldw	r2,0(r2)
801350d8:	d0a0a515 	stw	r2,-32108(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
801350dc:	d0a0a517 	ldw	r2,-32108(gp)
801350e0:	10c00e17 	ldw	r3,56(r2)
801350e4:	18c00044 	addi	r3,r3,1
801350e8:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
801350ec:	d0a09f17 	ldw	r2,-32132(gp)
801350f0:	10800044 	addi	r2,r2,1
801350f4:	d0a09f15 	stw	r2,-32132(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
801350f8:	01460f40 	call	801460f4 <OSCtxSw>
801350fc:	e0bffd17 	ldw	r2,-12(fp)
80135100:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80135104:	e0bffe17 	ldw	r2,-8(fp)
80135108:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
8013510c:	0001883a 	nop
80135110:	e037883a 	mov	sp,fp
80135114:	dfc00117 	ldw	ra,4(sp)
80135118:	df000017 	ldw	fp,0(sp)
8013511c:	dec00204 	addi	sp,sp,8
80135120:	f800283a 	ret

80135124 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
80135124:	defffe04 	addi	sp,sp,-8
80135128:	de00012e 	bgeu	sp,et,80135130 <OS_SchedNew+0xc>
8013512c:	003b68fa 	trap	3
80135130:	df000115 	stw	fp,4(sp)
80135134:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
80135138:	d0a0a703 	ldbu	r2,-32100(gp)
8013513c:	10c03fcc 	andi	r3,r2,255
80135140:	00a00574 	movhi	r2,32789
80135144:	10a01204 	addi	r2,r2,-32696
80135148:	10c5883a 	add	r2,r2,r3
8013514c:	10800003 	ldbu	r2,0(r2)
80135150:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
80135154:	e0bfff03 	ldbu	r2,-4(fp)
80135158:	100490fa 	slli	r2,r2,3
8013515c:	1009883a 	mov	r4,r2
80135160:	e0ffff03 	ldbu	r3,-4(fp)
80135164:	d0a0a744 	addi	r2,gp,-32099
80135168:	1885883a 	add	r2,r3,r2
8013516c:	10800003 	ldbu	r2,0(r2)
80135170:	10c03fcc 	andi	r3,r2,255
80135174:	00a00574 	movhi	r2,32789
80135178:	10a01204 	addi	r2,r2,-32696
8013517c:	10c5883a 	add	r2,r2,r3
80135180:	10800003 	ldbu	r2,0(r2)
80135184:	2085883a 	add	r2,r4,r2
80135188:	d0a09c85 	stb	r2,-32142(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
8013518c:	0001883a 	nop
80135190:	e037883a 	mov	sp,fp
80135194:	df000017 	ldw	fp,0(sp)
80135198:	dec00104 	addi	sp,sp,4
8013519c:	f800283a 	ret

801351a0 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
801351a0:	defffc04 	addi	sp,sp,-16
801351a4:	de00012e 	bgeu	sp,et,801351ac <OS_StrCopy+0xc>
801351a8:	003b68fa 	trap	3
801351ac:	df000315 	stw	fp,12(sp)
801351b0:	df000304 	addi	fp,sp,12
801351b4:	e13ffe15 	stw	r4,-8(fp)
801351b8:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
801351bc:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
801351c0:	00000b06 	br	801351f0 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
801351c4:	e0bffe17 	ldw	r2,-8(fp)
801351c8:	10c00044 	addi	r3,r2,1
801351cc:	e0fffe15 	stw	r3,-8(fp)
801351d0:	e0ffff17 	ldw	r3,-4(fp)
801351d4:	19000044 	addi	r4,r3,1
801351d8:	e13fff15 	stw	r4,-4(fp)
801351dc:	18c00003 	ldbu	r3,0(r3)
801351e0:	10c00005 	stb	r3,0(r2)
        len++;
801351e4:	e0bffd03 	ldbu	r2,-12(fp)
801351e8:	10800044 	addi	r2,r2,1
801351ec:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
801351f0:	e0bfff17 	ldw	r2,-4(fp)
801351f4:	10800003 	ldbu	r2,0(r2)
801351f8:	10803fcc 	andi	r2,r2,255
801351fc:	103ff11e 	bne	r2,zero,801351c4 <__reset+0xfa1151c4>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
80135200:	e0bffe17 	ldw	r2,-8(fp)
80135204:	10000005 	stb	zero,0(r2)
    return (len);
80135208:	e0bffd03 	ldbu	r2,-12(fp)
}
8013520c:	e037883a 	mov	sp,fp
80135210:	df000017 	ldw	fp,0(sp)
80135214:	dec00104 	addi	sp,sp,4
80135218:	f800283a 	ret

8013521c <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
8013521c:	defffd04 	addi	sp,sp,-12
80135220:	de00012e 	bgeu	sp,et,80135228 <OS_StrLen+0xc>
80135224:	003b68fa 	trap	3
80135228:	df000215 	stw	fp,8(sp)
8013522c:	df000204 	addi	fp,sp,8
80135230:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
80135234:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
80135238:	00000606 	br	80135254 <OS_StrLen+0x38>
        psrc++;
8013523c:	e0bfff17 	ldw	r2,-4(fp)
80135240:	10800044 	addi	r2,r2,1
80135244:	e0bfff15 	stw	r2,-4(fp)
        len++;
80135248:	e0bffe03 	ldbu	r2,-8(fp)
8013524c:	10800044 	addi	r2,r2,1
80135250:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
80135254:	e0bfff17 	ldw	r2,-4(fp)
80135258:	10800003 	ldbu	r2,0(r2)
8013525c:	10803fcc 	andi	r2,r2,255
80135260:	103ff61e 	bne	r2,zero,8013523c <__reset+0xfa11523c>
        psrc++;
        len++;
    }
    return (len);
80135264:	e0bffe03 	ldbu	r2,-8(fp)
}
80135268:	e037883a 	mov	sp,fp
8013526c:	df000017 	ldw	fp,0(sp)
80135270:	dec00104 	addi	sp,sp,4
80135274:	f800283a 	ret

80135278 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
80135278:	defffa04 	addi	sp,sp,-24
8013527c:	de00012e 	bgeu	sp,et,80135284 <OS_TaskIdle+0xc>
80135280:	003b68fa 	trap	3
80135284:	dfc00515 	stw	ra,20(sp)
80135288:	df000415 	stw	fp,16(sp)
8013528c:	df000404 	addi	fp,sp,16
80135290:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
80135294:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80135298:	0005303a 	rdctl	r2,status
8013529c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801352a0:	e0fffd17 	ldw	r3,-12(fp)
801352a4:	00bfff84 	movi	r2,-2
801352a8:	1884703a 	and	r2,r3,r2
801352ac:	1001703a 	wrctl	status,r2
  
  return context;
801352b0:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
801352b4:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
801352b8:	d0a09b17 	ldw	r2,-32148(gp)
801352bc:	10800044 	addi	r2,r2,1
801352c0:	d0a09b15 	stw	r2,-32148(gp)
801352c4:	e0bffc17 	ldw	r2,-16(fp)
801352c8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801352cc:	e0bffe17 	ldw	r2,-8(fp)
801352d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
801352d4:	01464880 	call	80146488 <OSTaskIdleHook>
    }
801352d8:	003fef06 	br	80135298 <__reset+0xfa115298>

801352dc <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
801352dc:	defff804 	addi	sp,sp,-32
801352e0:	de00012e 	bgeu	sp,et,801352e8 <OS_TaskStat+0xc>
801352e4:	003b68fa 	trap	3
801352e8:	dfc00715 	stw	ra,28(sp)
801352ec:	df000615 	stw	fp,24(sp)
801352f0:	dc400515 	stw	r17,20(sp)
801352f4:	dc000415 	stw	r16,16(sp)
801352f8:	df000604 	addi	fp,sp,24
801352fc:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
80135300:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
80135304:	00000206 	br	80135310 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
80135308:	01003204 	movi	r4,200
8013530c:	013bd880 	call	8013bd88 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
80135310:	d0a0b003 	ldbu	r2,-32064(gp)
80135314:	10803fcc 	andi	r2,r2,255
80135318:	103ffb26 	beq	r2,zero,80135308 <__reset+0xfa115308>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
8013531c:	d0e0a117 	ldw	r3,-32124(gp)
80135320:	00947b34 	movhi	r2,20972
80135324:	10a147c4 	addi	r2,r2,-31457
80135328:	1888383a 	mulxuu	r4,r3,r2
8013532c:	1885383a 	mul	r2,r3,r2
80135330:	1021883a 	mov	r16,r2
80135334:	2023883a 	mov	r17,r4
80135338:	8804d17a 	srli	r2,r17,5
8013533c:	d0a0a115 	stw	r2,-32124(gp)
    if (OSIdleCtrMax == 0L) {
80135340:	d0a0a117 	ldw	r2,-32124(gp)
80135344:	1000031e 	bne	r2,zero,80135354 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
80135348:	d020a305 	stb	zero,-32116(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
8013534c:	01003fc4 	movi	r4,255
80135350:	013b9f80 	call	8013b9f8 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80135354:	0005303a 	rdctl	r2,status
80135358:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013535c:	e0fffb17 	ldw	r3,-20(fp)
80135360:	00bfff84 	movi	r2,-2
80135364:	1884703a 	and	r2,r3,r2
80135368:	1001703a 	wrctl	status,r2
  
  return context;
8013536c:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
80135370:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
80135374:	d0a09b17 	ldw	r2,-32148(gp)
80135378:	d0a0b115 	stw	r2,-32060(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
8013537c:	d0209b15 	stw	zero,-32148(gp)
80135380:	e0bffa17 	ldw	r2,-24(fp)
80135384:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80135388:	e0bffc17 	ldw	r2,-16(fp)
8013538c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
80135390:	d0e0b117 	ldw	r3,-32060(gp)
80135394:	d0a0a117 	ldw	r2,-32124(gp)
80135398:	1885203a 	divu	r2,r3,r2
8013539c:	1007883a 	mov	r3,r2
801353a0:	00801904 	movi	r2,100
801353a4:	10c5c83a 	sub	r2,r2,r3
801353a8:	d0a0a305 	stb	r2,-32116(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
801353ac:	01463b80 	call	801463b8 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
801353b0:	01353c00 	call	801353c0 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
801353b4:	01001904 	movi	r4,100
801353b8:	013bd880 	call	8013bd88 <OSTimeDly>
    }
801353bc:	003fe506 	br	80135354 <__reset+0xfa115354>

801353c0 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
801353c0:	defffa04 	addi	sp,sp,-24
801353c4:	de00012e 	bgeu	sp,et,801353cc <OS_TaskStatStkChk+0xc>
801353c8:	003b68fa 	trap	3
801353cc:	dfc00515 	stw	ra,20(sp)
801353d0:	df000415 	stw	fp,16(sp)
801353d4:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
801353d8:	e03ffc05 	stb	zero,-16(fp)
801353dc:	00002406 	br	80135470 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
801353e0:	e0bffc03 	ldbu	r2,-16(fp)
801353e4:	e0fffe04 	addi	r3,fp,-8
801353e8:	180b883a 	mov	r5,r3
801353ec:	1009883a 	mov	r4,r2
801353f0:	013b8300 	call	8013b830 <OSTaskStkChk>
801353f4:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
801353f8:	e0bffc43 	ldbu	r2,-15(fp)
801353fc:	1000191e 	bne	r2,zero,80135464 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
80135400:	e0fffc03 	ldbu	r3,-16(fp)
80135404:	00a005b4 	movhi	r2,32790
80135408:	10924b04 	addi	r2,r2,18732
8013540c:	18c7883a 	add	r3,r3,r3
80135410:	18c7883a 	add	r3,r3,r3
80135414:	10c5883a 	add	r2,r2,r3
80135418:	10800017 	ldw	r2,0(r2)
8013541c:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
80135420:	e0bffd17 	ldw	r2,-12(fp)
80135424:	10000f26 	beq	r2,zero,80135464 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
80135428:	e0bffd17 	ldw	r2,-12(fp)
8013542c:	10800060 	cmpeqi	r2,r2,1
80135430:	10000c1e 	bne	r2,zero,80135464 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
80135434:	e0bffd17 	ldw	r2,-12(fp)
80135438:	10c00217 	ldw	r3,8(r2)
8013543c:	e0bffd17 	ldw	r2,-12(fp)
80135440:	10800317 	ldw	r2,12(r2)
80135444:	1085883a 	add	r2,r2,r2
80135448:	1085883a 	add	r2,r2,r2
8013544c:	1887883a 	add	r3,r3,r2
80135450:	e0bffd17 	ldw	r2,-12(fp)
80135454:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
80135458:	e0ffff17 	ldw	r3,-4(fp)
8013545c:	e0bffd17 	ldw	r2,-12(fp)
80135460:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
80135464:	e0bffc03 	ldbu	r2,-16(fp)
80135468:	10800044 	addi	r2,r2,1
8013546c:	e0bffc05 	stb	r2,-16(fp)
80135470:	e0bffc03 	ldbu	r2,-16(fp)
80135474:	10800af0 	cmpltui	r2,r2,43
80135478:	103fd91e 	bne	r2,zero,801353e0 <__reset+0xfa1153e0>
#endif
                }
            }
        }
    }
}
8013547c:	0001883a 	nop
80135480:	e037883a 	mov	sp,fp
80135484:	dfc00117 	ldw	ra,4(sp)
80135488:	df000017 	ldw	fp,0(sp)
8013548c:	dec00204 	addi	sp,sp,8
80135490:	f800283a 	ret

80135494 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
80135494:	defff204 	addi	sp,sp,-56
80135498:	de00012e 	bgeu	sp,et,801354a0 <OS_TCBInit+0xc>
8013549c:	003b68fa 	trap	3
801354a0:	dfc00d15 	stw	ra,52(sp)
801354a4:	df000c15 	stw	fp,48(sp)
801354a8:	df000c04 	addi	fp,sp,48
801354ac:	e17ffc15 	stw	r5,-16(fp)
801354b0:	e1bffd15 	stw	r6,-12(fp)
801354b4:	3807883a 	mov	r3,r7
801354b8:	e0800417 	ldw	r2,16(fp)
801354bc:	e13ffb05 	stb	r4,-20(fp)
801354c0:	e0fffe0d 	sth	r3,-8(fp)
801354c4:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
801354c8:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801354cc:	0005303a 	rdctl	r2,status
801354d0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801354d4:	e0fffa17 	ldw	r3,-24(fp)
801354d8:	00bfff84 	movi	r2,-2
801354dc:	1884703a 	and	r2,r3,r2
801354e0:	1001703a 	wrctl	status,r2
  
  return context;
801354e4:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
801354e8:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
801354ec:	d0a0a217 	ldw	r2,-32120(gp)
801354f0:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
801354f4:	e0bff617 	ldw	r2,-40(fp)
801354f8:	10009326 	beq	r2,zero,80135748 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
801354fc:	e0bff617 	ldw	r2,-40(fp)
80135500:	10800517 	ldw	r2,20(r2)
80135504:	d0a0a215 	stw	r2,-32120(gp)
80135508:	e0bff417 	ldw	r2,-48(fp)
8013550c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80135510:	e0bff817 	ldw	r2,-32(fp)
80135514:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
80135518:	e0bff617 	ldw	r2,-40(fp)
8013551c:	e0fffc17 	ldw	r3,-16(fp)
80135520:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
80135524:	e0bff617 	ldw	r2,-40(fp)
80135528:	e0fffb03 	ldbu	r3,-20(fp)
8013552c:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
80135530:	e0bff617 	ldw	r2,-40(fp)
80135534:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
80135538:	e0bff617 	ldw	r2,-40(fp)
8013553c:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
80135540:	e0bff617 	ldw	r2,-40(fp)
80135544:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
80135548:	e0bff617 	ldw	r2,-40(fp)
8013554c:	e0c00317 	ldw	r3,12(fp)
80135550:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
80135554:	e0bff617 	ldw	r2,-40(fp)
80135558:	e0c00217 	ldw	r3,8(fp)
8013555c:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
80135560:	e0bff617 	ldw	r2,-40(fp)
80135564:	e0fffd17 	ldw	r3,-12(fp)
80135568:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
8013556c:	e0bff617 	ldw	r2,-40(fp)
80135570:	e0ffff0b 	ldhu	r3,-4(fp)
80135574:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
80135578:	e0bff617 	ldw	r2,-40(fp)
8013557c:	e0fffe0b 	ldhu	r3,-8(fp)
80135580:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
80135584:	e0bff617 	ldw	r2,-40(fp)
80135588:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
8013558c:	e0bffb03 	ldbu	r2,-20(fp)
80135590:	1004d0fa 	srli	r2,r2,3
80135594:	1007883a 	mov	r3,r2
80135598:	e0bff617 	ldw	r2,-40(fp)
8013559c:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
801355a0:	e0bffb03 	ldbu	r2,-20(fp)
801355a4:	108001cc 	andi	r2,r2,7
801355a8:	1007883a 	mov	r3,r2
801355ac:	e0bff617 	ldw	r2,-40(fp)
801355b0:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
801355b4:	e0bff617 	ldw	r2,-40(fp)
801355b8:	10800d03 	ldbu	r2,52(r2)
801355bc:	10803fcc 	andi	r2,r2,255
801355c0:	00c00044 	movi	r3,1
801355c4:	1884983a 	sll	r2,r3,r2
801355c8:	1007883a 	mov	r3,r2
801355cc:	e0bff617 	ldw	r2,-40(fp)
801355d0:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
801355d4:	e0bff617 	ldw	r2,-40(fp)
801355d8:	10800cc3 	ldbu	r2,51(r2)
801355dc:	10803fcc 	andi	r2,r2,255
801355e0:	00c00044 	movi	r3,1
801355e4:	1884983a 	sll	r2,r3,r2
801355e8:	1007883a 	mov	r3,r2
801355ec:	e0bff617 	ldw	r2,-40(fp)
801355f0:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
801355f4:	e0bff617 	ldw	r2,-40(fp)
801355f8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
801355fc:	e0bff617 	ldw	r2,-40(fp)
80135600:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
80135604:	e0bff617 	ldw	r2,-40(fp)
80135608:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8013560c:	e0bff617 	ldw	r2,-40(fp)
80135610:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
80135614:	e0bff617 	ldw	r2,-40(fp)
80135618:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8013561c:	e0bff617 	ldw	r2,-40(fp)
80135620:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
80135624:	e0bff617 	ldw	r2,-40(fp)
80135628:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8013562c:	e0bff617 	ldw	r2,-40(fp)
80135630:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
80135634:	e0bff617 	ldw	r2,-40(fp)
80135638:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8013563c:	e0bff617 	ldw	r2,-40(fp)
80135640:	00c00fc4 	movi	r3,63
80135644:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
80135648:	e0bff617 	ldw	r2,-40(fp)
8013564c:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
80135650:	e13ff617 	ldw	r4,-40(fp)
80135654:	01464b00 	call	801464b0 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
80135658:	e13ff617 	ldw	r4,-40(fp)
8013565c:	01463380 	call	80146338 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80135660:	0005303a 	rdctl	r2,status
80135664:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80135668:	e0fff517 	ldw	r3,-44(fp)
8013566c:	00bfff84 	movi	r2,-2
80135670:	1884703a 	and	r2,r3,r2
80135674:	1001703a 	wrctl	status,r2
  
  return context;
80135678:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
8013567c:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
80135680:	e0fffb03 	ldbu	r3,-20(fp)
80135684:	00a005b4 	movhi	r2,32790
80135688:	10924b04 	addi	r2,r2,18732
8013568c:	18c7883a 	add	r3,r3,r3
80135690:	18c7883a 	add	r3,r3,r3
80135694:	10c5883a 	add	r2,r2,r3
80135698:	e0fff617 	ldw	r3,-40(fp)
8013569c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
801356a0:	d0e09d17 	ldw	r3,-32140(gp)
801356a4:	e0bff617 	ldw	r2,-40(fp)
801356a8:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
801356ac:	e0bff617 	ldw	r2,-40(fp)
801356b0:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
801356b4:	d0a09d17 	ldw	r2,-32140(gp)
801356b8:	10000326 	beq	r2,zero,801356c8 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
801356bc:	d0a09d17 	ldw	r2,-32140(gp)
801356c0:	e0fff617 	ldw	r3,-40(fp)
801356c4:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
801356c8:	e0bff617 	ldw	r2,-40(fp)
801356cc:	d0a09d15 	stw	r2,-32140(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
801356d0:	e0bff617 	ldw	r2,-40(fp)
801356d4:	10c00d83 	ldbu	r3,54(r2)
801356d8:	d0a0a703 	ldbu	r2,-32100(gp)
801356dc:	1884b03a 	or	r2,r3,r2
801356e0:	d0a0a705 	stb	r2,-32100(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
801356e4:	e0bff617 	ldw	r2,-40(fp)
801356e8:	10800d03 	ldbu	r2,52(r2)
801356ec:	10c03fcc 	andi	r3,r2,255
801356f0:	e0bff617 	ldw	r2,-40(fp)
801356f4:	10800d03 	ldbu	r2,52(r2)
801356f8:	11003fcc 	andi	r4,r2,255
801356fc:	d0a0a744 	addi	r2,gp,-32099
80135700:	2085883a 	add	r2,r4,r2
80135704:	11000003 	ldbu	r4,0(r2)
80135708:	e0bff617 	ldw	r2,-40(fp)
8013570c:	10800d43 	ldbu	r2,53(r2)
80135710:	2084b03a 	or	r2,r4,r2
80135714:	1009883a 	mov	r4,r2
80135718:	d0a0a744 	addi	r2,gp,-32099
8013571c:	1885883a 	add	r2,r3,r2
80135720:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
80135724:	d0a0a343 	ldbu	r2,-32115(gp)
80135728:	10800044 	addi	r2,r2,1
8013572c:	d0a0a345 	stb	r2,-32115(gp)
80135730:	e0bff417 	ldw	r2,-48(fp)
80135734:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80135738:	e0bff717 	ldw	r2,-36(fp)
8013573c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
80135740:	0005883a 	mov	r2,zero
80135744:	00000506 	br	8013575c <OS_TCBInit+0x2c8>
80135748:	e0bff417 	ldw	r2,-48(fp)
8013574c:	e0bff915 	stw	r2,-28(fp)
80135750:	e0bff917 	ldw	r2,-28(fp)
80135754:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
80135758:	00801084 	movi	r2,66
}
8013575c:	e037883a 	mov	sp,fp
80135760:	dfc00117 	ldw	ra,4(sp)
80135764:	df000017 	ldw	fp,0(sp)
80135768:	dec00204 	addi	sp,sp,8
8013576c:	f800283a 	ret

80135770 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
80135770:	defffe04 	addi	sp,sp,-8
80135774:	de00012e 	bgeu	sp,et,8013577c <OSDebugInit+0xc>
80135778:	003b68fa 	trap	3
8013577c:	df000115 	stw	fp,4(sp)
80135780:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
80135784:	d0a01704 	addi	r2,gp,-32676
80135788:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
8013578c:	d0a01804 	addi	r2,gp,-32672
80135790:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
80135794:	d0a01984 	addi	r2,gp,-32666
80135798:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
8013579c:	d0a01a04 	addi	r2,gp,-32664
801357a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
801357a4:	d0a01904 	addi	r2,gp,-32668
801357a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
801357ac:	d0a01a84 	addi	r2,gp,-32662
801357b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
801357b4:	d0a01b04 	addi	r2,gp,-32660
801357b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
801357bc:	d0a01b84 	addi	r2,gp,-32658
801357c0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
801357c4:	d0a01c04 	addi	r2,gp,-32656
801357c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
801357cc:	d0a01c84 	addi	r2,gp,-32654
801357d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
801357d4:	d0a01d04 	addi	r2,gp,-32652
801357d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
801357dc:	d0a01d84 	addi	r2,gp,-32650
801357e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
801357e4:	d0a01e04 	addi	r2,gp,-32648
801357e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
801357ec:	d0a01e84 	addi	r2,gp,-32646
801357f0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
801357f4:	d0a01f04 	addi	r2,gp,-32644
801357f8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
801357fc:	d0a01f84 	addi	r2,gp,-32642
80135800:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
80135804:	d0a02004 	addi	r2,gp,-32640
80135808:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8013580c:	d0a02084 	addi	r2,gp,-32638
80135810:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
80135814:	d0a02104 	addi	r2,gp,-32636
80135818:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8013581c:	d0a02184 	addi	r2,gp,-32634
80135820:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
80135824:	d0a02204 	addi	r2,gp,-32632
80135828:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8013582c:	d0a02284 	addi	r2,gp,-32630
80135830:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
80135834:	d0a02304 	addi	r2,gp,-32628
80135838:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8013583c:	d0a02384 	addi	r2,gp,-32626
80135840:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
80135844:	d0a02404 	addi	r2,gp,-32624
80135848:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8013584c:	d0a02484 	addi	r2,gp,-32622
80135850:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
80135854:	d0a02504 	addi	r2,gp,-32620
80135858:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8013585c:	d0a02584 	addi	r2,gp,-32618
80135860:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
80135864:	d0a02604 	addi	r2,gp,-32616
80135868:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
8013586c:	d0a02684 	addi	r2,gp,-32614
80135870:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
80135874:	d0a02704 	addi	r2,gp,-32612
80135878:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
8013587c:	d0a02784 	addi	r2,gp,-32610
80135880:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
80135884:	d0a02804 	addi	r2,gp,-32608
80135888:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
8013588c:	d0a02884 	addi	r2,gp,-32606
80135890:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
80135894:	d0a02904 	addi	r2,gp,-32604
80135898:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
8013589c:	d0a02984 	addi	r2,gp,-32602
801358a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
801358a4:	d0a02a04 	addi	r2,gp,-32600
801358a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
801358ac:	d0a02a84 	addi	r2,gp,-32598
801358b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
801358b4:	d0a02b04 	addi	r2,gp,-32596
801358b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
801358bc:	d0a02b84 	addi	r2,gp,-32594
801358c0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
801358c4:	d0a02c04 	addi	r2,gp,-32592
801358c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
801358cc:	d0a02c84 	addi	r2,gp,-32590
801358d0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
801358d4:	d0a02d04 	addi	r2,gp,-32588
801358d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
801358dc:	d0a02d84 	addi	r2,gp,-32586
801358e0:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
801358e4:	00a005b4 	movhi	r2,32790
801358e8:	10bc6904 	addi	r2,r2,-3676
801358ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
801358f0:	00a005b4 	movhi	r2,32790
801358f4:	10ba5504 	addi	r2,r2,-5804
801358f8:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
801358fc:	d0a02e84 	addi	r2,gp,-32582
80135900:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
80135904:	d0a02f04 	addi	r2,gp,-32580
80135908:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8013590c:	d0a02f84 	addi	r2,gp,-32578
80135910:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
80135914:	d0a03004 	addi	r2,gp,-32576
80135918:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8013591c:	d0a03084 	addi	r2,gp,-32574
80135920:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
80135924:	d0a03104 	addi	r2,gp,-32572
80135928:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8013592c:	d0a03184 	addi	r2,gp,-32570
80135930:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
80135934:	d0a03204 	addi	r2,gp,-32568
80135938:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8013593c:	d0a03284 	addi	r2,gp,-32566
80135940:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
80135944:	d0a02e04 	addi	r2,gp,-32584
80135948:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8013594c:	d0a03304 	addi	r2,gp,-32564
80135950:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
80135954:	0001883a 	nop
80135958:	e037883a 	mov	sp,fp
8013595c:	df000017 	ldw	fp,0(sp)
80135960:	dec00104 	addi	sp,sp,4
80135964:	f800283a 	ret

80135968 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
80135968:	defff204 	addi	sp,sp,-56
8013596c:	de00012e 	bgeu	sp,et,80135974 <OSFlagAccept+0xc>
80135970:	003b68fa 	trap	3
80135974:	df000d15 	stw	fp,52(sp)
80135978:	df000d04 	addi	fp,sp,52
8013597c:	e13ffc15 	stw	r4,-16(fp)
80135980:	2807883a 	mov	r3,r5
80135984:	3005883a 	mov	r2,r6
80135988:	e1ffff15 	stw	r7,-4(fp)
8013598c:	e0fffd0d 	sth	r3,-12(fp)
80135990:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
80135994:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
80135998:	e0bfff17 	ldw	r2,-4(fp)
8013599c:	1000021e 	bne	r2,zero,801359a8 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
801359a0:	0005883a 	mov	r2,zero
801359a4:	0000b006 	br	80135c68 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
801359a8:	e0bffc17 	ldw	r2,-16(fp)
801359ac:	1000051e 	bne	r2,zero,801359c4 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
801359b0:	e0bfff17 	ldw	r2,-4(fp)
801359b4:	00c01b84 	movi	r3,110
801359b8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
801359bc:	0005883a 	mov	r2,zero
801359c0:	0000a906 	br	80135c68 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
801359c4:	e0bffc17 	ldw	r2,-16(fp)
801359c8:	10800003 	ldbu	r2,0(r2)
801359cc:	10803fcc 	andi	r2,r2,255
801359d0:	10800160 	cmpeqi	r2,r2,5
801359d4:	1000051e 	bne	r2,zero,801359ec <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
801359d8:	e0bfff17 	ldw	r2,-4(fp)
801359dc:	00c00044 	movi	r3,1
801359e0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
801359e4:	0005883a 	mov	r2,zero
801359e8:	00009f06 	br	80135c68 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
801359ec:	e0fffe03 	ldbu	r3,-8(fp)
801359f0:	00bfe004 	movi	r2,-128
801359f4:	1884703a 	and	r2,r3,r2
801359f8:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
801359fc:	e0bff503 	ldbu	r2,-44(fp)
80135a00:	10000626 	beq	r2,zero,80135a1c <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
80135a04:	e0bffe03 	ldbu	r2,-8(fp)
80135a08:	10801fcc 	andi	r2,r2,127
80135a0c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
80135a10:	00800044 	movi	r2,1
80135a14:	e0bff385 	stb	r2,-50(fp)
80135a18:	00000106 	br	80135a20 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
80135a1c:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
80135a20:	e0bfff17 	ldw	r2,-4(fp)
80135a24:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80135a28:	0005303a 	rdctl	r2,status
80135a2c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80135a30:	e0fffb17 	ldw	r3,-20(fp)
80135a34:	00bfff84 	movi	r2,-2
80135a38:	1884703a 	and	r2,r3,r2
80135a3c:	1001703a 	wrctl	status,r2
  
  return context;
80135a40:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
80135a44:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
80135a48:	e0bffe03 	ldbu	r2,-8(fp)
80135a4c:	10c00060 	cmpeqi	r3,r2,1
80135a50:	18005f1e 	bne	r3,zero,80135bd0 <OSFlagAccept+0x268>
80135a54:	10c00088 	cmpgei	r3,r2,2
80135a58:	1800021e 	bne	r3,zero,80135a64 <OSFlagAccept+0xfc>
80135a5c:	10003f26 	beq	r2,zero,80135b5c <OSFlagAccept+0x1f4>
80135a60:	00007706 	br	80135c40 <OSFlagAccept+0x2d8>
80135a64:	10c000a0 	cmpeqi	r3,r2,2
80135a68:	1800031e 	bne	r3,zero,80135a78 <OSFlagAccept+0x110>
80135a6c:	108000e0 	cmpeqi	r2,r2,3
80135a70:	10001e1e 	bne	r2,zero,80135aec <OSFlagAccept+0x184>
80135a74:	00007206 	br	80135c40 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
80135a78:	e0bffc17 	ldw	r2,-16(fp)
80135a7c:	10c0020b 	ldhu	r3,8(r2)
80135a80:	e0bffd0b 	ldhu	r2,-12(fp)
80135a84:	1884703a 	and	r2,r3,r2
80135a88:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
80135a8c:	e0fff30b 	ldhu	r3,-52(fp)
80135a90:	e0bffd0b 	ldhu	r2,-12(fp)
80135a94:	18800d1e 	bne	r3,r2,80135acc <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
80135a98:	e0bff383 	ldbu	r2,-50(fp)
80135a9c:	10800058 	cmpnei	r2,r2,1
80135aa0:	10000d1e 	bne	r2,zero,80135ad8 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
80135aa4:	e0bffc17 	ldw	r2,-16(fp)
80135aa8:	1080020b 	ldhu	r2,8(r2)
80135aac:	1007883a 	mov	r3,r2
80135ab0:	e0bff30b 	ldhu	r2,-52(fp)
80135ab4:	0084303a 	nor	r2,zero,r2
80135ab8:	1884703a 	and	r2,r3,r2
80135abc:	1007883a 	mov	r3,r2
80135ac0:	e0bffc17 	ldw	r2,-16(fp)
80135ac4:	10c0020d 	sth	r3,8(r2)
80135ac8:	00000306 	br	80135ad8 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
80135acc:	e0bfff17 	ldw	r2,-4(fp)
80135ad0:	00c01c04 	movi	r3,112
80135ad4:	10c00005 	stb	r3,0(r2)
80135ad8:	e0bff417 	ldw	r2,-48(fp)
80135adc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80135ae0:	e0bff617 	ldw	r2,-40(fp)
80135ae4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
80135ae8:	00005e06 	br	80135c64 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
80135aec:	e0bffc17 	ldw	r2,-16(fp)
80135af0:	10c0020b 	ldhu	r3,8(r2)
80135af4:	e0bffd0b 	ldhu	r2,-12(fp)
80135af8:	1884703a 	and	r2,r3,r2
80135afc:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
80135b00:	e0bff30b 	ldhu	r2,-52(fp)
80135b04:	10000d26 	beq	r2,zero,80135b3c <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
80135b08:	e0bff383 	ldbu	r2,-50(fp)
80135b0c:	10800058 	cmpnei	r2,r2,1
80135b10:	10000d1e 	bne	r2,zero,80135b48 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
80135b14:	e0bffc17 	ldw	r2,-16(fp)
80135b18:	1080020b 	ldhu	r2,8(r2)
80135b1c:	1007883a 	mov	r3,r2
80135b20:	e0bff30b 	ldhu	r2,-52(fp)
80135b24:	0084303a 	nor	r2,zero,r2
80135b28:	1884703a 	and	r2,r3,r2
80135b2c:	1007883a 	mov	r3,r2
80135b30:	e0bffc17 	ldw	r2,-16(fp)
80135b34:	10c0020d 	sth	r3,8(r2)
80135b38:	00000306 	br	80135b48 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
80135b3c:	e0bfff17 	ldw	r2,-4(fp)
80135b40:	00c01c04 	movi	r3,112
80135b44:	10c00005 	stb	r3,0(r2)
80135b48:	e0bff417 	ldw	r2,-48(fp)
80135b4c:	e0bff715 	stw	r2,-36(fp)
80135b50:	e0bff717 	ldw	r2,-36(fp)
80135b54:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
80135b58:	00004206 	br	80135c64 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
80135b5c:	e0bffc17 	ldw	r2,-16(fp)
80135b60:	1080020b 	ldhu	r2,8(r2)
80135b64:	0084303a 	nor	r2,zero,r2
80135b68:	1007883a 	mov	r3,r2
80135b6c:	e0bffd0b 	ldhu	r2,-12(fp)
80135b70:	1884703a 	and	r2,r3,r2
80135b74:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
80135b78:	e0fff30b 	ldhu	r3,-52(fp)
80135b7c:	e0bffd0b 	ldhu	r2,-12(fp)
80135b80:	18800b1e 	bne	r3,r2,80135bb0 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
80135b84:	e0bff383 	ldbu	r2,-50(fp)
80135b88:	10800058 	cmpnei	r2,r2,1
80135b8c:	10000b1e 	bne	r2,zero,80135bbc <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
80135b90:	e0bffc17 	ldw	r2,-16(fp)
80135b94:	10c0020b 	ldhu	r3,8(r2)
80135b98:	e0bff30b 	ldhu	r2,-52(fp)
80135b9c:	1884b03a 	or	r2,r3,r2
80135ba0:	1007883a 	mov	r3,r2
80135ba4:	e0bffc17 	ldw	r2,-16(fp)
80135ba8:	10c0020d 	sth	r3,8(r2)
80135bac:	00000306 	br	80135bbc <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
80135bb0:	e0bfff17 	ldw	r2,-4(fp)
80135bb4:	00c01c04 	movi	r3,112
80135bb8:	10c00005 	stb	r3,0(r2)
80135bbc:	e0bff417 	ldw	r2,-48(fp)
80135bc0:	e0bff815 	stw	r2,-32(fp)
80135bc4:	e0bff817 	ldw	r2,-32(fp)
80135bc8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
80135bcc:	00002506 	br	80135c64 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
80135bd0:	e0bffc17 	ldw	r2,-16(fp)
80135bd4:	1080020b 	ldhu	r2,8(r2)
80135bd8:	0084303a 	nor	r2,zero,r2
80135bdc:	1007883a 	mov	r3,r2
80135be0:	e0bffd0b 	ldhu	r2,-12(fp)
80135be4:	1884703a 	and	r2,r3,r2
80135be8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
80135bec:	e0bff30b 	ldhu	r2,-52(fp)
80135bf0:	10000b26 	beq	r2,zero,80135c20 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
80135bf4:	e0bff383 	ldbu	r2,-50(fp)
80135bf8:	10800058 	cmpnei	r2,r2,1
80135bfc:	10000b1e 	bne	r2,zero,80135c2c <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
80135c00:	e0bffc17 	ldw	r2,-16(fp)
80135c04:	10c0020b 	ldhu	r3,8(r2)
80135c08:	e0bff30b 	ldhu	r2,-52(fp)
80135c0c:	1884b03a 	or	r2,r3,r2
80135c10:	1007883a 	mov	r3,r2
80135c14:	e0bffc17 	ldw	r2,-16(fp)
80135c18:	10c0020d 	sth	r3,8(r2)
80135c1c:	00000306 	br	80135c2c <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
80135c20:	e0bfff17 	ldw	r2,-4(fp)
80135c24:	00c01c04 	movi	r3,112
80135c28:	10c00005 	stb	r3,0(r2)
80135c2c:	e0bff417 	ldw	r2,-48(fp)
80135c30:	e0bff915 	stw	r2,-28(fp)
80135c34:	e0bff917 	ldw	r2,-28(fp)
80135c38:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
80135c3c:	00000906 	br	80135c64 <OSFlagAccept+0x2fc>
80135c40:	e0bff417 	ldw	r2,-48(fp)
80135c44:	e0bffa15 	stw	r2,-24(fp)
80135c48:	e0bffa17 	ldw	r2,-24(fp)
80135c4c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
80135c50:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
80135c54:	e0bfff17 	ldw	r2,-4(fp)
80135c58:	00c01bc4 	movi	r3,111
80135c5c:	10c00005 	stb	r3,0(r2)
             break;
80135c60:	0001883a 	nop
    }
    return (flags_rdy);
80135c64:	e0bff30b 	ldhu	r2,-52(fp)
}
80135c68:	e037883a 	mov	sp,fp
80135c6c:	df000017 	ldw	fp,0(sp)
80135c70:	dec00104 	addi	sp,sp,4
80135c74:	f800283a 	ret

80135c78 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
80135c78:	defff804 	addi	sp,sp,-32
80135c7c:	de00012e 	bgeu	sp,et,80135c84 <OSFlagCreate+0xc>
80135c80:	003b68fa 	trap	3
80135c84:	df000715 	stw	fp,28(sp)
80135c88:	df000704 	addi	fp,sp,28
80135c8c:	2005883a 	mov	r2,r4
80135c90:	e17fff15 	stw	r5,-4(fp)
80135c94:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
80135c98:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
80135c9c:	e0bfff17 	ldw	r2,-4(fp)
80135ca0:	1000021e 	bne	r2,zero,80135cac <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
80135ca4:	0005883a 	mov	r2,zero
80135ca8:	00003306 	br	80135d78 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
80135cac:	d0a0aa03 	ldbu	r2,-32088(gp)
80135cb0:	10803fcc 	andi	r2,r2,255
80135cb4:	10000526 	beq	r2,zero,80135ccc <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
80135cb8:	e0bfff17 	ldw	r2,-4(fp)
80135cbc:	00c00404 	movi	r3,16
80135cc0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
80135cc4:	0005883a 	mov	r2,zero
80135cc8:	00002b06 	br	80135d78 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80135ccc:	0005303a 	rdctl	r2,status
80135cd0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80135cd4:	e0fffd17 	ldw	r3,-12(fp)
80135cd8:	00bfff84 	movi	r2,-2
80135cdc:	1884703a 	and	r2,r3,r2
80135ce0:	1001703a 	wrctl	status,r2
  
  return context;
80135ce4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
80135ce8:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
80135cec:	d0a0af17 	ldw	r2,-32068(gp)
80135cf0:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
80135cf4:	e0bffb17 	ldw	r2,-20(fp)
80135cf8:	10001726 	beq	r2,zero,80135d58 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
80135cfc:	d0a0af17 	ldw	r2,-32068(gp)
80135d00:	10800117 	ldw	r2,4(r2)
80135d04:	d0a0af15 	stw	r2,-32068(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
80135d08:	e0bffb17 	ldw	r2,-20(fp)
80135d0c:	00c00144 	movi	r3,5
80135d10:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
80135d14:	e0bffb17 	ldw	r2,-20(fp)
80135d18:	e0fffe0b 	ldhu	r3,-8(fp)
80135d1c:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
80135d20:	e0bffb17 	ldw	r2,-20(fp)
80135d24:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
80135d28:	e0bffb17 	ldw	r2,-20(fp)
80135d2c:	00c00fc4 	movi	r3,63
80135d30:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
80135d34:	e0bffb17 	ldw	r2,-20(fp)
80135d38:	100002c5 	stb	zero,11(r2)
80135d3c:	e0bff917 	ldw	r2,-28(fp)
80135d40:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80135d44:	e0bffa17 	ldw	r2,-24(fp)
80135d48:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
80135d4c:	e0bfff17 	ldw	r2,-4(fp)
80135d50:	10000005 	stb	zero,0(r2)
80135d54:	00000706 	br	80135d74 <OSFlagCreate+0xfc>
80135d58:	e0bff917 	ldw	r2,-28(fp)
80135d5c:	e0bffc15 	stw	r2,-16(fp)
80135d60:	e0bffc17 	ldw	r2,-16(fp)
80135d64:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
80135d68:	e0bfff17 	ldw	r2,-4(fp)
80135d6c:	00c01c84 	movi	r3,114
80135d70:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
80135d74:	e0bffb17 	ldw	r2,-20(fp)
}
80135d78:	e037883a 	mov	sp,fp
80135d7c:	df000017 	ldw	fp,0(sp)
80135d80:	dec00104 	addi	sp,sp,4
80135d84:	f800283a 	ret

80135d88 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
80135d88:	defff204 	addi	sp,sp,-56
80135d8c:	de00012e 	bgeu	sp,et,80135d94 <OSFlagDel+0xc>
80135d90:	003b68fa 	trap	3
80135d94:	dfc00d15 	stw	ra,52(sp)
80135d98:	df000c15 	stw	fp,48(sp)
80135d9c:	df000c04 	addi	fp,sp,48
80135da0:	e13ffd15 	stw	r4,-12(fp)
80135da4:	2805883a 	mov	r2,r5
80135da8:	e1bfff15 	stw	r6,-4(fp)
80135dac:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
80135db0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
80135db4:	e0bfff17 	ldw	r2,-4(fp)
80135db8:	1000021e 	bne	r2,zero,80135dc4 <OSFlagDel+0x3c>
        return (pgrp);
80135dbc:	e0bffd17 	ldw	r2,-12(fp)
80135dc0:	00008006 	br	80135fc4 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
80135dc4:	e0bffd17 	ldw	r2,-12(fp)
80135dc8:	1000051e 	bne	r2,zero,80135de0 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
80135dcc:	e0bfff17 	ldw	r2,-4(fp)
80135dd0:	00c01b84 	movi	r3,110
80135dd4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
80135dd8:	e0bffd17 	ldw	r2,-12(fp)
80135ddc:	00007906 	br	80135fc4 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
80135de0:	d0a0aa03 	ldbu	r2,-32088(gp)
80135de4:	10803fcc 	andi	r2,r2,255
80135de8:	10000526 	beq	r2,zero,80135e00 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
80135dec:	e0bfff17 	ldw	r2,-4(fp)
80135df0:	00c003c4 	movi	r3,15
80135df4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
80135df8:	e0bffd17 	ldw	r2,-12(fp)
80135dfc:	00007106 	br	80135fc4 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
80135e00:	e0bffd17 	ldw	r2,-12(fp)
80135e04:	10800003 	ldbu	r2,0(r2)
80135e08:	10803fcc 	andi	r2,r2,255
80135e0c:	10800160 	cmpeqi	r2,r2,5
80135e10:	1000051e 	bne	r2,zero,80135e28 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
80135e14:	e0bfff17 	ldw	r2,-4(fp)
80135e18:	00c00044 	movi	r3,1
80135e1c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
80135e20:	e0bffd17 	ldw	r2,-12(fp)
80135e24:	00006706 	br	80135fc4 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80135e28:	0005303a 	rdctl	r2,status
80135e2c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80135e30:	e0fffc17 	ldw	r3,-16(fp)
80135e34:	00bfff84 	movi	r2,-2
80135e38:	1884703a 	and	r2,r3,r2
80135e3c:	1001703a 	wrctl	status,r2
  
  return context;
80135e40:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80135e44:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
80135e48:	e0bffd17 	ldw	r2,-12(fp)
80135e4c:	10800117 	ldw	r2,4(r2)
80135e50:	10000326 	beq	r2,zero,80135e60 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
80135e54:	00800044 	movi	r2,1
80135e58:	e0bff405 	stb	r2,-48(fp)
80135e5c:	00000106 	br	80135e64 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
80135e60:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
80135e64:	e0bffe03 	ldbu	r2,-8(fp)
80135e68:	10000326 	beq	r2,zero,80135e78 <OSFlagDel+0xf0>
80135e6c:	10800060 	cmpeqi	r2,r2,1
80135e70:	1000231e 	bne	r2,zero,80135f00 <OSFlagDel+0x178>
80135e74:	00004806 	br	80135f98 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
80135e78:	e0bff403 	ldbu	r2,-48(fp)
80135e7c:	1000161e 	bne	r2,zero,80135ed8 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
80135e80:	e0bffd17 	ldw	r2,-12(fp)
80135e84:	00c00fc4 	movi	r3,63
80135e88:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
80135e8c:	e0bffd17 	ldw	r2,-12(fp)
80135e90:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
80135e94:	e0bffd17 	ldw	r2,-12(fp)
80135e98:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
80135e9c:	d0e0af17 	ldw	r3,-32068(gp)
80135ea0:	e0bffd17 	ldw	r2,-12(fp)
80135ea4:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
80135ea8:	e0bffd17 	ldw	r2,-12(fp)
80135eac:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
80135eb0:	e0bffd17 	ldw	r2,-12(fp)
80135eb4:	d0a0af15 	stw	r2,-32068(gp)
80135eb8:	e0bff717 	ldw	r2,-36(fp)
80135ebc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80135ec0:	e0bff817 	ldw	r2,-32(fp)
80135ec4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
80135ec8:	e0bfff17 	ldw	r2,-4(fp)
80135ecc:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
80135ed0:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
80135ed4:	00003a06 	br	80135fc0 <OSFlagDel+0x238>
80135ed8:	e0bff717 	ldw	r2,-36(fp)
80135edc:	e0bff915 	stw	r2,-28(fp)
80135ee0:	e0bff917 	ldw	r2,-28(fp)
80135ee4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
80135ee8:	e0bfff17 	ldw	r2,-4(fp)
80135eec:	00c01244 	movi	r3,73
80135ef0:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
80135ef4:	e0bffd17 	ldw	r2,-12(fp)
80135ef8:	e0bff615 	stw	r2,-40(fp)
             }
             break;
80135efc:	00003006 	br	80135fc0 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
80135f00:	e0bffd17 	ldw	r2,-12(fp)
80135f04:	10800117 	ldw	r2,4(r2)
80135f08:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
80135f0c:	00000606 	br	80135f28 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
80135f10:	000b883a 	mov	r5,zero
80135f14:	e13ff517 	ldw	r4,-44(fp)
80135f18:	0136f3c0 	call	80136f3c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
80135f1c:	e0bff517 	ldw	r2,-44(fp)
80135f20:	10800017 	ldw	r2,0(r2)
80135f24:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
80135f28:	e0bff517 	ldw	r2,-44(fp)
80135f2c:	103ff81e 	bne	r2,zero,80135f10 <__reset+0xfa115f10>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
80135f30:	e0bffd17 	ldw	r2,-12(fp)
80135f34:	00c00fc4 	movi	r3,63
80135f38:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
80135f3c:	e0bffd17 	ldw	r2,-12(fp)
80135f40:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
80135f44:	e0bffd17 	ldw	r2,-12(fp)
80135f48:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
80135f4c:	d0e0af17 	ldw	r3,-32068(gp)
80135f50:	e0bffd17 	ldw	r2,-12(fp)
80135f54:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
80135f58:	e0bffd17 	ldw	r2,-12(fp)
80135f5c:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
80135f60:	e0bffd17 	ldw	r2,-12(fp)
80135f64:	d0a0af15 	stw	r2,-32068(gp)
80135f68:	e0bff717 	ldw	r2,-36(fp)
80135f6c:	e0bffa15 	stw	r2,-24(fp)
80135f70:	e0bffa17 	ldw	r2,-24(fp)
80135f74:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
80135f78:	e0bff403 	ldbu	r2,-48(fp)
80135f7c:	10800058 	cmpnei	r2,r2,1
80135f80:	1000011e 	bne	r2,zero,80135f88 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
80135f84:	013504c0 	call	8013504c <OS_Sched>
             }
             *perr = OS_ERR_NONE;
80135f88:	e0bfff17 	ldw	r2,-4(fp)
80135f8c:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
80135f90:	e03ff615 	stw	zero,-40(fp)
             break;
80135f94:	00000a06 	br	80135fc0 <OSFlagDel+0x238>
80135f98:	e0bff717 	ldw	r2,-36(fp)
80135f9c:	e0bffb15 	stw	r2,-20(fp)
80135fa0:	e0bffb17 	ldw	r2,-20(fp)
80135fa4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
80135fa8:	e0bfff17 	ldw	r2,-4(fp)
80135fac:	00c001c4 	movi	r3,7
80135fb0:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
80135fb4:	e0bffd17 	ldw	r2,-12(fp)
80135fb8:	e0bff615 	stw	r2,-40(fp)
             break;
80135fbc:	0001883a 	nop
    }
    return (pgrp_return);
80135fc0:	e0bff617 	ldw	r2,-40(fp)
}
80135fc4:	e037883a 	mov	sp,fp
80135fc8:	dfc00117 	ldw	ra,4(sp)
80135fcc:	df000017 	ldw	fp,0(sp)
80135fd0:	dec00204 	addi	sp,sp,8
80135fd4:	f800283a 	ret

80135fd8 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
80135fd8:	defff604 	addi	sp,sp,-40
80135fdc:	de00012e 	bgeu	sp,et,80135fe4 <OSFlagNameGet+0xc>
80135fe0:	003b68fa 	trap	3
80135fe4:	dfc00915 	stw	ra,36(sp)
80135fe8:	df000815 	stw	fp,32(sp)
80135fec:	df000804 	addi	fp,sp,32
80135ff0:	e13ffd15 	stw	r4,-12(fp)
80135ff4:	e17ffe15 	stw	r5,-8(fp)
80135ff8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
80135ffc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
80136000:	e0bfff17 	ldw	r2,-4(fp)
80136004:	1000021e 	bne	r2,zero,80136010 <OSFlagNameGet+0x38>
        return (0);
80136008:	0005883a 	mov	r2,zero
8013600c:	00003906 	br	801360f4 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
80136010:	e0bffd17 	ldw	r2,-12(fp)
80136014:	1000051e 	bne	r2,zero,8013602c <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
80136018:	e0bfff17 	ldw	r2,-4(fp)
8013601c:	00c01b84 	movi	r3,110
80136020:	10c00005 	stb	r3,0(r2)
        return (0);
80136024:	0005883a 	mov	r2,zero
80136028:	00003206 	br	801360f4 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8013602c:	e0bffe17 	ldw	r2,-8(fp)
80136030:	1000051e 	bne	r2,zero,80136048 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
80136034:	e0bfff17 	ldw	r2,-4(fp)
80136038:	00c00304 	movi	r3,12
8013603c:	10c00005 	stb	r3,0(r2)
        return (0);
80136040:	0005883a 	mov	r2,zero
80136044:	00002b06 	br	801360f4 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
80136048:	d0a0aa03 	ldbu	r2,-32088(gp)
8013604c:	10803fcc 	andi	r2,r2,255
80136050:	10000526 	beq	r2,zero,80136068 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
80136054:	e0bfff17 	ldw	r2,-4(fp)
80136058:	00c00444 	movi	r3,17
8013605c:	10c00005 	stb	r3,0(r2)
        return (0);
80136060:	0005883a 	mov	r2,zero
80136064:	00002306 	br	801360f4 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80136068:	0005303a 	rdctl	r2,status
8013606c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80136070:	e0fffc17 	ldw	r3,-16(fp)
80136074:	00bfff84 	movi	r2,-2
80136078:	1884703a 	and	r2,r3,r2
8013607c:	1001703a 	wrctl	status,r2
  
  return context;
80136080:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80136084:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
80136088:	e0bffd17 	ldw	r2,-12(fp)
8013608c:	10800003 	ldbu	r2,0(r2)
80136090:	10803fcc 	andi	r2,r2,255
80136094:	10800160 	cmpeqi	r2,r2,5
80136098:	1000091e 	bne	r2,zero,801360c0 <OSFlagNameGet+0xe8>
8013609c:	e0bff817 	ldw	r2,-32(fp)
801360a0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801360a4:	e0bff917 	ldw	r2,-28(fp)
801360a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
801360ac:	e0bfff17 	ldw	r2,-4(fp)
801360b0:	00c00044 	movi	r3,1
801360b4:	10c00005 	stb	r3,0(r2)
        return (0);
801360b8:	0005883a 	mov	r2,zero
801360bc:	00000d06 	br	801360f4 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
801360c0:	e0bffd17 	ldw	r2,-12(fp)
801360c4:	10800284 	addi	r2,r2,10
801360c8:	100b883a 	mov	r5,r2
801360cc:	e13ffe17 	ldw	r4,-8(fp)
801360d0:	01351a00 	call	801351a0 <OS_StrCopy>
801360d4:	e0bffb05 	stb	r2,-20(fp)
801360d8:	e0bff817 	ldw	r2,-32(fp)
801360dc:	e0bffa15 	stw	r2,-24(fp)
801360e0:	e0bffa17 	ldw	r2,-24(fp)
801360e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
801360e8:	e0bfff17 	ldw	r2,-4(fp)
801360ec:	10000005 	stb	zero,0(r2)
    return (len);
801360f0:	e0bffb03 	ldbu	r2,-20(fp)
}
801360f4:	e037883a 	mov	sp,fp
801360f8:	dfc00117 	ldw	ra,4(sp)
801360fc:	df000017 	ldw	fp,0(sp)
80136100:	dec00204 	addi	sp,sp,8
80136104:	f800283a 	ret

80136108 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
80136108:	defff504 	addi	sp,sp,-44
8013610c:	de00012e 	bgeu	sp,et,80136114 <OSFlagNameSet+0xc>
80136110:	003b68fa 	trap	3
80136114:	dfc00a15 	stw	ra,40(sp)
80136118:	df000915 	stw	fp,36(sp)
8013611c:	df000904 	addi	fp,sp,36
80136120:	e13ffd15 	stw	r4,-12(fp)
80136124:	e17ffe15 	stw	r5,-8(fp)
80136128:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8013612c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
80136130:	e0bfff17 	ldw	r2,-4(fp)
80136134:	10004326 	beq	r2,zero,80136244 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
80136138:	e0bffd17 	ldw	r2,-12(fp)
8013613c:	1000041e 	bne	r2,zero,80136150 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
80136140:	e0bfff17 	ldw	r2,-4(fp)
80136144:	00c01b84 	movi	r3,110
80136148:	10c00005 	stb	r3,0(r2)
        return;
8013614c:	00003e06 	br	80136248 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
80136150:	e0bffe17 	ldw	r2,-8(fp)
80136154:	1000041e 	bne	r2,zero,80136168 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
80136158:	e0bfff17 	ldw	r2,-4(fp)
8013615c:	00c00304 	movi	r3,12
80136160:	10c00005 	stb	r3,0(r2)
        return;
80136164:	00003806 	br	80136248 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
80136168:	d0a0aa03 	ldbu	r2,-32088(gp)
8013616c:	10803fcc 	andi	r2,r2,255
80136170:	10000426 	beq	r2,zero,80136184 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
80136174:	e0bfff17 	ldw	r2,-4(fp)
80136178:	00c00484 	movi	r3,18
8013617c:	10c00005 	stb	r3,0(r2)
        return;
80136180:	00003106 	br	80136248 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80136184:	0005303a 	rdctl	r2,status
80136188:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013618c:	e0fffc17 	ldw	r3,-16(fp)
80136190:	00bfff84 	movi	r2,-2
80136194:	1884703a 	and	r2,r3,r2
80136198:	1001703a 	wrctl	status,r2
  
  return context;
8013619c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
801361a0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
801361a4:	e0bffd17 	ldw	r2,-12(fp)
801361a8:	10800003 	ldbu	r2,0(r2)
801361ac:	10803fcc 	andi	r2,r2,255
801361b0:	10800160 	cmpeqi	r2,r2,5
801361b4:	1000081e 	bne	r2,zero,801361d8 <OSFlagNameSet+0xd0>
801361b8:	e0bff717 	ldw	r2,-36(fp)
801361bc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801361c0:	e0bff817 	ldw	r2,-32(fp)
801361c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
801361c8:	e0bfff17 	ldw	r2,-4(fp)
801361cc:	00c00044 	movi	r3,1
801361d0:	10c00005 	stb	r3,0(r2)
        return;
801361d4:	00001c06 	br	80136248 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
801361d8:	e13ffe17 	ldw	r4,-8(fp)
801361dc:	013521c0 	call	8013521c <OS_StrLen>
801361e0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
801361e4:	e0bffa03 	ldbu	r2,-24(fp)
801361e8:	10800830 	cmpltui	r2,r2,32
801361ec:	1000081e 	bne	r2,zero,80136210 <OSFlagNameSet+0x108>
801361f0:	e0bff717 	ldw	r2,-36(fp)
801361f4:	e0bff915 	stw	r2,-28(fp)
801361f8:	e0bff917 	ldw	r2,-28(fp)
801361fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
80136200:	e0bfff17 	ldw	r2,-4(fp)
80136204:	00c01cc4 	movi	r3,115
80136208:	10c00005 	stb	r3,0(r2)
        return;
8013620c:	00000e06 	br	80136248 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
80136210:	e0bffd17 	ldw	r2,-12(fp)
80136214:	10800284 	addi	r2,r2,10
80136218:	e17ffe17 	ldw	r5,-8(fp)
8013621c:	1009883a 	mov	r4,r2
80136220:	01351a00 	call	801351a0 <OS_StrCopy>
80136224:	e0bff717 	ldw	r2,-36(fp)
80136228:	e0bffb15 	stw	r2,-20(fp)
8013622c:	e0bffb17 	ldw	r2,-20(fp)
80136230:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
80136234:	e0bfff17 	ldw	r2,-4(fp)
80136238:	10000005 	stb	zero,0(r2)
    return;
8013623c:	0001883a 	nop
80136240:	00000106 	br	80136248 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
80136244:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
80136248:	e037883a 	mov	sp,fp
8013624c:	dfc00117 	ldw	ra,4(sp)
80136250:	df000017 	ldw	fp,0(sp)
80136254:	dec00204 	addi	sp,sp,8
80136258:	f800283a 	ret

8013625c <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8013625c:	deffe104 	addi	sp,sp,-124
80136260:	de00012e 	bgeu	sp,et,80136268 <OSFlagPend+0xc>
80136264:	003b68fa 	trap	3
80136268:	dfc01e15 	stw	ra,120(sp)
8013626c:	df001d15 	stw	fp,116(sp)
80136270:	df001d04 	addi	fp,sp,116
80136274:	e13ffc15 	stw	r4,-16(fp)
80136278:	2809883a 	mov	r4,r5
8013627c:	3007883a 	mov	r3,r6
80136280:	3805883a 	mov	r2,r7
80136284:	e13ffd0d 	sth	r4,-12(fp)
80136288:	e0fffe05 	stb	r3,-8(fp)
8013628c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
80136290:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
80136294:	e0800217 	ldw	r2,8(fp)
80136298:	1000021e 	bne	r2,zero,801362a4 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8013629c:	0005883a 	mov	r2,zero
801362a0:	00015906 	br	80136808 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
801362a4:	e0bffc17 	ldw	r2,-16(fp)
801362a8:	1000051e 	bne	r2,zero,801362c0 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
801362ac:	e0800217 	ldw	r2,8(fp)
801362b0:	00c01b84 	movi	r3,110
801362b4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
801362b8:	0005883a 	mov	r2,zero
801362bc:	00015206 	br	80136808 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
801362c0:	d0a0aa03 	ldbu	r2,-32088(gp)
801362c4:	10803fcc 	andi	r2,r2,255
801362c8:	10000526 	beq	r2,zero,801362e0 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
801362cc:	e0800217 	ldw	r2,8(fp)
801362d0:	00c00084 	movi	r3,2
801362d4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
801362d8:	0005883a 	mov	r2,zero
801362dc:	00014a06 	br	80136808 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
801362e0:	d0a09803 	ldbu	r2,-32160(gp)
801362e4:	10803fcc 	andi	r2,r2,255
801362e8:	10000526 	beq	r2,zero,80136300 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
801362ec:	e0800217 	ldw	r2,8(fp)
801362f0:	00c00344 	movi	r3,13
801362f4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
801362f8:	0005883a 	mov	r2,zero
801362fc:	00014206 	br	80136808 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
80136300:	e0bffc17 	ldw	r2,-16(fp)
80136304:	10800003 	ldbu	r2,0(r2)
80136308:	10803fcc 	andi	r2,r2,255
8013630c:	10800160 	cmpeqi	r2,r2,5
80136310:	1000051e 	bne	r2,zero,80136328 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
80136314:	e0800217 	ldw	r2,8(fp)
80136318:	00c00044 	movi	r3,1
8013631c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
80136320:	0005883a 	mov	r2,zero
80136324:	00013806 	br	80136808 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
80136328:	e0fffe03 	ldbu	r3,-8(fp)
8013632c:	00bfe004 	movi	r2,-128
80136330:	1884703a 	and	r2,r3,r2
80136334:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
80136338:	e0bfe603 	ldbu	r2,-104(fp)
8013633c:	10000626 	beq	r2,zero,80136358 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
80136340:	e0bffe03 	ldbu	r2,-8(fp)
80136344:	10801fcc 	andi	r2,r2,127
80136348:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8013634c:	00800044 	movi	r2,1
80136350:	e0bfe405 	stb	r2,-112(fp)
80136354:	00000106 	br	8013635c <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
80136358:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013635c:	0005303a 	rdctl	r2,status
80136360:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80136364:	e0fff617 	ldw	r3,-40(fp)
80136368:	00bfff84 	movi	r2,-2
8013636c:	1884703a 	and	r2,r3,r2
80136370:	1001703a 	wrctl	status,r2
  
  return context;
80136374:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
80136378:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8013637c:	e0bffe03 	ldbu	r2,-8(fp)
80136380:	10c00060 	cmpeqi	r3,r2,1
80136384:	1800921e 	bne	r3,zero,801365d0 <OSFlagPend+0x374>
80136388:	10c00088 	cmpgei	r3,r2,2
8013638c:	1800021e 	bne	r3,zero,80136398 <OSFlagPend+0x13c>
80136390:	10006126 	beq	r2,zero,80136518 <OSFlagPend+0x2bc>
80136394:	0000bb06 	br	80136684 <OSFlagPend+0x428>
80136398:	10c000a0 	cmpeqi	r3,r2,2
8013639c:	1800031e 	bne	r3,zero,801363ac <OSFlagPend+0x150>
801363a0:	108000e0 	cmpeqi	r2,r2,3
801363a4:	10002f1e 	bne	r2,zero,80136464 <OSFlagPend+0x208>
801363a8:	0000b606 	br	80136684 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
801363ac:	e0bffc17 	ldw	r2,-16(fp)
801363b0:	10c0020b 	ldhu	r3,8(r2)
801363b4:	e0bffd0b 	ldhu	r2,-12(fp)
801363b8:	1884703a 	and	r2,r3,r2
801363bc:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
801363c0:	e0ffe80b 	ldhu	r3,-96(fp)
801363c4:	e0bffd0b 	ldhu	r2,-12(fp)
801363c8:	1880171e 	bne	r3,r2,80136428 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
801363cc:	e0bfe403 	ldbu	r2,-112(fp)
801363d0:	10800058 	cmpnei	r2,r2,1
801363d4:	1000091e 	bne	r2,zero,801363fc <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
801363d8:	e0bffc17 	ldw	r2,-16(fp)
801363dc:	1080020b 	ldhu	r2,8(r2)
801363e0:	1007883a 	mov	r3,r2
801363e4:	e0bfe80b 	ldhu	r2,-96(fp)
801363e8:	0084303a 	nor	r2,zero,r2
801363ec:	1884703a 	and	r2,r3,r2
801363f0:	1007883a 	mov	r3,r2
801363f4:	e0bffc17 	ldw	r2,-16(fp)
801363f8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
801363fc:	d0a0ab17 	ldw	r2,-32084(gp)
80136400:	e0ffe80b 	ldhu	r3,-96(fp)
80136404:	10c00b0d 	sth	r3,44(r2)
80136408:	e0bfe517 	ldw	r2,-108(fp)
8013640c:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80136410:	e0bfe717 	ldw	r2,-100(fp)
80136414:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
80136418:	e0800217 	ldw	r2,8(fp)
8013641c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
80136420:	e0bfe80b 	ldhu	r2,-96(fp)
80136424:	0000f806 	br	80136808 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
80136428:	e13ffd0b 	ldhu	r4,-12(fp)
8013642c:	e17ffe03 	ldbu	r5,-8(fp)
80136430:	e0bfff0b 	ldhu	r2,-4(fp)
80136434:	e0fff704 	addi	r3,fp,-36
80136438:	d8800015 	stw	r2,0(sp)
8013643c:	280f883a 	mov	r7,r5
80136440:	200d883a 	mov	r6,r4
80136444:	180b883a 	mov	r5,r3
80136448:	e13ffc17 	ldw	r4,-16(fp)
8013644c:	0136cec0 	call	80136cec <OS_FlagBlock>
80136450:	e0bfe517 	ldw	r2,-108(fp)
80136454:	e0bfe915 	stw	r2,-92(fp)
80136458:	e0bfe917 	ldw	r2,-92(fp)
8013645c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
80136460:	00009206 	br	801366ac <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
80136464:	e0bffc17 	ldw	r2,-16(fp)
80136468:	10c0020b 	ldhu	r3,8(r2)
8013646c:	e0bffd0b 	ldhu	r2,-12(fp)
80136470:	1884703a 	and	r2,r3,r2
80136474:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
80136478:	e0bfe80b 	ldhu	r2,-96(fp)
8013647c:	10001726 	beq	r2,zero,801364dc <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
80136480:	e0bfe403 	ldbu	r2,-112(fp)
80136484:	10800058 	cmpnei	r2,r2,1
80136488:	1000091e 	bne	r2,zero,801364b0 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8013648c:	e0bffc17 	ldw	r2,-16(fp)
80136490:	1080020b 	ldhu	r2,8(r2)
80136494:	1007883a 	mov	r3,r2
80136498:	e0bfe80b 	ldhu	r2,-96(fp)
8013649c:	0084303a 	nor	r2,zero,r2
801364a0:	1884703a 	and	r2,r3,r2
801364a4:	1007883a 	mov	r3,r2
801364a8:	e0bffc17 	ldw	r2,-16(fp)
801364ac:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
801364b0:	d0a0ab17 	ldw	r2,-32084(gp)
801364b4:	e0ffe80b 	ldhu	r3,-96(fp)
801364b8:	10c00b0d 	sth	r3,44(r2)
801364bc:	e0bfe517 	ldw	r2,-108(fp)
801364c0:	e0bfea15 	stw	r2,-88(fp)
801364c4:	e0bfea17 	ldw	r2,-88(fp)
801364c8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
801364cc:	e0800217 	ldw	r2,8(fp)
801364d0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
801364d4:	e0bfe80b 	ldhu	r2,-96(fp)
801364d8:	0000cb06 	br	80136808 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
801364dc:	e13ffd0b 	ldhu	r4,-12(fp)
801364e0:	e17ffe03 	ldbu	r5,-8(fp)
801364e4:	e0bfff0b 	ldhu	r2,-4(fp)
801364e8:	e0fff704 	addi	r3,fp,-36
801364ec:	d8800015 	stw	r2,0(sp)
801364f0:	280f883a 	mov	r7,r5
801364f4:	200d883a 	mov	r6,r4
801364f8:	180b883a 	mov	r5,r3
801364fc:	e13ffc17 	ldw	r4,-16(fp)
80136500:	0136cec0 	call	80136cec <OS_FlagBlock>
80136504:	e0bfe517 	ldw	r2,-108(fp)
80136508:	e0bfeb15 	stw	r2,-84(fp)
8013650c:	e0bfeb17 	ldw	r2,-84(fp)
80136510:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
80136514:	00006506 	br	801366ac <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
80136518:	e0bffc17 	ldw	r2,-16(fp)
8013651c:	1080020b 	ldhu	r2,8(r2)
80136520:	0084303a 	nor	r2,zero,r2
80136524:	1007883a 	mov	r3,r2
80136528:	e0bffd0b 	ldhu	r2,-12(fp)
8013652c:	1884703a 	and	r2,r3,r2
80136530:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
80136534:	e0ffe80b 	ldhu	r3,-96(fp)
80136538:	e0bffd0b 	ldhu	r2,-12(fp)
8013653c:	1880151e 	bne	r3,r2,80136594 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
80136540:	e0bfe403 	ldbu	r2,-112(fp)
80136544:	10800058 	cmpnei	r2,r2,1
80136548:	1000071e 	bne	r2,zero,80136568 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8013654c:	e0bffc17 	ldw	r2,-16(fp)
80136550:	10c0020b 	ldhu	r3,8(r2)
80136554:	e0bfe80b 	ldhu	r2,-96(fp)
80136558:	1884b03a 	or	r2,r3,r2
8013655c:	1007883a 	mov	r3,r2
80136560:	e0bffc17 	ldw	r2,-16(fp)
80136564:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
80136568:	d0a0ab17 	ldw	r2,-32084(gp)
8013656c:	e0ffe80b 	ldhu	r3,-96(fp)
80136570:	10c00b0d 	sth	r3,44(r2)
80136574:	e0bfe517 	ldw	r2,-108(fp)
80136578:	e0bfec15 	stw	r2,-80(fp)
8013657c:	e0bfec17 	ldw	r2,-80(fp)
80136580:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
80136584:	e0800217 	ldw	r2,8(fp)
80136588:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8013658c:	e0bfe80b 	ldhu	r2,-96(fp)
80136590:	00009d06 	br	80136808 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
80136594:	e13ffd0b 	ldhu	r4,-12(fp)
80136598:	e17ffe03 	ldbu	r5,-8(fp)
8013659c:	e0bfff0b 	ldhu	r2,-4(fp)
801365a0:	e0fff704 	addi	r3,fp,-36
801365a4:	d8800015 	stw	r2,0(sp)
801365a8:	280f883a 	mov	r7,r5
801365ac:	200d883a 	mov	r6,r4
801365b0:	180b883a 	mov	r5,r3
801365b4:	e13ffc17 	ldw	r4,-16(fp)
801365b8:	0136cec0 	call	80136cec <OS_FlagBlock>
801365bc:	e0bfe517 	ldw	r2,-108(fp)
801365c0:	e0bfed15 	stw	r2,-76(fp)
801365c4:	e0bfed17 	ldw	r2,-76(fp)
801365c8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
801365cc:	00003706 	br	801366ac <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
801365d0:	e0bffc17 	ldw	r2,-16(fp)
801365d4:	1080020b 	ldhu	r2,8(r2)
801365d8:	0084303a 	nor	r2,zero,r2
801365dc:	1007883a 	mov	r3,r2
801365e0:	e0bffd0b 	ldhu	r2,-12(fp)
801365e4:	1884703a 	and	r2,r3,r2
801365e8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
801365ec:	e0bfe80b 	ldhu	r2,-96(fp)
801365f0:	10001526 	beq	r2,zero,80136648 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
801365f4:	e0bfe403 	ldbu	r2,-112(fp)
801365f8:	10800058 	cmpnei	r2,r2,1
801365fc:	1000071e 	bne	r2,zero,8013661c <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
80136600:	e0bffc17 	ldw	r2,-16(fp)
80136604:	10c0020b 	ldhu	r3,8(r2)
80136608:	e0bfe80b 	ldhu	r2,-96(fp)
8013660c:	1884b03a 	or	r2,r3,r2
80136610:	1007883a 	mov	r3,r2
80136614:	e0bffc17 	ldw	r2,-16(fp)
80136618:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8013661c:	d0a0ab17 	ldw	r2,-32084(gp)
80136620:	e0ffe80b 	ldhu	r3,-96(fp)
80136624:	10c00b0d 	sth	r3,44(r2)
80136628:	e0bfe517 	ldw	r2,-108(fp)
8013662c:	e0bfee15 	stw	r2,-72(fp)
80136630:	e0bfee17 	ldw	r2,-72(fp)
80136634:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
80136638:	e0800217 	ldw	r2,8(fp)
8013663c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
80136640:	e0bfe80b 	ldhu	r2,-96(fp)
80136644:	00007006 	br	80136808 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
80136648:	e13ffd0b 	ldhu	r4,-12(fp)
8013664c:	e17ffe03 	ldbu	r5,-8(fp)
80136650:	e0bfff0b 	ldhu	r2,-4(fp)
80136654:	e0fff704 	addi	r3,fp,-36
80136658:	d8800015 	stw	r2,0(sp)
8013665c:	280f883a 	mov	r7,r5
80136660:	200d883a 	mov	r6,r4
80136664:	180b883a 	mov	r5,r3
80136668:	e13ffc17 	ldw	r4,-16(fp)
8013666c:	0136cec0 	call	80136cec <OS_FlagBlock>
80136670:	e0bfe517 	ldw	r2,-108(fp)
80136674:	e0bfef15 	stw	r2,-68(fp)
80136678:	e0bfef17 	ldw	r2,-68(fp)
8013667c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
80136680:	00000a06 	br	801366ac <OSFlagPend+0x450>
80136684:	e0bfe517 	ldw	r2,-108(fp)
80136688:	e0bff015 	stw	r2,-64(fp)
8013668c:	e0bff017 	ldw	r2,-64(fp)
80136690:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
80136694:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
80136698:	e0800217 	ldw	r2,8(fp)
8013669c:	00c01bc4 	movi	r3,111
801366a0:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
801366a4:	e0bfe80b 	ldhu	r2,-96(fp)
801366a8:	00005706 	br	80136808 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
801366ac:	013504c0 	call	8013504c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801366b0:	0005303a 	rdctl	r2,status
801366b4:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801366b8:	e0fff117 	ldw	r3,-60(fp)
801366bc:	00bfff84 	movi	r2,-2
801366c0:	1884703a 	and	r2,r3,r2
801366c4:	1001703a 	wrctl	status,r2
  
  return context;
801366c8:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
801366cc:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
801366d0:	d0a0ab17 	ldw	r2,-32084(gp)
801366d4:	10800c43 	ldbu	r2,49(r2)
801366d8:	10803fcc 	andi	r2,r2,255
801366dc:	10001c26 	beq	r2,zero,80136750 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
801366e0:	d0a0ab17 	ldw	r2,-32084(gp)
801366e4:	10800c43 	ldbu	r2,49(r2)
801366e8:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
801366ec:	d0a0ab17 	ldw	r2,-32084(gp)
801366f0:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
801366f4:	e0bff704 	addi	r2,fp,-36
801366f8:	1009883a 	mov	r4,r2
801366fc:	01370380 	call	80137038 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
80136700:	d0a0ab17 	ldw	r2,-32084(gp)
80136704:	10000c05 	stb	zero,48(r2)
80136708:	e0bfe517 	ldw	r2,-108(fp)
8013670c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80136710:	e0bff217 	ldw	r2,-56(fp)
80136714:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
80136718:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8013671c:	e0bff303 	ldbu	r2,-52(fp)
80136720:	108000a0 	cmpeqi	r2,r2,2
80136724:	10000426 	beq	r2,zero,80136738 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
80136728:	e0800217 	ldw	r2,8(fp)
8013672c:	00c00384 	movi	r3,14
80136730:	10c00005 	stb	r3,0(r2)
                 break;
80136734:	00000406 	br	80136748 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
80136738:	e0800217 	ldw	r2,8(fp)
8013673c:	00c00284 	movi	r3,10
80136740:	10c00005 	stb	r3,0(r2)
                 break;
80136744:	0001883a 	nop
        }
        return (flags_rdy);
80136748:	e0bfe80b 	ldhu	r2,-96(fp)
8013674c:	00002e06 	br	80136808 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
80136750:	d0a0ab17 	ldw	r2,-32084(gp)
80136754:	10800b0b 	ldhu	r2,44(r2)
80136758:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8013675c:	e0bfe403 	ldbu	r2,-112(fp)
80136760:	10800058 	cmpnei	r2,r2,1
80136764:	1000211e 	bne	r2,zero,801367ec <OSFlagPend+0x590>
        switch (wait_type) {
80136768:	e0bffe03 	ldbu	r2,-8(fp)
8013676c:	10001616 	blt	r2,zero,801367c8 <OSFlagPend+0x56c>
80136770:	10c00090 	cmplti	r3,r2,2
80136774:	18000c1e 	bne	r3,zero,801367a8 <OSFlagPend+0x54c>
80136778:	10800108 	cmpgei	r2,r2,4
8013677c:	1000121e 	bne	r2,zero,801367c8 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
80136780:	e0bffc17 	ldw	r2,-16(fp)
80136784:	1080020b 	ldhu	r2,8(r2)
80136788:	1007883a 	mov	r3,r2
8013678c:	e0bfe80b 	ldhu	r2,-96(fp)
80136790:	0084303a 	nor	r2,zero,r2
80136794:	1884703a 	and	r2,r3,r2
80136798:	1007883a 	mov	r3,r2
8013679c:	e0bffc17 	ldw	r2,-16(fp)
801367a0:	10c0020d 	sth	r3,8(r2)
                 break;
801367a4:	00001106 	br	801367ec <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
801367a8:	e0bffc17 	ldw	r2,-16(fp)
801367ac:	10c0020b 	ldhu	r3,8(r2)
801367b0:	e0bfe80b 	ldhu	r2,-96(fp)
801367b4:	1884b03a 	or	r2,r3,r2
801367b8:	1007883a 	mov	r3,r2
801367bc:	e0bffc17 	ldw	r2,-16(fp)
801367c0:	10c0020d 	sth	r3,8(r2)
                 break;
801367c4:	00000906 	br	801367ec <OSFlagPend+0x590>
801367c8:	e0bfe517 	ldw	r2,-108(fp)
801367cc:	e0bff415 	stw	r2,-48(fp)
801367d0:	e0bff417 	ldw	r2,-48(fp)
801367d4:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
801367d8:	e0800217 	ldw	r2,8(fp)
801367dc:	00c01bc4 	movi	r3,111
801367e0:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
801367e4:	0005883a 	mov	r2,zero
801367e8:	00000706 	br	80136808 <OSFlagPend+0x5ac>
801367ec:	e0bfe517 	ldw	r2,-108(fp)
801367f0:	e0bff515 	stw	r2,-44(fp)
801367f4:	e0bff517 	ldw	r2,-44(fp)
801367f8:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
801367fc:	e0800217 	ldw	r2,8(fp)
80136800:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
80136804:	e0bfe80b 	ldhu	r2,-96(fp)
}
80136808:	e037883a 	mov	sp,fp
8013680c:	dfc00117 	ldw	ra,4(sp)
80136810:	df000017 	ldw	fp,0(sp)
80136814:	dec00204 	addi	sp,sp,8
80136818:	f800283a 	ret

8013681c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8013681c:	defffb04 	addi	sp,sp,-20
80136820:	de00012e 	bgeu	sp,et,80136828 <OSFlagPendGetFlagsRdy+0xc>
80136824:	003b68fa 	trap	3
80136828:	df000415 	stw	fp,16(sp)
8013682c:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
80136830:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80136834:	0005303a 	rdctl	r2,status
80136838:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013683c:	e0fffe17 	ldw	r3,-8(fp)
80136840:	00bfff84 	movi	r2,-2
80136844:	1884703a 	and	r2,r3,r2
80136848:	1001703a 	wrctl	status,r2
  
  return context;
8013684c:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
80136850:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
80136854:	d0a0ab17 	ldw	r2,-32084(gp)
80136858:	10800b0b 	ldhu	r2,44(r2)
8013685c:	e0bffd0d 	sth	r2,-12(fp)
80136860:	e0bffc17 	ldw	r2,-16(fp)
80136864:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80136868:	e0bfff17 	ldw	r2,-4(fp)
8013686c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
80136870:	e0bffd0b 	ldhu	r2,-12(fp)
}
80136874:	e037883a 	mov	sp,fp
80136878:	df000017 	ldw	fp,0(sp)
8013687c:	dec00104 	addi	sp,sp,4
80136880:	f800283a 	ret

80136884 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
80136884:	deffef04 	addi	sp,sp,-68
80136888:	de00012e 	bgeu	sp,et,80136890 <OSFlagPost+0xc>
8013688c:	003b68fa 	trap	3
80136890:	dfc01015 	stw	ra,64(sp)
80136894:	df000f15 	stw	fp,60(sp)
80136898:	df000f04 	addi	fp,sp,60
8013689c:	e13ffc15 	stw	r4,-16(fp)
801368a0:	2807883a 	mov	r3,r5
801368a4:	3005883a 	mov	r2,r6
801368a8:	e1ffff15 	stw	r7,-4(fp)
801368ac:	e0fffd0d 	sth	r3,-12(fp)
801368b0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
801368b4:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
801368b8:	e0bfff17 	ldw	r2,-4(fp)
801368bc:	1000021e 	bne	r2,zero,801368c8 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
801368c0:	0005883a 	mov	r2,zero
801368c4:	0000d106 	br	80136c0c <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
801368c8:	e0bffc17 	ldw	r2,-16(fp)
801368cc:	1000051e 	bne	r2,zero,801368e4 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
801368d0:	e0bfff17 	ldw	r2,-4(fp)
801368d4:	00c01b84 	movi	r3,110
801368d8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
801368dc:	0005883a 	mov	r2,zero
801368e0:	0000ca06 	br	80136c0c <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
801368e4:	e0bffc17 	ldw	r2,-16(fp)
801368e8:	10800003 	ldbu	r2,0(r2)
801368ec:	10803fcc 	andi	r2,r2,255
801368f0:	10800160 	cmpeqi	r2,r2,5
801368f4:	1000051e 	bne	r2,zero,8013690c <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
801368f8:	e0bfff17 	ldw	r2,-4(fp)
801368fc:	00c00044 	movi	r3,1
80136900:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
80136904:	0005883a 	mov	r2,zero
80136908:	0000c006 	br	80136c0c <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013690c:	0005303a 	rdctl	r2,status
80136910:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80136914:	e0fffb17 	ldw	r3,-20(fp)
80136918:	00bfff84 	movi	r2,-2
8013691c:	1884703a 	and	r2,r3,r2
80136920:	1001703a 	wrctl	status,r2
  
  return context;
80136924:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
80136928:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8013692c:	e0bffe03 	ldbu	r2,-8(fp)
80136930:	10000326 	beq	r2,zero,80136940 <OSFlagPost+0xbc>
80136934:	10800060 	cmpeqi	r2,r2,1
80136938:	10000b1e 	bne	r2,zero,80136968 <OSFlagPost+0xe4>
8013693c:	00001206 	br	80136988 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
80136940:	e0bffc17 	ldw	r2,-16(fp)
80136944:	1080020b 	ldhu	r2,8(r2)
80136948:	1007883a 	mov	r3,r2
8013694c:	e0bffd0b 	ldhu	r2,-12(fp)
80136950:	0084303a 	nor	r2,zero,r2
80136954:	1884703a 	and	r2,r3,r2
80136958:	1007883a 	mov	r3,r2
8013695c:	e0bffc17 	ldw	r2,-16(fp)
80136960:	10c0020d 	sth	r3,8(r2)
             break;
80136964:	00001106 	br	801369ac <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
80136968:	e0bffc17 	ldw	r2,-16(fp)
8013696c:	10c0020b 	ldhu	r3,8(r2)
80136970:	e0bffd0b 	ldhu	r2,-12(fp)
80136974:	1884b03a 	or	r2,r3,r2
80136978:	1007883a 	mov	r3,r2
8013697c:	e0bffc17 	ldw	r2,-16(fp)
80136980:	10c0020d 	sth	r3,8(r2)
             break;
80136984:	00000906 	br	801369ac <OSFlagPost+0x128>
80136988:	e0bff317 	ldw	r2,-52(fp)
8013698c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80136990:	e0bff417 	ldw	r2,-48(fp)
80136994:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
80136998:	e0bfff17 	ldw	r2,-4(fp)
8013699c:	00c01c44 	movi	r3,113
801369a0:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
801369a4:	0005883a 	mov	r2,zero
801369a8:	00009806 	br	80136c0c <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
801369ac:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
801369b0:	e0bffc17 	ldw	r2,-16(fp)
801369b4:	10800117 	ldw	r2,4(r2)
801369b8:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
801369bc:	00007706 	br	80136b9c <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
801369c0:	e0bff117 	ldw	r2,-60(fp)
801369c4:	10800483 	ldbu	r2,18(r2)
801369c8:	10803fcc 	andi	r2,r2,255
801369cc:	10c00060 	cmpeqi	r3,r2,1
801369d0:	18004a1e 	bne	r3,zero,80136afc <OSFlagPost+0x278>
801369d4:	10c00088 	cmpgei	r3,r2,2
801369d8:	1800021e 	bne	r3,zero,801369e4 <OSFlagPost+0x160>
801369dc:	10002f26 	beq	r2,zero,80136a9c <OSFlagPost+0x218>
801369e0:	00005b06 	br	80136b50 <OSFlagPost+0x2cc>
801369e4:	10c000a0 	cmpeqi	r3,r2,2
801369e8:	1800031e 	bne	r3,zero,801369f8 <OSFlagPost+0x174>
801369ec:	108000e0 	cmpeqi	r2,r2,3
801369f0:	1000171e 	bne	r2,zero,80136a50 <OSFlagPost+0x1cc>
801369f4:	00005606 	br	80136b50 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
801369f8:	e0bffc17 	ldw	r2,-16(fp)
801369fc:	10c0020b 	ldhu	r3,8(r2)
80136a00:	e0bff117 	ldw	r2,-60(fp)
80136a04:	1080040b 	ldhu	r2,16(r2)
80136a08:	1884703a 	and	r2,r3,r2
80136a0c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
80136a10:	e0bff117 	ldw	r2,-60(fp)
80136a14:	1080040b 	ldhu	r2,16(r2)
80136a18:	10ffffcc 	andi	r3,r2,65535
80136a1c:	e0bff60b 	ldhu	r2,-40(fp)
80136a20:	1880541e 	bne	r3,r2,80136b74 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
80136a24:	e0bff60b 	ldhu	r2,-40(fp)
80136a28:	100b883a 	mov	r5,r2
80136a2c:	e13ff117 	ldw	r4,-60(fp)
80136a30:	0136f3c0 	call	80136f3c <OS_FlagTaskRdy>
80136a34:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
80136a38:	e0bff683 	ldbu	r2,-38(fp)
80136a3c:	10800058 	cmpnei	r2,r2,1
80136a40:	10004c1e 	bne	r2,zero,80136b74 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
80136a44:	00800044 	movi	r2,1
80136a48:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
80136a4c:	00004906 	br	80136b74 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
80136a50:	e0bffc17 	ldw	r2,-16(fp)
80136a54:	10c0020b 	ldhu	r3,8(r2)
80136a58:	e0bff117 	ldw	r2,-60(fp)
80136a5c:	1080040b 	ldhu	r2,16(r2)
80136a60:	1884703a 	and	r2,r3,r2
80136a64:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
80136a68:	e0bff60b 	ldhu	r2,-40(fp)
80136a6c:	10004326 	beq	r2,zero,80136b7c <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
80136a70:	e0bff60b 	ldhu	r2,-40(fp)
80136a74:	100b883a 	mov	r5,r2
80136a78:	e13ff117 	ldw	r4,-60(fp)
80136a7c:	0136f3c0 	call	80136f3c <OS_FlagTaskRdy>
80136a80:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
80136a84:	e0bff683 	ldbu	r2,-38(fp)
80136a88:	10800058 	cmpnei	r2,r2,1
80136a8c:	10003b1e 	bne	r2,zero,80136b7c <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
80136a90:	00800044 	movi	r2,1
80136a94:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
80136a98:	00003806 	br	80136b7c <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
80136a9c:	e0bffc17 	ldw	r2,-16(fp)
80136aa0:	1080020b 	ldhu	r2,8(r2)
80136aa4:	0084303a 	nor	r2,zero,r2
80136aa8:	1007883a 	mov	r3,r2
80136aac:	e0bff117 	ldw	r2,-60(fp)
80136ab0:	1080040b 	ldhu	r2,16(r2)
80136ab4:	1884703a 	and	r2,r3,r2
80136ab8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
80136abc:	e0bff117 	ldw	r2,-60(fp)
80136ac0:	1080040b 	ldhu	r2,16(r2)
80136ac4:	10ffffcc 	andi	r3,r2,65535
80136ac8:	e0bff60b 	ldhu	r2,-40(fp)
80136acc:	18802d1e 	bne	r3,r2,80136b84 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
80136ad0:	e0bff60b 	ldhu	r2,-40(fp)
80136ad4:	100b883a 	mov	r5,r2
80136ad8:	e13ff117 	ldw	r4,-60(fp)
80136adc:	0136f3c0 	call	80136f3c <OS_FlagTaskRdy>
80136ae0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
80136ae4:	e0bff683 	ldbu	r2,-38(fp)
80136ae8:	10800058 	cmpnei	r2,r2,1
80136aec:	1000251e 	bne	r2,zero,80136b84 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
80136af0:	00800044 	movi	r2,1
80136af4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
80136af8:	00002206 	br	80136b84 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
80136afc:	e0bffc17 	ldw	r2,-16(fp)
80136b00:	1080020b 	ldhu	r2,8(r2)
80136b04:	0084303a 	nor	r2,zero,r2
80136b08:	1007883a 	mov	r3,r2
80136b0c:	e0bff117 	ldw	r2,-60(fp)
80136b10:	1080040b 	ldhu	r2,16(r2)
80136b14:	1884703a 	and	r2,r3,r2
80136b18:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
80136b1c:	e0bff60b 	ldhu	r2,-40(fp)
80136b20:	10001a26 	beq	r2,zero,80136b8c <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
80136b24:	e0bff60b 	ldhu	r2,-40(fp)
80136b28:	100b883a 	mov	r5,r2
80136b2c:	e13ff117 	ldw	r4,-60(fp)
80136b30:	0136f3c0 	call	80136f3c <OS_FlagTaskRdy>
80136b34:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
80136b38:	e0bff683 	ldbu	r2,-38(fp)
80136b3c:	10800058 	cmpnei	r2,r2,1
80136b40:	1000121e 	bne	r2,zero,80136b8c <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
80136b44:	00800044 	movi	r2,1
80136b48:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
80136b4c:	00000f06 	br	80136b8c <OSFlagPost+0x308>
80136b50:	e0bff317 	ldw	r2,-52(fp)
80136b54:	e0bff515 	stw	r2,-44(fp)
80136b58:	e0bff517 	ldw	r2,-44(fp)
80136b5c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
80136b60:	e0bfff17 	ldw	r2,-4(fp)
80136b64:	00c01bc4 	movi	r3,111
80136b68:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
80136b6c:	0005883a 	mov	r2,zero
80136b70:	00002606 	br	80136c0c <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
80136b74:	0001883a 	nop
80136b78:	00000506 	br	80136b90 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
80136b7c:	0001883a 	nop
80136b80:	00000306 	br	80136b90 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
80136b84:	0001883a 	nop
80136b88:	00000106 	br	80136b90 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
80136b8c:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
80136b90:	e0bff117 	ldw	r2,-60(fp)
80136b94:	10800017 	ldw	r2,0(r2)
80136b98:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
80136b9c:	e0bff117 	ldw	r2,-60(fp)
80136ba0:	103f871e 	bne	r2,zero,801369c0 <__reset+0xfa1169c0>
80136ba4:	e0bff317 	ldw	r2,-52(fp)
80136ba8:	e0bff715 	stw	r2,-36(fp)
80136bac:	e0bff717 	ldw	r2,-36(fp)
80136bb0:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
80136bb4:	e0bff203 	ldbu	r2,-56(fp)
80136bb8:	10800058 	cmpnei	r2,r2,1
80136bbc:	1000011e 	bne	r2,zero,80136bc4 <OSFlagPost+0x340>
        OS_Sched();
80136bc0:	013504c0 	call	8013504c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80136bc4:	0005303a 	rdctl	r2,status
80136bc8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80136bcc:	e0fffa17 	ldw	r3,-24(fp)
80136bd0:	00bfff84 	movi	r2,-2
80136bd4:	1884703a 	and	r2,r3,r2
80136bd8:	1001703a 	wrctl	status,r2
  
  return context;
80136bdc:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
80136be0:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
80136be4:	e0bffc17 	ldw	r2,-16(fp)
80136be8:	1080020b 	ldhu	r2,8(r2)
80136bec:	e0bff90d 	sth	r2,-28(fp)
80136bf0:	e0bff317 	ldw	r2,-52(fp)
80136bf4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80136bf8:	e0bff817 	ldw	r2,-32(fp)
80136bfc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
80136c00:	e0bfff17 	ldw	r2,-4(fp)
80136c04:	10000005 	stb	zero,0(r2)
    return (flags_cur);
80136c08:	e0bff90b 	ldhu	r2,-28(fp)
}
80136c0c:	e037883a 	mov	sp,fp
80136c10:	dfc00117 	ldw	ra,4(sp)
80136c14:	df000017 	ldw	fp,0(sp)
80136c18:	dec00204 	addi	sp,sp,8
80136c1c:	f800283a 	ret

80136c20 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
80136c20:	defff904 	addi	sp,sp,-28
80136c24:	de00012e 	bgeu	sp,et,80136c2c <OSFlagQuery+0xc>
80136c28:	003b68fa 	trap	3
80136c2c:	df000615 	stw	fp,24(sp)
80136c30:	df000604 	addi	fp,sp,24
80136c34:	e13ffe15 	stw	r4,-8(fp)
80136c38:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
80136c3c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
80136c40:	e0bfff17 	ldw	r2,-4(fp)
80136c44:	1000021e 	bne	r2,zero,80136c50 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
80136c48:	0005883a 	mov	r2,zero
80136c4c:	00002306 	br	80136cdc <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
80136c50:	e0bffe17 	ldw	r2,-8(fp)
80136c54:	1000051e 	bne	r2,zero,80136c6c <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
80136c58:	e0bfff17 	ldw	r2,-4(fp)
80136c5c:	00c01b84 	movi	r3,110
80136c60:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
80136c64:	0005883a 	mov	r2,zero
80136c68:	00001c06 	br	80136cdc <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
80136c6c:	e0bffe17 	ldw	r2,-8(fp)
80136c70:	10800003 	ldbu	r2,0(r2)
80136c74:	10803fcc 	andi	r2,r2,255
80136c78:	10800160 	cmpeqi	r2,r2,5
80136c7c:	1000051e 	bne	r2,zero,80136c94 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
80136c80:	e0bfff17 	ldw	r2,-4(fp)
80136c84:	00c00044 	movi	r3,1
80136c88:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
80136c8c:	0005883a 	mov	r2,zero
80136c90:	00001206 	br	80136cdc <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80136c94:	0005303a 	rdctl	r2,status
80136c98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80136c9c:	e0fffc17 	ldw	r3,-16(fp)
80136ca0:	00bfff84 	movi	r2,-2
80136ca4:	1884703a 	and	r2,r3,r2
80136ca8:	1001703a 	wrctl	status,r2
  
  return context;
80136cac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80136cb0:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
80136cb4:	e0bffe17 	ldw	r2,-8(fp)
80136cb8:	1080020b 	ldhu	r2,8(r2)
80136cbc:	e0bffb0d 	sth	r2,-20(fp)
80136cc0:	e0bffa17 	ldw	r2,-24(fp)
80136cc4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80136cc8:	e0bffd17 	ldw	r2,-12(fp)
80136ccc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
80136cd0:	e0bfff17 	ldw	r2,-4(fp)
80136cd4:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
80136cd8:	e0bffb0b 	ldhu	r2,-20(fp)
}
80136cdc:	e037883a 	mov	sp,fp
80136ce0:	df000017 	ldw	fp,0(sp)
80136ce4:	dec00104 	addi	sp,sp,4
80136ce8:	f800283a 	ret

80136cec <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
80136cec:	defff804 	addi	sp,sp,-32
80136cf0:	de00012e 	bgeu	sp,et,80136cf8 <OS_FlagBlock+0xc>
80136cf4:	003b68fa 	trap	3
80136cf8:	df000715 	stw	fp,28(sp)
80136cfc:	df000704 	addi	fp,sp,28
80136d00:	e13ffb15 	stw	r4,-20(fp)
80136d04:	e17ffc15 	stw	r5,-16(fp)
80136d08:	3009883a 	mov	r4,r6
80136d0c:	3807883a 	mov	r3,r7
80136d10:	e0800117 	ldw	r2,4(fp)
80136d14:	e13ffd0d 	sth	r4,-12(fp)
80136d18:	e0fffe05 	stb	r3,-8(fp)
80136d1c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
80136d20:	d0a0ab17 	ldw	r2,-32084(gp)
80136d24:	d0e0ab17 	ldw	r3,-32084(gp)
80136d28:	18c00c03 	ldbu	r3,48(r3)
80136d2c:	18c00814 	ori	r3,r3,32
80136d30:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
80136d34:	d0a0ab17 	ldw	r2,-32084(gp)
80136d38:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
80136d3c:	d0a0ab17 	ldw	r2,-32084(gp)
80136d40:	e0ffff0b 	ldhu	r3,-4(fp)
80136d44:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
80136d48:	d0a0ab17 	ldw	r2,-32084(gp)
80136d4c:	e0fffc17 	ldw	r3,-16(fp)
80136d50:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
80136d54:	e0bffc17 	ldw	r2,-16(fp)
80136d58:	e0fffd0b 	ldhu	r3,-12(fp)
80136d5c:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
80136d60:	e0bffc17 	ldw	r2,-16(fp)
80136d64:	e0fffe03 	ldbu	r3,-8(fp)
80136d68:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
80136d6c:	d0e0ab17 	ldw	r3,-32084(gp)
80136d70:	e0bffc17 	ldw	r2,-16(fp)
80136d74:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
80136d78:	e0bffb17 	ldw	r2,-20(fp)
80136d7c:	10c00117 	ldw	r3,4(r2)
80136d80:	e0bffc17 	ldw	r2,-16(fp)
80136d84:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
80136d88:	e0bffc17 	ldw	r2,-16(fp)
80136d8c:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
80136d90:	e0bffc17 	ldw	r2,-16(fp)
80136d94:	e0fffb17 	ldw	r3,-20(fp)
80136d98:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
80136d9c:	e0bffb17 	ldw	r2,-20(fp)
80136da0:	10800117 	ldw	r2,4(r2)
80136da4:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
80136da8:	e0bff917 	ldw	r2,-28(fp)
80136dac:	10000326 	beq	r2,zero,80136dbc <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
80136db0:	e0bff917 	ldw	r2,-28(fp)
80136db4:	e0fffc17 	ldw	r3,-16(fp)
80136db8:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
80136dbc:	e0bffb17 	ldw	r2,-20(fp)
80136dc0:	e0fffc17 	ldw	r3,-16(fp)
80136dc4:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
80136dc8:	d0a0ab17 	ldw	r2,-32084(gp)
80136dcc:	10800d03 	ldbu	r2,52(r2)
80136dd0:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
80136dd4:	e0fffa03 	ldbu	r3,-24(fp)
80136dd8:	e13ffa03 	ldbu	r4,-24(fp)
80136ddc:	d0a0a744 	addi	r2,gp,-32099
80136de0:	2085883a 	add	r2,r4,r2
80136de4:	10800003 	ldbu	r2,0(r2)
80136de8:	1009883a 	mov	r4,r2
80136dec:	d0a0ab17 	ldw	r2,-32084(gp)
80136df0:	10800d43 	ldbu	r2,53(r2)
80136df4:	0084303a 	nor	r2,zero,r2
80136df8:	2084703a 	and	r2,r4,r2
80136dfc:	1009883a 	mov	r4,r2
80136e00:	d0a0a744 	addi	r2,gp,-32099
80136e04:	1885883a 	add	r2,r3,r2
80136e08:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
80136e0c:	e0fffa03 	ldbu	r3,-24(fp)
80136e10:	d0a0a744 	addi	r2,gp,-32099
80136e14:	1885883a 	add	r2,r3,r2
80136e18:	10800003 	ldbu	r2,0(r2)
80136e1c:	10803fcc 	andi	r2,r2,255
80136e20:	1000071e 	bne	r2,zero,80136e40 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
80136e24:	d0a0ab17 	ldw	r2,-32084(gp)
80136e28:	10800d83 	ldbu	r2,54(r2)
80136e2c:	0084303a 	nor	r2,zero,r2
80136e30:	1007883a 	mov	r3,r2
80136e34:	d0a0a703 	ldbu	r2,-32100(gp)
80136e38:	1884703a 	and	r2,r3,r2
80136e3c:	d0a0a705 	stb	r2,-32100(gp)
    }
}
80136e40:	0001883a 	nop
80136e44:	e037883a 	mov	sp,fp
80136e48:	df000017 	ldw	fp,0(sp)
80136e4c:	dec00104 	addi	sp,sp,4
80136e50:	f800283a 	ret

80136e54 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
80136e54:	defffb04 	addi	sp,sp,-20
80136e58:	de00012e 	bgeu	sp,et,80136e60 <OS_FlagInit+0xc>
80136e5c:	003b68fa 	trap	3
80136e60:	dfc00415 	stw	ra,16(sp)
80136e64:	df000315 	stw	fp,12(sp)
80136e68:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
80136e6c:	01421004 	movi	r5,2112
80136e70:	012005b4 	movhi	r4,32790
80136e74:	213a5904 	addi	r4,r4,-5788
80136e78:	0134f800 	call	80134f80 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
80136e7c:	00a005b4 	movhi	r2,32790
80136e80:	10ba5904 	addi	r2,r2,-5788
80136e84:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
80136e88:	00a005b4 	movhi	r2,32790
80136e8c:	10ba6404 	addi	r2,r2,-5744
80136e90:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
80136e94:	e03ffd0d 	sth	zero,-12(fp)
80136e98:	00001306 	br	80136ee8 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
80136e9c:	e0bffe17 	ldw	r2,-8(fp)
80136ea0:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
80136ea4:	e0bffe17 	ldw	r2,-8(fp)
80136ea8:	e0ffff17 	ldw	r3,-4(fp)
80136eac:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
80136eb0:	e0bffe17 	ldw	r2,-8(fp)
80136eb4:	00c00fc4 	movi	r3,63
80136eb8:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
80136ebc:	e0bffe17 	ldw	r2,-8(fp)
80136ec0:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
80136ec4:	e0bffe17 	ldw	r2,-8(fp)
80136ec8:	10800b04 	addi	r2,r2,44
80136ecc:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
80136ed0:	e0bfff17 	ldw	r2,-4(fp)
80136ed4:	10800b04 	addi	r2,r2,44
80136ed8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
80136edc:	e0bffd0b 	ldhu	r2,-12(fp)
80136ee0:	10800044 	addi	r2,r2,1
80136ee4:	e0bffd0d 	sth	r2,-12(fp)
80136ee8:	e0bffd0b 	ldhu	r2,-12(fp)
80136eec:	10800bf0 	cmpltui	r2,r2,47
80136ef0:	103fea1e 	bne	r2,zero,80136e9c <__reset+0xfa116e9c>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
80136ef4:	e0bffe17 	ldw	r2,-8(fp)
80136ef8:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
80136efc:	e0bffe17 	ldw	r2,-8(fp)
80136f00:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
80136f04:	e0bffe17 	ldw	r2,-8(fp)
80136f08:	00c00fc4 	movi	r3,63
80136f0c:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
80136f10:	e0bffe17 	ldw	r2,-8(fp)
80136f14:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
80136f18:	00a005b4 	movhi	r2,32790
80136f1c:	10ba5904 	addi	r2,r2,-5788
80136f20:	d0a0af15 	stw	r2,-32068(gp)
#endif
}
80136f24:	0001883a 	nop
80136f28:	e037883a 	mov	sp,fp
80136f2c:	dfc00117 	ldw	ra,4(sp)
80136f30:	df000017 	ldw	fp,0(sp)
80136f34:	dec00204 	addi	sp,sp,8
80136f38:	f800283a 	ret

80136f3c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
80136f3c:	defffa04 	addi	sp,sp,-24
80136f40:	de00012e 	bgeu	sp,et,80136f48 <OS_FlagTaskRdy+0xc>
80136f44:	003b68fa 	trap	3
80136f48:	dfc00515 	stw	ra,20(sp)
80136f4c:	df000415 	stw	fp,16(sp)
80136f50:	df000404 	addi	fp,sp,16
80136f54:	e13ffe15 	stw	r4,-8(fp)
80136f58:	2805883a 	mov	r2,r5
80136f5c:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
80136f60:	e0bffe17 	ldw	r2,-8(fp)
80136f64:	10800217 	ldw	r2,8(r2)
80136f68:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
80136f6c:	e0bffd17 	ldw	r2,-12(fp)
80136f70:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
80136f74:	e0bffd17 	ldw	r2,-12(fp)
80136f78:	e0ffff0b 	ldhu	r3,-4(fp)
80136f7c:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
80136f80:	e0bffd17 	ldw	r2,-12(fp)
80136f84:	10c00c03 	ldbu	r3,48(r2)
80136f88:	00bff7c4 	movi	r2,-33
80136f8c:	1884703a 	and	r2,r3,r2
80136f90:	1007883a 	mov	r3,r2
80136f94:	e0bffd17 	ldw	r2,-12(fp)
80136f98:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
80136f9c:	e0bffd17 	ldw	r2,-12(fp)
80136fa0:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
80136fa4:	e0bffd17 	ldw	r2,-12(fp)
80136fa8:	10800c03 	ldbu	r2,48(r2)
80136fac:	10803fcc 	andi	r2,r2,255
80136fb0:	1000181e 	bne	r2,zero,80137014 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
80136fb4:	e0bffd17 	ldw	r2,-12(fp)
80136fb8:	10c00d83 	ldbu	r3,54(r2)
80136fbc:	d0a0a703 	ldbu	r2,-32100(gp)
80136fc0:	1884b03a 	or	r2,r3,r2
80136fc4:	d0a0a705 	stb	r2,-32100(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
80136fc8:	e0bffd17 	ldw	r2,-12(fp)
80136fcc:	10800d03 	ldbu	r2,52(r2)
80136fd0:	10c03fcc 	andi	r3,r2,255
80136fd4:	e0bffd17 	ldw	r2,-12(fp)
80136fd8:	10800d03 	ldbu	r2,52(r2)
80136fdc:	11003fcc 	andi	r4,r2,255
80136fe0:	d0a0a744 	addi	r2,gp,-32099
80136fe4:	2085883a 	add	r2,r4,r2
80136fe8:	11000003 	ldbu	r4,0(r2)
80136fec:	e0bffd17 	ldw	r2,-12(fp)
80136ff0:	10800d43 	ldbu	r2,53(r2)
80136ff4:	2084b03a 	or	r2,r4,r2
80136ff8:	1009883a 	mov	r4,r2
80136ffc:	d0a0a744 	addi	r2,gp,-32099
80137000:	1885883a 	add	r2,r3,r2
80137004:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
80137008:	00800044 	movi	r2,1
8013700c:	e0bffc05 	stb	r2,-16(fp)
80137010:	00000106 	br	80137018 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
80137014:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
80137018:	e13ffe17 	ldw	r4,-8(fp)
8013701c:	01370380 	call	80137038 <OS_FlagUnlink>
    return (sched);
80137020:	e0bffc03 	ldbu	r2,-16(fp)
}
80137024:	e037883a 	mov	sp,fp
80137028:	dfc00117 	ldw	ra,4(sp)
8013702c:	df000017 	ldw	fp,0(sp)
80137030:	dec00204 	addi	sp,sp,8
80137034:	f800283a 	ret

80137038 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
80137038:	defffa04 	addi	sp,sp,-24
8013703c:	de00012e 	bgeu	sp,et,80137044 <OS_FlagUnlink+0xc>
80137040:	003b68fa 	trap	3
80137044:	df000515 	stw	fp,20(sp)
80137048:	df000504 	addi	fp,sp,20
8013704c:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
80137050:	e0bfff17 	ldw	r2,-4(fp)
80137054:	10800117 	ldw	r2,4(r2)
80137058:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8013705c:	e0bfff17 	ldw	r2,-4(fp)
80137060:	10800017 	ldw	r2,0(r2)
80137064:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
80137068:	e0bffb17 	ldw	r2,-20(fp)
8013706c:	10000b1e 	bne	r2,zero,8013709c <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
80137070:	e0bfff17 	ldw	r2,-4(fp)
80137074:	10800317 	ldw	r2,12(r2)
80137078:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8013707c:	e0bffd17 	ldw	r2,-12(fp)
80137080:	e0fffc17 	ldw	r3,-16(fp)
80137084:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
80137088:	e0bffc17 	ldw	r2,-16(fp)
8013708c:	10000b26 	beq	r2,zero,801370bc <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
80137090:	e0bffc17 	ldw	r2,-16(fp)
80137094:	10000115 	stw	zero,4(r2)
80137098:	00000806 	br	801370bc <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8013709c:	e0bffb17 	ldw	r2,-20(fp)
801370a0:	e0fffc17 	ldw	r3,-16(fp)
801370a4:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
801370a8:	e0bffc17 	ldw	r2,-16(fp)
801370ac:	10000326 	beq	r2,zero,801370bc <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
801370b0:	e0bffc17 	ldw	r2,-16(fp)
801370b4:	e0fffb17 	ldw	r3,-20(fp)
801370b8:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
801370bc:	e0bfff17 	ldw	r2,-4(fp)
801370c0:	10800217 	ldw	r2,8(r2)
801370c4:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
801370c8:	e0bffe17 	ldw	r2,-8(fp)
801370cc:	10000a15 	stw	zero,40(r2)
#endif
}
801370d0:	0001883a 	nop
801370d4:	e037883a 	mov	sp,fp
801370d8:	df000017 	ldw	fp,0(sp)
801370dc:	dec00104 	addi	sp,sp,4
801370e0:	f800283a 	ret

801370e4 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
801370e4:	defff404 	addi	sp,sp,-48
801370e8:	de00012e 	bgeu	sp,et,801370f0 <OSMemCreate+0xc>
801370ec:	003b68fa 	trap	3
801370f0:	df000b15 	stw	fp,44(sp)
801370f4:	df000b04 	addi	fp,sp,44
801370f8:	e13ffc15 	stw	r4,-16(fp)
801370fc:	e17ffd15 	stw	r5,-12(fp)
80137100:	e1bffe15 	stw	r6,-8(fp)
80137104:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
80137108:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8013710c:	e0bfff17 	ldw	r2,-4(fp)
80137110:	1000021e 	bne	r2,zero,8013711c <OSMemCreate+0x38>
        return ((OS_MEM *)0);
80137114:	0005883a 	mov	r2,zero
80137118:	00006506 	br	801372b0 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8013711c:	e0bffc17 	ldw	r2,-16(fp)
80137120:	1000051e 	bne	r2,zero,80137138 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
80137124:	e0bfff17 	ldw	r2,-4(fp)
80137128:	00c01884 	movi	r3,98
8013712c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
80137130:	0005883a 	mov	r2,zero
80137134:	00005e06 	br	801372b0 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
80137138:	e0bffc17 	ldw	r2,-16(fp)
8013713c:	108000cc 	andi	r2,r2,3
80137140:	10000526 	beq	r2,zero,80137158 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
80137144:	e0bfff17 	ldw	r2,-4(fp)
80137148:	00c01884 	movi	r3,98
8013714c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
80137150:	0005883a 	mov	r2,zero
80137154:	00005606 	br	801372b0 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
80137158:	e0bffd17 	ldw	r2,-12(fp)
8013715c:	108000a8 	cmpgeui	r2,r2,2
80137160:	1000051e 	bne	r2,zero,80137178 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
80137164:	e0bfff17 	ldw	r2,-4(fp)
80137168:	00c016c4 	movi	r3,91
8013716c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
80137170:	0005883a 	mov	r2,zero
80137174:	00004e06 	br	801372b0 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
80137178:	e0bffe17 	ldw	r2,-8(fp)
8013717c:	10800128 	cmpgeui	r2,r2,4
80137180:	1000051e 	bne	r2,zero,80137198 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
80137184:	e0bfff17 	ldw	r2,-4(fp)
80137188:	00c01704 	movi	r3,92
8013718c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
80137190:	0005883a 	mov	r2,zero
80137194:	00004606 	br	801372b0 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80137198:	0005303a 	rdctl	r2,status
8013719c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801371a0:	e0fffb17 	ldw	r3,-20(fp)
801371a4:	00bfff84 	movi	r2,-2
801371a8:	1884703a 	and	r2,r3,r2
801371ac:	1001703a 	wrctl	status,r2
  
  return context;
801371b0:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
801371b4:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
801371b8:	d0a0a417 	ldw	r2,-32112(gp)
801371bc:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
801371c0:	d0a0a417 	ldw	r2,-32112(gp)
801371c4:	10000326 	beq	r2,zero,801371d4 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
801371c8:	d0a0a417 	ldw	r2,-32112(gp)
801371cc:	10800117 	ldw	r2,4(r2)
801371d0:	d0a0a415 	stw	r2,-32112(gp)
801371d4:	e0bff817 	ldw	r2,-32(fp)
801371d8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801371dc:	e0bff917 	ldw	r2,-28(fp)
801371e0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
801371e4:	e0bffa17 	ldw	r2,-24(fp)
801371e8:	1000051e 	bne	r2,zero,80137200 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
801371ec:	e0bfff17 	ldw	r2,-4(fp)
801371f0:	00c01684 	movi	r3,90
801371f4:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
801371f8:	0005883a 	mov	r2,zero
801371fc:	00002c06 	br	801372b0 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
80137200:	e0bffc17 	ldw	r2,-16(fp)
80137204:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
80137208:	e0fffc17 	ldw	r3,-16(fp)
8013720c:	e0bffe17 	ldw	r2,-8(fp)
80137210:	1885883a 	add	r2,r3,r2
80137214:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
80137218:	e03ff715 	stw	zero,-36(fp)
8013721c:	00000c06 	br	80137250 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
80137220:	e0bff617 	ldw	r2,-40(fp)
80137224:	e0fff517 	ldw	r3,-44(fp)
80137228:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8013722c:	e0bff517 	ldw	r2,-44(fp)
80137230:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
80137234:	e0fff517 	ldw	r3,-44(fp)
80137238:	e0bffe17 	ldw	r2,-8(fp)
8013723c:	1885883a 	add	r2,r3,r2
80137240:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
80137244:	e0bff717 	ldw	r2,-36(fp)
80137248:	10800044 	addi	r2,r2,1
8013724c:	e0bff715 	stw	r2,-36(fp)
80137250:	e0bffd17 	ldw	r2,-12(fp)
80137254:	10bfffc4 	addi	r2,r2,-1
80137258:	e0fff717 	ldw	r3,-36(fp)
8013725c:	18bff036 	bltu	r3,r2,80137220 <__reset+0xfa117220>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
80137260:	e0bff617 	ldw	r2,-40(fp)
80137264:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
80137268:	e0bffa17 	ldw	r2,-24(fp)
8013726c:	e0fffc17 	ldw	r3,-16(fp)
80137270:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
80137274:	e0bffa17 	ldw	r2,-24(fp)
80137278:	e0fffc17 	ldw	r3,-16(fp)
8013727c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
80137280:	e0bffa17 	ldw	r2,-24(fp)
80137284:	e0fffd17 	ldw	r3,-12(fp)
80137288:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8013728c:	e0bffa17 	ldw	r2,-24(fp)
80137290:	e0fffd17 	ldw	r3,-12(fp)
80137294:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
80137298:	e0bffa17 	ldw	r2,-24(fp)
8013729c:	e0fffe17 	ldw	r3,-8(fp)
801372a0:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
801372a4:	e0bfff17 	ldw	r2,-4(fp)
801372a8:	10000005 	stb	zero,0(r2)
    return (pmem);
801372ac:	e0bffa17 	ldw	r2,-24(fp)
}
801372b0:	e037883a 	mov	sp,fp
801372b4:	df000017 	ldw	fp,0(sp)
801372b8:	dec00104 	addi	sp,sp,4
801372bc:	f800283a 	ret

801372c0 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
801372c0:	defff804 	addi	sp,sp,-32
801372c4:	de00012e 	bgeu	sp,et,801372cc <OSMemGet+0xc>
801372c8:	003b68fa 	trap	3
801372cc:	df000715 	stw	fp,28(sp)
801372d0:	df000704 	addi	fp,sp,28
801372d4:	e13ffe15 	stw	r4,-8(fp)
801372d8:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
801372dc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
801372e0:	e0bfff17 	ldw	r2,-4(fp)
801372e4:	1000021e 	bne	r2,zero,801372f0 <OSMemGet+0x30>
        return ((void *)0);
801372e8:	0005883a 	mov	r2,zero
801372ec:	00002e06 	br	801373a8 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
801372f0:	e0bffe17 	ldw	r2,-8(fp)
801372f4:	1000051e 	bne	r2,zero,8013730c <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
801372f8:	e0bfff17 	ldw	r2,-4(fp)
801372fc:	00c01804 	movi	r3,96
80137300:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
80137304:	0005883a 	mov	r2,zero
80137308:	00002706 	br	801373a8 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013730c:	0005303a 	rdctl	r2,status
80137310:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80137314:	e0fffd17 	ldw	r3,-12(fp)
80137318:	00bfff84 	movi	r2,-2
8013731c:	1884703a 	and	r2,r3,r2
80137320:	1001703a 	wrctl	status,r2
  
  return context;
80137324:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
80137328:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8013732c:	e0bffe17 	ldw	r2,-8(fp)
80137330:	10800417 	ldw	r2,16(r2)
80137334:	10001426 	beq	r2,zero,80137388 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
80137338:	e0bffe17 	ldw	r2,-8(fp)
8013733c:	10800117 	ldw	r2,4(r2)
80137340:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
80137344:	e0bffb17 	ldw	r2,-20(fp)
80137348:	10c00017 	ldw	r3,0(r2)
8013734c:	e0bffe17 	ldw	r2,-8(fp)
80137350:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
80137354:	e0bffe17 	ldw	r2,-8(fp)
80137358:	10800417 	ldw	r2,16(r2)
8013735c:	10ffffc4 	addi	r3,r2,-1
80137360:	e0bffe17 	ldw	r2,-8(fp)
80137364:	10c00415 	stw	r3,16(r2)
80137368:	e0bff917 	ldw	r2,-28(fp)
8013736c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80137370:	e0bffa17 	ldw	r2,-24(fp)
80137374:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
80137378:	e0bfff17 	ldw	r2,-4(fp)
8013737c:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
80137380:	e0bffb17 	ldw	r2,-20(fp)
80137384:	00000806 	br	801373a8 <OSMemGet+0xe8>
80137388:	e0bff917 	ldw	r2,-28(fp)
8013738c:	e0bffc15 	stw	r2,-16(fp)
80137390:	e0bffc17 	ldw	r2,-16(fp)
80137394:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
80137398:	e0bfff17 	ldw	r2,-4(fp)
8013739c:	00c01744 	movi	r3,93
801373a0:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
801373a4:	0005883a 	mov	r2,zero
}
801373a8:	e037883a 	mov	sp,fp
801373ac:	df000017 	ldw	fp,0(sp)
801373b0:	dec00104 	addi	sp,sp,4
801373b4:	f800283a 	ret

801373b8 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
801373b8:	defff704 	addi	sp,sp,-36
801373bc:	de00012e 	bgeu	sp,et,801373c4 <OSMemNameGet+0xc>
801373c0:	003b68fa 	trap	3
801373c4:	dfc00815 	stw	ra,32(sp)
801373c8:	df000715 	stw	fp,28(sp)
801373cc:	df000704 	addi	fp,sp,28
801373d0:	e13ffd15 	stw	r4,-12(fp)
801373d4:	e17ffe15 	stw	r5,-8(fp)
801373d8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801373dc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
801373e0:	e0bfff17 	ldw	r2,-4(fp)
801373e4:	1000021e 	bne	r2,zero,801373f0 <OSMemNameGet+0x38>
        return (0);
801373e8:	0005883a 	mov	r2,zero
801373ec:	00002b06 	br	8013749c <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
801373f0:	e0bffd17 	ldw	r2,-12(fp)
801373f4:	1000051e 	bne	r2,zero,8013740c <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
801373f8:	e0bfff17 	ldw	r2,-4(fp)
801373fc:	00c01804 	movi	r3,96
80137400:	10c00005 	stb	r3,0(r2)
        return (0);
80137404:	0005883a 	mov	r2,zero
80137408:	00002406 	br	8013749c <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8013740c:	e0bffe17 	ldw	r2,-8(fp)
80137410:	1000051e 	bne	r2,zero,80137428 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
80137414:	e0bfff17 	ldw	r2,-4(fp)
80137418:	00c00304 	movi	r3,12
8013741c:	10c00005 	stb	r3,0(r2)
        return (0);
80137420:	0005883a 	mov	r2,zero
80137424:	00001d06 	br	8013749c <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
80137428:	d0a0aa03 	ldbu	r2,-32088(gp)
8013742c:	10803fcc 	andi	r2,r2,255
80137430:	10000526 	beq	r2,zero,80137448 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
80137434:	e0bfff17 	ldw	r2,-4(fp)
80137438:	00c00444 	movi	r3,17
8013743c:	10c00005 	stb	r3,0(r2)
        return (0);
80137440:	0005883a 	mov	r2,zero
80137444:	00001506 	br	8013749c <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80137448:	0005303a 	rdctl	r2,status
8013744c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80137450:	e0fffb17 	ldw	r3,-20(fp)
80137454:	00bfff84 	movi	r2,-2
80137458:	1884703a 	and	r2,r3,r2
8013745c:	1001703a 	wrctl	status,r2
  
  return context;
80137460:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
80137464:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
80137468:	e0bffd17 	ldw	r2,-12(fp)
8013746c:	10800504 	addi	r2,r2,20
80137470:	100b883a 	mov	r5,r2
80137474:	e13ffe17 	ldw	r4,-8(fp)
80137478:	01351a00 	call	801351a0 <OS_StrCopy>
8013747c:	e0bffa05 	stb	r2,-24(fp)
80137480:	e0bff917 	ldw	r2,-28(fp)
80137484:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80137488:	e0bffc17 	ldw	r2,-16(fp)
8013748c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
80137490:	e0bfff17 	ldw	r2,-4(fp)
80137494:	10000005 	stb	zero,0(r2)
    return (len);
80137498:	e0bffa03 	ldbu	r2,-24(fp)
}
8013749c:	e037883a 	mov	sp,fp
801374a0:	dfc00117 	ldw	ra,4(sp)
801374a4:	df000017 	ldw	fp,0(sp)
801374a8:	dec00204 	addi	sp,sp,8
801374ac:	f800283a 	ret

801374b0 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
801374b0:	defff604 	addi	sp,sp,-40
801374b4:	de00012e 	bgeu	sp,et,801374bc <OSMemNameSet+0xc>
801374b8:	003b68fa 	trap	3
801374bc:	dfc00915 	stw	ra,36(sp)
801374c0:	df000815 	stw	fp,32(sp)
801374c4:	df000804 	addi	fp,sp,32
801374c8:	e13ffd15 	stw	r4,-12(fp)
801374cc:	e17ffe15 	stw	r5,-8(fp)
801374d0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801374d4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
801374d8:	e0bfff17 	ldw	r2,-4(fp)
801374dc:	10003526 	beq	r2,zero,801375b4 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
801374e0:	e0bffd17 	ldw	r2,-12(fp)
801374e4:	1000041e 	bne	r2,zero,801374f8 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
801374e8:	e0bfff17 	ldw	r2,-4(fp)
801374ec:	00c01804 	movi	r3,96
801374f0:	10c00005 	stb	r3,0(r2)
        return;
801374f4:	00003006 	br	801375b8 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
801374f8:	e0bffe17 	ldw	r2,-8(fp)
801374fc:	1000041e 	bne	r2,zero,80137510 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
80137500:	e0bfff17 	ldw	r2,-4(fp)
80137504:	00c00304 	movi	r3,12
80137508:	10c00005 	stb	r3,0(r2)
        return;
8013750c:	00002a06 	br	801375b8 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
80137510:	d0a0aa03 	ldbu	r2,-32088(gp)
80137514:	10803fcc 	andi	r2,r2,255
80137518:	10000426 	beq	r2,zero,8013752c <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8013751c:	e0bfff17 	ldw	r2,-4(fp)
80137520:	00c00484 	movi	r3,18
80137524:	10c00005 	stb	r3,0(r2)
        return;
80137528:	00002306 	br	801375b8 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013752c:	0005303a 	rdctl	r2,status
80137530:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80137534:	e0fffc17 	ldw	r3,-16(fp)
80137538:	00bfff84 	movi	r2,-2
8013753c:	1884703a 	and	r2,r3,r2
80137540:	1001703a 	wrctl	status,r2
  
  return context;
80137544:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80137548:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8013754c:	e13ffe17 	ldw	r4,-8(fp)
80137550:	013521c0 	call	8013521c <OS_StrLen>
80137554:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
80137558:	e0bffa03 	ldbu	r2,-24(fp)
8013755c:	10800830 	cmpltui	r2,r2,32
80137560:	1000081e 	bne	r2,zero,80137584 <OSMemNameSet+0xd4>
80137564:	e0bff817 	ldw	r2,-32(fp)
80137568:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013756c:	e0bff917 	ldw	r2,-28(fp)
80137570:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
80137574:	e0bfff17 	ldw	r2,-4(fp)
80137578:	00c018c4 	movi	r3,99
8013757c:	10c00005 	stb	r3,0(r2)
        return;
80137580:	00000d06 	br	801375b8 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
80137584:	e0bffd17 	ldw	r2,-12(fp)
80137588:	10800504 	addi	r2,r2,20
8013758c:	e17ffe17 	ldw	r5,-8(fp)
80137590:	1009883a 	mov	r4,r2
80137594:	01351a00 	call	801351a0 <OS_StrCopy>
80137598:	e0bff817 	ldw	r2,-32(fp)
8013759c:	e0bffb15 	stw	r2,-20(fp)
801375a0:	e0bffb17 	ldw	r2,-20(fp)
801375a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
801375a8:	e0bfff17 	ldw	r2,-4(fp)
801375ac:	10000005 	stb	zero,0(r2)
801375b0:	00000106 	br	801375b8 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
801375b4:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
801375b8:	e037883a 	mov	sp,fp
801375bc:	dfc00117 	ldw	ra,4(sp)
801375c0:	df000017 	ldw	fp,0(sp)
801375c4:	dec00204 	addi	sp,sp,8
801375c8:	f800283a 	ret

801375cc <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
801375cc:	defff904 	addi	sp,sp,-28
801375d0:	de00012e 	bgeu	sp,et,801375d8 <OSMemPut+0xc>
801375d4:	003b68fa 	trap	3
801375d8:	df000615 	stw	fp,24(sp)
801375dc:	df000604 	addi	fp,sp,24
801375e0:	e13ffe15 	stw	r4,-8(fp)
801375e4:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801375e8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
801375ec:	e0bffe17 	ldw	r2,-8(fp)
801375f0:	1000021e 	bne	r2,zero,801375fc <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
801375f4:	00801804 	movi	r2,96
801375f8:	00002806 	br	8013769c <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
801375fc:	e0bfff17 	ldw	r2,-4(fp)
80137600:	1000021e 	bne	r2,zero,8013760c <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
80137604:	008017c4 	movi	r2,95
80137608:	00002406 	br	8013769c <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013760c:	0005303a 	rdctl	r2,status
80137610:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80137614:	e0fffd17 	ldw	r3,-12(fp)
80137618:	00bfff84 	movi	r2,-2
8013761c:	1884703a 	and	r2,r3,r2
80137620:	1001703a 	wrctl	status,r2
  
  return context;
80137624:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
80137628:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8013762c:	e0bffe17 	ldw	r2,-8(fp)
80137630:	10c00417 	ldw	r3,16(r2)
80137634:	e0bffe17 	ldw	r2,-8(fp)
80137638:	10800317 	ldw	r2,12(r2)
8013763c:	18800636 	bltu	r3,r2,80137658 <OSMemPut+0x8c>
80137640:	e0bffa17 	ldw	r2,-24(fp)
80137644:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80137648:	e0bffb17 	ldw	r2,-20(fp)
8013764c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
80137650:	00801784 	movi	r2,94
80137654:	00001106 	br	8013769c <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
80137658:	e0bffe17 	ldw	r2,-8(fp)
8013765c:	10c00117 	ldw	r3,4(r2)
80137660:	e0bfff17 	ldw	r2,-4(fp)
80137664:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
80137668:	e0bffe17 	ldw	r2,-8(fp)
8013766c:	e0ffff17 	ldw	r3,-4(fp)
80137670:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
80137674:	e0bffe17 	ldw	r2,-8(fp)
80137678:	10800417 	ldw	r2,16(r2)
8013767c:	10c00044 	addi	r3,r2,1
80137680:	e0bffe17 	ldw	r2,-8(fp)
80137684:	10c00415 	stw	r3,16(r2)
80137688:	e0bffa17 	ldw	r2,-24(fp)
8013768c:	e0bffc15 	stw	r2,-16(fp)
80137690:	e0bffc17 	ldw	r2,-16(fp)
80137694:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
80137698:	0005883a 	mov	r2,zero
}
8013769c:	e037883a 	mov	sp,fp
801376a0:	df000017 	ldw	fp,0(sp)
801376a4:	dec00104 	addi	sp,sp,4
801376a8:	f800283a 	ret

801376ac <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
801376ac:	defffa04 	addi	sp,sp,-24
801376b0:	de00012e 	bgeu	sp,et,801376b8 <OSMemQuery+0xc>
801376b4:	003b68fa 	trap	3
801376b8:	df000515 	stw	fp,20(sp)
801376bc:	df000504 	addi	fp,sp,20
801376c0:	e13ffe15 	stw	r4,-8(fp)
801376c4:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801376c8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
801376cc:	e0bffe17 	ldw	r2,-8(fp)
801376d0:	1000021e 	bne	r2,zero,801376dc <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
801376d4:	00801804 	movi	r2,96
801376d8:	00002c06 	br	8013778c <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
801376dc:	e0bfff17 	ldw	r2,-4(fp)
801376e0:	1000021e 	bne	r2,zero,801376ec <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
801376e4:	00801844 	movi	r2,97
801376e8:	00002806 	br	8013778c <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801376ec:	0005303a 	rdctl	r2,status
801376f0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801376f4:	e0fffc17 	ldw	r3,-16(fp)
801376f8:	00bfff84 	movi	r2,-2
801376fc:	1884703a 	and	r2,r3,r2
80137700:	1001703a 	wrctl	status,r2
  
  return context;
80137704:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
80137708:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8013770c:	e0bffe17 	ldw	r2,-8(fp)
80137710:	10c00017 	ldw	r3,0(r2)
80137714:	e0bfff17 	ldw	r2,-4(fp)
80137718:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8013771c:	e0bffe17 	ldw	r2,-8(fp)
80137720:	10c00117 	ldw	r3,4(r2)
80137724:	e0bfff17 	ldw	r2,-4(fp)
80137728:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8013772c:	e0bffe17 	ldw	r2,-8(fp)
80137730:	10c00217 	ldw	r3,8(r2)
80137734:	e0bfff17 	ldw	r2,-4(fp)
80137738:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8013773c:	e0bffe17 	ldw	r2,-8(fp)
80137740:	10c00317 	ldw	r3,12(r2)
80137744:	e0bfff17 	ldw	r2,-4(fp)
80137748:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8013774c:	e0bffe17 	ldw	r2,-8(fp)
80137750:	10c00417 	ldw	r3,16(r2)
80137754:	e0bfff17 	ldw	r2,-4(fp)
80137758:	10c00415 	stw	r3,16(r2)
8013775c:	e0bffb17 	ldw	r2,-20(fp)
80137760:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80137764:	e0bffd17 	ldw	r2,-12(fp)
80137768:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8013776c:	e0bfff17 	ldw	r2,-4(fp)
80137770:	10c00317 	ldw	r3,12(r2)
80137774:	e0bfff17 	ldw	r2,-4(fp)
80137778:	10800417 	ldw	r2,16(r2)
8013777c:	1887c83a 	sub	r3,r3,r2
80137780:	e0bfff17 	ldw	r2,-4(fp)
80137784:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
80137788:	0005883a 	mov	r2,zero
}
8013778c:	e037883a 	mov	sp,fp
80137790:	df000017 	ldw	fp,0(sp)
80137794:	dec00104 	addi	sp,sp,4
80137798:	f800283a 	ret

8013779c <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8013779c:	defffc04 	addi	sp,sp,-16
801377a0:	de00012e 	bgeu	sp,et,801377a8 <OS_MemInit+0xc>
801377a4:	003b68fa 	trap	3
801377a8:	dfc00315 	stw	ra,12(sp)
801377ac:	df000215 	stw	fp,8(sp)
801377b0:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
801377b4:	01430c04 	movi	r5,3120
801377b8:	012005b4 	movhi	r4,32790
801377bc:	213cd104 	addi	r4,r4,-3260
801377c0:	0134f800 	call	80134f80 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
801377c4:	00a005b4 	movhi	r2,32790
801377c8:	10bcd104 	addi	r2,r2,-3260
801377cc:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
801377d0:	e03fff0d 	sth	zero,-4(fp)
801377d4:	00001306 	br	80137824 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
801377d8:	e0bfff0b 	ldhu	r2,-4(fp)
801377dc:	10800044 	addi	r2,r2,1
801377e0:	10c00d24 	muli	r3,r2,52
801377e4:	00a005b4 	movhi	r2,32790
801377e8:	10bcd104 	addi	r2,r2,-3260
801377ec:	1887883a 	add	r3,r3,r2
801377f0:	e0bffe17 	ldw	r2,-8(fp)
801377f4:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
801377f8:	e0bffe17 	ldw	r2,-8(fp)
801377fc:	00c00fc4 	movi	r3,63
80137800:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
80137804:	e0bffe17 	ldw	r2,-8(fp)
80137808:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8013780c:	e0bffe17 	ldw	r2,-8(fp)
80137810:	10800d04 	addi	r2,r2,52
80137814:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
80137818:	e0bfff0b 	ldhu	r2,-4(fp)
8013781c:	10800044 	addi	r2,r2,1
80137820:	e0bfff0d 	sth	r2,-4(fp)
80137824:	e0bfff0b 	ldhu	r2,-4(fp)
80137828:	10800ef0 	cmpltui	r2,r2,59
8013782c:	103fea1e 	bne	r2,zero,801377d8 <__reset+0xfa1177d8>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
80137830:	e0bffe17 	ldw	r2,-8(fp)
80137834:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
80137838:	e0bffe17 	ldw	r2,-8(fp)
8013783c:	00c00fc4 	movi	r3,63
80137840:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
80137844:	e0bffe17 	ldw	r2,-8(fp)
80137848:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8013784c:	00a005b4 	movhi	r2,32790
80137850:	10bcd104 	addi	r2,r2,-3260
80137854:	d0a0a415 	stw	r2,-32112(gp)
#endif
}
80137858:	0001883a 	nop
8013785c:	e037883a 	mov	sp,fp
80137860:	dfc00117 	ldw	ra,4(sp)
80137864:	df000017 	ldw	fp,0(sp)
80137868:	dec00204 	addi	sp,sp,8
8013786c:	f800283a 	ret

80137870 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
80137870:	defff704 	addi	sp,sp,-36
80137874:	de00012e 	bgeu	sp,et,8013787c <OSMutexAccept+0xc>
80137878:	003b68fa 	trap	3
8013787c:	df000815 	stw	fp,32(sp)
80137880:	df000804 	addi	fp,sp,32
80137884:	e13ffe15 	stw	r4,-8(fp)
80137888:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8013788c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
80137890:	e0bfff17 	ldw	r2,-4(fp)
80137894:	1000021e 	bne	r2,zero,801378a0 <OSMutexAccept+0x30>
        return (OS_FALSE);
80137898:	0005883a 	mov	r2,zero
8013789c:	00005b06 	br	80137a0c <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
801378a0:	e0bffe17 	ldw	r2,-8(fp)
801378a4:	1000051e 	bne	r2,zero,801378bc <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
801378a8:	e0bfff17 	ldw	r2,-4(fp)
801378ac:	00c00104 	movi	r3,4
801378b0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
801378b4:	0005883a 	mov	r2,zero
801378b8:	00005406 	br	80137a0c <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
801378bc:	e0bffe17 	ldw	r2,-8(fp)
801378c0:	10800003 	ldbu	r2,0(r2)
801378c4:	10803fcc 	andi	r2,r2,255
801378c8:	10800120 	cmpeqi	r2,r2,4
801378cc:	1000051e 	bne	r2,zero,801378e4 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
801378d0:	e0bfff17 	ldw	r2,-4(fp)
801378d4:	00c00044 	movi	r3,1
801378d8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
801378dc:	0005883a 	mov	r2,zero
801378e0:	00004a06 	br	80137a0c <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
801378e4:	d0a0aa03 	ldbu	r2,-32088(gp)
801378e8:	10803fcc 	andi	r2,r2,255
801378ec:	10000526 	beq	r2,zero,80137904 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
801378f0:	e0bfff17 	ldw	r2,-4(fp)
801378f4:	00c00084 	movi	r3,2
801378f8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
801378fc:	0005883a 	mov	r2,zero
80137900:	00004206 	br	80137a0c <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80137904:	0005303a 	rdctl	r2,status
80137908:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013790c:	e0fffd17 	ldw	r3,-12(fp)
80137910:	00bfff84 	movi	r2,-2
80137914:	1884703a 	and	r2,r3,r2
80137918:	1001703a 	wrctl	status,r2
  
  return context;
8013791c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
80137920:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
80137924:	e0bffe17 	ldw	r2,-8(fp)
80137928:	1080020b 	ldhu	r2,8(r2)
8013792c:	10bfffcc 	andi	r2,r2,65535
80137930:	1004d23a 	srli	r2,r2,8
80137934:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
80137938:	e0bffe17 	ldw	r2,-8(fp)
8013793c:	1080020b 	ldhu	r2,8(r2)
80137940:	10bfffcc 	andi	r2,r2,65535
80137944:	10803fcc 	andi	r2,r2,255
80137948:	10803fd8 	cmpnei	r2,r2,255
8013794c:	1000281e 	bne	r2,zero,801379f0 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
80137950:	e0bffe17 	ldw	r2,-8(fp)
80137954:	10c0020b 	ldhu	r3,8(r2)
80137958:	00bfc004 	movi	r2,-256
8013795c:	1884703a 	and	r2,r3,r2
80137960:	1007883a 	mov	r3,r2
80137964:	e0bffe17 	ldw	r2,-8(fp)
80137968:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8013796c:	e0bffe17 	ldw	r2,-8(fp)
80137970:	10c0020b 	ldhu	r3,8(r2)
80137974:	d0a0ab17 	ldw	r2,-32084(gp)
80137978:	10800c83 	ldbu	r2,50(r2)
8013797c:	10803fcc 	andi	r2,r2,255
80137980:	1884b03a 	or	r2,r3,r2
80137984:	1007883a 	mov	r3,r2
80137988:	e0bffe17 	ldw	r2,-8(fp)
8013798c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
80137990:	d0e0ab17 	ldw	r3,-32084(gp)
80137994:	e0bffe17 	ldw	r2,-8(fp)
80137998:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8013799c:	d0a0ab17 	ldw	r2,-32084(gp)
801379a0:	10800c83 	ldbu	r2,50(r2)
801379a4:	10803fcc 	andi	r2,r2,255
801379a8:	e0fffa03 	ldbu	r3,-24(fp)
801379ac:	18800836 	bltu	r3,r2,801379d0 <OSMutexAccept+0x160>
801379b0:	e0bff817 	ldw	r2,-32(fp)
801379b4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801379b8:	e0bff917 	ldw	r2,-28(fp)
801379bc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
801379c0:	e0bfff17 	ldw	r2,-4(fp)
801379c4:	00c01e04 	movi	r3,120
801379c8:	10c00005 	stb	r3,0(r2)
801379cc:	00000606 	br	801379e8 <OSMutexAccept+0x178>
801379d0:	e0bff817 	ldw	r2,-32(fp)
801379d4:	e0bffb15 	stw	r2,-20(fp)
801379d8:	e0bffb17 	ldw	r2,-20(fp)
801379dc:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
801379e0:	e0bfff17 	ldw	r2,-4(fp)
801379e4:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
801379e8:	00800044 	movi	r2,1
801379ec:	00000706 	br	80137a0c <OSMutexAccept+0x19c>
801379f0:	e0bff817 	ldw	r2,-32(fp)
801379f4:	e0bffc15 	stw	r2,-16(fp)
801379f8:	e0bffc17 	ldw	r2,-16(fp)
801379fc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
80137a00:	e0bfff17 	ldw	r2,-4(fp)
80137a04:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
80137a08:	0005883a 	mov	r2,zero
}
80137a0c:	e037883a 	mov	sp,fp
80137a10:	df000017 	ldw	fp,0(sp)
80137a14:	dec00104 	addi	sp,sp,4
80137a18:	f800283a 	ret

80137a1c <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
80137a1c:	defff604 	addi	sp,sp,-40
80137a20:	de00012e 	bgeu	sp,et,80137a28 <OSMutexCreate+0xc>
80137a24:	003b68fa 	trap	3
80137a28:	dfc00915 	stw	ra,36(sp)
80137a2c:	df000815 	stw	fp,32(sp)
80137a30:	df000804 	addi	fp,sp,32
80137a34:	2005883a 	mov	r2,r4
80137a38:	e17fff15 	stw	r5,-4(fp)
80137a3c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
80137a40:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
80137a44:	e0bfff17 	ldw	r2,-4(fp)
80137a48:	1000021e 	bne	r2,zero,80137a54 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
80137a4c:	0005883a 	mov	r2,zero
80137a50:	00006106 	br	80137bd8 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
80137a54:	e0bffe03 	ldbu	r2,-8(fp)
80137a58:	10800ab0 	cmpltui	r2,r2,42
80137a5c:	1000051e 	bne	r2,zero,80137a74 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
80137a60:	e0bfff17 	ldw	r2,-4(fp)
80137a64:	00c00a84 	movi	r3,42
80137a68:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
80137a6c:	0005883a 	mov	r2,zero
80137a70:	00005906 	br	80137bd8 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
80137a74:	d0a0aa03 	ldbu	r2,-32088(gp)
80137a78:	10803fcc 	andi	r2,r2,255
80137a7c:	10000526 	beq	r2,zero,80137a94 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
80137a80:	e0bfff17 	ldw	r2,-4(fp)
80137a84:	00c00404 	movi	r3,16
80137a88:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
80137a8c:	0005883a 	mov	r2,zero
80137a90:	00005106 	br	80137bd8 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80137a94:	0005303a 	rdctl	r2,status
80137a98:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80137a9c:	e0fffd17 	ldw	r3,-12(fp)
80137aa0:	00bfff84 	movi	r2,-2
80137aa4:	1884703a 	and	r2,r3,r2
80137aa8:	1001703a 	wrctl	status,r2
  
  return context;
80137aac:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
80137ab0:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
80137ab4:	e0fffe03 	ldbu	r3,-8(fp)
80137ab8:	00a005b4 	movhi	r2,32790
80137abc:	10924b04 	addi	r2,r2,18732
80137ac0:	18c7883a 	add	r3,r3,r3
80137ac4:	18c7883a 	add	r3,r3,r3
80137ac8:	10c5883a 	add	r2,r2,r3
80137acc:	10800017 	ldw	r2,0(r2)
80137ad0:	10000926 	beq	r2,zero,80137af8 <OSMutexCreate+0xdc>
80137ad4:	e0bff817 	ldw	r2,-32(fp)
80137ad8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80137adc:	e0bff917 	ldw	r2,-28(fp)
80137ae0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
80137ae4:	e0bfff17 	ldw	r2,-4(fp)
80137ae8:	00c00a04 	movi	r3,40
80137aec:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
80137af0:	0005883a 	mov	r2,zero
80137af4:	00003806 	br	80137bd8 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
80137af8:	e0fffe03 	ldbu	r3,-8(fp)
80137afc:	00a005b4 	movhi	r2,32790
80137b00:	10924b04 	addi	r2,r2,18732
80137b04:	18c7883a 	add	r3,r3,r3
80137b08:	18c7883a 	add	r3,r3,r3
80137b0c:	10c5883a 	add	r2,r2,r3
80137b10:	00c00044 	movi	r3,1
80137b14:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
80137b18:	d0a0a917 	ldw	r2,-32092(gp)
80137b1c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
80137b20:	e0bffb17 	ldw	r2,-20(fp)
80137b24:	1000101e 	bne	r2,zero,80137b68 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
80137b28:	e0fffe03 	ldbu	r3,-8(fp)
80137b2c:	00a005b4 	movhi	r2,32790
80137b30:	10924b04 	addi	r2,r2,18732
80137b34:	18c7883a 	add	r3,r3,r3
80137b38:	18c7883a 	add	r3,r3,r3
80137b3c:	10c5883a 	add	r2,r2,r3
80137b40:	10000015 	stw	zero,0(r2)
80137b44:	e0bff817 	ldw	r2,-32(fp)
80137b48:	e0bffa15 	stw	r2,-24(fp)
80137b4c:	e0bffa17 	ldw	r2,-24(fp)
80137b50:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
80137b54:	e0bfff17 	ldw	r2,-4(fp)
80137b58:	00c00104 	movi	r3,4
80137b5c:	10c00005 	stb	r3,0(r2)
        return (pevent);
80137b60:	e0bffb17 	ldw	r2,-20(fp)
80137b64:	00001c06 	br	80137bd8 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
80137b68:	d0a0a917 	ldw	r2,-32092(gp)
80137b6c:	10800117 	ldw	r2,4(r2)
80137b70:	d0a0a915 	stw	r2,-32092(gp)
80137b74:	e0bff817 	ldw	r2,-32(fp)
80137b78:	e0bffc15 	stw	r2,-16(fp)
80137b7c:	e0bffc17 	ldw	r2,-16(fp)
80137b80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
80137b84:	e0bffb17 	ldw	r2,-20(fp)
80137b88:	00c00104 	movi	r3,4
80137b8c:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
80137b90:	e0bffe03 	ldbu	r2,-8(fp)
80137b94:	1004923a 	slli	r2,r2,8
80137b98:	10803fd4 	ori	r2,r2,255
80137b9c:	1007883a 	mov	r3,r2
80137ba0:	e0bffb17 	ldw	r2,-20(fp)
80137ba4:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
80137ba8:	e0bffb17 	ldw	r2,-20(fp)
80137bac:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
80137bb0:	e0bffb17 	ldw	r2,-20(fp)
80137bb4:	00c00fc4 	movi	r3,63
80137bb8:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
80137bbc:	e0bffb17 	ldw	r2,-20(fp)
80137bc0:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
80137bc4:	e13ffb17 	ldw	r4,-20(fp)
80137bc8:	0134b680 	call	80134b68 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
80137bcc:	e0bfff17 	ldw	r2,-4(fp)
80137bd0:	10000005 	stb	zero,0(r2)
    return (pevent);
80137bd4:	e0bffb17 	ldw	r2,-20(fp)
}
80137bd8:	e037883a 	mov	sp,fp
80137bdc:	dfc00117 	ldw	ra,4(sp)
80137be0:	df000017 	ldw	fp,0(sp)
80137be4:	dec00204 	addi	sp,sp,8
80137be8:	f800283a 	ret

80137bec <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
80137bec:	defff004 	addi	sp,sp,-64
80137bf0:	de00012e 	bgeu	sp,et,80137bf8 <OSMutexDel+0xc>
80137bf4:	003b68fa 	trap	3
80137bf8:	dfc00f15 	stw	ra,60(sp)
80137bfc:	df000e15 	stw	fp,56(sp)
80137c00:	df000e04 	addi	fp,sp,56
80137c04:	e13ffd15 	stw	r4,-12(fp)
80137c08:	2805883a 	mov	r2,r5
80137c0c:	e1bfff15 	stw	r6,-4(fp)
80137c10:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
80137c14:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
80137c18:	e0bfff17 	ldw	r2,-4(fp)
80137c1c:	1000021e 	bne	r2,zero,80137c28 <OSMutexDel+0x3c>
        return (pevent);
80137c20:	e0bffd17 	ldw	r2,-12(fp)
80137c24:	0000ad06 	br	80137edc <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
80137c28:	e0bffd17 	ldw	r2,-12(fp)
80137c2c:	1000051e 	bne	r2,zero,80137c44 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
80137c30:	e0bfff17 	ldw	r2,-4(fp)
80137c34:	00c00104 	movi	r3,4
80137c38:	10c00005 	stb	r3,0(r2)
        return (pevent);
80137c3c:	e0bffd17 	ldw	r2,-12(fp)
80137c40:	0000a606 	br	80137edc <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
80137c44:	e0bffd17 	ldw	r2,-12(fp)
80137c48:	10800003 	ldbu	r2,0(r2)
80137c4c:	10803fcc 	andi	r2,r2,255
80137c50:	10800120 	cmpeqi	r2,r2,4
80137c54:	1000051e 	bne	r2,zero,80137c6c <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
80137c58:	e0bfff17 	ldw	r2,-4(fp)
80137c5c:	00c00044 	movi	r3,1
80137c60:	10c00005 	stb	r3,0(r2)
        return (pevent);
80137c64:	e0bffd17 	ldw	r2,-12(fp)
80137c68:	00009c06 	br	80137edc <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
80137c6c:	d0a0aa03 	ldbu	r2,-32088(gp)
80137c70:	10803fcc 	andi	r2,r2,255
80137c74:	10000526 	beq	r2,zero,80137c8c <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
80137c78:	e0bfff17 	ldw	r2,-4(fp)
80137c7c:	00c003c4 	movi	r3,15
80137c80:	10c00005 	stb	r3,0(r2)
        return (pevent);
80137c84:	e0bffd17 	ldw	r2,-12(fp)
80137c88:	00009406 	br	80137edc <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80137c8c:	0005303a 	rdctl	r2,status
80137c90:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80137c94:	e0fffc17 	ldw	r3,-16(fp)
80137c98:	00bfff84 	movi	r2,-2
80137c9c:	1884703a 	and	r2,r3,r2
80137ca0:	1001703a 	wrctl	status,r2
  
  return context;
80137ca4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80137ca8:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
80137cac:	e0bffd17 	ldw	r2,-12(fp)
80137cb0:	10800283 	ldbu	r2,10(r2)
80137cb4:	10803fcc 	andi	r2,r2,255
80137cb8:	10000326 	beq	r2,zero,80137cc8 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
80137cbc:	00800044 	movi	r2,1
80137cc0:	e0bff205 	stb	r2,-56(fp)
80137cc4:	00000106 	br	80137ccc <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
80137cc8:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
80137ccc:	e0bffe03 	ldbu	r2,-8(fp)
80137cd0:	10000326 	beq	r2,zero,80137ce0 <OSMutexDel+0xf4>
80137cd4:	10800060 	cmpeqi	r2,r2,1
80137cd8:	10002f1e 	bne	r2,zero,80137d98 <OSMutexDel+0x1ac>
80137cdc:	00007406 	br	80137eb0 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
80137ce0:	e0bff203 	ldbu	r2,-56(fp)
80137ce4:	1000221e 	bne	r2,zero,80137d70 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
80137ce8:	e0bffd17 	ldw	r2,-12(fp)
80137cec:	00c00fc4 	movi	r3,63
80137cf0:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
80137cf4:	e0bffd17 	ldw	r2,-12(fp)
80137cf8:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
80137cfc:	e0bffd17 	ldw	r2,-12(fp)
80137d00:	1080020b 	ldhu	r2,8(r2)
80137d04:	10bfffcc 	andi	r2,r2,65535
80137d08:	1004d23a 	srli	r2,r2,8
80137d0c:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
80137d10:	e0fff603 	ldbu	r3,-40(fp)
80137d14:	00a005b4 	movhi	r2,32790
80137d18:	10924b04 	addi	r2,r2,18732
80137d1c:	18c7883a 	add	r3,r3,r3
80137d20:	18c7883a 	add	r3,r3,r3
80137d24:	10c5883a 	add	r2,r2,r3
80137d28:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
80137d2c:	e0bffd17 	ldw	r2,-12(fp)
80137d30:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
80137d34:	d0e0a917 	ldw	r3,-32092(gp)
80137d38:	e0bffd17 	ldw	r2,-12(fp)
80137d3c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
80137d40:	e0bffd17 	ldw	r2,-12(fp)
80137d44:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
80137d48:	e0bffd17 	ldw	r2,-12(fp)
80137d4c:	d0a0a915 	stw	r2,-32092(gp)
80137d50:	e0bff417 	ldw	r2,-48(fp)
80137d54:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80137d58:	e0bff517 	ldw	r2,-44(fp)
80137d5c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
80137d60:	e0bfff17 	ldw	r2,-4(fp)
80137d64:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
80137d68:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
80137d6c:	00005a06 	br	80137ed8 <OSMutexDel+0x2ec>
80137d70:	e0bff417 	ldw	r2,-48(fp)
80137d74:	e0bff715 	stw	r2,-36(fp)
80137d78:	e0bff717 	ldw	r2,-36(fp)
80137d7c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
80137d80:	e0bfff17 	ldw	r2,-4(fp)
80137d84:	00c01244 	movi	r3,73
80137d88:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
80137d8c:	e0bffd17 	ldw	r2,-12(fp)
80137d90:	e0bff315 	stw	r2,-52(fp)
             }
             break;
80137d94:	00005006 	br	80137ed8 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
80137d98:	e0bffd17 	ldw	r2,-12(fp)
80137d9c:	1080020b 	ldhu	r2,8(r2)
80137da0:	10bfffcc 	andi	r2,r2,65535
80137da4:	1004d23a 	srli	r2,r2,8
80137da8:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
80137dac:	e0bffd17 	ldw	r2,-12(fp)
80137db0:	1080020b 	ldhu	r2,8(r2)
80137db4:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
80137db8:	e0bffd17 	ldw	r2,-12(fp)
80137dbc:	10800117 	ldw	r2,4(r2)
80137dc0:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
80137dc4:	e0bffa17 	ldw	r2,-24(fp)
80137dc8:	10000f26 	beq	r2,zero,80137e08 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
80137dcc:	e0bffa17 	ldw	r2,-24(fp)
80137dd0:	10800c83 	ldbu	r2,50(r2)
80137dd4:	10c03fcc 	andi	r3,r2,255
80137dd8:	e0bff603 	ldbu	r2,-40(fp)
80137ddc:	18800a1e 	bne	r3,r2,80137e08 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
80137de0:	e0bff903 	ldbu	r2,-28(fp)
80137de4:	100b883a 	mov	r5,r2
80137de8:	e13ffa17 	ldw	r4,-24(fp)
80137dec:	01388280 	call	80138828 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
80137df0:	00000506 	br	80137e08 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
80137df4:	000f883a 	mov	r7,zero
80137df8:	01800404 	movi	r6,16
80137dfc:	000b883a 	mov	r5,zero
80137e00:	e13ffd17 	ldw	r4,-12(fp)
80137e04:	01345900 	call	80134590 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
80137e08:	e0bffd17 	ldw	r2,-12(fp)
80137e0c:	10800283 	ldbu	r2,10(r2)
80137e10:	10803fcc 	andi	r2,r2,255
80137e14:	103ff71e 	bne	r2,zero,80137df4 <__reset+0xfa117df4>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
80137e18:	e0bffd17 	ldw	r2,-12(fp)
80137e1c:	00c00fc4 	movi	r3,63
80137e20:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
80137e24:	e0bffd17 	ldw	r2,-12(fp)
80137e28:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
80137e2c:	e0bffd17 	ldw	r2,-12(fp)
80137e30:	1080020b 	ldhu	r2,8(r2)
80137e34:	10bfffcc 	andi	r2,r2,65535
80137e38:	1004d23a 	srli	r2,r2,8
80137e3c:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
80137e40:	e0fff603 	ldbu	r3,-40(fp)
80137e44:	00a005b4 	movhi	r2,32790
80137e48:	10924b04 	addi	r2,r2,18732
80137e4c:	18c7883a 	add	r3,r3,r3
80137e50:	18c7883a 	add	r3,r3,r3
80137e54:	10c5883a 	add	r2,r2,r3
80137e58:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
80137e5c:	e0bffd17 	ldw	r2,-12(fp)
80137e60:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
80137e64:	d0e0a917 	ldw	r3,-32092(gp)
80137e68:	e0bffd17 	ldw	r2,-12(fp)
80137e6c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
80137e70:	e0bffd17 	ldw	r2,-12(fp)
80137e74:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
80137e78:	e0bffd17 	ldw	r2,-12(fp)
80137e7c:	d0a0a915 	stw	r2,-32092(gp)
80137e80:	e0bff417 	ldw	r2,-48(fp)
80137e84:	e0bff815 	stw	r2,-32(fp)
80137e88:	e0bff817 	ldw	r2,-32(fp)
80137e8c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
80137e90:	e0bff203 	ldbu	r2,-56(fp)
80137e94:	10800058 	cmpnei	r2,r2,1
80137e98:	1000011e 	bne	r2,zero,80137ea0 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
80137e9c:	013504c0 	call	8013504c <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
80137ea0:	e0bfff17 	ldw	r2,-4(fp)
80137ea4:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
80137ea8:	e03ff315 	stw	zero,-52(fp)
             break;
80137eac:	00000a06 	br	80137ed8 <OSMutexDel+0x2ec>
80137eb0:	e0bff417 	ldw	r2,-48(fp)
80137eb4:	e0bffb15 	stw	r2,-20(fp)
80137eb8:	e0bffb17 	ldw	r2,-20(fp)
80137ebc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
80137ec0:	e0bfff17 	ldw	r2,-4(fp)
80137ec4:	00c001c4 	movi	r3,7
80137ec8:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
80137ecc:	e0bffd17 	ldw	r2,-12(fp)
80137ed0:	e0bff315 	stw	r2,-52(fp)
             break;
80137ed4:	0001883a 	nop
    }
    return (pevent_return);
80137ed8:	e0bff317 	ldw	r2,-52(fp)
}
80137edc:	e037883a 	mov	sp,fp
80137ee0:	dfc00117 	ldw	ra,4(sp)
80137ee4:	df000017 	ldw	fp,0(sp)
80137ee8:	dec00204 	addi	sp,sp,8
80137eec:	f800283a 	ret

80137ef0 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
80137ef0:	deffee04 	addi	sp,sp,-72
80137ef4:	de00012e 	bgeu	sp,et,80137efc <OSMutexPend+0xc>
80137ef8:	003b68fa 	trap	3
80137efc:	dfc01115 	stw	ra,68(sp)
80137f00:	df001015 	stw	fp,64(sp)
80137f04:	df001004 	addi	fp,sp,64
80137f08:	e13ffd15 	stw	r4,-12(fp)
80137f0c:	2805883a 	mov	r2,r5
80137f10:	e1bfff15 	stw	r6,-4(fp)
80137f14:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
80137f18:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
80137f1c:	e0bfff17 	ldw	r2,-4(fp)
80137f20:	10015626 	beq	r2,zero,8013847c <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
80137f24:	e0bffd17 	ldw	r2,-12(fp)
80137f28:	1000041e 	bne	r2,zero,80137f3c <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
80137f2c:	e0bfff17 	ldw	r2,-4(fp)
80137f30:	00c00104 	movi	r3,4
80137f34:	10c00005 	stb	r3,0(r2)
        return;
80137f38:	00015106 	br	80138480 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
80137f3c:	e0bffd17 	ldw	r2,-12(fp)
80137f40:	10800003 	ldbu	r2,0(r2)
80137f44:	10803fcc 	andi	r2,r2,255
80137f48:	10800120 	cmpeqi	r2,r2,4
80137f4c:	1000041e 	bne	r2,zero,80137f60 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
80137f50:	e0bfff17 	ldw	r2,-4(fp)
80137f54:	00c00044 	movi	r3,1
80137f58:	10c00005 	stb	r3,0(r2)
        return;
80137f5c:	00014806 	br	80138480 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
80137f60:	d0a0aa03 	ldbu	r2,-32088(gp)
80137f64:	10803fcc 	andi	r2,r2,255
80137f68:	10000426 	beq	r2,zero,80137f7c <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
80137f6c:	e0bfff17 	ldw	r2,-4(fp)
80137f70:	00c00084 	movi	r3,2
80137f74:	10c00005 	stb	r3,0(r2)
        return;
80137f78:	00014106 	br	80138480 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
80137f7c:	d0a09803 	ldbu	r2,-32160(gp)
80137f80:	10803fcc 	andi	r2,r2,255
80137f84:	10000426 	beq	r2,zero,80137f98 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
80137f88:	e0bfff17 	ldw	r2,-4(fp)
80137f8c:	00c00344 	movi	r3,13
80137f90:	10c00005 	stb	r3,0(r2)
        return;
80137f94:	00013a06 	br	80138480 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80137f98:	0005303a 	rdctl	r2,status
80137f9c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80137fa0:	e0fffc17 	ldw	r3,-16(fp)
80137fa4:	00bfff84 	movi	r2,-2
80137fa8:	1884703a 	and	r2,r3,r2
80137fac:	1001703a 	wrctl	status,r2
  
  return context;
80137fb0:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
80137fb4:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
80137fb8:	e0bffd17 	ldw	r2,-12(fp)
80137fbc:	1080020b 	ldhu	r2,8(r2)
80137fc0:	10bfffcc 	andi	r2,r2,65535
80137fc4:	1004d23a 	srli	r2,r2,8
80137fc8:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
80137fcc:	e0bffd17 	ldw	r2,-12(fp)
80137fd0:	1080020b 	ldhu	r2,8(r2)
80137fd4:	10803fcc 	andi	r2,r2,255
80137fd8:	10803fd8 	cmpnei	r2,r2,255
80137fdc:	1000271e 	bne	r2,zero,8013807c <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
80137fe0:	e0bffd17 	ldw	r2,-12(fp)
80137fe4:	10c0020b 	ldhu	r3,8(r2)
80137fe8:	00bfc004 	movi	r2,-256
80137fec:	1884703a 	and	r2,r3,r2
80137ff0:	1007883a 	mov	r3,r2
80137ff4:	e0bffd17 	ldw	r2,-12(fp)
80137ff8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
80137ffc:	e0bffd17 	ldw	r2,-12(fp)
80138000:	10c0020b 	ldhu	r3,8(r2)
80138004:	d0a0ab17 	ldw	r2,-32084(gp)
80138008:	10800c83 	ldbu	r2,50(r2)
8013800c:	10803fcc 	andi	r2,r2,255
80138010:	1884b03a 	or	r2,r3,r2
80138014:	1007883a 	mov	r3,r2
80138018:	e0bffd17 	ldw	r2,-12(fp)
8013801c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
80138020:	d0e0ab17 	ldw	r3,-32084(gp)
80138024:	e0bffd17 	ldw	r2,-12(fp)
80138028:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8013802c:	d0a0ab17 	ldw	r2,-32084(gp)
80138030:	10800c83 	ldbu	r2,50(r2)
80138034:	10803fcc 	andi	r2,r2,255
80138038:	e0fff303 	ldbu	r3,-52(fp)
8013803c:	18800836 	bltu	r3,r2,80138060 <OSMutexPend+0x170>
80138040:	e0bff117 	ldw	r2,-60(fp)
80138044:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80138048:	e0bff217 	ldw	r2,-56(fp)
8013804c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
80138050:	e0bfff17 	ldw	r2,-4(fp)
80138054:	00c01e04 	movi	r3,120
80138058:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8013805c:	00010806 	br	80138480 <OSMutexPend+0x590>
80138060:	e0bff117 	ldw	r2,-60(fp)
80138064:	e0bff415 	stw	r2,-48(fp)
80138068:	e0bff417 	ldw	r2,-48(fp)
8013806c:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
80138070:	e0bfff17 	ldw	r2,-4(fp)
80138074:	10000005 	stb	zero,0(r2)
        }
        return;
80138078:	00010106 	br	80138480 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8013807c:	e0bffd17 	ldw	r2,-12(fp)
80138080:	1080020b 	ldhu	r2,8(r2)
80138084:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
80138088:	e0bffd17 	ldw	r2,-12(fp)
8013808c:	10800117 	ldw	r2,4(r2)
80138090:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
80138094:	e0bff717 	ldw	r2,-36(fp)
80138098:	10800c83 	ldbu	r2,50(r2)
8013809c:	10803fcc 	andi	r2,r2,255
801380a0:	e0fff303 	ldbu	r3,-52(fp)
801380a4:	1880b92e 	bgeu	r3,r2,8013838c <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
801380a8:	d0a0ab17 	ldw	r2,-32084(gp)
801380ac:	10800c83 	ldbu	r2,50(r2)
801380b0:	10c03fcc 	andi	r3,r2,255
801380b4:	e0bff603 	ldbu	r2,-40(fp)
801380b8:	1880b42e 	bgeu	r3,r2,8013838c <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
801380bc:	e0bff717 	ldw	r2,-36(fp)
801380c0:	10800d03 	ldbu	r2,52(r2)
801380c4:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
801380c8:	e0fff803 	ldbu	r3,-32(fp)
801380cc:	d0a0a744 	addi	r2,gp,-32099
801380d0:	1885883a 	add	r2,r3,r2
801380d4:	10c00003 	ldbu	r3,0(r2)
801380d8:	e0bff717 	ldw	r2,-36(fp)
801380dc:	10800d43 	ldbu	r2,53(r2)
801380e0:	1884703a 	and	r2,r3,r2
801380e4:	10803fcc 	andi	r2,r2,255
801380e8:	10001e26 	beq	r2,zero,80138164 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
801380ec:	e0fff803 	ldbu	r3,-32(fp)
801380f0:	e13ff803 	ldbu	r4,-32(fp)
801380f4:	d0a0a744 	addi	r2,gp,-32099
801380f8:	2085883a 	add	r2,r4,r2
801380fc:	10800003 	ldbu	r2,0(r2)
80138100:	1009883a 	mov	r4,r2
80138104:	e0bff717 	ldw	r2,-36(fp)
80138108:	10800d43 	ldbu	r2,53(r2)
8013810c:	0084303a 	nor	r2,zero,r2
80138110:	2084703a 	and	r2,r4,r2
80138114:	1009883a 	mov	r4,r2
80138118:	d0a0a744 	addi	r2,gp,-32099
8013811c:	1885883a 	add	r2,r3,r2
80138120:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
80138124:	e0fff803 	ldbu	r3,-32(fp)
80138128:	d0a0a744 	addi	r2,gp,-32099
8013812c:	1885883a 	add	r2,r3,r2
80138130:	10800003 	ldbu	r2,0(r2)
80138134:	10803fcc 	andi	r2,r2,255
80138138:	1000071e 	bne	r2,zero,80138158 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8013813c:	e0bff717 	ldw	r2,-36(fp)
80138140:	10800d83 	ldbu	r2,54(r2)
80138144:	0084303a 	nor	r2,zero,r2
80138148:	1007883a 	mov	r3,r2
8013814c:	d0a0a703 	ldbu	r2,-32100(gp)
80138150:	1884703a 	and	r2,r3,r2
80138154:	d0a0a705 	stb	r2,-32100(gp)
                }
                rdy = OS_TRUE;
80138158:	00800044 	movi	r2,1
8013815c:	e0bff005 	stb	r2,-64(fp)
80138160:	00002a06 	br	8013820c <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
80138164:	e0bff717 	ldw	r2,-36(fp)
80138168:	10800717 	ldw	r2,28(r2)
8013816c:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
80138170:	e0bff917 	ldw	r2,-28(fp)
80138174:	10002426 	beq	r2,zero,80138208 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
80138178:	e0bff717 	ldw	r2,-36(fp)
8013817c:	10800d03 	ldbu	r2,52(r2)
80138180:	10803fcc 	andi	r2,r2,255
80138184:	e0fff717 	ldw	r3,-36(fp)
80138188:	18c00d03 	ldbu	r3,52(r3)
8013818c:	18c03fcc 	andi	r3,r3,255
80138190:	e13ff917 	ldw	r4,-28(fp)
80138194:	20c7883a 	add	r3,r4,r3
80138198:	18c002c4 	addi	r3,r3,11
8013819c:	18c00003 	ldbu	r3,0(r3)
801381a0:	1809883a 	mov	r4,r3
801381a4:	e0fff717 	ldw	r3,-36(fp)
801381a8:	18c00d43 	ldbu	r3,53(r3)
801381ac:	00c6303a 	nor	r3,zero,r3
801381b0:	20c6703a 	and	r3,r4,r3
801381b4:	1809883a 	mov	r4,r3
801381b8:	e0fff917 	ldw	r3,-28(fp)
801381bc:	1887883a 	add	r3,r3,r2
801381c0:	18c002c4 	addi	r3,r3,11
801381c4:	19000005 	stb	r4,0(r3)
801381c8:	e0fff917 	ldw	r3,-28(fp)
801381cc:	1885883a 	add	r2,r3,r2
801381d0:	108002c4 	addi	r2,r2,11
801381d4:	10800003 	ldbu	r2,0(r2)
801381d8:	10803fcc 	andi	r2,r2,255
801381dc:	10000a1e 	bne	r2,zero,80138208 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
801381e0:	e0bff917 	ldw	r2,-28(fp)
801381e4:	10800283 	ldbu	r2,10(r2)
801381e8:	1007883a 	mov	r3,r2
801381ec:	e0bff717 	ldw	r2,-36(fp)
801381f0:	10800d83 	ldbu	r2,54(r2)
801381f4:	0084303a 	nor	r2,zero,r2
801381f8:	1884703a 	and	r2,r3,r2
801381fc:	1007883a 	mov	r3,r2
80138200:	e0bff917 	ldw	r2,-28(fp)
80138204:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
80138208:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8013820c:	e0bff717 	ldw	r2,-36(fp)
80138210:	e0fff303 	ldbu	r3,-52(fp)
80138214:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
80138218:	e0bff717 	ldw	r2,-36(fp)
8013821c:	10800c83 	ldbu	r2,50(r2)
80138220:	10803fcc 	andi	r2,r2,255
80138224:	1004d0fa 	srli	r2,r2,3
80138228:	1007883a 	mov	r3,r2
8013822c:	e0bff717 	ldw	r2,-36(fp)
80138230:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
80138234:	e0bff717 	ldw	r2,-36(fp)
80138238:	10800c83 	ldbu	r2,50(r2)
8013823c:	108001cc 	andi	r2,r2,7
80138240:	1007883a 	mov	r3,r2
80138244:	e0bff717 	ldw	r2,-36(fp)
80138248:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8013824c:	e0bff717 	ldw	r2,-36(fp)
80138250:	10800d03 	ldbu	r2,52(r2)
80138254:	10803fcc 	andi	r2,r2,255
80138258:	00c00044 	movi	r3,1
8013825c:	1884983a 	sll	r2,r3,r2
80138260:	1007883a 	mov	r3,r2
80138264:	e0bff717 	ldw	r2,-36(fp)
80138268:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8013826c:	e0bff717 	ldw	r2,-36(fp)
80138270:	10800cc3 	ldbu	r2,51(r2)
80138274:	10803fcc 	andi	r2,r2,255
80138278:	00c00044 	movi	r3,1
8013827c:	1884983a 	sll	r2,r3,r2
80138280:	1007883a 	mov	r3,r2
80138284:	e0bff717 	ldw	r2,-36(fp)
80138288:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8013828c:	e0bff003 	ldbu	r2,-64(fp)
80138290:	10800058 	cmpnei	r2,r2,1
80138294:	1000161e 	bne	r2,zero,801382f0 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
80138298:	e0bff717 	ldw	r2,-36(fp)
8013829c:	10c00d83 	ldbu	r3,54(r2)
801382a0:	d0a0a703 	ldbu	r2,-32100(gp)
801382a4:	1884b03a 	or	r2,r3,r2
801382a8:	d0a0a705 	stb	r2,-32100(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
801382ac:	e0bff717 	ldw	r2,-36(fp)
801382b0:	10800d03 	ldbu	r2,52(r2)
801382b4:	10c03fcc 	andi	r3,r2,255
801382b8:	e0bff717 	ldw	r2,-36(fp)
801382bc:	10800d03 	ldbu	r2,52(r2)
801382c0:	11003fcc 	andi	r4,r2,255
801382c4:	d0a0a744 	addi	r2,gp,-32099
801382c8:	2085883a 	add	r2,r4,r2
801382cc:	11000003 	ldbu	r4,0(r2)
801382d0:	e0bff717 	ldw	r2,-36(fp)
801382d4:	10800d43 	ldbu	r2,53(r2)
801382d8:	2084b03a 	or	r2,r4,r2
801382dc:	1009883a 	mov	r4,r2
801382e0:	d0a0a744 	addi	r2,gp,-32099
801382e4:	1885883a 	add	r2,r3,r2
801382e8:	11000005 	stb	r4,0(r2)
801382ec:	00001f06 	br	8013836c <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
801382f0:	e0bff717 	ldw	r2,-36(fp)
801382f4:	10800717 	ldw	r2,28(r2)
801382f8:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
801382fc:	e0bff917 	ldw	r2,-28(fp)
80138300:	10001a26 	beq	r2,zero,8013836c <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
80138304:	e0bff917 	ldw	r2,-28(fp)
80138308:	10c00283 	ldbu	r3,10(r2)
8013830c:	e0bff717 	ldw	r2,-36(fp)
80138310:	10800d83 	ldbu	r2,54(r2)
80138314:	1884b03a 	or	r2,r3,r2
80138318:	1007883a 	mov	r3,r2
8013831c:	e0bff917 	ldw	r2,-28(fp)
80138320:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
80138324:	e0bff717 	ldw	r2,-36(fp)
80138328:	10800d03 	ldbu	r2,52(r2)
8013832c:	10803fcc 	andi	r2,r2,255
80138330:	e0fff717 	ldw	r3,-36(fp)
80138334:	18c00d03 	ldbu	r3,52(r3)
80138338:	18c03fcc 	andi	r3,r3,255
8013833c:	e13ff917 	ldw	r4,-28(fp)
80138340:	20c7883a 	add	r3,r4,r3
80138344:	18c002c4 	addi	r3,r3,11
80138348:	19000003 	ldbu	r4,0(r3)
8013834c:	e0fff717 	ldw	r3,-36(fp)
80138350:	18c00d43 	ldbu	r3,53(r3)
80138354:	20c6b03a 	or	r3,r4,r3
80138358:	1809883a 	mov	r4,r3
8013835c:	e0fff917 	ldw	r3,-28(fp)
80138360:	1885883a 	add	r2,r3,r2
80138364:	108002c4 	addi	r2,r2,11
80138368:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8013836c:	e0fff303 	ldbu	r3,-52(fp)
80138370:	00a005b4 	movhi	r2,32790
80138374:	10924b04 	addi	r2,r2,18732
80138378:	18c7883a 	add	r3,r3,r3
8013837c:	18c7883a 	add	r3,r3,r3
80138380:	10c5883a 	add	r2,r2,r3
80138384:	e0fff717 	ldw	r3,-36(fp)
80138388:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8013838c:	d0a0ab17 	ldw	r2,-32084(gp)
80138390:	d0e0ab17 	ldw	r3,-32084(gp)
80138394:	18c00c03 	ldbu	r3,48(r3)
80138398:	18c00414 	ori	r3,r3,16
8013839c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
801383a0:	d0a0ab17 	ldw	r2,-32084(gp)
801383a4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
801383a8:	d0a0ab17 	ldw	r2,-32084(gp)
801383ac:	e0fffe0b 	ldhu	r3,-8(fp)
801383b0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
801383b4:	e13ffd17 	ldw	r4,-12(fp)
801383b8:	01347300 	call	80134730 <OS_EventTaskWait>
801383bc:	e0bff117 	ldw	r2,-60(fp)
801383c0:	e0bffb15 	stw	r2,-20(fp)
801383c4:	e0bffb17 	ldw	r2,-20(fp)
801383c8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
801383cc:	013504c0 	call	8013504c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801383d0:	0005303a 	rdctl	r2,status
801383d4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801383d8:	e0fff517 	ldw	r3,-44(fp)
801383dc:	00bfff84 	movi	r2,-2
801383e0:	1884703a 	and	r2,r3,r2
801383e4:	1001703a 	wrctl	status,r2
  
  return context;
801383e8:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
801383ec:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
801383f0:	d0a0ab17 	ldw	r2,-32084(gp)
801383f4:	10800c43 	ldbu	r2,49(r2)
801383f8:	10803fcc 	andi	r2,r2,255
801383fc:	10000326 	beq	r2,zero,8013840c <OSMutexPend+0x51c>
80138400:	108000a0 	cmpeqi	r2,r2,2
80138404:	1000041e 	bne	r2,zero,80138418 <OSMutexPend+0x528>
80138408:	00000706 	br	80138428 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8013840c:	e0bfff17 	ldw	r2,-4(fp)
80138410:	10000005 	stb	zero,0(r2)
             break;
80138414:	00000c06 	br	80138448 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
80138418:	e0bfff17 	ldw	r2,-4(fp)
8013841c:	00c00384 	movi	r3,14
80138420:	10c00005 	stb	r3,0(r2)
             break;
80138424:	00000806 	br	80138448 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
80138428:	d0a0ab17 	ldw	r2,-32084(gp)
8013842c:	e17ffd17 	ldw	r5,-12(fp)
80138430:	1009883a 	mov	r4,r2
80138434:	01349a00 	call	801349a0 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
80138438:	e0bfff17 	ldw	r2,-4(fp)
8013843c:	00c00284 	movi	r3,10
80138440:	10c00005 	stb	r3,0(r2)
             break;
80138444:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
80138448:	d0a0ab17 	ldw	r2,-32084(gp)
8013844c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
80138450:	d0a0ab17 	ldw	r2,-32084(gp)
80138454:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
80138458:	d0a0ab17 	ldw	r2,-32084(gp)
8013845c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
80138460:	d0a0ab17 	ldw	r2,-32084(gp)
80138464:	10000815 	stw	zero,32(r2)
80138468:	e0bff117 	ldw	r2,-60(fp)
8013846c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80138470:	e0bffa17 	ldw	r2,-24(fp)
80138474:	1001703a 	wrctl	status,r2
80138478:	00000106 	br	80138480 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8013847c:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
80138480:	e037883a 	mov	sp,fp
80138484:	dfc00117 	ldw	ra,4(sp)
80138488:	df000017 	ldw	fp,0(sp)
8013848c:	dec00204 	addi	sp,sp,8
80138490:	f800283a 	ret

80138494 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
80138494:	defff604 	addi	sp,sp,-40
80138498:	de00012e 	bgeu	sp,et,801384a0 <OSMutexPost+0xc>
8013849c:	003b68fa 	trap	3
801384a0:	dfc00915 	stw	ra,36(sp)
801384a4:	df000815 	stw	fp,32(sp)
801384a8:	df000804 	addi	fp,sp,32
801384ac:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
801384b0:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
801384b4:	d0a0aa03 	ldbu	r2,-32088(gp)
801384b8:	10803fcc 	andi	r2,r2,255
801384bc:	10000226 	beq	r2,zero,801384c8 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
801384c0:	00800144 	movi	r2,5
801384c4:	00007606 	br	801386a0 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
801384c8:	e0bfff17 	ldw	r2,-4(fp)
801384cc:	1000021e 	bne	r2,zero,801384d8 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
801384d0:	00800104 	movi	r2,4
801384d4:	00007206 	br	801386a0 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
801384d8:	e0bfff17 	ldw	r2,-4(fp)
801384dc:	10800003 	ldbu	r2,0(r2)
801384e0:	10803fcc 	andi	r2,r2,255
801384e4:	10800120 	cmpeqi	r2,r2,4
801384e8:	1000021e 	bne	r2,zero,801384f4 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
801384ec:	00800044 	movi	r2,1
801384f0:	00006b06 	br	801386a0 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801384f4:	0005303a 	rdctl	r2,status
801384f8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801384fc:	e0fffe17 	ldw	r3,-8(fp)
80138500:	00bfff84 	movi	r2,-2
80138504:	1884703a 	and	r2,r3,r2
80138508:	1001703a 	wrctl	status,r2
  
  return context;
8013850c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
80138510:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
80138514:	e0bfff17 	ldw	r2,-4(fp)
80138518:	1080020b 	ldhu	r2,8(r2)
8013851c:	10bfffcc 	andi	r2,r2,65535
80138520:	1004d23a 	srli	r2,r2,8
80138524:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
80138528:	e0bfff17 	ldw	r2,-4(fp)
8013852c:	1080020b 	ldhu	r2,8(r2)
80138530:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
80138534:	e0bfff17 	ldw	r2,-4(fp)
80138538:	10c00117 	ldw	r3,4(r2)
8013853c:	d0a0ab17 	ldw	r2,-32084(gp)
80138540:	18800626 	beq	r3,r2,8013855c <OSMutexPost+0xc8>
80138544:	e0bff817 	ldw	r2,-32(fp)
80138548:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013854c:	e0bff917 	ldw	r2,-28(fp)
80138550:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
80138554:	00801904 	movi	r2,100
80138558:	00005106 	br	801386a0 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8013855c:	d0a0ab17 	ldw	r2,-32084(gp)
80138560:	10800c83 	ldbu	r2,50(r2)
80138564:	10c03fcc 	andi	r3,r2,255
80138568:	e0bffa03 	ldbu	r2,-24(fp)
8013856c:	1880051e 	bne	r3,r2,80138584 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
80138570:	d0a0ab17 	ldw	r2,-32084(gp)
80138574:	e0fffa43 	ldbu	r3,-23(fp)
80138578:	180b883a 	mov	r5,r3
8013857c:	1009883a 	mov	r4,r2
80138580:	01388280 	call	80138828 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
80138584:	e0fffa03 	ldbu	r3,-24(fp)
80138588:	00a005b4 	movhi	r2,32790
8013858c:	10924b04 	addi	r2,r2,18732
80138590:	18c7883a 	add	r3,r3,r3
80138594:	18c7883a 	add	r3,r3,r3
80138598:	10c5883a 	add	r2,r2,r3
8013859c:	00c00044 	movi	r3,1
801385a0:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
801385a4:	e0bfff17 	ldw	r2,-4(fp)
801385a8:	10800283 	ldbu	r2,10(r2)
801385ac:	10803fcc 	andi	r2,r2,255
801385b0:	10002e26 	beq	r2,zero,8013866c <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
801385b4:	000f883a 	mov	r7,zero
801385b8:	01800404 	movi	r6,16
801385bc:	000b883a 	mov	r5,zero
801385c0:	e13fff17 	ldw	r4,-4(fp)
801385c4:	01345900 	call	80134590 <OS_EventTaskRdy>
801385c8:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
801385cc:	e0bfff17 	ldw	r2,-4(fp)
801385d0:	10c0020b 	ldhu	r3,8(r2)
801385d4:	00bfc004 	movi	r2,-256
801385d8:	1884703a 	and	r2,r3,r2
801385dc:	1007883a 	mov	r3,r2
801385e0:	e0bfff17 	ldw	r2,-4(fp)
801385e4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
801385e8:	e0bfff17 	ldw	r2,-4(fp)
801385ec:	10c0020b 	ldhu	r3,8(r2)
801385f0:	e0bffa43 	ldbu	r2,-23(fp)
801385f4:	1884b03a 	or	r2,r3,r2
801385f8:	1007883a 	mov	r3,r2
801385fc:	e0bfff17 	ldw	r2,-4(fp)
80138600:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
80138604:	e0fffa43 	ldbu	r3,-23(fp)
80138608:	00a005b4 	movhi	r2,32790
8013860c:	10924b04 	addi	r2,r2,18732
80138610:	18c7883a 	add	r3,r3,r3
80138614:	18c7883a 	add	r3,r3,r3
80138618:	10c5883a 	add	r2,r2,r3
8013861c:	10c00017 	ldw	r3,0(r2)
80138620:	e0bfff17 	ldw	r2,-4(fp)
80138624:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
80138628:	e0bffa43 	ldbu	r2,-23(fp)
8013862c:	e0fffa03 	ldbu	r3,-24(fp)
80138630:	18800736 	bltu	r3,r2,80138650 <OSMutexPost+0x1bc>
80138634:	e0bff817 	ldw	r2,-32(fp)
80138638:	e0bffb15 	stw	r2,-20(fp)
8013863c:	e0bffb17 	ldw	r2,-20(fp)
80138640:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
80138644:	013504c0 	call	8013504c <OS_Sched>
            return (OS_ERR_PIP_LOWER);
80138648:	00801e04 	movi	r2,120
8013864c:	00001406 	br	801386a0 <OSMutexPost+0x20c>
80138650:	e0bff817 	ldw	r2,-32(fp)
80138654:	e0bffc15 	stw	r2,-16(fp)
80138658:	e0bffc17 	ldw	r2,-16(fp)
8013865c:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
80138660:	013504c0 	call	8013504c <OS_Sched>
            return (OS_ERR_NONE);
80138664:	0005883a 	mov	r2,zero
80138668:	00000d06 	br	801386a0 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8013866c:	e0bfff17 	ldw	r2,-4(fp)
80138670:	1080020b 	ldhu	r2,8(r2)
80138674:	10803fd4 	ori	r2,r2,255
80138678:	1007883a 	mov	r3,r2
8013867c:	e0bfff17 	ldw	r2,-4(fp)
80138680:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
80138684:	e0bfff17 	ldw	r2,-4(fp)
80138688:	10000115 	stw	zero,4(r2)
8013868c:	e0bff817 	ldw	r2,-32(fp)
80138690:	e0bffd15 	stw	r2,-12(fp)
80138694:	e0bffd17 	ldw	r2,-12(fp)
80138698:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8013869c:	0005883a 	mov	r2,zero
}
801386a0:	e037883a 	mov	sp,fp
801386a4:	dfc00117 	ldw	ra,4(sp)
801386a8:	df000017 	ldw	fp,0(sp)
801386ac:	dec00204 	addi	sp,sp,8
801386b0:	f800283a 	ret

801386b4 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
801386b4:	defff704 	addi	sp,sp,-36
801386b8:	de00012e 	bgeu	sp,et,801386c0 <OSMutexQuery+0xc>
801386bc:	003b68fa 	trap	3
801386c0:	df000815 	stw	fp,32(sp)
801386c4:	df000804 	addi	fp,sp,32
801386c8:	e13ffe15 	stw	r4,-8(fp)
801386cc:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801386d0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
801386d4:	d0a0aa03 	ldbu	r2,-32088(gp)
801386d8:	10803fcc 	andi	r2,r2,255
801386dc:	10000226 	beq	r2,zero,801386e8 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
801386e0:	00800184 	movi	r2,6
801386e4:	00004c06 	br	80138818 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
801386e8:	e0bffe17 	ldw	r2,-8(fp)
801386ec:	1000021e 	bne	r2,zero,801386f8 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
801386f0:	00800104 	movi	r2,4
801386f4:	00004806 	br	80138818 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
801386f8:	e0bfff17 	ldw	r2,-4(fp)
801386fc:	1000021e 	bne	r2,zero,80138708 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
80138700:	00800244 	movi	r2,9
80138704:	00004406 	br	80138818 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
80138708:	e0bffe17 	ldw	r2,-8(fp)
8013870c:	10800003 	ldbu	r2,0(r2)
80138710:	10803fcc 	andi	r2,r2,255
80138714:	10800120 	cmpeqi	r2,r2,4
80138718:	1000021e 	bne	r2,zero,80138724 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8013871c:	00800044 	movi	r2,1
80138720:	00003d06 	br	80138818 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80138724:	0005303a 	rdctl	r2,status
80138728:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013872c:	e0fffd17 	ldw	r3,-12(fp)
80138730:	00bfff84 	movi	r2,-2
80138734:	1884703a 	and	r2,r3,r2
80138738:	1001703a 	wrctl	status,r2
  
  return context;
8013873c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
80138740:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
80138744:	e0bffe17 	ldw	r2,-8(fp)
80138748:	1080020b 	ldhu	r2,8(r2)
8013874c:	10bfffcc 	andi	r2,r2,65535
80138750:	1004d23a 	srli	r2,r2,8
80138754:	1007883a 	mov	r3,r2
80138758:	e0bfff17 	ldw	r2,-4(fp)
8013875c:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
80138760:	e0bffe17 	ldw	r2,-8(fp)
80138764:	1080020b 	ldhu	r2,8(r2)
80138768:	1007883a 	mov	r3,r2
8013876c:	e0bfff17 	ldw	r2,-4(fp)
80138770:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
80138774:	e0bfff17 	ldw	r2,-4(fp)
80138778:	10800203 	ldbu	r2,8(r2)
8013877c:	10803fcc 	andi	r2,r2,255
80138780:	10803fd8 	cmpnei	r2,r2,255
80138784:	1000041e 	bne	r2,zero,80138798 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
80138788:	e0bfff17 	ldw	r2,-4(fp)
8013878c:	00c00044 	movi	r3,1
80138790:	10c001c5 	stb	r3,7(r2)
80138794:	00000206 	br	801387a0 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
80138798:	e0bfff17 	ldw	r2,-4(fp)
8013879c:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
801387a0:	e0bffe17 	ldw	r2,-8(fp)
801387a4:	10c00283 	ldbu	r3,10(r2)
801387a8:	e0bfff17 	ldw	r2,-4(fp)
801387ac:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
801387b0:	e0bffe17 	ldw	r2,-8(fp)
801387b4:	108002c4 	addi	r2,r2,11
801387b8:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
801387bc:	e0bfff17 	ldw	r2,-4(fp)
801387c0:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
801387c4:	e03ff805 	stb	zero,-32(fp)
801387c8:	00000b06 	br	801387f8 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
801387cc:	e0bffa17 	ldw	r2,-24(fp)
801387d0:	10c00044 	addi	r3,r2,1
801387d4:	e0fffa15 	stw	r3,-24(fp)
801387d8:	e0fff917 	ldw	r3,-28(fp)
801387dc:	19000044 	addi	r4,r3,1
801387e0:	e13ff915 	stw	r4,-28(fp)
801387e4:	18c00003 	ldbu	r3,0(r3)
801387e8:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
801387ec:	e0bff803 	ldbu	r2,-32(fp)
801387f0:	10800044 	addi	r2,r2,1
801387f4:	e0bff805 	stb	r2,-32(fp)
801387f8:	e0bff803 	ldbu	r2,-32(fp)
801387fc:	108001b0 	cmpltui	r2,r2,6
80138800:	103ff21e 	bne	r2,zero,801387cc <__reset+0xfa1187cc>
80138804:	e0bffb17 	ldw	r2,-20(fp)
80138808:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013880c:	e0bffc17 	ldw	r2,-16(fp)
80138810:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
80138814:	0005883a 	mov	r2,zero
}
80138818:	e037883a 	mov	sp,fp
8013881c:	df000017 	ldw	fp,0(sp)
80138820:	dec00104 	addi	sp,sp,4
80138824:	f800283a 	ret

80138828 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
80138828:	defffc04 	addi	sp,sp,-16
8013882c:	de00012e 	bgeu	sp,et,80138834 <OSMutex_RdyAtPrio+0xc>
80138830:	003b68fa 	trap	3
80138834:	df000315 	stw	fp,12(sp)
80138838:	df000304 	addi	fp,sp,12
8013883c:	e13ffe15 	stw	r4,-8(fp)
80138840:	2805883a 	mov	r2,r5
80138844:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
80138848:	e0bffe17 	ldw	r2,-8(fp)
8013884c:	10800d03 	ldbu	r2,52(r2)
80138850:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
80138854:	e0fffd03 	ldbu	r3,-12(fp)
80138858:	e13ffd03 	ldbu	r4,-12(fp)
8013885c:	d0a0a744 	addi	r2,gp,-32099
80138860:	2085883a 	add	r2,r4,r2
80138864:	10800003 	ldbu	r2,0(r2)
80138868:	1009883a 	mov	r4,r2
8013886c:	e0bffe17 	ldw	r2,-8(fp)
80138870:	10800d43 	ldbu	r2,53(r2)
80138874:	0084303a 	nor	r2,zero,r2
80138878:	2084703a 	and	r2,r4,r2
8013887c:	1009883a 	mov	r4,r2
80138880:	d0a0a744 	addi	r2,gp,-32099
80138884:	1885883a 	add	r2,r3,r2
80138888:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8013888c:	e0fffd03 	ldbu	r3,-12(fp)
80138890:	d0a0a744 	addi	r2,gp,-32099
80138894:	1885883a 	add	r2,r3,r2
80138898:	10800003 	ldbu	r2,0(r2)
8013889c:	10803fcc 	andi	r2,r2,255
801388a0:	1000071e 	bne	r2,zero,801388c0 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
801388a4:	e0bffe17 	ldw	r2,-8(fp)
801388a8:	10800d83 	ldbu	r2,54(r2)
801388ac:	0084303a 	nor	r2,zero,r2
801388b0:	1007883a 	mov	r3,r2
801388b4:	d0a0a703 	ldbu	r2,-32100(gp)
801388b8:	1884703a 	and	r2,r3,r2
801388bc:	d0a0a705 	stb	r2,-32100(gp)
    }
    ptcb->OSTCBPrio         = prio;
801388c0:	e0bffe17 	ldw	r2,-8(fp)
801388c4:	e0ffff03 	ldbu	r3,-4(fp)
801388c8:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
801388cc:	e0bfff03 	ldbu	r2,-4(fp)
801388d0:	1004d0fa 	srli	r2,r2,3
801388d4:	108001cc 	andi	r2,r2,7
801388d8:	1007883a 	mov	r3,r2
801388dc:	e0bffe17 	ldw	r2,-8(fp)
801388e0:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
801388e4:	e0bfff03 	ldbu	r2,-4(fp)
801388e8:	108001cc 	andi	r2,r2,7
801388ec:	1007883a 	mov	r3,r2
801388f0:	e0bffe17 	ldw	r2,-8(fp)
801388f4:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
801388f8:	e0bffe17 	ldw	r2,-8(fp)
801388fc:	10800d03 	ldbu	r2,52(r2)
80138900:	10803fcc 	andi	r2,r2,255
80138904:	00c00044 	movi	r3,1
80138908:	1884983a 	sll	r2,r3,r2
8013890c:	1007883a 	mov	r3,r2
80138910:	e0bffe17 	ldw	r2,-8(fp)
80138914:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
80138918:	e0bffe17 	ldw	r2,-8(fp)
8013891c:	10800cc3 	ldbu	r2,51(r2)
80138920:	10803fcc 	andi	r2,r2,255
80138924:	00c00044 	movi	r3,1
80138928:	1884983a 	sll	r2,r3,r2
8013892c:	1007883a 	mov	r3,r2
80138930:	e0bffe17 	ldw	r2,-8(fp)
80138934:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
80138938:	e0bffe17 	ldw	r2,-8(fp)
8013893c:	10c00d83 	ldbu	r3,54(r2)
80138940:	d0a0a703 	ldbu	r2,-32100(gp)
80138944:	1884b03a 	or	r2,r3,r2
80138948:	d0a0a705 	stb	r2,-32100(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8013894c:	e0bffe17 	ldw	r2,-8(fp)
80138950:	10800d03 	ldbu	r2,52(r2)
80138954:	10c03fcc 	andi	r3,r2,255
80138958:	e0bffe17 	ldw	r2,-8(fp)
8013895c:	10800d03 	ldbu	r2,52(r2)
80138960:	11003fcc 	andi	r4,r2,255
80138964:	d0a0a744 	addi	r2,gp,-32099
80138968:	2085883a 	add	r2,r4,r2
8013896c:	11000003 	ldbu	r4,0(r2)
80138970:	e0bffe17 	ldw	r2,-8(fp)
80138974:	10800d43 	ldbu	r2,53(r2)
80138978:	2084b03a 	or	r2,r4,r2
8013897c:	1009883a 	mov	r4,r2
80138980:	d0a0a744 	addi	r2,gp,-32099
80138984:	1885883a 	add	r2,r3,r2
80138988:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8013898c:	e0ffff03 	ldbu	r3,-4(fp)
80138990:	00a005b4 	movhi	r2,32790
80138994:	10924b04 	addi	r2,r2,18732
80138998:	18c7883a 	add	r3,r3,r3
8013899c:	18c7883a 	add	r3,r3,r3
801389a0:	10c5883a 	add	r2,r2,r3
801389a4:	e0fffe17 	ldw	r3,-8(fp)
801389a8:	10c00015 	stw	r3,0(r2)
}
801389ac:	0001883a 	nop
801389b0:	e037883a 	mov	sp,fp
801389b4:	df000017 	ldw	fp,0(sp)
801389b8:	dec00104 	addi	sp,sp,4
801389bc:	f800283a 	ret

801389c0 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
801389c0:	defff804 	addi	sp,sp,-32
801389c4:	de00012e 	bgeu	sp,et,801389cc <OSQAccept+0xc>
801389c8:	003b68fa 	trap	3
801389cc:	df000715 	stw	fp,28(sp)
801389d0:	df000704 	addi	fp,sp,28
801389d4:	e13ffe15 	stw	r4,-8(fp)
801389d8:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
801389dc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
801389e0:	e0bfff17 	ldw	r2,-4(fp)
801389e4:	1000021e 	bne	r2,zero,801389f0 <OSQAccept+0x30>
        return ((void *)0);
801389e8:	0005883a 	mov	r2,zero
801389ec:	00004206 	br	80138af8 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
801389f0:	e0bffe17 	ldw	r2,-8(fp)
801389f4:	1000051e 	bne	r2,zero,80138a0c <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
801389f8:	e0bfff17 	ldw	r2,-4(fp)
801389fc:	00c00104 	movi	r3,4
80138a00:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
80138a04:	0005883a 	mov	r2,zero
80138a08:	00003b06 	br	80138af8 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
80138a0c:	e0bffe17 	ldw	r2,-8(fp)
80138a10:	10800003 	ldbu	r2,0(r2)
80138a14:	10803fcc 	andi	r2,r2,255
80138a18:	108000a0 	cmpeqi	r2,r2,2
80138a1c:	1000051e 	bne	r2,zero,80138a34 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
80138a20:	e0bfff17 	ldw	r2,-4(fp)
80138a24:	00c00044 	movi	r3,1
80138a28:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
80138a2c:	0005883a 	mov	r2,zero
80138a30:	00003106 	br	80138af8 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80138a34:	0005303a 	rdctl	r2,status
80138a38:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80138a3c:	e0fffd17 	ldw	r3,-12(fp)
80138a40:	00bfff84 	movi	r2,-2
80138a44:	1884703a 	and	r2,r3,r2
80138a48:	1001703a 	wrctl	status,r2
  
  return context;
80138a4c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
80138a50:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
80138a54:	e0bffe17 	ldw	r2,-8(fp)
80138a58:	10800117 	ldw	r2,4(r2)
80138a5c:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
80138a60:	e0bffc17 	ldw	r2,-16(fp)
80138a64:	1080058b 	ldhu	r2,22(r2)
80138a68:	10bfffcc 	andi	r2,r2,65535
80138a6c:	10001926 	beq	r2,zero,80138ad4 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
80138a70:	e0bffc17 	ldw	r2,-16(fp)
80138a74:	10800417 	ldw	r2,16(r2)
80138a78:	11000104 	addi	r4,r2,4
80138a7c:	e0fffc17 	ldw	r3,-16(fp)
80138a80:	19000415 	stw	r4,16(r3)
80138a84:	10800017 	ldw	r2,0(r2)
80138a88:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
80138a8c:	e0bffc17 	ldw	r2,-16(fp)
80138a90:	1080058b 	ldhu	r2,22(r2)
80138a94:	10bfffc4 	addi	r2,r2,-1
80138a98:	1007883a 	mov	r3,r2
80138a9c:	e0bffc17 	ldw	r2,-16(fp)
80138aa0:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
80138aa4:	e0bffc17 	ldw	r2,-16(fp)
80138aa8:	10c00417 	ldw	r3,16(r2)
80138aac:	e0bffc17 	ldw	r2,-16(fp)
80138ab0:	10800217 	ldw	r2,8(r2)
80138ab4:	1880041e 	bne	r3,r2,80138ac8 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
80138ab8:	e0bffc17 	ldw	r2,-16(fp)
80138abc:	10c00117 	ldw	r3,4(r2)
80138ac0:	e0bffc17 	ldw	r2,-16(fp)
80138ac4:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
80138ac8:	e0bfff17 	ldw	r2,-4(fp)
80138acc:	10000005 	stb	zero,0(r2)
80138ad0:	00000406 	br	80138ae4 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
80138ad4:	e0bfff17 	ldw	r2,-4(fp)
80138ad8:	00c007c4 	movi	r3,31
80138adc:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
80138ae0:	e03ff915 	stw	zero,-28(fp)
80138ae4:	e0bffa17 	ldw	r2,-24(fp)
80138ae8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80138aec:	e0bffb17 	ldw	r2,-20(fp)
80138af0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
80138af4:	e0bff917 	ldw	r2,-28(fp)
}
80138af8:	e037883a 	mov	sp,fp
80138afc:	df000017 	ldw	fp,0(sp)
80138b00:	dec00104 	addi	sp,sp,4
80138b04:	f800283a 	ret

80138b08 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
80138b08:	defff404 	addi	sp,sp,-48
80138b0c:	de00012e 	bgeu	sp,et,80138b14 <OSQCreate+0xc>
80138b10:	003b68fa 	trap	3
80138b14:	dfc00b15 	stw	ra,44(sp)
80138b18:	df000a15 	stw	fp,40(sp)
80138b1c:	df000a04 	addi	fp,sp,40
80138b20:	e13ffe15 	stw	r4,-8(fp)
80138b24:	2805883a 	mov	r2,r5
80138b28:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
80138b2c:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
80138b30:	d0a0aa03 	ldbu	r2,-32088(gp)
80138b34:	10803fcc 	andi	r2,r2,255
80138b38:	10000226 	beq	r2,zero,80138b44 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
80138b3c:	0005883a 	mov	r2,zero
80138b40:	00005906 	br	80138ca8 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80138b44:	0005303a 	rdctl	r2,status
80138b48:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80138b4c:	e0fffd17 	ldw	r3,-12(fp)
80138b50:	00bfff84 	movi	r2,-2
80138b54:	1884703a 	and	r2,r3,r2
80138b58:	1001703a 	wrctl	status,r2
  
  return context;
80138b5c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
80138b60:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
80138b64:	d0a0a917 	ldw	r2,-32092(gp)
80138b68:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
80138b6c:	d0a0a917 	ldw	r2,-32092(gp)
80138b70:	10000326 	beq	r2,zero,80138b80 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
80138b74:	d0a0a917 	ldw	r2,-32092(gp)
80138b78:	10800117 	ldw	r2,4(r2)
80138b7c:	d0a0a915 	stw	r2,-32092(gp)
80138b80:	e0bff717 	ldw	r2,-36(fp)
80138b84:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80138b88:	e0bff817 	ldw	r2,-32(fp)
80138b8c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
80138b90:	e0bff617 	ldw	r2,-40(fp)
80138b94:	10004326 	beq	r2,zero,80138ca4 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80138b98:	0005303a 	rdctl	r2,status
80138b9c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80138ba0:	e0fff917 	ldw	r3,-28(fp)
80138ba4:	00bfff84 	movi	r2,-2
80138ba8:	1884703a 	and	r2,r3,r2
80138bac:	1001703a 	wrctl	status,r2
  
  return context;
80138bb0:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
80138bb4:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
80138bb8:	d0a0a617 	ldw	r2,-32104(gp)
80138bbc:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
80138bc0:	e0bffb17 	ldw	r2,-20(fp)
80138bc4:	10002d26 	beq	r2,zero,80138c7c <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
80138bc8:	d0a0a617 	ldw	r2,-32104(gp)
80138bcc:	10800017 	ldw	r2,0(r2)
80138bd0:	d0a0a615 	stw	r2,-32104(gp)
80138bd4:	e0bff717 	ldw	r2,-36(fp)
80138bd8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80138bdc:	e0bffa17 	ldw	r2,-24(fp)
80138be0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
80138be4:	e0bffb17 	ldw	r2,-20(fp)
80138be8:	e0fffe17 	ldw	r3,-8(fp)
80138bec:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
80138bf0:	e0bfff0b 	ldhu	r2,-4(fp)
80138bf4:	1085883a 	add	r2,r2,r2
80138bf8:	1085883a 	add	r2,r2,r2
80138bfc:	1007883a 	mov	r3,r2
80138c00:	e0bffe17 	ldw	r2,-8(fp)
80138c04:	10c7883a 	add	r3,r2,r3
80138c08:	e0bffb17 	ldw	r2,-20(fp)
80138c0c:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
80138c10:	e0bffb17 	ldw	r2,-20(fp)
80138c14:	e0fffe17 	ldw	r3,-8(fp)
80138c18:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
80138c1c:	e0bffb17 	ldw	r2,-20(fp)
80138c20:	e0fffe17 	ldw	r3,-8(fp)
80138c24:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
80138c28:	e0bffb17 	ldw	r2,-20(fp)
80138c2c:	e0ffff0b 	ldhu	r3,-4(fp)
80138c30:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
80138c34:	e0bffb17 	ldw	r2,-20(fp)
80138c38:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
80138c3c:	e0bff617 	ldw	r2,-40(fp)
80138c40:	00c00084 	movi	r3,2
80138c44:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
80138c48:	e0bff617 	ldw	r2,-40(fp)
80138c4c:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
80138c50:	e0bff617 	ldw	r2,-40(fp)
80138c54:	e0fffb17 	ldw	r3,-20(fp)
80138c58:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
80138c5c:	e0bff617 	ldw	r2,-40(fp)
80138c60:	00c00fc4 	movi	r3,63
80138c64:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
80138c68:	e0bff617 	ldw	r2,-40(fp)
80138c6c:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
80138c70:	e13ff617 	ldw	r4,-40(fp)
80138c74:	0134b680 	call	80134b68 <OS_EventWaitListInit>
80138c78:	00000a06 	br	80138ca4 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
80138c7c:	d0e0a917 	ldw	r3,-32092(gp)
80138c80:	e0bff617 	ldw	r2,-40(fp)
80138c84:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
80138c88:	e0bff617 	ldw	r2,-40(fp)
80138c8c:	d0a0a915 	stw	r2,-32092(gp)
80138c90:	e0bff717 	ldw	r2,-36(fp)
80138c94:	e0bffc15 	stw	r2,-16(fp)
80138c98:	e0bffc17 	ldw	r2,-16(fp)
80138c9c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
80138ca0:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
80138ca4:	e0bff617 	ldw	r2,-40(fp)
}
80138ca8:	e037883a 	mov	sp,fp
80138cac:	dfc00117 	ldw	ra,4(sp)
80138cb0:	df000017 	ldw	fp,0(sp)
80138cb4:	dec00204 	addi	sp,sp,8
80138cb8:	f800283a 	ret

80138cbc <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
80138cbc:	defff204 	addi	sp,sp,-56
80138cc0:	de00012e 	bgeu	sp,et,80138cc8 <OSQDel+0xc>
80138cc4:	003b68fa 	trap	3
80138cc8:	dfc00d15 	stw	ra,52(sp)
80138ccc:	df000c15 	stw	fp,48(sp)
80138cd0:	df000c04 	addi	fp,sp,48
80138cd4:	e13ffd15 	stw	r4,-12(fp)
80138cd8:	2805883a 	mov	r2,r5
80138cdc:	e1bfff15 	stw	r6,-4(fp)
80138ce0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
80138ce4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
80138ce8:	e0bfff17 	ldw	r2,-4(fp)
80138cec:	1000021e 	bne	r2,zero,80138cf8 <OSQDel+0x3c>
        return (pevent);
80138cf0:	e0bffd17 	ldw	r2,-12(fp)
80138cf4:	00008e06 	br	80138f30 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
80138cf8:	e0bffd17 	ldw	r2,-12(fp)
80138cfc:	1000051e 	bne	r2,zero,80138d14 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
80138d00:	e0bfff17 	ldw	r2,-4(fp)
80138d04:	00c00104 	movi	r3,4
80138d08:	10c00005 	stb	r3,0(r2)
        return (pevent);
80138d0c:	e0bffd17 	ldw	r2,-12(fp)
80138d10:	00008706 	br	80138f30 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
80138d14:	e0bffd17 	ldw	r2,-12(fp)
80138d18:	10800003 	ldbu	r2,0(r2)
80138d1c:	10803fcc 	andi	r2,r2,255
80138d20:	108000a0 	cmpeqi	r2,r2,2
80138d24:	1000051e 	bne	r2,zero,80138d3c <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
80138d28:	e0bfff17 	ldw	r2,-4(fp)
80138d2c:	00c00044 	movi	r3,1
80138d30:	10c00005 	stb	r3,0(r2)
        return (pevent);
80138d34:	e0bffd17 	ldw	r2,-12(fp)
80138d38:	00007d06 	br	80138f30 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
80138d3c:	d0a0aa03 	ldbu	r2,-32088(gp)
80138d40:	10803fcc 	andi	r2,r2,255
80138d44:	10000526 	beq	r2,zero,80138d5c <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
80138d48:	e0bfff17 	ldw	r2,-4(fp)
80138d4c:	00c003c4 	movi	r3,15
80138d50:	10c00005 	stb	r3,0(r2)
        return (pevent);
80138d54:	e0bffd17 	ldw	r2,-12(fp)
80138d58:	00007506 	br	80138f30 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80138d5c:	0005303a 	rdctl	r2,status
80138d60:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80138d64:	e0fffc17 	ldw	r3,-16(fp)
80138d68:	00bfff84 	movi	r2,-2
80138d6c:	1884703a 	and	r2,r3,r2
80138d70:	1001703a 	wrctl	status,r2
  
  return context;
80138d74:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80138d78:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
80138d7c:	e0bffd17 	ldw	r2,-12(fp)
80138d80:	10800283 	ldbu	r2,10(r2)
80138d84:	10803fcc 	andi	r2,r2,255
80138d88:	10000326 	beq	r2,zero,80138d98 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
80138d8c:	00800044 	movi	r2,1
80138d90:	e0bff405 	stb	r2,-48(fp)
80138d94:	00000106 	br	80138d9c <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
80138d98:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
80138d9c:	e0bffe03 	ldbu	r2,-8(fp)
80138da0:	10000326 	beq	r2,zero,80138db0 <OSQDel+0xf4>
80138da4:	10800060 	cmpeqi	r2,r2,1
80138da8:	1000301e 	bne	r2,zero,80138e6c <OSQDel+0x1b0>
80138dac:	00005506 	br	80138f04 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
80138db0:	e0bff403 	ldbu	r2,-48(fp)
80138db4:	10001e1e 	bne	r2,zero,80138e30 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
80138db8:	e0bffd17 	ldw	r2,-12(fp)
80138dbc:	00c00fc4 	movi	r3,63
80138dc0:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
80138dc4:	e0bffd17 	ldw	r2,-12(fp)
80138dc8:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
80138dcc:	e0bffd17 	ldw	r2,-12(fp)
80138dd0:	10800117 	ldw	r2,4(r2)
80138dd4:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
80138dd8:	d0e0a617 	ldw	r3,-32104(gp)
80138ddc:	e0bff817 	ldw	r2,-32(fp)
80138de0:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
80138de4:	e0bff817 	ldw	r2,-32(fp)
80138de8:	d0a0a615 	stw	r2,-32104(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
80138dec:	e0bffd17 	ldw	r2,-12(fp)
80138df0:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
80138df4:	d0e0a917 	ldw	r3,-32092(gp)
80138df8:	e0bffd17 	ldw	r2,-12(fp)
80138dfc:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
80138e00:	e0bffd17 	ldw	r2,-12(fp)
80138e04:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
80138e08:	e0bffd17 	ldw	r2,-12(fp)
80138e0c:	d0a0a915 	stw	r2,-32092(gp)
80138e10:	e0bff617 	ldw	r2,-40(fp)
80138e14:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80138e18:	e0bff717 	ldw	r2,-36(fp)
80138e1c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
80138e20:	e0bfff17 	ldw	r2,-4(fp)
80138e24:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
80138e28:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
80138e2c:	00003f06 	br	80138f2c <OSQDel+0x270>
80138e30:	e0bff617 	ldw	r2,-40(fp)
80138e34:	e0bff915 	stw	r2,-28(fp)
80138e38:	e0bff917 	ldw	r2,-28(fp)
80138e3c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
80138e40:	e0bfff17 	ldw	r2,-4(fp)
80138e44:	00c01244 	movi	r3,73
80138e48:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
80138e4c:	e0bffd17 	ldw	r2,-12(fp)
80138e50:	e0bff515 	stw	r2,-44(fp)
             }
             break;
80138e54:	00003506 	br	80138f2c <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
80138e58:	000f883a 	mov	r7,zero
80138e5c:	01800104 	movi	r6,4
80138e60:	000b883a 	mov	r5,zero
80138e64:	e13ffd17 	ldw	r4,-12(fp)
80138e68:	01345900 	call	80134590 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
80138e6c:	e0bffd17 	ldw	r2,-12(fp)
80138e70:	10800283 	ldbu	r2,10(r2)
80138e74:	10803fcc 	andi	r2,r2,255
80138e78:	103ff71e 	bne	r2,zero,80138e58 <__reset+0xfa118e58>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
80138e7c:	e0bffd17 	ldw	r2,-12(fp)
80138e80:	00c00fc4 	movi	r3,63
80138e84:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
80138e88:	e0bffd17 	ldw	r2,-12(fp)
80138e8c:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
80138e90:	e0bffd17 	ldw	r2,-12(fp)
80138e94:	10800117 	ldw	r2,4(r2)
80138e98:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
80138e9c:	d0e0a617 	ldw	r3,-32104(gp)
80138ea0:	e0bff817 	ldw	r2,-32(fp)
80138ea4:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
80138ea8:	e0bff817 	ldw	r2,-32(fp)
80138eac:	d0a0a615 	stw	r2,-32104(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
80138eb0:	e0bffd17 	ldw	r2,-12(fp)
80138eb4:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
80138eb8:	d0e0a917 	ldw	r3,-32092(gp)
80138ebc:	e0bffd17 	ldw	r2,-12(fp)
80138ec0:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
80138ec4:	e0bffd17 	ldw	r2,-12(fp)
80138ec8:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
80138ecc:	e0bffd17 	ldw	r2,-12(fp)
80138ed0:	d0a0a915 	stw	r2,-32092(gp)
80138ed4:	e0bff617 	ldw	r2,-40(fp)
80138ed8:	e0bffa15 	stw	r2,-24(fp)
80138edc:	e0bffa17 	ldw	r2,-24(fp)
80138ee0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
80138ee4:	e0bff403 	ldbu	r2,-48(fp)
80138ee8:	10800058 	cmpnei	r2,r2,1
80138eec:	1000011e 	bne	r2,zero,80138ef4 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
80138ef0:	013504c0 	call	8013504c <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
80138ef4:	e0bfff17 	ldw	r2,-4(fp)
80138ef8:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
80138efc:	e03ff515 	stw	zero,-44(fp)
             break;
80138f00:	00000a06 	br	80138f2c <OSQDel+0x270>
80138f04:	e0bff617 	ldw	r2,-40(fp)
80138f08:	e0bffb15 	stw	r2,-20(fp)
80138f0c:	e0bffb17 	ldw	r2,-20(fp)
80138f10:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
80138f14:	e0bfff17 	ldw	r2,-4(fp)
80138f18:	00c001c4 	movi	r3,7
80138f1c:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
80138f20:	e0bffd17 	ldw	r2,-12(fp)
80138f24:	e0bff515 	stw	r2,-44(fp)
             break;
80138f28:	0001883a 	nop
    }
    return (pevent_return);
80138f2c:	e0bff517 	ldw	r2,-44(fp)
}
80138f30:	e037883a 	mov	sp,fp
80138f34:	dfc00117 	ldw	ra,4(sp)
80138f38:	df000017 	ldw	fp,0(sp)
80138f3c:	dec00204 	addi	sp,sp,8
80138f40:	f800283a 	ret

80138f44 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
80138f44:	defffa04 	addi	sp,sp,-24
80138f48:	de00012e 	bgeu	sp,et,80138f50 <OSQFlush+0xc>
80138f4c:	003b68fa 	trap	3
80138f50:	df000515 	stw	fp,20(sp)
80138f54:	df000504 	addi	fp,sp,20
80138f58:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
80138f5c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
80138f60:	e0bfff17 	ldw	r2,-4(fp)
80138f64:	1000021e 	bne	r2,zero,80138f70 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
80138f68:	00800104 	movi	r2,4
80138f6c:	00002106 	br	80138ff4 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
80138f70:	e0bfff17 	ldw	r2,-4(fp)
80138f74:	10800003 	ldbu	r2,0(r2)
80138f78:	10803fcc 	andi	r2,r2,255
80138f7c:	108000a0 	cmpeqi	r2,r2,2
80138f80:	1000021e 	bne	r2,zero,80138f8c <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
80138f84:	00800044 	movi	r2,1
80138f88:	00001a06 	br	80138ff4 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80138f8c:	0005303a 	rdctl	r2,status
80138f90:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80138f94:	e0fffd17 	ldw	r3,-12(fp)
80138f98:	00bfff84 	movi	r2,-2
80138f9c:	1884703a 	and	r2,r3,r2
80138fa0:	1001703a 	wrctl	status,r2
  
  return context;
80138fa4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
80138fa8:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
80138fac:	e0bfff17 	ldw	r2,-4(fp)
80138fb0:	10800117 	ldw	r2,4(r2)
80138fb4:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
80138fb8:	e0bffc17 	ldw	r2,-16(fp)
80138fbc:	10c00117 	ldw	r3,4(r2)
80138fc0:	e0bffc17 	ldw	r2,-16(fp)
80138fc4:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
80138fc8:	e0bffc17 	ldw	r2,-16(fp)
80138fcc:	10c00117 	ldw	r3,4(r2)
80138fd0:	e0bffc17 	ldw	r2,-16(fp)
80138fd4:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
80138fd8:	e0bffc17 	ldw	r2,-16(fp)
80138fdc:	1000058d 	sth	zero,22(r2)
80138fe0:	e0bffb17 	ldw	r2,-20(fp)
80138fe4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80138fe8:	e0bffe17 	ldw	r2,-8(fp)
80138fec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
80138ff0:	0005883a 	mov	r2,zero
}
80138ff4:	e037883a 	mov	sp,fp
80138ff8:	df000017 	ldw	fp,0(sp)
80138ffc:	dec00104 	addi	sp,sp,4
80139000:	f800283a 	ret

80139004 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
80139004:	defff304 	addi	sp,sp,-52
80139008:	de00012e 	bgeu	sp,et,80139010 <OSQPend+0xc>
8013900c:	003b68fa 	trap	3
80139010:	dfc00c15 	stw	ra,48(sp)
80139014:	df000b15 	stw	fp,44(sp)
80139018:	df000b04 	addi	fp,sp,44
8013901c:	e13ffd15 	stw	r4,-12(fp)
80139020:	2805883a 	mov	r2,r5
80139024:	e1bfff15 	stw	r6,-4(fp)
80139028:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8013902c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
80139030:	e0bfff17 	ldw	r2,-4(fp)
80139034:	1000021e 	bne	r2,zero,80139040 <OSQPend+0x3c>
        return ((void *)0);
80139038:	0005883a 	mov	r2,zero
8013903c:	00009106 	br	80139284 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
80139040:	e0bffd17 	ldw	r2,-12(fp)
80139044:	1000051e 	bne	r2,zero,8013905c <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
80139048:	e0bfff17 	ldw	r2,-4(fp)
8013904c:	00c00104 	movi	r3,4
80139050:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
80139054:	0005883a 	mov	r2,zero
80139058:	00008a06 	br	80139284 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8013905c:	e0bffd17 	ldw	r2,-12(fp)
80139060:	10800003 	ldbu	r2,0(r2)
80139064:	10803fcc 	andi	r2,r2,255
80139068:	108000a0 	cmpeqi	r2,r2,2
8013906c:	1000051e 	bne	r2,zero,80139084 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
80139070:	e0bfff17 	ldw	r2,-4(fp)
80139074:	00c00044 	movi	r3,1
80139078:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8013907c:	0005883a 	mov	r2,zero
80139080:	00008006 	br	80139284 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
80139084:	d0a0aa03 	ldbu	r2,-32088(gp)
80139088:	10803fcc 	andi	r2,r2,255
8013908c:	10000526 	beq	r2,zero,801390a4 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
80139090:	e0bfff17 	ldw	r2,-4(fp)
80139094:	00c00084 	movi	r3,2
80139098:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8013909c:	0005883a 	mov	r2,zero
801390a0:	00007806 	br	80139284 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
801390a4:	d0a09803 	ldbu	r2,-32160(gp)
801390a8:	10803fcc 	andi	r2,r2,255
801390ac:	10000526 	beq	r2,zero,801390c4 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
801390b0:	e0bfff17 	ldw	r2,-4(fp)
801390b4:	00c00344 	movi	r3,13
801390b8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
801390bc:	0005883a 	mov	r2,zero
801390c0:	00007006 	br	80139284 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801390c4:	0005303a 	rdctl	r2,status
801390c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801390cc:	e0fffc17 	ldw	r3,-16(fp)
801390d0:	00bfff84 	movi	r2,-2
801390d4:	1884703a 	and	r2,r3,r2
801390d8:	1001703a 	wrctl	status,r2
  
  return context;
801390dc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
801390e0:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
801390e4:	e0bffd17 	ldw	r2,-12(fp)
801390e8:	10800117 	ldw	r2,4(r2)
801390ec:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
801390f0:	e0bff817 	ldw	r2,-32(fp)
801390f4:	1080058b 	ldhu	r2,22(r2)
801390f8:	10bfffcc 	andi	r2,r2,65535
801390fc:	10001e26 	beq	r2,zero,80139178 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
80139100:	e0bff817 	ldw	r2,-32(fp)
80139104:	10800417 	ldw	r2,16(r2)
80139108:	11000104 	addi	r4,r2,4
8013910c:	e0fff817 	ldw	r3,-32(fp)
80139110:	19000415 	stw	r4,16(r3)
80139114:	10800017 	ldw	r2,0(r2)
80139118:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8013911c:	e0bff817 	ldw	r2,-32(fp)
80139120:	1080058b 	ldhu	r2,22(r2)
80139124:	10bfffc4 	addi	r2,r2,-1
80139128:	1007883a 	mov	r3,r2
8013912c:	e0bff817 	ldw	r2,-32(fp)
80139130:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
80139134:	e0bff817 	ldw	r2,-32(fp)
80139138:	10c00417 	ldw	r3,16(r2)
8013913c:	e0bff817 	ldw	r2,-32(fp)
80139140:	10800217 	ldw	r2,8(r2)
80139144:	1880041e 	bne	r3,r2,80139158 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
80139148:	e0bff817 	ldw	r2,-32(fp)
8013914c:	10c00117 	ldw	r3,4(r2)
80139150:	e0bff817 	ldw	r2,-32(fp)
80139154:	10c00415 	stw	r3,16(r2)
80139158:	e0bff617 	ldw	r2,-40(fp)
8013915c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80139160:	e0bff717 	ldw	r2,-36(fp)
80139164:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
80139168:	e0bfff17 	ldw	r2,-4(fp)
8013916c:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
80139170:	e0bff517 	ldw	r2,-44(fp)
80139174:	00004306 	br	80139284 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
80139178:	d0a0ab17 	ldw	r2,-32084(gp)
8013917c:	d0e0ab17 	ldw	r3,-32084(gp)
80139180:	18c00c03 	ldbu	r3,48(r3)
80139184:	18c00114 	ori	r3,r3,4
80139188:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8013918c:	d0a0ab17 	ldw	r2,-32084(gp)
80139190:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
80139194:	d0a0ab17 	ldw	r2,-32084(gp)
80139198:	e0fffe0b 	ldhu	r3,-8(fp)
8013919c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
801391a0:	e13ffd17 	ldw	r4,-12(fp)
801391a4:	01347300 	call	80134730 <OS_EventTaskWait>
801391a8:	e0bff617 	ldw	r2,-40(fp)
801391ac:	e0bffb15 	stw	r2,-20(fp)
801391b0:	e0bffb17 	ldw	r2,-20(fp)
801391b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
801391b8:	013504c0 	call	8013504c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801391bc:	0005303a 	rdctl	r2,status
801391c0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801391c4:	e0fff917 	ldw	r3,-28(fp)
801391c8:	00bfff84 	movi	r2,-2
801391cc:	1884703a 	and	r2,r3,r2
801391d0:	1001703a 	wrctl	status,r2
  
  return context;
801391d4:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
801391d8:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
801391dc:	d0a0ab17 	ldw	r2,-32084(gp)
801391e0:	10800c43 	ldbu	r2,49(r2)
801391e4:	10803fcc 	andi	r2,r2,255
801391e8:	10000326 	beq	r2,zero,801391f8 <OSQPend+0x1f4>
801391ec:	108000a0 	cmpeqi	r2,r2,2
801391f0:	1000071e 	bne	r2,zero,80139210 <OSQPend+0x20c>
801391f4:	00000b06 	br	80139224 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
801391f8:	d0a0ab17 	ldw	r2,-32084(gp)
801391fc:	10800917 	ldw	r2,36(r2)
80139200:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
80139204:	e0bfff17 	ldw	r2,-4(fp)
80139208:	10000005 	stb	zero,0(r2)
             break;
8013920c:	00000e06 	br	80139248 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
80139210:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
80139214:	e0bfff17 	ldw	r2,-4(fp)
80139218:	00c00384 	movi	r3,14
8013921c:	10c00005 	stb	r3,0(r2)
             break;
80139220:	00000906 	br	80139248 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
80139224:	d0a0ab17 	ldw	r2,-32084(gp)
80139228:	e17ffd17 	ldw	r5,-12(fp)
8013922c:	1009883a 	mov	r4,r2
80139230:	01349a00 	call	801349a0 <OS_EventTaskRemove>
             pmsg = (void *)0;
80139234:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
80139238:	e0bfff17 	ldw	r2,-4(fp)
8013923c:	00c00284 	movi	r3,10
80139240:	10c00005 	stb	r3,0(r2)
             break;
80139244:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
80139248:	d0a0ab17 	ldw	r2,-32084(gp)
8013924c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
80139250:	d0a0ab17 	ldw	r2,-32084(gp)
80139254:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
80139258:	d0a0ab17 	ldw	r2,-32084(gp)
8013925c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
80139260:	d0a0ab17 	ldw	r2,-32084(gp)
80139264:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
80139268:	d0a0ab17 	ldw	r2,-32084(gp)
8013926c:	10000915 	stw	zero,36(r2)
80139270:	e0bff617 	ldw	r2,-40(fp)
80139274:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80139278:	e0bffa17 	ldw	r2,-24(fp)
8013927c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
80139280:	e0bff517 	ldw	r2,-44(fp)
}
80139284:	e037883a 	mov	sp,fp
80139288:	dfc00117 	ldw	ra,4(sp)
8013928c:	df000017 	ldw	fp,0(sp)
80139290:	dec00204 	addi	sp,sp,8
80139294:	f800283a 	ret

80139298 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
80139298:	defff604 	addi	sp,sp,-40
8013929c:	de00012e 	bgeu	sp,et,801392a4 <OSQPendAbort+0xc>
801392a0:	003b68fa 	trap	3
801392a4:	dfc00915 	stw	ra,36(sp)
801392a8:	df000815 	stw	fp,32(sp)
801392ac:	df000804 	addi	fp,sp,32
801392b0:	e13ffd15 	stw	r4,-12(fp)
801392b4:	2805883a 	mov	r2,r5
801392b8:	e1bfff15 	stw	r6,-4(fp)
801392bc:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
801392c0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
801392c4:	e0bfff17 	ldw	r2,-4(fp)
801392c8:	1000021e 	bne	r2,zero,801392d4 <OSQPendAbort+0x3c>
        return (0);
801392cc:	0005883a 	mov	r2,zero
801392d0:	00004906 	br	801393f8 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
801392d4:	e0bffd17 	ldw	r2,-12(fp)
801392d8:	1000051e 	bne	r2,zero,801392f0 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
801392dc:	e0bfff17 	ldw	r2,-4(fp)
801392e0:	00c00104 	movi	r3,4
801392e4:	10c00005 	stb	r3,0(r2)
        return (0);
801392e8:	0005883a 	mov	r2,zero
801392ec:	00004206 	br	801393f8 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
801392f0:	e0bffd17 	ldw	r2,-12(fp)
801392f4:	10800003 	ldbu	r2,0(r2)
801392f8:	10803fcc 	andi	r2,r2,255
801392fc:	108000a0 	cmpeqi	r2,r2,2
80139300:	1000051e 	bne	r2,zero,80139318 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
80139304:	e0bfff17 	ldw	r2,-4(fp)
80139308:	00c00044 	movi	r3,1
8013930c:	10c00005 	stb	r3,0(r2)
        return (0);
80139310:	0005883a 	mov	r2,zero
80139314:	00003806 	br	801393f8 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80139318:	0005303a 	rdctl	r2,status
8013931c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80139320:	e0fffc17 	ldw	r3,-16(fp)
80139324:	00bfff84 	movi	r2,-2
80139328:	1884703a 	and	r2,r3,r2
8013932c:	1001703a 	wrctl	status,r2
  
  return context;
80139330:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80139334:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
80139338:	e0bffd17 	ldw	r2,-12(fp)
8013933c:	10800283 	ldbu	r2,10(r2)
80139340:	10803fcc 	andi	r2,r2,255
80139344:	10002526 	beq	r2,zero,801393dc <OSQPendAbort+0x144>
        nbr_tasks = 0;
80139348:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8013934c:	e0bffe03 	ldbu	r2,-8(fp)
80139350:	10800060 	cmpeqi	r2,r2,1
80139354:	10000e26 	beq	r2,zero,80139390 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
80139358:	00000806 	br	8013937c <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8013935c:	01c00084 	movi	r7,2
80139360:	01800104 	movi	r6,4
80139364:	000b883a 	mov	r5,zero
80139368:	e13ffd17 	ldw	r4,-12(fp)
8013936c:	01345900 	call	80134590 <OS_EventTaskRdy>
                     nbr_tasks++;
80139370:	e0bff803 	ldbu	r2,-32(fp)
80139374:	10800044 	addi	r2,r2,1
80139378:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8013937c:	e0bffd17 	ldw	r2,-12(fp)
80139380:	10800283 	ldbu	r2,10(r2)
80139384:	10803fcc 	andi	r2,r2,255
80139388:	103ff41e 	bne	r2,zero,8013935c <__reset+0xfa11935c>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8013938c:	00000906 	br	801393b4 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
80139390:	01c00084 	movi	r7,2
80139394:	01800104 	movi	r6,4
80139398:	000b883a 	mov	r5,zero
8013939c:	e13ffd17 	ldw	r4,-12(fp)
801393a0:	01345900 	call	80134590 <OS_EventTaskRdy>
                 nbr_tasks++;
801393a4:	e0bff803 	ldbu	r2,-32(fp)
801393a8:	10800044 	addi	r2,r2,1
801393ac:	e0bff805 	stb	r2,-32(fp)
                 break;
801393b0:	0001883a 	nop
801393b4:	e0bff917 	ldw	r2,-28(fp)
801393b8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801393bc:	e0bffa17 	ldw	r2,-24(fp)
801393c0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
801393c4:	013504c0 	call	8013504c <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
801393c8:	e0bfff17 	ldw	r2,-4(fp)
801393cc:	00c00384 	movi	r3,14
801393d0:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
801393d4:	e0bff803 	ldbu	r2,-32(fp)
801393d8:	00000706 	br	801393f8 <OSQPendAbort+0x160>
801393dc:	e0bff917 	ldw	r2,-28(fp)
801393e0:	e0bffb15 	stw	r2,-20(fp)
801393e4:	e0bffb17 	ldw	r2,-20(fp)
801393e8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
801393ec:	e0bfff17 	ldw	r2,-4(fp)
801393f0:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
801393f4:	0005883a 	mov	r2,zero
}
801393f8:	e037883a 	mov	sp,fp
801393fc:	dfc00117 	ldw	ra,4(sp)
80139400:	df000017 	ldw	fp,0(sp)
80139404:	dec00204 	addi	sp,sp,8
80139408:	f800283a 	ret

8013940c <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8013940c:	defff604 	addi	sp,sp,-40
80139410:	de00012e 	bgeu	sp,et,80139418 <OSQPost+0xc>
80139414:	003b68fa 	trap	3
80139418:	dfc00915 	stw	ra,36(sp)
8013941c:	df000815 	stw	fp,32(sp)
80139420:	df000804 	addi	fp,sp,32
80139424:	e13ffe15 	stw	r4,-8(fp)
80139428:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8013942c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
80139430:	e0bffe17 	ldw	r2,-8(fp)
80139434:	1000021e 	bne	r2,zero,80139440 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
80139438:	00800104 	movi	r2,4
8013943c:	00004a06 	br	80139568 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
80139440:	e0bffe17 	ldw	r2,-8(fp)
80139444:	10800003 	ldbu	r2,0(r2)
80139448:	10803fcc 	andi	r2,r2,255
8013944c:	108000a0 	cmpeqi	r2,r2,2
80139450:	1000021e 	bne	r2,zero,8013945c <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
80139454:	00800044 	movi	r2,1
80139458:	00004306 	br	80139568 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013945c:	0005303a 	rdctl	r2,status
80139460:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80139464:	e0fffd17 	ldw	r3,-12(fp)
80139468:	00bfff84 	movi	r2,-2
8013946c:	1884703a 	and	r2,r3,r2
80139470:	1001703a 	wrctl	status,r2
  
  return context;
80139474:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
80139478:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8013947c:	e0bffe17 	ldw	r2,-8(fp)
80139480:	10800283 	ldbu	r2,10(r2)
80139484:	10803fcc 	andi	r2,r2,255
80139488:	10000c26 	beq	r2,zero,801394bc <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8013948c:	000f883a 	mov	r7,zero
80139490:	01800104 	movi	r6,4
80139494:	e17fff17 	ldw	r5,-4(fp)
80139498:	e13ffe17 	ldw	r4,-8(fp)
8013949c:	01345900 	call	80134590 <OS_EventTaskRdy>
801394a0:	e0bff817 	ldw	r2,-32(fp)
801394a4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801394a8:	e0bff917 	ldw	r2,-28(fp)
801394ac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
801394b0:	013504c0 	call	8013504c <OS_Sched>
        return (OS_ERR_NONE);
801394b4:	0005883a 	mov	r2,zero
801394b8:	00002b06 	br	80139568 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
801394bc:	e0bffe17 	ldw	r2,-8(fp)
801394c0:	10800117 	ldw	r2,4(r2)
801394c4:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
801394c8:	e0bffb17 	ldw	r2,-20(fp)
801394cc:	10c0058b 	ldhu	r3,22(r2)
801394d0:	e0bffb17 	ldw	r2,-20(fp)
801394d4:	1080050b 	ldhu	r2,20(r2)
801394d8:	18ffffcc 	andi	r3,r3,65535
801394dc:	10bfffcc 	andi	r2,r2,65535
801394e0:	18800636 	bltu	r3,r2,801394fc <OSQPost+0xf0>
801394e4:	e0bff817 	ldw	r2,-32(fp)
801394e8:	e0bffa15 	stw	r2,-24(fp)
801394ec:	e0bffa17 	ldw	r2,-24(fp)
801394f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
801394f4:	00800784 	movi	r2,30
801394f8:	00001b06 	br	80139568 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
801394fc:	e0bffb17 	ldw	r2,-20(fp)
80139500:	10800317 	ldw	r2,12(r2)
80139504:	11000104 	addi	r4,r2,4
80139508:	e0fffb17 	ldw	r3,-20(fp)
8013950c:	19000315 	stw	r4,12(r3)
80139510:	e0ffff17 	ldw	r3,-4(fp)
80139514:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
80139518:	e0bffb17 	ldw	r2,-20(fp)
8013951c:	1080058b 	ldhu	r2,22(r2)
80139520:	10800044 	addi	r2,r2,1
80139524:	1007883a 	mov	r3,r2
80139528:	e0bffb17 	ldw	r2,-20(fp)
8013952c:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
80139530:	e0bffb17 	ldw	r2,-20(fp)
80139534:	10c00317 	ldw	r3,12(r2)
80139538:	e0bffb17 	ldw	r2,-20(fp)
8013953c:	10800217 	ldw	r2,8(r2)
80139540:	1880041e 	bne	r3,r2,80139554 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
80139544:	e0bffb17 	ldw	r2,-20(fp)
80139548:	10c00117 	ldw	r3,4(r2)
8013954c:	e0bffb17 	ldw	r2,-20(fp)
80139550:	10c00315 	stw	r3,12(r2)
80139554:	e0bff817 	ldw	r2,-32(fp)
80139558:	e0bffc15 	stw	r2,-16(fp)
8013955c:	e0bffc17 	ldw	r2,-16(fp)
80139560:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
80139564:	0005883a 	mov	r2,zero
}
80139568:	e037883a 	mov	sp,fp
8013956c:	dfc00117 	ldw	ra,4(sp)
80139570:	df000017 	ldw	fp,0(sp)
80139574:	dec00204 	addi	sp,sp,8
80139578:	f800283a 	ret

8013957c <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8013957c:	defff604 	addi	sp,sp,-40
80139580:	de00012e 	bgeu	sp,et,80139588 <OSQPostFront+0xc>
80139584:	003b68fa 	trap	3
80139588:	dfc00915 	stw	ra,36(sp)
8013958c:	df000815 	stw	fp,32(sp)
80139590:	df000804 	addi	fp,sp,32
80139594:	e13ffe15 	stw	r4,-8(fp)
80139598:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8013959c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
801395a0:	e0bffe17 	ldw	r2,-8(fp)
801395a4:	1000021e 	bne	r2,zero,801395b0 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
801395a8:	00800104 	movi	r2,4
801395ac:	00004c06 	br	801396e0 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
801395b0:	e0bffe17 	ldw	r2,-8(fp)
801395b4:	10800003 	ldbu	r2,0(r2)
801395b8:	10803fcc 	andi	r2,r2,255
801395bc:	108000a0 	cmpeqi	r2,r2,2
801395c0:	1000021e 	bne	r2,zero,801395cc <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
801395c4:	00800044 	movi	r2,1
801395c8:	00004506 	br	801396e0 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801395cc:	0005303a 	rdctl	r2,status
801395d0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801395d4:	e0fffd17 	ldw	r3,-12(fp)
801395d8:	00bfff84 	movi	r2,-2
801395dc:	1884703a 	and	r2,r3,r2
801395e0:	1001703a 	wrctl	status,r2
  
  return context;
801395e4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
801395e8:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
801395ec:	e0bffe17 	ldw	r2,-8(fp)
801395f0:	10800283 	ldbu	r2,10(r2)
801395f4:	10803fcc 	andi	r2,r2,255
801395f8:	10000c26 	beq	r2,zero,8013962c <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
801395fc:	000f883a 	mov	r7,zero
80139600:	01800104 	movi	r6,4
80139604:	e17fff17 	ldw	r5,-4(fp)
80139608:	e13ffe17 	ldw	r4,-8(fp)
8013960c:	01345900 	call	80134590 <OS_EventTaskRdy>
80139610:	e0bff817 	ldw	r2,-32(fp)
80139614:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80139618:	e0bff917 	ldw	r2,-28(fp)
8013961c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
80139620:	013504c0 	call	8013504c <OS_Sched>
        return (OS_ERR_NONE);
80139624:	0005883a 	mov	r2,zero
80139628:	00002d06 	br	801396e0 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8013962c:	e0bffe17 	ldw	r2,-8(fp)
80139630:	10800117 	ldw	r2,4(r2)
80139634:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
80139638:	e0bffb17 	ldw	r2,-20(fp)
8013963c:	10c0058b 	ldhu	r3,22(r2)
80139640:	e0bffb17 	ldw	r2,-20(fp)
80139644:	1080050b 	ldhu	r2,20(r2)
80139648:	18ffffcc 	andi	r3,r3,65535
8013964c:	10bfffcc 	andi	r2,r2,65535
80139650:	18800636 	bltu	r3,r2,8013966c <OSQPostFront+0xf0>
80139654:	e0bff817 	ldw	r2,-32(fp)
80139658:	e0bffa15 	stw	r2,-24(fp)
8013965c:	e0bffa17 	ldw	r2,-24(fp)
80139660:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
80139664:	00800784 	movi	r2,30
80139668:	00001d06 	br	801396e0 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8013966c:	e0bffb17 	ldw	r2,-20(fp)
80139670:	10c00417 	ldw	r3,16(r2)
80139674:	e0bffb17 	ldw	r2,-20(fp)
80139678:	10800117 	ldw	r2,4(r2)
8013967c:	1880041e 	bne	r3,r2,80139690 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
80139680:	e0bffb17 	ldw	r2,-20(fp)
80139684:	10c00217 	ldw	r3,8(r2)
80139688:	e0bffb17 	ldw	r2,-20(fp)
8013968c:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
80139690:	e0bffb17 	ldw	r2,-20(fp)
80139694:	10800417 	ldw	r2,16(r2)
80139698:	10ffff04 	addi	r3,r2,-4
8013969c:	e0bffb17 	ldw	r2,-20(fp)
801396a0:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
801396a4:	e0bffb17 	ldw	r2,-20(fp)
801396a8:	10800417 	ldw	r2,16(r2)
801396ac:	e0ffff17 	ldw	r3,-4(fp)
801396b0:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
801396b4:	e0bffb17 	ldw	r2,-20(fp)
801396b8:	1080058b 	ldhu	r2,22(r2)
801396bc:	10800044 	addi	r2,r2,1
801396c0:	1007883a 	mov	r3,r2
801396c4:	e0bffb17 	ldw	r2,-20(fp)
801396c8:	10c0058d 	sth	r3,22(r2)
801396cc:	e0bff817 	ldw	r2,-32(fp)
801396d0:	e0bffc15 	stw	r2,-16(fp)
801396d4:	e0bffc17 	ldw	r2,-16(fp)
801396d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
801396dc:	0005883a 	mov	r2,zero
}
801396e0:	e037883a 	mov	sp,fp
801396e4:	dfc00117 	ldw	ra,4(sp)
801396e8:	df000017 	ldw	fp,0(sp)
801396ec:	dec00204 	addi	sp,sp,8
801396f0:	f800283a 	ret

801396f4 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
801396f4:	defff504 	addi	sp,sp,-44
801396f8:	de00012e 	bgeu	sp,et,80139700 <OSQPostOpt+0xc>
801396fc:	003b68fa 	trap	3
80139700:	dfc00a15 	stw	ra,40(sp)
80139704:	df000915 	stw	fp,36(sp)
80139708:	df000904 	addi	fp,sp,36
8013970c:	e13ffd15 	stw	r4,-12(fp)
80139710:	e17ffe15 	stw	r5,-8(fp)
80139714:	3005883a 	mov	r2,r6
80139718:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8013971c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
80139720:	e0bffd17 	ldw	r2,-12(fp)
80139724:	1000021e 	bne	r2,zero,80139730 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
80139728:	00800104 	movi	r2,4
8013972c:	00007106 	br	801398f4 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
80139730:	e0bffd17 	ldw	r2,-12(fp)
80139734:	10800003 	ldbu	r2,0(r2)
80139738:	10803fcc 	andi	r2,r2,255
8013973c:	108000a0 	cmpeqi	r2,r2,2
80139740:	1000021e 	bne	r2,zero,8013974c <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
80139744:	00800044 	movi	r2,1
80139748:	00006a06 	br	801398f4 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013974c:	0005303a 	rdctl	r2,status
80139750:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80139754:	e0fffc17 	ldw	r3,-16(fp)
80139758:	00bfff84 	movi	r2,-2
8013975c:	1884703a 	and	r2,r3,r2
80139760:	1001703a 	wrctl	status,r2
  
  return context;
80139764:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80139768:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8013976c:	e0bffd17 	ldw	r2,-12(fp)
80139770:	10800283 	ldbu	r2,10(r2)
80139774:	10803fcc 	andi	r2,r2,255
80139778:	10001d26 	beq	r2,zero,801397f0 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8013977c:	e0bfff03 	ldbu	r2,-4(fp)
80139780:	1080004c 	andi	r2,r2,1
80139784:	10000b26 	beq	r2,zero,801397b4 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
80139788:	00000506 	br	801397a0 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8013978c:	000f883a 	mov	r7,zero
80139790:	01800104 	movi	r6,4
80139794:	e17ffe17 	ldw	r5,-8(fp)
80139798:	e13ffd17 	ldw	r4,-12(fp)
8013979c:	01345900 	call	80134590 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
801397a0:	e0bffd17 	ldw	r2,-12(fp)
801397a4:	10800283 	ldbu	r2,10(r2)
801397a8:	10803fcc 	andi	r2,r2,255
801397ac:	103ff71e 	bne	r2,zero,8013978c <__reset+0xfa11978c>
801397b0:	00000506 	br	801397c8 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
801397b4:	000f883a 	mov	r7,zero
801397b8:	01800104 	movi	r6,4
801397bc:	e17ffe17 	ldw	r5,-8(fp)
801397c0:	e13ffd17 	ldw	r4,-12(fp)
801397c4:	01345900 	call	80134590 <OS_EventTaskRdy>
801397c8:	e0bff717 	ldw	r2,-36(fp)
801397cc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801397d0:	e0bff817 	ldw	r2,-32(fp)
801397d4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
801397d8:	e0bfff03 	ldbu	r2,-4(fp)
801397dc:	1080010c 	andi	r2,r2,4
801397e0:	1000011e 	bne	r2,zero,801397e8 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
801397e4:	013504c0 	call	8013504c <OS_Sched>
        }
        return (OS_ERR_NONE);
801397e8:	0005883a 	mov	r2,zero
801397ec:	00004106 	br	801398f4 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
801397f0:	e0bffd17 	ldw	r2,-12(fp)
801397f4:	10800117 	ldw	r2,4(r2)
801397f8:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
801397fc:	e0bffa17 	ldw	r2,-24(fp)
80139800:	10c0058b 	ldhu	r3,22(r2)
80139804:	e0bffa17 	ldw	r2,-24(fp)
80139808:	1080050b 	ldhu	r2,20(r2)
8013980c:	18ffffcc 	andi	r3,r3,65535
80139810:	10bfffcc 	andi	r2,r2,65535
80139814:	18800636 	bltu	r3,r2,80139830 <OSQPostOpt+0x13c>
80139818:	e0bff717 	ldw	r2,-36(fp)
8013981c:	e0bff915 	stw	r2,-28(fp)
80139820:	e0bff917 	ldw	r2,-28(fp)
80139824:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
80139828:	00800784 	movi	r2,30
8013982c:	00003106 	br	801398f4 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
80139830:	e0bfff03 	ldbu	r2,-4(fp)
80139834:	1080008c 	andi	r2,r2,2
80139838:	10001326 	beq	r2,zero,80139888 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8013983c:	e0bffa17 	ldw	r2,-24(fp)
80139840:	10c00417 	ldw	r3,16(r2)
80139844:	e0bffa17 	ldw	r2,-24(fp)
80139848:	10800117 	ldw	r2,4(r2)
8013984c:	1880041e 	bne	r3,r2,80139860 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
80139850:	e0bffa17 	ldw	r2,-24(fp)
80139854:	10c00217 	ldw	r3,8(r2)
80139858:	e0bffa17 	ldw	r2,-24(fp)
8013985c:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
80139860:	e0bffa17 	ldw	r2,-24(fp)
80139864:	10800417 	ldw	r2,16(r2)
80139868:	10ffff04 	addi	r3,r2,-4
8013986c:	e0bffa17 	ldw	r2,-24(fp)
80139870:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
80139874:	e0bffa17 	ldw	r2,-24(fp)
80139878:	10800417 	ldw	r2,16(r2)
8013987c:	e0fffe17 	ldw	r3,-8(fp)
80139880:	10c00015 	stw	r3,0(r2)
80139884:	00001006 	br	801398c8 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
80139888:	e0bffa17 	ldw	r2,-24(fp)
8013988c:	10800317 	ldw	r2,12(r2)
80139890:	11000104 	addi	r4,r2,4
80139894:	e0fffa17 	ldw	r3,-24(fp)
80139898:	19000315 	stw	r4,12(r3)
8013989c:	e0fffe17 	ldw	r3,-8(fp)
801398a0:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
801398a4:	e0bffa17 	ldw	r2,-24(fp)
801398a8:	10c00317 	ldw	r3,12(r2)
801398ac:	e0bffa17 	ldw	r2,-24(fp)
801398b0:	10800217 	ldw	r2,8(r2)
801398b4:	1880041e 	bne	r3,r2,801398c8 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
801398b8:	e0bffa17 	ldw	r2,-24(fp)
801398bc:	10c00117 	ldw	r3,4(r2)
801398c0:	e0bffa17 	ldw	r2,-24(fp)
801398c4:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
801398c8:	e0bffa17 	ldw	r2,-24(fp)
801398cc:	1080058b 	ldhu	r2,22(r2)
801398d0:	10800044 	addi	r2,r2,1
801398d4:	1007883a 	mov	r3,r2
801398d8:	e0bffa17 	ldw	r2,-24(fp)
801398dc:	10c0058d 	sth	r3,22(r2)
801398e0:	e0bff717 	ldw	r2,-36(fp)
801398e4:	e0bffb15 	stw	r2,-20(fp)
801398e8:	e0bffb17 	ldw	r2,-20(fp)
801398ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
801398f0:	0005883a 	mov	r2,zero
}
801398f4:	e037883a 	mov	sp,fp
801398f8:	dfc00117 	ldw	ra,4(sp)
801398fc:	df000017 	ldw	fp,0(sp)
80139900:	dec00204 	addi	sp,sp,8
80139904:	f800283a 	ret

80139908 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
80139908:	defff604 	addi	sp,sp,-40
8013990c:	de00012e 	bgeu	sp,et,80139914 <OSQQuery+0xc>
80139910:	003b68fa 	trap	3
80139914:	df000915 	stw	fp,36(sp)
80139918:	df000904 	addi	fp,sp,36
8013991c:	e13ffe15 	stw	r4,-8(fp)
80139920:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
80139924:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
80139928:	e0bffe17 	ldw	r2,-8(fp)
8013992c:	1000021e 	bne	r2,zero,80139938 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
80139930:	00800104 	movi	r2,4
80139934:	00004906 	br	80139a5c <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
80139938:	e0bfff17 	ldw	r2,-4(fp)
8013993c:	1000021e 	bne	r2,zero,80139948 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
80139940:	00800244 	movi	r2,9
80139944:	00004506 	br	80139a5c <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
80139948:	e0bffe17 	ldw	r2,-8(fp)
8013994c:	10800003 	ldbu	r2,0(r2)
80139950:	10803fcc 	andi	r2,r2,255
80139954:	108000a0 	cmpeqi	r2,r2,2
80139958:	1000021e 	bne	r2,zero,80139964 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8013995c:	00800044 	movi	r2,1
80139960:	00003e06 	br	80139a5c <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80139964:	0005303a 	rdctl	r2,status
80139968:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013996c:	e0fffd17 	ldw	r3,-12(fp)
80139970:	00bfff84 	movi	r2,-2
80139974:	1884703a 	and	r2,r3,r2
80139978:	1001703a 	wrctl	status,r2
  
  return context;
8013997c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
80139980:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
80139984:	e0bffe17 	ldw	r2,-8(fp)
80139988:	10c00283 	ldbu	r3,10(r2)
8013998c:	e0bfff17 	ldw	r2,-4(fp)
80139990:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
80139994:	e0bffe17 	ldw	r2,-8(fp)
80139998:	108002c4 	addi	r2,r2,11
8013999c:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
801399a0:	e0bfff17 	ldw	r2,-4(fp)
801399a4:	10800204 	addi	r2,r2,8
801399a8:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
801399ac:	e03ff705 	stb	zero,-36(fp)
801399b0:	00000b06 	br	801399e0 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
801399b4:	e0bff917 	ldw	r2,-28(fp)
801399b8:	10c00044 	addi	r3,r2,1
801399bc:	e0fff915 	stw	r3,-28(fp)
801399c0:	e0fff817 	ldw	r3,-32(fp)
801399c4:	19000044 	addi	r4,r3,1
801399c8:	e13ff815 	stw	r4,-32(fp)
801399cc:	18c00003 	ldbu	r3,0(r3)
801399d0:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
801399d4:	e0bff703 	ldbu	r2,-36(fp)
801399d8:	10800044 	addi	r2,r2,1
801399dc:	e0bff705 	stb	r2,-36(fp)
801399e0:	e0bff703 	ldbu	r2,-36(fp)
801399e4:	108001b0 	cmpltui	r2,r2,6
801399e8:	103ff21e 	bne	r2,zero,801399b4 <__reset+0xfa1199b4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
801399ec:	e0bffe17 	ldw	r2,-8(fp)
801399f0:	10800117 	ldw	r2,4(r2)
801399f4:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
801399f8:	e0bffc17 	ldw	r2,-16(fp)
801399fc:	1080058b 	ldhu	r2,22(r2)
80139a00:	10bfffcc 	andi	r2,r2,65535
80139a04:	10000626 	beq	r2,zero,80139a20 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
80139a08:	e0bffc17 	ldw	r2,-16(fp)
80139a0c:	10800417 	ldw	r2,16(r2)
80139a10:	10c00017 	ldw	r3,0(r2)
80139a14:	e0bfff17 	ldw	r2,-4(fp)
80139a18:	10c00015 	stw	r3,0(r2)
80139a1c:	00000206 	br	80139a28 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
80139a20:	e0bfff17 	ldw	r2,-4(fp)
80139a24:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
80139a28:	e0bffc17 	ldw	r2,-16(fp)
80139a2c:	10c0058b 	ldhu	r3,22(r2)
80139a30:	e0bfff17 	ldw	r2,-4(fp)
80139a34:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
80139a38:	e0bffc17 	ldw	r2,-16(fp)
80139a3c:	10c0050b 	ldhu	r3,20(r2)
80139a40:	e0bfff17 	ldw	r2,-4(fp)
80139a44:	10c0018d 	sth	r3,6(r2)
80139a48:	e0bffa17 	ldw	r2,-24(fp)
80139a4c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80139a50:	e0bffb17 	ldw	r2,-20(fp)
80139a54:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
80139a58:	0005883a 	mov	r2,zero
}
80139a5c:	e037883a 	mov	sp,fp
80139a60:	df000017 	ldw	fp,0(sp)
80139a64:	dec00104 	addi	sp,sp,4
80139a68:	f800283a 	ret

80139a6c <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
80139a6c:	defffb04 	addi	sp,sp,-20
80139a70:	de00012e 	bgeu	sp,et,80139a78 <OS_QInit+0xc>
80139a74:	003b68fa 	trap	3
80139a78:	dfc00415 	stw	ra,16(sp)
80139a7c:	df000315 	stw	fp,12(sp)
80139a80:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
80139a84:	0140c004 	movi	r5,768
80139a88:	012005b4 	movhi	r4,32790
80139a8c:	2103dd04 	addi	r4,r4,3956
80139a90:	0134f800 	call	80134f80 <OS_MemClr>
    pq1 = &OSQTbl[0];
80139a94:	00a005b4 	movhi	r2,32790
80139a98:	1083dd04 	addi	r2,r2,3956
80139a9c:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
80139aa0:	00a005b4 	movhi	r2,32790
80139aa4:	1083e304 	addi	r2,r2,3980
80139aa8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
80139aac:	e03ffd0d 	sth	zero,-12(fp)
80139ab0:	00000c06 	br	80139ae4 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
80139ab4:	e0bffe17 	ldw	r2,-8(fp)
80139ab8:	e0ffff17 	ldw	r3,-4(fp)
80139abc:	10c00015 	stw	r3,0(r2)
        pq1++;
80139ac0:	e0bffe17 	ldw	r2,-8(fp)
80139ac4:	10800604 	addi	r2,r2,24
80139ac8:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
80139acc:	e0bfff17 	ldw	r2,-4(fp)
80139ad0:	10800604 	addi	r2,r2,24
80139ad4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
80139ad8:	e0bffd0b 	ldhu	r2,-12(fp)
80139adc:	10800044 	addi	r2,r2,1
80139ae0:	e0bffd0d 	sth	r2,-12(fp)
80139ae4:	e0bffd0b 	ldhu	r2,-12(fp)
80139ae8:	108007f0 	cmpltui	r2,r2,31
80139aec:	103ff11e 	bne	r2,zero,80139ab4 <__reset+0xfa119ab4>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
80139af0:	e0bffe17 	ldw	r2,-8(fp)
80139af4:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
80139af8:	00a005b4 	movhi	r2,32790
80139afc:	1083dd04 	addi	r2,r2,3956
80139b00:	d0a0a615 	stw	r2,-32104(gp)
#endif
}
80139b04:	0001883a 	nop
80139b08:	e037883a 	mov	sp,fp
80139b0c:	dfc00117 	ldw	ra,4(sp)
80139b10:	df000017 	ldw	fp,0(sp)
80139b14:	dec00204 	addi	sp,sp,8
80139b18:	f800283a 	ret

80139b1c <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
80139b1c:	defffa04 	addi	sp,sp,-24
80139b20:	de00012e 	bgeu	sp,et,80139b28 <OSSemAccept+0xc>
80139b24:	003b68fa 	trap	3
80139b28:	df000515 	stw	fp,20(sp)
80139b2c:	df000504 	addi	fp,sp,20
80139b30:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
80139b34:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
80139b38:	e0bfff17 	ldw	r2,-4(fp)
80139b3c:	1000021e 	bne	r2,zero,80139b48 <OSSemAccept+0x2c>
        return (0);
80139b40:	0005883a 	mov	r2,zero
80139b44:	00001f06 	br	80139bc4 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
80139b48:	e0bfff17 	ldw	r2,-4(fp)
80139b4c:	10800003 	ldbu	r2,0(r2)
80139b50:	10803fcc 	andi	r2,r2,255
80139b54:	108000e0 	cmpeqi	r2,r2,3
80139b58:	1000021e 	bne	r2,zero,80139b64 <OSSemAccept+0x48>
        return (0);
80139b5c:	0005883a 	mov	r2,zero
80139b60:	00001806 	br	80139bc4 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80139b64:	0005303a 	rdctl	r2,status
80139b68:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80139b6c:	e0fffe17 	ldw	r3,-8(fp)
80139b70:	00bfff84 	movi	r2,-2
80139b74:	1884703a 	and	r2,r3,r2
80139b78:	1001703a 	wrctl	status,r2
  
  return context;
80139b7c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
80139b80:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
80139b84:	e0bfff17 	ldw	r2,-4(fp)
80139b88:	1080020b 	ldhu	r2,8(r2)
80139b8c:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
80139b90:	e0bffd0b 	ldhu	r2,-12(fp)
80139b94:	10000626 	beq	r2,zero,80139bb0 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
80139b98:	e0bfff17 	ldw	r2,-4(fp)
80139b9c:	1080020b 	ldhu	r2,8(r2)
80139ba0:	10bfffc4 	addi	r2,r2,-1
80139ba4:	1007883a 	mov	r3,r2
80139ba8:	e0bfff17 	ldw	r2,-4(fp)
80139bac:	10c0020d 	sth	r3,8(r2)
80139bb0:	e0bffb17 	ldw	r2,-20(fp)
80139bb4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80139bb8:	e0bffc17 	ldw	r2,-16(fp)
80139bbc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
80139bc0:	e0bffd0b 	ldhu	r2,-12(fp)
}
80139bc4:	e037883a 	mov	sp,fp
80139bc8:	df000017 	ldw	fp,0(sp)
80139bcc:	dec00104 	addi	sp,sp,4
80139bd0:	f800283a 	ret

80139bd4 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
80139bd4:	defff904 	addi	sp,sp,-28
80139bd8:	de00012e 	bgeu	sp,et,80139be0 <OSSemCreate+0xc>
80139bdc:	003b68fa 	trap	3
80139be0:	dfc00615 	stw	ra,24(sp)
80139be4:	df000515 	stw	fp,20(sp)
80139be8:	df000504 	addi	fp,sp,20
80139bec:	2005883a 	mov	r2,r4
80139bf0:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
80139bf4:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
80139bf8:	d0a0aa03 	ldbu	r2,-32088(gp)
80139bfc:	10803fcc 	andi	r2,r2,255
80139c00:	10000226 	beq	r2,zero,80139c0c <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
80139c04:	0005883a 	mov	r2,zero
80139c08:	00002506 	br	80139ca0 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80139c0c:	0005303a 	rdctl	r2,status
80139c10:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80139c14:	e0fffe17 	ldw	r3,-8(fp)
80139c18:	00bfff84 	movi	r2,-2
80139c1c:	1884703a 	and	r2,r3,r2
80139c20:	1001703a 	wrctl	status,r2
  
  return context;
80139c24:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
80139c28:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
80139c2c:	d0a0a917 	ldw	r2,-32092(gp)
80139c30:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
80139c34:	d0a0a917 	ldw	r2,-32092(gp)
80139c38:	10000326 	beq	r2,zero,80139c48 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
80139c3c:	d0a0a917 	ldw	r2,-32092(gp)
80139c40:	10800117 	ldw	r2,4(r2)
80139c44:	d0a0a915 	stw	r2,-32092(gp)
80139c48:	e0bffb17 	ldw	r2,-20(fp)
80139c4c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80139c50:	e0bffc17 	ldw	r2,-16(fp)
80139c54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
80139c58:	e0bffd17 	ldw	r2,-12(fp)
80139c5c:	10000f26 	beq	r2,zero,80139c9c <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
80139c60:	e0bffd17 	ldw	r2,-12(fp)
80139c64:	00c000c4 	movi	r3,3
80139c68:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
80139c6c:	e0bffd17 	ldw	r2,-12(fp)
80139c70:	e0ffff0b 	ldhu	r3,-4(fp)
80139c74:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
80139c78:	e0bffd17 	ldw	r2,-12(fp)
80139c7c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
80139c80:	e0bffd17 	ldw	r2,-12(fp)
80139c84:	00c00fc4 	movi	r3,63
80139c88:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
80139c8c:	e0bffd17 	ldw	r2,-12(fp)
80139c90:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
80139c94:	e13ffd17 	ldw	r4,-12(fp)
80139c98:	0134b680 	call	80134b68 <OS_EventWaitListInit>
    }
    return (pevent);
80139c9c:	e0bffd17 	ldw	r2,-12(fp)
}
80139ca0:	e037883a 	mov	sp,fp
80139ca4:	dfc00117 	ldw	ra,4(sp)
80139ca8:	df000017 	ldw	fp,0(sp)
80139cac:	dec00204 	addi	sp,sp,8
80139cb0:	f800283a 	ret

80139cb4 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
80139cb4:	defff304 	addi	sp,sp,-52
80139cb8:	de00012e 	bgeu	sp,et,80139cc0 <OSSemDel+0xc>
80139cbc:	003b68fa 	trap	3
80139cc0:	dfc00c15 	stw	ra,48(sp)
80139cc4:	df000b15 	stw	fp,44(sp)
80139cc8:	df000b04 	addi	fp,sp,44
80139ccc:	e13ffd15 	stw	r4,-12(fp)
80139cd0:	2805883a 	mov	r2,r5
80139cd4:	e1bfff15 	stw	r6,-4(fp)
80139cd8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
80139cdc:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
80139ce0:	e0bfff17 	ldw	r2,-4(fp)
80139ce4:	1000021e 	bne	r2,zero,80139cf0 <OSSemDel+0x3c>
        return (pevent);
80139ce8:	e0bffd17 	ldw	r2,-12(fp)
80139cec:	00007e06 	br	80139ee8 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
80139cf0:	e0bffd17 	ldw	r2,-12(fp)
80139cf4:	1000051e 	bne	r2,zero,80139d0c <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
80139cf8:	e0bfff17 	ldw	r2,-4(fp)
80139cfc:	00c00104 	movi	r3,4
80139d00:	10c00005 	stb	r3,0(r2)
        return (pevent);
80139d04:	e0bffd17 	ldw	r2,-12(fp)
80139d08:	00007706 	br	80139ee8 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
80139d0c:	e0bffd17 	ldw	r2,-12(fp)
80139d10:	10800003 	ldbu	r2,0(r2)
80139d14:	10803fcc 	andi	r2,r2,255
80139d18:	108000e0 	cmpeqi	r2,r2,3
80139d1c:	1000051e 	bne	r2,zero,80139d34 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
80139d20:	e0bfff17 	ldw	r2,-4(fp)
80139d24:	00c00044 	movi	r3,1
80139d28:	10c00005 	stb	r3,0(r2)
        return (pevent);
80139d2c:	e0bffd17 	ldw	r2,-12(fp)
80139d30:	00006d06 	br	80139ee8 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
80139d34:	d0a0aa03 	ldbu	r2,-32088(gp)
80139d38:	10803fcc 	andi	r2,r2,255
80139d3c:	10000526 	beq	r2,zero,80139d54 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
80139d40:	e0bfff17 	ldw	r2,-4(fp)
80139d44:	00c003c4 	movi	r3,15
80139d48:	10c00005 	stb	r3,0(r2)
        return (pevent);
80139d4c:	e0bffd17 	ldw	r2,-12(fp)
80139d50:	00006506 	br	80139ee8 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80139d54:	0005303a 	rdctl	r2,status
80139d58:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80139d5c:	e0fffc17 	ldw	r3,-16(fp)
80139d60:	00bfff84 	movi	r2,-2
80139d64:	1884703a 	and	r2,r3,r2
80139d68:	1001703a 	wrctl	status,r2
  
  return context;
80139d6c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80139d70:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
80139d74:	e0bffd17 	ldw	r2,-12(fp)
80139d78:	10800283 	ldbu	r2,10(r2)
80139d7c:	10803fcc 	andi	r2,r2,255
80139d80:	10000326 	beq	r2,zero,80139d90 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
80139d84:	00800044 	movi	r2,1
80139d88:	e0bff505 	stb	r2,-44(fp)
80139d8c:	00000106 	br	80139d94 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
80139d90:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
80139d94:	e0bffe03 	ldbu	r2,-8(fp)
80139d98:	10000326 	beq	r2,zero,80139da8 <OSSemDel+0xf4>
80139d9c:	10800060 	cmpeqi	r2,r2,1
80139da0:	1000281e 	bne	r2,zero,80139e44 <OSSemDel+0x190>
80139da4:	00004506 	br	80139ebc <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
80139da8:	e0bff503 	ldbu	r2,-44(fp)
80139dac:	1000161e 	bne	r2,zero,80139e08 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
80139db0:	e0bffd17 	ldw	r2,-12(fp)
80139db4:	00c00fc4 	movi	r3,63
80139db8:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
80139dbc:	e0bffd17 	ldw	r2,-12(fp)
80139dc0:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
80139dc4:	e0bffd17 	ldw	r2,-12(fp)
80139dc8:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
80139dcc:	d0e0a917 	ldw	r3,-32092(gp)
80139dd0:	e0bffd17 	ldw	r2,-12(fp)
80139dd4:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
80139dd8:	e0bffd17 	ldw	r2,-12(fp)
80139ddc:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
80139de0:	e0bffd17 	ldw	r2,-12(fp)
80139de4:	d0a0a915 	stw	r2,-32092(gp)
80139de8:	e0bff717 	ldw	r2,-36(fp)
80139dec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80139df0:	e0bff817 	ldw	r2,-32(fp)
80139df4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
80139df8:	e0bfff17 	ldw	r2,-4(fp)
80139dfc:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
80139e00:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
80139e04:	00003706 	br	80139ee4 <OSSemDel+0x230>
80139e08:	e0bff717 	ldw	r2,-36(fp)
80139e0c:	e0bff915 	stw	r2,-28(fp)
80139e10:	e0bff917 	ldw	r2,-28(fp)
80139e14:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
80139e18:	e0bfff17 	ldw	r2,-4(fp)
80139e1c:	00c01244 	movi	r3,73
80139e20:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
80139e24:	e0bffd17 	ldw	r2,-12(fp)
80139e28:	e0bff615 	stw	r2,-40(fp)
             }
             break;
80139e2c:	00002d06 	br	80139ee4 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
80139e30:	000f883a 	mov	r7,zero
80139e34:	01800044 	movi	r6,1
80139e38:	000b883a 	mov	r5,zero
80139e3c:	e13ffd17 	ldw	r4,-12(fp)
80139e40:	01345900 	call	80134590 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
80139e44:	e0bffd17 	ldw	r2,-12(fp)
80139e48:	10800283 	ldbu	r2,10(r2)
80139e4c:	10803fcc 	andi	r2,r2,255
80139e50:	103ff71e 	bne	r2,zero,80139e30 <__reset+0xfa119e30>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
80139e54:	e0bffd17 	ldw	r2,-12(fp)
80139e58:	00c00fc4 	movi	r3,63
80139e5c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
80139e60:	e0bffd17 	ldw	r2,-12(fp)
80139e64:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
80139e68:	e0bffd17 	ldw	r2,-12(fp)
80139e6c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
80139e70:	d0e0a917 	ldw	r3,-32092(gp)
80139e74:	e0bffd17 	ldw	r2,-12(fp)
80139e78:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
80139e7c:	e0bffd17 	ldw	r2,-12(fp)
80139e80:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
80139e84:	e0bffd17 	ldw	r2,-12(fp)
80139e88:	d0a0a915 	stw	r2,-32092(gp)
80139e8c:	e0bff717 	ldw	r2,-36(fp)
80139e90:	e0bffa15 	stw	r2,-24(fp)
80139e94:	e0bffa17 	ldw	r2,-24(fp)
80139e98:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
80139e9c:	e0bff503 	ldbu	r2,-44(fp)
80139ea0:	10800058 	cmpnei	r2,r2,1
80139ea4:	1000011e 	bne	r2,zero,80139eac <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
80139ea8:	013504c0 	call	8013504c <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
80139eac:	e0bfff17 	ldw	r2,-4(fp)
80139eb0:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
80139eb4:	e03ff615 	stw	zero,-40(fp)
             break;
80139eb8:	00000a06 	br	80139ee4 <OSSemDel+0x230>
80139ebc:	e0bff717 	ldw	r2,-36(fp)
80139ec0:	e0bffb15 	stw	r2,-20(fp)
80139ec4:	e0bffb17 	ldw	r2,-20(fp)
80139ec8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
80139ecc:	e0bfff17 	ldw	r2,-4(fp)
80139ed0:	00c001c4 	movi	r3,7
80139ed4:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
80139ed8:	e0bffd17 	ldw	r2,-12(fp)
80139edc:	e0bff615 	stw	r2,-40(fp)
             break;
80139ee0:	0001883a 	nop
    }
    return (pevent_return);
80139ee4:	e0bff617 	ldw	r2,-40(fp)
}
80139ee8:	e037883a 	mov	sp,fp
80139eec:	dfc00117 	ldw	ra,4(sp)
80139ef0:	df000017 	ldw	fp,0(sp)
80139ef4:	dec00204 	addi	sp,sp,8
80139ef8:	f800283a 	ret

80139efc <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
80139efc:	defff504 	addi	sp,sp,-44
80139f00:	de00012e 	bgeu	sp,et,80139f08 <OSSemPend+0xc>
80139f04:	003b68fa 	trap	3
80139f08:	dfc00a15 	stw	ra,40(sp)
80139f0c:	df000915 	stw	fp,36(sp)
80139f10:	df000904 	addi	fp,sp,36
80139f14:	e13ffd15 	stw	r4,-12(fp)
80139f18:	2805883a 	mov	r2,r5
80139f1c:	e1bfff15 	stw	r6,-4(fp)
80139f20:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
80139f24:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
80139f28:	e0bfff17 	ldw	r2,-4(fp)
80139f2c:	10007226 	beq	r2,zero,8013a0f8 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
80139f30:	e0bffd17 	ldw	r2,-12(fp)
80139f34:	1000041e 	bne	r2,zero,80139f48 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
80139f38:	e0bfff17 	ldw	r2,-4(fp)
80139f3c:	00c00104 	movi	r3,4
80139f40:	10c00005 	stb	r3,0(r2)
        return;
80139f44:	00006d06 	br	8013a0fc <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
80139f48:	e0bffd17 	ldw	r2,-12(fp)
80139f4c:	10800003 	ldbu	r2,0(r2)
80139f50:	10803fcc 	andi	r2,r2,255
80139f54:	108000e0 	cmpeqi	r2,r2,3
80139f58:	1000041e 	bne	r2,zero,80139f6c <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
80139f5c:	e0bfff17 	ldw	r2,-4(fp)
80139f60:	00c00044 	movi	r3,1
80139f64:	10c00005 	stb	r3,0(r2)
        return;
80139f68:	00006406 	br	8013a0fc <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
80139f6c:	d0a0aa03 	ldbu	r2,-32088(gp)
80139f70:	10803fcc 	andi	r2,r2,255
80139f74:	10000426 	beq	r2,zero,80139f88 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
80139f78:	e0bfff17 	ldw	r2,-4(fp)
80139f7c:	00c00084 	movi	r3,2
80139f80:	10c00005 	stb	r3,0(r2)
        return;
80139f84:	00005d06 	br	8013a0fc <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
80139f88:	d0a09803 	ldbu	r2,-32160(gp)
80139f8c:	10803fcc 	andi	r2,r2,255
80139f90:	10000426 	beq	r2,zero,80139fa4 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
80139f94:	e0bfff17 	ldw	r2,-4(fp)
80139f98:	00c00344 	movi	r3,13
80139f9c:	10c00005 	stb	r3,0(r2)
        return;
80139fa0:	00005606 	br	8013a0fc <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80139fa4:	0005303a 	rdctl	r2,status
80139fa8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80139fac:	e0fffc17 	ldw	r3,-16(fp)
80139fb0:	00bfff84 	movi	r2,-2
80139fb4:	1884703a 	and	r2,r3,r2
80139fb8:	1001703a 	wrctl	status,r2
  
  return context;
80139fbc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
80139fc0:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
80139fc4:	e0bffd17 	ldw	r2,-12(fp)
80139fc8:	1080020b 	ldhu	r2,8(r2)
80139fcc:	10bfffcc 	andi	r2,r2,65535
80139fd0:	10000d26 	beq	r2,zero,8013a008 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
80139fd4:	e0bffd17 	ldw	r2,-12(fp)
80139fd8:	1080020b 	ldhu	r2,8(r2)
80139fdc:	10bfffc4 	addi	r2,r2,-1
80139fe0:	1007883a 	mov	r3,r2
80139fe4:	e0bffd17 	ldw	r2,-12(fp)
80139fe8:	10c0020d 	sth	r3,8(r2)
80139fec:	e0bff717 	ldw	r2,-36(fp)
80139ff0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80139ff4:	e0bff817 	ldw	r2,-32(fp)
80139ff8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
80139ffc:	e0bfff17 	ldw	r2,-4(fp)
8013a000:	10000005 	stb	zero,0(r2)
        return;
8013a004:	00003d06 	br	8013a0fc <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8013a008:	d0a0ab17 	ldw	r2,-32084(gp)
8013a00c:	d0e0ab17 	ldw	r3,-32084(gp)
8013a010:	18c00c03 	ldbu	r3,48(r3)
8013a014:	18c00054 	ori	r3,r3,1
8013a018:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8013a01c:	d0a0ab17 	ldw	r2,-32084(gp)
8013a020:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8013a024:	d0a0ab17 	ldw	r2,-32084(gp)
8013a028:	e0fffe0b 	ldhu	r3,-8(fp)
8013a02c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8013a030:	e13ffd17 	ldw	r4,-12(fp)
8013a034:	01347300 	call	80134730 <OS_EventTaskWait>
8013a038:	e0bff717 	ldw	r2,-36(fp)
8013a03c:	e0bffb15 	stw	r2,-20(fp)
8013a040:	e0bffb17 	ldw	r2,-20(fp)
8013a044:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8013a048:	013504c0 	call	8013504c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013a04c:	0005303a 	rdctl	r2,status
8013a050:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013a054:	e0fff917 	ldw	r3,-28(fp)
8013a058:	00bfff84 	movi	r2,-2
8013a05c:	1884703a 	and	r2,r3,r2
8013a060:	1001703a 	wrctl	status,r2
  
  return context;
8013a064:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8013a068:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8013a06c:	d0a0ab17 	ldw	r2,-32084(gp)
8013a070:	10800c43 	ldbu	r2,49(r2)
8013a074:	10803fcc 	andi	r2,r2,255
8013a078:	10000326 	beq	r2,zero,8013a088 <OSSemPend+0x18c>
8013a07c:	108000a0 	cmpeqi	r2,r2,2
8013a080:	1000041e 	bne	r2,zero,8013a094 <OSSemPend+0x198>
8013a084:	00000706 	br	8013a0a4 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8013a088:	e0bfff17 	ldw	r2,-4(fp)
8013a08c:	10000005 	stb	zero,0(r2)
             break;
8013a090:	00000c06 	br	8013a0c4 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8013a094:	e0bfff17 	ldw	r2,-4(fp)
8013a098:	00c00384 	movi	r3,14
8013a09c:	10c00005 	stb	r3,0(r2)
             break;
8013a0a0:	00000806 	br	8013a0c4 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8013a0a4:	d0a0ab17 	ldw	r2,-32084(gp)
8013a0a8:	e17ffd17 	ldw	r5,-12(fp)
8013a0ac:	1009883a 	mov	r4,r2
8013a0b0:	01349a00 	call	801349a0 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8013a0b4:	e0bfff17 	ldw	r2,-4(fp)
8013a0b8:	00c00284 	movi	r3,10
8013a0bc:	10c00005 	stb	r3,0(r2)
             break;
8013a0c0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8013a0c4:	d0a0ab17 	ldw	r2,-32084(gp)
8013a0c8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8013a0cc:	d0a0ab17 	ldw	r2,-32084(gp)
8013a0d0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8013a0d4:	d0a0ab17 	ldw	r2,-32084(gp)
8013a0d8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8013a0dc:	d0a0ab17 	ldw	r2,-32084(gp)
8013a0e0:	10000815 	stw	zero,32(r2)
8013a0e4:	e0bff717 	ldw	r2,-36(fp)
8013a0e8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013a0ec:	e0bffa17 	ldw	r2,-24(fp)
8013a0f0:	1001703a 	wrctl	status,r2
8013a0f4:	00000106 	br	8013a0fc <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8013a0f8:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8013a0fc:	e037883a 	mov	sp,fp
8013a100:	dfc00117 	ldw	ra,4(sp)
8013a104:	df000017 	ldw	fp,0(sp)
8013a108:	dec00204 	addi	sp,sp,8
8013a10c:	f800283a 	ret

8013a110 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8013a110:	defff604 	addi	sp,sp,-40
8013a114:	de00012e 	bgeu	sp,et,8013a11c <OSSemPendAbort+0xc>
8013a118:	003b68fa 	trap	3
8013a11c:	dfc00915 	stw	ra,36(sp)
8013a120:	df000815 	stw	fp,32(sp)
8013a124:	df000804 	addi	fp,sp,32
8013a128:	e13ffd15 	stw	r4,-12(fp)
8013a12c:	2805883a 	mov	r2,r5
8013a130:	e1bfff15 	stw	r6,-4(fp)
8013a134:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8013a138:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8013a13c:	e0bfff17 	ldw	r2,-4(fp)
8013a140:	1000021e 	bne	r2,zero,8013a14c <OSSemPendAbort+0x3c>
        return (0);
8013a144:	0005883a 	mov	r2,zero
8013a148:	00004906 	br	8013a270 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8013a14c:	e0bffd17 	ldw	r2,-12(fp)
8013a150:	1000051e 	bne	r2,zero,8013a168 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8013a154:	e0bfff17 	ldw	r2,-4(fp)
8013a158:	00c00104 	movi	r3,4
8013a15c:	10c00005 	stb	r3,0(r2)
        return (0);
8013a160:	0005883a 	mov	r2,zero
8013a164:	00004206 	br	8013a270 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8013a168:	e0bffd17 	ldw	r2,-12(fp)
8013a16c:	10800003 	ldbu	r2,0(r2)
8013a170:	10803fcc 	andi	r2,r2,255
8013a174:	108000e0 	cmpeqi	r2,r2,3
8013a178:	1000051e 	bne	r2,zero,8013a190 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8013a17c:	e0bfff17 	ldw	r2,-4(fp)
8013a180:	00c00044 	movi	r3,1
8013a184:	10c00005 	stb	r3,0(r2)
        return (0);
8013a188:	0005883a 	mov	r2,zero
8013a18c:	00003806 	br	8013a270 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013a190:	0005303a 	rdctl	r2,status
8013a194:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013a198:	e0fffc17 	ldw	r3,-16(fp)
8013a19c:	00bfff84 	movi	r2,-2
8013a1a0:	1884703a 	and	r2,r3,r2
8013a1a4:	1001703a 	wrctl	status,r2
  
  return context;
8013a1a8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8013a1ac:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8013a1b0:	e0bffd17 	ldw	r2,-12(fp)
8013a1b4:	10800283 	ldbu	r2,10(r2)
8013a1b8:	10803fcc 	andi	r2,r2,255
8013a1bc:	10002526 	beq	r2,zero,8013a254 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8013a1c0:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8013a1c4:	e0bffe03 	ldbu	r2,-8(fp)
8013a1c8:	10800060 	cmpeqi	r2,r2,1
8013a1cc:	10000e26 	beq	r2,zero,8013a208 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8013a1d0:	00000806 	br	8013a1f4 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8013a1d4:	01c00084 	movi	r7,2
8013a1d8:	01800044 	movi	r6,1
8013a1dc:	000b883a 	mov	r5,zero
8013a1e0:	e13ffd17 	ldw	r4,-12(fp)
8013a1e4:	01345900 	call	80134590 <OS_EventTaskRdy>
                     nbr_tasks++;
8013a1e8:	e0bff803 	ldbu	r2,-32(fp)
8013a1ec:	10800044 	addi	r2,r2,1
8013a1f0:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8013a1f4:	e0bffd17 	ldw	r2,-12(fp)
8013a1f8:	10800283 	ldbu	r2,10(r2)
8013a1fc:	10803fcc 	andi	r2,r2,255
8013a200:	103ff41e 	bne	r2,zero,8013a1d4 <__reset+0xfa11a1d4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8013a204:	00000906 	br	8013a22c <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8013a208:	01c00084 	movi	r7,2
8013a20c:	01800044 	movi	r6,1
8013a210:	000b883a 	mov	r5,zero
8013a214:	e13ffd17 	ldw	r4,-12(fp)
8013a218:	01345900 	call	80134590 <OS_EventTaskRdy>
                 nbr_tasks++;
8013a21c:	e0bff803 	ldbu	r2,-32(fp)
8013a220:	10800044 	addi	r2,r2,1
8013a224:	e0bff805 	stb	r2,-32(fp)
                 break;
8013a228:	0001883a 	nop
8013a22c:	e0bff917 	ldw	r2,-28(fp)
8013a230:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013a234:	e0bffa17 	ldw	r2,-24(fp)
8013a238:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8013a23c:	013504c0 	call	8013504c <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8013a240:	e0bfff17 	ldw	r2,-4(fp)
8013a244:	00c00384 	movi	r3,14
8013a248:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8013a24c:	e0bff803 	ldbu	r2,-32(fp)
8013a250:	00000706 	br	8013a270 <OSSemPendAbort+0x160>
8013a254:	e0bff917 	ldw	r2,-28(fp)
8013a258:	e0bffb15 	stw	r2,-20(fp)
8013a25c:	e0bffb17 	ldw	r2,-20(fp)
8013a260:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8013a264:	e0bfff17 	ldw	r2,-4(fp)
8013a268:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8013a26c:	0005883a 	mov	r2,zero
}
8013a270:	e037883a 	mov	sp,fp
8013a274:	dfc00117 	ldw	ra,4(sp)
8013a278:	df000017 	ldw	fp,0(sp)
8013a27c:	dec00204 	addi	sp,sp,8
8013a280:	f800283a 	ret

8013a284 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8013a284:	defff804 	addi	sp,sp,-32
8013a288:	de00012e 	bgeu	sp,et,8013a290 <OSSemPost+0xc>
8013a28c:	003b68fa 	trap	3
8013a290:	dfc00715 	stw	ra,28(sp)
8013a294:	df000615 	stw	fp,24(sp)
8013a298:	df000604 	addi	fp,sp,24
8013a29c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8013a2a0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8013a2a4:	e0bfff17 	ldw	r2,-4(fp)
8013a2a8:	1000021e 	bne	r2,zero,8013a2b4 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8013a2ac:	00800104 	movi	r2,4
8013a2b0:	00003506 	br	8013a388 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8013a2b4:	e0bfff17 	ldw	r2,-4(fp)
8013a2b8:	10800003 	ldbu	r2,0(r2)
8013a2bc:	10803fcc 	andi	r2,r2,255
8013a2c0:	108000e0 	cmpeqi	r2,r2,3
8013a2c4:	1000021e 	bne	r2,zero,8013a2d0 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8013a2c8:	00800044 	movi	r2,1
8013a2cc:	00002e06 	br	8013a388 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013a2d0:	0005303a 	rdctl	r2,status
8013a2d4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013a2d8:	e0fffe17 	ldw	r3,-8(fp)
8013a2dc:	00bfff84 	movi	r2,-2
8013a2e0:	1884703a 	and	r2,r3,r2
8013a2e4:	1001703a 	wrctl	status,r2
  
  return context;
8013a2e8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8013a2ec:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8013a2f0:	e0bfff17 	ldw	r2,-4(fp)
8013a2f4:	10800283 	ldbu	r2,10(r2)
8013a2f8:	10803fcc 	andi	r2,r2,255
8013a2fc:	10000c26 	beq	r2,zero,8013a330 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8013a300:	000f883a 	mov	r7,zero
8013a304:	01800044 	movi	r6,1
8013a308:	000b883a 	mov	r5,zero
8013a30c:	e13fff17 	ldw	r4,-4(fp)
8013a310:	01345900 	call	80134590 <OS_EventTaskRdy>
8013a314:	e0bffa17 	ldw	r2,-24(fp)
8013a318:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013a31c:	e0bffb17 	ldw	r2,-20(fp)
8013a320:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8013a324:	013504c0 	call	8013504c <OS_Sched>
        return (OS_ERR_NONE);
8013a328:	0005883a 	mov	r2,zero
8013a32c:	00001606 	br	8013a388 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8013a330:	e0bfff17 	ldw	r2,-4(fp)
8013a334:	1080020b 	ldhu	r2,8(r2)
8013a338:	10ffffcc 	andi	r3,r2,65535
8013a33c:	00bfffd4 	movui	r2,65535
8013a340:	18800c26 	beq	r3,r2,8013a374 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8013a344:	e0bfff17 	ldw	r2,-4(fp)
8013a348:	1080020b 	ldhu	r2,8(r2)
8013a34c:	10800044 	addi	r2,r2,1
8013a350:	1007883a 	mov	r3,r2
8013a354:	e0bfff17 	ldw	r2,-4(fp)
8013a358:	10c0020d 	sth	r3,8(r2)
8013a35c:	e0bffa17 	ldw	r2,-24(fp)
8013a360:	e0bffc15 	stw	r2,-16(fp)
8013a364:	e0bffc17 	ldw	r2,-16(fp)
8013a368:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8013a36c:	0005883a 	mov	r2,zero
8013a370:	00000506 	br	8013a388 <OSSemPost+0x104>
8013a374:	e0bffa17 	ldw	r2,-24(fp)
8013a378:	e0bffd15 	stw	r2,-12(fp)
8013a37c:	e0bffd17 	ldw	r2,-12(fp)
8013a380:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8013a384:	00800c84 	movi	r2,50
}
8013a388:	e037883a 	mov	sp,fp
8013a38c:	dfc00117 	ldw	ra,4(sp)
8013a390:	df000017 	ldw	fp,0(sp)
8013a394:	dec00204 	addi	sp,sp,8
8013a398:	f800283a 	ret

8013a39c <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8013a39c:	defff704 	addi	sp,sp,-36
8013a3a0:	de00012e 	bgeu	sp,et,8013a3a8 <OSSemQuery+0xc>
8013a3a4:	003b68fa 	trap	3
8013a3a8:	df000815 	stw	fp,32(sp)
8013a3ac:	df000804 	addi	fp,sp,32
8013a3b0:	e13ffe15 	stw	r4,-8(fp)
8013a3b4:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8013a3b8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8013a3bc:	e0bffe17 	ldw	r2,-8(fp)
8013a3c0:	1000021e 	bne	r2,zero,8013a3cc <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8013a3c4:	00800104 	movi	r2,4
8013a3c8:	00003606 	br	8013a4a4 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8013a3cc:	e0bfff17 	ldw	r2,-4(fp)
8013a3d0:	1000021e 	bne	r2,zero,8013a3dc <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8013a3d4:	00800244 	movi	r2,9
8013a3d8:	00003206 	br	8013a4a4 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8013a3dc:	e0bffe17 	ldw	r2,-8(fp)
8013a3e0:	10800003 	ldbu	r2,0(r2)
8013a3e4:	10803fcc 	andi	r2,r2,255
8013a3e8:	108000e0 	cmpeqi	r2,r2,3
8013a3ec:	1000021e 	bne	r2,zero,8013a3f8 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8013a3f0:	00800044 	movi	r2,1
8013a3f4:	00002b06 	br	8013a4a4 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013a3f8:	0005303a 	rdctl	r2,status
8013a3fc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013a400:	e0fffd17 	ldw	r3,-12(fp)
8013a404:	00bfff84 	movi	r2,-2
8013a408:	1884703a 	and	r2,r3,r2
8013a40c:	1001703a 	wrctl	status,r2
  
  return context;
8013a410:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8013a414:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8013a418:	e0bffe17 	ldw	r2,-8(fp)
8013a41c:	10c00283 	ldbu	r3,10(r2)
8013a420:	e0bfff17 	ldw	r2,-4(fp)
8013a424:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8013a428:	e0bffe17 	ldw	r2,-8(fp)
8013a42c:	108002c4 	addi	r2,r2,11
8013a430:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8013a434:	e0bfff17 	ldw	r2,-4(fp)
8013a438:	10800084 	addi	r2,r2,2
8013a43c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8013a440:	e03ffa05 	stb	zero,-24(fp)
8013a444:	00000b06 	br	8013a474 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8013a448:	e0bff917 	ldw	r2,-28(fp)
8013a44c:	10c00044 	addi	r3,r2,1
8013a450:	e0fff915 	stw	r3,-28(fp)
8013a454:	e0fff817 	ldw	r3,-32(fp)
8013a458:	19000044 	addi	r4,r3,1
8013a45c:	e13ff815 	stw	r4,-32(fp)
8013a460:	18c00003 	ldbu	r3,0(r3)
8013a464:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8013a468:	e0bffa03 	ldbu	r2,-24(fp)
8013a46c:	10800044 	addi	r2,r2,1
8013a470:	e0bffa05 	stb	r2,-24(fp)
8013a474:	e0bffa03 	ldbu	r2,-24(fp)
8013a478:	108001b0 	cmpltui	r2,r2,6
8013a47c:	103ff21e 	bne	r2,zero,8013a448 <__reset+0xfa11a448>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8013a480:	e0bffe17 	ldw	r2,-8(fp)
8013a484:	10c0020b 	ldhu	r3,8(r2)
8013a488:	e0bfff17 	ldw	r2,-4(fp)
8013a48c:	10c0000d 	sth	r3,0(r2)
8013a490:	e0bffb17 	ldw	r2,-20(fp)
8013a494:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013a498:	e0bffc17 	ldw	r2,-16(fp)
8013a49c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8013a4a0:	0005883a 	mov	r2,zero
}
8013a4a4:	e037883a 	mov	sp,fp
8013a4a8:	df000017 	ldw	fp,0(sp)
8013a4ac:	dec00104 	addi	sp,sp,4
8013a4b0:	f800283a 	ret

8013a4b4 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8013a4b4:	defff904 	addi	sp,sp,-28
8013a4b8:	de00012e 	bgeu	sp,et,8013a4c0 <OSSemSet+0xc>
8013a4bc:	003b68fa 	trap	3
8013a4c0:	df000615 	stw	fp,24(sp)
8013a4c4:	df000604 	addi	fp,sp,24
8013a4c8:	e13ffd15 	stw	r4,-12(fp)
8013a4cc:	2805883a 	mov	r2,r5
8013a4d0:	e1bfff15 	stw	r6,-4(fp)
8013a4d4:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8013a4d8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8013a4dc:	e0bfff17 	ldw	r2,-4(fp)
8013a4e0:	10003126 	beq	r2,zero,8013a5a8 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8013a4e4:	e0bffd17 	ldw	r2,-12(fp)
8013a4e8:	1000041e 	bne	r2,zero,8013a4fc <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8013a4ec:	e0bfff17 	ldw	r2,-4(fp)
8013a4f0:	00c00104 	movi	r3,4
8013a4f4:	10c00005 	stb	r3,0(r2)
        return;
8013a4f8:	00002c06 	br	8013a5ac <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8013a4fc:	e0bffd17 	ldw	r2,-12(fp)
8013a500:	10800003 	ldbu	r2,0(r2)
8013a504:	10803fcc 	andi	r2,r2,255
8013a508:	108000e0 	cmpeqi	r2,r2,3
8013a50c:	1000041e 	bne	r2,zero,8013a520 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8013a510:	e0bfff17 	ldw	r2,-4(fp)
8013a514:	00c00044 	movi	r3,1
8013a518:	10c00005 	stb	r3,0(r2)
        return;
8013a51c:	00002306 	br	8013a5ac <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013a520:	0005303a 	rdctl	r2,status
8013a524:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013a528:	e0fffc17 	ldw	r3,-16(fp)
8013a52c:	00bfff84 	movi	r2,-2
8013a530:	1884703a 	and	r2,r3,r2
8013a534:	1001703a 	wrctl	status,r2
  
  return context;
8013a538:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8013a53c:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8013a540:	e0bfff17 	ldw	r2,-4(fp)
8013a544:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8013a548:	e0bffd17 	ldw	r2,-12(fp)
8013a54c:	1080020b 	ldhu	r2,8(r2)
8013a550:	10bfffcc 	andi	r2,r2,65535
8013a554:	10000426 	beq	r2,zero,8013a568 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8013a558:	e0bffd17 	ldw	r2,-12(fp)
8013a55c:	e0fffe0b 	ldhu	r3,-8(fp)
8013a560:	10c0020d 	sth	r3,8(r2)
8013a564:	00000b06 	br	8013a594 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8013a568:	e0bffd17 	ldw	r2,-12(fp)
8013a56c:	10800283 	ldbu	r2,10(r2)
8013a570:	10803fcc 	andi	r2,r2,255
8013a574:	1000041e 	bne	r2,zero,8013a588 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8013a578:	e0bffd17 	ldw	r2,-12(fp)
8013a57c:	e0fffe0b 	ldhu	r3,-8(fp)
8013a580:	10c0020d 	sth	r3,8(r2)
8013a584:	00000306 	br	8013a594 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8013a588:	e0bfff17 	ldw	r2,-4(fp)
8013a58c:	00c01244 	movi	r3,73
8013a590:	10c00005 	stb	r3,0(r2)
8013a594:	e0bffa17 	ldw	r2,-24(fp)
8013a598:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013a59c:	e0bffb17 	ldw	r2,-20(fp)
8013a5a0:	1001703a 	wrctl	status,r2
8013a5a4:	00000106 	br	8013a5ac <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8013a5a8:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8013a5ac:	e037883a 	mov	sp,fp
8013a5b0:	df000017 	ldw	fp,0(sp)
8013a5b4:	dec00104 	addi	sp,sp,4
8013a5b8:	f800283a 	ret

8013a5bc <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8013a5bc:	defff104 	addi	sp,sp,-60
8013a5c0:	de00012e 	bgeu	sp,et,8013a5c8 <OSTaskChangePrio+0xc>
8013a5c4:	003b68fa 	trap	3
8013a5c8:	dfc00e15 	stw	ra,56(sp)
8013a5cc:	df000d15 	stw	fp,52(sp)
8013a5d0:	df000d04 	addi	fp,sp,52
8013a5d4:	2007883a 	mov	r3,r4
8013a5d8:	2805883a 	mov	r2,r5
8013a5dc:	e0fffe05 	stb	r3,-8(fp)
8013a5e0:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8013a5e4:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8013a5e8:	e0bffe03 	ldbu	r2,-8(fp)
8013a5ec:	10800ab0 	cmpltui	r2,r2,42
8013a5f0:	1000051e 	bne	r2,zero,8013a608 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8013a5f4:	e0bffe03 	ldbu	r2,-8(fp)
8013a5f8:	10803fe0 	cmpeqi	r2,r2,255
8013a5fc:	1000021e 	bne	r2,zero,8013a608 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8013a600:	00800a84 	movi	r2,42
8013a604:	00012606 	br	8013aaa0 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8013a608:	e0bfff03 	ldbu	r2,-4(fp)
8013a60c:	10800ab0 	cmpltui	r2,r2,42
8013a610:	1000021e 	bne	r2,zero,8013a61c <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8013a614:	00800a84 	movi	r2,42
8013a618:	00012106 	br	8013aaa0 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013a61c:	0005303a 	rdctl	r2,status
8013a620:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013a624:	e0fffd17 	ldw	r3,-12(fp)
8013a628:	00bfff84 	movi	r2,-2
8013a62c:	1884703a 	and	r2,r3,r2
8013a630:	1001703a 	wrctl	status,r2
  
  return context;
8013a634:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8013a638:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8013a63c:	e0ffff03 	ldbu	r3,-4(fp)
8013a640:	00a005b4 	movhi	r2,32790
8013a644:	10924b04 	addi	r2,r2,18732
8013a648:	18c7883a 	add	r3,r3,r3
8013a64c:	18c7883a 	add	r3,r3,r3
8013a650:	10c5883a 	add	r2,r2,r3
8013a654:	10800017 	ldw	r2,0(r2)
8013a658:	10000626 	beq	r2,zero,8013a674 <OSTaskChangePrio+0xb8>
8013a65c:	e0bff517 	ldw	r2,-44(fp)
8013a660:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013a664:	e0bff617 	ldw	r2,-40(fp)
8013a668:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8013a66c:	00800a04 	movi	r2,40
8013a670:	00010b06 	br	8013aaa0 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8013a674:	e0bffe03 	ldbu	r2,-8(fp)
8013a678:	10803fd8 	cmpnei	r2,r2,255
8013a67c:	1000031e 	bne	r2,zero,8013a68c <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8013a680:	d0a0ab17 	ldw	r2,-32084(gp)
8013a684:	10800c83 	ldbu	r2,50(r2)
8013a688:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8013a68c:	e0fffe03 	ldbu	r3,-8(fp)
8013a690:	00a005b4 	movhi	r2,32790
8013a694:	10924b04 	addi	r2,r2,18732
8013a698:	18c7883a 	add	r3,r3,r3
8013a69c:	18c7883a 	add	r3,r3,r3
8013a6a0:	10c5883a 	add	r2,r2,r3
8013a6a4:	10800017 	ldw	r2,0(r2)
8013a6a8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8013a6ac:	e0bff817 	ldw	r2,-32(fp)
8013a6b0:	1000061e 	bne	r2,zero,8013a6cc <OSTaskChangePrio+0x110>
8013a6b4:	e0bff517 	ldw	r2,-44(fp)
8013a6b8:	e0bff715 	stw	r2,-36(fp)
8013a6bc:	e0bff717 	ldw	r2,-36(fp)
8013a6c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8013a6c4:	00800a44 	movi	r2,41
8013a6c8:	0000f506 	br	8013aaa0 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8013a6cc:	e0bff817 	ldw	r2,-32(fp)
8013a6d0:	10800058 	cmpnei	r2,r2,1
8013a6d4:	1000061e 	bne	r2,zero,8013a6f0 <OSTaskChangePrio+0x134>
8013a6d8:	e0bff517 	ldw	r2,-44(fp)
8013a6dc:	e0bff915 	stw	r2,-28(fp)
8013a6e0:	e0bff917 	ldw	r2,-28(fp)
8013a6e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8013a6e8:	008010c4 	movi	r2,67
8013a6ec:	0000ec06 	br	8013aaa0 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8013a6f0:	e0bfff03 	ldbu	r2,-4(fp)
8013a6f4:	1004d0fa 	srli	r2,r2,3
8013a6f8:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8013a6fc:	e0bfff03 	ldbu	r2,-4(fp)
8013a700:	108001cc 	andi	r2,r2,7
8013a704:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8013a708:	e0bffb03 	ldbu	r2,-20(fp)
8013a70c:	00c00044 	movi	r3,1
8013a710:	1884983a 	sll	r2,r3,r2
8013a714:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8013a718:	e0bffb43 	ldbu	r2,-19(fp)
8013a71c:	00c00044 	movi	r3,1
8013a720:	1884983a 	sll	r2,r3,r2
8013a724:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8013a728:	e0fffe03 	ldbu	r3,-8(fp)
8013a72c:	00a005b4 	movhi	r2,32790
8013a730:	10924b04 	addi	r2,r2,18732
8013a734:	18c7883a 	add	r3,r3,r3
8013a738:	18c7883a 	add	r3,r3,r3
8013a73c:	10c5883a 	add	r2,r2,r3
8013a740:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8013a744:	e0ffff03 	ldbu	r3,-4(fp)
8013a748:	00a005b4 	movhi	r2,32790
8013a74c:	10924b04 	addi	r2,r2,18732
8013a750:	18c7883a 	add	r3,r3,r3
8013a754:	18c7883a 	add	r3,r3,r3
8013a758:	10c5883a 	add	r2,r2,r3
8013a75c:	e0fff817 	ldw	r3,-32(fp)
8013a760:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8013a764:	e0bff817 	ldw	r2,-32(fp)
8013a768:	10800d03 	ldbu	r2,52(r2)
8013a76c:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8013a770:	e0bff817 	ldw	r2,-32(fp)
8013a774:	10800d83 	ldbu	r2,54(r2)
8013a778:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8013a77c:	e0bff817 	ldw	r2,-32(fp)
8013a780:	10800d43 	ldbu	r2,53(r2)
8013a784:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8013a788:	e0fffc03 	ldbu	r3,-16(fp)
8013a78c:	d0a0a744 	addi	r2,gp,-32099
8013a790:	1885883a 	add	r2,r3,r2
8013a794:	10c00003 	ldbu	r3,0(r2)
8013a798:	e0bffc83 	ldbu	r2,-14(fp)
8013a79c:	1884703a 	and	r2,r3,r2
8013a7a0:	10803fcc 	andi	r2,r2,255
8013a7a4:	10002826 	beq	r2,zero,8013a848 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8013a7a8:	e0fffc03 	ldbu	r3,-16(fp)
8013a7ac:	e13ffc03 	ldbu	r4,-16(fp)
8013a7b0:	d0a0a744 	addi	r2,gp,-32099
8013a7b4:	2085883a 	add	r2,r4,r2
8013a7b8:	10800003 	ldbu	r2,0(r2)
8013a7bc:	1009883a 	mov	r4,r2
8013a7c0:	e0bffc83 	ldbu	r2,-14(fp)
8013a7c4:	0084303a 	nor	r2,zero,r2
8013a7c8:	2084703a 	and	r2,r4,r2
8013a7cc:	1009883a 	mov	r4,r2
8013a7d0:	d0a0a744 	addi	r2,gp,-32099
8013a7d4:	1885883a 	add	r2,r3,r2
8013a7d8:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8013a7dc:	e0fffc03 	ldbu	r3,-16(fp)
8013a7e0:	d0a0a744 	addi	r2,gp,-32099
8013a7e4:	1885883a 	add	r2,r3,r2
8013a7e8:	10800003 	ldbu	r2,0(r2)
8013a7ec:	10803fcc 	andi	r2,r2,255
8013a7f0:	1000061e 	bne	r2,zero,8013a80c <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8013a7f4:	e0bffc43 	ldbu	r2,-15(fp)
8013a7f8:	0084303a 	nor	r2,zero,r2
8013a7fc:	1007883a 	mov	r3,r2
8013a800:	d0a0a703 	ldbu	r2,-32100(gp)
8013a804:	1884703a 	and	r2,r3,r2
8013a808:	d0a0a705 	stb	r2,-32100(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8013a80c:	d0e0a703 	ldbu	r3,-32100(gp)
8013a810:	e0bffb83 	ldbu	r2,-18(fp)
8013a814:	1884b03a 	or	r2,r3,r2
8013a818:	d0a0a705 	stb	r2,-32100(gp)
         OSRdyTbl[y_new] |= bitx_new;
8013a81c:	e0fffb03 	ldbu	r3,-20(fp)
8013a820:	e13ffb03 	ldbu	r4,-20(fp)
8013a824:	d0a0a744 	addi	r2,gp,-32099
8013a828:	2085883a 	add	r2,r4,r2
8013a82c:	11000003 	ldbu	r4,0(r2)
8013a830:	e0bffbc3 	ldbu	r2,-17(fp)
8013a834:	2084b03a 	or	r2,r4,r2
8013a838:	1009883a 	mov	r4,r2
8013a83c:	d0a0a744 	addi	r2,gp,-32099
8013a840:	1885883a 	add	r2,r3,r2
8013a844:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8013a848:	e0bff817 	ldw	r2,-32(fp)
8013a84c:	10800717 	ldw	r2,28(r2)
8013a850:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8013a854:	e0bff317 	ldw	r2,-52(fp)
8013a858:	10003326 	beq	r2,zero,8013a928 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8013a85c:	e0bffc03 	ldbu	r2,-16(fp)
8013a860:	e0fffc03 	ldbu	r3,-16(fp)
8013a864:	e13ff317 	ldw	r4,-52(fp)
8013a868:	20c7883a 	add	r3,r4,r3
8013a86c:	18c002c4 	addi	r3,r3,11
8013a870:	18c00003 	ldbu	r3,0(r3)
8013a874:	1809883a 	mov	r4,r3
8013a878:	e0fffc83 	ldbu	r3,-14(fp)
8013a87c:	00c6303a 	nor	r3,zero,r3
8013a880:	20c6703a 	and	r3,r4,r3
8013a884:	1809883a 	mov	r4,r3
8013a888:	e0fff317 	ldw	r3,-52(fp)
8013a88c:	1885883a 	add	r2,r3,r2
8013a890:	108002c4 	addi	r2,r2,11
8013a894:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8013a898:	e0bffc03 	ldbu	r2,-16(fp)
8013a89c:	e0fff317 	ldw	r3,-52(fp)
8013a8a0:	1885883a 	add	r2,r3,r2
8013a8a4:	108002c4 	addi	r2,r2,11
8013a8a8:	10800003 	ldbu	r2,0(r2)
8013a8ac:	10803fcc 	andi	r2,r2,255
8013a8b0:	1000091e 	bne	r2,zero,8013a8d8 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8013a8b4:	e0bff317 	ldw	r2,-52(fp)
8013a8b8:	10800283 	ldbu	r2,10(r2)
8013a8bc:	1007883a 	mov	r3,r2
8013a8c0:	e0bffc43 	ldbu	r2,-15(fp)
8013a8c4:	0084303a 	nor	r2,zero,r2
8013a8c8:	1884703a 	and	r2,r3,r2
8013a8cc:	1007883a 	mov	r3,r2
8013a8d0:	e0bff317 	ldw	r2,-52(fp)
8013a8d4:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8013a8d8:	e0bff317 	ldw	r2,-52(fp)
8013a8dc:	10c00283 	ldbu	r3,10(r2)
8013a8e0:	e0bffb83 	ldbu	r2,-18(fp)
8013a8e4:	1884b03a 	or	r2,r3,r2
8013a8e8:	1007883a 	mov	r3,r2
8013a8ec:	e0bff317 	ldw	r2,-52(fp)
8013a8f0:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8013a8f4:	e0bffb03 	ldbu	r2,-20(fp)
8013a8f8:	e0fffb03 	ldbu	r3,-20(fp)
8013a8fc:	e13ff317 	ldw	r4,-52(fp)
8013a900:	20c7883a 	add	r3,r4,r3
8013a904:	18c002c4 	addi	r3,r3,11
8013a908:	19000003 	ldbu	r4,0(r3)
8013a90c:	e0fffbc3 	ldbu	r3,-17(fp)
8013a910:	20c6b03a 	or	r3,r4,r3
8013a914:	1809883a 	mov	r4,r3
8013a918:	e0fff317 	ldw	r3,-52(fp)
8013a91c:	1885883a 	add	r2,r3,r2
8013a920:	108002c4 	addi	r2,r2,11
8013a924:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8013a928:	e0bff817 	ldw	r2,-32(fp)
8013a92c:	10800817 	ldw	r2,32(r2)
8013a930:	10004226 	beq	r2,zero,8013aa3c <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8013a934:	e0bff817 	ldw	r2,-32(fp)
8013a938:	10800817 	ldw	r2,32(r2)
8013a93c:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8013a940:	e0bff417 	ldw	r2,-48(fp)
8013a944:	10800017 	ldw	r2,0(r2)
8013a948:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8013a94c:	00003906 	br	8013aa34 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8013a950:	e0bffc03 	ldbu	r2,-16(fp)
8013a954:	e0fffc03 	ldbu	r3,-16(fp)
8013a958:	e13ff317 	ldw	r4,-52(fp)
8013a95c:	20c7883a 	add	r3,r4,r3
8013a960:	18c002c4 	addi	r3,r3,11
8013a964:	18c00003 	ldbu	r3,0(r3)
8013a968:	1809883a 	mov	r4,r3
8013a96c:	e0fffc83 	ldbu	r3,-14(fp)
8013a970:	00c6303a 	nor	r3,zero,r3
8013a974:	20c6703a 	and	r3,r4,r3
8013a978:	1809883a 	mov	r4,r3
8013a97c:	e0fff317 	ldw	r3,-52(fp)
8013a980:	1885883a 	add	r2,r3,r2
8013a984:	108002c4 	addi	r2,r2,11
8013a988:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8013a98c:	e0bffc03 	ldbu	r2,-16(fp)
8013a990:	e0fff317 	ldw	r3,-52(fp)
8013a994:	1885883a 	add	r2,r3,r2
8013a998:	108002c4 	addi	r2,r2,11
8013a99c:	10800003 	ldbu	r2,0(r2)
8013a9a0:	10803fcc 	andi	r2,r2,255
8013a9a4:	1000091e 	bne	r2,zero,8013a9cc <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8013a9a8:	e0bff317 	ldw	r2,-52(fp)
8013a9ac:	10800283 	ldbu	r2,10(r2)
8013a9b0:	1007883a 	mov	r3,r2
8013a9b4:	e0bffc43 	ldbu	r2,-15(fp)
8013a9b8:	0084303a 	nor	r2,zero,r2
8013a9bc:	1884703a 	and	r2,r3,r2
8013a9c0:	1007883a 	mov	r3,r2
8013a9c4:	e0bff317 	ldw	r2,-52(fp)
8013a9c8:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8013a9cc:	e0bff317 	ldw	r2,-52(fp)
8013a9d0:	10c00283 	ldbu	r3,10(r2)
8013a9d4:	e0bffb83 	ldbu	r2,-18(fp)
8013a9d8:	1884b03a 	or	r2,r3,r2
8013a9dc:	1007883a 	mov	r3,r2
8013a9e0:	e0bff317 	ldw	r2,-52(fp)
8013a9e4:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8013a9e8:	e0bffb03 	ldbu	r2,-20(fp)
8013a9ec:	e0fffb03 	ldbu	r3,-20(fp)
8013a9f0:	e13ff317 	ldw	r4,-52(fp)
8013a9f4:	20c7883a 	add	r3,r4,r3
8013a9f8:	18c002c4 	addi	r3,r3,11
8013a9fc:	19000003 	ldbu	r4,0(r3)
8013aa00:	e0fffbc3 	ldbu	r3,-17(fp)
8013aa04:	20c6b03a 	or	r3,r4,r3
8013aa08:	1809883a 	mov	r4,r3
8013aa0c:	e0fff317 	ldw	r3,-52(fp)
8013aa10:	1885883a 	add	r2,r3,r2
8013aa14:	108002c4 	addi	r2,r2,11
8013aa18:	11000005 	stb	r4,0(r2)
            pevents++;
8013aa1c:	e0bff417 	ldw	r2,-48(fp)
8013aa20:	10800104 	addi	r2,r2,4
8013aa24:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8013aa28:	e0bff417 	ldw	r2,-48(fp)
8013aa2c:	10800017 	ldw	r2,0(r2)
8013aa30:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8013aa34:	e0bff317 	ldw	r2,-52(fp)
8013aa38:	103fc51e 	bne	r2,zero,8013a950 <__reset+0xfa11a950>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8013aa3c:	e0bff817 	ldw	r2,-32(fp)
8013aa40:	e0ffff03 	ldbu	r3,-4(fp)
8013aa44:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8013aa48:	e0bff817 	ldw	r2,-32(fp)
8013aa4c:	e0fffb03 	ldbu	r3,-20(fp)
8013aa50:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8013aa54:	e0bff817 	ldw	r2,-32(fp)
8013aa58:	e0fffb43 	ldbu	r3,-19(fp)
8013aa5c:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8013aa60:	e0bff817 	ldw	r2,-32(fp)
8013aa64:	e0fffb83 	ldbu	r3,-18(fp)
8013aa68:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8013aa6c:	e0bff817 	ldw	r2,-32(fp)
8013aa70:	e0fffbc3 	ldbu	r3,-17(fp)
8013aa74:	10c00d45 	stb	r3,53(r2)
8013aa78:	e0bff517 	ldw	r2,-44(fp)
8013aa7c:	e0bffa15 	stw	r2,-24(fp)
8013aa80:	e0bffa17 	ldw	r2,-24(fp)
8013aa84:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8013aa88:	d0a09a03 	ldbu	r2,-32152(gp)
8013aa8c:	10803fcc 	andi	r2,r2,255
8013aa90:	10800058 	cmpnei	r2,r2,1
8013aa94:	1000011e 	bne	r2,zero,8013aa9c <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8013aa98:	013504c0 	call	8013504c <OS_Sched>
    }
    return (OS_ERR_NONE);
8013aa9c:	0005883a 	mov	r2,zero
}
8013aaa0:	e037883a 	mov	sp,fp
8013aaa4:	dfc00117 	ldw	ra,4(sp)
8013aaa8:	df000017 	ldw	fp,0(sp)
8013aaac:	dec00204 	addi	sp,sp,8
8013aab0:	f800283a 	ret

8013aab4 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8013aab4:	deffee04 	addi	sp,sp,-72
8013aab8:	de00012e 	bgeu	sp,et,8013aac0 <OSTaskCreate+0xc>
8013aabc:	003b68fa 	trap	3
8013aac0:	dfc01115 	stw	ra,68(sp)
8013aac4:	df001015 	stw	fp,64(sp)
8013aac8:	df001004 	addi	fp,sp,64
8013aacc:	e13ffc15 	stw	r4,-16(fp)
8013aad0:	e17ffd15 	stw	r5,-12(fp)
8013aad4:	e1bffe15 	stw	r6,-8(fp)
8013aad8:	3805883a 	mov	r2,r7
8013aadc:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8013aae0:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8013aae4:	e0bfff03 	ldbu	r2,-4(fp)
8013aae8:	10800af0 	cmpltui	r2,r2,43
8013aaec:	1000021e 	bne	r2,zero,8013aaf8 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8013aaf0:	00800a84 	movi	r2,42
8013aaf4:	00005706 	br	8013ac54 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013aaf8:	0005303a 	rdctl	r2,status
8013aafc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013ab00:	e0fffb17 	ldw	r3,-20(fp)
8013ab04:	00bfff84 	movi	r2,-2
8013ab08:	1884703a 	and	r2,r3,r2
8013ab0c:	1001703a 	wrctl	status,r2
  
  return context;
8013ab10:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8013ab14:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8013ab18:	d0a0aa03 	ldbu	r2,-32088(gp)
8013ab1c:	10803fcc 	andi	r2,r2,255
8013ab20:	10000626 	beq	r2,zero,8013ab3c <OSTaskCreate+0x88>
8013ab24:	e0bff317 	ldw	r2,-52(fp)
8013ab28:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013ab2c:	e0bff417 	ldw	r2,-48(fp)
8013ab30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8013ab34:	00800f04 	movi	r2,60
8013ab38:	00004606 	br	8013ac54 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8013ab3c:	e0ffff03 	ldbu	r3,-4(fp)
8013ab40:	00a005b4 	movhi	r2,32790
8013ab44:	10924b04 	addi	r2,r2,18732
8013ab48:	18c7883a 	add	r3,r3,r3
8013ab4c:	18c7883a 	add	r3,r3,r3
8013ab50:	10c5883a 	add	r2,r2,r3
8013ab54:	10800017 	ldw	r2,0(r2)
8013ab58:	1000391e 	bne	r2,zero,8013ac40 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8013ab5c:	e0ffff03 	ldbu	r3,-4(fp)
8013ab60:	00a005b4 	movhi	r2,32790
8013ab64:	10924b04 	addi	r2,r2,18732
8013ab68:	18c7883a 	add	r3,r3,r3
8013ab6c:	18c7883a 	add	r3,r3,r3
8013ab70:	10c5883a 	add	r2,r2,r3
8013ab74:	00c00044 	movi	r3,1
8013ab78:	10c00015 	stw	r3,0(r2)
8013ab7c:	e0bff317 	ldw	r2,-52(fp)
8013ab80:	e0bff515 	stw	r2,-44(fp)
8013ab84:	e0bff517 	ldw	r2,-44(fp)
8013ab88:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8013ab8c:	000f883a 	mov	r7,zero
8013ab90:	e1bffe17 	ldw	r6,-8(fp)
8013ab94:	e17ffd17 	ldw	r5,-12(fp)
8013ab98:	e13ffc17 	ldw	r4,-16(fp)
8013ab9c:	01461d40 	call	801461d4 <OSTaskStkInit>
8013aba0:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8013aba4:	e0bfff03 	ldbu	r2,-4(fp)
8013aba8:	d8000215 	stw	zero,8(sp)
8013abac:	d8000115 	stw	zero,4(sp)
8013abb0:	d8000015 	stw	zero,0(sp)
8013abb4:	000f883a 	mov	r7,zero
8013abb8:	000d883a 	mov	r6,zero
8013abbc:	e17ff717 	ldw	r5,-36(fp)
8013abc0:	1009883a 	mov	r4,r2
8013abc4:	01354940 	call	80135494 <OS_TCBInit>
8013abc8:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8013abcc:	e0bff803 	ldbu	r2,-32(fp)
8013abd0:	1000061e 	bne	r2,zero,8013abec <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8013abd4:	d0a09a03 	ldbu	r2,-32152(gp)
8013abd8:	10803fcc 	andi	r2,r2,255
8013abdc:	10800058 	cmpnei	r2,r2,1
8013abe0:	1000151e 	bne	r2,zero,8013ac38 <OSTaskCreate+0x184>
                OS_Sched();
8013abe4:	013504c0 	call	8013504c <OS_Sched>
8013abe8:	00001306 	br	8013ac38 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013abec:	0005303a 	rdctl	r2,status
8013abf0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013abf4:	e0fffa17 	ldw	r3,-24(fp)
8013abf8:	00bfff84 	movi	r2,-2
8013abfc:	1884703a 	and	r2,r3,r2
8013ac00:	1001703a 	wrctl	status,r2
  
  return context;
8013ac04:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8013ac08:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8013ac0c:	e0ffff03 	ldbu	r3,-4(fp)
8013ac10:	00a005b4 	movhi	r2,32790
8013ac14:	10924b04 	addi	r2,r2,18732
8013ac18:	18c7883a 	add	r3,r3,r3
8013ac1c:	18c7883a 	add	r3,r3,r3
8013ac20:	10c5883a 	add	r2,r2,r3
8013ac24:	10000015 	stw	zero,0(r2)
8013ac28:	e0bff317 	ldw	r2,-52(fp)
8013ac2c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013ac30:	e0bff617 	ldw	r2,-40(fp)
8013ac34:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8013ac38:	e0bff803 	ldbu	r2,-32(fp)
8013ac3c:	00000506 	br	8013ac54 <OSTaskCreate+0x1a0>
8013ac40:	e0bff317 	ldw	r2,-52(fp)
8013ac44:	e0bff915 	stw	r2,-28(fp)
8013ac48:	e0bff917 	ldw	r2,-28(fp)
8013ac4c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8013ac50:	00800a04 	movi	r2,40
}
8013ac54:	e037883a 	mov	sp,fp
8013ac58:	dfc00117 	ldw	ra,4(sp)
8013ac5c:	df000017 	ldw	fp,0(sp)
8013ac60:	dec00204 	addi	sp,sp,8
8013ac64:	f800283a 	ret

8013ac68 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8013ac68:	deffec04 	addi	sp,sp,-80
8013ac6c:	de00012e 	bgeu	sp,et,8013ac74 <OSTaskCreateExt+0xc>
8013ac70:	003b68fa 	trap	3
8013ac74:	dfc01315 	stw	ra,76(sp)
8013ac78:	df001215 	stw	fp,72(sp)
8013ac7c:	df001204 	addi	fp,sp,72
8013ac80:	e13ffa15 	stw	r4,-24(fp)
8013ac84:	e17ffb15 	stw	r5,-20(fp)
8013ac88:	e1bffc15 	stw	r6,-16(fp)
8013ac8c:	3809883a 	mov	r4,r7
8013ac90:	e0c00217 	ldw	r3,8(fp)
8013ac94:	e0800617 	ldw	r2,24(fp)
8013ac98:	e13ffd05 	stb	r4,-12(fp)
8013ac9c:	e0fffe0d 	sth	r3,-8(fp)
8013aca0:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8013aca4:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8013aca8:	e0bffd03 	ldbu	r2,-12(fp)
8013acac:	10800af0 	cmpltui	r2,r2,43
8013acb0:	1000021e 	bne	r2,zero,8013acbc <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8013acb4:	00800a84 	movi	r2,42
8013acb8:	00006106 	br	8013ae40 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013acbc:	0005303a 	rdctl	r2,status
8013acc0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013acc4:	e0fff917 	ldw	r3,-28(fp)
8013acc8:	00bfff84 	movi	r2,-2
8013accc:	1884703a 	and	r2,r3,r2
8013acd0:	1001703a 	wrctl	status,r2
  
  return context;
8013acd4:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8013acd8:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8013acdc:	d0a0aa03 	ldbu	r2,-32088(gp)
8013ace0:	10803fcc 	andi	r2,r2,255
8013ace4:	10000626 	beq	r2,zero,8013ad00 <OSTaskCreateExt+0x98>
8013ace8:	e0bff117 	ldw	r2,-60(fp)
8013acec:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013acf0:	e0bff217 	ldw	r2,-56(fp)
8013acf4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8013acf8:	00800f04 	movi	r2,60
8013acfc:	00005006 	br	8013ae40 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8013ad00:	e0fffd03 	ldbu	r3,-12(fp)
8013ad04:	00a005b4 	movhi	r2,32790
8013ad08:	10924b04 	addi	r2,r2,18732
8013ad0c:	18c7883a 	add	r3,r3,r3
8013ad10:	18c7883a 	add	r3,r3,r3
8013ad14:	10c5883a 	add	r2,r2,r3
8013ad18:	10800017 	ldw	r2,0(r2)
8013ad1c:	1000431e 	bne	r2,zero,8013ae2c <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8013ad20:	e0fffd03 	ldbu	r3,-12(fp)
8013ad24:	00a005b4 	movhi	r2,32790
8013ad28:	10924b04 	addi	r2,r2,18732
8013ad2c:	18c7883a 	add	r3,r3,r3
8013ad30:	18c7883a 	add	r3,r3,r3
8013ad34:	10c5883a 	add	r2,r2,r3
8013ad38:	00c00044 	movi	r3,1
8013ad3c:	10c00015 	stw	r3,0(r2)
8013ad40:	e0bff117 	ldw	r2,-60(fp)
8013ad44:	e0bff315 	stw	r2,-52(fp)
8013ad48:	e0bff317 	ldw	r2,-52(fp)
8013ad4c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8013ad50:	e0bfff0b 	ldhu	r2,-4(fp)
8013ad54:	100d883a 	mov	r6,r2
8013ad58:	e1400417 	ldw	r5,16(fp)
8013ad5c:	e1000317 	ldw	r4,12(fp)
8013ad60:	013bd100 	call	8013bd10 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8013ad64:	e0bfff0b 	ldhu	r2,-4(fp)
8013ad68:	100f883a 	mov	r7,r2
8013ad6c:	e1bffc17 	ldw	r6,-16(fp)
8013ad70:	e17ffb17 	ldw	r5,-20(fp)
8013ad74:	e13ffa17 	ldw	r4,-24(fp)
8013ad78:	01461d40 	call	801461d4 <OSTaskStkInit>
8013ad7c:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8013ad80:	e0fffd03 	ldbu	r3,-12(fp)
8013ad84:	e13ffe0b 	ldhu	r4,-8(fp)
8013ad88:	e0bfff0b 	ldhu	r2,-4(fp)
8013ad8c:	d8800215 	stw	r2,8(sp)
8013ad90:	e0800517 	ldw	r2,20(fp)
8013ad94:	d8800115 	stw	r2,4(sp)
8013ad98:	e0800417 	ldw	r2,16(fp)
8013ad9c:	d8800015 	stw	r2,0(sp)
8013ada0:	200f883a 	mov	r7,r4
8013ada4:	e1800317 	ldw	r6,12(fp)
8013ada8:	e17ff517 	ldw	r5,-44(fp)
8013adac:	1809883a 	mov	r4,r3
8013adb0:	01354940 	call	80135494 <OS_TCBInit>
8013adb4:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8013adb8:	e0bff603 	ldbu	r2,-40(fp)
8013adbc:	1000061e 	bne	r2,zero,8013add8 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8013adc0:	d0a09a03 	ldbu	r2,-32152(gp)
8013adc4:	10803fcc 	andi	r2,r2,255
8013adc8:	10800058 	cmpnei	r2,r2,1
8013adcc:	1000151e 	bne	r2,zero,8013ae24 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8013add0:	013504c0 	call	8013504c <OS_Sched>
8013add4:	00001306 	br	8013ae24 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013add8:	0005303a 	rdctl	r2,status
8013addc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013ade0:	e0fff817 	ldw	r3,-32(fp)
8013ade4:	00bfff84 	movi	r2,-2
8013ade8:	1884703a 	and	r2,r3,r2
8013adec:	1001703a 	wrctl	status,r2
  
  return context;
8013adf0:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8013adf4:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8013adf8:	e0fffd03 	ldbu	r3,-12(fp)
8013adfc:	00a005b4 	movhi	r2,32790
8013ae00:	10924b04 	addi	r2,r2,18732
8013ae04:	18c7883a 	add	r3,r3,r3
8013ae08:	18c7883a 	add	r3,r3,r3
8013ae0c:	10c5883a 	add	r2,r2,r3
8013ae10:	10000015 	stw	zero,0(r2)
8013ae14:	e0bff117 	ldw	r2,-60(fp)
8013ae18:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013ae1c:	e0bff417 	ldw	r2,-48(fp)
8013ae20:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8013ae24:	e0bff603 	ldbu	r2,-40(fp)
8013ae28:	00000506 	br	8013ae40 <OSTaskCreateExt+0x1d8>
8013ae2c:	e0bff117 	ldw	r2,-60(fp)
8013ae30:	e0bff715 	stw	r2,-36(fp)
8013ae34:	e0bff717 	ldw	r2,-36(fp)
8013ae38:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8013ae3c:	00800a04 	movi	r2,40
}
8013ae40:	e037883a 	mov	sp,fp
8013ae44:	dfc00117 	ldw	ra,4(sp)
8013ae48:	df000017 	ldw	fp,0(sp)
8013ae4c:	dec00204 	addi	sp,sp,8
8013ae50:	f800283a 	ret

8013ae54 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8013ae54:	defff404 	addi	sp,sp,-48
8013ae58:	de00012e 	bgeu	sp,et,8013ae60 <OSTaskDel+0xc>
8013ae5c:	003b68fa 	trap	3
8013ae60:	dfc00b15 	stw	ra,44(sp)
8013ae64:	df000a15 	stw	fp,40(sp)
8013ae68:	df000a04 	addi	fp,sp,40
8013ae6c:	2005883a 	mov	r2,r4
8013ae70:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8013ae74:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8013ae78:	d0a0aa03 	ldbu	r2,-32088(gp)
8013ae7c:	10803fcc 	andi	r2,r2,255
8013ae80:	10000226 	beq	r2,zero,8013ae8c <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8013ae84:	00801004 	movi	r2,64
8013ae88:	0000c006 	br	8013b18c <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8013ae8c:	e0bfff03 	ldbu	r2,-4(fp)
8013ae90:	10800a98 	cmpnei	r2,r2,42
8013ae94:	1000021e 	bne	r2,zero,8013aea0 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8013ae98:	00800f84 	movi	r2,62
8013ae9c:	0000bb06 	br	8013b18c <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8013aea0:	e0bfff03 	ldbu	r2,-4(fp)
8013aea4:	10800ab0 	cmpltui	r2,r2,42
8013aea8:	1000051e 	bne	r2,zero,8013aec0 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8013aeac:	e0bfff03 	ldbu	r2,-4(fp)
8013aeb0:	10803fe0 	cmpeqi	r2,r2,255
8013aeb4:	1000021e 	bne	r2,zero,8013aec0 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8013aeb8:	00800a84 	movi	r2,42
8013aebc:	0000b306 	br	8013b18c <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013aec0:	0005303a 	rdctl	r2,status
8013aec4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013aec8:	e0fffe17 	ldw	r3,-8(fp)
8013aecc:	00bfff84 	movi	r2,-2
8013aed0:	1884703a 	and	r2,r3,r2
8013aed4:	1001703a 	wrctl	status,r2
  
  return context;
8013aed8:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8013aedc:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8013aee0:	e0bfff03 	ldbu	r2,-4(fp)
8013aee4:	10803fd8 	cmpnei	r2,r2,255
8013aee8:	1000031e 	bne	r2,zero,8013aef8 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8013aeec:	d0a0ab17 	ldw	r2,-32084(gp)
8013aef0:	10800c83 	ldbu	r2,50(r2)
8013aef4:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8013aef8:	e0ffff03 	ldbu	r3,-4(fp)
8013aefc:	00a005b4 	movhi	r2,32790
8013af00:	10924b04 	addi	r2,r2,18732
8013af04:	18c7883a 	add	r3,r3,r3
8013af08:	18c7883a 	add	r3,r3,r3
8013af0c:	10c5883a 	add	r2,r2,r3
8013af10:	10800017 	ldw	r2,0(r2)
8013af14:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8013af18:	e0bff817 	ldw	r2,-32(fp)
8013af1c:	1000061e 	bne	r2,zero,8013af38 <OSTaskDel+0xe4>
8013af20:	e0bff617 	ldw	r2,-40(fp)
8013af24:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013af28:	e0bff717 	ldw	r2,-36(fp)
8013af2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8013af30:	008010c4 	movi	r2,67
8013af34:	00009506 	br	8013b18c <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8013af38:	e0bff817 	ldw	r2,-32(fp)
8013af3c:	10800058 	cmpnei	r2,r2,1
8013af40:	1000061e 	bne	r2,zero,8013af5c <OSTaskDel+0x108>
8013af44:	e0bff617 	ldw	r2,-40(fp)
8013af48:	e0bff915 	stw	r2,-28(fp)
8013af4c:	e0bff917 	ldw	r2,-28(fp)
8013af50:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8013af54:	00800f44 	movi	r2,61
8013af58:	00008c06 	br	8013b18c <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8013af5c:	e0bff817 	ldw	r2,-32(fp)
8013af60:	10800d03 	ldbu	r2,52(r2)
8013af64:	10c03fcc 	andi	r3,r2,255
8013af68:	e0bff817 	ldw	r2,-32(fp)
8013af6c:	10800d03 	ldbu	r2,52(r2)
8013af70:	11003fcc 	andi	r4,r2,255
8013af74:	d0a0a744 	addi	r2,gp,-32099
8013af78:	2085883a 	add	r2,r4,r2
8013af7c:	10800003 	ldbu	r2,0(r2)
8013af80:	1009883a 	mov	r4,r2
8013af84:	e0bff817 	ldw	r2,-32(fp)
8013af88:	10800d43 	ldbu	r2,53(r2)
8013af8c:	0084303a 	nor	r2,zero,r2
8013af90:	2084703a 	and	r2,r4,r2
8013af94:	1009883a 	mov	r4,r2
8013af98:	d0a0a744 	addi	r2,gp,-32099
8013af9c:	1885883a 	add	r2,r3,r2
8013afa0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8013afa4:	e0bff817 	ldw	r2,-32(fp)
8013afa8:	10800d03 	ldbu	r2,52(r2)
8013afac:	10c03fcc 	andi	r3,r2,255
8013afb0:	d0a0a744 	addi	r2,gp,-32099
8013afb4:	1885883a 	add	r2,r3,r2
8013afb8:	10800003 	ldbu	r2,0(r2)
8013afbc:	10803fcc 	andi	r2,r2,255
8013afc0:	1000071e 	bne	r2,zero,8013afe0 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8013afc4:	e0bff817 	ldw	r2,-32(fp)
8013afc8:	10800d83 	ldbu	r2,54(r2)
8013afcc:	0084303a 	nor	r2,zero,r2
8013afd0:	1007883a 	mov	r3,r2
8013afd4:	d0a0a703 	ldbu	r2,-32100(gp)
8013afd8:	1884703a 	and	r2,r3,r2
8013afdc:	d0a0a705 	stb	r2,-32100(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8013afe0:	e0bff817 	ldw	r2,-32(fp)
8013afe4:	10800717 	ldw	r2,28(r2)
8013afe8:	10000526 	beq	r2,zero,8013b000 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8013afec:	e0bff817 	ldw	r2,-32(fp)
8013aff0:	10800717 	ldw	r2,28(r2)
8013aff4:	100b883a 	mov	r5,r2
8013aff8:	e13ff817 	ldw	r4,-32(fp)
8013affc:	01349a00 	call	801349a0 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8013b000:	e0bff817 	ldw	r2,-32(fp)
8013b004:	10800817 	ldw	r2,32(r2)
8013b008:	10000526 	beq	r2,zero,8013b020 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8013b00c:	e0bff817 	ldw	r2,-32(fp)
8013b010:	10800817 	ldw	r2,32(r2)
8013b014:	100b883a 	mov	r5,r2
8013b018:	e13ff817 	ldw	r4,-32(fp)
8013b01c:	0134a600 	call	80134a60 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8013b020:	e0bff817 	ldw	r2,-32(fp)
8013b024:	10800a17 	ldw	r2,40(r2)
8013b028:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8013b02c:	e0bffb17 	ldw	r2,-20(fp)
8013b030:	10000226 	beq	r2,zero,8013b03c <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8013b034:	e13ffb17 	ldw	r4,-20(fp)
8013b038:	01370380 	call	80137038 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8013b03c:	e0bff817 	ldw	r2,-32(fp)
8013b040:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8013b044:	e0bff817 	ldw	r2,-32(fp)
8013b048:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8013b04c:	e0bff817 	ldw	r2,-32(fp)
8013b050:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8013b054:	d0a09803 	ldbu	r2,-32160(gp)
8013b058:	10803fcc 	andi	r2,r2,255
8013b05c:	10803fe0 	cmpeqi	r2,r2,255
8013b060:	1000031e 	bne	r2,zero,8013b070 <OSTaskDel+0x21c>
        OSLockNesting++;
8013b064:	d0a09803 	ldbu	r2,-32160(gp)
8013b068:	10800044 	addi	r2,r2,1
8013b06c:	d0a09805 	stb	r2,-32160(gp)
8013b070:	e0bff617 	ldw	r2,-40(fp)
8013b074:	e0bffd15 	stw	r2,-12(fp)
8013b078:	e0bffd17 	ldw	r2,-12(fp)
8013b07c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8013b080:	01345680 	call	80134568 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013b084:	0005303a 	rdctl	r2,status
8013b088:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013b08c:	e0fffa17 	ldw	r3,-24(fp)
8013b090:	00bfff84 	movi	r2,-2
8013b094:	1884703a 	and	r2,r3,r2
8013b098:	1001703a 	wrctl	status,r2
  
  return context;
8013b09c:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8013b0a0:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8013b0a4:	d0a09803 	ldbu	r2,-32160(gp)
8013b0a8:	10803fcc 	andi	r2,r2,255
8013b0ac:	10000326 	beq	r2,zero,8013b0bc <OSTaskDel+0x268>
        OSLockNesting--;
8013b0b0:	d0a09803 	ldbu	r2,-32160(gp)
8013b0b4:	10bfffc4 	addi	r2,r2,-1
8013b0b8:	d0a09805 	stb	r2,-32160(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8013b0bc:	e13ff817 	ldw	r4,-32(fp)
8013b0c0:	01463640 	call	80146364 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8013b0c4:	d0a0a343 	ldbu	r2,-32115(gp)
8013b0c8:	10bfffc4 	addi	r2,r2,-1
8013b0cc:	d0a0a345 	stb	r2,-32115(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8013b0d0:	e0ffff03 	ldbu	r3,-4(fp)
8013b0d4:	00a005b4 	movhi	r2,32790
8013b0d8:	10924b04 	addi	r2,r2,18732
8013b0dc:	18c7883a 	add	r3,r3,r3
8013b0e0:	18c7883a 	add	r3,r3,r3
8013b0e4:	10c5883a 	add	r2,r2,r3
8013b0e8:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8013b0ec:	e0bff817 	ldw	r2,-32(fp)
8013b0f0:	10800617 	ldw	r2,24(r2)
8013b0f4:	1000071e 	bne	r2,zero,8013b114 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8013b0f8:	e0bff817 	ldw	r2,-32(fp)
8013b0fc:	10800517 	ldw	r2,20(r2)
8013b100:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8013b104:	e0bff817 	ldw	r2,-32(fp)
8013b108:	10800517 	ldw	r2,20(r2)
8013b10c:	d0a09d15 	stw	r2,-32140(gp)
8013b110:	00000a06 	br	8013b13c <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8013b114:	e0bff817 	ldw	r2,-32(fp)
8013b118:	10800617 	ldw	r2,24(r2)
8013b11c:	e0fff817 	ldw	r3,-32(fp)
8013b120:	18c00517 	ldw	r3,20(r3)
8013b124:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8013b128:	e0bff817 	ldw	r2,-32(fp)
8013b12c:	10800517 	ldw	r2,20(r2)
8013b130:	e0fff817 	ldw	r3,-32(fp)
8013b134:	18c00617 	ldw	r3,24(r3)
8013b138:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8013b13c:	d0e0a217 	ldw	r3,-32120(gp)
8013b140:	e0bff817 	ldw	r2,-32(fp)
8013b144:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8013b148:	e0bff817 	ldw	r2,-32(fp)
8013b14c:	d0a0a215 	stw	r2,-32120(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8013b150:	e0bff817 	ldw	r2,-32(fp)
8013b154:	00c00fc4 	movi	r3,63
8013b158:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8013b15c:	e0bff817 	ldw	r2,-32(fp)
8013b160:	10001345 	stb	zero,77(r2)
8013b164:	e0bff617 	ldw	r2,-40(fp)
8013b168:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013b16c:	e0bffc17 	ldw	r2,-16(fp)
8013b170:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8013b174:	d0a09a03 	ldbu	r2,-32152(gp)
8013b178:	10803fcc 	andi	r2,r2,255
8013b17c:	10800058 	cmpnei	r2,r2,1
8013b180:	1000011e 	bne	r2,zero,8013b188 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8013b184:	013504c0 	call	8013504c <OS_Sched>
    }
    return (OS_ERR_NONE);
8013b188:	0005883a 	mov	r2,zero
}
8013b18c:	e037883a 	mov	sp,fp
8013b190:	dfc00117 	ldw	ra,4(sp)
8013b194:	df000017 	ldw	fp,0(sp)
8013b198:	dec00204 	addi	sp,sp,8
8013b19c:	f800283a 	ret

8013b1a0 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8013b1a0:	defff504 	addi	sp,sp,-44
8013b1a4:	de00012e 	bgeu	sp,et,8013b1ac <OSTaskDelReq+0xc>
8013b1a8:	003b68fa 	trap	3
8013b1ac:	df000a15 	stw	fp,40(sp)
8013b1b0:	df000a04 	addi	fp,sp,40
8013b1b4:	2005883a 	mov	r2,r4
8013b1b8:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8013b1bc:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8013b1c0:	e0bfff03 	ldbu	r2,-4(fp)
8013b1c4:	10800a98 	cmpnei	r2,r2,42
8013b1c8:	1000021e 	bne	r2,zero,8013b1d4 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8013b1cc:	00800f84 	movi	r2,62
8013b1d0:	00004506 	br	8013b2e8 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8013b1d4:	e0bfff03 	ldbu	r2,-4(fp)
8013b1d8:	10800ab0 	cmpltui	r2,r2,42
8013b1dc:	1000051e 	bne	r2,zero,8013b1f4 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8013b1e0:	e0bfff03 	ldbu	r2,-4(fp)
8013b1e4:	10803fe0 	cmpeqi	r2,r2,255
8013b1e8:	1000021e 	bne	r2,zero,8013b1f4 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8013b1ec:	00800a84 	movi	r2,42
8013b1f0:	00003d06 	br	8013b2e8 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8013b1f4:	e0bfff03 	ldbu	r2,-4(fp)
8013b1f8:	10803fd8 	cmpnei	r2,r2,255
8013b1fc:	1000111e 	bne	r2,zero,8013b244 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013b200:	0005303a 	rdctl	r2,status
8013b204:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013b208:	e0fff917 	ldw	r3,-28(fp)
8013b20c:	00bfff84 	movi	r2,-2
8013b210:	1884703a 	and	r2,r3,r2
8013b214:	1001703a 	wrctl	status,r2
  
  return context;
8013b218:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8013b21c:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8013b220:	d0a0ab17 	ldw	r2,-32084(gp)
8013b224:	10800dc3 	ldbu	r2,55(r2)
8013b228:	e0bff805 	stb	r2,-32(fp)
8013b22c:	e0bff617 	ldw	r2,-40(fp)
8013b230:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013b234:	e0bffe17 	ldw	r2,-8(fp)
8013b238:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8013b23c:	e0bff803 	ldbu	r2,-32(fp)
8013b240:	00002906 	br	8013b2e8 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013b244:	0005303a 	rdctl	r2,status
8013b248:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013b24c:	e0fff717 	ldw	r3,-36(fp)
8013b250:	00bfff84 	movi	r2,-2
8013b254:	1884703a 	and	r2,r3,r2
8013b258:	1001703a 	wrctl	status,r2
  
  return context;
8013b25c:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8013b260:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8013b264:	e0ffff03 	ldbu	r3,-4(fp)
8013b268:	00a005b4 	movhi	r2,32790
8013b26c:	10924b04 	addi	r2,r2,18732
8013b270:	18c7883a 	add	r3,r3,r3
8013b274:	18c7883a 	add	r3,r3,r3
8013b278:	10c5883a 	add	r2,r2,r3
8013b27c:	10800017 	ldw	r2,0(r2)
8013b280:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8013b284:	e0bffb17 	ldw	r2,-20(fp)
8013b288:	1000061e 	bne	r2,zero,8013b2a4 <OSTaskDelReq+0x104>
8013b28c:	e0bff617 	ldw	r2,-40(fp)
8013b290:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013b294:	e0bffa17 	ldw	r2,-24(fp)
8013b298:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8013b29c:	008010c4 	movi	r2,67
8013b2a0:	00001106 	br	8013b2e8 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8013b2a4:	e0bffb17 	ldw	r2,-20(fp)
8013b2a8:	10800058 	cmpnei	r2,r2,1
8013b2ac:	1000061e 	bne	r2,zero,8013b2c8 <OSTaskDelReq+0x128>
8013b2b0:	e0bff617 	ldw	r2,-40(fp)
8013b2b4:	e0bffc15 	stw	r2,-16(fp)
8013b2b8:	e0bffc17 	ldw	r2,-16(fp)
8013b2bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8013b2c0:	00800f44 	movi	r2,61
8013b2c4:	00000806 	br	8013b2e8 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8013b2c8:	e0bffb17 	ldw	r2,-20(fp)
8013b2cc:	00c00fc4 	movi	r3,63
8013b2d0:	10c00dc5 	stb	r3,55(r2)
8013b2d4:	e0bff617 	ldw	r2,-40(fp)
8013b2d8:	e0bffd15 	stw	r2,-12(fp)
8013b2dc:	e0bffd17 	ldw	r2,-12(fp)
8013b2e0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8013b2e4:	0005883a 	mov	r2,zero
}
8013b2e8:	e037883a 	mov	sp,fp
8013b2ec:	df000017 	ldw	fp,0(sp)
8013b2f0:	dec00104 	addi	sp,sp,4
8013b2f4:	f800283a 	ret

8013b2f8 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8013b2f8:	defff404 	addi	sp,sp,-48
8013b2fc:	de00012e 	bgeu	sp,et,8013b304 <OSTaskNameGet+0xc>
8013b300:	003b68fa 	trap	3
8013b304:	dfc00b15 	stw	ra,44(sp)
8013b308:	df000a15 	stw	fp,40(sp)
8013b30c:	df000a04 	addi	fp,sp,40
8013b310:	2005883a 	mov	r2,r4
8013b314:	e17ffe15 	stw	r5,-8(fp)
8013b318:	e1bfff15 	stw	r6,-4(fp)
8013b31c:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8013b320:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8013b324:	e0bfff17 	ldw	r2,-4(fp)
8013b328:	1000021e 	bne	r2,zero,8013b334 <OSTaskNameGet+0x3c>
        return (0);
8013b32c:	0005883a 	mov	r2,zero
8013b330:	00005406 	br	8013b484 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8013b334:	e0bffd03 	ldbu	r2,-12(fp)
8013b338:	10800af0 	cmpltui	r2,r2,43
8013b33c:	1000081e 	bne	r2,zero,8013b360 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8013b340:	e0bffd03 	ldbu	r2,-12(fp)
8013b344:	10803fe0 	cmpeqi	r2,r2,255
8013b348:	1000051e 	bne	r2,zero,8013b360 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8013b34c:	e0bfff17 	ldw	r2,-4(fp)
8013b350:	00c00a84 	movi	r3,42
8013b354:	10c00005 	stb	r3,0(r2)
            return (0);
8013b358:	0005883a 	mov	r2,zero
8013b35c:	00004906 	br	8013b484 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8013b360:	e0bffe17 	ldw	r2,-8(fp)
8013b364:	1000051e 	bne	r2,zero,8013b37c <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8013b368:	e0bfff17 	ldw	r2,-4(fp)
8013b36c:	00c00304 	movi	r3,12
8013b370:	10c00005 	stb	r3,0(r2)
        return (0);
8013b374:	0005883a 	mov	r2,zero
8013b378:	00004206 	br	8013b484 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8013b37c:	d0a0aa03 	ldbu	r2,-32088(gp)
8013b380:	10803fcc 	andi	r2,r2,255
8013b384:	10000526 	beq	r2,zero,8013b39c <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8013b388:	e0bfff17 	ldw	r2,-4(fp)
8013b38c:	00c00444 	movi	r3,17
8013b390:	10c00005 	stb	r3,0(r2)
        return (0);
8013b394:	0005883a 	mov	r2,zero
8013b398:	00003a06 	br	8013b484 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013b39c:	0005303a 	rdctl	r2,status
8013b3a0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013b3a4:	e0fffc17 	ldw	r3,-16(fp)
8013b3a8:	00bfff84 	movi	r2,-2
8013b3ac:	1884703a 	and	r2,r3,r2
8013b3b0:	1001703a 	wrctl	status,r2
  
  return context;
8013b3b4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8013b3b8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8013b3bc:	e0bffd03 	ldbu	r2,-12(fp)
8013b3c0:	10803fd8 	cmpnei	r2,r2,255
8013b3c4:	1000031e 	bne	r2,zero,8013b3d4 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8013b3c8:	d0a0ab17 	ldw	r2,-32084(gp)
8013b3cc:	10800c83 	ldbu	r2,50(r2)
8013b3d0:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8013b3d4:	e0fffd03 	ldbu	r3,-12(fp)
8013b3d8:	00a005b4 	movhi	r2,32790
8013b3dc:	10924b04 	addi	r2,r2,18732
8013b3e0:	18c7883a 	add	r3,r3,r3
8013b3e4:	18c7883a 	add	r3,r3,r3
8013b3e8:	10c5883a 	add	r2,r2,r3
8013b3ec:	10800017 	ldw	r2,0(r2)
8013b3f0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8013b3f4:	e0bff817 	ldw	r2,-32(fp)
8013b3f8:	1000091e 	bne	r2,zero,8013b420 <OSTaskNameGet+0x128>
8013b3fc:	e0bff617 	ldw	r2,-40(fp)
8013b400:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013b404:	e0bff717 	ldw	r2,-36(fp)
8013b408:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8013b40c:	e0bfff17 	ldw	r2,-4(fp)
8013b410:	00c010c4 	movi	r3,67
8013b414:	10c00005 	stb	r3,0(r2)
        return (0);
8013b418:	0005883a 	mov	r2,zero
8013b41c:	00001906 	br	8013b484 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8013b420:	e0bff817 	ldw	r2,-32(fp)
8013b424:	10800058 	cmpnei	r2,r2,1
8013b428:	1000091e 	bne	r2,zero,8013b450 <OSTaskNameGet+0x158>
8013b42c:	e0bff617 	ldw	r2,-40(fp)
8013b430:	e0bff915 	stw	r2,-28(fp)
8013b434:	e0bff917 	ldw	r2,-28(fp)
8013b438:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8013b43c:	e0bfff17 	ldw	r2,-4(fp)
8013b440:	00c010c4 	movi	r3,67
8013b444:	10c00005 	stb	r3,0(r2)
        return (0);
8013b448:	0005883a 	mov	r2,zero
8013b44c:	00000d06 	br	8013b484 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8013b450:	e0bff817 	ldw	r2,-32(fp)
8013b454:	10801304 	addi	r2,r2,76
8013b458:	100b883a 	mov	r5,r2
8013b45c:	e13ffe17 	ldw	r4,-8(fp)
8013b460:	01351a00 	call	801351a0 <OS_StrCopy>
8013b464:	e0bffb05 	stb	r2,-20(fp)
8013b468:	e0bff617 	ldw	r2,-40(fp)
8013b46c:	e0bffa15 	stw	r2,-24(fp)
8013b470:	e0bffa17 	ldw	r2,-24(fp)
8013b474:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8013b478:	e0bfff17 	ldw	r2,-4(fp)
8013b47c:	10000005 	stb	zero,0(r2)
    return (len);
8013b480:	e0bffb03 	ldbu	r2,-20(fp)
}
8013b484:	e037883a 	mov	sp,fp
8013b488:	dfc00117 	ldw	ra,4(sp)
8013b48c:	df000017 	ldw	fp,0(sp)
8013b490:	dec00204 	addi	sp,sp,8
8013b494:	f800283a 	ret

8013b498 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8013b498:	defff304 	addi	sp,sp,-52
8013b49c:	de00012e 	bgeu	sp,et,8013b4a4 <OSTaskNameSet+0xc>
8013b4a0:	003b68fa 	trap	3
8013b4a4:	dfc00c15 	stw	ra,48(sp)
8013b4a8:	df000b15 	stw	fp,44(sp)
8013b4ac:	df000b04 	addi	fp,sp,44
8013b4b0:	2005883a 	mov	r2,r4
8013b4b4:	e17ffe15 	stw	r5,-8(fp)
8013b4b8:	e1bfff15 	stw	r6,-4(fp)
8013b4bc:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8013b4c0:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8013b4c4:	e0bfff17 	ldw	r2,-4(fp)
8013b4c8:	10005c26 	beq	r2,zero,8013b63c <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8013b4cc:	e0bffd03 	ldbu	r2,-12(fp)
8013b4d0:	10800af0 	cmpltui	r2,r2,43
8013b4d4:	1000071e 	bne	r2,zero,8013b4f4 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8013b4d8:	e0bffd03 	ldbu	r2,-12(fp)
8013b4dc:	10803fe0 	cmpeqi	r2,r2,255
8013b4e0:	1000041e 	bne	r2,zero,8013b4f4 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8013b4e4:	e0bfff17 	ldw	r2,-4(fp)
8013b4e8:	00c00a84 	movi	r3,42
8013b4ec:	10c00005 	stb	r3,0(r2)
            return;
8013b4f0:	00005306 	br	8013b640 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8013b4f4:	e0bffe17 	ldw	r2,-8(fp)
8013b4f8:	1000041e 	bne	r2,zero,8013b50c <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8013b4fc:	e0bfff17 	ldw	r2,-4(fp)
8013b500:	00c00304 	movi	r3,12
8013b504:	10c00005 	stb	r3,0(r2)
        return;
8013b508:	00004d06 	br	8013b640 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8013b50c:	d0a0aa03 	ldbu	r2,-32088(gp)
8013b510:	10803fcc 	andi	r2,r2,255
8013b514:	10000426 	beq	r2,zero,8013b528 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8013b518:	e0bfff17 	ldw	r2,-4(fp)
8013b51c:	00c00484 	movi	r3,18
8013b520:	10c00005 	stb	r3,0(r2)
        return;
8013b524:	00004606 	br	8013b640 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013b528:	0005303a 	rdctl	r2,status
8013b52c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013b530:	e0fffc17 	ldw	r3,-16(fp)
8013b534:	00bfff84 	movi	r2,-2
8013b538:	1884703a 	and	r2,r3,r2
8013b53c:	1001703a 	wrctl	status,r2
  
  return context;
8013b540:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8013b544:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8013b548:	e0bffd03 	ldbu	r2,-12(fp)
8013b54c:	10803fd8 	cmpnei	r2,r2,255
8013b550:	1000031e 	bne	r2,zero,8013b560 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8013b554:	d0a0ab17 	ldw	r2,-32084(gp)
8013b558:	10800c83 	ldbu	r2,50(r2)
8013b55c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8013b560:	e0fffd03 	ldbu	r3,-12(fp)
8013b564:	00a005b4 	movhi	r2,32790
8013b568:	10924b04 	addi	r2,r2,18732
8013b56c:	18c7883a 	add	r3,r3,r3
8013b570:	18c7883a 	add	r3,r3,r3
8013b574:	10c5883a 	add	r2,r2,r3
8013b578:	10800017 	ldw	r2,0(r2)
8013b57c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8013b580:	e0bff717 	ldw	r2,-36(fp)
8013b584:	1000081e 	bne	r2,zero,8013b5a8 <OSTaskNameSet+0x110>
8013b588:	e0bff517 	ldw	r2,-44(fp)
8013b58c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013b590:	e0bff617 	ldw	r2,-40(fp)
8013b594:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8013b598:	e0bfff17 	ldw	r2,-4(fp)
8013b59c:	00c010c4 	movi	r3,67
8013b5a0:	10c00005 	stb	r3,0(r2)
        return;
8013b5a4:	00002606 	br	8013b640 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8013b5a8:	e0bff717 	ldw	r2,-36(fp)
8013b5ac:	10800058 	cmpnei	r2,r2,1
8013b5b0:	1000081e 	bne	r2,zero,8013b5d4 <OSTaskNameSet+0x13c>
8013b5b4:	e0bff517 	ldw	r2,-44(fp)
8013b5b8:	e0bff815 	stw	r2,-32(fp)
8013b5bc:	e0bff817 	ldw	r2,-32(fp)
8013b5c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8013b5c4:	e0bfff17 	ldw	r2,-4(fp)
8013b5c8:	00c010c4 	movi	r3,67
8013b5cc:	10c00005 	stb	r3,0(r2)
        return;
8013b5d0:	00001b06 	br	8013b640 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8013b5d4:	e13ffe17 	ldw	r4,-8(fp)
8013b5d8:	013521c0 	call	8013521c <OS_StrLen>
8013b5dc:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8013b5e0:	e0bffa03 	ldbu	r2,-24(fp)
8013b5e4:	10800830 	cmpltui	r2,r2,32
8013b5e8:	1000081e 	bne	r2,zero,8013b60c <OSTaskNameSet+0x174>
8013b5ec:	e0bff517 	ldw	r2,-44(fp)
8013b5f0:	e0bff915 	stw	r2,-28(fp)
8013b5f4:	e0bff917 	ldw	r2,-28(fp)
8013b5f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8013b5fc:	e0bfff17 	ldw	r2,-4(fp)
8013b600:	00c01044 	movi	r3,65
8013b604:	10c00005 	stb	r3,0(r2)
        return;
8013b608:	00000d06 	br	8013b640 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8013b60c:	e0bff717 	ldw	r2,-36(fp)
8013b610:	10801304 	addi	r2,r2,76
8013b614:	e17ffe17 	ldw	r5,-8(fp)
8013b618:	1009883a 	mov	r4,r2
8013b61c:	01351a00 	call	801351a0 <OS_StrCopy>
8013b620:	e0bff517 	ldw	r2,-44(fp)
8013b624:	e0bffb15 	stw	r2,-20(fp)
8013b628:	e0bffb17 	ldw	r2,-20(fp)
8013b62c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8013b630:	e0bfff17 	ldw	r2,-4(fp)
8013b634:	10000005 	stb	zero,0(r2)
8013b638:	00000106 	br	8013b640 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8013b63c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8013b640:	e037883a 	mov	sp,fp
8013b644:	dfc00117 	ldw	ra,4(sp)
8013b648:	df000017 	ldw	fp,0(sp)
8013b64c:	dec00204 	addi	sp,sp,8
8013b650:	f800283a 	ret

8013b654 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8013b654:	defff404 	addi	sp,sp,-48
8013b658:	de00012e 	bgeu	sp,et,8013b660 <OSTaskResume+0xc>
8013b65c:	003b68fa 	trap	3
8013b660:	dfc00b15 	stw	ra,44(sp)
8013b664:	df000a15 	stw	fp,40(sp)
8013b668:	df000a04 	addi	fp,sp,40
8013b66c:	2005883a 	mov	r2,r4
8013b670:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8013b674:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8013b678:	e0bfff03 	ldbu	r2,-4(fp)
8013b67c:	10800ab0 	cmpltui	r2,r2,42
8013b680:	1000021e 	bne	r2,zero,8013b68c <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8013b684:	00800a84 	movi	r2,42
8013b688:	00006406 	br	8013b81c <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013b68c:	0005303a 	rdctl	r2,status
8013b690:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013b694:	e0fffe17 	ldw	r3,-8(fp)
8013b698:	00bfff84 	movi	r2,-2
8013b69c:	1884703a 	and	r2,r3,r2
8013b6a0:	1001703a 	wrctl	status,r2
  
  return context;
8013b6a4:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8013b6a8:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8013b6ac:	e0ffff03 	ldbu	r3,-4(fp)
8013b6b0:	00a005b4 	movhi	r2,32790
8013b6b4:	10924b04 	addi	r2,r2,18732
8013b6b8:	18c7883a 	add	r3,r3,r3
8013b6bc:	18c7883a 	add	r3,r3,r3
8013b6c0:	10c5883a 	add	r2,r2,r3
8013b6c4:	10800017 	ldw	r2,0(r2)
8013b6c8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8013b6cc:	e0bff817 	ldw	r2,-32(fp)
8013b6d0:	1000061e 	bne	r2,zero,8013b6ec <OSTaskResume+0x98>
8013b6d4:	e0bff617 	ldw	r2,-40(fp)
8013b6d8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013b6dc:	e0bff717 	ldw	r2,-36(fp)
8013b6e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8013b6e4:	00801184 	movi	r2,70
8013b6e8:	00004c06 	br	8013b81c <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8013b6ec:	e0bff817 	ldw	r2,-32(fp)
8013b6f0:	10800058 	cmpnei	r2,r2,1
8013b6f4:	1000061e 	bne	r2,zero,8013b710 <OSTaskResume+0xbc>
8013b6f8:	e0bff617 	ldw	r2,-40(fp)
8013b6fc:	e0bff915 	stw	r2,-28(fp)
8013b700:	e0bff917 	ldw	r2,-28(fp)
8013b704:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8013b708:	008010c4 	movi	r2,67
8013b70c:	00004306 	br	8013b81c <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8013b710:	e0bff817 	ldw	r2,-32(fp)
8013b714:	10800c03 	ldbu	r2,48(r2)
8013b718:	10803fcc 	andi	r2,r2,255
8013b71c:	1080020c 	andi	r2,r2,8
8013b720:	10003926 	beq	r2,zero,8013b808 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8013b724:	e0bff817 	ldw	r2,-32(fp)
8013b728:	10c00c03 	ldbu	r3,48(r2)
8013b72c:	00bffdc4 	movi	r2,-9
8013b730:	1884703a 	and	r2,r3,r2
8013b734:	1007883a 	mov	r3,r2
8013b738:	e0bff817 	ldw	r2,-32(fp)
8013b73c:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8013b740:	e0bff817 	ldw	r2,-32(fp)
8013b744:	10800c03 	ldbu	r2,48(r2)
8013b748:	10803fcc 	andi	r2,r2,255
8013b74c:	1000281e 	bne	r2,zero,8013b7f0 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8013b750:	e0bff817 	ldw	r2,-32(fp)
8013b754:	10800b8b 	ldhu	r2,46(r2)
8013b758:	10bfffcc 	andi	r2,r2,65535
8013b75c:	10001f1e 	bne	r2,zero,8013b7dc <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8013b760:	e0bff817 	ldw	r2,-32(fp)
8013b764:	10c00d83 	ldbu	r3,54(r2)
8013b768:	d0a0a703 	ldbu	r2,-32100(gp)
8013b76c:	1884b03a 	or	r2,r3,r2
8013b770:	d0a0a705 	stb	r2,-32100(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8013b774:	e0bff817 	ldw	r2,-32(fp)
8013b778:	10800d03 	ldbu	r2,52(r2)
8013b77c:	10c03fcc 	andi	r3,r2,255
8013b780:	e0bff817 	ldw	r2,-32(fp)
8013b784:	10800d03 	ldbu	r2,52(r2)
8013b788:	11003fcc 	andi	r4,r2,255
8013b78c:	d0a0a744 	addi	r2,gp,-32099
8013b790:	2085883a 	add	r2,r4,r2
8013b794:	11000003 	ldbu	r4,0(r2)
8013b798:	e0bff817 	ldw	r2,-32(fp)
8013b79c:	10800d43 	ldbu	r2,53(r2)
8013b7a0:	2084b03a 	or	r2,r4,r2
8013b7a4:	1009883a 	mov	r4,r2
8013b7a8:	d0a0a744 	addi	r2,gp,-32099
8013b7ac:	1885883a 	add	r2,r3,r2
8013b7b0:	11000005 	stb	r4,0(r2)
8013b7b4:	e0bff617 	ldw	r2,-40(fp)
8013b7b8:	e0bffa15 	stw	r2,-24(fp)
8013b7bc:	e0bffa17 	ldw	r2,-24(fp)
8013b7c0:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8013b7c4:	d0a09a03 	ldbu	r2,-32152(gp)
8013b7c8:	10803fcc 	andi	r2,r2,255
8013b7cc:	10800058 	cmpnei	r2,r2,1
8013b7d0:	10000b1e 	bne	r2,zero,8013b800 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8013b7d4:	013504c0 	call	8013504c <OS_Sched>
8013b7d8:	00000906 	br	8013b800 <OSTaskResume+0x1ac>
8013b7dc:	e0bff617 	ldw	r2,-40(fp)
8013b7e0:	e0bffb15 	stw	r2,-20(fp)
8013b7e4:	e0bffb17 	ldw	r2,-20(fp)
8013b7e8:	1001703a 	wrctl	status,r2
8013b7ec:	00000406 	br	8013b800 <OSTaskResume+0x1ac>
8013b7f0:	e0bff617 	ldw	r2,-40(fp)
8013b7f4:	e0bffc15 	stw	r2,-16(fp)
8013b7f8:	e0bffc17 	ldw	r2,-16(fp)
8013b7fc:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8013b800:	0005883a 	mov	r2,zero
8013b804:	00000506 	br	8013b81c <OSTaskResume+0x1c8>
8013b808:	e0bff617 	ldw	r2,-40(fp)
8013b80c:	e0bffd15 	stw	r2,-12(fp)
8013b810:	e0bffd17 	ldw	r2,-12(fp)
8013b814:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8013b818:	00801104 	movi	r2,68
}
8013b81c:	e037883a 	mov	sp,fp
8013b820:	dfc00117 	ldw	ra,4(sp)
8013b824:	df000017 	ldw	fp,0(sp)
8013b828:	dec00204 	addi	sp,sp,8
8013b82c:	f800283a 	ret

8013b830 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8013b830:	defff304 	addi	sp,sp,-52
8013b834:	de00012e 	bgeu	sp,et,8013b83c <OSTaskStkChk+0xc>
8013b838:	003b68fa 	trap	3
8013b83c:	df000c15 	stw	fp,48(sp)
8013b840:	df000c04 	addi	fp,sp,48
8013b844:	2005883a 	mov	r2,r4
8013b848:	e17fff15 	stw	r5,-4(fp)
8013b84c:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8013b850:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8013b854:	e0bffe03 	ldbu	r2,-8(fp)
8013b858:	10800af0 	cmpltui	r2,r2,43
8013b85c:	1000051e 	bne	r2,zero,8013b874 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8013b860:	e0bffe03 	ldbu	r2,-8(fp)
8013b864:	10803fe0 	cmpeqi	r2,r2,255
8013b868:	1000021e 	bne	r2,zero,8013b874 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8013b86c:	00800a84 	movi	r2,42
8013b870:	00005d06 	br	8013b9e8 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8013b874:	e0bfff17 	ldw	r2,-4(fp)
8013b878:	1000021e 	bne	r2,zero,8013b884 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8013b87c:	00800244 	movi	r2,9
8013b880:	00005906 	br	8013b9e8 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8013b884:	e0bfff17 	ldw	r2,-4(fp)
8013b888:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8013b88c:	e0bfff17 	ldw	r2,-4(fp)
8013b890:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013b894:	0005303a 	rdctl	r2,status
8013b898:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013b89c:	e0fffd17 	ldw	r3,-12(fp)
8013b8a0:	00bfff84 	movi	r2,-2
8013b8a4:	1884703a 	and	r2,r3,r2
8013b8a8:	1001703a 	wrctl	status,r2
  
  return context;
8013b8ac:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8013b8b0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8013b8b4:	e0bffe03 	ldbu	r2,-8(fp)
8013b8b8:	10803fd8 	cmpnei	r2,r2,255
8013b8bc:	1000031e 	bne	r2,zero,8013b8cc <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8013b8c0:	d0a0ab17 	ldw	r2,-32084(gp)
8013b8c4:	10800c83 	ldbu	r2,50(r2)
8013b8c8:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8013b8cc:	e0fffe03 	ldbu	r3,-8(fp)
8013b8d0:	00a005b4 	movhi	r2,32790
8013b8d4:	10924b04 	addi	r2,r2,18732
8013b8d8:	18c7883a 	add	r3,r3,r3
8013b8dc:	18c7883a 	add	r3,r3,r3
8013b8e0:	10c5883a 	add	r2,r2,r3
8013b8e4:	10800017 	ldw	r2,0(r2)
8013b8e8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8013b8ec:	e0bff817 	ldw	r2,-32(fp)
8013b8f0:	1000061e 	bne	r2,zero,8013b90c <OSTaskStkChk+0xdc>
8013b8f4:	e0bff617 	ldw	r2,-40(fp)
8013b8f8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013b8fc:	e0bff717 	ldw	r2,-36(fp)
8013b900:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8013b904:	008010c4 	movi	r2,67
8013b908:	00003706 	br	8013b9e8 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8013b90c:	e0bff817 	ldw	r2,-32(fp)
8013b910:	10800058 	cmpnei	r2,r2,1
8013b914:	1000061e 	bne	r2,zero,8013b930 <OSTaskStkChk+0x100>
8013b918:	e0bff617 	ldw	r2,-40(fp)
8013b91c:	e0bff915 	stw	r2,-28(fp)
8013b920:	e0bff917 	ldw	r2,-28(fp)
8013b924:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8013b928:	008010c4 	movi	r2,67
8013b92c:	00002e06 	br	8013b9e8 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8013b930:	e0bff817 	ldw	r2,-32(fp)
8013b934:	1080040b 	ldhu	r2,16(r2)
8013b938:	10bfffcc 	andi	r2,r2,65535
8013b93c:	1080004c 	andi	r2,r2,1
8013b940:	1000061e 	bne	r2,zero,8013b95c <OSTaskStkChk+0x12c>
8013b944:	e0bff617 	ldw	r2,-40(fp)
8013b948:	e0bffa15 	stw	r2,-24(fp)
8013b94c:	e0bffa17 	ldw	r2,-24(fp)
8013b950:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8013b954:	00801144 	movi	r2,69
8013b958:	00002306 	br	8013b9e8 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8013b95c:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8013b960:	e0bff817 	ldw	r2,-32(fp)
8013b964:	10800317 	ldw	r2,12(r2)
8013b968:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8013b96c:	e0bff817 	ldw	r2,-32(fp)
8013b970:	10800217 	ldw	r2,8(r2)
8013b974:	e0bff415 	stw	r2,-48(fp)
8013b978:	e0bff617 	ldw	r2,-40(fp)
8013b97c:	e0bffb15 	stw	r2,-20(fp)
8013b980:	e0bffb17 	ldw	r2,-20(fp)
8013b984:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8013b988:	00000306 	br	8013b998 <OSTaskStkChk+0x168>
        nfree++;
8013b98c:	e0bff517 	ldw	r2,-44(fp)
8013b990:	10800044 	addi	r2,r2,1
8013b994:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8013b998:	e0bff417 	ldw	r2,-48(fp)
8013b99c:	10c00104 	addi	r3,r2,4
8013b9a0:	e0fff415 	stw	r3,-48(fp)
8013b9a4:	10800017 	ldw	r2,0(r2)
8013b9a8:	103ff826 	beq	r2,zero,8013b98c <__reset+0xfa11b98c>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8013b9ac:	e0bff517 	ldw	r2,-44(fp)
8013b9b0:	1085883a 	add	r2,r2,r2
8013b9b4:	1085883a 	add	r2,r2,r2
8013b9b8:	1007883a 	mov	r3,r2
8013b9bc:	e0bfff17 	ldw	r2,-4(fp)
8013b9c0:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8013b9c4:	e0fffc17 	ldw	r3,-16(fp)
8013b9c8:	e0bff517 	ldw	r2,-44(fp)
8013b9cc:	1885c83a 	sub	r2,r3,r2
8013b9d0:	1085883a 	add	r2,r2,r2
8013b9d4:	1085883a 	add	r2,r2,r2
8013b9d8:	1007883a 	mov	r3,r2
8013b9dc:	e0bfff17 	ldw	r2,-4(fp)
8013b9e0:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8013b9e4:	0005883a 	mov	r2,zero
}
8013b9e8:	e037883a 	mov	sp,fp
8013b9ec:	df000017 	ldw	fp,0(sp)
8013b9f0:	dec00104 	addi	sp,sp,4
8013b9f4:	f800283a 	ret

8013b9f8 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8013b9f8:	defff504 	addi	sp,sp,-44
8013b9fc:	de00012e 	bgeu	sp,et,8013ba04 <OSTaskSuspend+0xc>
8013ba00:	003b68fa 	trap	3
8013ba04:	dfc00a15 	stw	ra,40(sp)
8013ba08:	df000915 	stw	fp,36(sp)
8013ba0c:	df000904 	addi	fp,sp,36
8013ba10:	2005883a 	mov	r2,r4
8013ba14:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8013ba18:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8013ba1c:	e0bfff03 	ldbu	r2,-4(fp)
8013ba20:	10800a98 	cmpnei	r2,r2,42
8013ba24:	1000021e 	bne	r2,zero,8013ba30 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8013ba28:	008011c4 	movi	r2,71
8013ba2c:	00006806 	br	8013bbd0 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8013ba30:	e0bfff03 	ldbu	r2,-4(fp)
8013ba34:	10800ab0 	cmpltui	r2,r2,42
8013ba38:	1000051e 	bne	r2,zero,8013ba50 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8013ba3c:	e0bfff03 	ldbu	r2,-4(fp)
8013ba40:	10803fe0 	cmpeqi	r2,r2,255
8013ba44:	1000021e 	bne	r2,zero,8013ba50 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8013ba48:	00800a84 	movi	r2,42
8013ba4c:	00006006 	br	8013bbd0 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013ba50:	0005303a 	rdctl	r2,status
8013ba54:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013ba58:	e0fffe17 	ldw	r3,-8(fp)
8013ba5c:	00bfff84 	movi	r2,-2
8013ba60:	1884703a 	and	r2,r3,r2
8013ba64:	1001703a 	wrctl	status,r2
  
  return context;
8013ba68:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8013ba6c:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8013ba70:	e0bfff03 	ldbu	r2,-4(fp)
8013ba74:	10803fd8 	cmpnei	r2,r2,255
8013ba78:	1000061e 	bne	r2,zero,8013ba94 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8013ba7c:	d0a0ab17 	ldw	r2,-32084(gp)
8013ba80:	10800c83 	ldbu	r2,50(r2)
8013ba84:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8013ba88:	00800044 	movi	r2,1
8013ba8c:	e0bff705 	stb	r2,-36(fp)
8013ba90:	00000906 	br	8013bab8 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8013ba94:	d0a0ab17 	ldw	r2,-32084(gp)
8013ba98:	10800c83 	ldbu	r2,50(r2)
8013ba9c:	10c03fcc 	andi	r3,r2,255
8013baa0:	e0bfff03 	ldbu	r2,-4(fp)
8013baa4:	1880031e 	bne	r3,r2,8013bab4 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8013baa8:	00800044 	movi	r2,1
8013baac:	e0bff705 	stb	r2,-36(fp)
8013bab0:	00000106 	br	8013bab8 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8013bab4:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8013bab8:	e0ffff03 	ldbu	r3,-4(fp)
8013babc:	00a005b4 	movhi	r2,32790
8013bac0:	10924b04 	addi	r2,r2,18732
8013bac4:	18c7883a 	add	r3,r3,r3
8013bac8:	18c7883a 	add	r3,r3,r3
8013bacc:	10c5883a 	add	r2,r2,r3
8013bad0:	10800017 	ldw	r2,0(r2)
8013bad4:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8013bad8:	e0bffa17 	ldw	r2,-24(fp)
8013badc:	1000061e 	bne	r2,zero,8013baf8 <OSTaskSuspend+0x100>
8013bae0:	e0bff817 	ldw	r2,-32(fp)
8013bae4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013bae8:	e0bff917 	ldw	r2,-28(fp)
8013baec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8013baf0:	00801204 	movi	r2,72
8013baf4:	00003606 	br	8013bbd0 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8013baf8:	e0bffa17 	ldw	r2,-24(fp)
8013bafc:	10800058 	cmpnei	r2,r2,1
8013bb00:	1000061e 	bne	r2,zero,8013bb1c <OSTaskSuspend+0x124>
8013bb04:	e0bff817 	ldw	r2,-32(fp)
8013bb08:	e0bffb15 	stw	r2,-20(fp)
8013bb0c:	e0bffb17 	ldw	r2,-20(fp)
8013bb10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8013bb14:	008010c4 	movi	r2,67
8013bb18:	00002d06 	br	8013bbd0 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8013bb1c:	e0bffa17 	ldw	r2,-24(fp)
8013bb20:	10800d03 	ldbu	r2,52(r2)
8013bb24:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8013bb28:	e0fffd03 	ldbu	r3,-12(fp)
8013bb2c:	e13ffd03 	ldbu	r4,-12(fp)
8013bb30:	d0a0a744 	addi	r2,gp,-32099
8013bb34:	2085883a 	add	r2,r4,r2
8013bb38:	10800003 	ldbu	r2,0(r2)
8013bb3c:	1009883a 	mov	r4,r2
8013bb40:	e0bffa17 	ldw	r2,-24(fp)
8013bb44:	10800d43 	ldbu	r2,53(r2)
8013bb48:	0084303a 	nor	r2,zero,r2
8013bb4c:	2084703a 	and	r2,r4,r2
8013bb50:	1009883a 	mov	r4,r2
8013bb54:	d0a0a744 	addi	r2,gp,-32099
8013bb58:	1885883a 	add	r2,r3,r2
8013bb5c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8013bb60:	e0fffd03 	ldbu	r3,-12(fp)
8013bb64:	d0a0a744 	addi	r2,gp,-32099
8013bb68:	1885883a 	add	r2,r3,r2
8013bb6c:	10800003 	ldbu	r2,0(r2)
8013bb70:	10803fcc 	andi	r2,r2,255
8013bb74:	1000071e 	bne	r2,zero,8013bb94 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8013bb78:	e0bffa17 	ldw	r2,-24(fp)
8013bb7c:	10800d83 	ldbu	r2,54(r2)
8013bb80:	0084303a 	nor	r2,zero,r2
8013bb84:	1007883a 	mov	r3,r2
8013bb88:	d0a0a703 	ldbu	r2,-32100(gp)
8013bb8c:	1884703a 	and	r2,r3,r2
8013bb90:	d0a0a705 	stb	r2,-32100(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8013bb94:	e0bffa17 	ldw	r2,-24(fp)
8013bb98:	10800c03 	ldbu	r2,48(r2)
8013bb9c:	10800214 	ori	r2,r2,8
8013bba0:	1007883a 	mov	r3,r2
8013bba4:	e0bffa17 	ldw	r2,-24(fp)
8013bba8:	10c00c05 	stb	r3,48(r2)
8013bbac:	e0bff817 	ldw	r2,-32(fp)
8013bbb0:	e0bffc15 	stw	r2,-16(fp)
8013bbb4:	e0bffc17 	ldw	r2,-16(fp)
8013bbb8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8013bbbc:	e0bff703 	ldbu	r2,-36(fp)
8013bbc0:	10800058 	cmpnei	r2,r2,1
8013bbc4:	1000011e 	bne	r2,zero,8013bbcc <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8013bbc8:	013504c0 	call	8013504c <OS_Sched>
    }
    return (OS_ERR_NONE);
8013bbcc:	0005883a 	mov	r2,zero
}
8013bbd0:	e037883a 	mov	sp,fp
8013bbd4:	dfc00117 	ldw	ra,4(sp)
8013bbd8:	df000017 	ldw	fp,0(sp)
8013bbdc:	dec00204 	addi	sp,sp,8
8013bbe0:	f800283a 	ret

8013bbe4 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8013bbe4:	defff604 	addi	sp,sp,-40
8013bbe8:	de00012e 	bgeu	sp,et,8013bbf0 <OSTaskQuery+0xc>
8013bbec:	003b68fa 	trap	3
8013bbf0:	dfc00915 	stw	ra,36(sp)
8013bbf4:	df000815 	stw	fp,32(sp)
8013bbf8:	df000804 	addi	fp,sp,32
8013bbfc:	2005883a 	mov	r2,r4
8013bc00:	e17fff15 	stw	r5,-4(fp)
8013bc04:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8013bc08:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8013bc0c:	e0bffe03 	ldbu	r2,-8(fp)
8013bc10:	10800af0 	cmpltui	r2,r2,43
8013bc14:	1000051e 	bne	r2,zero,8013bc2c <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8013bc18:	e0bffe03 	ldbu	r2,-8(fp)
8013bc1c:	10803fe0 	cmpeqi	r2,r2,255
8013bc20:	1000021e 	bne	r2,zero,8013bc2c <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8013bc24:	00800a84 	movi	r2,42
8013bc28:	00003406 	br	8013bcfc <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8013bc2c:	e0bfff17 	ldw	r2,-4(fp)
8013bc30:	1000021e 	bne	r2,zero,8013bc3c <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8013bc34:	00800244 	movi	r2,9
8013bc38:	00003006 	br	8013bcfc <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013bc3c:	0005303a 	rdctl	r2,status
8013bc40:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013bc44:	e0fffd17 	ldw	r3,-12(fp)
8013bc48:	00bfff84 	movi	r2,-2
8013bc4c:	1884703a 	and	r2,r3,r2
8013bc50:	1001703a 	wrctl	status,r2
  
  return context;
8013bc54:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8013bc58:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8013bc5c:	e0bffe03 	ldbu	r2,-8(fp)
8013bc60:	10803fd8 	cmpnei	r2,r2,255
8013bc64:	1000031e 	bne	r2,zero,8013bc74 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8013bc68:	d0a0ab17 	ldw	r2,-32084(gp)
8013bc6c:	10800c83 	ldbu	r2,50(r2)
8013bc70:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8013bc74:	e0fffe03 	ldbu	r3,-8(fp)
8013bc78:	00a005b4 	movhi	r2,32790
8013bc7c:	10924b04 	addi	r2,r2,18732
8013bc80:	18c7883a 	add	r3,r3,r3
8013bc84:	18c7883a 	add	r3,r3,r3
8013bc88:	10c5883a 	add	r2,r2,r3
8013bc8c:	10800017 	ldw	r2,0(r2)
8013bc90:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8013bc94:	e0bffa17 	ldw	r2,-24(fp)
8013bc98:	1000061e 	bne	r2,zero,8013bcb4 <OSTaskQuery+0xd0>
8013bc9c:	e0bff817 	ldw	r2,-32(fp)
8013bca0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013bca4:	e0bff917 	ldw	r2,-28(fp)
8013bca8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8013bcac:	00800a44 	movi	r2,41
8013bcb0:	00001206 	br	8013bcfc <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8013bcb4:	e0bffa17 	ldw	r2,-24(fp)
8013bcb8:	10800058 	cmpnei	r2,r2,1
8013bcbc:	1000061e 	bne	r2,zero,8013bcd8 <OSTaskQuery+0xf4>
8013bcc0:	e0bff817 	ldw	r2,-32(fp)
8013bcc4:	e0bffb15 	stw	r2,-20(fp)
8013bcc8:	e0bffb17 	ldw	r2,-20(fp)
8013bccc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8013bcd0:	008010c4 	movi	r2,67
8013bcd4:	00000906 	br	8013bcfc <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8013bcd8:	01801b04 	movi	r6,108
8013bcdc:	e17ffa17 	ldw	r5,-24(fp)
8013bce0:	e13fff17 	ldw	r4,-4(fp)
8013bce4:	0134fdc0 	call	80134fdc <OS_MemCopy>
8013bce8:	e0bff817 	ldw	r2,-32(fp)
8013bcec:	e0bffc15 	stw	r2,-16(fp)
8013bcf0:	e0bffc17 	ldw	r2,-16(fp)
8013bcf4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8013bcf8:	0005883a 	mov	r2,zero
}
8013bcfc:	e037883a 	mov	sp,fp
8013bd00:	dfc00117 	ldw	ra,4(sp)
8013bd04:	df000017 	ldw	fp,0(sp)
8013bd08:	dec00204 	addi	sp,sp,8
8013bd0c:	f800283a 	ret

8013bd10 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8013bd10:	defffc04 	addi	sp,sp,-16
8013bd14:	de00012e 	bgeu	sp,et,8013bd1c <OS_TaskStkClr+0xc>
8013bd18:	003b68fa 	trap	3
8013bd1c:	df000315 	stw	fp,12(sp)
8013bd20:	df000304 	addi	fp,sp,12
8013bd24:	e13ffd15 	stw	r4,-12(fp)
8013bd28:	e17ffe15 	stw	r5,-8(fp)
8013bd2c:	3005883a 	mov	r2,r6
8013bd30:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8013bd34:	e0bfff0b 	ldhu	r2,-4(fp)
8013bd38:	1080004c 	andi	r2,r2,1
8013bd3c:	10000d26 	beq	r2,zero,8013bd74 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8013bd40:	e0bfff0b 	ldhu	r2,-4(fp)
8013bd44:	1080008c 	andi	r2,r2,2
8013bd48:	10000a26 	beq	r2,zero,8013bd74 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8013bd4c:	00000706 	br	8013bd6c <OS_TaskStkClr+0x5c>
                size--;
8013bd50:	e0bffe17 	ldw	r2,-8(fp)
8013bd54:	10bfffc4 	addi	r2,r2,-1
8013bd58:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8013bd5c:	e0bffd17 	ldw	r2,-12(fp)
8013bd60:	10c00104 	addi	r3,r2,4
8013bd64:	e0fffd15 	stw	r3,-12(fp)
8013bd68:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8013bd6c:	e0bffe17 	ldw	r2,-8(fp)
8013bd70:	103ff71e 	bne	r2,zero,8013bd50 <__reset+0xfa11bd50>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8013bd74:	0001883a 	nop
8013bd78:	e037883a 	mov	sp,fp
8013bd7c:	df000017 	ldw	fp,0(sp)
8013bd80:	dec00104 	addi	sp,sp,4
8013bd84:	f800283a 	ret

8013bd88 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8013bd88:	defff904 	addi	sp,sp,-28
8013bd8c:	de00012e 	bgeu	sp,et,8013bd94 <OSTimeDly+0xc>
8013bd90:	003b68fa 	trap	3
8013bd94:	dfc00615 	stw	ra,24(sp)
8013bd98:	df000515 	stw	fp,20(sp)
8013bd9c:	df000504 	addi	fp,sp,20
8013bda0:	2005883a 	mov	r2,r4
8013bda4:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8013bda8:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8013bdac:	d0a0aa03 	ldbu	r2,-32088(gp)
8013bdb0:	10803fcc 	andi	r2,r2,255
8013bdb4:	1000311e 	bne	r2,zero,8013be7c <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8013bdb8:	e0bfff0b 	ldhu	r2,-4(fp)
8013bdbc:	10003026 	beq	r2,zero,8013be80 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013bdc0:	0005303a 	rdctl	r2,status
8013bdc4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013bdc8:	e0fffe17 	ldw	r3,-8(fp)
8013bdcc:	00bfff84 	movi	r2,-2
8013bdd0:	1884703a 	and	r2,r3,r2
8013bdd4:	1001703a 	wrctl	status,r2
  
  return context;
8013bdd8:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8013bddc:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8013bde0:	d0a0ab17 	ldw	r2,-32084(gp)
8013bde4:	10800d03 	ldbu	r2,52(r2)
8013bde8:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8013bdec:	e0fffd03 	ldbu	r3,-12(fp)
8013bdf0:	e13ffd03 	ldbu	r4,-12(fp)
8013bdf4:	d0a0a744 	addi	r2,gp,-32099
8013bdf8:	2085883a 	add	r2,r4,r2
8013bdfc:	10800003 	ldbu	r2,0(r2)
8013be00:	1009883a 	mov	r4,r2
8013be04:	d0a0ab17 	ldw	r2,-32084(gp)
8013be08:	10800d43 	ldbu	r2,53(r2)
8013be0c:	0084303a 	nor	r2,zero,r2
8013be10:	2084703a 	and	r2,r4,r2
8013be14:	1009883a 	mov	r4,r2
8013be18:	d0a0a744 	addi	r2,gp,-32099
8013be1c:	1885883a 	add	r2,r3,r2
8013be20:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8013be24:	e0fffd03 	ldbu	r3,-12(fp)
8013be28:	d0a0a744 	addi	r2,gp,-32099
8013be2c:	1885883a 	add	r2,r3,r2
8013be30:	10800003 	ldbu	r2,0(r2)
8013be34:	10803fcc 	andi	r2,r2,255
8013be38:	1000071e 	bne	r2,zero,8013be58 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8013be3c:	d0a0ab17 	ldw	r2,-32084(gp)
8013be40:	10800d83 	ldbu	r2,54(r2)
8013be44:	0084303a 	nor	r2,zero,r2
8013be48:	1007883a 	mov	r3,r2
8013be4c:	d0a0a703 	ldbu	r2,-32100(gp)
8013be50:	1884703a 	and	r2,r3,r2
8013be54:	d0a0a705 	stb	r2,-32100(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8013be58:	d0a0ab17 	ldw	r2,-32084(gp)
8013be5c:	e0ffff0b 	ldhu	r3,-4(fp)
8013be60:	10c00b8d 	sth	r3,46(r2)
8013be64:	e0bffb17 	ldw	r2,-20(fp)
8013be68:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013be6c:	e0bffc17 	ldw	r2,-16(fp)
8013be70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8013be74:	013504c0 	call	8013504c <OS_Sched>
8013be78:	00000106 	br	8013be80 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8013be7c:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8013be80:	e037883a 	mov	sp,fp
8013be84:	dfc00117 	ldw	ra,4(sp)
8013be88:	df000017 	ldw	fp,0(sp)
8013be8c:	dec00204 	addi	sp,sp,8
8013be90:	f800283a 	ret

8013be94 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8013be94:	defff804 	addi	sp,sp,-32
8013be98:	de00012e 	bgeu	sp,et,8013bea0 <OSTimeDlyHMSM+0xc>
8013be9c:	003b68fa 	trap	3
8013bea0:	dfc00715 	stw	ra,28(sp)
8013bea4:	df000615 	stw	fp,24(sp)
8013bea8:	df000604 	addi	fp,sp,24
8013beac:	2015883a 	mov	r10,r4
8013beb0:	2809883a 	mov	r4,r5
8013beb4:	3007883a 	mov	r3,r6
8013beb8:	3805883a 	mov	r2,r7
8013bebc:	e2bffc05 	stb	r10,-16(fp)
8013bec0:	e13ffd05 	stb	r4,-12(fp)
8013bec4:	e0fffe05 	stb	r3,-8(fp)
8013bec8:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8013becc:	d0a0aa03 	ldbu	r2,-32088(gp)
8013bed0:	10803fcc 	andi	r2,r2,255
8013bed4:	10000226 	beq	r2,zero,8013bee0 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8013bed8:	00801544 	movi	r2,85
8013bedc:	00004106 	br	8013bfe4 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8013bee0:	e0bffc03 	ldbu	r2,-16(fp)
8013bee4:	1000081e 	bne	r2,zero,8013bf08 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8013bee8:	e0bffd03 	ldbu	r2,-12(fp)
8013beec:	1000061e 	bne	r2,zero,8013bf08 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8013bef0:	e0bffe03 	ldbu	r2,-8(fp)
8013bef4:	1000041e 	bne	r2,zero,8013bf08 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8013bef8:	e0bfff0b 	ldhu	r2,-4(fp)
8013befc:	1000021e 	bne	r2,zero,8013bf08 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8013bf00:	00801504 	movi	r2,84
8013bf04:	00003706 	br	8013bfe4 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8013bf08:	e0bffd03 	ldbu	r2,-12(fp)
8013bf0c:	10800f30 	cmpltui	r2,r2,60
8013bf10:	1000021e 	bne	r2,zero,8013bf1c <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8013bf14:	00801444 	movi	r2,81
8013bf18:	00003206 	br	8013bfe4 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8013bf1c:	e0bffe03 	ldbu	r2,-8(fp)
8013bf20:	10800f30 	cmpltui	r2,r2,60
8013bf24:	1000021e 	bne	r2,zero,8013bf30 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8013bf28:	00801484 	movi	r2,82
8013bf2c:	00002d06 	br	8013bfe4 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8013bf30:	e0bfff0b 	ldhu	r2,-4(fp)
8013bf34:	1080fa30 	cmpltui	r2,r2,1000
8013bf38:	1000021e 	bne	r2,zero,8013bf44 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8013bf3c:	008014c4 	movi	r2,83
8013bf40:	00002806 	br	8013bfe4 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8013bf44:	e0bffc03 	ldbu	r2,-16(fp)
8013bf48:	10c38424 	muli	r3,r2,3600
8013bf4c:	e0bffd03 	ldbu	r2,-12(fp)
8013bf50:	10800f24 	muli	r2,r2,60
8013bf54:	1887883a 	add	r3,r3,r2
8013bf58:	e0bffe03 	ldbu	r2,-8(fp)
8013bf5c:	1885883a 	add	r2,r3,r2
8013bf60:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8013bf64:	e0bfff0b 	ldhu	r2,-4(fp)
8013bf68:	10c0fa24 	muli	r3,r2,1000
8013bf6c:	008418b4 	movhi	r2,4194
8013bf70:	109374c4 	addi	r2,r2,19923
8013bf74:	188a383a 	mulxuu	r5,r3,r2
8013bf78:	1885383a 	mul	r2,r3,r2
8013bf7c:	1011883a 	mov	r8,r2
8013bf80:	2813883a 	mov	r9,r5
8013bf84:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8013bf88:	2085883a 	add	r2,r4,r2
8013bf8c:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8013bf90:	e0bffb17 	ldw	r2,-20(fp)
8013bf94:	1004d43a 	srli	r2,r2,16
8013bf98:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8013bf9c:	e0bffb17 	ldw	r2,-20(fp)
8013bfa0:	10bfffcc 	andi	r2,r2,65535
8013bfa4:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8013bfa8:	e0bffb17 	ldw	r2,-20(fp)
8013bfac:	10bfffcc 	andi	r2,r2,65535
8013bfb0:	1009883a 	mov	r4,r2
8013bfb4:	013bd880 	call	8013bd88 <OSTimeDly>
    while (loops > 0) {
8013bfb8:	00000706 	br	8013bfd8 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8013bfbc:	01200014 	movui	r4,32768
8013bfc0:	013bd880 	call	8013bd88 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8013bfc4:	01200014 	movui	r4,32768
8013bfc8:	013bd880 	call	8013bd88 <OSTimeDly>
        loops--;
8013bfcc:	e0bffa0b 	ldhu	r2,-24(fp)
8013bfd0:	10bfffc4 	addi	r2,r2,-1
8013bfd4:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8013bfd8:	e0bffa0b 	ldhu	r2,-24(fp)
8013bfdc:	103ff71e 	bne	r2,zero,8013bfbc <__reset+0xfa11bfbc>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8013bfe0:	0005883a 	mov	r2,zero
}
8013bfe4:	e037883a 	mov	sp,fp
8013bfe8:	dfc00117 	ldw	ra,4(sp)
8013bfec:	df000017 	ldw	fp,0(sp)
8013bff0:	dec00204 	addi	sp,sp,8
8013bff4:	f800283a 	ret

8013bff8 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8013bff8:	defff504 	addi	sp,sp,-44
8013bffc:	de00012e 	bgeu	sp,et,8013c004 <OSTimeDlyResume+0xc>
8013c000:	003b68fa 	trap	3
8013c004:	dfc00a15 	stw	ra,40(sp)
8013c008:	df000915 	stw	fp,36(sp)
8013c00c:	df000904 	addi	fp,sp,36
8013c010:	2005883a 	mov	r2,r4
8013c014:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8013c018:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8013c01c:	e0bfff03 	ldbu	r2,-4(fp)
8013c020:	10800ab0 	cmpltui	r2,r2,42
8013c024:	1000021e 	bne	r2,zero,8013c030 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8013c028:	00800a84 	movi	r2,42
8013c02c:	00006406 	br	8013c1c0 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013c030:	0005303a 	rdctl	r2,status
8013c034:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013c038:	e0fffe17 	ldw	r3,-8(fp)
8013c03c:	00bfff84 	movi	r2,-2
8013c040:	1884703a 	and	r2,r3,r2
8013c044:	1001703a 	wrctl	status,r2
  
  return context;
8013c048:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8013c04c:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8013c050:	e0ffff03 	ldbu	r3,-4(fp)
8013c054:	00a005b4 	movhi	r2,32790
8013c058:	10924b04 	addi	r2,r2,18732
8013c05c:	18c7883a 	add	r3,r3,r3
8013c060:	18c7883a 	add	r3,r3,r3
8013c064:	10c5883a 	add	r2,r2,r3
8013c068:	10800017 	ldw	r2,0(r2)
8013c06c:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8013c070:	e0bff917 	ldw	r2,-28(fp)
8013c074:	1000061e 	bne	r2,zero,8013c090 <OSTimeDlyResume+0x98>
8013c078:	e0bff717 	ldw	r2,-36(fp)
8013c07c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013c080:	e0bff817 	ldw	r2,-32(fp)
8013c084:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8013c088:	008010c4 	movi	r2,67
8013c08c:	00004c06 	br	8013c1c0 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8013c090:	e0bff917 	ldw	r2,-28(fp)
8013c094:	10800058 	cmpnei	r2,r2,1
8013c098:	1000061e 	bne	r2,zero,8013c0b4 <OSTimeDlyResume+0xbc>
8013c09c:	e0bff717 	ldw	r2,-36(fp)
8013c0a0:	e0bffa15 	stw	r2,-24(fp)
8013c0a4:	e0bffa17 	ldw	r2,-24(fp)
8013c0a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8013c0ac:	008010c4 	movi	r2,67
8013c0b0:	00004306 	br	8013c1c0 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8013c0b4:	e0bff917 	ldw	r2,-28(fp)
8013c0b8:	10800b8b 	ldhu	r2,46(r2)
8013c0bc:	10bfffcc 	andi	r2,r2,65535
8013c0c0:	1000061e 	bne	r2,zero,8013c0dc <OSTimeDlyResume+0xe4>
8013c0c4:	e0bff717 	ldw	r2,-36(fp)
8013c0c8:	e0bffb15 	stw	r2,-20(fp)
8013c0cc:	e0bffb17 	ldw	r2,-20(fp)
8013c0d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8013c0d4:	00801404 	movi	r2,80
8013c0d8:	00003906 	br	8013c1c0 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8013c0dc:	e0bff917 	ldw	r2,-28(fp)
8013c0e0:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8013c0e4:	e0bff917 	ldw	r2,-28(fp)
8013c0e8:	10800c03 	ldbu	r2,48(r2)
8013c0ec:	10803fcc 	andi	r2,r2,255
8013c0f0:	10800dcc 	andi	r2,r2,55
8013c0f4:	10000b26 	beq	r2,zero,8013c124 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8013c0f8:	e0bff917 	ldw	r2,-28(fp)
8013c0fc:	10c00c03 	ldbu	r3,48(r2)
8013c100:	00bff204 	movi	r2,-56
8013c104:	1884703a 	and	r2,r3,r2
8013c108:	1007883a 	mov	r3,r2
8013c10c:	e0bff917 	ldw	r2,-28(fp)
8013c110:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8013c114:	e0bff917 	ldw	r2,-28(fp)
8013c118:	00c00044 	movi	r3,1
8013c11c:	10c00c45 	stb	r3,49(r2)
8013c120:	00000206 	br	8013c12c <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8013c124:	e0bff917 	ldw	r2,-28(fp)
8013c128:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8013c12c:	e0bff917 	ldw	r2,-28(fp)
8013c130:	10800c03 	ldbu	r2,48(r2)
8013c134:	10803fcc 	andi	r2,r2,255
8013c138:	1080020c 	andi	r2,r2,8
8013c13c:	10001b1e 	bne	r2,zero,8013c1ac <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8013c140:	e0bff917 	ldw	r2,-28(fp)
8013c144:	10c00d83 	ldbu	r3,54(r2)
8013c148:	d0a0a703 	ldbu	r2,-32100(gp)
8013c14c:	1884b03a 	or	r2,r3,r2
8013c150:	d0a0a705 	stb	r2,-32100(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8013c154:	e0bff917 	ldw	r2,-28(fp)
8013c158:	10800d03 	ldbu	r2,52(r2)
8013c15c:	10c03fcc 	andi	r3,r2,255
8013c160:	e0bff917 	ldw	r2,-28(fp)
8013c164:	10800d03 	ldbu	r2,52(r2)
8013c168:	11003fcc 	andi	r4,r2,255
8013c16c:	d0a0a744 	addi	r2,gp,-32099
8013c170:	2085883a 	add	r2,r4,r2
8013c174:	11000003 	ldbu	r4,0(r2)
8013c178:	e0bff917 	ldw	r2,-28(fp)
8013c17c:	10800d43 	ldbu	r2,53(r2)
8013c180:	2084b03a 	or	r2,r4,r2
8013c184:	1009883a 	mov	r4,r2
8013c188:	d0a0a744 	addi	r2,gp,-32099
8013c18c:	1885883a 	add	r2,r3,r2
8013c190:	11000005 	stb	r4,0(r2)
8013c194:	e0bff717 	ldw	r2,-36(fp)
8013c198:	e0bffc15 	stw	r2,-16(fp)
8013c19c:	e0bffc17 	ldw	r2,-16(fp)
8013c1a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8013c1a4:	013504c0 	call	8013504c <OS_Sched>
8013c1a8:	00000406 	br	8013c1bc <OSTimeDlyResume+0x1c4>
8013c1ac:	e0bff717 	ldw	r2,-36(fp)
8013c1b0:	e0bffd15 	stw	r2,-12(fp)
8013c1b4:	e0bffd17 	ldw	r2,-12(fp)
8013c1b8:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8013c1bc:	0005883a 	mov	r2,zero
}
8013c1c0:	e037883a 	mov	sp,fp
8013c1c4:	dfc00117 	ldw	ra,4(sp)
8013c1c8:	df000017 	ldw	fp,0(sp)
8013c1cc:	dec00204 	addi	sp,sp,8
8013c1d0:	f800283a 	ret

8013c1d4 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8013c1d4:	defffb04 	addi	sp,sp,-20
8013c1d8:	de00012e 	bgeu	sp,et,8013c1e0 <OSTimeGet+0xc>
8013c1dc:	003b68fa 	trap	3
8013c1e0:	df000415 	stw	fp,16(sp)
8013c1e4:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8013c1e8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013c1ec:	0005303a 	rdctl	r2,status
8013c1f0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013c1f4:	e0fffe17 	ldw	r3,-8(fp)
8013c1f8:	00bfff84 	movi	r2,-2
8013c1fc:	1884703a 	and	r2,r3,r2
8013c200:	1001703a 	wrctl	status,r2
  
  return context;
8013c204:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8013c208:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8013c20c:	d0a0ad17 	ldw	r2,-32076(gp)
8013c210:	e0bffd15 	stw	r2,-12(fp)
8013c214:	e0bffc17 	ldw	r2,-16(fp)
8013c218:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013c21c:	e0bfff17 	ldw	r2,-4(fp)
8013c220:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8013c224:	e0bffd17 	ldw	r2,-12(fp)
}
8013c228:	e037883a 	mov	sp,fp
8013c22c:	df000017 	ldw	fp,0(sp)
8013c230:	dec00104 	addi	sp,sp,4
8013c234:	f800283a 	ret

8013c238 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
8013c238:	defffb04 	addi	sp,sp,-20
8013c23c:	de00012e 	bgeu	sp,et,8013c244 <OSTimeSet+0xc>
8013c240:	003b68fa 	trap	3
8013c244:	df000415 	stw	fp,16(sp)
8013c248:	df000404 	addi	fp,sp,16
8013c24c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8013c250:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8013c254:	0005303a 	rdctl	r2,status
8013c258:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8013c25c:	e0fffd17 	ldw	r3,-12(fp)
8013c260:	00bfff84 	movi	r2,-2
8013c264:	1884703a 	and	r2,r3,r2
8013c268:	1001703a 	wrctl	status,r2
  
  return context;
8013c26c:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
8013c270:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8013c274:	e0bfff17 	ldw	r2,-4(fp)
8013c278:	d0a0ad15 	stw	r2,-32076(gp)
8013c27c:	e0bffc17 	ldw	r2,-16(fp)
8013c280:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8013c284:	e0bffe17 	ldw	r2,-8(fp)
8013c288:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8013c28c:	0001883a 	nop
8013c290:	e037883a 	mov	sp,fp
8013c294:	df000017 	ldw	fp,0(sp)
8013c298:	dec00104 	addi	sp,sp,4
8013c29c:	f800283a 	ret

8013c2a0 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8013c2a0:	defff804 	addi	sp,sp,-32
8013c2a4:	de00012e 	bgeu	sp,et,8013c2ac <OSTmrCreate+0xc>
8013c2a8:	003b68fa 	trap	3
8013c2ac:	dfc00715 	stw	ra,28(sp)
8013c2b0:	df000615 	stw	fp,24(sp)
8013c2b4:	df000604 	addi	fp,sp,24
8013c2b8:	e13ffc15 	stw	r4,-16(fp)
8013c2bc:	e17ffd15 	stw	r5,-12(fp)
8013c2c0:	3005883a 	mov	r2,r6
8013c2c4:	e1ffff15 	stw	r7,-4(fp)
8013c2c8:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8013c2cc:	e0800417 	ldw	r2,16(fp)
8013c2d0:	1000021e 	bne	r2,zero,8013c2dc <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8013c2d4:	0005883a 	mov	r2,zero
8013c2d8:	00005d06 	br	8013c450 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8013c2dc:	e0bffe03 	ldbu	r2,-8(fp)
8013c2e0:	10c00060 	cmpeqi	r3,r2,1
8013c2e4:	1800091e 	bne	r3,zero,8013c30c <OSTmrCreate+0x6c>
8013c2e8:	108000a0 	cmpeqi	r2,r2,2
8013c2ec:	10000e26 	beq	r2,zero,8013c328 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8013c2f0:	e0bffd17 	ldw	r2,-12(fp)
8013c2f4:	1000111e 	bne	r2,zero,8013c33c <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
8013c2f8:	e0800417 	ldw	r2,16(fp)
8013c2fc:	00ffe0c4 	movi	r3,-125
8013c300:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8013c304:	0005883a 	mov	r2,zero
8013c308:	00005106 	br	8013c450 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
8013c30c:	e0bffc17 	ldw	r2,-16(fp)
8013c310:	10000c1e 	bne	r2,zero,8013c344 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8013c314:	e0800417 	ldw	r2,16(fp)
8013c318:	00ffe084 	movi	r3,-126
8013c31c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8013c320:	0005883a 	mov	r2,zero
8013c324:	00004a06 	br	8013c450 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
8013c328:	e0800417 	ldw	r2,16(fp)
8013c32c:	00ffe104 	movi	r3,-124
8013c330:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8013c334:	0005883a 	mov	r2,zero
8013c338:	00004506 	br	8013c450 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8013c33c:	0001883a 	nop
8013c340:	00000106 	br	8013c348 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8013c344:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8013c348:	d0a0aa03 	ldbu	r2,-32088(gp)
8013c34c:	10803fcc 	andi	r2,r2,255
8013c350:	10000526 	beq	r2,zero,8013c368 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8013c354:	e0800417 	ldw	r2,16(fp)
8013c358:	00ffe2c4 	movi	r3,-117
8013c35c:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8013c360:	0005883a 	mov	r2,zero
8013c364:	00003a06 	br	8013c450 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8013c368:	013d2580 	call	8013d258 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8013c36c:	013ccf80 	call	8013ccf8 <OSTmr_Alloc>
8013c370:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8013c374:	e0bffa17 	ldw	r2,-24(fp)
8013c378:	1000061e 	bne	r2,zero,8013c394 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8013c37c:	013d29c0 	call	8013d29c <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
8013c380:	e0800417 	ldw	r2,16(fp)
8013c384:	00ffe184 	movi	r3,-122
8013c388:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8013c38c:	0005883a 	mov	r2,zero
8013c390:	00002f06 	br	8013c450 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8013c394:	e0bffa17 	ldw	r2,-24(fp)
8013c398:	00c00044 	movi	r3,1
8013c39c:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
8013c3a0:	e0bffa17 	ldw	r2,-24(fp)
8013c3a4:	e0fffc17 	ldw	r3,-16(fp)
8013c3a8:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8013c3ac:	e0bffa17 	ldw	r2,-24(fp)
8013c3b0:	e0fffd17 	ldw	r3,-12(fp)
8013c3b4:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8013c3b8:	e0bffa17 	ldw	r2,-24(fp)
8013c3bc:	e0fffe03 	ldbu	r3,-8(fp)
8013c3c0:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8013c3c4:	e0bffa17 	ldw	r2,-24(fp)
8013c3c8:	e0ffff17 	ldw	r3,-4(fp)
8013c3cc:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
8013c3d0:	e0bffa17 	ldw	r2,-24(fp)
8013c3d4:	e0c00217 	ldw	r3,8(fp)
8013c3d8:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
8013c3dc:	e0800317 	ldw	r2,12(fp)
8013c3e0:	10001726 	beq	r2,zero,8013c440 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8013c3e4:	e1000317 	ldw	r4,12(fp)
8013c3e8:	013521c0 	call	8013521c <OS_StrLen>
8013c3ec:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8013c3f0:	e0bffb03 	ldbu	r2,-20(fp)
8013c3f4:	10800428 	cmpgeui	r2,r2,16
8013c3f8:	1000061e 	bne	r2,zero,8013c414 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8013c3fc:	e0bffa17 	ldw	r2,-24(fp)
8013c400:	10800804 	addi	r2,r2,32
8013c404:	e1400317 	ldw	r5,12(fp)
8013c408:	1009883a 	mov	r4,r2
8013c40c:	01351a00 	call	801351a0 <OS_StrCopy>
8013c410:	00000b06 	br	8013c440 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8013c414:	e0bffa17 	ldw	r2,-24(fp)
8013c418:	00c008c4 	movi	r3,35
8013c41c:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8013c420:	e0bffa17 	ldw	r2,-24(fp)
8013c424:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
8013c428:	e0800417 	ldw	r2,16(fp)
8013c42c:	00ffe304 	movi	r3,-116
8013c430:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8013c434:	013d29c0 	call	8013d29c <OSTmr_Unlock>
            return (ptmr);
8013c438:	e0bffa17 	ldw	r2,-24(fp)
8013c43c:	00000406 	br	8013c450 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8013c440:	013d29c0 	call	8013d29c <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8013c444:	e0800417 	ldw	r2,16(fp)
8013c448:	10000005 	stb	zero,0(r2)
    return (ptmr);
8013c44c:	e0bffa17 	ldw	r2,-24(fp)
}
8013c450:	e037883a 	mov	sp,fp
8013c454:	dfc00117 	ldw	ra,4(sp)
8013c458:	df000017 	ldw	fp,0(sp)
8013c45c:	dec00204 	addi	sp,sp,8
8013c460:	f800283a 	ret

8013c464 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8013c464:	defffc04 	addi	sp,sp,-16
8013c468:	de00012e 	bgeu	sp,et,8013c470 <OSTmrDel+0xc>
8013c46c:	003b68fa 	trap	3
8013c470:	dfc00315 	stw	ra,12(sp)
8013c474:	df000215 	stw	fp,8(sp)
8013c478:	df000204 	addi	fp,sp,8
8013c47c:	e13ffe15 	stw	r4,-8(fp)
8013c480:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8013c484:	e0bfff17 	ldw	r2,-4(fp)
8013c488:	1000021e 	bne	r2,zero,8013c494 <OSTmrDel+0x30>
        return (OS_FALSE);
8013c48c:	0005883a 	mov	r2,zero
8013c490:	00003f06 	br	8013c590 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8013c494:	e0bffe17 	ldw	r2,-8(fp)
8013c498:	1000051e 	bne	r2,zero,8013c4b0 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8013c49c:	e0bfff17 	ldw	r2,-4(fp)
8013c4a0:	00ffe284 	movi	r3,-118
8013c4a4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013c4a8:	0005883a 	mov	r2,zero
8013c4ac:	00003806 	br	8013c590 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8013c4b0:	e0bffe17 	ldw	r2,-8(fp)
8013c4b4:	10800003 	ldbu	r2,0(r2)
8013c4b8:	10803fcc 	andi	r2,r2,255
8013c4bc:	10801920 	cmpeqi	r2,r2,100
8013c4c0:	1000051e 	bne	r2,zero,8013c4d8 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8013c4c4:	e0bfff17 	ldw	r2,-4(fp)
8013c4c8:	00ffe244 	movi	r3,-119
8013c4cc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013c4d0:	0005883a 	mov	r2,zero
8013c4d4:	00002e06 	br	8013c590 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8013c4d8:	d0a0aa03 	ldbu	r2,-32088(gp)
8013c4dc:	10803fcc 	andi	r2,r2,255
8013c4e0:	10000526 	beq	r2,zero,8013c4f8 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8013c4e4:	e0bfff17 	ldw	r2,-4(fp)
8013c4e8:	00ffe2c4 	movi	r3,-117
8013c4ec:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013c4f0:	0005883a 	mov	r2,zero
8013c4f4:	00002606 	br	8013c590 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
8013c4f8:	013d2580 	call	8013d258 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8013c4fc:	e0bffe17 	ldw	r2,-8(fp)
8013c500:	10800c43 	ldbu	r2,49(r2)
8013c504:	10803fcc 	andi	r2,r2,255
8013c508:	10c000c8 	cmpgei	r3,r2,3
8013c50c:	1800031e 	bne	r3,zero,8013c51c <OSTmrDel+0xb8>
8013c510:	00800d16 	blt	zero,r2,8013c548 <OSTmrDel+0xe4>
8013c514:	10001326 	beq	r2,zero,8013c564 <OSTmrDel+0x100>
8013c518:	00001806 	br	8013c57c <OSTmrDel+0x118>
8013c51c:	108000e0 	cmpeqi	r2,r2,3
8013c520:	10001626 	beq	r2,zero,8013c57c <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8013c524:	e13ffe17 	ldw	r4,-8(fp)
8013c528:	013d15c0 	call	8013d15c <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8013c52c:	e13ffe17 	ldw	r4,-8(fp)
8013c530:	013cd6c0 	call	8013cd6c <OSTmr_Free>
             OSTmr_Unlock();
8013c534:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8013c538:	e0bfff17 	ldw	r2,-4(fp)
8013c53c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8013c540:	00800044 	movi	r2,1
8013c544:	00001206 	br	8013c590 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8013c548:	e13ffe17 	ldw	r4,-8(fp)
8013c54c:	013cd6c0 	call	8013cd6c <OSTmr_Free>
             OSTmr_Unlock();
8013c550:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8013c554:	e0bfff17 	ldw	r2,-4(fp)
8013c558:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8013c55c:	00800044 	movi	r2,1
8013c560:	00000b06 	br	8013c590 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8013c564:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8013c568:	e0bfff17 	ldw	r2,-4(fp)
8013c56c:	00ffe1c4 	movi	r3,-121
8013c570:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8013c574:	0005883a 	mov	r2,zero
8013c578:	00000506 	br	8013c590 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8013c57c:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8013c580:	e0bfff17 	ldw	r2,-4(fp)
8013c584:	00ffe344 	movi	r3,-115
8013c588:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8013c58c:	0005883a 	mov	r2,zero
    }
}
8013c590:	e037883a 	mov	sp,fp
8013c594:	dfc00117 	ldw	ra,4(sp)
8013c598:	df000017 	ldw	fp,0(sp)
8013c59c:	dec00204 	addi	sp,sp,8
8013c5a0:	f800283a 	ret

8013c5a4 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8013c5a4:	defffa04 	addi	sp,sp,-24
8013c5a8:	de00012e 	bgeu	sp,et,8013c5b0 <OSTmrNameGet+0xc>
8013c5ac:	003b68fa 	trap	3
8013c5b0:	dfc00515 	stw	ra,20(sp)
8013c5b4:	df000415 	stw	fp,16(sp)
8013c5b8:	df000404 	addi	fp,sp,16
8013c5bc:	e13ffd15 	stw	r4,-12(fp)
8013c5c0:	e17ffe15 	stw	r5,-8(fp)
8013c5c4:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8013c5c8:	e0bfff17 	ldw	r2,-4(fp)
8013c5cc:	1000021e 	bne	r2,zero,8013c5d8 <OSTmrNameGet+0x34>
        return (0);
8013c5d0:	0005883a 	mov	r2,zero
8013c5d4:	00003e06 	br	8013c6d0 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
8013c5d8:	e0bffe17 	ldw	r2,-8(fp)
8013c5dc:	1000051e 	bne	r2,zero,8013c5f4 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8013c5e0:	e0bfff17 	ldw	r2,-4(fp)
8013c5e4:	00ffe204 	movi	r3,-120
8013c5e8:	10c00005 	stb	r3,0(r2)
        return (0);
8013c5ec:	0005883a 	mov	r2,zero
8013c5f0:	00003706 	br	8013c6d0 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8013c5f4:	e0bffd17 	ldw	r2,-12(fp)
8013c5f8:	1000051e 	bne	r2,zero,8013c610 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8013c5fc:	e0bfff17 	ldw	r2,-4(fp)
8013c600:	00ffe284 	movi	r3,-118
8013c604:	10c00005 	stb	r3,0(r2)
        return (0);
8013c608:	0005883a 	mov	r2,zero
8013c60c:	00003006 	br	8013c6d0 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8013c610:	e0bffd17 	ldw	r2,-12(fp)
8013c614:	10800003 	ldbu	r2,0(r2)
8013c618:	10803fcc 	andi	r2,r2,255
8013c61c:	10801920 	cmpeqi	r2,r2,100
8013c620:	1000051e 	bne	r2,zero,8013c638 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8013c624:	e0bfff17 	ldw	r2,-4(fp)
8013c628:	00ffe244 	movi	r3,-119
8013c62c:	10c00005 	stb	r3,0(r2)
        return (0);
8013c630:	0005883a 	mov	r2,zero
8013c634:	00002606 	br	8013c6d0 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8013c638:	d0a0aa03 	ldbu	r2,-32088(gp)
8013c63c:	10803fcc 	andi	r2,r2,255
8013c640:	10000526 	beq	r2,zero,8013c658 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8013c644:	e0bfff17 	ldw	r2,-4(fp)
8013c648:	00c00444 	movi	r3,17
8013c64c:	10c00005 	stb	r3,0(r2)
        return (0);
8013c650:	0005883a 	mov	r2,zero
8013c654:	00001e06 	br	8013c6d0 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
8013c658:	013d2580 	call	8013d258 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8013c65c:	e0bffd17 	ldw	r2,-12(fp)
8013c660:	10800c43 	ldbu	r2,49(r2)
8013c664:	10803fcc 	andi	r2,r2,255
8013c668:	10000e26 	beq	r2,zero,8013c6a4 <OSTmrNameGet+0x100>
8013c66c:	10001316 	blt	r2,zero,8013c6bc <OSTmrNameGet+0x118>
8013c670:	10800108 	cmpgei	r2,r2,4
8013c674:	1000111e 	bne	r2,zero,8013c6bc <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
8013c678:	e0bffd17 	ldw	r2,-12(fp)
8013c67c:	10800804 	addi	r2,r2,32
8013c680:	100b883a 	mov	r5,r2
8013c684:	e13ffe17 	ldw	r4,-8(fp)
8013c688:	01351a00 	call	801351a0 <OS_StrCopy>
8013c68c:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
8013c690:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8013c694:	e0bfff17 	ldw	r2,-4(fp)
8013c698:	10000005 	stb	zero,0(r2)
             return (len);
8013c69c:	e0bffc03 	ldbu	r2,-16(fp)
8013c6a0:	00000b06 	br	8013c6d0 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8013c6a4:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8013c6a8:	e0bfff17 	ldw	r2,-4(fp)
8013c6ac:	00ffe1c4 	movi	r3,-121
8013c6b0:	10c00005 	stb	r3,0(r2)
             return (0);
8013c6b4:	0005883a 	mov	r2,zero
8013c6b8:	00000506 	br	8013c6d0 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8013c6bc:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8013c6c0:	e0bfff17 	ldw	r2,-4(fp)
8013c6c4:	00ffe344 	movi	r3,-115
8013c6c8:	10c00005 	stb	r3,0(r2)
             return (0);
8013c6cc:	0005883a 	mov	r2,zero
    }
}
8013c6d0:	e037883a 	mov	sp,fp
8013c6d4:	dfc00117 	ldw	ra,4(sp)
8013c6d8:	df000017 	ldw	fp,0(sp)
8013c6dc:	dec00204 	addi	sp,sp,8
8013c6e0:	f800283a 	ret

8013c6e4 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8013c6e4:	defffb04 	addi	sp,sp,-20
8013c6e8:	de00012e 	bgeu	sp,et,8013c6f0 <OSTmrRemainGet+0xc>
8013c6ec:	003b68fa 	trap	3
8013c6f0:	dfc00415 	stw	ra,16(sp)
8013c6f4:	df000315 	stw	fp,12(sp)
8013c6f8:	df000304 	addi	fp,sp,12
8013c6fc:	e13ffe15 	stw	r4,-8(fp)
8013c700:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8013c704:	e0bfff17 	ldw	r2,-4(fp)
8013c708:	1000021e 	bne	r2,zero,8013c714 <OSTmrRemainGet+0x30>
        return (0);
8013c70c:	0005883a 	mov	r2,zero
8013c710:	00005d06 	br	8013c888 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8013c714:	e0bffe17 	ldw	r2,-8(fp)
8013c718:	1000051e 	bne	r2,zero,8013c730 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8013c71c:	e0bfff17 	ldw	r2,-4(fp)
8013c720:	00ffe284 	movi	r3,-118
8013c724:	10c00005 	stb	r3,0(r2)
        return (0);
8013c728:	0005883a 	mov	r2,zero
8013c72c:	00005606 	br	8013c888 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8013c730:	e0bffe17 	ldw	r2,-8(fp)
8013c734:	10800003 	ldbu	r2,0(r2)
8013c738:	10803fcc 	andi	r2,r2,255
8013c73c:	10801920 	cmpeqi	r2,r2,100
8013c740:	1000051e 	bne	r2,zero,8013c758 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8013c744:	e0bfff17 	ldw	r2,-4(fp)
8013c748:	00ffe244 	movi	r3,-119
8013c74c:	10c00005 	stb	r3,0(r2)
        return (0);
8013c750:	0005883a 	mov	r2,zero
8013c754:	00004c06 	br	8013c888 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8013c758:	d0a0aa03 	ldbu	r2,-32088(gp)
8013c75c:	10803fcc 	andi	r2,r2,255
8013c760:	10000526 	beq	r2,zero,8013c778 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8013c764:	e0bfff17 	ldw	r2,-4(fp)
8013c768:	00ffe2c4 	movi	r3,-117
8013c76c:	10c00005 	stb	r3,0(r2)
        return (0);
8013c770:	0005883a 	mov	r2,zero
8013c774:	00004406 	br	8013c888 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
8013c778:	013d2580 	call	8013d258 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8013c77c:	e0bffe17 	ldw	r2,-8(fp)
8013c780:	10800c43 	ldbu	r2,49(r2)
8013c784:	10803fcc 	andi	r2,r2,255
8013c788:	10c00060 	cmpeqi	r3,r2,1
8013c78c:	1800121e 	bne	r3,zero,8013c7d8 <OSTmrRemainGet+0xf4>
8013c790:	10c00088 	cmpgei	r3,r2,2
8013c794:	1800021e 	bne	r3,zero,8013c7a0 <OSTmrRemainGet+0xbc>
8013c798:	10003026 	beq	r2,zero,8013c85c <OSTmrRemainGet+0x178>
8013c79c:	00003506 	br	8013c874 <OSTmrRemainGet+0x190>
8013c7a0:	10c000a0 	cmpeqi	r3,r2,2
8013c7a4:	1800281e 	bne	r3,zero,8013c848 <OSTmrRemainGet+0x164>
8013c7a8:	108000e0 	cmpeqi	r2,r2,3
8013c7ac:	10003126 	beq	r2,zero,8013c874 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8013c7b0:	e0bffe17 	ldw	r2,-8(fp)
8013c7b4:	10c00517 	ldw	r3,20(r2)
8013c7b8:	d0a0ac17 	ldw	r2,-32080(gp)
8013c7bc:	1885c83a 	sub	r2,r3,r2
8013c7c0:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8013c7c4:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
8013c7c8:	e0bfff17 	ldw	r2,-4(fp)
8013c7cc:	10000005 	stb	zero,0(r2)
             return (remain);
8013c7d0:	e0bffd17 	ldw	r2,-12(fp)
8013c7d4:	00002c06 	br	8013c888 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
8013c7d8:	e0bffe17 	ldw	r2,-8(fp)
8013c7dc:	10800c03 	ldbu	r2,48(r2)
8013c7e0:	10803fcc 	andi	r2,r2,255
8013c7e4:	108000a0 	cmpeqi	r2,r2,2
8013c7e8:	10000e26 	beq	r2,zero,8013c824 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8013c7ec:	e0bffe17 	ldw	r2,-8(fp)
8013c7f0:	10800617 	ldw	r2,24(r2)
8013c7f4:	1000041e 	bne	r2,zero,8013c808 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
8013c7f8:	e0bffe17 	ldw	r2,-8(fp)
8013c7fc:	10800717 	ldw	r2,28(r2)
8013c800:	e0bffd15 	stw	r2,-12(fp)
8013c804:	00000306 	br	8013c814 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
8013c808:	e0bffe17 	ldw	r2,-8(fp)
8013c80c:	10800617 	ldw	r2,24(r2)
8013c810:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8013c814:	013d29c0 	call	8013d29c <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8013c818:	e0bfff17 	ldw	r2,-4(fp)
8013c81c:	10000005 	stb	zero,0(r2)
                      break;
8013c820:	00000706 	br	8013c840 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8013c824:	e0bffe17 	ldw	r2,-8(fp)
8013c828:	10800617 	ldw	r2,24(r2)
8013c82c:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8013c830:	013d29c0 	call	8013d29c <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8013c834:	e0bfff17 	ldw	r2,-4(fp)
8013c838:	10000005 	stb	zero,0(r2)
                      break;
8013c83c:	0001883a 	nop
             }
             return (remain);
8013c840:	e0bffd17 	ldw	r2,-12(fp)
8013c844:	00001006 	br	8013c888 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
8013c848:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8013c84c:	e0bfff17 	ldw	r2,-4(fp)
8013c850:	10000005 	stb	zero,0(r2)
             return (0);
8013c854:	0005883a 	mov	r2,zero
8013c858:	00000b06 	br	8013c888 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8013c85c:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8013c860:	e0bfff17 	ldw	r2,-4(fp)
8013c864:	00ffe1c4 	movi	r3,-121
8013c868:	10c00005 	stb	r3,0(r2)
             return (0);
8013c86c:	0005883a 	mov	r2,zero
8013c870:	00000506 	br	8013c888 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8013c874:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8013c878:	e0bfff17 	ldw	r2,-4(fp)
8013c87c:	00ffe344 	movi	r3,-115
8013c880:	10c00005 	stb	r3,0(r2)
             return (0);
8013c884:	0005883a 	mov	r2,zero
    }
}
8013c888:	e037883a 	mov	sp,fp
8013c88c:	dfc00117 	ldw	ra,4(sp)
8013c890:	df000017 	ldw	fp,0(sp)
8013c894:	dec00204 	addi	sp,sp,8
8013c898:	f800283a 	ret

8013c89c <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8013c89c:	defffb04 	addi	sp,sp,-20
8013c8a0:	de00012e 	bgeu	sp,et,8013c8a8 <OSTmrStateGet+0xc>
8013c8a4:	003b68fa 	trap	3
8013c8a8:	dfc00415 	stw	ra,16(sp)
8013c8ac:	df000315 	stw	fp,12(sp)
8013c8b0:	df000304 	addi	fp,sp,12
8013c8b4:	e13ffe15 	stw	r4,-8(fp)
8013c8b8:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8013c8bc:	e0bfff17 	ldw	r2,-4(fp)
8013c8c0:	1000021e 	bne	r2,zero,8013c8cc <OSTmrStateGet+0x30>
        return (0);
8013c8c4:	0005883a 	mov	r2,zero
8013c8c8:	00002a06 	br	8013c974 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8013c8cc:	e0bffe17 	ldw	r2,-8(fp)
8013c8d0:	1000051e 	bne	r2,zero,8013c8e8 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8013c8d4:	e0bfff17 	ldw	r2,-4(fp)
8013c8d8:	00ffe284 	movi	r3,-118
8013c8dc:	10c00005 	stb	r3,0(r2)
        return (0);
8013c8e0:	0005883a 	mov	r2,zero
8013c8e4:	00002306 	br	8013c974 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8013c8e8:	e0bffe17 	ldw	r2,-8(fp)
8013c8ec:	10800003 	ldbu	r2,0(r2)
8013c8f0:	10803fcc 	andi	r2,r2,255
8013c8f4:	10801920 	cmpeqi	r2,r2,100
8013c8f8:	1000051e 	bne	r2,zero,8013c910 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8013c8fc:	e0bfff17 	ldw	r2,-4(fp)
8013c900:	00ffe244 	movi	r3,-119
8013c904:	10c00005 	stb	r3,0(r2)
        return (0);
8013c908:	0005883a 	mov	r2,zero
8013c90c:	00001906 	br	8013c974 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8013c910:	d0a0aa03 	ldbu	r2,-32088(gp)
8013c914:	10803fcc 	andi	r2,r2,255
8013c918:	10000526 	beq	r2,zero,8013c930 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8013c91c:	e0bfff17 	ldw	r2,-4(fp)
8013c920:	00ffe2c4 	movi	r3,-117
8013c924:	10c00005 	stb	r3,0(r2)
        return (0);
8013c928:	0005883a 	mov	r2,zero
8013c92c:	00001106 	br	8013c974 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8013c930:	013d2580 	call	8013d258 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8013c934:	e0bffe17 	ldw	r2,-8(fp)
8013c938:	10800c43 	ldbu	r2,49(r2)
8013c93c:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8013c940:	e0bffd03 	ldbu	r2,-12(fp)
8013c944:	1005883a 	mov	r2,r2
8013c948:	10800128 	cmpgeui	r2,r2,4
8013c94c:	1000031e 	bne	r2,zero,8013c95c <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8013c950:	e0bfff17 	ldw	r2,-4(fp)
8013c954:	10000005 	stb	zero,0(r2)
             break;
8013c958:	00000406 	br	8013c96c <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8013c95c:	e0bfff17 	ldw	r2,-4(fp)
8013c960:	00ffe344 	movi	r3,-115
8013c964:	10c00005 	stb	r3,0(r2)
             break;
8013c968:	0001883a 	nop
    }
    OSTmr_Unlock();
8013c96c:	013d29c0 	call	8013d29c <OSTmr_Unlock>
    return (state);
8013c970:	e0bffd03 	ldbu	r2,-12(fp)
}
8013c974:	e037883a 	mov	sp,fp
8013c978:	dfc00117 	ldw	ra,4(sp)
8013c97c:	df000017 	ldw	fp,0(sp)
8013c980:	dec00204 	addi	sp,sp,8
8013c984:	f800283a 	ret

8013c988 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8013c988:	defffc04 	addi	sp,sp,-16
8013c98c:	de00012e 	bgeu	sp,et,8013c994 <OSTmrStart+0xc>
8013c990:	003b68fa 	trap	3
8013c994:	dfc00315 	stw	ra,12(sp)
8013c998:	df000215 	stw	fp,8(sp)
8013c99c:	df000204 	addi	fp,sp,8
8013c9a0:	e13ffe15 	stw	r4,-8(fp)
8013c9a4:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8013c9a8:	e0bfff17 	ldw	r2,-4(fp)
8013c9ac:	1000021e 	bne	r2,zero,8013c9b8 <OSTmrStart+0x30>
        return (OS_FALSE);
8013c9b0:	0005883a 	mov	r2,zero
8013c9b4:	00004106 	br	8013cabc <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8013c9b8:	e0bffe17 	ldw	r2,-8(fp)
8013c9bc:	1000051e 	bne	r2,zero,8013c9d4 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8013c9c0:	e0bfff17 	ldw	r2,-4(fp)
8013c9c4:	00ffe284 	movi	r3,-118
8013c9c8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013c9cc:	0005883a 	mov	r2,zero
8013c9d0:	00003a06 	br	8013cabc <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8013c9d4:	e0bffe17 	ldw	r2,-8(fp)
8013c9d8:	10800003 	ldbu	r2,0(r2)
8013c9dc:	10803fcc 	andi	r2,r2,255
8013c9e0:	10801920 	cmpeqi	r2,r2,100
8013c9e4:	1000051e 	bne	r2,zero,8013c9fc <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8013c9e8:	e0bfff17 	ldw	r2,-4(fp)
8013c9ec:	00ffe244 	movi	r3,-119
8013c9f0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013c9f4:	0005883a 	mov	r2,zero
8013c9f8:	00003006 	br	8013cabc <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8013c9fc:	d0a0aa03 	ldbu	r2,-32088(gp)
8013ca00:	10803fcc 	andi	r2,r2,255
8013ca04:	10000526 	beq	r2,zero,8013ca1c <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8013ca08:	e0bfff17 	ldw	r2,-4(fp)
8013ca0c:	00ffe2c4 	movi	r3,-117
8013ca10:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013ca14:	0005883a 	mov	r2,zero
8013ca18:	00002806 	br	8013cabc <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8013ca1c:	013d2580 	call	8013d258 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8013ca20:	e0bffe17 	ldw	r2,-8(fp)
8013ca24:	10800c43 	ldbu	r2,49(r2)
8013ca28:	10803fcc 	andi	r2,r2,255
8013ca2c:	10c000c8 	cmpgei	r3,r2,3
8013ca30:	1800031e 	bne	r3,zero,8013ca40 <OSTmrStart+0xb8>
8013ca34:	00800e16 	blt	zero,r2,8013ca70 <OSTmrStart+0xe8>
8013ca38:	10001526 	beq	r2,zero,8013ca90 <OSTmrStart+0x108>
8013ca3c:	00001a06 	br	8013caa8 <OSTmrStart+0x120>
8013ca40:	108000e0 	cmpeqi	r2,r2,3
8013ca44:	10001826 	beq	r2,zero,8013caa8 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8013ca48:	e13ffe17 	ldw	r4,-8(fp)
8013ca4c:	013d15c0 	call	8013d15c <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8013ca50:	000b883a 	mov	r5,zero
8013ca54:	e13ffe17 	ldw	r4,-8(fp)
8013ca58:	013d00c0 	call	8013d00c <OSTmr_Link>
             OSTmr_Unlock();
8013ca5c:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8013ca60:	e0bfff17 	ldw	r2,-4(fp)
8013ca64:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8013ca68:	00800044 	movi	r2,1
8013ca6c:	00001306 	br	8013cabc <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8013ca70:	000b883a 	mov	r5,zero
8013ca74:	e13ffe17 	ldw	r4,-8(fp)
8013ca78:	013d00c0 	call	8013d00c <OSTmr_Link>
             OSTmr_Unlock();
8013ca7c:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8013ca80:	e0bfff17 	ldw	r2,-4(fp)
8013ca84:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8013ca88:	00800044 	movi	r2,1
8013ca8c:	00000b06 	br	8013cabc <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8013ca90:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8013ca94:	e0bfff17 	ldw	r2,-4(fp)
8013ca98:	00ffe1c4 	movi	r3,-121
8013ca9c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8013caa0:	0005883a 	mov	r2,zero
8013caa4:	00000506 	br	8013cabc <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8013caa8:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8013caac:	e0bfff17 	ldw	r2,-4(fp)
8013cab0:	00ffe344 	movi	r3,-115
8013cab4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8013cab8:	0005883a 	mov	r2,zero
    }
}
8013cabc:	e037883a 	mov	sp,fp
8013cac0:	dfc00117 	ldw	ra,4(sp)
8013cac4:	df000017 	ldw	fp,0(sp)
8013cac8:	dec00204 	addi	sp,sp,8
8013cacc:	f800283a 	ret

8013cad0 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8013cad0:	defff904 	addi	sp,sp,-28
8013cad4:	de00012e 	bgeu	sp,et,8013cadc <OSTmrStop+0xc>
8013cad8:	003b68fa 	trap	3
8013cadc:	dfc00615 	stw	ra,24(sp)
8013cae0:	df000515 	stw	fp,20(sp)
8013cae4:	df000504 	addi	fp,sp,20
8013cae8:	e13ffc15 	stw	r4,-16(fp)
8013caec:	2805883a 	mov	r2,r5
8013caf0:	e1bffe15 	stw	r6,-8(fp)
8013caf4:	e1ffff15 	stw	r7,-4(fp)
8013caf8:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8013cafc:	e0bfff17 	ldw	r2,-4(fp)
8013cb00:	1000021e 	bne	r2,zero,8013cb0c <OSTmrStop+0x3c>
        return (OS_FALSE);
8013cb04:	0005883a 	mov	r2,zero
8013cb08:	00006606 	br	8013cca4 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8013cb0c:	e0bffc17 	ldw	r2,-16(fp)
8013cb10:	1000051e 	bne	r2,zero,8013cb28 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8013cb14:	e0bfff17 	ldw	r2,-4(fp)
8013cb18:	00ffe284 	movi	r3,-118
8013cb1c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013cb20:	0005883a 	mov	r2,zero
8013cb24:	00005f06 	br	8013cca4 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8013cb28:	e0bffc17 	ldw	r2,-16(fp)
8013cb2c:	10800003 	ldbu	r2,0(r2)
8013cb30:	10803fcc 	andi	r2,r2,255
8013cb34:	10801920 	cmpeqi	r2,r2,100
8013cb38:	1000051e 	bne	r2,zero,8013cb50 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8013cb3c:	e0bfff17 	ldw	r2,-4(fp)
8013cb40:	00ffe244 	movi	r3,-119
8013cb44:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013cb48:	0005883a 	mov	r2,zero
8013cb4c:	00005506 	br	8013cca4 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8013cb50:	d0a0aa03 	ldbu	r2,-32088(gp)
8013cb54:	10803fcc 	andi	r2,r2,255
8013cb58:	10000526 	beq	r2,zero,8013cb70 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8013cb5c:	e0bfff17 	ldw	r2,-4(fp)
8013cb60:	00ffe2c4 	movi	r3,-117
8013cb64:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8013cb68:	0005883a 	mov	r2,zero
8013cb6c:	00004d06 	br	8013cca4 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8013cb70:	013d2580 	call	8013d258 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8013cb74:	e0bffc17 	ldw	r2,-16(fp)
8013cb78:	10800c43 	ldbu	r2,49(r2)
8013cb7c:	10803fcc 	andi	r2,r2,255
8013cb80:	10c000c8 	cmpgei	r3,r2,3
8013cb84:	1800031e 	bne	r3,zero,8013cb94 <OSTmrStop+0xc4>
8013cb88:	00803516 	blt	zero,r2,8013cc60 <OSTmrStop+0x190>
8013cb8c:	10003a26 	beq	r2,zero,8013cc78 <OSTmrStop+0x1a8>
8013cb90:	00003f06 	br	8013cc90 <OSTmrStop+0x1c0>
8013cb94:	108000e0 	cmpeqi	r2,r2,3
8013cb98:	10003d26 	beq	r2,zero,8013cc90 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8013cb9c:	e13ffc17 	ldw	r4,-16(fp)
8013cba0:	013d15c0 	call	8013d15c <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8013cba4:	e0bfff17 	ldw	r2,-4(fp)
8013cba8:	10000005 	stb	zero,0(r2)
             switch (opt) {
8013cbac:	e0bffd03 	ldbu	r2,-12(fp)
8013cbb0:	10c000e0 	cmpeqi	r3,r2,3
8013cbb4:	1800041e 	bne	r3,zero,8013cbc8 <OSTmrStop+0xf8>
8013cbb8:	10c00120 	cmpeqi	r3,r2,4
8013cbbc:	1800121e 	bne	r3,zero,8013cc08 <OSTmrStop+0x138>
8013cbc0:	10002326 	beq	r2,zero,8013cc50 <OSTmrStop+0x180>
8013cbc4:	00001e06 	br	8013cc40 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8013cbc8:	e0bffc17 	ldw	r2,-16(fp)
8013cbcc:	10800117 	ldw	r2,4(r2)
8013cbd0:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8013cbd4:	e0bffb17 	ldw	r2,-20(fp)
8013cbd8:	10000726 	beq	r2,zero,8013cbf8 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8013cbdc:	e0bffc17 	ldw	r2,-16(fp)
8013cbe0:	10c00217 	ldw	r3,8(r2)
8013cbe4:	e0bffb17 	ldw	r2,-20(fp)
8013cbe8:	180b883a 	mov	r5,r3
8013cbec:	e13ffc17 	ldw	r4,-16(fp)
8013cbf0:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8013cbf4:	00001706 	br	8013cc54 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8013cbf8:	e0bfff17 	ldw	r2,-4(fp)
8013cbfc:	00ffe3c4 	movi	r3,-113
8013cc00:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8013cc04:	00001306 	br	8013cc54 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8013cc08:	e0bffc17 	ldw	r2,-16(fp)
8013cc0c:	10800117 	ldw	r2,4(r2)
8013cc10:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8013cc14:	e0bffb17 	ldw	r2,-20(fp)
8013cc18:	10000526 	beq	r2,zero,8013cc30 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8013cc1c:	e0bffb17 	ldw	r2,-20(fp)
8013cc20:	e17ffe17 	ldw	r5,-8(fp)
8013cc24:	e13ffc17 	ldw	r4,-16(fp)
8013cc28:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8013cc2c:	00000906 	br	8013cc54 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8013cc30:	e0bfff17 	ldw	r2,-4(fp)
8013cc34:	00ffe3c4 	movi	r3,-113
8013cc38:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8013cc3c:	00000506 	br	8013cc54 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8013cc40:	e0bfff17 	ldw	r2,-4(fp)
8013cc44:	00ffe104 	movi	r3,-124
8013cc48:	10c00005 	stb	r3,0(r2)
                     break;
8013cc4c:	00000106 	br	8013cc54 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8013cc50:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8013cc54:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             return (OS_TRUE);
8013cc58:	00800044 	movi	r2,1
8013cc5c:	00001106 	br	8013cca4 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8013cc60:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8013cc64:	e0bfff17 	ldw	r2,-4(fp)
8013cc68:	00ffe384 	movi	r3,-114
8013cc6c:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8013cc70:	00800044 	movi	r2,1
8013cc74:	00000b06 	br	8013cca4 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8013cc78:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8013cc7c:	e0bfff17 	ldw	r2,-4(fp)
8013cc80:	00ffe1c4 	movi	r3,-121
8013cc84:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8013cc88:	0005883a 	mov	r2,zero
8013cc8c:	00000506 	br	8013cca4 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8013cc90:	013d29c0 	call	8013d29c <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8013cc94:	e0bfff17 	ldw	r2,-4(fp)
8013cc98:	00ffe344 	movi	r3,-115
8013cc9c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8013cca0:	0005883a 	mov	r2,zero
    }
}
8013cca4:	e037883a 	mov	sp,fp
8013cca8:	dfc00117 	ldw	ra,4(sp)
8013ccac:	df000017 	ldw	fp,0(sp)
8013ccb0:	dec00204 	addi	sp,sp,8
8013ccb4:	f800283a 	ret

8013ccb8 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8013ccb8:	defffd04 	addi	sp,sp,-12
8013ccbc:	de00012e 	bgeu	sp,et,8013ccc4 <OSTmrSignal+0xc>
8013ccc0:	003b68fa 	trap	3
8013ccc4:	dfc00215 	stw	ra,8(sp)
8013ccc8:	df000115 	stw	fp,4(sp)
8013cccc:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8013ccd0:	d0a09917 	ldw	r2,-32156(gp)
8013ccd4:	1009883a 	mov	r4,r2
8013ccd8:	013a2840 	call	8013a284 <OSSemPost>
8013ccdc:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8013cce0:	e0bfff03 	ldbu	r2,-4(fp)
}
8013cce4:	e037883a 	mov	sp,fp
8013cce8:	dfc00117 	ldw	ra,4(sp)
8013ccec:	df000017 	ldw	fp,0(sp)
8013ccf0:	dec00204 	addi	sp,sp,8
8013ccf4:	f800283a 	ret

8013ccf8 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8013ccf8:	defffe04 	addi	sp,sp,-8
8013ccfc:	de00012e 	bgeu	sp,et,8013cd04 <OSTmr_Alloc+0xc>
8013cd00:	003b68fa 	trap	3
8013cd04:	df000115 	stw	fp,4(sp)
8013cd08:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8013cd0c:	d0a09717 	ldw	r2,-32164(gp)
8013cd10:	1000021e 	bne	r2,zero,8013cd1c <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8013cd14:	0005883a 	mov	r2,zero
8013cd18:	00001006 	br	8013cd5c <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8013cd1c:	d0a09717 	ldw	r2,-32164(gp)
8013cd20:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8013cd24:	e0bfff17 	ldw	r2,-4(fp)
8013cd28:	10800317 	ldw	r2,12(r2)
8013cd2c:	d0a09715 	stw	r2,-32164(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8013cd30:	e0bfff17 	ldw	r2,-4(fp)
8013cd34:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8013cd38:	e0bfff17 	ldw	r2,-4(fp)
8013cd3c:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8013cd40:	d0a09c0b 	ldhu	r2,-32144(gp)
8013cd44:	10800044 	addi	r2,r2,1
8013cd48:	d0a09c0d 	sth	r2,-32144(gp)
    OSTmrFree--;
8013cd4c:	d0a0a00b 	ldhu	r2,-32128(gp)
8013cd50:	10bfffc4 	addi	r2,r2,-1
8013cd54:	d0a0a00d 	sth	r2,-32128(gp)
    return (ptmr);
8013cd58:	e0bfff17 	ldw	r2,-4(fp)
}
8013cd5c:	e037883a 	mov	sp,fp
8013cd60:	df000017 	ldw	fp,0(sp)
8013cd64:	dec00104 	addi	sp,sp,4
8013cd68:	f800283a 	ret

8013cd6c <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8013cd6c:	defffe04 	addi	sp,sp,-8
8013cd70:	de00012e 	bgeu	sp,et,8013cd78 <OSTmr_Free+0xc>
8013cd74:	003b68fa 	trap	3
8013cd78:	df000115 	stw	fp,4(sp)
8013cd7c:	df000104 	addi	fp,sp,4
8013cd80:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8013cd84:	e0bfff17 	ldw	r2,-4(fp)
8013cd88:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8013cd8c:	e0bfff17 	ldw	r2,-4(fp)
8013cd90:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8013cd94:	e0bfff17 	ldw	r2,-4(fp)
8013cd98:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8013cd9c:	e0bfff17 	ldw	r2,-4(fp)
8013cda0:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8013cda4:	e0bfff17 	ldw	r2,-4(fp)
8013cda8:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8013cdac:	e0bfff17 	ldw	r2,-4(fp)
8013cdb0:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8013cdb4:	e0bfff17 	ldw	r2,-4(fp)
8013cdb8:	00c00fc4 	movi	r3,63
8013cdbc:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8013cdc0:	e0bfff17 	ldw	r2,-4(fp)
8013cdc4:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8013cdc8:	e0bfff17 	ldw	r2,-4(fp)
8013cdcc:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8013cdd0:	d0e09717 	ldw	r3,-32164(gp)
8013cdd4:	e0bfff17 	ldw	r2,-4(fp)
8013cdd8:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8013cddc:	e0bfff17 	ldw	r2,-4(fp)
8013cde0:	d0a09715 	stw	r2,-32164(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8013cde4:	d0a09c0b 	ldhu	r2,-32144(gp)
8013cde8:	10bfffc4 	addi	r2,r2,-1
8013cdec:	d0a09c0d 	sth	r2,-32144(gp)
    OSTmrFree++;
8013cdf0:	d0a0a00b 	ldhu	r2,-32128(gp)
8013cdf4:	10800044 	addi	r2,r2,1
8013cdf8:	d0a0a00d 	sth	r2,-32128(gp)
}
8013cdfc:	0001883a 	nop
8013ce00:	e037883a 	mov	sp,fp
8013ce04:	df000017 	ldw	fp,0(sp)
8013ce08:	dec00104 	addi	sp,sp,4
8013ce0c:	f800283a 	ret

8013ce10 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8013ce10:	defffa04 	addi	sp,sp,-24
8013ce14:	de00012e 	bgeu	sp,et,8013ce1c <OSTmr_Init+0xc>
8013ce18:	003b68fa 	trap	3
8013ce1c:	dfc00515 	stw	ra,20(sp)
8013ce20:	df000415 	stw	fp,16(sp)
8013ce24:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8013ce28:	01406804 	movi	r5,416
8013ce2c:	012005b4 	movhi	r4,32790
8013ce30:	213c6904 	addi	r4,r4,-3676
8013ce34:	0134f800 	call	80134f80 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8013ce38:	01400404 	movi	r5,16
8013ce3c:	012005b4 	movhi	r4,32790
8013ce40:	213a5504 	addi	r4,r4,-5804
8013ce44:	0134f800 	call	80134f80 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8013ce48:	00a005b4 	movhi	r2,32790
8013ce4c:	10bc6904 	addi	r2,r2,-3676
8013ce50:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8013ce54:	00a005b4 	movhi	r2,32790
8013ce58:	10bc7604 	addi	r2,r2,-3624
8013ce5c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8013ce60:	e03ffc0d 	sth	zero,-16(fp)
8013ce64:	00001606 	br	8013cec0 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8013ce68:	e0bffd17 	ldw	r2,-12(fp)
8013ce6c:	00c01904 	movi	r3,100
8013ce70:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8013ce74:	e0bffd17 	ldw	r2,-12(fp)
8013ce78:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8013ce7c:	e0bffd17 	ldw	r2,-12(fp)
8013ce80:	e0fffe17 	ldw	r3,-8(fp)
8013ce84:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8013ce88:	e0bffd17 	ldw	r2,-12(fp)
8013ce8c:	00c00fc4 	movi	r3,63
8013ce90:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8013ce94:	e0bffd17 	ldw	r2,-12(fp)
8013ce98:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8013ce9c:	e0bffd17 	ldw	r2,-12(fp)
8013cea0:	10800d04 	addi	r2,r2,52
8013cea4:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8013cea8:	e0bffe17 	ldw	r2,-8(fp)
8013ceac:	10800d04 	addi	r2,r2,52
8013ceb0:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8013ceb4:	e0bffc0b 	ldhu	r2,-16(fp)
8013ceb8:	10800044 	addi	r2,r2,1
8013cebc:	e0bffc0d 	sth	r2,-16(fp)
8013cec0:	e0bffc0b 	ldhu	r2,-16(fp)
8013cec4:	108001f0 	cmpltui	r2,r2,7
8013cec8:	103fe71e 	bne	r2,zero,8013ce68 <__reset+0xfa11ce68>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8013cecc:	e0bffd17 	ldw	r2,-12(fp)
8013ced0:	00c01904 	movi	r3,100
8013ced4:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8013ced8:	e0bffd17 	ldw	r2,-12(fp)
8013cedc:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8013cee0:	e0bffd17 	ldw	r2,-12(fp)
8013cee4:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8013cee8:	e0bffd17 	ldw	r2,-12(fp)
8013ceec:	00c00fc4 	movi	r3,63
8013cef0:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8013cef4:	e0bffd17 	ldw	r2,-12(fp)
8013cef8:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8013cefc:	d020ac15 	stw	zero,-32080(gp)
    OSTmrUsed           = 0;
8013cf00:	d0209c0d 	sth	zero,-32144(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8013cf04:	00800204 	movi	r2,8
8013cf08:	d0a0a00d 	sth	r2,-32128(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8013cf0c:	00a005b4 	movhi	r2,32790
8013cf10:	10bc6904 	addi	r2,r2,-3676
8013cf14:	d0a09715 	stw	r2,-32164(gp)
    OSTmrSem            = OSSemCreate(1);
8013cf18:	01000044 	movi	r4,1
8013cf1c:	0139bd40 	call	80139bd4 <OSSemCreate>
8013cf20:	d0a0ae15 	stw	r2,-32072(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8013cf24:	0009883a 	mov	r4,zero
8013cf28:	0139bd40 	call	80139bd4 <OSSemCreate>
8013cf2c:	d0a09915 	stw	r2,-32156(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8013cf30:	d0a0ae17 	ldw	r2,-32072(gp)
8013cf34:	e0ffff04 	addi	r3,fp,-4
8013cf38:	180d883a 	mov	r6,r3
8013cf3c:	01600574 	movhi	r5,32789
8013cf40:	29605a04 	addi	r5,r5,-32408
8013cf44:	1009883a 	mov	r4,r2
8013cf48:	01337dc0 	call	801337dc <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8013cf4c:	d0a09917 	ldw	r2,-32156(gp)
8013cf50:	e0ffff04 	addi	r3,fp,-4
8013cf54:	180d883a 	mov	r6,r3
8013cf58:	01600574 	movhi	r5,32789
8013cf5c:	29605f04 	addi	r5,r5,-32388
8013cf60:	1009883a 	mov	r4,r2
8013cf64:	01337dc0 	call	801337dc <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8013cf68:	013cf840 	call	8013cf84 <OSTmr_InitTask>
}
8013cf6c:	0001883a 	nop
8013cf70:	e037883a 	mov	sp,fp
8013cf74:	dfc00117 	ldw	ra,4(sp)
8013cf78:	df000017 	ldw	fp,0(sp)
8013cf7c:	dec00204 	addi	sp,sp,8
8013cf80:	f800283a 	ret

8013cf84 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8013cf84:	defff804 	addi	sp,sp,-32
8013cf88:	de00012e 	bgeu	sp,et,8013cf90 <OSTmr_InitTask+0xc>
8013cf8c:	003b68fa 	trap	3
8013cf90:	dfc00715 	stw	ra,28(sp)
8013cf94:	df000615 	stw	fp,24(sp)
8013cf98:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8013cf9c:	008000c4 	movi	r2,3
8013cfa0:	d8800415 	stw	r2,16(sp)
8013cfa4:	d8000315 	stw	zero,12(sp)
8013cfa8:	00808004 	movi	r2,512
8013cfac:	d8800215 	stw	r2,8(sp)
8013cfb0:	00a005b4 	movhi	r2,32790
8013cfb4:	10849d04 	addi	r2,r2,4724
8013cfb8:	d8800115 	stw	r2,4(sp)
8013cfbc:	00bfff54 	movui	r2,65533
8013cfc0:	d8800015 	stw	r2,0(sp)
8013cfc4:	01c00744 	movi	r7,29
8013cfc8:	01a005b4 	movhi	r6,32790
8013cfcc:	31869c04 	addi	r6,r6,6768
8013cfd0:	000b883a 	mov	r5,zero
8013cfd4:	01200534 	movhi	r4,32788
8013cfd8:	2134b604 	addi	r4,r4,-11560
8013cfdc:	013ac680 	call	8013ac68 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8013cfe0:	e1bfff04 	addi	r6,fp,-4
8013cfe4:	01600574 	movhi	r5,32789
8013cfe8:	29606404 	addi	r5,r5,-32368
8013cfec:	01000744 	movi	r4,29
8013cff0:	013b4980 	call	8013b498 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8013cff4:	0001883a 	nop
8013cff8:	e037883a 	mov	sp,fp
8013cffc:	dfc00117 	ldw	ra,4(sp)
8013d000:	df000017 	ldw	fp,0(sp)
8013d004:	dec00204 	addi	sp,sp,8
8013d008:	f800283a 	ret

8013d00c <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8013d00c:	defffa04 	addi	sp,sp,-24
8013d010:	de00012e 	bgeu	sp,et,8013d018 <OSTmr_Link+0xc>
8013d014:	003b68fa 	trap	3
8013d018:	df000515 	stw	fp,20(sp)
8013d01c:	df000504 	addi	fp,sp,20
8013d020:	e13ffe15 	stw	r4,-8(fp)
8013d024:	2805883a 	mov	r2,r5
8013d028:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8013d02c:	e0bffe17 	ldw	r2,-8(fp)
8013d030:	00c000c4 	movi	r3,3
8013d034:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8013d038:	e0bfff03 	ldbu	r2,-4(fp)
8013d03c:	10800058 	cmpnei	r2,r2,1
8013d040:	1000071e 	bne	r2,zero,8013d060 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8013d044:	e0bffe17 	ldw	r2,-8(fp)
8013d048:	10c00717 	ldw	r3,28(r2)
8013d04c:	d0a0ac17 	ldw	r2,-32080(gp)
8013d050:	1887883a 	add	r3,r3,r2
8013d054:	e0bffe17 	ldw	r2,-8(fp)
8013d058:	10c00515 	stw	r3,20(r2)
8013d05c:	00001006 	br	8013d0a0 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8013d060:	e0bffe17 	ldw	r2,-8(fp)
8013d064:	10800617 	ldw	r2,24(r2)
8013d068:	1000071e 	bne	r2,zero,8013d088 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8013d06c:	e0bffe17 	ldw	r2,-8(fp)
8013d070:	10c00717 	ldw	r3,28(r2)
8013d074:	d0a0ac17 	ldw	r2,-32080(gp)
8013d078:	1887883a 	add	r3,r3,r2
8013d07c:	e0bffe17 	ldw	r2,-8(fp)
8013d080:	10c00515 	stw	r3,20(r2)
8013d084:	00000606 	br	8013d0a0 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8013d088:	e0bffe17 	ldw	r2,-8(fp)
8013d08c:	10c00617 	ldw	r3,24(r2)
8013d090:	d0a0ac17 	ldw	r2,-32080(gp)
8013d094:	1887883a 	add	r3,r3,r2
8013d098:	e0bffe17 	ldw	r2,-8(fp)
8013d09c:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8013d0a0:	e0bffe17 	ldw	r2,-8(fp)
8013d0a4:	10800517 	ldw	r2,20(r2)
8013d0a8:	1080004c 	andi	r2,r2,1
8013d0ac:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8013d0b0:	e0bffb0b 	ldhu	r2,-20(fp)
8013d0b4:	100690fa 	slli	r3,r2,3
8013d0b8:	00a005b4 	movhi	r2,32790
8013d0bc:	10ba5504 	addi	r2,r2,-5804
8013d0c0:	1885883a 	add	r2,r3,r2
8013d0c4:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8013d0c8:	e0bffc17 	ldw	r2,-16(fp)
8013d0cc:	10800017 	ldw	r2,0(r2)
8013d0d0:	1000091e 	bne	r2,zero,8013d0f8 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8013d0d4:	e0bffc17 	ldw	r2,-16(fp)
8013d0d8:	e0fffe17 	ldw	r3,-8(fp)
8013d0dc:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8013d0e0:	e0bffe17 	ldw	r2,-8(fp)
8013d0e4:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8013d0e8:	e0bffc17 	ldw	r2,-16(fp)
8013d0ec:	00c00044 	movi	r3,1
8013d0f0:	10c0010d 	sth	r3,4(r2)
8013d0f4:	00001206 	br	8013d140 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8013d0f8:	e0bffc17 	ldw	r2,-16(fp)
8013d0fc:	10800017 	ldw	r2,0(r2)
8013d100:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8013d104:	e0bffc17 	ldw	r2,-16(fp)
8013d108:	e0fffe17 	ldw	r3,-8(fp)
8013d10c:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8013d110:	e0bffe17 	ldw	r2,-8(fp)
8013d114:	e0fffd17 	ldw	r3,-12(fp)
8013d118:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8013d11c:	e0bffd17 	ldw	r2,-12(fp)
8013d120:	e0fffe17 	ldw	r3,-8(fp)
8013d124:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8013d128:	e0bffc17 	ldw	r2,-16(fp)
8013d12c:	1080010b 	ldhu	r2,4(r2)
8013d130:	10800044 	addi	r2,r2,1
8013d134:	1007883a 	mov	r3,r2
8013d138:	e0bffc17 	ldw	r2,-16(fp)
8013d13c:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8013d140:	e0bffe17 	ldw	r2,-8(fp)
8013d144:	10000415 	stw	zero,16(r2)
}
8013d148:	0001883a 	nop
8013d14c:	e037883a 	mov	sp,fp
8013d150:	df000017 	ldw	fp,0(sp)
8013d154:	dec00104 	addi	sp,sp,4
8013d158:	f800283a 	ret

8013d15c <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8013d15c:	defffa04 	addi	sp,sp,-24
8013d160:	de00012e 	bgeu	sp,et,8013d168 <OSTmr_Unlink+0xc>
8013d164:	003b68fa 	trap	3
8013d168:	df000515 	stw	fp,20(sp)
8013d16c:	df000504 	addi	fp,sp,20
8013d170:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8013d174:	e0bfff17 	ldw	r2,-4(fp)
8013d178:	10800517 	ldw	r2,20(r2)
8013d17c:	1080004c 	andi	r2,r2,1
8013d180:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8013d184:	e0bffb0b 	ldhu	r2,-20(fp)
8013d188:	100690fa 	slli	r3,r2,3
8013d18c:	00a005b4 	movhi	r2,32790
8013d190:	10ba5504 	addi	r2,r2,-5804
8013d194:	1885883a 	add	r2,r3,r2
8013d198:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8013d19c:	e0bffc17 	ldw	r2,-16(fp)
8013d1a0:	10c00017 	ldw	r3,0(r2)
8013d1a4:	e0bfff17 	ldw	r2,-4(fp)
8013d1a8:	18800b1e 	bne	r3,r2,8013d1d8 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8013d1ac:	e0bfff17 	ldw	r2,-4(fp)
8013d1b0:	10800317 	ldw	r2,12(r2)
8013d1b4:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8013d1b8:	e0bffc17 	ldw	r2,-16(fp)
8013d1bc:	e0fffd17 	ldw	r3,-12(fp)
8013d1c0:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8013d1c4:	e0bffd17 	ldw	r2,-12(fp)
8013d1c8:	10001126 	beq	r2,zero,8013d210 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8013d1cc:	e0bffd17 	ldw	r2,-12(fp)
8013d1d0:	10000415 	stw	zero,16(r2)
8013d1d4:	00000e06 	br	8013d210 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8013d1d8:	e0bfff17 	ldw	r2,-4(fp)
8013d1dc:	10800417 	ldw	r2,16(r2)
8013d1e0:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8013d1e4:	e0bfff17 	ldw	r2,-4(fp)
8013d1e8:	10800317 	ldw	r2,12(r2)
8013d1ec:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8013d1f0:	e0bffd17 	ldw	r2,-12(fp)
8013d1f4:	e0fffe17 	ldw	r3,-8(fp)
8013d1f8:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8013d1fc:	e0bffe17 	ldw	r2,-8(fp)
8013d200:	10000326 	beq	r2,zero,8013d210 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8013d204:	e0bffe17 	ldw	r2,-8(fp)
8013d208:	e0fffd17 	ldw	r3,-12(fp)
8013d20c:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8013d210:	e0bfff17 	ldw	r2,-4(fp)
8013d214:	00c00044 	movi	r3,1
8013d218:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8013d21c:	e0bfff17 	ldw	r2,-4(fp)
8013d220:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8013d224:	e0bfff17 	ldw	r2,-4(fp)
8013d228:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8013d22c:	e0bffc17 	ldw	r2,-16(fp)
8013d230:	1080010b 	ldhu	r2,4(r2)
8013d234:	10bfffc4 	addi	r2,r2,-1
8013d238:	1007883a 	mov	r3,r2
8013d23c:	e0bffc17 	ldw	r2,-16(fp)
8013d240:	10c0010d 	sth	r3,4(r2)
}
8013d244:	0001883a 	nop
8013d248:	e037883a 	mov	sp,fp
8013d24c:	df000017 	ldw	fp,0(sp)
8013d250:	dec00104 	addi	sp,sp,4
8013d254:	f800283a 	ret

8013d258 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8013d258:	defffd04 	addi	sp,sp,-12
8013d25c:	de00012e 	bgeu	sp,et,8013d264 <OSTmr_Lock+0xc>
8013d260:	003b68fa 	trap	3
8013d264:	dfc00215 	stw	ra,8(sp)
8013d268:	df000115 	stw	fp,4(sp)
8013d26c:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8013d270:	d0a0ae17 	ldw	r2,-32072(gp)
8013d274:	e1bfff04 	addi	r6,fp,-4
8013d278:	000b883a 	mov	r5,zero
8013d27c:	1009883a 	mov	r4,r2
8013d280:	0139efc0 	call	80139efc <OSSemPend>
    (void)err;
}
8013d284:	0001883a 	nop
8013d288:	e037883a 	mov	sp,fp
8013d28c:	dfc00117 	ldw	ra,4(sp)
8013d290:	df000017 	ldw	fp,0(sp)
8013d294:	dec00204 	addi	sp,sp,8
8013d298:	f800283a 	ret

8013d29c <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8013d29c:	defffe04 	addi	sp,sp,-8
8013d2a0:	de00012e 	bgeu	sp,et,8013d2a8 <OSTmr_Unlock+0xc>
8013d2a4:	003b68fa 	trap	3
8013d2a8:	dfc00115 	stw	ra,4(sp)
8013d2ac:	df000015 	stw	fp,0(sp)
8013d2b0:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8013d2b4:	d0a0ae17 	ldw	r2,-32072(gp)
8013d2b8:	1009883a 	mov	r4,r2
8013d2bc:	013a2840 	call	8013a284 <OSSemPost>
}
8013d2c0:	0001883a 	nop
8013d2c4:	e037883a 	mov	sp,fp
8013d2c8:	dfc00117 	ldw	ra,4(sp)
8013d2cc:	df000017 	ldw	fp,0(sp)
8013d2d0:	dec00204 	addi	sp,sp,8
8013d2d4:	f800283a 	ret

8013d2d8 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8013d2d8:	defff704 	addi	sp,sp,-36
8013d2dc:	de00012e 	bgeu	sp,et,8013d2e4 <OSTmr_Task+0xc>
8013d2e0:	003b68fa 	trap	3
8013d2e4:	dfc00815 	stw	ra,32(sp)
8013d2e8:	df000715 	stw	fp,28(sp)
8013d2ec:	df000704 	addi	fp,sp,28
8013d2f0:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8013d2f4:	d0a09917 	ldw	r2,-32156(gp)
8013d2f8:	e0fffe04 	addi	r3,fp,-8
8013d2fc:	180d883a 	mov	r6,r3
8013d300:	000b883a 	mov	r5,zero
8013d304:	1009883a 	mov	r4,r2
8013d308:	0139efc0 	call	80139efc <OSSemPend>
        OSTmr_Lock();
8013d30c:	013d2580 	call	8013d258 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8013d310:	d0a0ac17 	ldw	r2,-32080(gp)
8013d314:	10800044 	addi	r2,r2,1
8013d318:	d0a0ac15 	stw	r2,-32080(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8013d31c:	d0a0ac17 	ldw	r2,-32080(gp)
8013d320:	1080004c 	andi	r2,r2,1
8013d324:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8013d328:	e0bffa0b 	ldhu	r2,-24(fp)
8013d32c:	100690fa 	slli	r3,r2,3
8013d330:	00a005b4 	movhi	r2,32790
8013d334:	10ba5504 	addi	r2,r2,-5804
8013d338:	1885883a 	add	r2,r3,r2
8013d33c:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8013d340:	e0bffb17 	ldw	r2,-20(fp)
8013d344:	10800017 	ldw	r2,0(r2)
8013d348:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8013d34c:	00002206 	br	8013d3d8 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8013d350:	e0bff917 	ldw	r2,-28(fp)
8013d354:	10800317 	ldw	r2,12(r2)
8013d358:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8013d35c:	e0bff917 	ldw	r2,-28(fp)
8013d360:	10c00517 	ldw	r3,20(r2)
8013d364:	d0a0ac17 	ldw	r2,-32080(gp)
8013d368:	1880191e 	bne	r3,r2,8013d3d0 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8013d36c:	e0bff917 	ldw	r2,-28(fp)
8013d370:	10800117 	ldw	r2,4(r2)
8013d374:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8013d378:	e0bffd17 	ldw	r2,-12(fp)
8013d37c:	10000626 	beq	r2,zero,8013d398 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8013d380:	e0bff917 	ldw	r2,-28(fp)
8013d384:	10c00217 	ldw	r3,8(r2)
8013d388:	e0bffd17 	ldw	r2,-12(fp)
8013d38c:	180b883a 	mov	r5,r3
8013d390:	e13ff917 	ldw	r4,-28(fp)
8013d394:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8013d398:	e13ff917 	ldw	r4,-28(fp)
8013d39c:	013d15c0 	call	8013d15c <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8013d3a0:	e0bff917 	ldw	r2,-28(fp)
8013d3a4:	10800c03 	ldbu	r2,48(r2)
8013d3a8:	10803fcc 	andi	r2,r2,255
8013d3ac:	10800098 	cmpnei	r2,r2,2
8013d3b0:	1000041e 	bne	r2,zero,8013d3c4 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8013d3b4:	01400044 	movi	r5,1
8013d3b8:	e13ff917 	ldw	r4,-28(fp)
8013d3bc:	013d00c0 	call	8013d00c <OSTmr_Link>
8013d3c0:	00000306 	br	8013d3d0 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8013d3c4:	e0bff917 	ldw	r2,-28(fp)
8013d3c8:	00c00084 	movi	r3,2
8013d3cc:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8013d3d0:	e0bffc17 	ldw	r2,-16(fp)
8013d3d4:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8013d3d8:	e0bff917 	ldw	r2,-28(fp)
8013d3dc:	103fdc1e 	bne	r2,zero,8013d350 <__reset+0xfa11d350>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8013d3e0:	013d29c0 	call	8013d29c <OSTmr_Unlock>
    }
8013d3e4:	003fc306 	br	8013d2f4 <__reset+0xfa11d2f4>

8013d3e8 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
8013d3e8:	defffd04 	addi	sp,sp,-12
8013d3ec:	de00012e 	bgeu	sp,et,8013d3f4 <alt_dev_reg+0xc>
8013d3f0:	003b68fa 	trap	3
8013d3f4:	dfc00215 	stw	ra,8(sp)
8013d3f8:	df000115 	stw	fp,4(sp)
8013d3fc:	df000104 	addi	fp,sp,4
8013d400:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8013d404:	d1600c04 	addi	r5,gp,-32720
8013d408:	e13fff17 	ldw	r4,-4(fp)
8013d40c:	01456880 	call	80145688 <alt_dev_llist_insert>
}
8013d410:	e037883a 	mov	sp,fp
8013d414:	dfc00117 	ldw	ra,4(sp)
8013d418:	df000017 	ldw	fp,0(sp)
8013d41c:	dec00204 	addi	sp,sp,8
8013d420:	f800283a 	ret

8013d424 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8013d424:	defffd04 	addi	sp,sp,-12
8013d428:	de00012e 	bgeu	sp,et,8013d430 <alt_irq_init+0xc>
8013d42c:	003b68fa 	trap	3
8013d430:	dfc00215 	stw	ra,8(sp)
8013d434:	df000115 	stw	fp,4(sp)
8013d438:	df000104 	addi	fp,sp,4
8013d43c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8013d440:	01460c80 	call	801460c8 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8013d444:	00800044 	movi	r2,1
8013d448:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8013d44c:	0001883a 	nop
8013d450:	e037883a 	mov	sp,fp
8013d454:	dfc00117 	ldw	ra,4(sp)
8013d458:	df000017 	ldw	fp,0(sp)
8013d45c:	dec00204 	addi	sp,sp,8
8013d460:	f800283a 	ret

8013d464 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8013d464:	defffe04 	addi	sp,sp,-8
8013d468:	de00012e 	bgeu	sp,et,8013d470 <alt_sys_init+0xc>
8013d46c:	003b68fa 	trap	3
8013d470:	dfc00115 	stw	ra,4(sp)
8013d474:	df000015 	stw	fp,0(sp)
8013d478:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8013d47c:	01c0fa04 	movi	r7,1000
8013d480:	01800204 	movi	r6,8
8013d484:	000b883a 	mov	r5,zero
8013d488:	01100034 	movhi	r4,16384
8013d48c:	21022004 	addi	r4,r4,2176
8013d490:	01427bc0 	call	801427bc <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8013d494:	018001c4 	movi	r6,7
8013d498:	000b883a 	mov	r5,zero
8013d49c:	01200574 	movhi	r4,32789
8013d4a0:	21240004 	addi	r4,r4,-28672
8013d4a4:	0141aa80 	call	80141aa8 <altera_avalon_jtag_uart_init>
8013d4a8:	01200574 	movhi	r4,32789
8013d4ac:	2123f604 	addi	r4,r4,-28712
8013d4b0:	013d3e80 	call	8013d3e8 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8013d4b4:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
8013d4b8:	018002c4 	movi	r6,11
8013d4bc:	000b883a 	mov	r5,zero
8013d4c0:	01200574 	movhi	r4,32789
8013d4c4:	21281b04 	addi	r4,r4,-24468
8013d4c8:	01429680 	call	80142968 <altera_avalon_uart_init>
8013d4cc:	01200574 	movhi	r4,32789
8013d4d0:	21281104 	addi	r4,r4,-24508
8013d4d4:	013d3e80 	call	8013d3e8 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
8013d4d8:	00a00574 	movhi	r2,32789
8013d4dc:	10a84504 	addi	r2,r2,-24300
8013d4e0:	10c00717 	ldw	r3,28(r2)
8013d4e4:	00a00574 	movhi	r2,32789
8013d4e8:	10a84504 	addi	r2,r2,-24300
8013d4ec:	10800817 	ldw	r2,32(r2)
8013d4f0:	100d883a 	mov	r6,r2
8013d4f4:	180b883a 	mov	r5,r3
8013d4f8:	01200574 	movhi	r4,32789
8013d4fc:	21284504 	addi	r4,r4,-24300
8013d500:	01451f00 	call	801451f0 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8013d504:	00a00574 	movhi	r2,32789
8013d508:	10a85e04 	addi	r2,r2,-24200
8013d50c:	10c00717 	ldw	r3,28(r2)
8013d510:	00a00574 	movhi	r2,32789
8013d514:	10a85e04 	addi	r2,r2,-24200
8013d518:	10800817 	ldw	r2,32(r2)
8013d51c:	100d883a 	mov	r6,r2
8013d520:	180b883a 	mov	r5,r3
8013d524:	01200574 	movhi	r4,32789
8013d528:	21285e04 	addi	r4,r4,-24200
8013d52c:	01451f00 	call	801451f0 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8013d530:	01200574 	movhi	r4,32789
8013d534:	21287704 	addi	r4,r4,-24100
8013d538:	013d3e80 	call	8013d3e8 <alt_dev_reg>
}
8013d53c:	0001883a 	nop
8013d540:	e037883a 	mov	sp,fp
8013d544:	dfc00117 	ldw	ra,4(sp)
8013d548:	df000017 	ldw	fp,0(sp)
8013d54c:	dec00204 	addi	sp,sp,8
8013d550:	f800283a 	ret

8013d554 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8013d554:	defffa04 	addi	sp,sp,-24
8013d558:	de00012e 	bgeu	sp,et,8013d560 <Write_Sector_Data+0xc>
8013d55c:	003b68fa 	trap	3
8013d560:	dfc00515 	stw	ra,20(sp)
8013d564:	df000415 	stw	fp,16(sp)
8013d568:	df000404 	addi	fp,sp,16
8013d56c:	e13ffe15 	stw	r4,-8(fp)
8013d570:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8013d574:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
8013d578:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
8013d57c:	10001e26 	beq	r2,zero,8013d5f8 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8013d580:	00803fc4 	movi	r2,255
8013d584:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8013d588:	d0a0b817 	ldw	r2,-32032(gp)
8013d58c:	e13ffe17 	ldw	r4,-8(fp)
8013d590:	e0ffff17 	ldw	r3,-4(fp)
8013d594:	20c7883a 	add	r3,r4,r3
8013d598:	1806927a 	slli	r3,r3,9
8013d59c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8013d5a0:	d0a0b717 	ldw	r2,-32036(gp)
8013d5a4:	00c00604 	movi	r3,24
8013d5a8:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8013d5ac:	d0a0b417 	ldw	r2,-32048(gp)
8013d5b0:	1080002b 	ldhuio	r2,0(r2)
8013d5b4:	10bfffcc 	andi	r2,r2,65535
8013d5b8:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8013d5bc:	e0bffd0b 	ldhu	r2,-12(fp)
8013d5c0:	10bfffcc 	andi	r2,r2,65535
8013d5c4:	1080010c 	andi	r2,r2,4
8013d5c8:	103ff81e 	bne	r2,zero,8013d5ac <__reset+0xfa11d5ac>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8013d5cc:	e0bffd0b 	ldhu	r2,-12(fp)
8013d5d0:	10bfffcc 	andi	r2,r2,65535
8013d5d4:	1080040c 	andi	r2,r2,16
8013d5d8:	1000071e 	bne	r2,zero,8013d5f8 <Write_Sector_Data+0xa4>
        {
            result = true;
8013d5dc:	00800044 	movi	r2,1
8013d5e0:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8013d5e4:	d020bd15 	stw	zero,-32012(gp)
            current_sector_index = sector_index+partition_offset;
8013d5e8:	e0fffe17 	ldw	r3,-8(fp)
8013d5ec:	e0bfff17 	ldw	r2,-4(fp)
8013d5f0:	1885883a 	add	r2,r3,r2
8013d5f4:	d0a0be15 	stw	r2,-32008(gp)
        }
    }
    return result;
8013d5f8:	e0bffc17 	ldw	r2,-16(fp)
}
8013d5fc:	e037883a 	mov	sp,fp
8013d600:	dfc00117 	ldw	ra,4(sp)
8013d604:	df000017 	ldw	fp,0(sp)
8013d608:	dec00204 	addi	sp,sp,8
8013d60c:	f800283a 	ret

8013d610 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8013d610:	defffd04 	addi	sp,sp,-12
8013d614:	de00012e 	bgeu	sp,et,8013d61c <Save_Modified_Sector+0xc>
8013d618:	003b68fa 	trap	3
8013d61c:	dfc00215 	stw	ra,8(sp)
8013d620:	df000115 	stw	fp,4(sp)
8013d624:	df000104 	addi	fp,sp,4
    bool result = true;
8013d628:	00800044 	movi	r2,1
8013d62c:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8013d630:	d0a0bd17 	ldw	r2,-32012(gp)
8013d634:	10000526 	beq	r2,zero,8013d64c <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
8013d638:	d0a0be17 	ldw	r2,-32008(gp)
8013d63c:	000b883a 	mov	r5,zero
8013d640:	1009883a 	mov	r4,r2
8013d644:	013d5540 	call	8013d554 <Write_Sector_Data>
8013d648:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8013d64c:	e0bfff17 	ldw	r2,-4(fp)
}
8013d650:	e037883a 	mov	sp,fp
8013d654:	dfc00117 	ldw	ra,4(sp)
8013d658:	df000017 	ldw	fp,0(sp)
8013d65c:	dec00204 	addi	sp,sp,8
8013d660:	f800283a 	ret

8013d664 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8013d664:	defffa04 	addi	sp,sp,-24
8013d668:	de00012e 	bgeu	sp,et,8013d670 <Read_Sector_Data+0xc>
8013d66c:	003b68fa 	trap	3
8013d670:	dfc00515 	stw	ra,20(sp)
8013d674:	df000415 	stw	fp,16(sp)
8013d678:	df000404 	addi	fp,sp,16
8013d67c:	e13ffe15 	stw	r4,-8(fp)
8013d680:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8013d684:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
8013d688:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
8013d68c:	10002726 	beq	r2,zero,8013d72c <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
8013d690:	00803fc4 	movi	r2,255
8013d694:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
8013d698:	d0a0bd17 	ldw	r2,-32012(gp)
8013d69c:	10000726 	beq	r2,zero,8013d6bc <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8013d6a0:	d0a0be17 	ldw	r2,-32008(gp)
8013d6a4:	000b883a 	mov	r5,zero
8013d6a8:	1009883a 	mov	r4,r2
8013d6ac:	013d5540 	call	8013d554 <Write_Sector_Data>
8013d6b0:	1000021e 	bne	r2,zero,8013d6bc <Read_Sector_Data+0x58>
            {
                return false;
8013d6b4:	0005883a 	mov	r2,zero
8013d6b8:	00001d06 	br	8013d730 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8013d6bc:	d0a0b817 	ldw	r2,-32032(gp)
8013d6c0:	e13ffe17 	ldw	r4,-8(fp)
8013d6c4:	e0ffff17 	ldw	r3,-4(fp)
8013d6c8:	20c7883a 	add	r3,r4,r3
8013d6cc:	1806927a 	slli	r3,r3,9
8013d6d0:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8013d6d4:	d0a0b717 	ldw	r2,-32036(gp)
8013d6d8:	00c00444 	movi	r3,17
8013d6dc:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8013d6e0:	d0a0b417 	ldw	r2,-32048(gp)
8013d6e4:	1080002b 	ldhuio	r2,0(r2)
8013d6e8:	10bfffcc 	andi	r2,r2,65535
8013d6ec:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8013d6f0:	e0bffd0b 	ldhu	r2,-12(fp)
8013d6f4:	10bfffcc 	andi	r2,r2,65535
8013d6f8:	1080010c 	andi	r2,r2,4
8013d6fc:	103ff81e 	bne	r2,zero,8013d6e0 <__reset+0xfa11d6e0>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8013d700:	e0bffd0b 	ldhu	r2,-12(fp)
8013d704:	10bfffcc 	andi	r2,r2,65535
8013d708:	1080040c 	andi	r2,r2,16
8013d70c:	1000071e 	bne	r2,zero,8013d72c <Read_Sector_Data+0xc8>
		{
			result = true;
8013d710:	00800044 	movi	r2,1
8013d714:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8013d718:	d020bd15 	stw	zero,-32012(gp)
            current_sector_index = sector_index+partition_offset;
8013d71c:	e0fffe17 	ldw	r3,-8(fp)
8013d720:	e0bfff17 	ldw	r2,-4(fp)
8013d724:	1885883a 	add	r2,r3,r2
8013d728:	d0a0be15 	stw	r2,-32008(gp)
		}
	}
	return result;
8013d72c:	e0bffc17 	ldw	r2,-16(fp)
}
8013d730:	e037883a 	mov	sp,fp
8013d734:	dfc00117 	ldw	ra,4(sp)
8013d738:	df000017 	ldw	fp,0(sp)
8013d73c:	dec00204 	addi	sp,sp,8
8013d740:	f800283a 	ret

8013d744 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8013d744:	defffb04 	addi	sp,sp,-20
8013d748:	de00012e 	bgeu	sp,et,8013d750 <get_cluster_flag+0xc>
8013d74c:	003b68fa 	trap	3
8013d750:	dfc00415 	stw	ra,16(sp)
8013d754:	df000315 	stw	fp,12(sp)
8013d758:	df000304 	addi	fp,sp,12
8013d75c:	e13ffe15 	stw	r4,-8(fp)
8013d760:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8013d764:	e0bffe17 	ldw	r2,-8(fp)
8013d768:	1004d23a 	srli	r2,r2,8
8013d76c:	d0e0ba17 	ldw	r3,-32024(gp)
8013d770:	10c5883a 	add	r2,r2,r3
8013d774:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8013d778:	00a005b4 	movhi	r2,32790
8013d77c:	10927b04 	addi	r2,r2,18924
8013d780:	10801117 	ldw	r2,68(r2)
8013d784:	e0fffd17 	ldw	r3,-12(fp)
8013d788:	1885883a 	add	r2,r3,r2
8013d78c:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
8013d790:	d0a0be17 	ldw	r2,-32008(gp)
8013d794:	e0fffd17 	ldw	r3,-12(fp)
8013d798:	18800726 	beq	r3,r2,8013d7b8 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8013d79c:	e0bffd17 	ldw	r2,-12(fp)
8013d7a0:	000b883a 	mov	r5,zero
8013d7a4:	1009883a 	mov	r4,r2
8013d7a8:	013d6640 	call	8013d664 <Read_Sector_Data>
8013d7ac:	1000021e 	bne	r2,zero,8013d7b8 <get_cluster_flag+0x74>
        {
            return false;
8013d7b0:	0005883a 	mov	r2,zero
8013d7b4:	00000d06 	br	8013d7ec <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
8013d7b8:	e0bffe17 	ldw	r2,-8(fp)
8013d7bc:	10803fcc 	andi	r2,r2,255
8013d7c0:	1085883a 	add	r2,r2,r2
8013d7c4:	1007883a 	mov	r3,r2
8013d7c8:	d0a0bc17 	ldw	r2,-32016(gp)
8013d7cc:	10800a17 	ldw	r2,40(r2)
8013d7d0:	1885883a 	add	r2,r3,r2
8013d7d4:	1080002b 	ldhuio	r2,0(r2)
8013d7d8:	10bfffcc 	andi	r2,r2,65535
8013d7dc:	1007883a 	mov	r3,r2
8013d7e0:	e0bfff17 	ldw	r2,-4(fp)
8013d7e4:	10c0000d 	sth	r3,0(r2)
    return true;
8013d7e8:	00800044 	movi	r2,1
}
8013d7ec:	e037883a 	mov	sp,fp
8013d7f0:	dfc00117 	ldw	ra,4(sp)
8013d7f4:	df000017 	ldw	fp,0(sp)
8013d7f8:	dec00204 	addi	sp,sp,8
8013d7fc:	f800283a 	ret

8013d800 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8013d800:	defffa04 	addi	sp,sp,-24
8013d804:	de00012e 	bgeu	sp,et,8013d80c <mark_cluster+0xc>
8013d808:	003b68fa 	trap	3
8013d80c:	dfc00515 	stw	ra,20(sp)
8013d810:	df000415 	stw	fp,16(sp)
8013d814:	df000404 	addi	fp,sp,16
8013d818:	e13ffd15 	stw	r4,-12(fp)
8013d81c:	2805883a 	mov	r2,r5
8013d820:	e1bfff15 	stw	r6,-4(fp)
8013d824:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
8013d828:	e0bffd17 	ldw	r2,-12(fp)
8013d82c:	1004d23a 	srli	r2,r2,8
8013d830:	d0e0ba17 	ldw	r3,-32024(gp)
8013d834:	10c5883a 	add	r2,r2,r3
8013d838:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8013d83c:	e0bfff17 	ldw	r2,-4(fp)
8013d840:	10000726 	beq	r2,zero,8013d860 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8013d844:	00a005b4 	movhi	r2,32790
8013d848:	10927b04 	addi	r2,r2,18924
8013d84c:	10801117 	ldw	r2,68(r2)
8013d850:	e0fffc17 	ldw	r3,-16(fp)
8013d854:	1885883a 	add	r2,r3,r2
8013d858:	e0bffc15 	stw	r2,-16(fp)
8013d85c:	00000606 	br	8013d878 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8013d860:	00a005b4 	movhi	r2,32790
8013d864:	10927b04 	addi	r2,r2,18924
8013d868:	10801217 	ldw	r2,72(r2)
8013d86c:	e0fffc17 	ldw	r3,-16(fp)
8013d870:	1885883a 	add	r2,r3,r2
8013d874:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
8013d878:	d0a0be17 	ldw	r2,-32008(gp)
8013d87c:	e0fffc17 	ldw	r3,-16(fp)
8013d880:	18800726 	beq	r3,r2,8013d8a0 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8013d884:	e0bffc17 	ldw	r2,-16(fp)
8013d888:	000b883a 	mov	r5,zero
8013d88c:	1009883a 	mov	r4,r2
8013d890:	013d6640 	call	8013d664 <Read_Sector_Data>
8013d894:	1000021e 	bne	r2,zero,8013d8a0 <mark_cluster+0xa0>
        {
            return false;
8013d898:	0005883a 	mov	r2,zero
8013d89c:	00000d06 	br	8013d8d4 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8013d8a0:	e0bffd17 	ldw	r2,-12(fp)
8013d8a4:	10803fcc 	andi	r2,r2,255
8013d8a8:	1085883a 	add	r2,r2,r2
8013d8ac:	1007883a 	mov	r3,r2
8013d8b0:	d0a0bc17 	ldw	r2,-32016(gp)
8013d8b4:	10800a17 	ldw	r2,40(r2)
8013d8b8:	1885883a 	add	r2,r3,r2
8013d8bc:	1007883a 	mov	r3,r2
8013d8c0:	e0bffe0f 	ldh	r2,-8(fp)
8013d8c4:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
8013d8c8:	00800044 	movi	r2,1
8013d8cc:	d0a0bd15 	stw	r2,-32012(gp)
    return true;
8013d8d0:	00800044 	movi	r2,1
}
8013d8d4:	e037883a 	mov	sp,fp
8013d8d8:	dfc00117 	ldw	ra,4(sp)
8013d8dc:	df000017 	ldw	fp,0(sp)
8013d8e0:	dec00204 	addi	sp,sp,8
8013d8e4:	f800283a 	ret

8013d8e8 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
8013d8e8:	defff704 	addi	sp,sp,-36
8013d8ec:	de00012e 	bgeu	sp,et,8013d8f4 <Check_for_Master_Boot_Record+0xc>
8013d8f0:	003b68fa 	trap	3
8013d8f4:	dfc00815 	stw	ra,32(sp)
8013d8f8:	df000715 	stw	fp,28(sp)
8013d8fc:	df000704 	addi	fp,sp,28
	bool result = false;
8013d900:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8013d904:	000b883a 	mov	r5,zero
8013d908:	0009883a 	mov	r4,zero
8013d90c:	013d6640 	call	8013d664 <Read_Sector_Data>
8013d910:	10005a26 	beq	r2,zero,8013da7c <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8013d914:	d0a0bc17 	ldw	r2,-32016(gp)
8013d918:	10800a17 	ldw	r2,40(r2)
8013d91c:	10807f84 	addi	r2,r2,510
8013d920:	1080002b 	ldhuio	r2,0(r2)
8013d924:	10bfffcc 	andi	r2,r2,65535
8013d928:	10bfffcc 	andi	r2,r2,65535
8013d92c:	10a0001c 	xori	r2,r2,32768
8013d930:	10a00004 	addi	r2,r2,-32768
8013d934:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
8013d938:	e0bffb17 	ldw	r2,-20(fp)
8013d93c:	10ffffcc 	andi	r3,r2,65535
8013d940:	00aa9554 	movui	r2,43605
8013d944:	18804d1e 	bne	r3,r2,8013da7c <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8013d948:	e03ffa15 	stw	zero,-24(fp)
8013d94c:	00004806 	br	8013da70 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8013d950:	e0bffa17 	ldw	r2,-24(fp)
8013d954:	1004913a 	slli	r2,r2,4
8013d958:	10806f84 	addi	r2,r2,446
8013d95c:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8013d960:	d0a0bc17 	ldw	r2,-32016(gp)
8013d964:	10c00a17 	ldw	r3,40(r2)
8013d968:	e0bffc17 	ldw	r2,-16(fp)
8013d96c:	1885883a 	add	r2,r3,r2
8013d970:	10800104 	addi	r2,r2,4
8013d974:	10800023 	ldbuio	r2,0(r2)
8013d978:	10803fcc 	andi	r2,r2,255
8013d97c:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8013d980:	e0bffd07 	ldb	r2,-12(fp)
8013d984:	10800060 	cmpeqi	r2,r2,1
8013d988:	1000091e 	bne	r2,zero,8013d9b0 <Check_for_Master_Boot_Record+0xc8>
8013d98c:	e0bffd07 	ldb	r2,-12(fp)
8013d990:	10800120 	cmpeqi	r2,r2,4
8013d994:	1000061e 	bne	r2,zero,8013d9b0 <Check_for_Master_Boot_Record+0xc8>
8013d998:	e0bffd07 	ldb	r2,-12(fp)
8013d99c:	108001a0 	cmpeqi	r2,r2,6
8013d9a0:	1000031e 	bne	r2,zero,8013d9b0 <Check_for_Master_Boot_Record+0xc8>
8013d9a4:	e0bffd07 	ldb	r2,-12(fp)
8013d9a8:	10800398 	cmpnei	r2,r2,14
8013d9ac:	10002d1e 	bne	r2,zero,8013da64 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8013d9b0:	d0a0bc17 	ldw	r2,-32016(gp)
8013d9b4:	10c00a17 	ldw	r3,40(r2)
8013d9b8:	e0bffc17 	ldw	r2,-16(fp)
8013d9bc:	1885883a 	add	r2,r3,r2
8013d9c0:	10800284 	addi	r2,r2,10
8013d9c4:	1080002b 	ldhuio	r2,0(r2)
8013d9c8:	10bfffcc 	andi	r2,r2,65535
8013d9cc:	1006943a 	slli	r3,r2,16
8013d9d0:	d0a0bc17 	ldw	r2,-32016(gp)
8013d9d4:	11000a17 	ldw	r4,40(r2)
8013d9d8:	e0bffc17 	ldw	r2,-16(fp)
8013d9dc:	2085883a 	add	r2,r4,r2
8013d9e0:	10800204 	addi	r2,r2,8
8013d9e4:	1080002b 	ldhuio	r2,0(r2)
8013d9e8:	10bfffcc 	andi	r2,r2,65535
8013d9ec:	10bfffcc 	andi	r2,r2,65535
8013d9f0:	1884b03a 	or	r2,r3,r2
8013d9f4:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
8013d9f8:	d0a0bc17 	ldw	r2,-32016(gp)
8013d9fc:	10c00a17 	ldw	r3,40(r2)
8013da00:	e0bffc17 	ldw	r2,-16(fp)
8013da04:	1885883a 	add	r2,r3,r2
8013da08:	10800384 	addi	r2,r2,14
8013da0c:	1080002b 	ldhuio	r2,0(r2)
8013da10:	10bfffcc 	andi	r2,r2,65535
8013da14:	1006943a 	slli	r3,r2,16
8013da18:	d0a0bc17 	ldw	r2,-32016(gp)
8013da1c:	11000a17 	ldw	r4,40(r2)
8013da20:	e0bffc17 	ldw	r2,-16(fp)
8013da24:	2085883a 	add	r2,r4,r2
8013da28:	10800304 	addi	r2,r2,12
8013da2c:	1080002b 	ldhuio	r2,0(r2)
8013da30:	10bfffcc 	andi	r2,r2,65535
8013da34:	10bfffcc 	andi	r2,r2,65535
8013da38:	1884b03a 	or	r2,r3,r2
8013da3c:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8013da40:	e0bfff17 	ldw	r2,-4(fp)
8013da44:	0080070e 	bge	zero,r2,8013da64 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8013da48:	00800044 	movi	r2,1
8013da4c:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8013da50:	e0bfff17 	ldw	r2,-4(fp)
8013da54:	d0a0bb15 	stw	r2,-32020(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8013da58:	e0bffe17 	ldw	r2,-8(fp)
8013da5c:	d0a0ba15 	stw	r2,-32024(gp)
						break;
8013da60:	00000606 	br	8013da7c <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8013da64:	e0bffa17 	ldw	r2,-24(fp)
8013da68:	10800044 	addi	r2,r2,1
8013da6c:	e0bffa15 	stw	r2,-24(fp)
8013da70:	e0bffa17 	ldw	r2,-24(fp)
8013da74:	10800110 	cmplti	r2,r2,4
8013da78:	103fb51e 	bne	r2,zero,8013d950 <__reset+0xfa11d950>
				}
			}
		}
	}

	return result;
8013da7c:	e0bff917 	ldw	r2,-28(fp)
}
8013da80:	e037883a 	mov	sp,fp
8013da84:	dfc00117 	ldw	ra,4(sp)
8013da88:	df000017 	ldw	fp,0(sp)
8013da8c:	dec00204 	addi	sp,sp,8
8013da90:	f800283a 	ret

8013da94 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8013da94:	defff804 	addi	sp,sp,-32
8013da98:	de00012e 	bgeu	sp,et,8013daa0 <Read_File_Record_At_Offset+0xc>
8013da9c:	003b68fa 	trap	3
8013daa0:	dfc00715 	stw	ra,28(sp)
8013daa4:	df000615 	stw	fp,24(sp)
8013daa8:	df000604 	addi	fp,sp,24
8013daac:	e13ffc15 	stw	r4,-16(fp)
8013dab0:	e17ffd15 	stw	r5,-12(fp)
8013dab4:	e1bffe15 	stw	r6,-8(fp)
8013dab8:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8013dabc:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8013dac0:	e0bffc17 	ldw	r2,-16(fp)
8013dac4:	108007cc 	andi	r2,r2,31
8013dac8:	10008d1e 	bne	r2,zero,8013dd00 <Read_File_Record_At_Offset+0x26c>
8013dacc:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
8013dad0:	10008b26 	beq	r2,zero,8013dd00 <Read_File_Record_At_Offset+0x26c>
8013dad4:	d0a0b317 	ldw	r2,-32052(gp)
8013dad8:	10008926 	beq	r2,zero,8013dd00 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8013dadc:	e03ffb15 	stw	zero,-20(fp)
8013dae0:	00001106 	br	8013db28 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8013dae4:	e0fffc17 	ldw	r3,-16(fp)
8013dae8:	e0bffb17 	ldw	r2,-20(fp)
8013daec:	1885883a 	add	r2,r3,r2
8013daf0:	1007883a 	mov	r3,r2
8013daf4:	d0a0bc17 	ldw	r2,-32016(gp)
8013daf8:	10800a17 	ldw	r2,40(r2)
8013dafc:	1885883a 	add	r2,r3,r2
8013db00:	10800023 	ldbuio	r2,0(r2)
8013db04:	10803fcc 	andi	r2,r2,255
8013db08:	1009883a 	mov	r4,r2
8013db0c:	e0fffd17 	ldw	r3,-12(fp)
8013db10:	e0bffb17 	ldw	r2,-20(fp)
8013db14:	1885883a 	add	r2,r3,r2
8013db18:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8013db1c:	e0bffb17 	ldw	r2,-20(fp)
8013db20:	10800044 	addi	r2,r2,1
8013db24:	e0bffb15 	stw	r2,-20(fp)
8013db28:	e0bffb17 	ldw	r2,-20(fp)
8013db2c:	10800210 	cmplti	r2,r2,8
8013db30:	103fec1e 	bne	r2,zero,8013dae4 <__reset+0xfa11dae4>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8013db34:	e03ffb15 	stw	zero,-20(fp)
8013db38:	00001306 	br	8013db88 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8013db3c:	e0fffc17 	ldw	r3,-16(fp)
8013db40:	e0bffb17 	ldw	r2,-20(fp)
8013db44:	1885883a 	add	r2,r3,r2
8013db48:	1007883a 	mov	r3,r2
8013db4c:	d0a0bc17 	ldw	r2,-32016(gp)
8013db50:	10800a17 	ldw	r2,40(r2)
8013db54:	1885883a 	add	r2,r3,r2
8013db58:	10800204 	addi	r2,r2,8
8013db5c:	10800023 	ldbuio	r2,0(r2)
8013db60:	10803fcc 	andi	r2,r2,255
8013db64:	1009883a 	mov	r4,r2
8013db68:	e0fffd17 	ldw	r3,-12(fp)
8013db6c:	e0bffb17 	ldw	r2,-20(fp)
8013db70:	1885883a 	add	r2,r3,r2
8013db74:	10800204 	addi	r2,r2,8
8013db78:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8013db7c:	e0bffb17 	ldw	r2,-20(fp)
8013db80:	10800044 	addi	r2,r2,1
8013db84:	e0bffb15 	stw	r2,-20(fp)
8013db88:	e0bffb17 	ldw	r2,-20(fp)
8013db8c:	108000d0 	cmplti	r2,r2,3
8013db90:	103fea1e 	bne	r2,zero,8013db3c <__reset+0xfa11db3c>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8013db94:	d0a0bc17 	ldw	r2,-32016(gp)
8013db98:	10c00a17 	ldw	r3,40(r2)
8013db9c:	e0bffc17 	ldw	r2,-16(fp)
8013dba0:	1885883a 	add	r2,r3,r2
8013dba4:	108002c4 	addi	r2,r2,11
8013dba8:	10800023 	ldbuio	r2,0(r2)
8013dbac:	10803fcc 	andi	r2,r2,255
8013dbb0:	1007883a 	mov	r3,r2
8013dbb4:	e0bffd17 	ldw	r2,-12(fp)
8013dbb8:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8013dbbc:	d0a0bc17 	ldw	r2,-32016(gp)
8013dbc0:	10c00a17 	ldw	r3,40(r2)
8013dbc4:	e0bffc17 	ldw	r2,-16(fp)
8013dbc8:	1885883a 	add	r2,r3,r2
8013dbcc:	10800384 	addi	r2,r2,14
8013dbd0:	1080002b 	ldhuio	r2,0(r2)
8013dbd4:	10bfffcc 	andi	r2,r2,65535
8013dbd8:	1007883a 	mov	r3,r2
8013dbdc:	e0bffd17 	ldw	r2,-12(fp)
8013dbe0:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8013dbe4:	d0a0bc17 	ldw	r2,-32016(gp)
8013dbe8:	10c00a17 	ldw	r3,40(r2)
8013dbec:	e0bffc17 	ldw	r2,-16(fp)
8013dbf0:	1885883a 	add	r2,r3,r2
8013dbf4:	10800404 	addi	r2,r2,16
8013dbf8:	1080002b 	ldhuio	r2,0(r2)
8013dbfc:	10bfffcc 	andi	r2,r2,65535
8013dc00:	1007883a 	mov	r3,r2
8013dc04:	e0bffd17 	ldw	r2,-12(fp)
8013dc08:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8013dc0c:	d0a0bc17 	ldw	r2,-32016(gp)
8013dc10:	10c00a17 	ldw	r3,40(r2)
8013dc14:	e0bffc17 	ldw	r2,-16(fp)
8013dc18:	1885883a 	add	r2,r3,r2
8013dc1c:	10800484 	addi	r2,r2,18
8013dc20:	1080002b 	ldhuio	r2,0(r2)
8013dc24:	10bfffcc 	andi	r2,r2,65535
8013dc28:	1007883a 	mov	r3,r2
8013dc2c:	e0bffd17 	ldw	r2,-12(fp)
8013dc30:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8013dc34:	d0a0bc17 	ldw	r2,-32016(gp)
8013dc38:	10c00a17 	ldw	r3,40(r2)
8013dc3c:	e0bffc17 	ldw	r2,-16(fp)
8013dc40:	1885883a 	add	r2,r3,r2
8013dc44:	10800584 	addi	r2,r2,22
8013dc48:	1080002b 	ldhuio	r2,0(r2)
8013dc4c:	10bfffcc 	andi	r2,r2,65535
8013dc50:	1007883a 	mov	r3,r2
8013dc54:	e0bffd17 	ldw	r2,-12(fp)
8013dc58:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8013dc5c:	d0a0bc17 	ldw	r2,-32016(gp)
8013dc60:	10c00a17 	ldw	r3,40(r2)
8013dc64:	e0bffc17 	ldw	r2,-16(fp)
8013dc68:	1885883a 	add	r2,r3,r2
8013dc6c:	10800604 	addi	r2,r2,24
8013dc70:	1080002b 	ldhuio	r2,0(r2)
8013dc74:	10bfffcc 	andi	r2,r2,65535
8013dc78:	1007883a 	mov	r3,r2
8013dc7c:	e0bffd17 	ldw	r2,-12(fp)
8013dc80:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
8013dc84:	d0a0bc17 	ldw	r2,-32016(gp)
8013dc88:	10c00a17 	ldw	r3,40(r2)
8013dc8c:	e0bffc17 	ldw	r2,-16(fp)
8013dc90:	1885883a 	add	r2,r3,r2
8013dc94:	10800684 	addi	r2,r2,26
8013dc98:	1080002b 	ldhuio	r2,0(r2)
8013dc9c:	10bfffcc 	andi	r2,r2,65535
8013dca0:	1007883a 	mov	r3,r2
8013dca4:	e0bffd17 	ldw	r2,-12(fp)
8013dca8:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8013dcac:	d0a0bc17 	ldw	r2,-32016(gp)
8013dcb0:	10c00a17 	ldw	r3,40(r2)
8013dcb4:	e0bffc17 	ldw	r2,-16(fp)
8013dcb8:	1885883a 	add	r2,r3,r2
8013dcbc:	10800704 	addi	r2,r2,28
8013dcc0:	10800037 	ldwio	r2,0(r2)
8013dcc4:	1007883a 	mov	r3,r2
8013dcc8:	e0bffd17 	ldw	r2,-12(fp)
8013dccc:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8013dcd0:	e0bffd17 	ldw	r2,-12(fp)
8013dcd4:	e0fffe17 	ldw	r3,-8(fp)
8013dcd8:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8013dcdc:	e0bffd17 	ldw	r2,-12(fp)
8013dce0:	e0ffff17 	ldw	r3,-4(fp)
8013dce4:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
8013dce8:	e0bffc17 	ldw	r2,-16(fp)
8013dcec:	1007883a 	mov	r3,r2
8013dcf0:	e0bffd17 	ldw	r2,-12(fp)
8013dcf4:	10c00c0d 	sth	r3,48(r2)
		result = true;
8013dcf8:	00800044 	movi	r2,1
8013dcfc:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8013dd00:	e0bffa17 	ldw	r2,-24(fp)
}
8013dd04:	e037883a 	mov	sp,fp
8013dd08:	dfc00117 	ldw	ra,4(sp)
8013dd0c:	df000017 	ldw	fp,0(sp)
8013dd10:	dec00204 	addi	sp,sp,8
8013dd14:	f800283a 	ret

8013dd18 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
8013dd18:	defff904 	addi	sp,sp,-28
8013dd1c:	de00012e 	bgeu	sp,et,8013dd24 <Write_File_Record_At_Offset+0xc>
8013dd20:	003b68fa 	trap	3
8013dd24:	dfc00615 	stw	ra,24(sp)
8013dd28:	df000515 	stw	fp,20(sp)
8013dd2c:	df000504 	addi	fp,sp,20
8013dd30:	e13ffe15 	stw	r4,-8(fp)
8013dd34:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8013dd38:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8013dd3c:	e0bffe17 	ldw	r2,-8(fp)
8013dd40:	108007cc 	andi	r2,r2,31
8013dd44:	1000931e 	bne	r2,zero,8013df94 <Write_File_Record_At_Offset+0x27c>
8013dd48:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
8013dd4c:	10009126 	beq	r2,zero,8013df94 <Write_File_Record_At_Offset+0x27c>
8013dd50:	d0a0b317 	ldw	r2,-32052(gp)
8013dd54:	10008f26 	beq	r2,zero,8013df94 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8013dd58:	e03ffc15 	stw	zero,-16(fp)
8013dd5c:	00001f06 	br	8013dddc <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8013dd60:	e0bffc17 	ldw	r2,-16(fp)
8013dd64:	10800044 	addi	r2,r2,1
8013dd68:	e0ffff17 	ldw	r3,-4(fp)
8013dd6c:	1885883a 	add	r2,r3,r2
8013dd70:	10800003 	ldbu	r2,0(r2)
8013dd74:	10803fcc 	andi	r2,r2,255
8013dd78:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8013dd7c:	e0bffd0f 	ldh	r2,-12(fp)
8013dd80:	1004923a 	slli	r2,r2,8
8013dd84:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8013dd88:	e0ffff17 	ldw	r3,-4(fp)
8013dd8c:	e0bffc17 	ldw	r2,-16(fp)
8013dd90:	1885883a 	add	r2,r3,r2
8013dd94:	10800003 	ldbu	r2,0(r2)
8013dd98:	10c03fcc 	andi	r3,r2,255
8013dd9c:	e0bffd0b 	ldhu	r2,-12(fp)
8013dda0:	1884b03a 	or	r2,r3,r2
8013dda4:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8013dda8:	e0fffe17 	ldw	r3,-8(fp)
8013ddac:	e0bffc17 	ldw	r2,-16(fp)
8013ddb0:	1885883a 	add	r2,r3,r2
8013ddb4:	1007883a 	mov	r3,r2
8013ddb8:	d0a0bc17 	ldw	r2,-32016(gp)
8013ddbc:	10800a17 	ldw	r2,40(r2)
8013ddc0:	1885883a 	add	r2,r3,r2
8013ddc4:	1007883a 	mov	r3,r2
8013ddc8:	e0bffd0f 	ldh	r2,-12(fp)
8013ddcc:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8013ddd0:	e0bffc17 	ldw	r2,-16(fp)
8013ddd4:	10800084 	addi	r2,r2,2
8013ddd8:	e0bffc15 	stw	r2,-16(fp)
8013dddc:	e0bffc17 	ldw	r2,-16(fp)
8013dde0:	10800210 	cmplti	r2,r2,8
8013dde4:	103fde1e 	bne	r2,zero,8013dd60 <__reset+0xfa11dd60>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8013dde8:	e03ffc15 	stw	zero,-16(fp)
8013ddec:	00001306 	br	8013de3c <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8013ddf0:	e0fffe17 	ldw	r3,-8(fp)
8013ddf4:	e0bffc17 	ldw	r2,-16(fp)
8013ddf8:	1885883a 	add	r2,r3,r2
8013ddfc:	1007883a 	mov	r3,r2
8013de00:	d0a0bc17 	ldw	r2,-32016(gp)
8013de04:	10800a17 	ldw	r2,40(r2)
8013de08:	1885883a 	add	r2,r3,r2
8013de0c:	10800204 	addi	r2,r2,8
8013de10:	1009883a 	mov	r4,r2
8013de14:	e0ffff17 	ldw	r3,-4(fp)
8013de18:	e0bffc17 	ldw	r2,-16(fp)
8013de1c:	1885883a 	add	r2,r3,r2
8013de20:	10800204 	addi	r2,r2,8
8013de24:	10800003 	ldbu	r2,0(r2)
8013de28:	10803fcc 	andi	r2,r2,255
8013de2c:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8013de30:	e0bffc17 	ldw	r2,-16(fp)
8013de34:	10800044 	addi	r2,r2,1
8013de38:	e0bffc15 	stw	r2,-16(fp)
8013de3c:	e0bffc17 	ldw	r2,-16(fp)
8013de40:	108000d0 	cmplti	r2,r2,3
8013de44:	103fea1e 	bne	r2,zero,8013ddf0 <__reset+0xfa11ddf0>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8013de48:	d0a0bc17 	ldw	r2,-32016(gp)
8013de4c:	10c00a17 	ldw	r3,40(r2)
8013de50:	e0bffe17 	ldw	r2,-8(fp)
8013de54:	1885883a 	add	r2,r3,r2
8013de58:	108002c4 	addi	r2,r2,11
8013de5c:	1007883a 	mov	r3,r2
8013de60:	e0bfff17 	ldw	r2,-4(fp)
8013de64:	108002c3 	ldbu	r2,11(r2)
8013de68:	10803fcc 	andi	r2,r2,255
8013de6c:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
8013de70:	d0a0bc17 	ldw	r2,-32016(gp)
8013de74:	10c00a17 	ldw	r3,40(r2)
8013de78:	e0bffe17 	ldw	r2,-8(fp)
8013de7c:	1885883a 	add	r2,r3,r2
8013de80:	10800384 	addi	r2,r2,14
8013de84:	1007883a 	mov	r3,r2
8013de88:	e0bfff17 	ldw	r2,-4(fp)
8013de8c:	1080030b 	ldhu	r2,12(r2)
8013de90:	10bfffcc 	andi	r2,r2,65535
8013de94:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8013de98:	d0a0bc17 	ldw	r2,-32016(gp)
8013de9c:	10c00a17 	ldw	r3,40(r2)
8013dea0:	e0bffe17 	ldw	r2,-8(fp)
8013dea4:	1885883a 	add	r2,r3,r2
8013dea8:	10800404 	addi	r2,r2,16
8013deac:	1007883a 	mov	r3,r2
8013deb0:	e0bfff17 	ldw	r2,-4(fp)
8013deb4:	1080038b 	ldhu	r2,14(r2)
8013deb8:	10bfffcc 	andi	r2,r2,65535
8013debc:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
8013dec0:	d0a0bc17 	ldw	r2,-32016(gp)
8013dec4:	10c00a17 	ldw	r3,40(r2)
8013dec8:	e0bffe17 	ldw	r2,-8(fp)
8013decc:	1885883a 	add	r2,r3,r2
8013ded0:	10800484 	addi	r2,r2,18
8013ded4:	1007883a 	mov	r3,r2
8013ded8:	e0bfff17 	ldw	r2,-4(fp)
8013dedc:	1080040b 	ldhu	r2,16(r2)
8013dee0:	10bfffcc 	andi	r2,r2,65535
8013dee4:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
8013dee8:	d0a0bc17 	ldw	r2,-32016(gp)
8013deec:	10c00a17 	ldw	r3,40(r2)
8013def0:	e0bffe17 	ldw	r2,-8(fp)
8013def4:	1885883a 	add	r2,r3,r2
8013def8:	10800584 	addi	r2,r2,22
8013defc:	1007883a 	mov	r3,r2
8013df00:	e0bfff17 	ldw	r2,-4(fp)
8013df04:	1080048b 	ldhu	r2,18(r2)
8013df08:	10bfffcc 	andi	r2,r2,65535
8013df0c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
8013df10:	d0a0bc17 	ldw	r2,-32016(gp)
8013df14:	10c00a17 	ldw	r3,40(r2)
8013df18:	e0bffe17 	ldw	r2,-8(fp)
8013df1c:	1885883a 	add	r2,r3,r2
8013df20:	10800604 	addi	r2,r2,24
8013df24:	1007883a 	mov	r3,r2
8013df28:	e0bfff17 	ldw	r2,-4(fp)
8013df2c:	1080050b 	ldhu	r2,20(r2)
8013df30:	10bfffcc 	andi	r2,r2,65535
8013df34:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
8013df38:	d0a0bc17 	ldw	r2,-32016(gp)
8013df3c:	10c00a17 	ldw	r3,40(r2)
8013df40:	e0bffe17 	ldw	r2,-8(fp)
8013df44:	1885883a 	add	r2,r3,r2
8013df48:	10800684 	addi	r2,r2,26
8013df4c:	1007883a 	mov	r3,r2
8013df50:	e0bfff17 	ldw	r2,-4(fp)
8013df54:	1080058b 	ldhu	r2,22(r2)
8013df58:	10bfffcc 	andi	r2,r2,65535
8013df5c:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
8013df60:	d0a0bc17 	ldw	r2,-32016(gp)
8013df64:	10c00a17 	ldw	r3,40(r2)
8013df68:	e0bffe17 	ldw	r2,-8(fp)
8013df6c:	1885883a 	add	r2,r3,r2
8013df70:	10800704 	addi	r2,r2,28
8013df74:	1007883a 	mov	r3,r2
8013df78:	e0bfff17 	ldw	r2,-4(fp)
8013df7c:	10800617 	ldw	r2,24(r2)
8013df80:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
8013df84:	00800044 	movi	r2,1
8013df88:	d0a0bd15 	stw	r2,-32012(gp)
        result = true;
8013df8c:	00800044 	movi	r2,1
8013df90:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
8013df94:	e0bffb17 	ldw	r2,-20(fp)
}
8013df98:	e037883a 	mov	sp,fp
8013df9c:	dfc00117 	ldw	ra,4(sp)
8013dfa0:	df000017 	ldw	fp,0(sp)
8013dfa4:	dec00204 	addi	sp,sp,8
8013dfa8:	f800283a 	ret

8013dfac <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8013dfac:	defff904 	addi	sp,sp,-28
8013dfb0:	de00012e 	bgeu	sp,et,8013dfb8 <Check_for_DOS_FAT+0xc>
8013dfb4:	003b68fa 	trap	3
8013dfb8:	dfc00615 	stw	ra,24(sp)
8013dfbc:	df000515 	stw	fp,20(sp)
8013dfc0:	df000504 	addi	fp,sp,20
8013dfc4:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8013dfc8:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8013dfcc:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
8013dfd0:	e17fff17 	ldw	r5,-4(fp)
8013dfd4:	0009883a 	mov	r4,zero
8013dfd8:	013d6640 	call	8013d664 <Read_Sector_Data>
8013dfdc:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
8013dfe0:	d0a0bc17 	ldw	r2,-32016(gp)
8013dfe4:	10800a17 	ldw	r2,40(r2)
8013dfe8:	10807f84 	addi	r2,r2,510
8013dfec:	1080002b 	ldhuio	r2,0(r2)
8013dff0:	10bfffcc 	andi	r2,r2,65535
8013dff4:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
8013dff8:	e0bffe0f 	ldh	r2,-8(fp)
8013dffc:	10ffffcc 	andi	r3,r2,65535
8013e000:	00aa9554 	movui	r2,43605
8013e004:	1881841e 	bne	r3,r2,8013e618 <Check_for_DOS_FAT+0x66c>
8013e008:	e0bffb17 	ldw	r2,-20(fp)
8013e00c:	10018226 	beq	r2,zero,8013e618 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
8013e010:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
8013e014:	d0a0bc17 	ldw	r2,-32016(gp)
8013e018:	10800a17 	ldw	r2,40(r2)
8013e01c:	10800023 	ldbuio	r2,0(r2)
8013e020:	10803fcc 	andi	r2,r2,255
8013e024:	1007883a 	mov	r3,r2
8013e028:	00a005b4 	movhi	r2,32790
8013e02c:	10927b04 	addi	r2,r2,18924
8013e030:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
8013e034:	d0a0bc17 	ldw	r2,-32016(gp)
8013e038:	10800a17 	ldw	r2,40(r2)
8013e03c:	10800044 	addi	r2,r2,1
8013e040:	10800023 	ldbuio	r2,0(r2)
8013e044:	10803fcc 	andi	r2,r2,255
8013e048:	1007883a 	mov	r3,r2
8013e04c:	00a005b4 	movhi	r2,32790
8013e050:	10927b04 	addi	r2,r2,18924
8013e054:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8013e058:	d0a0bc17 	ldw	r2,-32016(gp)
8013e05c:	10800a17 	ldw	r2,40(r2)
8013e060:	10800084 	addi	r2,r2,2
8013e064:	10800023 	ldbuio	r2,0(r2)
8013e068:	10803fcc 	andi	r2,r2,255
8013e06c:	1007883a 	mov	r3,r2
8013e070:	00a005b4 	movhi	r2,32790
8013e074:	10927b04 	addi	r2,r2,18924
8013e078:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8013e07c:	e03ffc15 	stw	zero,-16(fp)
8013e080:	00001106 	br	8013e0c8 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
8013e084:	d0a0bc17 	ldw	r2,-32016(gp)
8013e088:	10c00a17 	ldw	r3,40(r2)
8013e08c:	e0bffc17 	ldw	r2,-16(fp)
8013e090:	1885883a 	add	r2,r3,r2
8013e094:	108000c4 	addi	r2,r2,3
8013e098:	10800023 	ldbuio	r2,0(r2)
8013e09c:	10803fcc 	andi	r2,r2,255
8013e0a0:	1009883a 	mov	r4,r2
8013e0a4:	00a005b4 	movhi	r2,32790
8013e0a8:	10927b04 	addi	r2,r2,18924
8013e0ac:	e0fffc17 	ldw	r3,-16(fp)
8013e0b0:	10c5883a 	add	r2,r2,r3
8013e0b4:	108000c4 	addi	r2,r2,3
8013e0b8:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8013e0bc:	e0bffc17 	ldw	r2,-16(fp)
8013e0c0:	10800044 	addi	r2,r2,1
8013e0c4:	e0bffc15 	stw	r2,-16(fp)
8013e0c8:	e0bffc17 	ldw	r2,-16(fp)
8013e0cc:	10800210 	cmplti	r2,r2,8
8013e0d0:	103fec1e 	bne	r2,zero,8013e084 <__reset+0xfa11e084>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8013e0d4:	d0a0bc17 	ldw	r2,-32016(gp)
8013e0d8:	10800a17 	ldw	r2,40(r2)
8013e0dc:	10800304 	addi	r2,r2,12
8013e0e0:	10800023 	ldbuio	r2,0(r2)
8013e0e4:	10803fcc 	andi	r2,r2,255
8013e0e8:	1004923a 	slli	r2,r2,8
8013e0ec:	1007883a 	mov	r3,r2
8013e0f0:	d0a0bc17 	ldw	r2,-32016(gp)
8013e0f4:	10800a17 	ldw	r2,40(r2)
8013e0f8:	108002c4 	addi	r2,r2,11
8013e0fc:	10800023 	ldbuio	r2,0(r2)
8013e100:	10803fcc 	andi	r2,r2,255
8013e104:	10803fcc 	andi	r2,r2,255
8013e108:	1080201c 	xori	r2,r2,128
8013e10c:	10bfe004 	addi	r2,r2,-128
8013e110:	1884b03a 	or	r2,r3,r2
8013e114:	1007883a 	mov	r3,r2
8013e118:	00a005b4 	movhi	r2,32790
8013e11c:	10927b04 	addi	r2,r2,18924
8013e120:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8013e124:	d0a0bc17 	ldw	r2,-32016(gp)
8013e128:	10800a17 	ldw	r2,40(r2)
8013e12c:	10800344 	addi	r2,r2,13
8013e130:	10800023 	ldbuio	r2,0(r2)
8013e134:	10803fcc 	andi	r2,r2,255
8013e138:	1007883a 	mov	r3,r2
8013e13c:	00a005b4 	movhi	r2,32790
8013e140:	10927b04 	addi	r2,r2,18924
8013e144:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8013e148:	d0a0bc17 	ldw	r2,-32016(gp)
8013e14c:	10800a17 	ldw	r2,40(r2)
8013e150:	10800384 	addi	r2,r2,14
8013e154:	1080002b 	ldhuio	r2,0(r2)
8013e158:	10bfffcc 	andi	r2,r2,65535
8013e15c:	1007883a 	mov	r3,r2
8013e160:	00a005b4 	movhi	r2,32790
8013e164:	10927b04 	addi	r2,r2,18924
8013e168:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8013e16c:	d0a0bc17 	ldw	r2,-32016(gp)
8013e170:	10800a17 	ldw	r2,40(r2)
8013e174:	10800404 	addi	r2,r2,16
8013e178:	10800023 	ldbuio	r2,0(r2)
8013e17c:	10803fcc 	andi	r2,r2,255
8013e180:	1007883a 	mov	r3,r2
8013e184:	00a005b4 	movhi	r2,32790
8013e188:	10927b04 	addi	r2,r2,18924
8013e18c:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
8013e190:	d0a0bc17 	ldw	r2,-32016(gp)
8013e194:	10800a17 	ldw	r2,40(r2)
8013e198:	10800484 	addi	r2,r2,18
8013e19c:	10800023 	ldbuio	r2,0(r2)
8013e1a0:	10803fcc 	andi	r2,r2,255
8013e1a4:	1004923a 	slli	r2,r2,8
8013e1a8:	1007883a 	mov	r3,r2
8013e1ac:	d0a0bc17 	ldw	r2,-32016(gp)
8013e1b0:	10800a17 	ldw	r2,40(r2)
8013e1b4:	10800444 	addi	r2,r2,17
8013e1b8:	10800023 	ldbuio	r2,0(r2)
8013e1bc:	10803fcc 	andi	r2,r2,255
8013e1c0:	10803fcc 	andi	r2,r2,255
8013e1c4:	1884b03a 	or	r2,r3,r2
8013e1c8:	1007883a 	mov	r3,r2
8013e1cc:	00a005b4 	movhi	r2,32790
8013e1d0:	10927b04 	addi	r2,r2,18924
8013e1d4:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8013e1d8:	d0a0bc17 	ldw	r2,-32016(gp)
8013e1dc:	10800a17 	ldw	r2,40(r2)
8013e1e0:	10800504 	addi	r2,r2,20
8013e1e4:	10800023 	ldbuio	r2,0(r2)
8013e1e8:	10803fcc 	andi	r2,r2,255
8013e1ec:	1004923a 	slli	r2,r2,8
8013e1f0:	1007883a 	mov	r3,r2
8013e1f4:	d0a0bc17 	ldw	r2,-32016(gp)
8013e1f8:	10800a17 	ldw	r2,40(r2)
8013e1fc:	108004c4 	addi	r2,r2,19
8013e200:	10800023 	ldbuio	r2,0(r2)
8013e204:	10803fcc 	andi	r2,r2,255
8013e208:	10803fcc 	andi	r2,r2,255
8013e20c:	1884b03a 	or	r2,r3,r2
8013e210:	1007883a 	mov	r3,r2
8013e214:	00a005b4 	movhi	r2,32790
8013e218:	10927b04 	addi	r2,r2,18924
8013e21c:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
8013e220:	d0a0bc17 	ldw	r2,-32016(gp)
8013e224:	10800a17 	ldw	r2,40(r2)
8013e228:	10800544 	addi	r2,r2,21
8013e22c:	10800023 	ldbuio	r2,0(r2)
8013e230:	10803fcc 	andi	r2,r2,255
8013e234:	1007883a 	mov	r3,r2
8013e238:	00a005b4 	movhi	r2,32790
8013e23c:	10927b04 	addi	r2,r2,18924
8013e240:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8013e244:	d0a0bc17 	ldw	r2,-32016(gp)
8013e248:	10800a17 	ldw	r2,40(r2)
8013e24c:	10800584 	addi	r2,r2,22
8013e250:	1080002b 	ldhuio	r2,0(r2)
8013e254:	10bfffcc 	andi	r2,r2,65535
8013e258:	1007883a 	mov	r3,r2
8013e25c:	00a005b4 	movhi	r2,32790
8013e260:	10927b04 	addi	r2,r2,18924
8013e264:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8013e268:	d0a0bc17 	ldw	r2,-32016(gp)
8013e26c:	10800a17 	ldw	r2,40(r2)
8013e270:	10800604 	addi	r2,r2,24
8013e274:	1080002b 	ldhuio	r2,0(r2)
8013e278:	10bfffcc 	andi	r2,r2,65535
8013e27c:	1007883a 	mov	r3,r2
8013e280:	00a005b4 	movhi	r2,32790
8013e284:	10927b04 	addi	r2,r2,18924
8013e288:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8013e28c:	d0a0bc17 	ldw	r2,-32016(gp)
8013e290:	10800a17 	ldw	r2,40(r2)
8013e294:	10800684 	addi	r2,r2,26
8013e298:	1080002b 	ldhuio	r2,0(r2)
8013e29c:	10bfffcc 	andi	r2,r2,65535
8013e2a0:	1007883a 	mov	r3,r2
8013e2a4:	00a005b4 	movhi	r2,32790
8013e2a8:	10927b04 	addi	r2,r2,18924
8013e2ac:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
8013e2b0:	d0a0bc17 	ldw	r2,-32016(gp)
8013e2b4:	10800a17 	ldw	r2,40(r2)
8013e2b8:	10800704 	addi	r2,r2,28
8013e2bc:	10800037 	ldwio	r2,0(r2)
8013e2c0:	1007883a 	mov	r3,r2
8013e2c4:	00a005b4 	movhi	r2,32790
8013e2c8:	10927b04 	addi	r2,r2,18924
8013e2cc:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
8013e2d0:	d0a0bc17 	ldw	r2,-32016(gp)
8013e2d4:	10800a17 	ldw	r2,40(r2)
8013e2d8:	10800804 	addi	r2,r2,32
8013e2dc:	10800037 	ldwio	r2,0(r2)
8013e2e0:	1007883a 	mov	r3,r2
8013e2e4:	00a005b4 	movhi	r2,32790
8013e2e8:	10927b04 	addi	r2,r2,18924
8013e2ec:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
8013e2f0:	d0a0bc17 	ldw	r2,-32016(gp)
8013e2f4:	10800a17 	ldw	r2,40(r2)
8013e2f8:	10800904 	addi	r2,r2,36
8013e2fc:	10800023 	ldbuio	r2,0(r2)
8013e300:	10803fcc 	andi	r2,r2,255
8013e304:	1007883a 	mov	r3,r2
8013e308:	00a005b4 	movhi	r2,32790
8013e30c:	10927b04 	addi	r2,r2,18924
8013e310:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8013e314:	d0a0bc17 	ldw	r2,-32016(gp)
8013e318:	10800a17 	ldw	r2,40(r2)
8013e31c:	10800944 	addi	r2,r2,37
8013e320:	10800023 	ldbuio	r2,0(r2)
8013e324:	10803fcc 	andi	r2,r2,255
8013e328:	1007883a 	mov	r3,r2
8013e32c:	00a005b4 	movhi	r2,32790
8013e330:	10927b04 	addi	r2,r2,18924
8013e334:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
8013e338:	d0a0bc17 	ldw	r2,-32016(gp)
8013e33c:	10800a17 	ldw	r2,40(r2)
8013e340:	10800984 	addi	r2,r2,38
8013e344:	10800023 	ldbuio	r2,0(r2)
8013e348:	10803fcc 	andi	r2,r2,255
8013e34c:	1007883a 	mov	r3,r2
8013e350:	00a005b4 	movhi	r2,32790
8013e354:	10927b04 	addi	r2,r2,18924
8013e358:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8013e35c:	00a005b4 	movhi	r2,32790
8013e360:	10927b04 	addi	r2,r2,18924
8013e364:	1080040b 	ldhu	r2,16(r2)
8013e368:	10ffffcc 	andi	r3,r2,65535
8013e36c:	00a005b4 	movhi	r2,32790
8013e370:	10927b04 	addi	r2,r2,18924
8013e374:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8013e378:	00a005b4 	movhi	r2,32790
8013e37c:	10927b04 	addi	r2,r2,18924
8013e380:	10c01117 	ldw	r3,68(r2)
8013e384:	00a005b4 	movhi	r2,32790
8013e388:	10927b04 	addi	r2,r2,18924
8013e38c:	1080068b 	ldhu	r2,26(r2)
8013e390:	10bfffcc 	andi	r2,r2,65535
8013e394:	1887883a 	add	r3,r3,r2
8013e398:	00a005b4 	movhi	r2,32790
8013e39c:	10927b04 	addi	r2,r2,18924
8013e3a0:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8013e3a4:	00a005b4 	movhi	r2,32790
8013e3a8:	10927b04 	addi	r2,r2,18924
8013e3ac:	10c01217 	ldw	r3,72(r2)
8013e3b0:	00a005b4 	movhi	r2,32790
8013e3b4:	10927b04 	addi	r2,r2,18924
8013e3b8:	1080068b 	ldhu	r2,26(r2)
8013e3bc:	10bfffcc 	andi	r2,r2,65535
8013e3c0:	1887883a 	add	r3,r3,r2
8013e3c4:	00a005b4 	movhi	r2,32790
8013e3c8:	10927b04 	addi	r2,r2,18924
8013e3cc:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
8013e3d0:	00a005b4 	movhi	r2,32790
8013e3d4:	10927b04 	addi	r2,r2,18924
8013e3d8:	10c01317 	ldw	r3,76(r2)
8013e3dc:	00a005b4 	movhi	r2,32790
8013e3e0:	10927b04 	addi	r2,r2,18924
8013e3e4:	1080050b 	ldhu	r2,20(r2)
8013e3e8:	10bfffcc 	andi	r2,r2,65535
8013e3ec:	1008917a 	slli	r4,r2,5
8013e3f0:	00a005b4 	movhi	r2,32790
8013e3f4:	10927b04 	addi	r2,r2,18924
8013e3f8:	1080030b 	ldhu	r2,12(r2)
8013e3fc:	10bfffcc 	andi	r2,r2,65535
8013e400:	2085283a 	div	r2,r4,r2
8013e404:	1887883a 	add	r3,r3,r2
8013e408:	00a005b4 	movhi	r2,32790
8013e40c:	10927b04 	addi	r2,r2,18924
8013e410:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8013e414:	00a005b4 	movhi	r2,32790
8013e418:	10927b04 	addi	r2,r2,18924
8013e41c:	1080058b 	ldhu	r2,22(r2)
8013e420:	10bfffcc 	andi	r2,r2,65535
8013e424:	10000b26 	beq	r2,zero,8013e454 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
8013e428:	00a005b4 	movhi	r2,32790
8013e42c:	10927b04 	addi	r2,r2,18924
8013e430:	1080058b 	ldhu	r2,22(r2)
8013e434:	10ffffcc 	andi	r3,r2,65535
8013e438:	00a005b4 	movhi	r2,32790
8013e43c:	10927b04 	addi	r2,r2,18924
8013e440:	10800383 	ldbu	r2,14(r2)
8013e444:	10803fcc 	andi	r2,r2,255
8013e448:	1885283a 	div	r2,r3,r2
8013e44c:	e0bffd15 	stw	r2,-12(fp)
8013e450:	00000906 	br	8013e478 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8013e454:	00a005b4 	movhi	r2,32790
8013e458:	10927b04 	addi	r2,r2,18924
8013e45c:	10c00917 	ldw	r3,36(r2)
8013e460:	00a005b4 	movhi	r2,32790
8013e464:	10927b04 	addi	r2,r2,18924
8013e468:	10800383 	ldbu	r2,14(r2)
8013e46c:	10803fcc 	andi	r2,r2,255
8013e470:	1885203a 	divu	r2,r3,r2
8013e474:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
8013e478:	e0bffd17 	ldw	r2,-12(fp)
8013e47c:	1083fdc8 	cmpgei	r2,r2,4087
8013e480:	1000051e 	bne	r2,zero,8013e498 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8013e484:	00a005b4 	movhi	r2,32790
8013e488:	10927b04 	addi	r2,r2,18924
8013e48c:	00c00304 	movi	r3,12
8013e490:	10c01085 	stb	r3,66(r2)
8013e494:	00000c06 	br	8013e4c8 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
8013e498:	e0bffd17 	ldw	r2,-12(fp)
8013e49c:	00fffb54 	movui	r3,65517
8013e4a0:	18800516 	blt	r3,r2,8013e4b8 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8013e4a4:	00a005b4 	movhi	r2,32790
8013e4a8:	10927b04 	addi	r2,r2,18924
8013e4ac:	00c00404 	movi	r3,16
8013e4b0:	10c01085 	stb	r3,66(r2)
8013e4b4:	00000406 	br	8013e4c8 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
8013e4b8:	00a005b4 	movhi	r2,32790
8013e4bc:	10927b04 	addi	r2,r2,18924
8013e4c0:	00c00804 	movi	r3,32
8013e4c4:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
8013e4c8:	e03ffc15 	stw	zero,-16(fp)
8013e4cc:	00001106 	br	8013e514 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8013e4d0:	d0a0bc17 	ldw	r2,-32016(gp)
8013e4d4:	10c00a17 	ldw	r3,40(r2)
8013e4d8:	e0bffc17 	ldw	r2,-16(fp)
8013e4dc:	1885883a 	add	r2,r3,r2
8013e4e0:	108009c4 	addi	r2,r2,39
8013e4e4:	10800023 	ldbuio	r2,0(r2)
8013e4e8:	10803fcc 	andi	r2,r2,255
8013e4ec:	1009883a 	mov	r4,r2
8013e4f0:	00a005b4 	movhi	r2,32790
8013e4f4:	10927b04 	addi	r2,r2,18924
8013e4f8:	e0fffc17 	ldw	r3,-16(fp)
8013e4fc:	10c5883a 	add	r2,r2,r3
8013e500:	10800ac4 	addi	r2,r2,43
8013e504:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
8013e508:	e0bffc17 	ldw	r2,-16(fp)
8013e50c:	10800044 	addi	r2,r2,1
8013e510:	e0bffc15 	stw	r2,-16(fp)
8013e514:	e0bffc17 	ldw	r2,-16(fp)
8013e518:	10800110 	cmplti	r2,r2,4
8013e51c:	103fec1e 	bne	r2,zero,8013e4d0 <__reset+0xfa11e4d0>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8013e520:	e03ffc15 	stw	zero,-16(fp)
8013e524:	00001106 	br	8013e56c <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
8013e528:	d0a0bc17 	ldw	r2,-32016(gp)
8013e52c:	10c00a17 	ldw	r3,40(r2)
8013e530:	e0bffc17 	ldw	r2,-16(fp)
8013e534:	1885883a 	add	r2,r3,r2
8013e538:	10800ac4 	addi	r2,r2,43
8013e53c:	10800023 	ldbuio	r2,0(r2)
8013e540:	10803fcc 	andi	r2,r2,255
8013e544:	1009883a 	mov	r4,r2
8013e548:	00a005b4 	movhi	r2,32790
8013e54c:	10927b04 	addi	r2,r2,18924
8013e550:	e0fffc17 	ldw	r3,-16(fp)
8013e554:	10c5883a 	add	r2,r2,r3
8013e558:	10800bc4 	addi	r2,r2,47
8013e55c:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8013e560:	e0bffc17 	ldw	r2,-16(fp)
8013e564:	10800044 	addi	r2,r2,1
8013e568:	e0bffc15 	stw	r2,-16(fp)
8013e56c:	e0bffc17 	ldw	r2,-16(fp)
8013e570:	108002d0 	cmplti	r2,r2,11
8013e574:	103fec1e 	bne	r2,zero,8013e528 <__reset+0xfa11e528>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8013e578:	e03ffc15 	stw	zero,-16(fp)
8013e57c:	00001106 	br	8013e5c4 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8013e580:	d0a0bc17 	ldw	r2,-32016(gp)
8013e584:	10c00a17 	ldw	r3,40(r2)
8013e588:	e0bffc17 	ldw	r2,-16(fp)
8013e58c:	1885883a 	add	r2,r3,r2
8013e590:	10800d84 	addi	r2,r2,54
8013e594:	10800023 	ldbuio	r2,0(r2)
8013e598:	10803fcc 	andi	r2,r2,255
8013e59c:	1009883a 	mov	r4,r2
8013e5a0:	00a005b4 	movhi	r2,32790
8013e5a4:	10927b04 	addi	r2,r2,18924
8013e5a8:	e0fffc17 	ldw	r3,-16(fp)
8013e5ac:	10c5883a 	add	r2,r2,r3
8013e5b0:	10800e84 	addi	r2,r2,58
8013e5b4:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8013e5b8:	e0bffc17 	ldw	r2,-16(fp)
8013e5bc:	10800044 	addi	r2,r2,1
8013e5c0:	e0bffc15 	stw	r2,-16(fp)
8013e5c4:	e0bffc17 	ldw	r2,-16(fp)
8013e5c8:	10800210 	cmplti	r2,r2,8
8013e5cc:	103fec1e 	bne	r2,zero,8013e580 <__reset+0xfa11e580>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8013e5d0:	e03ffc15 	stw	zero,-16(fp)
8013e5d4:	00000a06 	br	8013e600 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
8013e5d8:	00a005b4 	movhi	r2,32790
8013e5dc:	10929004 	addi	r2,r2,19008
8013e5e0:	e0fffc17 	ldw	r3,-16(fp)
8013e5e4:	180691ba 	slli	r3,r3,6
8013e5e8:	10c5883a 	add	r2,r2,r3
8013e5ec:	10800f04 	addi	r2,r2,60
8013e5f0:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8013e5f4:	e0bffc17 	ldw	r2,-16(fp)
8013e5f8:	10800044 	addi	r2,r2,1
8013e5fc:	e0bffc15 	stw	r2,-16(fp)
8013e600:	e0bffc17 	ldw	r2,-16(fp)
8013e604:	10800510 	cmplti	r2,r2,20
8013e608:	103ff31e 	bne	r2,zero,8013e5d8 <__reset+0xfa11e5d8>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8013e60c:	00800044 	movi	r2,1
8013e610:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8013e614:	00000106 	br	8013e61c <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
8013e618:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8013e61c:	e0bffb17 	ldw	r2,-20(fp)
}
8013e620:	e037883a 	mov	sp,fp
8013e624:	dfc00117 	ldw	ra,4(sp)
8013e628:	df000017 	ldw	fp,0(sp)
8013e62c:	dec00204 	addi	sp,sp,8
8013e630:	f800283a 	ret

8013e634 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8013e634:	defffc04 	addi	sp,sp,-16
8013e638:	de00012e 	bgeu	sp,et,8013e640 <Look_for_FAT16+0xc>
8013e63c:	003b68fa 	trap	3
8013e640:	dfc00315 	stw	ra,12(sp)
8013e644:	df000215 	stw	fp,8(sp)
8013e648:	df000204 	addi	fp,sp,8
	bool result = false;
8013e64c:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8013e650:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
8013e654:	10002e26 	beq	r2,zero,8013e710 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
8013e658:	d0a0b617 	ldw	r2,-32040(gp)
8013e65c:	1080000b 	ldhu	r2,0(r2)
8013e660:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8013e664:	d020ba15 	stw	zero,-32024(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
8013e668:	d020bb15 	stw	zero,-32020(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8013e66c:	e0bfff0f 	ldh	r2,-4(fp)
8013e670:	10002716 	blt	r2,zero,8013e710 <Look_for_FAT16+0xdc>
8013e674:	e0bfff0b 	ldhu	r2,-4(fp)
8013e678:	10bfffcc 	andi	r2,r2,65535
8013e67c:	1083000c 	andi	r2,r2,3072
8013e680:	10830020 	cmpeqi	r2,r2,3072
8013e684:	1000221e 	bne	r2,zero,8013e710 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
8013e688:	e0bfff0b 	ldhu	r2,-4(fp)
8013e68c:	10bfffcc 	andi	r2,r2,65535
8013e690:	1083000c 	andi	r2,r2,3072
8013e694:	10810018 	cmpnei	r2,r2,1024
8013e698:	1000031e 	bne	r2,zero,8013e6a8 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8013e69c:	0009883a 	mov	r4,zero
8013e6a0:	013dfac0 	call	8013dfac <Check_for_DOS_FAT>
8013e6a4:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
8013e6a8:	e0bfff0b 	ldhu	r2,-4(fp)
8013e6ac:	10bfffcc 	andi	r2,r2,65535
8013e6b0:	1083000c 	andi	r2,r2,3072
8013e6b4:	1000061e 	bne	r2,zero,8013e6d0 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
8013e6b8:	013d8e80 	call	8013d8e8 <Check_for_Master_Boot_Record>
8013e6bc:	10000426 	beq	r2,zero,8013e6d0 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8013e6c0:	d0a0ba17 	ldw	r2,-32024(gp)
8013e6c4:	1009883a 	mov	r4,r2
8013e6c8:	013dfac0 	call	8013dfac <Check_for_DOS_FAT>
8013e6cc:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8013e6d0:	e0bffe17 	ldw	r2,-8(fp)
8013e6d4:	10800058 	cmpnei	r2,r2,1
8013e6d8:	10000d1e 	bne	r2,zero,8013e710 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8013e6dc:	00a005b4 	movhi	r2,32790
8013e6e0:	10927b04 	addi	r2,r2,18924
8013e6e4:	10801083 	ldbu	r2,66(r2)
8013e6e8:	10803fcc 	andi	r2,r2,255
8013e6ec:	10800420 	cmpeqi	r2,r2,16
8013e6f0:	1000021e 	bne	r2,zero,8013e6fc <Look_for_FAT16+0xc8>
				{
					result = false;
8013e6f4:	e03ffe15 	stw	zero,-8(fp)
8013e6f8:	00000506 	br	8013e710 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8013e6fc:	00a005b4 	movhi	r2,32790
8013e700:	10927b04 	addi	r2,r2,18924
8013e704:	1080058b 	ldhu	r2,22(r2)
8013e708:	10bfffcc 	andi	r2,r2,65535
8013e70c:	d0a0bb15 	stw	r2,-32020(gp)
				}
			}
		}
	}
	return result;
8013e710:	e0bffe17 	ldw	r2,-8(fp)
}
8013e714:	e037883a 	mov	sp,fp
8013e718:	dfc00117 	ldw	ra,4(sp)
8013e71c:	df000017 	ldw	fp,0(sp)
8013e720:	dec00204 	addi	sp,sp,8
8013e724:	f800283a 	ret

8013e728 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
8013e728:	defffb04 	addi	sp,sp,-20
8013e72c:	de00012e 	bgeu	sp,et,8013e734 <filename_to_upper_case+0xc>
8013e730:	003b68fa 	trap	3
8013e734:	dfc00415 	stw	ra,16(sp)
8013e738:	df000315 	stw	fp,12(sp)
8013e73c:	df000304 	addi	fp,sp,12
8013e740:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8013e744:	e13fff17 	ldw	r4,-4(fp)
8013e748:	01219540 	call	80121954 <strlen>
8013e74c:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8013e750:	e03ffd15 	stw	zero,-12(fp)
8013e754:	00001e06 	br	8013e7d0 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
8013e758:	e0bffd17 	ldw	r2,-12(fp)
8013e75c:	e0ffff17 	ldw	r3,-4(fp)
8013e760:	1885883a 	add	r2,r3,r2
8013e764:	10800003 	ldbu	r2,0(r2)
8013e768:	10803fcc 	andi	r2,r2,255
8013e76c:	1080201c 	xori	r2,r2,128
8013e770:	10bfe004 	addi	r2,r2,-128
8013e774:	10801850 	cmplti	r2,r2,97
8013e778:	1000121e 	bne	r2,zero,8013e7c4 <filename_to_upper_case+0x9c>
8013e77c:	e0bffd17 	ldw	r2,-12(fp)
8013e780:	e0ffff17 	ldw	r3,-4(fp)
8013e784:	1885883a 	add	r2,r3,r2
8013e788:	10800003 	ldbu	r2,0(r2)
8013e78c:	10803fcc 	andi	r2,r2,255
8013e790:	1080201c 	xori	r2,r2,128
8013e794:	10bfe004 	addi	r2,r2,-128
8013e798:	10801ec8 	cmpgei	r2,r2,123
8013e79c:	1000091e 	bne	r2,zero,8013e7c4 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8013e7a0:	e0bffd17 	ldw	r2,-12(fp)
8013e7a4:	e0ffff17 	ldw	r3,-4(fp)
8013e7a8:	1885883a 	add	r2,r3,r2
8013e7ac:	e0fffd17 	ldw	r3,-12(fp)
8013e7b0:	e13fff17 	ldw	r4,-4(fp)
8013e7b4:	20c7883a 	add	r3,r4,r3
8013e7b8:	18c00003 	ldbu	r3,0(r3)
8013e7bc:	18fff804 	addi	r3,r3,-32
8013e7c0:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8013e7c4:	e0bffd17 	ldw	r2,-12(fp)
8013e7c8:	10800044 	addi	r2,r2,1
8013e7cc:	e0bffd15 	stw	r2,-12(fp)
8013e7d0:	e0fffd17 	ldw	r3,-12(fp)
8013e7d4:	e0bffe17 	ldw	r2,-8(fp)
8013e7d8:	18bfdf16 	blt	r3,r2,8013e758 <__reset+0xfa11e758>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8013e7dc:	0001883a 	nop
8013e7e0:	e037883a 	mov	sp,fp
8013e7e4:	dfc00117 	ldw	ra,4(sp)
8013e7e8:	df000017 	ldw	fp,0(sp)
8013e7ec:	dec00204 	addi	sp,sp,8
8013e7f0:	f800283a 	ret

8013e7f4 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8013e7f4:	defff804 	addi	sp,sp,-32
8013e7f8:	de00012e 	bgeu	sp,et,8013e800 <check_file_name_for_FAT16_compliance+0xc>
8013e7fc:	003b68fa 	trap	3
8013e800:	dfc00715 	stw	ra,28(sp)
8013e804:	df000615 	stw	fp,24(sp)
8013e808:	df000604 	addi	fp,sp,24
8013e80c:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8013e810:	e13fff17 	ldw	r4,-4(fp)
8013e814:	01219540 	call	80121954 <strlen>
8013e818:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8013e81c:	00bfffc4 	movi	r2,-1
8013e820:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8013e824:	00bfffc4 	movi	r2,-1
8013e828:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8013e82c:	00800044 	movi	r2,1
8013e830:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8013e834:	e03ffa15 	stw	zero,-24(fp)
8013e838:	00006d06 	br	8013e9f0 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8013e83c:	e0bffa17 	ldw	r2,-24(fp)
8013e840:	e0ffff17 	ldw	r3,-4(fp)
8013e844:	1885883a 	add	r2,r3,r2
8013e848:	10800003 	ldbu	r2,0(r2)
8013e84c:	10803fcc 	andi	r2,r2,255
8013e850:	1080201c 	xori	r2,r2,128
8013e854:	10bfe004 	addi	r2,r2,-128
8013e858:	10800820 	cmpeqi	r2,r2,32
8013e85c:	10003e1e 	bne	r2,zero,8013e958 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8013e860:	e0bffa17 	ldw	r2,-24(fp)
8013e864:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
8013e868:	e0bffb17 	ldw	r2,-20(fp)
8013e86c:	1880121e 	bne	r3,r2,8013e8b8 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8013e870:	e0bffa17 	ldw	r2,-24(fp)
8013e874:	e0ffff17 	ldw	r3,-4(fp)
8013e878:	1885883a 	add	r2,r3,r2
8013e87c:	10800003 	ldbu	r2,0(r2)
8013e880:	10803fcc 	andi	r2,r2,255
8013e884:	1080201c 	xori	r2,r2,128
8013e888:	10bfe004 	addi	r2,r2,-128
8013e88c:	10801720 	cmpeqi	r2,r2,92
8013e890:	1000311e 	bne	r2,zero,8013e958 <check_file_name_for_FAT16_compliance+0x164>
8013e894:	e0bffa17 	ldw	r2,-24(fp)
8013e898:	e0ffff17 	ldw	r3,-4(fp)
8013e89c:	1885883a 	add	r2,r3,r2
8013e8a0:	10800003 	ldbu	r2,0(r2)
8013e8a4:	10803fcc 	andi	r2,r2,255
8013e8a8:	1080201c 	xori	r2,r2,128
8013e8ac:	10bfe004 	addi	r2,r2,-128
8013e8b0:	10800be0 	cmpeqi	r2,r2,47
8013e8b4:	1000281e 	bne	r2,zero,8013e958 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8013e8b8:	e0fffa17 	ldw	r3,-24(fp)
8013e8bc:	e0bffc17 	ldw	r2,-16(fp)
8013e8c0:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8013e8c4:	10800258 	cmpnei	r2,r2,9
8013e8c8:	1000091e 	bne	r2,zero,8013e8f0 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8013e8cc:	e0bffa17 	ldw	r2,-24(fp)
8013e8d0:	e0ffff17 	ldw	r3,-4(fp)
8013e8d4:	1885883a 	add	r2,r3,r2
8013e8d8:	10800003 	ldbu	r2,0(r2)
8013e8dc:	10803fcc 	andi	r2,r2,255
8013e8e0:	1080201c 	xori	r2,r2,128
8013e8e4:	10bfe004 	addi	r2,r2,-128
8013e8e8:	10800b98 	cmpnei	r2,r2,46
8013e8ec:	10001a1e 	bne	r2,zero,8013e958 <check_file_name_for_FAT16_compliance+0x164>
8013e8f0:	e0fffb17 	ldw	r3,-20(fp)
8013e8f4:	e0bffc17 	ldw	r2,-16(fp)
8013e8f8:	18801926 	beq	r3,r2,8013e960 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8013e8fc:	e0fffa17 	ldw	r3,-24(fp)
8013e900:	e0bffc17 	ldw	r2,-16(fp)
8013e904:	1885c83a 	sub	r2,r3,r2
8013e908:	10800110 	cmplti	r2,r2,4
8013e90c:	1000141e 	bne	r2,zero,8013e960 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8013e910:	e0bffa17 	ldw	r2,-24(fp)
8013e914:	e0ffff17 	ldw	r3,-4(fp)
8013e918:	1885883a 	add	r2,r3,r2
8013e91c:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8013e920:	10803fcc 	andi	r2,r2,255
8013e924:	1080201c 	xori	r2,r2,128
8013e928:	10bfe004 	addi	r2,r2,-128
8013e92c:	10801720 	cmpeqi	r2,r2,92
8013e930:	10000b1e 	bne	r2,zero,8013e960 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8013e934:	e0bffa17 	ldw	r2,-24(fp)
8013e938:	e0ffff17 	ldw	r3,-4(fp)
8013e93c:	1885883a 	add	r2,r3,r2
8013e940:	10800003 	ldbu	r2,0(r2)
8013e944:	10803fcc 	andi	r2,r2,255
8013e948:	1080201c 	xori	r2,r2,128
8013e94c:	10bfe004 	addi	r2,r2,-128
8013e950:	10800be0 	cmpeqi	r2,r2,47
8013e954:	1000021e 	bne	r2,zero,8013e960 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
8013e958:	e03ffd15 	stw	zero,-12(fp)
            break;
8013e95c:	00002706 	br	8013e9fc <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8013e960:	e0bffa17 	ldw	r2,-24(fp)
8013e964:	e0ffff17 	ldw	r3,-4(fp)
8013e968:	1885883a 	add	r2,r3,r2
8013e96c:	10800003 	ldbu	r2,0(r2)
8013e970:	10803fcc 	andi	r2,r2,255
8013e974:	1080201c 	xori	r2,r2,128
8013e978:	10bfe004 	addi	r2,r2,-128
8013e97c:	10801720 	cmpeqi	r2,r2,92
8013e980:	1000091e 	bne	r2,zero,8013e9a8 <check_file_name_for_FAT16_compliance+0x1b4>
8013e984:	e0bffa17 	ldw	r2,-24(fp)
8013e988:	e0ffff17 	ldw	r3,-4(fp)
8013e98c:	1885883a 	add	r2,r3,r2
8013e990:	10800003 	ldbu	r2,0(r2)
8013e994:	10803fcc 	andi	r2,r2,255
8013e998:	1080201c 	xori	r2,r2,128
8013e99c:	10bfe004 	addi	r2,r2,-128
8013e9a0:	10800bd8 	cmpnei	r2,r2,47
8013e9a4:	1000041e 	bne	r2,zero,8013e9b8 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
8013e9a8:	e0bffa17 	ldw	r2,-24(fp)
8013e9ac:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
8013e9b0:	e0bffa17 	ldw	r2,-24(fp)
8013e9b4:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
8013e9b8:	e0bffa17 	ldw	r2,-24(fp)
8013e9bc:	e0ffff17 	ldw	r3,-4(fp)
8013e9c0:	1885883a 	add	r2,r3,r2
8013e9c4:	10800003 	ldbu	r2,0(r2)
8013e9c8:	10803fcc 	andi	r2,r2,255
8013e9cc:	1080201c 	xori	r2,r2,128
8013e9d0:	10bfe004 	addi	r2,r2,-128
8013e9d4:	10800b98 	cmpnei	r2,r2,46
8013e9d8:	1000021e 	bne	r2,zero,8013e9e4 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8013e9dc:	e0bffa17 	ldw	r2,-24(fp)
8013e9e0:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8013e9e4:	e0bffa17 	ldw	r2,-24(fp)
8013e9e8:	10800044 	addi	r2,r2,1
8013e9ec:	e0bffa15 	stw	r2,-24(fp)
8013e9f0:	e0fffa17 	ldw	r3,-24(fp)
8013e9f4:	e0bffe17 	ldw	r2,-8(fp)
8013e9f8:	18bf9016 	blt	r3,r2,8013e83c <__reset+0xfa11e83c>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8013e9fc:	e0bffe17 	ldw	r2,-8(fp)
8013ea00:	10bfffc4 	addi	r2,r2,-1
8013ea04:	e0ffff17 	ldw	r3,-4(fp)
8013ea08:	1885883a 	add	r2,r3,r2
8013ea0c:	10800003 	ldbu	r2,0(r2)
8013ea10:	10803fcc 	andi	r2,r2,255
8013ea14:	1080201c 	xori	r2,r2,128
8013ea18:	10bfe004 	addi	r2,r2,-128
8013ea1c:	10801720 	cmpeqi	r2,r2,92
8013ea20:	10000a1e 	bne	r2,zero,8013ea4c <check_file_name_for_FAT16_compliance+0x258>
8013ea24:	e0bffe17 	ldw	r2,-8(fp)
8013ea28:	10bfffc4 	addi	r2,r2,-1
8013ea2c:	e0ffff17 	ldw	r3,-4(fp)
8013ea30:	1885883a 	add	r2,r3,r2
8013ea34:	10800003 	ldbu	r2,0(r2)
8013ea38:	10803fcc 	andi	r2,r2,255
8013ea3c:	1080201c 	xori	r2,r2,128
8013ea40:	10bfe004 	addi	r2,r2,-128
8013ea44:	10800bd8 	cmpnei	r2,r2,47
8013ea48:	1000011e 	bne	r2,zero,8013ea50 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8013ea4c:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8013ea50:	e0bffd17 	ldw	r2,-12(fp)
}
8013ea54:	e037883a 	mov	sp,fp
8013ea58:	dfc00117 	ldw	ra,4(sp)
8013ea5c:	df000017 	ldw	fp,0(sp)
8013ea60:	dec00204 	addi	sp,sp,8
8013ea64:	f800283a 	ret

8013ea68 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8013ea68:	defffb04 	addi	sp,sp,-20
8013ea6c:	de00012e 	bgeu	sp,et,8013ea74 <get_dir_divider_location+0xc>
8013ea70:	003b68fa 	trap	3
8013ea74:	dfc00415 	stw	ra,16(sp)
8013ea78:	df000315 	stw	fp,12(sp)
8013ea7c:	df000304 	addi	fp,sp,12
8013ea80:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
8013ea84:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8013ea88:	e13fff17 	ldw	r4,-4(fp)
8013ea8c:	01219540 	call	80121954 <strlen>
8013ea90:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
8013ea94:	e03ffd15 	stw	zero,-12(fp)
8013ea98:	00001506 	br	8013eaf0 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8013ea9c:	e0bffd17 	ldw	r2,-12(fp)
8013eaa0:	e0ffff17 	ldw	r3,-4(fp)
8013eaa4:	1885883a 	add	r2,r3,r2
8013eaa8:	10800003 	ldbu	r2,0(r2)
8013eaac:	10803fcc 	andi	r2,r2,255
8013eab0:	1080201c 	xori	r2,r2,128
8013eab4:	10bfe004 	addi	r2,r2,-128
8013eab8:	10801720 	cmpeqi	r2,r2,92
8013eabc:	10000f1e 	bne	r2,zero,8013eafc <get_dir_divider_location+0x94>
8013eac0:	e0bffd17 	ldw	r2,-12(fp)
8013eac4:	e0ffff17 	ldw	r3,-4(fp)
8013eac8:	1885883a 	add	r2,r3,r2
8013eacc:	10800003 	ldbu	r2,0(r2)
8013ead0:	10803fcc 	andi	r2,r2,255
8013ead4:	1080201c 	xori	r2,r2,128
8013ead8:	10bfe004 	addi	r2,r2,-128
8013eadc:	10800be0 	cmpeqi	r2,r2,47
8013eae0:	1000061e 	bne	r2,zero,8013eafc <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
8013eae4:	e0bffd17 	ldw	r2,-12(fp)
8013eae8:	10800044 	addi	r2,r2,1
8013eaec:	e0bffd15 	stw	r2,-12(fp)
8013eaf0:	e0fffd17 	ldw	r3,-12(fp)
8013eaf4:	e0bffe17 	ldw	r2,-8(fp)
8013eaf8:	18bfe816 	blt	r3,r2,8013ea9c <__reset+0xfa11ea9c>
        {
            break;
        }
    }
    
    if (index == length)
8013eafc:	e0fffd17 	ldw	r3,-12(fp)
8013eb00:	e0bffe17 	ldw	r2,-8(fp)
8013eb04:	1880021e 	bne	r3,r2,8013eb10 <get_dir_divider_location+0xa8>
    {
        index = -1;
8013eb08:	00bfffc4 	movi	r2,-1
8013eb0c:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8013eb10:	e0bffd17 	ldw	r2,-12(fp)
}
8013eb14:	e037883a 	mov	sp,fp
8013eb18:	dfc00117 	ldw	ra,4(sp)
8013eb1c:	df000017 	ldw	fp,0(sp)
8013eb20:	dec00204 	addi	sp,sp,8
8013eb24:	f800283a 	ret

8013eb28 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
8013eb28:	defffa04 	addi	sp,sp,-24
8013eb2c:	de00012e 	bgeu	sp,et,8013eb34 <match_file_record_to_name_ext+0xc>
8013eb30:	003b68fa 	trap	3
8013eb34:	df000515 	stw	fp,20(sp)
8013eb38:	df000504 	addi	fp,sp,20
8013eb3c:	e13ffd15 	stw	r4,-12(fp)
8013eb40:	e17ffe15 	stw	r5,-8(fp)
8013eb44:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8013eb48:	00800044 	movi	r2,1
8013eb4c:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8013eb50:	e03ffc15 	stw	zero,-16(fp)
8013eb54:	00004606 	br	8013ec70 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8013eb58:	e0fffd17 	ldw	r3,-12(fp)
8013eb5c:	e0bffc17 	ldw	r2,-16(fp)
8013eb60:	1885883a 	add	r2,r3,r2
8013eb64:	10800003 	ldbu	r2,0(r2)
8013eb68:	10803fcc 	andi	r2,r2,255
8013eb6c:	10801870 	cmpltui	r2,r2,97
8013eb70:	1000101e 	bne	r2,zero,8013ebb4 <match_file_record_to_name_ext+0x8c>
8013eb74:	e0fffd17 	ldw	r3,-12(fp)
8013eb78:	e0bffc17 	ldw	r2,-16(fp)
8013eb7c:	1885883a 	add	r2,r3,r2
8013eb80:	10800003 	ldbu	r2,0(r2)
8013eb84:	10803fcc 	andi	r2,r2,255
8013eb88:	10801ee8 	cmpgeui	r2,r2,123
8013eb8c:	1000091e 	bne	r2,zero,8013ebb4 <match_file_record_to_name_ext+0x8c>
8013eb90:	e0fffd17 	ldw	r3,-12(fp)
8013eb94:	e0bffc17 	ldw	r2,-16(fp)
8013eb98:	1885883a 	add	r2,r3,r2
8013eb9c:	10800003 	ldbu	r2,0(r2)
8013eba0:	10bff804 	addi	r2,r2,-32
8013eba4:	10c03fcc 	andi	r3,r2,255
8013eba8:	18c0201c 	xori	r3,r3,128
8013ebac:	18ffe004 	addi	r3,r3,-128
8013ebb0:	00000706 	br	8013ebd0 <match_file_record_to_name_ext+0xa8>
8013ebb4:	e0fffd17 	ldw	r3,-12(fp)
8013ebb8:	e0bffc17 	ldw	r2,-16(fp)
8013ebbc:	1885883a 	add	r2,r3,r2
8013ebc0:	10800003 	ldbu	r2,0(r2)
8013ebc4:	10c03fcc 	andi	r3,r2,255
8013ebc8:	18c0201c 	xori	r3,r3,128
8013ebcc:	18ffe004 	addi	r3,r3,-128
8013ebd0:	e0bffc17 	ldw	r2,-16(fp)
8013ebd4:	e13ffe17 	ldw	r4,-8(fp)
8013ebd8:	2085883a 	add	r2,r4,r2
8013ebdc:	10800003 	ldbu	r2,0(r2)
8013ebe0:	10803fcc 	andi	r2,r2,255
8013ebe4:	1080201c 	xori	r2,r2,128
8013ebe8:	10bfe004 	addi	r2,r2,-128
8013ebec:	10801850 	cmplti	r2,r2,97
8013ebf0:	1000121e 	bne	r2,zero,8013ec3c <match_file_record_to_name_ext+0x114>
8013ebf4:	e0bffc17 	ldw	r2,-16(fp)
8013ebf8:	e13ffe17 	ldw	r4,-8(fp)
8013ebfc:	2085883a 	add	r2,r4,r2
8013ec00:	10800003 	ldbu	r2,0(r2)
8013ec04:	10803fcc 	andi	r2,r2,255
8013ec08:	1080201c 	xori	r2,r2,128
8013ec0c:	10bfe004 	addi	r2,r2,-128
8013ec10:	10801ec8 	cmpgei	r2,r2,123
8013ec14:	1000091e 	bne	r2,zero,8013ec3c <match_file_record_to_name_ext+0x114>
8013ec18:	e0bffc17 	ldw	r2,-16(fp)
8013ec1c:	e13ffe17 	ldw	r4,-8(fp)
8013ec20:	2085883a 	add	r2,r4,r2
8013ec24:	10800003 	ldbu	r2,0(r2)
8013ec28:	10bff804 	addi	r2,r2,-32
8013ec2c:	10803fcc 	andi	r2,r2,255
8013ec30:	1080201c 	xori	r2,r2,128
8013ec34:	10bfe004 	addi	r2,r2,-128
8013ec38:	00000706 	br	8013ec58 <match_file_record_to_name_ext+0x130>
8013ec3c:	e0bffc17 	ldw	r2,-16(fp)
8013ec40:	e13ffe17 	ldw	r4,-8(fp)
8013ec44:	2085883a 	add	r2,r4,r2
8013ec48:	10800003 	ldbu	r2,0(r2)
8013ec4c:	10803fcc 	andi	r2,r2,255
8013ec50:	1080201c 	xori	r2,r2,128
8013ec54:	10bfe004 	addi	r2,r2,-128
8013ec58:	18800226 	beq	r3,r2,8013ec64 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8013ec5c:	e03ffb15 	stw	zero,-20(fp)
			break;
8013ec60:	00000606 	br	8013ec7c <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
8013ec64:	e0bffc17 	ldw	r2,-16(fp)
8013ec68:	10800044 	addi	r2,r2,1
8013ec6c:	e0bffc15 	stw	r2,-16(fp)
8013ec70:	e0bffc17 	ldw	r2,-16(fp)
8013ec74:	10800210 	cmplti	r2,r2,8
8013ec78:	103fb71e 	bne	r2,zero,8013eb58 <__reset+0xfa11eb58>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8013ec7c:	e03ffc15 	stw	zero,-16(fp)
8013ec80:	00004a06 	br	8013edac <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
8013ec84:	e0fffd17 	ldw	r3,-12(fp)
8013ec88:	e0bffc17 	ldw	r2,-16(fp)
8013ec8c:	1885883a 	add	r2,r3,r2
8013ec90:	10800204 	addi	r2,r2,8
8013ec94:	10800003 	ldbu	r2,0(r2)
8013ec98:	10803fcc 	andi	r2,r2,255
8013ec9c:	10801870 	cmpltui	r2,r2,97
8013eca0:	1000121e 	bne	r2,zero,8013ecec <match_file_record_to_name_ext+0x1c4>
8013eca4:	e0fffd17 	ldw	r3,-12(fp)
8013eca8:	e0bffc17 	ldw	r2,-16(fp)
8013ecac:	1885883a 	add	r2,r3,r2
8013ecb0:	10800204 	addi	r2,r2,8
8013ecb4:	10800003 	ldbu	r2,0(r2)
8013ecb8:	10803fcc 	andi	r2,r2,255
8013ecbc:	10801ee8 	cmpgeui	r2,r2,123
8013ecc0:	10000a1e 	bne	r2,zero,8013ecec <match_file_record_to_name_ext+0x1c4>
8013ecc4:	e0fffd17 	ldw	r3,-12(fp)
8013ecc8:	e0bffc17 	ldw	r2,-16(fp)
8013eccc:	1885883a 	add	r2,r3,r2
8013ecd0:	10800204 	addi	r2,r2,8
8013ecd4:	10800003 	ldbu	r2,0(r2)
8013ecd8:	10bff804 	addi	r2,r2,-32
8013ecdc:	10c03fcc 	andi	r3,r2,255
8013ece0:	18c0201c 	xori	r3,r3,128
8013ece4:	18ffe004 	addi	r3,r3,-128
8013ece8:	00000806 	br	8013ed0c <match_file_record_to_name_ext+0x1e4>
8013ecec:	e0fffd17 	ldw	r3,-12(fp)
8013ecf0:	e0bffc17 	ldw	r2,-16(fp)
8013ecf4:	1885883a 	add	r2,r3,r2
8013ecf8:	10800204 	addi	r2,r2,8
8013ecfc:	10800003 	ldbu	r2,0(r2)
8013ed00:	10c03fcc 	andi	r3,r2,255
8013ed04:	18c0201c 	xori	r3,r3,128
8013ed08:	18ffe004 	addi	r3,r3,-128
8013ed0c:	e0bffc17 	ldw	r2,-16(fp)
8013ed10:	e13fff17 	ldw	r4,-4(fp)
8013ed14:	2085883a 	add	r2,r4,r2
8013ed18:	10800003 	ldbu	r2,0(r2)
8013ed1c:	10803fcc 	andi	r2,r2,255
8013ed20:	1080201c 	xori	r2,r2,128
8013ed24:	10bfe004 	addi	r2,r2,-128
8013ed28:	10801850 	cmplti	r2,r2,97
8013ed2c:	1000121e 	bne	r2,zero,8013ed78 <match_file_record_to_name_ext+0x250>
8013ed30:	e0bffc17 	ldw	r2,-16(fp)
8013ed34:	e13fff17 	ldw	r4,-4(fp)
8013ed38:	2085883a 	add	r2,r4,r2
8013ed3c:	10800003 	ldbu	r2,0(r2)
8013ed40:	10803fcc 	andi	r2,r2,255
8013ed44:	1080201c 	xori	r2,r2,128
8013ed48:	10bfe004 	addi	r2,r2,-128
8013ed4c:	10801ec8 	cmpgei	r2,r2,123
8013ed50:	1000091e 	bne	r2,zero,8013ed78 <match_file_record_to_name_ext+0x250>
8013ed54:	e0bffc17 	ldw	r2,-16(fp)
8013ed58:	e13fff17 	ldw	r4,-4(fp)
8013ed5c:	2085883a 	add	r2,r4,r2
8013ed60:	10800003 	ldbu	r2,0(r2)
8013ed64:	10bff804 	addi	r2,r2,-32
8013ed68:	10803fcc 	andi	r2,r2,255
8013ed6c:	1080201c 	xori	r2,r2,128
8013ed70:	10bfe004 	addi	r2,r2,-128
8013ed74:	00000706 	br	8013ed94 <match_file_record_to_name_ext+0x26c>
8013ed78:	e0bffc17 	ldw	r2,-16(fp)
8013ed7c:	e13fff17 	ldw	r4,-4(fp)
8013ed80:	2085883a 	add	r2,r4,r2
8013ed84:	10800003 	ldbu	r2,0(r2)
8013ed88:	10803fcc 	andi	r2,r2,255
8013ed8c:	1080201c 	xori	r2,r2,128
8013ed90:	10bfe004 	addi	r2,r2,-128
8013ed94:	18800226 	beq	r3,r2,8013eda0 <match_file_record_to_name_ext+0x278>
        {
            match = false;
8013ed98:	e03ffb15 	stw	zero,-20(fp)
			break;
8013ed9c:	00000606 	br	8013edb8 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8013eda0:	e0bffc17 	ldw	r2,-16(fp)
8013eda4:	10800044 	addi	r2,r2,1
8013eda8:	e0bffc15 	stw	r2,-16(fp)
8013edac:	e0bffc17 	ldw	r2,-16(fp)
8013edb0:	108000d0 	cmplti	r2,r2,3
8013edb4:	103fb31e 	bne	r2,zero,8013ec84 <__reset+0xfa11ec84>
        {
            match = false;
			break;
        }
    }
	return match;
8013edb8:	e0bffb17 	ldw	r2,-20(fp)
}
8013edbc:	e037883a 	mov	sp,fp
8013edc0:	df000017 	ldw	fp,0(sp)
8013edc4:	dec00104 	addi	sp,sp,4
8013edc8:	f800283a 	ret

8013edcc <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8013edcc:	deffe704 	addi	sp,sp,-100
8013edd0:	de00012e 	bgeu	sp,et,8013edd8 <get_home_directory_cluster_for_file+0xc>
8013edd4:	003b68fa 	trap	3
8013edd8:	dfc01815 	stw	ra,96(sp)
8013eddc:	df001715 	stw	fp,92(sp)
8013ede0:	df001704 	addi	fp,sp,92
8013ede4:	e13ffd15 	stw	r4,-12(fp)
8013ede8:	e17ffe15 	stw	r5,-8(fp)
8013edec:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
8013edf0:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
8013edf4:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
8013edf8:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8013edfc:	e13ffd17 	ldw	r4,-12(fp)
8013ee00:	013ea680 	call	8013ea68 <get_dir_divider_location>
8013ee04:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
8013ee08:	00012f06 	br	8013f2c8 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8013ee0c:	00800804 	movi	r2,32
8013ee10:	e0bff905 	stb	r2,-28(fp)
8013ee14:	00800804 	movi	r2,32
8013ee18:	e0bff945 	stb	r2,-27(fp)
8013ee1c:	00800804 	movi	r2,32
8013ee20:	e0bff985 	stb	r2,-26(fp)
8013ee24:	00800804 	movi	r2,32
8013ee28:	e0bff9c5 	stb	r2,-25(fp)
8013ee2c:	00800804 	movi	r2,32
8013ee30:	e0bffa05 	stb	r2,-24(fp)
8013ee34:	00800804 	movi	r2,32
8013ee38:	e0bffa45 	stb	r2,-23(fp)
8013ee3c:	00800804 	movi	r2,32
8013ee40:	e0bffa85 	stb	r2,-22(fp)
8013ee44:	00800804 	movi	r2,32
8013ee48:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
8013ee4c:	00800804 	movi	r2,32
8013ee50:	e0bffb05 	stb	r2,-20(fp)
8013ee54:	00800804 	movi	r2,32
8013ee58:	e0bffb45 	stb	r2,-19(fp)
8013ee5c:	00800804 	movi	r2,32
8013ee60:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
8013ee64:	00bfffc4 	movi	r2,-1
8013ee68:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
8013ee6c:	e0bfea17 	ldw	r2,-88(fp)
8013ee70:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8013ee74:	e03fec15 	stw	zero,-80(fp)
8013ee78:	00002d06 	br	8013ef30 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
8013ee7c:	e0ffec17 	ldw	r3,-80(fp)
8013ee80:	e0bfed17 	ldw	r2,-76(fp)
8013ee84:	1885883a 	add	r2,r3,r2
8013ee88:	1007883a 	mov	r3,r2
8013ee8c:	e0bffd17 	ldw	r2,-12(fp)
8013ee90:	10c5883a 	add	r2,r2,r3
8013ee94:	10800003 	ldbu	r2,0(r2)
8013ee98:	10803fcc 	andi	r2,r2,255
8013ee9c:	1080201c 	xori	r2,r2,128
8013eea0:	10bfe004 	addi	r2,r2,-128
8013eea4:	10800b98 	cmpnei	r2,r2,46
8013eea8:	1000031e 	bne	r2,zero,8013eeb8 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8013eeac:	e0bfec17 	ldw	r2,-80(fp)
8013eeb0:	e0bfee15 	stw	r2,-72(fp)
8013eeb4:	00001b06 	br	8013ef24 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
8013eeb8:	e0bfee17 	ldw	r2,-72(fp)
8013eebc:	10000c0e 	bge	r2,zero,8013eef0 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
8013eec0:	e0ffec17 	ldw	r3,-80(fp)
8013eec4:	e0bfed17 	ldw	r2,-76(fp)
8013eec8:	1885883a 	add	r2,r3,r2
8013eecc:	1007883a 	mov	r3,r2
8013eed0:	e0bffd17 	ldw	r2,-12(fp)
8013eed4:	10c5883a 	add	r2,r2,r3
8013eed8:	10c00003 	ldbu	r3,0(r2)
8013eedc:	e13ff904 	addi	r4,fp,-28
8013eee0:	e0bfec17 	ldw	r2,-80(fp)
8013eee4:	2085883a 	add	r2,r4,r2
8013eee8:	10c00005 	stb	r3,0(r2)
8013eeec:	00000d06 	br	8013ef24 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
8013eef0:	e0ffec17 	ldw	r3,-80(fp)
8013eef4:	e0bfee17 	ldw	r2,-72(fp)
8013eef8:	1885c83a 	sub	r2,r3,r2
8013eefc:	e13fec17 	ldw	r4,-80(fp)
8013ef00:	e0ffed17 	ldw	r3,-76(fp)
8013ef04:	20c7883a 	add	r3,r4,r3
8013ef08:	1809883a 	mov	r4,r3
8013ef0c:	e0fffd17 	ldw	r3,-12(fp)
8013ef10:	1907883a 	add	r3,r3,r4
8013ef14:	18c00003 	ldbu	r3,0(r3)
8013ef18:	e13ffb04 	addi	r4,fp,-20
8013ef1c:	2085883a 	add	r2,r4,r2
8013ef20:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8013ef24:	e0bfec17 	ldw	r2,-80(fp)
8013ef28:	10800044 	addi	r2,r2,1
8013ef2c:	e0bfec15 	stw	r2,-80(fp)
8013ef30:	e0ffec17 	ldw	r3,-80(fp)
8013ef34:	e0bfeb17 	ldw	r2,-84(fp)
8013ef38:	18bfd016 	blt	r3,r2,8013ee7c <__reset+0xfa11ee7c>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
8013ef3c:	e0bfea17 	ldw	r2,-88(fp)
8013ef40:	10005c1e 	bne	r2,zero,8013f0b4 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8013ef44:	00a005b4 	movhi	r2,32790
8013ef48:	10927b04 	addi	r2,r2,18924
8013ef4c:	1080050b 	ldhu	r2,20(r2)
8013ef50:	10bfffcc 	andi	r2,r2,65535
8013ef54:	1006917a 	slli	r3,r2,5
8013ef58:	00a005b4 	movhi	r2,32790
8013ef5c:	10927b04 	addi	r2,r2,18924
8013ef60:	1080030b 	ldhu	r2,12(r2)
8013ef64:	10bfffcc 	andi	r2,r2,65535
8013ef68:	1885283a 	div	r2,r3,r2
8013ef6c:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8013ef70:	e03ff015 	stw	zero,-64(fp)
8013ef74:	00003b06 	br	8013f064 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8013ef78:	00a005b4 	movhi	r2,32790
8013ef7c:	10927b04 	addi	r2,r2,18924
8013ef80:	10c01317 	ldw	r3,76(r2)
8013ef84:	e0bff017 	ldw	r2,-64(fp)
8013ef88:	1885883a 	add	r2,r3,r2
8013ef8c:	1007883a 	mov	r3,r2
8013ef90:	d0a0ba17 	ldw	r2,-32024(gp)
8013ef94:	100b883a 	mov	r5,r2
8013ef98:	1809883a 	mov	r4,r3
8013ef9c:	013d6640 	call	8013d664 <Read_Sector_Data>
8013efa0:	10003426 	beq	r2,zero,8013f074 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8013efa4:	e03ff115 	stw	zero,-60(fp)
8013efa8:	00002506 	br	8013f040 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8013efac:	e0bff117 	ldw	r2,-60(fp)
8013efb0:	1004917a 	slli	r2,r2,5
8013efb4:	e0fff017 	ldw	r3,-64(fp)
8013efb8:	180f883a 	mov	r7,r3
8013efbc:	000d883a 	mov	r6,zero
8013efc0:	e17fff17 	ldw	r5,-4(fp)
8013efc4:	1009883a 	mov	r4,r2
8013efc8:	013da940 	call	8013da94 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8013efcc:	e0bfff17 	ldw	r2,-4(fp)
8013efd0:	10800003 	ldbu	r2,0(r2)
8013efd4:	10803fcc 	andi	r2,r2,255
8013efd8:	10803960 	cmpeqi	r2,r2,229
8013efdc:	1000151e 	bne	r2,zero,8013f034 <get_home_directory_cluster_for_file+0x268>
8013efe0:	e0bfff17 	ldw	r2,-4(fp)
8013efe4:	10800003 	ldbu	r2,0(r2)
8013efe8:	10803fcc 	andi	r2,r2,255
8013efec:	10001126 	beq	r2,zero,8013f034 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8013eff0:	e0fffb04 	addi	r3,fp,-20
8013eff4:	e0bff904 	addi	r2,fp,-28
8013eff8:	180d883a 	mov	r6,r3
8013effc:	100b883a 	mov	r5,r2
8013f000:	e13fff17 	ldw	r4,-4(fp)
8013f004:	013eb280 	call	8013eb28 <match_file_record_to_name_ext>
8013f008:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8013f00c:	e0bff817 	ldw	r2,-32(fp)
8013f010:	10000826 	beq	r2,zero,8013f034 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
8013f014:	e0bfff17 	ldw	r2,-4(fp)
8013f018:	1080058b 	ldhu	r2,22(r2)
8013f01c:	10bfffcc 	andi	r2,r2,65535
8013f020:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
8013f024:	e0bfff17 	ldw	r2,-4(fp)
8013f028:	00c00044 	movi	r3,1
8013f02c:	10c00a15 	stw	r3,40(r2)
                                break;
8013f030:	00000606 	br	8013f04c <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8013f034:	e0bff117 	ldw	r2,-60(fp)
8013f038:	10800044 	addi	r2,r2,1
8013f03c:	e0bff115 	stw	r2,-60(fp)
8013f040:	e0bff117 	ldw	r2,-60(fp)
8013f044:	10800410 	cmplti	r2,r2,16
8013f048:	103fd81e 	bne	r2,zero,8013efac <__reset+0xfa11efac>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
8013f04c:	e0ffef17 	ldw	r3,-68(fp)
8013f050:	e0bfea17 	ldw	r2,-88(fp)
8013f054:	1880091e 	bne	r3,r2,8013f07c <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8013f058:	e0bff017 	ldw	r2,-64(fp)
8013f05c:	10800044 	addi	r2,r2,1
8013f060:	e0bff015 	stw	r2,-64(fp)
8013f064:	e0fff017 	ldw	r3,-64(fp)
8013f068:	e0bff717 	ldw	r2,-36(fp)
8013f06c:	18bfc216 	blt	r3,r2,8013ef78 <__reset+0xfa11ef78>
8013f070:	00000306 	br	8013f080 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
8013f074:	0001883a 	nop
8013f078:	00000106 	br	8013f080 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
8013f07c:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
8013f080:	e0ffef17 	ldw	r3,-68(fp)
8013f084:	e0bfea17 	ldw	r2,-88(fp)
8013f088:	18800826 	beq	r3,r2,8013f0ac <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8013f08c:	e0bfef17 	ldw	r2,-68(fp)
8013f090:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8013f094:	e0ffed17 	ldw	r3,-76(fp)
8013f098:	e0bfeb17 	ldw	r2,-84(fp)
8013f09c:	1885883a 	add	r2,r3,r2
8013f0a0:	10800044 	addi	r2,r2,1
8013f0a4:	e0bfed15 	stw	r2,-76(fp)
8013f0a8:	00007d06 	br	8013f2a0 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8013f0ac:	0005883a 	mov	r2,zero
8013f0b0:	00009106 	br	8013f2f8 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
8013f0b4:	e0bfea17 	ldw	r2,-88(fp)
8013f0b8:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8013f0bc:	e0bff417 	ldw	r2,-48(fp)
8013f0c0:	10ffff84 	addi	r3,r2,-2
8013f0c4:	00a005b4 	movhi	r2,32790
8013f0c8:	10927b04 	addi	r2,r2,18924
8013f0cc:	10800383 	ldbu	r2,14(r2)
8013f0d0:	10803fcc 	andi	r2,r2,255
8013f0d4:	1885383a 	mul	r2,r3,r2
8013f0d8:	1007883a 	mov	r3,r2
8013f0dc:	00a005b4 	movhi	r2,32790
8013f0e0:	10927b04 	addi	r2,r2,18924
8013f0e4:	10801417 	ldw	r2,80(r2)
8013f0e8:	1885883a 	add	r2,r3,r2
8013f0ec:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8013f0f0:	e03ff215 	stw	zero,-56(fp)
8013f0f4:	00003606 	br	8013f1d0 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8013f0f8:	e0fff217 	ldw	r3,-56(fp)
8013f0fc:	e0bff517 	ldw	r2,-44(fp)
8013f100:	1885883a 	add	r2,r3,r2
8013f104:	d0e0ba17 	ldw	r3,-32024(gp)
8013f108:	180b883a 	mov	r5,r3
8013f10c:	1009883a 	mov	r4,r2
8013f110:	013d6640 	call	8013d664 <Read_Sector_Data>
8013f114:	10003526 	beq	r2,zero,8013f1ec <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8013f118:	e03ff315 	stw	zero,-52(fp)
8013f11c:	00002306 	br	8013f1ac <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8013f120:	e0bff317 	ldw	r2,-52(fp)
8013f124:	1004917a 	slli	r2,r2,5
8013f128:	e0fff417 	ldw	r3,-48(fp)
8013f12c:	e13ff217 	ldw	r4,-56(fp)
8013f130:	200f883a 	mov	r7,r4
8013f134:	180d883a 	mov	r6,r3
8013f138:	e17fff17 	ldw	r5,-4(fp)
8013f13c:	1009883a 	mov	r4,r2
8013f140:	013da940 	call	8013da94 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8013f144:	e0bfff17 	ldw	r2,-4(fp)
8013f148:	10800003 	ldbu	r2,0(r2)
8013f14c:	10803fcc 	andi	r2,r2,255
8013f150:	10803960 	cmpeqi	r2,r2,229
8013f154:	1000121e 	bne	r2,zero,8013f1a0 <get_home_directory_cluster_for_file+0x3d4>
8013f158:	e0bfff17 	ldw	r2,-4(fp)
8013f15c:	10800003 	ldbu	r2,0(r2)
8013f160:	10803fcc 	andi	r2,r2,255
8013f164:	10000e26 	beq	r2,zero,8013f1a0 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8013f168:	e0fffb04 	addi	r3,fp,-20
8013f16c:	e0bff904 	addi	r2,fp,-28
8013f170:	180d883a 	mov	r6,r3
8013f174:	100b883a 	mov	r5,r2
8013f178:	e13fff17 	ldw	r4,-4(fp)
8013f17c:	013eb280 	call	8013eb28 <match_file_record_to_name_ext>
8013f180:	e0bff615 	stw	r2,-40(fp)
                                if (match)
8013f184:	e0bff617 	ldw	r2,-40(fp)
8013f188:	10000526 	beq	r2,zero,8013f1a0 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8013f18c:	e0bfff17 	ldw	r2,-4(fp)
8013f190:	1080058b 	ldhu	r2,22(r2)
8013f194:	10bfffcc 	andi	r2,r2,65535
8013f198:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8013f19c:	00000606 	br	8013f1b8 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8013f1a0:	e0bff317 	ldw	r2,-52(fp)
8013f1a4:	10800044 	addi	r2,r2,1
8013f1a8:	e0bff315 	stw	r2,-52(fp)
8013f1ac:	e0bff317 	ldw	r2,-52(fp)
8013f1b0:	10800410 	cmplti	r2,r2,16
8013f1b4:	103fda1e 	bne	r2,zero,8013f120 <__reset+0xfa11f120>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
8013f1b8:	e0ffef17 	ldw	r3,-68(fp)
8013f1bc:	e0bfea17 	ldw	r2,-88(fp)
8013f1c0:	18800c1e 	bne	r3,r2,8013f1f4 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8013f1c4:	e0bff217 	ldw	r2,-56(fp)
8013f1c8:	10800044 	addi	r2,r2,1
8013f1cc:	e0bff215 	stw	r2,-56(fp)
8013f1d0:	00a005b4 	movhi	r2,32790
8013f1d4:	10927b04 	addi	r2,r2,18924
8013f1d8:	10800383 	ldbu	r2,14(r2)
8013f1dc:	10803fcc 	andi	r2,r2,255
8013f1e0:	e0fff217 	ldw	r3,-56(fp)
8013f1e4:	18bfc416 	blt	r3,r2,8013f0f8 <__reset+0xfa11f0f8>
8013f1e8:	00000306 	br	8013f1f8 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
8013f1ec:	0001883a 	nop
8013f1f0:	00000106 	br	8013f1f8 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
8013f1f4:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
8013f1f8:	e0ffef17 	ldw	r3,-68(fp)
8013f1fc:	e0bfea17 	ldw	r2,-88(fp)
8013f200:	1880141e 	bne	r3,r2,8013f254 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
8013f204:	e0bfef17 	ldw	r2,-68(fp)
8013f208:	e0fffc04 	addi	r3,fp,-16
8013f20c:	180b883a 	mov	r5,r3
8013f210:	1009883a 	mov	r4,r2
8013f214:	013d7440 	call	8013d744 <get_cluster_flag>
8013f218:	10000c26 	beq	r2,zero,8013f24c <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8013f21c:	e0bffc0b 	ldhu	r2,-16(fp)
8013f220:	10bfffcc 	andi	r2,r2,65535
8013f224:	10fffe0c 	andi	r3,r2,65528
8013f228:	00bffe14 	movui	r2,65528
8013f22c:	1880021e 	bne	r3,r2,8013f238 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
8013f230:	0005883a 	mov	r2,zero
8013f234:	00003006 	br	8013f2f8 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
8013f238:	e0bffc0b 	ldhu	r2,-16(fp)
8013f23c:	10bfffcc 	andi	r2,r2,65535
8013f240:	10bffe0c 	andi	r2,r2,65528
8013f244:	e0bfef15 	stw	r2,-68(fp)
8013f248:	00000206 	br	8013f254 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
8013f24c:	0005883a 	mov	r2,zero
8013f250:	00002906 	br	8013f2f8 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8013f254:	e0bff417 	ldw	r2,-48(fp)
8013f258:	00fffdd4 	movui	r3,65527
8013f25c:	18800316 	blt	r3,r2,8013f26c <get_home_directory_cluster_for_file+0x4a0>
8013f260:	e0ffef17 	ldw	r3,-68(fp)
8013f264:	e0bfea17 	ldw	r2,-88(fp)
8013f268:	18bf9426 	beq	r3,r2,8013f0bc <__reset+0xfa11f0bc>
            if (new_cluster != home_dir_cluster)
8013f26c:	e0ffef17 	ldw	r3,-68(fp)
8013f270:	e0bfea17 	ldw	r2,-88(fp)
8013f274:	18800826 	beq	r3,r2,8013f298 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8013f278:	e0bfef17 	ldw	r2,-68(fp)
8013f27c:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8013f280:	e0ffed17 	ldw	r3,-76(fp)
8013f284:	e0bfeb17 	ldw	r2,-84(fp)
8013f288:	1885883a 	add	r2,r3,r2
8013f28c:	10800044 	addi	r2,r2,1
8013f290:	e0bfed15 	stw	r2,-76(fp)
8013f294:	00000206 	br	8013f2a0 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8013f298:	0005883a 	mov	r2,zero
8013f29c:	00001606 	br	8013f2f8 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
8013f2a0:	e0bfed17 	ldw	r2,-76(fp)
8013f2a4:	e0fffd17 	ldw	r3,-12(fp)
8013f2a8:	1885883a 	add	r2,r3,r2
8013f2ac:	1009883a 	mov	r4,r2
8013f2b0:	013ea680 	call	8013ea68 <get_dir_divider_location>
8013f2b4:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
8013f2b8:	e0bfeb17 	ldw	r2,-84(fp)
8013f2bc:	1000020e 	bge	r2,zero,8013f2c8 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
8013f2c0:	00800044 	movi	r2,1
8013f2c4:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
8013f2c8:	e0bfeb17 	ldw	r2,-84(fp)
8013f2cc:	00becf16 	blt	zero,r2,8013ee0c <__reset+0xfa11ee0c>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
8013f2d0:	e0bffe17 	ldw	r2,-8(fp)
8013f2d4:	e0ffea17 	ldw	r3,-88(fp)
8013f2d8:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
8013f2dc:	e0bfea17 	ldw	r2,-88(fp)
8013f2e0:	1000041e 	bne	r2,zero,8013f2f4 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
8013f2e4:	e0bfff17 	ldw	r2,-4(fp)
8013f2e8:	10000a15 	stw	zero,40(r2)
		result = true;
8013f2ec:	00800044 	movi	r2,1
8013f2f0:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
8013f2f4:	e0bfe917 	ldw	r2,-92(fp)
}
8013f2f8:	e037883a 	mov	sp,fp
8013f2fc:	dfc00117 	ldw	ra,4(sp)
8013f300:	df000017 	ldw	fp,0(sp)
8013f304:	dec00204 	addi	sp,sp,8
8013f308:	f800283a 	ret

8013f30c <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
8013f30c:	deffe804 	addi	sp,sp,-96
8013f310:	de00012e 	bgeu	sp,et,8013f318 <find_file_in_directory+0xc>
8013f314:	003b68fa 	trap	3
8013f318:	dfc01715 	stw	ra,92(sp)
8013f31c:	df001615 	stw	fp,88(sp)
8013f320:	df001604 	addi	fp,sp,88
8013f324:	e13ffd15 	stw	r4,-12(fp)
8013f328:	e17ffe15 	stw	r5,-8(fp)
8013f32c:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
8013f330:	e13ffe17 	ldw	r4,-8(fp)
8013f334:	013ea680 	call	8013ea68 <get_dir_divider_location>
8013f338:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
8013f33c:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8013f340:	00800804 	movi	r2,32
8013f344:	e0bff905 	stb	r2,-28(fp)
8013f348:	00800804 	movi	r2,32
8013f34c:	e0bff945 	stb	r2,-27(fp)
8013f350:	00800804 	movi	r2,32
8013f354:	e0bff985 	stb	r2,-26(fp)
8013f358:	00800804 	movi	r2,32
8013f35c:	e0bff9c5 	stb	r2,-25(fp)
8013f360:	00800804 	movi	r2,32
8013f364:	e0bffa05 	stb	r2,-24(fp)
8013f368:	00800804 	movi	r2,32
8013f36c:	e0bffa45 	stb	r2,-23(fp)
8013f370:	00800804 	movi	r2,32
8013f374:	e0bffa85 	stb	r2,-22(fp)
8013f378:	00800804 	movi	r2,32
8013f37c:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
8013f380:	00800804 	movi	r2,32
8013f384:	e0bffb05 	stb	r2,-20(fp)
8013f388:	00800804 	movi	r2,32
8013f38c:	e0bffb45 	stb	r2,-19(fp)
8013f390:	00800804 	movi	r2,32
8013f394:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
8013f398:	00bfffc4 	movi	r2,-1
8013f39c:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
8013f3a0:	e0bffd17 	ldw	r2,-12(fp)
8013f3a4:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
8013f3a8:	e13ffe17 	ldw	r4,-8(fp)
8013f3ac:	01219540 	call	80121954 <strlen>
8013f3b0:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
8013f3b4:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8013f3b8:	00000b06 	br	8013f3e8 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8013f3bc:	e0ffeb17 	ldw	r3,-84(fp)
8013f3c0:	e0bfea17 	ldw	r2,-88(fp)
8013f3c4:	1885883a 	add	r2,r3,r2
8013f3c8:	10800044 	addi	r2,r2,1
8013f3cc:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
8013f3d0:	e0bfeb17 	ldw	r2,-84(fp)
8013f3d4:	e0fffe17 	ldw	r3,-8(fp)
8013f3d8:	1885883a 	add	r2,r3,r2
8013f3dc:	1009883a 	mov	r4,r2
8013f3e0:	013ea680 	call	8013ea68 <get_dir_divider_location>
8013f3e4:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
8013f3e8:	e0bfea17 	ldw	r2,-88(fp)
8013f3ec:	00bff316 	blt	zero,r2,8013f3bc <__reset+0xfa11f3bc>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8013f3f0:	e0bfeb17 	ldw	r2,-84(fp)
8013f3f4:	e0bfee15 	stw	r2,-72(fp)
8013f3f8:	00002706 	br	8013f498 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8013f3fc:	e0bfee17 	ldw	r2,-72(fp)
8013f400:	e0fffe17 	ldw	r3,-8(fp)
8013f404:	1885883a 	add	r2,r3,r2
8013f408:	10800003 	ldbu	r2,0(r2)
8013f40c:	10803fcc 	andi	r2,r2,255
8013f410:	1080201c 	xori	r2,r2,128
8013f414:	10bfe004 	addi	r2,r2,-128
8013f418:	10800b98 	cmpnei	r2,r2,46
8013f41c:	1000031e 	bne	r2,zero,8013f42c <find_file_in_directory+0x120>
        {
            ext_index = index;
8013f420:	e0bfee17 	ldw	r2,-72(fp)
8013f424:	e0bfec15 	stw	r2,-80(fp)
8013f428:	00001806 	br	8013f48c <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
8013f42c:	e0bfec17 	ldw	r2,-80(fp)
8013f430:	10000b0e 	bge	r2,zero,8013f460 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8013f434:	e0ffee17 	ldw	r3,-72(fp)
8013f438:	e0bfeb17 	ldw	r2,-84(fp)
8013f43c:	1885c83a 	sub	r2,r3,r2
8013f440:	e0ffee17 	ldw	r3,-72(fp)
8013f444:	e13ffe17 	ldw	r4,-8(fp)
8013f448:	20c7883a 	add	r3,r4,r3
8013f44c:	18c00003 	ldbu	r3,0(r3)
8013f450:	e13ff904 	addi	r4,fp,-28
8013f454:	2085883a 	add	r2,r4,r2
8013f458:	10c00005 	stb	r3,0(r2)
8013f45c:	00000b06 	br	8013f48c <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8013f460:	e0ffee17 	ldw	r3,-72(fp)
8013f464:	e0bfec17 	ldw	r2,-80(fp)
8013f468:	1885c83a 	sub	r2,r3,r2
8013f46c:	10bfffc4 	addi	r2,r2,-1
8013f470:	e0ffee17 	ldw	r3,-72(fp)
8013f474:	e13ffe17 	ldw	r4,-8(fp)
8013f478:	20c7883a 	add	r3,r4,r3
8013f47c:	18c00003 	ldbu	r3,0(r3)
8013f480:	e13ffb04 	addi	r4,fp,-20
8013f484:	2085883a 	add	r2,r4,r2
8013f488:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8013f48c:	e0bfee17 	ldw	r2,-72(fp)
8013f490:	10800044 	addi	r2,r2,1
8013f494:	e0bfee15 	stw	r2,-72(fp)
8013f498:	e0ffee17 	ldw	r3,-72(fp)
8013f49c:	e0bff417 	ldw	r2,-48(fp)
8013f4a0:	18bfd616 	blt	r3,r2,8013f3fc <__reset+0xfa11f3fc>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8013f4a4:	e0bffd17 	ldw	r2,-12(fp)
8013f4a8:	1000461e 	bne	r2,zero,8013f5c4 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8013f4ac:	00a005b4 	movhi	r2,32790
8013f4b0:	10927b04 	addi	r2,r2,18924
8013f4b4:	1080050b 	ldhu	r2,20(r2)
8013f4b8:	10bfffcc 	andi	r2,r2,65535
8013f4bc:	1006917a 	slli	r3,r2,5
8013f4c0:	00a005b4 	movhi	r2,32790
8013f4c4:	10927b04 	addi	r2,r2,18924
8013f4c8:	1080030b 	ldhu	r2,12(r2)
8013f4cc:	10bfffcc 	andi	r2,r2,65535
8013f4d0:	1885283a 	div	r2,r3,r2
8013f4d4:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8013f4d8:	e03ff015 	stw	zero,-64(fp)
8013f4dc:	00003506 	br	8013f5b4 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8013f4e0:	00a005b4 	movhi	r2,32790
8013f4e4:	10927b04 	addi	r2,r2,18924
8013f4e8:	10c01317 	ldw	r3,76(r2)
8013f4ec:	e0bff017 	ldw	r2,-64(fp)
8013f4f0:	1885883a 	add	r2,r3,r2
8013f4f4:	1007883a 	mov	r3,r2
8013f4f8:	d0a0ba17 	ldw	r2,-32024(gp)
8013f4fc:	100b883a 	mov	r5,r2
8013f500:	1809883a 	mov	r4,r3
8013f504:	013d6640 	call	8013d664 <Read_Sector_Data>
8013f508:	10009626 	beq	r2,zero,8013f764 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8013f50c:	e03ff115 	stw	zero,-60(fp)
8013f510:	00002006 	br	8013f594 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8013f514:	e0bff117 	ldw	r2,-60(fp)
8013f518:	1004917a 	slli	r2,r2,5
8013f51c:	e0fff017 	ldw	r3,-64(fp)
8013f520:	180f883a 	mov	r7,r3
8013f524:	000d883a 	mov	r6,zero
8013f528:	e17fff17 	ldw	r5,-4(fp)
8013f52c:	1009883a 	mov	r4,r2
8013f530:	013da940 	call	8013da94 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8013f534:	e0bfff17 	ldw	r2,-4(fp)
8013f538:	10800003 	ldbu	r2,0(r2)
8013f53c:	10803fcc 	andi	r2,r2,255
8013f540:	10803960 	cmpeqi	r2,r2,229
8013f544:	1000101e 	bne	r2,zero,8013f588 <find_file_in_directory+0x27c>
8013f548:	e0bfff17 	ldw	r2,-4(fp)
8013f54c:	10800003 	ldbu	r2,0(r2)
8013f550:	10803fcc 	andi	r2,r2,255
8013f554:	10000c26 	beq	r2,zero,8013f588 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
8013f558:	e0fffb04 	addi	r3,fp,-20
8013f55c:	e0bff904 	addi	r2,fp,-28
8013f560:	180d883a 	mov	r6,r3
8013f564:	100b883a 	mov	r5,r2
8013f568:	e13fff17 	ldw	r4,-4(fp)
8013f56c:	013eb280 	call	8013eb28 <match_file_record_to_name_ext>
8013f570:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8013f574:	e0bff817 	ldw	r2,-32(fp)
8013f578:	10000326 	beq	r2,zero,8013f588 <find_file_in_directory+0x27c>
                        {
                            result = true;
8013f57c:	00800044 	movi	r2,1
8013f580:	e0bfef15 	stw	r2,-68(fp)
                            break;
8013f584:	00000606 	br	8013f5a0 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8013f588:	e0bff117 	ldw	r2,-60(fp)
8013f58c:	10800044 	addi	r2,r2,1
8013f590:	e0bff115 	stw	r2,-60(fp)
8013f594:	e0bff117 	ldw	r2,-60(fp)
8013f598:	10800410 	cmplti	r2,r2,16
8013f59c:	103fdd1e 	bne	r2,zero,8013f514 <__reset+0xfa11f514>
            }
            else
            {
                break;
            }
            if (result)
8013f5a0:	e0bfef17 	ldw	r2,-68(fp)
8013f5a4:	1000711e 	bne	r2,zero,8013f76c <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8013f5a8:	e0bff017 	ldw	r2,-64(fp)
8013f5ac:	10800044 	addi	r2,r2,1
8013f5b0:	e0bff015 	stw	r2,-64(fp)
8013f5b4:	e0fff017 	ldw	r3,-64(fp)
8013f5b8:	e0bff717 	ldw	r2,-36(fp)
8013f5bc:	18bfc816 	blt	r3,r2,8013f4e0 <__reset+0xfa11f4e0>
8013f5c0:	00006b06 	br	8013f770 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8013f5c4:	e0bfed17 	ldw	r2,-76(fp)
8013f5c8:	10ffff84 	addi	r3,r2,-2
8013f5cc:	00a005b4 	movhi	r2,32790
8013f5d0:	10927b04 	addi	r2,r2,18924
8013f5d4:	10800383 	ldbu	r2,14(r2)
8013f5d8:	10803fcc 	andi	r2,r2,255
8013f5dc:	1885383a 	mul	r2,r3,r2
8013f5e0:	1007883a 	mov	r3,r2
8013f5e4:	00a005b4 	movhi	r2,32790
8013f5e8:	10927b04 	addi	r2,r2,18924
8013f5ec:	10801417 	ldw	r2,80(r2)
8013f5f0:	1885883a 	add	r2,r3,r2
8013f5f4:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8013f5f8:	e03ff215 	stw	zero,-56(fp)
8013f5fc:	00003306 	br	8013f6cc <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8013f600:	e0fff217 	ldw	r3,-56(fp)
8013f604:	e0bff517 	ldw	r2,-44(fp)
8013f608:	1885883a 	add	r2,r3,r2
8013f60c:	d0e0ba17 	ldw	r3,-32024(gp)
8013f610:	180b883a 	mov	r5,r3
8013f614:	1009883a 	mov	r4,r2
8013f618:	013d6640 	call	8013d664 <Read_Sector_Data>
8013f61c:	10003226 	beq	r2,zero,8013f6e8 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8013f620:	e03ff315 	stw	zero,-52(fp)
8013f624:	00002106 	br	8013f6ac <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8013f628:	e0bff317 	ldw	r2,-52(fp)
8013f62c:	1004917a 	slli	r2,r2,5
8013f630:	e0ffed17 	ldw	r3,-76(fp)
8013f634:	e13ff217 	ldw	r4,-56(fp)
8013f638:	200f883a 	mov	r7,r4
8013f63c:	180d883a 	mov	r6,r3
8013f640:	e17fff17 	ldw	r5,-4(fp)
8013f644:	1009883a 	mov	r4,r2
8013f648:	013da940 	call	8013da94 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8013f64c:	e0bfff17 	ldw	r2,-4(fp)
8013f650:	10800003 	ldbu	r2,0(r2)
8013f654:	10803fcc 	andi	r2,r2,255
8013f658:	10803960 	cmpeqi	r2,r2,229
8013f65c:	1000101e 	bne	r2,zero,8013f6a0 <find_file_in_directory+0x394>
8013f660:	e0bfff17 	ldw	r2,-4(fp)
8013f664:	10800003 	ldbu	r2,0(r2)
8013f668:	10803fcc 	andi	r2,r2,255
8013f66c:	10000c26 	beq	r2,zero,8013f6a0 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8013f670:	e0fffb04 	addi	r3,fp,-20
8013f674:	e0bff904 	addi	r2,fp,-28
8013f678:	180d883a 	mov	r6,r3
8013f67c:	100b883a 	mov	r5,r2
8013f680:	e13fff17 	ldw	r4,-4(fp)
8013f684:	013eb280 	call	8013eb28 <match_file_record_to_name_ext>
8013f688:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8013f68c:	e0bff617 	ldw	r2,-40(fp)
8013f690:	10000326 	beq	r2,zero,8013f6a0 <find_file_in_directory+0x394>
                            {                               
                                result = true;
8013f694:	00800044 	movi	r2,1
8013f698:	e0bfef15 	stw	r2,-68(fp)
                                break;
8013f69c:	00000606 	br	8013f6b8 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8013f6a0:	e0bff317 	ldw	r2,-52(fp)
8013f6a4:	10800044 	addi	r2,r2,1
8013f6a8:	e0bff315 	stw	r2,-52(fp)
8013f6ac:	e0bff317 	ldw	r2,-52(fp)
8013f6b0:	10800410 	cmplti	r2,r2,16
8013f6b4:	103fdc1e 	bne	r2,zero,8013f628 <__reset+0xfa11f628>
                }
                else
                {
                    break;
                }
                if (result)
8013f6b8:	e0bfef17 	ldw	r2,-68(fp)
8013f6bc:	10000c1e 	bne	r2,zero,8013f6f0 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8013f6c0:	e0bff217 	ldw	r2,-56(fp)
8013f6c4:	10800044 	addi	r2,r2,1
8013f6c8:	e0bff215 	stw	r2,-56(fp)
8013f6cc:	00a005b4 	movhi	r2,32790
8013f6d0:	10927b04 	addi	r2,r2,18924
8013f6d4:	10800383 	ldbu	r2,14(r2)
8013f6d8:	10803fcc 	andi	r2,r2,255
8013f6dc:	e0fff217 	ldw	r3,-56(fp)
8013f6e0:	18bfc716 	blt	r3,r2,8013f600 <__reset+0xfa11f600>
8013f6e4:	00000306 	br	8013f6f4 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
8013f6e8:	0001883a 	nop
8013f6ec:	00000106 	br	8013f6f4 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8013f6f0:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
8013f6f4:	e0bfef17 	ldw	r2,-68(fp)
8013f6f8:	1000141e 	bne	r2,zero,8013f74c <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8013f6fc:	e0bfed17 	ldw	r2,-76(fp)
8013f700:	e0fffc04 	addi	r3,fp,-16
8013f704:	180b883a 	mov	r5,r3
8013f708:	1009883a 	mov	r4,r2
8013f70c:	013d7440 	call	8013d744 <get_cluster_flag>
8013f710:	10000c26 	beq	r2,zero,8013f744 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8013f714:	e0bffc0b 	ldhu	r2,-16(fp)
8013f718:	10bfffcc 	andi	r2,r2,65535
8013f71c:	10fffe0c 	andi	r3,r2,65528
8013f720:	00bffe14 	movui	r2,65528
8013f724:	1880021e 	bne	r3,r2,8013f730 <find_file_in_directory+0x424>
					{
						return false;
8013f728:	0005883a 	mov	r2,zero
8013f72c:	00001106 	br	8013f774 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8013f730:	e0bffc0b 	ldhu	r2,-16(fp)
8013f734:	10bfffcc 	andi	r2,r2,65535
8013f738:	10bffe0c 	andi	r2,r2,65528
8013f73c:	e0bfed15 	stw	r2,-76(fp)
8013f740:	00000206 	br	8013f74c <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8013f744:	0005883a 	mov	r2,zero
8013f748:	00000a06 	br	8013f774 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8013f74c:	e0bfed17 	ldw	r2,-76(fp)
8013f750:	00fffdd4 	movui	r3,65527
8013f754:	18800616 	blt	r3,r2,8013f770 <find_file_in_directory+0x464>
8013f758:	e0bfef17 	ldw	r2,-68(fp)
8013f75c:	103f9926 	beq	r2,zero,8013f5c4 <__reset+0xfa11f5c4>
8013f760:	00000306 	br	8013f770 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8013f764:	0001883a 	nop
8013f768:	00000106 	br	8013f770 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8013f76c:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8013f770:	e0bfef17 	ldw	r2,-68(fp)
}
8013f774:	e037883a 	mov	sp,fp
8013f778:	dfc00117 	ldw	ra,4(sp)
8013f77c:	df000017 	ldw	fp,0(sp)
8013f780:	dec00204 	addi	sp,sp,8
8013f784:	f800283a 	ret

8013f788 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
8013f788:	defff504 	addi	sp,sp,-44
8013f78c:	de00012e 	bgeu	sp,et,8013f794 <find_first_empty_cluster+0xc>
8013f790:	003b68fa 	trap	3
8013f794:	dfc00a15 	stw	ra,40(sp)
8013f798:	df000915 	stw	fp,36(sp)
8013f79c:	df000904 	addi	fp,sp,36
8013f7a0:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8013f7a4:	00a005b4 	movhi	r2,32790
8013f7a8:	10927b04 	addi	r2,r2,18924
8013f7ac:	10801117 	ldw	r2,68(r2)
8013f7b0:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
8013f7b4:	00800084 	movi	r2,2
8013f7b8:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8013f7bc:	00bfffc4 	movi	r2,-1
8013f7c0:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
8013f7c4:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
8013f7c8:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8013f7cc:	00a005b4 	movhi	r2,32790
8013f7d0:	10927b04 	addi	r2,r2,18924
8013f7d4:	10801417 	ldw	r2,80(r2)
8013f7d8:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8013f7dc:	00a005b4 	movhi	r2,32790
8013f7e0:	10927b04 	addi	r2,r2,18924
8013f7e4:	1080058b 	ldhu	r2,22(r2)
8013f7e8:	10bfffcc 	andi	r2,r2,65535
8013f7ec:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8013f7f0:	00a005b4 	movhi	r2,32790
8013f7f4:	10927b04 	addi	r2,r2,18924
8013f7f8:	10800917 	ldw	r2,36(r2)
8013f7fc:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8013f800:	e0bffd17 	ldw	r2,-12(fp)
8013f804:	e0fffe17 	ldw	r3,-8(fp)
8013f808:	18800b2e 	bgeu	r3,r2,8013f838 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8013f80c:	e0fffd17 	ldw	r3,-12(fp)
8013f810:	e0bffc17 	ldw	r2,-16(fp)
8013f814:	1887c83a 	sub	r3,r3,r2
8013f818:	00a005b4 	movhi	r2,32790
8013f81c:	10927b04 	addi	r2,r2,18924
8013f820:	10800383 	ldbu	r2,14(r2)
8013f824:	10803fcc 	andi	r2,r2,255
8013f828:	1885203a 	divu	r2,r3,r2
8013f82c:	10800044 	addi	r2,r2,1
8013f830:	e0bffb15 	stw	r2,-20(fp)
8013f834:	00002a06 	br	8013f8e0 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8013f838:	e0fffe17 	ldw	r3,-8(fp)
8013f83c:	e0bffc17 	ldw	r2,-16(fp)
8013f840:	1887c83a 	sub	r3,r3,r2
8013f844:	00a005b4 	movhi	r2,32790
8013f848:	10927b04 	addi	r2,r2,18924
8013f84c:	10800383 	ldbu	r2,14(r2)
8013f850:	10803fcc 	andi	r2,r2,255
8013f854:	1885203a 	divu	r2,r3,r2
8013f858:	10800044 	addi	r2,r2,1
8013f85c:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8013f860:	00001f06 	br	8013f8e0 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8013f864:	e0bff717 	ldw	r2,-36(fp)
8013f868:	d0e0ba17 	ldw	r3,-32024(gp)
8013f86c:	180b883a 	mov	r5,r3
8013f870:	1009883a 	mov	r4,r2
8013f874:	013d6640 	call	8013d664 <Read_Sector_Data>
8013f878:	10001426 	beq	r2,zero,8013f8cc <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8013f87c:	e0bff817 	ldw	r2,-32(fp)
8013f880:	10803fcc 	andi	r2,r2,255
8013f884:	1085883a 	add	r2,r2,r2
8013f888:	1007883a 	mov	r3,r2
8013f88c:	d0a0bc17 	ldw	r2,-32016(gp)
8013f890:	10800a17 	ldw	r2,40(r2)
8013f894:	1885883a 	add	r2,r3,r2
8013f898:	1080002b 	ldhuio	r2,0(r2)
8013f89c:	10bfffcc 	andi	r2,r2,65535
8013f8a0:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8013f8a4:	e0bff90f 	ldh	r2,-28(fp)
8013f8a8:	10000726 	beq	r2,zero,8013f8c8 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8013f8ac:	e0bff817 	ldw	r2,-32(fp)
8013f8b0:	10800044 	addi	r2,r2,1
8013f8b4:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
8013f8b8:	e0bff817 	ldw	r2,-32(fp)
8013f8bc:	10803fcc 	andi	r2,r2,255
8013f8c0:	103fee1e 	bne	r2,zero,8013f87c <__reset+0xfa11f87c>
8013f8c4:	00000106 	br	8013f8cc <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
8013f8c8:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8013f8cc:	e0bff90f 	ldh	r2,-28(fp)
8013f8d0:	10000926 	beq	r2,zero,8013f8f8 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
8013f8d4:	e0bff717 	ldw	r2,-36(fp)
8013f8d8:	10800044 	addi	r2,r2,1
8013f8dc:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8013f8e0:	00a005b4 	movhi	r2,32790
8013f8e4:	10927b04 	addi	r2,r2,18924
8013f8e8:	10c01217 	ldw	r3,72(r2)
8013f8ec:	e0bff717 	ldw	r2,-36(fp)
8013f8f0:	18bfdc1e 	bne	r3,r2,8013f864 <__reset+0xfa11f864>
8013f8f4:	00000106 	br	8013f8fc <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
8013f8f8:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8013f8fc:	e0bff90f 	ldh	r2,-28(fp)
8013f900:	1000081e 	bne	r2,zero,8013f924 <find_first_empty_cluster+0x19c>
8013f904:	e0bff90f 	ldh	r2,-28(fp)
8013f908:	e0fffb17 	ldw	r3,-20(fp)
8013f90c:	18800536 	bltu	r3,r2,8013f924 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8013f910:	e0bfff17 	ldw	r2,-4(fp)
8013f914:	e0fff817 	ldw	r3,-32(fp)
8013f918:	10c00015 	stw	r3,0(r2)
		result = true;
8013f91c:	00800044 	movi	r2,1
8013f920:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8013f924:	e0bffa17 	ldw	r2,-24(fp)
}
8013f928:	e037883a 	mov	sp,fp
8013f92c:	dfc00117 	ldw	ra,4(sp)
8013f930:	df000017 	ldw	fp,0(sp)
8013f934:	dec00204 	addi	sp,sp,8
8013f938:	f800283a 	ret

8013f93c <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8013f93c:	defff604 	addi	sp,sp,-40
8013f940:	de00012e 	bgeu	sp,et,8013f948 <find_first_empty_record_in_a_subdirectory+0xc>
8013f944:	003b68fa 	trap	3
8013f948:	dfc00915 	stw	ra,36(sp)
8013f94c:	df000815 	stw	fp,32(sp)
8013f950:	df000804 	addi	fp,sp,32
8013f954:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
8013f958:	00bfffc4 	movi	r2,-1
8013f95c:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8013f960:	e0bfff17 	ldw	r2,-4(fp)
8013f964:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8013f968:	e0bff917 	ldw	r2,-28(fp)
8013f96c:	10ffff84 	addi	r3,r2,-2
8013f970:	00a005b4 	movhi	r2,32790
8013f974:	10927b04 	addi	r2,r2,18924
8013f978:	10800383 	ldbu	r2,14(r2)
8013f97c:	10803fcc 	andi	r2,r2,255
8013f980:	1885383a 	mul	r2,r3,r2
8013f984:	1007883a 	mov	r3,r2
8013f988:	00a005b4 	movhi	r2,32790
8013f98c:	10927b04 	addi	r2,r2,18924
8013f990:	10801417 	ldw	r2,80(r2)
8013f994:	1885883a 	add	r2,r3,r2
8013f998:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8013f99c:	e03ffa15 	stw	zero,-24(fp)
8013f9a0:	00002c06 	br	8013fa54 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8013f9a4:	e0fffa17 	ldw	r3,-24(fp)
8013f9a8:	e0bffc17 	ldw	r2,-16(fp)
8013f9ac:	1885883a 	add	r2,r3,r2
8013f9b0:	d0e0ba17 	ldw	r3,-32024(gp)
8013f9b4:	180b883a 	mov	r5,r3
8013f9b8:	1009883a 	mov	r4,r2
8013f9bc:	013d6640 	call	8013d664 <Read_Sector_Data>
8013f9c0:	10002b26 	beq	r2,zero,8013fa70 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8013f9c4:	e03ffb15 	stw	zero,-20(fp)
8013f9c8:	00001c06 	br	8013fa3c <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8013f9cc:	e0bffb17 	ldw	r2,-20(fp)
8013f9d0:	1004917a 	slli	r2,r2,5
8013f9d4:	1007883a 	mov	r3,r2
8013f9d8:	d0a0bc17 	ldw	r2,-32016(gp)
8013f9dc:	10800a17 	ldw	r2,40(r2)
8013f9e0:	1885883a 	add	r2,r3,r2
8013f9e4:	10800023 	ldbuio	r2,0(r2)
8013f9e8:	10803fcc 	andi	r2,r2,255
8013f9ec:	10803fcc 	andi	r2,r2,255
8013f9f0:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
8013f9f4:	e0bffd0b 	ldhu	r2,-12(fp)
8013f9f8:	10803960 	cmpeqi	r2,r2,229
8013f9fc:	1000021e 	bne	r2,zero,8013fa08 <find_first_empty_record_in_a_subdirectory+0xcc>
8013fa00:	e0bffd0b 	ldhu	r2,-12(fp)
8013fa04:	10000a1e 	bne	r2,zero,8013fa30 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
8013fa08:	e0bffa17 	ldw	r2,-24(fp)
8013fa0c:	1006913a 	slli	r3,r2,4
8013fa10:	e0bffb17 	ldw	r2,-20(fp)
8013fa14:	1885883a 	add	r2,r3,r2
8013fa18:	1006943a 	slli	r3,r2,16
8013fa1c:	e0bff917 	ldw	r2,-28(fp)
8013fa20:	1884b03a 	or	r2,r3,r2
8013fa24:	e0bff815 	stw	r2,-32(fp)
                        return result;
8013fa28:	e0bff817 	ldw	r2,-32(fp)
8013fa2c:	00005306 	br	8013fb7c <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8013fa30:	e0bffb17 	ldw	r2,-20(fp)
8013fa34:	10800044 	addi	r2,r2,1
8013fa38:	e0bffb15 	stw	r2,-20(fp)
8013fa3c:	e0bffb17 	ldw	r2,-20(fp)
8013fa40:	10800410 	cmplti	r2,r2,16
8013fa44:	103fe11e 	bne	r2,zero,8013f9cc <__reset+0xfa11f9cc>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8013fa48:	e0bffa17 	ldw	r2,-24(fp)
8013fa4c:	10800044 	addi	r2,r2,1
8013fa50:	e0bffa15 	stw	r2,-24(fp)
8013fa54:	00a005b4 	movhi	r2,32790
8013fa58:	10927b04 	addi	r2,r2,18924
8013fa5c:	10800383 	ldbu	r2,14(r2)
8013fa60:	10803fcc 	andi	r2,r2,255
8013fa64:	e0fffa17 	ldw	r3,-24(fp)
8013fa68:	18bfce16 	blt	r3,r2,8013f9a4 <__reset+0xfa11f9a4>
8013fa6c:	00000106 	br	8013fa74 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8013fa70:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8013fa74:	e0bff817 	ldw	r2,-32(fp)
8013fa78:	1000390e 	bge	r2,zero,8013fb60 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8013fa7c:	e0bff917 	ldw	r2,-28(fp)
8013fa80:	e0fffd84 	addi	r3,fp,-10
8013fa84:	180b883a 	mov	r5,r3
8013fa88:	1009883a 	mov	r4,r2
8013fa8c:	013d7440 	call	8013d744 <get_cluster_flag>
8013fa90:	10003126 	beq	r2,zero,8013fb58 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8013fa94:	e0bffd8b 	ldhu	r2,-10(fp)
8013fa98:	10bfffcc 	andi	r2,r2,65535
8013fa9c:	10fffe0c 	andi	r3,r2,65528
8013faa0:	00bffe14 	movui	r2,65528
8013faa4:	18802e1e 	bne	r3,r2,8013fb60 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8013faa8:	e0bffe04 	addi	r2,fp,-8
8013faac:	1009883a 	mov	r4,r2
8013fab0:	013f7880 	call	8013f788 <find_first_empty_cluster>
8013fab4:	10002326 	beq	r2,zero,8013fb44 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8013fab8:	e0bff917 	ldw	r2,-28(fp)
8013fabc:	e0fffe17 	ldw	r3,-8(fp)
8013fac0:	18ffffcc 	andi	r3,r3,65535
8013fac4:	18e0001c 	xori	r3,r3,32768
8013fac8:	18e00004 	addi	r3,r3,-32768
8013facc:	01800044 	movi	r6,1
8013fad0:	180b883a 	mov	r5,r3
8013fad4:	1009883a 	mov	r4,r2
8013fad8:	013d8000 	call	8013d800 <mark_cluster>
8013fadc:	10001926 	beq	r2,zero,8013fb44 <find_first_empty_record_in_a_subdirectory+0x208>
8013fae0:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8013fae4:	01800044 	movi	r6,1
8013fae8:	017fffc4 	movi	r5,-1
8013faec:	1009883a 	mov	r4,r2
8013faf0:	013d8000 	call	8013d800 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8013faf4:	10001326 	beq	r2,zero,8013fb44 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8013faf8:	e0bff917 	ldw	r2,-28(fp)
8013fafc:	e0fffe17 	ldw	r3,-8(fp)
8013fb00:	18ffffcc 	andi	r3,r3,65535
8013fb04:	18e0001c 	xori	r3,r3,32768
8013fb08:	18e00004 	addi	r3,r3,-32768
8013fb0c:	000d883a 	mov	r6,zero
8013fb10:	180b883a 	mov	r5,r3
8013fb14:	1009883a 	mov	r4,r2
8013fb18:	013d8000 	call	8013d800 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8013fb1c:	10000926 	beq	r2,zero,8013fb44 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8013fb20:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
8013fb24:	000d883a 	mov	r6,zero
8013fb28:	017fffc4 	movi	r5,-1
8013fb2c:	1009883a 	mov	r4,r2
8013fb30:	013d8000 	call	8013d800 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8013fb34:	10000326 	beq	r2,zero,8013fb44 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
8013fb38:	013d6100 	call	8013d610 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8013fb3c:	e0bffe17 	ldw	r2,-8(fp)
8013fb40:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8013fb44:	e0bffd8b 	ldhu	r2,-10(fp)
8013fb48:	10bfffcc 	andi	r2,r2,65535
8013fb4c:	10bffe0c 	andi	r2,r2,65528
8013fb50:	e0bff915 	stw	r2,-28(fp)
8013fb54:	00000206 	br	8013fb60 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8013fb58:	00bfffc4 	movi	r2,-1
8013fb5c:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8013fb60:	e0bff917 	ldw	r2,-28(fp)
8013fb64:	00fffdd4 	movui	r3,65527
8013fb68:	18800316 	blt	r3,r2,8013fb78 <find_first_empty_record_in_a_subdirectory+0x23c>
8013fb6c:	e0bff817 	ldw	r2,-32(fp)
8013fb70:	10bfffe0 	cmpeqi	r2,r2,-1
8013fb74:	103f7c1e 	bne	r2,zero,8013f968 <__reset+0xfa11f968>
    return result; 
8013fb78:	e0bff817 	ldw	r2,-32(fp)
}
8013fb7c:	e037883a 	mov	sp,fp
8013fb80:	dfc00117 	ldw	ra,4(sp)
8013fb84:	df000017 	ldw	fp,0(sp)
8013fb88:	dec00204 	addi	sp,sp,8
8013fb8c:	f800283a 	ret

8013fb90 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
8013fb90:	defff904 	addi	sp,sp,-28
8013fb94:	de00012e 	bgeu	sp,et,8013fb9c <find_first_empty_record_in_root_directory+0xc>
8013fb98:	003b68fa 	trap	3
8013fb9c:	dfc00615 	stw	ra,24(sp)
8013fba0:	df000515 	stw	fp,20(sp)
8013fba4:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8013fba8:	00a005b4 	movhi	r2,32790
8013fbac:	10927b04 	addi	r2,r2,18924
8013fbb0:	1080050b 	ldhu	r2,20(r2)
8013fbb4:	10bfffcc 	andi	r2,r2,65535
8013fbb8:	1006917a 	slli	r3,r2,5
8013fbbc:	00a005b4 	movhi	r2,32790
8013fbc0:	10927b04 	addi	r2,r2,18924
8013fbc4:	1080030b 	ldhu	r2,12(r2)
8013fbc8:	10bfffcc 	andi	r2,r2,65535
8013fbcc:	1885283a 	div	r2,r3,r2
8013fbd0:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
8013fbd4:	00bfffc4 	movi	r2,-1
8013fbd8:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8013fbdc:	e03ffb15 	stw	zero,-20(fp)
8013fbe0:	00002d06 	br	8013fc98 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8013fbe4:	00a005b4 	movhi	r2,32790
8013fbe8:	10927b04 	addi	r2,r2,18924
8013fbec:	10c01317 	ldw	r3,76(r2)
8013fbf0:	e0bffb17 	ldw	r2,-20(fp)
8013fbf4:	1885883a 	add	r2,r3,r2
8013fbf8:	1007883a 	mov	r3,r2
8013fbfc:	d0a0ba17 	ldw	r2,-32024(gp)
8013fc00:	100b883a 	mov	r5,r2
8013fc04:	1809883a 	mov	r4,r3
8013fc08:	013d6640 	call	8013d664 <Read_Sector_Data>
8013fc0c:	10002626 	beq	r2,zero,8013fca8 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8013fc10:	e03ffc15 	stw	zero,-16(fp)
8013fc14:	00001a06 	br	8013fc80 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8013fc18:	e0bffc17 	ldw	r2,-16(fp)
8013fc1c:	1004917a 	slli	r2,r2,5
8013fc20:	1007883a 	mov	r3,r2
8013fc24:	d0a0bc17 	ldw	r2,-32016(gp)
8013fc28:	10800a17 	ldw	r2,40(r2)
8013fc2c:	1885883a 	add	r2,r3,r2
8013fc30:	10800023 	ldbuio	r2,0(r2)
8013fc34:	10803fcc 	andi	r2,r2,255
8013fc38:	10803fcc 	andi	r2,r2,255
8013fc3c:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8013fc40:	e0bfff0b 	ldhu	r2,-4(fp)
8013fc44:	10803960 	cmpeqi	r2,r2,229
8013fc48:	1000021e 	bne	r2,zero,8013fc54 <find_first_empty_record_in_root_directory+0xc4>
8013fc4c:	e0bfff0b 	ldhu	r2,-4(fp)
8013fc50:	1000081e 	bne	r2,zero,8013fc74 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
8013fc54:	e0bffb17 	ldw	r2,-20(fp)
8013fc58:	1006913a 	slli	r3,r2,4
8013fc5c:	e0bffc17 	ldw	r2,-16(fp)
8013fc60:	1885883a 	add	r2,r3,r2
8013fc64:	1004943a 	slli	r2,r2,16
8013fc68:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8013fc6c:	e0bffe17 	ldw	r2,-8(fp)
8013fc70:	00000f06 	br	8013fcb0 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8013fc74:	e0bffc17 	ldw	r2,-16(fp)
8013fc78:	10800044 	addi	r2,r2,1
8013fc7c:	e0bffc15 	stw	r2,-16(fp)
8013fc80:	e0bffc17 	ldw	r2,-16(fp)
8013fc84:	10800410 	cmplti	r2,r2,16
8013fc88:	103fe31e 	bne	r2,zero,8013fc18 <__reset+0xfa11fc18>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8013fc8c:	e0bffb17 	ldw	r2,-20(fp)
8013fc90:	10800044 	addi	r2,r2,1
8013fc94:	e0bffb15 	stw	r2,-20(fp)
8013fc98:	e0fffb17 	ldw	r3,-20(fp)
8013fc9c:	e0bffd17 	ldw	r2,-12(fp)
8013fca0:	18bfd016 	blt	r3,r2,8013fbe4 <__reset+0xfa11fbe4>
8013fca4:	00000106 	br	8013fcac <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8013fca8:	0001883a 	nop
        }
    }
    return result;
8013fcac:	e0bffe17 	ldw	r2,-8(fp)
}
8013fcb0:	e037883a 	mov	sp,fp
8013fcb4:	dfc00117 	ldw	ra,4(sp)
8013fcb8:	df000017 	ldw	fp,0(sp)
8013fcbc:	dec00204 	addi	sp,sp,8
8013fcc0:	f800283a 	ret

8013fcc4 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
8013fcc4:	defffa04 	addi	sp,sp,-24
8013fcc8:	de00012e 	bgeu	sp,et,8013fcd0 <convert_filename_to_name_extension+0xc>
8013fccc:	003b68fa 	trap	3
8013fcd0:	df000515 	stw	fp,20(sp)
8013fcd4:	df000504 	addi	fp,sp,20
8013fcd8:	e13ffd15 	stw	r4,-12(fp)
8013fcdc:	e17ffe15 	stw	r5,-8(fp)
8013fce0:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
8013fce4:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
8013fce8:	e03ffb15 	stw	zero,-20(fp)
8013fcec:	00002506 	br	8013fd84 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8013fcf0:	e0bffc17 	ldw	r2,-16(fp)
8013fcf4:	e0fffd17 	ldw	r3,-12(fp)
8013fcf8:	1885883a 	add	r2,r3,r2
8013fcfc:	10800003 	ldbu	r2,0(r2)
8013fd00:	10803fcc 	andi	r2,r2,255
8013fd04:	1080201c 	xori	r2,r2,128
8013fd08:	10bfe004 	addi	r2,r2,-128
8013fd0c:	10800ba0 	cmpeqi	r2,r2,46
8013fd10:	1000141e 	bne	r2,zero,8013fd64 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
8013fd14:	e0bffb17 	ldw	r2,-20(fp)
8013fd18:	e0fffe17 	ldw	r3,-8(fp)
8013fd1c:	1885883a 	add	r2,r3,r2
8013fd20:	e0fffc17 	ldw	r3,-16(fp)
8013fd24:	e13ffd17 	ldw	r4,-12(fp)
8013fd28:	20c7883a 	add	r3,r4,r3
8013fd2c:	18c00003 	ldbu	r3,0(r3)
8013fd30:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
8013fd34:	e0bffc17 	ldw	r2,-16(fp)
8013fd38:	e0fffd17 	ldw	r3,-12(fp)
8013fd3c:	1885883a 	add	r2,r3,r2
8013fd40:	10800003 	ldbu	r2,0(r2)
8013fd44:	10803fcc 	andi	r2,r2,255
8013fd48:	1080201c 	xori	r2,r2,128
8013fd4c:	10bfe004 	addi	r2,r2,-128
8013fd50:	10000926 	beq	r2,zero,8013fd78 <convert_filename_to_name_extension+0xb4>
8013fd54:	e0bffc17 	ldw	r2,-16(fp)
8013fd58:	10800044 	addi	r2,r2,1
8013fd5c:	e0bffc15 	stw	r2,-16(fp)
8013fd60:	00000506 	br	8013fd78 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
8013fd64:	e0bffb17 	ldw	r2,-20(fp)
8013fd68:	e0fffe17 	ldw	r3,-8(fp)
8013fd6c:	1885883a 	add	r2,r3,r2
8013fd70:	00c00804 	movi	r3,32
8013fd74:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
8013fd78:	e0bffb17 	ldw	r2,-20(fp)
8013fd7c:	10800044 	addi	r2,r2,1
8013fd80:	e0bffb15 	stw	r2,-20(fp)
8013fd84:	e0bffb17 	ldw	r2,-20(fp)
8013fd88:	10800210 	cmplti	r2,r2,8
8013fd8c:	103fd81e 	bne	r2,zero,8013fcf0 <__reset+0xfa11fcf0>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
8013fd90:	e0bffc17 	ldw	r2,-16(fp)
8013fd94:	e0fffd17 	ldw	r3,-12(fp)
8013fd98:	1885883a 	add	r2,r3,r2
8013fd9c:	10800003 	ldbu	r2,0(r2)
8013fda0:	10803fcc 	andi	r2,r2,255
8013fda4:	1080201c 	xori	r2,r2,128
8013fda8:	10bfe004 	addi	r2,r2,-128
8013fdac:	10800b98 	cmpnei	r2,r2,46
8013fdb0:	1000031e 	bne	r2,zero,8013fdc0 <convert_filename_to_name_extension+0xfc>
8013fdb4:	e0bffc17 	ldw	r2,-16(fp)
8013fdb8:	10800044 	addi	r2,r2,1
8013fdbc:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
8013fdc0:	e03ffb15 	stw	zero,-20(fp)
8013fdc4:	00001c06 	br	8013fe38 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
8013fdc8:	e0bffc17 	ldw	r2,-16(fp)
8013fdcc:	e0fffd17 	ldw	r3,-12(fp)
8013fdd0:	1885883a 	add	r2,r3,r2
8013fdd4:	10800003 	ldbu	r2,0(r2)
8013fdd8:	10803fcc 	andi	r2,r2,255
8013fddc:	1080201c 	xori	r2,r2,128
8013fde0:	10bfe004 	addi	r2,r2,-128
8013fde4:	10000c26 	beq	r2,zero,8013fe18 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
8013fde8:	e0bffb17 	ldw	r2,-20(fp)
8013fdec:	e0ffff17 	ldw	r3,-4(fp)
8013fdf0:	1885883a 	add	r2,r3,r2
8013fdf4:	e0fffc17 	ldw	r3,-16(fp)
8013fdf8:	e13ffd17 	ldw	r4,-12(fp)
8013fdfc:	20c7883a 	add	r3,r4,r3
8013fe00:	18c00003 	ldbu	r3,0(r3)
8013fe04:	10c00005 	stb	r3,0(r2)
            local++;
8013fe08:	e0bffc17 	ldw	r2,-16(fp)
8013fe0c:	10800044 	addi	r2,r2,1
8013fe10:	e0bffc15 	stw	r2,-16(fp)
8013fe14:	00000506 	br	8013fe2c <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
8013fe18:	e0bffb17 	ldw	r2,-20(fp)
8013fe1c:	e0ffff17 	ldw	r3,-4(fp)
8013fe20:	1885883a 	add	r2,r3,r2
8013fe24:	00c00804 	movi	r3,32
8013fe28:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
8013fe2c:	e0bffb17 	ldw	r2,-20(fp)
8013fe30:	10800044 	addi	r2,r2,1
8013fe34:	e0bffb15 	stw	r2,-20(fp)
8013fe38:	e0bffb17 	ldw	r2,-20(fp)
8013fe3c:	108000d0 	cmplti	r2,r2,3
8013fe40:	103fe11e 	bne	r2,zero,8013fdc8 <__reset+0xfa11fdc8>
        {
            extension[counter] = ' ';
        }
    }

}
8013fe44:	0001883a 	nop
8013fe48:	e037883a 	mov	sp,fp
8013fe4c:	df000017 	ldw	fp,0(sp)
8013fe50:	dec00104 	addi	sp,sp,4
8013fe54:	f800283a 	ret

8013fe58 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
8013fe58:	defff504 	addi	sp,sp,-44
8013fe5c:	de00012e 	bgeu	sp,et,8013fe64 <create_file+0xc>
8013fe60:	003b68fa 	trap	3
8013fe64:	dfc00a15 	stw	ra,40(sp)
8013fe68:	df000915 	stw	fp,36(sp)
8013fe6c:	df000904 	addi	fp,sp,36
8013fe70:	e13ffd15 	stw	r4,-12(fp)
8013fe74:	e17ffe15 	stw	r5,-8(fp)
8013fe78:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
8013fe7c:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
8013fe80:	e0bffc04 	addi	r2,fp,-16
8013fe84:	1009883a 	mov	r4,r2
8013fe88:	013f7880 	call	8013f788 <find_first_empty_cluster>
8013fe8c:	1000a026 	beq	r2,zero,80140110 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
8013fe90:	e0bfff17 	ldw	r2,-4(fp)
8013fe94:	10800a17 	ldw	r2,40(r2)
8013fe98:	1000031e 	bne	r2,zero,8013fea8 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
8013fe9c:	013fb900 	call	8013fb90 <find_first_empty_record_in_root_directory>
8013fea0:	e0bff815 	stw	r2,-32(fp)
8013fea4:	00000606 	br	8013fec0 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
8013fea8:	e0bfff17 	ldw	r2,-4(fp)
8013feac:	1080058b 	ldhu	r2,22(r2)
8013feb0:	10bfffcc 	andi	r2,r2,65535
8013feb4:	1009883a 	mov	r4,r2
8013feb8:	013f93c0 	call	8013f93c <find_first_empty_record_in_a_subdirectory>
8013febc:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
8013fec0:	e0bff817 	ldw	r2,-32(fp)
8013fec4:	10009216 	blt	r2,zero,80140110 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
8013fec8:	e13ffd17 	ldw	r4,-12(fp)
8013fecc:	013ea680 	call	8013ea68 <get_dir_divider_location>
8013fed0:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
8013fed4:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
8013fed8:	00000b06 	br	8013ff08 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8013fedc:	e0fffa17 	ldw	r3,-24(fp)
8013fee0:	e0bff917 	ldw	r2,-28(fp)
8013fee4:	1885883a 	add	r2,r3,r2
8013fee8:	10800044 	addi	r2,r2,1
8013feec:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
8013fef0:	e0bffa17 	ldw	r2,-24(fp)
8013fef4:	e0fffd17 	ldw	r3,-12(fp)
8013fef8:	1885883a 	add	r2,r3,r2
8013fefc:	1009883a 	mov	r4,r2
8013ff00:	013ea680 	call	8013ea68 <get_dir_divider_location>
8013ff04:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
8013ff08:	e0bff917 	ldw	r2,-28(fp)
8013ff0c:	00bff316 	blt	zero,r2,8013fedc <__reset+0xfa11fedc>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
8013ff10:	e0bffa17 	ldw	r2,-24(fp)
8013ff14:	e0fffd17 	ldw	r3,-12(fp)
8013ff18:	1887883a 	add	r3,r3,r2
8013ff1c:	e13ffe17 	ldw	r4,-8(fp)
8013ff20:	e0bffe17 	ldw	r2,-8(fp)
8013ff24:	10800204 	addi	r2,r2,8
8013ff28:	100d883a 	mov	r6,r2
8013ff2c:	200b883a 	mov	r5,r4
8013ff30:	1809883a 	mov	r4,r3
8013ff34:	013fcc40 	call	8013fcc4 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
8013ff38:	e0bffe17 	ldw	r2,-8(fp)
8013ff3c:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
8013ff40:	e0bffe17 	ldw	r2,-8(fp)
8013ff44:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
8013ff48:	e0bffe17 	ldw	r2,-8(fp)
8013ff4c:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
8013ff50:	e0bffe17 	ldw	r2,-8(fp)
8013ff54:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
8013ff58:	e0bffe17 	ldw	r2,-8(fp)
8013ff5c:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
8013ff60:	e0bffe17 	ldw	r2,-8(fp)
8013ff64:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
8013ff68:	e0bffc17 	ldw	r2,-16(fp)
8013ff6c:	1007883a 	mov	r3,r2
8013ff70:	e0bffe17 	ldw	r2,-8(fp)
8013ff74:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
8013ff78:	e0bffe17 	ldw	r2,-8(fp)
8013ff7c:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
8013ff80:	e0fffc17 	ldw	r3,-16(fp)
8013ff84:	e0bffe17 	ldw	r2,-8(fp)
8013ff88:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
8013ff8c:	e0bffe17 	ldw	r2,-8(fp)
8013ff90:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
8013ff94:	e0bffe17 	ldw	r2,-8(fp)
8013ff98:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
8013ff9c:	e0bff817 	ldw	r2,-32(fp)
8013ffa0:	10ffffcc 	andi	r3,r2,65535
8013ffa4:	e0bffe17 	ldw	r2,-8(fp)
8013ffa8:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8013ffac:	e0bff817 	ldw	r2,-32(fp)
8013ffb0:	1004d43a 	srli	r2,r2,16
8013ffb4:	1000010e 	bge	r2,zero,8013ffbc <create_file+0x164>
8013ffb8:	108003c4 	addi	r2,r2,15
8013ffbc:	1005d13a 	srai	r2,r2,4
8013ffc0:	1007883a 	mov	r3,r2
8013ffc4:	e0bffe17 	ldw	r2,-8(fp)
8013ffc8:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8013ffcc:	e0bff817 	ldw	r2,-32(fp)
8013ffd0:	1004d43a 	srli	r2,r2,16
8013ffd4:	1007883a 	mov	r3,r2
8013ffd8:	00a00034 	movhi	r2,32768
8013ffdc:	108003c4 	addi	r2,r2,15
8013ffe0:	1884703a 	and	r2,r3,r2
8013ffe4:	1000040e 	bge	r2,zero,8013fff8 <create_file+0x1a0>
8013ffe8:	10bfffc4 	addi	r2,r2,-1
8013ffec:	00fffc04 	movi	r3,-16
8013fff0:	10c4b03a 	or	r2,r2,r3
8013fff4:	10800044 	addi	r2,r2,1
8013fff8:	1004917a 	slli	r2,r2,5
8013fffc:	1007883a 	mov	r3,r2
80140000:	e0bffe17 	ldw	r2,-8(fp)
80140004:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
80140008:	e0bfff17 	ldw	r2,-4(fp)
8014000c:	1080058b 	ldhu	r2,22(r2)
80140010:	10ffffcc 	andi	r3,r2,65535
80140014:	e0bffe17 	ldw	r2,-8(fp)
80140018:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
8014001c:	e0bffe17 	ldw	r2,-8(fp)
80140020:	00c00044 	movi	r3,1
80140024:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
80140028:	e0bffe17 	ldw	r2,-8(fp)
8014002c:	00c00044 	movi	r3,1
80140030:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
80140034:	e0bffe17 	ldw	r2,-8(fp)
80140038:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8014003c:	1000071e 	bne	r2,zero,8014005c <create_file+0x204>
80140040:	00a005b4 	movhi	r2,32790
80140044:	10927b04 	addi	r2,r2,18924
80140048:	10c01317 	ldw	r3,76(r2)
8014004c:	e0bffe17 	ldw	r2,-8(fp)
80140050:	10800b17 	ldw	r2,44(r2)
80140054:	1885883a 	add	r2,r3,r2
80140058:	00000f06 	br	80140098 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
8014005c:	00a005b4 	movhi	r2,32790
80140060:	10927b04 	addi	r2,r2,18924
80140064:	10c01417 	ldw	r3,80(r2)
80140068:	e0bffe17 	ldw	r2,-8(fp)
8014006c:	10800a17 	ldw	r2,40(r2)
80140070:	113fff84 	addi	r4,r2,-2
80140074:	00a005b4 	movhi	r2,32790
80140078:	10927b04 	addi	r2,r2,18924
8014007c:	10800383 	ldbu	r2,14(r2)
80140080:	10803fcc 	andi	r2,r2,255
80140084:	2085383a 	mul	r2,r4,r2
80140088:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
8014008c:	e0bffe17 	ldw	r2,-8(fp)
80140090:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
80140094:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
80140098:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
8014009c:	e0bffb17 	ldw	r2,-20(fp)
801400a0:	d0e0ba17 	ldw	r3,-32024(gp)
801400a4:	180b883a 	mov	r5,r3
801400a8:	1009883a 	mov	r4,r2
801400ac:	013d6640 	call	8013d664 <Read_Sector_Data>
801400b0:	10001726 	beq	r2,zero,80140110 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
801400b4:	e0bffe17 	ldw	r2,-8(fp)
801400b8:	10800c0b 	ldhu	r2,48(r2)
801400bc:	10bfffcc 	andi	r2,r2,65535
801400c0:	10a0001c 	xori	r2,r2,32768
801400c4:	10a00004 	addi	r2,r2,-32768
801400c8:	e17ffe17 	ldw	r5,-8(fp)
801400cc:	1009883a 	mov	r4,r2
801400d0:	013dd180 	call	8013dd18 <Write_File_Record_At_Offset>
801400d4:	10000e26 	beq	r2,zero,80140110 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
801400d8:	013d6100 	call	8013d610 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
801400dc:	e0bffc17 	ldw	r2,-16(fp)
801400e0:	01800044 	movi	r6,1
801400e4:	017fffc4 	movi	r5,-1
801400e8:	1009883a 	mov	r4,r2
801400ec:	013d8000 	call	8013d800 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
801400f0:	e0bffc17 	ldw	r2,-16(fp)
801400f4:	000d883a 	mov	r6,zero
801400f8:	017fffc4 	movi	r5,-1
801400fc:	1009883a 	mov	r4,r2
80140100:	013d8000 	call	8013d800 <mark_cluster>
80140104:	10000226 	beq	r2,zero,80140110 <create_file+0x2b8>
                    {
                        result = true;
80140108:	00800044 	movi	r2,1
8014010c:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
80140110:	e0bff717 	ldw	r2,-36(fp)
}
80140114:	e037883a 	mov	sp,fp
80140118:	dfc00117 	ldw	ra,4(sp)
8014011c:	df000017 	ldw	fp,0(sp)
80140120:	dec00204 	addi	sp,sp,8
80140124:	f800283a 	ret

80140128 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
80140128:	defffb04 	addi	sp,sp,-20
8014012c:	de00012e 	bgeu	sp,et,80140134 <copy_file_record_name_to_string+0xc>
80140130:	003b68fa 	trap	3
80140134:	df000415 	stw	fp,16(sp)
80140138:	df000404 	addi	fp,sp,16
8014013c:	e13ffe15 	stw	r4,-8(fp)
80140140:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
80140144:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
80140148:	e03ffc15 	stw	zero,-16(fp)
8014014c:	00001506 	br	801401a4 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
80140150:	e0fffe17 	ldw	r3,-8(fp)
80140154:	e0bffc17 	ldw	r2,-16(fp)
80140158:	1885883a 	add	r2,r3,r2
8014015c:	10800003 	ldbu	r2,0(r2)
80140160:	10803fcc 	andi	r2,r2,255
80140164:	10800820 	cmpeqi	r2,r2,32
80140168:	10000b1e 	bne	r2,zero,80140198 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
8014016c:	e0bffd17 	ldw	r2,-12(fp)
80140170:	e0ffff17 	ldw	r3,-4(fp)
80140174:	1885883a 	add	r2,r3,r2
80140178:	e13ffe17 	ldw	r4,-8(fp)
8014017c:	e0fffc17 	ldw	r3,-16(fp)
80140180:	20c7883a 	add	r3,r4,r3
80140184:	18c00003 	ldbu	r3,0(r3)
80140188:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
8014018c:	e0bffd17 	ldw	r2,-12(fp)
80140190:	10800044 	addi	r2,r2,1
80140194:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
80140198:	e0bffc17 	ldw	r2,-16(fp)
8014019c:	10800044 	addi	r2,r2,1
801401a0:	e0bffc15 	stw	r2,-16(fp)
801401a4:	e0bffc17 	ldw	r2,-16(fp)
801401a8:	10800210 	cmplti	r2,r2,8
801401ac:	103fe81e 	bne	r2,zero,80140150 <__reset+0xfa120150>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
801401b0:	e0bffe17 	ldw	r2,-8(fp)
801401b4:	10800203 	ldbu	r2,8(r2)
801401b8:	10803fcc 	andi	r2,r2,255
801401bc:	10800820 	cmpeqi	r2,r2,32
801401c0:	1000241e 	bne	r2,zero,80140254 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
801401c4:	e0bffd17 	ldw	r2,-12(fp)
801401c8:	e0ffff17 	ldw	r3,-4(fp)
801401cc:	1885883a 	add	r2,r3,r2
801401d0:	00c00b84 	movi	r3,46
801401d4:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
801401d8:	e0bffd17 	ldw	r2,-12(fp)
801401dc:	10800044 	addi	r2,r2,1
801401e0:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
801401e4:	e03ffc15 	stw	zero,-16(fp)
801401e8:	00001706 	br	80140248 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
801401ec:	e0fffe17 	ldw	r3,-8(fp)
801401f0:	e0bffc17 	ldw	r2,-16(fp)
801401f4:	1885883a 	add	r2,r3,r2
801401f8:	10800204 	addi	r2,r2,8
801401fc:	10800003 	ldbu	r2,0(r2)
80140200:	10803fcc 	andi	r2,r2,255
80140204:	10800820 	cmpeqi	r2,r2,32
80140208:	10000c1e 	bne	r2,zero,8014023c <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
8014020c:	e0bffd17 	ldw	r2,-12(fp)
80140210:	e0ffff17 	ldw	r3,-4(fp)
80140214:	1885883a 	add	r2,r3,r2
80140218:	e13ffe17 	ldw	r4,-8(fp)
8014021c:	e0fffc17 	ldw	r3,-16(fp)
80140220:	20c7883a 	add	r3,r4,r3
80140224:	18c00204 	addi	r3,r3,8
80140228:	18c00003 	ldbu	r3,0(r3)
8014022c:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
80140230:	e0bffd17 	ldw	r2,-12(fp)
80140234:	10800044 	addi	r2,r2,1
80140238:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
8014023c:	e0bffc17 	ldw	r2,-16(fp)
80140240:	10800044 	addi	r2,r2,1
80140244:	e0bffc15 	stw	r2,-16(fp)
80140248:	e0bffc17 	ldw	r2,-16(fp)
8014024c:	108000d0 	cmplti	r2,r2,3
80140250:	103fe61e 	bne	r2,zero,801401ec <__reset+0xfa1201ec>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
80140254:	e0bffd17 	ldw	r2,-12(fp)
80140258:	e0ffff17 	ldw	r3,-4(fp)
8014025c:	1885883a 	add	r2,r3,r2
80140260:	10000005 	stb	zero,0(r2)
}
80140264:	0001883a 	nop
80140268:	e037883a 	mov	sp,fp
8014026c:	df000017 	ldw	fp,0(sp)
80140270:	dec00104 	addi	sp,sp,4
80140274:	f800283a 	ret

80140278 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
80140278:	defffc04 	addi	sp,sp,-16
8014027c:	de00012e 	bgeu	sp,et,80140284 <alt_up_sd_card_open_dev+0xc>
80140280:	003b68fa 	trap	3
80140284:	dfc00315 	stw	ra,12(sp)
80140288:	df000215 	stw	fp,8(sp)
8014028c:	df000204 	addi	fp,sp,8
80140290:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
80140294:	d1600c04 	addi	r5,gp,-32720
80140298:	e13fff17 	ldw	r4,-4(fp)
8014029c:	01457340 	call	80145734 <alt_find_dev>
801402a0:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
801402a4:	e0bffe17 	ldw	r2,-8(fp)
801402a8:	10001e26 	beq	r2,zero,80140324 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
801402ac:	e0bffe17 	ldw	r2,-8(fp)
801402b0:	10800a17 	ldw	r2,40(r2)
801402b4:	10808d04 	addi	r2,r2,564
801402b8:	d0a0b415 	stw	r2,-32048(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
801402bc:	e0bffe17 	ldw	r2,-8(fp)
801402c0:	10800a17 	ldw	r2,40(r2)
801402c4:	10808904 	addi	r2,r2,548
801402c8:	d0a0b515 	stw	r2,-32044(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
801402cc:	e0bffe17 	ldw	r2,-8(fp)
801402d0:	10800a17 	ldw	r2,40(r2)
801402d4:	10808404 	addi	r2,r2,528
801402d8:	d0a0b615 	stw	r2,-32040(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
801402dc:	e0bffe17 	ldw	r2,-8(fp)
801402e0:	10800a17 	ldw	r2,40(r2)
801402e4:	10808c04 	addi	r2,r2,560
801402e8:	d0a0b715 	stw	r2,-32036(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
801402ec:	e0bffe17 	ldw	r2,-8(fp)
801402f0:	10800a17 	ldw	r2,40(r2)
801402f4:	10808b04 	addi	r2,r2,556
801402f8:	d0a0b815 	stw	r2,-32032(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
801402fc:	e0bffe17 	ldw	r2,-8(fp)
80140300:	10800a17 	ldw	r2,40(r2)
80140304:	d0a0b915 	stw	r2,-32028(gp)
		device_pointer = dev;
80140308:	e0bffe17 	ldw	r2,-8(fp)
8014030c:	d0a0bc15 	stw	r2,-32016(gp)
		initialized = false;
80140310:	d020b215 	stw	zero,-32056(gp)
		is_sd_card_formated_as_FAT16 = false;
80140314:	d020b315 	stw	zero,-32052(gp)
		search_data.valid = false;
80140318:	00a005b4 	movhi	r2,32790
8014031c:	10927604 	addi	r2,r2,18904
80140320:	10000415 	stw	zero,16(r2)
	}
	return dev;
80140324:	e0bffe17 	ldw	r2,-8(fp)
}
80140328:	e037883a 	mov	sp,fp
8014032c:	dfc00117 	ldw	ra,4(sp)
80140330:	df000017 	ldw	fp,0(sp)
80140334:	dec00204 	addi	sp,sp,8
80140338:	f800283a 	ret

8014033c <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
8014033c:	defffd04 	addi	sp,sp,-12
80140340:	de00012e 	bgeu	sp,et,80140348 <alt_up_sd_card_is_Present+0xc>
80140344:	003b68fa 	trap	3
80140348:	df000215 	stw	fp,8(sp)
8014034c:	df000204 	addi	fp,sp,8
    bool result = false;
80140350:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
80140354:	d0a0bc17 	ldw	r2,-32016(gp)
80140358:	10000826 	beq	r2,zero,8014037c <alt_up_sd_card_is_Present+0x40>
8014035c:	d0a0b417 	ldw	r2,-32048(gp)
80140360:	1080002b 	ldhuio	r2,0(r2)
80140364:	10bfffcc 	andi	r2,r2,65535
80140368:	1080008c 	andi	r2,r2,2
8014036c:	10000326 	beq	r2,zero,8014037c <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
80140370:	00800044 	movi	r2,1
80140374:	e0bffe15 	stw	r2,-8(fp)
80140378:	00001e06 	br	801403f4 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
8014037c:	d0a0b217 	ldw	r2,-32056(gp)
80140380:	10800058 	cmpnei	r2,r2,1
80140384:	10001b1e 	bne	r2,zero,801403f4 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
80140388:	d020b215 	stw	zero,-32056(gp)
		search_data.valid = false;
8014038c:	00a005b4 	movhi	r2,32790
80140390:	10927604 	addi	r2,r2,18904
80140394:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
80140398:	d020b315 	stw	zero,-32052(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
8014039c:	e03fff15 	stw	zero,-4(fp)
801403a0:	00001106 	br	801403e8 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
801403a4:	00a005b4 	movhi	r2,32790
801403a8:	10929004 	addi	r2,r2,19008
801403ac:	e0ffff17 	ldw	r3,-4(fp)
801403b0:	180691ba 	slli	r3,r3,6
801403b4:	10c5883a 	add	r2,r2,r3
801403b8:	10800f04 	addi	r2,r2,60
801403bc:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
801403c0:	00a005b4 	movhi	r2,32790
801403c4:	10929004 	addi	r2,r2,19008
801403c8:	e0ffff17 	ldw	r3,-4(fp)
801403cc:	180691ba 	slli	r3,r3,6
801403d0:	10c5883a 	add	r2,r2,r3
801403d4:	10800e04 	addi	r2,r2,56
801403d8:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
801403dc:	e0bfff17 	ldw	r2,-4(fp)
801403e0:	10800044 	addi	r2,r2,1
801403e4:	e0bfff15 	stw	r2,-4(fp)
801403e8:	e0bfff17 	ldw	r2,-4(fp)
801403ec:	10800510 	cmplti	r2,r2,20
801403f0:	103fec1e 	bne	r2,zero,801403a4 <__reset+0xfa1203a4>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
801403f4:	e0bffe17 	ldw	r2,-8(fp)
}
801403f8:	e037883a 	mov	sp,fp
801403fc:	df000017 	ldw	fp,0(sp)
80140400:	dec00104 	addi	sp,sp,4
80140404:	f800283a 	ret

80140408 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
80140408:	defffd04 	addi	sp,sp,-12
8014040c:	de00012e 	bgeu	sp,et,80140414 <alt_up_sd_card_is_FAT16+0xc>
80140410:	003b68fa 	trap	3
80140414:	dfc00215 	stw	ra,8(sp)
80140418:	df000115 	stw	fp,4(sp)
8014041c:	df000104 	addi	fp,sp,4
	bool result = false;
80140420:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
80140424:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
80140428:	10000c26 	beq	r2,zero,8014045c <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
8014042c:	d0a0b217 	ldw	r2,-32056(gp)
80140430:	1000071e 	bne	r2,zero,80140450 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
80140434:	013e6340 	call	8013e634 <Look_for_FAT16>
80140438:	d0a0b315 	stw	r2,-32052(gp)
			initialized = is_sd_card_formated_as_FAT16;
8014043c:	d0a0b317 	ldw	r2,-32052(gp)
80140440:	d0a0b215 	stw	r2,-32056(gp)
			search_data.valid = false;
80140444:	00a005b4 	movhi	r2,32790
80140448:	10927604 	addi	r2,r2,18904
8014044c:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
80140450:	d0a0b317 	ldw	r2,-32052(gp)
80140454:	e0bfff15 	stw	r2,-4(fp)
80140458:	00000206 	br	80140464 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
8014045c:	d020b215 	stw	zero,-32056(gp)
		is_sd_card_formated_as_FAT16 = false;
80140460:	d020b315 	stw	zero,-32052(gp)
	}

	return result;
80140464:	e0bfff17 	ldw	r2,-4(fp)
}
80140468:	e037883a 	mov	sp,fp
8014046c:	dfc00117 	ldw	ra,4(sp)
80140470:	df000017 	ldw	fp,0(sp)
80140474:	dec00204 	addi	sp,sp,8
80140478:	f800283a 	ret

8014047c <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
8014047c:	deffea04 	addi	sp,sp,-88
80140480:	de00012e 	bgeu	sp,et,80140488 <alt_up_sd_card_find_first+0xc>
80140484:	003b68fa 	trap	3
80140488:	dfc01515 	stw	ra,84(sp)
8014048c:	df001415 	stw	fp,80(sp)
80140490:	df001404 	addi	fp,sp,80
80140494:	e13ffe15 	stw	r4,-8(fp)
80140498:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
8014049c:	00800084 	movi	r2,2
801404a0:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
801404a4:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
801404a8:	10002426 	beq	r2,zero,8014053c <alt_up_sd_card_find_first+0xc0>
801404ac:	d0a0b317 	ldw	r2,-32052(gp)
801404b0:	10002226 	beq	r2,zero,8014053c <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
801404b4:	e0ffee04 	addi	r3,fp,-72
801404b8:	e0bfed04 	addi	r2,fp,-76
801404bc:	180d883a 	mov	r6,r3
801404c0:	100b883a 	mov	r5,r2
801404c4:	e13ffe17 	ldw	r4,-8(fp)
801404c8:	013edcc0 	call	8013edcc <get_home_directory_cluster_for_file>
801404cc:	10001926 	beq	r2,zero,80140534 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
801404d0:	e0bfed17 	ldw	r2,-76(fp)
801404d4:	1007883a 	mov	r3,r2
801404d8:	00a005b4 	movhi	r2,32790
801404dc:	10927604 	addi	r2,r2,18904
801404e0:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
801404e4:	e0bfed17 	ldw	r2,-76(fp)
801404e8:	1007883a 	mov	r3,r2
801404ec:	00a005b4 	movhi	r2,32790
801404f0:	10927604 	addi	r2,r2,18904
801404f4:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
801404f8:	00a005b4 	movhi	r2,32790
801404fc:	10927604 	addi	r2,r2,18904
80140500:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
80140504:	00a005b4 	movhi	r2,32790
80140508:	10927604 	addi	r2,r2,18904
8014050c:	00ffffc4 	movi	r3,-1
80140510:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
80140514:	00a005b4 	movhi	r2,32790
80140518:	10927604 	addi	r2,r2,18904
8014051c:	00c00044 	movi	r3,1
80140520:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
80140524:	e13fff17 	ldw	r4,-4(fp)
80140528:	01405540 	call	80140554 <alt_up_sd_card_find_next>
8014052c:	e0bfec0d 	sth	r2,-80(fp)
80140530:	00000206 	br	8014053c <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
80140534:	00800044 	movi	r2,1
80140538:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
8014053c:	e0bfec0b 	ldhu	r2,-80(fp)
}
80140540:	e037883a 	mov	sp,fp
80140544:	dfc00117 	ldw	ra,4(sp)
80140548:	df000017 	ldw	fp,0(sp)
8014054c:	dec00204 	addi	sp,sp,8
80140550:	f800283a 	ret

80140554 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
80140554:	deffe404 	addi	sp,sp,-112
80140558:	de00012e 	bgeu	sp,et,80140560 <alt_up_sd_card_find_next+0xc>
8014055c:	003b68fa 	trap	3
80140560:	dfc01b15 	stw	ra,108(sp)
80140564:	df001a15 	stw	fp,104(sp)
80140568:	df001a04 	addi	fp,sp,104
8014056c:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
80140570:	00800084 	movi	r2,2
80140574:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
80140578:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
8014057c:	1000df26 	beq	r2,zero,801408fc <alt_up_sd_card_find_next+0x3a8>
80140580:	d0a0b317 	ldw	r2,-32052(gp)
80140584:	1000dd26 	beq	r2,zero,801408fc <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
80140588:	00a005b4 	movhi	r2,32790
8014058c:	10927604 	addi	r2,r2,18904
80140590:	10800417 	ldw	r2,16(r2)
80140594:	1000d726 	beq	r2,zero,801408f4 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
80140598:	00a005b4 	movhi	r2,32790
8014059c:	10927604 	addi	r2,r2,18904
801405a0:	10800117 	ldw	r2,4(r2)
801405a4:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
801405a8:	e0bfe717 	ldw	r2,-100(fp)
801405ac:	1000561e 	bne	r2,zero,80140708 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
801405b0:	00a005b4 	movhi	r2,32790
801405b4:	10927b04 	addi	r2,r2,18924
801405b8:	1080050b 	ldhu	r2,20(r2)
801405bc:	10bfffcc 	andi	r2,r2,65535
801405c0:	1006917a 	slli	r3,r2,5
801405c4:	00a005b4 	movhi	r2,32790
801405c8:	10927b04 	addi	r2,r2,18924
801405cc:	1080030b 	ldhu	r2,12(r2)
801405d0:	10bfffcc 	andi	r2,r2,65535
801405d4:	1885283a 	div	r2,r3,r2
801405d8:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
801405dc:	00a005b4 	movhi	r2,32790
801405e0:	10927604 	addi	r2,r2,18904
801405e4:	10800217 	ldw	r2,8(r2)
801405e8:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
801405ec:	00a005b4 	movhi	r2,32790
801405f0:	10927604 	addi	r2,r2,18904
801405f4:	1080030b 	ldhu	r2,12(r2)
801405f8:	10bfffcc 	andi	r2,r2,65535
801405fc:	10a0001c 	xori	r2,r2,32768
80140600:	10a00004 	addi	r2,r2,-32768
80140604:	10800044 	addi	r2,r2,1
80140608:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8014060c:	00003606 	br	801406e8 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
80140610:	00a005b4 	movhi	r2,32790
80140614:	10927b04 	addi	r2,r2,18924
80140618:	10c01317 	ldw	r3,76(r2)
8014061c:	e0bfe817 	ldw	r2,-96(fp)
80140620:	1885883a 	add	r2,r3,r2
80140624:	1007883a 	mov	r3,r2
80140628:	d0a0ba17 	ldw	r2,-32024(gp)
8014062c:	100b883a 	mov	r5,r2
80140630:	1809883a 	mov	r4,r3
80140634:	013d6640 	call	8013d664 <Read_Sector_Data>
80140638:	10002f26 	beq	r2,zero,801406f8 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8014063c:	00002306 	br	801406cc <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
80140640:	e0bfe917 	ldw	r2,-92(fp)
80140644:	1004917a 	slli	r2,r2,5
80140648:	e13fe817 	ldw	r4,-96(fp)
8014064c:	e0ffef04 	addi	r3,fp,-68
80140650:	200f883a 	mov	r7,r4
80140654:	000d883a 	mov	r6,zero
80140658:	180b883a 	mov	r5,r3
8014065c:	1009883a 	mov	r4,r2
80140660:	013da940 	call	8013da94 <Read_File_Record_At_Offset>
80140664:	10001626 	beq	r2,zero,801406c0 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
80140668:	e0bfef03 	ldbu	r2,-68(fp)
8014066c:	10803fcc 	andi	r2,r2,255
80140670:	10001326 	beq	r2,zero,801406c0 <alt_up_sd_card_find_next+0x16c>
80140674:	e0bfef03 	ldbu	r2,-68(fp)
80140678:	10803fcc 	andi	r2,r2,255
8014067c:	10803960 	cmpeqi	r2,r2,229
80140680:	10000f1e 	bne	r2,zero,801406c0 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
80140684:	e0bfe917 	ldw	r2,-92(fp)
80140688:	1007883a 	mov	r3,r2
8014068c:	00a005b4 	movhi	r2,32790
80140690:	10927604 	addi	r2,r2,18904
80140694:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
80140698:	e0ffe817 	ldw	r3,-96(fp)
8014069c:	00a005b4 	movhi	r2,32790
801406a0:	10927604 	addi	r2,r2,18904
801406a4:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
801406a8:	e0bfef04 	addi	r2,fp,-68
801406ac:	e17fff17 	ldw	r5,-4(fp)
801406b0:	1009883a 	mov	r4,r2
801406b4:	01401280 	call	80140128 <copy_file_record_name_to_string>
									return 0;
801406b8:	0005883a 	mov	r2,zero
801406bc:	00009006 	br	80140900 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
801406c0:	e0bfe917 	ldw	r2,-92(fp)
801406c4:	10800044 	addi	r2,r2,1
801406c8:	e0bfe915 	stw	r2,-92(fp)
801406cc:	e0bfe917 	ldw	r2,-92(fp)
801406d0:	10800410 	cmplti	r2,r2,16
801406d4:	103fda1e 	bne	r2,zero,80140640 <__reset+0xfa120640>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
801406d8:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
801406dc:	e0bfe817 	ldw	r2,-96(fp)
801406e0:	10800044 	addi	r2,r2,1
801406e4:	e0bfe815 	stw	r2,-96(fp)
801406e8:	e0ffe817 	ldw	r3,-96(fp)
801406ec:	e0bfec17 	ldw	r2,-80(fp)
801406f0:	18bfc716 	blt	r3,r2,80140610 <__reset+0xfa120610>
801406f4:	00000106 	br	801406fc <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
801406f8:	0001883a 	nop
					}
				}
				result = -1;
801406fc:	00bfffc4 	movi	r2,-1
80140700:	e0bfe60d 	sth	r2,-104(fp)
80140704:	00007d06 	br	801408fc <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
80140708:	00a005b4 	movhi	r2,32790
8014070c:	10927604 	addi	r2,r2,18904
80140710:	1080030b 	ldhu	r2,12(r2)
80140714:	10bfffcc 	andi	r2,r2,65535
80140718:	10a0001c 	xori	r2,r2,32768
8014071c:	10a00004 	addi	r2,r2,-32768
80140720:	10800044 	addi	r2,r2,1
80140724:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
80140728:	e0bfe717 	ldw	r2,-100(fp)
8014072c:	10ffff84 	addi	r3,r2,-2
80140730:	00a005b4 	movhi	r2,32790
80140734:	10927b04 	addi	r2,r2,18924
80140738:	10800383 	ldbu	r2,14(r2)
8014073c:	10803fcc 	andi	r2,r2,255
80140740:	1885383a 	mul	r2,r3,r2
80140744:	1007883a 	mov	r3,r2
80140748:	00a005b4 	movhi	r2,32790
8014074c:	10927b04 	addi	r2,r2,18924
80140750:	10801417 	ldw	r2,80(r2)
80140754:	1885883a 	add	r2,r3,r2
80140758:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
8014075c:	00a005b4 	movhi	r2,32790
80140760:	10927604 	addi	r2,r2,18904
80140764:	10800217 	ldw	r2,8(r2)
80140768:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8014076c:	00003806 	br	80140850 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
80140770:	e0ffeb17 	ldw	r3,-84(fp)
80140774:	e0bfed17 	ldw	r2,-76(fp)
80140778:	1885883a 	add	r2,r3,r2
8014077c:	d0e0ba17 	ldw	r3,-32024(gp)
80140780:	180b883a 	mov	r5,r3
80140784:	1009883a 	mov	r4,r2
80140788:	013d6640 	call	8013d664 <Read_Sector_Data>
8014078c:	10003726 	beq	r2,zero,8014086c <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
80140790:	00002806 	br	80140834 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
80140794:	e0bfea17 	ldw	r2,-88(fp)
80140798:	1004917a 	slli	r2,r2,5
8014079c:	e13fe717 	ldw	r4,-100(fp)
801407a0:	e17feb17 	ldw	r5,-84(fp)
801407a4:	e0ffef04 	addi	r3,fp,-68
801407a8:	280f883a 	mov	r7,r5
801407ac:	200d883a 	mov	r6,r4
801407b0:	180b883a 	mov	r5,r3
801407b4:	1009883a 	mov	r4,r2
801407b8:	013da940 	call	8013da94 <Read_File_Record_At_Offset>
801407bc:	10001a26 	beq	r2,zero,80140828 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
801407c0:	e0bfef03 	ldbu	r2,-68(fp)
801407c4:	10803fcc 	andi	r2,r2,255
801407c8:	10001726 	beq	r2,zero,80140828 <alt_up_sd_card_find_next+0x2d4>
801407cc:	e0bfef03 	ldbu	r2,-68(fp)
801407d0:	10803fcc 	andi	r2,r2,255
801407d4:	10803960 	cmpeqi	r2,r2,229
801407d8:	1000131e 	bne	r2,zero,80140828 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
801407dc:	e0ffe717 	ldw	r3,-100(fp)
801407e0:	00a005b4 	movhi	r2,32790
801407e4:	10927604 	addi	r2,r2,18904
801407e8:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
801407ec:	e0bfea17 	ldw	r2,-88(fp)
801407f0:	1007883a 	mov	r3,r2
801407f4:	00a005b4 	movhi	r2,32790
801407f8:	10927604 	addi	r2,r2,18904
801407fc:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
80140800:	e0ffeb17 	ldw	r3,-84(fp)
80140804:	00a005b4 	movhi	r2,32790
80140808:	10927604 	addi	r2,r2,18904
8014080c:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
80140810:	e0bfef04 	addi	r2,fp,-68
80140814:	e17fff17 	ldw	r5,-4(fp)
80140818:	1009883a 	mov	r4,r2
8014081c:	01401280 	call	80140128 <copy_file_record_name_to_string>
										return 0;
80140820:	0005883a 	mov	r2,zero
80140824:	00003606 	br	80140900 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
80140828:	e0bfea17 	ldw	r2,-88(fp)
8014082c:	10800044 	addi	r2,r2,1
80140830:	e0bfea15 	stw	r2,-88(fp)
80140834:	e0bfea17 	ldw	r2,-88(fp)
80140838:	10800410 	cmplti	r2,r2,16
8014083c:	103fd51e 	bne	r2,zero,80140794 <__reset+0xfa120794>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
80140840:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
80140844:	e0bfeb17 	ldw	r2,-84(fp)
80140848:	10800044 	addi	r2,r2,1
8014084c:	e0bfeb15 	stw	r2,-84(fp)
80140850:	00a005b4 	movhi	r2,32790
80140854:	10927b04 	addi	r2,r2,18924
80140858:	10800383 	ldbu	r2,14(r2)
8014085c:	10803fcc 	andi	r2,r2,255
80140860:	e0ffeb17 	ldw	r3,-84(fp)
80140864:	18bfc216 	blt	r3,r2,80140770 <__reset+0xfa120770>
80140868:	00000106 	br	80140870 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
8014086c:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
80140870:	00a005b4 	movhi	r2,32790
80140874:	10927b04 	addi	r2,r2,18924
80140878:	10800383 	ldbu	r2,14(r2)
8014087c:	10803fcc 	andi	r2,r2,255
80140880:	e0ffeb17 	ldw	r3,-84(fp)
80140884:	18801716 	blt	r3,r2,801408e4 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
80140888:	e0bfe717 	ldw	r2,-100(fp)
8014088c:	e0ffee04 	addi	r3,fp,-72
80140890:	180b883a 	mov	r5,r3
80140894:	1009883a 	mov	r4,r2
80140898:	013d7440 	call	8013d744 <get_cluster_flag>
8014089c:	10000f26 	beq	r2,zero,801408dc <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
801408a0:	e0bfee0b 	ldhu	r2,-72(fp)
801408a4:	10bfffcc 	andi	r2,r2,65535
801408a8:	10fffe0c 	andi	r3,r2,65528
801408ac:	00bffe14 	movui	r2,65528
801408b0:	1880051e 	bne	r3,r2,801408c8 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
801408b4:	00bfffc4 	movi	r2,-1
801408b8:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
801408bc:	00a005b4 	movhi	r2,32790
801408c0:	10927604 	addi	r2,r2,18904
801408c4:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
801408c8:	e0bfee0b 	ldhu	r2,-72(fp)
801408cc:	10bfffcc 	andi	r2,r2,65535
801408d0:	10bffe0c 	andi	r2,r2,65528
801408d4:	e0bfe715 	stw	r2,-100(fp)
801408d8:	00000206 	br	801408e4 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
801408dc:	00bfffc4 	movi	r2,-1
801408e0:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
801408e4:	e0bfe717 	ldw	r2,-100(fp)
801408e8:	00fffdd4 	movui	r3,65527
801408ec:	18bf8e0e 	bge	r3,r2,80140728 <__reset+0xfa120728>
801408f0:	00000206 	br	801408fc <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
801408f4:	008000c4 	movi	r2,3
801408f8:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
801408fc:	e0bfe60b 	ldhu	r2,-104(fp)
}
80140900:	e037883a 	mov	sp,fp
80140904:	dfc00117 	ldw	ra,4(sp)
80140908:	df000017 	ldw	fp,0(sp)
8014090c:	dec00204 	addi	sp,sp,8
80140910:	f800283a 	ret

80140914 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
80140914:	deffe904 	addi	sp,sp,-92
80140918:	de00012e 	bgeu	sp,et,80140920 <alt_up_sd_card_fopen+0xc>
8014091c:	003b68fa 	trap	3
80140920:	dfc01615 	stw	ra,88(sp)
80140924:	df001515 	stw	fp,84(sp)
80140928:	df001504 	addi	fp,sp,84
8014092c:	e13ffe15 	stw	r4,-8(fp)
80140930:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
80140934:	00bfffc4 	movi	r2,-1
80140938:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8014093c:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
80140940:	1000cf26 	beq	r2,zero,80140c80 <alt_up_sd_card_fopen+0x36c>
80140944:	d0a0b317 	ldw	r2,-32052(gp)
80140948:	1000cd26 	beq	r2,zero,80140c80 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
8014094c:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
80140950:	e13ffe17 	ldw	r4,-8(fp)
80140954:	013e7280 	call	8013e728 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
80140958:	e13ffe17 	ldw	r4,-8(fp)
8014095c:	013e7f40 	call	8013e7f4 <check_file_name_for_FAT16_compliance>
80140960:	1000c726 	beq	r2,zero,80140c80 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
80140964:	e0ffee04 	addi	r3,fp,-72
80140968:	e0bfed04 	addi	r2,fp,-76
8014096c:	180d883a 	mov	r6,r3
80140970:	100b883a 	mov	r5,r2
80140974:	e13ffe17 	ldw	r4,-8(fp)
80140978:	013edcc0 	call	8013edcc <get_home_directory_cluster_for_file>
8014097c:	1000021e 	bne	r2,zero,80140988 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
80140980:	e0bfeb0b 	ldhu	r2,-84(fp)
80140984:	0000bf06 	br	80140c84 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
80140988:	e03fec15 	stw	zero,-80(fp)
8014098c:	00000e06 	br	801409c8 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
80140990:	00a005b4 	movhi	r2,32790
80140994:	10929004 	addi	r2,r2,19008
80140998:	e0ffec17 	ldw	r3,-80(fp)
8014099c:	180691ba 	slli	r3,r3,6
801409a0:	10c5883a 	add	r2,r2,r3
801409a4:	10800f04 	addi	r2,r2,60
801409a8:	10800017 	ldw	r2,0(r2)
801409ac:	1000031e 	bne	r2,zero,801409bc <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
801409b0:	e0bfec17 	ldw	r2,-80(fp)
801409b4:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
801409b8:	00000606 	br	801409d4 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
801409bc:	e0bfec17 	ldw	r2,-80(fp)
801409c0:	10800044 	addi	r2,r2,1
801409c4:	e0bfec15 	stw	r2,-80(fp)
801409c8:	e0bfec17 	ldw	r2,-80(fp)
801409cc:	10800510 	cmplti	r2,r2,20
801409d0:	103fef1e 	bne	r2,zero,80140990 <__reset+0xfa120990>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
801409d4:	e0bfeb0f 	ldh	r2,-84(fp)
801409d8:	1000a916 	blt	r2,zero,80140c80 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
801409dc:	e0bfed17 	ldw	r2,-76(fp)
801409e0:	1009883a 	mov	r4,r2
801409e4:	e0bfeb0f 	ldh	r2,-84(fp)
801409e8:	100691ba 	slli	r3,r2,6
801409ec:	00a005b4 	movhi	r2,32790
801409f0:	10929004 	addi	r2,r2,19008
801409f4:	1885883a 	add	r2,r3,r2
801409f8:	100d883a 	mov	r6,r2
801409fc:	e17ffe17 	ldw	r5,-8(fp)
80140a00:	013f30c0 	call	8013f30c <find_file_in_directory>
80140a04:	10007b26 	beq	r2,zero,80140bf4 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
80140a08:	e0bfff17 	ldw	r2,-4(fp)
80140a0c:	10000226 	beq	r2,zero,80140a18 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
80140a10:	00bfffc4 	movi	r2,-1
80140a14:	00009b06 	br	80140c84 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
80140a18:	e13feb0f 	ldh	r4,-84(fp)
80140a1c:	e0ffeb0f 	ldh	r3,-84(fp)
80140a20:	00a005b4 	movhi	r2,32790
80140a24:	10929004 	addi	r2,r2,19008
80140a28:	180691ba 	slli	r3,r3,6
80140a2c:	10c5883a 	add	r2,r2,r3
80140a30:	10800584 	addi	r2,r2,22
80140a34:	1080000b 	ldhu	r2,0(r2)
80140a38:	10ffffcc 	andi	r3,r2,65535
80140a3c:	00a005b4 	movhi	r2,32790
80140a40:	10929004 	addi	r2,r2,19008
80140a44:	200891ba 	slli	r4,r4,6
80140a48:	1105883a 	add	r2,r2,r4
80140a4c:	10800704 	addi	r2,r2,28
80140a50:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
80140a54:	e0ffeb0f 	ldh	r3,-84(fp)
80140a58:	00a005b4 	movhi	r2,32790
80140a5c:	10929004 	addi	r2,r2,19008
80140a60:	180691ba 	slli	r3,r3,6
80140a64:	10c5883a 	add	r2,r2,r3
80140a68:	10800804 	addi	r2,r2,32
80140a6c:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
80140a70:	e0ffeb0f 	ldh	r3,-84(fp)
80140a74:	00a005b4 	movhi	r2,32790
80140a78:	10929004 	addi	r2,r2,19008
80140a7c:	180691ba 	slli	r3,r3,6
80140a80:	10c5883a 	add	r2,r2,r3
80140a84:	10800904 	addi	r2,r2,36
80140a88:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
80140a8c:	e0ffeb0f 	ldh	r3,-84(fp)
80140a90:	00a005b4 	movhi	r2,32790
80140a94:	10929004 	addi	r2,r2,19008
80140a98:	180691ba 	slli	r3,r3,6
80140a9c:	10c5883a 	add	r2,r2,r3
80140aa0:	10800f04 	addi	r2,r2,60
80140aa4:	00c00044 	movi	r3,1
80140aa8:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
80140aac:	e0ffeb0f 	ldh	r3,-84(fp)
80140ab0:	00a005b4 	movhi	r2,32790
80140ab4:	10929004 	addi	r2,r2,19008
80140ab8:	180691ba 	slli	r3,r3,6
80140abc:	10c5883a 	add	r2,r2,r3
80140ac0:	10800e04 	addi	r2,r2,56
80140ac4:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
80140ac8:	e03fec15 	stw	zero,-80(fp)
80140acc:	00004506 	br	80140be4 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
80140ad0:	e0ffeb0f 	ldh	r3,-84(fp)
80140ad4:	e0bfec17 	ldw	r2,-80(fp)
80140ad8:	18803f26 	beq	r3,r2,80140bd8 <alt_up_sd_card_fopen+0x2c4>
80140adc:	00a005b4 	movhi	r2,32790
80140ae0:	10929004 	addi	r2,r2,19008
80140ae4:	e0ffec17 	ldw	r3,-80(fp)
80140ae8:	180691ba 	slli	r3,r3,6
80140aec:	10c5883a 	add	r2,r2,r3
80140af0:	10800f04 	addi	r2,r2,60
80140af4:	10800017 	ldw	r2,0(r2)
80140af8:	10800058 	cmpnei	r2,r2,1
80140afc:	1000361e 	bne	r2,zero,80140bd8 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
80140b00:	e0ffeb0f 	ldh	r3,-84(fp)
80140b04:	00a005b4 	movhi	r2,32790
80140b08:	10929004 	addi	r2,r2,19008
80140b0c:	180691ba 	slli	r3,r3,6
80140b10:	10c5883a 	add	r2,r2,r3
80140b14:	10800a04 	addi	r2,r2,40
80140b18:	10c00017 	ldw	r3,0(r2)
80140b1c:	00a005b4 	movhi	r2,32790
80140b20:	10929004 	addi	r2,r2,19008
80140b24:	e13fec17 	ldw	r4,-80(fp)
80140b28:	200891ba 	slli	r4,r4,6
80140b2c:	1105883a 	add	r2,r2,r4
80140b30:	10800a04 	addi	r2,r2,40
80140b34:	10800017 	ldw	r2,0(r2)
80140b38:	1880271e 	bne	r3,r2,80140bd8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
80140b3c:	e0ffeb0f 	ldh	r3,-84(fp)
80140b40:	00a005b4 	movhi	r2,32790
80140b44:	10929004 	addi	r2,r2,19008
80140b48:	180691ba 	slli	r3,r3,6
80140b4c:	10c5883a 	add	r2,r2,r3
80140b50:	10800b04 	addi	r2,r2,44
80140b54:	10c00017 	ldw	r3,0(r2)
80140b58:	00a005b4 	movhi	r2,32790
80140b5c:	10929004 	addi	r2,r2,19008
80140b60:	e13fec17 	ldw	r4,-80(fp)
80140b64:	200891ba 	slli	r4,r4,6
80140b68:	1105883a 	add	r2,r2,r4
80140b6c:	10800b04 	addi	r2,r2,44
80140b70:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
80140b74:	1880181e 	bne	r3,r2,80140bd8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
80140b78:	e0ffeb0f 	ldh	r3,-84(fp)
80140b7c:	00a005b4 	movhi	r2,32790
80140b80:	10929004 	addi	r2,r2,19008
80140b84:	180691ba 	slli	r3,r3,6
80140b88:	10c5883a 	add	r2,r2,r3
80140b8c:	10800c04 	addi	r2,r2,48
80140b90:	1100000b 	ldhu	r4,0(r2)
80140b94:	00a005b4 	movhi	r2,32790
80140b98:	10929004 	addi	r2,r2,19008
80140b9c:	e0ffec17 	ldw	r3,-80(fp)
80140ba0:	180691ba 	slli	r3,r3,6
80140ba4:	10c5883a 	add	r2,r2,r3
80140ba8:	10800c04 	addi	r2,r2,48
80140bac:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
80140bb0:	20ffffcc 	andi	r3,r4,65535
80140bb4:	18e0001c 	xori	r3,r3,32768
80140bb8:	18e00004 	addi	r3,r3,-32768
80140bbc:	10bfffcc 	andi	r2,r2,65535
80140bc0:	10a0001c 	xori	r2,r2,32768
80140bc4:	10a00004 	addi	r2,r2,-32768
80140bc8:	1880031e 	bne	r3,r2,80140bd8 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
80140bcc:	00bfff84 	movi	r2,-2
80140bd0:	e0bfeb0d 	sth	r2,-84(fp)
								break;
80140bd4:	00002a06 	br	80140c80 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
80140bd8:	e0bfec17 	ldw	r2,-80(fp)
80140bdc:	10800044 	addi	r2,r2,1
80140be0:	e0bfec15 	stw	r2,-80(fp)
80140be4:	e0bfec17 	ldw	r2,-80(fp)
80140be8:	10800510 	cmplti	r2,r2,20
80140bec:	103fb81e 	bne	r2,zero,80140ad0 <__reset+0xfa120ad0>
80140bf0:	00002306 	br	80140c80 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
80140bf4:	e0bfff17 	ldw	r2,-4(fp)
80140bf8:	10001f26 	beq	r2,zero,80140c78 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
80140bfc:	e0bfeb0f 	ldh	r2,-84(fp)
80140c00:	100691ba 	slli	r3,r2,6
80140c04:	00a005b4 	movhi	r2,32790
80140c08:	10929004 	addi	r2,r2,19008
80140c0c:	1885883a 	add	r2,r3,r2
80140c10:	e0ffee04 	addi	r3,fp,-72
80140c14:	180d883a 	mov	r6,r3
80140c18:	100b883a 	mov	r5,r2
80140c1c:	e13ffe17 	ldw	r4,-8(fp)
80140c20:	013fe580 	call	8013fe58 <create_file>
80140c24:	10001126 	beq	r2,zero,80140c6c <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
80140c28:	e0ffeb0f 	ldh	r3,-84(fp)
80140c2c:	00a005b4 	movhi	r2,32790
80140c30:	10929004 	addi	r2,r2,19008
80140c34:	180691ba 	slli	r3,r3,6
80140c38:	10c5883a 	add	r2,r2,r3
80140c3c:	10800f04 	addi	r2,r2,60
80140c40:	00c00044 	movi	r3,1
80140c44:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
80140c48:	e0ffeb0f 	ldh	r3,-84(fp)
80140c4c:	00a005b4 	movhi	r2,32790
80140c50:	10929004 	addi	r2,r2,19008
80140c54:	180691ba 	slli	r3,r3,6
80140c58:	10c5883a 	add	r2,r2,r3
80140c5c:	10800e04 	addi	r2,r2,56
80140c60:	00c00044 	movi	r3,1
80140c64:	10c00015 	stw	r3,0(r2)
80140c68:	00000506 	br	80140c80 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
80140c6c:	00bfffc4 	movi	r2,-1
80140c70:	e0bfeb0d 	sth	r2,-84(fp)
80140c74:	00000206 	br	80140c80 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
80140c78:	00bfffc4 	movi	r2,-1
80140c7c:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
80140c80:	e0bfeb0b 	ldhu	r2,-84(fp)
}
80140c84:	e037883a 	mov	sp,fp
80140c88:	dfc00117 	ldw	ra,4(sp)
80140c8c:	df000017 	ldw	fp,0(sp)
80140c90:	dec00204 	addi	sp,sp,8
80140c94:	f800283a 	ret

80140c98 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
80140c98:	defffd04 	addi	sp,sp,-12
80140c9c:	de00012e 	bgeu	sp,et,80140ca4 <alt_up_sd_card_set_attributes+0xc>
80140ca0:	003b68fa 	trap	3
80140ca4:	df000215 	stw	fp,8(sp)
80140ca8:	df000204 	addi	fp,sp,8
80140cac:	2007883a 	mov	r3,r4
80140cb0:	2805883a 	mov	r2,r5
80140cb4:	e0fffe0d 	sth	r3,-8(fp)
80140cb8:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
80140cbc:	e0bffe0f 	ldh	r2,-8(fp)
80140cc0:	10001416 	blt	r2,zero,80140d14 <alt_up_sd_card_set_attributes+0x7c>
80140cc4:	e0bffe0f 	ldh	r2,-8(fp)
80140cc8:	10800508 	cmpgei	r2,r2,20
80140ccc:	1000111e 	bne	r2,zero,80140d14 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
80140cd0:	e0fffe0f 	ldh	r3,-8(fp)
80140cd4:	00a005b4 	movhi	r2,32790
80140cd8:	10929004 	addi	r2,r2,19008
80140cdc:	180691ba 	slli	r3,r3,6
80140ce0:	10c5883a 	add	r2,r2,r3
80140ce4:	10800f04 	addi	r2,r2,60
80140ce8:	10800017 	ldw	r2,0(r2)
80140cec:	10000926 	beq	r2,zero,80140d14 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
80140cf0:	e0fffe0f 	ldh	r3,-8(fp)
80140cf4:	e0bfff0b 	ldhu	r2,-4(fp)
80140cf8:	1009883a 	mov	r4,r2
80140cfc:	00a005b4 	movhi	r2,32790
80140d00:	10929004 	addi	r2,r2,19008
80140d04:	180691ba 	slli	r3,r3,6
80140d08:	10c5883a 	add	r2,r2,r3
80140d0c:	108002c4 	addi	r2,r2,11
80140d10:	11000005 	stb	r4,0(r2)
        }
    }
}
80140d14:	0001883a 	nop
80140d18:	e037883a 	mov	sp,fp
80140d1c:	df000017 	ldw	fp,0(sp)
80140d20:	dec00104 	addi	sp,sp,4
80140d24:	f800283a 	ret

80140d28 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
80140d28:	defffd04 	addi	sp,sp,-12
80140d2c:	de00012e 	bgeu	sp,et,80140d34 <alt_up_sd_card_get_attributes+0xc>
80140d30:	003b68fa 	trap	3
80140d34:	df000215 	stw	fp,8(sp)
80140d38:	df000204 	addi	fp,sp,8
80140d3c:	2005883a 	mov	r2,r4
80140d40:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
80140d44:	00bfffc4 	movi	r2,-1
80140d48:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
80140d4c:	e0bfff0f 	ldh	r2,-4(fp)
80140d50:	10001416 	blt	r2,zero,80140da4 <alt_up_sd_card_get_attributes+0x7c>
80140d54:	e0bfff0f 	ldh	r2,-4(fp)
80140d58:	10800508 	cmpgei	r2,r2,20
80140d5c:	1000111e 	bne	r2,zero,80140da4 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
80140d60:	e0ffff0f 	ldh	r3,-4(fp)
80140d64:	00a005b4 	movhi	r2,32790
80140d68:	10929004 	addi	r2,r2,19008
80140d6c:	180691ba 	slli	r3,r3,6
80140d70:	10c5883a 	add	r2,r2,r3
80140d74:	10800f04 	addi	r2,r2,60
80140d78:	10800017 	ldw	r2,0(r2)
80140d7c:	10000926 	beq	r2,zero,80140da4 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
80140d80:	e0ffff0f 	ldh	r3,-4(fp)
80140d84:	00a005b4 	movhi	r2,32790
80140d88:	10929004 	addi	r2,r2,19008
80140d8c:	180691ba 	slli	r3,r3,6
80140d90:	10c5883a 	add	r2,r2,r3
80140d94:	108002c4 	addi	r2,r2,11
80140d98:	10800003 	ldbu	r2,0(r2)
80140d9c:	10803fcc 	andi	r2,r2,255
80140da0:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
80140da4:	e0bffe0b 	ldhu	r2,-8(fp)
}
80140da8:	e037883a 	mov	sp,fp
80140dac:	df000017 	ldw	fp,0(sp)
80140db0:	dec00104 	addi	sp,sp,4
80140db4:	f800283a 	ret

80140db8 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
80140db8:	defffa04 	addi	sp,sp,-24
80140dbc:	de00012e 	bgeu	sp,et,80140dc4 <alt_up_sd_card_read+0xc>
80140dc0:	003b68fa 	trap	3
80140dc4:	dfc00515 	stw	ra,20(sp)
80140dc8:	df000415 	stw	fp,16(sp)
80140dcc:	df000404 	addi	fp,sp,16
80140dd0:	2005883a 	mov	r2,r4
80140dd4:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
80140dd8:	00bfffc4 	movi	r2,-1
80140ddc:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
80140de0:	e0bfff0f 	ldh	r2,-4(fp)
80140de4:	1000ce16 	blt	r2,zero,80141120 <alt_up_sd_card_read+0x368>
80140de8:	e0bfff0f 	ldh	r2,-4(fp)
80140dec:	10800508 	cmpgei	r2,r2,20
80140df0:	1000cb1e 	bne	r2,zero,80141120 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
80140df4:	e0ffff0f 	ldh	r3,-4(fp)
80140df8:	00a005b4 	movhi	r2,32790
80140dfc:	10929004 	addi	r2,r2,19008
80140e00:	180691ba 	slli	r3,r3,6
80140e04:	10c5883a 	add	r2,r2,r3
80140e08:	10800f04 	addi	r2,r2,60
80140e0c:	10800017 	ldw	r2,0(r2)
80140e10:	1000c326 	beq	r2,zero,80141120 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
80140e14:	e0ffff0f 	ldh	r3,-4(fp)
80140e18:	00a005b4 	movhi	r2,32790
80140e1c:	10929004 	addi	r2,r2,19008
80140e20:	180691ba 	slli	r3,r3,6
80140e24:	10c5883a 	add	r2,r2,r3
80140e28:	10800904 	addi	r2,r2,36
80140e2c:	10c00017 	ldw	r3,0(r2)
80140e30:	e13fff0f 	ldh	r4,-4(fp)
80140e34:	00a005b4 	movhi	r2,32790
80140e38:	10929004 	addi	r2,r2,19008
80140e3c:	200891ba 	slli	r4,r4,6
80140e40:	1105883a 	add	r2,r2,r4
80140e44:	10800604 	addi	r2,r2,24
80140e48:	10800017 	ldw	r2,0(r2)
80140e4c:	1880b42e 	bgeu	r3,r2,80141120 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
80140e50:	00a005b4 	movhi	r2,32790
80140e54:	10927b04 	addi	r2,r2,18924
80140e58:	10c01417 	ldw	r3,80(r2)
80140e5c:	e13fff0f 	ldh	r4,-4(fp)
80140e60:	00a005b4 	movhi	r2,32790
80140e64:	10929004 	addi	r2,r2,19008
80140e68:	200891ba 	slli	r4,r4,6
80140e6c:	1105883a 	add	r2,r2,r4
80140e70:	10800704 	addi	r2,r2,28
80140e74:	10800017 	ldw	r2,0(r2)
80140e78:	113fff84 	addi	r4,r2,-2
80140e7c:	00a005b4 	movhi	r2,32790
80140e80:	10927b04 	addi	r2,r2,18924
80140e84:	10800383 	ldbu	r2,14(r2)
80140e88:	10803fcc 	andi	r2,r2,255
80140e8c:	2085383a 	mul	r2,r4,r2
80140e90:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
80140e94:	e13fff0f 	ldh	r4,-4(fp)
80140e98:	00a005b4 	movhi	r2,32790
80140e9c:	10929004 	addi	r2,r2,19008
80140ea0:	200891ba 	slli	r4,r4,6
80140ea4:	1105883a 	add	r2,r2,r4
80140ea8:	10800804 	addi	r2,r2,32
80140eac:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
80140eb0:	1885883a 	add	r2,r3,r2
80140eb4:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
80140eb8:	e0ffff0f 	ldh	r3,-4(fp)
80140ebc:	00a005b4 	movhi	r2,32790
80140ec0:	10929004 	addi	r2,r2,19008
80140ec4:	180691ba 	slli	r3,r3,6
80140ec8:	10c5883a 	add	r2,r2,r3
80140ecc:	10800904 	addi	r2,r2,36
80140ed0:	10800017 	ldw	r2,0(r2)
80140ed4:	10006826 	beq	r2,zero,80141078 <alt_up_sd_card_read+0x2c0>
80140ed8:	e0ffff0f 	ldh	r3,-4(fp)
80140edc:	00a005b4 	movhi	r2,32790
80140ee0:	10929004 	addi	r2,r2,19008
80140ee4:	180691ba 	slli	r3,r3,6
80140ee8:	10c5883a 	add	r2,r2,r3
80140eec:	10800904 	addi	r2,r2,36
80140ef0:	10800017 	ldw	r2,0(r2)
80140ef4:	10807fcc 	andi	r2,r2,511
80140ef8:	10005f1e 	bne	r2,zero,80141078 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
80140efc:	e0ffff0f 	ldh	r3,-4(fp)
80140f00:	00a005b4 	movhi	r2,32790
80140f04:	10929004 	addi	r2,r2,19008
80140f08:	180691ba 	slli	r3,r3,6
80140f0c:	10c5883a 	add	r2,r2,r3
80140f10:	10800804 	addi	r2,r2,32
80140f14:	10c00017 	ldw	r3,0(r2)
80140f18:	00a005b4 	movhi	r2,32790
80140f1c:	10927b04 	addi	r2,r2,18924
80140f20:	10800383 	ldbu	r2,14(r2)
80140f24:	10803fcc 	andi	r2,r2,255
80140f28:	10bfffc4 	addi	r2,r2,-1
80140f2c:	1880401e 	bne	r3,r2,80141030 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
80140f30:	e0ffff0f 	ldh	r3,-4(fp)
80140f34:	00a005b4 	movhi	r2,32790
80140f38:	10929004 	addi	r2,r2,19008
80140f3c:	180691ba 	slli	r3,r3,6
80140f40:	10c5883a 	add	r2,r2,r3
80140f44:	10800704 	addi	r2,r2,28
80140f48:	10800017 	ldw	r2,0(r2)
80140f4c:	e0fffe04 	addi	r3,fp,-8
80140f50:	180b883a 	mov	r5,r3
80140f54:	1009883a 	mov	r4,r2
80140f58:	013d7440 	call	8013d744 <get_cluster_flag>
80140f5c:	10003226 	beq	r2,zero,80141028 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
80140f60:	e0bffe0b 	ldhu	r2,-8(fp)
80140f64:	10bfffcc 	andi	r2,r2,65535
80140f68:	10fffe0c 	andi	r3,r2,65528
80140f6c:	00bffe14 	movui	r2,65528
80140f70:	1880021e 	bne	r3,r2,80140f7c <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
80140f74:	00bfffc4 	movi	r2,-1
80140f78:	00006a06 	br	80141124 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
80140f7c:	e13fff0f 	ldh	r4,-4(fp)
80140f80:	e0bffe0b 	ldhu	r2,-8(fp)
80140f84:	10ffffcc 	andi	r3,r2,65535
80140f88:	00a005b4 	movhi	r2,32790
80140f8c:	10929004 	addi	r2,r2,19008
80140f90:	200891ba 	slli	r4,r4,6
80140f94:	1105883a 	add	r2,r2,r4
80140f98:	10800704 	addi	r2,r2,28
80140f9c:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
80140fa0:	e0ffff0f 	ldh	r3,-4(fp)
80140fa4:	00a005b4 	movhi	r2,32790
80140fa8:	10929004 	addi	r2,r2,19008
80140fac:	180691ba 	slli	r3,r3,6
80140fb0:	10c5883a 	add	r2,r2,r3
80140fb4:	10800804 	addi	r2,r2,32
80140fb8:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
80140fbc:	00a005b4 	movhi	r2,32790
80140fc0:	10927b04 	addi	r2,r2,18924
80140fc4:	10c01417 	ldw	r3,80(r2)
80140fc8:	e13fff0f 	ldh	r4,-4(fp)
80140fcc:	00a005b4 	movhi	r2,32790
80140fd0:	10929004 	addi	r2,r2,19008
80140fd4:	200891ba 	slli	r4,r4,6
80140fd8:	1105883a 	add	r2,r2,r4
80140fdc:	10800704 	addi	r2,r2,28
80140fe0:	10800017 	ldw	r2,0(r2)
80140fe4:	113fff84 	addi	r4,r2,-2
80140fe8:	00a005b4 	movhi	r2,32790
80140fec:	10927b04 	addi	r2,r2,18924
80140ff0:	10800383 	ldbu	r2,14(r2)
80140ff4:	10803fcc 	andi	r2,r2,255
80140ff8:	2085383a 	mul	r2,r4,r2
80140ffc:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
80141000:	e13fff0f 	ldh	r4,-4(fp)
80141004:	00a005b4 	movhi	r2,32790
80141008:	10929004 	addi	r2,r2,19008
8014100c:	200891ba 	slli	r4,r4,6
80141010:	1105883a 	add	r2,r2,r4
80141014:	10800804 	addi	r2,r2,32
80141018:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8014101c:	1885883a 	add	r2,r3,r2
80141020:	e0bffd15 	stw	r2,-12(fp)
80141024:	00001406 	br	80141078 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
80141028:	00bfff84 	movi	r2,-2
8014102c:	00003d06 	br	80141124 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
80141030:	e13fff0f 	ldh	r4,-4(fp)
80141034:	e0ffff0f 	ldh	r3,-4(fp)
80141038:	00a005b4 	movhi	r2,32790
8014103c:	10929004 	addi	r2,r2,19008
80141040:	180691ba 	slli	r3,r3,6
80141044:	10c5883a 	add	r2,r2,r3
80141048:	10800804 	addi	r2,r2,32
8014104c:	10800017 	ldw	r2,0(r2)
80141050:	10c00044 	addi	r3,r2,1
80141054:	00a005b4 	movhi	r2,32790
80141058:	10929004 	addi	r2,r2,19008
8014105c:	200891ba 	slli	r4,r4,6
80141060:	1105883a 	add	r2,r2,r4
80141064:	10800804 	addi	r2,r2,32
80141068:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8014106c:	e0bffd17 	ldw	r2,-12(fp)
80141070:	10800044 	addi	r2,r2,1
80141074:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
80141078:	d0e0ba17 	ldw	r3,-32024(gp)
8014107c:	e0bffd17 	ldw	r2,-12(fp)
80141080:	1885883a 	add	r2,r3,r2
80141084:	1007883a 	mov	r3,r2
80141088:	d0a0be17 	ldw	r2,-32008(gp)
8014108c:	18800726 	beq	r3,r2,801410ac <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
80141090:	d0a0ba17 	ldw	r2,-32024(gp)
80141094:	100b883a 	mov	r5,r2
80141098:	e13ffd17 	ldw	r4,-12(fp)
8014109c:	013d6640 	call	8013d664 <Read_Sector_Data>
801410a0:	1000021e 	bne	r2,zero,801410ac <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
801410a4:	00bfff84 	movi	r2,-2
801410a8:	00001e06 	br	80141124 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
801410ac:	d0e0b917 	ldw	r3,-32028(gp)
801410b0:	e13fff0f 	ldh	r4,-4(fp)
801410b4:	00a005b4 	movhi	r2,32790
801410b8:	10929004 	addi	r2,r2,19008
801410bc:	200891ba 	slli	r4,r4,6
801410c0:	1105883a 	add	r2,r2,r4
801410c4:	10800904 	addi	r2,r2,36
801410c8:	10800017 	ldw	r2,0(r2)
801410cc:	10807fcc 	andi	r2,r2,511
801410d0:	1885883a 	add	r2,r3,r2
801410d4:	10800023 	ldbuio	r2,0(r2)
801410d8:	10803fcc 	andi	r2,r2,255
801410dc:	10803fcc 	andi	r2,r2,255
801410e0:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
801410e4:	e13fff0f 	ldh	r4,-4(fp)
801410e8:	e0ffff0f 	ldh	r3,-4(fp)
801410ec:	00a005b4 	movhi	r2,32790
801410f0:	10929004 	addi	r2,r2,19008
801410f4:	180691ba 	slli	r3,r3,6
801410f8:	10c5883a 	add	r2,r2,r3
801410fc:	10800904 	addi	r2,r2,36
80141100:	10800017 	ldw	r2,0(r2)
80141104:	10c00044 	addi	r3,r2,1
80141108:	00a005b4 	movhi	r2,32790
8014110c:	10929004 	addi	r2,r2,19008
80141110:	200891ba 	slli	r4,r4,6
80141114:	1105883a 	add	r2,r2,r4
80141118:	10800904 	addi	r2,r2,36
8014111c:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
80141120:	e0bffc0b 	ldhu	r2,-16(fp)
}
80141124:	e037883a 	mov	sp,fp
80141128:	dfc00117 	ldw	ra,4(sp)
8014112c:	df000017 	ldw	fp,0(sp)
80141130:	dec00204 	addi	sp,sp,8
80141134:	f800283a 	ret

80141138 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
80141138:	defff804 	addi	sp,sp,-32
8014113c:	de00012e 	bgeu	sp,et,80141144 <alt_up_sd_card_write+0xc>
80141140:	003b68fa 	trap	3
80141144:	dfc00715 	stw	ra,28(sp)
80141148:	df000615 	stw	fp,24(sp)
8014114c:	df000604 	addi	fp,sp,24
80141150:	2007883a 	mov	r3,r4
80141154:	2805883a 	mov	r2,r5
80141158:	e0fffe0d 	sth	r3,-8(fp)
8014115c:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
80141160:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
80141164:	e0bffe0f 	ldh	r2,-8(fp)
80141168:	10017716 	blt	r2,zero,80141748 <alt_up_sd_card_write+0x610>
8014116c:	e0bffe0f 	ldh	r2,-8(fp)
80141170:	10800508 	cmpgei	r2,r2,20
80141174:	1001741e 	bne	r2,zero,80141748 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
80141178:	e0fffe0f 	ldh	r3,-8(fp)
8014117c:	00a005b4 	movhi	r2,32790
80141180:	10929004 	addi	r2,r2,19008
80141184:	180691ba 	slli	r3,r3,6
80141188:	10c5883a 	add	r2,r2,r3
8014118c:	10800f04 	addi	r2,r2,60
80141190:	10800017 	ldw	r2,0(r2)
80141194:	10016c26 	beq	r2,zero,80141748 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
80141198:	00a005b4 	movhi	r2,32790
8014119c:	10927b04 	addi	r2,r2,18924
801411a0:	10c01417 	ldw	r3,80(r2)
801411a4:	e13ffe0f 	ldh	r4,-8(fp)
801411a8:	00a005b4 	movhi	r2,32790
801411ac:	10929004 	addi	r2,r2,19008
801411b0:	200891ba 	slli	r4,r4,6
801411b4:	1105883a 	add	r2,r2,r4
801411b8:	10800704 	addi	r2,r2,28
801411bc:	10800017 	ldw	r2,0(r2)
801411c0:	113fff84 	addi	r4,r2,-2
801411c4:	00a005b4 	movhi	r2,32790
801411c8:	10927b04 	addi	r2,r2,18924
801411cc:	10800383 	ldbu	r2,14(r2)
801411d0:	10803fcc 	andi	r2,r2,255
801411d4:	2085383a 	mul	r2,r4,r2
801411d8:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
801411dc:	e13ffe0f 	ldh	r4,-8(fp)
801411e0:	00a005b4 	movhi	r2,32790
801411e4:	10929004 	addi	r2,r2,19008
801411e8:	200891ba 	slli	r4,r4,6
801411ec:	1105883a 	add	r2,r2,r4
801411f0:	10800804 	addi	r2,r2,32
801411f4:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
801411f8:	1885883a 	add	r2,r3,r2
801411fc:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
80141200:	e0fffe0f 	ldh	r3,-8(fp)
80141204:	00a005b4 	movhi	r2,32790
80141208:	10929004 	addi	r2,r2,19008
8014120c:	180691ba 	slli	r3,r3,6
80141210:	10c5883a 	add	r2,r2,r3
80141214:	10800904 	addi	r2,r2,36
80141218:	10c00017 	ldw	r3,0(r2)
8014121c:	00a005b4 	movhi	r2,32790
80141220:	10927b04 	addi	r2,r2,18924
80141224:	1080030b 	ldhu	r2,12(r2)
80141228:	10bfffcc 	andi	r2,r2,65535
8014122c:	1889203a 	divu	r4,r3,r2
80141230:	2085383a 	mul	r2,r4,r2
80141234:	1885c83a 	sub	r2,r3,r2
80141238:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8014123c:	e0fffe0f 	ldh	r3,-8(fp)
80141240:	00a005b4 	movhi	r2,32790
80141244:	10929004 	addi	r2,r2,19008
80141248:	180691ba 	slli	r3,r3,6
8014124c:	10c5883a 	add	r2,r2,r3
80141250:	10800904 	addi	r2,r2,36
80141254:	10c00017 	ldw	r3,0(r2)
80141258:	e13ffe0f 	ldh	r4,-8(fp)
8014125c:	00a005b4 	movhi	r2,32790
80141260:	10929004 	addi	r2,r2,19008
80141264:	200891ba 	slli	r4,r4,6
80141268:	1105883a 	add	r2,r2,r4
8014126c:	10800604 	addi	r2,r2,24
80141270:	10800017 	ldw	r2,0(r2)
80141274:	1880672e 	bgeu	r3,r2,80141414 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
80141278:	e0fffe0f 	ldh	r3,-8(fp)
8014127c:	00a005b4 	movhi	r2,32790
80141280:	10929004 	addi	r2,r2,19008
80141284:	180691ba 	slli	r3,r3,6
80141288:	10c5883a 	add	r2,r2,r3
8014128c:	10800904 	addi	r2,r2,36
80141290:	10800017 	ldw	r2,0(r2)
80141294:	1000e126 	beq	r2,zero,8014161c <alt_up_sd_card_write+0x4e4>
80141298:	e0bffc0f 	ldh	r2,-16(fp)
8014129c:	1000df1e 	bne	r2,zero,8014161c <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
801412a0:	e0fffe0f 	ldh	r3,-8(fp)
801412a4:	00a005b4 	movhi	r2,32790
801412a8:	10929004 	addi	r2,r2,19008
801412ac:	180691ba 	slli	r3,r3,6
801412b0:	10c5883a 	add	r2,r2,r3
801412b4:	10800804 	addi	r2,r2,32
801412b8:	10c00017 	ldw	r3,0(r2)
801412bc:	00a005b4 	movhi	r2,32790
801412c0:	10927b04 	addi	r2,r2,18924
801412c4:	10800383 	ldbu	r2,14(r2)
801412c8:	10803fcc 	andi	r2,r2,255
801412cc:	10bfffc4 	addi	r2,r2,-1
801412d0:	18803d1e 	bne	r3,r2,801413c8 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
801412d4:	e0fffe0f 	ldh	r3,-8(fp)
801412d8:	00a005b4 	movhi	r2,32790
801412dc:	10929004 	addi	r2,r2,19008
801412e0:	180691ba 	slli	r3,r3,6
801412e4:	10c5883a 	add	r2,r2,r3
801412e8:	10800704 	addi	r2,r2,28
801412ec:	10800017 	ldw	r2,0(r2)
801412f0:	e0fffc84 	addi	r3,fp,-14
801412f4:	180b883a 	mov	r5,r3
801412f8:	1009883a 	mov	r4,r2
801412fc:	013d7440 	call	8013d744 <get_cluster_flag>
80141300:	10002f26 	beq	r2,zero,801413c0 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
80141304:	e0bffc8b 	ldhu	r2,-14(fp)
80141308:	10bfffcc 	andi	r2,r2,65535
8014130c:	10bffe28 	cmpgeui	r2,r2,65528
80141310:	1000c21e 	bne	r2,zero,8014161c <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
80141314:	e13ffe0f 	ldh	r4,-8(fp)
80141318:	e0bffc8b 	ldhu	r2,-14(fp)
8014131c:	10ffffcc 	andi	r3,r2,65535
80141320:	00a005b4 	movhi	r2,32790
80141324:	10929004 	addi	r2,r2,19008
80141328:	200891ba 	slli	r4,r4,6
8014132c:	1105883a 	add	r2,r2,r4
80141330:	10800704 	addi	r2,r2,28
80141334:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
80141338:	e0fffe0f 	ldh	r3,-8(fp)
8014133c:	00a005b4 	movhi	r2,32790
80141340:	10929004 	addi	r2,r2,19008
80141344:	180691ba 	slli	r3,r3,6
80141348:	10c5883a 	add	r2,r2,r3
8014134c:	10800804 	addi	r2,r2,32
80141350:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
80141354:	00a005b4 	movhi	r2,32790
80141358:	10927b04 	addi	r2,r2,18924
8014135c:	10c01417 	ldw	r3,80(r2)
80141360:	e13ffe0f 	ldh	r4,-8(fp)
80141364:	00a005b4 	movhi	r2,32790
80141368:	10929004 	addi	r2,r2,19008
8014136c:	200891ba 	slli	r4,r4,6
80141370:	1105883a 	add	r2,r2,r4
80141374:	10800704 	addi	r2,r2,28
80141378:	10800017 	ldw	r2,0(r2)
8014137c:	113fff84 	addi	r4,r2,-2
80141380:	00a005b4 	movhi	r2,32790
80141384:	10927b04 	addi	r2,r2,18924
80141388:	10800383 	ldbu	r2,14(r2)
8014138c:	10803fcc 	andi	r2,r2,255
80141390:	2085383a 	mul	r2,r4,r2
80141394:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
80141398:	e13ffe0f 	ldh	r4,-8(fp)
8014139c:	00a005b4 	movhi	r2,32790
801413a0:	10929004 	addi	r2,r2,19008
801413a4:	200891ba 	slli	r4,r4,6
801413a8:	1105883a 	add	r2,r2,r4
801413ac:	10800804 	addi	r2,r2,32
801413b0:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
801413b4:	1885883a 	add	r2,r3,r2
801413b8:	e0bffb15 	stw	r2,-20(fp)
801413bc:	00009706 	br	8014161c <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
801413c0:	0005883a 	mov	r2,zero
801413c4:	0000e106 	br	8014174c <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
801413c8:	e13ffe0f 	ldh	r4,-8(fp)
801413cc:	e0fffe0f 	ldh	r3,-8(fp)
801413d0:	00a005b4 	movhi	r2,32790
801413d4:	10929004 	addi	r2,r2,19008
801413d8:	180691ba 	slli	r3,r3,6
801413dc:	10c5883a 	add	r2,r2,r3
801413e0:	10800804 	addi	r2,r2,32
801413e4:	10800017 	ldw	r2,0(r2)
801413e8:	10c00044 	addi	r3,r2,1
801413ec:	00a005b4 	movhi	r2,32790
801413f0:	10929004 	addi	r2,r2,19008
801413f4:	200891ba 	slli	r4,r4,6
801413f8:	1105883a 	add	r2,r2,r4
801413fc:	10800804 	addi	r2,r2,32
80141400:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
80141404:	e0bffb17 	ldw	r2,-20(fp)
80141408:	10800044 	addi	r2,r2,1
8014140c:	e0bffb15 	stw	r2,-20(fp)
80141410:	00008206 	br	8014161c <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
80141414:	e0fffe0f 	ldh	r3,-8(fp)
80141418:	00a005b4 	movhi	r2,32790
8014141c:	10929004 	addi	r2,r2,19008
80141420:	180691ba 	slli	r3,r3,6
80141424:	10c5883a 	add	r2,r2,r3
80141428:	10800904 	addi	r2,r2,36
8014142c:	10800017 	ldw	r2,0(r2)
80141430:	10007a26 	beq	r2,zero,8014161c <alt_up_sd_card_write+0x4e4>
80141434:	e0bffc0f 	ldh	r2,-16(fp)
80141438:	1000781e 	bne	r2,zero,8014161c <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8014143c:	e0fffe0f 	ldh	r3,-8(fp)
80141440:	00a005b4 	movhi	r2,32790
80141444:	10929004 	addi	r2,r2,19008
80141448:	180691ba 	slli	r3,r3,6
8014144c:	10c5883a 	add	r2,r2,r3
80141450:	10800804 	addi	r2,r2,32
80141454:	10c00017 	ldw	r3,0(r2)
80141458:	00a005b4 	movhi	r2,32790
8014145c:	10927b04 	addi	r2,r2,18924
80141460:	10800383 	ldbu	r2,14(r2)
80141464:	10803fcc 	andi	r2,r2,255
80141468:	10bfffc4 	addi	r2,r2,-1
8014146c:	18803e1e 	bne	r3,r2,80141568 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
80141470:	e0bffd04 	addi	r2,fp,-12
80141474:	1009883a 	mov	r4,r2
80141478:	013f7880 	call	8013f788 <find_first_empty_cluster>
8014147c:	10003826 	beq	r2,zero,80141560 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
80141480:	e0fffe0f 	ldh	r3,-8(fp)
80141484:	00a005b4 	movhi	r2,32790
80141488:	10929004 	addi	r2,r2,19008
8014148c:	180691ba 	slli	r3,r3,6
80141490:	10c5883a 	add	r2,r2,r3
80141494:	10800704 	addi	r2,r2,28
80141498:	10800017 	ldw	r2,0(r2)
8014149c:	e0fffd17 	ldw	r3,-12(fp)
801414a0:	18ffffcc 	andi	r3,r3,65535
801414a4:	18e0001c 	xori	r3,r3,32768
801414a8:	18e00004 	addi	r3,r3,-32768
801414ac:	01800044 	movi	r6,1
801414b0:	180b883a 	mov	r5,r3
801414b4:	1009883a 	mov	r4,r2
801414b8:	013d8000 	call	8013d800 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
801414bc:	e0bffd17 	ldw	r2,-12(fp)
801414c0:	01800044 	movi	r6,1
801414c4:	017fffc4 	movi	r5,-1
801414c8:	1009883a 	mov	r4,r2
801414cc:	013d8000 	call	8013d800 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
801414d0:	e0fffe0f 	ldh	r3,-8(fp)
801414d4:	00a005b4 	movhi	r2,32790
801414d8:	10929004 	addi	r2,r2,19008
801414dc:	180691ba 	slli	r3,r3,6
801414e0:	10c5883a 	add	r2,r2,r3
801414e4:	10800704 	addi	r2,r2,28
801414e8:	10800017 	ldw	r2,0(r2)
801414ec:	e0fffd17 	ldw	r3,-12(fp)
801414f0:	18ffffcc 	andi	r3,r3,65535
801414f4:	18e0001c 	xori	r3,r3,32768
801414f8:	18e00004 	addi	r3,r3,-32768
801414fc:	000d883a 	mov	r6,zero
80141500:	180b883a 	mov	r5,r3
80141504:	1009883a 	mov	r4,r2
80141508:	013d8000 	call	8013d800 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
8014150c:	e0bffd17 	ldw	r2,-12(fp)
80141510:	000d883a 	mov	r6,zero
80141514:	017fffc4 	movi	r5,-1
80141518:	1009883a 	mov	r4,r2
8014151c:	013d8000 	call	8013d800 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
80141520:	e13ffe0f 	ldh	r4,-8(fp)
80141524:	e0fffd17 	ldw	r3,-12(fp)
80141528:	00a005b4 	movhi	r2,32790
8014152c:	10929004 	addi	r2,r2,19008
80141530:	200891ba 	slli	r4,r4,6
80141534:	1105883a 	add	r2,r2,r4
80141538:	10800704 	addi	r2,r2,28
8014153c:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
80141540:	e0fffe0f 	ldh	r3,-8(fp)
80141544:	00a005b4 	movhi	r2,32790
80141548:	10929004 	addi	r2,r2,19008
8014154c:	180691ba 	slli	r3,r3,6
80141550:	10c5883a 	add	r2,r2,r3
80141554:	10800804 	addi	r2,r2,32
80141558:	10000015 	stw	zero,0(r2)
8014155c:	00001506 	br	801415b4 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
80141560:	0005883a 	mov	r2,zero
80141564:	00007906 	br	8014174c <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
80141568:	e13ffe0f 	ldh	r4,-8(fp)
8014156c:	e0fffe0f 	ldh	r3,-8(fp)
80141570:	00a005b4 	movhi	r2,32790
80141574:	10929004 	addi	r2,r2,19008
80141578:	180691ba 	slli	r3,r3,6
8014157c:	10c5883a 	add	r2,r2,r3
80141580:	10800904 	addi	r2,r2,36
80141584:	10c00017 	ldw	r3,0(r2)
80141588:	00a005b4 	movhi	r2,32790
8014158c:	10927b04 	addi	r2,r2,18924
80141590:	1080030b 	ldhu	r2,12(r2)
80141594:	10bfffcc 	andi	r2,r2,65535
80141598:	1887203a 	divu	r3,r3,r2
8014159c:	00a005b4 	movhi	r2,32790
801415a0:	10929004 	addi	r2,r2,19008
801415a4:	200891ba 	slli	r4,r4,6
801415a8:	1105883a 	add	r2,r2,r4
801415ac:	10800804 	addi	r2,r2,32
801415b0:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
801415b4:	00a005b4 	movhi	r2,32790
801415b8:	10927b04 	addi	r2,r2,18924
801415bc:	10c01417 	ldw	r3,80(r2)
801415c0:	e13ffe0f 	ldh	r4,-8(fp)
801415c4:	00a005b4 	movhi	r2,32790
801415c8:	10929004 	addi	r2,r2,19008
801415cc:	200891ba 	slli	r4,r4,6
801415d0:	1105883a 	add	r2,r2,r4
801415d4:	10800704 	addi	r2,r2,28
801415d8:	10800017 	ldw	r2,0(r2)
801415dc:	113fff84 	addi	r4,r2,-2
801415e0:	00a005b4 	movhi	r2,32790
801415e4:	10927b04 	addi	r2,r2,18924
801415e8:	10800383 	ldbu	r2,14(r2)
801415ec:	10803fcc 	andi	r2,r2,255
801415f0:	2085383a 	mul	r2,r4,r2
801415f4:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
801415f8:	e13ffe0f 	ldh	r4,-8(fp)
801415fc:	00a005b4 	movhi	r2,32790
80141600:	10929004 	addi	r2,r2,19008
80141604:	200891ba 	slli	r4,r4,6
80141608:	1105883a 	add	r2,r2,r4
8014160c:	10800804 	addi	r2,r2,32
80141610:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
80141614:	1885883a 	add	r2,r3,r2
80141618:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
8014161c:	d0e0ba17 	ldw	r3,-32024(gp)
80141620:	e0bffb17 	ldw	r2,-20(fp)
80141624:	1885883a 	add	r2,r3,r2
80141628:	1007883a 	mov	r3,r2
8014162c:	d0a0be17 	ldw	r2,-32008(gp)
80141630:	18800726 	beq	r3,r2,80141650 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
80141634:	d0a0ba17 	ldw	r2,-32024(gp)
80141638:	100b883a 	mov	r5,r2
8014163c:	e13ffb17 	ldw	r4,-20(fp)
80141640:	013d6640 	call	8013d664 <Read_Sector_Data>
80141644:	1000021e 	bne	r2,zero,80141650 <alt_up_sd_card_write+0x518>
                {
					return false;
80141648:	0005883a 	mov	r2,zero
8014164c:	00003f06 	br	8014174c <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
80141650:	d0e0b917 	ldw	r3,-32028(gp)
80141654:	e0bffc0f 	ldh	r2,-16(fp)
80141658:	1885883a 	add	r2,r3,r2
8014165c:	e0ffff07 	ldb	r3,-4(fp)
80141660:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
80141664:	e13ffe0f 	ldh	r4,-8(fp)
80141668:	e0fffe0f 	ldh	r3,-8(fp)
8014166c:	00a005b4 	movhi	r2,32790
80141670:	10929004 	addi	r2,r2,19008
80141674:	180691ba 	slli	r3,r3,6
80141678:	10c5883a 	add	r2,r2,r3
8014167c:	10800904 	addi	r2,r2,36
80141680:	10800017 	ldw	r2,0(r2)
80141684:	10c00044 	addi	r3,r2,1
80141688:	00a005b4 	movhi	r2,32790
8014168c:	10929004 	addi	r2,r2,19008
80141690:	200891ba 	slli	r4,r4,6
80141694:	1105883a 	add	r2,r2,r4
80141698:	10800904 	addi	r2,r2,36
8014169c:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
801416a0:	e0fffe0f 	ldh	r3,-8(fp)
801416a4:	00a005b4 	movhi	r2,32790
801416a8:	10929004 	addi	r2,r2,19008
801416ac:	180691ba 	slli	r3,r3,6
801416b0:	10c5883a 	add	r2,r2,r3
801416b4:	10800904 	addi	r2,r2,36
801416b8:	10c00017 	ldw	r3,0(r2)
801416bc:	e13ffe0f 	ldh	r4,-8(fp)
801416c0:	00a005b4 	movhi	r2,32790
801416c4:	10929004 	addi	r2,r2,19008
801416c8:	200891ba 	slli	r4,r4,6
801416cc:	1105883a 	add	r2,r2,r4
801416d0:	10800604 	addi	r2,r2,24
801416d4:	10800017 	ldw	r2,0(r2)
801416d8:	18801736 	bltu	r3,r2,80141738 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
801416dc:	e13ffe0f 	ldh	r4,-8(fp)
801416e0:	e0fffe0f 	ldh	r3,-8(fp)
801416e4:	00a005b4 	movhi	r2,32790
801416e8:	10929004 	addi	r2,r2,19008
801416ec:	180691ba 	slli	r3,r3,6
801416f0:	10c5883a 	add	r2,r2,r3
801416f4:	10800604 	addi	r2,r2,24
801416f8:	10800017 	ldw	r2,0(r2)
801416fc:	10c00044 	addi	r3,r2,1
80141700:	00a005b4 	movhi	r2,32790
80141704:	10929004 	addi	r2,r2,19008
80141708:	200891ba 	slli	r4,r4,6
8014170c:	1105883a 	add	r2,r2,r4
80141710:	10800604 	addi	r2,r2,24
80141714:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
80141718:	e0fffe0f 	ldh	r3,-8(fp)
8014171c:	00a005b4 	movhi	r2,32790
80141720:	10929004 	addi	r2,r2,19008
80141724:	180691ba 	slli	r3,r3,6
80141728:	10c5883a 	add	r2,r2,r3
8014172c:	10800e04 	addi	r2,r2,56
80141730:	00c00044 	movi	r3,1
80141734:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
80141738:	00800044 	movi	r2,1
8014173c:	d0a0bd15 	stw	r2,-32012(gp)
			result = true;
80141740:	00800044 	movi	r2,1
80141744:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
80141748:	e0bffa17 	ldw	r2,-24(fp)
}
8014174c:	e037883a 	mov	sp,fp
80141750:	dfc00117 	ldw	ra,4(sp)
80141754:	df000017 	ldw	fp,0(sp)
80141758:	dec00204 	addi	sp,sp,8
8014175c:	f800283a 	ret

80141760 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
80141760:	defffb04 	addi	sp,sp,-20
80141764:	de00012e 	bgeu	sp,et,8014176c <alt_up_sd_card_fclose+0xc>
80141768:	003b68fa 	trap	3
8014176c:	dfc00415 	stw	ra,16(sp)
80141770:	df000315 	stw	fp,12(sp)
80141774:	df000304 	addi	fp,sp,12
80141778:	2005883a 	mov	r2,r4
8014177c:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
80141780:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
80141784:	014033c0 	call	8014033c <alt_up_sd_card_is_Present>
80141788:	10006026 	beq	r2,zero,8014190c <alt_up_sd_card_fclose+0x1ac>
8014178c:	d0a0b317 	ldw	r2,-32052(gp)
80141790:	10005e26 	beq	r2,zero,8014190c <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
80141794:	e0ffff0f 	ldh	r3,-4(fp)
80141798:	00a005b4 	movhi	r2,32790
8014179c:	10929004 	addi	r2,r2,19008
801417a0:	180691ba 	slli	r3,r3,6
801417a4:	10c5883a 	add	r2,r2,r3
801417a8:	10800f04 	addi	r2,r2,60
801417ac:	10800017 	ldw	r2,0(r2)
801417b0:	10005626 	beq	r2,zero,8014190c <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
801417b4:	e0ffff0f 	ldh	r3,-4(fp)
801417b8:	00a005b4 	movhi	r2,32790
801417bc:	10929004 	addi	r2,r2,19008
801417c0:	180691ba 	slli	r3,r3,6
801417c4:	10c5883a 	add	r2,r2,r3
801417c8:	10800e04 	addi	r2,r2,56
801417cc:	10800017 	ldw	r2,0(r2)
801417d0:	10004526 	beq	r2,zero,801418e8 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
801417d4:	e0ffff0f 	ldh	r3,-4(fp)
801417d8:	00a005b4 	movhi	r2,32790
801417dc:	10929004 	addi	r2,r2,19008
801417e0:	180691ba 	slli	r3,r3,6
801417e4:	10c5883a 	add	r2,r2,r3
801417e8:	10800b04 	addi	r2,r2,44
801417ec:	10800017 	ldw	r2,0(r2)
801417f0:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
801417f4:	e0ffff0f 	ldh	r3,-4(fp)
801417f8:	00a005b4 	movhi	r2,32790
801417fc:	10929004 	addi	r2,r2,19008
80141800:	180691ba 	slli	r3,r3,6
80141804:	10c5883a 	add	r2,r2,r3
80141808:	10800a04 	addi	r2,r2,40
8014180c:	10800017 	ldw	r2,0(r2)
80141810:	1000071e 	bne	r2,zero,80141830 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
80141814:	00a005b4 	movhi	r2,32790
80141818:	10927b04 	addi	r2,r2,18924
8014181c:	10801317 	ldw	r2,76(r2)
80141820:	e0fffe17 	ldw	r3,-8(fp)
80141824:	1885883a 	add	r2,r3,r2
80141828:	e0bffe15 	stw	r2,-8(fp)
8014182c:	00001406 	br	80141880 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
80141830:	00a005b4 	movhi	r2,32790
80141834:	10927b04 	addi	r2,r2,18924
80141838:	10c01417 	ldw	r3,80(r2)
8014183c:	e0bffe17 	ldw	r2,-8(fp)
80141840:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
80141844:	e13fff0f 	ldh	r4,-4(fp)
80141848:	00a005b4 	movhi	r2,32790
8014184c:	10929004 	addi	r2,r2,19008
80141850:	200891ba 	slli	r4,r4,6
80141854:	1105883a 	add	r2,r2,r4
80141858:	10800a04 	addi	r2,r2,40
8014185c:	10800017 	ldw	r2,0(r2)
80141860:	113fff84 	addi	r4,r2,-2
80141864:	00a005b4 	movhi	r2,32790
80141868:	10927b04 	addi	r2,r2,18924
8014186c:	10800383 	ldbu	r2,14(r2)
80141870:	10803fcc 	andi	r2,r2,255
80141874:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
80141878:	1885883a 	add	r2,r3,r2
8014187c:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
80141880:	e0bffe17 	ldw	r2,-8(fp)
80141884:	d0e0ba17 	ldw	r3,-32024(gp)
80141888:	180b883a 	mov	r5,r3
8014188c:	1009883a 	mov	r4,r2
80141890:	013d6640 	call	8013d664 <Read_Sector_Data>
80141894:	10001426 	beq	r2,zero,801418e8 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
80141898:	e0ffff0f 	ldh	r3,-4(fp)
8014189c:	00a005b4 	movhi	r2,32790
801418a0:	10929004 	addi	r2,r2,19008
801418a4:	180691ba 	slli	r3,r3,6
801418a8:	10c5883a 	add	r2,r2,r3
801418ac:	10800c04 	addi	r2,r2,48
801418b0:	1080000b 	ldhu	r2,0(r2)
801418b4:	113fffcc 	andi	r4,r2,65535
801418b8:	2120001c 	xori	r4,r4,32768
801418bc:	21200004 	addi	r4,r4,-32768
801418c0:	e0bfff0f 	ldh	r2,-4(fp)
801418c4:	100691ba 	slli	r3,r2,6
801418c8:	00a005b4 	movhi	r2,32790
801418cc:	10929004 	addi	r2,r2,19008
801418d0:	1885883a 	add	r2,r3,r2
801418d4:	100b883a 	mov	r5,r2
801418d8:	013dd180 	call	8013dd18 <Write_File_Record_At_Offset>
801418dc:	10000226 	beq	r2,zero,801418e8 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
801418e0:	013d6100 	call	8013d610 <Save_Modified_Sector>
801418e4:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
801418e8:	e0ffff0f 	ldh	r3,-4(fp)
801418ec:	00a005b4 	movhi	r2,32790
801418f0:	10929004 	addi	r2,r2,19008
801418f4:	180691ba 	slli	r3,r3,6
801418f8:	10c5883a 	add	r2,r2,r3
801418fc:	10800f04 	addi	r2,r2,60
80141900:	10000015 	stw	zero,0(r2)
			result = true;
80141904:	00800044 	movi	r2,1
80141908:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
8014190c:	e0bffd17 	ldw	r2,-12(fp)
}
80141910:	e037883a 	mov	sp,fp
80141914:	dfc00117 	ldw	ra,4(sp)
80141918:	df000017 	ldw	fp,0(sp)
8014191c:	dec00204 	addi	sp,sp,8
80141920:	f800283a 	ret

80141924 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
80141924:	defffa04 	addi	sp,sp,-24
80141928:	de00012e 	bgeu	sp,et,80141930 <altera_avalon_jtag_uart_read_fd+0xc>
8014192c:	003b68fa 	trap	3
80141930:	dfc00515 	stw	ra,20(sp)
80141934:	df000415 	stw	fp,16(sp)
80141938:	df000404 	addi	fp,sp,16
8014193c:	e13ffd15 	stw	r4,-12(fp)
80141940:	e17ffe15 	stw	r5,-8(fp)
80141944:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
80141948:	e0bffd17 	ldw	r2,-12(fp)
8014194c:	10800017 	ldw	r2,0(r2)
80141950:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
80141954:	e0bffc17 	ldw	r2,-16(fp)
80141958:	10c00a04 	addi	r3,r2,40
8014195c:	e0bffd17 	ldw	r2,-12(fp)
80141960:	10800217 	ldw	r2,8(r2)
80141964:	100f883a 	mov	r7,r2
80141968:	e1bfff17 	ldw	r6,-4(fp)
8014196c:	e17ffe17 	ldw	r5,-8(fp)
80141970:	1809883a 	mov	r4,r3
80141974:	01421a80 	call	801421a8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
80141978:	e037883a 	mov	sp,fp
8014197c:	dfc00117 	ldw	ra,4(sp)
80141980:	df000017 	ldw	fp,0(sp)
80141984:	dec00204 	addi	sp,sp,8
80141988:	f800283a 	ret

8014198c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8014198c:	defffa04 	addi	sp,sp,-24
80141990:	de00012e 	bgeu	sp,et,80141998 <altera_avalon_jtag_uart_write_fd+0xc>
80141994:	003b68fa 	trap	3
80141998:	dfc00515 	stw	ra,20(sp)
8014199c:	df000415 	stw	fp,16(sp)
801419a0:	df000404 	addi	fp,sp,16
801419a4:	e13ffd15 	stw	r4,-12(fp)
801419a8:	e17ffe15 	stw	r5,-8(fp)
801419ac:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
801419b0:	e0bffd17 	ldw	r2,-12(fp)
801419b4:	10800017 	ldw	r2,0(r2)
801419b8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
801419bc:	e0bffc17 	ldw	r2,-16(fp)
801419c0:	10c00a04 	addi	r3,r2,40
801419c4:	e0bffd17 	ldw	r2,-12(fp)
801419c8:	10800217 	ldw	r2,8(r2)
801419cc:	100f883a 	mov	r7,r2
801419d0:	e1bfff17 	ldw	r6,-4(fp)
801419d4:	e17ffe17 	ldw	r5,-8(fp)
801419d8:	1809883a 	mov	r4,r3
801419dc:	014246c0 	call	8014246c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
801419e0:	e037883a 	mov	sp,fp
801419e4:	dfc00117 	ldw	ra,4(sp)
801419e8:	df000017 	ldw	fp,0(sp)
801419ec:	dec00204 	addi	sp,sp,8
801419f0:	f800283a 	ret

801419f4 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
801419f4:	defffc04 	addi	sp,sp,-16
801419f8:	de00012e 	bgeu	sp,et,80141a00 <altera_avalon_jtag_uart_close_fd+0xc>
801419fc:	003b68fa 	trap	3
80141a00:	dfc00315 	stw	ra,12(sp)
80141a04:	df000215 	stw	fp,8(sp)
80141a08:	df000204 	addi	fp,sp,8
80141a0c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
80141a10:	e0bfff17 	ldw	r2,-4(fp)
80141a14:	10800017 	ldw	r2,0(r2)
80141a18:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
80141a1c:	e0bffe17 	ldw	r2,-8(fp)
80141a20:	10c00a04 	addi	r3,r2,40
80141a24:	e0bfff17 	ldw	r2,-4(fp)
80141a28:	10800217 	ldw	r2,8(r2)
80141a2c:	100b883a 	mov	r5,r2
80141a30:	1809883a 	mov	r4,r3
80141a34:	01420400 	call	80142040 <altera_avalon_jtag_uart_close>
}
80141a38:	e037883a 	mov	sp,fp
80141a3c:	dfc00117 	ldw	ra,4(sp)
80141a40:	df000017 	ldw	fp,0(sp)
80141a44:	dec00204 	addi	sp,sp,8
80141a48:	f800283a 	ret

80141a4c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
80141a4c:	defffa04 	addi	sp,sp,-24
80141a50:	de00012e 	bgeu	sp,et,80141a58 <altera_avalon_jtag_uart_ioctl_fd+0xc>
80141a54:	003b68fa 	trap	3
80141a58:	dfc00515 	stw	ra,20(sp)
80141a5c:	df000415 	stw	fp,16(sp)
80141a60:	df000404 	addi	fp,sp,16
80141a64:	e13ffd15 	stw	r4,-12(fp)
80141a68:	e17ffe15 	stw	r5,-8(fp)
80141a6c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
80141a70:	e0bffd17 	ldw	r2,-12(fp)
80141a74:	10800017 	ldw	r2,0(r2)
80141a78:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
80141a7c:	e0bffc17 	ldw	r2,-16(fp)
80141a80:	10800a04 	addi	r2,r2,40
80141a84:	e1bfff17 	ldw	r6,-4(fp)
80141a88:	e17ffe17 	ldw	r5,-8(fp)
80141a8c:	1009883a 	mov	r4,r2
80141a90:	01420b00 	call	801420b0 <altera_avalon_jtag_uart_ioctl>
}
80141a94:	e037883a 	mov	sp,fp
80141a98:	dfc00117 	ldw	ra,4(sp)
80141a9c:	df000017 	ldw	fp,0(sp)
80141aa0:	dec00204 	addi	sp,sp,8
80141aa4:	f800283a 	ret

80141aa8 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
80141aa8:	deffef04 	addi	sp,sp,-68
80141aac:	de00012e 	bgeu	sp,et,80141ab4 <altera_avalon_jtag_uart_init+0xc>
80141ab0:	003b68fa 	trap	3
80141ab4:	dfc01015 	stw	ra,64(sp)
80141ab8:	df000f15 	stw	fp,60(sp)
80141abc:	dc400e15 	stw	r17,56(sp)
80141ac0:	dc000d15 	stw	r16,52(sp)
80141ac4:	df000f04 	addi	fp,sp,60
80141ac8:	e13ff715 	stw	r4,-36(fp)
80141acc:	e17ff815 	stw	r5,-32(fp)
80141ad0:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
80141ad4:	e0bff717 	ldw	r2,-36(fp)
80141ad8:	10800c04 	addi	r2,r2,48
80141adc:	e0bff215 	stw	r2,-56(fp)
80141ae0:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
80141ae4:	e0bff60b 	ldhu	r2,-40(fp)
80141ae8:	e0fff684 	addi	r3,fp,-38
80141aec:	180b883a 	mov	r5,r3
80141af0:	1009883a 	mov	r4,r2
80141af4:	0135c780 	call	80135c78 <OSFlagCreate>
80141af8:	1007883a 	mov	r3,r2
80141afc:	e0bff217 	ldw	r2,-56(fp)
80141b00:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
80141b04:	e0bff717 	ldw	r2,-36(fp)
80141b08:	10800a04 	addi	r2,r2,40
80141b0c:	e0bff315 	stw	r2,-52(fp)
80141b10:	00800044 	movi	r2,1
80141b14:	e0bff58d 	sth	r2,-42(fp)
80141b18:	e0bff58b 	ldhu	r2,-42(fp)
80141b1c:	1009883a 	mov	r4,r2
80141b20:	0139bd40 	call	80139bd4 <OSSemCreate>
80141b24:	1007883a 	mov	r3,r2
80141b28:	e0bff317 	ldw	r2,-52(fp)
80141b2c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
80141b30:	e0bff717 	ldw	r2,-36(fp)
80141b34:	10800b04 	addi	r2,r2,44
80141b38:	e0bff415 	stw	r2,-48(fp)
80141b3c:	00800044 	movi	r2,1
80141b40:	e0bff50d 	sth	r2,-44(fp)
80141b44:	e0bff50b 	ldhu	r2,-44(fp)
80141b48:	1009883a 	mov	r4,r2
80141b4c:	0139bd40 	call	80139bd4 <OSSemCreate>
80141b50:	1007883a 	mov	r3,r2
80141b54:	e0bff417 	ldw	r2,-48(fp)
80141b58:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
80141b5c:	e0bff717 	ldw	r2,-36(fp)
80141b60:	00c00044 	movi	r3,1
80141b64:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
80141b68:	e0bff717 	ldw	r2,-36(fp)
80141b6c:	10800017 	ldw	r2,0(r2)
80141b70:	10800104 	addi	r2,r2,4
80141b74:	1007883a 	mov	r3,r2
80141b78:	e0bff717 	ldw	r2,-36(fp)
80141b7c:	10800817 	ldw	r2,32(r2)
80141b80:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
80141b84:	e0bff817 	ldw	r2,-32(fp)
80141b88:	e0fff917 	ldw	r3,-28(fp)
80141b8c:	d8000015 	stw	zero,0(sp)
80141b90:	e1fff717 	ldw	r7,-36(fp)
80141b94:	01a00534 	movhi	r6,32788
80141b98:	31871e04 	addi	r6,r6,7288
80141b9c:	180b883a 	mov	r5,r3
80141ba0:	1009883a 	mov	r4,r2
80141ba4:	01457cc0 	call	801457cc <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
80141ba8:	e0bff717 	ldw	r2,-36(fp)
80141bac:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
80141bb0:	e0bff717 	ldw	r2,-36(fp)
80141bb4:	10800204 	addi	r2,r2,8
80141bb8:	d0e09117 	ldw	r3,-32188(gp)
80141bbc:	e1fff717 	ldw	r7,-36(fp)
80141bc0:	01a00534 	movhi	r6,32788
80141bc4:	3187cd04 	addi	r6,r6,7988
80141bc8:	180b883a 	mov	r5,r3
80141bcc:	1009883a 	mov	r4,r2
80141bd0:	01455100 	call	80145510 <alt_alarm_start>
80141bd4:	1000040e 	bge	r2,zero,80141be8 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
80141bd8:	e0fff717 	ldw	r3,-36(fp)
80141bdc:	00a00034 	movhi	r2,32768
80141be0:	10bfffc4 	addi	r2,r2,-1
80141be4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
80141be8:	d0a08a83 	ldbu	r2,-32214(gp)
80141bec:	10803fcc 	andi	r2,r2,255
80141bf0:	10800058 	cmpnei	r2,r2,1
80141bf4:	10000f1e 	bne	r2,zero,80141c34 <altera_avalon_jtag_uart_init+0x18c>
80141bf8:	d0e09117 	ldw	r3,-32188(gp)
80141bfc:	00b33374 	movhi	r2,52429
80141c00:	10b33344 	addi	r2,r2,-13107
80141c04:	1888383a 	mulxuu	r4,r3,r2
80141c08:	1885383a 	mul	r2,r3,r2
80141c0c:	1021883a 	mov	r16,r2
80141c10:	2023883a 	mov	r17,r4
80141c14:	8804d0fa 	srli	r2,r17,3
80141c18:	e1fff717 	ldw	r7,-36(fp)
80141c1c:	01a004f4 	movhi	r6,32787
80141c20:	31898504 	addi	r6,r6,9748
80141c24:	100b883a 	mov	r5,r2
80141c28:	012005b4 	movhi	r4,32790
80141c2c:	213a4f04 	addi	r4,r4,-5828
80141c30:	01455100 	call	80145510 <alt_alarm_start>
80141c34:	d0a08b03 	ldbu	r2,-32212(gp)
80141c38:	10803fcc 	andi	r2,r2,255
80141c3c:	10800058 	cmpnei	r2,r2,1
80141c40:	1000051e 	bne	r2,zero,80141c58 <altera_avalon_jtag_uart_init+0x1b0>
80141c44:	e0bff717 	ldw	r2,-36(fp)
80141c48:	10800017 	ldw	r2,0(r2)
80141c4c:	100b883a 	mov	r5,r2
80141c50:	e13ff717 	ldw	r4,-36(fp)
80141c54:	01327ac0 	call	801327ac <alt_log_jtag_uart_startup_info>
}
80141c58:	0001883a 	nop
80141c5c:	e6fffe04 	addi	sp,fp,-8
80141c60:	dfc00317 	ldw	ra,12(sp)
80141c64:	df000217 	ldw	fp,8(sp)
80141c68:	dc400117 	ldw	r17,4(sp)
80141c6c:	dc000017 	ldw	r16,0(sp)
80141c70:	dec00404 	addi	sp,sp,16
80141c74:	f800283a 	ret

80141c78 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
80141c78:	defff204 	addi	sp,sp,-56
80141c7c:	de00012e 	bgeu	sp,et,80141c84 <altera_avalon_jtag_uart_irq+0xc>
80141c80:	003b68fa 	trap	3
80141c84:	dfc00d15 	stw	ra,52(sp)
80141c88:	df000c15 	stw	fp,48(sp)
80141c8c:	df000c04 	addi	fp,sp,48
80141c90:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
80141c94:	e0bfff17 	ldw	r2,-4(fp)
80141c98:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
80141c9c:	e0bff617 	ldw	r2,-40(fp)
80141ca0:	10800017 	ldw	r2,0(r2)
80141ca4:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
80141ca8:	e0bff717 	ldw	r2,-36(fp)
80141cac:	e17ff617 	ldw	r5,-40(fp)
80141cb0:	1009883a 	mov	r4,r2
80141cb4:	01328000 	call	80132800 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
80141cb8:	e0bff717 	ldw	r2,-36(fp)
80141cbc:	10800104 	addi	r2,r2,4
80141cc0:	10800037 	ldwio	r2,0(r2)
80141cc4:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
80141cc8:	e0bff817 	ldw	r2,-32(fp)
80141ccc:	1080c00c 	andi	r2,r2,768
80141cd0:	10009126 	beq	r2,zero,80141f18 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
80141cd4:	e0bff817 	ldw	r2,-32(fp)
80141cd8:	1080400c 	andi	r2,r2,256
80141cdc:	10004726 	beq	r2,zero,80141dfc <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
80141ce0:	00800074 	movhi	r2,1
80141ce4:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
80141ce8:	e0bff617 	ldw	r2,-40(fp)
80141cec:	10800d17 	ldw	r2,52(r2)
80141cf0:	10800044 	addi	r2,r2,1
80141cf4:	1081ffcc 	andi	r2,r2,2047
80141cf8:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
80141cfc:	e0bff617 	ldw	r2,-40(fp)
80141d00:	10c00e17 	ldw	r3,56(r2)
80141d04:	e0bff917 	ldw	r2,-28(fp)
80141d08:	18802726 	beq	r3,r2,80141da8 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
80141d0c:	e0bff717 	ldw	r2,-36(fp)
80141d10:	10800037 	ldwio	r2,0(r2)
80141d14:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
80141d18:	e0bff417 	ldw	r2,-48(fp)
80141d1c:	10a0000c 	andi	r2,r2,32768
80141d20:	10002326 	beq	r2,zero,80141db0 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
80141d24:	e0bff617 	ldw	r2,-40(fp)
80141d28:	10800d17 	ldw	r2,52(r2)
80141d2c:	e0fff417 	ldw	r3,-48(fp)
80141d30:	1809883a 	mov	r4,r3
80141d34:	e0fff617 	ldw	r3,-40(fp)
80141d38:	1885883a 	add	r2,r3,r2
80141d3c:	10801104 	addi	r2,r2,68
80141d40:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
80141d44:	e0bff617 	ldw	r2,-40(fp)
80141d48:	10800d17 	ldw	r2,52(r2)
80141d4c:	10800044 	addi	r2,r2,1
80141d50:	10c1ffcc 	andi	r3,r2,2047
80141d54:	e0bff617 	ldw	r2,-40(fp)
80141d58:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
80141d5c:	e0bff617 	ldw	r2,-40(fp)
80141d60:	10800c17 	ldw	r2,48(r2)
80141d64:	e0bffb15 	stw	r2,-20(fp)
80141d68:	00800044 	movi	r2,1
80141d6c:	e0bffc0d 	sth	r2,-16(fp)
80141d70:	00800044 	movi	r2,1
80141d74:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
80141d78:	d0a09a03 	ldbu	r2,-32152(gp)
80141d7c:	10803fcc 	andi	r2,r2,255
80141d80:	103fd926 	beq	r2,zero,80141ce8 <__reset+0xfa121ce8>
  {
    OSFlagPost (group, flags, opt, &err);
80141d84:	e0bffc0b 	ldhu	r2,-16(fp)
80141d88:	e0fffc83 	ldbu	r3,-14(fp)
80141d8c:	e13ffdc4 	addi	r4,fp,-9
80141d90:	200f883a 	mov	r7,r4
80141d94:	180d883a 	mov	r6,r3
80141d98:	100b883a 	mov	r5,r2
80141d9c:	e13ffb17 	ldw	r4,-20(fp)
80141da0:	01368840 	call	80136884 <OSFlagPost>
      }
80141da4:	003fd006 	br	80141ce8 <__reset+0xfa121ce8>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
80141da8:	0001883a 	nop
80141dac:	00000106 	br	80141db4 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
80141db0:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
80141db4:	e0bff417 	ldw	r2,-48(fp)
80141db8:	10bfffec 	andhi	r2,r2,65535
80141dbc:	10000f26 	beq	r2,zero,80141dfc <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
80141dc0:	e0bff617 	ldw	r2,-40(fp)
80141dc4:	10c00817 	ldw	r3,32(r2)
80141dc8:	00bfff84 	movi	r2,-2
80141dcc:	1886703a 	and	r3,r3,r2
80141dd0:	e0bff617 	ldw	r2,-40(fp)
80141dd4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
80141dd8:	e0bff717 	ldw	r2,-36(fp)
80141ddc:	10800104 	addi	r2,r2,4
80141de0:	1007883a 	mov	r3,r2
80141de4:	e0bff617 	ldw	r2,-40(fp)
80141de8:	10800817 	ldw	r2,32(r2)
80141dec:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
80141df0:	e0bff717 	ldw	r2,-36(fp)
80141df4:	10800104 	addi	r2,r2,4
80141df8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
80141dfc:	e0bff817 	ldw	r2,-32(fp)
80141e00:	1080800c 	andi	r2,r2,512
80141e04:	103fac26 	beq	r2,zero,80141cb8 <__reset+0xfa121cb8>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
80141e08:	e0bff817 	ldw	r2,-32(fp)
80141e0c:	1004d43a 	srli	r2,r2,16
80141e10:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
80141e14:	00002606 	br	80141eb0 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
80141e18:	e0bff717 	ldw	r2,-36(fp)
80141e1c:	e0fff617 	ldw	r3,-40(fp)
80141e20:	18c01017 	ldw	r3,64(r3)
80141e24:	e13ff617 	ldw	r4,-40(fp)
80141e28:	20c7883a 	add	r3,r4,r3
80141e2c:	18c21104 	addi	r3,r3,2116
80141e30:	18c00003 	ldbu	r3,0(r3)
80141e34:	18c03fcc 	andi	r3,r3,255
80141e38:	18c0201c 	xori	r3,r3,128
80141e3c:	18ffe004 	addi	r3,r3,-128
80141e40:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
80141e44:	e0bff617 	ldw	r2,-40(fp)
80141e48:	10801017 	ldw	r2,64(r2)
80141e4c:	10800044 	addi	r2,r2,1
80141e50:	10c1ffcc 	andi	r3,r2,2047
80141e54:	e0bff617 	ldw	r2,-40(fp)
80141e58:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
80141e5c:	e0bff617 	ldw	r2,-40(fp)
80141e60:	10800c17 	ldw	r2,48(r2)
80141e64:	e0bffa15 	stw	r2,-24(fp)
80141e68:	00800084 	movi	r2,2
80141e6c:	e0bffd0d 	sth	r2,-12(fp)
80141e70:	00800044 	movi	r2,1
80141e74:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
80141e78:	d0a09a03 	ldbu	r2,-32152(gp)
80141e7c:	10803fcc 	andi	r2,r2,255
80141e80:	10000826 	beq	r2,zero,80141ea4 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
80141e84:	e0bffd0b 	ldhu	r2,-12(fp)
80141e88:	e0fffd83 	ldbu	r3,-10(fp)
80141e8c:	e13ffe04 	addi	r4,fp,-8
80141e90:	200f883a 	mov	r7,r4
80141e94:	180d883a 	mov	r6,r3
80141e98:	100b883a 	mov	r5,r2
80141e9c:	e13ffa17 	ldw	r4,-24(fp)
80141ea0:	01368840 	call	80136884 <OSFlagPost>

        space--;
80141ea4:	e0bff517 	ldw	r2,-44(fp)
80141ea8:	10bfffc4 	addi	r2,r2,-1
80141eac:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
80141eb0:	e0bff517 	ldw	r2,-44(fp)
80141eb4:	10000526 	beq	r2,zero,80141ecc <altera_avalon_jtag_uart_irq+0x254>
80141eb8:	e0bff617 	ldw	r2,-40(fp)
80141ebc:	10c01017 	ldw	r3,64(r2)
80141ec0:	e0bff617 	ldw	r2,-40(fp)
80141ec4:	10800f17 	ldw	r2,60(r2)
80141ec8:	18bfd31e 	bne	r3,r2,80141e18 <__reset+0xfa121e18>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
80141ecc:	e0bff517 	ldw	r2,-44(fp)
80141ed0:	103f7926 	beq	r2,zero,80141cb8 <__reset+0xfa121cb8>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
80141ed4:	e0bff617 	ldw	r2,-40(fp)
80141ed8:	10c00817 	ldw	r3,32(r2)
80141edc:	00bfff44 	movi	r2,-3
80141ee0:	1886703a 	and	r3,r3,r2
80141ee4:	e0bff617 	ldw	r2,-40(fp)
80141ee8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
80141eec:	e0bff617 	ldw	r2,-40(fp)
80141ef0:	10800017 	ldw	r2,0(r2)
80141ef4:	10800104 	addi	r2,r2,4
80141ef8:	1007883a 	mov	r3,r2
80141efc:	e0bff617 	ldw	r2,-40(fp)
80141f00:	10800817 	ldw	r2,32(r2)
80141f04:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
80141f08:	e0bff717 	ldw	r2,-36(fp)
80141f0c:	10800104 	addi	r2,r2,4
80141f10:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
80141f14:	003f6806 	br	80141cb8 <__reset+0xfa121cb8>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
80141f18:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
80141f1c:	0001883a 	nop
80141f20:	e037883a 	mov	sp,fp
80141f24:	dfc00117 	ldw	ra,4(sp)
80141f28:	df000017 	ldw	fp,0(sp)
80141f2c:	dec00204 	addi	sp,sp,8
80141f30:	f800283a 	ret

80141f34 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
80141f34:	defff904 	addi	sp,sp,-28
80141f38:	de00012e 	bgeu	sp,et,80141f40 <altera_avalon_jtag_uart_timeout+0xc>
80141f3c:	003b68fa 	trap	3
80141f40:	dfc00615 	stw	ra,24(sp)
80141f44:	df000515 	stw	fp,20(sp)
80141f48:	df000504 	addi	fp,sp,20
80141f4c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
80141f50:	e0bfff17 	ldw	r2,-4(fp)
80141f54:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
80141f58:	e0bffb17 	ldw	r2,-20(fp)
80141f5c:	10800017 	ldw	r2,0(r2)
80141f60:	10800104 	addi	r2,r2,4
80141f64:	10800037 	ldwio	r2,0(r2)
80141f68:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
80141f6c:	e0bffc17 	ldw	r2,-16(fp)
80141f70:	1081000c 	andi	r2,r2,1024
80141f74:	10000b26 	beq	r2,zero,80141fa4 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
80141f78:	e0bffb17 	ldw	r2,-20(fp)
80141f7c:	10800017 	ldw	r2,0(r2)
80141f80:	10800104 	addi	r2,r2,4
80141f84:	1007883a 	mov	r3,r2
80141f88:	e0bffb17 	ldw	r2,-20(fp)
80141f8c:	10800817 	ldw	r2,32(r2)
80141f90:	10810014 	ori	r2,r2,1024
80141f94:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
80141f98:	e0bffb17 	ldw	r2,-20(fp)
80141f9c:	10000915 	stw	zero,36(r2)
80141fa0:	00002106 	br	80142028 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
80141fa4:	e0bffb17 	ldw	r2,-20(fp)
80141fa8:	10c00917 	ldw	r3,36(r2)
80141fac:	00a00034 	movhi	r2,32768
80141fb0:	10bfff04 	addi	r2,r2,-4
80141fb4:	10c01c36 	bltu	r2,r3,80142028 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
80141fb8:	e0bffb17 	ldw	r2,-20(fp)
80141fbc:	10800917 	ldw	r2,36(r2)
80141fc0:	10c00044 	addi	r3,r2,1
80141fc4:	e0bffb17 	ldw	r2,-20(fp)
80141fc8:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
80141fcc:	e0bffb17 	ldw	r2,-20(fp)
80141fd0:	10c00917 	ldw	r3,36(r2)
80141fd4:	e0bffb17 	ldw	r2,-20(fp)
80141fd8:	10800117 	ldw	r2,4(r2)
80141fdc:	18801236 	bltu	r3,r2,80142028 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
80141fe0:	e0bffb17 	ldw	r2,-20(fp)
80141fe4:	10800c17 	ldw	r2,48(r2)
80141fe8:	e0bffd15 	stw	r2,-12(fp)
80141fec:	00800104 	movi	r2,4
80141ff0:	e0bffe0d 	sth	r2,-8(fp)
80141ff4:	00800044 	movi	r2,1
80141ff8:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
80141ffc:	d0a09a03 	ldbu	r2,-32152(gp)
80142000:	10803fcc 	andi	r2,r2,255
80142004:	10000826 	beq	r2,zero,80142028 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
80142008:	e0bffe0b 	ldhu	r2,-8(fp)
8014200c:	e0fffe83 	ldbu	r3,-6(fp)
80142010:	e13ffec4 	addi	r4,fp,-5
80142014:	200f883a 	mov	r7,r4
80142018:	180d883a 	mov	r6,r3
8014201c:	100b883a 	mov	r5,r2
80142020:	e13ffd17 	ldw	r4,-12(fp)
80142024:	01368840 	call	80136884 <OSFlagPost>
80142028:	d0a09117 	ldw	r2,-32188(gp)
    }
  }

  return alt_ticks_per_second();
}
8014202c:	e037883a 	mov	sp,fp
80142030:	dfc00117 	ldw	ra,4(sp)
80142034:	df000017 	ldw	fp,0(sp)
80142038:	dec00204 	addi	sp,sp,8
8014203c:	f800283a 	ret

80142040 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
80142040:	defffd04 	addi	sp,sp,-12
80142044:	de00012e 	bgeu	sp,et,8014204c <altera_avalon_jtag_uart_close+0xc>
80142048:	003b68fa 	trap	3
8014204c:	df000215 	stw	fp,8(sp)
80142050:	df000204 	addi	fp,sp,8
80142054:	e13ffe15 	stw	r4,-8(fp)
80142058:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
8014205c:	00000506 	br	80142074 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
80142060:	e0bfff17 	ldw	r2,-4(fp)
80142064:	1090000c 	andi	r2,r2,16384
80142068:	10000226 	beq	r2,zero,80142074 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
8014206c:	00bffd44 	movi	r2,-11
80142070:	00000b06 	br	801420a0 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
80142074:	e0bffe17 	ldw	r2,-8(fp)
80142078:	10c01017 	ldw	r3,64(r2)
8014207c:	e0bffe17 	ldw	r2,-8(fp)
80142080:	10800f17 	ldw	r2,60(r2)
80142084:	18800526 	beq	r3,r2,8014209c <altera_avalon_jtag_uart_close+0x5c>
80142088:	e0bffe17 	ldw	r2,-8(fp)
8014208c:	10c00917 	ldw	r3,36(r2)
80142090:	e0bffe17 	ldw	r2,-8(fp)
80142094:	10800117 	ldw	r2,4(r2)
80142098:	18bff136 	bltu	r3,r2,80142060 <__reset+0xfa122060>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
8014209c:	0005883a 	mov	r2,zero
}
801420a0:	e037883a 	mov	sp,fp
801420a4:	df000017 	ldw	fp,0(sp)
801420a8:	dec00104 	addi	sp,sp,4
801420ac:	f800283a 	ret

801420b0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
801420b0:	defffa04 	addi	sp,sp,-24
801420b4:	de00012e 	bgeu	sp,et,801420bc <altera_avalon_jtag_uart_ioctl+0xc>
801420b8:	003b68fa 	trap	3
801420bc:	df000515 	stw	fp,20(sp)
801420c0:	df000504 	addi	fp,sp,20
801420c4:	e13ffd15 	stw	r4,-12(fp)
801420c8:	e17ffe15 	stw	r5,-8(fp)
801420cc:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
801420d0:	00bff9c4 	movi	r2,-25
801420d4:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
801420d8:	e0bffe17 	ldw	r2,-8(fp)
801420dc:	10da8060 	cmpeqi	r3,r2,27137
801420e0:	1800031e 	bne	r3,zero,801420f0 <altera_avalon_jtag_uart_ioctl+0x40>
801420e4:	109a80a0 	cmpeqi	r2,r2,27138
801420e8:	1000181e 	bne	r2,zero,8014214c <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
801420ec:	00002906 	br	80142194 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
801420f0:	e0bffd17 	ldw	r2,-12(fp)
801420f4:	10c00117 	ldw	r3,4(r2)
801420f8:	00a00034 	movhi	r2,32768
801420fc:	10bfffc4 	addi	r2,r2,-1
80142100:	18802126 	beq	r3,r2,80142188 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
80142104:	e0bfff17 	ldw	r2,-4(fp)
80142108:	10800017 	ldw	r2,0(r2)
8014210c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
80142110:	e0bffc17 	ldw	r2,-16(fp)
80142114:	10800090 	cmplti	r2,r2,2
80142118:	1000061e 	bne	r2,zero,80142134 <altera_avalon_jtag_uart_ioctl+0x84>
8014211c:	e0fffc17 	ldw	r3,-16(fp)
80142120:	00a00034 	movhi	r2,32768
80142124:	10bfffc4 	addi	r2,r2,-1
80142128:	18800226 	beq	r3,r2,80142134 <altera_avalon_jtag_uart_ioctl+0x84>
8014212c:	e0bffc17 	ldw	r2,-16(fp)
80142130:	00000206 	br	8014213c <altera_avalon_jtag_uart_ioctl+0x8c>
80142134:	00a00034 	movhi	r2,32768
80142138:	10bfff84 	addi	r2,r2,-2
8014213c:	e0fffd17 	ldw	r3,-12(fp)
80142140:	18800115 	stw	r2,4(r3)
      rc = 0;
80142144:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
80142148:	00000f06 	br	80142188 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
8014214c:	e0bffd17 	ldw	r2,-12(fp)
80142150:	10c00117 	ldw	r3,4(r2)
80142154:	00a00034 	movhi	r2,32768
80142158:	10bfffc4 	addi	r2,r2,-1
8014215c:	18800c26 	beq	r3,r2,80142190 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
80142160:	e0bffd17 	ldw	r2,-12(fp)
80142164:	10c00917 	ldw	r3,36(r2)
80142168:	e0bffd17 	ldw	r2,-12(fp)
8014216c:	10800117 	ldw	r2,4(r2)
80142170:	1885803a 	cmpltu	r2,r3,r2
80142174:	10c03fcc 	andi	r3,r2,255
80142178:	e0bfff17 	ldw	r2,-4(fp)
8014217c:	10c00015 	stw	r3,0(r2)
      rc = 0;
80142180:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
80142184:	00000206 	br	80142190 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
80142188:	0001883a 	nop
8014218c:	00000106 	br	80142194 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
80142190:	0001883a 	nop

  default:
    break;
  }

  return rc;
80142194:	e0bffb17 	ldw	r2,-20(fp)
}
80142198:	e037883a 	mov	sp,fp
8014219c:	df000017 	ldw	fp,0(sp)
801421a0:	dec00104 	addi	sp,sp,4
801421a4:	f800283a 	ret

801421a8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
801421a8:	deffed04 	addi	sp,sp,-76
801421ac:	de00012e 	bgeu	sp,et,801421b4 <altera_avalon_jtag_uart_read+0xc>
801421b0:	003b68fa 	trap	3
801421b4:	dfc01215 	stw	ra,72(sp)
801421b8:	df001115 	stw	fp,68(sp)
801421bc:	df001104 	addi	fp,sp,68
801421c0:	e13ffc15 	stw	r4,-16(fp)
801421c4:	e17ffd15 	stw	r5,-12(fp)
801421c8:	e1bffe15 	stw	r6,-8(fp)
801421cc:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
801421d0:	e0bffd17 	ldw	r2,-12(fp)
801421d4:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
801421d8:	e0bffc17 	ldw	r2,-16(fp)
801421dc:	10800a17 	ldw	r2,40(r2)
801421e0:	e0bff815 	stw	r2,-32(fp)
801421e4:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
801421e8:	e0bff90b 	ldhu	r2,-28(fp)
801421ec:	e0fffb04 	addi	r3,fp,-20
801421f0:	180d883a 	mov	r6,r3
801421f4:	100b883a 	mov	r5,r2
801421f8:	e13ff817 	ldw	r4,-32(fp)
801421fc:	0139efc0 	call	80139efc <OSSemPend>

  while (space > 0)
80142200:	00006106 	br	80142388 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
80142204:	e0bffc17 	ldw	r2,-16(fp)
80142208:	10800d17 	ldw	r2,52(r2)
8014220c:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
80142210:	e0bffc17 	ldw	r2,-16(fp)
80142214:	10800e17 	ldw	r2,56(r2)
80142218:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
8014221c:	e0fff317 	ldw	r3,-52(fp)
80142220:	e0bff417 	ldw	r2,-48(fp)
80142224:	18800536 	bltu	r3,r2,8014223c <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
80142228:	e0fff317 	ldw	r3,-52(fp)
8014222c:	e0bff417 	ldw	r2,-48(fp)
80142230:	1885c83a 	sub	r2,r3,r2
80142234:	e0bff115 	stw	r2,-60(fp)
80142238:	00000406 	br	8014224c <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
8014223c:	00c20004 	movi	r3,2048
80142240:	e0bff417 	ldw	r2,-48(fp)
80142244:	1885c83a 	sub	r2,r3,r2
80142248:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8014224c:	e0bff117 	ldw	r2,-60(fp)
80142250:	10001e26 	beq	r2,zero,801422cc <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
80142254:	e0fffe17 	ldw	r3,-8(fp)
80142258:	e0bff117 	ldw	r2,-60(fp)
8014225c:	1880022e 	bgeu	r3,r2,80142268 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
80142260:	e0bffe17 	ldw	r2,-8(fp)
80142264:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
80142268:	e0bffc17 	ldw	r2,-16(fp)
8014226c:	10c01104 	addi	r3,r2,68
80142270:	e0bff417 	ldw	r2,-48(fp)
80142274:	1885883a 	add	r2,r3,r2
80142278:	e1bff117 	ldw	r6,-60(fp)
8014227c:	100b883a 	mov	r5,r2
80142280:	e13ff017 	ldw	r4,-64(fp)
80142284:	01214640 	call	80121464 <memcpy>
      ptr   += n;
80142288:	e0fff017 	ldw	r3,-64(fp)
8014228c:	e0bff117 	ldw	r2,-60(fp)
80142290:	1885883a 	add	r2,r3,r2
80142294:	e0bff015 	stw	r2,-64(fp)
      space -= n;
80142298:	e0fffe17 	ldw	r3,-8(fp)
8014229c:	e0bff117 	ldw	r2,-60(fp)
801422a0:	1885c83a 	sub	r2,r3,r2
801422a4:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
801422a8:	e0fff417 	ldw	r3,-48(fp)
801422ac:	e0bff117 	ldw	r2,-60(fp)
801422b0:	1885883a 	add	r2,r3,r2
801422b4:	10c1ffcc 	andi	r3,r2,2047
801422b8:	e0bffc17 	ldw	r2,-16(fp)
801422bc:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
801422c0:	e0bffe17 	ldw	r2,-8(fp)
801422c4:	00bfcf16 	blt	zero,r2,80142204 <__reset+0xfa122204>
801422c8:	00000106 	br	801422d0 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
801422cc:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
801422d0:	e0fff017 	ldw	r3,-64(fp)
801422d4:	e0bffd17 	ldw	r2,-12(fp)
801422d8:	18802e1e 	bne	r3,r2,80142394 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
801422dc:	e0bfff17 	ldw	r2,-4(fp)
801422e0:	1090000c 	andi	r2,r2,16384
801422e4:	10002d1e 	bne	r2,zero,8014239c <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
801422e8:	d0a09a03 	ldbu	r2,-32152(gp)
801422ec:	10803fcc 	andi	r2,r2,255
801422f0:	10800058 	cmpnei	r2,r2,1
801422f4:	1000161e 	bne	r2,zero,80142350 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
801422f8:	e0bffc17 	ldw	r2,-16(fp)
801422fc:	10800c17 	ldw	r2,48(r2)
80142300:	e0bff215 	stw	r2,-56(fp)
80142304:	00800144 	movi	r2,5
80142308:	e0bff98d 	sth	r2,-26(fp)
8014230c:	00bfe0c4 	movi	r2,-125
80142310:	e0bffa05 	stb	r2,-24(fp)
80142314:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
80142318:	d0a09a03 	ldbu	r2,-32152(gp)
8014231c:	10803fcc 	andi	r2,r2,255
80142320:	10001526 	beq	r2,zero,80142378 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
80142324:	e0fff98b 	ldhu	r3,-26(fp)
80142328:	e13ffa03 	ldbu	r4,-24(fp)
8014232c:	e17ffa8b 	ldhu	r5,-22(fp)
80142330:	e0bffb44 	addi	r2,fp,-19
80142334:	d8800015 	stw	r2,0(sp)
80142338:	280f883a 	mov	r7,r5
8014233c:	200d883a 	mov	r6,r4
80142340:	180b883a 	mov	r5,r3
80142344:	e13ff217 	ldw	r4,-56(fp)
80142348:	013625c0 	call	8013625c <OSFlagPend>
8014234c:	00000a06 	br	80142378 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
80142350:	0001883a 	nop
80142354:	e0bffc17 	ldw	r2,-16(fp)
80142358:	10c00d17 	ldw	r3,52(r2)
8014235c:	e0bff317 	ldw	r2,-52(fp)
80142360:	1880051e 	bne	r3,r2,80142378 <altera_avalon_jtag_uart_read+0x1d0>
80142364:	e0bffc17 	ldw	r2,-16(fp)
80142368:	10c00917 	ldw	r3,36(r2)
8014236c:	e0bffc17 	ldw	r2,-16(fp)
80142370:	10800117 	ldw	r2,4(r2)
80142374:	18bff736 	bltu	r3,r2,80142354 <__reset+0xfa122354>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
80142378:	e0bffc17 	ldw	r2,-16(fp)
8014237c:	10c00d17 	ldw	r3,52(r2)
80142380:	e0bff317 	ldw	r2,-52(fp)
80142384:	18800726 	beq	r3,r2,801423a4 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
80142388:	e0bffe17 	ldw	r2,-8(fp)
8014238c:	00bf9d16 	blt	zero,r2,80142204 <__reset+0xfa122204>
80142390:	00000506 	br	801423a8 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
80142394:	0001883a 	nop
80142398:	00000306 	br	801423a8 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
8014239c:	0001883a 	nop
801423a0:	00000106 	br	801423a8 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
801423a4:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
801423a8:	e0bffc17 	ldw	r2,-16(fp)
801423ac:	10800a17 	ldw	r2,40(r2)
801423b0:	1009883a 	mov	r4,r2
801423b4:	013a2840 	call	8013a284 <OSSemPost>

  if (ptr != buffer)
801423b8:	e0fff017 	ldw	r3,-64(fp)
801423bc:	e0bffd17 	ldw	r2,-12(fp)
801423c0:	18801826 	beq	r3,r2,80142424 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801423c4:	0005303a 	rdctl	r2,status
801423c8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801423cc:	e0fff717 	ldw	r3,-36(fp)
801423d0:	00bfff84 	movi	r2,-2
801423d4:	1884703a 	and	r2,r3,r2
801423d8:	1001703a 	wrctl	status,r2
  
  return context;
801423dc:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
801423e0:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
801423e4:	e0bffc17 	ldw	r2,-16(fp)
801423e8:	10800817 	ldw	r2,32(r2)
801423ec:	10c00054 	ori	r3,r2,1
801423f0:	e0bffc17 	ldw	r2,-16(fp)
801423f4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
801423f8:	e0bffc17 	ldw	r2,-16(fp)
801423fc:	10800017 	ldw	r2,0(r2)
80142400:	10800104 	addi	r2,r2,4
80142404:	1007883a 	mov	r3,r2
80142408:	e0bffc17 	ldw	r2,-16(fp)
8014240c:	10800817 	ldw	r2,32(r2)
80142410:	18800035 	stwio	r2,0(r3)
80142414:	e0bff617 	ldw	r2,-40(fp)
80142418:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8014241c:	e0bff517 	ldw	r2,-44(fp)
80142420:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
80142424:	e0fff017 	ldw	r3,-64(fp)
80142428:	e0bffd17 	ldw	r2,-12(fp)
8014242c:	18800426 	beq	r3,r2,80142440 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
80142430:	e0fff017 	ldw	r3,-64(fp)
80142434:	e0bffd17 	ldw	r2,-12(fp)
80142438:	1885c83a 	sub	r2,r3,r2
8014243c:	00000606 	br	80142458 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
80142440:	e0bfff17 	ldw	r2,-4(fp)
80142444:	1090000c 	andi	r2,r2,16384
80142448:	10000226 	beq	r2,zero,80142454 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
8014244c:	00bffd44 	movi	r2,-11
80142450:	00000106 	br	80142458 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
80142454:	00bffec4 	movi	r2,-5
}
80142458:	e037883a 	mov	sp,fp
8014245c:	dfc00117 	ldw	ra,4(sp)
80142460:	df000017 	ldw	fp,0(sp)
80142464:	dec00204 	addi	sp,sp,8
80142468:	f800283a 	ret

8014246c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
8014246c:	deffed04 	addi	sp,sp,-76
80142470:	de00012e 	bgeu	sp,et,80142478 <altera_avalon_jtag_uart_write+0xc>
80142474:	003b68fa 	trap	3
80142478:	dfc01215 	stw	ra,72(sp)
8014247c:	df001115 	stw	fp,68(sp)
80142480:	df001104 	addi	fp,sp,68
80142484:	e13ffc15 	stw	r4,-16(fp)
80142488:	e17ffd15 	stw	r5,-12(fp)
8014248c:	e1bffe15 	stw	r6,-8(fp)
80142490:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
80142494:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
80142498:	e0bffd17 	ldw	r2,-12(fp)
8014249c:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
801424a0:	e0bffc17 	ldw	r2,-16(fp)
801424a4:	10800b17 	ldw	r2,44(r2)
801424a8:	e0bff815 	stw	r2,-32(fp)
801424ac:	e03ff90d 	sth	zero,-28(fp)
801424b0:	e0bff90b 	ldhu	r2,-28(fp)
801424b4:	e0fffb44 	addi	r3,fp,-19
801424b8:	180d883a 	mov	r6,r3
801424bc:	100b883a 	mov	r5,r2
801424c0:	e13ff817 	ldw	r4,-32(fp)
801424c4:	0139efc0 	call	80139efc <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
801424c8:	00003706 	br	801425a8 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
801424cc:	e0bffc17 	ldw	r2,-16(fp)
801424d0:	10800f17 	ldw	r2,60(r2)
801424d4:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
801424d8:	e0bffc17 	ldw	r2,-16(fp)
801424dc:	10801017 	ldw	r2,64(r2)
801424e0:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
801424e4:	e0fff417 	ldw	r3,-48(fp)
801424e8:	e0bff017 	ldw	r2,-64(fp)
801424ec:	1880062e 	bgeu	r3,r2,80142508 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
801424f0:	e0fff017 	ldw	r3,-64(fp)
801424f4:	e0bff417 	ldw	r2,-48(fp)
801424f8:	1885c83a 	sub	r2,r3,r2
801424fc:	10bfffc4 	addi	r2,r2,-1
80142500:	e0bff115 	stw	r2,-60(fp)
80142504:	00000b06 	br	80142534 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
80142508:	e0bff017 	ldw	r2,-64(fp)
8014250c:	10000526 	beq	r2,zero,80142524 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
80142510:	00c20004 	movi	r3,2048
80142514:	e0bff417 	ldw	r2,-48(fp)
80142518:	1885c83a 	sub	r2,r3,r2
8014251c:	e0bff115 	stw	r2,-60(fp)
80142520:	00000406 	br	80142534 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
80142524:	00c1ffc4 	movi	r3,2047
80142528:	e0bff417 	ldw	r2,-48(fp)
8014252c:	1885c83a 	sub	r2,r3,r2
80142530:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
80142534:	e0bff117 	ldw	r2,-60(fp)
80142538:	10001e26 	beq	r2,zero,801425b4 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
8014253c:	e0fffe17 	ldw	r3,-8(fp)
80142540:	e0bff117 	ldw	r2,-60(fp)
80142544:	1880022e 	bgeu	r3,r2,80142550 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
80142548:	e0bffe17 	ldw	r2,-8(fp)
8014254c:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
80142550:	e0bffc17 	ldw	r2,-16(fp)
80142554:	10c21104 	addi	r3,r2,2116
80142558:	e0bff417 	ldw	r2,-48(fp)
8014255c:	1885883a 	add	r2,r3,r2
80142560:	e1bff117 	ldw	r6,-60(fp)
80142564:	e17ffd17 	ldw	r5,-12(fp)
80142568:	1009883a 	mov	r4,r2
8014256c:	01214640 	call	80121464 <memcpy>
      ptr   += n;
80142570:	e0fffd17 	ldw	r3,-12(fp)
80142574:	e0bff117 	ldw	r2,-60(fp)
80142578:	1885883a 	add	r2,r3,r2
8014257c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
80142580:	e0fffe17 	ldw	r3,-8(fp)
80142584:	e0bff117 	ldw	r2,-60(fp)
80142588:	1885c83a 	sub	r2,r3,r2
8014258c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
80142590:	e0fff417 	ldw	r3,-48(fp)
80142594:	e0bff117 	ldw	r2,-60(fp)
80142598:	1885883a 	add	r2,r3,r2
8014259c:	10c1ffcc 	andi	r3,r2,2047
801425a0:	e0bffc17 	ldw	r2,-16(fp)
801425a4:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
801425a8:	e0bffe17 	ldw	r2,-8(fp)
801425ac:	00bfc716 	blt	zero,r2,801424cc <__reset+0xfa1224cc>
801425b0:	00000106 	br	801425b8 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
801425b4:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801425b8:	0005303a 	rdctl	r2,status
801425bc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801425c0:	e0fff717 	ldw	r3,-36(fp)
801425c4:	00bfff84 	movi	r2,-2
801425c8:	1884703a 	and	r2,r3,r2
801425cc:	1001703a 	wrctl	status,r2
  
  return context;
801425d0:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
801425d4:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
801425d8:	e0bffc17 	ldw	r2,-16(fp)
801425dc:	10800817 	ldw	r2,32(r2)
801425e0:	10c00094 	ori	r3,r2,2
801425e4:	e0bffc17 	ldw	r2,-16(fp)
801425e8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
801425ec:	e0bffc17 	ldw	r2,-16(fp)
801425f0:	10800017 	ldw	r2,0(r2)
801425f4:	10800104 	addi	r2,r2,4
801425f8:	1007883a 	mov	r3,r2
801425fc:	e0bffc17 	ldw	r2,-16(fp)
80142600:	10800817 	ldw	r2,32(r2)
80142604:	18800035 	stwio	r2,0(r3)
80142608:	e0bff617 	ldw	r2,-40(fp)
8014260c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80142610:	e0bff317 	ldw	r2,-52(fp)
80142614:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
80142618:	e0bffe17 	ldw	r2,-8(fp)
8014261c:	00802a0e 	bge	zero,r2,801426c8 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
80142620:	e0bfff17 	ldw	r2,-4(fp)
80142624:	1090000c 	andi	r2,r2,16384
80142628:	10002a1e 	bne	r2,zero,801426d4 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
8014262c:	d0a09a03 	ldbu	r2,-32152(gp)
80142630:	10803fcc 	andi	r2,r2,255
80142634:	10800058 	cmpnei	r2,r2,1
80142638:	1000161e 	bne	r2,zero,80142694 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
8014263c:	e0bffc17 	ldw	r2,-16(fp)
80142640:	10800c17 	ldw	r2,48(r2)
80142644:	e0bff515 	stw	r2,-44(fp)
80142648:	00800184 	movi	r2,6
8014264c:	e0bff98d 	sth	r2,-26(fp)
80142650:	00bfe0c4 	movi	r2,-125
80142654:	e0bffa05 	stb	r2,-24(fp)
80142658:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8014265c:	d0a09a03 	ldbu	r2,-32152(gp)
80142660:	10803fcc 	andi	r2,r2,255
80142664:	10001526 	beq	r2,zero,801426bc <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
80142668:	e0fff98b 	ldhu	r3,-26(fp)
8014266c:	e13ffa03 	ldbu	r4,-24(fp)
80142670:	e17ffa8b 	ldhu	r5,-22(fp)
80142674:	e0bffb04 	addi	r2,fp,-20
80142678:	d8800015 	stw	r2,0(sp)
8014267c:	280f883a 	mov	r7,r5
80142680:	200d883a 	mov	r6,r4
80142684:	180b883a 	mov	r5,r3
80142688:	e13ff517 	ldw	r4,-44(fp)
8014268c:	013625c0 	call	8013625c <OSFlagPend>
80142690:	00000a06 	br	801426bc <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
80142694:	0001883a 	nop
80142698:	e0bffc17 	ldw	r2,-16(fp)
8014269c:	10c01017 	ldw	r3,64(r2)
801426a0:	e0bff017 	ldw	r2,-64(fp)
801426a4:	1880051e 	bne	r3,r2,801426bc <altera_avalon_jtag_uart_write+0x250>
801426a8:	e0bffc17 	ldw	r2,-16(fp)
801426ac:	10c00917 	ldw	r3,36(r2)
801426b0:	e0bffc17 	ldw	r2,-16(fp)
801426b4:	10800117 	ldw	r2,4(r2)
801426b8:	18bff736 	bltu	r3,r2,80142698 <__reset+0xfa122698>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
801426bc:	e0bffc17 	ldw	r2,-16(fp)
801426c0:	10800917 	ldw	r2,36(r2)
801426c4:	1000051e 	bne	r2,zero,801426dc <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
801426c8:	e0bffe17 	ldw	r2,-8(fp)
801426cc:	00bfb616 	blt	zero,r2,801425a8 <__reset+0xfa1225a8>
801426d0:	00000306 	br	801426e0 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
801426d4:	0001883a 	nop
801426d8:	00000106 	br	801426e0 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
801426dc:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
801426e0:	e0bffc17 	ldw	r2,-16(fp)
801426e4:	10800b17 	ldw	r2,44(r2)
801426e8:	1009883a 	mov	r4,r2
801426ec:	013a2840 	call	8013a284 <OSSemPost>

  if (ptr != start)
801426f0:	e0fffd17 	ldw	r3,-12(fp)
801426f4:	e0bff217 	ldw	r2,-56(fp)
801426f8:	18800426 	beq	r3,r2,8014270c <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
801426fc:	e0fffd17 	ldw	r3,-12(fp)
80142700:	e0bff217 	ldw	r2,-56(fp)
80142704:	1885c83a 	sub	r2,r3,r2
80142708:	00000606 	br	80142724 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
8014270c:	e0bfff17 	ldw	r2,-4(fp)
80142710:	1090000c 	andi	r2,r2,16384
80142714:	10000226 	beq	r2,zero,80142720 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
80142718:	00bffd44 	movi	r2,-11
8014271c:	00000106 	br	80142724 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
80142720:	00bffec4 	movi	r2,-5
}
80142724:	e037883a 	mov	sp,fp
80142728:	dfc00117 	ldw	ra,4(sp)
8014272c:	df000017 	ldw	fp,0(sp)
80142730:	dec00204 	addi	sp,sp,8
80142734:	f800283a 	ret

80142738 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
80142738:	defffa04 	addi	sp,sp,-24
8014273c:	de00012e 	bgeu	sp,et,80142744 <alt_avalon_timer_sc_irq+0xc>
80142740:	003b68fa 	trap	3
80142744:	dfc00515 	stw	ra,20(sp)
80142748:	df000415 	stw	fp,16(sp)
8014274c:	df000404 	addi	fp,sp,16
80142750:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
80142754:	0007883a 	mov	r3,zero
80142758:	e0bfff17 	ldw	r2,-4(fp)
8014275c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
80142760:	e0bfff17 	ldw	r2,-4(fp)
80142764:	10800104 	addi	r2,r2,4
80142768:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
8014276c:	01329a40 	call	801329a4 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80142770:	0005303a 	rdctl	r2,status
80142774:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80142778:	e0fffd17 	ldw	r3,-12(fp)
8014277c:	00bfff84 	movi	r2,-2
80142780:	1884703a 	and	r2,r3,r2
80142784:	1001703a 	wrctl	status,r2
  
  return context;
80142788:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
8014278c:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
80142790:	0132fe80 	call	80132fe8 <alt_tick>
80142794:	e0bffc17 	ldw	r2,-16(fp)
80142798:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8014279c:	e0bffe17 	ldw	r2,-8(fp)
801427a0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
801427a4:	0001883a 	nop
801427a8:	e037883a 	mov	sp,fp
801427ac:	dfc00117 	ldw	ra,4(sp)
801427b0:	df000017 	ldw	fp,0(sp)
801427b4:	dec00204 	addi	sp,sp,8
801427b8:	f800283a 	ret

801427bc <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
801427bc:	defff804 	addi	sp,sp,-32
801427c0:	de00012e 	bgeu	sp,et,801427c8 <alt_avalon_timer_sc_init+0xc>
801427c4:	003b68fa 	trap	3
801427c8:	dfc00715 	stw	ra,28(sp)
801427cc:	df000615 	stw	fp,24(sp)
801427d0:	df000604 	addi	fp,sp,24
801427d4:	e13ffc15 	stw	r4,-16(fp)
801427d8:	e17ffd15 	stw	r5,-12(fp)
801427dc:	e1bffe15 	stw	r6,-8(fp)
801427e0:	e1ffff15 	stw	r7,-4(fp)
801427e4:	e0bfff17 	ldw	r2,-4(fp)
801427e8:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
801427ec:	d0a09117 	ldw	r2,-32188(gp)
801427f0:	1000021e 	bne	r2,zero,801427fc <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
801427f4:	e0bffb17 	ldw	r2,-20(fp)
801427f8:	d0a09115 	stw	r2,-32188(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
801427fc:	e0bffc17 	ldw	r2,-16(fp)
80142800:	10800104 	addi	r2,r2,4
80142804:	00c001c4 	movi	r3,7
80142808:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
8014280c:	d8000015 	stw	zero,0(sp)
80142810:	e1fffc17 	ldw	r7,-16(fp)
80142814:	01a00534 	movhi	r6,32788
80142818:	3189ce04 	addi	r6,r6,10040
8014281c:	e17ffe17 	ldw	r5,-8(fp)
80142820:	e13ffd17 	ldw	r4,-12(fp)
80142824:	01457cc0 	call	801457cc <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
80142828:	0001883a 	nop
8014282c:	e037883a 	mov	sp,fp
80142830:	dfc00117 	ldw	ra,4(sp)
80142834:	df000017 	ldw	fp,0(sp)
80142838:	dec00204 	addi	sp,sp,8
8014283c:	f800283a 	ret

80142840 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
80142840:	defffa04 	addi	sp,sp,-24
80142844:	de00012e 	bgeu	sp,et,8014284c <altera_avalon_uart_read_fd+0xc>
80142848:	003b68fa 	trap	3
8014284c:	dfc00515 	stw	ra,20(sp)
80142850:	df000415 	stw	fp,16(sp)
80142854:	df000404 	addi	fp,sp,16
80142858:	e13ffd15 	stw	r4,-12(fp)
8014285c:	e17ffe15 	stw	r5,-8(fp)
80142860:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
80142864:	e0bffd17 	ldw	r2,-12(fp)
80142868:	10800017 	ldw	r2,0(r2)
8014286c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
80142870:	e0bffc17 	ldw	r2,-16(fp)
80142874:	10c00a04 	addi	r3,r2,40
80142878:	e0bffd17 	ldw	r2,-12(fp)
8014287c:	10800217 	ldw	r2,8(r2)
80142880:	100f883a 	mov	r7,r2
80142884:	e1bfff17 	ldw	r6,-4(fp)
80142888:	e17ffe17 	ldw	r5,-8(fp)
8014288c:	1809883a 	mov	r4,r3
80142890:	0142f000 	call	80142f00 <altera_avalon_uart_read>
      fd->fd_flags);
}
80142894:	e037883a 	mov	sp,fp
80142898:	dfc00117 	ldw	ra,4(sp)
8014289c:	df000017 	ldw	fp,0(sp)
801428a0:	dec00204 	addi	sp,sp,8
801428a4:	f800283a 	ret

801428a8 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
801428a8:	defffa04 	addi	sp,sp,-24
801428ac:	de00012e 	bgeu	sp,et,801428b4 <altera_avalon_uart_write_fd+0xc>
801428b0:	003b68fa 	trap	3
801428b4:	dfc00515 	stw	ra,20(sp)
801428b8:	df000415 	stw	fp,16(sp)
801428bc:	df000404 	addi	fp,sp,16
801428c0:	e13ffd15 	stw	r4,-12(fp)
801428c4:	e17ffe15 	stw	r5,-8(fp)
801428c8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
801428cc:	e0bffd17 	ldw	r2,-12(fp)
801428d0:	10800017 	ldw	r2,0(r2)
801428d4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
801428d8:	e0bffc17 	ldw	r2,-16(fp)
801428dc:	10c00a04 	addi	r3,r2,40
801428e0:	e0bffd17 	ldw	r2,-12(fp)
801428e4:	10800217 	ldw	r2,8(r2)
801428e8:	100f883a 	mov	r7,r2
801428ec:	e1bfff17 	ldw	r6,-4(fp)
801428f0:	e17ffe17 	ldw	r5,-8(fp)
801428f4:	1809883a 	mov	r4,r3
801428f8:	01431b40 	call	801431b4 <altera_avalon_uart_write>
      fd->fd_flags);
}
801428fc:	e037883a 	mov	sp,fp
80142900:	dfc00117 	ldw	ra,4(sp)
80142904:	df000017 	ldw	fp,0(sp)
80142908:	dec00204 	addi	sp,sp,8
8014290c:	f800283a 	ret

80142910 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
80142910:	defffc04 	addi	sp,sp,-16
80142914:	de00012e 	bgeu	sp,et,8014291c <altera_avalon_uart_close_fd+0xc>
80142918:	003b68fa 	trap	3
8014291c:	dfc00315 	stw	ra,12(sp)
80142920:	df000215 	stw	fp,8(sp)
80142924:	df000204 	addi	fp,sp,8
80142928:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8014292c:	e0bfff17 	ldw	r2,-4(fp)
80142930:	10800017 	ldw	r2,0(r2)
80142934:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
80142938:	e0bffe17 	ldw	r2,-8(fp)
8014293c:	10c00a04 	addi	r3,r2,40
80142940:	e0bfff17 	ldw	r2,-4(fp)
80142944:	10800217 	ldw	r2,8(r2)
80142948:	100b883a 	mov	r5,r2
8014294c:	1809883a 	mov	r4,r3
80142950:	0142e600 	call	80142e60 <altera_avalon_uart_close>
}
80142954:	e037883a 	mov	sp,fp
80142958:	dfc00117 	ldw	ra,4(sp)
8014295c:	df000017 	ldw	fp,0(sp)
80142960:	dec00204 	addi	sp,sp,8
80142964:	f800283a 	ret

80142968 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
80142968:	defff304 	addi	sp,sp,-52
8014296c:	de00012e 	bgeu	sp,et,80142974 <altera_avalon_uart_init+0xc>
80142970:	003b68fa 	trap	3
80142974:	dfc00c15 	stw	ra,48(sp)
80142978:	df000b15 	stw	fp,44(sp)
8014297c:	df000b04 	addi	fp,sp,44
80142980:	e13ffd15 	stw	r4,-12(fp)
80142984:	e17ffe15 	stw	r5,-8(fp)
80142988:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
8014298c:	e0bffd17 	ldw	r2,-12(fp)
80142990:	10800017 	ldw	r2,0(r2)
80142994:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
80142998:	e0bffd17 	ldw	r2,-12(fp)
8014299c:	10800704 	addi	r2,r2,28
801429a0:	e0bffa15 	stw	r2,-24(fp)
801429a4:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
801429a8:	e0bffb0b 	ldhu	r2,-20(fp)
801429ac:	e0fffc84 	addi	r3,fp,-14
801429b0:	180b883a 	mov	r5,r3
801429b4:	1009883a 	mov	r4,r2
801429b8:	0135c780 	call	80135c78 <OSFlagCreate>
801429bc:	1007883a 	mov	r3,r2
801429c0:	e0bffa17 	ldw	r2,-24(fp)
801429c4:	10c00015 	stw	r3,0(r2)
  return err;
801429c8:	e0bffc83 	ldbu	r2,-14(fp)
801429cc:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
801429d0:	1000241e 	bne	r2,zero,80142a64 <altera_avalon_uart_init+0xfc>
801429d4:	e0bffd17 	ldw	r2,-12(fp)
801429d8:	10800804 	addi	r2,r2,32
801429dc:	e0bff715 	stw	r2,-36(fp)
801429e0:	00800044 	movi	r2,1
801429e4:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
801429e8:	e0bffb8b 	ldhu	r2,-18(fp)
801429ec:	1009883a 	mov	r4,r2
801429f0:	0139bd40 	call	80139bd4 <OSSemCreate>
801429f4:	1007883a 	mov	r3,r2
801429f8:	e0bff717 	ldw	r2,-36(fp)
801429fc:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
80142a00:	e0bff717 	ldw	r2,-36(fp)
80142a04:	10800017 	ldw	r2,0(r2)
80142a08:	10000226 	beq	r2,zero,80142a14 <altera_avalon_uart_init+0xac>
80142a0c:	0005883a 	mov	r2,zero
80142a10:	00000106 	br	80142a18 <altera_avalon_uart_init+0xb0>
80142a14:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
80142a18:	1000121e 	bne	r2,zero,80142a64 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
80142a1c:	e0bffd17 	ldw	r2,-12(fp)
80142a20:	10800904 	addi	r2,r2,36
80142a24:	e0bff815 	stw	r2,-32(fp)
80142a28:	00800044 	movi	r2,1
80142a2c:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
80142a30:	e0bffc0b 	ldhu	r2,-16(fp)
80142a34:	1009883a 	mov	r4,r2
80142a38:	0139bd40 	call	80139bd4 <OSSemCreate>
80142a3c:	1007883a 	mov	r3,r2
80142a40:	e0bff817 	ldw	r2,-32(fp)
80142a44:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
80142a48:	e0bff817 	ldw	r2,-32(fp)
80142a4c:	10800017 	ldw	r2,0(r2)
80142a50:	10000226 	beq	r2,zero,80142a5c <altera_avalon_uart_init+0xf4>
80142a54:	0005883a 	mov	r2,zero
80142a58:	00000106 	br	80142a60 <altera_avalon_uart_init+0xf8>
80142a5c:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
80142a60:	10000226 	beq	r2,zero,80142a6c <altera_avalon_uart_init+0x104>
80142a64:	00800044 	movi	r2,1
80142a68:	00000106 	br	80142a70 <altera_avalon_uart_init+0x108>
80142a6c:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
80142a70:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
80142a74:	e0bff917 	ldw	r2,-28(fp)
80142a78:	10000f1e 	bne	r2,zero,80142ab8 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
80142a7c:	e0bffd17 	ldw	r2,-12(fp)
80142a80:	00c32004 	movi	r3,3200
80142a84:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
80142a88:	e0bff617 	ldw	r2,-40(fp)
80142a8c:	10800304 	addi	r2,r2,12
80142a90:	e0fffd17 	ldw	r3,-12(fp)
80142a94:	18c00117 	ldw	r3,4(r3)
80142a98:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
80142a9c:	d8000015 	stw	zero,0(sp)
80142aa0:	e1fffd17 	ldw	r7,-12(fp)
80142aa4:	01a00534 	movhi	r6,32788
80142aa8:	318ab404 	addi	r6,r6,10960
80142aac:	e17fff17 	ldw	r5,-4(fp)
80142ab0:	e13ffe17 	ldw	r4,-8(fp)
80142ab4:	01457cc0 	call	801457cc <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
80142ab8:	0001883a 	nop
80142abc:	e037883a 	mov	sp,fp
80142ac0:	dfc00117 	ldw	ra,4(sp)
80142ac4:	df000017 	ldw	fp,0(sp)
80142ac8:	dec00204 	addi	sp,sp,8
80142acc:	f800283a 	ret

80142ad0 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
80142ad0:	defffa04 	addi	sp,sp,-24
80142ad4:	de00012e 	bgeu	sp,et,80142adc <altera_avalon_uart_irq+0xc>
80142ad8:	003b68fa 	trap	3
80142adc:	dfc00515 	stw	ra,20(sp)
80142ae0:	df000415 	stw	fp,16(sp)
80142ae4:	df000404 	addi	fp,sp,16
80142ae8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
80142aec:	e0bfff17 	ldw	r2,-4(fp)
80142af0:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
80142af4:	e0bffc17 	ldw	r2,-16(fp)
80142af8:	10800017 	ldw	r2,0(r2)
80142afc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
80142b00:	e0bffd17 	ldw	r2,-12(fp)
80142b04:	10800204 	addi	r2,r2,8
80142b08:	10800037 	ldwio	r2,0(r2)
80142b0c:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
80142b10:	e0bffd17 	ldw	r2,-12(fp)
80142b14:	10800204 	addi	r2,r2,8
80142b18:	0007883a 	mov	r3,zero
80142b1c:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
80142b20:	e0bffd17 	ldw	r2,-12(fp)
80142b24:	10800204 	addi	r2,r2,8
80142b28:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
80142b2c:	e0bffe17 	ldw	r2,-8(fp)
80142b30:	1080200c 	andi	r2,r2,128
80142b34:	10000326 	beq	r2,zero,80142b44 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
80142b38:	e17ffe17 	ldw	r5,-8(fp)
80142b3c:	e13ffc17 	ldw	r4,-16(fp)
80142b40:	0142b740 	call	80142b74 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
80142b44:	e0bffe17 	ldw	r2,-8(fp)
80142b48:	1081100c 	andi	r2,r2,1088
80142b4c:	10000326 	beq	r2,zero,80142b5c <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
80142b50:	e17ffe17 	ldw	r5,-8(fp)
80142b54:	e13ffc17 	ldw	r4,-16(fp)
80142b58:	0142cb40 	call	80142cb4 <altera_avalon_uart_txirq>
  }
  

}
80142b5c:	0001883a 	nop
80142b60:	e037883a 	mov	sp,fp
80142b64:	dfc00117 	ldw	ra,4(sp)
80142b68:	df000017 	ldw	fp,0(sp)
80142b6c:	dec00204 	addi	sp,sp,8
80142b70:	f800283a 	ret

80142b74 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
80142b74:	defff904 	addi	sp,sp,-28
80142b78:	de00012e 	bgeu	sp,et,80142b80 <altera_avalon_uart_rxirq+0xc>
80142b7c:	003b68fa 	trap	3
80142b80:	dfc00615 	stw	ra,24(sp)
80142b84:	df000515 	stw	fp,20(sp)
80142b88:	df000504 	addi	fp,sp,20
80142b8c:	e13ffe15 	stw	r4,-8(fp)
80142b90:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
80142b94:	e0bfff17 	ldw	r2,-4(fp)
80142b98:	108000cc 	andi	r2,r2,3
80142b9c:	10003f1e 	bne	r2,zero,80142c9c <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
80142ba0:	e0bffe17 	ldw	r2,-8(fp)
80142ba4:	10c00317 	ldw	r3,12(r2)
80142ba8:	e0bffe17 	ldw	r2,-8(fp)
80142bac:	10800217 	ldw	r2,8(r2)
80142bb0:	1880121e 	bne	r3,r2,80142bfc <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
80142bb4:	e0bffe17 	ldw	r2,-8(fp)
80142bb8:	10800717 	ldw	r2,28(r2)
80142bbc:	e0bffc15 	stw	r2,-16(fp)
80142bc0:	00800044 	movi	r2,1
80142bc4:	e0bffd0d 	sth	r2,-12(fp)
80142bc8:	00800044 	movi	r2,1
80142bcc:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
80142bd0:	d0a09a03 	ldbu	r2,-32152(gp)
80142bd4:	10803fcc 	andi	r2,r2,255
80142bd8:	10000826 	beq	r2,zero,80142bfc <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
80142bdc:	e0bffd0b 	ldhu	r2,-12(fp)
80142be0:	e0fffd83 	ldbu	r3,-10(fp)
80142be4:	e13ffdc4 	addi	r4,fp,-9
80142be8:	200f883a 	mov	r7,r4
80142bec:	180d883a 	mov	r6,r3
80142bf0:	100b883a 	mov	r5,r2
80142bf4:	e13ffc17 	ldw	r4,-16(fp)
80142bf8:	01368840 	call	80136884 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
80142bfc:	e0bffe17 	ldw	r2,-8(fp)
80142c00:	10800317 	ldw	r2,12(r2)
80142c04:	10800044 	addi	r2,r2,1
80142c08:	10800fcc 	andi	r2,r2,63
80142c0c:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
80142c10:	e0bffe17 	ldw	r2,-8(fp)
80142c14:	10800317 	ldw	r2,12(r2)
80142c18:	e0fffe17 	ldw	r3,-8(fp)
80142c1c:	18c00017 	ldw	r3,0(r3)
80142c20:	18c00037 	ldwio	r3,0(r3)
80142c24:	1809883a 	mov	r4,r3
80142c28:	e0fffe17 	ldw	r3,-8(fp)
80142c2c:	1885883a 	add	r2,r3,r2
80142c30:	10800a04 	addi	r2,r2,40
80142c34:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
80142c38:	e0bffe17 	ldw	r2,-8(fp)
80142c3c:	e0fffb17 	ldw	r3,-20(fp)
80142c40:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
80142c44:	e0bffe17 	ldw	r2,-8(fp)
80142c48:	10800317 	ldw	r2,12(r2)
80142c4c:	10800044 	addi	r2,r2,1
80142c50:	10800fcc 	andi	r2,r2,63
80142c54:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
80142c58:	e0bffe17 	ldw	r2,-8(fp)
80142c5c:	10c00217 	ldw	r3,8(r2)
80142c60:	e0bffb17 	ldw	r2,-20(fp)
80142c64:	18800e1e 	bne	r3,r2,80142ca0 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
80142c68:	e0bffe17 	ldw	r2,-8(fp)
80142c6c:	10c00117 	ldw	r3,4(r2)
80142c70:	00bfdfc4 	movi	r2,-129
80142c74:	1886703a 	and	r3,r3,r2
80142c78:	e0bffe17 	ldw	r2,-8(fp)
80142c7c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
80142c80:	e0bffe17 	ldw	r2,-8(fp)
80142c84:	10800017 	ldw	r2,0(r2)
80142c88:	10800304 	addi	r2,r2,12
80142c8c:	e0fffe17 	ldw	r3,-8(fp)
80142c90:	18c00117 	ldw	r3,4(r3)
80142c94:	10c00035 	stwio	r3,0(r2)
80142c98:	00000106 	br	80142ca0 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
80142c9c:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
80142ca0:	e037883a 	mov	sp,fp
80142ca4:	dfc00117 	ldw	ra,4(sp)
80142ca8:	df000017 	ldw	fp,0(sp)
80142cac:	dec00204 	addi	sp,sp,8
80142cb0:	f800283a 	ret

80142cb4 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
80142cb4:	defffa04 	addi	sp,sp,-24
80142cb8:	de00012e 	bgeu	sp,et,80142cc0 <altera_avalon_uart_txirq+0xc>
80142cbc:	003b68fa 	trap	3
80142cc0:	dfc00515 	stw	ra,20(sp)
80142cc4:	df000415 	stw	fp,16(sp)
80142cc8:	df000404 	addi	fp,sp,16
80142ccc:	e13ffe15 	stw	r4,-8(fp)
80142cd0:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
80142cd4:	e0bffe17 	ldw	r2,-8(fp)
80142cd8:	10c00417 	ldw	r3,16(r2)
80142cdc:	e0bffe17 	ldw	r2,-8(fp)
80142ce0:	10800517 	ldw	r2,20(r2)
80142ce4:	18804726 	beq	r3,r2,80142e04 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
80142ce8:	e0bffe17 	ldw	r2,-8(fp)
80142cec:	10800617 	ldw	r2,24(r2)
80142cf0:	1080008c 	andi	r2,r2,2
80142cf4:	10000326 	beq	r2,zero,80142d04 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
80142cf8:	e0bfff17 	ldw	r2,-4(fp)
80142cfc:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
80142d00:	10003226 	beq	r2,zero,80142dcc <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
80142d04:	e0bffe17 	ldw	r2,-8(fp)
80142d08:	10c00417 	ldw	r3,16(r2)
80142d0c:	e0bffe17 	ldw	r2,-8(fp)
80142d10:	10800517 	ldw	r2,20(r2)
80142d14:	10800044 	addi	r2,r2,1
80142d18:	10800fcc 	andi	r2,r2,63
80142d1c:	1880121e 	bne	r3,r2,80142d68 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
80142d20:	e0bffe17 	ldw	r2,-8(fp)
80142d24:	10800717 	ldw	r2,28(r2)
80142d28:	e0bffc15 	stw	r2,-16(fp)
80142d2c:	00800084 	movi	r2,2
80142d30:	e0bffd0d 	sth	r2,-12(fp)
80142d34:	00800044 	movi	r2,1
80142d38:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
80142d3c:	d0a09a03 	ldbu	r2,-32152(gp)
80142d40:	10803fcc 	andi	r2,r2,255
80142d44:	10000826 	beq	r2,zero,80142d68 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
80142d48:	e0bffd0b 	ldhu	r2,-12(fp)
80142d4c:	e0fffd83 	ldbu	r3,-10(fp)
80142d50:	e13ffdc4 	addi	r4,fp,-9
80142d54:	200f883a 	mov	r7,r4
80142d58:	180d883a 	mov	r6,r3
80142d5c:	100b883a 	mov	r5,r2
80142d60:	e13ffc17 	ldw	r4,-16(fp)
80142d64:	01368840 	call	80136884 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
80142d68:	e0bffe17 	ldw	r2,-8(fp)
80142d6c:	10800017 	ldw	r2,0(r2)
80142d70:	10800104 	addi	r2,r2,4
80142d74:	e0fffe17 	ldw	r3,-8(fp)
80142d78:	18c00417 	ldw	r3,16(r3)
80142d7c:	e13ffe17 	ldw	r4,-8(fp)
80142d80:	20c7883a 	add	r3,r4,r3
80142d84:	18c01a04 	addi	r3,r3,104
80142d88:	18c00003 	ldbu	r3,0(r3)
80142d8c:	18c03fcc 	andi	r3,r3,255
80142d90:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
80142d94:	e0bffe17 	ldw	r2,-8(fp)
80142d98:	10800417 	ldw	r2,16(r2)
80142d9c:	10800044 	addi	r2,r2,1
80142da0:	e0fffe17 	ldw	r3,-8(fp)
80142da4:	18800415 	stw	r2,16(r3)
80142da8:	10c00fcc 	andi	r3,r2,63
80142dac:	e0bffe17 	ldw	r2,-8(fp)
80142db0:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
80142db4:	e0bffe17 	ldw	r2,-8(fp)
80142db8:	10800117 	ldw	r2,4(r2)
80142dbc:	10c01014 	ori	r3,r2,64
80142dc0:	e0bffe17 	ldw	r2,-8(fp)
80142dc4:	10c00115 	stw	r3,4(r2)
80142dc8:	00000e06 	br	80142e04 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
80142dcc:	e0bffe17 	ldw	r2,-8(fp)
80142dd0:	10800017 	ldw	r2,0(r2)
80142dd4:	10800204 	addi	r2,r2,8
80142dd8:	10800037 	ldwio	r2,0(r2)
80142ddc:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
80142de0:	e0bfff17 	ldw	r2,-4(fp)
80142de4:	1082000c 	andi	r2,r2,2048
80142de8:	1000061e 	bne	r2,zero,80142e04 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
80142dec:	e0bffe17 	ldw	r2,-8(fp)
80142df0:	10c00117 	ldw	r3,4(r2)
80142df4:	00bfefc4 	movi	r2,-65
80142df8:	1886703a 	and	r3,r3,r2
80142dfc:	e0bffe17 	ldw	r2,-8(fp)
80142e00:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
80142e04:	e0bffe17 	ldw	r2,-8(fp)
80142e08:	10c00417 	ldw	r3,16(r2)
80142e0c:	e0bffe17 	ldw	r2,-8(fp)
80142e10:	10800517 	ldw	r2,20(r2)
80142e14:	1880061e 	bne	r3,r2,80142e30 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
80142e18:	e0bffe17 	ldw	r2,-8(fp)
80142e1c:	10c00117 	ldw	r3,4(r2)
80142e20:	00beefc4 	movi	r2,-1089
80142e24:	1886703a 	and	r3,r3,r2
80142e28:	e0bffe17 	ldw	r2,-8(fp)
80142e2c:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
80142e30:	e0bffe17 	ldw	r2,-8(fp)
80142e34:	10800017 	ldw	r2,0(r2)
80142e38:	10800304 	addi	r2,r2,12
80142e3c:	e0fffe17 	ldw	r3,-8(fp)
80142e40:	18c00117 	ldw	r3,4(r3)
80142e44:	10c00035 	stwio	r3,0(r2)
}
80142e48:	0001883a 	nop
80142e4c:	e037883a 	mov	sp,fp
80142e50:	dfc00117 	ldw	ra,4(sp)
80142e54:	df000017 	ldw	fp,0(sp)
80142e58:	dec00204 	addi	sp,sp,8
80142e5c:	f800283a 	ret

80142e60 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
80142e60:	defffd04 	addi	sp,sp,-12
80142e64:	de00012e 	bgeu	sp,et,80142e6c <altera_avalon_uart_close+0xc>
80142e68:	003b68fa 	trap	3
80142e6c:	df000215 	stw	fp,8(sp)
80142e70:	df000204 	addi	fp,sp,8
80142e74:	e13ffe15 	stw	r4,-8(fp)
80142e78:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
80142e7c:	00000506 	br	80142e94 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
80142e80:	e0bfff17 	ldw	r2,-4(fp)
80142e84:	1090000c 	andi	r2,r2,16384
80142e88:	10000226 	beq	r2,zero,80142e94 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
80142e8c:	00bffd44 	movi	r2,-11
80142e90:	00000606 	br	80142eac <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
80142e94:	e0bffe17 	ldw	r2,-8(fp)
80142e98:	10c00417 	ldw	r3,16(r2)
80142e9c:	e0bffe17 	ldw	r2,-8(fp)
80142ea0:	10800517 	ldw	r2,20(r2)
80142ea4:	18bff61e 	bne	r3,r2,80142e80 <__reset+0xfa122e80>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
80142ea8:	0005883a 	mov	r2,zero
}
80142eac:	e037883a 	mov	sp,fp
80142eb0:	df000017 	ldw	fp,0(sp)
80142eb4:	dec00104 	addi	sp,sp,4
80142eb8:	f800283a 	ret

80142ebc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80142ebc:	defffe04 	addi	sp,sp,-8
80142ec0:	de00012e 	bgeu	sp,et,80142ec8 <alt_get_errno+0xc>
80142ec4:	003b68fa 	trap	3
80142ec8:	dfc00115 	stw	ra,4(sp)
80142ecc:	df000015 	stw	fp,0(sp)
80142ed0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
80142ed4:	d0a00f17 	ldw	r2,-32708(gp)
80142ed8:	10000326 	beq	r2,zero,80142ee8 <alt_get_errno+0x2c>
80142edc:	d0a00f17 	ldw	r2,-32708(gp)
80142ee0:	103ee83a 	callr	r2
80142ee4:	00000106 	br	80142eec <alt_get_errno+0x30>
80142ee8:	d0a08704 	addi	r2,gp,-32228
}
80142eec:	e037883a 	mov	sp,fp
80142ef0:	dfc00117 	ldw	ra,4(sp)
80142ef4:	df000017 	ldw	fp,0(sp)
80142ef8:	dec00204 	addi	sp,sp,8
80142efc:	f800283a 	ret

80142f00 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
80142f00:	deffec04 	addi	sp,sp,-80
80142f04:	de00012e 	bgeu	sp,et,80142f0c <altera_avalon_uart_read+0xc>
80142f08:	003b68fa 	trap	3
80142f0c:	dfc01315 	stw	ra,76(sp)
80142f10:	df001215 	stw	fp,72(sp)
80142f14:	df001204 	addi	fp,sp,72
80142f18:	e13ffc15 	stw	r4,-16(fp)
80142f1c:	e17ffd15 	stw	r5,-12(fp)
80142f20:	e1bffe15 	stw	r6,-8(fp)
80142f24:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
80142f28:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
80142f2c:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
80142f30:	e0bfff17 	ldw	r2,-4(fp)
80142f34:	1090000c 	andi	r2,r2,16384
80142f38:	1005003a 	cmpeq	r2,r2,zero
80142f3c:	10803fcc 	andi	r2,r2,255
80142f40:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
80142f44:	e0bffc17 	ldw	r2,-16(fp)
80142f48:	10800817 	ldw	r2,32(r2)
80142f4c:	e0bff815 	stw	r2,-32(fp)
80142f50:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
80142f54:	e0bff90b 	ldhu	r2,-28(fp)
80142f58:	e0fffb44 	addi	r3,fp,-19
80142f5c:	180d883a 	mov	r6,r3
80142f60:	100b883a 	mov	r5,r2
80142f64:	e13ff817 	ldw	r4,-32(fp)
80142f68:	0139efc0 	call	80139efc <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
80142f6c:	00001306 	br	80142fbc <altera_avalon_uart_read+0xbc>
    {
      count++;
80142f70:	e0bff017 	ldw	r2,-64(fp)
80142f74:	10800044 	addi	r2,r2,1
80142f78:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
80142f7c:	e0bffd17 	ldw	r2,-12(fp)
80142f80:	10c00044 	addi	r3,r2,1
80142f84:	e0fffd15 	stw	r3,-12(fp)
80142f88:	e0fffc17 	ldw	r3,-16(fp)
80142f8c:	18c00217 	ldw	r3,8(r3)
80142f90:	e13ffc17 	ldw	r4,-16(fp)
80142f94:	20c7883a 	add	r3,r4,r3
80142f98:	18c00a04 	addi	r3,r3,40
80142f9c:	18c00003 	ldbu	r3,0(r3)
80142fa0:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
80142fa4:	e0bffc17 	ldw	r2,-16(fp)
80142fa8:	10800217 	ldw	r2,8(r2)
80142fac:	10800044 	addi	r2,r2,1
80142fb0:	10c00fcc 	andi	r3,r2,63
80142fb4:	e0bffc17 	ldw	r2,-16(fp)
80142fb8:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
80142fbc:	e0fff017 	ldw	r3,-64(fp)
80142fc0:	e0bffe17 	ldw	r2,-8(fp)
80142fc4:	1880050e 	bge	r3,r2,80142fdc <altera_avalon_uart_read+0xdc>
80142fc8:	e0bffc17 	ldw	r2,-16(fp)
80142fcc:	10c00217 	ldw	r3,8(r2)
80142fd0:	e0bffc17 	ldw	r2,-16(fp)
80142fd4:	10800317 	ldw	r2,12(r2)
80142fd8:	18bfe51e 	bne	r3,r2,80142f70 <__reset+0xfa122f70>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
80142fdc:	e0bff017 	ldw	r2,-64(fp)
80142fe0:	10003a1e 	bne	r2,zero,801430cc <altera_avalon_uart_read+0x1cc>
80142fe4:	e0bffc17 	ldw	r2,-16(fp)
80142fe8:	10c00217 	ldw	r3,8(r2)
80142fec:	e0bffc17 	ldw	r2,-16(fp)
80142ff0:	10800317 	ldw	r2,12(r2)
80142ff4:	1880351e 	bne	r3,r2,801430cc <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
80142ff8:	e0bff117 	ldw	r2,-60(fp)
80142ffc:	1000071e 	bne	r2,zero,8014301c <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
80143000:	0142ebc0 	call	80142ebc <alt_get_errno>
80143004:	1007883a 	mov	r3,r2
80143008:	008002c4 	movi	r2,11
8014300c:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
80143010:	00800044 	movi	r2,1
80143014:	e0bfef05 	stb	r2,-68(fp)
        break;
80143018:	00003006 	br	801430dc <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8014301c:	0005303a 	rdctl	r2,status
80143020:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80143024:	e0fff517 	ldw	r3,-44(fp)
80143028:	00bfff84 	movi	r2,-2
8014302c:	1884703a 	and	r2,r3,r2
80143030:	1001703a 	wrctl	status,r2
  
  return context;
80143034:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
80143038:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8014303c:	e0bffc17 	ldw	r2,-16(fp)
80143040:	10800117 	ldw	r2,4(r2)
80143044:	10c02014 	ori	r3,r2,128
80143048:	e0bffc17 	ldw	r2,-16(fp)
8014304c:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
80143050:	e0bffc17 	ldw	r2,-16(fp)
80143054:	10800017 	ldw	r2,0(r2)
80143058:	10800304 	addi	r2,r2,12
8014305c:	e0fffc17 	ldw	r3,-16(fp)
80143060:	18c00117 	ldw	r3,4(r3)
80143064:	10c00035 	stwio	r3,0(r2)
80143068:	e0bff417 	ldw	r2,-48(fp)
8014306c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80143070:	e0bff617 	ldw	r2,-40(fp)
80143074:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
80143078:	e0bffc17 	ldw	r2,-16(fp)
8014307c:	10800717 	ldw	r2,28(r2)
80143080:	e0bff215 	stw	r2,-56(fp)
80143084:	00800044 	movi	r2,1
80143088:	e0bff98d 	sth	r2,-26(fp)
8014308c:	00bfe0c4 	movi	r2,-125
80143090:	e0bffa05 	stb	r2,-24(fp)
80143094:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
80143098:	d0a09a03 	ldbu	r2,-32152(gp)
8014309c:	10803fcc 	andi	r2,r2,255
801430a0:	10000a26 	beq	r2,zero,801430cc <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
801430a4:	e0fff98b 	ldhu	r3,-26(fp)
801430a8:	e13ffa03 	ldbu	r4,-24(fp)
801430ac:	e17ffa8b 	ldhu	r5,-22(fp)
801430b0:	e0bffb04 	addi	r2,fp,-20
801430b4:	d8800015 	stw	r2,0(sp)
801430b8:	280f883a 	mov	r7,r5
801430bc:	200d883a 	mov	r6,r4
801430c0:	180b883a 	mov	r5,r3
801430c4:	e13ff217 	ldw	r4,-56(fp)
801430c8:	013625c0 	call	8013625c <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
801430cc:	e0bff017 	ldw	r2,-64(fp)
801430d0:	1000021e 	bne	r2,zero,801430dc <altera_avalon_uart_read+0x1dc>
801430d4:	e0bffe17 	ldw	r2,-8(fp)
801430d8:	103fb81e 	bne	r2,zero,80142fbc <__reset+0xfa122fbc>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
801430dc:	e0bffc17 	ldw	r2,-16(fp)
801430e0:	10800817 	ldw	r2,32(r2)
801430e4:	1009883a 	mov	r4,r2
801430e8:	013a2840 	call	8013a284 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801430ec:	0005303a 	rdctl	r2,status
801430f0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801430f4:	e0fff717 	ldw	r3,-36(fp)
801430f8:	00bfff84 	movi	r2,-2
801430fc:	1884703a 	and	r2,r3,r2
80143100:	1001703a 	wrctl	status,r2
  
  return context;
80143104:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
80143108:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
8014310c:	e0bffc17 	ldw	r2,-16(fp)
80143110:	10800117 	ldw	r2,4(r2)
80143114:	10c02014 	ori	r3,r2,128
80143118:	e0bffc17 	ldw	r2,-16(fp)
8014311c:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
80143120:	e0bffc17 	ldw	r2,-16(fp)
80143124:	10800017 	ldw	r2,0(r2)
80143128:	10800304 	addi	r2,r2,12
8014312c:	e0fffc17 	ldw	r3,-16(fp)
80143130:	18c00117 	ldw	r3,4(r3)
80143134:	10c00035 	stwio	r3,0(r2)
80143138:	e0bff417 	ldw	r2,-48(fp)
8014313c:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80143140:	e0bff317 	ldw	r2,-52(fp)
80143144:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
80143148:	e0bfef03 	ldbu	r2,-68(fp)
8014314c:	10000226 	beq	r2,zero,80143158 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
80143150:	00bffd44 	movi	r2,-11
80143154:	00000106 	br	8014315c <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
80143158:	e0bff017 	ldw	r2,-64(fp)
  }
}
8014315c:	e037883a 	mov	sp,fp
80143160:	dfc00117 	ldw	ra,4(sp)
80143164:	df000017 	ldw	fp,0(sp)
80143168:	dec00204 	addi	sp,sp,8
8014316c:	f800283a 	ret

80143170 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80143170:	defffe04 	addi	sp,sp,-8
80143174:	de00012e 	bgeu	sp,et,8014317c <alt_get_errno+0xc>
80143178:	003b68fa 	trap	3
8014317c:	dfc00115 	stw	ra,4(sp)
80143180:	df000015 	stw	fp,0(sp)
80143184:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
80143188:	d0a00f17 	ldw	r2,-32708(gp)
8014318c:	10000326 	beq	r2,zero,8014319c <alt_get_errno+0x2c>
80143190:	d0a00f17 	ldw	r2,-32708(gp)
80143194:	103ee83a 	callr	r2
80143198:	00000106 	br	801431a0 <alt_get_errno+0x30>
8014319c:	d0a08704 	addi	r2,gp,-32228
}
801431a0:	e037883a 	mov	sp,fp
801431a4:	dfc00117 	ldw	ra,4(sp)
801431a8:	df000017 	ldw	fp,0(sp)
801431ac:	dec00204 	addi	sp,sp,8
801431b0:	f800283a 	ret

801431b4 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
801431b4:	deffec04 	addi	sp,sp,-80
801431b8:	de00012e 	bgeu	sp,et,801431c0 <altera_avalon_uart_write+0xc>
801431bc:	003b68fa 	trap	3
801431c0:	dfc01315 	stw	ra,76(sp)
801431c4:	df001215 	stw	fp,72(sp)
801431c8:	df001204 	addi	fp,sp,72
801431cc:	e13ffc15 	stw	r4,-16(fp)
801431d0:	e17ffd15 	stw	r5,-12(fp)
801431d4:	e1bffe15 	stw	r6,-8(fp)
801431d8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
801431dc:	e0bffe17 	ldw	r2,-8(fp)
801431e0:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
801431e4:	e0bfff17 	ldw	r2,-4(fp)
801431e8:	1090000c 	andi	r2,r2,16384
801431ec:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
801431f0:	e0bffc17 	ldw	r2,-16(fp)
801431f4:	10800917 	ldw	r2,36(r2)
801431f8:	e0bff815 	stw	r2,-32(fp)
801431fc:	e03ff90d 	sth	zero,-28(fp)
80143200:	e0bff90b 	ldhu	r2,-28(fp)
80143204:	e0fffb44 	addi	r3,fp,-19
80143208:	180d883a 	mov	r6,r3
8014320c:	100b883a 	mov	r5,r2
80143210:	e13ff817 	ldw	r4,-32(fp)
80143214:	0139efc0 	call	80139efc <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
80143218:	00005106 	br	80143360 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8014321c:	e0bffc17 	ldw	r2,-16(fp)
80143220:	10800517 	ldw	r2,20(r2)
80143224:	10800044 	addi	r2,r2,1
80143228:	10800fcc 	andi	r2,r2,63
8014322c:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
80143230:	e0bffc17 	ldw	r2,-16(fp)
80143234:	10c00417 	ldw	r3,16(r2)
80143238:	e0bff217 	ldw	r2,-56(fp)
8014323c:	1880371e 	bne	r3,r2,8014331c <altera_avalon_uart_write+0x168>
    {
      if (no_block)
80143240:	e0bff017 	ldw	r2,-64(fp)
80143244:	10000526 	beq	r2,zero,8014325c <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
80143248:	01431700 	call	80143170 <alt_get_errno>
8014324c:	1007883a 	mov	r3,r2
80143250:	008002c4 	movi	r2,11
80143254:	18800015 	stw	r2,0(r3)
        break;
80143258:	00004306 	br	80143368 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8014325c:	0005303a 	rdctl	r2,status
80143260:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80143264:	e0fff517 	ldw	r3,-44(fp)
80143268:	00bfff84 	movi	r2,-2
8014326c:	1884703a 	and	r2,r3,r2
80143270:	1001703a 	wrctl	status,r2
  
  return context;
80143274:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
80143278:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
8014327c:	e0bffc17 	ldw	r2,-16(fp)
80143280:	10800117 	ldw	r2,4(r2)
80143284:	10c11014 	ori	r3,r2,1088
80143288:	e0bffc17 	ldw	r2,-16(fp)
8014328c:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
80143290:	e0bffc17 	ldw	r2,-16(fp)
80143294:	10800017 	ldw	r2,0(r2)
80143298:	10800304 	addi	r2,r2,12
8014329c:	e0fffc17 	ldw	r3,-16(fp)
801432a0:	18c00117 	ldw	r3,4(r3)
801432a4:	10c00035 	stwio	r3,0(r2)
801432a8:	e0bff417 	ldw	r2,-48(fp)
801432ac:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801432b0:	e0bff117 	ldw	r2,-60(fp)
801432b4:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
801432b8:	e0bffc17 	ldw	r2,-16(fp)
801432bc:	10800717 	ldw	r2,28(r2)
801432c0:	e0bff315 	stw	r2,-52(fp)
801432c4:	00800084 	movi	r2,2
801432c8:	e0bff98d 	sth	r2,-26(fp)
801432cc:	00bfe0c4 	movi	r2,-125
801432d0:	e0bffa05 	stb	r2,-24(fp)
801432d4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
801432d8:	d0a09a03 	ldbu	r2,-32152(gp)
801432dc:	10803fcc 	andi	r2,r2,255
801432e0:	10000a26 	beq	r2,zero,8014330c <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
801432e4:	e0fff98b 	ldhu	r3,-26(fp)
801432e8:	e13ffa03 	ldbu	r4,-24(fp)
801432ec:	e17ffa8b 	ldhu	r5,-22(fp)
801432f0:	e0bffb04 	addi	r2,fp,-20
801432f4:	d8800015 	stw	r2,0(sp)
801432f8:	280f883a 	mov	r7,r5
801432fc:	200d883a 	mov	r6,r4
80143300:	180b883a 	mov	r5,r3
80143304:	e13ff317 	ldw	r4,-52(fp)
80143308:	013625c0 	call	8013625c <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
8014330c:	e0bffc17 	ldw	r2,-16(fp)
80143310:	10c00417 	ldw	r3,16(r2)
80143314:	e0bff217 	ldw	r2,-56(fp)
80143318:	18bfe726 	beq	r3,r2,801432b8 <__reset+0xfa1232b8>
      }
    }

    count--;
8014331c:	e0bfef17 	ldw	r2,-68(fp)
80143320:	10bfffc4 	addi	r2,r2,-1
80143324:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
80143328:	e0bffc17 	ldw	r2,-16(fp)
8014332c:	10c00517 	ldw	r3,20(r2)
80143330:	e0bffd17 	ldw	r2,-12(fp)
80143334:	11000044 	addi	r4,r2,1
80143338:	e13ffd15 	stw	r4,-12(fp)
8014333c:	10800003 	ldbu	r2,0(r2)
80143340:	1009883a 	mov	r4,r2
80143344:	e0bffc17 	ldw	r2,-16(fp)
80143348:	10c5883a 	add	r2,r2,r3
8014334c:	10801a04 	addi	r2,r2,104
80143350:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
80143354:	e0bffc17 	ldw	r2,-16(fp)
80143358:	e0fff217 	ldw	r3,-56(fp)
8014335c:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
80143360:	e0bfef17 	ldw	r2,-68(fp)
80143364:	103fad1e 	bne	r2,zero,8014321c <__reset+0xfa12321c>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
80143368:	e0bffc17 	ldw	r2,-16(fp)
8014336c:	10800917 	ldw	r2,36(r2)
80143370:	1009883a 	mov	r4,r2
80143374:	013a2840 	call	8013a284 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80143378:	0005303a 	rdctl	r2,status
8014337c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80143380:	e0fff717 	ldw	r3,-36(fp)
80143384:	00bfff84 	movi	r2,-2
80143388:	1884703a 	and	r2,r3,r2
8014338c:	1001703a 	wrctl	status,r2
  
  return context;
80143390:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
80143394:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
80143398:	e0bffc17 	ldw	r2,-16(fp)
8014339c:	10800117 	ldw	r2,4(r2)
801433a0:	10c11014 	ori	r3,r2,1088
801433a4:	e0bffc17 	ldw	r2,-16(fp)
801433a8:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
801433ac:	e0bffc17 	ldw	r2,-16(fp)
801433b0:	10800017 	ldw	r2,0(r2)
801433b4:	10800304 	addi	r2,r2,12
801433b8:	e0fffc17 	ldw	r3,-16(fp)
801433bc:	18c00117 	ldw	r3,4(r3)
801433c0:	10c00035 	stwio	r3,0(r2)
801433c4:	e0bff417 	ldw	r2,-48(fp)
801433c8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
801433cc:	e0bff617 	ldw	r2,-40(fp)
801433d0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
801433d4:	e0fffe17 	ldw	r3,-8(fp)
801433d8:	e0bfef17 	ldw	r2,-68(fp)
801433dc:	1885c83a 	sub	r2,r3,r2
}
801433e0:	e037883a 	mov	sp,fp
801433e4:	dfc00117 	ldw	ra,4(sp)
801433e8:	df000017 	ldw	fp,0(sp)
801433ec:	dec00204 	addi	sp,sp,8
801433f0:	f800283a 	ret

801433f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
801433f4:	defffe04 	addi	sp,sp,-8
801433f8:	de00012e 	bgeu	sp,et,80143400 <alt_get_errno+0xc>
801433fc:	003b68fa 	trap	3
80143400:	dfc00115 	stw	ra,4(sp)
80143404:	df000015 	stw	fp,0(sp)
80143408:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8014340c:	d0a00f17 	ldw	r2,-32708(gp)
80143410:	10000326 	beq	r2,zero,80143420 <alt_get_errno+0x2c>
80143414:	d0a00f17 	ldw	r2,-32708(gp)
80143418:	103ee83a 	callr	r2
8014341c:	00000106 	br	80143424 <alt_get_errno+0x30>
80143420:	d0a08704 	addi	r2,gp,-32228
}
80143424:	e037883a 	mov	sp,fp
80143428:	dfc00117 	ldw	ra,4(sp)
8014342c:	df000017 	ldw	fp,0(sp)
80143430:	dec00204 	addi	sp,sp,8
80143434:	f800283a 	ret

80143438 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
80143438:	defffc04 	addi	sp,sp,-16
8014343c:	de00012e 	bgeu	sp,et,80143444 <alt_msgdma_write_standard_descriptor+0xc>
80143440:	003b68fa 	trap	3
80143444:	df000315 	stw	fp,12(sp)
80143448:	df000304 	addi	fp,sp,12
8014344c:	e13ffd15 	stw	r4,-12(fp)
80143450:	e17ffe15 	stw	r5,-8(fp)
80143454:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
80143458:	e0bffd17 	ldw	r2,-12(fp)
8014345c:	10800037 	ldwio	r2,0(r2)
80143460:	1080010c 	andi	r2,r2,4
80143464:	10000226 	beq	r2,zero,80143470 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
80143468:	00bff904 	movi	r2,-28
8014346c:	00001506 	br	801434c4 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
80143470:	e0bfff17 	ldw	r2,-4(fp)
80143474:	10800017 	ldw	r2,0(r2)
80143478:	1007883a 	mov	r3,r2
8014347c:	e0bffe17 	ldw	r2,-8(fp)
80143480:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
80143484:	e0bffe17 	ldw	r2,-8(fp)
80143488:	10800104 	addi	r2,r2,4
8014348c:	e0ffff17 	ldw	r3,-4(fp)
80143490:	18c00117 	ldw	r3,4(r3)
80143494:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
80143498:	e0bffe17 	ldw	r2,-8(fp)
8014349c:	10800204 	addi	r2,r2,8
801434a0:	e0ffff17 	ldw	r3,-4(fp)
801434a4:	18c00217 	ldw	r3,8(r3)
801434a8:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
801434ac:	e0bffe17 	ldw	r2,-8(fp)
801434b0:	10800304 	addi	r2,r2,12
801434b4:	e0ffff17 	ldw	r3,-4(fp)
801434b8:	18c00317 	ldw	r3,12(r3)
801434bc:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
801434c0:	0005883a 	mov	r2,zero
}
801434c4:	e037883a 	mov	sp,fp
801434c8:	df000017 	ldw	fp,0(sp)
801434cc:	dec00104 	addi	sp,sp,4
801434d0:	f800283a 	ret

801434d4 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
801434d4:	defffc04 	addi	sp,sp,-16
801434d8:	de00012e 	bgeu	sp,et,801434e0 <alt_msgdma_write_extended_descriptor+0xc>
801434dc:	003b68fa 	trap	3
801434e0:	df000315 	stw	fp,12(sp)
801434e4:	df000304 	addi	fp,sp,12
801434e8:	e13ffd15 	stw	r4,-12(fp)
801434ec:	e17ffe15 	stw	r5,-8(fp)
801434f0:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
801434f4:	e0bffd17 	ldw	r2,-12(fp)
801434f8:	10800037 	ldwio	r2,0(r2)
801434fc:	1080010c 	andi	r2,r2,4
80143500:	10000226 	beq	r2,zero,8014350c <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
80143504:	00bff904 	movi	r2,-28
80143508:	00003b06 	br	801435f8 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
8014350c:	e0bfff17 	ldw	r2,-4(fp)
80143510:	10800017 	ldw	r2,0(r2)
80143514:	1007883a 	mov	r3,r2
80143518:	e0bffe17 	ldw	r2,-8(fp)
8014351c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
80143520:	e0bffe17 	ldw	r2,-8(fp)
80143524:	10800104 	addi	r2,r2,4
80143528:	e0ffff17 	ldw	r3,-4(fp)
8014352c:	18c00117 	ldw	r3,4(r3)
80143530:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
80143534:	e0bffe17 	ldw	r2,-8(fp)
80143538:	10800204 	addi	r2,r2,8
8014353c:	e0ffff17 	ldw	r3,-4(fp)
80143540:	18c00217 	ldw	r3,8(r3)
80143544:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
80143548:	e0bffe17 	ldw	r2,-8(fp)
8014354c:	10800304 	addi	r2,r2,12
80143550:	e0ffff17 	ldw	r3,-4(fp)
80143554:	18c0030b 	ldhu	r3,12(r3)
80143558:	18ffffcc 	andi	r3,r3,65535
8014355c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
80143560:	e0bffe17 	ldw	r2,-8(fp)
80143564:	10800384 	addi	r2,r2,14
80143568:	e0ffff17 	ldw	r3,-4(fp)
8014356c:	18c00383 	ldbu	r3,14(r3)
80143570:	18c03fcc 	andi	r3,r3,255
80143574:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
80143578:	e0bffe17 	ldw	r2,-8(fp)
8014357c:	108003c4 	addi	r2,r2,15
80143580:	e0ffff17 	ldw	r3,-4(fp)
80143584:	18c003c3 	ldbu	r3,15(r3)
80143588:	18c03fcc 	andi	r3,r3,255
8014358c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
80143590:	e0bffe17 	ldw	r2,-8(fp)
80143594:	10800404 	addi	r2,r2,16
80143598:	e0ffff17 	ldw	r3,-4(fp)
8014359c:	18c0040b 	ldhu	r3,16(r3)
801435a0:	18ffffcc 	andi	r3,r3,65535
801435a4:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
801435a8:	e0bffe17 	ldw	r2,-8(fp)
801435ac:	10800484 	addi	r2,r2,18
801435b0:	e0ffff17 	ldw	r3,-4(fp)
801435b4:	18c0048b 	ldhu	r3,18(r3)
801435b8:	18ffffcc 	andi	r3,r3,65535
801435bc:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
801435c0:	e0bffe17 	ldw	r2,-8(fp)
801435c4:	10800504 	addi	r2,r2,20
801435c8:	0007883a 	mov	r3,zero
801435cc:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
801435d0:	e0bffe17 	ldw	r2,-8(fp)
801435d4:	10800604 	addi	r2,r2,24
801435d8:	0007883a 	mov	r3,zero
801435dc:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
801435e0:	e0bffe17 	ldw	r2,-8(fp)
801435e4:	10800704 	addi	r2,r2,28
801435e8:	e0ffff17 	ldw	r3,-4(fp)
801435ec:	18c00717 	ldw	r3,28(r3)
801435f0:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
801435f4:	0005883a 	mov	r2,zero
}
801435f8:	e037883a 	mov	sp,fp
801435fc:	df000017 	ldw	fp,0(sp)
80143600:	dec00104 	addi	sp,sp,4
80143604:	f800283a 	ret

80143608 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
80143608:	defff804 	addi	sp,sp,-32
8014360c:	de00012e 	bgeu	sp,et,80143614 <alt_msgdma_irq+0xc>
80143610:	003b68fa 	trap	3
80143614:	dfc00715 	stw	ra,28(sp)
80143618:	df000615 	stw	fp,24(sp)
8014361c:	df000604 	addi	fp,sp,24
80143620:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
80143624:	e0bfff17 	ldw	r2,-4(fp)
80143628:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
8014362c:	e0bffa17 	ldw	r2,-24(fp)
80143630:	10801783 	ldbu	r2,94(r2)
80143634:	10803fcc 	andi	r2,r2,255
80143638:	10001126 	beq	r2,zero,80143680 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
8014363c:	e0bffa17 	ldw	r2,-24(fp)
80143640:	10800617 	ldw	r2,24(r2)
80143644:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
80143648:	1007883a 	mov	r3,r2
8014364c:	00bffdc4 	movi	r2,-9
80143650:	1884703a 	and	r2,r3,r2
80143654:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
80143658:	e0bffa17 	ldw	r2,-24(fp)
8014365c:	10800617 	ldw	r2,24(r2)
80143660:	e0fffb17 	ldw	r3,-20(fp)
80143664:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
80143668:	e0bffa17 	ldw	r2,-24(fp)
8014366c:	10800617 	ldw	r2,24(r2)
80143670:	10800404 	addi	r2,r2,16
80143674:	00c00044 	movi	r3,1
80143678:	10c00035 	stwio	r3,0(r2)
8014367c:	00001106 	br	801436c4 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
80143680:	e0bffa17 	ldw	r2,-24(fp)
80143684:	10800317 	ldw	r2,12(r2)
80143688:	10800104 	addi	r2,r2,4
8014368c:	10800037 	ldwio	r2,0(r2)
80143690:	1007883a 	mov	r3,r2
80143694:	00bffbc4 	movi	r2,-17
80143698:	1884703a 	and	r2,r3,r2
8014369c:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
801436a0:	e0bffa17 	ldw	r2,-24(fp)
801436a4:	10800317 	ldw	r2,12(r2)
801436a8:	10800104 	addi	r2,r2,4
801436ac:	e0fffb17 	ldw	r3,-20(fp)
801436b0:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
801436b4:	e0bffa17 	ldw	r2,-24(fp)
801436b8:	10800317 	ldw	r2,12(r2)
801436bc:	00c08004 	movi	r3,512
801436c0:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
801436c4:	e0bffa17 	ldw	r2,-24(fp)
801436c8:	10800b17 	ldw	r2,44(r2)
801436cc:	10001226 	beq	r2,zero,80143718 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801436d0:	0005303a 	rdctl	r2,status
801436d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801436d8:	e0fffd17 	ldw	r3,-12(fp)
801436dc:	00bfff84 	movi	r2,-2
801436e0:	1884703a 	and	r2,r3,r2
801436e4:	1001703a 	wrctl	status,r2
  
  return context;
801436e8:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
801436ec:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
801436f0:	e0bffa17 	ldw	r2,-24(fp)
801436f4:	10800b17 	ldw	r2,44(r2)
801436f8:	e0fffa17 	ldw	r3,-24(fp)
801436fc:	18c00c17 	ldw	r3,48(r3)
80143700:	1809883a 	mov	r4,r3
80143704:	103ee83a 	callr	r2
80143708:	e0bffc17 	ldw	r2,-16(fp)
8014370c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80143710:	e0bffe17 	ldw	r2,-8(fp)
80143714:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
80143718:	e0bffa17 	ldw	r2,-24(fp)
8014371c:	10801783 	ldbu	r2,94(r2)
80143720:	10803fcc 	andi	r2,r2,255
80143724:	10000a26 	beq	r2,zero,80143750 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
80143728:	e0bffa17 	ldw	r2,-24(fp)
8014372c:	10800617 	ldw	r2,24(r2)
80143730:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
80143734:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
80143738:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
8014373c:	e0bffa17 	ldw	r2,-24(fp)
80143740:	10800617 	ldw	r2,24(r2)
80143744:	e0fffb17 	ldw	r3,-20(fp)
80143748:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
8014374c:	00000c06 	br	80143780 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
80143750:	e0bffa17 	ldw	r2,-24(fp)
80143754:	10800317 	ldw	r2,12(r2)
80143758:	10800104 	addi	r2,r2,4
8014375c:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
80143760:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
80143764:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
80143768:	e0bffa17 	ldw	r2,-24(fp)
8014376c:	10800317 	ldw	r2,12(r2)
80143770:	10800104 	addi	r2,r2,4
80143774:	e0fffb17 	ldw	r3,-20(fp)
80143778:	10c00035 	stwio	r3,0(r2)
    }

    return;
8014377c:	0001883a 	nop
}
80143780:	e037883a 	mov	sp,fp
80143784:	dfc00117 	ldw	ra,4(sp)
80143788:	df000017 	ldw	fp,0(sp)
8014378c:	dec00204 	addi	sp,sp,8
80143790:	f800283a 	ret

80143794 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
80143794:	defffb04 	addi	sp,sp,-20
80143798:	de00012e 	bgeu	sp,et,801437a0 <alt_msgdma_construct_standard_descriptor+0xc>
8014379c:	003b68fa 	trap	3
801437a0:	df000415 	stw	fp,16(sp)
801437a4:	df000404 	addi	fp,sp,16
801437a8:	e13ffc15 	stw	r4,-16(fp)
801437ac:	e17ffd15 	stw	r5,-12(fp)
801437b0:	e1bffe15 	stw	r6,-8(fp)
801437b4:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
801437b8:	e0bffc17 	ldw	r2,-16(fp)
801437bc:	10c01217 	ldw	r3,72(r2)
801437c0:	e0800117 	ldw	r2,4(fp)
801437c4:	18800436 	bltu	r3,r2,801437d8 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
801437c8:	e0bffc17 	ldw	r2,-16(fp)
801437cc:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
801437d0:	10803fcc 	andi	r2,r2,255
801437d4:	10000226 	beq	r2,zero,801437e0 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
801437d8:	00bffa84 	movi	r2,-22
801437dc:	00000e06 	br	80143818 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
801437e0:	e0bffd17 	ldw	r2,-12(fp)
801437e4:	e0fffe17 	ldw	r3,-8(fp)
801437e8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
801437ec:	e0bffd17 	ldw	r2,-12(fp)
801437f0:	e0ffff17 	ldw	r3,-4(fp)
801437f4:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
801437f8:	e0bffd17 	ldw	r2,-12(fp)
801437fc:	e0c00117 	ldw	r3,4(fp)
80143800:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
80143804:	e0800217 	ldw	r2,8(fp)
80143808:	10e00034 	orhi	r3,r2,32768
8014380c:	e0bffd17 	ldw	r2,-12(fp)
80143810:	10c00315 	stw	r3,12(r2)
    
    return 0;
80143814:	0005883a 	mov	r2,zero
}
80143818:	e037883a 	mov	sp,fp
8014381c:	df000017 	ldw	fp,0(sp)
80143820:	dec00104 	addi	sp,sp,4
80143824:	f800283a 	ret

80143828 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
80143828:	defff604 	addi	sp,sp,-40
8014382c:	de00012e 	bgeu	sp,et,80143834 <alt_msgdma_construct_extended_descriptor+0xc>
80143830:	003b68fa 	trap	3
80143834:	df000915 	stw	fp,36(sp)
80143838:	df000904 	addi	fp,sp,36
8014383c:	e13ff715 	stw	r4,-36(fp)
80143840:	e17ff815 	stw	r5,-32(fp)
80143844:	e1bff915 	stw	r6,-28(fp)
80143848:	e1fffa15 	stw	r7,-24(fp)
8014384c:	e1800317 	ldw	r6,12(fp)
80143850:	e1400417 	ldw	r5,16(fp)
80143854:	e1000517 	ldw	r4,20(fp)
80143858:	e0c00617 	ldw	r3,24(fp)
8014385c:	e0800717 	ldw	r2,28(fp)
80143860:	e1bffb0d 	sth	r6,-20(fp)
80143864:	e17ffc05 	stb	r5,-16(fp)
80143868:	e13ffd05 	stb	r4,-12(fp)
8014386c:	e0fffe0d 	sth	r3,-8(fp)
80143870:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
80143874:	e0bff717 	ldw	r2,-36(fp)
80143878:	10c01217 	ldw	r3,72(r2)
8014387c:	e0800117 	ldw	r2,4(fp)
80143880:	18801936 	bltu	r3,r2,801438e8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
80143884:	e13ff717 	ldw	r4,-36(fp)
80143888:	20801317 	ldw	r2,76(r4)
8014388c:	20c01417 	ldw	r3,80(r4)
80143890:	e13ffe0b 	ldhu	r4,-8(fp)
80143894:	213fffcc 	andi	r4,r4,65535
80143898:	2015883a 	mov	r10,r4
8014389c:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
801438a0:	1ac01136 	bltu	r3,r11,801438e8 <alt_msgdma_construct_extended_descriptor+0xc0>
801438a4:	58c0011e 	bne	r11,r3,801438ac <alt_msgdma_construct_extended_descriptor+0x84>
801438a8:	12800f36 	bltu	r2,r10,801438e8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
801438ac:	e13ff717 	ldw	r4,-36(fp)
801438b0:	20801317 	ldw	r2,76(r4)
801438b4:	20c01417 	ldw	r3,80(r4)
801438b8:	e13fff0b 	ldhu	r4,-4(fp)
801438bc:	213fffcc 	andi	r4,r4,65535
801438c0:	2011883a 	mov	r8,r4
801438c4:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
801438c8:	1a400736 	bltu	r3,r9,801438e8 <alt_msgdma_construct_extended_descriptor+0xc0>
801438cc:	48c0011e 	bne	r9,r3,801438d4 <alt_msgdma_construct_extended_descriptor+0xac>
801438d0:	12000536 	bltu	r2,r8,801438e8 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
801438d4:	e0bff717 	ldw	r2,-36(fp)
801438d8:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
801438dc:	10803fcc 	andi	r2,r2,255
801438e0:	10800060 	cmpeqi	r2,r2,1
801438e4:	1000021e 	bne	r2,zero,801438f0 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
801438e8:	00bffa84 	movi	r2,-22
801438ec:	00002106 	br	80143974 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
801438f0:	e0bff817 	ldw	r2,-32(fp)
801438f4:	e0fff917 	ldw	r3,-28(fp)
801438f8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
801438fc:	e0bff817 	ldw	r2,-32(fp)
80143900:	e0fffa17 	ldw	r3,-24(fp)
80143904:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
80143908:	e0bff817 	ldw	r2,-32(fp)
8014390c:	e0c00117 	ldw	r3,4(fp)
80143910:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
80143914:	e0bff817 	ldw	r2,-32(fp)
80143918:	e0fffb0b 	ldhu	r3,-20(fp)
8014391c:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
80143920:	e0bff817 	ldw	r2,-32(fp)
80143924:	e0fffc03 	ldbu	r3,-16(fp)
80143928:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
8014392c:	e0bff817 	ldw	r2,-32(fp)
80143930:	e0fffd03 	ldbu	r3,-12(fp)
80143934:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
80143938:	e0bff817 	ldw	r2,-32(fp)
8014393c:	e0fffe0b 	ldhu	r3,-8(fp)
80143940:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
80143944:	e0bff817 	ldw	r2,-32(fp)
80143948:	e0ffff0b 	ldhu	r3,-4(fp)
8014394c:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
80143950:	e0bff817 	ldw	r2,-32(fp)
80143954:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
80143958:	e0bff817 	ldw	r2,-32(fp)
8014395c:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
80143960:	e0800217 	ldw	r2,8(fp)
80143964:	10e00034 	orhi	r3,r2,32768
80143968:	e0bff817 	ldw	r2,-32(fp)
8014396c:	10c00715 	stw	r3,28(r2)

  return 0 ;
80143970:	0005883a 	mov	r2,zero

}
80143974:	e037883a 	mov	sp,fp
80143978:	df000017 	ldw	fp,0(sp)
8014397c:	dec00104 	addi	sp,sp,4
80143980:	f800283a 	ret

80143984 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
80143984:	deffee04 	addi	sp,sp,-72
80143988:	de00012e 	bgeu	sp,et,80143990 <alt_msgdma_descriptor_async_transfer+0xc>
8014398c:	003b68fa 	trap	3
80143990:	dfc01115 	stw	ra,68(sp)
80143994:	df001015 	stw	fp,64(sp)
80143998:	df001004 	addi	fp,sp,64
8014399c:	e13ffd15 	stw	r4,-12(fp)
801439a0:	e17ffe15 	stw	r5,-8(fp)
801439a4:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
801439a8:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
801439ac:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
801439b0:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
801439b4:	e0bffd17 	ldw	r2,-12(fp)
801439b8:	10800317 	ldw	r2,12(r2)
801439bc:	10800204 	addi	r2,r2,8
801439c0:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
801439c4:	10bfffcc 	andi	r2,r2,65535
801439c8:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
801439cc:	e0bffd17 	ldw	r2,-12(fp)
801439d0:	10800317 	ldw	r2,12(r2)
801439d4:	10800204 	addi	r2,r2,8
801439d8:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
801439dc:	1004d43a 	srli	r2,r2,16
801439e0:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
801439e4:	e0bffd17 	ldw	r2,-12(fp)
801439e8:	10800917 	ldw	r2,36(r2)
801439ec:	e0fff417 	ldw	r3,-48(fp)
801439f0:	1880042e 	bgeu	r3,r2,80143a04 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
801439f4:	e0bffd17 	ldw	r2,-12(fp)
801439f8:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
801439fc:	e0fff317 	ldw	r3,-52(fp)
80143a00:	18800236 	bltu	r3,r2,80143a0c <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
80143a04:	00bff904 	movi	r2,-28
80143a08:	0000a906 	br	80143cb0 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
80143a0c:	e0bffd17 	ldw	r2,-12(fp)
80143a10:	10801817 	ldw	r2,96(r2)
80143a14:	e0bff615 	stw	r2,-40(fp)
80143a18:	e03ffc0d 	sth	zero,-16(fp)
80143a1c:	e0bffc0b 	ldhu	r2,-16(fp)
80143a20:	e0fffc84 	addi	r3,fp,-14
80143a24:	180d883a 	mov	r6,r3
80143a28:	100b883a 	mov	r5,r2
80143a2c:	e13ff617 	ldw	r4,-40(fp)
80143a30:	0139efc0 	call	80139efc <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
80143a34:	00800804 	movi	r2,32
80143a38:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80143a3c:	0005303a 	rdctl	r2,status
80143a40:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80143a44:	e0fff717 	ldw	r3,-36(fp)
80143a48:	00bfff84 	movi	r2,-2
80143a4c:	1884703a 	and	r2,r3,r2
80143a50:	1001703a 	wrctl	status,r2
  
  return context;
80143a54:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
80143a58:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
80143a5c:	e0bffd17 	ldw	r2,-12(fp)
80143a60:	10800317 	ldw	r2,12(r2)
80143a64:	10800104 	addi	r2,r2,4
80143a68:	e0fff117 	ldw	r3,-60(fp)
80143a6c:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
80143a70:	e0bffd17 	ldw	r2,-12(fp)
80143a74:	10800317 	ldw	r2,12(r2)
80143a78:	e0fffd17 	ldw	r3,-12(fp)
80143a7c:	18c00317 	ldw	r3,12(r3)
80143a80:	18c00037 	ldwio	r3,0(r3)
80143a84:	10c00035 	stwio	r3,0(r2)
80143a88:	e0bff217 	ldw	r2,-56(fp)
80143a8c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80143a90:	e0bffb17 	ldw	r2,-20(fp)
80143a94:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
80143a98:	e0bffe17 	ldw	r2,-8(fp)
80143a9c:	10001e26 	beq	r2,zero,80143b18 <alt_msgdma_descriptor_async_transfer+0x194>
80143aa0:	e0bfff17 	ldw	r2,-4(fp)
80143aa4:	10001c1e 	bne	r2,zero,80143b18 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
80143aa8:	00001106 	br	80143af0 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
80143aac:	01000044 	movi	r4,1
80143ab0:	01318f00 	call	801318f0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
80143ab4:	e0bff00b 	ldhu	r2,-64(fp)
80143ab8:	1084e230 	cmpltui	r2,r2,5000
80143abc:	1000091e 	bne	r2,zero,80143ae4 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
80143ac0:	01200574 	movhi	r4,32789
80143ac4:	21208c04 	addi	r4,r4,-32208
80143ac8:	0145e500 	call	80145e50 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
80143acc:	e0bffd17 	ldw	r2,-12(fp)
80143ad0:	10801817 	ldw	r2,96(r2)
80143ad4:	1009883a 	mov	r4,r2
80143ad8:	013a2840 	call	8013a284 <OSSemPost>
				
                return -ETIME;
80143adc:	00bff084 	movi	r2,-62
80143ae0:	00007306 	br	80143cb0 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
80143ae4:	e0bff00b 	ldhu	r2,-64(fp)
80143ae8:	10800044 	addi	r2,r2,1
80143aec:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
80143af0:	e0bffd17 	ldw	r2,-12(fp)
80143af4:	10c00317 	ldw	r3,12(r2)
80143af8:	e0bffd17 	ldw	r2,-12(fp)
80143afc:	10800417 	ldw	r2,16(r2)
80143b00:	e1bffe17 	ldw	r6,-8(fp)
80143b04:	100b883a 	mov	r5,r2
80143b08:	1809883a 	mov	r4,r3
80143b0c:	01434380 	call	80143438 <alt_msgdma_write_standard_descriptor>
80143b10:	103fe61e 	bne	r2,zero,80143aac <__reset+0xfa123aac>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
80143b14:	00002706 	br	80143bb4 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
80143b18:	e0bffe17 	ldw	r2,-8(fp)
80143b1c:	10001f1e 	bne	r2,zero,80143b9c <alt_msgdma_descriptor_async_transfer+0x218>
80143b20:	e0bfff17 	ldw	r2,-4(fp)
80143b24:	10001d26 	beq	r2,zero,80143b9c <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
80143b28:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
80143b2c:	00001106 	br	80143b74 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
80143b30:	01000044 	movi	r4,1
80143b34:	01318f00 	call	801318f0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
80143b38:	e0bff00b 	ldhu	r2,-64(fp)
80143b3c:	1084e230 	cmpltui	r2,r2,5000
80143b40:	1000091e 	bne	r2,zero,80143b68 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
80143b44:	01200574 	movhi	r4,32789
80143b48:	2120a204 	addi	r4,r4,-32120
80143b4c:	0145e500 	call	80145e50 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
80143b50:	e0bffd17 	ldw	r2,-12(fp)
80143b54:	10801817 	ldw	r2,96(r2)
80143b58:	1009883a 	mov	r4,r2
80143b5c:	013a2840 	call	8013a284 <OSSemPost>
				
                return -ETIME;
80143b60:	00bff084 	movi	r2,-62
80143b64:	00005206 	br	80143cb0 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
80143b68:	e0bff00b 	ldhu	r2,-64(fp)
80143b6c:	10800044 	addi	r2,r2,1
80143b70:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
80143b74:	e0bffd17 	ldw	r2,-12(fp)
80143b78:	10c00317 	ldw	r3,12(r2)
80143b7c:	e0bffd17 	ldw	r2,-12(fp)
80143b80:	10800417 	ldw	r2,16(r2)
80143b84:	e1bfff17 	ldw	r6,-4(fp)
80143b88:	100b883a 	mov	r5,r2
80143b8c:	1809883a 	mov	r4,r3
80143b90:	01434d40 	call	801434d4 <alt_msgdma_write_extended_descriptor>
80143b94:	103fe61e 	bne	r2,zero,80143b30 <__reset+0xfa123b30>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
80143b98:	00000606 	br	80143bb4 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
80143b9c:	e0bffd17 	ldw	r2,-12(fp)
80143ba0:	10801817 	ldw	r2,96(r2)
80143ba4:	1009883a 	mov	r4,r2
80143ba8:	013a2840 	call	8013a284 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
80143bac:	00bfffc4 	movi	r2,-1
80143bb0:	00003f06 	br	80143cb0 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
80143bb4:	e0bffd17 	ldw	r2,-12(fp)
80143bb8:	10800b17 	ldw	r2,44(r2)
80143bbc:	10001c26 	beq	r2,zero,80143c30 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
80143bc0:	e0bffd17 	ldw	r2,-12(fp)
80143bc4:	10c00d17 	ldw	r3,52(r2)
80143bc8:	e0bff117 	ldw	r2,-60(fp)
80143bcc:	1884b03a 	or	r2,r3,r2
80143bd0:	10800514 	ori	r2,r2,20
80143bd4:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
80143bd8:	e0fff117 	ldw	r3,-60(fp)
80143bdc:	00bff7c4 	movi	r2,-33
80143be0:	1884703a 	and	r2,r3,r2
80143be4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80143be8:	0005303a 	rdctl	r2,status
80143bec:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80143bf0:	e0fff917 	ldw	r3,-28(fp)
80143bf4:	00bfff84 	movi	r2,-2
80143bf8:	1884703a 	and	r2,r3,r2
80143bfc:	1001703a 	wrctl	status,r2
  
  return context;
80143c00:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
80143c04:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
80143c08:	e0bffd17 	ldw	r2,-12(fp)
80143c0c:	10800317 	ldw	r2,12(r2)
80143c10:	10800104 	addi	r2,r2,4
80143c14:	e0fff117 	ldw	r3,-60(fp)
80143c18:	10c00035 	stwio	r3,0(r2)
80143c1c:	e0bff217 	ldw	r2,-56(fp)
80143c20:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80143c24:	e0bff517 	ldw	r2,-44(fp)
80143c28:	1001703a 	wrctl	status,r2
80143c2c:	00001b06 	br	80143c9c <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
80143c30:	e0bffd17 	ldw	r2,-12(fp)
80143c34:	10c00d17 	ldw	r3,52(r2)
80143c38:	e0bff117 	ldw	r2,-60(fp)
80143c3c:	1884b03a 	or	r2,r3,r2
80143c40:	10800114 	ori	r2,r2,4
80143c44:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
80143c48:	e0fff117 	ldw	r3,-60(fp)
80143c4c:	00bff3c4 	movi	r2,-49
80143c50:	1884703a 	and	r2,r3,r2
80143c54:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80143c58:	0005303a 	rdctl	r2,status
80143c5c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80143c60:	e0fffa17 	ldw	r3,-24(fp)
80143c64:	00bfff84 	movi	r2,-2
80143c68:	1884703a 	and	r2,r3,r2
80143c6c:	1001703a 	wrctl	status,r2
  
  return context;
80143c70:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
80143c74:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
80143c78:	e0bffd17 	ldw	r2,-12(fp)
80143c7c:	10800317 	ldw	r2,12(r2)
80143c80:	10800104 	addi	r2,r2,4
80143c84:	e0fff117 	ldw	r3,-60(fp)
80143c88:	10c00035 	stwio	r3,0(r2)
80143c8c:	e0bff217 	ldw	r2,-56(fp)
80143c90:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80143c94:	e0bff817 	ldw	r2,-32(fp)
80143c98:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
80143c9c:	e0bffd17 	ldw	r2,-12(fp)
80143ca0:	10801817 	ldw	r2,96(r2)
80143ca4:	1009883a 	mov	r4,r2
80143ca8:	013a2840 	call	8013a284 <OSSemPost>
    
    return 0;
80143cac:	0005883a 	mov	r2,zero
}
80143cb0:	e037883a 	mov	sp,fp
80143cb4:	dfc00117 	ldw	ra,4(sp)
80143cb8:	df000017 	ldw	fp,0(sp)
80143cbc:	dec00204 	addi	sp,sp,8
80143cc0:	f800283a 	ret

80143cc4 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
80143cc4:	deffee04 	addi	sp,sp,-72
80143cc8:	de00012e 	bgeu	sp,et,80143cd0 <alt_msgdma_descriptor_sync_transfer+0xc>
80143ccc:	003b68fa 	trap	3
80143cd0:	dfc01115 	stw	ra,68(sp)
80143cd4:	df001015 	stw	fp,64(sp)
80143cd8:	df001004 	addi	fp,sp,64
80143cdc:	e13ffd15 	stw	r4,-12(fp)
80143ce0:	e17ffe15 	stw	r5,-8(fp)
80143ce4:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
80143ce8:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
80143cec:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
80143cf0:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
80143cf4:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
80143cf8:	e0bffd17 	ldw	r2,-12(fp)
80143cfc:	10800317 	ldw	r2,12(r2)
80143d00:	10800204 	addi	r2,r2,8
80143d04:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
80143d08:	10bfffcc 	andi	r2,r2,65535
80143d0c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
80143d10:	e0bffd17 	ldw	r2,-12(fp)
80143d14:	10800317 	ldw	r2,12(r2)
80143d18:	10800204 	addi	r2,r2,8
80143d1c:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
80143d20:	1004d43a 	srli	r2,r2,16
80143d24:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
80143d28:	00807804 	movi	r2,480
80143d2c:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
80143d30:	00001906 	br	80143d98 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
80143d34:	01000044 	movi	r4,1
80143d38:	01318f00 	call	801318f0 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
80143d3c:	e0bff10b 	ldhu	r2,-60(fp)
80143d40:	1084e230 	cmpltui	r2,r2,5000
80143d44:	1000051e 	bne	r2,zero,80143d5c <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
80143d48:	01200574 	movhi	r4,32789
80143d4c:	2120b804 	addi	r4,r4,-32032
80143d50:	0145e500 	call	80145e50 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
80143d54:	00bff084 	movi	r2,-62
80143d58:	0000d706 	br	801440b8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
80143d5c:	e0bff10b 	ldhu	r2,-60(fp)
80143d60:	10800044 	addi	r2,r2,1
80143d64:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
80143d68:	e0bffd17 	ldw	r2,-12(fp)
80143d6c:	10800317 	ldw	r2,12(r2)
80143d70:	10800204 	addi	r2,r2,8
80143d74:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
80143d78:	10bfffcc 	andi	r2,r2,65535
80143d7c:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
80143d80:	e0bffd17 	ldw	r2,-12(fp)
80143d84:	10800317 	ldw	r2,12(r2)
80143d88:	10800204 	addi	r2,r2,8
80143d8c:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
80143d90:	1004d43a 	srli	r2,r2,16
80143d94:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
80143d98:	e0bffd17 	ldw	r2,-12(fp)
80143d9c:	10800917 	ldw	r2,36(r2)
80143da0:	e0fff317 	ldw	r3,-52(fp)
80143da4:	18bfe32e 	bgeu	r3,r2,80143d34 <__reset+0xfa123d34>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
80143da8:	e0bffd17 	ldw	r2,-12(fp)
80143dac:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
80143db0:	e0fff217 	ldw	r3,-56(fp)
80143db4:	18bfdf2e 	bgeu	r3,r2,80143d34 <__reset+0xfa123d34>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
80143db8:	e0bffd17 	ldw	r2,-12(fp)
80143dbc:	10801817 	ldw	r2,96(r2)
80143dc0:	e0bff815 	stw	r2,-32(fp)
80143dc4:	e03ffc0d 	sth	zero,-16(fp)
80143dc8:	e0bffc0b 	ldhu	r2,-16(fp)
80143dcc:	e0fffc84 	addi	r3,fp,-14
80143dd0:	180d883a 	mov	r6,r3
80143dd4:	100b883a 	mov	r5,r2
80143dd8:	e13ff817 	ldw	r4,-32(fp)
80143ddc:	0139efc0 	call	80139efc <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80143de0:	0005303a 	rdctl	r2,status
80143de4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80143de8:	e0fffb17 	ldw	r3,-20(fp)
80143dec:	00bfff84 	movi	r2,-2
80143df0:	1884703a 	and	r2,r3,r2
80143df4:	1001703a 	wrctl	status,r2
  
  return context;
80143df8:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
80143dfc:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
80143e00:	e0bffd17 	ldw	r2,-12(fp)
80143e04:	10800317 	ldw	r2,12(r2)
80143e08:	10800104 	addi	r2,r2,4
80143e0c:	00c00804 	movi	r3,32
80143e10:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
80143e14:	e0bffd17 	ldw	r2,-12(fp)
80143e18:	10800317 	ldw	r2,12(r2)
80143e1c:	e0fffd17 	ldw	r3,-12(fp)
80143e20:	18c00317 	ldw	r3,12(r3)
80143e24:	18c00037 	ldwio	r3,0(r3)
80143e28:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
80143e2c:	e0bffe17 	ldw	r2,-8(fp)
80143e30:	10001f26 	beq	r2,zero,80143eb0 <alt_msgdma_descriptor_sync_transfer+0x1ec>
80143e34:	e0bfff17 	ldw	r2,-4(fp)
80143e38:	10001d1e 	bne	r2,zero,80143eb0 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
80143e3c:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
80143e40:	00001106 	br	80143e88 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
80143e44:	01000044 	movi	r4,1
80143e48:	01318f00 	call	801318f0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
80143e4c:	e0bff10b 	ldhu	r2,-60(fp)
80143e50:	1084e230 	cmpltui	r2,r2,5000
80143e54:	1000091e 	bne	r2,zero,80143e7c <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
80143e58:	01200574 	movhi	r4,32789
80143e5c:	2120cc04 	addi	r4,r4,-31952
80143e60:	0145e500 	call	80145e50 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
80143e64:	e0bffd17 	ldw	r2,-12(fp)
80143e68:	10801817 	ldw	r2,96(r2)
80143e6c:	1009883a 	mov	r4,r2
80143e70:	013a2840 	call	8013a284 <OSSemPost>
				
                return -ETIME;
80143e74:	00bff084 	movi	r2,-62
80143e78:	00008f06 	br	801440b8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
80143e7c:	e0bff10b 	ldhu	r2,-60(fp)
80143e80:	10800044 	addi	r2,r2,1
80143e84:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
80143e88:	e0bffd17 	ldw	r2,-12(fp)
80143e8c:	10c00317 	ldw	r3,12(r2)
80143e90:	e0bffd17 	ldw	r2,-12(fp)
80143e94:	10800417 	ldw	r2,16(r2)
80143e98:	e1bffe17 	ldw	r6,-8(fp)
80143e9c:	100b883a 	mov	r5,r2
80143ea0:	1809883a 	mov	r4,r3
80143ea4:	01434380 	call	80143438 <alt_msgdma_write_standard_descriptor>
80143ea8:	103fe61e 	bne	r2,zero,80143e44 <__reset+0xfa123e44>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
80143eac:	00002706 	br	80143f4c <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
80143eb0:	e0bffe17 	ldw	r2,-8(fp)
80143eb4:	10001f1e 	bne	r2,zero,80143f34 <alt_msgdma_descriptor_sync_transfer+0x270>
80143eb8:	e0bfff17 	ldw	r2,-4(fp)
80143ebc:	10001d26 	beq	r2,zero,80143f34 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
80143ec0:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
80143ec4:	00001106 	br	80143f0c <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
80143ec8:	01000044 	movi	r4,1
80143ecc:	01318f00 	call	801318f0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
80143ed0:	e0bff10b 	ldhu	r2,-60(fp)
80143ed4:	1084e230 	cmpltui	r2,r2,5000
80143ed8:	1000091e 	bne	r2,zero,80143f00 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
80143edc:	01200574 	movhi	r4,32789
80143ee0:	2120dd04 	addi	r4,r4,-31884
80143ee4:	0145e500 	call	80145e50 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
80143ee8:	e0bffd17 	ldw	r2,-12(fp)
80143eec:	10801817 	ldw	r2,96(r2)
80143ef0:	1009883a 	mov	r4,r2
80143ef4:	013a2840 	call	8013a284 <OSSemPost>
				
                return -ETIME;
80143ef8:	00bff084 	movi	r2,-62
80143efc:	00006e06 	br	801440b8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
80143f00:	e0bff10b 	ldhu	r2,-60(fp)
80143f04:	10800044 	addi	r2,r2,1
80143f08:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
80143f0c:	e0bffd17 	ldw	r2,-12(fp)
80143f10:	10c00317 	ldw	r3,12(r2)
80143f14:	e0bffd17 	ldw	r2,-12(fp)
80143f18:	10800417 	ldw	r2,16(r2)
80143f1c:	e1bfff17 	ldw	r6,-4(fp)
80143f20:	100b883a 	mov	r5,r2
80143f24:	1809883a 	mov	r4,r3
80143f28:	01434d40 	call	801434d4 <alt_msgdma_write_extended_descriptor>
80143f2c:	103fe61e 	bne	r2,zero,80143ec8 <__reset+0xfa123ec8>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
80143f30:	00000606 	br	80143f4c <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
80143f34:	e0bffd17 	ldw	r2,-12(fp)
80143f38:	10801817 	ldw	r2,96(r2)
80143f3c:	1009883a 	mov	r4,r2
80143f40:	013a2840 	call	8013a284 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
80143f44:	00bfffc4 	movi	r2,-1
80143f48:	00005b06 	br	801440b8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
80143f4c:	e0bffd17 	ldw	r2,-12(fp)
80143f50:	10800317 	ldw	r2,12(r2)
80143f54:	10800104 	addi	r2,r2,4
80143f58:	e0fffd17 	ldw	r3,-12(fp)
80143f5c:	19000d17 	ldw	r4,52(r3)
80143f60:	00fff2c4 	movi	r3,-53
80143f64:	20c6703a 	and	r3,r4,r3
80143f68:	18c00114 	ori	r3,r3,4
80143f6c:	10c00035 	stwio	r3,0(r2)
80143f70:	e0bff517 	ldw	r2,-44(fp)
80143f74:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80143f78:	e0bff717 	ldw	r2,-36(fp)
80143f7c:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
80143f80:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
80143f84:	e0bffd17 	ldw	r2,-12(fp)
80143f88:	10800317 	ldw	r2,12(r2)
80143f8c:	10800037 	ldwio	r2,0(r2)
80143f90:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
80143f94:	00001506 	br	80143fec <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
80143f98:	01000044 	movi	r4,1
80143f9c:	01318f00 	call	801318f0 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
80143fa0:	e0bff10b 	ldhu	r2,-60(fp)
80143fa4:	1084e230 	cmpltui	r2,r2,5000
80143fa8:	1000091e 	bne	r2,zero,80143fd0 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
80143fac:	01200574 	movhi	r4,32789
80143fb0:	2120ee04 	addi	r4,r4,-31816
80143fb4:	0145e500 	call	80145e50 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
80143fb8:	e0bffd17 	ldw	r2,-12(fp)
80143fbc:	10801817 	ldw	r2,96(r2)
80143fc0:	1009883a 	mov	r4,r2
80143fc4:	013a2840 	call	8013a284 <OSSemPost>
			
            return -ETIME;
80143fc8:	00bff084 	movi	r2,-62
80143fcc:	00003a06 	br	801440b8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
80143fd0:	e0bff10b 	ldhu	r2,-60(fp)
80143fd4:	10800044 	addi	r2,r2,1
80143fd8:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
80143fdc:	e0bffd17 	ldw	r2,-12(fp)
80143fe0:	10800317 	ldw	r2,12(r2)
80143fe4:	10800037 	ldwio	r2,0(r2)
80143fe8:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
80143fec:	e0fff017 	ldw	r3,-64(fp)
80143ff0:	e0bff617 	ldw	r2,-40(fp)
80143ff4:	1884703a 	and	r2,r3,r2
80143ff8:	1000031e 	bne	r2,zero,80144008 <alt_msgdma_descriptor_sync_transfer+0x344>
80143ffc:	e0bff017 	ldw	r2,-64(fp)
80144000:	1080004c 	andi	r2,r2,1
80144004:	103fe41e 	bne	r2,zero,80143f98 <__reset+0xfa123f98>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
80144008:	e0fff017 	ldw	r3,-64(fp)
8014400c:	e0bff617 	ldw	r2,-40(fp)
80144010:	1884703a 	and	r2,r3,r2
80144014:	10000626 	beq	r2,zero,80144030 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
80144018:	e0bffd17 	ldw	r2,-12(fp)
8014401c:	10801817 	ldw	r2,96(r2)
80144020:	1009883a 	mov	r4,r2
80144024:	013a2840 	call	8013a284 <OSSemPost>
		
        return error;
80144028:	e0bff617 	ldw	r2,-40(fp)
8014402c:	00002206 	br	801440b8 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
80144030:	e0bffd17 	ldw	r2,-12(fp)
80144034:	10800317 	ldw	r2,12(r2)
80144038:	10800104 	addi	r2,r2,4
8014403c:	10800037 	ldwio	r2,0(r2)
80144040:	10800814 	ori	r2,r2,32
80144044:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80144048:	0005303a 	rdctl	r2,status
8014404c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80144050:	e0fffa17 	ldw	r3,-24(fp)
80144054:	00bfff84 	movi	r2,-2
80144058:	1884703a 	and	r2,r3,r2
8014405c:	1001703a 	wrctl	status,r2
  
  return context;
80144060:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
80144064:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
80144068:	e0bffd17 	ldw	r2,-12(fp)
8014406c:	10800317 	ldw	r2,12(r2)
80144070:	10800104 	addi	r2,r2,4
80144074:	e0fff417 	ldw	r3,-48(fp)
80144078:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
8014407c:	e0bffd17 	ldw	r2,-12(fp)
80144080:	10800317 	ldw	r2,12(r2)
80144084:	e0fffd17 	ldw	r3,-12(fp)
80144088:	18c00317 	ldw	r3,12(r3)
8014408c:	18c00037 	ldwio	r3,0(r3)
80144090:	10c00035 	stwio	r3,0(r2)
80144094:	e0bff517 	ldw	r2,-44(fp)
80144098:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8014409c:	e0bff917 	ldw	r2,-28(fp)
801440a0:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
801440a4:	e0bffd17 	ldw	r2,-12(fp)
801440a8:	10801817 	ldw	r2,96(r2)
801440ac:	1009883a 	mov	r4,r2
801440b0:	013a2840 	call	8013a284 <OSSemPost>
    
    return 0;
801440b4:	0005883a 	mov	r2,zero

}
801440b8:	e037883a 	mov	sp,fp
801440bc:	dfc00117 	ldw	ra,4(sp)
801440c0:	df000017 	ldw	fp,0(sp)
801440c4:	dec00204 	addi	sp,sp,8
801440c8:	f800283a 	ret

801440cc <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
801440cc:	defff804 	addi	sp,sp,-32
801440d0:	de00012e 	bgeu	sp,et,801440d8 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
801440d4:	003b68fa 	trap	3
801440d8:	dfc00715 	stw	ra,28(sp)
801440dc:	df000615 	stw	fp,24(sp)
801440e0:	df000604 	addi	fp,sp,24
801440e4:	e13ffc15 	stw	r4,-16(fp)
801440e8:	e17ffd15 	stw	r5,-12(fp)
801440ec:	e1bffe15 	stw	r6,-8(fp)
801440f0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
801440f4:	e0800217 	ldw	r2,8(fp)
801440f8:	d8800115 	stw	r2,4(sp)
801440fc:	e0bfff17 	ldw	r2,-4(fp)
80144100:	d8800015 	stw	r2,0(sp)
80144104:	e1fffe17 	ldw	r7,-8(fp)
80144108:	000d883a 	mov	r6,zero
8014410c:	e17ffd17 	ldw	r5,-12(fp)
80144110:	e13ffc17 	ldw	r4,-16(fp)
80144114:	01437940 	call	80143794 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
80144118:	e037883a 	mov	sp,fp
8014411c:	dfc00117 	ldw	ra,4(sp)
80144120:	df000017 	ldw	fp,0(sp)
80144124:	dec00204 	addi	sp,sp,8
80144128:	f800283a 	ret

8014412c <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
8014412c:	defff804 	addi	sp,sp,-32
80144130:	de00012e 	bgeu	sp,et,80144138 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
80144134:	003b68fa 	trap	3
80144138:	dfc00715 	stw	ra,28(sp)
8014413c:	df000615 	stw	fp,24(sp)
80144140:	df000604 	addi	fp,sp,24
80144144:	e13ffc15 	stw	r4,-16(fp)
80144148:	e17ffd15 	stw	r5,-12(fp)
8014414c:	e1bffe15 	stw	r6,-8(fp)
80144150:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
80144154:	e0800217 	ldw	r2,8(fp)
80144158:	d8800115 	stw	r2,4(sp)
8014415c:	e0bfff17 	ldw	r2,-4(fp)
80144160:	d8800015 	stw	r2,0(sp)
80144164:	000f883a 	mov	r7,zero
80144168:	e1bffe17 	ldw	r6,-8(fp)
8014416c:	e17ffd17 	ldw	r5,-12(fp)
80144170:	e13ffc17 	ldw	r4,-16(fp)
80144174:	01437940 	call	80143794 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
80144178:	e037883a 	mov	sp,fp
8014417c:	dfc00117 	ldw	ra,4(sp)
80144180:	df000017 	ldw	fp,0(sp)
80144184:	dec00204 	addi	sp,sp,8
80144188:	f800283a 	ret

8014418c <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8014418c:	defff804 	addi	sp,sp,-32
80144190:	de00012e 	bgeu	sp,et,80144198 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
80144194:	003b68fa 	trap	3
80144198:	dfc00715 	stw	ra,28(sp)
8014419c:	df000615 	stw	fp,24(sp)
801441a0:	df000604 	addi	fp,sp,24
801441a4:	e13ffc15 	stw	r4,-16(fp)
801441a8:	e17ffd15 	stw	r5,-12(fp)
801441ac:	e1bffe15 	stw	r6,-8(fp)
801441b0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
801441b4:	e0800317 	ldw	r2,12(fp)
801441b8:	d8800115 	stw	r2,4(sp)
801441bc:	e0800217 	ldw	r2,8(fp)
801441c0:	d8800015 	stw	r2,0(sp)
801441c4:	e1ffff17 	ldw	r7,-4(fp)
801441c8:	e1bffe17 	ldw	r6,-8(fp)
801441cc:	e17ffd17 	ldw	r5,-12(fp)
801441d0:	e13ffc17 	ldw	r4,-16(fp)
801441d4:	01437940 	call	80143794 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
801441d8:	e037883a 	mov	sp,fp
801441dc:	dfc00117 	ldw	ra,4(sp)
801441e0:	df000017 	ldw	fp,0(sp)
801441e4:	dec00204 	addi	sp,sp,8
801441e8:	f800283a 	ret

801441ec <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
801441ec:	defff004 	addi	sp,sp,-64
801441f0:	de00012e 	bgeu	sp,et,801441f8 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
801441f4:	003b68fa 	trap	3
801441f8:	dfc00f15 	stw	ra,60(sp)
801441fc:	df000e15 	stw	fp,56(sp)
80144200:	df000e04 	addi	fp,sp,56
80144204:	e13ff915 	stw	r4,-28(fp)
80144208:	e17ffa15 	stw	r5,-24(fp)
8014420c:	e1bffb15 	stw	r6,-20(fp)
80144210:	e1fffc15 	stw	r7,-16(fp)
80144214:	e1000317 	ldw	r4,12(fp)
80144218:	e0c00417 	ldw	r3,16(fp)
8014421c:	e0800517 	ldw	r2,20(fp)
80144220:	e13ffd0d 	sth	r4,-12(fp)
80144224:	e0fffe05 	stb	r3,-8(fp)
80144228:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8014422c:	e0bffd0b 	ldhu	r2,-12(fp)
80144230:	e0fffe03 	ldbu	r3,-8(fp)
80144234:	e13fff0b 	ldhu	r4,-4(fp)
80144238:	d9000615 	stw	r4,24(sp)
8014423c:	d8000515 	stw	zero,20(sp)
80144240:	d8c00415 	stw	r3,16(sp)
80144244:	d8000315 	stw	zero,12(sp)
80144248:	d8800215 	stw	r2,8(sp)
8014424c:	e0800217 	ldw	r2,8(fp)
80144250:	d8800115 	stw	r2,4(sp)
80144254:	e0bffc17 	ldw	r2,-16(fp)
80144258:	d8800015 	stw	r2,0(sp)
8014425c:	e1fffb17 	ldw	r7,-20(fp)
80144260:	000d883a 	mov	r6,zero
80144264:	e17ffa17 	ldw	r5,-24(fp)
80144268:	e13ff917 	ldw	r4,-28(fp)
8014426c:	01438280 	call	80143828 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
80144270:	e037883a 	mov	sp,fp
80144274:	dfc00117 	ldw	ra,4(sp)
80144278:	df000017 	ldw	fp,0(sp)
8014427c:	dec00204 	addi	sp,sp,8
80144280:	f800283a 	ret

80144284 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
80144284:	defff004 	addi	sp,sp,-64
80144288:	de00012e 	bgeu	sp,et,80144290 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
8014428c:	003b68fa 	trap	3
80144290:	dfc00f15 	stw	ra,60(sp)
80144294:	df000e15 	stw	fp,56(sp)
80144298:	df000e04 	addi	fp,sp,56
8014429c:	e13ff915 	stw	r4,-28(fp)
801442a0:	e17ffa15 	stw	r5,-24(fp)
801442a4:	e1bffb15 	stw	r6,-20(fp)
801442a8:	e1fffc15 	stw	r7,-16(fp)
801442ac:	e1000317 	ldw	r4,12(fp)
801442b0:	e0c00417 	ldw	r3,16(fp)
801442b4:	e0800517 	ldw	r2,20(fp)
801442b8:	e13ffd0d 	sth	r4,-12(fp)
801442bc:	e0fffe05 	stb	r3,-8(fp)
801442c0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
801442c4:	e0bffd0b 	ldhu	r2,-12(fp)
801442c8:	e0fffe03 	ldbu	r3,-8(fp)
801442cc:	e13fff0b 	ldhu	r4,-4(fp)
801442d0:	d8000615 	stw	zero,24(sp)
801442d4:	d9000515 	stw	r4,20(sp)
801442d8:	d8000415 	stw	zero,16(sp)
801442dc:	d8c00315 	stw	r3,12(sp)
801442e0:	d8800215 	stw	r2,8(sp)
801442e4:	e0800217 	ldw	r2,8(fp)
801442e8:	d8800115 	stw	r2,4(sp)
801442ec:	e0bffc17 	ldw	r2,-16(fp)
801442f0:	d8800015 	stw	r2,0(sp)
801442f4:	000f883a 	mov	r7,zero
801442f8:	e1bffb17 	ldw	r6,-20(fp)
801442fc:	e17ffa17 	ldw	r5,-24(fp)
80144300:	e13ff917 	ldw	r4,-28(fp)
80144304:	01438280 	call	80143828 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
80144308:	e037883a 	mov	sp,fp
8014430c:	dfc00117 	ldw	ra,4(sp)
80144310:	df000017 	ldw	fp,0(sp)
80144314:	dec00204 	addi	sp,sp,8
80144318:	f800283a 	ret

8014431c <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
8014431c:	deffee04 	addi	sp,sp,-72
80144320:	de00012e 	bgeu	sp,et,80144328 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
80144324:	003b68fa 	trap	3
80144328:	dfc01115 	stw	ra,68(sp)
8014432c:	df001015 	stw	fp,64(sp)
80144330:	df001004 	addi	fp,sp,64
80144334:	e13ff715 	stw	r4,-36(fp)
80144338:	e17ff815 	stw	r5,-32(fp)
8014433c:	e1bff915 	stw	r6,-28(fp)
80144340:	e1fffa15 	stw	r7,-24(fp)
80144344:	e1800417 	ldw	r6,16(fp)
80144348:	e1400517 	ldw	r5,20(fp)
8014434c:	e1000617 	ldw	r4,24(fp)
80144350:	e0c00717 	ldw	r3,28(fp)
80144354:	e0800817 	ldw	r2,32(fp)
80144358:	e1bffb0d 	sth	r6,-20(fp)
8014435c:	e17ffc05 	stb	r5,-16(fp)
80144360:	e13ffd05 	stb	r4,-12(fp)
80144364:	e0fffe0d 	sth	r3,-8(fp)
80144368:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
8014436c:	e0bffb0b 	ldhu	r2,-20(fp)
80144370:	e0fffc03 	ldbu	r3,-16(fp)
80144374:	e13ffd03 	ldbu	r4,-12(fp)
80144378:	e17ffe0b 	ldhu	r5,-8(fp)
8014437c:	e1bfff0b 	ldhu	r6,-4(fp)
80144380:	d9800615 	stw	r6,24(sp)
80144384:	d9400515 	stw	r5,20(sp)
80144388:	d9000415 	stw	r4,16(sp)
8014438c:	d8c00315 	stw	r3,12(sp)
80144390:	d8800215 	stw	r2,8(sp)
80144394:	e0800317 	ldw	r2,12(fp)
80144398:	d8800115 	stw	r2,4(sp)
8014439c:	e0800217 	ldw	r2,8(fp)
801443a0:	d8800015 	stw	r2,0(sp)
801443a4:	e1fffa17 	ldw	r7,-24(fp)
801443a8:	e1bff917 	ldw	r6,-28(fp)
801443ac:	e17ff817 	ldw	r5,-32(fp)
801443b0:	e13ff717 	ldw	r4,-36(fp)
801443b4:	01438280 	call	80143828 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
801443b8:	e037883a 	mov	sp,fp
801443bc:	dfc00117 	ldw	ra,4(sp)
801443c0:	df000017 	ldw	fp,0(sp)
801443c4:	dec00204 	addi	sp,sp,8
801443c8:	f800283a 	ret

801443cc <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
801443cc:	defffb04 	addi	sp,sp,-20
801443d0:	de00012e 	bgeu	sp,et,801443d8 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
801443d4:	003b68fa 	trap	3
801443d8:	df000415 	stw	fp,16(sp)
801443dc:	df000404 	addi	fp,sp,16
801443e0:	e13ffc15 	stw	r4,-16(fp)
801443e4:	e17ffd15 	stw	r5,-12(fp)
801443e8:	e1bffe15 	stw	r6,-8(fp)
801443ec:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
801443f0:	e0bffc17 	ldw	r2,-16(fp)
801443f4:	10c01217 	ldw	r3,72(r2)
801443f8:	e0800117 	ldw	r2,4(fp)
801443fc:	18800436 	bltu	r3,r2,80144410 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
80144400:	e0bffc17 	ldw	r2,-16(fp)
80144404:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
80144408:	10803fcc 	andi	r2,r2,255
8014440c:	10000226 	beq	r2,zero,80144418 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
80144410:	00bffa84 	movi	r2,-22
80144414:	00001406 	br	80144468 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
80144418:	e0bffd17 	ldw	r2,-12(fp)
8014441c:	e0fffe17 	ldw	r3,-8(fp)
80144420:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
80144424:	e0bffd17 	ldw	r2,-12(fp)
80144428:	e0ffff17 	ldw	r3,-4(fp)
8014442c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
80144430:	e0bffd17 	ldw	r2,-12(fp)
80144434:	e0c00117 	ldw	r3,4(fp)
80144438:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
8014443c:	e0fffd17 	ldw	r3,-12(fp)
80144440:	e0bffd17 	ldw	r2,-12(fp)
80144444:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
80144448:	e0c00217 	ldw	r3,8(fp)
8014444c:	00900034 	movhi	r2,16384
80144450:	10bfffc4 	addi	r2,r2,-1
80144454:	1884703a 	and	r2,r3,r2
80144458:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
8014445c:	e0bffd17 	ldw	r2,-12(fp)
80144460:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
80144464:	0005883a 	mov	r2,zero
}
80144468:	e037883a 	mov	sp,fp
8014446c:	df000017 	ldw	fp,0(sp)
80144470:	dec00104 	addi	sp,sp,4
80144474:	f800283a 	ret

80144478 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
80144478:	defff404 	addi	sp,sp,-48
8014447c:	de00012e 	bgeu	sp,et,80144484 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
80144480:	003b68fa 	trap	3
80144484:	df000b15 	stw	fp,44(sp)
80144488:	df000b04 	addi	fp,sp,44
8014448c:	e13ff715 	stw	r4,-36(fp)
80144490:	e17ff815 	stw	r5,-32(fp)
80144494:	e1bff915 	stw	r6,-28(fp)
80144498:	e1fffa15 	stw	r7,-24(fp)
8014449c:	e1800517 	ldw	r6,20(fp)
801444a0:	e1400617 	ldw	r5,24(fp)
801444a4:	e1000717 	ldw	r4,28(fp)
801444a8:	e0c00817 	ldw	r3,32(fp)
801444ac:	e0800917 	ldw	r2,36(fp)
801444b0:	e1bffb0d 	sth	r6,-20(fp)
801444b4:	e17ffc05 	stb	r5,-16(fp)
801444b8:	e13ffd05 	stb	r4,-12(fp)
801444bc:	e0fffe0d 	sth	r3,-8(fp)
801444c0:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
801444c4:	e0bff717 	ldw	r2,-36(fp)
801444c8:	10c01217 	ldw	r3,72(r2)
801444cc:	e0800317 	ldw	r2,12(fp)
801444d0:	18801936 	bltu	r3,r2,80144538 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
801444d4:	e13ff717 	ldw	r4,-36(fp)
801444d8:	20801317 	ldw	r2,76(r4)
801444dc:	20c01417 	ldw	r3,80(r4)
801444e0:	e13ffe0b 	ldhu	r4,-8(fp)
801444e4:	213fffcc 	andi	r4,r4,65535
801444e8:	2015883a 	mov	r10,r4
801444ec:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
801444f0:	1ac01136 	bltu	r3,r11,80144538 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
801444f4:	58c0011e 	bne	r11,r3,801444fc <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
801444f8:	12800f36 	bltu	r2,r10,80144538 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
801444fc:	e13ff717 	ldw	r4,-36(fp)
80144500:	20801317 	ldw	r2,76(r4)
80144504:	20c01417 	ldw	r3,80(r4)
80144508:	e13fff0b 	ldhu	r4,-4(fp)
8014450c:	213fffcc 	andi	r4,r4,65535
80144510:	2011883a 	mov	r8,r4
80144514:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
80144518:	1a400736 	bltu	r3,r9,80144538 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
8014451c:	48c0011e 	bne	r9,r3,80144524 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
80144520:	12000536 	bltu	r2,r8,80144538 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
80144524:	e0bff717 	ldw	r2,-36(fp)
80144528:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
8014452c:	10803fcc 	andi	r2,r2,255
80144530:	10800060 	cmpeqi	r2,r2,1
80144534:	1000021e 	bne	r2,zero,80144540 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
80144538:	00bffa84 	movi	r2,-22
8014453c:	00003106 	br	80144604 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
80144540:	e0bff817 	ldw	r2,-32(fp)
80144544:	e0fff917 	ldw	r3,-28(fp)
80144548:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
8014454c:	e0bff817 	ldw	r2,-32(fp)
80144550:	e0fffa17 	ldw	r3,-24(fp)
80144554:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
80144558:	e0bff817 	ldw	r2,-32(fp)
8014455c:	e0c00117 	ldw	r3,4(fp)
80144560:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
80144564:	e0bff817 	ldw	r2,-32(fp)
80144568:	e0c00217 	ldw	r3,8(fp)
8014456c:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
80144570:	e0bff817 	ldw	r2,-32(fp)
80144574:	e0c00317 	ldw	r3,12(fp)
80144578:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8014457c:	e0bff817 	ldw	r2,-32(fp)
80144580:	e0fffb0b 	ldhu	r3,-20(fp)
80144584:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
80144588:	e0bff817 	ldw	r2,-32(fp)
8014458c:	e0fffc03 	ldbu	r3,-16(fp)
80144590:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
80144594:	e0bff817 	ldw	r2,-32(fp)
80144598:	e0fffd03 	ldbu	r3,-12(fp)
8014459c:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
801445a0:	e0bff817 	ldw	r2,-32(fp)
801445a4:	e0fffe0b 	ldhu	r3,-8(fp)
801445a8:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
801445ac:	e0bff817 	ldw	r2,-32(fp)
801445b0:	e0ffff0b 	ldhu	r3,-4(fp)
801445b4:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
801445b8:	e0bff817 	ldw	r2,-32(fp)
801445bc:	1019883a 	mov	r12,r2
801445c0:	001b883a 	mov	r13,zero
801445c4:	e33ff515 	stw	r12,-44(fp)
801445c8:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
801445cc:	e0fff517 	ldw	r3,-44(fp)
801445d0:	e0bff817 	ldw	r2,-32(fp)
801445d4:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
801445d8:	e0fff617 	ldw	r3,-40(fp)
801445dc:	e0bff817 	ldw	r2,-32(fp)
801445e0:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
801445e4:	e0c00417 	ldw	r3,16(fp)
801445e8:	00900034 	movhi	r2,16384
801445ec:	10bfffc4 	addi	r2,r2,-1
801445f0:	1884703a 	and	r2,r3,r2
801445f4:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
801445f8:	e0bff817 	ldw	r2,-32(fp)
801445fc:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
80144600:	0005883a 	mov	r2,zero
}
80144604:	e037883a 	mov	sp,fp
80144608:	df000017 	ldw	fp,0(sp)
8014460c:	dec00104 	addi	sp,sp,4
80144610:	f800283a 	ret

80144614 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
80144614:	defff804 	addi	sp,sp,-32
80144618:	de00012e 	bgeu	sp,et,80144620 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
8014461c:	003b68fa 	trap	3
80144620:	dfc00715 	stw	ra,28(sp)
80144624:	df000615 	stw	fp,24(sp)
80144628:	df000604 	addi	fp,sp,24
8014462c:	e13ffc15 	stw	r4,-16(fp)
80144630:	e17ffd15 	stw	r5,-12(fp)
80144634:	e1bffe15 	stw	r6,-8(fp)
80144638:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8014463c:	e0800317 	ldw	r2,12(fp)
80144640:	d8800115 	stw	r2,4(sp)
80144644:	e0800217 	ldw	r2,8(fp)
80144648:	d8800015 	stw	r2,0(sp)
8014464c:	e1ffff17 	ldw	r7,-4(fp)
80144650:	e1bffe17 	ldw	r6,-8(fp)
80144654:	e17ffd17 	ldw	r5,-12(fp)
80144658:	e13ffc17 	ldw	r4,-16(fp)
8014465c:	01443cc0 	call	801443cc <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
80144660:	e037883a 	mov	sp,fp
80144664:	dfc00117 	ldw	ra,4(sp)
80144668:	df000017 	ldw	fp,0(sp)
8014466c:	dec00204 	addi	sp,sp,8
80144670:	f800283a 	ret

80144674 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
80144674:	defff804 	addi	sp,sp,-32
80144678:	de00012e 	bgeu	sp,et,80144680 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
8014467c:	003b68fa 	trap	3
80144680:	dfc00715 	stw	ra,28(sp)
80144684:	df000615 	stw	fp,24(sp)
80144688:	df000604 	addi	fp,sp,24
8014468c:	e13ffc15 	stw	r4,-16(fp)
80144690:	e17ffd15 	stw	r5,-12(fp)
80144694:	e1bffe15 	stw	r6,-8(fp)
80144698:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
8014469c:	e0800217 	ldw	r2,8(fp)
801446a0:	d8800115 	stw	r2,4(sp)
801446a4:	e0bfff17 	ldw	r2,-4(fp)
801446a8:	d8800015 	stw	r2,0(sp)
801446ac:	e1fffe17 	ldw	r7,-8(fp)
801446b0:	000d883a 	mov	r6,zero
801446b4:	e17ffd17 	ldw	r5,-12(fp)
801446b8:	e13ffc17 	ldw	r4,-16(fp)
801446bc:	01443cc0 	call	801443cc <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
801446c0:	e037883a 	mov	sp,fp
801446c4:	dfc00117 	ldw	ra,4(sp)
801446c8:	df000017 	ldw	fp,0(sp)
801446cc:	dec00204 	addi	sp,sp,8
801446d0:	f800283a 	ret

801446d4 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
801446d4:	defff804 	addi	sp,sp,-32
801446d8:	de00012e 	bgeu	sp,et,801446e0 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
801446dc:	003b68fa 	trap	3
801446e0:	dfc00715 	stw	ra,28(sp)
801446e4:	df000615 	stw	fp,24(sp)
801446e8:	df000604 	addi	fp,sp,24
801446ec:	e13ffc15 	stw	r4,-16(fp)
801446f0:	e17ffd15 	stw	r5,-12(fp)
801446f4:	e1bffe15 	stw	r6,-8(fp)
801446f8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
801446fc:	e0800217 	ldw	r2,8(fp)
80144700:	d8800115 	stw	r2,4(sp)
80144704:	e0bfff17 	ldw	r2,-4(fp)
80144708:	d8800015 	stw	r2,0(sp)
8014470c:	000f883a 	mov	r7,zero
80144710:	e1bffe17 	ldw	r6,-8(fp)
80144714:	e17ffd17 	ldw	r5,-12(fp)
80144718:	e13ffc17 	ldw	r4,-16(fp)
8014471c:	01443cc0 	call	801443cc <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
80144720:	e037883a 	mov	sp,fp
80144724:	dfc00117 	ldw	ra,4(sp)
80144728:	df000017 	ldw	fp,0(sp)
8014472c:	dec00204 	addi	sp,sp,8
80144730:	f800283a 	ret

80144734 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
80144734:	deffee04 	addi	sp,sp,-72
80144738:	de00012e 	bgeu	sp,et,80144740 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
8014473c:	003b68fa 	trap	3
80144740:	dfc01115 	stw	ra,68(sp)
80144744:	df001015 	stw	fp,64(sp)
80144748:	df001004 	addi	fp,sp,64
8014474c:	e13ff915 	stw	r4,-28(fp)
80144750:	e17ffa15 	stw	r5,-24(fp)
80144754:	e1bffb15 	stw	r6,-20(fp)
80144758:	e1fffc15 	stw	r7,-16(fp)
8014475c:	e1000417 	ldw	r4,16(fp)
80144760:	e0c00517 	ldw	r3,20(fp)
80144764:	e0800617 	ldw	r2,24(fp)
80144768:	e13ffd0d 	sth	r4,-12(fp)
8014476c:	e0fffe05 	stb	r3,-8(fp)
80144770:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
80144774:	e0bffd0b 	ldhu	r2,-12(fp)
80144778:	e0fffe03 	ldbu	r3,-8(fp)
8014477c:	e13fff0b 	ldhu	r4,-4(fp)
80144780:	d9000815 	stw	r4,32(sp)
80144784:	d8000715 	stw	zero,28(sp)
80144788:	d8c00615 	stw	r3,24(sp)
8014478c:	d8000515 	stw	zero,20(sp)
80144790:	d8800415 	stw	r2,16(sp)
80144794:	e0800317 	ldw	r2,12(fp)
80144798:	d8800315 	stw	r2,12(sp)
8014479c:	e0800217 	ldw	r2,8(fp)
801447a0:	d8800215 	stw	r2,8(sp)
801447a4:	e0bffc17 	ldw	r2,-16(fp)
801447a8:	d8800115 	stw	r2,4(sp)
801447ac:	e0bffb17 	ldw	r2,-20(fp)
801447b0:	d8800015 	stw	r2,0(sp)
801447b4:	000f883a 	mov	r7,zero
801447b8:	000d883a 	mov	r6,zero
801447bc:	e17ffa17 	ldw	r5,-24(fp)
801447c0:	e13ff917 	ldw	r4,-28(fp)
801447c4:	01444780 	call	80144478 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
801447c8:	e037883a 	mov	sp,fp
801447cc:	dfc00117 	ldw	ra,4(sp)
801447d0:	df000017 	ldw	fp,0(sp)
801447d4:	dec00204 	addi	sp,sp,8
801447d8:	f800283a 	ret

801447dc <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
801447dc:	deffee04 	addi	sp,sp,-72
801447e0:	de00012e 	bgeu	sp,et,801447e8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
801447e4:	003b68fa 	trap	3
801447e8:	dfc01115 	stw	ra,68(sp)
801447ec:	df001015 	stw	fp,64(sp)
801447f0:	df001004 	addi	fp,sp,64
801447f4:	e13ff915 	stw	r4,-28(fp)
801447f8:	e17ffa15 	stw	r5,-24(fp)
801447fc:	e1bffb15 	stw	r6,-20(fp)
80144800:	e1fffc15 	stw	r7,-16(fp)
80144804:	e1000417 	ldw	r4,16(fp)
80144808:	e0c00517 	ldw	r3,20(fp)
8014480c:	e0800617 	ldw	r2,24(fp)
80144810:	e13ffd0d 	sth	r4,-12(fp)
80144814:	e0fffe05 	stb	r3,-8(fp)
80144818:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
8014481c:	e0bffd0b 	ldhu	r2,-12(fp)
80144820:	e0fffe03 	ldbu	r3,-8(fp)
80144824:	e13fff0b 	ldhu	r4,-4(fp)
80144828:	d8000815 	stw	zero,32(sp)
8014482c:	d9000715 	stw	r4,28(sp)
80144830:	d8000615 	stw	zero,24(sp)
80144834:	d8c00515 	stw	r3,20(sp)
80144838:	d8800415 	stw	r2,16(sp)
8014483c:	e0800317 	ldw	r2,12(fp)
80144840:	d8800315 	stw	r2,12(sp)
80144844:	e0800217 	ldw	r2,8(fp)
80144848:	d8800215 	stw	r2,8(sp)
8014484c:	d8000115 	stw	zero,4(sp)
80144850:	d8000015 	stw	zero,0(sp)
80144854:	e1fffc17 	ldw	r7,-16(fp)
80144858:	e1bffb17 	ldw	r6,-20(fp)
8014485c:	e17ffa17 	ldw	r5,-24(fp)
80144860:	e13ff917 	ldw	r4,-28(fp)
80144864:	01444780 	call	80144478 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
80144868:	e037883a 	mov	sp,fp
8014486c:	dfc00117 	ldw	ra,4(sp)
80144870:	df000017 	ldw	fp,0(sp)
80144874:	dec00204 	addi	sp,sp,8
80144878:	f800283a 	ret

8014487c <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
8014487c:	deffec04 	addi	sp,sp,-80
80144880:	de00012e 	bgeu	sp,et,80144888 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
80144884:	003b68fa 	trap	3
80144888:	dfc01315 	stw	ra,76(sp)
8014488c:	df001215 	stw	fp,72(sp)
80144890:	df001204 	addi	fp,sp,72
80144894:	e13ff715 	stw	r4,-36(fp)
80144898:	e17ff815 	stw	r5,-32(fp)
8014489c:	e1bff915 	stw	r6,-28(fp)
801448a0:	e1fffa15 	stw	r7,-24(fp)
801448a4:	e1800617 	ldw	r6,24(fp)
801448a8:	e1400717 	ldw	r5,28(fp)
801448ac:	e1000817 	ldw	r4,32(fp)
801448b0:	e0c00917 	ldw	r3,36(fp)
801448b4:	e0800a17 	ldw	r2,40(fp)
801448b8:	e1bffb0d 	sth	r6,-20(fp)
801448bc:	e17ffc05 	stb	r5,-16(fp)
801448c0:	e13ffd05 	stb	r4,-12(fp)
801448c4:	e0fffe0d 	sth	r3,-8(fp)
801448c8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
801448cc:	e0bffb0b 	ldhu	r2,-20(fp)
801448d0:	e0fffc03 	ldbu	r3,-16(fp)
801448d4:	e13ffd03 	ldbu	r4,-12(fp)
801448d8:	e17ffe0b 	ldhu	r5,-8(fp)
801448dc:	e1bfff0b 	ldhu	r6,-4(fp)
801448e0:	d9800815 	stw	r6,32(sp)
801448e4:	d9400715 	stw	r5,28(sp)
801448e8:	d9000615 	stw	r4,24(sp)
801448ec:	d8c00515 	stw	r3,20(sp)
801448f0:	d8800415 	stw	r2,16(sp)
801448f4:	e0800517 	ldw	r2,20(fp)
801448f8:	d8800315 	stw	r2,12(sp)
801448fc:	e0800417 	ldw	r2,16(fp)
80144900:	d8800215 	stw	r2,8(sp)
80144904:	e0800317 	ldw	r2,12(fp)
80144908:	d8800115 	stw	r2,4(sp)
8014490c:	e0800217 	ldw	r2,8(fp)
80144910:	d8800015 	stw	r2,0(sp)
80144914:	e1fffa17 	ldw	r7,-24(fp)
80144918:	e1bff917 	ldw	r6,-28(fp)
8014491c:	e17ff817 	ldw	r5,-32(fp)
80144920:	e13ff717 	ldw	r4,-36(fp)
80144924:	01444780 	call	80144478 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
80144928:	e037883a 	mov	sp,fp
8014492c:	dfc00117 	ldw	ra,4(sp)
80144930:	df000017 	ldw	fp,0(sp)
80144934:	dec00204 	addi	sp,sp,8
80144938:	f800283a 	ret

8014493c <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
8014493c:	defffc04 	addi	sp,sp,-16
80144940:	de00012e 	bgeu	sp,et,80144948 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
80144944:	003b68fa 	trap	3
80144948:	df000315 	stw	fp,12(sp)
8014494c:	df000304 	addi	fp,sp,12
80144950:	e13ffe15 	stw	r4,-8(fp)
80144954:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
80144958:	e0bfff17 	ldw	r2,-4(fp)
8014495c:	1000021e 	bne	r2,zero,80144968 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
80144960:	00bffa84 	movi	r2,-22
80144964:	00002f06 	br	80144a24 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
80144968:	e0bfff17 	ldw	r2,-4(fp)
8014496c:	10c00317 	ldw	r3,12(r2)
80144970:	e0bfff17 	ldw	r2,-4(fp)
80144974:	18800226 	beq	r3,r2,80144980 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
80144978:	00bffa84 	movi	r2,-22
8014497c:	00002906 	br	80144a24 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
80144980:	e0bffe17 	ldw	r2,-8(fp)
80144984:	10800017 	ldw	r2,0(r2)
80144988:	1000051e 	bne	r2,zero,801449a0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
8014498c:	e0bffe17 	ldw	r2,-8(fp)
80144990:	e0ffff17 	ldw	r3,-4(fp)
80144994:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
80144998:	0005883a 	mov	r2,zero
8014499c:	00002106 	br	80144a24 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
801449a0:	e0bffe17 	ldw	r2,-8(fp)
801449a4:	10c00017 	ldw	r3,0(r2)
801449a8:	e0bfff17 	ldw	r2,-4(fp)
801449ac:	1880021e 	bne	r3,r2,801449b8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
801449b0:	00bffa84 	movi	r2,-22
801449b4:	00001b06 	br	80144a24 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
801449b8:	e0bffe17 	ldw	r2,-8(fp)
801449bc:	10800017 	ldw	r2,0(r2)
801449c0:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
801449c4:	00000906 	br	801449ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
801449c8:	e0bffd17 	ldw	r2,-12(fp)
801449cc:	10c00317 	ldw	r3,12(r2)
801449d0:	e0bfff17 	ldw	r2,-4(fp)
801449d4:	1880021e 	bne	r3,r2,801449e0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
801449d8:	00bffa84 	movi	r2,-22
801449dc:	00001106 	br	80144a24 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
801449e0:	e0bffd17 	ldw	r2,-12(fp)
801449e4:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
801449e8:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
801449ec:	e0bffd17 	ldw	r2,-12(fp)
801449f0:	10800317 	ldw	r2,12(r2)
801449f4:	e0fffe17 	ldw	r3,-8(fp)
801449f8:	18c00017 	ldw	r3,0(r3)
801449fc:	10fff21e 	bne	r2,r3,801449c8 <__reset+0xfa1249c8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
80144a00:	e0ffff17 	ldw	r3,-4(fp)
80144a04:	e0bffd17 	ldw	r2,-12(fp)
80144a08:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
80144a0c:	e0bffe17 	ldw	r2,-8(fp)
80144a10:	10800017 	ldw	r2,0(r2)
80144a14:	1007883a 	mov	r3,r2
80144a18:	e0bfff17 	ldw	r2,-4(fp)
80144a1c:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
80144a20:	0005883a 	mov	r2,zero
}
80144a24:	e037883a 	mov	sp,fp
80144a28:	df000017 	ldw	fp,0(sp)
80144a2c:	dec00104 	addi	sp,sp,4
80144a30:	f800283a 	ret

80144a34 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
80144a34:	defff804 	addi	sp,sp,-32
80144a38:	de00012e 	bgeu	sp,et,80144a40 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
80144a3c:	003b68fa 	trap	3
80144a40:	df000715 	stw	fp,28(sp)
80144a44:	df000704 	addi	fp,sp,28
80144a48:	e13ffe15 	stw	r4,-8(fp)
80144a4c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
80144a50:	e13fff17 	ldw	r4,-4(fp)
80144a54:	2000021e 	bne	r4,zero,80144a60 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
80144a58:	00bffa84 	movi	r2,-22
80144a5c:	00005906 	br	80144bc4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
80144a60:	e13fff17 	ldw	r4,-4(fp)
80144a64:	2015883a 	mov	r10,r4
80144a68:	0017883a 	mov	r11,zero
80144a6c:	e2bffc15 	stw	r10,-16(fp)
80144a70:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
80144a74:	e13fff17 	ldw	r4,-4(fp)
80144a78:	21400317 	ldw	r5,12(r4)
80144a7c:	e13ffc17 	ldw	r4,-16(fp)
80144a80:	29000626 	beq	r5,r4,80144a9c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
80144a84:	e13fff17 	ldw	r4,-4(fp)
80144a88:	21400b17 	ldw	r5,44(r4)
80144a8c:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
80144a90:	29000226 	beq	r5,r4,80144a9c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
80144a94:	00bffa84 	movi	r2,-22
80144a98:	00004a06 	br	80144bc4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
80144a9c:	e13ffe17 	ldw	r4,-8(fp)
80144aa0:	21000017 	ldw	r4,0(r4)
80144aa4:	2000051e 	bne	r4,zero,80144abc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
80144aa8:	e0bffe17 	ldw	r2,-8(fp)
80144aac:	e0ffff17 	ldw	r3,-4(fp)
80144ab0:	10c00015 	stw	r3,0(r2)
		return 0;
80144ab4:	0005883a 	mov	r2,zero
80144ab8:	00004206 	br	80144bc4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
80144abc:	e13ffe17 	ldw	r4,-8(fp)
80144ac0:	21400017 	ldw	r5,0(r4)
80144ac4:	e13fff17 	ldw	r4,-4(fp)
80144ac8:	2900021e 	bne	r5,r4,80144ad4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
80144acc:	00bffa84 	movi	r2,-22
80144ad0:	00003c06 	br	80144bc4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
80144ad4:	e13ffe17 	ldw	r4,-8(fp)
80144ad8:	21000017 	ldw	r4,0(r4)
80144adc:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
80144ae0:	e13ffe17 	ldw	r4,-8(fp)
80144ae4:	21000017 	ldw	r4,0(r4)
80144ae8:	2011883a 	mov	r8,r4
80144aec:	0013883a 	mov	r9,zero
80144af0:	e23ffa15 	stw	r8,-24(fp)
80144af4:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
80144af8:	00001806 	br	80144b5c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
80144afc:	e13fff17 	ldw	r4,-4(fp)
80144b00:	200d883a 	mov	r6,r4
80144b04:	000f883a 	mov	r7,zero
80144b08:	e1bffc15 	stw	r6,-16(fp)
80144b0c:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
80144b10:	e13ff917 	ldw	r4,-28(fp)
80144b14:	21400317 	ldw	r5,12(r4)
80144b18:	e13ffc17 	ldw	r4,-16(fp)
80144b1c:	2900061e 	bne	r5,r4,80144b38 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
80144b20:	e13ff917 	ldw	r4,-28(fp)
80144b24:	21400b17 	ldw	r5,44(r4)
80144b28:	e13ffd17 	ldw	r4,-12(fp)
80144b2c:	2900021e 	bne	r5,r4,80144b38 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
80144b30:	00bffa84 	movi	r2,-22
80144b34:	00002306 	br	80144bc4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
80144b38:	e13ff917 	ldw	r4,-28(fp)
80144b3c:	21000317 	ldw	r4,12(r4)
80144b40:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
80144b44:	e13ff917 	ldw	r4,-28(fp)
80144b48:	21000b17 	ldw	r4,44(r4)
80144b4c:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
80144b50:	e13ffc17 	ldw	r4,-16(fp)
80144b54:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
80144b58:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
80144b5c:	e13ff917 	ldw	r4,-28(fp)
80144b60:	21400317 	ldw	r5,12(r4)
80144b64:	e13ffa17 	ldw	r4,-24(fp)
80144b68:	29000426 	beq	r5,r4,80144b7c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
80144b6c:	e13ff917 	ldw	r4,-28(fp)
80144b70:	21400b17 	ldw	r5,44(r4)
80144b74:	e13ffb17 	ldw	r4,-20(fp)
80144b78:	293fe01e 	bne	r5,r4,80144afc <__reset+0xfa124afc>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
80144b7c:	e13fff17 	ldw	r4,-4(fp)
80144b80:	2005883a 	mov	r2,r4
80144b84:	0007883a 	mov	r3,zero
80144b88:	e0bffc15 	stw	r2,-16(fp)
80144b8c:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
80144b90:	e0fffc17 	ldw	r3,-16(fp)
80144b94:	e0bff917 	ldw	r2,-28(fp)
80144b98:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
80144b9c:	e0fffd17 	ldw	r3,-12(fp)
80144ba0:	e0bff917 	ldw	r2,-28(fp)
80144ba4:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
80144ba8:	e0fffa17 	ldw	r3,-24(fp)
80144bac:	e0bfff17 	ldw	r2,-4(fp)
80144bb0:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
80144bb4:	e0fffb17 	ldw	r3,-20(fp)
80144bb8:	e0bfff17 	ldw	r2,-4(fp)
80144bbc:	10c00b15 	stw	r3,44(r2)
	return 0;
80144bc0:	0005883a 	mov	r2,zero
}
80144bc4:	e037883a 	mov	sp,fp
80144bc8:	df000017 	ldw	fp,0(sp)
80144bcc:	dec00104 	addi	sp,sp,4
80144bd0:	f800283a 	ret

80144bd4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
80144bd4:	defffc04 	addi	sp,sp,-16
80144bd8:	de00012e 	bgeu	sp,et,80144be0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
80144bdc:	003b68fa 	trap	3
80144be0:	df000315 	stw	fp,12(sp)
80144be4:	df000304 	addi	fp,sp,12
80144be8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
80144bec:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
80144bf0:	e0bfff17 	ldw	r2,-4(fp)
80144bf4:	1000021e 	bne	r2,zero,80144c00 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
80144bf8:	00bffa84 	movi	r2,-22
80144bfc:	00001906 	br	80144c64 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
80144c00:	e0bfff17 	ldw	r2,-4(fp)
80144c04:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
80144c08:	00000a06 	br	80144c34 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
80144c0c:	e0bffd17 	ldw	r2,-12(fp)
80144c10:	10800717 	ldw	r2,28(r2)
80144c14:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
80144c18:	e0bffe17 	ldw	r2,-8(fp)
80144c1c:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
80144c20:	e0bffd17 	ldw	r2,-12(fp)
80144c24:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
80144c28:	e0bffd17 	ldw	r2,-12(fp)
80144c2c:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
80144c30:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
80144c34:	e0bffd17 	ldw	r2,-12(fp)
80144c38:	10c00317 	ldw	r3,12(r2)
80144c3c:	e0bfff17 	ldw	r2,-4(fp)
80144c40:	18bff21e 	bne	r3,r2,80144c0c <__reset+0xfa124c0c>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
80144c44:	e0bffd17 	ldw	r2,-12(fp)
80144c48:	10800717 	ldw	r2,28(r2)
80144c4c:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
80144c50:	e0bffe17 	ldw	r2,-8(fp)
80144c54:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
80144c58:	e0bffd17 	ldw	r2,-12(fp)
80144c5c:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
80144c60:	0005883a 	mov	r2,zero
}
80144c64:	e037883a 	mov	sp,fp
80144c68:	df000017 	ldw	fp,0(sp)
80144c6c:	dec00104 	addi	sp,sp,4
80144c70:	f800283a 	ret

80144c74 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
80144c74:	defff804 	addi	sp,sp,-32
80144c78:	de00012e 	bgeu	sp,et,80144c80 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
80144c7c:	003b68fa 	trap	3
80144c80:	df000715 	stw	fp,28(sp)
80144c84:	df000704 	addi	fp,sp,28
80144c88:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
80144c8c:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
80144c90:	e13fff17 	ldw	r4,-4(fp)
80144c94:	2000021e 	bne	r4,zero,80144ca0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
80144c98:	00bffa84 	movi	r2,-22
80144c9c:	00002806 	br	80144d40 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
80144ca0:	e13fff17 	ldw	r4,-4(fp)
80144ca4:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
80144ca8:	e13fff17 	ldw	r4,-4(fp)
80144cac:	2005883a 	mov	r2,r4
80144cb0:	0007883a 	mov	r3,zero
80144cb4:	e0bffb15 	stw	r2,-20(fp)
80144cb8:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
80144cbc:	00001006 	br	80144d00 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
80144cc0:	e0bff917 	ldw	r2,-28(fp)
80144cc4:	10800f17 	ldw	r2,60(r2)
80144cc8:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
80144ccc:	e0bffa17 	ldw	r2,-24(fp)
80144cd0:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
80144cd4:	e0bff917 	ldw	r2,-28(fp)
80144cd8:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
80144cdc:	e0bff917 	ldw	r2,-28(fp)
80144ce0:	10800317 	ldw	r2,12(r2)
80144ce4:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
80144ce8:	e0bff917 	ldw	r2,-28(fp)
80144cec:	10800b17 	ldw	r2,44(r2)
80144cf0:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
80144cf4:	e0bffd17 	ldw	r2,-12(fp)
80144cf8:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
80144cfc:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
80144d00:	e0bff917 	ldw	r2,-28(fp)
80144d04:	10c00317 	ldw	r3,12(r2)
80144d08:	e0bffb17 	ldw	r2,-20(fp)
80144d0c:	18800426 	beq	r3,r2,80144d20 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
80144d10:	e0bff917 	ldw	r2,-28(fp)
80144d14:	10c00b17 	ldw	r3,44(r2)
80144d18:	e0bffc17 	ldw	r2,-16(fp)
80144d1c:	18bfe81e 	bne	r3,r2,80144cc0 <__reset+0xfa124cc0>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
80144d20:	e0bff917 	ldw	r2,-28(fp)
80144d24:	10800f17 	ldw	r2,60(r2)
80144d28:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
80144d2c:	e0bffa17 	ldw	r2,-24(fp)
80144d30:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
80144d34:	e0bff917 	ldw	r2,-28(fp)
80144d38:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
80144d3c:	0005883a 	mov	r2,zero
}
80144d40:	e037883a 	mov	sp,fp
80144d44:	df000017 	ldw	fp,0(sp)
80144d48:	dec00104 	addi	sp,sp,4
80144d4c:	f800283a 	ret

80144d50 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
80144d50:	deffeb04 	addi	sp,sp,-84
80144d54:	de00012e 	bgeu	sp,et,80144d5c <alt_msgdma_start_prefetcher_with_list_addr+0xc>
80144d58:	003b68fa 	trap	3
80144d5c:	dfc01415 	stw	ra,80(sp)
80144d60:	df001315 	stw	fp,76(sp)
80144d64:	df001304 	addi	fp,sp,76
80144d68:	e13ffb15 	stw	r4,-20(fp)
80144d6c:	e17ffc15 	stw	r5,-16(fp)
80144d70:	e1bffd15 	stw	r6,-12(fp)
80144d74:	3807883a 	mov	r3,r7
80144d78:	e0800217 	ldw	r2,8(fp)
80144d7c:	e0fffe05 	stb	r3,-8(fp)
80144d80:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
80144d84:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
80144d88:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
80144d8c:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
80144d90:	e0bffc17 	ldw	r2,-16(fp)
80144d94:	e0bff815 	stw	r2,-32(fp)
80144d98:	e0bffd17 	ldw	r2,-12(fp)
80144d9c:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
80144da0:	e0bffb17 	ldw	r2,-20(fp)
80144da4:	10801817 	ldw	r2,96(r2)
80144da8:	e0bff615 	stw	r2,-40(fp)
80144dac:	e03ff70d 	sth	zero,-36(fp)
80144db0:	e0bff70b 	ldhu	r2,-36(fp)
80144db4:	e0fffa04 	addi	r3,fp,-24
80144db8:	180d883a 	mov	r6,r3
80144dbc:	100b883a 	mov	r5,r2
80144dc0:	e13ff617 	ldw	r4,-40(fp)
80144dc4:	0139efc0 	call	80139efc <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
80144dc8:	e0bffb17 	ldw	r2,-20(fp)
80144dcc:	10800617 	ldw	r2,24(r2)
80144dd0:	10800037 	ldwio	r2,0(r2)
80144dd4:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
80144dd8:	e0bfed17 	ldw	r2,-76(fp)
80144ddc:	1080004c 	andi	r2,r2,1
80144de0:	10000626 	beq	r2,zero,80144dfc <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
80144de4:	e0bffb17 	ldw	r2,-20(fp)
80144de8:	10801817 	ldw	r2,96(r2)
80144dec:	1009883a 	mov	r4,r2
80144df0:	013a2840 	call	8013a284 <OSSemPost>
		return -EBUSY;
80144df4:	00bffc04 	movi	r2,-16
80144df8:	00009606 	br	80145054 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
80144dfc:	00800804 	movi	r2,32
80144e00:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80144e04:	0005303a 	rdctl	r2,status
80144e08:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80144e0c:	e0fff217 	ldw	r3,-56(fp)
80144e10:	00bfff84 	movi	r2,-2
80144e14:	1884703a 	and	r2,r3,r2
80144e18:	1001703a 	wrctl	status,r2
  
  return context;
80144e1c:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
80144e20:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
80144e24:	e0bffb17 	ldw	r2,-20(fp)
80144e28:	10800317 	ldw	r2,12(r2)
80144e2c:	10800104 	addi	r2,r2,4
80144e30:	e0ffee17 	ldw	r3,-72(fp)
80144e34:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
80144e38:	e0bffb17 	ldw	r2,-20(fp)
80144e3c:	10800317 	ldw	r2,12(r2)
80144e40:	e0fffb17 	ldw	r3,-20(fp)
80144e44:	18c00317 	ldw	r3,12(r3)
80144e48:	18c00037 	ldwio	r3,0(r3)
80144e4c:	10c00035 	stwio	r3,0(r2)
80144e50:	e0bfef17 	ldw	r2,-68(fp)
80144e54:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80144e58:	e0bff017 	ldw	r2,-64(fp)
80144e5c:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
80144e60:	e0bffb17 	ldw	r2,-20(fp)
80144e64:	10800b17 	ldw	r2,44(r2)
80144e68:	10002326 	beq	r2,zero,80144ef8 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
80144e6c:	e0bffb17 	ldw	r2,-20(fp)
80144e70:	10c00d17 	ldw	r3,52(r2)
80144e74:	e0bfee17 	ldw	r2,-72(fp)
80144e78:	1884b03a 	or	r2,r3,r2
80144e7c:	10800514 	ori	r2,r2,20
80144e80:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
80144e84:	e0ffee17 	ldw	r3,-72(fp)
80144e88:	00bff7c4 	movi	r2,-33
80144e8c:	1884703a 	and	r2,r3,r2
80144e90:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
80144e94:	e0bfed17 	ldw	r2,-76(fp)
80144e98:	10800214 	ori	r2,r2,8
80144e9c:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80144ea0:	0005303a 	rdctl	r2,status
80144ea4:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80144ea8:	e0fff417 	ldw	r3,-48(fp)
80144eac:	00bfff84 	movi	r2,-2
80144eb0:	1884703a 	and	r2,r3,r2
80144eb4:	1001703a 	wrctl	status,r2
  
  return context;
80144eb8:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
80144ebc:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
80144ec0:	e0bffb17 	ldw	r2,-20(fp)
80144ec4:	10800317 	ldw	r2,12(r2)
80144ec8:	10800104 	addi	r2,r2,4
80144ecc:	e0ffee17 	ldw	r3,-72(fp)
80144ed0:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
80144ed4:	e0bffb17 	ldw	r2,-20(fp)
80144ed8:	10800617 	ldw	r2,24(r2)
80144edc:	e0ffed17 	ldw	r3,-76(fp)
80144ee0:	10c00035 	stwio	r3,0(r2)
80144ee4:	e0bfef17 	ldw	r2,-68(fp)
80144ee8:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80144eec:	e0bff117 	ldw	r2,-60(fp)
80144ef0:	1001703a 	wrctl	status,r2
80144ef4:	00002306 	br	80144f84 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
80144ef8:	e0bffb17 	ldw	r2,-20(fp)
80144efc:	10c00d17 	ldw	r3,52(r2)
80144f00:	e0bfee17 	ldw	r2,-72(fp)
80144f04:	1884b03a 	or	r2,r3,r2
80144f08:	10800114 	ori	r2,r2,4
80144f0c:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
80144f10:	e0ffee17 	ldw	r3,-72(fp)
80144f14:	00bff3c4 	movi	r2,-49
80144f18:	1884703a 	and	r2,r3,r2
80144f1c:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
80144f20:	e0ffed17 	ldw	r3,-76(fp)
80144f24:	00bffdc4 	movi	r2,-9
80144f28:	1884703a 	and	r2,r3,r2
80144f2c:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80144f30:	0005303a 	rdctl	r2,status
80144f34:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80144f38:	e0fff517 	ldw	r3,-44(fp)
80144f3c:	00bfff84 	movi	r2,-2
80144f40:	1884703a 	and	r2,r3,r2
80144f44:	1001703a 	wrctl	status,r2
  
  return context;
80144f48:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
80144f4c:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
80144f50:	e0bffb17 	ldw	r2,-20(fp)
80144f54:	10800317 	ldw	r2,12(r2)
80144f58:	10800104 	addi	r2,r2,4
80144f5c:	e0ffee17 	ldw	r3,-72(fp)
80144f60:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
80144f64:	e0bffb17 	ldw	r2,-20(fp)
80144f68:	10800617 	ldw	r2,24(r2)
80144f6c:	e0ffed17 	ldw	r3,-76(fp)
80144f70:	10c00035 	stwio	r3,0(r2)
80144f74:	e0bfef17 	ldw	r2,-68(fp)
80144f78:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80144f7c:	e0bff317 	ldw	r2,-52(fp)
80144f80:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
80144f84:	e0bffb17 	ldw	r2,-20(fp)
80144f88:	10800617 	ldw	r2,24(r2)
80144f8c:	10800104 	addi	r2,r2,4
80144f90:	e0fff817 	ldw	r3,-32(fp)
80144f94:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
80144f98:	e0bffb17 	ldw	r2,-20(fp)
80144f9c:	10800617 	ldw	r2,24(r2)
80144fa0:	10800204 	addi	r2,r2,8
80144fa4:	e0fff917 	ldw	r3,-28(fp)
80144fa8:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
80144fac:	e0bffe03 	ldbu	r2,-8(fp)
80144fb0:	10000426 	beq	r2,zero,80144fc4 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
80144fb4:	e0bfed17 	ldw	r2,-76(fp)
80144fb8:	10800414 	ori	r2,r2,16
80144fbc:	e0bfed15 	stw	r2,-76(fp)
80144fc0:	00000406 	br	80144fd4 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
80144fc4:	e0ffed17 	ldw	r3,-76(fp)
80144fc8:	00bffbc4 	movi	r2,-17
80144fcc:	1884703a 	and	r2,r3,r2
80144fd0:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
80144fd4:	e0bfff03 	ldbu	r2,-4(fp)
80144fd8:	10000e26 	beq	r2,zero,80145014 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
80144fdc:	e0bfed17 	ldw	r2,-76(fp)
80144fe0:	10800094 	ori	r2,r2,2
80144fe4:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
80144fe8:	e0bffb17 	ldw	r2,-20(fp)
80144fec:	10800617 	ldw	r2,24(r2)
80144ff0:	10800304 	addi	r2,r2,12
80144ff4:	10800037 	ldwio	r2,0(r2)
80144ff8:	10000a1e 	bne	r2,zero,80145024 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
80144ffc:	e0bffb17 	ldw	r2,-20(fp)
80145000:	10800617 	ldw	r2,24(r2)
80145004:	10800304 	addi	r2,r2,12
80145008:	00c03fc4 	movi	r3,255
8014500c:	10c00035 	stwio	r3,0(r2)
80145010:	00000406 	br	80145024 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
80145014:	e0ffed17 	ldw	r3,-76(fp)
80145018:	00bfff44 	movi	r2,-3
8014501c:	1884703a 	and	r2,r3,r2
80145020:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
80145024:	e0bfed17 	ldw	r2,-76(fp)
80145028:	10800054 	ori	r2,r2,1
8014502c:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
80145030:	e0bffb17 	ldw	r2,-20(fp)
80145034:	10800617 	ldw	r2,24(r2)
80145038:	e0ffed17 	ldw	r3,-76(fp)
8014503c:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
80145040:	e0bffb17 	ldw	r2,-20(fp)
80145044:	10801817 	ldw	r2,96(r2)
80145048:	1009883a 	mov	r4,r2
8014504c:	013a2840 	call	8013a284 <OSSemPost>
	 
	 return 0;
80145050:	0005883a 	mov	r2,zero
}
80145054:	e037883a 	mov	sp,fp
80145058:	dfc00117 	ldw	ra,4(sp)
8014505c:	df000017 	ldw	fp,0(sp)
80145060:	dec00204 	addi	sp,sp,8
80145064:	f800283a 	ret

80145068 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
80145068:	defff704 	addi	sp,sp,-36
8014506c:	de00012e 	bgeu	sp,et,80145074 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
80145070:	003b68fa 	trap	3
80145074:	dfc00815 	stw	ra,32(sp)
80145078:	df000715 	stw	fp,28(sp)
8014507c:	dc400615 	stw	r17,24(sp)
80145080:	dc000515 	stw	r16,20(sp)
80145084:	df000704 	addi	fp,sp,28
80145088:	e13ffa15 	stw	r4,-24(fp)
8014508c:	e17ffb15 	stw	r5,-20(fp)
80145090:	3007883a 	mov	r3,r6
80145094:	3805883a 	mov	r2,r7
80145098:	e0fffc05 	stb	r3,-16(fp)
8014509c:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
801450a0:	e13ffb17 	ldw	r4,-20(fp)
801450a4:	0144bd40 	call	80144bd4 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
801450a8:	10000226 	beq	r2,zero,801450b4 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
801450ac:	00bffa84 	movi	r2,-22
801450b0:	00000b06 	br	801450e0 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
801450b4:	e0bffb17 	ldw	r2,-20(fp)
801450b8:	1021883a 	mov	r16,r2
801450bc:	0023883a 	mov	r17,zero
801450c0:	e0fffc03 	ldbu	r3,-16(fp)
801450c4:	e0bffd03 	ldbu	r2,-12(fp)
801450c8:	d8800015 	stw	r2,0(sp)
801450cc:	180f883a 	mov	r7,r3
801450d0:	800b883a 	mov	r5,r16
801450d4:	880d883a 	mov	r6,r17
801450d8:	e13ffa17 	ldw	r4,-24(fp)
801450dc:	0144d500 	call	80144d50 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
801450e0:	e6fffe04 	addi	sp,fp,-8
801450e4:	dfc00317 	ldw	ra,12(sp)
801450e8:	df000217 	ldw	fp,8(sp)
801450ec:	dc400117 	ldw	r17,4(sp)
801450f0:	dc000017 	ldw	r16,0(sp)
801450f4:	dec00404 	addi	sp,sp,16
801450f8:	f800283a 	ret

801450fc <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
801450fc:	defff704 	addi	sp,sp,-36
80145100:	de00012e 	bgeu	sp,et,80145108 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
80145104:	003b68fa 	trap	3
80145108:	dfc00815 	stw	ra,32(sp)
8014510c:	df000715 	stw	fp,28(sp)
80145110:	dc400615 	stw	r17,24(sp)
80145114:	dc000515 	stw	r16,20(sp)
80145118:	df000704 	addi	fp,sp,28
8014511c:	e13ffa15 	stw	r4,-24(fp)
80145120:	e17ffb15 	stw	r5,-20(fp)
80145124:	3007883a 	mov	r3,r6
80145128:	3805883a 	mov	r2,r7
8014512c:	e0fffc05 	stb	r3,-16(fp)
80145130:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
80145134:	e13ffb17 	ldw	r4,-20(fp)
80145138:	0144c740 	call	80144c74 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
8014513c:	10000226 	beq	r2,zero,80145148 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
80145140:	00bffa84 	movi	r2,-22
80145144:	00000b06 	br	80145174 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
80145148:	e0bffb17 	ldw	r2,-20(fp)
8014514c:	1021883a 	mov	r16,r2
80145150:	0023883a 	mov	r17,zero
80145154:	e0fffc03 	ldbu	r3,-16(fp)
80145158:	e0bffd03 	ldbu	r2,-12(fp)
8014515c:	d8800015 	stw	r2,0(sp)
80145160:	180f883a 	mov	r7,r3
80145164:	800b883a 	mov	r5,r16
80145168:	880d883a 	mov	r6,r17
8014516c:	e13ffa17 	ldw	r4,-24(fp)
80145170:	0144d500 	call	80144d50 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
80145174:	e6fffe04 	addi	sp,fp,-8
80145178:	dfc00317 	ldw	ra,12(sp)
8014517c:	df000217 	ldw	fp,8(sp)
80145180:	dc400117 	ldw	r17,4(sp)
80145184:	dc000017 	ldw	r16,0(sp)
80145188:	dec00404 	addi	sp,sp,16
8014518c:	f800283a 	ret

80145190 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
80145190:	defffc04 	addi	sp,sp,-16
80145194:	de00012e 	bgeu	sp,et,8014519c <alt_msgdma_open+0xc>
80145198:	003b68fa 	trap	3
8014519c:	dfc00315 	stw	ra,12(sp)
801451a0:	df000215 	stw	fp,8(sp)
801451a4:	df000204 	addi	fp,sp,8
801451a8:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
801451ac:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
801451b0:	d1603404 	addi	r5,gp,-32560
801451b4:	e13fff17 	ldw	r4,-4(fp)
801451b8:	01457340 	call	80145734 <alt_find_dev>
801451bc:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
801451c0:	e0bffe17 	ldw	r2,-8(fp)
801451c4:	1000041e 	bne	r2,zero,801451d8 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
801451c8:	01433f40 	call	801433f4 <alt_get_errno>
801451cc:	1007883a 	mov	r3,r2
801451d0:	008004c4 	movi	r2,19
801451d4:	18800015 	stw	r2,0(r3)
    }

    return dev;
801451d8:	e0bffe17 	ldw	r2,-8(fp)
}
801451dc:	e037883a 	mov	sp,fp
801451e0:	dfc00117 	ldw	ra,4(sp)
801451e4:	df000017 	ldw	fp,0(sp)
801451e8:	dec00204 	addi	sp,sp,8
801451ec:	f800283a 	ret

801451f0 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
801451f0:	defff604 	addi	sp,sp,-40
801451f4:	de00012e 	bgeu	sp,et,801451fc <alt_msgdma_init+0xc>
801451f8:	003b68fa 	trap	3
801451fc:	dfc00915 	stw	ra,36(sp)
80145200:	df000815 	stw	fp,32(sp)
80145204:	df000804 	addi	fp,sp,32
80145208:	e13ffd15 	stw	r4,-12(fp)
8014520c:	e17ffe15 	stw	r5,-8(fp)
80145210:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
80145214:	e0bffd17 	ldw	r2,-12(fp)
80145218:	10801783 	ldbu	r2,94(r2)
8014521c:	10803fcc 	andi	r2,r2,255
80145220:	10000b26 	beq	r2,zero,80145250 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
80145224:	e0bffd17 	ldw	r2,-12(fp)
80145228:	10800617 	ldw	r2,24(r2)
8014522c:	00c00104 	movi	r3,4
80145230:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
80145234:	0001883a 	nop
80145238:	e0bffd17 	ldw	r2,-12(fp)
8014523c:	10800617 	ldw	r2,24(r2)
80145240:	10800037 	ldwio	r2,0(r2)
80145244:	1080010c 	andi	r2,r2,4
80145248:	1005d0ba 	srai	r2,r2,2
8014524c:	103ffa1e 	bne	r2,zero,80145238 <__reset+0xfa125238>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
80145250:	e0bffd17 	ldw	r2,-12(fp)
80145254:	10800317 	ldw	r2,12(r2)
80145258:	10800104 	addi	r2,r2,4
8014525c:	00c00084 	movi	r3,2
80145260:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
80145264:	0001883a 	nop
80145268:	e0bffd17 	ldw	r2,-12(fp)
8014526c:	10800317 	ldw	r2,12(r2)
80145270:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
80145274:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
80145278:	103ffb1e 	bne	r2,zero,80145268 <__reset+0xfa125268>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8014527c:	e0bffd17 	ldw	r2,-12(fp)
80145280:	10800317 	ldw	r2,12(r2)
80145284:	10800104 	addi	r2,r2,4
80145288:	10800037 	ldwio	r2,0(r2)
8014528c:	1007883a 	mov	r3,r2
80145290:	00bffbc4 	movi	r2,-17
80145294:	1884703a 	and	r2,r3,r2
80145298:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8014529c:	e0bff917 	ldw	r2,-28(fp)
801452a0:	10800814 	ori	r2,r2,32
801452a4:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
801452a8:	e0bffd17 	ldw	r2,-12(fp)
801452ac:	10800317 	ldw	r2,12(r2)
801452b0:	10800104 	addi	r2,r2,4
801452b4:	e0fff917 	ldw	r3,-28(fp)
801452b8:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
801452bc:	e0bffd17 	ldw	r2,-12(fp)
801452c0:	10800317 	ldw	r2,12(r2)
801452c4:	e0fffd17 	ldw	r3,-12(fp)
801452c8:	18c00317 	ldw	r3,12(r3)
801452cc:	18c00037 	ldwio	r3,0(r3)
801452d0:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
801452d4:	e0bffd17 	ldw	r2,-12(fp)
801452d8:	10801783 	ldbu	r2,94(r2)
801452dc:	10803fcc 	andi	r2,r2,255
801452e0:	10000826 	beq	r2,zero,80145304 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
801452e4:	e0bffd17 	ldw	r2,-12(fp)
801452e8:	10800617 	ldw	r2,24(r2)
801452ec:	10800404 	addi	r2,r2,16
801452f0:	e0fffd17 	ldw	r3,-12(fp)
801452f4:	18c00617 	ldw	r3,24(r3)
801452f8:	18c00404 	addi	r3,r3,16
801452fc:	18c00037 	ldwio	r3,0(r3)
80145300:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
80145304:	d1603404 	addi	r5,gp,-32560
80145308:	e13ffd17 	ldw	r4,-12(fp)
8014530c:	01456880 	call	80145688 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
80145310:	e0bffd17 	ldw	r2,-12(fp)
80145314:	10801804 	addi	r2,r2,96
80145318:	e0bffb15 	stw	r2,-20(fp)
8014531c:	00800044 	movi	r2,1
80145320:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
80145324:	e0bffc0b 	ldhu	r2,-16(fp)
80145328:	1009883a 	mov	r4,r2
8014532c:	0139bd40 	call	80139bd4 <OSSemCreate>
80145330:	1007883a 	mov	r3,r2
80145334:	e0bffb17 	ldw	r2,-20(fp)
80145338:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8014533c:	e0bffb17 	ldw	r2,-20(fp)
80145340:	10800017 	ldw	r2,0(r2)
80145344:	10000226 	beq	r2,zero,80145350 <alt_msgdma_init+0x160>
80145348:	0005883a 	mov	r2,zero
8014534c:	00000106 	br	80145354 <alt_msgdma_init+0x164>
80145350:	00bfffc4 	movi	r2,-1
80145354:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
80145358:	e0bffa17 	ldw	r2,-24(fp)
8014535c:	1000081e 	bne	r2,zero,80145380 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
80145360:	d8000015 	stw	zero,0(sp)
80145364:	e1fffd17 	ldw	r7,-12(fp)
80145368:	01a00534 	movhi	r6,32788
8014536c:	318d8204 	addi	r6,r6,13832
80145370:	e17fff17 	ldw	r5,-4(fp)
80145374:	e13ffe17 	ldw	r4,-8(fp)
80145378:	01457cc0 	call	801457cc <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
8014537c:	00000406 	br	80145390 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
80145380:	01200574 	movhi	r4,32789
80145384:	21210004 	addi	r4,r4,-31744
80145388:	0145e500 	call	80145e50 <alt_printf>
    }
    
    return;
8014538c:	0001883a 	nop

}
80145390:	e037883a 	mov	sp,fp
80145394:	dfc00117 	ldw	ra,4(sp)
80145398:	df000017 	ldw	fp,0(sp)
8014539c:	dec00204 	addi	sp,sp,8
801453a0:	f800283a 	ret

801453a4 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
801453a4:	defffb04 	addi	sp,sp,-20
801453a8:	de00012e 	bgeu	sp,et,801453b0 <alt_msgdma_register_callback+0xc>
801453ac:	003b68fa 	trap	3
801453b0:	df000415 	stw	fp,16(sp)
801453b4:	df000404 	addi	fp,sp,16
801453b8:	e13ffc15 	stw	r4,-16(fp)
801453bc:	e17ffd15 	stw	r5,-12(fp)
801453c0:	e1bffe15 	stw	r6,-8(fp)
801453c4:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
801453c8:	e0bffc17 	ldw	r2,-16(fp)
801453cc:	e0fffd17 	ldw	r3,-12(fp)
801453d0:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
801453d4:	e0bffc17 	ldw	r2,-16(fp)
801453d8:	e0ffff17 	ldw	r3,-4(fp)
801453dc:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
801453e0:	e0bffc17 	ldw	r2,-16(fp)
801453e4:	e0fffe17 	ldw	r3,-8(fp)
801453e8:	10c00d15 	stw	r3,52(r2)

    return ;
801453ec:	0001883a 	nop
}
801453f0:	e037883a 	mov	sp,fp
801453f4:	df000017 	ldw	fp,0(sp)
801453f8:	dec00104 	addi	sp,sp,4
801453fc:	f800283a 	ret

80145400 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
80145400:	defffc04 	addi	sp,sp,-16
80145404:	de00012e 	bgeu	sp,et,8014540c <alt_msgdma_standard_descriptor_async_transfer+0xc>
80145408:	003b68fa 	trap	3
8014540c:	dfc00315 	stw	ra,12(sp)
80145410:	df000215 	stw	fp,8(sp)
80145414:	df000204 	addi	fp,sp,8
80145418:	e13ffe15 	stw	r4,-8(fp)
8014541c:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
80145420:	000d883a 	mov	r6,zero
80145424:	e17fff17 	ldw	r5,-4(fp)
80145428:	e13ffe17 	ldw	r4,-8(fp)
8014542c:	01439840 	call	80143984 <alt_msgdma_descriptor_async_transfer>

}
80145430:	e037883a 	mov	sp,fp
80145434:	dfc00117 	ldw	ra,4(sp)
80145438:	df000017 	ldw	fp,0(sp)
8014543c:	dec00204 	addi	sp,sp,8
80145440:	f800283a 	ret

80145444 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
80145444:	defffc04 	addi	sp,sp,-16
80145448:	de00012e 	bgeu	sp,et,80145450 <alt_msgdma_extended_descriptor_async_transfer+0xc>
8014544c:	003b68fa 	trap	3
80145450:	dfc00315 	stw	ra,12(sp)
80145454:	df000215 	stw	fp,8(sp)
80145458:	df000204 	addi	fp,sp,8
8014545c:	e13ffe15 	stw	r4,-8(fp)
80145460:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
80145464:	e1bfff17 	ldw	r6,-4(fp)
80145468:	000b883a 	mov	r5,zero
8014546c:	e13ffe17 	ldw	r4,-8(fp)
80145470:	01439840 	call	80143984 <alt_msgdma_descriptor_async_transfer>
}
80145474:	e037883a 	mov	sp,fp
80145478:	dfc00117 	ldw	ra,4(sp)
8014547c:	df000017 	ldw	fp,0(sp)
80145480:	dec00204 	addi	sp,sp,8
80145484:	f800283a 	ret

80145488 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
80145488:	defffc04 	addi	sp,sp,-16
8014548c:	de00012e 	bgeu	sp,et,80145494 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
80145490:	003b68fa 	trap	3
80145494:	dfc00315 	stw	ra,12(sp)
80145498:	df000215 	stw	fp,8(sp)
8014549c:	df000204 	addi	fp,sp,8
801454a0:	e13ffe15 	stw	r4,-8(fp)
801454a4:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
801454a8:	000d883a 	mov	r6,zero
801454ac:	e17fff17 	ldw	r5,-4(fp)
801454b0:	e13ffe17 	ldw	r4,-8(fp)
801454b4:	0143cc40 	call	80143cc4 <alt_msgdma_descriptor_sync_transfer>
}
801454b8:	e037883a 	mov	sp,fp
801454bc:	dfc00117 	ldw	ra,4(sp)
801454c0:	df000017 	ldw	fp,0(sp)
801454c4:	dec00204 	addi	sp,sp,8
801454c8:	f800283a 	ret

801454cc <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
801454cc:	defffc04 	addi	sp,sp,-16
801454d0:	de00012e 	bgeu	sp,et,801454d8 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
801454d4:	003b68fa 	trap	3
801454d8:	dfc00315 	stw	ra,12(sp)
801454dc:	df000215 	stw	fp,8(sp)
801454e0:	df000204 	addi	fp,sp,8
801454e4:	e13ffe15 	stw	r4,-8(fp)
801454e8:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
801454ec:	e1bfff17 	ldw	r6,-4(fp)
801454f0:	000b883a 	mov	r5,zero
801454f4:	e13ffe17 	ldw	r4,-8(fp)
801454f8:	0143cc40 	call	80143cc4 <alt_msgdma_descriptor_sync_transfer>
}
801454fc:	e037883a 	mov	sp,fp
80145500:	dfc00117 	ldw	ra,4(sp)
80145504:	df000017 	ldw	fp,0(sp)
80145508:	dec00204 	addi	sp,sp,8
8014550c:	f800283a 	ret

80145510 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
80145510:	defff504 	addi	sp,sp,-44
80145514:	de00012e 	bgeu	sp,et,8014551c <alt_alarm_start+0xc>
80145518:	003b68fa 	trap	3
8014551c:	df000a15 	stw	fp,40(sp)
80145520:	df000a04 	addi	fp,sp,40
80145524:	e13ffc15 	stw	r4,-16(fp)
80145528:	e17ffd15 	stw	r5,-12(fp)
8014552c:	e1bffe15 	stw	r6,-8(fp)
80145530:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
80145534:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
80145538:	d0a09117 	ldw	r2,-32188(gp)
  
  if (alt_ticks_per_second ())
8014553c:	10003c26 	beq	r2,zero,80145630 <alt_alarm_start+0x120>
  {
    if (alarm)
80145540:	e0bffc17 	ldw	r2,-16(fp)
80145544:	10003826 	beq	r2,zero,80145628 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
80145548:	e0bffc17 	ldw	r2,-16(fp)
8014554c:	e0fffe17 	ldw	r3,-8(fp)
80145550:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
80145554:	e0bffc17 	ldw	r2,-16(fp)
80145558:	e0ffff17 	ldw	r3,-4(fp)
8014555c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80145560:	0005303a 	rdctl	r2,status
80145564:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80145568:	e0fff917 	ldw	r3,-28(fp)
8014556c:	00bfff84 	movi	r2,-2
80145570:	1884703a 	and	r2,r3,r2
80145574:	1001703a 	wrctl	status,r2
  
  return context;
80145578:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
8014557c:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
80145580:	d0a09217 	ldw	r2,-32184(gp)
      
      current_nticks = alt_nticks();
80145584:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
80145588:	e0fffd17 	ldw	r3,-12(fp)
8014558c:	e0bff617 	ldw	r2,-40(fp)
80145590:	1885883a 	add	r2,r3,r2
80145594:	10c00044 	addi	r3,r2,1
80145598:	e0bffc17 	ldw	r2,-16(fp)
8014559c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
801455a0:	e0bffc17 	ldw	r2,-16(fp)
801455a4:	10c00217 	ldw	r3,8(r2)
801455a8:	e0bff617 	ldw	r2,-40(fp)
801455ac:	1880042e 	bgeu	r3,r2,801455c0 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
801455b0:	e0bffc17 	ldw	r2,-16(fp)
801455b4:	00c00044 	movi	r3,1
801455b8:	10c00405 	stb	r3,16(r2)
801455bc:	00000206 	br	801455c8 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
801455c0:	e0bffc17 	ldw	r2,-16(fp)
801455c4:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
801455c8:	e0bffc17 	ldw	r2,-16(fp)
801455cc:	d0e01304 	addi	r3,gp,-32692
801455d0:	e0fffa15 	stw	r3,-24(fp)
801455d4:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
801455d8:	e0bffb17 	ldw	r2,-20(fp)
801455dc:	e0fffa17 	ldw	r3,-24(fp)
801455e0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
801455e4:	e0bffa17 	ldw	r2,-24(fp)
801455e8:	10c00017 	ldw	r3,0(r2)
801455ec:	e0bffb17 	ldw	r2,-20(fp)
801455f0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
801455f4:	e0bffa17 	ldw	r2,-24(fp)
801455f8:	10800017 	ldw	r2,0(r2)
801455fc:	e0fffb17 	ldw	r3,-20(fp)
80145600:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
80145604:	e0bffa17 	ldw	r2,-24(fp)
80145608:	e0fffb17 	ldw	r3,-20(fp)
8014560c:	10c00015 	stw	r3,0(r2)
80145610:	e0bff817 	ldw	r2,-32(fp)
80145614:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80145618:	e0bff717 	ldw	r2,-36(fp)
8014561c:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
80145620:	0005883a 	mov	r2,zero
80145624:	00000306 	br	80145634 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
80145628:	00bffa84 	movi	r2,-22
8014562c:	00000106 	br	80145634 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
80145630:	00bfde84 	movi	r2,-134
  }
}
80145634:	e037883a 	mov	sp,fp
80145638:	df000017 	ldw	fp,0(sp)
8014563c:	dec00104 	addi	sp,sp,4
80145640:	f800283a 	ret

80145644 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80145644:	defffe04 	addi	sp,sp,-8
80145648:	de00012e 	bgeu	sp,et,80145650 <alt_get_errno+0xc>
8014564c:	003b68fa 	trap	3
80145650:	dfc00115 	stw	ra,4(sp)
80145654:	df000015 	stw	fp,0(sp)
80145658:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8014565c:	d0a00f17 	ldw	r2,-32708(gp)
80145660:	10000326 	beq	r2,zero,80145670 <alt_get_errno+0x2c>
80145664:	d0a00f17 	ldw	r2,-32708(gp)
80145668:	103ee83a 	callr	r2
8014566c:	00000106 	br	80145674 <alt_get_errno+0x30>
80145670:	d0a08704 	addi	r2,gp,-32228
}
80145674:	e037883a 	mov	sp,fp
80145678:	dfc00117 	ldw	ra,4(sp)
8014567c:	df000017 	ldw	fp,0(sp)
80145680:	dec00204 	addi	sp,sp,8
80145684:	f800283a 	ret

80145688 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
80145688:	defffa04 	addi	sp,sp,-24
8014568c:	de00012e 	bgeu	sp,et,80145694 <alt_dev_llist_insert+0xc>
80145690:	003b68fa 	trap	3
80145694:	dfc00515 	stw	ra,20(sp)
80145698:	df000415 	stw	fp,16(sp)
8014569c:	df000404 	addi	fp,sp,16
801456a0:	e13ffe15 	stw	r4,-8(fp)
801456a4:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
801456a8:	e0bffe17 	ldw	r2,-8(fp)
801456ac:	10000326 	beq	r2,zero,801456bc <alt_dev_llist_insert+0x34>
801456b0:	e0bffe17 	ldw	r2,-8(fp)
801456b4:	10800217 	ldw	r2,8(r2)
801456b8:	1000061e 	bne	r2,zero,801456d4 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
801456bc:	01456440 	call	80145644 <alt_get_errno>
801456c0:	1007883a 	mov	r3,r2
801456c4:	00800584 	movi	r2,22
801456c8:	18800015 	stw	r2,0(r3)
    return -EINVAL;
801456cc:	00bffa84 	movi	r2,-22
801456d0:	00001306 	br	80145720 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
801456d4:	e0bffe17 	ldw	r2,-8(fp)
801456d8:	e0ffff17 	ldw	r3,-4(fp)
801456dc:	e0fffc15 	stw	r3,-16(fp)
801456e0:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
801456e4:	e0bffd17 	ldw	r2,-12(fp)
801456e8:	e0fffc17 	ldw	r3,-16(fp)
801456ec:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
801456f0:	e0bffc17 	ldw	r2,-16(fp)
801456f4:	10c00017 	ldw	r3,0(r2)
801456f8:	e0bffd17 	ldw	r2,-12(fp)
801456fc:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
80145700:	e0bffc17 	ldw	r2,-16(fp)
80145704:	10800017 	ldw	r2,0(r2)
80145708:	e0fffd17 	ldw	r3,-12(fp)
8014570c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
80145710:	e0bffc17 	ldw	r2,-16(fp)
80145714:	e0fffd17 	ldw	r3,-12(fp)
80145718:	10c00015 	stw	r3,0(r2)

  return 0;  
8014571c:	0005883a 	mov	r2,zero
}
80145720:	e037883a 	mov	sp,fp
80145724:	dfc00117 	ldw	ra,4(sp)
80145728:	df000017 	ldw	fp,0(sp)
8014572c:	dec00204 	addi	sp,sp,8
80145730:	f800283a 	ret

80145734 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
80145734:	defffa04 	addi	sp,sp,-24
80145738:	de00012e 	bgeu	sp,et,80145740 <alt_find_dev+0xc>
8014573c:	003b68fa 	trap	3
80145740:	dfc00515 	stw	ra,20(sp)
80145744:	df000415 	stw	fp,16(sp)
80145748:	df000404 	addi	fp,sp,16
8014574c:	e13ffe15 	stw	r4,-8(fp)
80145750:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
80145754:	e0bfff17 	ldw	r2,-4(fp)
80145758:	10800017 	ldw	r2,0(r2)
8014575c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
80145760:	e13ffe17 	ldw	r4,-8(fp)
80145764:	01219540 	call	80121954 <strlen>
80145768:	10800044 	addi	r2,r2,1
8014576c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
80145770:	00000d06 	br	801457a8 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
80145774:	e0bffc17 	ldw	r2,-16(fp)
80145778:	10800217 	ldw	r2,8(r2)
8014577c:	e0fffd17 	ldw	r3,-12(fp)
80145780:	180d883a 	mov	r6,r3
80145784:	e17ffe17 	ldw	r5,-8(fp)
80145788:	1009883a 	mov	r4,r2
8014578c:	01467b40 	call	801467b4 <memcmp>
80145790:	1000021e 	bne	r2,zero,8014579c <alt_find_dev+0x68>
    {
      /* match found */

      return next;
80145794:	e0bffc17 	ldw	r2,-16(fp)
80145798:	00000706 	br	801457b8 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
8014579c:	e0bffc17 	ldw	r2,-16(fp)
801457a0:	10800017 	ldw	r2,0(r2)
801457a4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
801457a8:	e0fffc17 	ldw	r3,-16(fp)
801457ac:	e0bfff17 	ldw	r2,-4(fp)
801457b0:	18bff01e 	bne	r3,r2,80145774 <__reset+0xfa125774>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
801457b4:	0005883a 	mov	r2,zero
}
801457b8:	e037883a 	mov	sp,fp
801457bc:	dfc00117 	ldw	ra,4(sp)
801457c0:	df000017 	ldw	fp,0(sp)
801457c4:	dec00204 	addi	sp,sp,8
801457c8:	f800283a 	ret

801457cc <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
801457cc:	defff904 	addi	sp,sp,-28
801457d0:	de00012e 	bgeu	sp,et,801457d8 <alt_ic_isr_register+0xc>
801457d4:	003b68fa 	trap	3
801457d8:	dfc00615 	stw	ra,24(sp)
801457dc:	df000515 	stw	fp,20(sp)
801457e0:	df000504 	addi	fp,sp,20
801457e4:	e13ffc15 	stw	r4,-16(fp)
801457e8:	e17ffd15 	stw	r5,-12(fp)
801457ec:	e1bffe15 	stw	r6,-8(fp)
801457f0:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
801457f4:	e0800217 	ldw	r2,8(fp)
801457f8:	d8800015 	stw	r2,0(sp)
801457fc:	e1ffff17 	ldw	r7,-4(fp)
80145800:	e1bffe17 	ldw	r6,-8(fp)
80145804:	e17ffd17 	ldw	r5,-12(fp)
80145808:	e13ffc17 	ldw	r4,-16(fp)
8014580c:	014599c0 	call	8014599c <alt_iic_isr_register>
}  
80145810:	e037883a 	mov	sp,fp
80145814:	dfc00117 	ldw	ra,4(sp)
80145818:	df000017 	ldw	fp,0(sp)
8014581c:	dec00204 	addi	sp,sp,8
80145820:	f800283a 	ret

80145824 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
80145824:	defff904 	addi	sp,sp,-28
80145828:	de00012e 	bgeu	sp,et,80145830 <alt_ic_irq_enable+0xc>
8014582c:	003b68fa 	trap	3
80145830:	df000615 	stw	fp,24(sp)
80145834:	df000604 	addi	fp,sp,24
80145838:	e13ffe15 	stw	r4,-8(fp)
8014583c:	e17fff15 	stw	r5,-4(fp)
80145840:	e0bfff17 	ldw	r2,-4(fp)
80145844:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
80145848:	0005303a 	rdctl	r2,status
8014584c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
80145850:	e0fffb17 	ldw	r3,-20(fp)
80145854:	00bfff84 	movi	r2,-2
80145858:	1884703a 	and	r2,r3,r2
8014585c:	1001703a 	wrctl	status,r2
  
  return context;
80145860:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
80145864:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
80145868:	00c00044 	movi	r3,1
8014586c:	e0bffa17 	ldw	r2,-24(fp)
80145870:	1884983a 	sll	r2,r3,r2
80145874:	1007883a 	mov	r3,r2
80145878:	d0a08917 	ldw	r2,-32220(gp)
8014587c:	1884b03a 	or	r2,r3,r2
80145880:	d0a08915 	stw	r2,-32220(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
80145884:	d0a08917 	ldw	r2,-32220(gp)
80145888:	100170fa 	wrctl	ienable,r2
8014588c:	e0bffc17 	ldw	r2,-16(fp)
80145890:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80145894:	e0bffd17 	ldw	r2,-12(fp)
80145898:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8014589c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
801458a0:	0001883a 	nop
}
801458a4:	e037883a 	mov	sp,fp
801458a8:	df000017 	ldw	fp,0(sp)
801458ac:	dec00104 	addi	sp,sp,4
801458b0:	f800283a 	ret

801458b4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
801458b4:	defff904 	addi	sp,sp,-28
801458b8:	de00012e 	bgeu	sp,et,801458c0 <alt_ic_irq_disable+0xc>
801458bc:	003b68fa 	trap	3
801458c0:	df000615 	stw	fp,24(sp)
801458c4:	df000604 	addi	fp,sp,24
801458c8:	e13ffe15 	stw	r4,-8(fp)
801458cc:	e17fff15 	stw	r5,-4(fp)
801458d0:	e0bfff17 	ldw	r2,-4(fp)
801458d4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801458d8:	0005303a 	rdctl	r2,status
801458dc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801458e0:	e0fffb17 	ldw	r3,-20(fp)
801458e4:	00bfff84 	movi	r2,-2
801458e8:	1884703a 	and	r2,r3,r2
801458ec:	1001703a 	wrctl	status,r2
  
  return context;
801458f0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
801458f4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
801458f8:	00c00044 	movi	r3,1
801458fc:	e0bffa17 	ldw	r2,-24(fp)
80145900:	1884983a 	sll	r2,r3,r2
80145904:	0084303a 	nor	r2,zero,r2
80145908:	1007883a 	mov	r3,r2
8014590c:	d0a08917 	ldw	r2,-32220(gp)
80145910:	1884703a 	and	r2,r3,r2
80145914:	d0a08915 	stw	r2,-32220(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
80145918:	d0a08917 	ldw	r2,-32220(gp)
8014591c:	100170fa 	wrctl	ienable,r2
80145920:	e0bffc17 	ldw	r2,-16(fp)
80145924:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80145928:	e0bffd17 	ldw	r2,-12(fp)
8014592c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
80145930:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
80145934:	0001883a 	nop
}
80145938:	e037883a 	mov	sp,fp
8014593c:	df000017 	ldw	fp,0(sp)
80145940:	dec00104 	addi	sp,sp,4
80145944:	f800283a 	ret

80145948 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
80145948:	defffc04 	addi	sp,sp,-16
8014594c:	de00012e 	bgeu	sp,et,80145954 <alt_ic_irq_enabled+0xc>
80145950:	003b68fa 	trap	3
80145954:	df000315 	stw	fp,12(sp)
80145958:	df000304 	addi	fp,sp,12
8014595c:	e13ffe15 	stw	r4,-8(fp)
80145960:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
80145964:	000530fa 	rdctl	r2,ienable
80145968:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8014596c:	00c00044 	movi	r3,1
80145970:	e0bfff17 	ldw	r2,-4(fp)
80145974:	1884983a 	sll	r2,r3,r2
80145978:	1007883a 	mov	r3,r2
8014597c:	e0bffd17 	ldw	r2,-12(fp)
80145980:	1884703a 	and	r2,r3,r2
80145984:	1004c03a 	cmpne	r2,r2,zero
80145988:	10803fcc 	andi	r2,r2,255
}
8014598c:	e037883a 	mov	sp,fp
80145990:	df000017 	ldw	fp,0(sp)
80145994:	dec00104 	addi	sp,sp,4
80145998:	f800283a 	ret

8014599c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8014599c:	defff504 	addi	sp,sp,-44
801459a0:	de00012e 	bgeu	sp,et,801459a8 <alt_iic_isr_register+0xc>
801459a4:	003b68fa 	trap	3
801459a8:	dfc00a15 	stw	ra,40(sp)
801459ac:	df000915 	stw	fp,36(sp)
801459b0:	df000904 	addi	fp,sp,36
801459b4:	e13ffc15 	stw	r4,-16(fp)
801459b8:	e17ffd15 	stw	r5,-12(fp)
801459bc:	e1bffe15 	stw	r6,-8(fp)
801459c0:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
801459c4:	00bffa84 	movi	r2,-22
801459c8:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
801459cc:	e0bffd17 	ldw	r2,-12(fp)
801459d0:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
801459d4:	e0bff817 	ldw	r2,-32(fp)
801459d8:	10800808 	cmpgei	r2,r2,32
801459dc:	1000271e 	bne	r2,zero,80145a7c <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
801459e0:	0005303a 	rdctl	r2,status
801459e4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
801459e8:	e0fffb17 	ldw	r3,-20(fp)
801459ec:	00bfff84 	movi	r2,-2
801459f0:	1884703a 	and	r2,r3,r2
801459f4:	1001703a 	wrctl	status,r2
  
  return context;
801459f8:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
801459fc:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
80145a00:	00a005b4 	movhi	r2,32790
80145a04:	1093d004 	addi	r2,r2,20288
80145a08:	e0fff817 	ldw	r3,-32(fp)
80145a0c:	180690fa 	slli	r3,r3,3
80145a10:	10c5883a 	add	r2,r2,r3
80145a14:	e0fffe17 	ldw	r3,-8(fp)
80145a18:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
80145a1c:	00a005b4 	movhi	r2,32790
80145a20:	1093d004 	addi	r2,r2,20288
80145a24:	e0fff817 	ldw	r3,-32(fp)
80145a28:	180690fa 	slli	r3,r3,3
80145a2c:	10c5883a 	add	r2,r2,r3
80145a30:	10800104 	addi	r2,r2,4
80145a34:	e0ffff17 	ldw	r3,-4(fp)
80145a38:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
80145a3c:	e0bffe17 	ldw	r2,-8(fp)
80145a40:	10000526 	beq	r2,zero,80145a58 <alt_iic_isr_register+0xbc>
80145a44:	e0bff817 	ldw	r2,-32(fp)
80145a48:	100b883a 	mov	r5,r2
80145a4c:	e13ffc17 	ldw	r4,-16(fp)
80145a50:	01458240 	call	80145824 <alt_ic_irq_enable>
80145a54:	00000406 	br	80145a68 <alt_iic_isr_register+0xcc>
80145a58:	e0bff817 	ldw	r2,-32(fp)
80145a5c:	100b883a 	mov	r5,r2
80145a60:	e13ffc17 	ldw	r4,-16(fp)
80145a64:	01458b40 	call	801458b4 <alt_ic_irq_disable>
80145a68:	e0bff715 	stw	r2,-36(fp)
80145a6c:	e0bffa17 	ldw	r2,-24(fp)
80145a70:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
80145a74:	e0bff917 	ldw	r2,-28(fp)
80145a78:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
80145a7c:	e0bff717 	ldw	r2,-36(fp)
}
80145a80:	e037883a 	mov	sp,fp
80145a84:	dfc00117 	ldw	ra,4(sp)
80145a88:	df000017 	ldw	fp,0(sp)
80145a8c:	dec00204 	addi	sp,sp,8
80145a90:	f800283a 	ret

80145a94 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
80145a94:	defff904 	addi	sp,sp,-28
80145a98:	de00012e 	bgeu	sp,et,80145aa0 <alt_open_fd+0xc>
80145a9c:	003b68fa 	trap	3
80145aa0:	dfc00615 	stw	ra,24(sp)
80145aa4:	df000515 	stw	fp,20(sp)
80145aa8:	df000504 	addi	fp,sp,20
80145aac:	e13ffc15 	stw	r4,-16(fp)
80145ab0:	e17ffd15 	stw	r5,-12(fp)
80145ab4:	e1bffe15 	stw	r6,-8(fp)
80145ab8:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
80145abc:	e1bfff17 	ldw	r6,-4(fp)
80145ac0:	e17ffe17 	ldw	r5,-8(fp)
80145ac4:	e13ffd17 	ldw	r4,-12(fp)
80145ac8:	0145cf40 	call	80145cf4 <open>
80145acc:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
80145ad0:	e0bffb17 	ldw	r2,-20(fp)
80145ad4:	10001c16 	blt	r2,zero,80145b48 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
80145ad8:	00a00574 	movhi	r2,32789
80145adc:	10a36f04 	addi	r2,r2,-29252
80145ae0:	e0fffb17 	ldw	r3,-20(fp)
80145ae4:	18c00324 	muli	r3,r3,12
80145ae8:	10c5883a 	add	r2,r2,r3
80145aec:	10c00017 	ldw	r3,0(r2)
80145af0:	e0bffc17 	ldw	r2,-16(fp)
80145af4:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
80145af8:	00a00574 	movhi	r2,32789
80145afc:	10a36f04 	addi	r2,r2,-29252
80145b00:	e0fffb17 	ldw	r3,-20(fp)
80145b04:	18c00324 	muli	r3,r3,12
80145b08:	10c5883a 	add	r2,r2,r3
80145b0c:	10800104 	addi	r2,r2,4
80145b10:	10c00017 	ldw	r3,0(r2)
80145b14:	e0bffc17 	ldw	r2,-16(fp)
80145b18:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
80145b1c:	00a00574 	movhi	r2,32789
80145b20:	10a36f04 	addi	r2,r2,-29252
80145b24:	e0fffb17 	ldw	r3,-20(fp)
80145b28:	18c00324 	muli	r3,r3,12
80145b2c:	10c5883a 	add	r2,r2,r3
80145b30:	10800204 	addi	r2,r2,8
80145b34:	10c00017 	ldw	r3,0(r2)
80145b38:	e0bffc17 	ldw	r2,-16(fp)
80145b3c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
80145b40:	e13ffb17 	ldw	r4,-20(fp)
80145b44:	0132ddc0 	call	80132ddc <alt_release_fd>
  }
} 
80145b48:	0001883a 	nop
80145b4c:	e037883a 	mov	sp,fp
80145b50:	dfc00117 	ldw	ra,4(sp)
80145b54:	df000017 	ldw	fp,0(sp)
80145b58:	dec00204 	addi	sp,sp,8
80145b5c:	f800283a 	ret

80145b60 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
80145b60:	defffb04 	addi	sp,sp,-20
80145b64:	de00012e 	bgeu	sp,et,80145b6c <alt_io_redirect+0xc>
80145b68:	003b68fa 	trap	3
80145b6c:	dfc00415 	stw	ra,16(sp)
80145b70:	df000315 	stw	fp,12(sp)
80145b74:	df000304 	addi	fp,sp,12
80145b78:	e13ffd15 	stw	r4,-12(fp)
80145b7c:	e17ffe15 	stw	r5,-8(fp)
80145b80:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
80145b84:	01c07fc4 	movi	r7,511
80145b88:	01800044 	movi	r6,1
80145b8c:	e17ffd17 	ldw	r5,-12(fp)
80145b90:	01200574 	movhi	r4,32789
80145b94:	21237204 	addi	r4,r4,-29240
80145b98:	0145a940 	call	80145a94 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
80145b9c:	01c07fc4 	movi	r7,511
80145ba0:	000d883a 	mov	r6,zero
80145ba4:	e17ffe17 	ldw	r5,-8(fp)
80145ba8:	01200574 	movhi	r4,32789
80145bac:	21236f04 	addi	r4,r4,-29252
80145bb0:	0145a940 	call	80145a94 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
80145bb4:	01c07fc4 	movi	r7,511
80145bb8:	01800044 	movi	r6,1
80145bbc:	e17fff17 	ldw	r5,-4(fp)
80145bc0:	01200574 	movhi	r4,32789
80145bc4:	21237504 	addi	r4,r4,-29228
80145bc8:	0145a940 	call	80145a94 <alt_open_fd>
}  
80145bcc:	0001883a 	nop
80145bd0:	e037883a 	mov	sp,fp
80145bd4:	dfc00117 	ldw	ra,4(sp)
80145bd8:	df000017 	ldw	fp,0(sp)
80145bdc:	dec00204 	addi	sp,sp,8
80145be0:	f800283a 	ret

80145be4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
80145be4:	defffe04 	addi	sp,sp,-8
80145be8:	de00012e 	bgeu	sp,et,80145bf0 <alt_get_errno+0xc>
80145bec:	003b68fa 	trap	3
80145bf0:	dfc00115 	stw	ra,4(sp)
80145bf4:	df000015 	stw	fp,0(sp)
80145bf8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
80145bfc:	d0a00f17 	ldw	r2,-32708(gp)
80145c00:	10000326 	beq	r2,zero,80145c10 <alt_get_errno+0x2c>
80145c04:	d0a00f17 	ldw	r2,-32708(gp)
80145c08:	103ee83a 	callr	r2
80145c0c:	00000106 	br	80145c14 <alt_get_errno+0x30>
80145c10:	d0a08704 	addi	r2,gp,-32228
}
80145c14:	e037883a 	mov	sp,fp
80145c18:	dfc00117 	ldw	ra,4(sp)
80145c1c:	df000017 	ldw	fp,0(sp)
80145c20:	dec00204 	addi	sp,sp,8
80145c24:	f800283a 	ret

80145c28 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
80145c28:	defffd04 	addi	sp,sp,-12
80145c2c:	de00012e 	bgeu	sp,et,80145c34 <alt_file_locked+0xc>
80145c30:	003b68fa 	trap	3
80145c34:	df000215 	stw	fp,8(sp)
80145c38:	df000204 	addi	fp,sp,8
80145c3c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
80145c40:	e0bfff17 	ldw	r2,-4(fp)
80145c44:	10800217 	ldw	r2,8(r2)
80145c48:	10d00034 	orhi	r3,r2,16384
80145c4c:	e0bfff17 	ldw	r2,-4(fp)
80145c50:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
80145c54:	e03ffe15 	stw	zero,-8(fp)
80145c58:	00001d06 	br	80145cd0 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
80145c5c:	00a00574 	movhi	r2,32789
80145c60:	10a36f04 	addi	r2,r2,-29252
80145c64:	e0fffe17 	ldw	r3,-8(fp)
80145c68:	18c00324 	muli	r3,r3,12
80145c6c:	10c5883a 	add	r2,r2,r3
80145c70:	10c00017 	ldw	r3,0(r2)
80145c74:	e0bfff17 	ldw	r2,-4(fp)
80145c78:	10800017 	ldw	r2,0(r2)
80145c7c:	1880111e 	bne	r3,r2,80145cc4 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
80145c80:	00a00574 	movhi	r2,32789
80145c84:	10a36f04 	addi	r2,r2,-29252
80145c88:	e0fffe17 	ldw	r3,-8(fp)
80145c8c:	18c00324 	muli	r3,r3,12
80145c90:	10c5883a 	add	r2,r2,r3
80145c94:	10800204 	addi	r2,r2,8
80145c98:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
80145c9c:	1000090e 	bge	r2,zero,80145cc4 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
80145ca0:	e0bffe17 	ldw	r2,-8(fp)
80145ca4:	10c00324 	muli	r3,r2,12
80145ca8:	00a00574 	movhi	r2,32789
80145cac:	10a36f04 	addi	r2,r2,-29252
80145cb0:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
80145cb4:	e0bfff17 	ldw	r2,-4(fp)
80145cb8:	18800226 	beq	r3,r2,80145cc4 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
80145cbc:	00bffcc4 	movi	r2,-13
80145cc0:	00000806 	br	80145ce4 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
80145cc4:	e0bffe17 	ldw	r2,-8(fp)
80145cc8:	10800044 	addi	r2,r2,1
80145ccc:	e0bffe15 	stw	r2,-8(fp)
80145cd0:	d0a00e17 	ldw	r2,-32712(gp)
80145cd4:	1007883a 	mov	r3,r2
80145cd8:	e0bffe17 	ldw	r2,-8(fp)
80145cdc:	18bfdf2e 	bgeu	r3,r2,80145c5c <__reset+0xfa125c5c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
80145ce0:	0005883a 	mov	r2,zero
}
80145ce4:	e037883a 	mov	sp,fp
80145ce8:	df000017 	ldw	fp,0(sp)
80145cec:	dec00104 	addi	sp,sp,4
80145cf0:	f800283a 	ret

80145cf4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
80145cf4:	defff604 	addi	sp,sp,-40
80145cf8:	de00012e 	bgeu	sp,et,80145d00 <open+0xc>
80145cfc:	003b68fa 	trap	3
80145d00:	dfc00915 	stw	ra,36(sp)
80145d04:	df000815 	stw	fp,32(sp)
80145d08:	df000804 	addi	fp,sp,32
80145d0c:	e13ffd15 	stw	r4,-12(fp)
80145d10:	e17ffe15 	stw	r5,-8(fp)
80145d14:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
80145d18:	00bfffc4 	movi	r2,-1
80145d1c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
80145d20:	00bffb44 	movi	r2,-19
80145d24:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
80145d28:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
80145d2c:	d1600c04 	addi	r5,gp,-32720
80145d30:	e13ffd17 	ldw	r4,-12(fp)
80145d34:	01457340 	call	80145734 <alt_find_dev>
80145d38:	e0bff815 	stw	r2,-32(fp)
80145d3c:	e0bff817 	ldw	r2,-32(fp)
80145d40:	1000051e 	bne	r2,zero,80145d58 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
80145d44:	e13ffd17 	ldw	r4,-12(fp)
80145d48:	01464dc0 	call	801464dc <alt_find_file>
80145d4c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
80145d50:	00800044 	movi	r2,1
80145d54:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
80145d58:	e0bff817 	ldw	r2,-32(fp)
80145d5c:	10002926 	beq	r2,zero,80145e04 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
80145d60:	e13ff817 	ldw	r4,-32(fp)
80145d64:	01465ec0 	call	801465ec <alt_get_fd>
80145d68:	e0bff915 	stw	r2,-28(fp)
80145d6c:	e0bff917 	ldw	r2,-28(fp)
80145d70:	1000030e 	bge	r2,zero,80145d80 <open+0x8c>
    {
      status = index;
80145d74:	e0bff917 	ldw	r2,-28(fp)
80145d78:	e0bffa15 	stw	r2,-24(fp)
80145d7c:	00002306 	br	80145e0c <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
80145d80:	e0bff917 	ldw	r2,-28(fp)
80145d84:	10c00324 	muli	r3,r2,12
80145d88:	00a00574 	movhi	r2,32789
80145d8c:	10a36f04 	addi	r2,r2,-29252
80145d90:	1885883a 	add	r2,r3,r2
80145d94:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
80145d98:	e0fffe17 	ldw	r3,-8(fp)
80145d9c:	00900034 	movhi	r2,16384
80145da0:	10bfffc4 	addi	r2,r2,-1
80145da4:	1886703a 	and	r3,r3,r2
80145da8:	e0bffc17 	ldw	r2,-16(fp)
80145dac:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
80145db0:	e0bffb17 	ldw	r2,-20(fp)
80145db4:	1000051e 	bne	r2,zero,80145dcc <open+0xd8>
80145db8:	e13ffc17 	ldw	r4,-16(fp)
80145dbc:	0145c280 	call	80145c28 <alt_file_locked>
80145dc0:	e0bffa15 	stw	r2,-24(fp)
80145dc4:	e0bffa17 	ldw	r2,-24(fp)
80145dc8:	10001016 	blt	r2,zero,80145e0c <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
80145dcc:	e0bff817 	ldw	r2,-32(fp)
80145dd0:	10800317 	ldw	r2,12(r2)
80145dd4:	10000826 	beq	r2,zero,80145df8 <open+0x104>
80145dd8:	e0bff817 	ldw	r2,-32(fp)
80145ddc:	10800317 	ldw	r2,12(r2)
80145de0:	e1ffff17 	ldw	r7,-4(fp)
80145de4:	e1bffe17 	ldw	r6,-8(fp)
80145de8:	e17ffd17 	ldw	r5,-12(fp)
80145dec:	e13ffc17 	ldw	r4,-16(fp)
80145df0:	103ee83a 	callr	r2
80145df4:	00000106 	br	80145dfc <open+0x108>
80145df8:	0005883a 	mov	r2,zero
80145dfc:	e0bffa15 	stw	r2,-24(fp)
80145e00:	00000206 	br	80145e0c <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
80145e04:	00bffb44 	movi	r2,-19
80145e08:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
80145e0c:	e0bffa17 	ldw	r2,-24(fp)
80145e10:	1000090e 	bge	r2,zero,80145e38 <open+0x144>
  {
    alt_release_fd (index);  
80145e14:	e13ff917 	ldw	r4,-28(fp)
80145e18:	0132ddc0 	call	80132ddc <alt_release_fd>
    ALT_ERRNO = -status;
80145e1c:	0145be40 	call	80145be4 <alt_get_errno>
80145e20:	1007883a 	mov	r3,r2
80145e24:	e0bffa17 	ldw	r2,-24(fp)
80145e28:	0085c83a 	sub	r2,zero,r2
80145e2c:	18800015 	stw	r2,0(r3)
    return -1;
80145e30:	00bfffc4 	movi	r2,-1
80145e34:	00000106 	br	80145e3c <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
80145e38:	e0bff917 	ldw	r2,-28(fp)
}
80145e3c:	e037883a 	mov	sp,fp
80145e40:	dfc00117 	ldw	ra,4(sp)
80145e44:	df000017 	ldw	fp,0(sp)
80145e48:	dec00204 	addi	sp,sp,8
80145e4c:	f800283a 	ret

80145e50 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
80145e50:	defff204 	addi	sp,sp,-56
80145e54:	de00012e 	bgeu	sp,et,80145e5c <alt_printf+0xc>
80145e58:	003b68fa 	trap	3
80145e5c:	dfc00a15 	stw	ra,40(sp)
80145e60:	df000915 	stw	fp,36(sp)
80145e64:	df000904 	addi	fp,sp,36
80145e68:	e13fff15 	stw	r4,-4(fp)
80145e6c:	e1400215 	stw	r5,8(fp)
80145e70:	e1800315 	stw	r6,12(fp)
80145e74:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
80145e78:	e0800204 	addi	r2,fp,8
80145e7c:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
80145e80:	e0bfff17 	ldw	r2,-4(fp)
80145e84:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
80145e88:	00006f06 	br	80146048 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
80145e8c:	e0bff807 	ldb	r2,-32(fp)
80145e90:	10800960 	cmpeqi	r2,r2,37
80145e94:	1000041e 	bne	r2,zero,80145ea8 <alt_printf+0x58>
        {
            alt_putchar(c);
80145e98:	e0bff807 	ldb	r2,-32(fp)
80145e9c:	1009883a 	mov	r4,r2
80145ea0:	01460840 	call	80146084 <alt_putchar>
80145ea4:	00006806 	br	80146048 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
80145ea8:	e0bff717 	ldw	r2,-36(fp)
80145eac:	10c00044 	addi	r3,r2,1
80145eb0:	e0fff715 	stw	r3,-36(fp)
80145eb4:	10800003 	ldbu	r2,0(r2)
80145eb8:	e0bff805 	stb	r2,-32(fp)
80145ebc:	e0bff807 	ldb	r2,-32(fp)
80145ec0:	10006926 	beq	r2,zero,80146068 <alt_printf+0x218>
            {
                if (c == '%')
80145ec4:	e0bff807 	ldb	r2,-32(fp)
80145ec8:	10800958 	cmpnei	r2,r2,37
80145ecc:	1000041e 	bne	r2,zero,80145ee0 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
80145ed0:	e0bff807 	ldb	r2,-32(fp)
80145ed4:	1009883a 	mov	r4,r2
80145ed8:	01460840 	call	80146084 <alt_putchar>
80145edc:	00005a06 	br	80146048 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
80145ee0:	e0bff807 	ldb	r2,-32(fp)
80145ee4:	108018d8 	cmpnei	r2,r2,99
80145ee8:	1000081e 	bne	r2,zero,80145f0c <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
80145eec:	e0bffe17 	ldw	r2,-8(fp)
80145ef0:	10c00104 	addi	r3,r2,4
80145ef4:	e0fffe15 	stw	r3,-8(fp)
80145ef8:	10800017 	ldw	r2,0(r2)
80145efc:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
80145f00:	e13ffd17 	ldw	r4,-12(fp)
80145f04:	01460840 	call	80146084 <alt_putchar>
80145f08:	00004f06 	br	80146048 <alt_printf+0x1f8>
                }
                else if (c == 'x')
80145f0c:	e0bff807 	ldb	r2,-32(fp)
80145f10:	10801e18 	cmpnei	r2,r2,120
80145f14:	1000341e 	bne	r2,zero,80145fe8 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
80145f18:	e0bffe17 	ldw	r2,-8(fp)
80145f1c:	10c00104 	addi	r3,r2,4
80145f20:	e0fffe15 	stw	r3,-8(fp)
80145f24:	10800017 	ldw	r2,0(r2)
80145f28:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
80145f2c:	e0bffb17 	ldw	r2,-20(fp)
80145f30:	1000031e 	bne	r2,zero,80145f40 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
80145f34:	01000c04 	movi	r4,48
80145f38:	01460840 	call	80146084 <alt_putchar>
                        continue;
80145f3c:	00004206 	br	80146048 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
80145f40:	00800704 	movi	r2,28
80145f44:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
80145f48:	00000306 	br	80145f58 <alt_printf+0x108>
                        digit_shift -= 4;
80145f4c:	e0bff917 	ldw	r2,-28(fp)
80145f50:	10bfff04 	addi	r2,r2,-4
80145f54:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
80145f58:	00c003c4 	movi	r3,15
80145f5c:	e0bff917 	ldw	r2,-28(fp)
80145f60:	1884983a 	sll	r2,r3,r2
80145f64:	1007883a 	mov	r3,r2
80145f68:	e0bffb17 	ldw	r2,-20(fp)
80145f6c:	1884703a 	and	r2,r3,r2
80145f70:	103ff626 	beq	r2,zero,80145f4c <__reset+0xfa125f4c>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
80145f74:	00001906 	br	80145fdc <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
80145f78:	00c003c4 	movi	r3,15
80145f7c:	e0bff917 	ldw	r2,-28(fp)
80145f80:	1884983a 	sll	r2,r3,r2
80145f84:	1007883a 	mov	r3,r2
80145f88:	e0bffb17 	ldw	r2,-20(fp)
80145f8c:	1886703a 	and	r3,r3,r2
80145f90:	e0bff917 	ldw	r2,-28(fp)
80145f94:	1884d83a 	srl	r2,r3,r2
80145f98:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
80145f9c:	e0bffc17 	ldw	r2,-16(fp)
80145fa0:	108002a8 	cmpgeui	r2,r2,10
80145fa4:	1000041e 	bne	r2,zero,80145fb8 <alt_printf+0x168>
                            c = '0' + digit;
80145fa8:	e0bffc17 	ldw	r2,-16(fp)
80145fac:	10800c04 	addi	r2,r2,48
80145fb0:	e0bff805 	stb	r2,-32(fp)
80145fb4:	00000306 	br	80145fc4 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
80145fb8:	e0bffc17 	ldw	r2,-16(fp)
80145fbc:	108015c4 	addi	r2,r2,87
80145fc0:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
80145fc4:	e0bff807 	ldb	r2,-32(fp)
80145fc8:	1009883a 	mov	r4,r2
80145fcc:	01460840 	call	80146084 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
80145fd0:	e0bff917 	ldw	r2,-28(fp)
80145fd4:	10bfff04 	addi	r2,r2,-4
80145fd8:	e0bff915 	stw	r2,-28(fp)
80145fdc:	e0bff917 	ldw	r2,-28(fp)
80145fe0:	103fe50e 	bge	r2,zero,80145f78 <__reset+0xfa125f78>
80145fe4:	00001806 	br	80146048 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
80145fe8:	e0bff807 	ldb	r2,-32(fp)
80145fec:	10801cd8 	cmpnei	r2,r2,115
80145ff0:	1000151e 	bne	r2,zero,80146048 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
80145ff4:	e0bffe17 	ldw	r2,-8(fp)
80145ff8:	10c00104 	addi	r3,r2,4
80145ffc:	e0fffe15 	stw	r3,-8(fp)
80146000:	10800017 	ldw	r2,0(r2)
80146004:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
80146008:	00000906 	br	80146030 <alt_printf+0x1e0>
                      alt_putchar(*s++);
8014600c:	e0bffa17 	ldw	r2,-24(fp)
80146010:	10c00044 	addi	r3,r2,1
80146014:	e0fffa15 	stw	r3,-24(fp)
80146018:	10800003 	ldbu	r2,0(r2)
8014601c:	10803fcc 	andi	r2,r2,255
80146020:	1080201c 	xori	r2,r2,128
80146024:	10bfe004 	addi	r2,r2,-128
80146028:	1009883a 	mov	r4,r2
8014602c:	01460840 	call	80146084 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
80146030:	e0bffa17 	ldw	r2,-24(fp)
80146034:	10800003 	ldbu	r2,0(r2)
80146038:	10803fcc 	andi	r2,r2,255
8014603c:	1080201c 	xori	r2,r2,128
80146040:	10bfe004 	addi	r2,r2,-128
80146044:	103ff11e 	bne	r2,zero,8014600c <__reset+0xfa12600c>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
80146048:	e0bff717 	ldw	r2,-36(fp)
8014604c:	10c00044 	addi	r3,r2,1
80146050:	e0fff715 	stw	r3,-36(fp)
80146054:	10800003 	ldbu	r2,0(r2)
80146058:	e0bff805 	stb	r2,-32(fp)
8014605c:	e0bff807 	ldb	r2,-32(fp)
80146060:	103f8a1e 	bne	r2,zero,80145e8c <__reset+0xfa125e8c>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
80146064:	00000106 	br	8014606c <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
80146068:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
8014606c:	0001883a 	nop
80146070:	e037883a 	mov	sp,fp
80146074:	dfc00117 	ldw	ra,4(sp)
80146078:	df000017 	ldw	fp,0(sp)
8014607c:	dec00504 	addi	sp,sp,20
80146080:	f800283a 	ret

80146084 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
80146084:	defffd04 	addi	sp,sp,-12
80146088:	de00012e 	bgeu	sp,et,80146090 <alt_putchar+0xc>
8014608c:	003b68fa 	trap	3
80146090:	dfc00215 	stw	ra,8(sp)
80146094:	df000115 	stw	fp,4(sp)
80146098:	df000104 	addi	fp,sp,4
8014609c:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
801460a0:	d0a00517 	ldw	r2,-32748(gp)
801460a4:	10800217 	ldw	r2,8(r2)
801460a8:	100b883a 	mov	r5,r2
801460ac:	e13fff17 	ldw	r4,-4(fp)
801460b0:	01468d80 	call	801468d8 <putc>
#endif
#endif
}
801460b4:	e037883a 	mov	sp,fp
801460b8:	dfc00117 	ldw	ra,4(sp)
801460bc:	df000017 	ldw	fp,0(sp)
801460c0:	dec00204 	addi	sp,sp,8
801460c4:	f800283a 	ret

801460c8 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
801460c8:	deffff04 	addi	sp,sp,-4
801460cc:	de00012e 	bgeu	sp,et,801460d4 <altera_nios2_gen2_irq_init+0xc>
801460d0:	003b68fa 	trap	3
801460d4:	df000015 	stw	fp,0(sp)
801460d8:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
801460dc:	000170fa 	wrctl	ienable,zero
}
801460e0:	0001883a 	nop
801460e4:	e037883a 	mov	sp,fp
801460e8:	df000017 	ldw	fp,0(sp)
801460ec:	dec00104 	addi	sp,sp,4
801460f0:	f800283a 	ret

801460f4 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
801460f4:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
801460f8:	de002436 	bltu	sp,et,8014618c <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
801460fc:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
80146100:	d120ab17 	ldw	r4,-32084(gp)

      stw ra,  0(sp)
80146104:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
80146108:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
8014610c:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
80146110:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
80146114:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
80146118:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
8014611c:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
80146120:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
80146124:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
80146128:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
8014612c:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
80146130:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
80146134:	01463900 	call	80146390 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
80146138:	d120a517 	ldw	r4,-32108(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
8014613c:	d1609c87 	ldb	r5,-32142(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
80146140:	d120ab15 	stw	r4,-32084(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
80146144:	d1609cc5 	stb	r5,-32141(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
80146148:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
8014614c:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
80146150:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
80146154:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
80146158:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
8014615c:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
80146160:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
80146164:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
80146168:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
8014616c:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
80146170:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
80146174:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
80146178:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
8014617c:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
80146180:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
80146184:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
80146188:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
8014618c:	003da0fa 	break	3

80146190 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
80146190:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
80146194:	047fff84 	movi	r17,-2
      and   r18, r18, r17
80146198:	9464703a 	and	r18,r18,r17
      wrctl status, r18
8014619c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
801461a0:	01463900 	call	80146390 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
801461a4:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
801461a8:	d4a09a05 	stb	r18,-32152(gp)

      /*
       * start execution of the new task.
       */

      br 9b
801461ac:	003fe206 	br	80146138 <__reset+0xfa126138>

801461b0 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
801461b0:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
801461b4:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
801461b8:	10800054 	ori	r2,r2,1
      wrctl status, r2
801461bc:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
801461c0:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
801461c4:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
801461c8:	dec00204 	addi	sp,sp,8

      callr r2
801461cc:	103ee83a 	callr	r2

      nop
801461d0:	0001883a 	nop

801461d4 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
801461d4:	defff704 	addi	sp,sp,-36
801461d8:	de00012e 	bgeu	sp,et,801461e0 <OSTaskStkInit+0xc>
801461dc:	003b68fa 	trap	3
801461e0:	dfc00815 	stw	ra,32(sp)
801461e4:	df000715 	stw	fp,28(sp)
801461e8:	df000704 	addi	fp,sp,28
801461ec:	e13ffc15 	stw	r4,-16(fp)
801461f0:	e17ffd15 	stw	r5,-12(fp)
801461f4:	e1bffe15 	stw	r6,-8(fp)
801461f8:	3805883a 	mov	r2,r7
801461fc:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
80146200:	e0fffe17 	ldw	r3,-8(fp)
80146204:	00bfff04 	movi	r2,-4
80146208:	1884703a 	and	r2,r3,r2
8014620c:	10bef704 	addi	r2,r2,-1060
80146210:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
80146214:	01810904 	movi	r6,1060
80146218:	000b883a 	mov	r5,zero
8014621c:	e13ff917 	ldw	r4,-28(fp)
80146220:	01215b40 	call	801215b4 <memset>
80146224:	e0bff917 	ldw	r2,-28(fp)
80146228:	10c0bb04 	addi	r3,r2,748
8014622c:	e0bff917 	ldw	r2,-28(fp)
80146230:	10c00115 	stw	r3,4(r2)
80146234:	e0bff917 	ldw	r2,-28(fp)
80146238:	10c0d504 	addi	r3,r2,852
8014623c:	e0bff917 	ldw	r2,-28(fp)
80146240:	10c00215 	stw	r3,8(r2)
80146244:	e0bff917 	ldw	r2,-28(fp)
80146248:	10c0ef04 	addi	r3,r2,956
8014624c:	e0bff917 	ldw	r2,-28(fp)
80146250:	10c00315 	stw	r3,12(r2)
80146254:	e0fff917 	ldw	r3,-28(fp)
80146258:	00a00574 	movhi	r2,32789
8014625c:	10a10804 	addi	r2,r2,-31712
80146260:	18800d15 	stw	r2,52(r3)
80146264:	e0bff917 	ldw	r2,-28(fp)
80146268:	00c00044 	movi	r3,1
8014626c:	10c02915 	stw	r3,164(r2)
80146270:	10002a15 	stw	zero,168(r2)
80146274:	e0bff917 	ldw	r2,-28(fp)
80146278:	00ccc384 	movi	r3,13070
8014627c:	10c02b0d 	sth	r3,172(r2)
80146280:	e0bff917 	ldw	r2,-28(fp)
80146284:	00eaf344 	movi	r3,-21555
80146288:	10c02b8d 	sth	r3,174(r2)
8014628c:	e0bff917 	ldw	r2,-28(fp)
80146290:	00c48d04 	movi	r3,4660
80146294:	10c02c0d 	sth	r3,176(r2)
80146298:	e0bff917 	ldw	r2,-28(fp)
8014629c:	00f99b44 	movi	r3,-6547
801462a0:	10c02c8d 	sth	r3,178(r2)
801462a4:	e0bff917 	ldw	r2,-28(fp)
801462a8:	00f7bb04 	movi	r3,-8468
801462ac:	10c02d0d 	sth	r3,180(r2)
801462b0:	e0bff917 	ldw	r2,-28(fp)
801462b4:	00c00144 	movi	r3,5
801462b8:	10c02d8d 	sth	r3,182(r2)
801462bc:	e0bff917 	ldw	r2,-28(fp)
801462c0:	00c002c4 	movi	r3,11
801462c4:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
801462c8:	e0bff917 	ldw	r2,-28(fp)
801462cc:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
801462d0:	e0bffa17 	ldw	r2,-24(fp)
801462d4:	10bff304 	addi	r2,r2,-52
801462d8:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
801462dc:	e0bffb17 	ldw	r2,-20(fp)
801462e0:	10800c04 	addi	r2,r2,48
801462e4:	e0fffc17 	ldw	r3,-16(fp)
801462e8:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
801462ec:	e0bffb17 	ldw	r2,-20(fp)
801462f0:	10800b04 	addi	r2,r2,44
801462f4:	e0fffd17 	ldw	r3,-12(fp)
801462f8:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
801462fc:	e0bffb17 	ldw	r2,-20(fp)
80146300:	10800a04 	addi	r2,r2,40
80146304:	e0fff917 	ldw	r3,-28(fp)
80146308:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8014630c:	00a00534 	movhi	r2,32788
80146310:	10986c04 	addi	r2,r2,25008
80146314:	10c00104 	addi	r3,r2,4
80146318:	e0bffb17 	ldw	r2,-20(fp)
8014631c:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
80146320:	e0bffb17 	ldw	r2,-20(fp)
}
80146324:	e037883a 	mov	sp,fp
80146328:	dfc00117 	ldw	ra,4(sp)
8014632c:	df000017 	ldw	fp,0(sp)
80146330:	dec00204 	addi	sp,sp,8
80146334:	f800283a 	ret

80146338 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
80146338:	defffe04 	addi	sp,sp,-8
8014633c:	de00012e 	bgeu	sp,et,80146344 <OSTaskCreateHook+0xc>
80146340:	003b68fa 	trap	3
80146344:	df000115 	stw	fp,4(sp)
80146348:	df000104 	addi	fp,sp,4
8014634c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
80146350:	0001883a 	nop
80146354:	e037883a 	mov	sp,fp
80146358:	df000017 	ldw	fp,0(sp)
8014635c:	dec00104 	addi	sp,sp,4
80146360:	f800283a 	ret

80146364 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
80146364:	defffe04 	addi	sp,sp,-8
80146368:	de00012e 	bgeu	sp,et,80146370 <OSTaskDelHook+0xc>
8014636c:	003b68fa 	trap	3
80146370:	df000115 	stw	fp,4(sp)
80146374:	df000104 	addi	fp,sp,4
80146378:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8014637c:	0001883a 	nop
80146380:	e037883a 	mov	sp,fp
80146384:	df000017 	ldw	fp,0(sp)
80146388:	dec00104 	addi	sp,sp,4
8014638c:	f800283a 	ret

80146390 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
80146390:	deffff04 	addi	sp,sp,-4
80146394:	de00012e 	bgeu	sp,et,8014639c <OSTaskSwHook+0xc>
80146398:	003b68fa 	trap	3
8014639c:	df000015 	stw	fp,0(sp)
801463a0:	d839883a 	mov	fp,sp
}
801463a4:	0001883a 	nop
801463a8:	e037883a 	mov	sp,fp
801463ac:	df000017 	ldw	fp,0(sp)
801463b0:	dec00104 	addi	sp,sp,4
801463b4:	f800283a 	ret

801463b8 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
801463b8:	deffff04 	addi	sp,sp,-4
801463bc:	de00012e 	bgeu	sp,et,801463c4 <OSTaskStatHook+0xc>
801463c0:	003b68fa 	trap	3
801463c4:	df000015 	stw	fp,0(sp)
801463c8:	d839883a 	mov	fp,sp
}
801463cc:	0001883a 	nop
801463d0:	e037883a 	mov	sp,fp
801463d4:	df000017 	ldw	fp,0(sp)
801463d8:	dec00104 	addi	sp,sp,4
801463dc:	f800283a 	ret

801463e0 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
801463e0:	defffe04 	addi	sp,sp,-8
801463e4:	de00012e 	bgeu	sp,et,801463ec <OSTimeTickHook+0xc>
801463e8:	003b68fa 	trap	3
801463ec:	dfc00115 	stw	ra,4(sp)
801463f0:	df000015 	stw	fp,0(sp)
801463f4:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
801463f8:	d0a0bf0b 	ldhu	r2,-32004(gp)
801463fc:	10800044 	addi	r2,r2,1
80146400:	d0a0bf0d 	sth	r2,-32004(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
80146404:	d0a0bf0b 	ldhu	r2,-32004(gp)
80146408:	10bfffcc 	andi	r2,r2,65535
8014640c:	10807d30 	cmpltui	r2,r2,500
80146410:	1000021e 	bne	r2,zero,8014641c <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
80146414:	d020bf0d 	sth	zero,-32004(gp)
        OSTmrSignal();
80146418:	013ccb80 	call	8013ccb8 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8014641c:	0001883a 	nop
80146420:	e037883a 	mov	sp,fp
80146424:	dfc00117 	ldw	ra,4(sp)
80146428:	df000017 	ldw	fp,0(sp)
8014642c:	dec00204 	addi	sp,sp,8
80146430:	f800283a 	ret

80146434 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
80146434:	deffff04 	addi	sp,sp,-4
80146438:	de00012e 	bgeu	sp,et,80146440 <OSInitHookBegin+0xc>
8014643c:	003b68fa 	trap	3
80146440:	df000015 	stw	fp,0(sp)
80146444:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
80146448:	d020bf0d 	sth	zero,-32004(gp)
#endif
}
8014644c:	0001883a 	nop
80146450:	e037883a 	mov	sp,fp
80146454:	df000017 	ldw	fp,0(sp)
80146458:	dec00104 	addi	sp,sp,4
8014645c:	f800283a 	ret

80146460 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
80146460:	deffff04 	addi	sp,sp,-4
80146464:	de00012e 	bgeu	sp,et,8014646c <OSInitHookEnd+0xc>
80146468:	003b68fa 	trap	3
8014646c:	df000015 	stw	fp,0(sp)
80146470:	d839883a 	mov	fp,sp
}
80146474:	0001883a 	nop
80146478:	e037883a 	mov	sp,fp
8014647c:	df000017 	ldw	fp,0(sp)
80146480:	dec00104 	addi	sp,sp,4
80146484:	f800283a 	ret

80146488 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
80146488:	deffff04 	addi	sp,sp,-4
8014648c:	de00012e 	bgeu	sp,et,80146494 <OSTaskIdleHook+0xc>
80146490:	003b68fa 	trap	3
80146494:	df000015 	stw	fp,0(sp)
80146498:	d839883a 	mov	fp,sp
}
8014649c:	0001883a 	nop
801464a0:	e037883a 	mov	sp,fp
801464a4:	df000017 	ldw	fp,0(sp)
801464a8:	dec00104 	addi	sp,sp,4
801464ac:	f800283a 	ret

801464b0 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
801464b0:	defffe04 	addi	sp,sp,-8
801464b4:	de00012e 	bgeu	sp,et,801464bc <OSTCBInitHook+0xc>
801464b8:	003b68fa 	trap	3
801464bc:	df000115 	stw	fp,4(sp)
801464c0:	df000104 	addi	fp,sp,4
801464c4:	e13fff15 	stw	r4,-4(fp)
}
801464c8:	0001883a 	nop
801464cc:	e037883a 	mov	sp,fp
801464d0:	df000017 	ldw	fp,0(sp)
801464d4:	dec00104 	addi	sp,sp,4
801464d8:	f800283a 	ret

801464dc <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
801464dc:	defffb04 	addi	sp,sp,-20
801464e0:	de00012e 	bgeu	sp,et,801464e8 <alt_find_file+0xc>
801464e4:	003b68fa 	trap	3
801464e8:	dfc00415 	stw	ra,16(sp)
801464ec:	df000315 	stw	fp,12(sp)
801464f0:	df000304 	addi	fp,sp,12
801464f4:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
801464f8:	d0a00a17 	ldw	r2,-32728(gp)
801464fc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
80146500:	00003106 	br	801465c8 <alt_find_file+0xec>
  {
    len = strlen(next->name);
80146504:	e0bffd17 	ldw	r2,-12(fp)
80146508:	10800217 	ldw	r2,8(r2)
8014650c:	1009883a 	mov	r4,r2
80146510:	01219540 	call	80121954 <strlen>
80146514:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
80146518:	e0bffd17 	ldw	r2,-12(fp)
8014651c:	10c00217 	ldw	r3,8(r2)
80146520:	e0bffe17 	ldw	r2,-8(fp)
80146524:	10bfffc4 	addi	r2,r2,-1
80146528:	1885883a 	add	r2,r3,r2
8014652c:	10800003 	ldbu	r2,0(r2)
80146530:	10803fcc 	andi	r2,r2,255
80146534:	1080201c 	xori	r2,r2,128
80146538:	10bfe004 	addi	r2,r2,-128
8014653c:	10800bd8 	cmpnei	r2,r2,47
80146540:	1000031e 	bne	r2,zero,80146550 <alt_find_file+0x74>
    {
      len -= 1;
80146544:	e0bffe17 	ldw	r2,-8(fp)
80146548:	10bfffc4 	addi	r2,r2,-1
8014654c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
80146550:	e0bffe17 	ldw	r2,-8(fp)
80146554:	e0ffff17 	ldw	r3,-4(fp)
80146558:	1885883a 	add	r2,r3,r2
8014655c:	10800003 	ldbu	r2,0(r2)
80146560:	10803fcc 	andi	r2,r2,255
80146564:	1080201c 	xori	r2,r2,128
80146568:	10bfe004 	addi	r2,r2,-128
8014656c:	10800be0 	cmpeqi	r2,r2,47
80146570:	1000081e 	bne	r2,zero,80146594 <alt_find_file+0xb8>
80146574:	e0bffe17 	ldw	r2,-8(fp)
80146578:	e0ffff17 	ldw	r3,-4(fp)
8014657c:	1885883a 	add	r2,r3,r2
80146580:	10800003 	ldbu	r2,0(r2)
80146584:	10803fcc 	andi	r2,r2,255
80146588:	1080201c 	xori	r2,r2,128
8014658c:	10bfe004 	addi	r2,r2,-128
80146590:	10000a1e 	bne	r2,zero,801465bc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
80146594:	e0bffd17 	ldw	r2,-12(fp)
80146598:	10800217 	ldw	r2,8(r2)
8014659c:	e0fffe17 	ldw	r3,-8(fp)
801465a0:	180d883a 	mov	r6,r3
801465a4:	e17fff17 	ldw	r5,-4(fp)
801465a8:	1009883a 	mov	r4,r2
801465ac:	01467b40 	call	801467b4 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
801465b0:	1000021e 	bne	r2,zero,801465bc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
801465b4:	e0bffd17 	ldw	r2,-12(fp)
801465b8:	00000706 	br	801465d8 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
801465bc:	e0bffd17 	ldw	r2,-12(fp)
801465c0:	10800017 	ldw	r2,0(r2)
801465c4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
801465c8:	e0fffd17 	ldw	r3,-12(fp)
801465cc:	d0a00a04 	addi	r2,gp,-32728
801465d0:	18bfcc1e 	bne	r3,r2,80146504 <__reset+0xfa126504>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
801465d4:	0005883a 	mov	r2,zero
}
801465d8:	e037883a 	mov	sp,fp
801465dc:	dfc00117 	ldw	ra,4(sp)
801465e0:	df000017 	ldw	fp,0(sp)
801465e4:	dec00204 	addi	sp,sp,8
801465e8:	f800283a 	ret

801465ec <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
801465ec:	defff904 	addi	sp,sp,-28
801465f0:	de00012e 	bgeu	sp,et,801465f8 <alt_get_fd+0xc>
801465f4:	003b68fa 	trap	3
801465f8:	dfc00615 	stw	ra,24(sp)
801465fc:	df000515 	stw	fp,20(sp)
80146600:	df000504 	addi	fp,sp,20
80146604:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
80146608:	00bffa04 	movi	r2,-24
8014660c:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
80146610:	d0a08817 	ldw	r2,-32224(gp)
80146614:	e0bffd15 	stw	r2,-12(fp)
80146618:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8014661c:	e0bffe0b 	ldhu	r2,-8(fp)
80146620:	e0fffe84 	addi	r3,fp,-6
80146624:	180d883a 	mov	r6,r3
80146628:	100b883a 	mov	r5,r2
8014662c:	e13ffd17 	ldw	r4,-12(fp)
80146630:	0139efc0 	call	80139efc <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
80146634:	e03ffb15 	stw	zero,-20(fp)
80146638:	00001906 	br	801466a0 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
8014663c:	00a00574 	movhi	r2,32789
80146640:	10a36f04 	addi	r2,r2,-29252
80146644:	e0fffb17 	ldw	r3,-20(fp)
80146648:	18c00324 	muli	r3,r3,12
8014664c:	10c5883a 	add	r2,r2,r3
80146650:	10800017 	ldw	r2,0(r2)
80146654:	10000f1e 	bne	r2,zero,80146694 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
80146658:	00a00574 	movhi	r2,32789
8014665c:	10a36f04 	addi	r2,r2,-29252
80146660:	e0fffb17 	ldw	r3,-20(fp)
80146664:	18c00324 	muli	r3,r3,12
80146668:	10c5883a 	add	r2,r2,r3
8014666c:	e0ffff17 	ldw	r3,-4(fp)
80146670:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
80146674:	d0e00e17 	ldw	r3,-32712(gp)
80146678:	e0bffb17 	ldw	r2,-20(fp)
8014667c:	1880020e 	bge	r3,r2,80146688 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
80146680:	e0bffb17 	ldw	r2,-20(fp)
80146684:	d0a00e15 	stw	r2,-32712(gp)
      }
      rc = i;
80146688:	e0bffb17 	ldw	r2,-20(fp)
8014668c:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
80146690:	00000606 	br	801466ac <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
80146694:	e0bffb17 	ldw	r2,-20(fp)
80146698:	10800044 	addi	r2,r2,1
8014669c:	e0bffb15 	stw	r2,-20(fp)
801466a0:	e0bffb17 	ldw	r2,-20(fp)
801466a4:	10800810 	cmplti	r2,r2,32
801466a8:	103fe41e 	bne	r2,zero,8014663c <__reset+0xfa12663c>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
801466ac:	d0a08817 	ldw	r2,-32224(gp)
801466b0:	1009883a 	mov	r4,r2
801466b4:	013a2840 	call	8013a284 <OSSemPost>

  return rc;
801466b8:	e0bffc17 	ldw	r2,-16(fp)
}
801466bc:	e037883a 	mov	sp,fp
801466c0:	dfc00117 	ldw	ra,4(sp)
801466c4:	df000017 	ldw	fp,0(sp)
801466c8:	dec00204 	addi	sp,sp,8
801466cc:	f800283a 	ret

801466d0 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
801466d0:	defffe04 	addi	sp,sp,-8
801466d4:	de00012e 	bgeu	sp,et,801466dc <alt_exception_cause_generated_bad_addr+0xc>
801466d8:	003b68fa 	trap	3
801466dc:	df000115 	stw	fp,4(sp)
801466e0:	df000104 	addi	fp,sp,4
801466e4:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
801466e8:	e0bfff17 	ldw	r2,-4(fp)
801466ec:	10bffe84 	addi	r2,r2,-6
801466f0:	10c00428 	cmpgeui	r3,r2,16
801466f4:	18001a1e 	bne	r3,zero,80146760 <alt_exception_cause_generated_bad_addr+0x90>
801466f8:	100690ba 	slli	r3,r2,2
801466fc:	00a00534 	movhi	r2,32788
80146700:	1099c404 	addi	r2,r2,26384
80146704:	1885883a 	add	r2,r3,r2
80146708:	10800017 	ldw	r2,0(r2)
8014670c:	1000683a 	jmp	r2
80146710:	80146750 	cmplti	zero,r16,20893
80146714:	80146750 	cmplti	zero,r16,20893
80146718:	80146760 	cmpeqi	zero,r16,20893
8014671c:	80146760 	cmpeqi	zero,r16,20893
80146720:	80146760 	cmpeqi	zero,r16,20893
80146724:	80146750 	cmplti	zero,r16,20893
80146728:	80146758 	cmpnei	zero,r16,20893
8014672c:	80146760 	cmpeqi	zero,r16,20893
80146730:	80146750 	cmplti	zero,r16,20893
80146734:	80146750 	cmplti	zero,r16,20893
80146738:	80146760 	cmpeqi	zero,r16,20893
8014673c:	80146750 	cmplti	zero,r16,20893
80146740:	80146758 	cmpnei	zero,r16,20893
80146744:	80146760 	cmpeqi	zero,r16,20893
80146748:	80146760 	cmpeqi	zero,r16,20893
8014674c:	80146750 	cmplti	zero,r16,20893
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
80146750:	00800044 	movi	r2,1
80146754:	00000306 	br	80146764 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
80146758:	0005883a 	mov	r2,zero
8014675c:	00000106 	br	80146764 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
80146760:	0005883a 	mov	r2,zero
  }
}
80146764:	e037883a 	mov	sp,fp
80146768:	df000017 	ldw	fp,0(sp)
8014676c:	dec00104 	addi	sp,sp,4
80146770:	f800283a 	ret

80146774 <exit>:
80146774:	defffe04 	addi	sp,sp,-8
80146778:	000b883a 	mov	r5,zero
8014677c:	de00012e 	bgeu	sp,et,80146784 <exit+0x10>
80146780:	003b68fa 	trap	3
80146784:	dc000015 	stw	r16,0(sp)
80146788:	dfc00115 	stw	ra,4(sp)
8014678c:	2021883a 	mov	r16,r4
80146790:	0146bf40 	call	80146bf4 <__call_exitprocs>
80146794:	00a00574 	movhi	r2,32789
80146798:	10a88604 	addi	r2,r2,-24040
8014679c:	11000017 	ldw	r4,0(r2)
801467a0:	20800f17 	ldw	r2,60(r4)
801467a4:	10000126 	beq	r2,zero,801467ac <exit+0x38>
801467a8:	103ee83a 	callr	r2
801467ac:	8009883a 	mov	r4,r16
801467b0:	0146d7c0 	call	80146d7c <_exit>

801467b4 <memcmp>:
801467b4:	01c000c4 	movi	r7,3
801467b8:	3980192e 	bgeu	r7,r6,80146820 <memcmp+0x6c>
801467bc:	2144b03a 	or	r2,r4,r5
801467c0:	11c4703a 	and	r2,r2,r7
801467c4:	10000f26 	beq	r2,zero,80146804 <memcmp+0x50>
801467c8:	20800003 	ldbu	r2,0(r4)
801467cc:	28c00003 	ldbu	r3,0(r5)
801467d0:	10c0151e 	bne	r2,r3,80146828 <memcmp+0x74>
801467d4:	31bfff84 	addi	r6,r6,-2
801467d8:	01ffffc4 	movi	r7,-1
801467dc:	00000406 	br	801467f0 <memcmp+0x3c>
801467e0:	20800003 	ldbu	r2,0(r4)
801467e4:	28c00003 	ldbu	r3,0(r5)
801467e8:	31bfffc4 	addi	r6,r6,-1
801467ec:	10c00e1e 	bne	r2,r3,80146828 <memcmp+0x74>
801467f0:	21000044 	addi	r4,r4,1
801467f4:	29400044 	addi	r5,r5,1
801467f8:	31fff91e 	bne	r6,r7,801467e0 <__reset+0xfa1267e0>
801467fc:	0005883a 	mov	r2,zero
80146800:	f800283a 	ret
80146804:	20c00017 	ldw	r3,0(r4)
80146808:	28800017 	ldw	r2,0(r5)
8014680c:	18bfee1e 	bne	r3,r2,801467c8 <__reset+0xfa1267c8>
80146810:	31bfff04 	addi	r6,r6,-4
80146814:	21000104 	addi	r4,r4,4
80146818:	29400104 	addi	r5,r5,4
8014681c:	39bff936 	bltu	r7,r6,80146804 <__reset+0xfa126804>
80146820:	303fe91e 	bne	r6,zero,801467c8 <__reset+0xfa1267c8>
80146824:	003ff506 	br	801467fc <__reset+0xfa1267fc>
80146828:	10c5c83a 	sub	r2,r2,r3
8014682c:	f800283a 	ret

80146830 <_putc_r>:
80146830:	defffc04 	addi	sp,sp,-16
80146834:	de00012e 	bgeu	sp,et,8014683c <_putc_r+0xc>
80146838:	003b68fa 	trap	3
8014683c:	dc000215 	stw	r16,8(sp)
80146840:	dfc00315 	stw	ra,12(sp)
80146844:	2021883a 	mov	r16,r4
80146848:	20000226 	beq	r4,zero,80146854 <_putc_r+0x24>
8014684c:	20800e17 	ldw	r2,56(r4)
80146850:	10001b26 	beq	r2,zero,801468c0 <_putc_r+0x90>
80146854:	30800217 	ldw	r2,8(r6)
80146858:	10bfffc4 	addi	r2,r2,-1
8014685c:	30800215 	stw	r2,8(r6)
80146860:	10000a16 	blt	r2,zero,8014688c <_putc_r+0x5c>
80146864:	30800017 	ldw	r2,0(r6)
80146868:	11400005 	stb	r5,0(r2)
8014686c:	30800017 	ldw	r2,0(r6)
80146870:	10c00044 	addi	r3,r2,1
80146874:	30c00015 	stw	r3,0(r6)
80146878:	10800003 	ldbu	r2,0(r2)
8014687c:	dfc00317 	ldw	ra,12(sp)
80146880:	dc000217 	ldw	r16,8(sp)
80146884:	dec00404 	addi	sp,sp,16
80146888:	f800283a 	ret
8014688c:	30c00617 	ldw	r3,24(r6)
80146890:	10c00616 	blt	r2,r3,801468ac <_putc_r+0x7c>
80146894:	30800017 	ldw	r2,0(r6)
80146898:	00c00284 	movi	r3,10
8014689c:	11400005 	stb	r5,0(r2)
801468a0:	30800017 	ldw	r2,0(r6)
801468a4:	11400003 	ldbu	r5,0(r2)
801468a8:	28fff11e 	bne	r5,r3,80146870 <__reset+0xfa126870>
801468ac:	8009883a 	mov	r4,r16
801468b0:	dfc00317 	ldw	ra,12(sp)
801468b4:	dc000217 	ldw	r16,8(sp)
801468b8:	dec00404 	addi	sp,sp,16
801468bc:	0146a941 	jmpi	80146a94 <__swbuf_r>
801468c0:	d9400015 	stw	r5,0(sp)
801468c4:	d9800115 	stw	r6,4(sp)
801468c8:	01276140 	call	80127614 <__sinit>
801468cc:	d9800117 	ldw	r6,4(sp)
801468d0:	d9400017 	ldw	r5,0(sp)
801468d4:	003fdf06 	br	80146854 <__reset+0xfa126854>

801468d8 <putc>:
801468d8:	00a00574 	movhi	r2,32789
801468dc:	defffc04 	addi	sp,sp,-16
801468e0:	10a88704 	addi	r2,r2,-24036
801468e4:	de00012e 	bgeu	sp,et,801468ec <putc+0x14>
801468e8:	003b68fa 	trap	3
801468ec:	dc000115 	stw	r16,4(sp)
801468f0:	14000017 	ldw	r16,0(r2)
801468f4:	dc400215 	stw	r17,8(sp)
801468f8:	dfc00315 	stw	ra,12(sp)
801468fc:	2023883a 	mov	r17,r4
80146900:	80000226 	beq	r16,zero,8014690c <putc+0x34>
80146904:	80800e17 	ldw	r2,56(r16)
80146908:	10001a26 	beq	r2,zero,80146974 <putc+0x9c>
8014690c:	28800217 	ldw	r2,8(r5)
80146910:	10bfffc4 	addi	r2,r2,-1
80146914:	28800215 	stw	r2,8(r5)
80146918:	10000b16 	blt	r2,zero,80146948 <putc+0x70>
8014691c:	28800017 	ldw	r2,0(r5)
80146920:	14400005 	stb	r17,0(r2)
80146924:	28800017 	ldw	r2,0(r5)
80146928:	10c00044 	addi	r3,r2,1
8014692c:	28c00015 	stw	r3,0(r5)
80146930:	10800003 	ldbu	r2,0(r2)
80146934:	dfc00317 	ldw	ra,12(sp)
80146938:	dc400217 	ldw	r17,8(sp)
8014693c:	dc000117 	ldw	r16,4(sp)
80146940:	dec00404 	addi	sp,sp,16
80146944:	f800283a 	ret
80146948:	28c00617 	ldw	r3,24(r5)
8014694c:	10c00e16 	blt	r2,r3,80146988 <putc+0xb0>
80146950:	28800017 	ldw	r2,0(r5)
80146954:	01000284 	movi	r4,10
80146958:	14400005 	stb	r17,0(r2)
8014695c:	28800017 	ldw	r2,0(r5)
80146960:	10c00003 	ldbu	r3,0(r2)
80146964:	193ff01e 	bne	r3,r4,80146928 <__reset+0xfa126928>
80146968:	280d883a 	mov	r6,r5
8014696c:	180b883a 	mov	r5,r3
80146970:	00000706 	br	80146990 <putc+0xb8>
80146974:	8009883a 	mov	r4,r16
80146978:	d9400015 	stw	r5,0(sp)
8014697c:	01276140 	call	80127614 <__sinit>
80146980:	d9400017 	ldw	r5,0(sp)
80146984:	003fe106 	br	8014690c <__reset+0xfa12690c>
80146988:	280d883a 	mov	r6,r5
8014698c:	880b883a 	mov	r5,r17
80146990:	8009883a 	mov	r4,r16
80146994:	dfc00317 	ldw	ra,12(sp)
80146998:	dc400217 	ldw	r17,8(sp)
8014699c:	dc000117 	ldw	r16,4(sp)
801469a0:	dec00404 	addi	sp,sp,16
801469a4:	0146a941 	jmpi	80146a94 <__swbuf_r>

801469a8 <strncpy>:
801469a8:	2906b03a 	or	r3,r5,r4
801469ac:	18c000cc 	andi	r3,r3,3
801469b0:	2005883a 	mov	r2,r4
801469b4:	18002c1e 	bne	r3,zero,80146a68 <strncpy+0xc0>
801469b8:	010000c4 	movi	r4,3
801469bc:	21802a2e 	bgeu	r4,r6,80146a68 <strncpy+0xc0>
801469c0:	033fbff4 	movhi	r12,65279
801469c4:	02e02074 	movhi	r11,32897
801469c8:	633fbfc4 	addi	r12,r12,-257
801469cc:	5ae02004 	addi	r11,r11,-32640
801469d0:	100f883a 	mov	r7,r2
801469d4:	2a000017 	ldw	r8,0(r5)
801469d8:	3815883a 	mov	r10,r7
801469dc:	4313883a 	add	r9,r8,r12
801469e0:	0206303a 	nor	r3,zero,r8
801469e4:	48c6703a 	and	r3,r9,r3
801469e8:	1ac6703a 	and	r3,r3,r11
801469ec:	1800261e 	bne	r3,zero,80146a88 <strncpy+0xe0>
801469f0:	39c00104 	addi	r7,r7,4
801469f4:	52000015 	stw	r8,0(r10)
801469f8:	31bfff04 	addi	r6,r6,-4
801469fc:	3811883a 	mov	r8,r7
80146a00:	29400104 	addi	r5,r5,4
80146a04:	21bff336 	bltu	r4,r6,801469d4 <__reset+0xfa1269d4>
80146a08:	30001e26 	beq	r6,zero,80146a84 <strncpy+0xdc>
80146a0c:	29c00003 	ldbu	r7,0(r5)
80146a10:	31bfffc4 	addi	r6,r6,-1
80146a14:	40c00044 	addi	r3,r8,1
80146a18:	41c00005 	stb	r7,0(r8)
80146a1c:	39c03fcc 	andi	r7,r7,255
80146a20:	39c0201c 	xori	r7,r7,128
80146a24:	39ffe004 	addi	r7,r7,-128
80146a28:	29400044 	addi	r5,r5,1
80146a2c:	38001026 	beq	r7,zero,80146a70 <strncpy+0xc8>
80146a30:	1811883a 	mov	r8,r3
80146a34:	00000906 	br	80146a5c <strncpy+0xb4>
80146a38:	29c00003 	ldbu	r7,0(r5)
80146a3c:	31bfffc4 	addi	r6,r6,-1
80146a40:	29400044 	addi	r5,r5,1
80146a44:	41c00005 	stb	r7,0(r8)
80146a48:	39c03fcc 	andi	r7,r7,255
80146a4c:	39c0201c 	xori	r7,r7,128
80146a50:	39ffe004 	addi	r7,r7,-128
80146a54:	1811883a 	mov	r8,r3
80146a58:	38000526 	beq	r7,zero,80146a70 <strncpy+0xc8>
80146a5c:	18c00044 	addi	r3,r3,1
80146a60:	303ff51e 	bne	r6,zero,80146a38 <__reset+0xfa126a38>
80146a64:	f800283a 	ret
80146a68:	1011883a 	mov	r8,r2
80146a6c:	003fe606 	br	80146a08 <__reset+0xfa126a08>
80146a70:	30000726 	beq	r6,zero,80146a90 <strncpy+0xe8>
80146a74:	198d883a 	add	r6,r3,r6
80146a78:	18000005 	stb	zero,0(r3)
80146a7c:	18c00044 	addi	r3,r3,1
80146a80:	19bffd1e 	bne	r3,r6,80146a78 <__reset+0xfa126a78>
80146a84:	f800283a 	ret
80146a88:	3811883a 	mov	r8,r7
80146a8c:	003fdf06 	br	80146a0c <__reset+0xfa126a0c>
80146a90:	f800283a 	ret

80146a94 <__swbuf_r>:
80146a94:	defffb04 	addi	sp,sp,-20
80146a98:	de00012e 	bgeu	sp,et,80146aa0 <__swbuf_r+0xc>
80146a9c:	003b68fa 	trap	3
80146aa0:	dcc00315 	stw	r19,12(sp)
80146aa4:	dc800215 	stw	r18,8(sp)
80146aa8:	dc000015 	stw	r16,0(sp)
80146aac:	dfc00415 	stw	ra,16(sp)
80146ab0:	dc400115 	stw	r17,4(sp)
80146ab4:	2025883a 	mov	r18,r4
80146ab8:	2827883a 	mov	r19,r5
80146abc:	3021883a 	mov	r16,r6
80146ac0:	20000226 	beq	r4,zero,80146acc <__swbuf_r+0x38>
80146ac4:	20800e17 	ldw	r2,56(r4)
80146ac8:	10004226 	beq	r2,zero,80146bd4 <__swbuf_r+0x140>
80146acc:	80800617 	ldw	r2,24(r16)
80146ad0:	8100030b 	ldhu	r4,12(r16)
80146ad4:	80800215 	stw	r2,8(r16)
80146ad8:	2080020c 	andi	r2,r4,8
80146adc:	10003626 	beq	r2,zero,80146bb8 <__swbuf_r+0x124>
80146ae0:	80c00417 	ldw	r3,16(r16)
80146ae4:	18003426 	beq	r3,zero,80146bb8 <__swbuf_r+0x124>
80146ae8:	2088000c 	andi	r2,r4,8192
80146aec:	9c403fcc 	andi	r17,r19,255
80146af0:	10001a26 	beq	r2,zero,80146b5c <__swbuf_r+0xc8>
80146af4:	80800017 	ldw	r2,0(r16)
80146af8:	81000517 	ldw	r4,20(r16)
80146afc:	10c7c83a 	sub	r3,r2,r3
80146b00:	1900200e 	bge	r3,r4,80146b84 <__swbuf_r+0xf0>
80146b04:	18c00044 	addi	r3,r3,1
80146b08:	81000217 	ldw	r4,8(r16)
80146b0c:	11400044 	addi	r5,r2,1
80146b10:	81400015 	stw	r5,0(r16)
80146b14:	213fffc4 	addi	r4,r4,-1
80146b18:	81000215 	stw	r4,8(r16)
80146b1c:	14c00005 	stb	r19,0(r2)
80146b20:	80800517 	ldw	r2,20(r16)
80146b24:	10c01e26 	beq	r2,r3,80146ba0 <__swbuf_r+0x10c>
80146b28:	8080030b 	ldhu	r2,12(r16)
80146b2c:	1080004c 	andi	r2,r2,1
80146b30:	10000226 	beq	r2,zero,80146b3c <__swbuf_r+0xa8>
80146b34:	00800284 	movi	r2,10
80146b38:	88801926 	beq	r17,r2,80146ba0 <__swbuf_r+0x10c>
80146b3c:	8805883a 	mov	r2,r17
80146b40:	dfc00417 	ldw	ra,16(sp)
80146b44:	dcc00317 	ldw	r19,12(sp)
80146b48:	dc800217 	ldw	r18,8(sp)
80146b4c:	dc400117 	ldw	r17,4(sp)
80146b50:	dc000017 	ldw	r16,0(sp)
80146b54:	dec00504 	addi	sp,sp,20
80146b58:	f800283a 	ret
80146b5c:	81401917 	ldw	r5,100(r16)
80146b60:	00b7ffc4 	movi	r2,-8193
80146b64:	21080014 	ori	r4,r4,8192
80146b68:	2884703a 	and	r2,r5,r2
80146b6c:	80801915 	stw	r2,100(r16)
80146b70:	80800017 	ldw	r2,0(r16)
80146b74:	8100030d 	sth	r4,12(r16)
80146b78:	81000517 	ldw	r4,20(r16)
80146b7c:	10c7c83a 	sub	r3,r2,r3
80146b80:	193fe016 	blt	r3,r4,80146b04 <__reset+0xfa126b04>
80146b84:	800b883a 	mov	r5,r16
80146b88:	9009883a 	mov	r4,r18
80146b8c:	012e65c0 	call	8012e65c <_fflush_r>
80146b90:	1000071e 	bne	r2,zero,80146bb0 <__swbuf_r+0x11c>
80146b94:	80800017 	ldw	r2,0(r16)
80146b98:	00c00044 	movi	r3,1
80146b9c:	003fda06 	br	80146b08 <__reset+0xfa126b08>
80146ba0:	800b883a 	mov	r5,r16
80146ba4:	9009883a 	mov	r4,r18
80146ba8:	012e65c0 	call	8012e65c <_fflush_r>
80146bac:	103fe326 	beq	r2,zero,80146b3c <__reset+0xfa126b3c>
80146bb0:	00bfffc4 	movi	r2,-1
80146bb4:	003fe206 	br	80146b40 <__reset+0xfa126b40>
80146bb8:	800b883a 	mov	r5,r16
80146bbc:	9009883a 	mov	r4,r18
80146bc0:	012e0a80 	call	8012e0a8 <__swsetup_r>
80146bc4:	103ffa1e 	bne	r2,zero,80146bb0 <__reset+0xfa126bb0>
80146bc8:	8100030b 	ldhu	r4,12(r16)
80146bcc:	80c00417 	ldw	r3,16(r16)
80146bd0:	003fc506 	br	80146ae8 <__reset+0xfa126ae8>
80146bd4:	01276140 	call	80127614 <__sinit>
80146bd8:	003fbc06 	br	80146acc <__reset+0xfa126acc>

80146bdc <__swbuf>:
80146bdc:	00a00574 	movhi	r2,32789
80146be0:	10a88704 	addi	r2,r2,-24036
80146be4:	280d883a 	mov	r6,r5
80146be8:	200b883a 	mov	r5,r4
80146bec:	11000017 	ldw	r4,0(r2)
80146bf0:	0146a941 	jmpi	80146a94 <__swbuf_r>

80146bf4 <__call_exitprocs>:
80146bf4:	defff504 	addi	sp,sp,-44
80146bf8:	de00012e 	bgeu	sp,et,80146c00 <__call_exitprocs+0xc>
80146bfc:	003b68fa 	trap	3
80146c00:	df000915 	stw	fp,36(sp)
80146c04:	dd400615 	stw	r21,24(sp)
80146c08:	dc800315 	stw	r18,12(sp)
80146c0c:	dfc00a15 	stw	ra,40(sp)
80146c10:	ddc00815 	stw	r23,32(sp)
80146c14:	dd800715 	stw	r22,28(sp)
80146c18:	dd000515 	stw	r20,20(sp)
80146c1c:	dcc00415 	stw	r19,16(sp)
80146c20:	dc400215 	stw	r17,8(sp)
80146c24:	dc000115 	stw	r16,4(sp)
80146c28:	d9000015 	stw	r4,0(sp)
80146c2c:	2839883a 	mov	fp,r5
80146c30:	04800044 	movi	r18,1
80146c34:	057fffc4 	movi	r21,-1
80146c38:	00a00574 	movhi	r2,32789
80146c3c:	10a88604 	addi	r2,r2,-24040
80146c40:	12000017 	ldw	r8,0(r2)
80146c44:	45005217 	ldw	r20,328(r8)
80146c48:	44c05204 	addi	r19,r8,328
80146c4c:	a0001c26 	beq	r20,zero,80146cc0 <__call_exitprocs+0xcc>
80146c50:	a0800117 	ldw	r2,4(r20)
80146c54:	15ffffc4 	addi	r23,r2,-1
80146c58:	b8000d16 	blt	r23,zero,80146c90 <__call_exitprocs+0x9c>
80146c5c:	14000044 	addi	r16,r2,1
80146c60:	8421883a 	add	r16,r16,r16
80146c64:	8421883a 	add	r16,r16,r16
80146c68:	84402004 	addi	r17,r16,128
80146c6c:	a463883a 	add	r17,r20,r17
80146c70:	a421883a 	add	r16,r20,r16
80146c74:	e0001e26 	beq	fp,zero,80146cf0 <__call_exitprocs+0xfc>
80146c78:	80804017 	ldw	r2,256(r16)
80146c7c:	e0801c26 	beq	fp,r2,80146cf0 <__call_exitprocs+0xfc>
80146c80:	bdffffc4 	addi	r23,r23,-1
80146c84:	843fff04 	addi	r16,r16,-4
80146c88:	8c7fff04 	addi	r17,r17,-4
80146c8c:	bd7ff91e 	bne	r23,r21,80146c74 <__reset+0xfa126c74>
80146c90:	00800034 	movhi	r2,0
80146c94:	10800004 	addi	r2,r2,0
80146c98:	10000926 	beq	r2,zero,80146cc0 <__call_exitprocs+0xcc>
80146c9c:	a0800117 	ldw	r2,4(r20)
80146ca0:	1000301e 	bne	r2,zero,80146d64 <__call_exitprocs+0x170>
80146ca4:	a0800017 	ldw	r2,0(r20)
80146ca8:	10003226 	beq	r2,zero,80146d74 <__call_exitprocs+0x180>
80146cac:	a009883a 	mov	r4,r20
80146cb0:	98800015 	stw	r2,0(r19)
80146cb4:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
80146cb8:	9d000017 	ldw	r20,0(r19)
80146cbc:	a03fe41e 	bne	r20,zero,80146c50 <__reset+0xfa126c50>
80146cc0:	dfc00a17 	ldw	ra,40(sp)
80146cc4:	df000917 	ldw	fp,36(sp)
80146cc8:	ddc00817 	ldw	r23,32(sp)
80146ccc:	dd800717 	ldw	r22,28(sp)
80146cd0:	dd400617 	ldw	r21,24(sp)
80146cd4:	dd000517 	ldw	r20,20(sp)
80146cd8:	dcc00417 	ldw	r19,16(sp)
80146cdc:	dc800317 	ldw	r18,12(sp)
80146ce0:	dc400217 	ldw	r17,8(sp)
80146ce4:	dc000117 	ldw	r16,4(sp)
80146ce8:	dec00b04 	addi	sp,sp,44
80146cec:	f800283a 	ret
80146cf0:	a0800117 	ldw	r2,4(r20)
80146cf4:	80c00017 	ldw	r3,0(r16)
80146cf8:	10bfffc4 	addi	r2,r2,-1
80146cfc:	15c01426 	beq	r2,r23,80146d50 <__call_exitprocs+0x15c>
80146d00:	80000015 	stw	zero,0(r16)
80146d04:	183fde26 	beq	r3,zero,80146c80 <__reset+0xfa126c80>
80146d08:	95c8983a 	sll	r4,r18,r23
80146d0c:	a0806217 	ldw	r2,392(r20)
80146d10:	a5800117 	ldw	r22,4(r20)
80146d14:	2084703a 	and	r2,r4,r2
80146d18:	10000b26 	beq	r2,zero,80146d48 <__call_exitprocs+0x154>
80146d1c:	a0806317 	ldw	r2,396(r20)
80146d20:	2088703a 	and	r4,r4,r2
80146d24:	20000c1e 	bne	r4,zero,80146d58 <__call_exitprocs+0x164>
80146d28:	89400017 	ldw	r5,0(r17)
80146d2c:	d9000017 	ldw	r4,0(sp)
80146d30:	183ee83a 	callr	r3
80146d34:	a0800117 	ldw	r2,4(r20)
80146d38:	15bfbf1e 	bne	r2,r22,80146c38 <__reset+0xfa126c38>
80146d3c:	98800017 	ldw	r2,0(r19)
80146d40:	153fcf26 	beq	r2,r20,80146c80 <__reset+0xfa126c80>
80146d44:	003fbc06 	br	80146c38 <__reset+0xfa126c38>
80146d48:	183ee83a 	callr	r3
80146d4c:	003ff906 	br	80146d34 <__reset+0xfa126d34>
80146d50:	a5c00115 	stw	r23,4(r20)
80146d54:	003feb06 	br	80146d04 <__reset+0xfa126d04>
80146d58:	89000017 	ldw	r4,0(r17)
80146d5c:	183ee83a 	callr	r3
80146d60:	003ff406 	br	80146d34 <__reset+0xfa126d34>
80146d64:	a0800017 	ldw	r2,0(r20)
80146d68:	a027883a 	mov	r19,r20
80146d6c:	1029883a 	mov	r20,r2
80146d70:	003fb606 	br	80146c4c <__reset+0xfa126c4c>
80146d74:	0005883a 	mov	r2,zero
80146d78:	003ffb06 	br	80146d68 <__reset+0xfa126d68>

80146d7c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
80146d7c:	defffc04 	addi	sp,sp,-16
80146d80:	de00012e 	bgeu	sp,et,80146d88 <_exit+0xc>
80146d84:	003b68fa 	trap	3
80146d88:	dfc00315 	stw	ra,12(sp)
80146d8c:	df000215 	stw	fp,8(sp)
80146d90:	df000204 	addi	fp,sp,8
80146d94:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
80146d98:	d0a01117 	ldw	r2,-32700(gp)
80146d9c:	10800058 	cmpnei	r2,r2,1
80146da0:	1000031e 	bne	r2,zero,80146db0 <_exit+0x34>
80146da4:	01200574 	movhi	r4,32789
80146da8:	21210904 	addi	r4,r4,-31708
80146dac:	01325b40 	call	801325b4 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
80146db0:	d0a01117 	ldw	r2,-32700(gp)
80146db4:	10800058 	cmpnei	r2,r2,1
80146db8:	1000041e 	bne	r2,zero,80146dcc <_exit+0x50>
80146dbc:	e17fff17 	ldw	r5,-4(fp)
80146dc0:	01200574 	movhi	r4,32789
80146dc4:	21211404 	addi	r4,r4,-31664
80146dc8:	01325b40 	call	801325b4 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
80146dcc:	d0a01117 	ldw	r2,-32700(gp)
80146dd0:	10800058 	cmpnei	r2,r2,1
80146dd4:	1000031e 	bne	r2,zero,80146de4 <_exit+0x68>
80146dd8:	01200574 	movhi	r4,32789
80146ddc:	21211f04 	addi	r4,r4,-31620
80146de0:	01325b40 	call	801325b4 <alt_log_printf_proc>
  ALT_OS_STOP();
80146de4:	d0209a05 	stb	zero,-32152(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
80146de8:	d0a01117 	ldw	r2,-32700(gp)
80146dec:	10800058 	cmpnei	r2,r2,1
80146df0:	1000031e 	bne	r2,zero,80146e00 <_exit+0x84>
80146df4:	01200574 	movhi	r4,32789
80146df8:	21212904 	addi	r4,r4,-31580
80146dfc:	01325b40 	call	801325b4 <alt_log_printf_proc>
80146e00:	e0bfff17 	ldw	r2,-4(fp)
80146e04:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
80146e08:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
80146e0c:	10000226 	beq	r2,zero,80146e18 <_exit+0x9c>
    ALT_SIM_FAIL();
80146e10:	002af070 	cmpltui	zero,zero,43969
80146e14:	00000106 	br	80146e1c <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
80146e18:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
80146e1c:	d0a01117 	ldw	r2,-32700(gp)
80146e20:	10800058 	cmpnei	r2,r2,1
80146e24:	1000031e 	bne	r2,zero,80146e34 <_exit+0xb8>
80146e28:	01200574 	movhi	r4,32789
80146e2c:	21213304 	addi	r4,r4,-31540
80146e30:	01325b40 	call	801325b4 <alt_log_printf_proc>
  while (1);
80146e34:	003fff06 	br	80146e34 <__reset+0xfa126e34>
